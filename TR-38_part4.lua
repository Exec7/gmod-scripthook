--Stealed clientside server code by exechack.cc
--Hostname: [TR] Venom Roleplay | DarkRP #venom25 - discord.gg/eniyisi  - Part 4/12 - 06/04/2025


--PATH lua/zclib/util/sh_language.lua:
return gluapack()()
--lua/zclib/util/cl_rope.lua:
if SERVER then return end
zclib = zclib or {}
zclib.Rope = zclib.Rope or {}

function zclib.Rope.Setup(Length, v_start, v_end)
	local RopePoints = {}

	if v_end then
		for point = 1, Length do
			RopePoints[point] = {
				position = LerpVector((1 / Length) * point, v_start, v_end),
				velocity = vector_origin
			}
		end
	else
		for point = 1, Length do
			RopePoints[point] = {
				position = v_start,
				velocity = vector_origin
			}
		end
	end

	return RopePoints
end

local RopeOffset = Vector(0,0,10)
function zclib.Rope.Update(RopePoints, v_start, v_end, length, gravity, damping)
	// Updates the Rope points to move physicly

	if not v_end then return end
	if not v_start then return end

	// This fixes the rope breaking when both start and end are the same
	if v_end == v_start then
		v_end = v_start + RopeOffset
	end

	if isentity(v_end) then v_end = v_end:GetPos() end
	if isentity(v_start) then v_start = v_start:GetPos() end

	local dist = v_end:DistToSqr(v_start)
	dist = (dist / length) * 0.1


	for point = 1, length do
		local position1 = (RopePoints[math.Clamp(point - 1, 1, length)].position or vector_origin) - (RopePoints[point].position or vector_origin)
		local length1 = math.max(position1:Length(), dist)

		local position2 = (RopePoints[math.Clamp(point + 1, 1, length)].position or vector_origin) - (RopePoints[point].position or vector_origin)
		local length2 = math.max(position2:Length(), dist)

		local velocity = (position1 / length1) + (position2 / length2) + (gravity * 0.001)

		RopePoints[point].velocity = (RopePoints[point].velocity * damping) + velocity * (dist * 0.01)

		RopePoints[point].position = (RopePoints[point].position or vector_origin) + RopePoints[point].velocity
	end

	RopePoints[1].position = v_start
	RopePoints[length].position = v_end
end

function zclib.Rope.Draw(RopePoints, v_start, v_end, length, LineMaterial, MatSprite, color , width)
	if not v_end then return end
	if not v_start then return end

	if isentity(v_end) then v_end = v_end:GetPos() end
	if isentity(v_start) then v_start = v_start:GetPos() end

	local dist = v_end:DistToSqr(v_start)
	dist = (dist / length) * 0.1

	cam.Start3D()
		render.SetMaterial(LineMaterial)
		render.StartBeam(length)
			local tex_repeat = math.floor(dist / 50)
			tex_repeat = math.Clamp(tex_repeat, 10, 50)

			for point = 1, length do
				if RopePoints[point] then
					local tex = (tex_repeat / length) * point
					render.AddBeam(RopePoints[point].position, width or 10, tex, color)
				end
			end
		render.EndBeam()

		if MatSprite then
			render.SetMaterial(MatSprite)
			render.DrawSprite(RopePoints[length].position, 15, 15, color)
		end

	cam.End3D()
end

--lua/zclib/util/cl_settings.lua:
if not CLIENT then return end

zclib = zclib or {}
zclib.Settings = zclib.Settings or {}

local Created = false

function zclib.Settings.OptionPanel(name,desc,main_color,bg_color, CPanel, cmds)
	local panel = vgui.Create("DPanel")
	panel:Dock(FILL)
	panel.Paint = function(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, bg_color)
		zclib.util.DrawOutlinedBox( 0, 0, w, h, 4, zclib.colors["black_a100"])
	end
	panel:DockPadding(10,10,10,10)

	local title = vgui.Create("DLabel", panel)
	title:Dock(TOP)
	title:SetText(name)
	title:SetFont(zclib.GetFont("zclib_font_medium"))
	title:DockPadding(5,5,5,5)
	title:SetTextColor(color_white)
	title:SetTall(30)

	if desc then
		local desc_pnl = vgui.Create("DLabel", panel)
		desc_pnl:Dock(TOP)
		desc_pnl:SetText(desc)
		desc_pnl:SetFont(zclib.GetFont("zclib_font_small_thin"))
		desc_pnl:DockPadding(5,2,5,2)
		desc_pnl:SetTextColor(color_white)
		desc_pnl:SetContentAlignment(4)
		//desc_pnl:SetWrap(true)
		desc_pnl:SizeToContentsY( 5 )
	end

	for k, v in ipairs(cmds) do
		if v.class == "DNumSlider" then

			local item = vgui.Create("DNumSlider", panel)
			item:Dock(TOP)
			item:DockPadding(5,5,5,5)
			item:DockMargin(5,5,5,5)

			item:SetText(v.name)
			item:SetMin(v.min)
			item:SetMax(v.max)

			item:SetDecimals(v.decimal)
			item:SetDefaultValue(math.Clamp(math.Round(GetConVar(v.cmd):GetFloat(),v.decimal),v.min,v.max))
			item:ResetToDefaultValue()
			item:SetConVar( v.cmd )
			item.OnValueChanged = function(self, val)

				if v.RunOnChange then pcall(v.RunOnChange,val) end

				if Created then
					RunConsoleCommand(v.cmd, tostring(val))
				end
			end
		elseif v.class == "DCheckBoxLabel" then

			local item = vgui.Create("DCheckBoxLabel", panel)
			item:Dock(TOP)
			item:DockPadding(5,5,5,5)
			item:DockMargin(5,5,5,5)
			item:SetText( v.name )
			item:SetConVar( v.cmd )
			item.OnChange = function(self, val)

				if v.RunOnChange then pcall(v.RunOnChange,val) end

				if Created then
					if val then
						RunConsoleCommand(v.cmd, "1")
					else
						RunConsoleCommand(v.cmd, "0")
					end
				end
			end


			timer.Simple(0.1, function()
				if (item) then
					item:SetValue(GetConVar(v.cmd):GetInt())
				end
			end)
		elseif v.class == "DButton" then
			local item = vgui.Create("DButton", panel)
			item:Dock(TOP)
			item:DockMargin(0,10,0,0)
			item:SetText( v.name )
			item:SetFont(zclib.GetFont("zclib_font_small"))
			item:SetTextColor(color_white)
			item.Paint = function(s, w, h)
				draw.RoundedBox(4, 0, 0, w, h, main_color)
				if s.Hovered then
					draw.RoundedBox(4, 0, 0, w, h, zclib.colors["white_a15"])
				end
			end
			item.DoClick = function()

				// if zclib.Player.IsAdmin(LocalPlayer()) == false then return end

				LocalPlayer():EmitSound("zclib_ui_click")

				if v.notify then notification.AddLegacy(  v.notify, NOTIFY_GENERIC, 2 ) end
				LocalPlayer():ConCommand( v.cmd )
			end
		elseif v.class == "DColorMixer" then

			local main = vgui.Create("DPanel", panel)
			main:SetSize(200 * zclib.wM, 300 * zclib.hM)
			main:Dock(TOP)
			main:DockPadding(5, 5, 5, 5)
			main:DockMargin(5, 5, 5, 5)
			main.Paint = function(s, w, h)
				draw.RoundedBox(4, 0, 0, w, 5 * zclib.hM, zclib.colors["black_a100"])

				draw.RoundedBox(4, 0, h - 5 * zclib.hM, w, 5 * zclib.hM, zclib.colors["black_a100"])
			end

			local a_title = vgui.Create("DLabel", main)
			a_title:Dock(TOP)
			a_title:SetFont(zclib.GetFont("zclib_font_small"))
			a_title:SetText(v.name)
			a_title:SetTextColor(color_white)
			a_title:SetContentAlignment(4)
			a_title:SizeToContentsY( 10 )

			local Mixer = vgui.Create("DColorMixer", main)
			Mixer:SetSize(200 * zclib.wM, 200 * zclib.hM)
			Mixer:Dock(FILL)
			Mixer:DockMargin(0, 5, 0, 5)
			Mixer:SetPalette(false)
			Mixer:SetAlphaBar(true)
			Mixer:SetWangs(true)

			if v.cmd[1] then Mixer:SetConVarR(v.cmd[1]) end
			if v.cmd[2] then Mixer:SetConVarG(v.cmd[2]) end
			if v.cmd[3] then Mixer:SetConVarB(v.cmd[3]) end
			if v.cmd[4] then Mixer:SetConVarA(v.cmd[4]) end

			main:InvalidateParent(true)
			main:SizeToChildren(false,true)
		elseif v.class == "Custom" then
			pcall(v.content,panel)
		end

		if v.desc then
			local desc_pnl = vgui.Create("DLabel", panel)
			desc_pnl:Dock(TOP)
			desc_pnl:DockMargin(5,5,5,5)
			desc_pnl:SetFont(zclib.GetFont("zclib_font_small_thin"))
			desc_pnl:SetText(v.desc)
			desc_pnl:SetTextColor(color_white)
			desc_pnl:SetContentAlignment(7)
			desc_pnl:SizeToContentsY( 30 )
			desc_pnl:SetWrap(true)


			// Only create a seperation line if we got another item after this
			if cmds[k + 1] then
				local line = vgui.Create("DPanel",panel)
				line:Dock(TOP)
				line:DockMargin(5,5,5,5)
				line:SetTall(4)
				line.Paint = function(s, w, h)
					draw.RoundedBox(0, 0, 0, w, h, zclib.colors["black_a100"])
				end
			end
		end
	end


	panel:InvalidateLayout(true)
	panel:SizeToChildren(true, true)

	CPanel:AddPanel(panel)
end

hook.Add("AddToolMenuCategories", "zclib_CreateCategories", function()
	spawnmenu.AddToolCategory("Options", "zclib_options", "Zeros Libary")
end)

hook.Add("PopulateToolMenu", "zclib_PopulateMenus", function()

	timer.Simple(0.2, function()
		Created = true
	end)

	spawnmenu.AddToolMenuOption("Options", "zclib_options", "zclib_Client_Settings", "Client Settings", "", "", function(CPanel)
		zclib.Settings.OptionPanel("Thumbnail Cache", nil, Color(82, 131, 198, 255), zclib.colors["ui02"], CPanel, {
			[1] = {
				name = "Delete Thumbnail Cache",
				desc = "Deletes any model thumbnails found at garrysmod/data/zclib/img",
				class = "DButton",
				cmd = "zclib_delete_thumbnails"
			}
		})

		zclib.Settings.OptionPanel("Imgur Cache", nil, Color(82, 131, 198, 255), zclib.colors["ui02"], CPanel, {
			[1] = {
				name = "Delete Imgur Cache",
				desc = "Deletes any images found at garrysmod/data/zclib/imgur",
				class = "DButton",
				cmd = "zclib_delete_imgur"
			}
		})

		zclib.Settings.OptionPanel("Other", nil, Color(82, 131, 198, 255), zclib.colors[ "ui02" ], CPanel, {
			[ 1 ] = {
				name = "Particle Effects",
				class = "DCheckBoxLabel",
				cmd = "zclib_cl_particleeffects"
			},
			[ 2 ] = {
				name = "Draw UI",
				class = "DCheckBoxLabel",
				cmd = "zclib_cl_drawui"
			},
			[ 3 ] = {
				name = "Dynamic Light",
				class = "DCheckBoxLabel",
				cmd = "zclib_cl_vfx_dynamiclight"
			},
			[ 4 ] = {
				name = "Volume",
				class = "DNumSlider",
				min = 0,
				max = 1,
				decimal = 2,
				cmd = "zclib_cl_sfx_volume"
			},
		})
	end)
end)

--lua/zclib/generic/sh_notify.lua:
zclib = zclib or {}
zclib.PanelNotify = zclib.PanelNotify or {}

/*

	Creates a notify box over the currently opend zclib window, otherwise creates a normal notify

*/

if SERVER then
	util.AddNetworkString("zclib.Notify.Create")
	function zclib.PanelNotify.Create(ply,msg,msgType)
		net.Start("zclib.Notify.Create")
		net.WriteString(msg)
		net.WriteUInt(msgType,10)
		net.Send(ply)
	end
else
	net.Receive("zclib.Notify.Create", function(len,ply)
		zclib.Debug_Net("zclib.Notify.Create", len)

		local msg = net.ReadString()
		local msgType = net.ReadUInt(10)

		if IsValid(zclib_main_panel) then
			zclib.PanelNotify.Create(LocalPlayer(),msg,msgType)
		else
			zclib.vgui.Notify(msg,msgType)
		end
	end)

	function zclib.PanelNotify.Create(ply,msg,msgtype)

		local dur = 4
		local pnl = zclib_main_panel

		if not IsValid(pnl) then return end

	    if IsValid(pnl.NotifyPanel) then
	        pnl.NotifyPanel:Remove()
	    end

	    local s_sound = "common/bugreporter_succeeded.wav"
	    local mat_icon = zclib.Materials.Get("info")
		local mat_color = color_white
	    if msgtype == NOTIFY_GENERIC then
	        s_sound = "common/bugreporter_succeeded.wav"
	        mat_icon = zclib.Materials.Get("info")
	    elseif msgtype == NOTIFY_ERROR then
	        s_sound = "common/warning.wav"
	        mat_icon = zclib.Materials.Get("close")
			mat_color = zclib.colors["red01"]
	    elseif msgtype == NOTIFY_HINT then
	        s_sound = "buttons/button15.wav"
	        mat_icon = zclib.Materials.Get("info")
	    end
	    zclib.vgui.PlaySound(s_sound)

	    local x,y = pnl:GetPos()

	    local p = vgui.Create("DPanel")

		// come from behind, go up
		p:SetPos(x,y)
		p:MoveTo(x,y - 55 * zclib.hM,0.25,0,1,function()
			if IsValid(p) then p:AlphaTo(0,1,dur,function() if IsValid(p) then p:Remove() end end) end
		end)

	    p:SetSize(600 * zclib.wM,50 * zclib.hM)
	    p:SetAutoDelete(true)
	    p:ParentToHUD()
	    p:SetDrawOnTop(false)
	    p.Paint = function(s, w, h)
	        draw.RoundedBox(0, 0, 0, w, h, zclib.colors["ui02"])
	        zclib.util.DrawOutlinedBox(0, 0, w, h, 3, zclib.colors["black_a100"])
	    end


	    local p_icon = vgui.Create("DPanel", p)
	    p_icon:SetPos(0 * zclib.wM,0 * zclib.hM)
	    p_icon:SetSize(50 * zclib.wM,50 * zclib.hM)
	    p_icon.Paint = function(s, w, h)
	        surface.SetDrawColor(mat_color)
	        surface.SetMaterial(mat_icon)
	        surface.DrawTexturedRectRotated(w/2, h/2, w * 0.9, w * 0.9,0)
	    end
	    p_icon:Dock(LEFT)

	    local p_lbl = vgui.Create("DLabel", p)
	    p_lbl:SetPos(0 * zclib.wM,0 * zclib.hM)
	    p_lbl:SetSize(600 * zclib.wM,50 * zclib.hM)
	    p_lbl.Paint = function(s, w, h) end
	    p_lbl:SetText(msg)
	    p_lbl:SetTextColor(zclib.colors["text01"])
	    p_lbl:SetFont(zclib.GetFont("zclib_font_medium"))
	    p_lbl:SetContentAlignment(4)
	    p_lbl:SizeToContentsX( 15 * zclib.wM )
	    p_lbl:Dock(LEFT)

	    p:InvalidateChildren(true)
	    p:SizeToChildren(true,false)

	    pnl.NotifyPanel = p

	    // Here we attach the notify to the on remove function, so it gets cleaned up
	    if pnl.NotifyCleanup == nil then
	        pnl.NotifyCleanup = function()
	            local oldRemove = pnl.OnRemove
	            function pnl:OnRemove()
	                pcall(oldRemove)
	                if IsValid(self.NotifyPanel) then self.NotifyPanel:Remove() end
	            end
	        end
	        pnl.NotifyCleanup()
	    end
	end
end

--lua/zclib/generic/cl_imgur.lua:
if SERVER then return end

zclib = zclib or {}
zclib.Imgur = {}
zclib.Imgur.CachedMaterials = {}

/*

	A system that automaticly downloads Images from Image Sharing Service sites

*/

file.CreateDir("zclib")

function zclib.Imgur.Init()
	zclib.Debug("zclib.Imgur.Init")
	if file.Exists("zclib/" .. zclib.config.ActiveImageService, "DATA") == false then
		file.CreateDir("zclib/" .. zclib.config.ActiveImageService)
	end

	// Load the cached id list, if it exists
	zclib.Imgur.CachedImages = {}
	if file.Exists("zclib/" .. zclib.config.ActiveImageService .. "_cachedids.txt", "DATA") then

		// Load imgur id list
		zclib.Imgur.CachedImages = util.JSONToTable(file.Read("zclib/" .. zclib.config.ActiveImageService .. "_cachedids.txt", "DATA")) or {}

		// Check if the image id as lowercase id exists as png and if so then load it as material
		for imgurid, _ in pairs(zclib.Imgur.CachedImages) do
			if file.Exists("zclib/" .. zclib.config.ActiveImageService .. "/" .. string.lower(imgurid) .. ".png", "DATA") then
				zclib.Imgur.CachedMaterials[imgurid] = Material("data/zclib/" .. zclib.config.ActiveImageService .. "/" .. string.lower(imgurid) .. ".png", "smooth noclamp")
			end
		end
	end
end

function zclib.Imgur.GetMaterial(id, callback,retry_format)

	if id == nil then
		callback(false)
		return
	end

	if id == "" then
		callback(false)
		return
	end

	if id == " " then
		callback(false)
		return
	end


	//Here we check if the id allready exists in our cache
	if zclib.Imgur.CachedMaterials[id] then
        //zclib.Debug("Image already loaded, returning material, " .. tostring(zclib.Imgur.CachedMaterials[id]))
		callback(zclib.Imgur.CachedMaterials[id])
	else
		//If the image done exists in the cache then we check if the file is allready on the clients machine
		if file.Exists("zclib/" .. zclib.config.ActiveImageService .. "/" .. string.lower(id) .. ".png", "DATA") then
			zclib.Debug("File found, loading material then returning")

			//If its on the machine then we load it in to our cache
			zclib.Imgur.CachedMaterials[id] = Material("data/zclib/" .. zclib.config.ActiveImageService .. "/" .. string.lower(id) .. ".png", "smooth noclamp")
			callback(zclib.Imgur.CachedMaterials[id])
		else
			zclib.Debug("Failed to find image, attempting to load from " .. zclib.config.ActiveImageService .. " > " .. "zclib/" .. zclib.config.ActiveImageService .. "/" .. id .. ".png")

			//If the file does not exist then we load it from imgur and store the result in our cache
			//print("[" .. math.Round(CurTime(), 2) .. "][IMGUR] Fetching Image: " .. id)
			http.Fetch(zclib.config.ImageServices[zclib.config.ActiveImageService] .. id .. (retry_format or ".png"), function(img, len, headers, code)
				local filesize = len / 1000
				if filesize > zclib.config.ImageSizeLimit then
					callback(false)
				else

					// This makes sure the received data is a image
					if headers["Content-Type"] == "image/png" or headers["Content-Type"] == "image/jpeg" or headers["Content-Type"] == "image/jpg"  then
						zclib.Debug("Loaded Imgur Image : " .. id .. ".png")

						//print("[" .. math.Round(CurTime(), 2) .. "][IMGUR] Saving Image: " .. id)

						// Add original upper/lower case id to list
						zclib.Imgur.AddToImageCache(id)

						// Create image file , but its gonna be lowercase automaticly, thanks garry :(
						file.Write("zclib/" .. zclib.config.ActiveImageService .. "/" .. id .. ".png", img)

						// Cache lowercase material with original id
						zclib.Imgur.CachedMaterials[id] = Material("data/zclib/" .. zclib.config.ActiveImageService .. "/" .. id .. ".png", "smooth noclamp")

						callback(zclib.Imgur.CachedMaterials[id])
					else
						if retry_format == nil then
							zclib.Imgur.GetMaterial(id, callback,".jpg")
							return
						end
						callback(false)
					end
				end
			end, function()
				callback(false)
			end)
		end
	end
end

function zclib.Imgur.AddToImageCache(id)

	// Add id to list
	zclib.Imgur.CachedImages[id] = true

	// save to file
	file.Write("zclib/" .. zclib.config.ActiveImageService .. "_cachedids.txt", util.TableToJSON(zclib.Imgur.CachedImages,true))
end

zclib.Imgur.Init()

function zclib.Imgur.DeleteAllFiles(path)
	local files, directs = file.Find(path .. "/*", "DATA")

	-- Remove files
	for k, v in pairs(files) do
		if file.Exists(path .. "/" .. v, "DATA") then
			file.Delete(path .. "/" .. v)
		end
	end

	-- Remove directory
	file.Delete(path)

	for k, v in pairs(directs) do
		zclib.Snapshoter.DeleteAllFiles(path .. "/" .. v)
	end
end

concommand.Add("zclib_delete_imgur", function(ply, cmd, args)
	zclib.Imgur.DeleteAllFiles("zclib/imgur")
	file.Delete("zclib/imgur_cachedids.txt")

	zclib.Imgur.DeleteAllFiles("zclib/imgpile")
	file.Delete("zclib/imgpile_cachedids.txt")

	zclib.Imgur.CachedMaterials = {}
	zclib.Imgur.CachedImages = {}

	timer.Simple(1, function()
		notification.AddLegacy("Imgur cache removed!", NOTIFY_GENERIC, 4)
		surface.PlaySound("common/bugreporter_succeeded.wav")
	end)
end)

--lua/zclib/generic/cl_vgui.lua:
if SERVER then return end
zclib = zclib or {}
zclib.vgui = zclib.vgui or {}

zclib.hM = ScrH() / 1080
zclib.wM = zclib.hM

// Lets update the WindowSize Multiplicator if teh ScreenSize got changed
zclib.Hook.Add("OnScreenSizeChanged", "VGUIScaleReset", function(oldWidth, oldHeight)
	zclib.hM = ScrH() / 1080
	zclib.wM = zclib.hM

	zclib.Print("ScreenSize changed, Recalculating ScreenSize values.")
end)

// Plays a interface sound
function zclib.vgui.PlaySound(sound)
	surface.PlaySound(sound)
end

// Creates a notify + sound according to what view the player currntly has
function zclib.vgui.Notify(msg,msgType)
	local s_sound = nil

	if msgType == NOTIFY_GENERIC then
		s_sound = "common/bugreporter_succeeded.wav"
	elseif msgType == NOTIFY_ERROR then
		s_sound = "common/warning.wav"
	elseif msgType == NOTIFY_HINT then
		s_sound = "buttons/button15.wav"
	end

	zclib.vgui.PlaySound(s_sound)

	if msg and string.len(msg) > 0 then
		local dur = 0.2 * string.len(msg)
		notification.AddLegacy(msg, msgType, dur)
	end
end

function zclib.vgui.TextButton(_x,_y,_w,_h,parent,data,action,IsLocked,IsSelected)
	/*
		data = {
			Text01 = "Off"
			color
			txt_color
			locked
		}
	*/
	local button_pnl = vgui.Create("DButton", parent)
	button_pnl:SetPos(_x * zclib.wM, _y * zclib.hM)
	button_pnl:SetSize(_w * zclib.wM, _h * zclib.hM)
	button_pnl:SetAutoDelete(true)
	button_pnl:SetText("")

	button_pnl.Text01 = data.Text01
	button_pnl.color = data.color or zclib.colors["ui01"]
	button_pnl.txt_color = data.txt_color or zclib.colors["text01"]
	button_pnl.txt_font = data.txt_font or zclib.GetFont("zclib_font_big")
	button_pnl.locked = false

	local txtW,txtH = zclib.util.GetTextSize(button_pnl.Text01,button_pnl.txt_font)
	button_pnl.txt_length = txtW
	button_pnl.txt_height = txtH

	local round = 5

	button_pnl.Paint = function(s, w, h)

		draw.RoundedBox(round, 0, 0, w, h, s.color)

		if IsSelected then
			local _, result = xpcall(IsSelected, function() end, nil)

			if result then
				draw.RoundedBox(8, 0, 0, 8 * zclib.wM, h, zclib.colors["green01"])
			end
		end

		if s.Text01 then
			draw.SimpleText(s.Text01, s.txt_font, w / 2, h / 2, s.txt_color, TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
		end

		if s.locked == true then
			draw.RoundedBox(round, 0, 0, w, h, zclib.colors["black_a100"])
		else
			if IsLocked then
				local _, varg = xpcall(IsLocked, function() end, s)
				if varg then
					draw.RoundedBox(round, 0, 0, w, h, zclib.colors["black_a100"])
				else
					if s:IsHovered() then
						draw.RoundedBox(round, 0, 0, w, h, zclib.colors["white_a15"])
					end
				end
			else
				if s:IsHovered() then
					draw.RoundedBox(round, 0, 0, w, h, zclib.colors["white_a15"])
				end
			end
		end
	end

	button_pnl.DoClick = function(s)
		if s.locked == true then return end
		local _, varg = xpcall(IsLocked, function() end, nil)
		if varg == true then return end
		zclib.vgui.PlaySound("UI/buttonclick.wav")
		pcall(action,button_pnl)
	end
	return button_pnl
end

function zclib.vgui.Slider(parent,text,start_val,onChange)

	local p = vgui.Create("DButton", parent)
	p:SetSize(200 * zclib.wM,50 * zclib.hM )
	p.locked = false
	p.slideValue = start_val
	p:SetAutoDelete(true)
	p:SetText("")
	p.Paint = function(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, zclib.colors["black_a50"])

		draw.SimpleText(text, zclib.GetFont("zclib_font_medium"),5 * zclib.wM, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

		draw.SimpleText(math.Round(s.slideValue * 100), zclib.GetFont("zclib_font_medium"),w - 5 * zclib.wM, h / 2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)

		local AreaW = w * 0.5
		local AreaX = w * 0.35
		draw.RoundedBox(4, AreaX, h * 0.5, AreaW, 2 * zclib.hM, color_black)


		local boxHeight = h * 0.5
		local boxPosX = AreaW * s.slideValue
		draw.RoundedBox(4, (AreaX - (boxHeight / 2)) + boxPosX, boxHeight / 2, boxHeight, boxHeight, zclib.colors["ui01"])

		if p.locked == true then
			draw.RoundedBox(4, 0, 0, w, h, zclib.colors["black_a100"])
		end

		if s:IsDown() then
			local x,_ = s:CursorPos()
			local min = AreaX
			local max = min + AreaW

			x = math.Clamp(x, min, max)

			local val = (1 / AreaW) * (x - min)

			s.slideValue = math.Round(val,2)

			if s.slideValue ~= s.LastValue then
				s.LastValue = s.slideValue

				if s.locked == true then return end
				pcall(onChange,s.slideValue)
			end
			// 60 = 0
			// 230 = 1
		end
	end
	return p
end

function zclib.vgui.CheckBox(parent,text,state,onclick)

	local p = vgui.Create("DButton", parent)
	p:SetSize(200 * zclib.wM,50 * zclib.hM )
	p.locked = false
	p.state = state
	p.slideValue = 0
	p:SetAutoDelete(true)
	p:SetText("")
	p.Paint = function(s, w, h)
		//draw.RoundedBox(0, 0, 0, w, h, zclib.colors["ui01"])

		draw.RoundedBox(4, 0, 0, w, h, zclib.colors["black_a100"])

		//draw.SimpleText(text, zclib.GetFont("zclib_font_medium"),5 * zclib.wM, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)


		local BoxWidth = w
		local BoxHeight = h
		local BoxPosY = 0
		local BoxPosX = 0

		//draw.SimpleText(text, zclib.GetFont("zclib_font_medium"),w / 2, BoxHeight * 0.8, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		draw.RoundedBox(4, BoxPosX, BoxPosY, BoxWidth, BoxHeight, zclib.colors["black_a100"])

		if s.state then
			s.slideValue = Lerp(5 * FrameTime(), s.slideValue, 1)
		else
			s.slideValue = Lerp(5 * FrameTime(), s.slideValue, 0)
		end

		local col = zclib.util.LerpColor(s.slideValue, zclib.colors["ui01"], zclib.colors["green01"])
		draw.RoundedBox(4, BoxPosX + (BoxWidth-BoxHeight) * s.slideValue, BoxPosY, BoxHeight, BoxHeight, col)

		if p.locked == true then
			draw.RoundedBox(4, BoxPosX, BoxPosY, BoxWidth, BoxHeight, zclib.colors["black_a100"])
		end
	end
	p.DoClick = function(s)
		if p.locked == true then return end
		zclib.vgui.PlaySound("UI/buttonclick.wav")
		s.state = not s.state
		pcall(onclick,s.state)
	end
	return p
end

function zclib.vgui.ImageButton(_x,_y,_w,_h,parent,image,OnClick,IsLocked,SoundOverwrite)
	local Button = vgui.Create("DButton", parent)
	Button:SetPos(_x , _y )
	Button:SetSize(_w, _h)
	Button:SetText("")
	Button.IconColor = zclib.colors["text01"]
	Button.NoneHover_IconColor = zclib.colors["ui01"]
	Button.Sound = SoundOverwrite or "UI/buttonclick.wav"
	Button.IconImage = image
	Button.Paint = function(s, w, h)
		if IsLocked then
			local _, varg = xpcall(IsLocked, function() end, nil)
			if varg or s:IsEnabled() == false then
				zclib.util.DrawOutlinedBox(0 * zclib.wM, 0 * zclib.hM, w, h, 2, zclib.colors["black_a50"])
				surface.SetDrawColor(zclib.colors["black_a50"])
				surface.SetMaterial(s.IconImage)
				surface.DrawTexturedRect(0, 0,w, h)
			else
				if s:IsHovered() then
					zclib.util.DrawOutlinedBox(0 * zclib.wM, 0 * zclib.hM, w, h, 2, zclib.colors["text01"])
					surface.SetDrawColor(s.IconColor)
					surface.SetMaterial(s.IconImage)
					surface.DrawTexturedRect(0, 0,w, h)
				else
					zclib.util.DrawOutlinedBox(0 * zclib.wM, 0 * zclib.hM, w, h, 2, s.NoneHover_IconColor)
					surface.SetDrawColor(s.NoneHover_IconColor)
					surface.SetMaterial(s.IconImage)
					surface.DrawTexturedRect(0, 0,w, h)
				end
			end
		else
			if s:IsHovered() then
				zclib.util.DrawOutlinedBox(0 * zclib.wM, 0 * zclib.hM, w, h, 2, zclib.colors["text01"])
				surface.SetDrawColor(s.IconColor)
				surface.SetMaterial(s.IconImage)
				surface.DrawTexturedRect(0, 0,w, h)
			else
				zclib.util.DrawOutlinedBox(0 * zclib.wM, 0 * zclib.hM, w, h, 2, s.NoneHover_IconColor)
				surface.SetDrawColor(s.NoneHover_IconColor)
				surface.SetMaterial(s.IconImage)
				surface.DrawTexturedRect(0, 0,w, h)
			end
		end
	end
	Button.DoClick = function(s)

		local _, varg = xpcall(IsLocked, function() end, nil)
		if varg == true then return end

		zclib.vgui.PlaySound(s.Sound)

		s:SetEnabled(false)

		timer.Simple(0.25, function() if IsValid(s) then s:SetEnabled(true) end end)

		pcall(OnClick,s)
	end
	return Button
end

function zclib.vgui.TextEntry(parent, emptytext,onchange,hasrefreshbutton,onRefresh)
	local p = vgui.Create("DTextEntry", parent)
	p:SetSize(200 * zclib.wM,50 * zclib.hM )
	p:SetPaintBackground(false)
	p:SetAutoDelete(true)
	p:SetUpdateOnType(true)
	p.font = zclib.GetFont("zclib_font_small")
	p.bg_color = zclib.colors["ui01"]
	p.Emptytext = emptytext
	p.Paint = function(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, s.bg_color)
		//draw.RoundedBox(4, 0, 0, w, h, zclib.colors["red01"])

		if s:GetText() == "" and not s:IsEditing() then
			draw.SimpleText(s.Emptytext, s.font, 5 * zclib.wM, h / 2, zclib.colors["white_a15"], 0, 1)
		end

		s:DrawTextEntryText(color_white, zclib.colors["textentry"], color_white)
	end
	p:SetDrawLanguageID(false)
	p.OnValueChange = function(s,val)
		pcall(onchange,val)
	end

	function p:PerformLayout(width, height)
		self:SetFontInternal(self.font)
	end

	if hasrefreshbutton then
		local b = vgui.Create("DButton",p)
		b:SetText("")
		b:SetSize(50 * zclib.wM, 50 * zclib.hM )
		b:Dock(RIGHT)
		b.DoClick = function()
			onRefresh(p:GetText())
		end
		b.Paint = function(s, w, h)
			surface.SetDrawColor(zclib.colors["textentry"])
			surface.SetMaterial(zclib.Materials.Get("refresh"))
			surface.DrawTexturedRect(5 * zclib.wM, 5 * zclib.hM, h - 10 * zclib.hM,h - 10 * zclib.hM)
		end

		p.b = b

		timer.Simple(0,function()
			if IsValid(b) and IsValid(p) then
				b:SetPos(p:GetWide() - 50 * zclib.wM,0 * zclib.hM  )
			end
		end)
	end

	return p
end

function zclib.vgui.ModelPanel(data)
	local model_pnl = vgui.Create("DModelPanel")
	model_pnl:SetPos(0 * zclib.wM, 0 * zclib.hM)
	model_pnl:SetSize(50 * zclib.wM, 50 * zclib.hM)
	model_pnl:SetVisible(false)
	model_pnl:SetAutoDelete(true)
	model_pnl.LayoutEntity = function(self) end

	if data and data.model then

		model_pnl:SetModel(zclib.CacheModel(data.model))

		if not IsValid(model_pnl.Entity) then
			model_pnl:SetVisible(true)
			zclib.Print("Could not create DModel Panel, Clientmodel Limit reached?")
			return model_pnl
		end

		local min, max = model_pnl.Entity:GetRenderBounds()
		local size = 0
		size = math.max(size, math.abs(min.x) + math.abs(max.x))
		size = math.max(size, math.abs(min.y) + math.abs(max.y))
		size = math.max(size, math.abs(min.z) + math.abs(max.z))

		// Force the model to look good, aka no lod reduction
		model_pnl.Entity:SetLOD( 0 )

		local rData = data.render

		local FOV = 35
		local x = 0
		local y = 0
		local z = 0
		local ang = Angle(0, 25, 0)
		local pos = vector_origin

		if rData then
			FOV = rData.FOV or 35
			x = rData.X or 0
			y = rData.Y or 0
			z = rData.Z or 0
			ang = rData.Angles or angle_zero
			pos = rData.Pos or vector_origin
		end

		model_pnl:SetFOV(FOV)
		model_pnl:SetCamPos(Vector(size + x, size + 30 + y, size + 5 + z))
		model_pnl:SetLookAt((min + max) * 0.5)

		if ang then
			model_pnl.Entity:SetAngles(ang)
		end

		if pos then
			model_pnl.Entity:SetPos(pos)
		end

		if data.color then
			model_pnl:SetColor(data.color)
		end

		if data.skin then
			model_pnl.Entity:SetSkin(data.skin)
		end

		if data.material then
			model_pnl.Entity:SetMaterial(data.material)
		end

		if data.anim then
			model_pnl:SetAnimated(true)
			model_pnl.Entity:SetSequence(data.anim)
			model_pnl:SetPlaybackRate(data.speed)
			model_pnl:RunAnimation()
		end

		if data.bodygroup then
			for k,v in pairs(data.bodygroup) do
				model_pnl.Entity:SetBodygroup(k,v)
			end
		end

		model_pnl:SetVisible(true)
	end

	return model_pnl
end

function zclib.vgui.DAdjustableModelPanel(data)
	local model_pnl = vgui.Create("DAdjustableModelPanel")
	model_pnl:SetPos(0 * zclib.wM, 0 * zclib.hM)
	model_pnl:SetSize(50 * zclib.wM, 50 * zclib.hM)
	model_pnl:SetVisible(false)
	model_pnl:SetAutoDelete(true)
	model_pnl.LayoutEntity = function(self) end

	if data and data.model then

		model_pnl:SetModel(zclib.CacheModel(data.model))

		if not IsValid(model_pnl.Entity) then
			model_pnl:SetVisible(true)
			zclib.Print("Could not create DModel Panel, Clientmodel Limit reached?")
			return model_pnl
		end

		local min, max = model_pnl.Entity:GetRenderBounds()
		local size = 0
		size = math.max(size, math.abs(min.x) + math.abs(max.x))
		size = math.max(size, math.abs(min.y) + math.abs(max.y))
		size = math.max(size, math.abs(min.z) + math.abs(max.z))

		// Force the model to look good, aka no lod reduction
		model_pnl.Entity:SetLOD( 0 )

		local rData = data.render

		local FOV = 35
		local x = 0
		local y = 0
		local z = 0
		local ang = Angle(0, 25, 0)
		local pos = vector_origin

		if rData then
			FOV = rData.FOV or 35
			x = rData.X or 0
			y = rData.Y or 0
			z = rData.Z or 0
			ang = rData.Angles or angle_zero
			pos = rData.Pos or vector_origin
		end

		model_pnl:SetFOV(FOV)
		model_pnl:SetCamPos(Vector(size + x, size + 30 + y, size + 5 + z))
		model_pnl:SetLookAt((min + max) * 0.5)

		if ang then
			model_pnl.Entity:SetAngles(ang)
		end

		if pos then
			model_pnl.Entity:SetPos(pos)
		end

		if data.color then
			model_pnl:SetColor(data.color)
		end

		if data.skin then
			model_pnl.Entity:SetSkin(data.skin)
		end

		if data.material then
			model_pnl.Entity:SetMaterial(data.material)
		end

		if data.anim then
			model_pnl:SetAnimated(true)
			model_pnl.Entity:SetSequence(data.anim)
			model_pnl:SetPlaybackRate(data.speed)
			model_pnl:RunAnimation()
		end

		if data.bodygroup then
			for k,v in pairs(data.bodygroup) do
				model_pnl.Entity:SetBodygroup(k,v)
			end
		end

		model_pnl:SetVisible(true)
	end

	return model_pnl
end



function zclib.vgui.Panel(parent, name)
	local m = vgui.Create("DPanel", parent)
	m:SetSize(600 * zclib.wM, 600 * zclib.hM)
	m:DockMargin(50 * zclib.wM, 10 * zclib.hM, 50 * zclib.wM, 0 * zclib.hM)

	if name then
		m:DockPadding(0, 50 * zclib.hM, 0, 0)
	else
		m:DockPadding(0, 0 , 0, 0)
	end

	m:Dock(TOP)

	m.Title_text = name
	m.Title_font = zclib.GetFont("zclib_font_medium")
	m.Title_color = zclib.colors["orange01"]
	m.BG_color = zclib.colors["ui01"]

	m.Paint = function(s, w, h)
		draw.RoundedBox(5, 0, 0, w, h, s.BG_color)
		if s.Title_text then
			draw.SimpleText(s.Title_text, s.Title_font, 10 * zclib.wM, 10 * zclib.hM, s.Title_color, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
		end
	end

	m:InvalidateLayout(true)
	m:InvalidateParent(true)

	return m
end

function zclib.vgui.ComboBox(parent,default,OnSelect)

    local DComboBox = vgui.Create( "DComboBox", parent )
    DComboBox:SetSize(200 * zclib.wM, 50 * zclib.hM)
    DComboBox:DockMargin(240 * zclib.wM,0 * zclib.hM,0 * zclib.wM,0 * zclib.hM)
    DComboBox:Dock(FILL)
    if default then DComboBox:SetValue(default) end
    DComboBox:SetColor(zclib.colors["text01"] )
    DComboBox.Paint = function(s, w, h) draw.RoundedBox(4, 0, 0, w, h, zclib.colors["black_a50"]) end
    DComboBox.OnSelect = function( s, index, value ,data_val) pcall(OnSelect,index,value,DComboBox,data_val) end

    return DComboBox
end

function zclib.vgui.Colormixer(parent,default,OnChange,OnValueChangeStop)
    local colmix = vgui.Create("DColorMixer", parent)
    colmix:SetSize(240 * zclib.wM, 100 * zclib.hM)
    colmix:DockMargin(10 * zclib.wM,40 * zclib.hM,10 * zclib.wM,0 * zclib.hM)
    colmix:Dock(FILL)
    colmix:SetPalette(false)
    colmix:SetAlphaBar(false)
    colmix:SetWangs(true)
    colmix:SetColor(default or color_white)
    colmix.ValueChanged = function(s,col)
        pcall(OnChange,col,s)

        zclib.Timer.Remove("zclib_colormixer_delay")
        zclib.Timer.Create("zclib_colormixer_delay",0.1,1,function()
            pcall(OnValueChangeStop,col,s)
        end)
    end

    return colmix
end

function zclib.vgui.Page(title, content, desc)
	if IsValid(zclib_main_panel) then zclib_main_panel:Remove() end

    local mainframe = vgui.Create("DFrame")
    mainframe:SetSize(1000 * zclib.wM, 800 * zclib.hM)
    mainframe:Center()
    mainframe:MakePopup()
    mainframe:ShowCloseButton(false)
    mainframe:SetTitle("")
    mainframe:SetDraggable(true)
    mainframe:SetSizable(false)
    mainframe:DockPadding(0, 15 * zclib.hM, 0, 30 * zclib.hM)

    mainframe.Paint = function(s, w, h)
        draw.RoundedBox(5, 0, 0, w, h, zclib.colors["ui02"])

        surface.SetMaterial(zclib.Materials.Get("grib_horizontal"))
        surface.SetDrawColor(zclib.colors["white_a5"])
        surface.DrawTexturedRectUV(0, 0, w, 20 * zclib.hM, 0, 0, w / (30 * zclib.hM), (20 * zclib.hM) / (20 * zclib.hM))

        if input.IsKeyDown(KEY_ESCAPE) and IsValid(mainframe) then
            mainframe:Close()
        end
    end

    zclib_main_panel = mainframe

	zclib_main_panel.Close = function()
		zclib.Inventory.RemoveSlotOptions()
		zclib.vgui.ActiveEntity = nil

		if IsValid(zclib_main_panel) then
			zclib_main_panel:Remove()
		end
	end

    local top_pnl = vgui.Create("DPanel", mainframe)
    top_pnl:SetSize(600 * zclib.wM, 80 * zclib.hM)
    top_pnl:Dock(TOP)
    top_pnl:DockPadding(10 * zclib.wM, 10 * zclib.hM, 10 * zclib.wM, 20 * zclib.hM)
    top_pnl:DockMargin(0 * zclib.wM, 0 * zclib.hM, 0 * zclib.wM, 10 * zclib.hM)
    top_pnl.Title_font = zclib.GetFont("zclib_font_big")
	top_pnl.title = title
    top_pnl.Paint = function(s, w, h)
        draw.RoundedBox(5, 50 * zclib.wM, h - 5 * zclib.hM, w, 5 * zclib.hM, zclib.colors["ui01"])

        if desc then
            draw.SimpleText(s.title, s.Title_font, 50 * zclib.wM, 30 * zclib.hM, zclib.colors["text01"], TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
            draw.SimpleText(desc, zclib.GetFont("zclib_font_mediumsmall_thin"), 50 * zclib.wM, 60 * zclib.hM, zclib.colors["orange01"], TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        else
            draw.SimpleText(s.title, s.Title_font, 50 * zclib.wM, 35 * zclib.hM, zclib.colors["text01"], TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
    end

    pcall(content, mainframe, top_pnl)

	mainframe:InvalidateLayout(true)
	mainframe:SizeToChildren(false,true)
	mainframe:Center()

	return mainframe
end

function zclib.vgui.AddSeperator(parent)
	local seperator = vgui.Create("DPanel", parent)
	seperator:SetSize(600 * zclib.wM, 5 * zclib.hM)
	seperator:Dock(TOP)
	seperator:DockMargin(50 * zclib.wM, 10 * zclib.hM, 50 * zclib.wM, 0 * zclib.hM)

	seperator.Paint = function(s, w, h)
		draw.RoundedBox(5, 0, 0, w, h, zclib.colors["ui01"])
	end

	return seperator
end

function zclib.vgui.List(parent)
	local scroll = vgui.Create("DScrollPanel", parent)
	scroll:Dock(FILL)
	scroll:DockMargin(10 * zclib.wM, 10 * zclib.hM, 10 * zclib.wM, 10 * zclib.hM)

	scroll.Paint = function(s, w, h)
		//draw.RoundedBox(0, 0, 0, w, h, zclib.colors["green01"])
	end

	local sbar = scroll:GetVBar()
	sbar:SetHideButtons(true)

	function sbar:Paint(w, h)
		draw.RoundedBox(5, w * 0.1, 0, w * 0.8, h, zclib.colors["black_a50"])
	end

	function sbar.btnUp:Paint(w, h)
	end

	function sbar.btnDown:Paint(w, h)
	end

	function sbar.btnGrip:Paint(w, h)
		draw.RoundedBox(5, w * 0.1, 0, w * 0.8, h, zclib.colors["text01"])
	end

	function scroll:JumpToChild(panel)
		self:InvalidateLayout(true)
		local _, y = self.pnlCanvas:GetChildPosition(panel)
		local _, h = panel:GetSize()
		y = y + h * 0.5
		y = y - self:GetTall() * 0.5
		self.VBar:AnimateTo(y, 0.01, 0, 0.5)
	end

	local list = vgui.Create("DIconLayout", scroll)
	list:Dock(FILL)
	list:SetSpaceY(10 * zclib.hM)
	list:SetSpaceX(10 * zclib.wM)
	list:DockMargin(10 * zclib.wM, 10 * zclib.hM, 10 * zclib.wM, 0 * zclib.hM)

	list.Paint = function(s, w, h)
		//draw.RoundedBox(0, 0, 0, w, h, zclib.colors["red01"])
	end

	list:Layout()

	return list, scroll
end

--lua/zclib/generic/cl_vibrate.lua:
return gluapack()()
--addons/[binbon]misc/lua/autorun/!bb_shmisc.lua:
return gluapack()()
--lua/autorun/aovicki_npc.lua:
return gluapack()()
--lua/autorun/aovicki_npc.lua:
local Category = "Arkham Origins Vicki Vale"
local NPC = {    Name = "Vicki Vale", 
                Class = "npc_citizen", 
                Model = "models/player/bobert/AOVicki_npc.mdl",                 
Health = "150",                 KeyValues = { citizentype = 4 },                 
Category = Category }  list.Set( "NPC", "npc_AOVicki", NPC ) 

--addons/aphone/lua/aphone/languages/turkish.lua:
aphone.LanguageTable = {
    // NPC
    NPC_Name = "Telefonun yapısını değiştir",

    // Error
    Error_FailedTextScreen = "DTextEntry oluşturulması başarısız, hata konsola aktarılmıştır",

    // APP Names
    Calculator = "Hesap Makinesi",
    Camera = "Kamera",
    Contacts = "Rehber",
    Cookies = "Kurabiyeler",
    Darkweb = "Karanlık Ağ",
    Gallery = "Galeri",
    GPS = "GPS",
    SMS = "SMS",
    Radio = "Radyo",
    Options = "Ayarlar",
    Bank = "Banka",
    Printer = "Yazıcısı",

    // Printers
    printer_money = "Para",
    printer_capacity = "Kapasite",
    printer_sec = "Para/Sec",
    printer_danger = "Yazıcılar Aşırı Isınıyor",

    // Params
    SilentMode = "Sessiz Mod",
    AutoLight = "OtoIşık",

    // DodgeIt!
    Restart = "Yeniden deneyecek misin ?",
    Hello = "Merhaba",
    WelcomeTo = "Hoşgeldiniz:",

    // Special Numbers
    Police = "Polis",
    Police_Desc = "Polisi Ara",

    // Painting
    Material = "Resim",
    Angle = "Açı",
    Red = "Kırmızı",
    Blue = "Mavi",
    Green = "Yeşil",
    PosX = "X Pozisyonu",
    PosY = "Y Pozisyonu",
    SizeX = "X Boyutu",
    SizeY = "Y Boyutu",
    Add_Layer = "Katman Ekle",
    Confirm = "Onayla",

    // Call
    Already_Call = "Zaten Bir Çağrıdasın",
    Calling = "Ara",

    // Pictures
    Uploading = "Yükleniyor",
    Online_Pictures = "Bulutun",
    Offline_Pictures = "Galerin",

    // Contacts
    No_Number = "Numara Yok",
    PutName = "İsim Yazın",
    PutNumber = "Numara Yazın",
    Already_Exist = "Zaten var olmakta",
    PlayerNotFound = "Oyuncu bulunamadı",
    ChangeName = "İsimi değiştir",

    // Cookies ( Number )
    Thousand = " yüz",
    Million = " milyon",
    Billion = " milyar",
    Trillion = " trilyon",
    Quadrillion = " katrilyon",
    Quintillion = " kentilyon",
    Sextillion = " sekstilyon",
    Septillion = " septilyon",

    // Cookies ( Items )
    Cursor = "İmleç",
    Grandma = "Anneanne",
    Farm = "Tarla",
    Mine = "Maden",
    Factory = "Fabrika",
    Bank = "Banka",
    Temple = "Tapınak",
    WizardTower = "Büyücü Kulesi",
    Shipment = "Gönderi",
    Alchemy = "Simya",
    Portal = "Portal",
    TimeMachine = "Zaman Makinesi",
    Antimatter_Condenser = "Anti-Madde Kondansatörü",
    Prism = "Prizma",
    Chancemaker = "Şansölye",
    FractalEngine = "Fraktal Motor",
    JSConsole = "Javascript Konsolu",
    Idleverse = "Idleverse",

    // Messages
    Messages = "Mesajlar",
    Type_Message = "Yaz...",
    First_Message = "Mesaj bulunamadı\nSohbeti başlatmak ister misin ?",
    Search = "Ara",
    Available = "Bağlanıldı",
    Not_Available = "Sadece Mesaj",

    // Radio
    Music_NotFound = "Bilinmeyen müzik",
    Music_Disabled = "- Deaktif",
    Radio_Off = "Kapalı",

    // Darkweb
    Darkweb_Title = "karanlıkağ",
    Darkweb_Contracts = "rehber",
    Darkweb_Confirm = "onayla",
    Darkweb_name = "isim",
    Darkweb_price = "ücret",
    Darkweb_putname = "isim yazınız",
    Darkweb_notfound = "bulunamadı",

    // Days
    Monday = "Pazartesi",
    Tuesday = "Salı",
    Wednesday = "Çarşamba",
    Thursday = "Perşembe",
    Friday = "Cuma",
    Saturday = "Cumartesi",
    Sunday = "Pazar",

    January = "Ocak",
    February = "Şubat",
    March = "Mart",
    April = "Nisan",
    May = "Mayıs",
    June = "Haziran",
    July = "Temmuz",
    August = "Ağustos",
    September = "Eylül",
    October = "Ekim",
    November = "Kasım",
    December = "Aralık",

    // BLogs
    BLogs_Message = "{1}, {2}'ya mesaj yolladı ",
    BLogs_MessageOffline = "{1} %s'ya mesaj yolladı ",
    BLogs_Call_Pending = "{1}, {2}'yı aradı",
    BLogs_Call_Accept = "{1}, {2}'nın çağrısını açtı",
    BLogs_Call_Stop = "{1}, {2}'nın çağrısını kapattı",
    BLogs_Deepweb_Create = "{1}, {2} adına kontrakt koydu ",
    BLogs_Deepweb_Remove = "{1}'nn {2} adına koyduğu kontraktı kaldırdı ",

    // Colors
    Black48 = "Siyah",
    Black40 = "Siyah 2",
    Black40_120 = "Siyah 2 - 120",
    Silver = "Gümüş",
    White = "Beyaz",
    Black1 = "Siyah 3",
    Black2 = "Siyah 4",
    Black3 = "Siyah 5",
    mat_black = "Siyah 6",

    Text_White = "Metin Rengi",
    Text_White180 = "Metin Rengi - 180",
    Text_White120 = "Metin Rengi - 120",
    Text_White60 = "Metin Rengi - 60",
    Text_Shadow = "Metin Gölgesi",
    Text_Apps = "Uygulama'nın başlığı",

    Text_Orange = "Turuncu",
    mat_orange = "Turuncu 2",
    GPS_Line = "GPS Çizgisi",

    Cookie_BoostOff = "Kurabiye - Nitrosuz",
    Cookie_BoostOn = "Kurabiye - Nitrolu",
    Cookie_Blue = "Kurabiye - Mağaza Arkaplanı",

    Radio_Background = "Radyo - Arkaplanı",
    Radio_VolumeBar = "Radyo - Ses Arkaplanı",
    Radio_RadioList = "Radyo - Arkaplan Listesi",

    mat_red = "Kırmızı",
    mat_blackred = "Koyu Kırmızı",
    mat_lightred = "Açık Kırmızı",
    Services_Desc = "İstediğin zaman yardım al !",
    Services = "Servisler",
    BATM_Issue = "Bunu kullanmadan önce bir bankamatik kullanmanız gerekir.",
    OnlyMyRadio = "o benim radyom",
    Ringtones = "Zil sesleri",

    Darkweb_Notify = "Cinayet için sana %s ödendi",

    Colors = "Renk",
    Core = "Diğerleri",
    SettingFlashlight = "El feneri",
}
--addons/aphone/lua/aphone/_libs/__header/cl_loadapps.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/__header/sh_devconfig.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/_utilities/cl_panels.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/_utilities/sh_compatibilities.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/_utilities/sh_lib.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/banks/sh_slownlsatm.lua:
return gluapack()()
--addons/aphone/lua/aphone/_libs/banks/sh_slownlsatm.lua:
hook.Add("PostGamemodeLoaded", "Aphone_SlownLSATM", function()
    if SlownLS and SlownLS.ATM then
        local p = FindMetaTable("Player")

        if aphone.Bank then
            print("[APhone] Do you got multiples banks addons ? The last loaded bank will be used for the bank app")
        end

        aphone.Bank = aphone.Bank or {}

        aphone.Bank.clr = Color(231, 76, 60)
        aphone.Bank.logo = Material("akulla/aphone/atm.png", "smooth 1")

        function p:aphone_bankWithdraw(amt)
            if amt < 0 or !SlownLS.ATM:CanAfford(self, amt) then return end

            SlownLS.ATM:Withdraw(self:SteamID64(), amt)
            SlownLS.ATM:AddLog(self, "APhone - -" .. amt)
            aphone.Gamemode.AddMoney(self, amt)
        end

        function p:aphone_bankDeposit(amt)
            if amt < 0 or !aphone.Gamemode.Afford(self, amt) then return end

            SlownLS.ATM:Deposit(self:SteamID64(), amt)
            SlownLS.ATM:AddLog(self, "APhone - +" .. amt)
            aphone.Gamemode.AddMoney(self, -amt)
        end

        function p:aphone_bankTransfer(ply2, amt)
            if amt < 0 or !SlownLS.ATM:CanAfford(self, amt) then return end

            SlownLS.ATM:Withdraw(self:SteamID64(), amt)
            SlownLS.ATM:Deposit(ply2:SteamID64(), amt)
            SlownLS.ATM:AddLog(ply2, "APhone - +" .. amt)
            SlownLS.ATM:AddLog(self, "APhone - -" .. amt)
        end

        function p:aphone_getmoney()
            return SERVER and self:GetBankBalance() or LocalPlayer():SlownLS_ATM_Balance()
        end

        function aphone.Bank.FormatMoney(amt)
            return aphone.Gamemode.Format(amt)
        end
    end
end)
--addons/aphone/lua/aphone/_libs/gamemodes_related/sh_nutscript.lua:
hook.Add("PostGamemodeLoaded", "APhone_GR_Nut", function()
    if nut then
        aphone.Gamemode = {}

        function aphone.Gamemode.Afford(ply, amt)
            return ply:canAfford(amt)
        end
    
        function aphone.Gamemode.AddMoney(ply, amt)
            local c = ply:getChar()
    
            local money = c:getMoney()
            if money + amt < 0 then return false end
    
            c:addMoney(c:getMoney() + amt)
            return true
        end
    
        function aphone.Gamemode.Format(amt)
            return nut.currency.get(amt)
        end

        function aphone.Gamemode.GetMoney(ply)
            return ply:getChar():getMoney()
        end
    end
end)

--addons/aphone/lua/aphone/_libs/painting/cl_rt.lua:
// Convert everything
for k, v in pairs(aphone.Painting) do
	if isstring(v) then
		aphone.Painting[k] = Material(v, "smooth 1")
	end
end

// Put it in global, so we keep a trace of our textures
aphone.Texturelist = aphone.Texturelist or {}

function aphone:Painting_Generate(rt, skintbl)
	if !skintbl then return end

	render.PushRenderTarget(rt)
		render.Clear(255, 255, 255, 255)
		cam.Start2D()
			-- I don't use ipairs because it's not always sequencial tables ( like in panel painting where I remove index, but not fill gap )
			for k,v in pairs(skintbl) do
				local mat = aphone.Painting[v.mat_id]

				if !mat or type(mat) != "IMaterial" or mat:IsError() then continue end

				local dw = 256
				local dh = mat:Height() / mat:Width() * dw

				local tr = Matrix()
				tr:Translate(Vector(v.posx * 1024, v.posy * 1024))
				tr:Scale(Vector(v.sizex, v.sizey, 1))
				tr:Translate(Vector(-dw / 2, -dh / 2))

				cam.PushModelMatrix(tr)
					surface.SetMaterial(mat)
					surface.SetDrawColor(v.clr_r, v.clr_g, v.clr_b)
					surface.DrawTexturedRectRotated(dw / 2, dh / 2, dw, dh, v.angle)
				cam.PopModelMatrix()
			end
		cam.End2D()
	render.PopRenderTarget()
end

local function create_newplayerpaint(ply, table)
	local rt = aphone.Texturelist[ply].rt or GetRenderTargetEx( "aphone_RT_" ..  ply, 1024, 1024, RT_SIZE_OFFSCREEN, MATERIAL_RT_DEPTH_NONE, 0, 0, IMAGE_FORMAT_RGBA8888)
	local tex = aphone.Texturelist[ply].tex or CreateMaterial( "aphone_RT_" ..  ply, "VertexLitGeneric", {
		["$basetexture"] = rt:GetName()
	} )

	aphone:Painting_Generate(rt, table)

	local infos = {
		tex = tex,
		rt = rt,
		last_refresh = CurTime(),
	}

	if ply == LocalPlayer():UserID() then
		aphone.SelfPaint = table
	end

	aphone.Texturelist[ply] = infos
end

net.Receive("aphone_PaintLoad", function()
	local user_id = net.ReadUInt(16)
	local step = net.ReadUInt(6)

	local stickers = {}

	for i = 1, step do
		local tbl = {
			mat_id = net.ReadUInt(16) or 1,
			angle = net.ReadUInt(9) or 0,
			clr_r = net.ReadUInt(8) or 255,
			clr_g = net.ReadUInt(8) or 255,
			clr_b = net.ReadUInt(8) or 255,
			posx = (net.ReadUInt(10) or 50)/100,
			posy = (net.ReadUInt(10) or 50)/100,
			sizex = (net.ReadUInt(10) or 100)/100,
			sizey = (net.ReadUInt(10) or 100)/100,
		}

		table.insert(stickers, tbl)
	end

	aphone.Texturelist[user_id] = aphone.Texturelist[user_id] or {}

	create_newplayerpaint(user_id, stickers)
end)

function aphone.RefreshWeapon(ply, wep)
	if aphone.Texturelist[ply:UserID()] and (!wep.last_refresh or wep.last_refresh < aphone.Texturelist[ply:UserID()].last_refresh) then
		wep.last_refresh = CurTime()

		for k, v in pairs(aphone.matlist) do
			wep:SetSubMaterial(v, "!" .. aphone.Texturelist[ply:UserID()].rt:GetName())
		end
	end
end
--addons/aphone/lua/aphone/_libs/panels/cl_imageshow.lua:
local PANEL = {};

function PANEL:Init()
    local w, h = self:GetParent():GetSize()

    local clr_black40 = aphone:Color("Black40_120")
    local font_svg30 = aphone:GetFont("SVG_30")
    local clr_white120 = aphone:Color("Text_White120")

    self:SetMouseInputEnabled(true)
    local pnl = self

    if !self.skipanim then
        self:SetSize(0, 0)
        self:SetPos(w / 2, h / 2)

        self:SizeTo(w, h, 0.33, 0, 0.5)
        self:MoveTo(0, 0, 0.33, 0, 0.5)
    else
        self:SetSize(w, h)
    end

    surface.SetFont(font_svg30)
    local _, text_y = surface.GetTextSize("l")

    local header = vgui.Create("DPanel", self)
    header:Dock(TOP)
    header:SetTall(text_y * 1.5)

    function header:Paint(w, h)
        surface.SetDrawColor(clr_black40)
        surface.DrawRect(0, 0, w, h)
    end

    local header_quit = vgui.Create("DButton", header)
    header_quit:Dock(LEFT)
    header_quit:SetWide(text_y)
    header_quit:SetFont(font_svg30)
    header_quit:SetText("l")
    header_quit:SetPaintBackground(false)
    header_quit:SetTextColor(clr_white120)
    header_quit:DockMargin(text_y / 2, 0, 0, 0)
    header_quit:Phone_AlphaHover()

    function header_quit:DoClick()
        pnl:CloseAnimation()

        if pnl.onclose then
            pnl.onclose()
        end
    end

    self.header_upload = vgui.Create("DButton", header)
    self.header_upload:Dock(LEFT)
    self.header_upload:SetWide(text_y)
    self.header_upload:SetFont(font_svg30)
    self.header_upload:SetText("k")
    self.header_upload:SetPaintBackground(false)
    self.header_upload:SetTextColor(clr_white120)
    self.header_upload:SetEnabled(false)
    self.header_upload:SetAlpha(0)
    self.header_upload:Phone_AlphaHover()

    function self.header_upload:DoClick()
        if !aphone.ImgurUploading then
            aphone.ImgurUploading = true

            if !pnl.dir then
                print("[APhone] Issue in imageshow, please report this in a gmodstore ticket, there must be a error on top of this, please report this too")
            end

            aphone.SendImgur(pnl.dir)

            self.waitend = true
        end
    end

    function self.header_upload:Think()
        if self.waitend and !aphone.ImgurUploading then
            pnl:CloseAnimation()
            self.Think = nil
        end
    end

    if !aphone.URLUpload or !aphone.URLupload_picture then
        self.header_upload:Remove()
    end
    
    self:aphone_RemoveCursor()
end

function PANEL:SetDir(dir)
    self.dir = dir

    if IsValid(self.header_upload) then
        self.header_upload:SetEnabled(true)
        self.header_upload:SetAlpha(255)
    end
end

function PANEL:CloseAnimation()
    self:SizeTo(0, 0, 0.33, 0, 0.5)
    self:MoveTo(self:GetWide() / 2, self:GetTall() / 2, 0.33, 0, 0.5, function(_, p)
        p:Remove()
    end)
end

function PANEL:SetMat(mat)
    self.mat = mat

    local w = mat:Width()
    local h = mat:Height()

    self.horizontal_pic = h < w
end

function PANEL:Paint(w, h)
    if self.mat then
        surface.SetDrawColor(color_black)
        surface.DrawRect(0, 0, w, h)

        surface.SetMaterial(self.mat)
        surface.SetDrawColor(color_white)

        local horizontal = w > h

        if self.horizontal_pic and !horizontal then
            surface.DrawTexturedRect(0, h/2 - (w*(w/h))/2, w, w*(w/h))
        elseif !self.horizontal_pic and horizontal then
            surface.DrawTexturedRect(w/2 - (h*(h/w))/2, 0, h*(h/w), h)
        else
            surface.DrawTexturedRect(0, 0, w, h)
        end
    end
end

local black_180 = Color(40, 40, 40, 180)
local stencil_clr = Color(1, 1, 1, 1)
function PANEL:PaintOver(w, h)
    if aphone.ImgurUploading then
        surface.SetDrawColor(black_180)
        surface.DrawRect(0, 0, w, h)

        if !self.circle1 then
            self.circle1 = aphone.GUI.GenerateCircle(w / 2, h / 2, (aphone.Horizontal and h or w) / 4)
            self.circle2 = aphone.GUI.GenerateCircle(w / 2, h / 2, (aphone.Horizontal and h or w) / 4-6)
        end

        local rad = CurTime() * 6

        aphone.Stencils.Start()
            surface.SetDrawColor(stencil_clr)
            surface.DrawPoly(self.circle1)
        aphone.Stencils.AfterMask(false)
            surface.DrawPoly(self.circle2)

            surface.SetDrawColor(aphone:Color("GPS_Line"))

            local p_size = (aphone.Horizontal and h or w) 
            draw.SimpleText("d", aphone:GetFont("SVG_60"), math.cos( rad ) * (p_size / 4) + w / 2, math.sin(rad) * (p_size / 4) + h / 2, aphone:Color("GPS_Line"), 1, 1)
        aphone.Stencils.End()
    end
end

function PANEL:SetValid(func)
    local valid_label = vgui.Create("DLabel", self)
    valid_label:Dock(BOTTOM)
    valid_label:SetTall(aphone.MainDerma:GetTall()*0.2)
    valid_label:SetText("r")
    valid_label:Phone_AlphaHover()
    valid_label:SetFont(aphone:GetFont("SVG_60"))
    valid_label:SetContentAlignment(8)
    valid_label:SetMouseInputEnabled(true)

    function valid_label:DoClick()
        func()
    end

    valid_label:aphone_RemoveCursor()
end

vgui.Register("aphone_ShowImage", PANEL)
--addons/aphone/lua/aphone/_libs/panels/cl_msg.lua:
local PANEL = {}
local clr_green = Color(46,139,87)

function PANEL:InitPly(ply)
    local main_x, main_y = aphone.MainDerma:GetSize()
    local clr_black3 = aphone:Color("Black3")
    local clr_black2 = aphone:Color("Black2")
    local clr_black1 = aphone:Color("Black1")
    local clr_white120 = aphone:Color("Text_White120")
    local font_mediumheader = aphone:GetFont("MediumHeader")
    local connected = ply and isentity(ply) and ply:IsPlayer()
    local id = connected and ply:aphone_GetID() or ply
    local name = aphone.GetName(ply)
    local pnl = self

    self:SetPaintBackground(false)

    self:SetSize(aphone.MainDerma:GetSize())

    local message_panel = vgui.Create("DPanel", self)
    message_panel:SetSize(main_x, main_y)
    message_panel:SetPos(main_x, 0)
    message_panel:MoveTo(0, 0, 0.25, 0, 0.5)

    local message_writing = vgui.Create("DPanel", message_panel)
    message_writing:Dock(BOTTOM)
    message_writing:DockMargin(main_x * 0.04, main_y * 0.025, main_x * 0.04, main_y * 0.025)
    message_writing:SetTall(main_y * 0.07)

    local perfect_h = main_y * 0.035

    function message_writing:Paint(w, h)
        draw.RoundedBox(perfect_h, 0, 0, w, h, clr_black1)
    end

    surface.SetFont(aphone:GetFont("SVG_30"))
    local msg_writingtall = message_writing:GetTall()

    local message_send = vgui.Create("DLabel", message_writing)
    message_send:Dock(RIGHT)
    message_send:DockMargin(0, 0, msg_writingtall / 4, 0)
    message_send:SetWide(select(1, surface.GetTextSize("i")))
    message_send:SetFont(aphone:GetFont("SVG_30"))
    message_send:SetText("i")
    message_send:SetTextColor(clr_white120)
    message_send:SetMouseInputEnabled(true)

    // aphone_OnlinePictureList
    local messages_pic = vgui.Create("DLabel", message_writing)
    messages_pic:Dock(RIGHT)
    messages_pic:DockMargin(0, 0, msg_writingtall / 4, 0)
    messages_pic:SetWide(select(1, surface.GetTextSize("m")))
    messages_pic:SetFont(aphone:GetFont("SVG_30"))
    messages_pic:SetText("m")
    messages_pic:SetTextColor(clr_white120)
    messages_pic:SetMouseInputEnabled(true)
    messages_pic:Phone_AlphaHover()

    local message_writingEntry = vgui.Create("DLabel", message_writing)
    message_writingEntry:Dock(FILL)
    message_writingEntry:DockMargin(msg_writingtall / 2, 0, msg_writingtall / 2, 0)
    message_writingEntry:SetFont(font_mediumheader)
    message_writingEntry:SetText(aphone.L("Type_Message"))
    message_writingEntry:SetTextColor(clr_white120)
    message_writingEntry:SetMouseInputEnabled(true)
    message_writingEntry:Phone_AlphaHover()

    -- Create a panel to select online pictures, then set the dlabel text to the link
    function messages_pic:DoClick()
        local messages_picmain = vgui.Create("aphone_OnlinePictureList", pnl)
        function messages_picmain:OnSelected(imgur_url)
            aphone.InsertNewMessage(LocalPlayer(), "imgur://" .. imgur_url)
            aphone.Contacts.Send(id, "imgur://" .. imgur_url)
        end
    end

    local placeholder = aphone.L("Type_Message")
    function message_writingEntry:DoClick()
        self:Phone_AskTextEntry(message_writingEntry:GetText() == placeholder and "" or self:GetText(), 140, message_writing, (main_x*0.92 - msg_writingtall*1.25 - messages_pic:GetWide() - message_send:GetWide()))
    end

    function message_writingEntry:textEnd(clean_txt, wrapped_txt)
        self:SetText(wrapped_txt)
        self.goodtext = clean_txt
    end

    surface.SetFont(aphone:GetFont("Roboto45_700"))
    local title_x, title_y = surface.GetTextSize(name)

    local top_name = vgui.Create("DPanel", message_panel)
    top_name:Dock(TOP)
    top_name:DockMargin(main_x * 0.12, main_y * 0.05, 0, main_y * 0.05)
    top_name:SetTall(title_y)
    top_name:SetPaintBackground(false)

    local top_back = vgui.Create("DButton", top_name)
    top_back:Dock(RIGHT)
    top_back:SetWide(title_y)
    top_back:SetFont(aphone:GetFont("SVG_30"))
    top_back:SetText("l")
    top_back:SetPaintBackground(false)
    top_back:Phone_AlphaHover()
    top_back:SetTextColor(clr_white120)
    top_back:DockMargin(0, 0, top_back:GetWide(), 0)

    function top_back:DoClick()
        message_panel:MoveTo(main_x, 0, 0.5, 0, 0.5, function()
            pnl:Remove()
        end)
    end

    // Disconnected, hide call button
    if connected then
        surface.SetFont(aphone:GetFont("SVG_30"))
        local top_call = vgui.Create("DButton", top_name)
        top_call:Dock(RIGHT)
        top_call:SetWide(select(1, surface.GetTextSize("o")))
        top_call:SetFont(aphone:GetFont("SVG_30"))
        top_call:SetText("o")
        top_call:Phone_AlphaHover()
        top_call:SetTextColor(clr_white120)
        top_call:SetPaintBackground(false)

        function top_call:DoClick()
            net.Start("aphone_Phone")
                net.WriteUInt(1, 4)
                net.WriteEntity(ply)
            net.SendToServer()
        end
    end

    local title_sub = vgui.Create("DLabel", top_name)
    title_sub:SetFont(aphone:GetFont("Roboto40_700"))
    title_sub:SetTextColor(aphone:Color("Text_White"))
    title_sub:SetText(name)
    title_sub:Dock(FILL)
    title_sub:SetWide(title_x + 10)

    local message_scroll = vgui.Create("DScrollPanel", message_panel)
    message_scroll:Dock(FILL)
    message_scroll:aphone_PaintScroll()

    local is_empty = true

    // Ghetto but work and won't make optimisation issues searching the dscrollpanel from the main panel etc
    local last_msgpanel
    function aphone.InsertNewMessage(userid, body)
        if IsValid(message_scroll) then
            local ext = false

            if isbool(userid) then
                ext = userid
            elseif isentity(userid) and userid == LocalPlayer() then
                ext = true
            elseif isnumber(userid) and userid == LocalPlayer():aphone_GetID() then
                ext = true
            end

            is_empty = false

            if string.StartWith(body, "imgur://") then
                local sub_messagepnl = message_scroll:Add("aphone_MessageImage")
                sub_messagepnl:Dock(TOP)
                sub_messagepnl:DockMargin(0, main_x * 0.025, 0, main_x * 0.025)
                sub_messagepnl:Left_Avatar(ext)
                sub_messagepnl:SetImgur(body)
                sub_messagepnl:SetTall(main_x * 0.35)

                function sub_messagepnl:DoClick()
                    local show_pic = vgui.Create("aphone_ShowImage", pnl)
                    show_pic:SetMat(aphone.GetImgurMat(body))
                end

                last_msgpanel = sub_messagepnl
                return sub_messagepnl
            else
                if !IsValid(last_msgpanel) or last_msgpanel:GetName() != "aphone_Message" or last_msgpanel.revert != ext then
                    local sub_messagepnl = message_scroll:Add("aphone_Message")
                    sub_messagepnl:Dock(TOP)
                    sub_messagepnl:DockMargin(main_x * 0.05, main_x * 0.025, main_x * 0.05, main_x * 0.025)
                    sub_messagepnl:Left_Avatar(ext)
                    sub_messagepnl:SetText(body)
                    sub_messagepnl:SetBackgroundColor(ext and clr_green or clr_black2)

                    if !connected then
                        sub_messagepnl:KillAvatar()
                    else
                        sub_messagepnl:SetAvatar(userid, 184)
                    end

                    last_msgpanel = sub_messagepnl
                    return sub_messagepnl
                else
                    last_msgpanel:SetText(last_msgpanel:GetText() .. "\n" .. body)
                end
            end
        end
    end

    function message_send:DoClick()
        if !message_writingEntry.goodtext then return end

        aphone.Contacts.Send(id, message_writingEntry.goodtext)

        self:GetParent():SetTall(main_y * 0.07)
        aphone.InsertNewMessage(LocalPlayer(), message_writingEntry.goodtext)

        message_writingEntry.goodtext = nil
        message_writingEntry:SetText(aphone.L("Type_Message"))
    end

    // Let's not load ALL messages. Imagine if he got a lot of messages
    local msg_tbl = sql.Query("SELECT * FROM aphone_Messages WHERE user = " .. id .. " AND ip = '" .. game.GetIPAddress() .. "' AND timestamp > " .. os.time() - 604800) or {}

    local pnl
    for k, v in ipairs(msg_tbl) do
        if connected then
            pnl = aphone.InsertNewMessage(tonumber(v.local_sender) == 1 and LocalPlayer() or ply, v.body)
        else
            pnl = aphone.InsertNewMessage(tonumber(v.local_sender) == 1, v.body)
        end
    end

    if IsValid(pnl) then
        timer.Simple(0.33, function()
            message_scroll:ScrollToChild(pnl)
        end)
    end

    function message_panel:Paint(w, h)
        surface.SetDrawColor(clr_black3)
        surface.DrawRect(0,0,w,h)

        if is_empty then
            local _, txt_y = draw.SimpleText("U", aphone:GetFont("SVG_76"), w / 2, h / 4, clr_white120, 1)
            draw.DrawText(aphone.L("First_Message"), font_mediumheader, w / 2, h / 4 + txt_y + 10, clr_white120, 1)
        end
    end

    self:aphone_RemoveCursor()
end

vgui.Register("aphone_Msg", PANEL, "DPanel")
--addons/aphone/lua/aphone/_libs/printers/sh_sprinter.lua:
hook.Add("PostGamemodeLoaded", "Aphone_SPrinter", function()
    if sPrinter then
        aphone.Printer = aphone.Printer or {}

        function aphone.Printer.GetPrinters(ply)
            local tbl = {}
    
            for k, ent in ipairs(ents.FindByClass("sprinter_*") or {}) do
                local owner = ent.Getowning_ent and ent:Getowning_ent() or nil

                if IsValid(ent:GetParent()) and ent:GetParent():GetClass() == "sprinter_rack" then
                    owner = ent:GetParent():Getowning_ent()
                end

                if !IsValid(ent) or !IsValid(owner) or owner != ply then continue end

                table.insert(tbl, ent)
            end
    
            return tbl
        end
    
        function aphone.Printer.FormatMoney(amt)
            return aphone.Gamemode.Format(amt)
        end
    
        function aphone.Printer.GetInfo(ents)
            local capacity = 0
            local money = 0
            local sec = 0
            local danger = 0
    
            for k, v in pairs(ents) do
                if IsValid(v) and v:GetClass() != "sprinter_rack" then
                    if !v.GetBattery or v:GetBattery() <= 0 or !v:GetPower() then continue end
    
                    money = money + v:GetMoney()
                    capacity = capacity + v.data.maxstorage
    
                    if v.data.maxstorage > v:GetMoney() then
                        sec = sec + (v.data.baseincome * (v:GetUpgrade("overclocking") + v.data.clockspeed)) * 6
                    end
    
                    local temp = v:GetTemperature()
                    local rack = v:GetRack()
    
                    if IsValid(rack) then
                        local racktemp = 0
                        if rack:GetSkin() == 1 then
                            racktemp = math.random(10, 15)
                        else
                            racktemp = math.random(25, 40)
                        end
    
                        if rack.printers then
                            racktemp = racktemp + (racktempsplit * table.Count(rack.printers))
                        end
    
                        temp = temp + racktemp
                    end
    
                    danger = danger + (v:GetTemperature() > 80 and 1 or 0)
                else
                    ents[k] = nil
                end
            end
    
            return {
                [1] = {
                    val = money,
                    name = "money",
                },
    
                [2] = {
                    val = sec,
                    name = "sec",
                },
    
                [3] = {
                    val = capacity,
                    name = "capacity",
                },
    
                [4] = {
                    val = danger,
                    name = "danger",
                },
            }, ents
        end
    end
end)
--addons/aphone/lua/aphone/apps/calculator/cl_main.lua:
return gluapack()()
--addons/aphone/lua/aphone/apps/contacts/cl_contacts.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/shared/sh_acwcommon.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/shared/sh_controls.lua:
net.Receive("arccw_firemode", function(len, ply)
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    wpn:ChangeFiremode()
end)

net.Receive("arccw_ubgl", function(len, ply)
    local on = net.ReadBool()
    local wpn = ply:GetActiveWeapon()

    if !wpn.ArcCW then return end

    if on then
        wpn:SelectUBGL()
    else
        wpn:DeselectUBGL()
    end
end)

if CLIENT then
    net.Receive("arccw_togglecustomize", function()
        if !LocalPlayer():GetActiveWeapon() or !LocalPlayer():GetActiveWeapon().ArcCW then return end
        LocalPlayer():GetActiveWeapon():ToggleCustomizeHUD(net.ReadBool())
    end)
elseif SERVER then
    net.Receive("arccw_togglecustomize", function(len, ply)
        local wpn = ply:GetActiveWeapon()
        local onoff = net.ReadBool()

        if !wpn.ArcCW then return end

        wpn:ToggleCustomizeHUD(onoff)
    end)
end

hook.Add("EntityTakeDamage", "ArcCW_CloseOnHurt", function(ply, dmg)
    if ply:IsPlayer() and ply:GetActiveWeapon() and ply:GetActiveWeapon().ArcCW
            and tobool(ply:GetInfo("arccw_attinv_closeonhurt"))
            and ply:GetActiveWeapon():GetState() == ArcCW.STATE_CUSTOMIZE then
        net.Start("arccw_togglecustomize")
            net.WriteBool(false)
        net.Send(ply)
        ply:GetActiveWeapon():ToggleCustomizeHUD(false)
    end
end)
--addons/[binbon]arccw_modify/lua/arccw/shared/sh_loadatts.lua:
return gluapack()()
--lua/arccw/shared/attachments/arccw_barrel.lua:
att.PrintName = "Extended Barrel"
att.Icon = Material("entities/barrellazylol.png")
att.Description = "Increases barrel length"
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Slot = "mw_mcxlength"

att.Mult_RPM = 0.5
att.Add_BarrelLength = 5
att.Mult_Range = 2.25

att.AutoStats = true

--lua/arccw/shared/attachments/arccw_specz_perk_soh.lua:
att.PrintName = "Sleight Of Hand"
att.Icon = Material("entities/soh_test.png")
att.Description = "Improves reloading speed"
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Slot = "perk_mw"

att.InvAtt = "perk_sohmw"

att.Mult_DrawTime = 0.95
att.Mult_SightTime = 0.95

att.Hook_TranslateAnimation = function(wep, anim)
    if anim == "reload_empty" then
        return "reload_empty_soh"
    end
    if anim == "reload" then
        return "reload_soh"
    end
end

att.AutoStats = true

--lua/arccw/shared/attachments/mw2_akimbo_m93r.lua:
return gluapack()()
--lua/arccw/shared/attachments/mw2_akimbo_ranger.lua:
att.PrintName = "Ranger"
att.Icon = Material("entities/acwatt_mw2_akimbo.png", "smooth")
att.Description = "Wholy."
att.Hidden = false
att.Desc_Pros = {
    "+100% more gun",
}
att.Desc_Cons = {
    "- Cannot use ironsights"
}
att.Desc_Neutrals = {
    "Don't toggle the UBGL"
}
att.AutoStats = true
att.Mult_HipDispersion = 4
att.Slot = "akimbotest"

att.GivesFlags = {"cantuseshitinakimboyet"}

att.SortOrder = 1738

att.AddSuffix = " + Ranger"

att.MountPositionOverride = 0

att.Model = "models/weapons/arccw/fesiugmw2_2/c_ranger_2.mdl"


att.LHIK = true
att.LHIK_Animation = true
att.LHIK_MovementMult = 0

att.UBGL = true

att.UBGL_PrintName = "AKIMBO"
att.UBGL_Automatic = false
att.UBGL_MuzzleEffect = "muzzleflash_m3"
att.UBGL_ClipSize = 2
att.UBGL_Ammo = "Buckshot"
att.UBGL_RPM = 60 / 0.009
att.UBGL_Recoil = 3
att.UBGL_RecoilSide = 2
att.UBGL_RecoilRise = 0
att.UBGL_Capacity = 2

att.Hook_ShouldNotSight = function(wep)
    return true
end

local function Ammo(wep)
    return wep.Owner:GetAmmoCount("Buckshot") -- att.UBGL_Ammo
end

att.Hook_Think = function(wep)
    if wep:GetMW2Masterkey_ShellInsertTime() < CurTime() and wep:GetMW2Masterkey_ShellInsertTime() != 0 then
        wep:SetMW2Masterkey_ShellInsertTime(0)
        local clip = 2
        if wep:Clip2() >= clip then return end
        if Ammo(wep) <= 0 then return end

        local reserve = Ammo(wep)
        reserve = reserve + wep:Clip2()
        local load = math.Clamp(clip, 0, reserve)
        wep.Owner:SetAmmo(reserve - load, "Buckshot")
        wep:SetClip2(load)
    end

    if !IsFirstTimePredicted() then return end
    if wep:GetOwner():KeyPressed(IN_RELOAD) then
        wep:SetInUBGL(false)
        wep:ReloadUBGL()
    elseif wep:GetOwner():KeyPressed(IN_ATTACK) then
        wep:SetInUBGL(false)
    elseif wep:GetOwner():KeyPressed(IN_ATTACK2) then
        wep:SetInUBGL(true)
        wep:ShootUBGL()
    end
end

att.Hook_TranslateSequence = function(wep, anim)
end

local awesomelist = {
    ["sprint_in_r"] = {
        time = 10/30,
        anim = "sprint_in_l",
    },
    ["sprint_out_r"] = {
        time = 10/30,
        anim = "sprint_out_l",
    },
    ["sprint_loop_r"] = {
        time = 30/40,
        anim = "sprint_loop_l",
    },
    ["pullout_r"] = {
        time = 12/30,
        anim = "pullout_l",
    },
    ["putaway_r"] = {
        time = 23/30,
        anim = "putaway_l",
    },
}

att.Hook_TranslateSequence = function(wep, anim)
    if awesomelist[anim] then
        local bab = awesomelist[anim]
        wep:DoLHIKAnimation(bab.anim, bab.time)
    end
end

att.Hook_LHIK_TranslateAnimation = function(wep, anim)
    if anim == "idle" then return "idle_l" end
end

att.UBGL_Fire = function(wep, ubgl)
    if wep:Clip2() <= 0 then return end

    -- this bitch
    local fixedcone = wep:GetDispersion() / 360 / 60

    wep.Owner:FireBullets({
		Src = wep.Owner:EyePos(),
		Num = 6,
		Damage = 75,
		Force = 1,
		Attacker = wep.Owner,
		Dir = wep.Owner:EyeAngles():Forward(),
		Spread = Vector(fixedcone, fixedcone, 0),
		Callback = function(_, tr, dmg)
			local dist = (tr.HitPos - tr.StartPos):Length() * ArcCW.HUToM

			local dmgmax = 75
			local dmgmin = 35

			local delta = dist / 800 * 0.025

			delta = math.Clamp(delta, 0, 1)

			local amt = Lerp(delta, dmgmax, dmgmin)

			dmg:SetDamage(amt)
		end
	})
    wep:EmitSound("weapons/fesiugmw2/fire/shot_ranger.wav", 130, 115 * math.Rand(1 - 0.05, 1 + 0.05))
                            -- This is kinda important
                                            -- Wep volume
                                                    -- Weapon pitch (along with the pitch randomizer)




    wep:SetClip2(wep:Clip2() - 1)
    
    wep:DoLHIKAnimation("fire_l", 16/30)

    wep:DoEffects()
end

att.UBGL_Reload = function(wep, ubgl)
        if wep:Clip2() >= 2 then return end
        if Ammo(wep) <= 0 then return end

    wep:SetInUBGL(false)
    wep:Reload()

    wep:DoLHIKAnimation("reload_mp_l", 120/30)
    wep:SetNextSecondaryFire(CurTime() + 120/30)
    wep:SetMW2Masterkey_ShellInsertTime(CurTime() + 1.549)
    wep:PlaySoundTable({
        {s = "weapons/fesiugmw2/foley/wpfoly_ranger_reload_lift_v1.wav", 		t = 0.01},
        {s = "weapons/fesiugmw2/foley/wpfoly_ranger_reload_clipout_v1.wav", 		t = 12/30},
        {s = "weapons/fesiugmw2/foley/wpfoly_ranger_reload_clip1in_v1.wav", 		t = 53/30},
        {s = "weapons/fesiugmw2/foley/wpfoly_ranger_reload_clip2in_v1.wav", 		t = 70/30},
        {s = "weapons/fesiugmw2/foley/wpfoly_ranger_reload_chamber_v1.wav", 		t = 106/30},
    })
end

att.Hook_GetHUDData = function( wep, data )
    if ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        data.clip = wep:Clip2() .. " / " .. wep:Clip1()
    else
        data.clip = wep:Clip1() + wep:Clip2()
    end
    data.ubgl = nil
    return data
end
--lua/arccw/shared/attachments/mw2_wepcamo_bluetiger.lua:
return gluapack()()
--lua/arccw/shared/attachments/optic_cheytacscope.lua:
return gluapack()()
--lua/arccw/shared/attachments/optic_mw2_mp5krearsight.lua:
return gluapack()()
--lua/arccw/shared/attachments/perk_fmj.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_40mm_napalm.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_ammo_sg_bird2.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_ammo_sg_magnum.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_ammo_sg_magnum.lua:
att.PrintName = "\"MAG\" #000 Magnum Buckshot"
att.AbbrevName = "\"MAG\" #000 Buckshot"

att.SortOrder = 5
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = [[Buckshot load using fewer, larger diameter shots and a more intense powder load. This ammo type is particularly effective up close, but its energy fizzles out quickly.]]
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.pellet.0.75",
    "uc.accuracy.10",
}
att.Desc_Neutrals = {
}
att.Slot = {"ud_ammo_shotgun","uc_ammo"}

att.AutoStats = true

att.Mult_Num = 0.75
att.Mult_Damage = 1.25

att.Mult_Range = 0.5
att.Mult_RangeMin = 2

att.Mult_Recoil = 1.3
att.Add_AccuracyMOA = 10

att.Mult_HullSize = 1.5

att.Override_UC_ShellColor = Color(0.8 * 255, 0.8 * 255, 0.8 * 255)

att.Hook_Compatible = function(wep)
    if !wep:GetIsShotgun() or wep:GetBuff_Override("UC_Shotshell") then
        return false
    end
end
--lua/arccw/shared/attachments/uc_ammo_sg_slug.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_charm_sgmanual.lua:
att.PrintName = "Slugger"

att.SortOrder = 1
att.Icon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")
att.Description = "Forces weapons to only use manual-action modes. Not the most competitively viable, but it surely shows you can still kick ass without all those fancy-shmancy automatic modes."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.manualonly",
}
att.Slot = "charm"
att.AutoStats = true

att.ActivateElements = {"uc_manualonly"}
att.GivesFlags = {"needsmanual"}
att.Hook_Compatible = function(wep)
    if (!wep.ManualAction and !wep.UC_CanManualAction) or !wep:GetIsShotgun() then return false end
end

att.Ignore = true
--lua/arccw/shared/attachments/uc_charm_urbancharm.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_charm_urbancharm_anarchy.lua:
att.PrintName = "Urban Charm - Anarchy"
att.Description = "The icon of a Garry's Mod addon."
att.Ignore = true
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/atts/uc_urbancharm.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.5, 0.5, 0.5)
att.CharmOffset = Vector(0, -1.1, -0.2)
att.CharmAngle = Angle(20, 0, 80)
att.CharmSkin = 3

--lua/arccw/shared/attachments/uc_charm_urbancharm_ordinance.lua:
att.PrintName = "Urban Charm - Ordinance"
att.Description = "The icon of a Garry's Mod addon."
att.Ignore = true

att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "charm"

att.Free = true

att.Model = "models/weapons/arccw/atts/charmbase.mdl"

att.DroppedModel = "models/Items/BoxSRounds.mdl"

att.Charm = true
att.CharmModel = "models/weapons/arccw/atts/uc_urbancharm.mdl"
att.CharmAtt = "Charm"
att.CharmScale = Vector(0.5, 0.5, 0.5)
att.CharmOffset = Vector(0, -1.1, -0.2)
att.CharmAngle = Angle(20, 0, 80)
att.CharmSkin = 4

--lua/arccw/shared/attachments/uc_fg_underwater.lua:
att.PrintName = "Sealed Bolt"

att.Icon = Material("entities/att/acwatt_uc_sealedbolt.png", "smooth mips")
att.Description = "Watertight modifications that allow the weapon to fire underwater."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = {"uc_fg", "uc_fg_singleshot"}
att.AutoStats = true
att.SortOrder = 3

att.Override_CanFireUnderwater = true

att.Hook_AddShootSound = function(wep)
    if wep:GetOwner():WaterLevel() >= 3 then
        wep:MyEmitSound("weapons/underwater_explode" .. math.random(3, 4) .. ".wav", 70, math.random(60, 80), 0.5, CHAN_AUTO)
    end
end

att.Hook_PreDoEffects = function(wep)
    if wep:GetOwner():WaterLevel() >= 3 then
        return true
    end
end

att.M_Hook_Mult_ShootPitch = function(wep, data)
    if wep:GetOwner():WaterLevel() >= 3 then
        data.mult = data.mult * 0.6
    end
end

att.AttachSound = "arccw_uc/common/gunsmith/internal_modification.ogg"
--lua/arccw/shared/attachments/uc_muzzle_compensator.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_muzzle_supp_masada.lua:
att.PrintName = "Magpul PTS AAC Masada Suppressor"
att.AbbrevName = "Masada Suppressor"
att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_masada.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nReduces recoil by providing extra room for gas expansion."
att.Desc_Neutrals = {"uc.supptail"}

att.AutoStats = true
att.Slot = {"muzzle"}

att.SortOrder = 150

att.Model = "models/weapons/arccw/atts/uc_magpul_masada.mdl"
att.ModelOffset = Vector(2.65, 0, 0)
att.ModelScale = Vector(1.15, 1.15, 1.15)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_Recoil = .9

att.Add_BarrelLength = 5
att.Mult_SightTime = 1.1
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_muzzle_supp_pbs4.lua:
att.PrintName = "PBS-4 Suppressor"

att.Icon = Material("entities/att/acwatt_uc_muzzle_supp_pbs4.png", "mips smooth")
att.Description = "Traps propellant gas from the muzzle, reducing visual and audible report.\nOriginally designed for carbine barrels, this suppressor compensates for inaccuracy, and can be mounted to other barrels with some gunsmithing work."
att.Desc_Neutrals = {"uc.exclusive.545", "uc.supptail"}

att.AutoStats = true
att.AutoStats = true
att.Slot = {"ur_ak_muzzle"}

att.SortOrder = 149

att.Model = "models/weapons/arccw/atts/uc_pbs4.mdl"
att.ModelOffset = Vector(2.9, 0, 0)
att.ModelScale = Vector(1.3, 1.3, 1.3)
att.OffsetAng = Angle(0, 0, 0)

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.IsMuzzleDevice = true

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75
att.Mult_AccuracyMOA = 0.75

att.Add_BarrelLength = 5
att.Mult_SightTime = 1.1
att.Mult_Sway = 1.15

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"

att.Hook_Compatible = function(wep)
    if wep:GetBuff_Override("Override_Ammo", wep.Primary.Ammo) != "smg1" then
        return false
    end
end

att.Hook_GetDistantShootSound = function(wep, distancesound)
    if wep:GetBuff("PhysBulletMuzzleVelocity") < ArcCW.UC.SubsonicThreshold then
        return false
    end
end
--lua/arccw/shared/attachments/uc_muzzle_supp_salvo.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_optic_eotech553.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_optic_nvis.lua:
att.PrintName = "N-Vision HALO-LR Thermal Scope (1-6x)"
att.AbbrevName = "HALO-LR (1-6x)"
att.Icon = Material("entities/att/acwatt_uc_optic_nvis.png", "mips smooth")
att.Description = "Cutting-edge night vision optic that highlights targets via infrared imaging. The complicated electronics result in a massive weight gain for the base weapon."

att.SortOrder = 6

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
    "autostat.thermal"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "Double-tap +USE to toggle imaging modes"
}
att.AutoStats = true
att.Slot = {"optic"}

att.Model = "models/weapons/arccw/atts/uc_nvis.mdl"
att.ModelOffset = Vector(0, 0, 0.18)


att.AdditionalSights = {
    {
        Pos = Vector(-0.035, 6.5, -1.25),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ViewModelFOV = 25,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 3,
        ScopeMagnification = UC_HalfScope( 1.5 ),
        Thermal = true,
        ThermalScopeColor = Color(255, 255, 255),
        ThermalHighlightColor = Color(255, 255, 255),
        ThermalFullColor = false,
        ThermalScopeSimple = false,
        ThermalNoCC = false,
        ThermalBHOT = false,
        IgnoreExtra = true,
        Contrast = 0.51,
        Brightness = 0.1,
        ForceLowRes = true,
        FPSLock = 42,
    },
    {
        Pos = Vector(-0.035, 6.5, -1.25),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ViewModelFOV = 25,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 3,
        ScopeMagnification = UC_HalfScope( 1.5 ),
        Thermal = true,
        ThermalScopeColor = Color(255, 255, 255),
        ThermalHighlightColor = Color(0, 0, 0),
        ThermalFullColor = false,
        ThermalScopeSimple = false,
        ThermalNoCC = false,
        ThermalBHOT = false,
        IgnoreExtra = true,
        Contrast = 0.7,
        Brightness = 0.5,
        ForceLowRes = true,
        FPSLock = 42,
    },
    {
        Pos = Vector(-0.035, 6.5, -1.25),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ViewModelFOV = 25,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ZoomLevels = 3,
        ScopeMagnification = UC_HalfScope( 1.5 ),
        IgnoreExtra = true,
        ForceLowRes = true,
        FPSLock = 42,

        SpecialScopeFunction = function(screen)
            render.PushRenderTarget(screen)

            DrawColorModify({
                ["$pp_colour_addr"] = 0,
                ["$pp_colour_addg"] = 0,
                ["$pp_colour_addb"] = 0,
                ["$pp_colour_brightness"] = 0,
                ["$pp_colour_contrast"] = 1,
                ["$pp_colour_colour"] = 0.75,
                ["$pp_colour_mulr"] = 0,
                ["$pp_colour_mulg"] = 0,
                ["$pp_colour_mulb"] = 0
            })

            render.PopRenderTarget()
        end,
    },
}

att.ScopeGlint = false

att.Holosight = true
att.HolosightReticle = Material("hud/scopes/uc_nvis_reticle1grid.png", "mips smooth")
att.HolosightNoFlare = true
att.HolosightSize = 20
att.HolosightBone = "holosight"
att.HolosightPiece = "models/weapons/arccw/atts/uc_nvis_hsp.mdl"
att.Colorable = false

att.HolosightBlackbox = true

att.HolosightMagnification = UC_HalfScope( 1.5 )
att.HolosightMagnificationMin = UC_HalfScope( 1.5 )
att.HolosightMagnificationMax = UC_HalfScope( 6 )

att.Mult_SightTime = 1.1
att.Mult_SightedSpeedMult = 0.7
att.Mult_Sway = 1.25
--lua/arccw/shared/attachments/uc_optic_pso1.lua:
att.PrintName = "PSO-1 (4x)"
att.AbbrevName = "PSO-1 (4x)"
att.Icon = Material("entities/att/acwatt_uc_optic_pso1.png", "mips smooth")
att.Description = "Medium range combat scope for improved precision at longer ranges.\nExclusive to the \"Warsaw Pact\" optic mount, and is slightly more agile than rail mounted optics."

att.SortOrder = 300

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"ur_ak_optic"}

att.Model = "models/weapons/arccw/atts/ur_pso1.mdl"
att.ModelOffset = Vector(-2, 0, -4.55)

att.AdditionalSights = {
    {
        Pos = Vector(0, 13, -1.5),
        Ang = Angle(0, 0, 0),
        Magnification = 1.25,
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("hud/scopes/uc_pso.png", "mips smooth"),
            HolosightNoFlare = true,
            HolosightSize = 10.5,
            HolosightPiece = "models/weapons/arccw/atts/ur_pso1_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification = UC_HalfScope( 4 ),
            Colorable = true,
        },
    }
}

-- att.Holosight = true
-- att.HolosightReticle = Material("mifl_tarkov_reticle/dot.png", "mips smooth")

att.HolosightPiece = "models/weapons/arccw/atts/ur_pso1_hsp.mdl"
-- att.HolosightNoFlare = true
-- att.HolosightSize = 1
-- att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = .8
att.ExcludeFlags = {"ak_norail","cover_rail"}

--lua/arccw/shared/attachments/uc_tac_flashlight3.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_tp_fastreload.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_tp_overload.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_tp_pointshoot.lua:
att.PrintName = "Point Shooting"

att.Icon = Material("entities/att/arccw_uc_tp_pointshooting.png", "smooth mips")
att.Description = "Dedicated practice at shooting without using the sights has given you the ability to fire from the hip more effectively. If John Rambo can do it, so can you."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_tp"

att.AutoStats = true
att.SortOrder = 6

att.Mult_HipDispersion = 0.75

att.NotForNPCs = true
--lua/arccw/shared/attachments/uc_tp_technician.lua:
return gluapack()()
--lua/arccw/shared/attachments/uc_usp_cal_40sw.lua:
att.PrintName = "USP40 .40 Smith & Wesson Conversion"
att.AbbrevName = ".40 Smith & Wesson"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "P93-40 .40 Smith & Wesson Conversion"
end

att.SortOrder = 8
att.Icon = Material("entities/att/uc_bullets/40sw.png", "smooth mips")
att.Description = "Stubby caliber which the USP was designed around. Retains damage over distance better than other calibers."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "uc_usp_caliber"

att.AutoStats = true

att.Override_Trivia_Calibre = ".40 Smith & Wesson"

att.Mult_Damage = 30 / 45
att.Mult_DamageMin = 23 / 15
att.Mult_Penetration = 8 / 9
att.Mult_RangeMin = 20 / 10

att.Mult_Recoil = 0.85
att.Mult_RecoilSide = 0.75

att.Mult_PhysBulletMuzzleVelocity = 340 / 315

--att.Mult_ClipSize = 13 / 12
att.Add_ClipSize = 1
att.Override_ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
att.Override_ShellScale = 1

att.Override_PhysTracerProfile = 0
att.Override_PhysTracerProfile_Priority = -1
att.Override_TracerNum = 1
att.Override_TracerNum_Priority = -1

local path = ")weapons/arccw_uc_usp/"

att.Hook_GetShootSound = function(wep, sound) -- Temporary
    if wep:GetBuff_Override("Silencer") then
        return {path .. "fire-40-sup-01.ogg", path .. "fire-40-sup-02.ogg", path .. "fire-40-sup-03.ogg", path .. "fire-40-sup-04.ogg", path .. "fire-40-sup-05.ogg", path .. "fire-40-sup-06.ogg"}
    else
        return {path .. "fire-40-01.ogg", path .. "fire-40-02.ogg", path .. "fire-40-03.ogg", path .. "fire-40-04.ogg", path .. "fire-40-05.ogg", path .. "fire-40-06.ogg"}
    end
end

local tail = ")/arccw_uc/common/40sw/"

att.Hook_GetDistantShootSoundOutdoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return {
            tail .. "fire-dist-40sw-pistol-ext-01.ogg",
            tail .. "fire-dist-40sw-pistol-ext-02.ogg",
            tail .. "fire-dist-40sw-pistol-ext-03.ogg",
            tail .. "fire-dist-40sw-pistol-ext-04.ogg",
            tail .. "fire-dist-40sw-pistol-ext-05.ogg",
            tail .. "fire-dist-40sw-pistol-ext-06.ogg"
        }
    end
end

-- att.GivesFlags = {"cal_subsonic"}
-- att.ExcludeFlags = {"powder_subsonic"}
--lua/arccw/shared/attachments/uc_usp_mag_ext.lua:
att.PrintName = "USP 17-Round Magazine Extension"
att.AbbrevName = "17-Round Extended Mag"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "P93 17-Round Magazine Extension"
end

att.SortOrder = 33
att.Icon = Material("entities/att/acwatt_uc_usp_mag_extended.png", "smooth mips")
att.Description = "Aftermarket magazine extension with a thickened base for improved ergonomics. Heavier and throws off weapon balance, but does allow you to fire for longer."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "uc_usp_mag"

att.AutoStats = true

att.Mult_SightTime = 1.1
att.Mult_ReloadTime = 1.15
att.Add_ClipSize = 5

att.Mult_HipDispersion = 1.25
att.Mult_Sway = 1.5
att.Mult_ShootSpeedMult = 0.95

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_ext"
end

--lua/arccw/shared/attachments/uc_usp_sight.lua:
att.PrintName = "Alternative Irons"

att.Icon = Material("entities/att/acwatt_uc_usp_sight.png", "smooth mips")
att.Description = "A set of alternative, taller ironsights."
att.Desc_Neutrals = {
    "uc.cosmetic"
}
att.AutoStats = true 
att.SortOrder = 999

att.Slot = "uc_usp_sight"
--lua/arccw/shared/attachments/ud_870_slide_long.lua:
att.PrintName = "Express-12 Long Forend"
att.AbbrevName = "Long Forend"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Remington 870 Long Forend"
end

att.Icon = Material("entities/att/acwatt_ud_870_slide_long.png", "smooth mips")
att.Description = "Long wood forend for the R870. Additional heft improves grip but is slower to cycle."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_870_slide"

att.AutoStats = true

--att.Mult_SightTime = 1.75
--att.Mult_Recoil = 0.5
--att.Mult_Sway = 3

att.Mult_SightTime = 1.15

att.Mult_Sway = 0.75
att.Mult_Recoil = 0.9
att.Mult_RecoilSide = 0.5

att.Mult_CycleTime = 1.1

att.ActivateElements = {"ud_870_slide_long"}
--lua/arccw/shared/attachments/ud_870_tube_ext.lua:
att.PrintName = "Express-12 8 Shell Tube"
att.AbbrevName = "8 Shell Tube"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Remington 870 8 Shell Tube"
end


att.Icon = Material("entities/att/acwatt_ud_870_tube_ext.png", "smooth mips")
att.Description = "An extension of the default shell tube holds more rounds, but increases weapon weight."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "ud_870_tube"

att.AutoStats = true

att.Override_ClipSize = 8
att.Mult_Sway = 1.5
att.Mult_SightedSpeedMult = 0.8
att.Mult_SightTime = 1.15
att.Mult_ReloadTime = 1.1

att.ActivateElements = {"ud_870_tube_ext"}
--lua/arccw/shared/attachments/ud_870_tube_reduced.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_glock_frame_flared.lua:
att.PrintName = "GEN3 Flared Frame"
att.AbbrevName = "Flared Magwell"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Glock 17 Flared Frame"
end

att.Icon = Material("entities/att/acwatt_ud_glock_frame_flared.png", "smooth mips")
att.Description = "Custom frame with a flared magwell to facilitate faster reloads. The extra weight slows down handling by a bit."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_glock_frame"

att.AutoStats = true

att.Mult_ReloadTime = 0.9
att.Mult_SightTime = 1.1
att.Mult_SightedSpeedMult = 0.95
att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

att.ActivateElements = {"ud_glock_frame_flared"}

-- att.Hook_SelectReloadAnimation = function(wep, anim)
--     if anim == "reload_empty" then
--         return "reload_empty_flared"
--     end
-- end
--lua/arccw/shared/attachments/ud_glock_skin_tan.lua:
att.PrintName = "Glock 17 FDE Polymer Finish"
if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "GEN3 FDE Polymer Finish"
end
att.AbbrevName = "FDE Polymer"
att.Icon = Material("entities/att/acwatt_ud_glock_material.png", "smooth mips")
att.Description = "Flat dark earth finish for your polymer handgun."
att.Desc_Neutrals = {"uc.cosmetic"}
att.Slot = "ud_glock_skin"

--lua/arccw/shared/attachments/ud_glock_slide_comp.lua:
att.PrintName = "GEN3 Competition Slide"
att.AbbrevName = "Competition Slide"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Glock 17 Competition Slide"
end

att.Icon = Material("entities/att/acwatt_ud_glock_slide_comp.png", "smooth mips")
att.Description = "Custom slide with side vents and ring sight. Improves sighting time and straightens recoil."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_glock_slide"

att.AutoStats = true

att.Mult_SightTime = 0.8
att.Mult_RecoilSide = 0.75
att.Mult_Recoil = 1.1

att.ActivateElements = {"ud_glock_slide_comp"}
--lua/arccw/shared/attachments/ud_m1014_barrel_sawn.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m1014_barrel_short.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m1014_stock_gripstock.lua:
att.PrintName = "FC1040 Gripstock"
att.AbbrevName = "Gripstock"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "M4 Super 90 Gripstock"
end


att.Icon = Material("entities/att/acwatt_ud_m1014_stock_buffer.png", "smooth mips")
att.Description = "Solid stock with a pistol grip. Reduces recoil with minimal side effects."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_1014_stock"

att.AutoStats = true

att.Mult_Recoil = .85
att.Mult_SightedSpeedMult = .9
att.Mult_SightTime = 1.1

att.ActivateElements = {"ud_autoshotgun_stock_gripstock"}

--lua/arccw/shared/attachments/ud_m1014_stock_sport.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_charm_ch.lua:
att.PrintName = "Modern Rail Mount"
att.Icon = Material("entities/att/acwatt_ud_m16_charm_ch.png", "smooth mips")
att.Description = "Keep it retro.\nReject flat top. Return to carry handle."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {
    "ud.m16_ch.1",
    "ud.m16_ch.2",
    "ud.m16_nors"
}
att.Slot = "ud_m16_charm"

att.ActivateElements = {"ud_m16_upper_charm"}
att.GivesFlags = {"ud_m16_retro"}
att.ExcludeFlags = {"ud_m16_not_retro", "ud_m16_a1"}
att.TopMount = 1

att.SortOrder = 1001
--lua/arccw/shared/attachments/ud_m16_charm_ch2.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_fs_magpul.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_hg_lmg.lua:
att.PrintName = "AMSAW LMG Handguard"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Colt LMG Handguard"
end

att.AbbrevName = "LMG Handguard"
att.Icon = Material("entities/att/acwatt_ud_m16_hg_lmg.png", "smooth mips")
att.Description = "Heavy duty handguard with built-in bipod and foregrip, sporting improved durability and recoil control for sustained automatic fire."
att.Desc_Pros = {}
att.Desc_Cons = {
    "uc.noubs"
}
att.Desc_Neutrals = {}
att.Slot = "ud_m16_hg"

att.AutoStats = true

att.Mult_SpeedMult = 0.95
att.Mult_SightedSpeedMult = 0.8
att.Mult_Sway = 1.5
att.Mult_SightTime = 1.25

att.Mult_RPM = 0.915
att.Mult_Recoil = 0.7
att.Mult_RecoilSide = 0.5

att.Mult_MalfunctionMean = 2

att.Bipod = true
att.Mult_BipodDispersion = 0.2
att.Mult_BipodRecoil = 0.15

att.ActivateElements = {"hg_lmg"}
att.GivesFlags = {"m16_lmg","hg_no11"}
att.ExcludeFlags = {"blen_11"}

att.LHIK = true

att.Model = "models/weapons/arccw/atts/lmg_lhik.mdl"
att.ModelOffset = (Vector(0.41, 0, -1.63) - Vector(11.5, 2.8, -4.2)) + Vector(-0.1, 0, 0)

--lua/arccw/shared/attachments/ud_m16_hg_ru556.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_hg_wood.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_mag_20.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_m16_mag_20.lua:
att.PrintName = "STANAG 20-Round Compact Mag"
att.AbbrevName = "20-Round Compact Mag"
att.SortOrder = 20
att.Icon = Material("entities/att/acwatt_ud_m16_mag_20.png", "smooth mips")
att.Description = "Original, low-capacity magazine for the M16. The lighter load reduces the weapon's weight and brings back memories of the rice fields."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "ud_m16_mag"

att.AutoStats = true
att.HideIfBlocked = true

att.Override_ClipSize = 20

att.Mult_SightTime = 0.85
att.Mult_ReloadTime = 0.9
att.Mult_Sway = 0.75

att.Mult_SpeedMult = 1.025
att.Mult_SightedSpeedMult = 1.05
att.Mult_ShootSpeedMult = 1.05

att.Mult_MalfunctionMean = 1.5

att.Mult_HipDispersion = 0.75

att.ActivateElements = {"ud_m16_mag_20"}

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_20"
end

att.ExcludeFlags = {"m16_usas", "m16_9mm", "m16_50beo"}
--lua/arccw/shared/attachments/ud_m16_muzzle_605.lua:
att.PrintName = "Model 605 Three-prong"
att.AbbrevName = "M605 Three-prong"
att.Icon = Material("entities/att/acwatt_ud_m16_muzzle_605.png", "mips smooth")
att.Description = ""
att.Desc_Pros = {
    "uc.flashhider"
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = "ud_m16_muzzle"

att.SortOrder = -101

att.Model = "models/weapons/arccw/atts/fesiug_threeprong_605.mdl"
att.ModelOffset = Vector(0.4, 0, 0)
att.ModelScale = Vector(1, 1, 1)
att.OffsetAng = Angle(0, 0, 0)

att.Add_BarrelLength = 4
att.Mult_Sway = 1.1
att.Mult_HipDispersion = 0.9

att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.75

att.AttachSound = "arccw_uc/common/gunsmith/suppressor_thread.ogg"
--lua/arccw/shared/attachments/ud_m16_stock_608.lua:
att.PrintName = "AMCAR 608 Stock"
att.AbbrevName = "M608 Cap Stock"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "M16 Model 608 Stock"
end

att.Icon = Material("entities/att/acwatt_ud_m16_stock_608.png", "smooth mips")
att.Description = "Stock used on the Model 608 survival rifle. Essentially an elongated buffer tube with a cap. Improves point shooting abilities."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_m16_stock"

att.AutoStats = true
att.SortOrder = 4

att.Mult_HipDispersion = 0.75
att.Mult_MoveDispersion = 0.85
att.Mult_SightTime = 1.15
att.Mult_Recoil = 1.25
att.Mult_Sway = 1.5

att.Add_BarrelLength = 0

att.ActivateElements = {"stock_608"}
--lua/arccw/shared/attachments/ud_m16_stock_adar.lua:
att.PrintName = "RUCAR 225 Stock"

att.Icon = Material("entities/att/acwatt_ud_m16_stock_adar.png", "smooth mips")
att.Description = "Wooden fixed stock with integral grip used on the Russian RUCAR 225 rifle. Very steady while aiming and reduces recoil effectively, but quite difficult to manuver with."

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "ADAR 2-15 Stock"
    --att.Description = "Wooden fixed stock with integral grip used on the Russian ADAR 2-15 rifle. The sturdiest stock currently available for the AR platform."
end

att.Desc_Pros = {
    --"uc.auto"
}
att.Desc_Cons = {
    "uc.nogrip"
}
att.Desc_Neutrals = {
}
att.Slot = "ud_m16_stock"
att.SortOrder = 10

att.AutoStats = true

att.Mult_Sway = 0.5
att.Mult_Recoil = 0.8
att.Mult_RecoilSide = 0.75
att.Mult_SpeedMult = 0.95
att.Mult_SightedSpeedMult = .8
att.Mult_SightTime = 1.25

att.ActivateElements = {"stock_adar"}
att.GivesFlags = {"m16_adar"}

local slotinfo = {
    [9] = {"Intergral Grip", "Integral Grip", att.Icon},
}
att.Hook_GetDefaultAttName = function(wep, slot)
    if slotinfo[slot] then
        return GetConVar("arccw_truenames"):GetBool() and slotinfo[slot][2] or slotinfo[slot][1]
    end
end
att.Hook_GetDefaultAttIcon = function(wep, slot)
    if slotinfo[slot] then
        return slotinfo[slot][3]
    end
end
--lua/arccw/shared/attachments/ud_m79_barrel_short.lua:
att.PrintName = "AMSGL Short Tube"
att.AbbrevName = "Short Tube"

if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "M79 Short Tube"
end

att.Icon = Material("entities/att/acwatt_ud_m79_barrel_short.png", "smooth mips")
att.Description = "Nicknamed the 'Pirate Gun' due to its likeliness to a hand cannon, this short barrel improves agility at the cost of precision and projectile range."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.altnofs"
}
att.Desc_Neutrals = {
}
att.Slot = "ud_m79_barrel"

att.LHIK = true

att.Model = "models/weapons/arccw/atts/lhik_short.mdl"

att.AutoStats = true

att.Mult_MuzzleVelocity = 0.5
att.Mult_Recoil = 1.25
att.Mult_AccuracyMOA = 2

att.Mult_MoveDispersion = 0.75
att.Mult_SightTime = 0.75
att.Mult_ReloadTime = 0.85

att.Mult_SpeedMult = 1.01
att.Mult_SightedSpeedMult = 1.05

att.Mult_Sway = 0.75

att.A_Hook_Add_SightsDispersion = function(wep, data)
    if data and !wep.Attachments[1].Installed then
        data.add = data.add + 50
    end
end

att.ActivateElements = {"m79_pirategun"}

att.GivesFlags = {"m79_pirategun"}
--lua/arccw/shared/attachments/ud_mini14_mag_10_762.lua:
att.PrintName = "Mini-30 7.62x39mm 10-Round Flush Mag"
att.AbbrevName = "10-Round Flush Mag"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Patriot 816 7.62x39mm 10-Round Flush Mag"
end

att.SortOrder = 10
att.Icon = Material("entities/att/acwatt_ud_mini14_mag_10.png", "smooth mips")
att.Description = "Low-capacity 7.62mm flush magazine. It is much less likely to jam thanks to the low capaacity."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_mini14_mag"

att.AutoStats = true

att.Mult_SightTime = 0.85
att.Mult_ReloadTime = 0.9
att.Override_ClipSize = 10
att.Mult_Sway = 0.75

att.Mult_MalfunctionMean = 1.5

att.ActivateElements = {"ud_mini14_mag_10"}
att.RequireFlags = {"mini14_762"}
att.HideIfBlocked = true

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_10"
end
--lua/arccw/shared/attachments/ud_mini14_mag_30.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_mini14_receiver_762.lua:
return gluapack()()
--lua/arccw/shared/attachments/ud_mini14_receiver_auto.lua:
att.PrintName = "AC-556 Automatic Receiver"
att.AbbrevName = "Automatic Receiver"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Patriot ACC Automatic Receiver"
end

att.Icon = Material("entities/att/acwatt_ud_mini14_receiver_auto.png", "smooth mips")
att.Description = "Receiver adapted with a military auto sear and fire selector."
att.Desc_Pros = {
    "uc.auto"
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_mini14_receiver"

att.AutoStats = true

att.Override_Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = -3,
        Override_ShotRecoilTable = {
            [1] = 0.9,
            [2] = 0.8,
            [3] = 0.7,
        },
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

att.Override_Trivia_Class = "Assault Rifle"

att.ActivateElements = {"ud_mini14_receiver_auto"}

att.Mult_RPM = 750 / 540

att.Mult_RecoilSide = 1.5
att.Mult_HipDispersion = 1.25
att.Mult_AccuracyMOA = 2
att.Mult_ShootSpeedMult = 0.85
att.Mult_MalfunctionMean = 0.75
att.Mult_MalfunctionVariance = 1.25
--lua/arccw/shared/attachments/ud_mini14_stock_polymer.lua:
att.PrintName = "Mini-14 Polymer Stock"
att.AbbrevName = "Polymer Stock"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Patriot 809 Polymer Stock"
end

att.Icon = Material("entities/att/acwatt_ud_mini14_stock.png", "smooth mips")
att.Description = "A fairly lightweight body replacement that improves weapon agility."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_mini14_stock"

att.AutoStats = true

att.Mult_SightTime = 0.9
att.Mult_SpeedMult = 1.05
att.Mult_SightedSpeedMult = 1.1

att.Mult_Recoil = 1.15
--att.Mult_Sway = 3

-- att.Add_BarrelLength = 32

att.ActivateElements = {"ud_mini14_stock_polymer"}
--lua/arccw/shared/attachments/ud_mini14_stock_tactical_polymer.lua:
att.PrintName = "Mini-14 GB Tactical Stock"
att.AbbrevName = "Tactical Stock"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Patriot 812 Tactical Stock"
end

att.Icon = Material("entities/att/acwatt_ud_mini14_stock_tactical.png", "smooth mips")
att.Description = "A lightweight body replacement that improves weapon handling by combining a polymer chassis and a side-folding stock. Prioritizes speed when aiming the sights at the cost of increased recoil."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
}
att.Slot = "ud_mini14_stock"

att.AutoStats = true

att.Mult_SightTime = 0.75
att.Mult_SpeedMult = 1.05
att.Mult_SightedSpeedMult = 1.2
att.Mult_ShootSpeedMult = 1.1

att.Mult_Recoil = 1.33
att.Mult_Sway = 1.2

-- att.Add_BarrelLength = 32

att.ActivateElements = {"ud_mini14_stock_tactical_polymer"}

att.Ignore = false
--lua/arccw/shared/attachments/ud_uzi_stock_remove.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_1911_grip_pachmayr.lua:
att.PrintName = "M1911 Pachmayr Grip"
att.AbbrevName = "Pachmayr Grip"
att.Icon = Material("entities/att/ur_1911/grip_pach.png","mips smooth")
att.Description = "Aftermarket grip with finger grooves and a pleasant rosewood texture.\nThe finger grooves steadies aim, but is a bit slower to draw."

att.AutoStats = true
att.Slot = "ur_m1911_grip"

att.Mult_Sway = 0.75
att.Mult_Recoil = 0.95
att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25

--lua/arccw/shared/attachments/ur_1911_grip_snake.lua:
att.PrintName = "M1911 Snake Grip"
att.AbbrevName = "Snake Grip"
att.Icon = Material("entities/att/ur_1911/grip_snake.png","mips smooth")
att.Description = "A gaudy grip for those with too much taste and those with too little taste.\nIts rough texture marginally reduces moving spread.\n\n\"Whoever did this is a professional, no question. This thing could shoot a one-hole at 25 yards in a machine rest.\""

att.AutoStats = true
att.Slot = "ur_m1911_grip"

att.Mult_MoveDispersion = 0.9
att.Mult_RecoilSide = 1.15
--lua/arccw/shared/attachments/ur_329_barrel_m29.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_329_barrel_master.lua:
att.PrintName = "7\" Master Barrel"
att.AbbrevName = "7\" Master Barrel"
att.Icon = Material("entities/att/acwatt_ur_329_barrel_master.png","smooth mips")
att.Description = "Huge, imposing barrel with extra frontal weight and precision rifling. Hard to keep steady, but hones accuracy even further."
att.Slot = "ur_329_barrel"
att.AutoStats = true
att.SortOrder = 7

att.Mult_AccuracyMOA = 0.5
att.Mult_Range = 1.6
att.Mult_Recoil = 0.75
att.Mult_SightTime = 1.3
att.Mult_Sway = 1.4
att.Mult_HipDispersion = 1.15
att.Mult_PhysBulletMuzzleVelocity = 1.2
att.Mult_SightedSpeedMult = .8

att.Add_BarrelLength = 5

att.Mult_DrawTime = 1.25
att.Mult_HolsterTime = 1.25
--lua/arccw/shared/attachments/ur_329_barrel_pocket.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_329_caliber_44special.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_barrel_105.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_barrel_vepr.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_cal_366.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_cover_alpha.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_hg_dong.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_mag_545_45.lua:
att.PrintName = "45-Round Extended Mag"
att.Icon = Material("entities/att/ur_ak/magazines/545_45.png", "mips smooth")
att.Description = "Extended magazine for the AK-74. While intended for squad gunners, the extra ammo is useful for any loadout, though the longer mag is noticeably heavier."
att.Slot = {"ur_ak_mag"}
att.AutoStats = true
att.Desc_Cons = {
    "uc.jam"
}

att.SortOrder = 45

att.HideIfBlocked = true

att.Override_ClipSize = 45

att.Mult_SightTime = 1.25
att.Mult_ReloadTime = 1.15
att.Mult_Sway = 1.5
att.Mult_RecoilSide = 1.2
att.Mult_SpeedMult = 0.95
att.Mult_ShootSpeedMult = 0.9

att.Override_Malfunction = true
att.Mult_MalfunctionMean = 0.85
att.Mult_MalfunctionVariance = 1.5

att.Mult_HipDispersion = 1.25

att.ActivateElements = {"mag_545_45"}
att.RequireFlags = {"cal_545"}
--lua/arccw/shared/attachments/ur_ak_mag_545_black.lua:
att.PrintName = "30-Round Black Bakelite Mag"
att.AbbrevName = "30-Round Mag (Black)"
att.Icon = Material("entities/att/ur_ak/magazines/545_30_b.png", "mips smooth")
att.Description = "Identical to the stock magazine, spray-painted black. Might suit your taste better."
att.Slot = {"ur_ak_mag"}
att.AutoStats = true
att.Desc_Neutrals = {
    "uc.cosmetic",
}

att.SortOrder = 99

att.HideIfBlocked = true

att.ActivateElements = {"mag_545_black"}
att.RequireFlags = {"cal_545"}
--lua/arccw/shared/attachments/ur_ak_mag_762_bakelite.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_muzzle_ak74.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_stock_alpha.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_ak_stock_vepr.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_aw_barrel_sd.lua:
att.PrintName = "AWS 28\" Suppressed Barrel"
att.AbbrevName = "28\" SD Barrel"
att.Icon = Material("entities/att/ur_aw/bar_sup.png", "mips smooth")

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "APS 28\" SD Barrel"
end

--att.Icon = Material("entities/att/acwatt_ud_mini14_barrel_long.png", "smooth mips")
att.SortOrder = 28
att.Description = "Integrally suppressed barrel for the Arctic Warfare, designed for use with subsonic ammunition. Very effective for noise reduction, but reduces effective range.\nIncompatible with magnum ammunition."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.nomuzzle"
}
att.Desc_Neutrals = {
}
att.Slot = "ur_aw_barrel"

att.Silencer = true
att.Override_MuzzleEffect = "muzzleflash_suppressed"
att.Mult_ShootPitch = 1.1
att.Mult_ShootVol = 0.6

att.Mult_Range = .85
att.Add_BarrelLength = 3
att.Mult_SightedSpeedMult = 0.85

att.AutoStats = true
att.ExcludeFlags = {"mag_338","mag_300"}
att.ActivateElements = {"barrel_sd"}
att.GivesFlags = {"barrel_sd"}

--lua/arccw/shared/attachments/ur_aw_cal_300.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_aw_cal_300.lua:
att.PrintName = "AWM .300 Winchester Magnum Receiver"
att.AbbrevName = ".300 Winchester Magnum"
att.Icon = Material("entities/att/uc_bullets/300winchester.png", "mips smooth")
att.Description = "Versatile magnum cartridge identical in diameter to 7.62x51mm rounds but with significantly higher muzzle energy. Liable to overpenetration at close range."
att.Slot = "ur_aw_cal"
att.Desc_Pros = {
    --"ur.aw.velocity"
}

att.AutoStats = true

att.Mult_Damage = 50 / 80
att.Mult_DamageMin = 90 / 50
--att.Mult_Range = 2
att.Override_Range = 50
att.Override_RangeMin = 10


att.Mult_PhysBulletMuzzleVelocity = 1000 / 850
-- att.Override_PhysBulletMuzzleVelocity = 1000

att.Mult_Penetration = 1.25
att.Mult_Recoil = 1.5
att.Mult_ReloadTime = 5.55 / 5.15

att.Mult_ShootSpeedMult = 0.9

local path = ")weapons/arccw_ur/aw_placeholders/338/"
local path1 = ")weapons/arccw_ur/aw_placeholders/"

local fire300 = {path .. "fire-01.ogg",path .. "fire-02.ogg",path .. "fire-03.ogg",path .. "fire-04.ogg",path .. "fire-05.ogg",path .. "fire-06.ogg"}
local fire300sup = {path1 .. "fire-sup-01.ogg",path1 .. "fire-sup-02.ogg",path1 .. "fire-sup-03.ogg",path1 .. "fire-sup-04.ogg",path1 .. "fire-sup-05.ogg",path1 .. "fire-sup-06.ogg"}

att.Hook_GetShootSound = function(wep, sound)
    if wep:GetBuff_Override("Silencer") then
        return fire300sup
    else
        return fire300
    end
end

local tail = ")/arccw_uc/common/338lm/"
local fire338dist = {tail .. "fire-dist-338lm-rif-ext-01.ogg", tail .. "fire-dist-338lm-rif-ext-02.ogg", tail .. "fire-dist-338lm-rif-ext-03.ogg", tail .. "fire-dist-338lm-rif-ext-04.ogg", tail .. "fire-dist-338lm-rif-ext-05.ogg", tail .. "fire-dist-338lm-rif-ext-06.ogg"}

att.Hook_GetDistantShootSoundOutdoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return fire338dist
    end
end

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_338"
end

-- local slotinfo = {
--     [5] = {"5-Round Mag", "5-Round Mag", Material("entities/att/ur_aw/mag338_5.png", "mips smooth")},
-- }

-- att.Hook_GetDefaultAttIcon = function(wep, slot)
--     if slotinfo[slot] then
--         return slotinfo[slot][3]
--     end
-- end

att.Override_Trivia_Calibre = ".300 Winchester Magnum"
att.Override_ShellModel = "models/weapons/arccw/ud_shells/338.mdl"
att.Override_Ammo = "SniperPenetratedRound"
att.GivesFlags = {"mag_300"}
--att.ActivateElements = {"mag_338"}
--lua/arccw/shared/attachments/ur_aw_mag_10.lua:
att.PrintName = "AW 10-Round Extended Mag"
att.AbbrevName = "10-Round Extended Mag"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "AP 10-Round Extended Mag"
end

att.SortOrder = 10
att.Icon = Material("entities/att/ur_aw/mag308_10.png", "mips smooth")
att.Description = "Extended magazine for the Arctic Warfare. The extra rounds add weight to the magazine, but allow for twice as many shots to be taken between reloads."
att.Desc_Pros = {}
att.Desc_Neutrals = {}
att.Slot = "ur_aw_mag"

att.AutoStats = true
att.HideIfBlocked = true

att.Override_ClipSize = 10

att.Desc_Cons = {
    --"+ Reload time"
}

att.Mult_SightTime = 1.25
att.Mult_ReloadTime = 5.675 / 5.15 -- compensation for longer anim length
att.Mult_Sway = 1.25

att.Mult_SpeedMult = 0.975
att.Mult_ShootSpeedMult = 0.95

att.Mult_HipDispersion = 1.25

att.ActivateElements = {"mag_ext"}

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_10"
end

att.ExcludeFlags = {"mag_338","mag_300"}
--lua/arccw/shared/attachments/ur_aw_mag_10m.lua:
att.PrintName = "AWM .300 10-Round Extended Mag"
att.AbbrevName = "10-Round Extended Mag"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "AP 10-Round Extended Mag"
end

att.SortOrder = 10
att.Icon = Material("entities/att/ur_aw/mag338_10.png", "mips smooth")
att.Description = "Extended magazine for the Arctic Warfare. The extra rounds add weight to the magazine, but allow for twice as many shots to be taken between reloads."
att.Desc_Pros = {}
att.Desc_Cons = {}
att.Desc_Neutrals = {}
att.Slot = "ur_aw_mag"

att.AutoStats = true

att.HideIfBlocked = true

att.Override_ClipSize = 10

att.Mult_SightTime = 1.25
att.Mult_ReloadTime = 6 / 5.55
att.Mult_Sway = 1.25

att.Mult_SpeedMult = 0.975
att.Mult_ShootSpeedMult = 0.95

att.Mult_HipDispersion = 1.25

att.ActivateElements = {"mag_ext_338"}

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_10_338"
end

att.RequireFlags = {"mag_300"}
att.ExcludeFlags = {"mag_308"}
--lua/arccw/shared/attachments/ur_aw_stock_ru.lua:
att.PrintName = "RU556 Fixed-Adjustable Stock"
att.AbbrevName = "Fixed-Adjustable Stock"

att.Icon = Material("entities/att/ur_aw/stock_ru.png", "mips smooth")
if GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Magpul UBR GEN2 Stock"
end

att.Description = "Polymer stock designed for assault rifles. Unstable, but provides much-needed mobility."
att.Slot = {"ur_aw_stock"}
att.AutoStats = true

att.SortOrder = 2.1

att.Mult_SpeedMult = 1.08
att.Mult_MoveDispersion = .6
att.Mult_SightTime = .9

att.Mult_Sway = 1.5
att.Mult_RecoilSide = 1.5

att.ActivateElements = {"stock_ru"}
att.GivesFlags = {"pistolgrip"}
--lua/arccw/shared/attachments/ur_dbs_stock_sawedoff.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_dbs_tp_doom.lua:
att.PrintName = "The Slayer"
att.Icon = Material("entities/att/acwatt_ur_dbs_tp_doom.png", "smooth mips")
att.Description = "They are rage, brutal, without mercy. But you. You will be worse."
att.Desc_Pros = {
}
att.Desc_Cons = {
}
att.Desc_Neutrals = {
    "uc.cosmetic"
}
att.Slot = "uc_db_tp"

att.AutoStats = true
att.SortOrder = 999

att.LHIK = true
att.LHIKHide = false

att.Override_ActivePos = Vector(-1.5, 0, 1.2)
att.Override_ActivePos_Priority = 10
att.Override_ActiveAng = Angle(0, -0.5, 3)
att.Override_ActiveAng_Priority = 10

att.Free = true
att.IgnorePickX = true

att.RequireFlags = {"sawnoff", "ur_dbs_stock_sawedoff", "uc_tp_gong"}
att.HideIfBlocked = true
--lua/arccw/shared/attachments/ur_deagle_caliber_410.lua:
att.PrintName = "Desert Eagle .410 Bore Conversion"
att.AbbrevName = ".410 Bore"
att.Icon = Material("entities/att/uc_bullets/20g.png","smooth mips")
att.Description = "Hobbyist conversion that allows the weapon to accept .410 bore shotgun shells. Because the weapon was never meant to fire these, performance beyond point blank is poor."

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Predator .410 Bore Conversion"
end
-- Todo: alt shoot sound

att.AutoStats = true
att.Desc_Pros = {
    "ur.deagle.410.1"
}
att.Desc_Cons = {
    "ur.deagle.410.2"
}
att.Slot = "ur_deagle_caliber"
att.SortOrder = -1

att.Override_Num = 4
att.Mult_Range = 0.5
att.Override_AccuracyMOA = 35
att.Override_AccuracyMOA_Priority = 0
att.Mult_ClipSize = 1.15
att.Mult_Recoil = 0.75

att.Mult_Damage = 72 / 70
att.Mult_DamageMin = 20 / 17

att.Override_HullSize = 0.1
att.Override_BodyDamageMults = ArcCW.UC.BodyDamageMults_Shotgun
att.Override_Penetration = 1

--att.Override_Malfunction = true
--att.Mult_MalfunctionVariance = 1.5

att.Override_IsShotgun = true
att.Override_Ammo = "buckshot"
att.Override_ShellModel = "models/weapons/arccw/uc_shells/410bore.mdl"
att.Override_ShellScale = 1
att.Override_ShellSounds = ArcCW.ShotgunShellSoundsTable
att.Override_Trivia_Class = "Shot Pistol"
att.Override_Trivia_Calibre = att.AbbrevName -- E F F I C I E N C Y

local slotinfo = {
    [6] = {"8-Round Mag", "8-Round Mag", Material("entities/att/acwatt_ur_deagle_mag_7.png", "mips smooth")},
    [9] = {"\"BUCK\" #000 Buckshot", "\"BUCK\" #000 Buckshot", Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth")},
}
att.Hook_GetDefaultAttName = function(wep, slot)
    if slotinfo[slot] then
        return GetConVar("arccw_truenames"):GetBool() and slotinfo[slot][2] or slotinfo[slot][1]
    end
end
att.Hook_GetDefaultAttIcon = function(wep, slot)
    if slotinfo[slot] then
        return slotinfo[slot][3]
    end
end
att.Hook_GetShootSound = function(wep, sound)
    if wep:GetBuff_Override("Silencer") then
        return "weapons/arccw_ur/deagle/fire_supp_10.ogg" -- Placeholder
    else
        return {"weapons/arccw_ur/deagle/fire-410-01.ogg", "weapons/arccw_ur/deagle/fire-410-02.ogg", "weapons/arccw_ur/deagle/fire-410-03.ogg", "weapons/arccw_ur/deagle/fire-410-04.ogg", "weapons/arccw_ur/deagle/fire-410-05.ogg", "weapons/arccw_ur/deagle/fire-410-06.ogg"} -- Not Placeholder
    end
end

local tail = ")/arccw_uc/common/357mag/"

att.Hook_GetDistantShootSoundOutdoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return {
            tail .. "fire-dist-357mag-pistol-ext-01.ogg",
            tail .. "fire-dist-357mag-pistol-ext-02.ogg",
            tail .. "fire-dist-357mag-pistol-ext-03.ogg",
            tail .. "fire-dist-357mag-pistol-ext-04.ogg",
            tail .. "fire-dist-357mag-pistol-ext-05.ogg",
            tail .. "fire-dist-357mag-pistol-ext-06.ogg"
        }
    end
end
--lua/arccw/shared/attachments/ur_deagle_caliber_44.lua:
att.PrintName = "Desert Eagle .44 Magnum Conversion"
att.AbbrevName = ".44 Magnum"
att.Icon = Material("entities/att/uc_bullets/44magnum.png","smooth mips")
att.Description = "Smaller (comparatively speaking) caliber that retains most of .50 AE's iconic punch, but is small enough to fit an extra round in the magazine."

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Predator .44 Magnum Conversion"
end
-- Todo: alt shoot sound

att.AutoStats = true
att.Slot = "ur_deagle_caliber"

att.Mult_ClipSize = 1.15
att.Mult_Recoil = 0.85
att.Mult_Damage = 75 / 80
att.Mult_DamageMin = 16 / 12

att.Mult_ShootSpeedMult = 1.1
att.Mult_RPM = 1 + (1/6)

att.Override_Trivia_Calibre = att.AbbrevName -- E F F I C I E N C Y
att.Override_ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
att.Override_ShellScale = 1

local path = ")^weapons/arccw_ur/sw329/"
local fire44 = {path .. "fire-01.ogg", path .. "fire-02.ogg", path .. "fire-03.ogg", path .. "fire-04.ogg", path .. "fire-05.ogg", path .. "fire-06.ogg"}

att.Hook_GetShootSound = function(wep, sound)
    if wep:GetBuff_Override("Silencer") then
        return fire44sup
    else
        return fire44
    end
end

local tail = ")/arccw_uc/common/44mag/"
local fire44dist = {tail .. "fire-dist-44mag-pistol-ext-01.ogg", tail .. "fire-dist-44mag-pistol-ext-02.ogg", tail .. "fire-dist-44mag-pistol-ext-03.ogg", tail .. "fire-dist-44mag-pistol-ext-04.ogg", tail .. "fire-dist-44mag-pistol-ext-05.ogg", tail .. "fire-dist-44mag-pistol-ext-06.ogg"}
local common = ")/arccw_uc/common/"

att.Hook_GetDistantShootSoundOutdoors = function(wep, distancesound)
    if wep:GetBuff_Override("Silencer") then
        -- fallback to script
    else
        return fire44dist
    end
end
--lua/arccw/shared/attachments/ur_deagle_mag_10.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_deagle_skin_chrome.lua:
att.PrintName = "Desert Eagle Polished Chrome Finish"
att.AbbrevName = "Polished Chrome"
if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "Predator Polished Chrome Finish"
end
att.Icon = Material("entities/att/acwatt_ur_deagle_finish_chrome.png","mips smooth")
att.Description = "A luster that demands attention.\n\n\"I had to kill Bob Morton because he made a mistake. Now it's time to erase that mistake.\""
att.Slot = "ur_deagle_skin"
att.Desc_Neutrals = {
    "uc.cosmetic"
}
att.SortOrder = 2

att.IgnorePickX = true
att.ActivateElements = {"ur_deagle_skin_chrome"}
--lua/arccw/shared/attachments/ur_deagle_skin_gold.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_g3_barrel_26.lua:
att.PrintName = "PSG-1 26\" Sniper Barrel"
att.AbbrevName = "26\" Sniper Barrel"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "PMR-2 26\" Sniper Barrel"
end

att.Icon = Material("entities/att/ur_g3/barrel_psg.png","smooth mips")
att.Description = "Long barrel and handguard assembly for the sniper variant of the rifle. Reduces fire rate, but enhances ranged performance greatly.\nDesigned purely for long range usage, this barrel lacks a front sight post."
att.Slot = "ur_g3_barrel"
att.Desc_Cons = {
    "uc.nofs",
}
att.AutoStats = true

att.SortOrder = 26

att.Mult_SightTime = 1.2
att.Add_BarrelLength = 6
att.Mult_SightedSpeedMult = 0.85

att.Mult_Recoil = 0.75
att.Mult_AccuracyMOA = 0.5
att.Mult_RangeMin = 2
att.Mult_Range = 1.25
att.Mult_RPM = 360 / 400

att.A_Hook_Add_SightsDispersion = function(wep, data)
    if data and !wep.Attachments[1].Installed then
        data.add = data.add + 250
    end
end


att.GivesFlags = {"g3_nohg","g3_not8"}
--lua/arccw/shared/attachments/ur_g3_barrel_8.lua:
att.PrintName = "HK51 8\" Compact Barrel"
att.AbbrevName = "8\" Compact Barrel"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "CN102 8\" Blitz Barrel"
    att.AbbrevName = "8\" Blitz Barrel"
end

att.Icon = Material("entities/att/ur_g3/barrel_51.png","smooth mips")
att.Description = "Ridiculously short aftermarket barrel. Colloquially known as a \"flashbang dispenser,\" the tiny barrel drastically increases fire rate - for better and for worse.\n\nThe reduced dimensions are compatible with some MP5 furniture."
att.Slot = "ur_g3_barrel"
att.Desc_Pros = {
    "ur.g3.8"
}
att.AutoStats = true

att.SortOrder = 8

att.Mult_SightTime = 0.85
att.Add_BarrelLength = -6
att.Mult_SightedSpeedMult = 1.2
att.Mult_HipDispersion = 0.75
att.Mult_Sway = 0.5

att.Mult_Recoil = 1.3
att.Mult_AccuracyMOA = 2
att.Mult_Range = 0.35
att.Mult_RPM = 1.2

att.GivesFlags = {"g3_hk51hg"}
--lua/arccw/shared/attachments/ur_g3_optic_sg1.lua:
att.PrintName = "Zeiss Diavari DA 1.5-6x Sniper Scope"
att.AbbrevName = "G3SG/1 Optic (1.5-6x)"

if !GetConVar("arccw_truenames"):GetBool() then
    att.AbbrevName = "SSR Optic (1.5-6x)"
end

att.Icon = Material("entities/att/acwatt_ur_g3_optic_sg1.png", "mips smooth")
att.Description = "Variable power scope, adjustable for a very wide range of magnifications.\nExclusive to the G3 pattern rifle."
-- need icon
att.SortOrder = 300

att.Desc_Pros = {
    "autostat.holosight",
    "autostat.zoom",
}
att.Desc_Cons = {
}
att.AutoStats = true
att.Slot = {"ur_g3_optic"}

att.Model = "models/weapons/arccw/atts/g3_optic_sg1.mdl"
att.ModelOffset = Vector(0.55, 0, -1.7)

att.AdditionalSights = {
    {
        Pos = Vector(0.01, 10.5, -1.18),
        Ang = Angle(0, 0, 0),
        Magnification = 1.1,
        ScrollFunc = ArcCW.SCROLL_ZOOM,
        ScopeMagnificationMin = UC_HalfScope( 1.5 ),
        ScopeMagnificationMax = UC_HalfScope( 6 ),
        ScopeMagnification = UC_HalfScope( 4.5 ),
        HolosightData = {
            Holosight = true,
            HolosightReticle = Material("hud/scopes/SG1_reticle.png", "mips smooth"),
            HolosightNoFlare = true,
            HolosightSize = 9.5,
            HolosightPiece = "models/weapons/arccw/atts/g3_optic_sg1_hsp.mdl",
            HolosightBlackbox = true,
            HolosightMagnification = UC_HalfScope( 4.5 ),
            HolosightMagnificationMin = UC_HalfScope( 1.5 ),
            HolosightMagnificationMax = UC_HalfScope( 6 ),
            Colorable = true,
        },
    }
}

-- att.Holosight = true
-- att.HolosightReticle = Material("mifl_tarkov_reticle/dot.png", "mips smooth")

att.HolosightPiece = "models/weapons/arccw/atts/g3_optic_sg1_hsp.mdl"
-- att.HolosightNoFlare = true
-- att.HolosightSize = 1
-- att.HolosightBone = "holosight"
att.Colorable = true

att.Mult_SightedSpeedMult = 0.78

--lua/arccw/shared/attachments/ur_g3_stock_collapsible.lua:
att.PrintName = "G3 Collapsible Stock" -- I just copied the mp5 collapsible stock for the stats. --that's ok, i probably would have done the same
att.AbbrevName = "Collapsible Stock"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "AG58 Collapsible Stock"
end

att.Icon = Material("entities/att/ur_g3/stock_colap.png","smooth mips")
att.Description = "Lightweight collapsable stock that significantly shortens the rifle when collapsed. Though sturdy for a collapsing stock, acquiring a proper cheek weld is practically impossible, and its felt recoil reduction is poor.\n\nToggling the stock modifies performance accordingly."
att.AutoStats = true
att.Slot = {"ur_g3_stock"}

att.SortOrder = 10

att.Mult_SightTime = 0.75

att.ToggleLockDefault = true
att.ToggleSound = "arccw_uc/common/stockslide.ogg"
att.ToggleStats = {
    {
        PrintName = "Extended",
        ActivateElements = {"stock_g3_collapsible"},
        AutoStats = true,
        Mult_Recoil = 1.2,
    },
    {
        PrintName = "Collapsed",
        ActivateElements = {"stock_g3_collapsed"},
        AutoStats = true,
        Mult_HipDispersion = .8,
        Mult_DrawTime = 0.85,
        Mult_HolsterTime = 0.85,
        Mult_ShootSpeedMult = 1.15,
        Add_BarrelLength = -5,
        Mult_Recoil = 1.5,
        Mult_RecoilSide = 1.25,
        Mult_Sway = 3,
    }
}
--lua/arccw/shared/attachments/ur_mp5_barrel_kurz.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_mag_50.lua:
att.PrintName = "MP5 50-Round Drum Magazine"
att.AbbrevName = "50-Round Drum Mag"

if !GetConVar("arccw_truenames"):GetBool() then
    att.PrintName = "PK5 50-Round Drum Magazine"
end


att.SortOrder = 10
att.Icon = Material("entities/att/ur_mp5/mag50.png", "smooth mips")
att.Description = "Drum magazine with a 50-round capacity. Compact and reliable as far as drum magazines come, but still prone to jamming and ergonomics problems."
att.Desc_Pros = {
}
att.Desc_Cons = {
    "uc.jam"
}
att.Desc_Neutrals = {
}
att.Slot = "ur_mp5_mag"

att.AutoStats = true


att.Override_ClipSize = 50

att.Mult_SightTime = 1.25
--att.Mult_Recoil = 0.9
att.Mult_ReloadTime = 1.15
att.Mult_SpeedMult = 0.93
att.Mult_DrawTime = 1.2
att.Mult_HolsterTime = 1.2
att.Mult_Sway = 1.7
--att.Mult_ShootSpeedMult = 0.85
--att.Override_Jamming = true
att.Override_Malfunction = true
att.Mult_MalfunctionMean = 0.85
att.Mult_MalfunctionVariance = 1.5

att.Mult_HipDispersion = 1.5

att.ActivateElements = {"ur_mp5_50_mag"}
att.ExcludeFlags = {"ur_mp5_cal_10mm","ur_mp5_cal_40sw"}

att.Hook_SelectReloadAnimation = function(wep, anim)
    return anim .. "_drum"
end
--lua/arccw/shared/attachments/ur_mp5_optic_alt.lua:
return gluapack()()
--lua/arccw/shared/attachments/ur_mp5_stock_ump.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/shared/sh_localization.lua:
if SERVER and game.SinglePlayer() then
    util.AddNetworkString("arccw_sp_reloadlangs")
end

ArcCW.LangTable = ArcCW.LangTable or {}
-- Converts raw string to a lang phrase. not case sensitive.
ArcCW.StringToLang = {
    -- Class
    ["pistol"] = "class.pistol",
    ["revolver"] = "class.revolver",
    ["machine pistol"] = "class.machinepistol",

    ["submachine gun"] = "class.smg", -- Preferred
    ["sub-machine gun"] = "class.smg",
    ["smg"] = "class.smg",

    ["personal defense weapon"] = "class.pdw", -- Preferred
    ["pdw"] = "class.pdw",

    ["shotgun"] = "class.shotgun",

    ["assault carbine"] = "class.assaultcarbine",
    ["carbine"] = "class.carbine",
    ["assault rifle"] = "class.assaultrifle",
    ["rifle"] = "class.rifle",

    ["battle rifle"] = "class.battlerifle",
    ["designated marksman rifle"] = "class.dmr",
    ["dmr"] = "class.dmr", -- Preferred
    ["sniper rifle"] = "class.sniperrifle", -- Preferred
    ["sniper"] = "class.sniperrifle",

    ["antimateriel rifle"] = "class.antimaterielrifle", -- Preferred
    ["antimaterial rifle"] = "class.antimaterielrifle",
    ["anti-material rifle"] = "class.antimaterielrifle",
    ["rocket launcher"] = "class.rocketlauncher",

    ["hand grenade"] = "class.grenade", -- Preferred
    ["grenade"] = "class.grenade",
    ["melee weapon"] = "class.melee", -- Preferred

    -- Attachment Slot
    ["optic"] = "attslot.optic",
    ["backup optic"] = "attslot.bkoptic",
    ["muzzle"] = "attslot.muzzle",
    ["barrel"] = "attslot.barrel",
    ["choke"] = "attslot.choke",
    ["underbarrel"] = "attslot.underbarrel",
    ["tactical"] = "attslot.tactical",
    ["grip"] = "attslot.grip",
    ["stock"] = "attslot.stock",
    ["fire group"] = "attslot.fcg",
    ["ammo type"] = "attslot.ammo",
    ["perk"] = "attslot.perk",
    ["charm"] = "attslot.charm",
    ["skin"] = "attslot.skin",
    ["magazine"] = "attslot.magazine",
    ["slide"] = "attslot.slide",

    ["iron sights"] = "attslot.optic.default",
    ["ironsights"] = "attslot.optic.default",
    ["standard barrel"] = "attslot.barrel.default",
    ["standard choke"] = "attslot.choke.default",
    ["standard muzzle"] = "attslot.muzzle.default",
    ["standard grip"] = "attslot.grip.default",
    ["standard stock"] = "attslot.stock.default",
    ["no stock"] = "attslot.stock.none",
    ["standard fcg"] = "attslot.fcg.default",
    ["standard magazine"] = "attslot.magazine.default",
}

-- Helper function for getting the overwrite or default language
function ArcCW.GetLanguage()
    local l = ArcCW.ConVars["language"] and string.lower(ArcCW.ConVars["language"]:GetString())
    if !l or l == "" then l = string.lower(GetConVar("gmod_language"):GetString()) end
    return l
end

-- Adds a string to the StringToLang table.
function ArcCW.AddStringToLang(str, phrase)
    if phrase == nil or phrase == "" or str == nil or str == "" then return nil end
    ArcCW.StringToLang[string.lower(str)] = phrase
end

-- Retrieves a lang phrase from a string. If the string is a phrase itself, it will be returned.
function ArcCW.GetPhraseFromString(str)
    if str == nil or str == "" then return nil end
    if ArcCW.StringToLang[string.lower(str)] then
        return ArcCW.StringToLang[string.lower(str)]
    end
    if ArcCW.LangTable["en"][string.lower(str)] then
        return string.lower(str)
    end
    return nil
end

-- Gets a translated string from a phrase. Will attempt to fallback to English.
-- Returns nil if no such phrase exists.
function ArcCW.GetTranslation(phrase, format)
    if phrase == nil or phrase == "" then return nil end
    local lang = ArcCW.GetLanguage()
    if !lang or lang == "" or !ArcCW.LangTable[lang] or !ArcCW.LangTable[lang][phrase] then
        lang = "en"
    end
    if ArcCW.LangTable[lang] and ArcCW.LangTable[lang][phrase] then
        local str = ArcCW.LangTable[lang][phrase]
        for i, v in pairs(format or {}) do
            -- print(i, v)
            str = string.Replace(str, "{" .. i .. "}", v)
        end
        return str
    end
    return nil
end

-- Attempts to translate a string (could be either a raw string or a phrase).
-- If fail, return the string itself.
function ArcCW.TryTranslation(str, format)
    if !str then return nil end
    local phrase = ArcCW.GetPhraseFromString(str)
    if !phrase then return str end

    return ArcCW.GetTranslation(phrase, format) or str
end

-- Adds a translated string for a specific language's phrase. lang defaults to English.
function ArcCW.AddTranslation(phrase, str, lang)
    if phrase == nil or phrase == "" or str == nil or str == "" then return nil end
    lang = lang and string.lower(lang) or "en"
    ArcCW.LangTable[lang] = ArcCW.LangTable[lang] or {}
    ArcCW.LangTable[lang][string.lower(phrase)] = str
end

-- Translates an ammo string. If enabled, we will use our custom names (pulse -> rifle, smg -> carbine);
-- Otherwise returns the in-game translation for it.
function ArcCW.TranslateAmmo(ammo)
    if isnumber(ammo) then ammo = game.GetAmmoName(ammo) end
    if !ammo or !isstring(ammo) then return nil end
    ammo = string.lower(ammo)

    local lang = ArcCW.GetLanguage()
    local str = "ammo." .. ammo
    if SERVER or ArcCW.ConVars["ammonames"]:GetBool() then
        if ArcCW.LangTable[lang] and ArcCW.LangTable[lang][str] then
            return ArcCW.LangTable[lang][str]
        elseif ArcCW.LangTable["en"][str] then
            return ArcCW.LangTable["en"][str]
        end
    end
    return SERVER and (ammo .. " ammo") or language.GetPhrase(ammo .. "_ammo")
end

if CLIENT then
    function ArcCW.LoadClientLanguage(files)
        local lang = ArcCW.GetLanguage()
        files = files or file.Find("arccw/client/cl_languages/*", "LUA")

        local lang_tbl = {}
        local lang_tbl_en = {}

        for _, v in pairs(files) do
            local exp = string.Explode("_", string.lower(string.Replace(v, ".lua", "")))
            if lang != "en" and exp[#exp] == lang then
                include("arccw/client/cl_languages/" .. v)
                for phrase, str in pairs(L) do
                    lang_tbl[phrase] = str
                end
                print("Loaded ArcCW cl_language file " .. v .. " with " .. table.Count(L) .. " strings.")
                L = nil
            elseif exp[#exp] == "en" then
                -- Always load english as backup
                include("arccw/client/cl_languages/" .. v)
                for phrase, str in pairs(L) do
                    lang_tbl_en[phrase] = str
                end
            end
        end
        table.Merge(lang_tbl_en, lang_tbl)
        for phrase, str in pairs(lang_tbl_en) do
            language.Add(phrase, str)
        end
    end
elseif SERVER then
    for _, v in pairs(file.Find("arccw/client/cl_languages/*", "LUA")) do
        AddCSLuaFile("arccw/client/cl_languages/" .. v)
    end
end

function ArcCW.LoadLanguages()
    ArcCW.LangTable = {}
    for _, v in pairs(file.Find("arccw/shared/languages/*", "LUA")) do
        include("arccw/shared/languages/" .. v)
        AddCSLuaFile("arccw/shared/languages/" .. v)

        local exp = string.Explode("_", string.lower(string.Replace(v, ".lua", "")))
        local lang = exp[#exp]

        if !lang then
            print("Failed to load ArcCW language file " .. v .. ", did not get language name (naming convention incorrect?)")
            continue
        elseif !L then
            print("Failed to load ArcCW language file " .. v .. ", did not get language table")
            continue
        end

        for phrase, str in pairs(L) do
            ArcCW.AddTranslation(phrase, str, lang)
        end

        -- Load StringToLang stuff incase it is needed
        if STL then
            for str, phrase in pairs(STL) do
                ArcCW.AddStringToLang(str, phrase)
            end
        end

        print("Loaded ArcCW language file " .. v .. " with " .. table.Count(L) .. " strings.")
        L = nil
        STL = nil
    end

    if CLIENT then
        ArcCW.LoadClientLanguage()
    end

    hook.Run("ArcCW_LocalizationLoaded")
end

ArcCW.LoadLanguages()
hook.Add("PreGamemodeLoaded", "ArcCW_Lang", function()
    if CLIENT and ArcCW.ConVars["ammonames"]:GetBool() then
        local ourlang = ArcCW.GetLanguage()
        for _, name in pairs(game.GetAmmoTypes()) do
            if ArcCW.LangTable[ourlang] and ArcCW.LangTable[ourlang]["ammo." .. string.lower(name)] then
                language.Add(name .. "_ammo", ArcCW.LangTable[ourlang]["ammo." .. string.lower(name)])
            elseif ArcCW.LangTable["en"]["ammo." .. string.lower(name)] then
                language.Add(name .. "_ammo", ArcCW.LangTable["en"]["ammo." .. string.lower(name)])
            end
        end
    end
end)

concommand.Add("arccw_reloadlangs", function(ply)
    if SERVER and !game.SinglePlayer() and IsValid(ply) and !ply:IsSuperAdmin() then return end

    ArcCW.LoadLanguages()
    if SERVER and game.SinglePlayer() then
        net.Start("arccw_sp_reloadlangs")
        net.Broadcast()
    end
end, nil, "Reloads all language files.")

if game.SinglePlayer() then
    net.Receive("arccw_sp_reloadlangs", function()
        ArcCW.LoadLanguages()
    end)
end

--addons/[binbon]arccw_modify/lua/arccw/shared/languages/base_en.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/shared/sh_truenames.lua:
hook.Add("CreateTeams", "ArcCW_TrueNames", function()
    if !ArcCW.ConVars["truenames"]:GetBool() then return end

    for _, i in pairs(weapons.GetList()) do
        local wpn = weapons.GetStored(i.ClassName)

        if wpn.TrueName then
            wpn.PrintName = wpn.TrueName
        end
    end
end)
--addons/[binbon]arccw_modify/lua/arccw/client/cl_blacklist.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/client/cl_convars.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/arccw/client/cl_convars.lua:
--[[
    ClientConVars table doc:
    name = data:
    def  - default value
    desc - description of var
    min  - minimum value
    max  - maximum value
    usri - userinfo
    save - whether to save (default true)
]]

ArcCW.ClientConVars = {
    ["arccw_bullet_imaginary"]        = { def = 1 },

    ["arccw_crosshair"]               = { def = 1 },
    ["arccw_crosshair_clr_r"]         = { def = 255 },
    ["arccw_crosshair_clr_g"]         = { def = 255 },
    ["arccw_crosshair_clr_b"]         = { def = 255 },
    ["arccw_crosshair_clr_a"]         = { def = 255 },
    ["arccw_crosshair_length"]        = { def = 4 },
    ["arccw_crosshair_thickness"]     = { def = 1 },
    ["arccw_crosshair_gap"]           = { def = 1 },
    ["arccw_crosshair_static"]        = { def = 0 },
    ["arccw_crosshair_clump"]         = { def = 0 },
    ["arccw_crosshair_clump_outline"] = { def = 0 },
    ["arccw_crosshair_clump_always"]  = { def = 0 },
    ["arccw_crosshair_outline"]       = { def = 2 },
    ["arccw_crosshair_outline_r"]     = { def = 0 },
    ["arccw_crosshair_outline_g"]     = { def = 0 },
    ["arccw_crosshair_outline_b"]     = { def = 0 },
    ["arccw_crosshair_outline_a"]     = { def = 255 },
    ["arccw_crosshair_dot"]           = { def =  1 },
    ["arccw_crosshair_shotgun"]       = { def =  1 },
    ["arccw_crosshair_equip"]         = { def =  1 },
    ["arccw_crosshair_aa"]            = { def =  1 },
    ["arccw_crosshair_trueaim"]       = { def =  0 },
    ["arccw_crosshair_prong_top"]     = { def =  1 },
    ["arccw_crosshair_prong_left"]    = { def =  1 },
    ["arccw_crosshair_prong_right"]   = { def =  1 },
    ["arccw_crosshair_prong_bottom"]  = { def =  1 },
    ["arccw_crosshair_tilt"]    = { def =  0 },

    ["arccw_attinv_simpleproscons"]   = { def =  0 },
    ["arccw_attinv_onlyinspect"]      = { def =  0 },
    ["arccw_attinv_hideunowned"]      = { def =  0 },
    ["arccw_attinv_darkunowned"]      = { def =  0 },
    ["arccw_attinv_closeonhurt"]      = { def =  0, usri = true },
    ["arccw_attinv_gamemodebuttons"]  = { def =  1 },

    ["arccw_language"]                = { def =  "", usri = true },
    ["arccw_font"]                    = { def =  "", usri = true },
    ["arccw_ammonames"]               = { def =  0 },

    ["arccw_cheapscopes"]             = { def =  1 },
    ["arccw_cheapscopesv2_ratio"]     = { def =  0.05 },
    ["arccw_scopepp"]                 = { def =  1 },
    ["arccw_thermalpp"]               = { def =  1 },
    ["arccw_scopepp_refract"]         = { def =  0 },
    ["arccw_scopepp_refract_ratio"]   = { def =  0.75 },

    ["arccw_cheapscopesautoconfig"]   = { def =  0 }, -- what this for

    --["arccw_flatscopes"]              = { def = 0 },

    ["arccw_shake"]                   = { def =  1 },
    ["arccw_shakevm"]                 = { def =  1 },
    ["arccw_muzzleeffects"]           = { def =  1 },
    ["arccw_shelleffects"]            = { def =  1 },
    ["arccw_shelltime"]               = { def =  0 },
    ["arccw_att_showothers"]          = { def =  1 },
    ["arccw_att_showground"]          = { def =  1 },
    ["arccw_visibility"]              = { def =  8000 },
    ["arccw_fastmuzzles"]             = { def =  0 },
    ["arccw_fasttracers"]             = { def =  0 },

    ["arccw_2d3d"]                    = { def =  1, min = 0, max = 2},

    ["arccw_hud_3dfun"]               = { def =  0, usri = true },
    ["arccw_hud_3dfun_lite"]          = { def =  0 },
    ["arccw_hud_3dfun_ammotype"]      = { def =  0 },
    ["arccw_hud_forceshow"]           = { def =  0 },
    ["arccw_hud_fcgbars"]             = { def =  1, desc = "Draw firemode bars on ammo HUD." },
    ["arccw_hud_fcgabbrev"]           = { def =  0, desc = "Use shortened firemode names."},
    ["arccw_hud_minimal"]             = { def =  1, desc = "Backup HUD if we cannot draw the ammo HUD." },
    ["arccw_hud_embracetradition"]    = { def =  0, desc = "Use the classic customization HUD." },
    ["arccw_hud_deadzone_x"]          = { def =  0 },
    ["arccw_hud_deadzone_y"]          = { def =  0 },
    ["arccw_hud_3dfun_decaytime"]     = { def =  3 },
    ["arccw_hud_3dfun_right"]         = { def =  2 },
    ["arccw_hud_3dfun_up"]            = { def =  1 },
    ["arccw_hud_3dfun_forward"]       = { def =  0 },
    ["arccw_hud_size"]                = { def =  1 },

    ["arccw_cust_sounds"]             = { def =  1, desc = "Play sounds when opening and closing the customization menu." },

    ["arccw_scope_r"]                 = { def =  255 },
    ["arccw_scope_g"]                 = { def =  0 },
    ["arccw_scope_b"]                 = { def =  0 },

    ["arccw_blur"]                    = { def =  0 },
    ["arccw_blur_toytown"]            = { def =  1 },

    ["arccw_adjustsensthreshold"]     = { def =  0 },

    ["arccw_drawbarrel"]              = { def =  0 },

    ["arccw_glare"]                   = { def =  1 },
    ["arccw_autosave"]                = { def =  1 },

    ["arccw_vm_right"]                = { def =  0 },
    ["arccw_vm_up"]                   = { def =  0 },
    ["arccw_vm_forward"]              = { def =  0 },
    ["arccw_vm_pitch"]                = { def =  0 },
    ["arccw_vm_yaw"]                  = { def =  0 },
    ["arccw_vm_roll"]                 = { def =  0 },
    ["arccw_vm_fov"]                  = { def =  0, usri = true },
    ["arccw_vm_add_ads"]              = { def =  0},
    ["arccw_vm_coolsway"]             = { def =  1 },
    ["arccw_vm_coolview"]             = { def =  1 },
    ["arccw_vm_coolview_mult"]        = { def =  1 },
    ["arccw_vm_look_xmult"]           = { def =  1 },
    ["arccw_vm_look_ymult"]           = { def =  1 },
    ["arccw_vm_sway_xmult"]           = { def =  1 },
    ["arccw_vm_sway_ymult"]           = { def =  1 },
    ["arccw_vm_sway_zmult"]           = { def =  1 },

    ["arccw_vm_sway_speedmult"]       = { def =  1 },
    ["arccw_vm_nearwall"]             = { def =  1 },

    ["arccw_toggleads"]               = { def = 0, usri = true },
    ["arccw_altbindsonly"]            = { def = 0, usri = true },
    ["arccw_altsafety"]               = { def = 0, usri = true },
    ["arccw_automaticreload"]         = { def = 0, usri = true },

    ["arccw_nohl2flash"]              = { def = 0, usri = true },

    ["arccw_aimassist_cl"]            = { def = 0, usri = true },

    ["arccw_dev_benchgun"]            = { def = 0, save = false },
    ["arccw_dev_benchgun_custom"]     = { def = "", save = false },

    ["arccw_dev_removeonclose"]       = { def = 0, desc = "Remove the hud when closing instead of fading out, allowing easy reloading of the hud.", save = false },
    ["arccw_noinspect"]               = { def = 0, usri = true },

    ["arccw_dev_crosshair"]           = { def = 0, save = false },
}

for name, data in pairs(ArcCW.ClientConVars) do
    ArcCW.ConVars[string.sub(name, 7)] = CreateClientConVar(name, data.def, data.save == nil and true or data.save, data.usri or false, data.desc, data.min, data.max)
end

-- CreateClientConVar("arccw_quicknade", KEY_G)

--addons/[binbon]arccw_modify/lua/arccw/client/cl_vrmod.lua:
local function addmenu()
    if !vrmod then return end

    vrmod.AddInGameMenuItem("ArcCW Customize", 3, 1, function()
        local wep = LocalPlayer():GetActiveWeapon()

        if !IsValid(wep) or !wep.ArcCW then return end

        wep:ToggleCustomizeHUD(!IsValid(ArcCW.InvHUD))
    end)
end

hook.Add("VRMod_Start", "ArcCW", addmenu)
--lua/autorun/arccw_fml_eft_mdr.lua:
return gluapack()()
--addons/policearmorylocker/lua/autorun/armory_locker_initialize.lua:
return gluapack()()
--addons/policearmorylocker/lua/armory_locker/client/armory_locker_client.lua:
return gluapack()()
--addons/policearmorylocker/lua/armory_locker/shared/armory_locker_config.lua:
CH_Armory_Locker = {}
CH_Armory_Locker.Config = {}
CH_Armory_Locker.Design = {}

-- TEAM CONFIGURATION
CH_Armory_Locker.Config.GovernmentTeams = { -- These are your government teams. They will receive messages of robbery and can access the police locker. Use the actual team name, as shown below.

}

CH_Armory_Locker.Config.AllowedTeams = { -- These are the teams that are allowed to rob the armory.

}

-- General Config
CH_Armory_Locker.Config.WeaponsArmoryEnabled = true -- Should the weapon armory for police jobs be enabled or not? true/false option. [Default = true]
CH_Armory_Locker.Config.RetrieveCooldown = 0.1 -- Amount of minutes between being able to retrieve a weapon from the police armory as a government official. [Default = 5]
CH_Armory_Locker.Config.PoliceKillRobberReward = 2000 -- Amount of money police officers get when killing someone that is lockpicking the armory. [Default = 1250]
CH_Armory_Locker.Config.KillRobberReward = 250 -- Amount of money anyone else get when killing someone that is lockpicking the armory. [Default = 250]

-- Lockpicking Config
CH_Armory_Locker.Config.LockpickTime = 1 -- Amount of seconds to lockpick the armory. [Default = 15]
CH_Armory_Locker.Config.LockpickCooldown = 2 -- Amount of seconds after having lockpicked a door, before being able to lockpick another door. [Default = 60]
CH_Armory_Locker.Config.DoorCooldown = 120 -- Amount of seconds a door is on a cooldown after being lockpicked. The above config still applies for the individual user. [Default = 120]
CH_Armory_Locker.Config.NotifyPolice = true -- Should police jobs be notified when someone has lockpicked the armory and leaves? true/false.

-- Display 3D2D Config
CH_Armory_Locker.Config.DisplayHeaderText = true -- Should the text above the armory be displayed?
CH_Armory_Locker.Config.HeaderText = "Polis Cephaneliği" -- Header text above armory/locker.
CH_Armory_Locker.Config.DistanceToHeader = 1000 -- Distance between player and police locker before the title appears.
CH_Armory_Locker.Config.DistanceToIcons = 500 -- Distance before lockpick/cooldown icons appear.

CH_Armory_Locker.Design.ArmoryHeaderColor = Color( 48, 151, 209, 255 ) -- Header text color (gmodstore blue color)
CH_Armory_Locker.Design.ArmoryHeaderBoarder = Color( 0, 0, 0, 255 ) -- Header text boarder color

-- DEFAULT ARMORY WEAPONS
CH_Armory_Locker.Weapons = {
	{ Weapon = "arccw_ud_m4a1", Name = "M4A1" , level = 10, Desc = "weapon", EntType = "weapon", Model = "models/weapons/w_rif_m4a1.mdl", AmmoType = "SniperRound", AmmoAmt = 100 },
	 { Weapon = "arccw_ur_mp5kpdw", Name = "MP5PK" , level = 5, Desc = "weapon", EntType = "weapon", Model = "models/weapons/w_smg_mp5.mdl", AmmoType = "SniperRound", AmmoAmt = 100 },
	 { Weapon = "arccw_ur_deagle", Name = "DEAGLE" , level = 4, Desc = "weapon", EntType = "weapon", Model = "models/weapons/arccw/c_ud_deagle.mdl", AmmoType = "SniperRound", AmmoAmt = 100 },
	{ Weapon = "armor_100",  level = 7, Name = "Zırh", Desc = "100 Zırh.", EntType = "armor", Model = "models/Items/combine_rifle_ammo01.mdl", AmmoType = "none", AmmoAmt = 100 },
    { Weapon = "health_25", level = 2 ,Name = "Sağlık Kiti (25)", Desc = "25 can.", EntType = "health", Model = "models/craphead_scripts/ocrp2/props_meow/weapons/w_medpack.mdl", AmmoType = "none", AmmoAmt = 25 },

}
--addons/ashop/lua/ashop/code/_kernel/sh_permissions.lua:
function ashop.PermissionCreate(name, minAccess, desc)
    CAMI.RegisterPrivilege({
        Name = name,
        MinAccess = minAccess,
        Description = desc
    })
end
--addons/ashop/lua/ashop/code/gamemodes/currencies/integrations/sh_chcrypto.lua:
hook.Add("InitPostEntity", "AShop_Crypto", function()
    if CH_CryptoCurrencies then
        for index, crypto in ipairs( CH_CryptoCurrencies.Config.Currencies ) do
            ashop.currencies.RegisterCurrency("Crypto - " .. crypto.Name, function(ply, amt)
                CH_CryptoCurrencies.GiveCrypto( ply, crypto.Currency, amt )
            end, function(ply)
                return ply.CH_CryptoCurrencies_Wallet[ index ]
            end, function(amt)
                return string.format( "%f", amt ) .. " ".. crypto.Currency
            end)
        end
    end
end)

--addons/ashop/lua/ashop/code/gamemodes/currencies/integrations/sh_flux.lua:
// You won't find this gamemode online, it's my private gm
hook.Add("Flux_LoadedGamemode", "AShop_LoadGMFlux", function()
    ashop.currencies.RegisterCurrency("Flux", function(ply, amt)
        ply:ChangeMoney(amt)
    end, function(ply)
        return ply:GetMoney()
    end, function(amt)
        return Flux:FormatMoney(amt)
    end)
end)
--addons/ashop/lua/ashop/code/gamemodes/currencies/integrations/sh_nutscript.lua:
hook.Add("PostGamemodeLoaded", "AShop_GR_Nut", function()
    if nut then
        ashop.currencies.RegisterCurrency("Nutscript", function(ply, amt)
            local c = ply:getChar()
            c:SetMoney(c:getMoney() + amt)
        end, function(ply)
            return ply:getChar():getMoney()
        end, function(amt)
            return nut.currency.get(amt)
        end)
    end
end)

--addons/ashop/lua/ashop/code/logs/sh_init.lua:
ashop.Logs = ashop.Logs or {}

ashop.Logs.CountPerPage = 17
ashop.Logs.IDs = {
    BuyItem = 1,
    BuyItemOffline = 2,

    ChangeUserMetadata = 3,
    ChangeMoney = 4,
    ChangeMoney_Offline = 7,

    RankGroupCreateBy = 5,
    RankGroupEditBy = 6,
    RankGroupDelete = 8,

    Rarity_Delete = 9,
    Rarity_Create = 10,

    Item_Delete = 11,
    Item_Update = 12,
    Item_Create = 36,

    ObjectType_Create = 13,
    ObjectType_Update = 14, //
    ObjectType_Delete = 15,

    Render_Edit = 16,
    Render_Create = 17,
    Render_Delete = 18,

    Pac3_Create = 19,
    Pac3_Update = 20,
    Pac3_Delete = 21,

    Currency_Used = 22,
    Currency_New = 23,
    Currency_Update = 24,
    Currency_Delete = 25,

    AdminInventory_Read = 26,
    AdminInventory_EditMoney = 27,
    AdminInventory_EditMoneyPremium = 37,
    AdminInventory_AddItem = 28,
    AdminInventory_RemoveItem = 29,
    AdminInventory_RemoveItemOffline = 38,

    WeaponMaterial_Update = 30,
    WeaponMaterial_Delete = 31,
    WeaponMaterial_Create = 32,

    RankPromotion_Create = 33,
    RankPromotion_Update = 34,
    RankPromotion_Delete = 35,

    CarMaterial_Update = 39,
    CarMaterial_Delete = 40,
    CarMaterial_Create = 41,
}
--addons/ashop/lua/ashop/code/object_types/badges/cl_b.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = "Badges"
OBJECT_TYPE.UniqueIdentifier = "Badges"

function ashop.GetPlayerBadges(ply)
    local t = {}

    assert(IsValid(ply), 'Calling ashop.GetPlayerBadges without valid ply')

    if !ply.ashop_data or !ply.ashop_data.equipped then return t end

    local succ, id, tbl = pcall(ashop.GetObjectTypeIDByUID, "Badges")
    if !succ then return t end
    if !ply.ashop_data or !ply.ashop_data.equipped or !ply.ashop_data.equipped[id] then return t end


    for _, plyItemID in pairs(ply.ashop_data.equipped[id][0]) do
        local plyItem = ply.ashop_data.items[plyItemID]
        assert(plyItem, "Missing plyItem, while being equipped")

        local item = ashop.items[plyItem.item_id]
        local mat

        local ptrTbl = {
            name = item.name,
            desc = item.metadata[2],
            mat = function()
                return mat
            end,
        }

        ashop.ui.setMaterialByLink(item.metadata[1], nil, function(m)
            // Be cool with devs, don't make a painful api, even if this is a bit ugly
            if isfunction(m) then
                ptrTbl.mat = m
            else
                mat = m
            end
        end, 'UnlitGeneric')

        table.insert(t, ptrTbl)
    end

    return t
end

function OBJECT_TYPE.UI_FILL(plyItem, item, pnl, parent, w, h, noCircle)
    local circleParent = vgui.Create("EditablePanel", pnl)
    circleParent:SetSize(w, h)

    local c = math.min(math.max(w, h) * 0.6, 64)
    local sub = vgui.Create("EditablePanel", circleParent)
    sub:SetSize(c, c)
    sub:Center()

    local mat
    ashop.ui.setMaterialByLink(item.metadata[1], nil, function(fMat)
        mat = fMat
    end, 'UnlitGeneric')

    local r1
    function sub:Paint(w, h)
        if !r1 then
            r1 = ashop.ui.RoundedBox(ashop.Config.round, 0, 0, w, h)
        end

        if !mat then return end

        ashop.StartStencil()
            surface.SetDrawColor(1,1,1,1)
            draw.NoTexture()
            surface.DrawPoly(r1)
        ashop.ReplaceStencil(1)
            surface.SetDrawColor(255, 255, 255)
            local m = mat

            if isfunction(mat) then
                m = mat()
            end

            surface.SetMaterial(m)
            surface.DrawTexturedRect(0, 0, w, h)
        ashop.EndStencil()
    end
end

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/object_types/bundles/sh_bundles.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/commandes/cl_commandes.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = "Commandes"
OBJECT_TYPE.UniqueIdentifier = "Commandes"

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/object_types/model/cl_model.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/model/cl_model.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = ashop.L('PlayerModelClass')
OBJECT_TYPE.UniqueIdentifier = "PlayerModel"

local vec = Vector(15, 0, 0)

function OBJECT_TYPE.UI_FILL(plyItem, item, pnl, parent, w, h, noCircle)
    local m = vgui.Create( "DModelPanel" , parent ) -- SpawnIcon
    m:SetSize(parent:GetSize())
    m:SetModel( item.metadata[1] ) -- Model we want for this spawn icon
    m:SetMouseInputEnabled(false)
    m:SetPaintedManually(true)

    local fov = LocalPlayer():GetFOV()
    m:SetFOV(fov)
    m.FarZ = 4096*10

    function m:LayoutEntity() end

    local ent = m:GetEntity()
    local b = ent:LookupBone("ValveBiped.Bip01_Head1")
    local eyepos = b and ent:GetBonePosition(b) or Vector(0, 0, 60)

    m:SetLookAt(eyepos)
    m:SetCamPos(eyepos+vec)

    return true, {m}
end

// Rendering
function OBJECT_TYPE.OnLocalEquip(ply, plyItem, item)
    if ply.DModelPanel and ply.DModelPanel:GetModel() != ashop.GetItemAttribute(plyItem, item, 1) then
        ply.ashop_oldmodel = ply:GetModel()
        ply.DModelPanel:SetModel(ashop.GetItemAttribute(plyItem, item, 1))
    elseif !ply.DModelPanel then
        ply.ashop_oldmodel = ply:GetModel()
        ply:SetModel(ashop.GetItemAttribute(plyItem, item, 1))
    end
end

function OBJECT_TYPE.OnLocalRemove(ply, plyItem, item)
    if ply.ashop_oldmodel and ply:GetModel() == ashop.GetItemAttribute(plyItem, item, 1) then
        if ply.DModelPanel then
            ply.DModelPanel:SetModel(ply.ashop_oldmodel)
        else
            ply:SetModel(ply.ashop_oldmodel)
        end
    end
end

function OBJECT_TYPE.OnMetadataUpdate(ply, plyItem, item, metadataKey, oldValue, newValue)
    if ply.DModelPanel and metadataKey == 1 then
        ply.DModelPanel:SetModel(newValue)
    end
end

ashop.RegisterObjectType(OBJECT_TYPE)
--addons/ashop/lua/ashop/code/object_types/taunts/cl_taunts.lua:
local OBJECT_TYPE = {}

OBJECT_TYPE.Name = ashop.L('TauntsClass')
OBJECT_TYPE.UniqueIdentifier = "Taunts"
OBJECT_TYPE.DefaultRender = "Accessories"

local ang90 = Angle(0, 90, 0)

function OBJECT_TYPE.UI_FILL(plyItem, item, pnl, parent, w, h, noCircle)
    local circleParent = vgui.Create("EditablePanel", pnl)
    circleParent:SetSize(w, h)
    circleParent:SetMouseInputEnabled(false)

    local m = vgui.Create( "DModelPanel" , pnl ) -- SpawnIcon
    m:Dock(FILL)
    m:SetModel( LocalPlayer():GetModel() ) -- Model we want for this spawn icon
    m:SetMouseInputEnabled(false)
    m:SetPaintedManually(true)

    m.FarZ = 4096*10

    local mn, mx = m.Entity:GetRenderBounds()
    local size = 0
    size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
    size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
    size = math.max( size, math.abs(mn.z) + math.abs(mx.z) )

    m:SetFOV( 45 )
    m:SetLookAt( (mn + mx) * 0.5 )
    m:SetCamPos( Vector(size, size, 0))
    m.Entity:SetAngles(m.Entity:GetAngles() + ang90)
    m.Entity:ResetSequence(item.metadata[2])

    function m:LayoutEntity() end

    function m:PreDrawModel(ent)
        local fr = FrameTime()
        local c = ent:GetCycle()
        local seqD = ent:SequenceDuration()
        local mdRat = item.metadata[5] or 1

        ratio = fr * mdRat
        c = (c + ratio/seqD) % 1

        ent:SetCycle(c)
        render.SetLightingMode(1)
    end

    function m:PostDrawModel(ent)
        render.SetLightingMode(0)
    end

    return true, {m}
end

function OBJECT_TYPE.OnLocalRemove(ply, plyItem, item)
    OBJECT_TYPE.OnRemove(ply, plyItem, item)
end

function OBJECT_TYPE.OnLocalFPDraw(ply)
end

function OBJECT_TYPE.OnRemove(ply, plyItem, item)
    // Remove the anim taunt from player, if any
    ply.ashop_anim = nil
end

// Check if player was visible this frame
local radios = {}

// Get all radios from players, if lua refresh
for k, v in ipairs(player.GetHumans()) do
    if v.ashop_animmusic then
        radios[v.ashop_animmusic[1]] = v
    end
end

function OBJECT_TYPE.OnPostPlayerDraw(ply, plyItem, item, inModelPanel)
    if ply.ashop_animmusic then
        ply.ashop_animmusic[1]:SetPos(ply:GetPos() + ply:OBBMaxs())
    end
end

// When gmod is waiting to get the URL, you can't disconnect
// Making painful to disconnect when there a loop looping to get links
local blockedURLs = {}

ashop.RegisterObjectType(OBJECT_TYPE)

// The "most" optimised method I found, avoiding think or PostPlayerDraw
timer.Create("ashop_checkradios", 0.33, 0, function()
    for k, v in pairs(radios) do
        // Player not valid
        if !IsValid(v) or !v.ashop_anim then
            if k:IsValid() then
                k:Stop()
            end

            radios[k] = nil
            continue
        end

        
        // Radio not valid, happens sometimes
        if !k:IsValid() then
            local url = v.ashop_animmusic[2]

            if !blockedURLs[url] then
                sound.PlayURL ( url, "noblock" .. (LocalPlayer() == v and "" or "3d"), function( station )
                    if !IsValid(v) then return end

                    if ( IsValid( station ) ) then
                        station:SetPos( v:GetPos() )
                        station:Play()
                        station:EnableLooping(true)
                        v.ashop_animmusic = {station, url}
                        radios[station] = v
                    else
                        print( "[AShop] Invalid Anim music URL !" )
                        blockedURLs[url] = true
                    end
                end )
            end
            
            radios[k] = nil
            continue
        end

        if v:IsDormant() then
            k:Pause()
        else
            k:Play()
            k:SetPos(v:GetPos())
        end
    end
end)

net.Receive("ashop_selectTaunt", function()
    local ply = net.ReadEntity()

    if !IsValid(ply) then return end

    if ply.ashop_anim then
        if ply.ashop_animmusic then
            radios[ply.ashop_animmusic[1]] = nil
            ply.ashop_animmusic[1]:Stop()
            ply.ashop_animmusic = nil
        end
        ply.ashop_anim = nil
    end

    if net.ReadBool() then
        local itemid = net.ReadUInt(ashop.Config.BitsItemID)
        if !ashop.items or !ashop.items[itemid] then return end

        local item = ashop.items[itemid]
        local url = item.metadata[4]
        ply.ashop_anim = {item.metadata[2], item.metadata[5], item.metadata[3] or false}

        if url and !blockedURLs[url] then
            sound.PlayURL ( url, "noblock " .. (ply != LocalPlayer() and "3d" or ""), function( station )
                if !IsValid(ply) then return end

                if ( IsValid( station ) ) then
                    station:SetPos( ply:GetPos() )
                    station:Play()
                    station:EnableLooping(true)
                    ply.ashop_animmusic = {station, url}

                    radios[station] = ply
                else
                    print( "[AShop] Invalid Anim music URL !" )
                    blockedURLs[url] = true
                end
            end )
        end
    end

    ply:SetCycle( 0 )
end)

local ang180 = Angle(0, 180, 0)
local ang45 = Angle(0, 45, 0)
concommand.Add("ashop_OpenTauntMenu", function()
    local ply = LocalPlayer()
    local localModel = ply:GetModel()
    local b = ashop.GetObjectTypeIDByUID('Taunts')
    local equipped, count = ply:AShop_SlotStateGet(b)

    local u = vgui.Create('AShop_RadialMenu')
    function u:CallbackItem(data)
        net.Start('ashop_selectTaunt')
            net.WriteBool(true)
            net.WriteUInt(data, ashop.Config.BitsPlyItemID)
        net.SendToServer()
        u:Remove()
    end

    local radialItems = {}
    if count > 0 then
        for i = 1, count do
            if equipped[i] then
                local item = ashop.items[ply.ashop_data.items[equipped[i]].item_id]
                local cm = ClientsideModel(localModel)
                cm:SetNoDraw(true)
                cm:Spawn()
                cm:ResetSequence(item.metadata[2])
                cm:SetAngles(ang45)

                radialItems[i] = {
                    name = item.name,
                    data = equipped[i],
                    cm = cm,
                    item = item
                }

                local bMin, bMax = cm:GetModelBounds()
                local size = 0
                size = math.max( size, math.abs(bMin.x) + math.abs(bMax.x) )
                local center = (bMax - bMin) / 2 + bMin

                cm.viewPos = Vector( size, size, size ) + Angle():Forward()*100 + Vector(0, 0, size/2)
                cm.ang = (cm.viewPos - center):Angle() + ang180
            end
        end
    end

    function u:DrawItem(data, x, y, w, h, key)
        local mdl = radialItems[key].cm
        local Sx, Sy = self:LocalToScreen(x, y)

        ashop.StartStencil()
            cam.Start3D(mdl.viewPos, mdl.ang, 40, Sx, Sy, w, h, 50, 800)
            mdl:DrawModel()
            mdl:SetCycle(radialItems[key].item.metadata[6] or 0.8)
            cam.End3D()
        ashop.ReplaceStencil(1)
            surface.SetDrawColor(255, 255, 255)
            surface.DrawRect(x, y, w, h)
        ashop.EndStencil()
    end

    function u:OnRemove()
        for k, v in pairs(radialItems) do
            if v.cm and IsValid(v.cm) then
                v.cm:Remove()
            end
        end
    end

    u.desc = ashop.L('ClickTaunt')

    u:SetContents(count, radialItems)
end)

hook.Add("CalcView", "ashop_animFirstPerson", function(ply, origin, angles)
    if ply.ashop_anim and !ply:ShouldDrawLocalPlayer() then
        local b = ply:LookupBone('ValveBiped.Bip01_Head1')
        if !b then return end

        local pos, ang = ply:GetBonePosition(b)
        ang = ang

        ang:RotateAroundAxis(ang:Up(), -90)
        ang:RotateAroundAxis(ang:Forward(), -90)

        return {
            // Get this value with origin - pos
            origin = pos + ang:Forward()*8,
            angles = ang,
            drawviewer = true
        }
    end
end)
--addons/ashop/lua/ashop/code/object_types/taunts/sh_taunts.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/title_code/cl_init.lua:
ashop.titles = ashop.titles or {
    styles = {},
    colors = {}
}

local function defaultEffect(text, color, xOffset, yOffset, textOriginal, topAlign, font)
    local textSize = #text
    surface.SetFont(font or "ashop_18")
    local w, h = surface.GetTextSize(textOriginal)
    local xOffset = xOffset or 0
    local yOffset = yOffset or 0

    surface.SetTextPos(xOffset - w/2, yOffset - (topAlign == TEXT_ALIGN_CENTER and h/2 or 0))

    for i = 1, textSize do
        if istable(color) then
            surface.SetTextColor(color)
        else
            local r, g, b, a = ashop.titles.colors[color].draw(i, textSize)
            surface.SetTextColor( r, g, b, a )
        end
        surface.DrawText( text[i] )
    end
end
ashop.titles.styles[0] = defaultEffect

local t = {}
local str = "A Cool Title"

for i = 1, string.len(str) do
    t[i] = utf8.sub(str, i, i )
end

// TODO: Custom fonts ?. Maybe in a update
function ashop.DrawTitle(text, color, effect, x, y, textOriginal, topAlign, font)
    effect = effect or defaultEffect
    effect(text or t, color or color_white, x, y, textOriginal or str, topAlign, font)
end
--addons/ashop/lua/ashop/code/object_types/weapon_perms/cl_permwep.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/object_types/wearable/sh_wearable.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/cl_lib.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/cl_stencil.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/item_shop_effects/sh_matrix.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels/cl_slider.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/cl_giveaway.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/cl_renderedit.lua:
local function DrawInterior(editor, key, value, parent)
    local scroll = vgui.Create("DScrollPanel", editor)
    scroll:Dock(FILL)

    ashop.ui.SkinScrollPanel(scroll)

    local nameContainer = vgui.Create('AShop_Entry', scroll)
    nameContainer:Dock(TOP)
    nameContainer:SetTall(0)
    nameContainer:IsRequired(true)
    nameContainer:SetInput(ashop.L('Name'), TYPE_STRING, value.name, {
        required = true,
        maxLength = 24,
        minLength = 4
    })
    nameContainer.boxcolor = ashop.GetColor('Grad2_0')
    nameContainer:AddSeparator()

    function nameContainer:OnSave(value)
        parent:SetText(value)

        net.Start('ashop_Render_Edit')
            net.WriteBool(true)
            net.WriteUInt(key, ashop.Config.BitsRender)
            net.WriteString(value)
        net.SendToServer()
    end

    for k, v in pairs(ashop.object_types) do
        if value.cat[k] then continue end

        local objectType = vgui.Create('AShop_Entry', scroll)
        objectType:Dock(TOP)
        objectType:AddSeparator()

        objectType:SetInput(ashop.L('DrawObjectTypeInShopCategory', v.Name), TYPE_BOOL, value.cat[k])

        function objectType:OnSave(value)
            net.Start('ashop_Render_Edit')
                net.WriteBool(false)
                net.WriteUInt(key, ashop.Config.BitsRender)
                net.WriteUInt(k, ashop.Config.BitsObjectType)
            net.SendToServer()

            if value then
                objectType:Remove()
                scroll:InvalidateLayout()
            end
        end
        objectType.boxcolor = ashop.GetColor('Grad2_0')
    end
end

ashop.registerParameter(ashop.L('Renders'), DrawInterior, function()
    local o = {}

    for k, v in pairs(ashop.render) do
        table.insert(o, {v.name, k, v})
    end

    return o
end, function()
    local a = vgui.Create('AShop_Form', ashop.menu)
    a:SetTitle(ashop.L('CreateARender'))
    a:CreateEntry(true, ashop.L('Name'), TYPE_STRING, {
        maxLength = 24,
        minLength = 4
    })

    for k, v in pairs(ashop.object_types) do
        a:CreateEntry(true, ashop.L('DrawObjectTypeInShopCategory', v.Name), TYPE_BOOL)
    end

    function a:OnSend(name, ...)
        local t = {...}

        net.Start('ashop_Render_New')
            net.WriteString(name)
            ashop.Network.W_Bulk(
                t,
                function(t)
                    net.WriteBool(t)
                end,
                0, ashop.Config.BitsObjectType, ashop.Config.BitsObjectType
            )
        net.SendToServer()
    end
    a:Center()
end, function(but, settingButton, objectTarget, fullObject)
    function but:DoRightClick()
        if table.Count(ashop.render) <= 1 then return end

        CloseDermaMenus()
        local menu = vgui.Create( "AShop_DMenu", but )

        menu:AddOption(ashop.L('Remove'), function()
            if objectTarget.cat and !table.IsEmpty(objectTarget.cat) then
                local id = next(objectTarget.cat)
                ashop.DermaNotify(ashop.L('CantDeleteNotEmptyRender') .. ". The object type you need to move is : " .. ashop.object_types[id].Name, NOTIFY_ERROR, 3)
                return
            end

            // Check if only one

            ashop.ui.popAskbox(ashop.L('DeleteRender', objectTarget.name), ashop.L('CantUndoOperation'), function()
                net.Start('ashop_Render_Delete')
                    net.WriteUInt(fullObject[2], ashop.Config.BitsRender)
                net.SendToServer()
            end)
        end)

        menu:Open()
    end
end)
--addons/ashop/lua/ashop/code/ui/panels_settings/cl_weaponskins.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_darkrp_money.lua:
ashop.RegisterPremade("DarkRP Money", {
    objectTypes = {
        {
            "Commandes",
        }
    },

    items = {
        {
            name = "1000 DarkRP Money",
            rendering = 1,
            metadata = {
                [2] = 3,
                [3] = 'player.GetBySteamID({PLAYER_STEAMID}):addMoney(1000)',
            },
        },
    },
})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_gtav_back.lua:
ashop.RegisterPremade("GTAV Backpack", {
    requireWorkshop = "572310302",

    objectTypes = {
        {
            "Wearables",
            {"ValveBiped.Bip01_Spine2"},
            "Back"
        }
    },

    items = {
        {
            name = "Red Backpack",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/backpack_1.mdl',
                [3] = Vector(-0.375, 2, -0.3125),
                [4] = Angle(0.09375, 90, 90),
                [7] = Vector(1, 1, 1),

                [10] = false,
                [12] = 200,
                [13] = Vector(-200, -76, 97)
            },
        },

        {
            name = "Hiking Backpack",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/backpack_2.mdl',
                [3] = Vector(-0.375, 2, -0.3125),
                [4] = Angle(0.09375, 90, 90),
                [7] = Vector(1, 1, 1),
                [12] = 250,
                [13] = Vector(-200, -96, 16)
            },
        },

        {
            name = "Black Backpack",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/backpack_1.mdl',
                [3] = Vector(-0.375, 2, -0.3125),
                [4] = Angle(0.09375, 90, 90),
                [7] = Vector(1, 1, 1),

                [10] = false,
                [11] = 1,
                [12] = 200,
                [13] = Vector(-200, -76, 97)
            },
        },

        {
            name = "Orange Backpack",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/backpack_1.mdl',
                [3] = Vector(-0.375, 2, -0.3125),
                [4] = Angle(0.09375, 90, 90),
                [7] = Vector(1, 1, 1),

                [10] = false,
                [11] = 2,
                [12] = 200,
                [13] = Vector(-200, -76, 97)
            },
        },

        {
            name = "Black Backpack 2",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/backpack_3.mdl',
                [3] = Vector(-0.375, 2, -0.3125),
                [4] = Angle(0.09375, 90, 90),
                [7] = Vector(1, 1, 1),

                [10] = false,
                [11] = 3,
                [12] = 200,
                [13] = Vector(-200, -96, 73)
            },
        },

        {
            name = "Grey Backpack",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/backpack_3.mdl',
                [3] = Vector(-0.375, 2, -0.3125),
                [4] = Angle(0.09375, 90, 90),
                [7] = Vector(1, 1, 1),

                [10] = false,
                [11] = 1,
                [12] = 200,
                [13] = Vector(-200, -96, 73)
            },
        },

        {
            name = "Green Hiking Backpack",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/backpack_2.mdl',
                [3] = Vector(-0.375, 2, -0.3125),
                [4] = Angle(0.09375, 90, 90),
                [7] = Vector(1, 1, 1),

                [11] = 1,
                [12] = 250,
                [13] = Vector(-200, -96, 16)
            },
        },

        {
            name = "Hiking Backpack 2",
            rendering = 1,
            metadata = {
                [1] = 'models/modified/backpack_2.mdl',
                [3] = Vector(-0.375, 2, -0.3125),
                [4] = Angle(0.09375, 90, 90),
                [7] = Vector(1, 1, 1),

                [11] = 2,
                [12] = 250,
                [13] = Vector(-200, -96, 16)
            },
        },
    },
})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_gtav_neck.lua:
ashop.RegisterPremade("GTAV Neck", {
    requireWorkshop = "572310302",

    objectTypes = {
        {
            "Wearables",
            {"ValveBiped.Bip01_Neck1"},
            "Neck"
        }
    },

    items = {
        {
            name = "White Scarf",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/scarf01.mdl',
                [3] = Vector(-16, -17.375, -0.1875),
                [4] = Angle(0.65625, -51, -90.3125),
                [10] = false,
                [12] = 100,
                [13] = Vector(22, 10, -200)
            },
        },

        {
            name = "Black Scarf",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/scarf01.mdl',
                [3] = Vector(-16, -17.375, -0.1875),
                [4] = Angle(0.65625, -51, -90.3125),
                [9] = Color(40, 40, 40),
                [10] = false,
                [12] = 100,
                [13] = Vector(22, 10, -200)
            },
        },

        {
            name = "Blue Scarf",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/scarf01.mdl',
                [3] = Vector(-16, -17.375, -0.1875),
                [4] = Angle(0.65625, -51, -90.3125),
                [9] = Color(40, 162, 232),
                [10] = false,
                [12] = 100,
                [13] = Vector(22, 10, -200)
            },
        },

        {
            name = "Red Scarf",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/scarf01.mdl',
                [3] = Vector(-16, -17.375, -0.1875),
                [4] = Angle(0.65625, -51, -90.3125),
                [9] = Color(163, 83, 115),
                [10] = false,
                [12] = 100,
                [13] = Vector(22, 10, -200)
            },
        },

        {
            name = "Green Scarf",
            rendering = 1,
            metadata = {
                [1] = 'models/sal/acc/fix/scarf01.mdl',
                [3] = Vector(-16, -17.375, -0.1875),
                [4] = Angle(0.65625, -51, -90.3125),
                [10] = false,
                [9] = Color(86, 162, 84),
                [12] = 100,
                [13] = Vector(22, 10, -200)
            },
        },
    },
})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_moatweaponskin.lua:
ashop.RegisterPremade("Moat Weapon Skins", {
    requireWorkshop = "",

    objectTypes = {
        {
            "WeaponSkins",
            // {} metadatas,
        }
    },

    items = {
        {
            metadata = {"akulla/weaponskins/animated_101"},
            name = "Electric Marble",
            rendering = 1
        },

        {
            metadata = {"akulla/weaponskins/animated_102"},
            name = "Royal Black",
            rendering = 1
        },

        {
            name = "Extinction",
            metadata = {"akulla/weaponskins/animated_103"},
            rendering = 1
        },

        {
            name = "California Fever",
            metadata = {"akulla/weaponskins/animated_104"},
            rendering = 1
        },

        {
            name = "BOO!",
            metadata = {"akulla/weaponskins/animated_105"},
            rendering = 1
        },

        {
            name = "Splash!",
            metadata = {"akulla/weaponskins/animated_106"},
            rendering = 1
        },

        {
            name = "Fishy",
            metadata = {"akulla/weaponskins/animated_107"},
            rendering = 1
        },

        {
            name = "Geometrical Graffiti",
            metadata = {"akulla/weaponskins/animated_108"},
            rendering = 1
        },

        {
            name = "Crushin Love",
            metadata = {"akulla/weaponskins/animated_109"},
            rendering = 1
        },

        {
            name = "Valorant Is Better",
            metadata = {"akulla/weaponskins/animated_110"},
            rendering = 1
        },

        {
            name = "Hope",
            metadata = {"akulla/weaponskins/animated_112"},
            rendering = 1
        },

        {
            name = "Phasing",
            metadata = {"akulla/weaponskins/animated_113"},
            rendering = 1
        },

        {
            name = "Rainbow Notch",
            metadata = {"akulla/weaponskins/animated_114"},
            rendering = 1
        },

        {
            name = "Air Food",
            metadata = {"akulla/weaponskins/animated_115"},
            rendering = 1
        },

        {
            name = "A Long Snake",
            metadata = {"akulla/weaponskins/animated_116"},
            rendering = 1
        },

        {
            name = "Tsunami",
            metadata = {"akulla/weaponskins/animated_117"},
            rendering = 1
        },

        {
            name = "Fantasy Nature",
            metadata = {"akulla/weaponskins/animated_118"},
            rendering = 1
        },

        {
            name = "Nippon",
            metadata = {"akulla/weaponskins/animated_119"},
            rendering = 1
        },

        {
            name = "Penguin",
            metadata = {"akulla/weaponskins/animated_120"},
            rendering = 1
        },

        {
            name = "Orange Spam",
            metadata = {"akulla/weaponskins/animated_121"},
            rendering = 1
        },

        {
            name = "Lean Waves",
            metadata = {"akulla/weaponskins/static_101"},
            rendering = 1
        },

        {
            name = "Lean Waves",
            metadata = {"akulla/weaponskins/static_101"},
            rendering = 1
        },

        {
            name = "Rainbow Vomit",
            metadata = {"akulla/weaponskins/static_102"},
            rendering = 1
        },

        {
            name = "Colorful",
            metadata = {"akulla/weaponskins/static_103"},
            rendering = 1
        },

        {
            name = "Blue Rock",
            metadata = {"akulla/weaponskins/static_104"},
            rendering = 1
        },

        {
            name = "Red Exhaust",
            metadata = {"akulla/weaponskins/static_105"},
            rendering = 1
        },

        {
            name = "Pastel",
            metadata = {"akulla/weaponskins/static_106"},
            rendering = 1
        },

        {
            name = "Foliages",
            metadata = {"akulla/weaponskins/static_107"},
            rendering = 1
        },

        {
            name = "Pixels",
            metadata = {"akulla/weaponskins/static_108"},
            rendering = 1
        },

        {
            name = "Space Explosion",
            metadata = {"akulla/weaponskins/static_109"},
            rendering = 1
        },

        {
            name = "Feline",
            metadata = {"akulla/weaponskins/static_110"},
            rendering = 1
        },

        {
            name = "Neon",
            metadata = {"akulla/weaponskins/static_111"},
            rendering = 1
        },

        {
            name = "Gaia",
            metadata = {"akulla/weaponskins/static_112"},
            rendering = 1
        },

        {
            name = "Hypno",
            metadata = {"akulla/weaponskins/static_113"},
            rendering = 1
        },

        {
            name = "Chill Bubbles",
            metadata = {"akulla/weaponskins/static_114"},
            rendering = 1
        },

        {
            name = "Lava",
            metadata = {"akulla/weaponskins/static_115"},
            rendering = 1
        },

        {
            name = "Mint",
            metadata = {"akulla/weaponskins/static_116"},
            rendering = 1
        },

        {
            name = "Magikarp",
            metadata = {"akulla/weaponskins/static_117"},
            rendering = 1
        },

        {
            name = "Cosmos",
            metadata = {"akulla/weaponskins/static_118"},
            rendering = 1
        },

        {
            name = "Yellow Flowers",
            metadata = {"akulla/weaponskins/static_119"},
            rendering = 1
        },

        {
            name = "Yellow Bricks",
            metadata = {"akulla/weaponskins/static_120"},
            rendering = 1
        },

        {
            name = "Yellow/Pink",
            metadata = {"akulla/weaponskins/static_121"},
            rendering = 1
        },

        {
            name = "Neon Storm",
            metadata = {"akulla/weaponskins/static_122"},
            rendering = 1
        },

        {
            name = "Purple Interior",
            metadata = {"akulla/weaponskins/static_123"},
            rendering = 1
        },

        {
            name = "Savane Foliage",
            metadata = {"akulla/weaponskins/static_124"},
            rendering = 1
        },

        {
            name = "Neon Impulse",
            metadata = {"akulla/weaponskins/static_125"},
            rendering = 1
        },

        {
            name = "Windy",
            metadata = {"akulla/weaponskins/static_126"},
            rendering = 1
        },

        {
            name = "Window",
            metadata = {"akulla/weaponskins/static_127"},
            rendering = 1
        },

        {
            name = "Yellow Explosion",
            metadata = {"akulla/weaponskins/static_128"},
            rendering = 1
        },

        {
            name = "Rainbow Road",
            metadata = {"akulla/weaponskins/static_129"},
            rendering = 1
        },

        {
            name = "Orange Camo",
            metadata = {"akulla/weaponskins/static_130"},
            rendering = 1
        },

        {
            name = "Crossed Camo",
            metadata = {"akulla/weaponskins/static_131"},
            rendering = 1
        },

        {
            name = "Cold Geometric",
            metadata = {"akulla/weaponskins/static_132"},
            rendering = 1
        },

        {
            name = "Fly",
            metadata = {"akulla/weaponskins/static_133"},
            rendering = 1
        },

        {
            name = "Fire",
            metadata = {"akulla/weaponskins/static_134"},
            rendering = 1
        },

        {
            name = "Green Cut",
            metadata = {"akulla/weaponskins/static_135"},
            rendering = 1
        },

        {
            name = "Cyberpunk",
            metadata = {"akulla/weaponskins/static_136"},
            rendering = 1
        },

        {
            name = "COMING4YOU",
            metadata = {"akulla/weaponskins/static_137"},
            rendering = 1
        },

        {
            name = "Lost",
            metadata = {"akulla/weaponskins/static_138"},
            rendering = 1
        },

        {
            name = "A Orange Camo",
            metadata = {"akulla/weaponskins/static_139"},
            rendering = 1
        },

        {
            name = "Infinite Cos",
            metadata = {"akulla/weaponskins/static_140"},
            rendering = 1
        },

        {
            name = "Squared",
            metadata = {"akulla/weaponskins/static_141"},
            rendering = 1
        },

        {
            name = "Psycho",
            metadata = {"akulla/weaponskins/static_142"},
            rendering = 1
        },

        {
            name = "Cyberware",
            metadata = {"akulla/weaponskins/static_143"},
            rendering = 1
        },
    }
})
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_rpsafeanims.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_splatoonhead.lua:
return gluapack()()
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_theatermask.lua:
local t = {}

for k, v in ipairs({"his", "her"}) do
    for acc, j in pairs({"", "_eye"}) do
        for i = 0, 4 do
            table.insert(t, {
                name = "Theater Mask" .. (k == 1 and " Male" or " Female") .. (acc == 1 and "" or " Eye") .. (i == 0 and "" or (" " .. i)),
                rendering = INSERT,
                metadata = {
                    [1] = 'models/mask/mask_' .. v .. j .. '.mdl',
                    [3] = Vector(-1.71875, -4.71875, -0.0625),
                    [4] = Angle(-0.25, -74.65625, -90.40625),
                    [10] = false,
                    [11] = i,
                },
            })
        end
    end
end

ashop.RegisterPremade("Theater Mask", {
        requireWorkshop = "173676413",

        objectTypes = {
            {
                "Wearables",
                {"ValveBiped.Bip01_Head1"},
                "Facemask"
            },
        },

        items = t
    }
)
--addons/ashop/lua/ashop/code/ui/panels_settings/premades/cl_urafinisher.lua:
return gluapack()()
--addons/sh_reports/lua/reports/cl_main.lua:
if (!SH_REPORTS.ActiveReports) then
	SH_REPORTS.ActiveReports = {}
end

function SH_REPORTS:ReportCreated(data)
	chat.AddText(self.Style.header, "[" .. self:L("reports") .. "] ", color_white, self:L("report_received", data.reporter_name, data.reported_name, self.ReportReasons[data.reason_id])) -- 76561198347218033

	if (self.NewReportSound.enabled) then
		surface.PlaySound(self.NewReportSound.path)
	end

	self:MakeNotification(data)
	self:MakePending(data)

	if (!self.ActiveReports) then
		self.ActiveReports = {}
	end
	table.insert(self.ActiveReports, data)
end

hook.Add("Think", "SH_REPORTS.Ready", function()
	if (IsValid(LocalPlayer())) then
		hook.Remove("Think", "SH_REPORTS.Ready")
		easynet.SendToServer("SH_REPORTS.PlayerReady")
	end
end)

easynet.Callback("SH_REPORTS.SendList", function(data)
	local pendings = {}
	for _, report in pairs (SH_REPORTS.ActiveReports) do
		if (IsValid(report.pending)) then
			pendings[report.id] = report.pending
		end
	end

	SH_REPORTS.ServerTime = data.server_time
	SH_REPORTS.ActiveReports = data.struct_reports

	for _, report in pairs (SH_REPORTS.ActiveReports) do
		report.pending = pendings[report.id]
	end
	
	SH_REPORTS:ShowReports()
end)

easynet.Callback("SH_REPORTS.MinimizeReport", function(data)
	if (IsValid(_SH_REPORTS_VIEW)) then
		_SH_REPORTS_VIEW:Close()
	end

	local report
	for _, rep in pairs (SH_REPORTS.ActiveReports) do
		if (rep.id == data.report_id) then
			report = rep
			break
		end
	end

	if (report) then
		SH_REPORTS:MakeTab(report)
	end
end)

easynet.Callback("SH_REPORTS.ReportClosed", function(data)
	for k, rep in pairs (SH_REPORTS.ActiveReports) do
		if (rep.id == data.report_id) then
			if (IsValid(rep.line)) then
				rep.line:Close()
			end

			if (IsValid(rep.pending)) then
				rep.pending:Close()
			end

			SH_REPORTS.ActiveReports[k] = nil
		end
	end

	if (IsValid(_SH_REPORTS_TAB) and _SH_REPORTS_TAB.id == data.report_id) then
		_SH_REPORTS_TAB:Close()
	end

	SH_REPORTS:ClosePendingPanel(data.report_id)
end)

easynet.Callback("SH_REPORTS.ReportClaimed", function(data)
	for _, rep in pairs (SH_REPORTS.ActiveReports) do
		if (rep.id == data.report_id) then
			rep.admin_id = data.admin_id

			if (IsValid(rep.line)) then
				rep.line.claimed.avi:SetSteamID(data.admin_id)
				rep.line.claimed.avi:SetVisible(true)

				local admin = player.GetBySteamID64(data.admin_id)
				if (IsValid(admin)) then
					rep.line.claimed.name:SetTextInset(32, 0)
					rep.line.claimed.name:SetContentAlignment(4)
					rep.line.claimed.name:SetText(admin:Nick())
				end
			end

			if (IsValid(rep.pending)) then
				rep.pending:Close()
			end

			if (data.admin_id ~= LocalPlayer():SteamID64() and IsValid(rep.line) and IsValid(rep.line.delete)) then
				rep.line.delete:Remove()
			end
		end
	end

	SH_REPORTS:ClosePendingPanel(data.report_id)
end)

easynet.Callback("SH_REPORTS.Notify", function(data)
	-- do NOT do this
	SH_REPORTS:Notify(SH_REPORTS:L(unpack(string.Explode("\t", data.msg))), nil, data.positive and SH_REPORTS.Style.success or SH_REPORTS.Style.failure)
end)

easynet.Callback("SH_REPORTS.Chat", function(data)
	chat.AddText(SH_REPORTS.Style.header, "[" .. SH_REPORTS:L("reports") .. "] ", color_white, data.msg)
end)

easynet.Callback("SH_REPORTS.ReportCreated", function(data)
	SH_REPORTS:ReportCreated(data)
end)

easynet.Callback("SH_REPORTS.ReportsPending", function(data)
	chat.AddText(SH_REPORTS.Style.header, "[" .. SH_REPORTS:L("reports") .. "] ", color_white, SH_REPORTS:L("there_are_x_reports_pending", data.num)) -- 76561198347218024

	SH_REPORTS.ActiveReports = table.Copy(data.struct_reports)

	for _, report in pairs (SH_REPORTS.ActiveReports) do
		SH_REPORTS:MakePending(report)
	end
end)

easynet.Callback("SH_REPORTS.AdminLeft", function(data)
	for _, rep in pairs (SH_REPORTS.ActiveReports) do
		if (rep.id == data.report_id) then
			rep.admin_id = ""

			if (IsValid(rep.line)) then
				rep.line.claimed.avi:SetVisible(false)

				rep.line.claimed.name:SetTextInset(0, 0)
				rep.line.claimed.name:SetContentAlignment(5)
				rep.line.claimed.name:SetText(SH_REPORTS:L("unclaimed"))
			end
		end
	end
end)
--addons/yere_oturma/lua/autorun/binbon_yereoturma.lua:
local addonName = "Ground Sitting"
local PLAYER, ENTITY = FindMetaTable("Player"), FindMetaTable("Entity")
local Length2DSqr = FindMetaTable("Vector").Length2DSqr
local GetMoveType, IsOnGround = ENTITY.GetMoveType, ENTITY.IsOnGround
local MOVETYPE_WALK = MOVETYPE_WALK
local Alive, InVehicle = PLAYER.Alive, PLAYER.InVehicle
local SERVER = SERVER
local Add = hook.Add
local isSittingOnGround = nil
do
	local GetNW2Bool = ENTITY.GetNW2Bool
	isSittingOnGround = function(self)
		return GetNW2Bool(self, addonName)
	end
	PLAYER.IsSittingOnGround = isSittingOnGround
end
do
	local mp_sitting_on_ground_attack = CreateConVar("mp_sitting_on_ground_attack", "0", bit.bor(FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE), "Allows players to attack while sitting on the ground.", 0, 1)
	local KeyDown, AddKey, RemoveKey, ClearMovement
	do
		local _obj_0 = FindMetaTable("CUserCmd")
		KeyDown, AddKey, RemoveKey, ClearMovement = _obj_0.KeyDown, _obj_0.AddKey, _obj_0.RemoveKey, _obj_0.ClearMovement
	end
	local IN_ATTACK, IN_ATTACK2 = IN_ATTACK, IN_ATTACK2
	local GetVelocity = ENTITY.GetVelocity
	local IN_SPEED = IN_SPEED
	local IN_DUCK = IN_DUCK
	Add("StartCommand", addonName, function(self, cmd)
		if not isSittingOnGround(self) then
			return
		end
		if SERVER and (not Alive(self) or not IsOnGround(self) or GetMoveType(self) ~= MOVETYPE_WALK or InVehicle(self)) then
			self:RequestSittingOnGround(false)
			return
		end
		if Length2DSqr(GetVelocity(self)) < 1 then
			if KeyDown(cmd, IN_ATTACK) and not mp_sitting_on_ground_attack:GetBool() then
				RemoveKey(cmd, IN_ATTACK)
			end
			if KeyDown(cmd, IN_ATTACK2) and not mp_sitting_on_ground_attack:GetBool() then
				RemoveKey(cmd, IN_ATTACK2)
			end
		end
		if KeyDown(cmd, IN_DUCK) then
			if KeyDown(cmd, IN_SPEED) then
				RemoveKey(cmd, IN_SPEED)
			end
			return
		end
		AddKey(cmd, IN_DUCK)
		ClearMovement(cmd)
		return
	end)
end
do
	local ACT_HL2MP_IDLE = ACT_HL2MP_IDLE
	local LookupSequence = ENTITY.LookupSequence
	Add("CalcMainActivity", addonName, function(self, velocity)
		if isSittingOnGround(self) and Length2DSqr(velocity) < 1 then
			return ACT_HL2MP_IDLE, LookupSequence(self, "pose_ducking_02")
		end
	end)
end
if not SERVER then
	return
end
Add("CanPlayerGroundSit", addonName, function(self, reqested)
	if not reqested then
		return
	end
	if not (Alive(self) and IsOnGround(self)) then
		return false
	end
	if GetMoveType(self) ~= MOVETYPE_WALK or InVehicle(self) then
		return false
	end
end)
local requestSittingOnGround = nil
do
	local Call = hook.Call
	requestSittingOnGround = function(self, reqested, force)
		if isSittingOnGround(self) == reqested or (not force and Call("CanPlayerGroundSit", nil, self, reqested) == false) then
			return false
		end
		self:SetNW2Bool(addonName, reqested)
		Call("PlayerGroundSit", nil, self, reqested)
		return true
	end
	PLAYER.RequestSittingOnGround = requestSittingOnGround
end
do
	local TraceLine = util.TraceLine
	local IN_WALK = IN_WALK
	local IN_JUMP = IN_JUMP
	local IN_USE = IN_USE
	local traceResult = { }
	local trace = {
		output = traceResult
	}
	Add("KeyPress", addonName, function(self, key)
		if IN_USE == key then
			if not (self:KeyDown(IN_WALK)) then
				return
			end
			trace.start = self:GetShootPos()
			trace.endpos = trace.start + self:GetAimVector() * 72
			trace.filter = self
			TraceLine(trace)
			if not traceResult.Hit or self:EyeAngles()[1] < 80 then
				return false
			end
			requestSittingOnGround(self, true)
			return
		elseif IN_JUMP == key then
			requestSittingOnGround(self, false)
			return
		end
	end)
end
Add("PlayerShouldTaunt", addonName, function(self)
	if isSittingOnGround(self) then
		return false
	end
end)
Add("PlayerGroundSit", addonName, function(self, isEntered)
	self.m_bNextGroundSit = CurTime() + (isEntered and 0.5 or 1)
end)
return concommand.Add("ground_sit", function(self)
	if (self.m_bNextGroundSit or 0) > CurTime() then
		return
	end
	return requestSittingOnGround(self, not isSittingOnGround(self))
end)

--lua/autorun/celty.lua:
return gluapack()()
--lua/autorun/cfm_sparrow_bl.lua:
player_manager.AddValidModel( "CFM_Sparrow_BL", "models/cfmsparrowbl/cfmsparrowbl.mdl" );


local Category = "CrossFire Mobile"

local NPC = { 	Name = "CFM_Sparrow_BL - Friendly", 
				Class = "npc_citizen",
				Model = "models/cfmsparrowbl/cfmsparrowbl.mdl",
				Health = "100",
				KeyValues = { citizentype = 4 },
				Weapons = { "weapons_smg1" },
				Category = Category	}

list.Set( "NPC", "CFM_Sparrow_BL_f", NPC )

local Category = "CrossFire Mobile"

local NPC = { 	Name = "CFM_Sparrow_BL - Hostile", 
				Class = "npc_combine_s",
				Model = "models/cfmsparrowbl/cfmsparrowbl.mdl",
				Squadname = "CFM_Sparrow_BL",
				Numgrenades = "3",
				Health = "100",
				Category = Category	}

list.Set( "NPC", "CFM_Sparrow_BL_h", NPC )
--addons/ch_atm/lua/ch_atm/shared/ch_atm_darkrpadds.lua:
function CH_ATM.DarkRPAdds()
	DarkRP.createEntity("POS Makinesi", {
		ent = "ch_atm_card_scanner",
		model = "models/craphead_scripts/ch_atm/terminal.mdl",
		price = 250,
		max = 2,
		cmd = "buycreditcardterminal"
	})
end
hook.Add( "loadCustomDarkRPItems", "CH_ATM.DarkRPAdds", CH_ATM.DarkRPAdds )
--addons/ch_atm/lua/ch_atm/shared/ch_atm_dev.lua:
--[[
	Just a simple developer function to do debug prints
	Requires that debugmode is enabled
--]]
CH_ATM.Config.DebugMode = false

function CH_ATM.DebugPrint( to_print )
	if not CH_ATM.Config.DebugMode then
		return
	end
	
	if istable( to_print ) then
		PrintTable( to_print )
	else
		print( to_print )
	end
end
--addons/ch_atm/lua/ch_atm/shared/currencies/basewars.lua:
CH_ATM.Currencies[ "basewars" ] = {
	Name = "Basewars Money",
	
	AddMoney = function( ply, amount )
		ply:GiveMoney( amount )
	end,
	
	TakeMoney = function( ply, amount )
		ply:TakeMoney( amount )
	end,
	
	GetMoney = function( ply )
		return ply:GetMoney()
	end,
	
	CanAfford = function( ply, amount )
		return ply:GetMoney() >= amount
	end,
	
	FormatMoney = function( amount )
		return DarkRP.formatMoney( amount )
	end,
	
	CurrencyAbbreviation = function()
		return "USD"
	end,
}
--addons/ch_atm/lua/ch_atm/client/ch_atm_admin.lua:
return gluapack()()
--addons/ch_atm/lua/ch_atm/client/ch_atm_colors_materials.lua:
CH_ATM.Colors = CH_ATM.Colors or {}
CH_ATM.Materials = CH_ATM.Materials or {}

--[[
	Cache materials in our table.
--]]
CH_ATM.Materials.Cursor = Material( "materials/craphead_scripts/ch_atm/gui/cursor.png", "noclamp smooth" )
CH_ATM.Materials.HandCursor = Material( "materials/craphead_scripts/ch_atm/gui/hand_cursor.png", "noclamp smooth" )
CH_ATM.Materials.CloseIcon = Material( "craphead_scripts/ch_atm/gui/close.png", "noclamp smooth" )
CH_ATM.Materials.Crosshair = Material( "craphead_scripts/ch_atm/gui/crosshair.png", "noclamp smooth" )

--[[
	Cache colors in our table.
--]]
CH_ATM.Colors.DarkGray = Color( 22, 22, 22, 255 )
CH_ATM.Colors.LightGray = Color( 30, 30, 30, 255 )

CH_ATM.Colors.Green = Color( 75, 174, 79, 255 )
CH_ATM.Colors.GreenHovered = Color( 99, 215, 103, 255 )

CH_ATM.Colors.Red = Color( 243, 66, 53, 255 )
CH_ATM.Colors.RedHovered = Color( 220, 55, 43, 255 )
CH_ATM.Colors.RedAlpha = Color( 243, 66, 53, 70 )

CH_ATM.Colors.WhiteAlpha = Color( 255, 255, 255, 5 )
CH_ATM.Colors.WhiteAlpha2 = Color( 255, 255, 255, 70 )

CH_ATM.Colors.GMSBlue = Color( 52, 152, 219, 255 )
--addons/darkrpbankrobbery2/lua/ch_bank_robbery/shared/bank_config.lua:
return gluapack()()
--addons/darkrpbankrobbery2/lua/ch_bank_robbery/shared/bank_config_design.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/shared/config/ch_mayor_config.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/shared/config/ch_mayor_config.lua:
CH_Mayor = CH_Mayor or {}
CH_Mayor.Config = CH_Mayor.Config or {}
CH_Mayor.Catalog = CH_Mayor.Catalog or {}
CH_Mayor.Upgrades = CH_Mayor.Upgrades or {}

-- SET LANGUAGE
-- Available languages: English: en - French: fr - Danish: da - Spanish: es - Polish: pl
CH_Mayor.Config.Language = "tr" -- Set the language of the script.

--[[
	TEAMS CONFIG
--]]
CH_Mayor.Config.MayorTeam = "Başkan" -- Name of your mayor team.

CH_Mayor.Config.GovernmentTeams = { -- Teams that are considered government.
    ["Bekçi"] = true,
    ["Polis"] = true,
    ["Sivil Polis"] = true,
    ["Başkan"] = true,
    ["PÖH"] = true,
    ["PÖH Doktor"] = true,
    ["PÖH Amir"] = true,
    ["PÖH Keskin Nişancı"] = true,
    ["MIT Ajanı"] = true,
    ["Emniyet Amiri"] = true,
    ["Hakim"] = true,
}

CH_Mayor.Config.PoliceTeams = { -- Teams that are considered police teams (for example counts towards when you can rob the vault).
    ["Bekçi"] = true,
    ["Polis"] = true,
    ["Sivil Polis"] = true,
    ["Başkan"] = true,
    ["PÖH"] = true,
    ["PÖH Doktor"] = true,
    ["PÖH Amir"] = true,
    ["PÖH Keskin Nişancı"] = true,
    ["MIT Ajanı"] = true,
    ["Emniyet Amiri"] = true,
    ["Hakim"] = true,
}

CH_Mayor.Config.CriminalTeams = { --Teams that are considered criminals. These can rob the vault.
	["Terorist Uyesi"] = true,
	["Terorist Lideri"] = true,
}

CH_Mayor.Config.AdminUsergroups = { --Usergroups that are considered admins.
	["owner"] = true,
	["superadmin"] = true,
	["admin"] = true,
}

--[[
	GENERAL CONFIG
--]]
CH_Mayor.Config.NotificationTime = 10 -- Amount of seconds the notification display for DarkRP
CH_Mayor.Config.DistanceTo3D2D = 500000 -- Distance to draw 3d2d on entities

CH_Mayor.Config.UseMayorMenuKey = true -- Should we enable the key to open the mayor menu?
CH_Mayor.Config.MayorMenuKey = KEY_F7 -- The key that opens the mayor menu. You can find all keys here: https://wiki.garrysmod.com/page/Enums/KEY

CH_Mayor.Config.UseMayorChatCommand = true -- Should we enable the chat command to open the mayor menu?
CH_Mayor.Config.MayorMenuChatCommand = "!baskan" -- Chat command to open the mayor menu.

CH_Mayor.Config.UsingSetAllowNonAsciiCharacters = false -- Set this to true if you need special characters like Russian/Chinese support for text entries https://wiki.facepunch.com/gmod/Panel:SetAllowNonAsciiCharacters

--[[
	VAULT CONFIG
--]]
CH_Mayor.Config.PermanentlySaveVaultMoney = false -- Should vault money be stored in the database and move over on server restarts?

CH_Mayor.Config.VaultGenerateMoney = true -- Should money automatically be generated in the vault?
CH_Mayor.Config.GenerateMoneyInterval = 60 -- Every x seconds money will be generated in the vault.
CH_Mayor.Config.GenerateMoneyMin = 50 -- Minimum amount of money generated in the vault every time the interval runs.
CH_Mayor.Config.GenerateMoneyMax = 150 -- Maximum amount of money generated in the vault every time the interval runs.

CH_Mayor.Config.VaultDefaultMax = 100000 -- The default max money the vault can hold

CH_Mayor.Config.VaultBodygroupLevels = { -- The bodygroups for the vault change based on how much money there is. For example it will be bodygroup 1 when it has 1 dollar and bodygroup 2 when it has 6000 dollars.
	[1] = 1,
	[2] = 6000,
	[3] = 9000,
	[4] = 18000,
	[5] = 27000,
	[6] = 36000,
	[7] = 45000,
}

CH_Mayor.Config.EnableDeposit = true -- Should mayor be able to deposit funds into the bank vault himself?
CH_Mayor.Config.DepositMaximumPerMayor = 5000 -- How much money can a mayor deposit in total? This resets when they're demoted/leaves

CH_Mayor.Config.EnableWithdraw = true -- Should mayor be able to withdraw money to himself from the vault?
CH_Mayor.Config.WithdrawMaximumPerMayor = 5000 -- How much money can a mayor withdraw in total? This resets when they're demoted/leaves

CH_Mayor.Config.MustBeCloseToVault = false -- If the mayor must be close to the vault to withdraw/deposit money?

--[[
	ROBBERY CONFIG
--]]
CH_Mayor.Config.MayorRequiredToRob = true -- If this is set to true then there must be an active mayor to rob the mayor vault.
CH_Mayor.Config.PoliceRequired = 3 -- How many police officers are required before a criminal can start a robbery?
CH_Mayor.Config.PlayersRequired = 5 -- How many total players are required to start a robbery?
CH_Mayor.Config.RobberyAliveTime = 1 -- For how many minutes must a player stay alive to succeed with the robbery? (IN MINUTES)
CH_Mayor.Config.RobberyDistance = 50000 -- How far away can the player move from the vault before the robbery fails
CH_Mayor.Config.RobberyCooldownTime = 5 -- How long time is the mayor vault on a cooldown (cannot be robbed) after a robbery attempt? (IN MINUTES)

CH_Mayor.Config.EmitSoundOnRob = true -- Should an alarm go off when the bank vault gets robbed.
CH_Mayor.Config.TheSound = "ambient/alarms/alarm_citizen_loop1.wav" -- The sound to be played.
CH_Mayor.Config.SoundVolume = 100 -- The sound volume for the alarm sound https://wiki.facepunch.com/gmod/Enums/SNDLVL
CH_Mayor.Config.SoundDuration = 30  -- Amount of seconds the sound should play for.

CH_Mayor.Config.KillReward = 5000 -- The reward for killing an active robber.

CH_Mayor.Config.XPSuccessfulRobbery = 100 -- XP given for succesfully robbing the vault.
CH_Mayor.Config.XPStoppingRobber = 50 -- XP given for killing a vault robber.

--[[
	OFFICIALS MANAGEMENT
	The first team is the team that can be promoted.
	The second part of the table are the teams that you can promote this team to.
	
	For example you can promote medics to medic chief or medic overhead.
	Or you can promote the police officer team to police chief.
--]]
CH_Mayor.Config.PromotableTeams = {
	["Medic"] = {
		"Medic Chief",
		"Medic Overhead",
	},
	["Police Officer"] = {
		"Police Chief",
	},
	["Police Chief"] = {
		"SWAT",
		"SWAT Chief",
	},
}

--[[
	CIVILIAN MANAGEMENT
--]]
CH_Mayor.Config.MaximumWantedTime = 300 -- Maximum amount of seconds mayor can make a player wanted for

--[[
	TAXES
	Console ommand to generate random taxes for all your darkrp teams: ch_mayor_randomtaxes
	Run it in your servers console (not in-game) and it will generate a table of random taxes for all your darkrp teams. You can then modify/remove teams afterwards.
--]]
CH_Mayor.Config.DisableTeamTaxWhenNoMayor = false -- If set to true then there will be a check to see if there is a mayor before taxing players on paychecks

CH_Mayor.Config.TeamsTaxes = { -- Teams and their default taxes. If team is not listed, then it does not pay taxes.
	["Citizen"] = 20,
}

CH_Mayor.Config.MaximumTeamTax = 80 -- What is the maximum team tax a team can have?

CH_Mayor.Config.ResetTeamTaxOnDemoted = true -- Should all team taxes reset to their default when a mayor leaves/is demoted?

CH_Mayor.Config.TaxMoneyGoesToCityVault = true -- Should money paid in taxes on paychecks go to the city vault? If true then yes, if false it just dissapears
CH_Mayor.Config.TaxMoneyCityVaultNotify = false -- Should the mayor receive a notitication of receiving money in vault when it's tax money from salaries? (Could case a little bit of spam with a lot of people)

CH_Mayor.Config.RotateTeamTaxesOnCityBoard = true -- Should team taxes (paycheck tax) be shown and rotate randomly on the city board?
CH_Mayor.Config.RotateTeamTaxesInterval = 15 -- Every x second it will shuffle the team tax shown on the board

--[[
	LAWS
--]]
CH_Mayor.Config.ResetLawsOnDemote = true -- Should laws reset when the mayor is demoted/leaves?

CH_Mayor.Config.NotifyAllOnNewLaw = true -- Should we notify all players that a new law was added?

CH_Mayor.Config.EnableCommandToPrintLaws = true -- Should the command below be enabled?
CH_Mayor.Config.CommandToPrintLaws = "!laws" -- Clientside chat command that allows players to print laws to chat.

--[[
	CATALOG
--]]
CH_Mayor.Config.RemoveCatalogEntsOnDemote = true -- Should we remove entities bought via catalog on demote? Like boards, screens, props, etc

--[[
	TRASHCAN
--]]
CH_Mayor.Config.TrashcanEntities = { -- List of entities that the trashcan can remove plus their min/max pays for trashing.
	["prop_physics"] = { 10, 50 }, -- The 10 is the minimum and 50 is the maximum reward for prop_physics throw in trash
	["drug"] = { 10, 50 },
	["drug_lab"] = { 10, 50 },
	["food"] = { 10, 50 },
	["gunlab"] = { 10, 50 },
	["letter"] = { 10, 50 },
	["microwave"] = { 10, 50 },
	["money_printer"] = { 10, 50 },
	["spawned_ammo"] = { 10, 50 },
	["spawned_food"] = { 10, 50 },
	["spawned_money"] = { 10, 50 },
	["spawned_shipment"] = { 10, 50 },
	["spawned_weapon"] = { 10, 50 },
}

CH_Mayor.Config.TrashcanModel = "models/props_junk/TrashDumpster01a.mdl" -- Sets the model for the trashcan
CH_Mayor.Config.EnableTrashReward = false -- Should players receive money for trashing items?

CH_Mayor.Config.EnableTrashXPReward = false -- If we should also receive XP rewards for trashing items.
CH_Mayor.Config.TrashXPReward = 10 -- How much XP?

--[[
	MAYOR DEATH
--]]
CH_Mayor.Config.DemoteMayorOnDeath = false -- Should the mayor be demoted on death?

--[[
	ANNOUNCEMENTS
--]]
CH_Mayor.Config.NewAnnouncementScreenFlashTime = 20 -- For how many seconds will the screen flash when a new announcement is made?

--[[
	INTEGRATIONS
--]]
CH_Mayor.Config.ZerosVendingMachineTax = false -- Should we charge a percentage of all sales and give to mayor funds?
CH_Mayor.Config.ZerosVendingMachineTaxPercetange = 2 -- How many percetange to tax and give to mayor funds per purchase in vending machine?
CH_Mayor.Config.ZerosVendingMachineTaxNotify = false -- Notify mayor about money being added when money is from vending machine tax.

CH_Mayor.Config.RealisticFastFoodTax = false -- Should we charge a percentage of all sales and give to mayor funds?
CH_Mayor.Config.RealisticFastFoodTaxPercetange = 2 -- How many percetange to tax and give to mayor funds per purchase of food from the terminals?
CH_Mayor.Config.RealisticFastFoodTaxNotify = false -- Notify mayor about money being added when money is from fast food sales.
--addons/ch_mayor/lua/ch_adv_mayor/shared/config/upgrades/upgrade_reinforced_doors.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/shared/config/upgrades/upgrade_reinforced_doors.lua:
CH_Mayor.Upgrades_ReinforcedDoorsTime = 0

CH_Mayor.Upgrades["upgrade_reinforced_doors"] = {
	Name = "Güçlendirilmiş Kapılar",
	Icon = Material( "materials/craphead_scripts/advanced_mayor/gui/upgrades/door.png", "noclamp smooth" ),
	Description = "Şehirdeki tüm kapıları güçlendirir.",
	Levels = {
		[1] = {
			Price = 75000,
			Description = "Kilit açma süresini 30 saniyeye çıkarır.",
			UpgradeFunction = function( ply )
				CH_Mayor.Upgrades_ReinforcedDoorsTime = 30

				hook.Add( "lockpickTime", "CH_Mayor_Upgrades_ReinforcedDoors", function( ply )
					return CH_Mayor.Upgrades_ReinforcedDoorsTime
				end )
			end,
		},
		[2] = {
			Price = 100000,
			Description = "Kilit açma süresini 45 saniyeye çıkarır.",
			UpgradeFunction = function( ply )
				CH_Mayor.Upgrades_ReinforcedDoorsTime = 45
			end,
		},
		[3] = {
			Price = 120000,
			Description = "Kilit açma süresini 60 saniyeye çıkarır.",
			UpgradeFunction = function( ply )
				CH_Mayor.Upgrades_ReinforcedDoorsTime = 60
			end,
		},
		[4] = {
			Price = 150000,
			Description = "Kilit açma süresini 75 saniyeye çıkarır.",
			UpgradeFunction = function( ply )
				CH_Mayor.Upgrades_ReinforcedDoorsTime = 75
			end,
		},
		[5] = {
			Price = 170000,
			Description = "Kilit açma süresini 90 saniyeye çıkarır.",
			UpgradeFunction = function( ply )
				CH_Mayor.Upgrades_ReinforcedDoorsTime = 90
			end,
		},
	},
	RemoveFunction = function( ply )
		hook.Remove( "lockpickTime", "CH_Mayor_Upgrades_ReinforcedDoors" )
		
		CH_Mayor.Upgrades_ReinforcedDoorsTime = 0
	end,
}

--addons/ch_mayor/lua/ch_adv_mayor/shared/ch_mayor_utils.lua:
local PMETA = FindMetaTable( "Player" )

--[[
	Language functions
--]]
function CH_Mayor.LangString( text )
	local translation = text .." (Translation missing)"
	local lang = CH_Mayor.Config.Language or "en"
	
	if CH_Mayor.Config.Lang[ text ] then
		translation = CH_Mayor.Config.Lang[ text ][ lang ]
	end
	
	return translation
end

--[[
	Check if player is mayor
--]]
function PMETA:CH_Mayor_IsMayor()
	return team.GetName( self:Team() ) == CH_Mayor.Config.MayorTeam
end

function PMETA:CH_Mayor_IsGovTeam()
	return CH_Mayor.Config.GovernmentTeams[ team.GetName( self:Team() ) ]
end

function PMETA:CH_Mayor_IsPoliceTeam()
	return CH_Mayor.Config.PoliceTeams[ team.GetName( self:Team() ) ]
end

function PMETA:CH_Mayor_IsCriminalTeam()
	return CH_Mayor.Config.CriminalTeams[ team.GetName( self:Team() ) ]
end

function PMETA:CH_Mayor_IsAdmin()
	return CH_Mayor.Config.AdminUsergroups[ self:GetUserGroup() ]
end

--[[
	Get the mayor
--]]
function CH_Mayor.GetMayor()
	local mayor = nil
	
	for k, ply in ipairs( player.GetAll() ) do
		if CH_Mayor.Config.MayorTeam == team.GetName( ply:Team() ) then
			mayor = ply
			
			break
		end
	end
	
	return mayor
end

--[[
	Get amount of government teams
--]]
function CH_Mayor.GetGovCount()
	local amount = 0
	
	for k, ply in ipairs( player.GetAll() ) do
		if ply:CH_Mayor_IsGovTeam() then
			amount = amount + 1
		end
	end
	
	return amount
end

--[[
	Get amount of police teams
--]]
function CH_Mayor.GetPoliceCount()
	local amount = 0
	
	for k, ply in ipairs( player.GetAll() ) do
		if ply:CH_Mayor_IsPoliceTeam() then
			amount = amount + 1
		end
	end
	
	return amount
end
--addons/ch_mayor/lua/ch_adv_mayor/client/ch_mayor_playtime.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/vgui/ch_mayor_menu_taxes.lua:
return gluapack()()
--addons/ch_mayor/lua/ch_adv_mayor/client/vgui/ch_mayor_menu_warrant.lua:
CH_Mayor.WarrantedPlayers = CH_Mayor.WarrantedPlayers or {}

net.Receive( "CH_Mayor_Net_RemoveWarrantedPlayer", function( len, ply )
	local target = net.ReadEntity()
	
	CH_Mayor.WarrantedPlayers[ target ] = nil
end )

net.Receive( "CH_Mayor_Net_UpdateWarrants", function( len, ply )
	local amount_of_entries = net.ReadUInt( 6 )
	
	for i = 1, amount_of_entries do
		local target = net.ReadEntity()
		local reason = net.ReadString()
		local time = net.ReadDouble()
		
		CH_Mayor.WarrantedPlayers[ target ] = {
			warrant_reason = reason,
			warrant_time = time,
		}
	end
end )

--[[
	MAYOR WARRANT MENU
--]]
function CH_Mayor.WarrantMenu()
	local ply = LocalPlayer()

	local GUI_WantedFrame = vgui.Create( "DFrame" )
	GUI_WantedFrame:SetTitle( "" )
	GUI_WantedFrame:SetSize( CH_Mayor.ScrW * 0.6, CH_Mayor.ScrH * 0.665 )
	GUI_WantedFrame:Center()
	GUI_WantedFrame.Paint = function( self, w, h )
		-- Draw frame
		surface.SetDrawColor( CH_Mayor.Colors.GrayFront )
		surface.DrawRect( 0, 0, w, h )
		
		-- Draw top
		surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h * 0.059 )
		
		-- Draw the top title.
		draw.SimpleText( CH_Mayor.LangString( "City Management" ), "CH_Mayor_Font_Size10", w / 2, h * 0.03, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		-- Draw titles
		surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
		surface.DrawRect( w * 0.182, h * 0.0724, w * 0.812, h * 0.06 )
		
		draw.SimpleText( "#", "CH_Mayor_Font_Size10", w * 0.2, h * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mayor.LangString( "Citizen" ), "CH_Mayor_Font_Size10", w * 0.375, h * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mayor.LangString( "Reason" ), "CH_Mayor_Font_Size10", w * 0.55, h * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mayor.LangString( "Time Remaining" ), "CH_Mayor_Font_Size10", w * 0.725, h * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		
		draw.SimpleText( CH_Mayor.LangString( "Action" ), "CH_Mayor_Font_Size10", w * 0.9, h * 0.1, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	GUI_WantedFrame:MakePopup()
	GUI_WantedFrame:SetDraggable( false )
	GUI_WantedFrame:ShowCloseButton( false )
	
	local GUI_CloseMenu = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_CloseMenu:SetPos( CH_Mayor.ScrW * 0.582, CH_Mayor.ScrH * 0.01 )
	GUI_CloseMenu:SetSize( CH_Mayor.ScrW * 0.0125, CH_Mayor.ScrH * 0.02223 )
	GUI_CloseMenu:SetText( "" )
	GUI_CloseMenu.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.Red or color_white )
		surface.SetMaterial( CH_Mayor.Materials.CloseIcon )
		surface.DrawTexturedRect( 0, 0, CH_Mayor.ScrW * 0.0125, CH_Mayor.ScrH * 0.02223 )
	end
	GUI_CloseMenu.DoClick = function()
		GUI_WantedFrame:Remove()
	end
	
	local GUI_DashboardFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_DashboardFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_DashboardFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.0475 )
	GUI_DashboardFrameBtn:SetText( "" )
	GUI_DashboardFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Dashboard )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Dashboard" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_DashboardFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.DashboardMenu()
	end

	local GUI_UpgradesFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_UpgradesFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_UpgradesFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.095 )
	GUI_UpgradesFrameBtn:SetText( "" )
	GUI_UpgradesFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Upgrades )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Upgrades" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_UpgradesFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.UpgradesMenu()
	end
	
	local GUI_TaxesFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_TaxesFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_TaxesFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.1425 )
	GUI_TaxesFrameBtn:SetText( "" )
	GUI_TaxesFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Taxes )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Taxes" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_TaxesFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.TaxesMenu()
	end

	local GUI_CatalogFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_CatalogFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_CatalogFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.19 )
	GUI_CatalogFrameBtn:SetText( "" )
	GUI_CatalogFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Catalog )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Catalog" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_CatalogFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.CatalogMenu()
	end
	
	local GUI_LawsFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_LawsFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_LawsFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.2375 )
	GUI_LawsFrameBtn:SetText( "" )
	GUI_LawsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Laws )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Laws" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_LawsFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.LawsMenu()
	end
	
	local GUI_WantedFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_WantedFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_WantedFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.285 )
	GUI_WantedFrameBtn:SetText( "" )
	GUI_WantedFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Licenses )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Licenses" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_WantedFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.LicensesMenu( )
	end
	
	local GUI_OfficialsManagementFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_OfficialsManagementFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_OfficialsManagementFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.3325 )
	GUI_OfficialsManagementFrameBtn:SetText( "" )
	GUI_OfficialsManagementFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_OfficialsManagement )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Officials" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_OfficialsManagementFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.OfficialsMenu()
	end
	
	local GUI_CiviliansManagementFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_CiviliansManagementFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_CiviliansManagementFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.38 )
	GUI_CiviliansManagementFrameBtn:SetText( "" )
	GUI_CiviliansManagementFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_CivilianManagement )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Civilians" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_CiviliansManagementFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.CiviliansMenu()
	end
	
	local GUI_WantedFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_WantedFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_WantedFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.4275 )
	GUI_WantedFrameBtn:SetText( "" )
	GUI_WantedFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Wanted )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Wanted" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_WantedFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.WantedMenu()
	end
	
	local GUI_WarrantFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_WarrantFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_WarrantFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.475 )
	GUI_WarrantFrameBtn:SetText( "" )
	GUI_WarrantFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( CH_Mayor.Colors.GMSBlue )
		surface.DrawRect( 0, 0, 2, h )
		
		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Warrant )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Warrant" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_WarrantFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.WarrantMenu()
	end
	
	local GUI_AnnouncementFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_AnnouncementFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_AnnouncementFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.5225 )
	GUI_AnnouncementFrameBtn:SetText( "" )
	GUI_AnnouncementFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Announcement )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Announcement" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_AnnouncementFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.AnnouncementMenu()
	end
	
	local GUI_LockdownFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_LockdownFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_LockdownFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.57 )
	GUI_LockdownFrameBtn:SetText( "" )
	GUI_LockdownFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Lockdown )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Lockdown" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_LockdownFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.LockdownMenu()
	end
	
	local GUI_StatsFrameBtn = vgui.Create( "DButton", GUI_WantedFrame )
	GUI_StatsFrameBtn:SetSize( CH_Mayor.ScrW * 0.1, CH_Mayor.ScrH * 0.04 )
	GUI_StatsFrameBtn:SetPos( CH_Mayor.ScrW * 0.005, CH_Mayor.ScrH * 0.6175 )
	GUI_StatsFrameBtn:SetText( "" )
	GUI_StatsFrameBtn.Paint = function( self, w, h )
		surface.SetDrawColor( self:IsHovered() and CH_Mayor.Colors.GMSBlue or CH_Mayor.Colors.GrayBG )
		surface.DrawRect( 0, 0, w, h )

		surface.SetDrawColor( color_white )
		surface.SetMaterial( CH_Mayor.Materials.Icon_Economy )
		surface.DrawTexturedRect( w * 0.065, h * 0.18, CH_Mayor.ScrW * 0.014065, CH_Mayor.ScrH * 0.025 )
		
		draw.SimpleText( CH_Mayor.LangString( "Statistics" ), "CH_Mayor_Font_Size9", w * 0.25, h / 2, self:IsHovered() and color_white or CH_Mayor.Colors.WhiteAlpha2, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
	end
	GUI_StatsFrameBtn.DoClick = function()
		GUI_WantedFrame:Remove()
		
		CH_Mayor.StatisticsMenu()
	end
	
	-- The list of players
	local total_players = player.GetCount()
	
	local GUI_PlayerList = vgui.Create( "DPanelList", GUI_WantedFrame )
	GUI_PlayerList:SetSize( CH_Mayor.ScrW * 0.491, CH_Mayor.ScrH * 0.563 )
	GUI_PlayerList:SetPos( CH_Mayor.ScrW * 0.109, CH_Mayor.ScrH * 0.095 )
	GUI_PlayerList:EnableVerticalScrollbar( true )
	GUI_PlayerList:EnableHorizontal( true )
	GUI_PlayerList:SetSpacing( 8.4 )
	GUI_PlayerList.Paint = function( self, w, h )
		draw.RoundedBox( 0, 0, 0, w, h, color_transparent )
	end
	if ( GUI_PlayerList.VBar ) then
		GUI_PlayerList.VBar.Paint = function( self, w, h ) -- BG
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_PlayerList.VBar.btnUp.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_PlayerList.VBar.btnGrip.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mayor.Colors.GMSBlue )
			surface.DrawRect( 0, 0, 7, h )
		end
		
		GUI_PlayerList.VBar.btnDown.Paint = function( self, w, h )
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			surface.DrawRect( 0, 0, 7, h )
		end
	end
	
	for k, v in pairs( CH_Mayor.WarrantedPlayers ) do
		if math.Round( v.warrant_time - CurTime() ) <= 0 then
			continue
		end
		
		local reason = v.warrant_reason
		
		local GUI_PlayerPanel = vgui.Create( "DPanelList" )
		GUI_PlayerPanel:SetSize( CH_Mayor.ScrW * 0.487, CH_Mayor.ScrH * 0.04 )
		GUI_PlayerPanel.Paint = function( self, w, h )
			-- Background
			surface.SetDrawColor( CH_Mayor.Colors.GrayBG )
			if total_players <= 13 then
				surface.DrawRect( 0, 0, w, h )
			else
				surface.DrawRect( 0, 0, w * 0.986, h )
			end
			
			-- Number
			draw.SimpleText( "0", "CH_Mayor_Font_Size8", w * 0.0225, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			
			-- Name
			draw.SimpleText( k:Nick(), "CH_Mayor_Font_Size8", w * 0.241, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			
			-- Reason
			if string.len( reason ) > 38 then
				reason = string.Left( reason, 38 ) ..".."
			end
			draw.SimpleText( reason, "CH_Mayor_Font_Size8", w * 0.455, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			
			local cur_time = CurTime()
			if math.Round( v.warrant_time - cur_time ) > 0 then
				draw.SimpleText( string.ToMinutesSeconds( math.Round( v.warrant_time - cur_time ) ), "CH_Mayor_Font_Size8", w * 0.67, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				draw.SimpleText( CH_Mayor.LangString( "Expired" ), "CH_Mayor_Font_Size8", w * 0.67, h / 2, CH_Mayor.Colors.Red, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end
			
		local GUI_RemoveWantedBtn = vgui.Create( "DButton", GUI_PlayerPanel )
		GUI_RemoveWantedBtn:SetSize( CH_Mayor.ScrW * 0.05, CH_Mayor.ScrH * 0.03 )
		GUI_RemoveWantedBtn:SetPos( CH_Mayor.ScrW * 0.408, CH_Mayor.ScrH * 0.005 )
		GUI_RemoveWantedBtn:SetText( "" )
		GUI_RemoveWantedBtn.Paint = function( self, w, h )
			if self:IsHovered() then
				surface.SetDrawColor( CH_Mayor.Colors.GrayFront )
				surface.DrawRect( 0, 0, w, h )
				
				surface.SetDrawColor( CH_Mayor.Colors.Red )
				surface.DrawRect( 0, 0, w, 1 )
				surface.DrawRect( 0, h-1, w, 1 )
				surface.DrawRect( w-1, 0, 1, h )
				surface.DrawRect( 0, 0, 1, h )
			else
				surface.SetDrawColor( CH_Mayor.Colors.GrayFront )
				surface.DrawRect( 0, 0, w, h )
				
				surface.SetDrawColor( CH_Mayor.Colors.Red )
				surface.DrawRect( 0, 0, 1, 10 )
				surface.DrawRect( 0, 0, 10, 1 )
				surface.DrawRect( 0, h-10, 1, 10 )
				surface.DrawRect( 0, h-1, 10, 1 )
				surface.DrawRect( w-1, 0, 1, 10 )
				surface.DrawRect( w-10, 0, 10, 1 )
				surface.DrawRect( w-1, h-10, 1, 10 )
				surface.DrawRect( w-10, h-1, 10, 1 )
			end
			
			draw.SimpleText( CH_Mayor.LangString( "Cancel" ), "CH_Mayor_Font_Size8", w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		GUI_RemoveWantedBtn.DoClick = function()
			net.Start( "CH_Mayor_Net_MakeUnwarrant" )
				net.WriteEntity( k )
			net.SendToServer()
			
			GUI_WantedFrame:Remove()
		end
		
		GUI_PlayerList:AddItem( GUI_PlayerPanel )
	end
end

-- 76561198347218024
--addons/ch_mining/lua/autorun/ch_mining_initialize.lua:
-- INITIALIZE SCRIPT
if SERVER then
	for k, v in ipairs( file.Find( "ch_mining/shared/config/*.lua", "LUA" ) ) do
		include( "ch_mining/shared/config/".. v )
		AddCSLuaFile( "ch_mining/shared/config/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_mining/shared/*.lua", "LUA" ) ) do
		include( "ch_mining/shared/".. v )
		AddCSLuaFile( "ch_mining/shared/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_mining/shared/currencies/*.lua", "LUA" ) ) do
		include( "ch_mining/shared/currencies/".. v )
		AddCSLuaFile( "ch_mining/shared/currencies/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_mining/server/*.lua", "LUA" ) ) do
		include( "ch_mining/server/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_mining/server/sql/*.lua", "LUA" ) ) do
		include( "ch_mining/server/sql/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_mining/client/*.lua", "LUA" ) ) do
		AddCSLuaFile( "ch_mining/client/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_mining/client/vgui/*.lua", "LUA" ) ) do
		AddCSLuaFile( "ch_mining/client/vgui/".. v )
	end
end

if CLIENT then
	for k, v in ipairs( file.Find( "ch_mining/shared/config/*.lua", "LUA" ) ) do
		include( "ch_mining/shared/config/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_mining/shared/*.lua", "LUA" ) ) do
		include( "ch_mining/shared/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_mining/shared/currencies/*.lua", "LUA" ) ) do
		include( "ch_mining/shared/currencies/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_mining/client/*.lua", "LUA" ) ) do
		include( "ch_mining/client/".. v )
	end
	
	for k, v in ipairs( file.Find( "ch_mining/client/vgui/*.lua", "LUA" ) ) do
		include( "ch_mining/client/vgui/".. v )
	end
end
--addons/ch_mining/lua/ch_mining/shared/config/ch_mining_config_bonuses.lua:
CH_Mining.Bonuses = CH_Mining.Bonuses or {}

--[[
	READ THIS ARTICLE HOW TO EDIT THIS FILE
	
	https://www.gmodstore.com/help/addon/mining/configuration-16/topics/bonuses
--]]

CH_Mining.Bonuses["bonus_minerals"] = {
	Name = "Double Minerals",
	RequiredLevel = 30,
	BonusFunction = function( ply, mineral, amount, xp )
		CH_Mining.AddMineral( ply, mineral, amount, true )
	end,
}

CH_Mining.Bonuses["bonus_xp"] = {
	Name = "Double XP",
	RequiredLevel = 4,
	BonusFunction = function( ply, mineral, amount, xp )
		CH_Mining.AddXP( ply, xp )
	end,
}

CH_Mining.Bonuses["bonus_money"] = {
	Name = "$5,000 DarkRP Money",
	RequiredLevel = 5,
	BonusFunction = function( ply, mineral, amount, xp )
		ply:addMoney( 5000 )
	end,
}

CH_Mining.Bonuses["bonus_skill_point"] = {
	Name = "Skill Point",
	RequiredLevel = 10,
	BonusFunction = function( ply, mineral, amount, xp )
		CH_Mining.AddSkill( ply, "Points" )
	end,
}
--addons/ch_mining/lua/ch_mining/shared/currencies/bricks_credit_store.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/shared/currencies/underdone.lua:
CH_Mining.Currencies[ "underdone" ] = {
	Name = "Underdone Money",
	
	AddMoney = function( ply, amount )
		ply:AddItem( "money", amount )
	end,
	
	TakeMoney = function( ply, amount )
		ply:RemoveItem( "money", -amount )
	end,
	
	GetMoney = function( ply )
		return ply.Data.Inventory["money"] or 0
	end,
	
	CanAfford = function( ply, amount )
		local cur_money = ply.Data.Inventory["money"] or 0
		
		return cur_money >= amount
	end,
	
	FormatMoney = function( amount )
		return "$" .. string.Comma( amount )
	end,
}
--addons/ch_mining/lua/ch_mining/client/ch_mining_client.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/ch_mining_fonts.lua:
--[[
	Create scaled fonts
--]]
local CH_Mining_FontSizes = { "6", "7", "8", "9", "10", "12", "14" }

local function CH_Mining_CreateFonts()
	for k, font in ipairs( CH_Mining_FontSizes ) do
		local font_path = "Open Sans"
		local boldness = 500
		
		-- Fonts
		surface.CreateFont( "CH_Mining_Font_Size".. font, {
			font = font_path, 
			size = ScreenScale( font ), 
			weight = boldness
		} )
	end
end

CH_Mining_CreateFonts()

--[[
	Non-Scaled fonts
--]]
surface.CreateFont( "CH_Mining_Font_3D2D_35", {
    font = "Open Sans", 
    size = 35,
    weight = 500
} )

surface.CreateFont( "CH_Mining_Font_3D2D_60", {
    font = "Open Sans", 
    size = 60,
    weight = 500
} )

surface.CreateFont( "CH_Mining_Font_3D2D_100", {
    font = "Open Sans", 
    size = 100,
    weight = 500
} )

surface.CreateFont( "CH_Mining_Font_3D2D_120", {
    font = "Open Sans", 
    size = 120,
    weight = 500
} )

surface.CreateFont( "CH_Mining_Font_3D2D_300", {
    font = "Open Sans", 
    size = 300,
    weight = 500
} )

surface.CreateFont( "CH_Mining_Font_Toolgun", {
    font = "Open Sans", 
    size = 30,
    weight = 500
} )

--[[
	Update when screen sizes changes
--]]
local function CH_Mining_OnScreenSizeChanged()
	CH_Mining.ScrW = ScrW()
	CH_Mining.ScrH = ScrH()
	
	-- Recreate fonts
    CH_Mining_CreateFonts()
end
hook.Add( "OnScreenSizeChanged", "CH_Mining_OnScreenSizeChanged", CH_Mining_OnScreenSizeChanged )
--addons/ch_mining/lua/ch_mining/client/ch_mining_hud.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/vgui/ch_mining_menu.lua:
CH_Mining.Colors = CH_Mining.Colors or {}
CH_Mining.Materials = CH_Mining.Materials or {}

CH_Mining.ScrW = ScrW()
CH_Mining.ScrH = ScrH()

--[[
	Cache materials
--]]
CH_Mining.Materials.CheckmarkIcon = Material( "materials/craphead_scripts/mining/gui/checkmark.png", "noclamp smooth" )
CH_Mining.Materials.CloseIcon = Material( "materials/craphead_scripts/mining/gui/close.png", "noclamp smooth" )
CH_Mining.Materials.BackIcon = Material( "materials/craphead_scripts/mining/gui/arrowbtn.png", "noclamp smooth" )
CH_Mining.Materials.CrosshairIcon = Material( "materials/craphead_scripts/mining/hud/crosshair.png", "noclamp smooth" )
CH_Mining.Materials.AutoFillIcon = Material( "materials/craphead_scripts/mining/gui/autofill.png", "noclamp smooth" )
CH_Mining.Materials.WavingHand = Material( "materials/craphead_scripts/mining/gui/waving_hand.png", "noclamp smooth" )

CH_Mining.Materials.ArrowUpIcon = Material( "materials/craphead_scripts/mining/gui/increase.png", "noclamp smooth" )
CH_Mining.Materials.ArrowDownIcon = Material( "materials/craphead_scripts/mining/gui/decrease.png", "noclamp smooth" )
CH_Mining.Materials.ArrowExchangeIcon = Material( "materials/craphead_scripts/mining/gui/arrow_exchange.png", "noclamp smooth" )

CH_Mining.Materials.MenuDashboard = Material( "materials/craphead_scripts/mining/gui/dashboard.png", "noclamp smooth" )
CH_Mining.Materials.MenuInventory = Material( "materials/craphead_scripts/mining/gui/inventory.png", "noclamp smooth" )
CH_Mining.Materials.MenuSkills = Material( "materials/craphead_scripts/mining/gui/skills.png", "noclamp smooth" )
CH_Mining.Materials.MenuCrafting = Material( "materials/craphead_scripts/mining/gui/crafting.png", "noclamp smooth" )
CH_Mining.Materials.MenuLeaderboard = Material( "materials/craphead_scripts/mining/gui/leaderboard.png", "noclamp smooth" )
CH_Mining.Materials.MenuTransactions = Material( "materials/craphead_scripts/mining/gui/transactions.png", "noclamp smooth" )
CH_Mining.Materials.MenuStats = Material( "materials/craphead_scripts/mining/gui/stats.png", "noclamp smooth" )
CH_Mining.Materials.MenuOptions = Material( "materials/craphead_scripts/mining/gui/options.png", "noclamp smooth" )

CH_Mining.Materials.Diamond = Material( "materials/craphead_scripts/mining/hud/diamond.png", "noclamp smooth" )
CH_Mining.Materials.StripesBG = Material( "materials/craphead_scripts/mining/gui/bg_stripes.png", "noclamp smooth" )
CH_Mining.Materials.SkillsInfo = Material( "materials/craphead_scripts/mining/gui/skills/info.png", "noclamp smooth" )

CH_Mining.Materials.SkillsPlus = Material( "materials/craphead_scripts/mining/gui/skills/plus.png", "noclamp smooth" )
CH_Mining.Materials.SkillsMinus = Material( "materials/craphead_scripts/mining/gui/skills/minus.png", "noclamp smooth" )

CH_Mining.Materials.CraftingInspect = Material( "materials/craphead_scripts/mining/gui/crafting/inspect.png", "noclamp smooth" )
CH_Mining.Materials.CraftingCost = Material( "materials/craphead_scripts/mining/gui/crafting/dollar.png", "noclamp smooth" )

CH_Mining.Materials.LeaderboardFirst = Material( "materials/craphead_scripts/mining/gui/leaderboards/first.png", "noclamp smooth" )
CH_Mining.Materials.LeaderboardSecond = Material( "materials/craphead_scripts/mining/gui/leaderboards/second.png", "noclamp smooth" )
CH_Mining.Materials.LeaderboardThird = Material( "materials/craphead_scripts/mining/gui/leaderboards/third.png", "noclamp smooth" )

--[[
	Cache colors
--]]
CH_Mining.Colors.GrayBG = Color( 30, 30, 30, 255 )
CH_Mining.Colors.GrayFront = Color( 22, 22, 22, 255 )
CH_Mining.Colors.GrayAlpha = Color( 22, 22, 22, 225 )

CH_Mining.Colors.Green = Color( 52, 178, 52, 255 )
CH_Mining.Colors.Red = Color( 201, 29, 29, 255 )
CH_Mining.Colors.WhiteAlpha = Color( 255, 255, 255, 5 )
CH_Mining.Colors.WhiteAlpha2 = Color( 255, 255, 255, 100 )
CH_Mining.Colors.GMSBlue = Color( 52, 152, 219, 255 )

--[[
	Net message to show mining menu
	-- 76561198314224586
--]]
net.Receive( "CH_Mining_Net_ShowMiningMenu", function( len, ply )
	CH_Mining.DashboardMenu()
end )
--addons/ch_mining/lua/ch_mining/client/vgui/ch_mining_menu_skills.lua:
return gluapack()()
--addons/ch_mining/lua/ch_mining/client/vgui/ch_mining_menu_transactions.lua:
return gluapack()()
--lua/autorun/crsk_versioncheck.lua:
return gluapack()()
--lua/autorun/crsk_versioncheck.lua:
/*
CrSkShared_VERSION = 20
CrSkShared_WVERSION = 0

if CLIENT then
	timer.Create("CL_CrSkShared_VersionCheck", 60, 0, function()
		http.Fetch("https://steamcommunity.com/workshop/filedetails/?id=935754808", function(body)
			local workshopVersion = tonumber(body:match('Version ([%d%.]+)%s') or "") or CrSkShared_VERSION
			local workshopVersion_Desc = tostring(body:match("%-%-%-.-Done") or "")
			if not CrSkShared_WasNotificated or CrSkShared_WVERSION < workshopVersion then
				if workshopVersion > CrSkShared_VERSION then
					CrSkShared_WVERSION = workshopVersion
					chat.AddText(Color(255,255,255),"CrSk Autos: Shared textures are outdated!\n", Color(0,255,255),"Workshop version: "..workshopVersion..". Your version: "..CrSkShared_VERSION..".\n"..workshopVersion_Desc.."\n")
					CrSkShared_WasNotificated = true
				end
			end
		end)
	end)
end
*/
--lua/autorun/egm_pm_kod_rebs.lua:
return gluapack()()
--addons/executioner_v2/lua/executioner_v2/ui/executioner_v2_avatar.lua:

	--> Credit to Dan for making this for me <--

	if not CLIENT then return end

	local function DrawCircle( x, y, radius, seg )
		local cir = {}
		table.insert( cir, { x = x, y = y } )
		for i = 0, seg do
			local a = math.rad( ( i / seg ) * -360 )
			table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius } )
		end
		local a = math.rad( 0 )
		table.insert( cir, { x = x + math.sin( a ) * radius, y = y + math.cos( a ) * radius } )
		surface.DrawPoly( cir )
	end

	local PANEL = {}

	function PANEL:Init()
		self.avatar = vgui.Create( "AvatarImage", self )
		self.avatar:SetPaintedManually( true )
	end
	function PANEL:PerformLayout()
		self.avatar:SetSize( self:GetWide(), self:GetTall() )
	end
	function PANEL:SetPlayer( ply, size )
		self.avatar:SetPlayer( ply, size )
	end
	function PANEL:Paint( w, h )
		render.ClearStencil()
		render.SetStencilEnable( true )

		render.SetStencilWriteMask( 1 )
		render.SetStencilTestMask( 1 )

		render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
		render.SetStencilPassOperation( STENCILOPERATION_ZERO )
		render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
		render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )
		render.SetStencilReferenceValue( 1 )

		draw.NoTexture()
		surface.SetDrawColor( Color( 0, 0, 0, 255 ) )
		DrawCircle( w/2, h/2, w/2, 48 )

		render.SetStencilFailOperation( STENCILOPERATION_ZERO )
		render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
		render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
		render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
		render.SetStencilReferenceValue( 1 )

		self.avatar:PaintManual()

		render.SetStencilEnable( false )
		render.ClearStencil()
		
	end
	
	vgui.Register( "CircleAvatar", PANEL )
--lua/gmodadminsuite/thirdparty/pon.lua:
--[[

DEVELOPMENTAL VERSION;

VERSION 1.2.2
Copyright thelastpenguin™

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author, thelastpenguin™, if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above still applies to the modified code.

	The author is not held responsible for any damages incured from the use of pon, you use it at your own risk.

DATA TYPES SUPPORTED:
 - tables  - 		k,v - pointers
 - strings - 		k,v - pointers
 - numbers -		k,v
 - booleans- 		k,v
 - Vectors - 		k,v
 - Angles  -		k,v
 - Entities- 		k,v
 - Players - 		k,v

CHANGE LOG
V 1.1.0
 - Added Vehicle, NPC, NextBot, Player, Weapon
V 1.2.0
 - Added custom handling for k,v tables without any array component.
V 1.2.1
 - fixed deserialization bug.

THANKS TO...
 - VERCAS for the inspiration.
]]


local pon = {};
_G.pon = _G.pon or pon

local type, count = type, table.Count ;
local tonumber = tonumber ;
local format = string.format;
do
	local type, count = type, table.Count ;
	local tonumber = tonumber ;
	local format = string.format;

	local encode = {};

	local tryCache ;

	local cacheSize = 0;

	encode['table'] = function( self, tbl, output, cache )

		if( cache[ tbl ] )then
			output[ #output + 1 ] = format('(%x)',  cache[tbl] );
			return ;
		else
			cacheSize = cacheSize + 1;
			cache[ tbl ] = cacheSize;
		end


    local first = next(tbl, nil)
    local predictedNumeric = 1
    local lastKey = nil
    -- starts with a numeric dealio
    if first == 1 then
      output[#output + 1] = '{'

      for k,v in next, tbl do
        if k == predictedNumeric then
          predictedNumeric = predictedNumeric + 1

          local tv = type(v)
          if tv == 'string' then
            local pid = cache[v]
            if pid then
              output[#output + 1] = format('(%x)', pid)
            else
              cacheSize = cacheSize + 1
              cache[v] = cacheSize
              self.string(self, v, output, cache)
            end
          else
            self[tv](self, v, output, cache)
          end

        else
          break
        end
      end

			predictedNumeric = predictedNumeric - 1
    else
      predictedNumeric = nil
    end

    if predictedNumeric == nil then
      output[#output + 1] = '[' -- no array component
    else
      output[#output + 1] = '~' -- array component came first so shit needs to happen
    end

    for k, v in next, tbl, predictedNumeric do
      local tk, tv = type(k), type(v)

      -- WRITE KEY
      if tk == 'string' then
        local pid = cache[ k ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ k ] = cacheSize;

          self.string( self, k, output, cache );
        end
      else
        self[tk](self, k, output, cache)
      end

      -- WRITE VALUE
      if( tv == 'string' )then
        local pid = cache[ v ];
        if( pid )then
          output[ #output + 1 ] = format('(%x)',  pid );
        else
          cacheSize = cacheSize + 1;
          cache[ v ] = cacheSize;

          self.string( self, v, output, cache );
        end
      else
        self[ tv ]( self, v, output, cache );
      end
    end

    output[#output + 1] = '}'
	end
	--    ENCODE STRING
	local gsub = string.gsub ;
	encode['string'] = function( self, str, output )
		--if tryCache( str, output ) then return end
		local estr, count = gsub( str, ";", "\\;");
		if( count == 0 )then
			output[ #output + 1 ] = '\''..str..';';
		else
			output[ #output + 1 ] = '"'..estr..'";';
		end
	end
	--    ENCODE NUMBER
	encode['number'] = function( self, num, output )
		if num%1 == 0 then
			if num < 0 then
				output[ #output + 1 ] = format( 'x%x;', -num );
			else
				output[ #output + 1 ] = format('X%x;', num );
			end
		else
			output[ #output + 1 ] = tonumber( num )..';';
		end
	end
	--    ENCODE BOOLEAN
	encode['boolean'] = function( self, val, output )
		output[ #output + 1 ] = val and 't' or 'f'
	end
	--    ENCODE VECTOR
	encode['Vector'] = function( self, val, output )
		output[ #output + 1 ] = ('v'..val.x..','..val.y)..(','..val.z..';');
	end
	--    ENCODE ANGLE
	encode['Angle'] = function( self, val, output )
		output[ #output + 1 ] = ('a'..val.p..','..val.y)..(','..val.r..';');
	end
	encode['Entity'] = function( self, val, output )
		output[ #output + 1] = 'E'..(IsValid( val ) and (val:EntIndex( )..';') or '#');
	end
	encode['Player']  = encode['Entity'];
	encode['Vehicle'] = encode['Entity'];
	encode['Weapon']  = encode['Entity'];
	encode['NPC']     = encode['Entity'];
	encode['NextBot'] = encode['Entity'];
	encode['PhysObj'] = encode['Entity'];

	encode['nil'] = function()
		output[ #output + 1 ] = '?';
	end
	encode.__index = function( key )
		ErrorNoHalt('Type: '..key..' can not be encoded. Encoded as as pass-over value.');
		return encode['nil'];
	end

	do
		local empty, concat = table.Empty, table.concat ;
		function pon.encode( tbl )
			local output = {};
			cacheSize = 0;
			encode[ 'table' ]( encode, tbl, output, {} );
			local res = concat( output );

			return res;
		end
	end
end

do
	local tonumber = tonumber ;
	local find, sub, gsub, Explode = string.find, string.sub, string.gsub, string.Explode ;
	local Vector, Angle, Entity = Vector, Angle, Entity ;

	local decode = {};
	decode['{'] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tv = sub( str, index, index );
			if( not tv or tv == '~' )then
				index = index + 1;
				break ;
			end
			if( tv == '}' )then
				return index + 1, cur;
			end

			-- READ THE VALUE
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );
			cur[ k ] = v;

			k = k + 1;
		end

		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY

			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end
	decode['['] = function( self, index, str, cache )

		local cur = {};
		cache[ #cache + 1 ] = cur;

		local k, v, tk, tv = 1, nil, nil, nil;
		while( true )do
			tk = sub( str, index, index );
			if( not tk or tk == '}' )then
				index = index + 1;
				break ;
			end

			-- READ THE KEY
			index = index + 1;
			index, k = self[ tk ]( self, index, str, cache );
			if not k then continue end

			-- READ THE VALUE
			tv = sub( str, index, index );
			index = index + 1;
			if not self[tv] then
				print('did not find type: '..tv)
			end
			index, v = self[ tv ]( self, index, str, cache );

			cur[ k ] = v;
		end

		return index, cur;
	end

	-- STRING
	decode['"'] = function( self, index, str, cache )
		local finish = find( str, '";', index, true );
		local res = gsub( sub( str, index, finish - 1 ), '\\;', ';' );
		index = finish + 2;

		cache[ #cache + 1 ] = res;
		return index, res;
	end
	-- STRING NO ESCAPING NEEDED
	decode['\''] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local res = sub( str, index, finish - 1 )
		index = finish + 1;

		cache[ #cache + 1 ] = res;
		return index, res;
	end

	-- NUMBER
	decode['n'] = function( self, index, str, cache )
		index = index - 1;
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, num;
	end
	decode['0'] = decode['n'];
	decode['1'] = decode['n'];
	decode['2'] = decode['n'];
	decode['3'] = decode['n'];
	decode['4'] = decode['n'];
	decode['5'] = decode['n'];
	decode['6'] = decode['n'];
	decode['7'] = decode['n'];
	decode['8'] = decode['n'];
	decode['9'] = decode['n'];
	decode['-'] = decode['n'];
	-- positive hex
	decode['X'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end
	-- negative hex
	decode['x'] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = -tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, num;
	end

	-- POINTER
	decode['('] = function( self, index, str, cache )
		local finish = find( str, ')', index, true );
		local num = tonumber( sub( str, index, finish - 1), 16 );
		index = finish + 1;
		return index, cache[ num ];
	end

	-- BOOLEAN. ONE DATA TYPE FOR YES, ANOTHER FOR NO.
	decode[ 't' ] = function( self, index )
		return index, true;
	end
	decode[ 'f' ] = function( self, index )
		return index, false;
	end

	-- VECTOR
	decode[ 'v' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local vecStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', vecStr, false );
		return index, Vector( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ANGLE
	decode[ 'a' ] = function( self, index, str, cache )
		local finish =  find( str, ';', index, true );
		local angStr = sub( str, index, finish - 1 );
		index = finish + 1; -- update the index.
		local segs = Explode( ',', angStr, false );
		return index, Angle( tonumber( segs[1] ), tonumber( segs[2] ), tonumber( segs[3] ) );
	end
	-- ENTITY
	decode[ 'E' ] = function( self, index, str, cache )
		if( str[index] == '#' )then
			index = index + 1;
			return index, NULL ;
		else
			local finish = find( str, ';', index, true );
			local num = tonumber( sub( str, index, finish - 1 ) );
			index = finish + 1;
			return index, Entity( num );
		end
	end
	-- PLAYER
	decode[ 'P' ] = function( self, index, str, cache )
		local finish = find( str, ';', index, true );
		local num = tonumber( sub( str, index, finish - 1 ) );
		index = finish + 1;
		return index, Entity( num ) or NULL;
	end
	-- NIL
	decode['?'] = function( self, index, str, cache )
		return index + 1, nil;
	end


	function pon.decode( data )
		local _, res = decode[sub(data,1,1)]( decode, 2, data, {});
		return res;
	end
end
--lua/gmodadminsuite/sh_language.lua:
return gluapack()()
--lua/gmodadminsuite/lang/chinese.lua:
return {
    Name = "Chinese",
    Flag = "flags16/cn.png",
    Phrases = function()
        return {
            open_menu = "打开菜单",
            menu_nopermission = "对不起，您没有权限访问GmodAdminSuite菜单。",
            menu_unknown_module = "对不起，该名称的模块未安装或不存在。",
            menu_disabled_module = "对不起，该模块已禁用。",
            menu_module_nopermission = "对不起，您没有权限访问此模块。",
            open_gas = "打开GmodAdminSuite",
            module_shortcut = "模块快捷方式",
            module_reset_data = "重置模块位置/大小",
            module_shortcut_info = [[
                您可以通过控制台和聊天命令快速访问此GmodAdminSuite模块。

                通过控制台访问模块，请输入：%s
                通过聊天访问模块，请输入：%s

                此外，您可以将键盘上的键绑定到特定模块。
                要做到这一点，请在控制台中输入：%s

                请确保将KEY替换为您选择的键盘上的键。
            %s]],
            close = "关闭",
            wiki = "维基",
            licensee = "许可证持有者",
            support = "支持",
            module_shop = "模块商店",
            welcome = "欢迎",
            operator = "操作员",
            script_page = "脚本页面",
            no_modules_available = "没有可用的模块！",
            no_modules_available_info = [[
                对不起，没有可供您使用的GmodAdminSuite模块。
		        您可能没有足够的权限使用任何模块，或者没有启用任何模块。
            ]],
            custom_ellipsis = "自定义...",
            usergroup_ellipsis = "用户组...",
            steamid_ellipsis = "SteamID...",
            enter_steamid_ellipsis = "输入SteamID...",
            by_distance = "按距离",
            by_usergroup = "按用户组",
            by_team = "按团队",
            by_name = "按名称",
            right_click_to_focus = "右键点击聚焦",
            unknown = "未知",
            utilities = "实用工具",
            player_management = "玩家管理",
            administration = "管理",
            s_second = "1秒",
            s_seconds = "%d秒",
            s_minute = "1分钟",
            s_minutes = "%d分钟",
            s_hour = "1小时",
            s_hours = "%d小时",
            second_ago = "1秒前",
            seconds_ago = "%d秒前",
            minute_ago = "1分钟前",
            minutes_ago = "%d分钟前",
            hour_ago = "1小时前",
            hours_ago = "%d小时前",
            just_now = "刚刚",
            click_to_focus = "点击聚焦",
            add_steamid = "自定义SteamID",
            copied = "已复制！",
            settings = "设置",
            add_steamid_help = [[
                输入SteamID或SteamID64。例如：
                SteamID：%s
                SteamID64：%s
            ]],

            setting_default_module = "默认模块",
            setting_default_module_tip = "打开GmodAdminSuite主菜单时应打开哪个模块？",
            none = "无",
            general = "通用",
            localization = "本地化",
            setting_menu_voicechat = "打开GAS菜单时允许语音聊天",
            setting_menu_voicechat_tip = "GmodAdminSuite的菜单不会阻止您的语音聊天键。如果此选项开启，只需按下您的语音聊天键即可在菜单中进行交谈。",
            use_gas_language = "使用GmodAdminSuite语言",
            default_format = "默认格式",
            short_date_format = "短日期格式",
            long_date_format = "长日期格式",
            short_date_format_tip = "用于较短日期格式的日期格式\n\n默认格式会自动匹配您所在地区的日期格式（北美、欧洲等）",
            long_date_format_tip = "用于较长日期格式的日期格式",
            permissions = "权限",
            module_enable_switch_tip = "此更改只会在服务器重启/地图更改后应用",
            enabled = "已启用",
            modules = "模块",
            permissions_help = [[
                GmodAdminSuite使用了一个名为OpenPermissions的开源权限库，由Billy为GAS开发。它为任何大小的服务器上运行的高级系统提供了优化的权限处理。
		
                OpenPermissions是您将控制哪些组可以访问哪些模块以及他们可以对这些模块做什么的地方。
                您可以随时通过在聊天中输入"!openpermissions"或在控制台中输入"openpermissions"来打开它。

                需要帮助和信息，请点击OpenPermissions菜单中的"帮助"标签。
            ]],
            website = "网站",
            fun = "权限",

            bvgui_copied = "已复制！",
            bvgui_open_context_menu = "打开上下文菜单",
            bvgui_open_steam_profile = "打开Steam个人资料",
            bvgui_right_click_to_focus = "右键点击聚焦",
            bvgui_click_to_focus = "点击聚焦",
            bvgui_unknown = "未知",
            bvgui_no_data = "无数据",
            bvgui_no_results_found = "未找到结果",
            bvgui_done = "完成",
            bvgui_enter_text_ellipsis = "输入文本...",
            bvgui_loading_ellipsis = "加载中...",
            bvgui_pin_tip = "按ESC再次点击菜单",
            bvgui_click_to_render = "点击渲染",
            bvgui_teleport = "传送",
            bvgui_inspecting = "检查中",
            bvgui_inspect = "检查",
            bvgui_screenshot = "截图",
            bvgui_ok = "确定",
            bvgui_screenshot_saved = "截图已保存",
            bvgui_screenshot_saved_to = "截图已保存到您的电脑上的%s",
            bvgui_reset = "重置",
            bvgui_right_click_to_stop_rendering = "右键点击停止渲染",

            settings_player_popup_close = "当\n他们失去焦点时关闭玩家弹窗",
            settings_player_popup_close_tip = "当您点击不同菜单时，玩家弹窗是否应该关闭？"
        }
    end
}

--addons/[binbon]misc/lua/gmodadminsuite/modules/fpsbooster/lang/english.lua:
return gluapack()()
--lua/gmodadminsuite/sh_registry_tbl.lua:
return gluapack()()
--addons/gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/_gas_info.lua:
return gluapack()()
--addons/gmodadminsuite-logging-2.4.8/lua/gmodadminsuite/modules/logging/sh_init.lua:
return gluapack()()
--lua/gmodadminsuite/modules/playerdatabase/sh_init.lua:
if (SERVER) then
	AddCSLuaFile("gmodadminsuite/modules/playerdatabase/sh_playerdatabase.lua")
end

GAS:hook("gmodadminsuite:LoadModule:playerdatabase", "LoadModule:playerdatabase", function()
	include("gmodadminsuite/modules/playerdatabase/sh_playerdatabase.lua")
end)
--lua/gmodadminsuite/modules/secondaryusergroups/_gas_info.lua:
return gluapack()()
--lua/gmodadminsuite/cl_menubar.lua:
return gluapack()()
--addons/gprofiler/lua/gprofiler/sh_config.lua:
return gluapack()()
--addons/gprofiler/lua/gprofiler/sh_utils.lua:
return gluapack()()
--addons/gprofiler/lua/gprofiler/profilers/functions/sh_functions.lua:
GProfiler.Functions = GProfiler.Functions or {}
GProfiler.Functions.IsDetoured = GProfiler.Functions.IsDetoured or false
GProfiler.Functions.ProfileData = GProfiler.Functions.ProfileData or {}
GProfiler.Functions.Focus = GProfiler.Functions.Focus or false

local SysTime = SysTime

-- Chunked net messages to avoid net message overflow
local chunkSizeLimit = 90000 -- 187765611992257692146877

local recurse = {}
local startTimes = {}
local IgnoreCache = {}

local function handleFunction(event)
	local time = SysTime()
	local func = event.func

	if IgnoreCache[func] or string.find(event.short_src, "/lua/gprofiler/", 1, true) then IgnoreCache[func] = true return end

	if not recurse[func] then recurse[func] = 0 end
	recurse[func] = recurse[func] + 1

	startTimes[func] = time
end

local function handleReturn(event)
	local time = SysTime()
	local func = event.func

	if GProfiler.Functions.Focus then
		if not GProfiler.Functions.Focus[tostring(func)] then return end
	end

	if not startTimes[func] then return end

	local runTime = time - startTimes[func]

	if not GProfiler.Functions.ProfileData[func] then
		local fstr = tostring(func)
		fstr = string.Replace(fstr, "function: ", "")
		GProfiler.Functions.ProfileData[func] = {
			name = event.name and string.format("%s (%s)", fstr, event.name) or fstr,
			source = event.short_src,
			lines = event.linedefined .. " - " .. event.lastlinedefined,
			calls = 0,
			time = 0,
			average = 0,
			focus = tostring(func)
		}
	end

	GProfiler.Functions.ProfileData[func].time = GProfiler.Functions.ProfileData[func].time + runTime
	GProfiler.Functions.ProfileData[func].calls = GProfiler.Functions.ProfileData[func].calls + 1
	GProfiler.Functions.ProfileData[func].average = GProfiler.Functions.ProfileData[func].time / GProfiler.Functions.ProfileData[func].calls

	recurse[func] = recurse[func] - 1
	if recurse[func] == 0 then recurse[func] = nil end
end

local function onEvent(event)
	local info = debug.getinfo(3)
	if not info then return end
	local func = info.func

	if event == "call" or event == "tail call" then
		handleFunction(info)
	else
		if not recurse[func] or recurse[func] == 0 then return end
		handleReturn(info)
	end
end

function GProfiler.Functions:StartProfiler(ply)
	if not GProfiler.Access.HasAccess(ply or LocalPlayer()) or GProfiler.Functions.IsDetoured then return end

	GProfiler.Log((SERVER and "Server" or "Client") .. " function profiler started!", 2)
	GProfiler.Functions.ProfileData = {}
	GProfiler.Functions.IsDetoured = true
	GProfiler.Functions.ProfileStarted = SysTime()

	recurse = {}
	startTimes = {}

	debug.sethook(function(event) onEvent(event) end, "cr")
end

function GProfiler.Functions:RestoreFunctions(ply)
	if not GProfiler.Access.HasAccess(ply or LocalPlayer()) or not GProfiler.Functions.IsDetoured then return end

	GProfiler.Log((SERVER and "Server" or "Client") .. " function profile stopped, sending data!", 2)
	GProfiler.Functions.IsDetoured = false
	GProfiler.Functions.ProfileStarted = nil

	debug.sethook()

	if SERVER then
		local chunks = {}
		local chunkCount = 1
		local currentChunkSize = 0
		for k, v in pairs(GProfiler.Functions.ProfileData) do
			local curChunkSize = 61 + (v.name and string.len(v.name) or 7) + string.len(v.source) + string.len(v.lines) + string.len(v.focus)
			local chunkSize = currentChunkSize + curChunkSize
			if chunkSize > chunkSizeLimit then
				chunkCount = chunkCount + 1
				currentChunkSize = 0
				chunkSize = 0
			end

			if not chunks[chunkCount] then chunks[chunkCount] = {} end
			table.insert(chunks[chunkCount], v)
			currentChunkSize = chunkSize
		end

		if table.IsEmpty(chunks) then
			net.Start("GProfiler_Functions_SendData", true)
			net.WriteBool(true)
			net.WriteBool(true)
			net.WriteUInt(0, 32)
			net.Send(ply)
			return
		end

		local i = 1
		local function sendChunk()
			if not chunks[i] then return end
			net.Start("GProfiler_Functions_SendData")
			net.WriteBool(i == 1)
			net.WriteBool(i == table.Count(chunks))
			net.WriteUInt(table.Count(chunks[i]), 32)
			for k, v1 in ipairs(chunks[i]) do
				net.WriteString(v1.name or "Unknown")
				net.WriteString(v1.source)
				net.WriteString(v1.lines)
				net.WriteUInt(v1.calls, 22)
				net.WriteFloat(v1.time)
				net.WriteFloat(v1.average)
				net.WriteString(v1.focus)
			end
			net.Send(ply)

			i = i + 1
			timer.Simple(.2, sendChunk)
		end
		sendChunk()
	end
end

if SERVER then
	util.AddNetworkString("GProfiler_Functions_ToggleServerProfile")
	util.AddNetworkString("GProfiler_Functions_ServerProfileStatus")
	util.AddNetworkString("GProfiler_Functions_SendData")

	net.Receive("GProfiler_Functions_ToggleServerProfile", function(len, ply)
		if not GProfiler.Access.HasAccess(ply) then return end

		local startStop = net.ReadBool()
		if startStop then
			local hasFocus = net.ReadBool()
			if hasFocus then
				local count = net.ReadUInt(5)
				GProfiler.Functions.Focus = {}
				for i = 1, count do
					GProfiler.Functions.Focus[net.ReadString()] = true
				end
			else
				GProfiler.Functions.Focus = false
			end

			GProfiler.Functions:StartProfiler(ply)
			net.Start("GProfiler_Functions_ServerProfileStatus")
			net.WriteBool(true)
			net.WriteEntity(ply)
			net.Broadcast()
		else
			GProfiler.Functions:RestoreFunctions(ply)
			net.Start("GProfiler_Functions_ServerProfileStatus")
			net.WriteBool(false)
			net.WriteEntity(ply)
			net.Broadcast()
		end
	end)
end

--addons/gprofiler/lua/gprofiler/profilers/timers/cl_timers.lua:
return gluapack()()
--addons/gprotect_1.13.99/lua/autorun/gprotect_loader.lua:
return gluapack()()
--lua/autorun/hitman_absolution_47_classic.lua:
return gluapack()()
--lua/autorun/jesse_pinkman_pm.lua:
return gluapack()()
--lua/autorun/jesse_pinkman_pm.lua:
player_manager.AddValidModel( "Jesse Pinkman", "models/breaking_bad/jesse_pinkman.mdl" )
list.Set( "PlayerOptionsModel",  "Jesse Pinkman", "models/breaking_bad/jesse_pinkman.mdl" )
--lua/autorun/john_martson_default.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/minigames/languages/english.lua:
--[[--------------------------------------------
               English Translation
--------------------------------------------]]--

-- Translation made by me, vicentefelipechile
Minigames.Language["english"] = {
    -- General
    ["tool.desc"] = "Use this tool to create minigames automatically",
    ["tool.left"] = "Create Minigames - Add/Remove players from your minigame",
    ["tool.right"] = "Setup Minigames",
    ["tool.reload"] = "Special option, for example: Pause the minigame",
    ["tool.singleplayer"] = "Warning: You are playing in singleplayer mode, the reload button will not work correctly",

    ["setupmenu.title"] = "Minigame Tool Assistant - Setup",
    ["setupmenu.togglegame"] = "Start / Stop the current minigame",
    ["setupmenu.players"] = "Current players",

    ["reward.title"] = "Rewards",
    ["reward.select"] = "Select a reward",
    ["reward.desc"] = "Rewards are given at the end of the minigame. \nThe winning player will receive the reward according to what was selected and the amount.",
    ["reward.onlyone"] = "The prize is the same %str",
    ["reward.nothing"] = "No reward selected",
    ["reward.disabled"] = "You must have a game ready to add rewards",
    ["reward.add"] = "Add reward",
    ["reward.none"] = "%ply has won the minigame!",
    ["reward.given"] = "%ply has won %str",

    ["playerlist.add"] = "Add player",
    ["playerlist.remove"] = "Remove player",
    ["playerlist.toggle"] = "Toggle player",
    ["playerlist.sendtogame"] = "Send player to minigame",
    ["playerlist.sendtooldpos"] = "Send player to their previous position",
    ["playerlist.sendtospawn"] = "Send player to their spawn",
    ["playerlist.mute"] = "Mute player",
    ["playerlist.unmute"] = "Unmute player",
    ["playerlist.hearowner"] = "Players can hear the owner",
    ["playerlist.muteall"] = "Mute all players",
    ["playerlist.hearself"] = "Use voice without proximity",

    ["playerlist.broadcast"] = "Create an announce to join the minigame",
    ["playerlist.broadcast.alreadywaiting"] = "Currently another minigame owner is looking for players, wait for it to finish before using this",
    ["playerlist.broadcast.join"] = "%ply is organizing a minigame, join by typing in chat: %str",
    ["playerlist.broadcast.gameremoved"] = "%ply's minigame has been canceled",
    ["playerlist.broadcast.gamestarted"] = "%ply's minigame has already started, no more entries are accepted",

    ["minigames.title"] = "Minigames",
    ["minigames.desc"] = "Description:",
    ["minigames.selectone"] = "Select a minigame",
    ["minigames.gameconfig"] = "Game configuration",
    ["minigames.playzoneconfig"] = "Play zone",
    ["minigames.onjoin"] = "Player %ply has joined the game",
    ["minigames.onleft"] = "Player %ply has left the game",
    ["minigames.onlose"] = "%ply has lost the game!",
    ["minigames.gamestopped"] = "The minigame has been canceled, no one wins!",
    ["minigames.removeyourgame"] = "Remove your current game before changing to another",

    ["minigames.player.notingame"] = "Player %ply is not in the game!",
    ["minigames.player.alreadyingame"] = "Player %ply is already in the game!",
    ["minigames.player.cantjoin"] = "Player %ply cannot join your game, they are already in one or belong to another!",
    ["minigames.player.cantjoin.dead"] = "Player %ply is dead!",
    ["minigames.player.cantjoin.you"] = "You cannot join this game!",
    ["minigames.player.cantjoin.owner"] = "This player cannot join your game!",

    ["minigames.error.gameisactive"] = "You have to stop your game before deleting it!",
    ["minigames.error.gamedontexists"] = "That minigame does not exist!",
    ["minigames.error.gameneed"] = "You have not created a game yet!",

    ["minigame_ammo"] = "Ammo",
    ["minigame_health"] = "Health",
    ["minigame_spawnpoint"] = "Respawn point",
    ["minigame_weapon"] = "Weapon",
    ["minigame_armor"] = "Armor",

    -- Plataforms (I noticed it was misspelled, it should be "Platforms" but I will keep it as it is, cuz idk)
    ["plataforms.name"] = "Platforms",
    ["plataforms.desc"] = "A platform game where the goal is to avoid falling while gradually more platforms disappear per round.",
    ["plataforms.tip"] = "To pause the game, use the reload key (R)",
    ["plataforms.sizex"] = "Width",
    ["plataforms.sizex.desc"] = "Amount of platforms that will be created in width in the game",
    ["plataforms.sizey"] = "Length",
    ["plataforms.sizey.desc"] = "Amount of platforms that will be created in length in the game",
    ["plataforms.increment"] = "Increment per round",
    ["plataforms.increment.desc"] = "Amount of platforms that must disappear per round",
    ["plataforms.delay"] = "Delay",
    ["plataforms.delay.desc"] = "Time before the platform disappears completely",
    ["plataforms.min"] = "Start (Minimum)",
    ["plataforms.min.desc"] = "Minimum percentage of platforms with which the game will start",
    ["plataforms.max"] = "End (Maximum)",
    ["plataforms.max.desc"] = "Maximum percentage of platforms that must disappear",
    ["plataforms.timereaction"] = "Reaction time",
    ["plataforms.timereaction.desc"] = "Time that players have to react before the platform disappears",
    ["plataforms.offset"] = "Distance",
    ["plataforms.offset.desc"] = "Separation distance that will be between each platform",
    ["plataforms.height"] = "Height",
    ["plataforms.height.desc"] = "Height at which the game will be created",

    -- Drop Out
    ["dropout.name"] = "Drop Out",
    ["dropout.desc"] = "A platform game is where the goal is to avoid falling while the platforms disappear forever.",
    ["dropout.tip"] = "To pause the game, use the reload key (R)",
    ["dropout.sizex"] = "Width",
    ["dropout.sizex.desc"] = "Width of the game in platforms",
    ["dropout.sizey"] = "Length",
    ["dropout.sizey.desc"] = "Length of the game in platforms",
    ["dropout.increment"] = "Increment per round",
    ["dropout.increment.desc"] = "Platforms that will disappear per round",
    ["dropout.delay"] = "Time per rounds",
    ["dropout.delay.desc"] = "How much time will pass since a platform disappears until the next one disappears",
    ["dropout.timereaction"] = "Reaction time",
    ["dropout.timereaction.desc"] = "Time that players have to react before the platform disappears",
    ["dropout.offset"] = "Distance",
    ["dropout.offset.desc"] = "Separation distance that will be between each platform",
    ["dropout.height"] = "Height",
    ["dropout.height.desc"] = "Height at which the game will be created",

    -- Red Light Green Light
    ["cigarrillo43.name"] = "Red Light Green Light",
    ["cigarrillo43.desc"] = "Players must pass through the path to reach the end, the first player to reach is the winner.",
    ["cigarrillo43.tip"] = "To alternate red light and green light, use the reload key (R)",
    ["cigarrillo43.sizex"] = "Width",
    ["cigarrillo43.sizex.desc"] = "Amount of platforms that will be created in width in the game",
    ["cigarrillo43.sizey"] = "Length",
    ["cigarrillo43.sizey.desc"] = "Amount of platforms that will be created in length in the game",
    ["cigarrillo43.safetime"] = "Reaction time",
    ["cigarrillo43.safetime.desc"] = "How much time (In seconds) players have to react and stop when they say Red Light",
    ["cigarrillo43.height"] = "Height",
    ["cigarrillo43.height.desc"] = "Height at which the game will be created",
    ["cigarrillo43.onespawn"] = "One spawn",
    ["cigarrillo43.onespawn.desc"] = "By activating this, players will appear in a single spawn",

    -- Simon says
    ["simonsays.name"] = "Simon says",
    ["simonsays.desc"] = "Players must follow the colors shown on the screens, the last player standing is the winner.",
    ["simonsays.tip"] = "To pause the game, use the reload key (R)",
    ["simonsays.sizex"] = "Width",
    ["simonsays.sizex.desc"] = "Amount of platforms that will be created in width in the game",
    ["simonsays.sizey"] = "Length",
    ["simonsays.sizey.desc"] = "Amount of platforms that will be created in length in the game",
    ["simonsays.offset"] = "Distance",
    ["simonsays.offset.desc"] = "Separation distance that will be between each platform",
    ["simonsays.timereaction"] = "Reaction time",
    ["simonsays.timereaction.desc"] = "Time that players have to react before the platform disappears",
    ["simonsays.substracttimereaction"] = "Faster reaction time",
    ["simonsays.substracttimereaction.desc"] = "How much the reaction time will be reduced per round",
    ["simonsays.delay"] = "Time per round",
    ["simonsays.delay.desc"] = "Time before the platform disappears completely (This time is affected by 'Subtract time')",
    ["simonsays.substracttime"] = "Faster rounds",
    ["simonsays.substracttime.desc"] = "How many seconds will make the game faster per round",
    ["simonsays.height"] = "Height",
    ["simonsays.height.desc"] = "Height at which the game will be created",
    ["simonsays.amountcolors"] = "Amount of colors",
    ["simonsays.amountcolors.desc"] = "Amount of colors that will be used in the game",
    ["simonsays.samecolors"] = "Same colors",
    ["simonsays.samecolors.desc"] = "By activating this, the colors will remain the same for each round",

    -- Russian Roulette
    ["russianroulette.name"] = "Russian roulette",
    ["russianroulette.desc"] = "A minigame that consists of luck, players have 2 options to shoot or skip, the last player alive is the winner.",
    ["russianroulette.tip"] = "Players receive a weapon when it is their turn to shoot.",
    ["russianroulette.decisiontime"] = "Decision time",
    ["russianroulette.decisiontime.desc"] = "Time that players have to decide whether to shoot or skip (Only if the decision time is activated)",
    ["russianroulette.magazinesize"] = "Magazine size",
    ["russianroulette.magazinesize.desc"] = "How many bullets the weapon's magazine will have",
    ["russianroulette.resetonfire"] = "Reset on fire",
    ["russianroulette.resetonfire.desc"] = "When a player fires the weapon, the magazine will change the bullet where the weapon is and the position will be reset",
    ["russianroulette.header.bots"] = "Bots",
    ["russianroulette.bots"] = "Amount of Bots",
    ["russianroulette.bots.desc"] = "How many bots will have the game",
    ["russianroulette.hud.primaryattack"] = "Test your luck by firing the weapon",
    ["russianroulette.hud.secondaryattack"] = "Not taking the risk and skipping your turn",
    ["russianroulette.hud.cantskip"] = "You can't skip your turn",

    -- Box Game
    ["boxgame.name"] = "Box Game",
    ["boxgame.desc"] = "The box game consists of players avoiding being crushed by the boxes, the last player standing is the winner.",
    ["boxgame.tip"] = "The boxes only kill when they are red, players will die as soon as they touch it.",
    ["boxgame.delaybetweendrops"] = "Time between dropped boxes",
    ["boxgame.delaybetweendrops.desc"] = "How long will it take for the boxes to appear between each round.",
    ["boxgame.dropdelay"] = "Drop time",
    ["boxgame.dropdelay.desc"] = "How long will it take for the boxes to fall.",
    ["boxgame.dropreaction"] = "Reaction time",
    ["boxgame.dropreaction.desc"] = "How much time (In seconds) players have to react to the boxes.",
    ["boxgame.startboxes"] = "Initial boxes",
    ["boxgame.startboxes.desc"] = "Amount of boxes that will fall at the beginning of the game.",
    ["boxgame.maxboxes"] = "Maximum boxes",
    ["boxgame.maxboxes.desc"] = "Maximum amount of boxes that will fall in the game. (It is related to the amount of boxes that will increase per round)",
    ["boxgame.addmoreboxes"] = "Add boxes",
    ["boxgame.addmoreboxes.desc"] = "Amount of boxes that will be added per round.",
    ["boxgame.sizex"] = "Width",
    ["boxgame.sizex.desc"] = "Amount of platforms that will be created in width in the game",
    ["boxgame.sizey"] = "Length",
    ["boxgame.sizey.desc"] = "Amount of platforms that will be created in length in the game",
    ["boxgame.offset"] = "Distance",
    ["boxgame.offset.desc"] = "Separation distance that will be between each platform",
    ["boxgame.height"] = "Height",
    ["boxgame.height.desc"] = "Height at which the game will be created",

    -- Deathmatch
    ["deathmatch.name"] = "Deathmatch",
    ["deathmatch.desc"] = "A deathmatch minigame where the goal is to kill other players, the player with the most deaths is the winner.",
    ["deathmatch.tip"] = "To pause the game, use the reload key (R)",
    ["deathmatch.insufficientspawns"] = "You need at least %s respawn points to start the game",
    ["deathmatch.leaderboard"] = "Leaderboard",
    ["deathmatch.leaderboard.andmore"] = "and %str more",
    ["deathmatch.tall"] = "Tall",
    ["deathmatch.tall.desc"] = "How tall the leaderboard will be",
    ["deathmatch.wide"] = "Wide",
    ["deathmatch.wide.desc"] = "How wide the leaderboard will be",
    ["deathmatch.heightoffset"] = "Height",
    ["deathmatch.heightoffset.desc"] = "Height above the ground that the leaderboard will appear",
    ["deathmatch.angleoffset"] = "Direction",
    ["deathmatch.angleoffset.desc"] = "Which direction the leaderboard will look",
    ["deathmatch.winbytime"] = "Win by time",
    ["deathmatch.winbytime.desc"] = "When active, the player with the most deaths at the end of the time will be the winner.\nWhen disabled, the player who reaches the number of deaths will be the winner.",
    ["deathmatch.time"] = "Time",
    ["deathmatch.time.desc"] = "How long the game will last",
    ["deathmatch.killstowin"] = "Kills to win",
    ["deathmatch.killstowin.desc"] = "Amount of deaths needed to win the game (Only works if \"Win by time\" is disabled)",
    ["deathmatch.falldamage"] = "Fall damage",
    ["deathmatch.falldamage.desc"] = "Players receive fall damage",
    ["deathmatch.respawntime"] = "Respawn time",
    ["deathmatch.respawntime.desc"] = "Time it will take for a player to respawn",
    ["deathmatch.respawnprotection"] = "Respawn protection",
    ["deathmatch.respawnprotection.desc"] = "Time a player will have protection when respawning",
    ["deathmatch.entitysettings"] = "Entities",
    ["deathmatch.spawnentitytype"] = "Entity type",
    ["deathmatch.spawnentitytype.desc"] = "The type of entity you are going to create for the minigame",
    ["deathmatch.spawnentitytypeoffset"] = "Height",
    ["deathmatch.spawnentitytypeoffset.desc"] = "Height above the ground that the entity will appear",
    ["deathmatch.spawnpointrotation"] = "Entity rotation",
    ["deathmatch.spawnpointrotation.desc"] = "Which direction entity will look",
    ["deathmatch.health"] = "Health",
    ["deathmatch.health.desc"] = "Amount of life that players will recover when they collect the health",
    ["deathmatch.healthrespawn"] = "Health (Respawn time)",
    ["deathmatch.healthrespawn.desc"] = "Time it will take for the health to respawn",
    ["deathmatch.armor"] = "Armor",
    ["deathmatch.armor.desc"] = "Amount of armor that players will recover when they collect the armor",
    ["deathmatch.armorrespawn"] = "Armor (Respawn time)",
    ["deathmatch.armorrespawn.desc"] = "Time it will take for the armor to respawn",
    ["deathmatch.ammo"] = "Ammo",
    ["deathmatch.ammo.desc"] = "Amount of ammunition that players will recover when they collect the ammunition",
    ["deathmatch.ammorespawn"] = "Ammo (Respawn time)",
    ["deathmatch.ammorespawn.desc"] = "Time it will take for the ammunition to respawn",
    ["deathmatch.weaponskit"] = "Weapons kit",
    ["deathmatch.weaponskit.desc"] = "The weapons kit that will appear in the game, to add categories and weapons edit your \"configuration.lua\" file"
}
--addons/minigame-tool-assistant/lua/minigames/enum.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/minigames/games/example.lua:
--[[--------------------------------------------
                Example Minigame
--------------------------------------------]]--

-- We don't need this game
if true then return end

--[[----------------------------
       Initial Game Config
----------------------------]]--

local GameScript = Minigames.CreateNewGame()

GameScript:SetGameName("Example")

GameScript:AddHeader("Example Header")
--[[
    This adds a header to the setupmenu, you can add as many as you want
    This work in this way:
        GameScript:AddHeader("Example Header")  -> Example Header
        GameScript:AddHeader("#exampleheader")  -> example.header.exampleheader (GameID.header.HeaderName)
        GameScript:AddHeader("!exampleheader")  -> minigames.exampleheader
--]]
GameScript:AddConfig("MyEpicConfig", {
    min = 1,
    max = 20,
    def = 5, -- or you can use "true" to set the default value to the minimum value
    desc = "You can set your own description here or in language.lua"

    -- In language you need to set it in this format:
    --      [ "name_of_the_lua.myepicconfig.desc" ] = "Correct Syntax"
    --      [ "example.myepicconfig.desc" ] = "Correct Syntax"
    --
    -- Invalid synthax:
    --      [ "example.lua.MyEpicConfig.desc"] = "Incorrect Syntax (Invalid Format)"
    --      [ "gungame.MyEpicConfig.desc"] = "Incorrect Syntax (Uppercase Letters)"
})


--[[----------------------------
        Trigger Events
----------------------------]]--

GameScript:AddHook( "PostPlayerDeath", "GetFallDamage" ) -- The player loss when they die in someway or by the fall damage

function GameScript:OnPlayerChanged(ply, Joined) -- Who and if the player joined or left the game
    if not self:IsActive() then return end

    local CurrentPlayers = self:GetPlayers(true)
    if #CurrentPlayers == 1 then
        self:SetPlayerWinner( CurrentPlayers ) -- Win on last player alive
    end
end

--[[----------------------------
          Main Functions
----------------------------]]--

function GameScript:StartGame()
    return Minigames.GameStart( self )
end

function GameScript:StopGame()
    self:RemoveAllPlayers(true) -- Remove all players silently

    return Minigames.GameStop( self )
end

function GameScript:ToggleGame()    -- (Optional)
    local Result = false

    if self:IsActive() then

        Result = self:StopGame()
        self:SetActive(false)

    else

        Result = self:StartGame()
        self:SetActive(true)

    end

    return Result
end

--[[----------------------------
        Action Functions
----------------------------]]--

-- Server-side
function GameScript:LeftClick( trace, owner, FirstTime )
    local Result = true

    return Result -- YOU MUST RETURN THE RESULT!!
end

-- Server-side
function GameScript:RightClick( trace, owner )

end

-- Shared
function GameScript:Reload( trace, owner )

end

-- Shared
function GameScript:Think( trace, owner )

end

-- Shared
function GameScript:Deploy( trace, owner )
    -- This is called when the player deploy our toolgun
end

-- Shared
function GameScript:RollUp( trace, owner )
    --[[----------------------------------------------------
    This is the opposite of deploy, this is called when the
    player roll up our toolgun. This works in any case like:

    - The player has changed their tool mode
    - The player has been killed while is holding the toolgun
    - The player changes their weapon
    ----------------------------------------------------]]-- 
end

-- Client-side
function GameScript:DrawHUD()

end

--[[----------------------------
      Setup Game to server
----------------------------]]--

Minigames.RegisterNewGame(GameScript)
--addons/minigame-tool-assistant/lua/minigames/games/plataforms.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/minigames/games/russianroulette.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/autorun/includes/extensions/sh_url.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/autorun/includes/extensions/sh_url.lua:
-----------------------------------------------------------------------------
-- URI parsing, composition and relative URL resolution
-- LuaSocket toolkit.
-- Author: Diego Nehab
-- RCS ID: $Id: url.lua,v 1.38 2006/04/03 04:45:42 diego Exp $
-----------------------------------------------------------------------------

-----------------------------------------------------------------------------
-- Declare module
-----------------------------------------------------------------------------
local string = string
local base = _G
local table = table
local pairs = pairs
local ipairs = ipairs
local tonumber = tonumber
local type = type
module("url")

-----------------------------------------------------------------------------
-- Module version
-----------------------------------------------------------------------------
_VERSION = "URL 1.0.1"

-----------------------------------------------------------------------------
-- HTML Entity Translation Table
-- http://lua-users.org/lists/lua-l/2005-10/msg00328.html
-----------------------------------------------------------------------------
local entities = {
	[' '] = '&nbsp;',
	['¡'] = '&iexcl;',
	['¢'] = '&cent;',
	['£'] = '&pound;',
	['¤'] = '&curren;',
	['¥'] = '&yen;',
	['¦'] = '&brvbar;',
	['§'] = '&sect;',
	['¨'] = '&uml;',
	['©'] = '&copy;',
	['ª'] = '&ordf;',
	['«'] = '&laquo;',
	['¬'] = '&not;',
	['­'] = '&shy;',
	['®'] = '&reg;',
	['¯'] = '&macr;',
	['°'] = '&deg;',
	['±'] = '&plusmn;',
	['²'] = '&sup2;',
	['³'] = '&sup3;',
	['´'] = '&acute;',
	['µ'] = '&micro;',
	['¶'] = '&para;',
	['·'] = '&middot;',
	['¸'] = '&cedil;',
	['¹'] = '&sup1;',
	['º'] = '&ordm;',
	['»'] = '&raquo;',
	['¼'] = '&frac14;',
	['½'] = '&frac12;',
	['¾'] = '&frac34;',
	['¿'] = '&iquest;',
	['À'] = '&Agrave;',
	['Á'] = '&Aacute;',
	['Â'] = '&Acirc;',
	['Ã'] = '&Atilde;',
	['Ä'] = '&Auml;',
	['Å'] = '&Aring;',
	['Æ'] = '&AElig;',
	['Ç'] = '&Ccedil;',
	['È'] = '&Egrave;',
	['É'] = '&Eacute;',
	['Ê'] = '&Ecirc;',
	['Ë'] = '&Euml;',
	['Ì'] = '&Igrave;',
	['Í'] = '&Iacute;',
	['Î'] = '&Icirc;',
	['Ï'] = '&Iuml;',
	['Ð'] = '&ETH;',
	['Ñ'] = '&Ntilde;',
	['Ò'] = '&Ograve;',
	['Ó'] = '&Oacute;',
	['Ô'] = '&Ocirc;',
	['Õ'] = '&Otilde;',
	['Ö'] = '&Ouml;',
	['×'] = '&times;',
	['Ø'] = '&Oslash;',
	['Ù'] = '&Ugrave;',
	['Ú'] = '&Uacute;',
	['Û'] = '&Ucirc;',
	['Ü'] = '&Uuml;',
	['Ý'] = '&Yacute;',
	['Þ'] = '&THORN;',
	['ß'] = '&szlig;',
	['à'] = '&agrave;',
	['á'] = '&aacute;',
	['â'] = '&acirc;',
	['ã'] = '&atilde;',
	['ä'] = '&auml;',
	['å'] = '&aring;',
	['æ'] = '&aelig;',
	['ç'] = '&ccedil;',
	['è'] = '&egrave;',
	['é'] = '&eacute;',
	['ê'] = '&ecirc;',
	['ë'] = '&euml;',
	['ì'] = '&igrave;',
	['í'] = '&iacute;',
	['î'] = '&icirc;',
	['ï'] = '&iuml;',
	['ð'] = '&eth;',
	['ñ'] = '&ntilde;',
	['ò'] = '&ograve;',
	['ó'] = '&oacute;',
	['ô'] = '&ocirc;',
	['õ'] = '&otilde;',
	['ö'] = '&ouml;',
	['÷'] = '&divide;',
	['ø'] = '&oslash;',
	['ù'] = '&ugrave;',
	['ú'] = '&uacute;',
	['û'] = '&ucirc;',
	['ü'] = '&uuml;',
	['ý'] = '&yacute;',
	['þ'] = '&thorn;',
	['ÿ'] = '&yuml;',
	['"'] = '&quot;',
	["'"] = '&#39;',
	['<'] = '&lt;',
	['>'] = '&gt;',
	['&'] = '&amp;'
}

function htmlentities(s)
	for k, v in pairs(entities) do
		s = string.gsub(s, k, v)
	end
	return s
end

function htmlentities_decode(s)
	for k, v in pairs(entities) do
		s = string.gsub(s, v, k)
	end
	return s
end

-----------------------------------------------------------------------------
-- Encodes a string into its escaped hexadecimal representation
-- Input
--   s: binary string to be encoded
-- Returns
--   escaped representation of string binary
-----------------------------------------------------------------------------
function escape(s)
	return string.gsub(s, "([^A-Za-z0-9_])", function(c)
		return string.format("%%%02x", string.byte(c))
	end)
end

-----------------------------------------------------------------------------
-- Protects a path segment, to prevent it from interfering with the
-- url parsing.
-- Input
--   s: binary string to be encoded
-- Returns
--   escaped representation of string binary
-----------------------------------------------------------------------------
local function make_set(t)
	local s = {}
	for i,v in ipairs(t) do
		s[t[i]] = 1
	end
	return s
end

-- these are allowed withing a path segment, along with alphanum
-- other characters must be escaped
local segment_set = make_set {
	"-", "_", ".", "!", "~", "*", "'", "(",
	")", ":", "@", "&", "=", "+", "$", ",",
}

local function protect_segment(s)
	return string.gsub(s, "([^A-Za-z0-9_])", function (c)
		if segment_set[c] then return c
		else return string.format("%%%02x", string.byte(c)) end
	end)
end

-----------------------------------------------------------------------------
-- Encodes a string into its escaped hexadecimal representation
-- Input
--   s: binary string to be encoded
-- Returns
--   escaped representation of string binary
-----------------------------------------------------------------------------
function unescape(s)
	return string.gsub(s, "%%(%x%x)", function(hex)
		return string.char(tonumber(hex, 16))
	end)
end

-----------------------------------------------------------------------------
-- Builds a path from a base path and a relative path
-- Input
--   base_path
--   relative_path
-- Returns
--   corresponding absolute path
-----------------------------------------------------------------------------
local function absolute_path(base_path, relative_path)
	if string.sub(relative_path, 1, 1) == "/" then return relative_path end
	local path = string.gsub(base_path, "[^/]*$", "")
	path = path .. relative_path
	path = string.gsub(path, "([^/]*%./)", function (s)
		if s ~= "./" then return s else return "" end
	end)
	path = string.gsub(path, "/%.$", "/")
	local reduced
	while reduced ~= path do
		reduced = path
		path = string.gsub(reduced, "([^/]*/%.%./)", function (s)
			if s ~= "../../" then return "" else return s end
		end)
	end
	path = string.gsub(reduced, "([^/]*/%.%.)$", function (s)
		if s ~= "../.." then return "" else return s end
	end)
	return path
end

-----------------------------------------------------------------------------
-- Parses a url and returns a table with all its parts according to RFC 2396
-- The following grammar describes the names given to the URL parts
-- <url> ::= <scheme>://<authority>/<path>;<params>?<query>#<fragment>
-- <authority> ::= <userinfo>@<host>:<port>
-- <userinfo> ::= <user>[:<password>]
-- <path> :: = {<segment>/}<segment>
-- Input
--   url: uniform resource locator of request
--   default: table with default values for each field
-- Returns
--   table with the following fields, where RFC naming conventions have
--   been preserved:
--     scheme, authority, userinfo, user, password, host, port,
--     path, params, query, fragment
-- Obs:
--   the leading '/' in {/<path>} is considered part of <path>
-----------------------------------------------------------------------------
function parse(url, default)
	-- initialize default parameters
	local parsed = {}
	for i,v in pairs(default or parsed) do parsed[i] = v end
	-- empty url is parsed to nil
	if not url or url == "" then return nil, "invalid url" end
	-- remove whitespace
	-- url = string.gsub(url, "%s", "")
	-- get fragment
	url = string.gsub(url, "#(.*)$", function(f)
		parsed.fragment = f
		return ""
	end)
	-- get scheme
	url = string.gsub(url, "^([%w][%w%+%-%.]*)%://",
		function(s) parsed.scheme = s; return "" end)
	-- get authority
	url = string.gsub(url, "^([^/%?]*)", function(n)
		parsed.authority = n
		return ""
	end)
	-- get query stringing
	url = string.gsub(url, "%?(.*)", function(q)
		parsed.query = q
		return ""
	end)
	-- get params
	url = string.gsub(url, "%;(.*)", function(p)
		parsed.params = p
		return ""
	end)
	-- path is whatever was left
	if url ~= "" then parsed.path = url else parsed.path = "/" end
	local authority = parsed.authority
	if not authority then return parsed end
	authority = string.gsub(authority,"^([^@]*)@",
		function(u) parsed.userinfo = u; return "" end)
	authority = string.gsub(authority, ":([^:]*)$",
		function(p) parsed.port = p; return "" end)
	if authority ~= "" then parsed.host = authority end
	local userinfo = parsed.userinfo
	if not userinfo then return parsed end
	userinfo = string.gsub(userinfo, ":([^:]*)$",
		function(p) parsed.password = p; return "" end)
	parsed.user = userinfo
	return parsed
end

-----------------------------------------------------------------------------
-- Parses the url and also seperates the query terms into a table
-----------------------------------------------------------------------------
function parse2(url, default)
	local parsed = parse(url, default)

	if parsed.query then
		local prmstr = parsed.query
		local prmarr = string.Explode("&", prmstr)
		local params = {}

		for i = 1, #prmarr do
			local tmparr = string.Explode("=", prmarr[i])
			params[tmparr[1]] = tmparr[2]
		end

		parsed.query = params
	end

	if parsed.fragment then
		local prmstr = parsed.fragment
		local prmarr = string.Explode("&", prmstr)
		local params = {}

		for i = 1, #prmarr do
			local tmparr = string.Explode("=", prmarr[i])
			params[tmparr[1]] = tmparr[2]
		end

		parsed.fragment = params
	end

	return parsed
end

-----------------------------------------------------------------------------
-- Rebuilds a parsed URL from its components.
-- Components are protected if any reserved or unallowed characters are found
-- Input
--   parsed: parsed URL, as returned by parse
-- Returns
--   a stringing with the corresponding URL
-----------------------------------------------------------------------------
function build(parsed)
	local ppath = parse_path(parsed.path or "")
	local url = build_path(ppath)
	local url = (parsed.path or ""):gsub("[^/]+", unescape)
	local url = url:gsub("[^/]*", protect_segment)
	if parsed.params then url = url .. ";" .. parsed.params end
	if parsed.query then url = url .. "?" .. parsed.query end
	local authority = parsed.authority
	if parsed.host then
		authority = parsed.host
		if parsed.port then authority = authority .. ":" .. parsed.port end
		local userinfo = parsed.userinfo
		if parsed.user then
			userinfo = parsed.user
			if parsed.password then
				userinfo = userinfo .. ":" .. parsed.password
			end
		end
		if userinfo then authority = userinfo .. "@" .. authority end
	end
	if authority then url = "//" .. authority .. url end
	if parsed.scheme then url = parsed.scheme .. ":" .. url end
	if parsed.fragment then url = url .. "#" .. parsed.fragment end
	-- url = string.gsub(url, "%s", "")
	return url
end

-----------------------------------------------------------------------------
-- Builds a absolute URL from a base and a relative URL according to RFC 2396
-- Input
--   base_url
--   relative_url
-- Returns
--   corresponding absolute url
-----------------------------------------------------------------------------
function absolute(base_url, relative_url)
	if type(base_url) == "table" then
		base_parsed = base_url
		base_url = build(base_parsed)
	else
		base_parsed = parse(base_url)
	end
	local relative_parsed = parse(relative_url)
	if not base_parsed then return relative_url
	elseif not relative_parsed then return base_url
	elseif relative_parsed.scheme then return relative_url
	else
		relative_parsed.scheme = base_parsed.scheme
		if not relative_parsed.authority or relative_parsed.authority == "" then
			relative_parsed.authority = base_parsed.authority
			if not relative_parsed.path then
				relative_parsed.path = base_parsed.path
				if not relative_parsed.params then
					relative_parsed.params = base_parsed.params
					if not relative_parsed.query then
						relative_parsed.query = base_parsed.query
					end
				end
			else
				relative_parsed.path = absolute_path(base_parsed.path or "",
					relative_parsed.path)
			end
		end
		return build(relative_parsed)
	end
end

-----------------------------------------------------------------------------
-- Breaks a path into its segments, unescaping the segments
-- Input
--   path
-- Returns
--   segment: a table with one entry per segment
-----------------------------------------------------------------------------
function parse_path(path)
	local parsed = {}
	path = path or ""
	--path = string.gsub(path, "%s", "")
	string.gsub(path, "([^/]*)", function (s) table.insert(parsed, s) end)
	for i = 1, table.getn(parsed) do
		parsed[i] = unescape(parsed[i])
	end
	if string.sub(path, 1, 1) == "/" then parsed.is_absolute = 1 end
	if string.sub(path, -1, -1) == "/" then parsed.is_directory = 1 end
	return parsed
end

-----------------------------------------------------------------------------
-- Builds a path component from its segments, escaping protected characters.
-- Input
--   parsed: path segments
--   unsafe: if true, segments are not protected before path is built
-- Returns
--   path: corresponding path stringing
-----------------------------------------------------------------------------
function build_path(parsed, unsafe)
	local path = ""
  local escape = unsafe and function(x) return x end or protect_segment
	local n = table.getn(parsed)
  for i = 1, n-1 do
	if parsed[i]~= "" or parsed[i+1] == "" then
	  path = path .. escape(parsed[i])
	  if i < n - 1 or parsed[i+1] ~= "" then path = path .. "/" end
	end
  end
  if n > 0 then
	path = path .. escape(parsed[n])
	if parsed.is_directory then path = path .. "/" end
  end
	if parsed.is_absolute then path = "/" .. path end
	return path
end
--addons/media_player_fixed_edition/lua/mediaplayer/cl_init.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/mediaplayer/utils.lua:
if SERVER then AddCSLuaFile() end

local math = math
local urllib = url
local ceil = math.ceil
local floor = math.floor
local Round = math.Round
local log = math.log
local pow = math.pow
local format = string.format
local tostring = tostring
local IsValid = IsValid


local utils = {}

---
-- Ceil the given number to the largest power of two.
--
function utils.CeilPower2(n)
	return pow(2, ceil(log(n) / log(2)))
end

---
-- Method for easily grabbing a value from a table without checking that each
-- fragment exists.
--
-- @param tbl Table
-- @param key e.g. "json.key.fragments"
--
function utils.TableLookup( tbl, key )
	local fragments = string.Split(key, '.')
	local value = tbl

	for _, fragment in ipairs(fragments) do
		value = value[fragment]

		if not value then
			return nil
		end
	end

	return value
end

---
-- Formats the number of seconds to a string.
-- e.g. 3612 => 24:12
--
function utils.FormatSeconds(sec)
	sec = Round(sec)

	local hours = floor(sec / 3600)
	local minutes = floor((sec % 3600) / 60)
	local seconds = sec % 60

	if minutes < 10 then
		minutes = "0" .. tostring(minutes)
	end

	if seconds < 10 then
		seconds = "0" .. tostring(seconds)
	end

	if hours > 0 then
		return format("%s:%s:%s", hours, minutes, seconds)
	else
		return format("%s:%s", minutes, seconds)
	end
end

-- https://github.com/xfbs/PiL3/blob/master/18MathLibrary/shuffle.lua
function utils.Shuffle(list)
	-- make and fill array of indices
	local indices = {}
	for i = 1, #list do
		indices[#indices + 1] = i
	end

	-- create shuffled list
	local shuffled = {}
	for i = 1, #list do
		-- get a random index
		local index = math.random(#indices)

		-- get the value
		local value = list[indices[index]]

		-- remove it from the list so it won't be used again
		table.remove(indices, index)

		-- insert into shuffled array
		shuffled[#shuffled + 1] = value
	end

	return shuffled
end

function utils.Retry( func, success, error, maxAttempts )

	maxAttempts = maxAttempts or 3
	local attempts = 1

	local function callback( value )
		if value then
			success( value )
		elseif attempts < maxAttempts then
			attempts = attempts + 1
			func( callback )
		else
			error()
		end
	end

	func( callback )

end

local function setTimeout( func, wait )
	local timerID = tostring( func )
	timer.Create( timerID, wait, 1, func )
	timer.Start( timerID )
	return timerID
end

local function clearTimeout( timerID )
	if timer.Exists( timerID ) then
		timer.Remove( timerID )
	end
end

-- based on underscore.js' _.throttle function
function utils.Throttle( func, wait, options )
	wait = wait or 1
	options = options or {}

	local timeout, args, result
	local previous

	local function later()
		previous = (options.leading == false) and 0 or RealTime()
		timeout = nil
		result = func( unpack(args) )
		if not timeout then
			args = nil
		end
	end

	local function throttled(...)
		local now = RealTime()
		if not previous then
			previous = now
		end

		local remaining = wait - (now - previous)

		args = {...}

		if remaining <= 0 or remaining > wait then
			if timeout then
				clearTimeout(timeout)
				timeout = nil
			end

			previous = now
			result = func( unpack(args) )

			if not timeout then
				args = nil
			end
		elseif not timeout and options.trailing ~= false then
			timeout = setTimeout(later, remaining)
		end

		return result
	end

	return throttled
end

if CLIENT then

	local CeilPower2 = utils.CeilPower2
	local SetDrawColor = surface.SetDrawColor
	local SetMaterial = surface.SetMaterial
	local DrawTexturedRect = surface.DrawTexturedRect
	local DrawRect = surface.DrawRect

	local color_white = color_white

	function utils.DrawHTMLPanel( panel, w, h )
		if not (IsValid( panel ) and w and h) then return end

		panel:UpdateHTMLTexture()

		local pw, ph = panel:GetSize()

		-- Convert to scalar
		w = w / pw
		h = h / ph

		-- Fix for non-power-of-two html panel size
		pw = CeilPower2(pw)
		ph = CeilPower2(ph)

		SetDrawColor( color_white )

		local mat = panel:GetHTMLMaterial()

		if mat then
			SetMaterial( mat )
			DrawTexturedRect( 0, 0, w * pw, h * ph )
		else
			DrawRect( 0, 0, w * pw, h * ph )
		end
	end

	function utils.ParseHHMMSS( time )
		local tbl = {}

		-- insert fragments in reverse
		for fragment, _ in string.gmatch(time, ":?(%d+)") do
			table.insert(tbl, 1, tonumber(fragment) or 0)
		end

		if #tbl == 0 then
			return nil
		end

		local seconds = 0

		for i = 1, #tbl do
			seconds = seconds + tbl[i] * math.max(60 ^ (i-1), 1)
		end

		return seconds
	end

	---
	-- Attempts to play uri from stream or local file and returns channel in
	-- callback.
	--
	function utils.LoadStreamChannel( uri, options, callback )
		local isLocalFile = false

		-- Play uri from a local file if:
		-- 1. Windows OS and path contains drive letter
		-- 2. Linux or OS X and path starts with a single '/'
		--
		-- We can't check this using file.Exists since GMod only allows checking
		-- within the GMod directory. However, sound.PlayFile will still load
		-- a file from any directory.
		if ( system.IsWindows() and uri:find("^%w:/") ) or
			( not system.IsWindows() and uri:find("^/[^/]") ) then
			isLocalFile = true

			local success, decoded = pcall(urllib.unescape, uri)
			if success then
				uri = decoded
			end
		end

		local playFunc = isLocalFile and sound.PlayFile or sound.PlayURL
		playFunc( uri, options or "noplay", function( channel )
			if IsValid( channel ) then
				callback( channel )
			else
				callback( nil )
			end
		end )
	end

	--- 
	-- Gathers the Duration from URI
	-- Works only with URIs that lead directly to the video
	do
		-- https://developer.mozilla.org/en-US/docs/Web/API/MediaError
		local ErrorCodes = {
			[1] = "The user canceled the media.", -- MEDIA_ERR_ABORTED
			[2] = "A network error occurred while fetching the media.", -- MEDIA_ERR_NETWORK
			[3] = "An error occurred while decoding the media.", -- MEDIA_ERR_DECODE
			[4] = "The media source is not supported.", -- MEDIA_ERR_SRC_NOT_SUPPORTED
			[5] = "An unknown error occurred.", -- MEDIA_ERR_UNKOWN
		}

		local HTML_Code = [[
			<html><body> <video id="video" src="{@VideoSrc}" preload="metadata"></video>
				<script>
					const video = document.querySelector('video');
					video.onloadedmetadata  = function() { console.log("DURATION:" + video.duration)};
					video.onerror = function() { console.log("ERROR:" + video.error.code ) };
				</script>
			</body></html>
		]]

		function utils.GatherVideoDuration( uri, callback )

			local panel = vgui.Create("HTML")
			panel:SetSize(100,100)
			panel:SetAlpha(0)
			panel:SetMouseInputEnabled(false)

			function panel:ConsoleMessage(msg)
				if MediaPlayer.DEBUG then
					print("MediaPlayer Gathering: ", msg)
				end

				if msg:StartWith("DURATION:") then
					local duration = math.ceil(tonumber(string.sub(msg, 10)))

					callback(true, duration)
					panel:Remove()
				end

				if msg:StartWith("ERROR:") then
					local code = tonumber(string.sub(msg, 7))
					local err = ErrorCodes[code] or ErrorCodes[5]

					callback(false, err)
					panel:Remove()
				end
			end

			panel:SetHTML(HTML_Code:Replace( "{@VideoSrc}", uri ))
		end
	end

end

_G.MediaPlayerUtils = utils

--addons/media_player_fixed_edition/lua/mediaplayer/sh_cvars.lua:
MediaPlayer.Cvars = {}

MediaPlayer.Cvars.Debug = CreateConVar( "mediaplayer_debug", 0, FCVAR_DONTRECORD, "Enables media player debug mode; logs a bunch of actions into the console." )
MediaPlayer.DEBUG = MediaPlayer.Cvars.Debug:GetBool()
cvars.AddChangeCallback( "mediaplayer_debug", function(name, old, new)
	MediaPlayer.DEBUG = new == 1
end)

MediaPlayer.Cvars.AllowWebpages = CreateConVar( "mediaplayer_allow_webpages", 0, {
	FCVAR_ARCHIVE,
	FCVAR_NOTIFY,
	FCVAR_REPLICATED,
	FCVAR_SERVER_CAN_EXECUTE
}, "Allows any webpage to be requested." )

MediaPlayer.Cvars.QueueLimit = CreateConVar( "mediaplayer_queue_limit", 64, {
	FCVAR_REPLICATED,
	FCVAR_SERVER_CAN_EXECUTE
}, "Maximum size of a media player queue." )

if CLIENT then

	MediaPlayer.Cvars.Resolution	= CreateClientConVar( "mediaplayer_resolution", 480, true, false )
	MediaPlayer.Cvars.Audio3D		= CreateClientConVar( "mediaplayer_3daudio", 1, true, false )
	MediaPlayer.Cvars.Volume		= CreateClientConVar( "mediaplayer_volume", 0.15, true, false )
	MediaPlayer.Cvars.MuteUnfocused	= CreateClientConVar( "mediaplayer_mute_unfocused", 1, true, false )
	MediaPlayer.Cvars.Fullscreen	= CreateClientConVar( "mediaplayer_fullscreen", 0, false, false )
	MediaPlayer.Cvars.DrawThumbnails = CreateClientConVar( "mediaplayer_draw_thumbnails", 0, true, false )

end

--addons/media_player_fixed_edition/lua/mediaplayer/players/base/net.lua:
local net = net
local CeilPower2 = MediaPlayerUtils.CeilPower2

local EOT = "\4" -- End of transmission

MEDIAPLAYER.net = {}
local mpnet = MEDIAPLAYER.net

function mpnet.ReadDuration()
	return net.ReadUInt(16)
end

function mpnet.WriteDuration( seconds )
	net.WriteUInt( seconds, 16 )
end

function mpnet.ReadMedia()
	local uid = net.ReadString()

	if uid == EOT then
		return nil
	end

	local url = net.ReadString()
	local metadata = net.ReadTable()
	local ownerName = net.ReadString()
	local ownerSteamId = net.ReadString()

	-- Create media object
	local media = MediaPlayer.GetMediaForUrl( url, true )

	-- Set uniqud ID to match the server
	media._id = uid

	media:SetMetadata( metadata, true )
	media._OwnerName = ownerName
	media._OwnerSteamID = ownerSteamId

	return media
end

function mpnet.WriteMedia( media )
	if media then
		net.WriteString( media:UniqueID() )
		net.WriteString( media:Url() )
		net.WriteTable( media._metadata or {} )
		net.WriteString( media:OwnerName() )
		net.WriteString( media:OwnerSteamID() )
	else
		net.WriteString( EOT )
	end
end

local StateBits = CeilPower2(NUM_MP_STATE) / 2

function mpnet.ReadPlayerState()
	return net.ReadUInt(StateBits)
end

function mpnet.WritePlayerState( state )
	net.WriteUInt(state, StateBits)
end

---
-- Threshold for determining if server and client system time differ.
--
local TIME_OFFSET_THRESHOLD = 2

---
-- Adjusts time returned from the server since RealTime will always differ.
--
local function correctTime( time, serverTime )
	local curTime = RealTime()
	local diffTime = os.difftime( serverTime, curTime )

	if math.abs(diffTime) > TIME_OFFSET_THRESHOLD then
		return time - diffTime
	else
		return time
	end
end

function mpnet.ReadTime()
	local time = net.ReadInt(32)
	local sync = net.ReadBit() == 1

	if sync then
		local serverTime = net.ReadInt(32)
		return correctTime(time, serverTime)
	else
		return time
	end
end

---
-- Writes the given epoch.
--
-- @param time Epoch.
-- @param sync Whether the time should be synced on the client (default: true).
--
function mpnet.WriteTime( time, sync )
	if sync == nil then sync = true end
	sync = tobool(sync)

	net.WriteInt( time, 32 )
	net.WriteBit( sync )

	if sync then
		-- We must send the current time in case either the server or the
		-- client's system clock is offset.
		net.WriteInt( RealTime(), 32 )
	end
end

---
-- Read a vote value or count.
--
function mpnet.ReadVote()
	return net.ReadInt(9)
end

---
-- Write a vote value or count.
--
function mpnet.WriteVote( value )
	net.WriteInt( value, 9 )
end

--addons/media_player_fixed_edition/lua/mediaplayer/players/entity/sh_meta.lua:
--[[---------------------------------------------------------
	Media Player Entity Meta
-----------------------------------------------------------]]

local EntityMeta = FindMetaTable("Entity")
if not EntityMeta then return end

function EntityMeta:GetMediaPlayer()
	return self._mp
end

--
-- Installs a media player reference to the entity.
--
-- @param Table|String?  mp    Media player table or string type.
-- @param String?        mpId  Media player unique ID.
--
function EntityMeta:InstallMediaPlayer( mp, mpId )
	if not istable(mp) then
		local mpType = isstring(mp) and mp or "entity"

		if not MediaPlayer.IsValidType(mpType) then
			ErrorNoHalt("ERROR: Attempted to install invalid mediaplayer type onto an entity!\n")
			ErrorNoHalt("ENTITY: " .. tostring(self) .. "\n")
			ErrorNoHalt("TYPE: " .. tostring(mpType) .. "\n")
			mpType = "entity" -- default
		end

		local mpId = mpId or "Entity" .. self:EntIndex()
		mp = MediaPlayer.Create( mpId, mpType )
	end

	self._mp = mp
	self._mp:SetEntity(self)

	local creator = self.GetCreator and self:GetCreator()
	if IsValid( creator ) then
		self._mp:SetOwner( creator )
	end

	if isfunction(self.SetupMediaPlayer) then
		self:SetupMediaPlayer(mp)
	end

	return mp
end

local DefaultConfig = {
	offset	= Vector(0,0,0),	-- translation from entity origin
	angle	= Angle(0,90,90),	-- rotation
	-- attachment = "corner"	-- attachment name
	width = 64,					-- screen width
	height = 64 * 9 / 16			-- screen height
}

function EntityMeta:GetMediaPlayerPosition()
	local cfg = self.PlayerConfig or DefaultConfig

	local w = (cfg.width or DefaultConfig.width)
	local h = (cfg.height or DefaultConfig.height)
	local angles = (cfg.angle or DefaultConfig.angle)

	local pos, ang

	if cfg.attachment then
		local idx = self:LookupAttachment(cfg.attachment)
		if not idx then
			local err = string.format("MediaPlayer:Entity.Draw: Invalid attachment '%s'\n", cfg.attachment)
			Error(err)
		end

		-- Get attachment orientation
		local attach = self:GetAttachment(idx)
		pos = attach.pos
		ang = attach.ang
	else
		pos = self:GetPos() -- TODO: use GetRenderOrigin?
	end

	-- Apply offset
	if cfg.offset then
		pos = pos +
			self:GetForward() * cfg.offset.x +
			self:GetRight() * cfg.offset.y +
			self:GetUp() * cfg.offset.z
	end

	-- Set angles
	ang = ang or self:GetAngles() -- TODO: use GetRenderAngles?

	ang:RotateAroundAxis( ang:Right(), angles.p )
	ang:RotateAroundAxis( ang:Up(), angles.y )
	ang:RotateAroundAxis( ang:Forward(), angles.r )

	return w, h, pos, ang
end

--addons/media_player_fixed_edition/lua/mediaplayer/services/audiofile/cl_init.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/autorun/menubar/mp_options.lua:
return gluapack()()
--addons/media_player_fixed_edition/lua/autorun/sandbox/mediaplayer_dupe.lua:
local MEDIAPLAYER_DUPE = nil
local MEDIAPLAYER_SAVE = false
local MEDIAPLAYER_THUMBNAIL = nil

local HTMLMAT_STYLE_DUPE = "htmlmat.style.dupe"
-- AddHTMLMaterialStyle( HTMLMAT_STYLE_DUPE, {
-- 	width = 512,
-- 	height = 512,
-- 	css = [[
-- img {
-- 	width: 100%;
-- 	position: absolute;
-- 	top: 50%;
-- 	left: 50%;
-- 	-webkit-filter: blur(6px);
-- 	-webkit-transform: translate(-50%, -50%) scale(1.1,1.1);
-- }]]
-- } )
AddHTMLMaterialStyle( HTMLMAT_STYLE_DUPE, {
	width = 512,
	height = 512,
	css = [[
img {
	-webkit-filter: blur(6px) brightness(0.9);
	-webkit-transform: translate(-50%, -50%) scale(1.05, 1.05);
}]]
}, HTMLMAT_STYLE_COVER_IMG )

surface.CreateFont( "DupeMediaText", {
	font		= "Comfortaa",
	antialias	= true,
	extended 	= true,
	weight		= 400,
	size        = 80
} )

local function PreSaveMediaPlayerDupe( Dupe )

	local mediaplayers = {}

	for _, ent in pairs( Dupe.Entities or {} ) do
		if ent.IsMediaPlayerEntity then
			table.insert( mediaplayers, ent )
		end
	end

	local mp = mediaplayers[1]
	local snapshot = mp.MediaPlayerSnapshot

	local media = snapshot.media
	local metadata = media and media._metadata
	local thumbnail = metadata and metadata.thumbnail

	if thumbnail then
		HTMLMaterial( thumbnail, HTMLMAT_STYLE_DUPE, function( material )
			MEDIAPLAYER_THUMBNAIL = material
			MEDIAPLAYER_SAVE = true
		end )
	else
		MEDIAPLAYER_THUMBNAIL = Material( "gui/dupe_bg.png" )
		MEDIAPLAYER_SAVE = true
	end

end

local function DrawOutlinedText(text, font, x, y, colour, xalign, yalign)
	local outlineColor = Color(0,0,0,colour.a)
	draw.SimpleText(text, font, x, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 1, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 1, y + 2, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x, y - 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 1, y - 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 1, y - 2, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x + 2, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 2, y + 1, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x + 2, y - 1, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x - 2, y + 2, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 2, y + 1, outlineColor, xalign, yalign)
	draw.SimpleText(text, font, x - 2, y - 1, outlineColor, xalign, yalign)

	draw.SimpleText(text, font, x, y, colour, xalign, yalign)
end

local function RenderMediaPlayerDupe( Dupe )

	local FOV = 17

	--
	-- This is gonna take some cunning to look awesome!
	--
	local Size		= Dupe.Maxs - Dupe.Mins;
	local Radius	= Size:Length() * 0.5;
	local CamDist	= Radius / math.sin( math.rad( FOV ) / 2 ) -- Works out how far the camera has to be away based on radius + fov!
	local Center	= LerpVector( 0.5, Dupe.Mins, Dupe.Maxs );
	local CamPos	= Center + Vector( -1, 0, 0.5 ):GetNormal() * CamDist;
	local EyeAng	= ( Center - CamPos ):GetNormal():Angle();

	--
	-- The base view
	--
	local view =
	{
		type		= "3D",
		origin		= CamPos,
		angles		= EyeAng,
		x			= 0,
		y			= 0,
		w			= 512,
		h			= 512,
		aspect		= 1,
		fov			= FOV
	}

	--
	-- Create a bunch of entities we're gonna use to render.
	--
	local entities = {}

	for k, v in pairs( Dupe.Entities ) do

		local ent

		if ( v.Class == "prop_ragdoll" ) then

			ent = ClientsideRagdoll( v.Model or "error.mdl", RENDERGROUP_OTHER )

			if ( istable( v.PhysicsObjects ) ) then

				for boneid, v in pairs( v.PhysicsObjects ) do

					local obj = ent:GetPhysicsObjectNum( boneid )
					if ( IsValid( obj ) ) then
						obj:SetPos( v.Pos )
						obj:SetAngles( v.Angle )
					end

				end

				ent:InvalidateBoneCache()

			end

		elseif v.IsMediaPlayerEntity then

			ent = ClientsideModel( v.Model or "error.mdl", RENDERGROUP_OTHER )
			ent.PlayerConfig = v.PlayerConfig

			local mp = MediaPlayer.GetById( v.DT.MediaPlayerID )
			if mp and mp:GetType() == "entity" then
				mp._oldent = mp.Entity
				mp.Entity = ent
			end

		end

		entities[k] = ent

	end


	--
	-- DRAW THE BACKGROUND
	--
	render.SetMaterial( Material( "gui/dupe_bg.png" ) )
	render.DrawScreenQuadEx( 0, 0, 512, 512 )

	render.SetMaterial( MEDIAPLAYER_THUMBNAIL )
	render.DrawScreenQuadEx( 0, 0, 512, 512 )
	render.SuppressEngineLighting( true )

	--
	-- BLACK OUTLINE
	-- AWESOME BRUTE FORCE METHOD
	--
	render.SuppressEngineLighting( true )

	local BorderSize	= CamDist * 0.004
	local Up			= EyeAng:Up() * BorderSize
	local Right			= EyeAng:Right() * BorderSize

	render.SetColorModulation( 1, 1, 1, 1 )
	render.MaterialOverride( Material( "models/debug/debugwhite" ) )

	-- Render each entity in a circle
	for k, v in pairs( Dupe.Entities ) do

		for i = 0, math.pi * 2, 0.2 do

			view.origin = CamPos + Up * math.sin( i ) + Right * math.cos( i )

			cam.Start( view )

				render.Model(
				{
					model	=	v.Model,
					pos		=	v.Pos,
					angle	=	v.Angle,

				}, entities[k] )

			cam.End()

		end

	end

	-- Because ee just messed up the depth
	render.ClearDepth()
	render.SetColorModulation( 0, 0, 0, 1 )

	-- Try to keep the border size consistent with zoom size
	local BorderSize	= CamDist * 0.002
	local Up			= EyeAng:Up() * BorderSize
	local Right			= EyeAng:Right() * BorderSize

	-- Render each entity in a circle
	for k, v in pairs( Dupe.Entities ) do

		for i = 0, math.pi * 2, 0.2 do

			view.origin = CamPos + Up * math.sin( i ) + Right * math.cos( i )
			cam.Start( view )

			render.Model(
			{
				model	=	v.Model,
				pos		=	v.Pos,
				angle	=	v.Angle,
				skin	=	v.Skin
			}, entities[k] )

			cam.End()

		end

	end

	--
	-- ACUAL RENDER!
	--

	-- We just fucked the depth up - so clean it
	render.ClearDepth()

	-- Set up the lighting. This is over-bright on purpose - to make the ents pop
	render.SetModelLighting( 0, 0, 0, 0 )
	render.SetModelLighting( 1, 2, 2, 2 )
	render.SetModelLighting( 2, 3, 2, 0 )
	render.SetModelLighting( 3, 0.5, 2.0, 2.5 )
	render.SetModelLighting( 4, 3, 3, 3 ) -- top
	render.SetModelLighting( 5, 0, 0, 0 )
	render.MaterialOverride( nil )

	view.origin = CamPos
	cam.Start( view )

	-- Render each model
	for k, v in pairs( Dupe.Entities ) do

		render.SetColorModulation( 1, 1, 1, 1 )

		if ( istable( v.EntityMods ) ) then

			if ( istable( v.EntityMods.colour ) ) then
				render.SetColorModulation( v.EntityMods.colour.Color.r / 255, v.EntityMods.colour.Color.g / 255, v.EntityMods.colour.Color.b / 255, v.EntityMods.colour.Color.a / 255 )
			end

			if ( istable( v.EntityMods.material ) ) then
				render.MaterialOverride( Material( v.EntityMods.material.MaterialOverride ) )
			end

		end

		local ent = entities[k]

		render.Model(
		{
			model	=	v.Model,
			pos		=	v.Pos,
			angle	=	v.Angle,
			skin	=	v.Skin
		}, ent )

		if v.IsMediaPlayerEntity then

			local mp = MediaPlayer.GetById( v.DT.MediaPlayerID )
			if mp then
				mp:Draw( true, false )
				mp.Entity = mp._oldent
			else
				local w, h, pos, ang = ent:GetMediaPlayerPosition()
				cam.Start3D2D( pos, ang, 1 )
					surface.SetDrawColor( color_white )
					surface.SetMaterial( Material( "theater/STATIC" ) )
					surface.DrawTexturedRect( 0, 0, w, h )
				cam.End3D2D()
			end

		end

		render.MaterialOverride( nil )

	end

	cam.End()

	-- Enable lighting again (or it will affect outside of this loop!)
	render.SuppressEngineLighting( false )
	render.SetColorModulation( 1, 1, 1, 1 )

	--
	-- Finished with the entities - remove them all
	--
	for k, v in pairs( entities ) do
		v:Remove()
	end

	--
	-- Media Player branding
	--
	cam.Start2D()
		DrawOutlinedText( "MEDIA PLAYER", "DupeMediaText", 512 / 2, 512 - 34,
			color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	cam.End2D()

	local jpegdata = render.Capture{
		format		=	"jpeg",
		x			=	0,
		y			=	0,
		w			=	512,
		h			=	512,
		quality		=	100
	}

	return jpegdata

end

local function SaveMediaPlayerDupe( Dupe, jpegdata )

	--
	-- Encode and compress the dupe
	--
	local Dupe = util.TableToJSON( Dupe )
	if ( not isstring( Dupe ) ) then
		Msg( "There was an error converting the dupe to a json string" );
	end

	Dupe = util.Compress( Dupe )

	--
	-- And save it! (filename is automatic md5 in dupes/)
	--
	if ( engine.WriteDupe( Dupe, jpegdata ) ) then

		-- Disable the save button!!
		hook.Run( "DupeSaveUnavailable" )
		hook.Run( "DupeSaved" )

		MsgN( "Saved!" )

		-- TODO: Open tab and show dupe!

	end

end

hook.Add( "PostRenderVGUI", "MediaPlayerDupe", function()

	if not g_ClientSaveDupe then return end
	local isMediaDupe = false

	for _, ent in pairs( g_ClientSaveDupe.Entities or {} ) do
		if ent.IsMediaPlayerEntity then
			isMediaDupe = true
			break
		end
	end

	if isMediaDupe then
		MEDIAPLAYER_DUPE = g_ClientSaveDupe
		g_ClientSaveDupe = nil

		PreSaveMediaPlayerDupe( MEDIAPLAYER_DUPE )
	end

end )

hook.Add( "PostRender", "MediaPlayerDupe", function()

	if not ( MEDIAPLAYER_DUPE and MEDIAPLAYER_SAVE ) then return end

	local jpeg = RenderMediaPlayerDupe( MEDIAPLAYER_DUPE )
	SaveMediaPlayerDupe( MEDIAPLAYER_DUPE, jpeg )

	MEDIAPLAYER_DUPE = nil
	MEDIAPLAYER_SAVE = false

end )


--addons/onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_utf8.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

onyx.utf8 = {}

local CASEMAP_LOWER = {} -- lower to upper
local CASEMAP_UPPER = {} -- upper to lower

do
    -- gmod doesn't like big lua files, so let's split them
    for index = 1, 4 do
        local data = include('data/utf8_chunk_' .. index .. '.lua')
        assert(data, 'missing UTF-8 casemap data (' .. index .. ')')
        for lowerCharCode, upperCharCode in next, data do
            CASEMAP_LOWER[lowerCharCode] = upperCharCode
            CASEMAP_UPPER[upperCharCode] = lowerCharCode
        end
    end
end

local function replace(text, mapping)
    assert(isstring(text), string.format('bad argument #1 `replace` (expected string, got %s)', type(text)))

    local newString = ''

    for _, code in utf8.codes(text) do
        newString = newString .. utf8.char(mapping[code] or code)
    end

    return newString
end

function onyx.utf8.upper(text)
    return replace(text, CASEMAP_LOWER)
end

function onyx.utf8.lower(text)
    return replace(text, CASEMAP_UPPER)
end
--addons/onyx_framework_2/lua/onyx/ui/libs/cl_spoly.lua:
--[[
MIT License

Copyright (c) 2023 Aleksandrs Filipovskis

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
--]]

local STATUS_IDLE = 0
local STATUS_BUSY = 1

onyx.spoly = onyx.spoly or {}
onyx.spoly.materials = onyx.spoly.materials or {}
onyx.spoly.queue = onyx.spoly.queue or {}
onyx.spoly.status = STATUS_IDLE

local spoly = onyx.spoly
local materials = spoly.materials
local queue = spoly.queue
local queued = {}

local SIZE = 2048
-- MATERIAL_RT_DEPTH_SEPARATE makes stencils possible to work
local RT = GetRenderTargetEx ('onyx_spoly_rt', SIZE, SIZE, 0, MATERIAL_RT_DEPTH_SEPARATE, bit.band(16, 1024), 0, IMAGE_FORMAT_DEFAULT)
local CAPTURE_DATA = {
    x = 0,
    y = 0,
    w = SIZE,
    h = SIZE,
    format = 'png',
    alpha = true
}

file.CreateDir('spoly')

do
    local colorTag = Color(92, 192, 254)
    local colorError = Color(254, 92, 92)
    local tag = '[SPoly] '

    function spoly.Print(text, ...)
        MsgC(colorTag, tag, color_white, string.format(text, ...), '\n')
    end

    function spoly.PrintError(text, ...)
        MsgC(colorTag, tag, colorError, '[ERROR] ', color_white, string.format(text, ...), '\n')
    end
end

--[[------------------------------
Either render.PushFilterMin and render.PushFilterMag don't work with materials created with Lua
Idk what shader parameter is missing, I couldn't find it even by comparing materials' KeyValues
--------------------------------]]
function spoly.Render(id, funcDraw)
    local path = 'spoly/' .. id .. '.png'
    local start = SysTime()

    spoly.status = STATUS_BUSY

    render.PushRenderTarget(RT)

        render.Clear(0, 0, 0, 0)

        cam.Start2D()
            surface.SetDrawColor(color_white)
            draw.NoTexture()
            local success, errorText = pcall(funcDraw, SIZE, SIZE)
        cam.End2D()

        local content = render.Capture(CAPTURE_DATA)

        file.Delete(path)
        file.Write(path, content)

    render.PopRenderTarget()

    materials[id] = Material('data/' .. path, 'mips')

    spoly.status = STATUS_IDLE

    local endtime = SysTime()
    local delta = tostring(math.Round(endtime - start, 3))

    if (not success) then
        spoly.PrintError('Failed to render \'%s\', error text: %s', id, errorText)
    else
        spoly.Print('Rendered \'%s\' in %ss', id, delta)
    end
end

function spoly.Generate(id, funcDraw)
    assert(isstring(id), Format('bad argument #1 to \'spoly.Generate\' (expected string, got %s)', type(id)))
    assert(isfunction(funcDraw), Format('bad argument #2 to \'spoly.Generate\' (expected function, got %s)', type(funcDraw)))

    if (materials[id]) then return end
    if (queued[id]) then return end

    local path = 'spoly/' .. id .. '.png'
    if (file.Exists(path, 'DATA')) then
        materials[id] = Material('data/' .. path, 'mips')
        if (not materials[id]:IsError()) then
            return
        end
    end

    queued[id] = true

    table.insert(queue, {
        id = id,
        funcDraw = funcDraw
    })
end

do
    local thinkRate = 1 / 10
    local nextThink = 0
    hook.Add('Think', 'spoly.QueueController', function()
        if (spoly.status == STATUS_IDLE and queue[1] and nextThink <= CurTime()) then
            nextThink = CurTime() + thinkRate

            local data = table.remove(queue, 1)

            spoly.Render(data.id, data.funcDraw)
        end
    end)
end

do
    local SetDrawColor = surface.SetDrawColor
    local SetMaterial = surface.SetMaterial
    local DrawTexturedRect = surface.DrawTexturedRect
    local DrawTexturedRectRotated = surface.DrawTexturedRectRotated

    local PushFilterMag = render.PushFilterMag
    local PushFilterMin = render.PushFilterMin
    local PopFilterMag = render.PopFilterMag
    local PopFilterMin = render.PopFilterMin

    -- calling this really often so trying to optimize as much as possible
    function spoly.Draw(id, x, y, w, h, color)
        local material = materials[id]
        if (not material) then return end

        if (color) then
            SetDrawColor(color)
        end

        SetMaterial(material)

        PushFilterMag(TEXFILTER.ANISOTROPIC)
        PushFilterMin(TEXFILTER.ANISOTROPIC)

        DrawTexturedRect(x, y, w, h)

        PopFilterMag()
        PopFilterMin()
    end

    function spoly.DrawRotated(id, x, y, w, h, rotation, color)
        local material = materials[id]
        if (not material) then return end

        if (color) then
            SetDrawColor(color)
        end

        SetMaterial(material)

        PushFilterMag(TEXFILTER.ANISOTROPIC)
        PushFilterMin(TEXFILTER.ANISOTROPIC)

        DrawTexturedRectRotated(x, y, w, h, rotation)

        PopFilterMag()
        PopFilterMin()
    end
end
--addons/onyx_framework_2/lua/onyx/ui/libs/cl_util.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_frame_header.lua:
return gluapack()()
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_navbar.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

31/12/2023

--]]

local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorGray = Color(197, 197, 197)
local colorGradient = onyx.LerpColor(.5, colorAccent, colorSecondary)

do
    local PANEL = {}

    AccessorFunc(PANEL, 'm_Name', 'Name')
    AccessorFunc(PANEL, 'm_Font', 'Font')
    AccessorFunc(PANEL, 'm_iRoundness', 'Roundness')
    AccessorFunc(PANEL, 'm_iIconSize', 'IconSize')
    AccessorFunc(PANEL, 'm_iIconMargin', 'IconMargin')
    AccessorFunc(PANEL, 'm_bMasking', 'Masking')
    AccessorFunc(PANEL, 'm_matMaterial', 'Material')
    AccessorFunc(PANEL, 'm_wimgObject', 'WebImage')

    function PANEL:Init()
        self:SetWide(onyx.ScaleWide(120))
        self:SetName('Tab')
        self:SetFont(onyx.Font('Comfortaa Bold@16'))
        self:SetRoundness(8)
        self:SetIconSize(onyx.ScaleTall(14))
        self:SetIconMargin(onyx.ScaleTall(5))
        self:Import('click')
        self.animActiveFraction = 0
    end

    function PANEL:Paint(w, h)
        local x0, y0 = w * .5, h * .5
        local textColor = self:IsHovered() and color_white or colorGray
        local animActiveFraction = self.animActiveFraction
        local screenX, screenY = self:LocalToScreen(0, 0)

        -- unactive text
        if (animActiveFraction < 1) then
            self:DrawContent(x0, y0, ColorAlpha(textColor, (1 - animActiveFraction) * 255))
        end

        -- active text
        if (animActiveFraction > 0) then
            local animHeight = h * animActiveFraction
            local animHeightHalf = animHeight * .5

            render.SetScissorRect(screenX, screenY + h * .5 - animHeightHalf, screenX + w, screenY + h * .5 + animHeightHalf, true)
                self:DrawContent(x0, y0, colorAccent)
            render.SetScissorRect(0, 0, 0, 0, false)
        end
    end

    function PANEL:DrawContent(x0, y0, color)
        local name = self.m_Name
        local font = self.m_Font
        local material = self.m_matMaterial
        local webimage = self.m_wimgObject
        local iconSize = self.m_iIconSize
        local iconMargin = self.m_iIconMargin

        if (material or webimage) then
            local textW = onyx.GetTextSize(name, font)
            local totalW = textW + iconSize + iconMargin
            local x = x0 - totalW * .5

            if (material) then
                onyx.DrawMaterial(material, x, y0 - iconSize * .5, iconSize, iconSize, color)
            else
                webimage:Draw(x, y0 - iconSize * .5, iconSize, iconSize, color)
            end

            draw.SimpleText(name, font, x + iconSize + iconMargin, y0, color, 0, 1)
        else
            draw.SimpleText(name, font, x0, y0, color, 1, 1)
        end
    end

    function PANEL:SetupTab(data)
        self:SetName(data.name)
        self:SetMaterial(data.material)

        if (data.icon) then
            self:SetWebImage(onyx.wimg.Simple(data.icon, 'smooth mips'))
        elseif (data.wimg) then
            self:SetWebImage(data.wimg)
        end
    end

    function PANEL:SizeToContents(space)
        local space = space or 0
        local textW = onyx.GetTextSize(self.m_Name, self.m_Font)
        local totalW = textW + space

        if (self:HasIcon()) then
            totalW = totalW + self:GetIconSize() + self:GetIconMargin()
        end

        self:SetWide(totalW)
    end

    function PANEL:HasIcon()
        return (self.m_matMaterial ~= nil)
    end

    function PANEL:SetActive(bActiveBool)
        self.active = bActiveBool

        onyx.anim.Create(self, .33, {
            index = 1,
            target = {
                animActiveFraction = (bActiveBool and 1 or 0)
            }
        })
    end

    function PANEL:PerformLayout(w, h)
        if (self.m_bMasking) then
            self.mask = onyx.CalculateRoundedBoxEx(self.m_iRoundness, 0, 0, w, h, false, false, true)
        end
    end

    onyx.gui.Register('onyx.Navbar.Tab', PANEL)
end

do
    local PANEL = {}

    AccessorFunc(PANEL, 'm_pnlContainer', 'Container')
    AccessorFunc(PANEL, 'm_pnlActiveTab', 'ActiveTab')
    AccessorFunc(PANEL, 'm_iRoundness', 'Roundness')
    AccessorFunc(PANEL, 'm_bKeepTabContent', 'KeepTabContent')
    AccessorFunc(PANEL, 'm_iSpace', 'Space')

    function PANEL:Init()
        self.tabs = {}
        self:SetRoundness(0)
        self:SetSpace(0)
        self.animLineCurrent = 0
        self.animLineTarget = 0

        self.animLineX = 0
        self.animLineW = 0
    end

    function PANEL:AddTab(data)
        local tab = self:Add('onyx.Navbar.Tab')
        tab:Dock(LEFT)
        tab:DockMargin(0, 0, self.m_iSpace, 0)
        tab:SetupTab(data)
        tab.DoClick = function(panel)
            self:SelectTab(panel)
        end

        tab.tabData = data
        tab.tabIndex = table.insert(self.tabs, tab)
        tab.cornerTab = tab.tabIndex == 1
        tab:SetMasking(tab.cornerTab)
        tab:SetRoundness(self:GetRoundness())

        self:Call('OnTabAdded', nil, tab)

        return tab
    end

    function PANEL:GetTabs()
        return self.tabs
    end

    function PANEL:ChooseTab(index, force)
        local tab = self.tabs[index]
        assert(IsValid(tab), 'tried to choose invalid tab')
        self:SelectTab(tab, force)
    end

    function PANEL:SelectTab(tab, force)
        local shouldKeepTabContent = self.m_bKeepTabContent
        local container = self:GetContainer()
        assert(IsValid(container), string.format('Invalid container (%s) linked to the NavBar', tostring(container)))

        local data = tab.tabData

        if (data.onClick and not data.onClick()) then
            return
        end

        local currentActiveTab = self:GetActiveTab()
        if (IsValid(currentActiveTab)) then
            if (currentActiveTab == tab and not force) then
                return
            end

            currentActiveTab:SetActive(false)
        end

        self:SetActiveTab(tab)
        tab:SetActive(true)

        if (IsValid(currentActiveTab) and IsValid(currentActiveTab.content)) then
            if (shouldKeepTabContent) then
                currentActiveTab.content:Hide()
            else
                currentActiveTab.content:Remove()
            end
        end

        if (IsValid(tab.content)) then
            tab.content:Show()
        else
            tab.content = container:Add(data.class)
            tab.content:Dock(FILL)
            tab.content.tab = tab

            if (data.onBuild) then
                data.onBuild(tab.content)
            end
        end

        self:Call('OnTabSelected', nil, tab, tab.content)

        self.animLineTarget = tab.tabIndex

        if (not self.animLineStart) then
            self.animLineCurrent = self.animLineTarget
            self.animLineX = tab:GetPos()
            self.animLineW = tab:GetWide()
        else
            onyx.anim.Create(self, .33, {
                index = 1,
                easing = 'inOutSine',
                target = {
                    animLineCurrent = self.animLineTarget,
                    animLineX = tab:GetPos(),
                    animLineW = tab:GetWide()
                }
            })
        end

        self.animLineStart = self.animLineCurrent
    end

    function PANEL:PaintOver(w, h)
        local current = self.animLineCurrent
        if (current <= 0) then return end

        local target = self.animLineTarget
        if (target <= 0) then return end

        local gradientHeight = h * .25

        local x = self.animLineX
        local wide = self.animLineW
        if (wide == 0 and current == target) then
            local tab = self:GetChild(target - 1)

            x = tab:GetPos()
            wide = tab:GetWide()
        end

        surface.SetDrawColor(colorAccent)
        surface.DrawRect(x, h - 2, wide, 2)

        onyx.DrawMatGradient(x, h - gradientHeight, wide, gradientHeight, TOP, ColorAlpha(colorGradient, 25))
    end

    onyx.gui.Register('onyx.Navbar', PANEL)
end

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .65, .65, function(self, w, h)
--     self:MakePopup()

--     local content = self:Add('Panel')
--     content:DockPadding(10, 10, 10, 10)
--     content:Dock(FILL)

--     -- local sidebar = self:Add('onyx.Sidebar')
--     local navbar = content:Add('onyx.Navbar')
--     navbar:SetTall(48)
--     navbar:Dock(TOP)
--     navbar.Paint = function(panel, w, h)
--         draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
--     end

--     local container = content:Add('Panel')
--     container:Dock(FILL)

--     navbar:SetContainer(container)
--     navbar:AddTab({
--         name = 'DASHBOARD',
--         desc = 'Main things',
--         class = 'DButton',
--         onSelected = function(panel)
--             panel:SetText('Meow')
--         end
--     })
--     navbar:AddTab({
--         name = 'JOBS',
--         desc = 'Choose your destiny',
--         material = Material('ut_darkrp/ui/box.png', 'mips smooth'),
--         class = 'DButton',
--     })
--     navbar:AddTab({
--         name = 'SHOP',
--         desc = 'Find items you need',
--         material = Material('ut_darkrp/ui/hat.png', 'mips smooth'),
--         class = 'DButton',
--     })
--     navbar:AddTab({
--         name = 'SETTINGS',
--         desc = 'Configure the game as you wish',
--         material = Material('ut_darkrp/ui/gear.png', 'mips smooth'),
--         class = 'DButton',
--     })
-- end)
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_rounded_avatar.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/04/2023

--]]

local PANEL = {}

function PANEL:Init()
    self.avatar = self:Add('AvatarImage')
    self.avatar:Dock(FILL)
    self.avatar:SetPaintedManually(true)

    self:Combine(self.avatar, 'SetPlayer')
    self:Combine(self.avatar, 'SetSteamID')
end

function PANEL:PerformLayout(w, h)
    self.mask = onyx.CalculateCircle(w * .5, h * .5, math.Round(h * .5) - 1, 24)
end

function PANEL:Paint(w, h)
    local mask = self.mask
    if (mask) then
        onyx.MaskFn(function()
            onyx.DrawPoly(mask)
        end, function()
            self.avatar:PaintManual()
        end)
    end
end

onyx.gui.Register('onyx.RoundedAvatar', PANEL)
--addons/onyx_framework_2/lua/onyx/ui/elements/cl_scrollpanel_canvas.lua:
return gluapack()()
--addons/onyx_f4/lua/onyx/modules/f4/languages/cl_french.lua:
return gluapack()()
--addons/onyx_f4/lua/onyx/modules/f4/core/cl_favorites.lua:
return gluapack()()
--addons/onyx_f4/lua/onyx/modules/f4/core/stats/cl_stats.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/01/2024

--]]

netchunk.Callback('onyx.f4:SendStats', function(data)
    hook.Run('onyx.f4.StatsReceived', data)
end)
--addons/onyx_f4/lua/onyx/modules/f4/ui/cl_item.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorOutline = Color(255, 255, 255, 5)
local colorGray = Color(159, 159, 159)
local fontDesc = onyx.Font('Comfortaa@16')
local colorFavoriteIconIdle = Color(235, 235, 235)
local colorFavoriteIconActive = Color(255, 241, 93)

local PANEL = {}

function PANEL:Init()
    self.padding = onyx.ScaleTall(7.5)
    self.itemColor = color_white
    self.itemColorBG = colorPrimary
    self.colorBG = colorSecondary
    self.colorBGGradient = Color(57, 57, 57, 25)
    self.gradientEnabled = onyx.f4:GetOptionValue('colored_items')

    self.iconContainer = self:Add('Panel')
    self.iconContainer:SetMouseInputEnabled(false)
    self.iconContainer.PerformLayout = function(panel, w, h)
        panel.mask = onyx.CalculateCircle(w * .5, h * .5, h * .5 - 2, 24)
    end
    self.iconContainer.Paint = function(panel, w, h)
        local child = panel:GetChild(0)
        if (IsValid(child)) then
            onyx.DrawCircle(w * .5, h * .5, h * .5, self.itemColorBG)

            onyx.DrawWithPolyMask(panel.mask, function()
                child:PaintManual()
            end)

            onyx.DrawOutlinedCircle(w * .5, h * .5, h * .5, 3, self.itemColor)
        end
    end

    if (onyx.f4:GetOptionValue('model_3d')) then
        self.iconModel = self.iconContainer:Add('DModelPanel')
        self.iconModel.LayoutEntity = function() end
        self.iconModel.PreDrawModel = function(panel)
            if (surface.GetAlphaMultiplier() < .5) then
                return false
            end
        end
    else
        self.iconModel = self.iconContainer:Add('SpawnIcon')
    end
    self.iconModel:Dock(FILL)
    self.iconModel:SetPaintedManually(true)
    self.iconModel:DockMargin(2, 2, 2, 2)

    self.lblName = self:Add('onyx.Label')
    self.lblName:SetText('Name')
    self.lblName:Font('Comfortaa Bold@18')
    self.lblName:SetContentAlignment(1)

    self.pnlDesc = self:Add('Panel')
    self.pnlDesc:SetMouseInputEnabled(false)
    self.pnlDesc.label = ''
    self.pnlDesc.text = ''
    self.pnlDesc.color = ''
    self.pnlDesc.Paint = function(panel, w, h)
        local label = panel.label:Trim()
        if (label ~= '') then
            local textW = draw.SimpleText(label .. ': ', fontDesc, 0, 0, colorGray, 0, 0)
            draw.SimpleText(panel.text, fontDesc, textW, 0, panel.color, 0, 0)
        else
            draw.SimpleText(panel.text, fontDesc, 0, 0, panel.color, 0, 0)
        end
    end
end

function PANEL:GetName()
    return self.lblName:GetText()
end

function PANEL:SetDescLabel(label)
    self.pnlDesc.label = label
end

function PANEL:SetDesc(desc)
    self.pnlDesc.text = desc
end

function PANEL:SetDescColor(label)
    self.pnlDesc.color = label
end

function PANEL:SetColor(color, bgFraction)
    self.itemColor = color
    if (bgFraction) then
        self.colorBGGradient = onyx.LerpColor(.05, colorSecondary, self.itemColor)
        self.itemColorBG = onyx.LerpColor(bgFraction, colorSecondary, onyx.CopyColor(self.itemColor))
    end
end

function PANEL:PerformLayout(w, h)
    local padding = self.padding
    local height = h - padding * 2
    local btnFavorite = self.btnFavorite

    self:DockPadding(padding, padding, padding, padding)
    self.mask = onyx.CalculateRoundedBox(8, 1, 1, w - 2, h - 2)

    self.iconContainer:Dock(LEFT)
    self.iconContainer:SetWide(height)
    self.iconContainer:DockMargin(0, 0, onyx.ScaleWide(10), 0)

    self.lblName:Dock(TOP)
    self.lblName:SetTall(height * .5)

    self.pnlDesc:Dock(FILL)

    if (IsValid(btnFavorite) and btnFavorite:IsVisible()) then
        btnFavorite:Dock(RIGHT)
        btnFavorite:SetZPos(-1)
        btnFavorite:SetWide(height)
    end
end

function PANEL:Paint(w, h)
    draw.RoundedBox(8, 0, 0, w, h, colorOutline)
    draw.RoundedBox(8, 1, 1, w - 2, h - 2, self.colorBG)

    if (self.gradientEnabled) then
        onyx.DrawWithPolyMask(self.mask, function()
            onyx.DrawMatGradient(0, 0, w, h, TOP, self.colorBGGradient)
        end)
    end
end

function PANEL:SetModel(modelPath)
    self.iconModel:SetModel(modelPath)
end

function PANEL:SetName(name)
    self.lblName:SetText(name)
end

local AXIS = {'x', 'y', 'z'}
function PANEL:PositionCamera(pos)
    local iconModel = self.iconModel

    if (not IsValid(iconModel)) then return end
    if (iconModel.ClassName ~= 'DModelPanel') then return end

    local ent = iconModel.Entity
    if (not IsValid(ent)) then return end

    if (pos == 'face') then
        local bone = ent:LookupBone('ValveBiped.Bip01_Head1')
        if (not bone) then return end

        local eyepos = ent:GetBonePosition(bone)
        eyepos:Add(Vector(0, 0, 2))

        iconModel:SetLookAt(eyepos)
        iconModel:SetCamPos(eyepos - Vector(-20, 0, 0))
        iconModel:SetFOV(45)

        ent:SetEyeTarget(eyepos - Vector(-20, 0, 0))
    elseif (pos == 'center') then
        local min, max = ent:GetRenderBounds()
        local center = (min + max) / 2
        local distance = 0

        for _, key in ipairs(AXIS) do
            distance = math.max(distance, max[key])
        end

        iconModel:SetLookAt(center)
        iconModel:SetFOV(distance + 10)
    end
end

function PANEL:AddFavoriteButton()
    self.btnFavorite = self:Add('onyx.ImageButton')
    self.btnFavorite.SetState = function(panel, state, ignore)
        panel.bState = state

        if (not ignore and self.objectIdentifier) then
            onyx.f4:SetFavorite(self.objectIdentifier, state)
        end

        local targetColor = state and colorFavoriteIconActive or colorFavoriteIconIdle

        if (state) then
            panel:SetWebImage('favorite_fill', 'smooth mips')
        else
            panel:SetWebImage('favorite_outline', 'smooth mips')
        end

        onyx.anim.Create(panel, .33, {
            index = onyx.anim.ANIM_HOVER,
            target = {
                m_colColor = targetColor
            }
        })

        self:Call('OnFavoriteStateSwitched', nil, state)
    end

    self.btnFavorite.m_Angle = 0
    self.btnFavorite.onyxEvents['OnCursorEntered'] = nil
    self.btnFavorite.onyxEvents['OnCursorExited'] = nil
    self.btnFavorite.onyxEvents['OnRelease'] = nil
    self.btnFavorite.onyxEvents['OnPress'] = nil
    self.btnFavorite:InstallRotationAnim()
    self.btnFavorite.m_iImageScale = .5
    self.btnFavorite.m_iImageScaleInitial = .5

    self.btnFavorite.DoClick = function(panel)
        panel:SetState(not panel.bState)
    end

    self.btnFavorite:SetState(onyx.f4:IsFavorite(self.objectIdentifier), true)
end

onyx.gui.Register('onyx.f4.Item', PANEL)

-- onyx.gui.Test('onyx.f4.Frame', .65, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(3)
-- end)
--addons/onyx_f4/lua/onyx/modules/f4/ui/cl_job_preview.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorTertiary = onyx:Config('colors.tertiary')
local colorLine = Color(75, 75, 75)
local colorBG = onyx.OffsetColor(colorPrimary, -3)
local colorFavoriteIconIdle = Color(235, 235, 235)
local colorFavoriteIconActive = Color(255, 241, 93)

local L = function(...) return onyx.lang:Get(...) end

local function generateDescHTML(desc)
    -- white-space: pre-wrap -- supports /t aswell
    local size = onyx.ScaleTall(12)
    local html = [[
        <head>
            <meta charset="UTF-8">
            <style>
                @import url('https://fonts.googleapis.com/css2?family=Comfortaa&family=Overpass:wght@400;600&display=swap');
                body {
                    color: white;
                    font-family: 'Comfortaa';
                    font-size: %dpx;
                    opacity: 0.999;
                    padding: 0;
                    margin: 0;
                    white-space: pre-line;
                    scroll-margin: 20px;
                    line-height: 1.5;
                }

                li {
                    line-height: 5px;
                }

                img {
                    text-align: center;
                    vertical-align: middle;
                    width: 24px;
                    height: 24px;
                }

                /* width */
                ::-webkit-scrollbar {
                    width: 4px;
                }

                /* Track */
                ::-webkit-scrollbar-track {
                    background: rgba(0, 0, 0, 0.1);
                    border-radius: 5px;
                }

                /* Handle */
                ::-webkit-scrollbar-thumb {
                    background: ]] .. onyx.ColorToHex(colorAccent) .. [[;
                    border-radius: 5px;
                }

                /* Handle on hover */
                ::-webkit-scrollbar-thumb:hover {
                    background: ]] .. onyx.ColorToHex(onyx.OffsetColor(colorAccent, -30)) .. [[;
                }
            </style>
        </head>
        <body>
            %s
        </body>
    ]]
    return string.format(html, size, desc)
end

local PANEL = {}

function PANEL:Init()
    self.colorSlightGradient = colorTertiary

    self.divInfo = self:Add('Panel')

    self.divModel = self:Add('Panel')

    self.iconModel = self.divModel:Add('DModelPanel')
    self.iconModel:Dock(FILL)
    self.iconModel:SetCursor('arrow')
    self.iconModel.LayoutEntity = function(panel, ent) end
    self.iconModel.slots = {}
    self.iconModel.PerformLayout = function(panel, w, h)
        local children = panel.slots
        local amount = #children
        local columns = 2
        local rows = math.ceil(amount / columns)
        local size = onyx.ScaleTall(36)
        local padding = onyx.ScaleTall(10)
        local space = onyx.ScaleTall(5)
        local X = w - size * columns - padding - space
        local Y = h - size * rows - padding - space * (rows - 1)

        local x = X
        for index = 1, amount do
            local button = children[index]

            button:SetSize(size, size)
            button:SetPos(x, Y)

            if (index % columns == 0) then
                x = X
                Y = Y + size + space
            else
                x = x + size + space
            end
        end
    end

    self.lblName = self.divInfo:Add('onyx.Label')
    self.lblName:Font('Comfortaa Bold@20')
    self.lblName:SetWrap(true)
    self.lblName:SetTextColor(color_white)
    self.lblName:SetAutoStretchVertical(true)
    self.lblName:Dock(TOP)

    self.lblSalary = self.divInfo:Add('onyx.Label')
    self.lblSalary:Font('Comfortaa Bold@16')
    self.lblSalary:SetTextColor(Color(161, 161, 161))
    self.lblSalary:Dock(TOP)
    self.lblSalary:DockMargin(0, 0, 0, onyx.ScaleTall(20))

    self.navbar = self.divInfo:Add('onyx.Navbar')
    self.navbar:Dock(TOP)
    self.navbar:SetTall(onyx.ScaleTall(35))
    self.navbar:DockMargin(0, 0, 0, onyx.ScaleTall(5))
    self.navbar:SetSpace(onyx.ScaleWide(15))
    self.navbar.Paint = function(panel, w, h)
        local x1 = -self.padding
        local w1 = w + self.padding * 2

        local parent = self:GetParent()
        local x, y = parent:LocalToScreen(0, 0)
        local realW, realH = parent:GetSize()

        DisableClipping(true)
            render.SetScissorRect(x, y, x + realW, y + realH, true)
                surface.SetDrawColor(colorLine)
                surface.DrawRect(x1, h - 1, w1, 1)
            render.SetScissorRect(0, 0, 0, 0, false)
        DisableClipping(false)
    end
    self.navbar.OnTabAdded = function(panel, tab)
        tab:SizeToContents()
        tab:SetFont(onyx.Font('Comfortaa Bold@14'))
    end

    self.navbarContent = self.divInfo:Add('Panel')
    self.navbarContent:Dock(FILL)

    self.navbar:SetKeepTabContent(true)
    self.navbar:SetContainer(self.navbarContent)

    self.footer = self.divInfo:Add('Panel')
    self.footer:Dock(BOTTOM)
    self.footer:SetTall(onyx.ScaleTall(30))

    self.btnChoose = self.footer:Add('onyx.Button')
    self.btnChoose:SetText(L('f4_become_u'))
    self.btnChoose:SetGradientColor(onyx.OffsetColor(colorAccent, -50))
    self.btnChoose:SetMasking(true)
    self.btnChoose:Font('Comfortaa Bold@16')
    self.btnChoose:Dock(FILL)

    self.btnFavorite = self.footer:Add('onyx.ImageButton')
    self.btnFavorite:Dock(RIGHT)
    self.btnFavorite:SetWide(self.footer:GetTall( ))
    self.btnFavorite:DockMargin(onyx.ScaleTall(10), 0, 0, 0)
    self.btnFavorite.SetState = function(panel, state, ignore)
        panel.bState = state

        if (not ignore) then
            onyx.f4:SetFavorite(self.teamCommand, state)
            self:Call('OnFavoriteStateSwitched', nil, self.teamCommand, state)
        end

        local targetColor = state and colorFavoriteIconActive or colorFavoriteIconIdle

        if (state) then
            panel:SetWebImage('favorite_fill', 'smooth mips')
        else
            panel:SetWebImage('favorite_outline', 'smooth mips')
        end

        onyx.anim.Create(panel, .33, {
            index = onyx.anim.ANIM_HOVER,
            target = {
                m_colColor = targetColor
            }
        })
    end

    self.btnFavorite.m_Angle = 0
    self.btnFavorite.onyxEvents['OnCursorEntered'] = nil
    self.btnFavorite.onyxEvents['OnCursorExited'] = nil
    self.btnFavorite.onyxEvents['OnRelease'] = nil
    self.btnFavorite.onyxEvents['OnPress'] = nil
    self.btnFavorite:InstallRotationAnim()
    self.btnFavorite.m_iImageScale = 1
    self.btnFavorite.m_iImageScaleInitial = 1

    self.btnFavorite.DoClick = function(panel)
        panel:SetState(not panel.bState)
    end

    self.spacer = self.divInfo:Add('Panel')
    self.spacer:Dock(BOTTOM)
    self.spacer:DockMargin(0, onyx.ScaleTall(10), 0, onyx.ScaleTall(5))
    self.spacer.Paint = function(panel, w, h)
        local x1 = -self.padding
        local w1 = w + self.padding * 2

        local parent = self:GetParent()
        local x, y = parent:LocalToScreen(0, 0)
        local realW, realH = parent:GetSize()

        DisableClipping(true)
            render.SetScissorRect(x, y, x + realW, y + realH, true)
                surface.SetDrawColor(colorLine)
                surface.DrawRect(x1, h * .5, w1, 1)
            render.SetScissorRect(0, 0, 0, 0, false)
        DisableClipping(false)
    end

    self.navbar:AddTab({
        name = L('f4_description_u'),
        class = 'DHTML',
        onBuild = function(content)
            content:SetHTML(generateDescHTML(''))
        end
    })

    self.navbar:AddTab({
        name = L('f4_weapons_u'),
        class = 'onyx.ScrollPanel'
    })
end

function PANEL:SetupJob(job)
    local models = job.model
    local multipleModels = istable(models) and #models > 1
    local model = istable(models) and models[1] or models
    local desc = job.description:Trim()
    local weaponsList = job.weapons or {}
    local teamIndex = job.team

    local navbar = self.navbar
    local tabs = navbar.tabs
    local descTab = tabs[1]
    local weaponsTab = tabs[2]
    local btnChoose = self.btnChoose

    self.teamIndex = teamIndex
    self.teamCommand = job.command
    self.teamData = job

    self.btnFavorite:SetState(onyx.f4:IsFavorite(job.command), true)

    if (job.vote or job.RequiresVote and job.RequiresVote(LocalPlayer(), job.team)) then
        btnChoose:SetText(L('f4_create_vote_u'))
        btnChoose.DoClick = function(panel)
            RunConsoleCommand('darkrp', 'vote' .. self.teamCommand)
        end
    else
        btnChoose:SetText(L('f4_become_u'))
        btnChoose.DoClick = function(panel)
            RunConsoleCommand('darkrp', self.teamCommand)
        end
    end

    self.lblName:SetText(onyx.utf8.upper(job.name))

    self.lblSalary:SetText(L('f4_salary') .. ': ' .. DarkRP.formatMoney(job.salary))

    self.colorSlightGradient = onyx.LerpColor(.1, colorSecondary, job.color)

    self.iconModel:SetModel(model)
    self.iconModel:SetCamPos(Vector(50, 0, 50))
    self.iconModel:SetFOV(45)

    self.iconModel:Clear()
    self.iconModel.slots = {}

    if (multipleModels) then
        local oldActiveModel
        for index, model in ipairs(models) do
            if (index > 14) then break end

            local button = self.iconModel:Add('DButton')
            button:SetText('')
            button.active = index == 1
            button.PerformLayout = function(panel, w, h)
                panel.mask = onyx.CalculateCircle(w * .5, h * .5, h * .5 - 2, 16)
            end
            button.Paint = function(panel, w, h)
                local child = panel:GetChild(0)

                onyx.DrawCircle(w * .5, h * .5, h * .5, colorSecondary)

                if (IsValid(child)) then
                    onyx.DrawWithPolyMask(panel.mask, function()
                        child:PaintManual()
                    end)
                end

                onyx.DrawOutlinedCircle(w * .5, h * .5, h * .5, 3, panel.active and colorAccent or color_white)
            end
            button.DoClick = function(panel)
                if (oldActiveModel) then
                    oldActiveModel.active = false
                end

                self.iconModel:SetModel(model)
                panel.active = true
                oldActiveModel = panel

                DarkRP.setPreferredJobModel(teamIndex, model)
            end

            if (index == 1) then
                oldActiveModel = button
            end

            local modelicon = button:Add('SpawnIcon')
            modelicon:Dock(FILL)
            modelicon:SetModel(model)
            modelicon:SetMouseInputEnabled(false)
            modelicon:SetPaintedManually(true)

            table.insert(self.iconModel.slots, button)
        end
    end

    navbar:SelectTab(descTab, true)

    if (IsValid(descTab.content)) then
        desc = desc:gsub('\t', '')
        desc = string.JavascriptSafe(desc)

        descTab.content:QueueJavascript([[
            document.body.innerHTML = ']] .. desc .. [[';
        ]])
    end

    weaponsTab:SetVisible(#weaponsList > 0)
    weaponsTab.tabData.onBuild = function(content)
        for _, class in ipairs(weaponsList) do
            local swepTable = weapons.Get(class)
            local name
            if (swepTable) then
                name = language.GetPhrase(swepTable.PrintName)
            else
                name = language.GetPhrase(class)
            end

            local panel = content:Add('onyx.Label')
            panel:Dock(TOP)
            panel:SetText(name)
            panel:SetTall(onyx.ScaleTall(30))
            panel:SetContentAlignment(5)
            panel:SetFont(onyx.Font('Comfortaa Bold@16'))
            panel.Paint = function(this, w, h)
                draw.RoundedBox(8, 0, 0, w, h, colorPrimary)
                draw.RoundedBox(8, 1, 1, w - 2, h - 2, colorTertiary)
            end
        end
    end

    if (IsValid(weaponsTab.content)) then
        weaponsTab.content:Remove()
    end
end

function PANEL:PerformLayout(w, h)
    local padding = onyx.ScaleTall(15)
    self.padding = padding

    self.divInfo:Dock(FILL)
    self.divInfo:DockPadding(padding, padding, padding, onyx.ScaleTall(5))

    self.divModel:Dock(RIGHT)
    self.divModel:SetWide(w * .5)
end

function PANEL:Paint(w, h)
    local x, y = self:LocalToScreen(0, 0)

    local frame = onyx.f4.frame
    if (not IsValid(frame)) then return end -- just in case

    local realX, realY = frame.container:LocalToScreen(0, 0)
    local realW, realH = frame.container:GetSize()
    local padding = frame.containerPadding

    local divModel = self.divModel
    local Y = -padding
    local H = h + padding * 2
    local W = w + padding

    if (self.enabled) then
        onyx.bshadows.BeginShadow()
            surface.SetDrawColor(colorSecondary)
            surface.DrawRect(x, y, w, h)
        onyx.bshadows.EndShadow(1, 2, 2, nil, 90, 2, true)
    end

    DisableClipping(true)
        render.SetScissorRect(realX, realY, realX + realW, realY + realH, true)
            draw.RoundedBoxEx(8, 0, Y, W, H, colorSecondary, false, false, false, true)

            draw.RoundedBoxEx(8, divModel:GetPos(), Y, divModel:GetWide() + padding, H, colorBG, false, false, false, true)

            onyx.DrawMatGradient(0, Y, self.divInfo:GetWide(), H * .5, BOTTOM, self.colorSlightGradient)
        render.SetScissorRect(0, 0, 0, 0, false)
    DisableClipping(false)
end

onyx.gui.Register('onyx.f4.JobPreview', PANEL)
--addons/bb_onyx_hud/lua/onyx/modules/hud/core/cl_core.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/core/cl_fonts.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/core/cl_level_support.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/core/cl_scaling.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

14/08/2024

--]]

-- I made this to cache calculated values for UI scaling
-- It is working cheaper than using raw functions ;P

local CONVAR = CreateClientConVar( 'cl_onyx_hud_scale', '100', true, false, 'Scale', 50, 150 )

local currentContextID
local cache = {
    [ 1 ] = {}, -- ScaleWide
    [ 2 ] = {} -- ScaleTall
}

local scale do
    local Round = math.Round
    function scale( int, method, storageIndex )
        local scaleFunc = onyx[ method ]
        local scaleInt = onyx.hud.GetScale() -- from outside

        if ( currentContextID ) then
            local cacheTable = cache[ storageIndex ]
            local cached = cacheTable[ int ]

            if ( cached ) then
                return cached
            else
                local result = Round( scaleFunc( int ) * scaleInt )
    
                cache[ storageIndex ][ int ] = result
    
                return result
            end
        else
            return Round( scaleFunc( int ) * scaleInt )
        end
    end
end

function onyx.hud.GetScale()
    return ( CONVAR:GetInt() / 100 )
end

function onyx.hud.StartScaling( contextID )
    currentContextID = contextID
end

function onyx.hud.EndScaling()
    if ( currentContextID ) then
        currentContextID = nil
    end
end

function onyx.hud.ScaleWide( int )
    return scale( int, 'ScaleWide', 1 )
end

function onyx.hud.ScaleTall( int )
    return scale( int, 'ScaleTall', 2 )
end

function onyx.hud.ResetScaleCache()
    local client = LocalPlayer()

    for index = 1, 2 do
        cache[ index ] = {}
    end

    for id, element in pairs( onyx.hud.elements ) do
        if ( element.onSizeChanged ) then
            element:onSizeChanged( client )
        end
    end
end

cvars.AddChangeCallback( 'cl_onyx_hud_scale', function( _, _, new )
    onyx.hud.ResetScaleCache()
    onyx.hud.BuildFonts()
end, 'onyx.hud.Update' )

hook.Add( 'OnScreenSizeChanged', 'onyx.hud.ResetScaleCache', function()
    onyx.hud.ResetScaleCache()
    onyx.hud.BuildFonts()
end )
--addons/bb_onyx_hud/lua/onyx/modules/hud/core/cl_settings.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/cfg/cl_themes.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_door_menu.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_gesture_menu.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

16/08/2024

--]]

local animationsTable = {}
animationsTable[ ACT_GMOD_GESTURE_BOW ] = 'bow'
animationsTable[ ACT_GMOD_TAUNT_MUSCLE ] = 'sexy_dance'
animationsTable[ ACT_GMOD_GESTURE_BECON ] = 'follow_me'
animationsTable[ ACT_GMOD_TAUNT_LAUGH ] = 'laugh'
animationsTable[ ACT_GMOD_TAUNT_PERSISTENCE ] = 'lion_pose'
animationsTable[ ACT_GMOD_GESTURE_DISAGREE ] = 'nonverbal_no'
animationsTable[ ACT_GMOD_GESTURE_AGREE ] = 'thumbs_up'
animationsTable[ ACT_GMOD_GESTURE_WAVE ] = 'wave'
animationsTable[ ACT_GMOD_TAUNT_DANCE ] = 'dance'

local animationsFrame
local function openGestureMenu()
    if ( IsValid( animationsFrame ) ) then
        return
    end

    local size = onyx.hud.ScaleTall( 512 )

    local choiceWheel = vgui.Create( 'onyx.hud.ChoiceWheel' )
    animationsFrame = choiceWheel
    choiceWheel:SetSize( size, size )
    choiceWheel:SetShowLabel( false )
    choiceWheel:MakePopup()
    choiceWheel:Center()
    choiceWheel.OnRemove = function()
        animationsFrame = nil
    end

    choiceWheel:AddChoice( { name = onyx.lang:Get( 'close' ) } )
    
    for animID, animName in pairs( animationsTable ) do
        choiceWheel:AddChoice( {
            name = DarkRP.getPhrase( animName ),
            callback = function()
                RunConsoleCommand( '_DarkRP_DoAnimation', animID )                                                                                                                                                                                                                                                              -- 9ad7c9aa-1560-4920-b64e-ac40347a307b
            end
        } )
    end
end

onyx.hud.OverrideGamemode( 'onyx.hud.OverrideGesturesMenu', function()
    concommand.Add( '_DarkRP_AnimationMenu', openGestureMenu )
end )
--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_main.lua:
return gluapack()()
--addons/bb_onyx_hud/lua/onyx/modules/hud/elements/cl_overhead.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

11/08/2024

--]]

local hud = onyx.hud
local nearest = {}
local statuses = {}

local MAX_DISTANCE = 400 ^ 2
local MAX_GLOBAL_DRAWS = 12

local CONVAR_MAX_DETAILED = CreateClientConVar( 'cl_onyx_hud_3d2d_max_details', '3', true, false, '', 1, 5 )

local COLOR_LOW_HP = Color( 255, 59, 59)
local COLOR_MAX_HP = Color( 115, 255, 49)
local COLOR_ARMOR = Color( 52, 130, 255)
local COLOR_RED = Color( 255, 52, 52)
local COLOR_BLUE = Color( 55, 52, 255)
local COLOR_SLIGHT_SHADOW = Color( 0, 0, 0, 150 )
local ICON_SIZE = 64
local WIMG_LICENSE = onyx.wimg.Create( 'hud_license', 'smooth mips' )

local FONT_NAME = onyx.hud.CreateFont3D2D( 'OverheadName', 'Comfortaa Bold', 72 )
local FONT_JOB = onyx.hud.CreateFont3D2D( 'OverheadJob', 'Comfortaa SemiBold', 40 )
local FONT_STATUS = onyx.hud.CreateFont3D2D( 'OverheadStatus', 'Comfortaa Bold', 64 )

local drawShadowText = onyx.hud.DrawShadowText

local getStatuses, hasStatus do
    local function createStatus( data )
        data.wimg = onyx.wimg.Create( data.icon, 'smooth mips' )
        table.insert( statuses, data )
    end

    function getStatuses( ply )
        local result = {}
        for _, status in ipairs( statuses ) do
            if ( status.func( ply ) ) then
                table.insert( result, status )
            end
        end
        return result
    end

    -- Quicker than checking by amount
    function hasStatus( ply )
        for _, status in ipairs( statuses ) do
            if ( status.func( ply ) ) then
                return true
            end
        end
        return false
    end

    createStatus( {
        id = 'wanted',
        icon = 'hud_wanted',
        big = true,
        func = function( ply )
            return ply:getDarkRPVar( 'wanted' )
        end,
        getColor = function()
            local fraction = math.abs( math.sin( CurTime() ) )
            local color = onyx.LerpColor( fraction, COLOR_RED, COLOR_BLUE )
            return color
        end
    } )

    createStatus( {
        id = 'speaking',
        icon = 'hud_microphone',
        func = function( ply )
            return ply:IsSpeaking()
        end
    } )

    createStatus( {
        id = 'typing',
        icon = 'hud_chat',
        func = function( ply )
            return ply:IsTyping()
        end
    } )
end

local function drawStatus( ply, y )
    local halfIconSize = ICON_SIZE * .5
    local iconSpace = 10
    local statuses = getStatuses( ply )
    local amount = #statuses
    local totalW = amount * ICON_SIZE + ( amount - 1 ) * iconSpace
    local iconX = -totalW * .5
    local isSingle = amount == 1

    -- Draw microphone
    for i = 1, amount do
        local status = statuses[ i ]
        local color = status.getColor and status.getColor() or ( status.color or hud:GetColor( 'accent' ) )

        if ( isSingle and status.big ) then
            status.text = status.text or onyx.lang:Get( 'hud_status_' .. status.id )
            local text = status.text

            if ( status.dots ) then
                text = text .. string.rep( '.', CurTime() % 4 )
            end
        
            surface.SetFont( FONT_STATUS )
            local textW, textH = surface.GetTextSize( text )
            
            iconX = iconX - ( textW + iconSpace ) * .5

            drawShadowText( text, FONT_STATUS, iconX + ICON_SIZE + iconSpace, y + ICON_SIZE * .5 - textH * .5, color )
        end

        status.wimg:Draw( iconX + 2, y + 2, ICON_SIZE, ICON_SIZE, COLOR_SLIGHT_SHADOW )
        status.wimg:Draw( iconX, y, ICON_SIZE, ICON_SIZE, color )
    
        iconX = iconX + ICON_SIZE + iconSpace
    end
end

local function drawQuickInfo( ply, client )
    drawStatus( ply, 0 )
end

local badgeMaterials = {}
local function GetBadgeMaterial(matName)
    if not badgeMaterials[matName] then
        badgeMaterials[matName] = Material("badge/" .. matName .. ".png", "smooth mips")
    end
    return badgeMaterials[matName]
end
local originalDrawInfo = drawInfo

function drawInfo(ply, client)
    if not IsValid(ply) then return end
    
    local playerName = ply:Name()
    local teamID = ply:Team()
    local teamName = ply:getDarkRPVar("job")
    if not teamName then return end
    local teamColor = team.GetColor(teamID)
    local hasLicense = ply:getDarkRPVar('HasGunLicense')
    local shouldDrawHealth = hud.IsElementEnabled('overhead_health')

    local currentY = -100

    drawStatus(ply, -ICON_SIZE - 145)

    -- Draw name
    if (hasLicense) then
        local iconSize = 32
        local iconSpace = 15

        surface.SetFont(FONT_NAME)
        local nameTextW, nameTextH = surface.GetTextSize(playerName)
        
        local nameX = (nameTextW + iconSize + iconSpace) * -.5
        local iconY = currentY + nameTextH * .5 - iconSize * .5
        
        WIMG_LICENSE:Draw(nameX + nameTextW + iconSpace + 2, iconY + 2, iconSize, iconSize, COLOR_SLIGHT_SHADOW)
        WIMG_LICENSE:Draw(nameX + nameTextW + iconSpace, iconY, iconSize, iconSize)

        drawShadowText(playerName, FONT_NAME, nameX, currentY, color_white)
        currentY = currentY + 65
    else
        drawShadowText(playerName, FONT_NAME, 0, currentY, color_white, 1, 0)
        currentY = currentY + 65
    end

    -- Draw team
    drawShadowText(teamName, FONT_JOB, 0, currentY, teamColor, 1, 0)
    currentY = currentY + 40

    -- Draw health & armor
    if (shouldDrawHealth) then
        local healthInt = ply:Health()
        local healthFraction = math.Clamp(healthInt / ply:GetMaxHealth(), 0, 1)
        local healthColor = onyx.LerpColor(healthFraction, COLOR_LOW_HP, COLOR_MAX_HP)
        
        local armorInt = ply:Armor()
        local shouldDrawArmor = armorInt > 0 and hud.IsElementEnabled('overhead_armor')

        local healthText = healthInt .. ' HP'
        
        if (shouldDrawArmor) then
            healthText = healthText .. '  '
            local armorText = armorInt .. ' AP'

            surface.SetFont(FONT_JOB)
            local healthTextWidth = surface.GetTextSize(healthText)
            local armorTextWidth = surface.GetTextSize(armorText)
            local totalTextWidth = healthTextWidth + armorTextWidth
            local textX = -totalTextWidth * .5
        
            drawShadowText(healthText, FONT_JOB, textX, currentY, healthColor)
            drawShadowText(armorText, FONT_JOB, textX + healthTextWidth, currentY, COLOR_ARMOR)
        else
            drawShadowText(healthText, FONT_JOB, 0, currentY, healthColor, 1, 0)
        end

        currentY = currentY + 30
    end

    drawShadowText(GlorifiedLeveling.GetPlayerLevel(ply).." Level", FONT_JOB, 0, currentY, color_white, 1, 0)
    currentY = currentY + 50

    local badges = ply:GetBadges()
    if badges and #badges > 0 then
        local BADGE_SIZE = 64
        local BADGE_SPACING = 5
        
        local totalWidth = (#badges * BADGE_SIZE) + ((#badges - 1) * BADGE_SPACING)
        local startX = -totalWidth / 2
        
        for i, badge in ipairs(badges) do
            local mat = GetBadgeMaterial(badge)
            if mat then
                local x = startX + ((i-1) * (BADGE_SIZE + BADGE_SPACING))
                
          
                surface.SetDrawColor(COLOR_SLIGHT_SHADOW)
                surface.SetMaterial(mat)
                surface.DrawTexturedRect(x + 1, currentY + 1, BADGE_SIZE, BADGE_SIZE)
                
            
                surface.SetDrawColor(255, 255, 255, 255)
                surface.SetMaterial(mat)
                surface.DrawTexturedRect(x, currentY, BADGE_SIZE, BADGE_SIZE)
            end
        end
    end
end

timer.Create( 'onyx.hud.CollectNearestPlayers', 0.85, 0, function()
    local client = LocalPlayer()
    if ( IsValid( client ) ) then
        nearest = {}

        -- Make sure that any random error (if there is any) won't break the timer
        ProtectedCall( function()
            local origin = client:GetPos()
            local aimVector = client:GetAimVector()
        
            for _, ply in player.Iterator() do
                local playerPos = ply:GetPos()
                if ( ply ~= client and ply:Alive() and ply:GetColor().a > 50 and ply:Health() > 0 and not ply:GetNoDraw() and playerPos:DistToSqr( origin ) <= MAX_DISTANCE ) then
                    local dotProduct = aimVector:Dot( ( playerPos - origin ):GetNormalized() )
                    if ( dotProduct > .6 ) then
                        table.insert( nearest, {
                            ply = ply,
                            dot = dotProduct
                        } )
                    end
                end
            end

            table.sort( nearest, function( a, b )
                return a.dot > b.dot
            end )
        end )
    end
end )
local vectorcache =  Vector( 0, 0, 90 )
hook.Add( 'PostDrawTranslucentRenderables', 'onyx.hud.DrawOverheadInfo', function()
    local client = LocalPlayer()
    local eyeangle = client:EyeAngles()

   -- for _, object in ipairs( nearest ) do
   for i = 1, #nearest do
        local object = nearest[i]
        local ply = object.ply
        if ( IsValid( ply ) ) then

            if ( i > MAX_GLOBAL_DRAWS ) then break end

            local detailed = i <= 3
            local shouldDraw = detailed or hasStatus( ply )

            if ( shouldDraw ) then

                local pos = ply:GetPos() + vectorcache
                local ang = Angle( 0, eyeangle.y - 90, 90 )
                
                cam.Start3D2D( pos, ang, 0.075 )
                    if ( detailed ) then
                        drawInfo( ply, client )
                    else
                        drawQuickInfo( ply, client )
                    end
                cam.End3D2D()
            end
        end
    end
end )
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/core/ranks/cl_ranks.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

onyx.scoreboard.nameEffects = {}

function onyx.scoreboard:RegisterNameEffect(id, func)
    table.insert(onyx.scoreboard.nameEffects, {
        id = id,
        func = func,
        name = ('scoreboard_eff_' .. id)
    })
end

function onyx.scoreboard:FindNameEffect(id)
    for index, data in ipairs(self.nameEffects) do
        if (data.id == id) then
            return data, index
        end
    end
end

do
    local fontCommon = onyx.Font('Comfortaa SemiBold@16') -- the size got dynamically changed
    local fontGlow = onyx.Font('Comfortaa SemiBold@16', 'blursize:2') -- the size got dynamically changed

    local COLOR_SHADOW = Color(0, 0, 0, 100)
    local SHADOW_DISTANCE = 2

    local ColorAlpha = ColorAlpha
    local SimpleText = draw.SimpleText

    -- Common (colorized)
    onyx.scoreboard:RegisterNameEffect('default', function(text, x, y, color, ax, ay)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontCommon, x, y, color, ax, ay)
    end)

    -- Glow (colorized)
    onyx.scoreboard:RegisterNameEffect('glow', function(text, x, y, color, ax, ay)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontGlow, x, y, ColorAlpha(color, 80 + 80 * math.abs(math.sin(CurTime() * 2))), ax, ay)
        SimpleText(text, fontCommon, x, y, color, ax, ay)
    end)

    -- Rainbow
    onyx.scoreboard:RegisterNameEffect('rainbow', function(text, x, y, color, ax, ay)
        local lastX = x
        local counter = 0
        local speed = CurTime() * 50

        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)

        for _, code in utf8.codes(text) do
            local offset = counter * 5
            local color = HSVToColor((speed + offset) % 360, 1, 1)

            counter = counter + 1
            lastX = lastX + select(1, SimpleText(utf8.char(code), fontCommon, lastX, y, color, ax, ay))
        end
    end)

    -- Wavy Dual
    onyx.scoreboard:RegisterNameEffect('wavy_dual', function(text, x, y, color, ax, ay)
        local lastX = x
        local counter = 0
        local speed = CurTime() * 5

        -- draw.SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)

        for _, code in utf8.codes(text) do
            local offset = math[counter % 2 == 0 and 'cos' or 'sin'](speed)
            local fraction = math.abs(offset)
            local color1 = color
            local h, s, v = ColorToHSV(color1)
            local color2 = onyx.ColorEditHSV(color1, (h + 90) % 360)
            local color = onyx.LerpColor(fraction, color1, color2)
            local char = utf8.char(code)

            counter = counter + 1

            SimpleText(char, fontCommon, lastX + SHADOW_DISTANCE, y + offset * .05 + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
            lastX = lastX + select(1, SimpleText(char, fontCommon, lastX, y + offset * .05, color, ax, ay))
        end
    end)

    -- Gradient
    onyx.scoreboard:RegisterNameEffect('gradient_invert', function(text, x, y, color, ax, ay, realX, realY)
        local color1 = color
        local h, s, v = ColorToHSV(color1)
        local color2 = onyx.ColorEditHSV(color1, (h + 180) % 360)

        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        local textW, textH = SimpleText(text, fontCommon, x, y, color, ax, ay)

        local realYStart = realY - textH * .5

        render.SetScissorRect(realX, realYStart + textH * .65, realX + textW, realYStart + textH, true)
            SimpleText(text, fontCommon, x, y, color2, ax, ay)
        render.SetScissorRect(0, 0, 0, 0, false)
    end)

    -- Scanning
    onyx.scoreboard:RegisterNameEffect('scanning_vertical', function(text, x, y, color, ax, ay, realX, realY)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontGlow, x, y, ColorAlpha(color, 30), ax, ay)
        local textW, textH = SimpleText(text, fontCommon, x, y, color_black, ax, ay)

        local realYStart = realY - textH * .5
        local animYStart = realYStart + textH * ((CurTime() * .5) % 1.5)
        local scanLineHeight = textH
        local scanLineRadius = scanLineHeight * .15

        render.SetScissorRect(realX, animYStart, realX + textW, animYStart + scanLineRadius, true)
            SimpleText(text, fontCommon, x, y, color, ax, ay)
        render.SetScissorRect(0, 0, 0, 0, false)
    end)

    onyx.scoreboard:RegisterNameEffect('scanning_horizontal', function(text, x, y, color, ax, ay, realX, realY)
        SimpleText(text, fontCommon, x + SHADOW_DISTANCE, y + SHADOW_DISTANCE, COLOR_SHADOW, ax, ay)
        SimpleText(text, fontGlow, x, y, ColorAlpha(color, 30), ax, ay)
        local textW, textH = SimpleText(text, fontCommon, x, y, color_black, ax, ay)

        local realYStart = realY - textH * .5
        local animXStart = realX + textW * ((CurTime() * 1) % 1.5)
        local scanLineWidth = textW
        local scanLineRadius = scanLineWidth * .1

        render.SetScissorRect(animXStart, realYStart, animXStart + scanLineRadius, realYStart + textH, true)
            SimpleText(text, fontCommon, x, y, color, ax, ay)
        render.SetScissorRect(0, 0, 0, 0, false)
    end)
end

net.Receive('onyx.scoreboard:SyncRanks', function(length)
    local rawData = net.ReadData(length)
    local parsedData = pon.decode(rawData)

    onyx.scoreboard.ranks = parsedData
    onyx.scoreboard:Print('Synchronized ranks.')

    hook.Run('onyx.scoreboard.SyncedRanks')
end)
--addons/onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_frame.lua:
return gluapack()()
--lua/autorun/openpermissions.lua:
OpenPermissions_Readying = true
OpenPermissions_Ready = nil

if (CLIENT and IsValid(OpenPermissions_Menu)) then
	OpenPermissions_Menu:Close()
end

OpenPermissions = {}
OpenPermissions.pon = include("openpermissions/thirdparty/pon.lua")

OpenPermissions.Version = "v1.0"

OpenPermissions.COLOR_WHITE      = Color(255,255,255)
OpenPermissions.COLOR_LIGHT_BLUE = Color(0,255,255)
OpenPermissions.COLOR_YELLOW     = Color(0,255,255)
OpenPermissions.COLOR_RED        = Color(255,0,0)
OpenPermissions.COLOR_GREEN      = Color(0,255,0)
OpenPermissions.COLOR_BLACK      = Color(0,0,0)
OpenPermissions.COLOR_SOFT_GREEN = Color(76,216,76)
OpenPermissions.COLOR_SOFT_RED   = Color(216,76,76)

local version_info = "Version: " .. OpenPermissions.Version
local padding = (65 - #version_info) / 2
local version_str = (" "):rep(math.ceil(padding)) .. version_info .. (" "):rep(math.floor(padding))

local github_link = "https://github.com/WilliamVenner/GLua-OpenPermissions"
local padding = (65 - #github_link) / 2
local github_str = (" "):rep(math.ceil(padding)) .. github_link .. (" "):rep(math.floor(padding))

MsgC(OpenPermissions.COLOR_YELLOW, [[

     _____             _____               _         _             
    |     |___ ___ ___|  _  |___ ___ _____|_|___ ___|_|___ ___ ___ 
    |  |  | . | -_|   |   __| -_|  _|     | |_ -|_ -| | . |   |_ -|
    |_____|  _|___|_|_|__|  |___|_| |_|_|_|_|___|___|_|___|_|_|___|
          |_|                                                      

]])
MsgC(OpenPermissions.COLOR_GREEN,  "  [=================================================================]\n")
MsgC(OpenPermissions.COLOR_YELLOW, "  [" ..                       version_str                       .. "]\n")
MsgC(OpenPermissions.COLOR_YELLOW, "  [" ..                       github_str                        .. "]\n")
MsgC(OpenPermissions.COLOR_GREEN,  "  [=================================================================]\n\n")

function OpenPermissions:Print(msg, prefix, color)
	MsgC(color or Color(0,255,255), "[OpenPermissions] " .. (prefix or "") .. " ", Color(255,255,255), msg, "\n")
end
function OpenPermissions:ChatPrint(msg, prefix, color)
	chat.AddText(color or Color(0,255,255), "[OpenPermissions] " .. (prefix or "") .. " ", Color(255,255,255), msg)
end

--## BillysErrors ##--

if (file.Exists("includes/modules/billyserrors.lua", "LUA")) then
	require("billyserrors")
end
if (SERVER and BillysErrors) then
	OpenPermissions.BillysErrors = BillysErrors:AddAddon({
		Name  = "OpenPermissions",
		Color = Color(80,0,255),
		Icon  = "icon16/group.png",
	})
end

--## Initialize configs ##--
OpenPermissions.Operators = {}

local function InstallConfigAddon()
	if (SERVER and BillysErrors) then
		OpenPermissions.BillysErrors:AddMessage("Looks like the OpenPermissions Config Addon has not been installed to your server: ", {Link = "https://gmodsto.re/openpermissions-config-addon"}, "\nYou need to install this addon in order to use & configure OpenPermissions.")
	else
		OpenPermissions:Print("Looks like the OpenPermissions Config Addon has not been installed to your server: https://gmodsto.re/openpermissions-config-addon\nYou need to install this addon in order to use & configure OpenPermissions.", "[ERROR]", OpenPermissions.COLOR_RED)
	end
end

if (not file.Exists("openpermissions_config.lua", "LUA")) then
	return InstallConfigAddon()
else
	local config_worked = include("openpermissions_config.lua")
	if (not config_worked) then
		if (SERVER and BillysErrors) then
			OpenPermissions.BillysErrors:AddMessage("Your config file appears to have an error! Please fix the errors by looking above or by resetting to the default config.")
		else
			OpenPermissions:Print("Your config file appears to have an error! Please fix the errors by looking above or by resetting to the default config.", "[ERROR]", OpenPermissions.COLOR_RED)
		end
		return
	end
end

if (not file.Exists("openpermissions_lua_functions.lua", "LUA")) then
	return InstallConfigAddon()
else
	local config_worked = include("openpermissions_lua_functions.lua")
	if (not config_worked) then
		if (SERVER and BillysErrors) then
			OpenPermissions.BillysErrors:AddMessage("Your Lua functions file appears to have an error! Please fix the errors by looking above or by resetting to the default Lua functions config.")
		else
			OpenPermissions:Print("Your Lua functions file appears to have an error! Please fix the errors by looking above or by resetting to the default Lua functions config.", "[ERROR]", OpenPermissions.COLOR_RED)
		end
		return
	else
		OpenPermissions.LuaFunctions = config_worked
	end
end

--## Languages ##--

if (CLIENT) then
	function OpenPermissions.L(phrase)
		return OpenPermissions.LANG.Phrases[phrase] or OpenPermissions.LANG_ENGLISH.Phrases[phrase] or phrase
	end
	function OpenPermissions.Lf(phrase, ...)
		return (OpenPermissions.LANG.Phrases[phrase] or OpenPermissions.LANG_ENGLISH.Phrases[phrase] or phrase):format(...)
	end

	function OpenPermissions:LoadPhrasebook()
		if (not file.Exists("openpermissions_lang.txt", "DATA")) then
			file.Write("openpermissions_lang.txt", "english")
		end
		local selected_language = file.Read("openpermissions_lang.txt", "DATA")
		if (not selected_language or not file.Find("openpermissions/lang/" .. selected_language .. ".lua", "LUA")) then selected_language = "english" end
		OpenPermissions.LANG_ENGLISH = include("openpermissions/lang/english.lua")
		if (selected_language == "english" or not file.Exists("openpermissions/lang/" .. selected_language .. ".lua", "LUA")) then
			OpenPermissions.LANG = OpenPermissions.LANG_ENGLISH or {}
		else
			OpenPermissions.LANG = include("openpermissions/lang/" .. selected_language .. ".lua") or {}
		end
	end
	OpenPermissions:LoadPhrasebook()
else
	local fs = file.Find("openpermissions/lang/*.lua", "LUA")
	for _,f in ipairs(fs) do
		AddCSLuaFile("openpermissions/lang/" .. f)
	end
end

--## Enums and Data Structures ##--

OpenPermissions.ACCESS_GROUP = {}
OpenPermissions.ACCESS_GROUP.USERGROUP = 1
OpenPermissions.ACCESS_GROUP.STEAMID = 2
OpenPermissions.ACCESS_GROUP.TEAM = 3
OpenPermissions.ACCESS_GROUP.LUA_FUNCTION = 4
OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY = 5

OpenPermissions.ACCESS_GROUP_KEY = {
	[OpenPermissions.ACCESS_GROUP.USERGROUP] = Color(216,76,76),
	[OpenPermissions.ACCESS_GROUP.STEAMID] = Color(81,174,255),
	[OpenPermissions.ACCESS_GROUP.TEAM] = Color(76,216,76),
	[OpenPermissions.ACCESS_GROUP.LUA_FUNCTION] = Color(76,76,216),
	[OpenPermissions.ACCESS_GROUP.DARKRP_CATEGORY] = Color(255,163,71),
}

OpenPermissions.CHECKBOX = {}
OpenPermissions.CHECKBOX.INHERIT = 0
OpenPermissions.CHECKBOX.TICKED = 1
OpenPermissions.CHECKBOX.CROSSED = 2

--## Add resources ##--

if (SERVER) then
	resource.AddWorkshop("1603635147")
	for _,f in ipairs((file.Find("materials/openpermissions/*.vmt", "GAME"))) do
		resource.AddFile("materials/openpermissions/" .. f)
	end
end

local function IsDarkRPCheck()
	hook.Remove(SERVER and "PlayerConnect" or "InitPostEntity", "OpenPermissions.IsDarkRP")
	OpenPermissions.IsDarkRP = DarkRP and DarkRP.getCategories and RPExtraTeams and true
end
hook.Add(SERVER and "PlayerConnect" or "InitPostEntity", "OpenPermissions.IsDarkRP", IsDarkRPCheck)

--## Initialize files ##--
include("openpermissions/sh.lua")
if (SERVER) then
	AddCSLuaFile("openpermissions/thirdparty/pon.lua")
	AddCSLuaFile("openpermissions_config.lua")
	AddCSLuaFile("openpermissions_lua_functions.lua")
	AddCSLuaFile("openpermissions/sh.lua")
	AddCSLuaFile("openpermissions/cl.lua")

	include("openpermissions/sv.lua")
else
	include("openpermissions/cl.lua")
end
--addons/partysystem/lua/autorun/partychat.lua:
return gluapack()()
--addons/pcasino/lua/perfectcasino/derma/cl_config.lua:
return gluapack()()
--addons/pcasino/lua/perfectcasino/core/sh_cooldown.lua:
-- A cooldown lib I stole from my community's lib
PerfectCasino.Cooldown.Timers = PerfectCasino.Cooldown.Timers or {}

function PerfectCasino.Cooldown.Check(id, time, ply)
	if not id then return true end
	if not time then return true end

	if not PerfectCasino.Cooldown.Timers[id] then
		PerfectCasino.Cooldown.Timers[id] = {}
		PerfectCasino.Cooldown.Timers[id].global = 0
	end

	if ply then
		if not PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] then
			PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] = 0
		end

		if PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] > CurTime() then return true end

		PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] = CurTime() + time

		return false
	else
		if PerfectCasino.Cooldown.Timers[id].global > CurTime() then return true end

		PerfectCasino.Cooldown.Timers[id].global = CurTime() + time

		return false
	end
end

function PerfectCasino.Cooldown.Get(id, ply)
	if not id then return 0 end
	if not time then return 0 end

	if not PerfectCasino.Cooldown.Timers[id] then return 0 end

	-- The correct returns
	if ply and PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] then return PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] end
	if not ply and PerfectCasino.Cooldown.Timers[id].global then return PerfectCasino.Cooldown.Timers[id].global end

	-- Failsafe
	return 0
end


function PerfectCasino.Cooldown.Reset(id, ply)
	if not id then return end

	if not PerfectCasino.Cooldown.Timers[id] then return end

	if ply then
		if not PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] then return end
		PerfectCasino.Cooldown.Timers[id][ply:SteamID64()] = 0
	else
		PerfectCasino.Cooldown.Timers[id].global = 0
	end
end
--addons/pcasino/lua/perfectcasino/config/sh_config.lua:
return gluapack()()
--addons/[binbon]misc/lua/autorun/pd2_dallas.lua:
return gluapack()()
--lua/autorun/pd2_heavy_swat_zeal_player_npc.lua:
return gluapack()()
--addons/[binbon]misc/lua/autorun/pd2_hoxton.lua:
return gluapack()()
--addons/undertale/lua/psa_undertale/resources_00.lua:
return gluapack()()
--addons/tablo_ent/lua/scoresheet/sheets/timeplay/shared.lua:
return gluapack()()
--addons/realisticcardealer/lua/realistic_cardealer/sh_advanced_config.lua:
RCD = RCD or {}
RCD.BaseButton = RCD.BaseButton or {}
RCD.SettingsButton = RCD.SettingsButton or {}

--[[ Vehicle blacklisted ]]
RCD.VehicleBlacklisted = {
    ["Seat_Airboat"] = true,
    ["Chair_Office2"] = true,
    ["Chair_Plastic"] = true,
    ["Seat_Jeep"] = true,
    ["Chair_Office1"] = true,
    ["Chair_Wood"] = true,
    ["prop_vehicle_prisoner_pod"] = true,
}

--[[ All buttons on the main menu]]
RCD.BaseButton = {
    {
        ["name"] = "close",
        ["mat"] = RCD.Materials["icon_close"],
        ["func"] = function(panel)
            if not IsValid(panel) then return end
            
            panel:Remove()
        end,
    },
    {
        ["name"] = "paint",
        ["mat"] = RCD.Materials["icon_paint"],
        ["func"] = function(panel)
            if RCD.CountVehicleBought() <= 0 then RCD.Notification(5, RCD.GetSentence("noVehicles")) return end
            RCD.ReloadVehiclesList(true)
        end,
    },
    {
        ["name"] = "returnButton",
        ["mat"] = RCD.Materials["icon_leave"],
        ["func"] = function(panel)            
            net.Start("RCD:Main:Client")
                net.WriteUInt(6, 4)
            net.SendToServer()
        end,
    },
    {
        ["name"] = "car",
        ["mat"] = RCD.Materials["icon_car"],
        ["func"] = function(panel)
            RCD.ReloadVehiclesList(false)
        end,
    },
}

--[[ All sliders on the main menu ]]
RCD.SettingsSlider = {
    ["default"] = {
        {
            ["name"] = "maxSpeed",
            ["max"] = 300,
            ["func"] = function(tbl)
                return tbl["engine"] and tbl["engine"]["maxspeed"] or 0
            end,
        },
        {
            ["name"] = "horsePower",
            ["max"] = 800,
            ["func"] = function(tbl)
    
                return tbl["engine"] and tbl["engine"]["horsepower"] or 0
            end,
        },
        {
            ["name"] = "wheelsPerAxles",
            ["max"] = 8,
            ["func"] = function(tbl)
    
                return tbl["wheelsperaxle"] or 0
            end,
        },
    },
    ["simfphys"] = {
        {
            ["name"] = "brakePower",
            ["max"] = 300,
            ["func"] = function(tbl)
                tbl["Members"] = tbl["Members"] or {}

                return tbl["Members"]["PeakTorque"] or 0
            end,
        },
        {
            ["name"] = "turnSpeed",
            ["max"] = 80,
            ["func"] = function(tbl)
                tbl["Members"] = tbl["Members"] or {}

                return tbl["Members"]["TurnSpeed"] or 0
            end,
        },
        {
            ["name"] = "mass",
            ["max"] = 5000,
            ["func"] = function(tbl)
                tbl["Members"] = tbl["Members"] or {}

                return tbl["Members"]["Mass"] or 0
            end,
        },
    }
}

--[[ All compatibilities options ]]
RCD.CompatibilitiesOptions = {
    ["saveHealth"] = {
        ["type"] = "number",
        ["get"] = function(ent)
            local health = 100
            if not IsValid(ent) then return health end

            if not ent.IsSimfphyscar then
                if VC then
                    health = ent:VC_getHealth(true)
                elseif SVMOD && SVMOD:GetAddonState() then
                    health = ent:SV_GetHealth()
                end
            else
                health = ent:GetCurHealth()
            end

            return health
        end,
        ["set"] = function(ent, value)
            local health = (tonumber(value) or 100)
            if not IsValid(ent) then return health end
            
            if not isnumber(health) or health <= 10 then health = 100 end
            
            if not ent.IsSimfphyscar then
                if VC then
              --      local maxHealth = (ent:VC_getHealthMax() or 100)
            --        ent:VC_setHealth(maxHealth*((health or 100)/100))
                elseif SVMOD && SVMOD:GetAddonState() then
                    ent:SV_SetHealth()
                end
            else
                ent:SetCurHealth(health)
            end
        end,
    },
}

-- [[ A list of all list.Get(...) for vehicles ]]
RCD.VehiclesListNames = {
    "Vehicles",
    "simfphys_vehicles",
}

--[[ This is the default configuration ]]
RCD.DefaultSettings = RCD.DefaultSettings or {
    ["lang"] = "en",
    ["maxVehicles"] = 2,
    ["testTime"] = 60,
    ["distToReturn"] = 50000,
    ["activateNotification"] = true,
    ["adminCommand"] = "/rcd",
    ["engineKey"] = KEY_M,
    ["nitroKey"] = KEY_LSHIFT,
    ["nitroSpeed"] = 1,
    ["minSpeedNitro"] = 30,
    ["engineActivate"] = true,
    ["engineTime"] = 2,
    ["beltActivate"] = true,
    ["beltKey"] = KEY_G,
    ["underglowKey"] = KEY_F,
    ["beltWarningSound"] = true,
    ["unitChoose"] = "kmh",
    ["cantExitModule"] = true,
    ["exitKMH"] = 20,
    ["smallAccidentActivate"] = true,
    ["smallAccidentMinDamage"] = 20,
    ["ejectActivate"] = true,
    ["ejectMinDamage"] = 40,
    ["speedometerActivate"] = true,
    ["speedometerPosX"] = 0.89,
    ["speedometerPosY"] = 0.95,
    ["speedometerCount"] = 8,
    ["speedometerSpace"] = 2.5,
    ["useSimfphysSpeedometer"] = false,
    ["speedometerSize"] = 140,
    ["currency"] = "$",
    ["enterVehicle"] = true,
    ["generalPourcentSell"] = 50,
    ["carDealerJob"] = "Citizen",
    ["nitroDuration"] = 2,
    ["nitroCooldowns"] = 30,
}

--[[ All things used on accordion, and other stuff ]] 
RCD.ParametersConfig = {
    ["vehiclePosition"] = {
        { --Line on the accordion
            { -- Number of params on the line
                ["class"] = "RCD:Slider", -- Panel to create on the right
                ["text"] = "posX", -- Text on the left
                ["sizeX"] = 0.14, -- Size X of the right panel
                ["sizeY"] = 0.05, -- Size Y of the right panel
                ["posX"] = 0.115, -- Pos X of the right panel
                ["posY"] = 0, -- Pos Y of the right panel
                ["func"] = function(pnl, panelLink, editVehicle) -- Function when the accordion is initialize
                    if IsValid(panelLink) then
                        local ent = panelLink.Entity
                        if not IsValid(ent) then return end

                        pnl:SetMinMax(-200, 200)

                        RCD.vehicleConfig = RCD.vehicleConfig or {}
                        RCD.vehicleConfig["vector"] = panelLink:GetLookAt()

                        pnl.OnValueChanged = function(pnl, number)
                            RCD.vehicleConfig["vector"][1] = number
                            local pos = Vector(RCD.vehicleConfig["vector"])

                            panelLink:SetLookAt(pos)
                        end

                        pnl.RCDLerp = RCD.vehicleConfig["vector"]
                        pnl.Think = function()
                            pnl.RCDLerp = LerpVector(FrameTime()*5, pnl.RCDLerp, RCD.vehicleConfig["vector"])

                            panelLink:SetLookAt(pnl.RCDLerp)
                        end
                        
                        if editVehicle && editVehicle["options"] && isvector(editVehicle["options"]["vector"]) then
                            RCD.vehicleConfig["vector"] = editVehicle["options"]["vector"]

                            pnl:SetValue(editVehicle["options"]["vector"][1])
                        end
                    end 
                end, 
            },
            {
                ["class"] = "RCD:Slider",
                ["text"] = "angleX",
                ["sizeX"] = 0.14,
                ["sizeY"] = 0.05,
                ["posX"] = 0.115,
                ["posY"] = 0,
                ["func"] = function(pnl, panelLink, editVehicle)
                    if IsValid(panelLink) then
                        local ent = panelLink.Entity
                        if not IsValid(ent) then return end

                        pnl:SetMinMax(-180, 180)

                        RCD.vehicleConfig = RCD.vehicleConfig or {}
                        RCD.vehicleConfig["angle"] = ent:GetAngles()

                        pnl.OnValueChanged = function(pnl, number)
                            RCD.vehicleConfig["angle"][1] = number

                            ent:SetAngles(RCD.vehicleConfig["angle"])
                        end

                        pnl.RCDLerp = ent:GetAngles()
                        pnl.Think = function()
                            pnl.RCDLerp = LerpAngle(FrameTime()*5, pnl.RCDLerp, RCD.vehicleConfig["angle"])

                            ent:SetAngles(pnl.RCDLerp)
                        end

                        if editVehicle && editVehicle["options"] && isangle(editVehicle["options"]["angle"]) then
                            RCD.vehicleConfig["angle"] = editVehicle["options"]["angle"]

                            pnl:SetValue(editVehicle["options"]["angle"][1])
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:Slider",
                ["text"] = "posY",
                ["sizeX"] = 0.14,
                ["sizeY"] = 0.05,
                ["posX"] = 0.115,
                ["posY"] = 0,
                ["func"] = function(pnl, panelLink, editVehicle)
                    if IsValid(panelLink) then
                        pnl:SetMinMax(-200, 200)

                        pnl.OnValueChanged = function(pnl, number)
                            RCD.vehicleConfig["vector"][2] = number
                            local pos = Vector(RCD.vehicleConfig["vector"])

                            panelLink:SetLookAt(pos)
                        end

                        if editVehicle && editVehicle["options"] && isvector(editVehicle["options"]["vector"]) then
                            pnl:SetValue(editVehicle["options"]["vector"][2])
                        end
                    end
                end,
            },
            {
                ["class"] = "RCD:Slider",
                ["text"] = "AngleY",
                ["sizeX"] = 0.14,
                ["sizeY"] = 0.05,
                ["posX"] = 0.115,
                ["posY"] = 0,
                ["func"] = function(pnl, panelLink, editVehicle)
                    if IsValid(panelLink) then
                        local ent = panelLink.Entity
                        if not IsValid(ent) then return end

                        pnl:SetMinMax(-180, 180)

                        pnl.OnValueChanged = function(pnl, number)
                            RCD.vehicleConfig["angle"][2] = number
                            local ang = Angle(RCD.vehicleConfig["angle"])

                            ent:SetAngles(ang)
                        end

                        if editVehicle && editVehicle["options"] && isangle(editVehicle["options"]["angle"]) then
                            pnl:SetValue(editVehicle["options"]["angle"][2])
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:Slider",
                ["text"] = "posZ",
                ["sizeX"] = 0.14,
                ["sizeY"] = 0.05,
                ["posX"] = 0.115,
                ["posY"] = 0,
                ["func"] = function(pnl, panelLink, editVehicle)
                    if IsValid(panelLink) then
                        pnl:SetMinMax(-200, 200)

                        local oldPos = panelLink:GetLookAt()

                        pnl.OnValueChanged = function(pnl, number)
                            RCD.vehicleConfig["vector"][3] = number
                            local pos = Vector(RCD.vehicleConfig["vector"])

                            panelLink:SetLookAt(pos)
                        end

                        if editVehicle && editVehicle["options"] && isvector(editVehicle["options"]["vector"]) then
                            pnl:SetValue(editVehicle["options"]["vector"][3])
                        end
                    end
                end,
            },
            {
                ["class"] = "RCD:Slider",
                ["text"] = "angleZ",
                ["sizeX"] = 0.14,
                ["sizeY"] = 0.05,
                ["posX"] = 0.115,
                ["posY"] = 0,
                ["func"] = function(pnl, panelLink, editVehicle)
                    if IsValid(panelLink) then
                        local ent = panelLink.Entity
                        if not IsValid(ent) then return end

                        pnl:SetMinMax(-180, 180)

                        pnl.OnValueChanged = function(pnl, number)
                            RCD.vehicleConfig["angle"][3] = number
                            local ang = Angle(RCD.vehicleConfig["angle"])

                            ent:SetAngles(ang)
                        end

                        if editVehicle && editVehicle["options"] && isangle(editVehicle["options"]["angle"]) then
                            pnl:SetValue(editVehicle["options"]["angle"][3])
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:Slider",
                ["text"] = "fov",
                ["sizeX"] = 0.14,
                ["sizeY"] = 0.05,
                ["posX"] = 0.382,
                ["posY"] = 0,
                ["func"] = function(pnl, panelLink, editVehicle)
                    if IsValid(panelLink) then
                        local ent = panelLink.Entity
                        if not IsValid(ent) then return end

                        pnl:SetMinMax(-30, 30)
                        pnl:SetValue(0)

                        RCD.vehicleConfig["fov"] = 0
                        local oldFov = panelLink:GetFOV()

                        pnl.OnValueChanged = function(pnl, number)
                            RCD.vehicleConfig["fov"] = number
                            
                            panelLink:SetFOV(oldFov + RCD.vehicleConfig["fov"])
                        end

                        pnl.RCDLerp = RCD.vehicleConfig["fov"]
                        pnl.Think = function()
                            pnl.RCDLerp = Lerp(FrameTime()*5, pnl.RCDLerp, RCD.vehicleConfig["fov"])

                            panelLink:SetFOV(oldFov + pnl.RCDLerp)
                        end

                        if editVehicle && editVehicle["options"] && isnumber(editVehicle["options"]["fov"]) then
                            pnl:SetValue(editVehicle["options"]["fov"])
                        end
                    end
                end,
            },
        },
    },
    ["generalSettings"] = {
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "useCustomNotification",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    RCD.AdvancedConfiguration["settings"] = {}

                    pnl:SetActive(tobool(RCD.DefaultSettings["activateNotification"]))

                    pnl.OnChange = function(self, bChecked)
                        RCD.AdvancedConfiguration["settings"]["activateNotification"] = bChecked
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "enterIntoVehicle",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(tobool(RCD.DefaultSettings["enterVehicle"]))

                    pnl.OnChange = function(self, bChecked)
                        RCD.AdvancedConfiguration["settings"]["enterVehicle"] = bChecked
                    end
                end,
            },
        },
        {
            {
                ["class"] = "DButton",
                ["text"] = "playersManagement",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetTextColor(RCD.Colors["white100"])
                    pnl:SetFont("RCD:Font:13")
                    
                    pnl.Paint = function(self, w, h)
                        pnl:SetText(RCD.GetSentence("open"))
                        draw.RoundedBox(6, 0, 0, w, h, RCD.Colors["white5"])
                    end

                    pnl.DoClick = function()
                        if IsValid(settingsMenu) then settingsMenu:Remove() end
                        RCD.ManagePlayers()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:DComboBox",
                ["text"] = "language",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)

                    for k,v in pairs(RCD.Language) do
                        pnl:AddChoice(k)
                    end

                    pnl:ChooseOption(RCD.DefaultSettings["lang"])

                    pnl.OnSelect = function(self, index, text, data)
                        RCD.AdvancedConfiguration["settings"]["lang"] = text
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:DComboBox",
                ["text"] = "speedUnit",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)

                    for k,v in pairs(RCD.UnitConvertion) do
                        pnl:AddChoice(k)
                    end

                    pnl:ChooseOption(RCD.DefaultSettings["unitChoose"])

                    pnl.OnSelect = function(self, index, text, data)
                        RCD.AdvancedConfiguration["settings"]["unitChoose"] = text
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:DComboBox",
                ["text"] = "carDealerJobConfig",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)
                    pnl:SetText("Citizen")

                    for k,v in pairs(team.GetAllTeams()) do
                        pnl:AddChoice(v.Name)
                    end

                    pnl:ChooseOption(RCD.DefaultSettings["carDealerJob"])

                    pnl.OnSelect = function(self, index, text, data)
                        RCD.AdvancedConfiguration["settings"]["carDealerJob"] = text
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:DComboBox",
                ["text"] = "currency",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)

                    for k,v in pairs(RCD.Currencies) do
                        pnl:AddChoice(k)
                    end

                    pnl:ChooseOption(RCD.DefaultSettings["currency"])

                    pnl.OnSelect = function(self, index, text, data)
                        RCD.AdvancedConfiguration["settings"]["currency"] = text
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "adminCommand",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)

                    pnl:SetPlaceHolder(RCD.DefaultSettings["adminCommand"])

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["adminCommand"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "maxVehicle",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["maxVehicles"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["maxVehicles"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "testTime",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["testTime"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["testTime"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "distanceToReturn",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["distToReturn"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["distToReturn"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "pourcentSell",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["generalPourcentSell"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["generalPourcentSell"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "DBinder",
                ["text"] = "underglowKey",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetText("KEY_"..input.GetKeyName(RCD.DefaultSettings["underglowKey"]):upper())
                    pnl:SetFont("RCD:Font:13")

                    pnl.OnChange = function(self, key)
                        self:SetText("KEY_"..input.GetKeyName(key):upper())
                        RCD.AdvancedConfiguration["settings"]["underglowKey"] = key
                    end

                    pnl.Paint = function(self, w, h)
                        draw.RoundedBox(6, 0, 0, w, h, RCD.Colors["white5"])
                    end
                    pnl:SetTextColor(RCD.Colors["white100"])
                end,
            },
        },
    },
    ["nitroConfig"] = {
        {
            {
                ["class"] = "DBinder",
                ["text"] = "nitroKey",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetText("KEY_"..input.GetKeyName(RCD.DefaultSettings["nitroKey"]):upper())
                    pnl:SetFont("RCD:Font:13")
    
                    pnl.OnChange = function(self, key)
                        self:SetText("KEY_"..input.GetKeyName(key):upper())
                        RCD.AdvancedConfiguration["settings"]["nitroKey"] = key
                    end
    
                    pnl.Paint = function(self, w, h)
                        draw.RoundedBox(6, 0, 0, w, h, RCD.Colors["white5"])
                    end
                    pnl:SetTextColor(RCD.Colors["white100"])
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "nitroSpeed",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["nitroSpeed"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)
    
                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["nitroSpeed"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "minSpeedNitro",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["minSpeedNitro"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)
    
                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["minSpeedNitro"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "nitroDuration",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["nitroDuration"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)
    
                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["nitroDuration"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "nitroCooldowns",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["nitroCooldowns"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)
    
                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["nitroCooldowns"] = self:GetText()
                    end
                end,
            },
        },
    },
    ["beltConfig"] = {
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "activateBelt",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(tobool(RCD.DefaultSettings["beltActivate"]))

                    pnl.OnChange = function(self, bChecked)
                        RCD.AdvancedConfiguration["settings"]["beltActivate"] = bChecked
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "warningSound",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(tobool(RCD.DefaultSettings["beltWarningSound"]))

                    pnl.OnChange = function(self, bChecked)
                        RCD.AdvancedConfiguration["settings"]["beltWarningSound"] = bChecked
                    end
                end,
            },
        },
        {
            {
                ["class"] = "DBinder",
                ["text"] = "beltKey",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetText("KEY_"..input.GetKeyName(RCD.DefaultSettings["beltKey"]):upper())
                    pnl:SetFont("RCD:Font:13")

                    pnl.OnChange = function(self, key)
                        self:SetText("KEY_"..input.GetKeyName(key):upper())
                        RCD.AdvancedConfiguration["settings"]["beltKey"] = key
                    end

                    pnl.Paint = function(self, w, h)
                        draw.RoundedBox(6, 0, 0, w, h, RCD.Colors["white5"])
                    end
                    pnl:SetTextColor(RCD.Colors["white100"])
                end,
            },
        },
    },
    ["engineModule"] = {
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "activateEngine",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(tobool(RCD.DefaultSettings["engineActivate"]))

                    pnl.OnChange = function(self, bChecked)
                        RCD.AdvancedConfiguration["settings"]["engineActivate"] = bChecked
                    end
                end,
            },
        },
        {
            {
                ["class"] = "DBinder",
                ["text"] = "engineKey",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetText("KEY_"..input.GetKeyName(RCD.DefaultSettings["engineKey"]):upper())
                    pnl:SetFont("RCD:Font:13")

                    pnl.OnChange = function(self, key)
                        self:SetText("KEY_"..input.GetKeyName(key):upper())
                        RCD.AdvancedConfiguration["settings"]["engineKey"] = key
                    end

                    pnl.Paint = function(self, w, h)
                        draw.RoundedBox(6, 0, 0, w, h, RCD.Colors["white5"])
                    end
                    pnl:SetTextColor(RCD.Colors["white100"])
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "timeToLunchVehicle",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["engineTime"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["engineTime"] = self:GetText()
                    end
                end,
            },
        },
    },
    ["driveModule"] = {
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "cantLeaveVehicleInMotion",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(tobool(RCD.DefaultSettings["cantExitModule"]))

                    pnl.OnChange = function(self, bChecked)
                        RCD.AdvancedConfiguration["settings"]["cantExitModule"] = bChecked
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "activateSmallAccident",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(tobool(RCD.DefaultSettings["smallAccidentActivate"]))

                    pnl.OnChange = function(self, bChecked)
                        RCD.AdvancedConfiguration["settings"]["smallAccidentActivate"] = bChecked
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "activateEjectionAccident",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(tobool(RCD.DefaultSettings["ejectActivate"]))

                    pnl.OnChange = function(self, bChecked)
                        RCD.AdvancedConfiguration["settings"]["ejectActivate"] = bChecked
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "lowerSpeedToExit",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["exitKMH"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["exitKMH"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "minDamageSmallAccident",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["smallAccidentMinDamage"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["smallAccidentMinDamage"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "minDamageEjectionAccident",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["ejectMinDamage"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["ejectMinDamage"] = self:GetText()
                    end
                end,
            },
        },
    },
    ["speedometerModule"] = {
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "activateSpeedometer",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(tobool(RCD.DefaultSettings["speedometerActivate"]))

                    pnl.OnChange = function(self, bChecked)
                        RCD.AdvancedConfiguration["settings"]["speedometerActivate"] = bChecked
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "speedometerSize",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["speedometerSize"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["speedometerSize"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "posX",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.199,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(math.Round(RCD.DefaultSettings["speedometerPosX"], 2))
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["speedometerPosX"] = self:GetText()
                    end
                end,
            },
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "posY",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.199,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(math.Round(RCD.DefaultSettings["speedometerPosY"], 2))
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["speedometerPosY"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "count",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.199,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["speedometerCount"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["speedometerCount"] = self:GetText()
                    end
                end,
            },
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "space",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.199,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetPlaceHolder(RCD.DefaultSettings["speedometerSpace"])
                    pnl:SetRounded(6)
                    pnl:SetNumeric(true)

                    pnl.entry.OnChange = function(self)
                        RCD.AdvancedConfiguration["settings"]["speedometerSpace"] = self:GetText()
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "activateSimfphysSpeedometer",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(tobool(RCD.DefaultSettings["activateSimfphysSpeedometer"]))

                    pnl.OnChange = function(self, bChecked)
                        RCD.AdvancedConfiguration["settings"]["activateSimfphysSpeedometer"] = bChecked
                    end
                end,
            },
        },
    },
    ["vehicleSettings"] = {
        {
            {
                ["class"] = "RCD:DComboBox",
                ["text"] = "defaultSkin",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:Clear()
                    pnl:SetText(RCD.GetSentence("choose"))
                    pnl:SetRounded(6)

                    if IsValid(panelLink) then

                        local ent = panelLink.Entity
                        if not IsValid(ent) then return end

                        pnl:SetSortItems(false)
                        
                        for i=0, ent:SkinCount()-1 do
                            pnl:AddChoice(RCD.GetSentence("skin").." "..i, i)
                        end

                        pnl.OnSelect = function(panel, index, data)
                            local optionData = panel:GetOptionData(index)

                            RCD.vehicleConfig["skin"] = optionData
                            ent:SetSkin(optionData)
                        end

                        if editVehicle && editVehicle["options"] && isnumber(editVehicle["options"]["skin"]) then
                            RCD.vehicleConfig["skin"] = editVehicle["options"]["skin"]
                            ent:SetSkin(RCD.vehicleConfig["skin"])
                            pnl:SetText(RCD.GetSentence("skin").." "..RCD.vehicleConfig["skin"])
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "DButton",
                ["text"] = "defaultColor",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    RCD.vehicleConfig["defaultColor"] = RCD.Colors["white"]

                    if editVehicle && editVehicle["options"] && istable(editVehicle["options"]["defaultColor"]) then
                        RCD.vehicleConfig["defaultColor"] = editVehicle["options"]["defaultColor"]
                        panelLink:SetColor(RCD.vehicleConfig["defaultColor"])
                    end

                    pnl:SetText("")
                    pnl.Paint = function(self,w,h)
                        RCD.DrawCircle(w/2, h/2, h/2, 0, 360, RCD.vehicleConfig["defaultColor"])
                    end
                    pnl.DoClick = function()
                        local chooseColor = vgui.Create("DFrame")
                        chooseColor:SetSize(RCD.ScrW*0.2, RCD.ScrH*0.43)
                        chooseColor:SetDraggable(true)
                        chooseColor:MakePopup()
                        chooseColor:SetTitle("")
                        chooseColor:ShowCloseButton(false)
                        chooseColor:Center()
                        chooseColor.Paint = function(self,w,h)
                            RCD.DrawBlur(self, 4) 
                    
                            draw.RoundedBox(0,0,0,w,h,RCD.Colors["blackpurple"])
                            draw.RoundedBox(0,w/2-RCD.ScrW*0.192/2,h*0.02,RCD.ScrW*0.192, RCD.ScrH*0.062,RCD.Colors["white20"])
                            
                            draw.DrawText(RCD.GetSentence("chooseColor"), "RCD:Font:10", w*0.05, h*0.02, RCD.Colors["white"], TEXT_ALIGN_LEFT)
                            draw.DrawText(RCD.GetSentence("configureDefaultColor"), "RCD:Font:11", w*0.05, h*0.09, RCD.Colors["white100"], TEXT_ALIGN_LEFT)
                        end

                        local defaultColor = vgui.Create("RCD:ColorPicker", chooseColor)
                        defaultColor:SetSize(RCD.ScrW*0.192, RCD.ScrH*0.33)
                        defaultColor:Dock(TOP)
                        defaultColor:DockMargin(RCD.ScrW*0.003, RCD.ScrH*0.04, RCD.ScrW*0.003, 0)

                        defaultColor.colorCube.OnUserChanged = function(pnl)
                            local color = pnl:GetRGB()
                            panelLink:SetColor(color)

                            RCD.vehicleConfig["defaultColor"] = Color(color.r, color.g, color.b, color.a)
                        end

                        local choose = vgui.Create("RCD:SlideButton", chooseColor)
                        choose:SetSize(RCD.ScrW*0.192, RCD.ScrH*0.041)
                        choose:SetPos(RCD.ScrW*0.005, RCD.ScrH*0.38)
                        choose:SetText(RCD.GetSentence("setDefaultColor"))
                        choose:SetFont("RCD:Font:12")
                        choose:SetTextColor(RCD.Colors["white"])
                        choose:InclineButton(0)
                        choose.MinMaxLerp = {100, 200}
                        choose:SetIconMaterial(nil)
                        choose:SetButtonColor(RCD.Colors["purple"])
                        choose.DoClick = function()
                            RCD.vehicleConfig["defaultColor"] = defaultColor:GetColor()

                            panelLink:SetColor(RCD.vehicleConfig["defaultColor"])
                            chooseColor:Remove()
                        end

                        local closeLerp = 50
                        local close = vgui.Create("DButton", chooseColor)
                        close:SetSize(RCD.ScrH*0.026, RCD.ScrH*0.026)
                        close:SetPos(RCD.ScrW*0.175, RCD.ScrH*0.028)
                        close:SetText("")
                        close.Paint = function(self,w,h)
                            closeLerp = Lerp(FrameTime()*5, closeLerp, (close:IsHovered() and 50 or 100))
                    
                            surface.SetDrawColor(ColorAlpha(RCD.Colors["white100"], closeLerp))
                            surface.SetMaterial(RCD.Materials["icon_close"])
                            surface.DrawTexturedRect(0, 0, w, h)
                        end
                        close.DoClick = function()
                            chooseColor:Remove()
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "canModifyBodygroup",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(true)
                    RCD.vehicleConfig["canChangeBodygroup"] = true

                    pnl.OnChange = function()
                        RCD.vehicleConfig["canChangeBodygroup"] = pnl:GetActive()
                    end

                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["canChangeBodygroup"]) then
                        RCD.vehicleConfig["canChangeBodygroup"] = editVehicle["options"]["canChangeBodygroup"]

                        pnl:SetActive(RCD.vehicleConfig["canChangeBodygroup"])
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "canModifySkin",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(true)
                    RCD.vehicleConfig["canChangeSkin"] = true

                    pnl.OnChange = function()
                        RCD.vehicleConfig["canChangeSkin"] = pnl:GetActive()
                    end

                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["canChangeSkin"]) then
                        RCD.vehicleConfig["canChangeSkin"] = editVehicle["options"]["canChangeSkin"]

                        pnl:SetActive(RCD.vehicleConfig["canChangeSkin"])
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "canModifyColor",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(true)
                    RCD.vehicleConfig["canChangeColor"] = true

                    pnl.OnChange = function()
                        RCD.vehicleConfig["canChangeColor"] = pnl:GetActive()
                    end

                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["canChangeColor"]) then
                        RCD.vehicleConfig["canChangeColor"] = editVehicle["options"]["canChangeColor"]

                        pnl:SetActive(RCD.vehicleConfig["canChangeColor"])
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "canModifyUngerglow",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(true)
                    RCD.vehicleConfig["canChangeUngerglow"] = true

                    pnl.OnChange = function()
                        RCD.vehicleConfig["canChangeUngerglow"] = pnl:GetActive()
                    end

                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["canChangeUngerglow"]) then
                        RCD.vehicleConfig["canChangeUngerglow"] = editVehicle["options"]["canChangeUngerglow"]

                        pnl:SetActive(RCD.vehicleConfig["canChangeUngerglow"])
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "canTestVehicle",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(true)
                    RCD.vehicleConfig["canTestVehicle"] = true

                    pnl.OnChange = function()
                        RCD.vehicleConfig["canTestVehicle"] = pnl:GetActive()
                    end

                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["canTestVehicle"]) then
                        RCD.vehicleConfig["canTestVehicle"] = editVehicle["options"]["canTestVehicle"]

                        pnl:SetActive(RCD.vehicleConfig["canTestVehicle"])
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "canBuyNitro",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl.OnChange = function()
                        RCD.vehicleConfig["canBuyNitro"] = pnl:GetActive()
                    end

                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["canBuyNitro"]) then
                        RCD.vehicleConfig["canBuyNitro"] = editVehicle["options"]["canBuyNitro"]

                        pnl:SetActive(RCD.vehicleConfig["canBuyNitro"])
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "cantSellSetting",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl.OnChange = function()
                        RCD.vehicleConfig["cantSell"] = pnl:GetActive()
                    end

                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["cantSell"]) then
                        RCD.vehicleConfig["cantSell"] = editVehicle["options"]["cantSell"]

                        pnl:SetActive(RCD.vehicleConfig["cantSell"])
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "boatSettingText",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl.OnChange = function()
                        RCD.vehicleConfig["isBoat"] = pnl:GetActive()
                    end

                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["isBoat"]) then
                        RCD.vehicleConfig["isBoat"] = editVehicle["options"]["isBoat"]

                        pnl:SetActive(RCD.vehicleConfig["isBoat"])
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "disableBeltVehicle",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl.OnChange = function()
                        RCD.vehicleConfig["disableBeltVehicle"] = pnl:GetActive()
                    end

                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["disableBeltVehicle"]) then
                        RCD.vehicleConfig["disableBeltVehicle"] = editVehicle["options"]["disableBeltVehicle"]

                        pnl:SetActive(RCD.vehicleConfig["disableBeltVehicle"])
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "disableEngineVehicle",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl.OnChange = function()
                        RCD.vehicleConfig["disableEngineVehicle"] = pnl:GetActive()
                    end

                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["disableEngineVehicle"]) then
                        RCD.vehicleConfig["disableEngineVehicle"] = editVehicle["options"]["disableEngineVehicle"]

                        pnl:SetActive(RCD.vehicleConfig["disableEngineVehicle"])
                    end
                end,
            },
        },
    },
    ["cardealerVehicles"] = {
        {
            {
                ["class"] = "RCD:CheckBox",
                ["text"] = "canSellWithJob",
                ["sizeX"] = 0.02,
                ["sizeY"] = 0.02,
                ["posX"] = 0.51,
                ["posY"] = 0.015,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetActive(false)
                    RCD.vehicleConfig["canSellWithJob"] = false
    
                    pnl.OnChange = function()
                        RCD.vehicleConfig["canSellWithJob"] = pnl:GetActive()
                    end
    
                    if editVehicle && editVehicle["options"] && isbool(editVehicle["options"]["canSellWithJob"]) then
                        RCD.vehicleConfig["canSellWithJob"] = editVehicle["options"]["canSellWithJob"]
    
                        pnl:SetActive(RCD.vehicleConfig["canSellWithJob"])
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "cardealerJobDiscount",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.468,
                ["posY"] = 0.012,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)
                    pnl:SetPlaceHolder("80")
                    pnl:SetNumeric(true)

                    RCD.vehicleConfig["cardealerJobDiscount"] = 80

                    pnl.entry.OnChange = function()
                        RCD.vehicleConfig["cardealerJobDiscount"] = pnl:GetText()
                    end

                    if editVehicle && editVehicle["options"] then
                        local price = tonumber(editVehicle["options"]["cardealerJobDiscount"])

                        if isnumber(price) then
                            RCD.vehicleConfig["cardealerJobDiscount"] = price

                            pnl:SetText(RCD.vehicleConfig["cardealerJobDiscount"])
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "rentPrice",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.468,
                ["posY"] = 0.012,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)
                    pnl:SetPlaceHolder("10000")
                    pnl:SetNumeric(true)

                    RCD.vehicleConfig["rentPrice"] = 10000

                    pnl.entry.OnChange = function()
                        RCD.vehicleConfig["rentPrice"] = pnl:GetText()
                    end

                    if editVehicle && editVehicle["options"] then
                        local price = tonumber(editVehicle["options"]["rentPrice"])

                        if isnumber(price) then
                            RCD.vehicleConfig["rentPrice"] = price

                            pnl:SetText(RCD.vehicleConfig["rentPrice"])
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "minCommissionPrice",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.2,
                ["posY"] = 0.012,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)
                    pnl:SetPlaceHolder("0")
                    pnl:SetNumeric(true)

                    RCD.vehicleConfig["minCommissionPrice"] = 0

                    pnl.entry.OnChange = function()
                        RCD.vehicleConfig["minCommissionPrice"] = pnl:GetText()
                    end

                    if editVehicle && editVehicle["options"] then
                        local price = tonumber(editVehicle["options"]["minCommissionPrice"])

                        if isnumber(price) then
                            RCD.vehicleConfig["minCommissionPrice"] = price

                            pnl:SetText(RCD.vehicleConfig["minCommissionPrice"])
                        end
                    end
                end,
            },
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "maxCommissionPrice",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.2,
                ["posY"] = 0.012,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)
                    pnl:SetPlaceHolder("1000")
                    pnl:SetNumeric(true)

                    RCD.vehicleConfig["maxCommissionPrice"] = 1000

                    pnl.entry.OnChange = function()
                        RCD.vehicleConfig["maxCommissionPrice"] = pnl:GetText()
                    end

                    if editVehicle && editVehicle["options"] then
                        local price = tonumber(editVehicle["options"]["maxCommissionPrice"])

                        if isnumber(price) then
                            RCD.vehicleConfig["maxCommissionPrice"] = price

                            pnl:SetText(RCD.vehicleConfig["maxCommissionPrice"])
                        end
                    end
                end,
            },
        },
    },
    ["customizationColors"] = {
        {
            {
                ["class"] = "RCD:ColorPicker",
                ["text"] = "",
                ["sizeX"] = 0.14,
                ["sizeY"] = 0.3,
                ["posX"] = 0,
                ["posY"] = 0.005,
                ["sizeYPanel"] = 0.328,
                ["disableBackgroundColor"] = true,
                ["func"] = function(pnl, vehicleModel, editVehicle, self)
                    RCD.customization = {}
                    RCD.ClientTable["priceCustomization"] = 0

                    pnl.colorCube.OnUserChanged = function(pnl)
                        local color = pnl:GetRGB()

                        vehicleModel.Vehicles[RCD.ClientTable["vehicleId"]].RCDColor = color
                        RCD.customization["vehicleColor"] = color

                        local oldCustomization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]
                        oldCustomization = oldCustomization["customization"] or {}
                        
                        local price = RCD.GetPriceCustomization(RCD.ClientTable["vehicleSelected"]["options"], oldCustomization, RCD.customization)
                        RCD.ClientTable["priceCustomization"] = price
                    end

                    local reset = vgui.Create("RCD:Button", self)
                    reset:SetSize(RCD.ScrW*0.142, RCD.ScrW*0.016)
                    reset:SetPos(RCD.ScrW*0.003, RCD.ScrH*0.335)
                    reset:SetIconMaterial(nil)
                    reset:SetValue(RCD.GetSentence("reset"))
                    reset:SetHoveredColor(RCD.Colors["white80"])
                    reset:SetBackgroundColor(RCD.Colors["purple"])
                    reset:SetTextAlignement(TEXT_ALIGN_CENTER)
                    reset.RCDMinMaxLerp = {60, 120}
                    reset.DoClick = function()
                        local oldCustomization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]
                        oldCustomization = oldCustomization["customization"] or {}

                        pnl:SetColor(oldCustomization["vehicleColor"])
                        RCD.customization["vehicleColor"] = oldCustomization["vehicleColor"]

                        local price = RCD.GetPriceCustomization(RCD.ClientTable["vehicleSelected"]["options"], oldCustomization, RCD.customization)
                        RCD.ClientTable["priceCustomization"] = price
                    end

                    if istable(RCD.ClientTable["vehiclesBought"]) && istable(RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]) then
                        local customization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]["customization"] or {}
                        if not istable(customization["vehicleColor"]) then return end

                        pnl:SetColor(customization["vehicleColor"])
                        RCD.customization["vehicleColor"] = customization["vehicleColor"]
                    end
                end,
            },
        }, 
    },
    ["customizationNitro"] = {
        {
            {
                ["class"] = "DPanel",
                ["text"] = "",
                ["sizeX"] = 0.145,
                ["sizeY"] = 0.3,
                ["posX"] = 0,
                ["posY"] = 0.0015,
                ["sizeYPanel"] = 0.3,
                ["disableBackgroundColor"] = true,
                ["func"] = function(pnl, vehicleModel, editVehicle, accordion)
                    local scrollPanel = vgui.Create("RCD:DScroll", pnl)
                    scrollPanel:SetSize(RCD.ScrH*0.0195, RCD.ScrH*0.2)
                    scrollPanel:SetPos(0, RCD.ScrH*0.003)
                    scrollPanel:GetVBar():SetWide(0)
                    
                    local sizeY = 0

                    local options = RCD.ClientTable["vehicleSelected"]["options"] or {}

                    for i=1, 3 do
                        local nitroButton = vgui.Create("RCD:SlideButton", scrollPanel)
                        nitroButton:SetSize(RCD.ScrH*0.0195, RCD.ScrH*0.025)
                        nitroButton:SetText("")
                        nitroButton.MinMaxLerp = {100, 255}
                        nitroButton:SetIconMaterial(nil)
                        nitroButton:Dock(TOP)
                        nitroButton:DockMargin(0,0,0,2)
                        nitroButton:SetButtonColor(RCD.Colors["purple"])
                        nitroButton.PaintOver = function(self,w,h)
                            nitroButton.MinMaxLerp[2] = (RCD.customization["vehicleNitro"] == i) and 100 or 255

                            draw.SimpleText("Level "..i, "RCD:Font:21", w*0.05, h/2, RCD.Colors["white"], TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
                            draw.SimpleText(RCD.formatMoney((options["priceNitro"] or 0)*i), "RCD:Font:21", w*0.95, h/2, RCD.Colors["white100"], TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
                        end
                        nitroButton.DoClick = function()
                            local oldCustomization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]
                            oldCustomization = oldCustomization["customization"] or {}

                            if (RCD.customization["vehicleNitro"] == i) then
                                RCD.customization["vehicleNitro"] = nil
                            else
                                RCD.customization["vehicleNitro"] = i
                            end
                            
                            local price = RCD.GetPriceCustomization(RCD.ClientTable["vehicleSelected"]["options"], oldCustomization, RCD.customization)
                            RCD.ClientTable["priceCustomization"] = price
                        end

                        sizeY = sizeY + nitroButton:GetTall() + RCD.ScrH*0.005
                    end

                    scrollPanel:SetSize(RCD.ScrW*0.142, sizeY)
                    accordion:SetSizeY(sizeY+RCD.ScrH*0.005, true, true)
                    
                    pnl.Paint = function() end

                    if istable(RCD.ClientTable["vehiclesBought"]) && istable(RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]) then
                        local customization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]["customization"] or {}
                        if not istable(customization["vehicleColor"]) then return end

                        RCD.customization["vehicleNitro"] = customization["vehicleNitro"]
                    end
                end,
            },
        },
    },
    ["customizationNeon"] = {
        {
            {
                ["class"] = "RCD:ColorPicker",
                ["text"] = "",
                ["sizeX"] = 0.14,
                ["sizeY"] = 0.3,
                ["posX"] = 0,
                ["posY"] = 0.005,
                ["sizeYPanel"] = 0.328,
                ["disableBackgroundColor"] = true,
                ["func"] = function(pnl, panelLink, editVehicle, self)
                    RCD.customization = RCD.customization or {}

                    pnl.colorCube.OnUserChanged = function(pnl)
                        local color = pnl:GetRGB()

                        RCD.customization["vehicleUnderglow"] = color

                        local oldCustomization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]
                        oldCustomization = oldCustomization["customization"] or {}
                        
                        local price = RCD.GetPriceCustomization(RCD.ClientTable["vehicleSelected"]["options"], oldCustomization, RCD.customization)
                        RCD.ClientTable["priceCustomization"] = price
                    end

                    local reset = vgui.Create("RCD:Button", self)
                    reset:SetSize(RCD.ScrW*0.142, RCD.ScrW*0.016)
                    reset:SetPos(RCD.ScrW*0.003, RCD.ScrH*0.335)
                    reset:SetIconMaterial(nil)
                    reset:SetValue(RCD.GetSentence("reset"))
                    reset:SetHoveredColor(RCD.Colors["white80"])
                    reset:SetBackgroundColor(RCD.Colors["purple"])
                    reset:SetTextAlignement(TEXT_ALIGN_CENTER)
                    reset.RCDMinMaxLerp = {60, 120}
                    reset.DoClick = function()
                        local oldCustomization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]
                        oldCustomization = oldCustomization["customization"] or {}

                        pnl:SetColor(oldCustomization["vehicleUnderglow"])
                        RCD.customization["vehicleUnderglow"] = oldCustomization["vehicleUnderglow"]

                        local price = RCD.GetPriceCustomization(RCD.ClientTable["vehicleSelected"]["options"], oldCustomization, RCD.customization)
                        RCD.ClientTable["priceCustomization"] = price
                    end

                    if istable(RCD.ClientTable["vehiclesBought"]) && istable(RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]) then
                        local customization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]["customization"] or {}
                        if not istable(customization["vehicleUnderglow"]) then return end
                        
                        pnl:SetColor(customization["vehicleUnderglow"])
                        RCD.customization["vehicleUnderglow"] = customization["vehicleUnderglow"]
                    end
                end,
            },
        },
    },
    ["customizationSkin"] = {
        {
            {
                ["class"] = "DPanel",
                ["text"] = "",
                ["sizeX"] = 0.145,
                ["sizeY"] = 0.3,
                ["posX"] = 0,
                ["posY"] = 0.0015,
                ["sizeYPanel"] = 0,
                ["disableBackgroundColor"] = true,
                ["func"] = function(pnl, vehicleModel, editVehicle, accordion)
                    local ent = vehicleModel.Vehicles[RCD.ClientTable["vehicleId"]]
                    if not IsValid(ent) then accordion:Remove() end

                    local skinCount = ent:SkinCount()-1
                    if skinCount <= 0 then accordion:Remove() end

                    local dIconLayout = vgui.Create("DIconLayout", pnl)
                    dIconLayout:SetSpaceX(RCD.ScrW*0.002)
                    dIconLayout:SetSpaceY(RCD.ScrH*0.005)
                
                    local sizeY, y = 0, 0                    
                    for i=0, skinCount do
                        local skinButton = vgui.Create("RCD:SlideButton", dIconLayout)
                        skinButton:SetSize(RCD.ScrH*0.0195, RCD.ScrH*0.0195)
                        skinButton:SetText("")
                        skinButton.MinMaxLerp = {100, 255}
                        skinButton:SetIconMaterial(nil)
                        skinButton:SetButtonColor(RCD.Colors["purple"])
                        skinButton.PaintOver = function(self,w,h)
                            skinButton.MinMaxLerp[2] = (RCD.customization["vehicleSkin"] == i) and 100 or 255

                            draw.SimpleText(i, "RCD:Font:21", w/2, h/2, RCD.Colors["white100"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                        end
                        skinButton.DoClick = function()
                            ent:SetSkin(i)

                            RCD.customization["vehicleSkin"] = i

                            local oldCustomization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]
                            oldCustomization = oldCustomization["customization"] or {}
                            
                            local price = RCD.GetPriceCustomization(RCD.ClientTable["vehicleSelected"]["options"], oldCustomization, RCD.customization)
                            RCD.ClientTable["priceCustomization"] = price
                        end

                        if (i)%11 == 1 then
                            sizeY = sizeY + skinButton:GetTall() + RCD.ScrH*0.005
                        end
                    end

                    dIconLayout:SetSize(RCD.ScrW*0.142, sizeY)
                    accordion:SetSizeY(sizeY+RCD.ScrH*0.005, true, true)

                    pnl.Paint = function() end

                    local options = RCD.ClientTable["vehicleSelected"]["options"]

                    local customization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]["customization"] or {}
                    if istable(RCD.ClientTable["vehiclesBought"]) && istable(RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]) && isnumber(customization["vehicleSkin"]) then

                        RCD.customization["vehicleSkin"] = customization["vehicleSkin"] or 0
                    else
                        RCD.customization["vehicleSkin"] = (options["skin"] or 0)
                    end
                end,
            },
        }, 
    },
    ["customizationBodygroups"] = {
        {
            {
                ["class"] = "DPanel",
                ["text"] = "",
                ["sizeX"] = 0.145,
                ["sizeY"] = 0.8,
                ["posX"] = 0,
                ["posY"] = 0.0015,
                ["sizeYPanel"] = 0,
                ["disableBackgroundColor"] = true,
                ["func"] = function(pnl, vehicleModel, editVehicle, accordion)
                    local ent = vehicleModel.Vehicles[RCD.ClientTable["vehicleId"]]
                    if not IsValid(ent) then accordion:Remove() end

                    local bodygroups = ent:GetBodyGroups()
                    if #bodygroups <= 1 then accordion:Remove() end

                    local scrollPanel = vgui.Create("RCD:DScroll", pnl)

                    local sizeY, count = 0, 0
                    for k,v in ipairs(bodygroups) do
                        if v.num <= 1 then continue end
                        if v.name == "" then continue end

                        local dLabel = vgui.Create("DLabel", scrollPanel)
                        dLabel:SetText(v.name:gsub("^%l", string.upper))
                        dLabel:SetFont("RCD:Font:21")
                        dLabel:Dock(TOP)

                        local dIconLayout = vgui.Create("DIconLayout", scrollPanel)
                        dIconLayout:SetSpaceX(RCD.ScrW*0.002)
                        dIconLayout:SetSpaceY(RCD.ScrH*0.005)
                        dIconLayout:Dock(TOP)
                        
                        for i=0, v.num-1 do
                            local bodygroupButton = vgui.Create("RCD:SlideButton", dIconLayout)
                            bodygroupButton:SetSize(RCD.ScrH*0.0195, RCD.ScrH*0.0195)
                            bodygroupButton:SetText("")
                            bodygroupButton.MinMaxLerp = {100, 255}
                            bodygroupButton:SetIconMaterial(nil)
                            bodygroupButton:SetButtonColor(RCD.Colors["purple"])
                            bodygroupButton.DoClick = function()
                                ent:SetBodygroup(v.id, i)
                                
                                RCD.customization["vehicleBodygroups"] = RCD.customization["vehicleBodygroups"] or {}
                                RCD.customization["vehicleBodygroups"][v.id] = i
                                
                                local oldCustomization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]
                                oldCustomization = oldCustomization["customization"] or {}
                                
                                local price = RCD.GetPriceCustomization(RCD.ClientTable["vehicleSelected"]["options"], oldCustomization, RCD.customization)
                                RCD.ClientTable["priceCustomization"] = price
                            end
                            bodygroupButton.PaintOver = function(self,w,h)
                                RCD.customization["vehicleBodygroups"] = RCD.customization["vehicleBodygroups"] or {}
                                draw.SimpleText(i, "RCD:Font:21", w/2, h/2, RCD.Colors["white100"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                                
                                bodygroupButton.MinMaxLerp[2] = (RCD.customization["vehicleBodygroups"][v.id] == i) and 100 or 255
                            end
                        end

                        local y = math.ceil(v.num/11)
                        sizeY = sizeY + y*RCD.ScrH*0.0195 + (y-1)*dIconLayout:GetSpaceY() + dLabel:GetTall()

                        count = count + 1
                    end

                    if istable(RCD.ClientTable["vehiclesBought"]) && istable(RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]) then
                        local customization = RCD.ClientTable["vehiclesBought"][RCD.ClientTable["vehicleId"]]["customization"] or {}

                        RCD.customization["vehicleBodygroups"] = customization["vehicleBodygroups"]
                    end

                    if count <= 0 then accordion:Remove() end
                    scrollPanel:SetSize(RCD.ScrW*0.142, sizeY)
                    accordion:SetSizeY(sizeY, true)

                    pnl.Paint = function() end
                end,
            },
        }, 
    },
    ["priceSettings"] = {
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "priceToChangeBodygroups",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.468,
                ["posY"] = 0.012,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)
                    pnl:SetPlaceHolder("500")
                    pnl:SetNumeric(true)

                    RCD.vehicleConfig["priceBodygroup"] = 500

                    pnl.entry.OnChange = function()
                        RCD.vehicleConfig["priceBodygroup"] = pnl:GetText()
                    end

                    if editVehicle && editVehicle["options"] then
                        local price = tonumber(editVehicle["options"]["priceBodygroup"])

                        if isnumber(price) then
                            RCD.vehicleConfig["priceBodygroup"] = price

                            pnl:SetText(RCD.vehicleConfig["priceBodygroup"])
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "priceToChangeSkins",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.468,
                ["posY"] = 0.012,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)
                    pnl:SetPlaceHolder("1000")
                    pnl:SetNumeric(true)

                    RCD.vehicleConfig["priceSkin"] = 1000

                    pnl.entry.OnChange = function()
                        RCD.vehicleConfig["priceSkin"] = pnl:GetText()
                    end

                    if editVehicle && editVehicle["options"] then
                        local price = tonumber(editVehicle["options"]["priceSkin"])

                        if isnumber(price) then
                            RCD.vehicleConfig["priceSkin"] = price

                            pnl:SetText(RCD.vehicleConfig["priceSkin"])
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "priceToChangeColors",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.468,
                ["posY"] = 0.012,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)
                    pnl:SetPlaceHolder("500")
                    pnl:SetNumeric(true)

                    RCD.vehicleConfig["priceColor"] = 500

                    pnl.entry.OnChange = function()
                        RCD.vehicleConfig["priceColor"] = pnl:GetText()
                    end

                    if editVehicle && editVehicle["options"] then
                        local price = tonumber(editVehicle["options"]["priceColor"])

                        if isnumber(price) then
                            RCD.vehicleConfig["priceColor"] = price

                            pnl:SetText(RCD.vehicleConfig["priceColor"])
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "priceToChangeUnderglow",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.468,
                ["posY"] = 0.012,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)
                    pnl:SetPlaceHolder("2000")
                    pnl:SetNumeric(true)

                    RCD.vehicleConfig["priceUnderglow"] = 2000

                    pnl.entry.OnChange = function()
                        RCD.vehicleConfig["priceUnderglow"] = pnl:GetText()
                    end

                    if editVehicle && editVehicle["options"] then
                        local price = tonumber(editVehicle["options"]["priceUnderglow"])

                        if isnumber(price) then
                            RCD.vehicleConfig["priceUnderglow"] = price

                            pnl:SetText(RCD.vehicleConfig["priceUnderglow"])
                        end
                    end
                end,
            },
        },
        {
            {
                ["class"] = "RCD:TextEntry",
                ["text"] = "priceToBuyNitro",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.468,
                ["posY"] = 0.012,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetRounded(6)
                    pnl:SetPlaceHolder("2000")
                    pnl:SetNumeric(true)

                    RCD.vehicleConfig["priceNitro"] = 2000

                    pnl.entry.OnChange = function()
                        RCD.vehicleConfig["priceNitro"] = pnl:GetText()
                    end

                    if editVehicle && editVehicle["options"] then
                        local price = tonumber(editVehicle["options"]["priceNitro"])

                        if isnumber(price) then
                            RCD.vehicleConfig["priceNitro"] = price

                            pnl:SetText(RCD.vehicleConfig["priceNitro"])
                        end
                    end
                end,
            },
        },
    }
}

function RCD.AddToConfigCompatibilities()
    local compatibilitesTable = {}
    
    if WCD then
        compatibilitesTable[#compatibilitesTable + 1] = {
            {
                ["class"] = "DButton",
                ["text"] = "wcdTransfert",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetTextColor(RCD.Colors["white100"])
                    pnl:SetFont("RCD:Font:13")
                    
                    pnl.Paint = function(self, w, h)
                        pnl:SetText(RCD.GetSentence("import"))
                        draw.RoundedBox(6, 0, 0, w, h, RCD.Colors["white5"])
                    end
                    
                    pnl.DoClick = function()
                        RunConsoleCommand("rcd_transfert_wcd")
                    end
                end,
            },
        }
    end

    if VC then
        compatibilitesTable[#compatibilitesTable + 1] = {
            {
                ["class"] = "DButton",
                ["text"] = "vcmodTransfert",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetTextColor(RCD.Colors["white100"])
                    pnl:SetFont("RCD:Font:13")
                    
                    pnl.Paint = function(self, w, h)
                        pnl:SetText(RCD.GetSentence("import"))
                        draw.RoundedBox(6, 0, 0, w, h, RCD.Colors["white5"])
                    end

                    pnl.DoClick = function()
                        RunConsoleCommand("rcd_transfert_vcmod")
                    end
                end,
            },
        }
    end

    if AdvCarDealer then
        compatibilitesTable[#compatibilitesTable + 1] = {
            {
                ["class"] = "DButton",
                ["text"] = "advancedTransfert",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetTextColor(RCD.Colors["white100"])
                    pnl:SetFont("RCD:Font:13")
                    
                    pnl.Paint = function(self, w, h)
                        pnl:SetText(RCD.GetSentence("import"))
                        draw.RoundedBox(6, 0, 0, w, h, RCD.Colors["white5"])
                    end

                    pnl.DoClick = function()
                        RunConsoleCommand("rcd_transfert_advanced")
                    end
                end,
            },
        }
    end

    if ModernCarDealer then
        compatibilitesTable[#compatibilitesTable + 1] = {
            {
                ["class"] = "DButton",
                ["text"] = "modernTransfert",
                ["sizeX"] = 0.06,
                ["sizeY"] = 0.03,
                ["posX"] = 0.466,
                ["posY"] = 0.01,
                ["func"] = function(pnl, panelLink, editVehicle)
                    pnl:SetTextColor(RCD.Colors["white100"])
                    pnl:SetFont("RCD:Font:13")
                    
                    pnl.Paint = function(self, w, h)
                        pnl:SetText(RCD.GetSentence("import"))
                        draw.RoundedBox(6, 0, 0, w, h, RCD.Colors["white5"])
                    end

                    pnl.DoClick = function()
                        RunConsoleCommand("rcd_transfert_modern")
                    end
                end,
            },
        }
    end

    RCD.ParametersConfig["compatibilities"] = compatibilitesTable
end

timer.Simple(1, function()
    RCD.AddToConfigCompatibilities()
end)

--[[ All tables used on the admin menu ]]
RCD.AdvancedConfiguration = RCD.AdvancedConfiguration or {
    ["groupsList"] = {},
    ["vehiclesList"] = {},
    ["plateforms"] = {},
    ["vehicleSpawned"] = {},
    ["settings"] = {},
}

--[[ List all type of value for the NW functions ]]
RCD.TypeNet = RCD.TypeNet or {
    ["Player"] = "Entity",
    ["Vector"] = "Vector",
    ["Angle"] = "Angle",
    ["Entity"] = "Entity",
    ["number"] = "Float",
    ["string"] = "String",
    ["table"] = "Table",
    ["boolean"] = "Bool",
}

--[[ List all constants values ]]
RCD.Constants = {
    ["vectorNPC"] = Vector(0, 0, 25),
    ["vectorSimfphys"] = Vector(0, 0, 20),
    ["vectorOrigin"] = Vector(0, 0, 0),
    ["angleOrigin"] = Angle(0, 0, 0),
    ["vectorShowcase"] = Vector(0, -100, 15),
    ["vectorCompatibilities"] = Vector(0,0,25),
    ["angleParams"] = Angle(0, -30, 0),
    ["vectorInvoice"] = Vector(0, 7, 0.4),
    ["angleWheel"] = Angle(0, 180, 0),
    ["angle90"] = Angle(0, 90, 0),
    ["vectorJob"] = Vector(0, -100, 0),
}

--[[ All colors of the colorpicker ]]
RCD.ColorPaletteColors = {
    [1] = Color(255, 0, 0, 255),
    [2] = Color(255, 0, 97, 255),
    [3] = Color(255, 0, 192, 255),
    [4] = Color(128, 0, 255, 255),
    [5] = Color(23, 0, 255, 255),
    [6] = Color(0, 61, 255, 255),
    [7] = Color(0, 255, 255, 255),
    [8] = Color(0, 255, 158, 255),
    [9] = Color(0, 255, 61, 255),
    [10] = Color(27, 255, 0, 255),
    [11] = Color(0, 162, 255, 255),
    [12] = Color(128, 255, 0, 255),
    [13] = Color(226, 255, 0, 255),
    [14] = Color(255, 192, 0, 255),
    [15] = Color(255, 93, 0, 255),
    [16] = Color(128, 0, 0, 255),
    [17] = Color(128, 0, 95, 255),
    [18] = Color(61, 0, 128, 255),
    [19] = Color(0, 25, 128, 255),
    [20] = Color(0, 128, 128, 255),
    [21] = Color(0, 128, 25, 255),
    [22] = Color(61, 128, 0, 255),
    [23] = Color(128, 95, 0, 255),
    [24] = Color(128, 61, 61, 255),
    [25] = Color(128, 61, 111, 255),
    [26] = Color(95, 61, 128, 255),
    [27] = Color(61, 78, 128, 255),
    [28] = Color(61, 78, 128, 255),
    [29] = Color(61, 128,78, 255),
    [30] = Color(95, 128, 61, 255),
    [31] = Color(128, 111, 61, 255),
    [32] = Color(255, 128, 128, 255),
    [33] = Color(255, 128, 224, 255),
    [34] = Color(192, 128, 255, 255),
    [35] = Color(128, 160, 255, 255),
    [36] = Color(128, 255, 255, 255),
    [37] = Color(128, 255, 160, 255),
    [38] = Color(192, 255, 128, 255),
    [39] = Color(255, 224, 128, 255),
    [40] = Color(255, 255, 255, 255),
    [41] = Color(219, 219, 219, 255),
    [42] = Color(183, 183, 183, 255),
    [43] = Color(146, 146, 146, 255),
    [44] = Color(146, 146, 146, 255),
    [45] = Color(70, 70, 70, 255),
    [46] = Color(31, 31, 31, 255),
    [47] = Color(0, 0, 0, 255)
}

--addons/realisticcardealer/lua/realistic_cardealer/client/cl_notify.lua:
return gluapack()()
--addons/realisticcardealer/lua/realistic_cardealer/vgui/cl_button.lua:
local PANEL = {}

function PANEL:Init()
    self:SetSize(RCD.ScrH*0.03, RCD.ScrH*0.03)
    self:SetText("")
    self.RCDBackgroundColor = RCD.Colors["white100"]
    self.RCDHoveredAlpha = 0
    self.RCDIcon = nil
    self.RCDAlignement = TEXT_ALIGN_LEFT
    self.RCDTextPos = 0
    self.RCDMinMaxLerp = {60, 0}
    self.RCDValue = RCD.GetSentence("invalidText")
end

function PANEL:SetValue(value)
    self.RCDValue = value
end

function PANEL:GetValue()
    return self.RCDValue or ""
end

function PANEL:SetBackgroundColor(color)
    self.RCDBackgroundColor = color
end

function PANEL:SetHoveredColor(color)
    self.RCDHoveredColor = color
end

function PANEL:SetIconMaterial(mat)
    self.RCDIcon = mat
end

function PANEL:SetTextAlignement(align) 
    self.RCDAlignement = align
end

function PANEL:Paint(w, h)
    self.RCDHoveredAlpha = Lerp(FrameTime()*3, self.RCDHoveredAlpha, (self:IsHovered() and self.RCDMinMaxLerp[1] or self.RCDMinMaxLerp[2]))

    surface.SetDrawColor(ColorAlpha(self.RCDBackgroundColor, self.RCDHoveredAlpha))
    surface.DrawRect(0, 0, w, h)

    if self.RCDIcon then
        self.RCDTextPos = RCD.ScrW*0.025

        RCD.DrawCircle(RCD.ScrW*0.012, h/2, h*0.4, 0, 360, RCD.Colors["white30"])
        
        surface.SetMaterial(self.RCDIcon)
        surface.SetDrawColor(RCD.Colors["white100"])
        surface.DrawTexturedRect(RCD.ScrW*0.012 - h*0.18, h/2-h*0.4/2, h*0.4, h*0.4)
    else
        self.RCDTextPos = self.RCDAlignement == TEXT_ALIGN_CENTER and w/2 or RCD.ScrW*0.005
    end

    draw.SimpleText(self.RCDValue, "RCD:Font:09", self.RCDTextPos, h/2, RCD.Colors["white"], self.RCDAlignement, TEXT_ALIGN_CENTER)
end

derma.DefineControl("RCD:Button", "RCD Button", PANEL, "DButton")
--addons/realisticcardealer/lua/realistic_cardealer/vgui/cl_dtextentry.lua:
return gluapack()()
--addons/realisticcardealer/lua/realistic_cardealer/vgui/cl_accordion.lua:
local PANEL = {}

function PANEL:Init()
    self:SetButtonTall(RCD.ScrH*0.05)
    self:SetTextFont("RCD:Font:18")
    self:SetRightTextFont("RCD:Font:18")
    self:SetArrowFont("RCD:Font:17")
    self.RCDText = RCD.GetSentence("noText")
    self.RCDDeploy = false
    self.RCDSizeY = RCD.ScrH*0.15
    self.RCDParams = {}
    self.RCDSizeYPanel = 0
    self.RCDHoveredAlpha = 0
    self.RCDHoveredAlpha2 = 0
    self.RCDCanInteract = true

    timer.Simple(0.1, function()
        if not IsValid(self) then return end
    
        self.Button = vgui.Create("DButton", self)
        self.Button:SetSize(self:GetWide(), self.RCDButtonSizeY)
        self.Button:SetText("")
        self.Button.Paint = function() end
        self.Button.DoClick = function()
            if not self.RCDCanInteract then return end

            self:Deploy(self.RCDSizeY)
        end
    end)
end

function PANEL:SetSizeY(number, notDeploy, bool)
    self.RCDBase = bool
    self.RCDSizeY = self.RCDSizeY - self.RCDSizeYPanel + number
    self.RCDSizeYPanel = number

    if not notDeploy then
        self:Deploy(self.RCDSizeY)
    end
end

function PANEL:Paint(w,h)
    self.RCDHoveredAlpha = Lerp(FrameTime()*3, self.RCDHoveredAlpha, 20)
    self.RCDHoveredAlpha2 = Lerp(FrameTime()*3, self.RCDHoveredAlpha2, 245)

    draw.RoundedBox(0, 0, 0, w, self.RCDButtonSizeY, ColorAlpha(RCD.Colors["white20"], self.RCDHoveredAlpha))
    draw.RoundedBox(0, 0, self.RCDButtonSizeY, w, h, RCD.Colors["white2"])
    
    if IsValid(self.Button) then
        local white = ColorAlpha(RCD.Colors["white"], self.RCDHoveredAlpha2)
        draw.DrawText(RCD.GetSentence(self.RCDText), self.RCDTextFont, RCD.ScrW*0.007, (self.RCDButtonSizeY - self.RCDTextFontSizeY)/2, white, TEXT_ALIGN_LEFT)
    
        draw.DrawText("▼", self.RCDArrowFont, w-RCD.ScrW*0.016, (self.RCDButtonSizeY - self.SetArrowFontSizeY)/2, RCD.Colors["grey30"], TEXT_ALIGN_LEFT)
    
        if isstring(self.RCDRightText) then
            draw.DrawText(self.RCDRightText, self.RCDRightTextFont, w-RCD.ScrW*0.017-self.RCDRightTextSizeX, (self.RCDButtonSizeY - self.SetRightTextFontSizeY)/2, white, TEXT_ALIGN_LEFT)
        end
    end
end

function PANEL:SetText(text)
    self.RCDText = text
end

function PANEL:SetInteract(bool)
    self.RCDCanInteract = bool
end

function PANEL:SetRightText(text)
    surface.SetFont("RCD:Font:17")
    self.RCDRightText, self.RCDRightTextSizeX, self.RCDRightTextSizeY = text, surface.GetTextSize(text)
end

function PANEL:SetTextFont(fontName)
    self.RCDTextFont = fontName

    surface.SetFont(fontName)
    self.RCDTextFontSizeY = select(2, surface.GetTextSize("AAA"))
end

function PANEL:SetRightTextFont(fontName)
    self.RCDRightTextFont = fontName

    surface.SetFont(fontName)
    self.SetRightTextFontSizeY = select(2, surface.GetTextSize("AAA"))
end

function PANEL:SetArrowFont(fontName)
    self.RCDArrowFont = fontName

    surface.SetFont(fontName)
    self.SetArrowFontSizeY = select(2, surface.GetTextSize("▼"))
end

function PANEL:SetButtonTall(y)

    if IsValid(self.Button) then
        self.Button:SetTall(y)
    end
    self.RCDButtonSizeY = y
end

function PANEL:InitializeCategory(name, panelLink, letOpen, editVehicle)
    if not istable(RCD.ParametersConfig[name]) then return end

    local borderX, borderY = RCD.ScrW*0.0034, RCD.ScrH*0.005
    local sizeToSet = 0

    if istable(self.RCDParams) && #self.RCDParams != 0 then
        for k,v in ipairs(self.RCDParams) do
            if not IsValid(v) then continue end

            v:Remove()
        end
    end
    
    for line, elements in ipairs(RCD.ParametersConfig[name]) do
        local numberElements = #elements

        local sizeYUp = 0
        for k,v in ipairs(elements) do
            local sizeX = math.Round(self:GetWide()/numberElements - borderX - borderX/numberElements)
            local sizeY = self.RCDButtonSizeY+borderY*(line==1 and 1 or line)+((line-1)*self.RCDButtonSizeY)

            local posX = math.Round(sizeX*(k-1) + (borderX*k))

            local dPanel = vgui.Create("DPanel", self)
            dPanel:SetPos(posX-RCD.ScrW*0.00001, sizeY)
            dPanel.Paint = function(_,w,h)
                dPanel:SetSize(sizeX, v.sizeYPanel and RCD.ScrH*v.sizeYPanel + self.RCDSizeYPanel or self.RCDButtonSizeY)
            
                local text = RCD.GetSentence(v.text)
                if text != "Lang Problem" then
                    draw.DrawText(text, "RCD:Font:13", RCD.ScrW*0.01, h*0.25, RCD.Colors["white100"], TEXT_ALIGN_LEFT)
                end

                if not v.disableBackgroundColor then
                    draw.RoundedBox(4,0,0,w,h,RCD.Colors["white2"])
                end
            end

            local params = vgui.Create(v.class, dPanel)
            params:SetSize(RCD.ScrW*v.sizeX, RCD.ScrH*v.sizeY)
            params:SetPos(RCD.ScrW*v.posX, RCD.ScrH*v.posY)
            if isfunction(v.func) then
                v.func(params, panelLink, editVehicle, self)
            end

            sizeYUp = sizeYUp + (v.sizeYPanel and RCD.ScrH*v.sizeYPanel + self.RCDSizeYPanel or self.RCDSizeYPanel )

            self.RCDParams[#self.RCDParams + 1] = dPanel
        end

        sizeToSet = sizeToSet + (sizeYUp == 0 and self.RCDButtonSizeY or sizeYUp) + borderY
    end
    
    self.RCDSizeY = sizeToSet + borderY

    if not letOpen then
        self:Deploy(sizeToSet + borderY)
    end
end

function PANEL:Deploy(size, force, noAnim)
    self.RCDDeploy = (force and force or !self.RCDDeploy)
    
    self:SizeTo(-1, self.RCDButtonSizeY + (self.RCDDeploy and (self.RCDBase and self.RCDSizeYPanel or size) or 0), (noAnim and 0 or 0.5))
end

derma.DefineControl("RCD:Accordion", "RCD Accordion", PANEL)
--addons/realisticcardealer/lua/realistic_cardealer/vgui/cl_circular_avatar.lua:
return gluapack()()
--addons/bb_isimeklentisi/lua/autorun/rpname_enforcer_loader.lua:
include("rpname_enforcer/sh_config.lua")
hook.Add("Initialize", "removecommand", function()
DarkRP.removeChatCommand("rpname")
DarkRP.removeChatCommand("name")
DarkRP.removeChatCommand("nick")
end)
if SERVER then	
	include("rpname_enforcer/server/rpname_enforcer_checker.lua")
	AddCSLuaFile("rpname_enforcer/sh_config.lua")
	AddCSLuaFile("rpname_enforcer/client/rpname_enforcer_system.lua")
elseif CLIENT then
	include("rpname_enforcer/client/rpname_enforcer_system.lua")
end
--addons/rsc/lua/autorun/rsc.lua:
AddCSLuaFile("rsc/init.lua")
include("rsc/init.lua")

--addons/rsc/lua/rsc/classes/event.lua:
local setmetatable = setmetatable
local pairs = pairs
local type = type
local ErrorNoHaltWithStack = ErrorNoHaltWithStack
local xpcall = xpcall
local table = table

-- Simple event handler
RSC.Event = RSC.Event or {}
local Event = RSC.Event

-- Metatable
Event.EVENT = Event.EVENT or {}
local EVENT = Event.EVENT
EVENT.__index = EVENT

function EVENT:RegisterData(data)
    self:Remove(data.id)
    table.insert(self.receivers, data)
end

function EVENT:On(func, identifier)
    if type(func) == "function" then
        self:RegisterData({
            id = identifier or func,
            func = func
        })
    end
end

function EVENT:Once(func, identifier)
    if type(func) == "function" then
        self:RegisterData({
            id = identifier or func,
            func = func,
            once = true
        })
    end
end

function EVENT:Remove(identifier)
    if identifier ~= nil then
        for i, t in pairs(self.receivers) do
            if t.id == identifier then
                self.receivers[i] = nil
            end
        end
    end
end

function EVENT:Emit(...)
    for i, t in pairs(self.receivers) do
        local func = t.func

        if type(func) == "function" then
            xpcall(func, ErrorNoHaltWithStack, ...)
        end

        if t.once then
            self.receivers[i] = nil
        end
    end
end

-- Constructor for Event class
function Event.New()
    return setmetatable({
        receivers = {}
    }, EVENT)
end

--addons/rsc/lua/rsc/classes/capture_request.lua:
return gluapack()()
--addons/rsc/lua/rsc/services/gmod.express.lua:
-- This api uses code from two open-source projects from CFC-Servers that was made by Brandon Sturgeon
-- https://github.com/CFC-Servers/gm_express
-- https://github.com/CFC-Servers/gm_express_service
--
-- These libraries are licensed under GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007
-- https://github.com/CFC-Servers/gm_express/blob/main/LICENSE
-- https://github.com/CFC-Servers/gm_express_service/blob/main/LICENSE

local promise = RSC.promise

-- Default gm_express domain is `gmod.express`
-- RSC uses `gmod-express.dankmolot.workers.dev` as default domain
local GM_EXPRESS_DOMAIN = RSC.ConVar("rsc_express_domain", "gmod-express.dankmolot.workers.dev", "The domain of the express server for RSC")
local GM_EXPRESS_DOMAIN_CL = RSC.ConVar("rsc_express_domain_cl", "", "The client-side domain of the express server for RSC")

local GM_EXPRESS_VERSION = 1
local GM_EXPRESS_REVISION = 1

local JSON_TYPE = "application/json"
local BYTES_TYPE = "application/octet-stream"

local gm_express = RSC.Service.New("gmod.express")

function gm_express:GetServerToken()
    return (self.tokenLifetime or 0) > SysTime() and self.serverToken
end

function gm_express:GetClientToken()
    return (self.tokenLifetime or 0) > SysTime() and self.clientToken
end

function gm_express:GetToken()
    return SERVER and self:GetServerToken() or self:GetClientToken()
end

function gm_express:GetDomain()
    local domain = GM_EXPRESS_DOMAIN:GetString()
    local clDomain = GM_EXPRESS_DOMAIN_CL:GetString()
    return (CLIENT and clDomain ~= "") and clDomain or domain
end

function gm_express:GetBaseURL()
    return string.format("%s://%s/v%d", "http", self:GetDomain(), GM_EXPRESS_VERSION)
end

function gm_express:GetURL(...)
    local url = self:GetBaseURL()
    local args = { url, ... }
    return table.concat(args, "/")
end

function gm_express:GetAccessURL(token, action, ...)
    return self:GetURL(action, token or self:GetToken(), ...)
end

function gm_express:GetDownloadURL(id, token)
    return self:GetAccessURL(token, "read", id)
end

function gm_express:Ping()
    local ok, res = promise.HTTP({ url = self:GetURL("revision"), headers = { ["Accept"] = JSON_TYPE, timeout = 5 } }):SafeAwait()

    local data = ok and res.code == 200 and util.JSONToTable(res.body)
    return data and data.revision == GM_EXPRESS_REVISION
end
gm_express.Ping = promise.Async(gm_express.Ping)

function gm_express:Upload(data, _, token)
    if not token then return promise.Reject("failed to get an upload token") end

    local ok, res = promise.HTTP({
        url = self:GetAccessURL(token, "write"),
        method = "POST",
        body = data,
        headers = { ["Accept"] = JSON_TYPE, ["Content-Length"] = #data },
        type = BYTES_TYPE,
        timeout = 20,
    }):SafeAwait()

    if not ok then return promise.Reject("http error: " .. tostring(res)) end
    if res.code ~= 200 then return promise.Reject("upload wasn't successful: http code - " .. res.code) end

    local response = util.JSONToTable(res.body)
    if not response or not response.id then return promise.Reject("invalid response from " .. self:GetDomain()) end

    return response.id
end
gm_express.Upload = promise.Async(gm_express.Upload)

function gm_express:Download(id, _, token)
    if not token then return promise.Reject("failed to get an upload token") end

    local ok, res = promise.HTTP({
        url = self:GetDownloadURL(id, token),
        method = "GET",
        headers = { ["Accept"] = BYTES_TYPE },
        timeout = 60,
    }):SafeAwait()

    if not ok then return promise.Reject("http error: " .. tostring(res)) end
    if res.code ~= 200 then return promise.Reject("upload wasn't successful: http code - " .. res.code) end

    return res.body
end
gm_express.Download = promise.Async(gm_express.Download)

function gm_express:Prepare()
    if not self:GetToken() then
        local oneDay = 60 * 60 * 24
        self.tokenLifetime = SysTime() + oneDay
        self.serverToken = nil
        self.clientToken = nil

        local ok, res = promise.HTTP({ url = self:GetURL("register"), headers = { ["Accept"] = JSON_TYPE } }):SafeAwait()
        if not ok or res.code ~= 200 then return end

        local data = util.JSONToTable(res.body)
        if not data or not data.client or not data.server then return end

        self.serverToken = data.server
        self.clientToken = data.client
    end

    return self:GetClientToken()
end
gm_express.Prepare = promise.Async(gm_express.Prepare)

gm_express:Register()

--addons/rsc/lua/rsc/client/cl_gallery.lua:
return gluapack()()
--addons/sam-159/lua/sam/libs/message_pack/sh_messagepack.lua:
return gluapack()()
--addons/sam-159/lua/sam/sh_colors.lua:
return gluapack()()
--addons/sam-159/lua/sam/sh_util.lua:
return gluapack()()
--addons/sam-159/lua/sam/config/cl_config.lua:
if SAM_LOADED then return end

local sam = sam
local sfs = sam.sfs
local config = sam.config
local type = sam.type

local encoders = sfs.Encoder.encoders

function config.set(key, value, force)
	if not sam.isstring(key) then
		error("invalid setting name")
	end

	if not encoders[type(value)] then
		error("not supported value type")
	end

	if not force and config.get(key) == value then return end
	sam.netstream.Start("Config.Set", key, value)
end

function config.get(key, default)
	local value = sam.get_global("Config", {})[key]
	if value ~= nil then
		return value
	end
	return default
end

local menu_settings = {}
function config.add_menu_setting(title, func)
	local i = #menu_settings + 1
	for k, v in ipairs(menu_settings) do
		if v.title == title then
			i = k
			break
		end
	end
	menu_settings[i] = {
		title = title,
		func = func,
	}
end

function config.get_menu_settings()
	return menu_settings
end

hook.Add("SAM.ChangedGlobalVar", "SAM.CheckLoadedConfig", function(key, value)
	if key == "Config" then
		config.loaded = true
		hook.Call("SAM.LoadedConfig", nil, value)
		hook.Remove("SAM.ChangedGlobalVar", "SAM.CheckLoadedConfig")
	end
end)

--addons/sam-159/lua/sam/command/sh_command.lua:
return gluapack()()
--addons/sam-159/lua/sam/command/cl_command.lua:
if SAM_LOADED then return end

local sam = sam
local command = sam.command

local get_syntax = function(args, cmd_args, cmd_str)
	for i = 1, #cmd_args do
		cmd_str = cmd_str .. " "

		local cmd_arg = cmd_args[i]
		local arg = args[i]

		if arg == "" then
			arg = nil
		end

		local optional = cmd_arg.optional
		local c_1, c_2 = "<", ">"
		if optional then
			c_1, c_2 = "[", "]"
		end

		cmd_str = cmd_str .. (arg and "\"" or c_1)

		cmd_str = cmd_str .. (arg or cmd_arg.hint or cmd_arg.name)

		if not arg then
			local default = cmd_arg.default
			if default then
				cmd_str = cmd_str .. " = " .. tostring(default)
			end
		end

		cmd_str = cmd_str .. (arg and "\"" or c_2)
	end

	return cmd_str
end

--
-- Auto Complete
--
concommand.Add("sam", function(_, _, _, text)
	LocalPlayer():ConCommand("sam_run " .. text)
end, function(_, text)
	local ply = LocalPlayer()
	local result = {}

	local new_arg = text:EndsWith(" ")
	local args = sam.parse_args(text)

	local cmd_name = (args[1] or ""):lower()
	local cmd = command.get_command(cmd_name)

	if not cmd or (#args == 1 and not new_arg) then
		local commands = command.get_commands()

		for _, v in ipairs(commands) do
			local name = v.name
			if name:find(cmd_name, nil, true) and ply:HasPermission(name) then
				table.insert(result, "sam " .. name)
			end
		end

		return result
	end

	if not ply:HasPermission(cmd_name) then return end

	table.remove(args, 1)

	if new_arg then
		local syntax = get_syntax(args, cmd.args, "sam " .. cmd.name)
		if #args == 0 then
			print(syntax)
		end
		table.insert(result, syntax)
		return result
	end

	local arg_index = new_arg and #args + 1 or #args

	local cmd_args = cmd.args
	local cmd_args_n = #cmd_args
	if cmd_args_n == 0 then return end

	if arg_index >= cmd_args_n then
		arg_index = cmd_args_n

		if cmd.get_rest_args then
			local arg = table.concat(args, " ", cmd_args_n)
			if arg ~= "" then
				args[cmd_args_n] = arg
				for i = cmd_args_n + 1, #args do
					args[i] = nil
				end
			end
		end
	end

	local arguments = command.get_arguments()
	local cmd_arg = cmd_args[arg_index]
	local func = arguments[cmd_arg.name].auto_complete
	if func then
		func(cmd_arg, result, args[arg_index] or "")
	end

	local cmd_str = "sam " .. cmd_name .. " "
	if arg_index - 1 > 0 then
		cmd_str = cmd_str .. "\"" .. table.concat(args, "\" ", 1, arg_index - 1) .. "\" "
	end

	for k, v in ipairs(result) do
		result[k] = cmd_str .. "\"" .. v .. "\""
	end

	return result
end)
--addons/sui/lua/includes/modules/sui.lua:
return gluapack()()
--addons/sui/lua/sui/libs/bshadows.lua:
local ScrW = ScrW
local ScrH = ScrH

local sin = math.sin
local cos = math.cos
local rad = math.rad
local ceil = math.ceil

local Start2D = cam.Start2D
local End2D = cam.End2D

local PushRenderTarget = render.PushRenderTarget
local OverrideAlphaWriteEnable = render.OverrideAlphaWriteEnable
local Clear = render.Clear
local CopyRenderTargetToTexture = render.CopyRenderTargetToTexture
local BlurRenderTarget = render.BlurRenderTarget
local PopRenderTarget = render.PopRenderTarget
local SetMaterial = render.SetMaterial
local DrawScreenQuadEx = render.DrawScreenQuadEx
local DrawScreenQuad = render.DrawScreenQuad

local RenderTarget, RenderTarget2
local load_render_targets = function()
	local w, h = ScrW(), ScrH()
	RenderTarget = GetRenderTarget("sui_bshadows_original" .. w .. h, w, h)
	RenderTarget2 = GetRenderTarget("sui_bshadows_shadow" .. w .. h,  w, h)
end
load_render_targets()
hook.Add("OnScreenSizeChanged", "SUI.BShadows", load_render_targets)

local ShadowMaterial = CreateMaterial("sui_bshadows", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["alpha"] = 1
})

local ShadowMaterialGrayscale = CreateMaterial("sui_bshadows_grayscale", "UnlitGeneric", {
	["$translucent"] = 1,
	["$vertexalpha"] = 1,
	["$alpha"] = 1,
	["$color"] = "0 0 0",
	["$color2"] = "0 0 0"
})

local SetTexture = ShadowMaterial.SetTexture

local BSHADOWS = {}

BSHADOWS.BeginShadow = function()
	PushRenderTarget(RenderTarget)

	OverrideAlphaWriteEnable(true, true)
	Clear(0, 0, 0, 0)
	OverrideAlphaWriteEnable(false, false)

	Start2D()
end

BSHADOWS.EndShadow = function(intensity, spread, blur, opacity, direction, distance, _shadowOnly)
	opacity = opacity or 255
	direction = direction or 0
	distance = distance or 0

	CopyRenderTargetToTexture(RenderTarget2)

	if blur > 0 then
		OverrideAlphaWriteEnable(true, true)
		BlurRenderTarget(RenderTarget2, spread, spread, blur)
		OverrideAlphaWriteEnable(false, false)
	end

	PopRenderTarget()

	SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
	SetTexture(ShadowMaterialGrayscale, "$basetexture", RenderTarget2)

	local xOffset = sin(rad(direction)) * distance
	local yOffset = cos(rad(direction)) * distance

	SetMaterial(ShadowMaterialGrayscale)
	for i = 1, ceil(intensity) do
		DrawScreenQuadEx(xOffset, yOffset, ScrW(), ScrH())
	end

	if not _shadowOnly then
		SetTexture(ShadowMaterial, "$basetexture", RenderTarget)
		SetMaterial(ShadowMaterial)
		DrawScreenQuad()
	end

	End2D()
end

sui.BSHADOWS = BSHADOWS
--addons/sui/lua/sui/libs/types.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_text_entry.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_toggle_button.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
local IsValid = IsValid

local TDLib_Classes = sui.TDLib.LibClasses
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local Panel = {}

function Panel:Init()
	self.tabs = {}

	local tab_scroller = self:Add(NAME .. ".ScrollPanel")
	tab_scroller:Dock(LEFT)

	function tab_scroller:Paint(w, h)
		self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet_bar"))
	end

	self.tabs_wide = 48
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:ScaleChanged()
	local tabs_wide = SUI.Scale(self.tabs_wide)
	self.tab_scroller:SetWide(tabs_wide)

	self:InvalidateLayout(true)

	local tabs = self.tabs
	for i = 1, #self.tabs do
		tabs[i].img:SetMinus(SUI.Scale(20))
	end
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet"))
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local tab_Paint = function(s, w, h)
	local cur_col
	if s.active then
		cur_col = GetColor("column_sheet_tab_active")
	elseif s.Hovered then
		cur_col = GetColor("column_sheet_tab_hover")
	else
		cur_col = GetColor("column_sheet_tab")
	end

	s:RoundedBox("Backgrounds", 0, 0, 0, w, h, cur_col)
end

local tab_OnRemove = function(s)
	table.RemoveByValue(s.parent.tabs, s)
end

function Panel:AddSheet(mat, load_func)
	local tab = self.tab_scroller:Add(NAME .. ".Button")
	tab:Dock(TOP)
	tab:SetText("")
	tab:SetTall(self.tabs_wide)

	tab.On = TDLib_Classes.On

	tab.DoClick = tab_DoClick
	tab.Paint = tab_Paint
	tab:On("OnRemove", tab_OnRemove)

	tab.parent = self
	tab.load_func = load_func

	local img = tab:Add(NAME .. ".Image")
	img:Dock(FILL)
	img:SetImage(mat)
	img:SetMinus(SUI.Scale(20))

	tab.img = img

	self.tab_scroller:AddItem(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function Panel:GetActiveTab()
	return self.active_tab
end

function Panel:SetActiveTab(new_tab)
	if new_tab == self.active_tab then return end

	if not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)
		panel:SetAlpha(0)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	local old_active_tab = self.active_tab
	local delay = 0
	if old_active_tab and IsValid(old_active_tab.panel) then
		old_active_tab.active = false
		delay = 0.2
		old_active_tab.panel:AlphaTo(0, delay, 0, function(_, p)
			if p:IsValid() then
				p:SetVisible(false)
			end
		end)
	end

	new_tab.active = true
	new_tab.panel:SetVisible(true)
	new_tab.panel:AlphaTo(255, 0.2, delay)
	self.active_tab = new_tab
end

sui.register("ColumnSheet", Panel, "EditablePanel")
--addons/sam-159/lua/sui/vgui/sam_player_line.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TDLib = sui.TDLib
local draw_material = sui.draw_material
local lerp_color = sui.lerp_color

local GetColor = SUI.GetColor
local RoundedBox = TDLib.RoundedBox
local CircleAvatar = TDLib.LibClasses.CircleAvatar
local CircleClick2 = TDLib.LibClasses.CircleClick2

local PLAYER_LINE_NAME = SUI.CreateFont("PlayerLineName", "Roboto Bold", 17)
local PLAYER_LINE_RANK = SUI.CreateFont("PlayerLineRank", "Roboto Bold", 13)
local PLAYER_LINE_STEAMID = SUI.CreateFont("PlayerLineSteamID", "Roboto Medium", 12)

local PANEL = {}

function PANEL:Init()
	local size = SUI.Scale(34)

	self:Dock(TOP)
	self:SetTall(size)

	self.size = size
end

local rank_Paint = function(s, w, h)
	RoundedBox(s.rect, SUI.Scale(10), 0, 0, w, h, s.col)
end

function PANEL:SetInfo(info)
	local size = self.size

	local container
	do
		local w = SUI.Scale(280) + size

		local _container = self:Add("Panel")
		_container:Dock(LEFT)
		_container:SetMouseInputEnabled(false)
		_container:SetWide(w)

		container = _container:Add("Panel")
		container:SetSize(w, size)

		function _container:PerformLayout()
			container:Center()
		end
	end

	do
		local avatar = container:Add("Panel")
		avatar:Dock(LEFT)
		avatar:DockMargin(0, 0, 5, 0)
		avatar:SetWide(size)
		avatar:SetMouseInputEnabled(false)
		CircleAvatar(avatar)

		avatar:SetSteamID(util.SteamIDTo64(info.steamid), size)
	end

	do
		local top_container = container:Add("Panel")
		top_container:Dock(TOP)
		top_container:DockMargin(0, 0, 0, 2)

		local name = top_container:Add("SAM.Label")
		name:Dock(LEFT)
		name:SetFont(PLAYER_LINE_NAME)
		self.name = name

		local pname = info.name
		if not pname or pname == "" then
			name:SetTextColor(GetColor("player_list_names_2"))
			self:SetName("N/A")
		else
			name:SetTextColor(GetColor("player_list_names"))
			self:SetName(pname)
		end

		if info.rank then
			local rank_bg = top_container:Add("Panel")
			rank_bg:Dock(LEFT)
			rank_bg:DockMargin(5, 0, 0, 0)

			rank_bg.rect = {}
			rank_bg.col = info.rank_bg or GetColor("player_list_rank")
			rank_bg.Paint = rank_Paint

			local rank = rank_bg:Add("SAM.Label")
			rank:Dock(FILL)
			rank:DockMargin(SUI.Scale(8), 0, 0, 0)
			rank:SetTextColor(GetColor("player_list_rank_text"))
			rank:SetFont(PLAYER_LINE_RANK)
			rank.bg = rank_bg

			self.rank = rank
			self:SetRank(info.rank)

			rank_bg:SetSize(rank:GetTextSize() + SUI.Scale(8) * 2)
		end

		top_container:SizeToChildren(true, true)
	end

	local steamid = container:Add("SAM.Label")
	steamid:Dock(TOP)
	steamid:SetTextColor(GetColor("player_list_steamid"))
	steamid:SetFont(PLAYER_LINE_STEAMID)
	steamid:SetText(info.steamid)
	steamid:SizeToContents()
	steamid:SetAutoStretchVertical(true)

	self.container = container
end

function PANEL:SetName(new_name)
	local name =  self.name
	name:SetText(new_name)
	name:SizeToContents()
	if name:GetWide() > 160 then
		name:SetWide(158)
	end
end

function PANEL:SetRank(new_rank)
	local rank = self.rank
	rank:SetText(new_rank)
	rank:SizeToContents()
	rank.bg:SetSize(rank:GetTextSize() + SUI.Scale(8) * 2)
end

function PANEL:Actions()
	local container
		do
		local size = self.size

		local _container = self:Add("Panel")
		_container:Dock(RIGHT)
		_container:SetWide(size)

		container = _container:Add("Panel")
		container:SetSize(size, size)

		function _container:PerformLayout()
			container:Center()
		end
	end

	local actions_button = container:Add("SAM.Button")
	actions_button:SetText("")
	actions_button:ClearPaint()

	function container:PerformLayout(w, h)
		actions_button:SetSize(h, h)
		actions_button:Center()
	end

	local image = actions_button:Add("SAM.Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sam/dots_verticle.png")

	local current_icon_color = Color(GetColor("actions_button_icon"):Unpack())
	function image:Draw(w, h)
		if not h then return end

		if actions_button.Hovered then
			lerp_color(current_icon_color, GetColor("actions_button_icon_hover"))
		else
			lerp_color(current_icon_color, GetColor("actions_button_icon"))
		end

		draw_material(nil, w / 2, h / 2, SUI.ScaleEven(20), current_icon_color)
	end

	CircleClick2(actions_button, Color(62, 62, 62), 10)
	actions_button:Center()

	return actions_button
end

sui.register("PlayerLine", PANEL, "Panel")
--addons/sam-159/lua/sam/sh_motd.lua:
if SAM_LOADED then return end

local sam = sam
local config = sam.config
local command = sam.command

if CLIENT then
	config.add_menu_setting("MOTD URL (Leave empty for no MOTD)", function()
		local entry = vgui.Create("SAM.TextEntry")
		entry:SetPlaceholder("")
		entry:SetNoBar(true)
		entry:SetConfig("MOTDURL", "")

		return entry
	end)
end

local motd
local load_motd = function()
	local url = config.get("MOTDURL", "")
	if url == "" then
		command.remove_command("motd")
		hook.Remove("HUDPaint", "SAM.OpenMOTD")
		return
	end

	if IsValid(motd) then
		motd:Remove()
	end

	command.set_category("Menus")

	command.new("motd")
		:Help("Open MOTD menu")
		:OnExecute(function(ply)
			sam.netstream.Start(ply, "OpenMOTD")
		end)
	:End()

	if CLIENT then
		function sam.menu.open_motd()
			if IsValid(motd) then
				motd:Remove()
			end

			motd = vgui.Create("SAM.Frame")
			motd:Dock(FILL)
			motd:DockMargin(40, 40, 40, 40)
			motd:MakePopup()

			function motd.close.DoClick()
				motd:Remove()
			end

			local html = motd:Add("DHTML")
			html:Dock(FILL)
			html:OpenURL(url)
		end

		sam.netstream.Hook("OpenMOTD", function()
			sam.menu.open_motd()
		end)

		hook.Add("HUDPaint", "SAM.OpenMOTD", function()
			sam.menu.open_motd()
			hook.Remove("HUDPaint", "SAM.OpenMOTD")
		end)
	end
end
config.hook({"MOTDURL"}, load_motd)
--addons/sam-159/lua/sam/modules/vote.lua:
return gluapack()()
--addons/sui/lua/sui/libs/gif_loader.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_panel.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_property_sheet.lua:
local draw = draw
local surface = surface
local vgui = vgui

local TYPE_MATERIAL = TYPE_MATERIAL

local RealFrameTime = RealFrameTime
local IsValid = IsValid
local Lerp = Lerp
local pairs = pairs
local TypeID = TypeID

local TDLib_Classes = sui.TDLib.LibClasses
local TextColor = TDLib_Classes.TextColor
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local PROPERTY_SHEET_FONT = SUI.CreateFont("PropertySheet", "Roboto Regular", 18)

local PANEL = {}

AccessorFunc(PANEL, "m_FontName", "Font", FORCE_STRING)

function PANEL:Init()
	self.tabs = {}

	self:SetFont(PROPERTY_SHEET_FONT)

	local tab_scroller = self:Add("DHorizontalScroller")
	tab_scroller:Dock(TOP)

	self.tabs_tall = 26
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function PANEL:ScaleChanged()
	self.tab_scroller:SetTall(SUI.Scale(self.tabs_tall))

	for k, v in pairs(self.tab_scroller.Panels) do
		if v:IsValid() then
			if v.Material then
				v:SetWide(self.tab_scroller:GetTall())
			else
				v:SizeToContentsX()
			end
		end
	end

	self:InvalidateLayout(true)
end

function PANEL:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, self.tab_scroller:GetTall(), SUI.GetColor("property_sheet_bg"))
end

function PANEL:PaintOver(w, h)
	local active_tab = self:GetActiveTab()
	if not IsValid(active_tab) then return end

	local tab_scroller = self.tab_scroller
	local offset = tab_scroller:GetTall() - SUI.Scale(1)

	local x = active_tab:LocalToScreen(0) - self:LocalToScreen(0)

	if not self.activeTabX then
		self.activeTabX = x
		self.activeTabW = active_tab:GetWide()
	end

	local delta = RealFrameTime() * 6
	if delta then
		self.activeTabX = Lerp(delta, self.activeTabX, x)
		self.activeTabW = Lerp(delta, self.activeTabW, active_tab:GetWide())
	end

	self:RoundedBox("Background2", 1, self.activeTabX, tab_scroller.y + offset, self.activeTabW, SUI.Scale(1), SUI.GetColor("property_sheet_tab_active"))
end

local tab_Paint = function(s, w, h)
	s.circle_click_color = SUI.GetColor("property_sheet_tab_click")
	if s.property_sheet:GetActiveTab() == s then
		TextColor(s, SUI.GetColor("property_sheet_tab_active"))
	else
		TextColor(s, SUI.GetColor("property_sheet_tab"))
	end
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local image_paint = function(s, w, h)
	surface.SetDrawColor(color_white)
	surface.SetMaterial(s.Material)
	surface.DrawTexturedRectRotated(w * 0.5, h * 0.5, w - 10, h - 10, 0)
end

function PANEL:AddSheet(name, load_func)
	local tab = vgui.Create("DButton")
	if TypeID(name) == TYPE_MATERIAL then
		tab:SetText("")
		tab.Material = name
		tab.Paint = image_paint
		tab:SetWide(self.tab_scroller:GetTall())
	else
		tab:SetFont(self:GetFont())
		tab:SetText(name)
		tab:SetTextInset(10, 0)
		tab:SizeToContentsX()

		tab.Paint = tab_Paint
	end

	tab.parent = self
	tab.DoClick = tab_DoClick

	tab.load_func = load_func
	tab.property_sheet = self

	tab.On = TDLib_Classes.On
	TDLib_Classes.CircleClick(tab)

	self.tab_scroller:AddPanel(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function PANEL:GetActiveTab()
	return self.active_tab
end

function PANEL:SetActiveTab(new_tab)
	if IsValid(new_tab) and not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	if self.active_tab and IsValid(self.active_tab.panel) then
		self.active_tab.panel:SetVisible(false)
	end

	if IsValid(new_tab) then
		new_tab.panel:SetVisible(true)
	end

	self.active_tab = new_tab
end

sui.register("PropertySheet", PANEL, "EditablePanel")
--addons/sui/lua/sui/vgui/sui_zbutton.lua:
return gluapack()()
--addons/sui/lua/sui/vgui/sui_zcolumn_sheet.lua:
local IsValid = IsValid

local TDLib_Classes = sui.TDLib.LibClasses
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local Panel = {}

function Panel:Init()
	self.tabs = {}

	local tab_scroller = self:Add(NAME .. ".ScrollPanel")
	tab_scroller:Dock(LEFT)

	function tab_scroller:Paint(w, h)
		self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet_bar"))
	end

	self.tabs_wide = 48
	self.tab_scroller = tab_scroller

	self:ScaleChanged()
	SUI.OnScaleChanged(self, self.ScaleChanged)
end

function Panel:ScaleChanged()
	local tabs_wide = SUI.Scale(self.tabs_wide)
	self.tab_scroller:SetWide(tabs_wide)

	self:InvalidateLayout(true)

	local tabs = self.tabs
	for i = 1, #self.tabs do
		tabs[i].img:SetMinus(SUI.Scale(20))
	end
end

function Panel:Paint(w, h)
	self:RoundedBox("Background", 1, 0, 0, w, h, GetColor("column_sheet"))
end

local tab_DoClick = function(s)
	s.parent:SetActiveTab(s)
end

local tab_Paint = function(s, w, h)
	local cur_col
	if s.active then
		cur_col = GetColor("column_sheet_tab_active")
	elseif s.Hovered then
		cur_col = GetColor("column_sheet_tab_hover")
	else
		cur_col = GetColor("column_sheet_tab")
	end

	s:RoundedBox("Backgrounds", 0, 0, 0, w, h, cur_col)
end

local tab_OnRemove = function(s)
	table.RemoveByValue(s.parent.tabs, s)
end

function Panel:AddSheet(mat, load_func)
	local tab = self.tab_scroller:Add(NAME .. ".Button")
	tab:Dock(TOP)
	tab:SetText("")
	tab:SetTall(self.tabs_wide)

	tab.On = TDLib_Classes.On

	tab.DoClick = tab_DoClick
	tab.Paint = tab_Paint
	tab:On("OnRemove", tab_OnRemove)

	tab.parent = self
	tab.load_func = load_func

	local img = tab:Add(NAME .. ".Image")
	img:Dock(FILL)
	img:SetImage(mat)
	img:SetMinus(SUI.Scale(20))

	tab.img = img

	self.tab_scroller:AddItem(tab)

	if not self:GetActiveTab() then
		self:SetActiveTab(tab)
	end

	table.insert(self.tabs, tab)

	return tab
end

function Panel:GetActiveTab()
	return self.active_tab
end

function Panel:SetActiveTab(new_tab)
	if new_tab == self.active_tab then return end

	if not IsValid(new_tab.panel) then
		local panel = new_tab.load_func(self)
		panel:SetParent(self)
		panel:SetVisible(false)
		panel:SetAlpha(0)

		panel.tab = new_tab
		new_tab.panel = panel
	end

	local old_active_tab = self.active_tab
	local delay = 0
	if old_active_tab and IsValid(old_active_tab.panel) then
		old_active_tab.active = false
		delay = 0.2
		old_active_tab.panel:AlphaTo(0, delay, 0, function(_, p)
			if p:IsValid() then
				p:SetVisible(false)
			end
		end)
	end

	new_tab.active = true
	new_tab.panel:SetVisible(true)
	new_tab.panel:AlphaTo(255, 0.2, delay)
	self.active_tab = new_tab
end

sui.register("ColumnSheet", Panel, "EditablePanel")
--addons/sui/lua/sui/vgui/sui_zmenu.lua:
return gluapack()()
--addons/scb-29/lua/scb/settings/cl_settings.lua:
if SCB_LOADED then return end

local vgui = vgui

local IsValid = IsValid
local pairs = pairs
local LocalPlayer = LocalPlayer

local scb = scb

local tabs = {}
for _, f in ipairs(file.Find("scb/settings/tabs/*.lua", "LUA")) do
	local data = include("scb/settings/tabs/" .. f)
	tabs[data.pos or #tabs + 1] = data
end

function scb.open_settings()
	if IsValid(scb.settings_frame) then
		return scb.settings_frame:Remove()
	end

	local frame = vgui.Create("SCB.Frame")
	frame:SetTitle("SCB | " .. scb.language.settings_title)
	frame:MakePopup()
	frame:AddAnimations(382, 420)

	local sheet = frame:Add("SCB.PropertySheet")
	sheet:Dock(FILL)
	sheet:DockMargin(4, 4, 4, 4)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)

	for k, v in pairs(tabs) do
		if v.check == false or scb.has_permission(LocalPlayer(), "menu") then
			sheet:AddSheet(v.title, v.func)
		end
	end

	scb.settings_frame = frame
end
--addons/scb-29/lua/scb/cl_overrides.lua:
if SCB_LOADED then return end

local table = table
local gui = gui
local team = team
local chat = chat
local hook = hook

local tonumber = tonumber
local Color = Color
local SetClipboardText = SetClipboardText
local IsValid = IsValid
local date = os.date
local team_GetColor = team.GetColor

local scb = scb
local config = scb.config
local language = scb.language

chat.OldOpen = chat.OldOpen or chat.Open
chat.OldClose = chat.OldClose or chat.Close

-- sometimes default chatbox prevents opening the console???
chat.OldClose()

local TEAM = "(" .. language.team .. ") "

function chat.Open(mode)
	mode = tonumber(mode)

	local dont_open = hook.Run("StartChat", mode ~= 1)
	if dont_open == true then return end

	do
		local succ, err = pcall(scb.create_chatbox)
		if not succ then
			if scb.chatbox then
				if scb.chatbox.Remove then
					scb.chatbox:Remove()
				end
				scb.chatbox = nil
			end
			SetClipboardText(err)
			hook.Add("HUDPaint", "SCB.FailedToLoad", function()
				local w, h = ScrW(), ScrH()
				draw.SimpleText("SCB Failed to load - Error is copied to your clipboard", "Trebuchet24", w / 2, h / 2, Color(255, 255, 255))
				draw.SimpleText(err, "Trebuchet24", w / 2, h / 2 + 20, Color(255, 255, 255))
			end)
			return
		end
	end

	local chatbox = scb.chatbox
	if chatbox.hidden == false then return end

	chatbox.bteam = mode
	chatbox.text_entry:SetPlaceholder((mode ~= 1 and TEAM or "") .. language.type_something)

	chatbox:SetVisible(true)
	chatbox.text_entry:RequestFocus()
	chatbox.text_entry:InvalidateLayout()
	chatbox:MakePopup()

	local childs = chatbox.scroll_panel:GetCanvas():GetChildren()
	for i = 1, #childs do
		local v = childs[i]
		v:Stop()
		v:AlphaTo(255, 0)
	end

	net.Start("SCB.IsTyping")
		net.WriteBool(true)
	net.SendToServer()
end

function chat.Close()
	local chatbox = scb.chatbox
	if not chatbox then return end

	if IsValid(scb.emojis_menu) then
		scb.emojis_menu:Remove()
	end

	chatbox.text_entry:SetValue("")
	chatbox.text_entry:OnTextChanged() -- reset chat history

	local childs = chatbox.scroll_panel:GetCanvas():GetChildren()
	for i = 1, #childs do
		local v = childs[i]
		if v.can_hide == nil then
			v:Stop()
			v:AlphaTo(0, 0)
		end
	end

	chatbox:SetVisible(false)
	chatbox:SetMouseInputEnabled(false)
	chatbox:SetKeyboardInputEnabled(false)

	chatbox.scroll_panel:ScrollToBottom()

	hook.Run("FinishChat")

	net.Start("SCB.IsTyping")
		net.WriteBool(false)
	net.SendToServer()
end

chat.OldGetChatBoxPos = chat.OldGetChatBoxPos or chat.GetChatBoxPos
function chat.GetChatBoxPos()
	if IsValid(scb.chatbox) then
		return scb.chatbox:GetPos()
	end
	return chat.OldGetChatBoxPos()
end

chat.OldGetChatBoxSize = chat.OldGetChatBoxSize or chat.GetChatBoxSize
function chat.GetChatBoxSize()
	if IsValid(scb.chatbox) then
		return scb.chatbox:GetSize()
	end
	return chat.OldGetChatBoxSize()
end

local fade_out_time = GetConVar("scb_message_fade_out_time"):GetFloat()
cvars.AddChangeCallback("scb_message_fade_out_time", function(_, _, value_new)
	fade_out_time = value_new
end)

chat.OldAddText = chat.OldAddText or chat.AddText
local AddText_queue = {}
local allow_parsing = config.parse_in_chat
function chat.AddText(...)
	local args
	if AddText_queue == true then
		args = ...
	else
		chat.OldAddText(...)
		args = {n = select("#", ...), ...}
	end

	if not scb.chatbox then
		table.insert(AddText_queue, args)
		return
	end

	local scroll_panel = scb.chatbox.scroll_panel
	local down = scroll_panel:ShouldScrollDown()

	local line = scroll_panel:Add("SCB.ChatLine")
	line:HideAfterTime(fade_out_time)

	line.parsing = true

	local current_color = line.text_color
	for i = 1, args.n do
		local v = args[i]
		local t = scb.type(v)
		if t == "Color" then
			current_color = v
		elseif t == "string" then
			if allow_parsing then
				line:Parse(v, current_color)
			else
				line:NewLabel(v, current_color)
			end
		elseif scb.isentity(v) and not IsValid(v) and not v:IsWorld() then
			line:NewLabel("NULL", current_color)
		elseif t == "Player" then
			line:NewLabel(v:Name(), team_GetColor(v:Team()))
		elseif t == "Entity" then
			line:NewLabel(v:GetClass(), current_color)
		end
	end

	line.parsing = nil

	line:SizeToChildren(false, true)

	if down then
		scroll_panel:ScrollToBottom()
	end
end

local gamemodes_OnPlayerChat = {}
do
	local add_say = function(key, func)
		gamemodes_OnPlayerChat[key] = func
	end

	local line_DoRightClick = function(s)
		local d_menu = DermaMenu()

		local text = s.text
		d_menu:AddOption(language.copy_text, function()
			SetClipboardText(text)
		end)

		local message = s.message
		d_menu:AddOption(language.copy_message, function()
			SetClipboardText(message)
		end)

		local steamid = s.steamid
		if steamid then
			d_menu:AddSpacer()

			d_menu:AddOption(language.copy_steamid, function()
				SetClipboardText(util.SteamIDFrom64(steamid))
			end)

			d_menu:AddOption(language.copy_steamid64, function()
				SetClipboardText(steamid)
			end)

			d_menu:AddOption(language.show_profile, function()
				gui.OpenURL("https://steamcommunity.com/profiles/" .. steamid)
			end)
		end

		d_menu:AddSpacer()
		local time = s.time
		d_menu:AddOption(language.copy_time, function()
			SetClipboardText(time)
		end)

		d_menu:Open()
		d_menu:MakePopup()
	end

	local show_timestamps = GetConVar("scb_show_timestamps"):GetBool()
	cvars.AddChangeCallback("scb_show_timestamps", function(_, _, value_new)
		show_timestamps = tobool(value_new)
	end)

	local show_avatars = config.enable_avatars and GetConVar("scb_show_avatars"):GetBool() or false
	cvars.AddChangeCallback("scb_show_avatars", function(_, _, value_new)
		show_avatars = tobool(value_new)
	end)

	local default_say = function(ply, text, bteam, is_dead, name_replacement, name_color_replacement, text_color)
		local is_console = not ply:IsValid()

		local scroll_panel = scb.chatbox.scroll_panel
		local down = scroll_panel:ShouldScrollDown()

		local line = scroll_panel:Add("SCB.ChatLine")
		line:HideAfterTime(fade_out_time)

		line.parsing = true
		line.time = date(config.timestamps_format)

		if show_timestamps then
			line:SetFont(SCB_16)
			line:NewLabel(line.time .. " ", Color(164, 164, 164))
			line:SetFont(SCB_18)
		end

		local name, name_color
		if not is_console then
			if show_avatars then
				line:NewAvatar(ply)
			end

			if is_dead then
				line:NewLabel(language.dead, Color(244, 67, 54))
			end

			if bteam then
				line:NewLabel(TEAM, Color(76, 175, 80))
			end

			local tag = ply:SCB_GetTag()
			if tag then
				line.emoji_size = 18
				line:Parse(tag .. " ")
				line.emoji_size = 24
			end

			if name_replacement then
				name = name_replacement
			else
				name = ply:Name()
			end

			if name_color_replacement then
				name_color = name_color_replacement
			else
				name_color = team_GetColor(ply:Team())
			end

			line.steamid = ply:SteamID64()
		else
			line:NewLabel("*")
			name, name_color = language.console, Color(13, 130, 223)
		end

		line:NewLabel(name, name_color)
		line:NewLabel(": ")
		line:SetPlayer(ply)
		line:Parse(text, text_color)

		line.message = text
		line.DoRightClick = line_DoRightClick

		if down then
			scroll_panel:ScrollToBottom()
		end

		chat.OldAddText(Color(164, 164, 164), line.time .. " - ", name_color, name, line.text_color, ": ", text_color, text)

		return true
	end
	add_say(1, default_say)

	add_say("darkrp", function(ply, text, _, is_dead, prefix, col1, col2)
		return default_say(ply, text, false, is_dead, prefix, col1, col2 ~= color_white and col2 or nil)
	end)

	add_say("terrortown", function(ply, text, bteam, is_dead)
		if not IsValid(ply) then
			return default_say(ply, text, bteam, is_dead)
		end

		local is_spec = ply:Team() == TEAM_SPEC
		if is_spec then
			is_dead = true
		end

		if bteam and ((not is_spec and not ply:IsSpecial()) or is_spec) then
			bteam = false
		end

		local name_color
		if ply:GetTraitor() then
			name_color = Color(244, 67, 54)
		elseif ply:GetDetective() then
			name_color = Color(13, 130, 223)
		end

		return default_say(ply, text, bteam, is_dead, nil, name_color)
	end)

	scb.add_chat_say = add_say
end

local OnPlayerChat_queue = {}
hook.Add("OnPlayerChat", "SCB", function(...)
	table.insert(OnPlayerChat_queue, {n = select("#", ...), ...})
	return true
end)

local OnPlayerChat
hook.Add("HUDPaint", "SCB", function()
	chat.Open(1)

	for _, v in ipairs(AddText_queue) do
		AddText_queue = true
		chat.AddText(v)
	end
	AddText_queue = nil

	hook.Remove("OnPlayerChat", "SCB")
	OnPlayerChat = gamemodes_OnPlayerChat[engine.ActiveGamemode()] or gamemodes_OnPlayerChat[1]
	function GAMEMODE:OnPlayerChat(...)
		return OnPlayerChat(...)
	end
	for _, v in ipairs(OnPlayerChat_queue) do
		OnPlayerChat(unpack(v, 1, v.n))
	end
	OnPlayerChat_queue = nil

	chat.Close()
	hook.Remove("HUDPaint", "SCB")
end)

hook.Add("PlayerButtonDown", "SCB", function()
	local chatbox = scb.chatbox
	if chatbox and not chatbox.hidden and IsValid(chatbox) then
		chatbox.text_entry:RequestFocus()
	end
end)

-- https://github.com/ValveSoftware/source-sdk-2013/blob/0d8dceea4310fde5706b3ce1c70609d72a38efdf/mp/src/game/client/clientmode_shared.cpp#L651
timer.Simple(5, function()
	local binds = {
		messagemode = 1,
		say = 1,

		messagemode2 = 0,
		say_team = 0
	}

	local old_PlayerBindPress = GAMEMODE.PlayerBindPress
	function GAMEMODE:PlayerBindPress(ply, bind, pressed)
		if old_PlayerBindPress(self, ply, bind, pressed) == true then
			return true
		end

		local team_mode = binds[bind]
		if team_mode then
			if pressed then
				chat.Open(team_mode)
			end
			return true
		end
	end
end)

timer.Simple(5, function()
	local types = {
		namechange = 1,
		servermsg = 1,
		teamchange = 1,
		none = 1,
	}

	if not config.enable_custom_join_messages and not config.enable_custom_leave_messages then
		types.joinleave = 1
	end

	local old_ChatText = GAMEMODE.ChatText
	function GAMEMODE:ChatText(index, name, text, type, ...)
		if old_ChatText(self, index, name, text, type) == true then
			return true
		end

		if types[type] then
			chat.AddText(text)
			return true
		end

		if type == "joinleave" then
			return true
		end
	end
end)

if config.enable_custom_join_messages then
	local show_var = GetConVar("scb_joindisconnect_message")

	local printed_join = {}
	gameevent.Listen("player_connect_client")
	hook.Add("player_connect_client", "SCB.JoinMessage", function(data)
		if not show_var:GetBool() then return end

		if data.bot == 1 then
			chat.AddText((
				language.bot_joined:gsub("NAME", scb.escape(data.name))
			))
			return
		end

		local steamid = data.networkid
		if not printed_join[steamid] then
			printed_join[steamid] = true

			timer.Simple(4, function()
				printed_join[steamid] = nil
			end)

			chat.AddText((
				language.player_connecting:gsub("NAME", scb.escape(data.name)):gsub("STEAMID", data.networkid)
			))
		end
	end)
end

if config.enable_custom_leave_messages then
	local show_var = GetConVar("scb_joindisconnect_message")

	local printed_left = {}
	gameevent.Listen("player_disconnect")
	hook.Add("player_disconnect", "SCB.LeaveMessage", function(data)
		if not show_var:GetBool() then return end

		if data.bot == 1 then
			chat.AddText((
				language.bot_left:gsub("NAME", scb.escape(data.name))
			))
			return
		end

		local steamid = data.networkid
		if not printed_left[steamid] then
			printed_left[steamid] = true

			timer.Simple(4, function()
				printed_left[steamid] = nil
			end)

			chat.AddText((
				language.player_left:gsub("NAME", scb.escape(data.name)):gsub("REASON", scb.escape(data.reason)):gsub("STEAMID", data.networkid)
			))
		end
	end)
end

hook.Add("HUDShouldDraw", "SCB", function(name)
	if name == "CHudChat" then
		return false
	end
end)

net.Receive("SCB.TTTRadio", function()
	local sender = net.ReadEntity()
	local msg = net.ReadString()
	local param = net.ReadString()
	if not IsValid(sender) and sender:IsPlayer() then return end

	GAMEMODE:PlayerSentRadioCommand(sender, msg, param)

	local lang_param = LANG.GetNameParam(param)
	if lang_param then
		if lang_param == "quick_corpse_id" then
			param = LANG.GetParamTranslation(lang_param, {player = net.ReadString()})
		else
			param = LANG.GetTranslation(lang_param)
		end
	end

	local text = LANG.GetParamTranslation(msg, {player = param})

	if lang_param then
		text = util.Capitalize(text)
	end

	OnPlayerChat(sender, text, false, false)
end)

--addons/thirdperson/lua/thirdperson/client/cl_thirdperson_menu.lua:
--[[
!ThirdPerson
By Imperial Knight.
Copyright © Imperial Knight 2019: Do not redistribute.
(76561198347218024)

CLIENTSIDE FILE
]]--

function THIRDPERSON.menuThirdPerson( pl )  
    if( BackPlane ~= nil ) then
        BackPlane:Remove()
    end

    -- Font initialization & management --
    local fonts = {
        ["title"]   = "Trebuchet24",
        ["heading"] = "Trebuchet18",
        ["setting"] = "Trebuchet18",
    };

    if ( THIRDPERSON.useFonts and file.Exists( "resource/fonts/roboto-thirdperson-ad3fc.ttf", "GAME" ) ) then
        surface.CreateFont( "Roboto-Thirdperson-AD3FCUnscaled15", { font = "Roboto-Thirdperson-AD3FC", size = 15, weight = 200 } );
        surface.CreateFont( "Roboto-Thirdperson-AD3FCUnscaled17", { font = "Roboto-Thirdperson-AD3FC", size = 17, weight = 200 } );

        local RobotoUnscaled15 = "Roboto-Thirdperson-AD3FCUnscaled15";
        local RobotoUnscaled17 = "Roboto-Thirdperson-AD3FCUnscaled17";

        fonts = {
            ["title"]   = RobotoUnscaled15,
            ["heading"] = RobotoUnscaled17,
            ["setting"] = RobotoUnscaled15,
        };
    end
    -- --

    local backPlaneHeight = 570;
    local backPlaneOffset = 0.40 * ScrH();

    if ( ( backPlaneOffset + backPlaneHeight ) > ScrH() ) then
        backPlaneOffset = backPlaneOffset - (  ScrH() - ( ( ScrH() / 2 ) + backPlaneOffset ) );
    end

    BackPlane = vgui.Create( "FPanel" )
    BackPlane:Style
    {
        ["width"] = 700,
        ["height"] = backPlaneHeight,
        ["float"] = "right",
        ["top"] = backPlaneOffset,
        ["bottom"] = "10%",
        ["right"] = "5%",
        ["blur"] = 3,
        ["border"] = { 4 },
        ["border-color"] = Color( 0, 0, 0 ),
        ["background-color"] = Color( 0, 0, 0, 230 ),
        ["popup"] = true,
    }

    local TP = TP or {}

    TP.TitleBar = vgui.Create( "FTitleBar", BackPlane )
    TP.TitleBar:Style
    {
        ["width"] = "100%",
        ["height"] = "8%",
        ["background-color"] = Color( 0, 0, 0 ),
        ["content"] = "!ThirdPerson - Ayarları",
        ["font-family"] = fonts["title"]
    }

    TP.InnerPlane = vgui.Create( "FPanel", BackPlane )
    TP.InnerPlane:Style
    {
        ["width"] = "100%",
        ["height"] = "92%",
        ["margin"] = { 20 },
        ["visibility"] = "hidden",
        ["below"] = TP.TitleBar
    }
    
    TP.Area1 = vgui.Create( "FPanel", TP.InnerPlane )
    TP.Area1:Style
    {
        ["width"] = "50%",
        ["height"] = "65%",
        ["margin"] = { 0, 0, 10, 20 },
        ["border"] = { 3 },
        ["border-color"] = Color( 0, 0, 0 ),
    }

    TP.Heading1 = vgui.Create( "FLabel", TP.Area1 )
    TP.Heading1:Style
    {
        ["width"] = "100%",
        ["height"] = 50,
        ["font-family"] = fonts["heading"],
        ["content"] = "Third Person Ayarları",
        ["background-color"] = Color( 0, 0, 0, 170 ),
        ["border"] = { 3 },
        ["border-color"] = Color( 0, 0, 0 )
    }

    local bindContent;

    if ( THIRDPERSON.Setting("thirdperson_bind") ~= nil && THIRDPERSON.Setting("thirdperson_bind") ~= "none" ) then
        bindContent = "BIND: " .. THIRDPERSON.Setting("thirdperson_bind");
    else
        bindContent = "Key Bind";
    end

    TP.Setting7 = vgui.Create( "FBinder", TP.Area1 )
    TP.Setting7:Style
    {
        ["below"] = TP.Heading1,
        ["height"] = 40,
        ["width"] = 150,
        ["top"] = 12,
        ["left"] = "27%",
        ["margin"] = { 10, 0 },
        ["font-family"] = fonts["setting"],
        ["content"] = bindContent,
        ["border"] = { 3 },
        ["border-color"] = Color( 0, 0, 0, 150 ),
    }

    if not THIRDPERSON.hasPermission( pl, "thirdperson_bind" ) then
        TP.Setting7:SetDisabled( true )
    end

    function TP.Setting7:OnChange( num )
        if THIRDPERSON.hasPermission( pl, "thirdperson_bind" ) then
            RunConsoleCommand( "thirdperson_bind", input.GetKeyName( num ) );
            if ( THIRDPERSON.broadcastChat ) then
                chat.AddText( Color(80, 215, 23), "[!ThirdPerson] ", Color(255, 255, 255), "Üçüncü şahıs geçiş tuşunuz şu şekilde ayarlandı: ", Color(61, 61, 61), input.GetKeyName( num ), Color(255, 255, 255), "." );

            end
        end
    end

    TP.Setting1 = vgui.Create( "FCheckBoxLabel", TP.Area1 )
    TP.Setting1:Style
    {
        ["below"] = TP.Setting7,
        ["height"] = 20,
        ["width"] = "100%",
        ["left"] = 7,
        ["top"] = 12,
        ["margin"] = { 10, 0 },
        ["font-family"] = fonts["setting"],
        ["content"] = "!ThirdPerson Aç.",
        ["cvar"] = "thirdperson_view"
    }

    if not THIRDPERSON.hasPermission( pl, "thirdperson_view" ) then
        TP.Setting1:SetDisabled( true )
    end

    TP.Setting2 = vgui.Create( "FCheckBoxLabel", TP.Area1 )
    TP.Setting2:Style
    {
        ["below"] = TP.Setting1,
        ["height"] = 20,
        ["width"] = "100%",
        ["left"] = 7,
        ["top"] = 8,
        ["margin"] = { 10, 0 },
        ["font-family"] = fonts["setting"],
        ["content"] = "Duvar arkasi gormeyi kapatir.",
        ["cvar"] = "thirdperson_preventwallcollisions"
    }

    if not THIRDPERSON.hasPermission( pl, "thirdperson_preventwallcollisions" ) then
        TP.Setting2:SetDisabled( true )
    end

    TP.Setting3 = vgui.Create( "FCheckBoxLabel", TP.Area1 )
    TP.Setting3:Style
    {
        ["below"] = TP.Setting2,
        ["height"] = 20,
        ["width"] = "100%",
        ["left"] = 7,
        ["top"] = 8,
        ["margin"] = { 10, 0 },
        ["font-family"] = fonts["setting"],
        ["content"] = "First personda scope açmayı ayarlar.",
        ["cvar"] = "thirdperson_scoping"
    }

    if not THIRDPERSON.hasPermission( pl, "thirdperson_scoping" ) then
        TP.Setting3:SetDisabled( true )
    end

    TP.Setting4 = vgui.Create( "FCheckBoxLabel", TP.Area1 )
    TP.Setting4:Style
    {
        ["below"] = TP.Setting3,
        ["height"] = 20,
        ["width"] = "100%",
        ["left"] = 7,
        ["top"] = 8,
        ["margin"] = { 10, 0 },
        ["font-family"] = fonts["setting"],
        ["content"] = "Chrosshaire göre mermi gitmeyi düzenler.",
        ["cvar"] = "thirdperson_bulletcorrection"
    }

    if not THIRDPERSON.hasPermission( pl, "thirdperson_bulletcorrection" ) or THIRDPERSON.Setting("thirdperson_crosshair") == "None" then
        TP.Setting4:SetDisabled( true )
    end

    TP.Setting5 = vgui.Create( "FCheckBoxLabel", TP.Area1 )
    TP.Setting5:Style
    {
        ["below"] = TP.Setting4,
        ["height"] = 20,
        ["width"] = "100%",
        ["left"] = 7,
        ["top"] = 8,
        ["margin"] = { 10, 0 },
        ["font-family"] = fonts["setting"],
        ["content"] = "Bazı nesneleri birinci şahıs bakış açısında görüntüle.",
        ["cvar"] = "thirdperson_entityview",
    }

    if not THIRDPERSON.hasPermission( pl, "thirdperson_entityview" ) then
        TP.Setting5:SetDisabled( true )
    end
    
    TP.Setting6 = vgui.Create( "FButton", TP.Area1 )
    TP.Setting6:Style
    {
        ["height"] = 25,
        ["right"] = 10,
        ["top"] = 12,
        ["float"] = "right",
        ["below"] = TP.Setting5,
        ["content"] = "Ayarları Sıfırla",
        ["border"] = { 3 },
        ["border-color"] = Color( 0, 0, 0, 150 )
    }

    TP.Setting6.DoClick = function()
        RunConsoleCommand( "thirdperson_reset", "all" )
        timer.Simple( .1, function() THIRDPERSON.menuThirdPerson( pl ) end )
    end

    TP.Area2 = vgui.Create( "FPanel", TP.InnerPlane )
    TP.Area2:Style
    {
        ["width"] = "50%",
        ["height"] = "50%",
        ["after"] = TP.Area1,
        ["margin"] = { 10, 0, 0, 20 },
        ["border"] = { 3 },
        ["border-color"] = Color( 0, 0, 0 ),
    }

    TP.Heading2 = vgui.Create( "FLabel", TP.Area2 )
    TP.Heading2:Style
    {
        ["width"] = "100%",
        ["height"] = 50,
        ["font-family"] = fonts["heading"],
        ["content"] = "Görüş Açısı",
        ["background-color"] = Color( 0, 0, 0, 170 ),
        ["border"] = { 3 },
        ["border-color"] = Color( 0, 0, 0 ),
    }

    TP.AngleBox = vgui.Create( "FPointMapper", TP.Area2 )
    TP.AngleBox:Style
    {
        ["width"] = "88%",
        ["height"] = "100%",
        ["margin"] = { 10, 10, 5, 60 },
        ["background-color"] = Color( 255, 255, 255, 3 ),
        ["below"] = TP.Heading2,
        ["border"] = { 1 },
        ["knob"] = { TP.AngleBox:ConvertX( THIRDPERSON.Setting("thirdperson_horizontalview"), 0, 1, -50, 50 ), TP.AngleBox:ConvertY( THIRDPERSON.Setting("thirdperson_verticalview"), 1, 0, -50, 50 ) } 
    }

    if not THIRDPERSON.hasPermission( pl, "thirdperson_viewangles" ) then
        TP.AngleBox:SetLockX( TP.AngleBox:ConvertX( THIRDPERSON.Setting("thirdperson_horizontalview"), 0, 1, -50, 50 ) );
        TP.AngleBox:SetLockY( TP.AngleBox:ConvertY( THIRDPERSON.Setting("thirdperson_verticalview"), 1, 0, -50, 50 ) );
    else
        TP.AngleBox.Think = function()
            if( TP.AngleBox:GetDragging() ) then
                local Horizontal = TP.AngleBox:ConvertX( "knob", -50, 50, 0, TP.AngleBox:GetWide() )
                local Vertical = TP.AngleBox:ConvertY( "knob", 50, -50, 0, TP.AngleBox:GetTall() )
                RunConsoleCommand( "thirdperson_horizontalview", Horizontal )
                RunConsoleCommand( "thirdperson_verticalview", Vertical )
            end
        end
    end

    TP.AngleSliderBox = vgui.Create( "FPanel", TP.Area2 )
    TP.AngleSliderBox:Style
    {
        ["width"] = "12%",
        ["height"] = "100%",
        ["margin"] = { 5, 10, 10, 60 },
        ["background-color"] = Color( 255, 255, 255, 5 ),
        ["after"] = TP.AngleBox,
        ["below"] = TP.Heading2,
        ["border"] = { 1 },
        ["border-color"] = Color( 0, 0, 0 )
    }

    TP.DistanceSlider = vgui.Create( "FSlider", TP.AngleSliderBox )
    TP.DistanceSlider:Style
    {
        ["width"] = "100%",
        ["height"] = "100%",
        ["visibility"] = "hidden",
        ["margin"] = { 2, 15, 0, 15 },
        ["border-color"] = Color( 0, 0, 0, 100 ),
        ["x-axis"] = 0.5,
        ["noclip"] = true,
        ["vbar"] = true,
        ["knob"] = { 0.5, TP.DistanceSlider:ConvertY( THIRDPERSON.Setting("thirdperson_distance"), 0, 1, 0, THIRDPERSON.maxDistance ) }
    }

    if not THIRDPERSON.hasPermission( pl, "thirdperson_distance" ) then
        TP.DistanceSlider:SetLockY( TP.DistanceSlider:ConvertY( THIRDPERSON.Setting("thirdperson_distance"), 0, 1, 0, THIRDPERSON.maxDistance ) );
    else
        TP.DistanceSlider.Think = function()
            if( TP.DistanceSlider:GetDragging() == true ) then
                local Vertical = TP.DistanceSlider:ConvertY( "knob", 0, THIRDPERSON.maxDistance, 0, TP.DistanceSlider:GetTall() )
                RunConsoleCommand( "thirdperson_distance", Vertical )
            end
        end
    end

    if not THIRDPERSON.hasPermission( pl, "thirdperson_viewangles" ) and not THIRDPERSON.hasPermission( pl, "thirdperson_distance" ) then
        TP.Area2:SetDisabled( true );
    end

    TP.Area3 = vgui.Create( "FPanel", TP.InnerPlane )
    TP.Area3:Style
    {
        ["width"] = "50%",
        ["height"] = "35%",
        ["below"] = TP.Area1,
        ["margin"] = { 0, 0, 10, 0 },
        ["border"] = { 3 },
        ["border-color"] = Color( 0, 0, 0 ),
    }

    TP.Heading3 = vgui.Create( "FLabel", TP.Area3 )
    TP.Heading3:Style
    {
        ["width"] = "100%",
        ["height"] = 50,
        ["font-family"] = fonts["heading"],
        ["content"] = "Crosshair Seç",
        ["background-color"] = Color( 0, 0, 0, 170 ),
        ["border"] = { 3 },
        ["border-color"] = Color( 0, 0, 0 ),
    }

    TP.Area4 = vgui.Create( "FPanel", TP.InnerPlane )
    TP.Area4:Style
    {
        ["width"] = "50%",
        ["height"] = "50%",
        ["after"] = TP.Area1,
        ["below"] = TP.Area2,
        ["margin"] = { 10, 0, 0, 0 },
        ["border"] = { 3 },
        ["border-color"] = Color( 0, 0, 0 ),
    }

    TP.Heading4 = vgui.Create( "FLabel", TP.Area4 )
    TP.Heading4:Style
    {
        ["width"] = "100%",
        ["height"] = 50,
        ["font-family"] = fonts["heading"],
        ["content"] = "Crosshair Renk",
        ["background-color"] = Color( 0, 0, 0, 170 ),
        ["border"] = { 3 },
        ["border-color"] = Color( 0, 0, 0 ),
    }


    TP.Area4ColorMixer = vgui.Create( "FColorMixer", TP.Area4 )
    TP.Area4ColorMixer:Style
    {
        ["height"] = "100%",
        ["width"] = "100%",
        ["margin"] = { 10, 10, 10, 60 },
        ["below"] = TP.Heading3
    }

    TP.CrossHair1 = vgui.Create( "FButton", TP.Area3 )
    TP.CrossHair1:Style
    {
        ["height"] = 38,
        ["width"] = 38,
        ["below"] = TP.Heading3,
        ["left"] = 15,
        ["top"] = 9,
        ["content"] = ""
    }
    
    local SelectedCrosshair = 0
    local thirdperson_crosshair = THIRDPERSON.Setting("thirdperson_crosshair")

    TP.CrossHair1.Paint = function( self, w, h )
        // Button
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawBox{ ["color"] = Color( 0, 0, 0, 150 ), ["x"] = 0, ["y"] = 0, ["width"] = w, ["height"] = h }
    
        // Crosshair
        FERMA.CORE.DrawHorizontalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = w / 2, ["y"] = h / 2, ["thickness"] = 1, ["length"] = 1 }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 10, ["y"] = 19, ["thickness"] = 1, ["length"] = 4 }
        FERMA.CORE.DrawVerticalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 19, ["y"] = 10, ["thickness"] = 1, ["length"] = 4 }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 24, ["y"] = 19, ["thickness"] = 1, ["length"] = 4 }
        FERMA.CORE.DrawVerticalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 19, ["y"] = 24, ["thickness"] = 1, ["length"] = 4 }
    
        if( self:IsHovered() ) then
            FERMA.CORE.DrawBox{ ["color"] = Color( 255, 255, 255, 10 ), ["x"] = 3, ["y"] = 3, ["width"] = w - 6, ["height"] = h - 6 }
        end

        if( SelectedCrosshair == 1 or thirdperson_crosshair == "1" ) then
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        end
    end

    TP.CrossHair1.DoClick = function( self, w, h )
        SelectedCrosshair = 1
        TP.Setting4:SetDisabled( false );
        RunConsoleCommand( "thirdperson_crosshair", "1" );
    end

    TP.CrossHair2 = vgui.Create( "FButton", TP.Area3 )
    TP.CrossHair2:Style
    {
        ["height"] = 38,
        ["width"] = 38,
        ["below"] = TP.Heading3,
        ["after"] = TP.CrossHair1,
        ["left"] = 12,
        ["top"] = 9,
        ["content"] = ""
    }

    TP.CrossHair2.Paint = function( self, w, h )
        // Button
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawBox{ ["color"] = Color( 0, 0, 0, 150 ), ["x"] = 0, ["y"] = 0, ["width"] = w, ["height"] = h }
    
        // Crosshair
        draw.RoundedBox( 2, w / 2 - 2, h / 2 - 2, 4, 4, TP.Area4ColorMixer:GetColor() )
    
        if( self:IsHovered() ) then
            FERMA.CORE.DrawBox{ ["color"] = Color( 255, 255, 255, 10 ), ["x"] = 3, ["y"] = 3, ["width"] = w - 6, ["height"] = h - 6 }
        end
            
        if( SelectedCrosshair == 2 or thirdperson_crosshair == "2") then
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        end
    end

    TP.CrossHair2.DoClick = function( self, w, h )
        SelectedCrosshair = 2
        TP.Setting4:SetDisabled( false );
        RunConsoleCommand( "thirdperson_crosshair", "2" );
    end

    TP.CrossHair3 = vgui.Create( "FButton", TP.Area3 )
    TP.CrossHair3:Style
    {
        ["height"] = 38,
        ["width"] = 38,
        ["below"] = TP.Heading3,
        ["after"] = TP.CrossHair2,
        ["left"] = 12,
        ["top"] = 9,
        ["content"] = ""
    }

    TP.CrossHair3.Paint = function( self, w, h )
        // Button                                                                                                                                // 76561198347218024
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawBox{ ["color"] = Color( 0, 0, 0, 150 ), ["x"] = 0, ["y"] = 0, ["width"] = w, ["height"] = h }

        // Crosshair
        FERMA.CORE.DrawHorizontalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 10, ["y"] = 19, ["thickness"] = 1, ["length"] = 18 }
        FERMA.CORE.DrawVerticalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 19, ["y"] = 10, ["thickness"] = 1, ["length"] = 18 }
    
        if( self:IsHovered() ) then
            FERMA.CORE.DrawBox{ ["color"] = Color( 255, 255, 255, 10 ), ["x"] = 3, ["y"] = 3, ["width"] = w - 6, ["height"] = h - 6 }
        end

        if( SelectedCrosshair == 3 or thirdperson_crosshair == "3" ) then
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        end
    end

    TP.CrossHair3.DoClick = function( self, w, h )
        SelectedCrosshair = 3
        TP.Setting4:SetDisabled( false );
        RunConsoleCommand( "thirdperson_crosshair", "3" );
    end

    TP.CrossHair4 = vgui.Create( "FButton", TP.Area3 )
    TP.CrossHair4:Style
    {
        ["height"] = 38,
        ["width"] = 38,
        ["below"] = TP.Heading3,
        ["after"] = TP.CrossHair3,
        ["left"] = 12,
        ["top"] = 9,
        ["content"] = ""
    }

    TP.CrossHair4.Paint = function( self, w, h )
        // Button
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawBox{ ["color"] = Color( 0, 0, 0, 150 ), ["x"] = 0, ["y"] = 0, ["width"] = w, ["height"] = h }

        // Crosshair
        FERMA.CORE.DrawHorizontalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 10, ["y"] = 19, ["thickness"] = 1, ["length"] = 5 }
        FERMA.CORE.DrawVerticalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 19, ["y"] = 10, ["thickness"] = 1, ["length"] = 5 }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 23, ["y"] = 19, ["thickness"] = 1, ["length"] = 5 }
        FERMA.CORE.DrawVerticalLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 19, ["y"] = 23, ["thickness"] = 1, ["length"] = 5 }
    
        if( self:IsHovered() ) then
            FERMA.CORE.DrawBox{ ["color"] = Color( 255, 255, 255, 10 ), ["x"] = 3, ["y"] = 3, ["width"] = w - 6, ["height"] = h - 6 }
        end

        if( SelectedCrosshair == 4 or thirdperson_crosshair == "4" ) then
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        end
    end

    TP.CrossHair4.DoClick = function( self, w, h )
        SelectedCrosshair = 4
        TP.Setting4:SetDisabled( false );
        RunConsoleCommand( "thirdperson_crosshair", "4" );
    end

    TP.CrossHair5 = vgui.Create( "FButton", TP.Area3 )
    TP.CrossHair5:Style
    {
        ["height"] = 38,
        ["width"] = 38,
        ["below"] = TP.Heading3,
        ["after"] = TP.CrossHair4,
        ["left"] = 12,
        ["top"] = 9,
        ["content"] = ""
    }

    TP.CrossHair5.Paint = function( self, w, h )
        // Button
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawBox{ ["color"] = Color( 0, 0, 0, 150 ), ["x"] = 0, ["y"] = 0, ["width"] = w, ["height"] = h }

        // Crosshair
        FERMA.CORE.DrawLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 10, ["y"] = 28, ["end-x"] = 28, ["end-y"] = 10 }
        FERMA.CORE.DrawLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 10, ["y"] = 10, ["end-x"] = 28, ["end-y"] = 28 }
    
        if( self:IsHovered() ) then
            FERMA.CORE.DrawBox{ ["color"] = Color( 255, 255, 255, 10 ), ["x"] = 3, ["y"] = 3, ["width"] = w - 6, ["height"] = h - 6 }
        end

        if( SelectedCrosshair == 5 or thirdperson_crosshair == "5" ) then
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        end
    end

    -- 76561221774735761

    TP.CrossHair5.DoClick = function( self, w, h )
        SelectedCrosshair = 5
        TP.Setting4:SetDisabled( false );
        RunConsoleCommand( "thirdperson_crosshair", "5" );
    end

    TP.CrossHair6 = vgui.Create( "FButton", TP.Area3 )
    TP.CrossHair6:Style
    {
        ["height"] = 38,
        ["width"] = 38,
        ["below"] = TP.Heading3,
        ["after"] = TP.CrossHair5,
        ["left"] = 12,
        ["top"] = 9,
        ["content"] = ""
    }

    TP.CrossHair6.Paint = function( self, w, h )
        // Button
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawBox{ ["color"] = Color( 0, 0, 0, 150 ), ["x"] = 0, ["y"] = 0, ["width"] = w, ["height"] = h }

        // Crosshair
        FERMA.CORE.DrawLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 10, ["y"] = 28, ["end-x"] = 17, ["end-y"] = 22 }
        FERMA.CORE.DrawLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 10, ["y"] = 10, ["end-x"] = 17, ["end-y"] = 16 }
        FERMA.CORE.DrawLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 21, ["y"] = 16, ["end-x"] = 28, ["end-y"] = 10 }
        FERMA.CORE.DrawLine{ ["color"] = TP.Area4ColorMixer:GetColor(), ["x"] = 21, ["y"] = 22, ["end-x"] = 28, ["end-y"] = 28 }
    
        if( self:IsHovered() ) then
            FERMA.CORE.DrawBox{ ["color"] = Color( 255, 255, 255, 10 ), ["x"] = 3, ["y"] = 3, ["width"] = w - 6, ["height"] = h - 6 }
        end

        if( SelectedCrosshair == 6 or thirdperson_crosshair == "6" ) then
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        end
    end

    TP.CrossHair6.DoClick = function( self, w, h )
        SelectedCrosshair = 6
        TP.Setting4:SetDisabled( false );
        RunConsoleCommand( "thirdperson_crosshair", "6" );
    end

    TP.CrossHairDefault = vgui.Create( "FButton", TP.Area3 )
    TP.CrossHairDefault:Style
    {
        ["height"] = 30,
        ["width"] = "30%",
        ["below"] = TP.Heading3,
        ["left"] = "35%",
        ["top"] = "40%",
        ["content"] = "Varsayılan",
        ["font-family"] = fonts["setting"]
    }

    TP.CrossHairDefault.Paint = function( self, w, h )
        // Button
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 0, 0, 0 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        FERMA.CORE.DrawBox{ ["color"] = Color( 0, 0, 0, 150 ), ["x"] = 0, ["y"] = 0, ["width"] = w, ["height"] = h }
    
        if( self:IsHovered() ) then
            FERMA.CORE.DrawBox{ ["color"] = Color( 255, 255, 255, 10 ), ["x"] = 3, ["y"] = 3, ["width"] = w - 6, ["height"] = h - 6 }
        end

        if( SelectedCrosshair == "None" or thirdperson_crosshair == "None" ) then
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 0, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawVerticalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = w - 3, ["y"] = 0, ["thickness"] = 3, ["length"] = h }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = 0, ["thickness"] = 3, ["length"] = w - 3 }
            FERMA.CORE.DrawHorizontalLine{ ["color"] = Color( 30, 30, 30 ), ["x"] = 3, ["y"] = h - 3, ["thickness"] = 3, ["length"] = w - 3 }
        end
    end

    TP.CrossHairDefault.DoClick = function( self, w, h )
        SelectedCrosshair = "None"
        TP.Setting4:SetDisabled( true );
        RunConsoleCommand( "thirdperson_crosshair", "None" );
    end

    TP.Area4ColorMixer:SetConVarR( "thirdperson_crosshair_color_r" )
    TP.Area4ColorMixer:SetConVarG( "thirdperson_crosshair_color_g" )
    TP.Area4ColorMixer:SetConVarB( "thirdperson_crosshair_color_b" )
    TP.Area4ColorMixer:SetConVarA( "thirdperson_crosshair_color_a" )

    if not THIRDPERSON.hasPermission( pl, "thirdperson_crosshair" ) then
        TP.Area3:SetDisabled( true )
    end

    if not THIRDPERSON.hasPermission( pl, "thirdperson_crosshaircolor" ) then
        TP.Area4:SetDisabled( true )
        TP.Area4ColorMixer:SetDisabled( true )
    end
end

concommand.Add( "thirdperson_menu", THIRDPERSON.menuThirdPerson )  -- ConCommand. Changing this *will* break the addon.
--addons/bb_simpsit/lua/simp_sit/config/sh_config.lua:
-- Enable debug info.
-- This includes a bunch of trace lines when 'developer 1' is enabled, some prints for both server and client, and the seat not getting set invisible.
SIMPSit.Config.Debug = false

-- The max distance someone can be from the point they want to sit
SIMPSit.Config.MaxDistance = 10000

-- The max pitch (slant) angle you can sit on.
SIMPSit.Config.MaxPitch = 10

-- The buffer around the position to build the circle to calculate the facing angle
SIMPSit.Config.CircleBuffer = 15

-- How far away from the ideal leave location before it becomes invalid
SIMPSit.Config.MaxIdealLeaveDistance = 50000

-- The keys that need to be pressed in order to trigger a sit attempt: https://wiki.facepunch.com/gmod/Enums/KEY
SIMPSit.Config.ButtonsToSit = {
	KEY_LALT,
	KEY_E
}
--lua/autorun/skipperplayer.lua:
return gluapack()()
--lua/slib/sh_util.lua:
slib = slib or {}
slib.panels = slib.panels or {}
slib.cachedAvatars = slib.cachedAvatars or {}
slib.generalCooldowns = slib.generalCooldowns or {}

slib.config = {scale = {x = 1, y = 1}}

slib.getStatement = function(val)
    if isbool(val) then return "bool" end
    if isnumber(val) then return "int" end
    if istable(val) and val.r and val.g and val.b then return "color" end
    if istable(val) then return "table" end
    if isfunction(val) then return "function" end
    if isstring(val) then return "string" end

    return "bool"
end

local callNum = 1
local loadedCalls = {}

local function loadFile(folder, file)
    if string.StartWith(file, "sv_") or string.find(folder, "server") then
        if SERVER then
            include(folder .. file)
            loaded = true
        end
    elseif string.StartWith(file, "sh_") or string.find(folder, "shared") then
        AddCSLuaFile(folder .. file)
        include(folder .. file)
        loaded = true
    elseif string.StartWith(file, "cl_") or string.find(folder, "client") then
        AddCSLuaFile(folder .. file)
        if CLIENT then include(folder .. file) loaded = true end
    end

    if loaded then
        print("[slib] Loaded "..folder..file)

        return folder..file
    end
end

slib.loadFolder = function(folder, subdirectories, firstload, lastload, call)
    local files, directories = file.Find(folder .. "*", "LUA")
    loadedCalls[callNum] = loadedCalls[callNum] or {}

    if firstload then
        for k,v in pairs(firstload) do
            local result = loadFile(v[1], v[2])
            if !result then continue end
            loadedCalls[callNum][result] = true
        end
    end

    if lastload then
        for k,v in pairs(lastload) do
            loadedCalls[callNum][v[1]..v[2]] = true
        end
    end

    for k, v in pairs(files) do
        if loadedCalls[callNum][folder..v] then continue end
        loadFile(folder, v)
    end

    if subdirectories then
        for k,v in pairs(directories) do
            slib.loadFolder(folder..v.."/", true, nil, nil, call and call or callNum)
        end
    end

    if lastload then
        for k,v in pairs(lastload) do
            loadFile(v[1], v[2])
        end
    end

    if call then return end
    callNum = callNum + 1
end

slib.getCooldown = function(var)
    if !slib.generalCooldowns[var] then return true end
    
    return slib.generalCooldowns[var] and CurTime() >= slib.generalCooldowns[var]
end

slib.getTimeLeft = function(var)
    return slib.generalCooldowns[var] and slib.generalCooldowns[var] - CurTime() or 0
end

slib.setCooldown = function(var, cd)
    slib.generalCooldowns[var] = CurTime() + cd
end

slib.oldFunctions = {}

slib.wrapFunction = function(element, funcname, pre, post, returnresult)
    if !slib.oldFunctions[funcname.."Old"] then
        slib.oldFunctions[funcname.."Old"] = element[funcname]
    end

    element[funcname] = function(...)
        local result 
        
        if pre then
            local callback = pre(...)
            result = returnresult and callback or result
        end

        if isfunction(slib.oldFunctions[funcname.."Old"]) then
            result = slib.oldFunctions[funcname.."Old"](...) or result
        end 

        if post then
            local callback = post(...)
            result = returnresult and callback or result
        end

        return result
    end
end

slib.lang = slib.lang or {}

slib.setLang = function(addon, lang, id, str)
    slib.lang[addon] = slib.lang[addon] or {}
    slib.lang[addon][lang] = slib.lang[addon][lang] or {}

    slib.lang[addon][lang][id] = str
end

slib.getLang = function(addon, lang, id, ...)
    local args = {...}
    local unformatted = slib.lang[addon] and slib.lang[addon][lang] and slib.lang[addon][lang][id]

    if !unformatted then unformatted = slib.lang[addon] and slib.lang[addon]["en"] and slib.lang[addon]["en"][id] or id end

    return table.IsEmpty(args) and unformatted or string.format(unformatted, ...)
end

slib.notify = function(str, ply)
    str = tostring(str)
    if SERVER then
        net.Start("slib.msg")
        net.WriteString(str)
        net.Send(ply)
    elseif CLIENT then
        print(str)
        notification.AddLegacy(str, 0, 5)
    end
end

local function differenciate(a, b)
    if !(isstring(a) == isstring(b)) or isbool(a) or isbool(b) then
        return tostring(a), tostring(b)
    end

    return a, b
end

slib.sortAlphabeticallyByKeyValues = function(tbl, ascending)
    local normaltable = {}
    local cleantable = {}
    
    for k,v in pairs(tbl) do
        table.insert(normaltable, k)
    end

    if ascending then
        table.sort(normaltable, function(a, b) a, b = differenciate(a, b) return a < b end)
    else
        table.sort(normaltable, function(a, b) a, b = differenciate(a, b) return a > b end)
    end

    for k,v in pairs(normaltable) do
        cleantable[v] = k
    end

    return cleantable
end

slib.sortAlphabeticallyByValue = function(tbl, ascending, keyvalue)
    if keyvalue then
        tbl = table.Copy(tbl)
    end

    if ascending then
        table.sort(tbl, function(a, b) a, b = differenciate(a, b) return a < b end)
    else
        table.sort(tbl, function(a, b) a, b = differenciate(a, b) return a > b end)
    end

    local cleantable = {}

    for k, v in pairs(tbl) do
        cleantable[v] = k
    end

    return keyvalue and cleantable or tbl
end

slib.sid64ToPly = slib.sid64ToPly or {}

if SERVER then
    slib.playerCache = slib.playerCache or player.GetAll()

    util.AddNetworkString("slib.msg")

    local punished = {}
    slib.punish = function(ply, type, msg, duration)
        local sid = ply:SteamID()

        if punished[sid] then return end
        punished[sid] = true

        if type == 1 then
            ply:Kick(msg)
        elseif type == 2 then
            if duration == nil then duration = 0 end
            if sAdmin then
                RunConsoleCommand("sa","banid", ply:SteamID64(), duration, msg)
            elseif ULib then
                ULib.ban(ply, duration, msg)
            elseif sam then
                RunConsoleCommand("sam","banid", sid, duration, msg)
            elseif xAdmin then
                if xAdmin.Config then
                    if xAdmin.Config.MajorVersion == 1 then
                        RunConsoleCommand("xadmin_ban", sid, duration, msg)
                    else
                        RunConsoleCommand("xadmin","ban", sid, duration, msg)
                    end
                end
            elseif SERVERGUARD then
                RunConsoleCommand("serverguard","ban", sid, duration, msg)
            else
                ply:Ban(duration, true)
            end
        end
    end

    slib.isBanned = function(sid64, callback)
        local sid32 = util.SteamIDFrom64(sid64)

        if sAdmin and sAdmin.isBanned then
            return sAdmin.isBanned(sid64)
        elseif sam and sam.player and sam.player.is_banned then
            return sam.player.is_banned(sid32, callback)
        elseif ulx and ULib and ULib.bans then
            return tobool(ULib.bans[sid32])
        elseif xAdmin and xAdmin.Admin and xAdmin.Admin.Bans then
            local data = xAdmin.Admin.Bans[sid64]
            local endtime = data.StartTime + (data.Length * 60)

            return data and (tonumber(endtime) <= os.time()) or false
        end
    end

    slib.setRank = function(ply, rank)
        local sid64 = ply:SteamID64()

        if sAdmin then
            RunConsoleCommand("sa", "setrankid", sid64, rank)
        elseif sam then
            RunConsoleCommand("sam", "setrankid", sid64, rank)
        elseif ulx then
            RunConsoleCommand("ulx", "adduserid", ply:SteamID(), rank)
        elseif xAdmin then
            RunConsoleCommand("xadmin", "setgroup", ply:Nick(), rank) -- yes
        end
    end

    hook.Add("PlayerInitialSpawn", "slib.reconnected", function(ply)
        local sid = ply:SteamID()
        if punished[sid] then
            punished[sid] = nil
        end
    end)

    hook.Add("PlayerInitialSpawn", "slib.FullLoaded", function( ply )
        table.insert(slib.playerCache, ply)
        local sid64 = ply:SteamID64()
        slib.sid64ToPly[sid64] = ply

        local id = sid64.."_slib"
        hook.Add( "SetupMove", id, function( self, mv, cmd )
            if self == ply and not cmd:IsForced() then
                hook.Run("slib.FullLoaded", ply)
                hook.Remove("SetupMove", id)
            end
        end )
    end)

    hook.Add("PlayerDisconnected", "slib.handleDisconnect", function(ply)
        table.RemoveByValue(slib.playerCache, ply)
    end)
end

if CLIENT then
    local blur = Material("pp/blurscreen")

    slib.DrawBlur = function(panel, amount)
        local x, y = panel:LocalToScreen(0, 0)
        local scrW, scrH = ScrW(), ScrH()
        surface.SetDrawColor(255, 255, 255)
        surface.SetMaterial(blur)
        for i = 1, 3 do
            blur:SetFloat("$blur", (i / 3) * (amount or 6))
            blur:Recompute()
            render.UpdateScreenEffectTexture()
            surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
        end
    end

    slib.getScaledSize = function(num, axis, scale)
        scale = scale or {x = 1, y = 1}

        if axis == "x" then
            num = ScrW() * (num/1920)

            num = num * scale.x
        end
    
        if axis == "y" or axis == nil then
            num = ScrH() * (num/1080)

            num = num * scale.y
        end
        
        return math.Round(num)
    end

    slib.cachedFonts = slib.cachedFonts or {}

    slib.createFont = function(fontname, size, thickness, ignorescale)
        size = size or 13
        thickness = thickness or 500
        local identifier = string.gsub(fontname, " ", "_")

        if !fontname or !size or !thickness then return end

        local name = "slib."..identifier..size.."."..thickness
        
        if ignorescale then name = "real_"..name end
        
        if slib.cachedFonts[name] then return name end

        surface.CreateFont( name, {
            font = fontname,
            size = ignorescale and size or slib.getScaledSize(size, "y"),
            weight = thickness,
        })

        slib.cachedFonts[name] = true

        return name
    end

    slib.colorCached = {}

    slib.lerpColor = function(identifier, wantedcolor, multiplier, nolerp)
        wantedcolor = table.Copy(wantedcolor)
        slib.colorCached[identifier] = slib.colorCached[identifier] or wantedcolor
        multiplier = multiplier or 1
        local basespeed = (RealFrameTime() * 3)
        local speed = basespeed * multiplier

        if minspeed then speed = minspeed > speed and minspeed or speed end
        
        for k,v in pairs(slib.colorCached[identifier]) do
            local percentageleft = math.abs(wantedcolor[k] - v)

            slib.colorCached[identifier][k] = math.Approach(v, wantedcolor[k], speed * (nolerp and 100 or percentageleft))
        end

        return slib.colorCached[identifier]
    end

    slib.numCached = {}
    slib.lerpNum = function(identifier, wantednum, multiplier, nolerp)
        slib.numCached[identifier] = slib.numCached[identifier] or wantednum
        multiplier = multiplier or 1
        local basespeed = (RealFrameTime() * 3)
        local speed = basespeed * multiplier

        local percentageleft = math.abs(wantednum - slib.numCached[identifier])

        slib.numCached[identifier] = math.Approach(slib.numCached[identifier], wantednum, speed * (nolerp and 100 or percentageleft))

        return math.Round(slib.numCached[identifier])
    end

    slib.drawTooltip = function(str, parent, align)
        local font = slib.createFont("Roboto", 13)
        local cursortposx, cursortposy = input.GetCursorPos()
        cursortposx = cursortposx + 15
        local x, y = cursortposx, cursortposy
       
        surface.SetFont(font)
        local strw, strh = surface.GetTextSize(str)
       
        local w = strw + slib.getScaledSize(6, "x")

        if align == 1 then
            local parentparent = parent:GetParent()
            if !IsValid(parentparent) then return end
            local posx, posy = parent:GetPos()
            x, y = parentparent:LocalToScreen(posx, posy)
            y = y + parent:GetTall()

            x = x + parent:GetWide() * .5

            x = x - w * .5
        end

        local tooltip = vgui.Create("EditablePanel")
        tooltip:SetMouseInputEnabled(false)
        tooltip:SetPos(x, y)
        tooltip:SetSize(w, slib.getScaledSize(22, "y"))
        tooltip:MakePopup()
    
        tooltip.Paint = function(s,w,h)
            if !parent:IsHovered() and !s:IsHovered() or !s:HasFocus() and !parent.clickable then s:Remove() end
    
            surface.SetDrawColor(slib.getTheme("maincolor", 10))
            surface.DrawRect(0, 0, w, h)
    
            surface.SetDrawColor(120, 120, 120, 200)
            surface.DrawOutlinedRect(0, 0, w, h)
    
            draw.SimpleText(str, font, slib.getScaledSize(3, "x"), h * .5, slib.getTheme("textcolor"), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        return tooltip
    end

    slib.createTooltip = function(str, parent)
        if !str or !parent then return end

        surface.SetFont(parent.font)
        local textw, texth = surface.GetTextSize(parent.name)


        local tooltipbutton = vgui.Create("DButton", parent)
		tooltipbutton:SetText("")
		tooltipbutton:Dock(LEFT)
		tooltipbutton:DockMargin(textw + slib.getScaledSize(6,"x"),slib.getScaledSize(5,"x"),0,slib.getScaledSize(5,"x"))
        tooltipbutton:SetWide(slib.getScaledSize(25, "y") - (slib.getScaledSize(5,"x") + slib.getScaledSize(5,"x")))
        tooltipbutton.bg = slib.getTheme("maincolor")
        
        tooltipbutton.DoClick = function()
            tooltipbutton.clicked = !tooltipbutton.clicked
        end

		tooltipbutton.Paint = function(s,w,h)
            draw.RoundedBox(h * .5, 0, 0, w, h, s.bg)

			draw.SimpleText("?", slib.createFont("Roboto", 14), w * .5, h * .5, slib.getTheme("textcolor", -50), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            if s.clickable and !s.clicked and IsValid(s.tooltip) then
                s.tooltip:Remove()
            end

            if s:IsHovered() then
                if IsValid(s.tooltip) then return end
                s.tooltip = slib.drawTooltip(str, tooltipbutton)
            else
                s.clicked = nil
			end
        end
        
        return tooltipbutton
    end

    slib.theme = slib.theme or {}

    slib.setTheme = function(var, val)
        slib.theme[var] = val
    end

    slib.getTheme = function(var, offset)
        local val = slib.theme[var]

        if istable(val) then
            val = table.Copy(val)
            
            if offset then
                for k,v in pairs(val) do
                    val[k] = v + offset
                end

                if val.r and val.g and val.b and val.a then
                    for k,v in pairs(val) do
                        val[k] = math.Clamp(v, 0, 255)
                    end
                end
            end 
        end

        return val
    end

    slib.isValidSID64 = function(sid64)
        return util.SteamIDFrom64(sid64) != "STEAM_0:0:0"
    end

    local loading_ico = Material("slib/load.png", "smooth")

    local matCache = {}
    local fetched = {}
    
    file.CreateDir("slib")
    
    local proxy = ""--"https://proxy.duckduckgo.com/iu/?u=" -- Disabled for now, it doesn't work
    slib.ImgurGetMaterial = function(id) -- RETURN THE LOADING MATERIAL UNTIL IT IS FOUND!!!
        if !matCache[id] then
            local link = proxy.."https://i.imgur.com/"..id..".png"

            if file.Exists("slib/"..id..".png", "DATA") then
                matCache[id] = Material("data/slib/"..id..".png", "noclamp smooth")

                if matCache[id]:IsError() then
                    file.Delete("slib/"..id..".png")

                    if !fetched[link] then
                        slib.ImgurGetMaterial(id)
                    end
                end
            else
                if fetched[link] then return loading_ico, true end
                
                fetched[link] = true
                
                http.Fetch(link,
                    function(body)
                        file.Write("slib/"..id..".png", body)
                        matCache[id] = Material("data/slib/"..id..".png", "noclamp smooth")
                    end
                )
            end
        else
            return matCache[id]
        end
        
        return loading_ico, true
    end

    local cachedNames = {}
    local requestedNames = {}

    slib.findName = function(sid64, rtrn_sid64)
        if cachedNames[sid64] then return cachedNames[sid64] end

        local servercheck = player.GetBySteamID64(sid64)
        local steamcheck = false

        if servercheck then
            cachedNames[sid64] = servercheck:Nick()
        else
            if requestedNames[sid64] then return rtrn_sid64 and sid64 end
            requestedNames[sid64] = true
            local start = "<title>Steam Community :: "
            local theEnd = '<link rel="shortcut icon" href="/favicon.ico" type="image/'

            http.Fetch("http://steamcommunity.com/profiles/"..sid64,
                function(data)
                    local nameStart = select(1, string.find(data, start))
                    local nameEnd = select(1, string.find(data, theEnd))

                    if !nameStart or !nameEnd then return end

                    nameStart = nameStart + #start
                    nameEnd = nameEnd - 12

                    local nick = string.sub(data, nameStart, nameEnd)

                    cachedNames[sid64] = nick
                end
            )

            if !rtrn_sid64 then
                cachedNames[sid64] = "N/A"
            end
        end

        return rtrn_sid64 and sid64 or cachedNames[sid64]
    end

    local function saveImageFromURL(url, path, cb)
        http.Fetch(url, function(data)
            file.Write(path, data)

            if cb then
                cb()
            end
        end)
    end

    local fetchingAvatar = {}
    local default_ico = Material("slib/default_steam.png", "smooth")

    slib.findAvatar = function(sid64, medium)
        if !sid64 then return end
        
        local path = "slib/avatars/"..sid64..(medium and "_medium" or "_full")..".jpg"
        local size = medium and "medium" or "full"

        slib.cachedAvatars[size] = slib.cachedAvatars[size] or {}

        if !slib.cachedAvatars[size][sid64] or slib.cachedAvatars[size][sid64]:IsError() then
            if file.Exists(path, "DATA") then
                slib.cachedAvatars[size][sid64] = Material("data/"..path, "smooth noclamp")

                return slib.cachedAvatars[size][sid64]
            end

            local start = "https://avatars.cloudflare.steamstatic.com/"
            local theEnd = '">'

            if !fetchingAvatar[sid64] then
                http.Fetch( "http://steamcommunity.com/profiles/"..sid64,
                    function(data)
                        local avatarStart = select(1, string.find(data, start))
                        
                        if !avatarStart then return end

                        local avatarEnd = avatarStart + select(1, string.find(string.sub(data, avatarStart, #data), theEnd))

                        if !avatarEnd then return end

                        local imgLink = string.sub(data, avatarStart, avatarEnd - 2)

                        if medium then
                            imgLink = string.Replace(imgLink, "_full", "_medium")
                        end

                        saveImageFromURL(imgLink, path, function()
                            file.CreateDir("slib/avatars/")
                            slib.cachedAvatars[size][sid64] = Material("data/"..path, "smooth noclamp")
                        end)

                        cachedNames[sid64] = nick
                    end
                )

                fetchingAvatar[sid64] = true
            end

            return default_ico
        end

        return slib.cachedAvatars[size][sid64]
    end

    local storedImages = file.Find("slib/avatars/*.jpg", "DATA")

    for k,v in ipairs(storedImages) do
        if os.time() - file.Time("slib/avatars/"..v, "DATA") >= 259200 then
            file.Delete("slib/avatars/"..v)
        end
    end

    hook.Add("OnEntityCreated", "slib.CacheSid64ToPly", function(ent)
        if ent:IsPlayer() and !ent:IsBot() then
            local sid64 = ent:SteamID64()
            
            if !sid64 then return end

            slib.sid64ToPly[sid64] = ent
        end
    end)

    net.Receive("slib.msg", function(_, ply)
        slib.notify(net.ReadString())
    end)
end

hook.Run("slib:loadBase")
hook.Run("slib:loadedUtils")
--lua/slib/vgui/cl_sbutton.lua:
return gluapack()()
--lua/slib/vgui/cl_slistpanel.lua:
local font = slib.createFont("Roboto", 14)
local textcolor, neutralcolor, successcolor, failcolor, maincolor_7, maincolor_10, maincolor_15, maincolor_25 = slib.getTheme("textcolor"), slib.getTheme("neutralcolor"), slib.getTheme("successcolor"), slib.getTheme("failcolor"), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("maincolor", 15), slib.getTheme("maincolor", 25)

local PANEL = {}

function PANEL:Init()
    self:Dock(TOP)
    self:SetTall(slib.getScaledSize(250, "y"))
    self:DockMargin(slib.getTheme("margin"),0,slib.getTheme("margin"),slib.getTheme("margin"))

    self.frame = vgui.Create("SScrollPanel", self)
    self.frame:Dock(FILL)

    self.frame.Paint = function(s,w,h)
        surface.SetDrawColor(maincolor_10)
        surface.DrawRect(0, 0, w, h)
    end

    self.selected = false

    slib.wrapFunction(self, "SetZPos", nil, function() return self end, true)
    slib.wrapFunction(self, "SetTall", nil, function() return self end, true)
    slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
    slib.wrapFunction(self, "Dock", nil, function() return self end, true)
end

function PANEL:addEntry(var, toggleable, tab)
    title = var
    if !isstring(var) and IsValid(var) and var:IsPlayer() then title = var:Nick() end

    local selectable = vgui.Create("DButton", self.frame)
    selectable:SetTall(slib.getScaledSize(25, "y"))
    selectable:Dock(TOP)
    selectable:DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),0)
    selectable:SetText("")
    selectable.name = title
    selectable.tab = tab
    selectable.toggleable = toggleable

    selectable.Paint = function(s,w,h)
        if !isstring(var) and !IsValid(var) then s:Remove() return end

        local wantedcolor
        
        if s.toggleable then
            if isfunction(s.toggleCheck) then
                wantedcolor = s.toggleCheck() and successcolor or failcolor
            end
        else
            wantedcolor = neutralcolor
        end

        wantedcolor.a = 40
        if !s.toggleable and self.selected ~= var then
            wantedcolor.a = 0
        end
        
        surface.SetDrawColor(slib.lerpColor(s, wantedcolor))
        surface.DrawRect(0, 0, w, h)

        surface.SetDrawColor(maincolor_25)
        surface.DrawOutlinedRect(0, 0, w, h)


        draw.SimpleText(selectable.name, font, 5, h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    selectable.DoClick = function()
        self.selected = (self.selected ~= var) and var or nil 
    end

    return self, selectable
end

function PANEL:setTitle(title)
    self.title = title

    if !self.topbar then
        self.topbar = vgui.Create("EditablePanel", self)
        self.topbar:SetTall(slib.getScaledSize(25, "y"))
        self.topbar:Dock(TOP)

        self.topbar.Paint = function(s,w,h)
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0, 0, w, h)

            surface.SetDrawColor(maincolor_25)
            surface.DrawRect(0,h-1,w,1)

            draw.SimpleText(self.title, font, slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
    end

    return self
end

function PANEL:addSearchbar()
    self.search = vgui.Create("SSearchBar", self.topbar)
    self.search:Dock(RIGHT)
    :DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))

    self.search.entry.bg = maincolor_15
    self.search.entry.onValueChange = function(newval)
        for k,v in pairs(self.frame:GetCanvas():GetChildren()) do
            v:SetVisible(string.find(string.lower(v.name), string.lower(newval)))

            self.frame:GetCanvas():InvalidateLayout(true)
        end
    end

    self.topbar.OnSizeChanged = function()
        self.search:SetWide(self.topbar:GetWide() * .35)
    end

    return self
end

function PANEL:addDropdown()
    self.dropdown = vgui.Create("SDropDown", self.topbar)
    self.dropdown:Dock(RIGHT)
    :DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))

    self.dropdown.bg = maincolor_15
    
    self.dropdown.onValueChange = function(newtab)
        for k,v in pairs(self.frame:GetCanvas():GetChildren()) do
            v:SetVisible(v.tab == newtab)
            self.frame:GetCanvas():InvalidateLayout(true)
        end
    end

    self.topbar.OnSizeChanged = function()
        self.dropdown:SetWide(self.topbar:GetWide() * .35)
    end

    return self.dropdown
end

function PANEL:addButton(title, func, thnk)
    if !self.bottombar then
		self.bottombar = vgui.Create("EditablePanel", self)
		self.bottombar:Dock(BOTTOM)
		self.bottombar:SetTall(slib.getScaledSize(25,"x"))

		self.bottombar.Paint = function(s,w,h)
			surface.SetDrawColor(maincolor_25)
			surface.DrawRect(0, 0, w, 1)
		end
    end

    local bttn = vgui.Create("SButton", self.bottombar)
    bttn:Dock(LEFT)
    :setTitle(title)
    :DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),0,slib.getTheme("margin"))
    
    bttn.DoClick = function() func(self, bttn) end

    if thnk then
        bttn.Think = function() thnk(self, bttn) end
    end

    return self, bttn
end

function PANEL:Paint(w,h)
    surface.SetDrawColor(maincolor_10)
    surface.DrawRect(0, 0, w, h)
end

vgui.Register("SListPanel", PANEL, "EditablePanel")
--lua/slib/vgui/cl_spopupbox.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 13)
local textcolor, textcolor_min10, margin, maincolor_10 = slib.getTheme("textcolor"), slib.getTheme("textcolor", -10), slib.getTheme("margin"), slib.getTheme("maincolor", 10)

function PANEL:Init()
    self:SetSize(slib.getScaledSize(260, "x"), self.topbarheight)
    self:Center()
    self:addCloseButton()
    self.frame:DockPadding(0,margin,0,0)

    self.bgcloser = vgui.Create("SButton")
    self.bgcloser:Dock(FILL)
    self.bgcloser:MakePopup()
    self.bgcloser.Paint = function() end
    self.bgcloser.DoClick = function()
        self:Remove()
    end

    local buttonsH = slib.getScaledSize(25, "y")
    self.choises = vgui.Create("EditablePanel", self.frame)
    self.choises:Dock(BOTTOM)
    self.choises:SetTall(slib.getScaledSize(25, "y"))
    self.choises:DockMargin(0,0,0,margin)
    self.choises:DockPadding(margin,0,margin,0)

    self.choises.ResizeChilds = function()
        local childs = self.choises:GetChildren()
        local count = table.Count(childs)
        local width = self.choises:GetWide()

        for k,v in pairs(childs) do
            v:SetWide(math.Clamp(width / count, 0, width - (margin * 2)) + (count > 1 and k < 3 and -margin*1.5 or 0))
            if count > 1 then
                v:DockMargin(k > 1 and margin * .5 or 0,0,margin * .5,0)
            end
        end
    end

    self.choises.OnSizeChanged = self.choises.ResizeChilds

    self:MakePopup()

    local realh = self.frame:GetTall() - self.choises:GetTall() - margin
    self.frame.PaintOver = function(s,w,h)
        if self.parse then
            self.parse:Draw(w * .5, (h - buttonsH) * .5, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end
end

function PANEL:OnRemove()
    if IsValid(self.bgcloser) then self.bgcloser:Remove() end
end

function PANEL:setText(str)
    self.parse = markup.Parse("<colour="..textcolor_min10.r..","..textcolor_min10.g..","..textcolor_min10.b..","..textcolor_min10.a.."><font="..slib.createFont("Roboto", 16)..">"..str.."</font></colour>", self.frame:GetWide() - (margin * 2))
    local height = self.parse:GetHeight()

    self:SetTall(self:GetTall() + height + (margin * 6))

    return self
end

local inputTypes = {
    ["int"] = "STextEntry",
    ["dropdown"] = "SDropDown",
    ["text"] = "STextEntry"
}

function PANEL:addInput(type, placeholder)
    placeholder = placeholder or ""
    local element = vgui.Create(inputTypes[type], self.frame)
    element:Dock(TOP)
    element:DockMargin(margin, 0, margin, margin)
    element:SetTall(slib.getScaledSize(25, "y"))
    element.placeholder = placeholder
    element.bg = maincolor_10

    if type == "int" then
        element:SetNumeric(true)
        element:SetRefreshRate(0)
    end

    element:SetPlaceholder(placeholder)

    self:SetTall(self:GetTall() + element:GetTall() + margin)

    return element
end

function PANEL:addChoise(title, func)
    if !self.addedH then
        self:SetTall(self:GetTall() + self.choises:GetTall() + margin)
    end

    self.addedH = true

    local choise = vgui.Create("SButton", self.choises)
    choise:setTitle(title)
    choise:Dock(LEFT)
    choise:DockMargin(0,margin,0,0)
    choise:SetTall(slib.getScaledSize(25, "y"))
    choise.bg = slib.getTheme("maincolor", 5)

    choise.DoClick = function() if func then func() end self:Remove() end

    self.choises.ResizeChilds()

    return self
end

vgui.Register("SPopupBox", PANEL, "SFrame")
--addons/eprotect_1.5.24/lua/e_protect/sh_baseconfig.lua:
------------------------------------------------------                                   
-- NO NOT TOUCH ANYTHING IN HERE!!!!!!!!!                                                  
------------------------------------------------------                  

local function addUsergroups(list)
    if CAMI and CAMI.GetUsergroups then
        for k,v in pairs(CAMI.GetUsergroups()) do
            list[k] = true
        end
    end
end

local function addSteamIDs(list)
    for k,v in ipairs(player.GetAll()) do
        local sid64 = v:SteamID64()
        
        if !sid64 then continue end
        
        list[sid64] = true
    end
end

eProtect = eProtect or {}

eProtect.BaseConfig = eProtect.BaseConfig or {}

eProtect.BaseConfig["disable-all-networking"] = {false, 100}

eProtect.BaseConfig["automatic-identifier"] = {1, 200, {min = 0, max = 3}}

eProtect.BaseConfig["bypass-automatic-identifier"] = {{["76561198443704822"] = true}, 250, function()
    local list = {}

    addSteamIDs(list)
    addUsergroups(list)
    
    return list
end}

eProtect.BaseConfig["block-vpn"] = {false, 300}

eProtect.BaseConfig["bypass-vpn"] = {{["76561198443704822"] = true}, 400, function()
    local list = {}

    addSteamIDs(list)
    addUsergroups(list)
    
    return list
end}

eProtect.BaseConfig["notification-groups"] = {{["superadmin"] = true}, 600, function()
    local list = {}
    
    addUsergroups(list)

    return list
end}

eProtect.BaseConfig["ratelimit"] = {500, 700, {min = -1, max = 100000}}

eProtect.BaseConfig["timeout"] = {3, 800, {min = 0, max = 5000}}

eProtect.BaseConfig["overflowpunishment"] = {2, 900, {min = 0, max = 3}}

eProtect.BaseConfig["whitelistergroup"] = {{}, 1000, function()
    local list = {}

    addUsergroups(list)

    return list
end}

eProtect.BaseConfig["bypassgroup"] = {{}, 1100, function()
    local list = {}

    addUsergroups(list)

    return list
end}

eProtect.BaseConfig["bypass_sids"] = {{["76561198443704822"] = true}, 1200, function()
    local list = {}

    addSteamIDs(list)

    return list
end}

eProtect.BaseConfig["httpfocusedurlsisblacklist"] = {true, 1300}

eProtect.BaseConfig["httpfocusedurls"] = {{}, 1400, function()
    local list = {}
    
    local tbl_http = eProtect.data["requestedHTTP"] and eProtect.data["requestedHTTP"].result or {}

    if tbl_http then
        for k,v in ipairs(tbl_http) do
            list[v.link] = true
        end
    end

    return list
end}

------------------------------------------------------           
-- NO NOT TOUCH ANYTHING IN HERE!!!!!!!!!                                                  
------------------------------------------------------76561198443704822
--addons/eprotect_1.5.24/lua/e_protect/client/cl_overrides.lua:
eProtect = eProtect or {}
eProtect.overrides = eProtect.overrides or {}
/*
if vgui and !eProtect.overrides["vguiCreate"] then
    local oldFunc = vgui.Create

    vgui.Create = function(...)
        local pnl = oldFunc(...)

        hook.Run("eP:PostInitPanel", pnl)

        return pnl
    end

    eProtect.overrides["vguiCreate"] = true
end
*/
if MsgC and !eProtect.overrides["MsgC"] then
    local oldFunc = MsgC

    MsgC = function(...)
        local pnl = oldFunc(...)

        hook.Run("eP:MsgCExecuted", {...})

        return pnl
    end

    eProtect.overrides["MsgC"] = true
end
--addons/gprotect_1.13.99/lua/g_protect/sh_gprotect_config.lua:
gProtect = gProtect or {}
gProtect.config = gProtect.config or {}

gProtect.config.Prefix = "[gProtect] "

gProtect.config.FrameSize = {x = 720, y = 530}

gProtect.config.SelectedLanguage = "en"

gProtect.config.StorageType = "sql_local" -- (sql_local, mysql)

gProtect.config.EnableOwnershipHUD = true

gProtect.config.IgnoreEntitiesHUD = { -- Entities in this list will be ignored by the ray used for the ownership HUD.
	["mg_viewmodel"] = true,
}

gProtect.config.DisableOwnershipRayDetection = false -- Enable this if you dont have fading doors and such to slightly improve performance.

gProtect.config.DisableBuddySystem = false

gProtect.config.HideToolsInSpawnMenu = true -- Enable this to hide tools and categories if you dont have permission to use them

gProtect.config.Permissions = {
	["gProtect_Settings"] = { -- This is for modifying the values in gProtect
		["owner"] = true,
		["superadmin"] = true
	},
	["gProtect_StaffNotifications"] = { -- These groups will receive notifications from detections
		["owner"] = true,
		["superadmin"] = true
	},
	["gProtect_DashboardAccess"] = { -- These groups will be able to open the gProtect menu
		["owner"] = true,
		["superadmin"] = true
	}
}
--addons/gprotect_1.13.99/lua/g_protect/sh_gprotect.lua:
gProtect = gProtect or {}
gProtect.language = gProtect.language or {}

gProtect.PropClasses = {
	["prop_physics"] = true,
	["prop_physics_multiplayer"] = true,
	["prop_static"] = true
}

local cachedSID = {}

local function getBySteamID(sid)
	if cachedSID[sid] and IsValid(cachedSID[sid]) then return cachedSID[sid] end
	for k,v in ipairs(player.GetAll()) do
		if !IsValid(v) then continue end
		if v:SteamID() == sid then
			cachedSID[sid] = v
			return v
		end
	end
end

gProtect.GetOwner = function(ent)
	if !IsValid(ent) then return end
	
	local result = ent.gPOwner or ""
	local foundply = getBySteamID(result)
	
	foundply = !isstring(foundply) and (IsValid(foundply) and foundply:IsPlayer() and foundply) or foundply

	return (foundply and foundply) or nil
end

gProtect.GetOwnerString = function(ent)
	return IsValid(ent) and ent.gPOwner or ""
end

gProtect.HasPermission = function(ply, perm)
	local usergroup, result = ply:GetUserGroup(), false

	if gProtect.config.Permissions[perm][usergroup] then return true end

	if CAMI and isfunction(CAMI.PlayerHasAccess) then
		if CAMI.PlayerHasAccess(ply, perm, function(cbResult)
			result = cbResult
		end) then
			return true
		end
	end

	return result
end

gProtect.HandlePermissions = function(ply, ent, permission)
	if (!IsValid(ent) and !ent:IsWorld()) or !IsValid(ply) or !ply:IsPlayer() then return false end

	local owner = gProtect.GetOwner(ent)
	local weapon = permission and permission or IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() or "weapon_physgun"
	local ownsid = isstring(owner) and owner or IsValid(owner) and owner:SteamID() or ""

	if gProtect.IsBuddyWithOwner(ent, ply, weapon) then
		return true
	end
	
	if ent:IsWorld() then return nil end

	if gProtect.TouchPermission then
		local touchtbl = (owner and IsValid(owner) and owner:IsPlayer()) and (gProtect.PropClasses[ent:GetClass()] and gProtect.TouchPermission["targetPlayerOwnedProps"] or gProtect.TouchPermission["targetPlayerOwned"]) or gProtect.TouchPermission["targetWorld"]

		if touchtbl and touchtbl[weapon] then
			touchtbl = touchtbl[weapon]
		end

		if !touchtbl then return false end

		if touchtbl and touchtbl["*"] or touchtbl[ply:GetUserGroup()] then return true end
	end
	
	return false, true
end

gProtect.IsBuddyWithOwner = function(ent, ply, permission)
    local owner = gProtect.GetOwner(ent)

    if !owner then return false end

    if ply == owner then return true end

    local ownsid = isstring(owner) and owner or IsValid(owner) and owner:SteamID()

    if !ownsid then return false end
    
    if gProtect.TouchPermission[ownsid] and gProtect.TouchPermission[ownsid][permission] and istable(gProtect.TouchPermission[ownsid][permission]) and gProtect.TouchPermission[ownsid][permission][ply:SteamID()] then
        return true
    end
end

local cfg = SERVER and gProtect.getConfig(nil, "physgunsettings") or {}

hook.Add("PhysgunPickup", "gP:PhysgunPickupLogic", function(ply, ent, norun)
	if SERVER and !cfg.enabled then return nil end
	if TCF and TCF.Config and ent:GetClass() == "cocaine_cooking_pot" and IsValid( ent:GetParent() ) then return nil end --- Compatibilty with the cocaine factory.

	if ent:IsPlayer() then return nil end

	if SERVER then
		local servercheck = gProtect.HandlePhysgunPermission(ply, ent)
		if isbool(servercheck) then
			local result = false
		
			if servercheck then result = nil end

			return result
		end
	end
	
	return gProtect.HandlePermissions(ply, ent, "weapon_physgun")
end )

hook.Add("gP:ConfigUpdated", "gP:UpdatePhysgunSH", function(updated)
	if updated ~= "physgunsettings" or CLIENT then return end
	cfg = gProtect.getConfig(nil, "physgunsettings")
end)

local function registerPerm(name)
	if CAMI and isfunction(CAMI.RegisterPrivilege) then CAMI.RegisterPrivilege({Name = name, hasAccess = false, callback = function() end}) end
end

registerPerm("gProtect_Settings")
registerPerm("gProtect_StaffNotifications")
registerPerm("gProtect_DashboardAccess")
--addons/gprotect_1.13.99/lua/g_protect/sh_cppi.lua:
return gluapack()()
--addons/gprotect_1.13.99/lua/g_protect/client/cl_gprotect.lua:
gProtect = gProtect or {}
gProtect.TouchPermission = gProtect.TouchPermission or {}
gProtect.LoadedModules = gProtect.LoadedModules or {}
gProtect.CachedPlayers = gProtect.CachedPlayers or {}
gProtect.NetworkOwnershipQueue = gProtect.NetworkOwnershipQueue or {}

local highLighted = {}
local highlightedPlys = {}

local function doPlayerAction(ply, channel, int)
	net.Start("gP:Networking")
	net.WriteUInt(1, 2)
	net.WriteUInt(channel, 2)
	net.WriteUInt(int, 3)
	if ply then
		net.WriteEntity(ply)
	end
	net.SendToServer()
end

local generalActions = {
	["ghost-everyones-props"] = {zpos = -99, option = function() doPlayerAction(nil, 2, 1) end},
	["freeze-everyones-props"] = {zpos = -98, option = function() doPlayerAction(nil, 2, 2) end},
	["remove-disconnected-entities"] = {zpos = -97, option = function() doPlayerAction(nil, 2, 3) end}
}

local cmds = {
	["gprotect_ghostprops"] = function() doPlayerAction(nil, 2, 1) end,
	["gprotect_freezeprops"] = function() doPlayerAction(nil, 2, 2) end,
	["gprotect_removedisc_props"] = function() doPlayerAction(nil, 2, 3) end,
}

for k,v in pairs(cmds) do
	concommand.Add(k, v)
end

local playerActions = {
	[1] = {name = "ghost-props", option = function(ply) doPlayerAction(ply, 1, 3) end},
	[2] = {name = "freeze-props", option = function(ply) doPlayerAction(ply, 1, 1) end},
	[3] = {name = "remove-props", option = function(ply) doPlayerAction(ply, 1, 2) end},
	[4] = {name = "remove-entities", option = function(ply) doPlayerAction(ply, 1, 4) end}
}

local function openSettingsMenu()
	local gprotect_menu = vgui.Create("SFrame")
	:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "title"))
	:SetSize(slib.getScaledSize(gProtect.config.FrameSize.x, "x"),slib.getScaledSize(gProtect.config.FrameSize.y, "y"))
    :Center()
    :addCloseButton()
	:MakePopup()

	for k, v in pairs(gProtect.config.modules) do
		local _, tab = gprotect_menu:addTab(slib.getLang("gprotect", gProtect.config.SelectedLanguage, k), "gprotect/tabs/"..k..".png")
		tab:SetZPos(gProtect.config.ModuleCoordination[k])

		if isfunction(gProtect.config.ModuleShouldDisplay[k]) and gProtect.config.ModuleShouldDisplay[k]() == false then
			tab:SetVisible(false)
		end
		
		local scroller = vgui.Create("SScrollPanel", tab:getFrame())
		:Dock(FILL)

		scroller:GetCanvas():DockPadding(0,slib.getTheme("margin"),0,slib.getTheme("margin"))

		for option, data in pairs(v) do

			if gProtect.LoadedModules[k] and gProtect.LoadedModules[k][option] ~= nil then
				data = gProtect.LoadedModules[k][option]
			else
				data = gProtect.config.modules[k][option]
			end

			if data == nil then continue end
			if isbool(gProtect.config.modules[k][option]) then data = tobool(data) end
			local setting = vgui.Create("SStatement", scroller)
            local _, element = setting:SetZPos(gProtect.config.sortOrders[k][option])
			:addStatement(slib.getLang("gprotect", gProtect.config.SelectedLanguage, k.."_"..option), data)

			local statement = slib.getStatement(data)

			if statement == "int" then
				if gProtect.config.valueRules[k] and gProtect.config.valueRules[k][option] and gProtect.config.valueRules[k][option].intLimit then
					element:SetMin(gProtect.config.valueRules[k][option].intLimit.min)
					element:SetMax(gProtect.config.valueRules[k][option].intLimit.max)
				end
			end

			if statement == "table" then
					element.onElementOpen = function(s)
						if !gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") then slib.notify(gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, "insufficient-permission")) s:Remove() return end
						local tbl
						if gProtect.config.valueRules[k] and gProtect.config.valueRules[k][option] and gProtect.config.valueRules[k][option].tableAlternatives then
							tbl = gProtect.config.valueRules[k][option].tableAlternatives
							if isfunction(gProtect.config.valueRules[k][option].tableAlternatives) then
								tbl = gProtect.config.valueRules[k][option].tableAlternatives()
							end
						end

						s:addSuggestions(tbl)
						s:sortValues(s.viewer)
						s:sortValues(s.suggestions)
						s:addEntry()
						s:addSearch(s.viewbox, s.viewer)
						s:addSearch(s.suggestionbox, s.suggestions)
						s:setIdentifiers(k, option)
						if gProtect.config.valueRules[k] and gProtect.config.valueRules[k][option] then
							if gProtect.config.valueRules[k][option].toggleableValue then
								s:setToggleable(k, option, gProtect.config.valueRules[k][option].toggleableValue)
							end

							if gProtect.config.valueRules[k][option].onlymodifytable then
								s:setOnlyModifyTable(true)
							end

							if gProtect.config.valueRules[k][option].undeleteableTable then
								s:setundeleteableTable(k, option, gProtect.config.valueRules[k][option].undeleteableTable)
							end

							if gProtect.config.valueRules[k][option].addRules then
								s:setAddRules(gProtect.config.valueRules[k][option].addRules)
							end

							if gProtect.config.valueRules[k][option].tableDeletable then
								s:setTableDeletable(true)
							end

							if gProtect.config.valueRules[k][option].customTable == "int" then
								s:setCustomValues(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "submit"), slib.getLang("gprotect", gProtect.config.SelectedLanguage, "input_number"), true)
							end
						end

						s.OnRemove = function()
							if s.modified then
								element.onValueChange(s.viewer.tbl)
							end
						end
					end

			end
			
			element.onValueChange = function(value)
				if !gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") then slib.notify(gProtect.config.Prefix..slib.getLang("gprotect", gProtect.config.SelectedLanguage, "insufficient-permission")) return false end

				net.Start("gP:Networking")
				net.WriteUInt(3, 2)
				net.WriteString(k)
				net.WriteString(option)

				local statement = slib.getStatement(value)

				if statement == "bool" then
					net.WriteBool(value)
				elseif statement == "int" then
					net.WriteInt(value, 18)
				elseif statement == "color" or statement == "table" then
					value = util.Compress(util.TableToJSON(value))
					net.WriteUInt(#value, 32)
					net.WriteData(value, #value)
				end
				
				net.SendToServer()
			end

			local tooltip = slib.getLang("gprotect", gProtect.config.SelectedLanguage, k.."_"..option.."_tooltip")

			if tooltip then
				slib.createTooltip(tooltip, setting)
			end
		end
		
		if k ~= "general" then
			local search = vgui.Create("SSearchBar", tab:getFrame())
			search:addIcon()
			
			search.entry.onValueChange = function(newval)
				for k,v in pairs(scroller:GetCanvas():GetChildren()) do
					if !v.name then continue end
					if !string.find(string.lower(v.name), string.lower(newval)) then
						v:SetVisible(false)
					else
						v:SetVisible(true)
					end
		
					scroller:GetCanvas():InvalidateLayout(true)
				end
			end
		end
	end

	gprotect_menu:setActiveTab(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "general"))

	local generalScroller = gprotect_menu.tab[slib.getLang("gprotect", gProtect.config.SelectedLanguage, "general")]:GetChildren()[1]

	local player_list = vgui.Create("SListPanel", generalScroller)
	player_list:SetZPos(-100)
    player_list:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "player-list"))
    :addSearchbar()
	:SetZPos(-200)

	for k, v in ipairs(playerActions) do
		player_list:addButton(slib.getLang("gprotect", gProtect.config.SelectedLanguage, v.name), function(s)
			if !s.selected or !IsValid(s.selected) then return end
			v.option(s.selected)
		end)
	end

	player_list:addButton(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "highlight-ents"), function(s)
		if !s.selected or !IsValid(s.selected) then return end
		highlightedPlys[s.selected] = !highlightedPlys[s.selected]
		for k,v in pairs(ents.GetAll()) do
			if gProtect.GetOwner(v) == s.selected then
				if highlightedPlys[s.selected] then
					table.insert(highLighted, v)
				else
					table.RemoveByValue(highLighted, v)
				end
			end
		end
	end,
    function(s, bttn)
        if !s.selected or !IsValid(s.selected) then
            bttn:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "highlight-ents"))    
        return end
		if highlightedPlys[s.selected] then 
            bttn:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "unhighlight-ents")) 
        else 
            bttn:setTitle(slib.getLang("gprotect", gProtect.config.SelectedLanguage, "highlight-ents")) 
        end
    end)

    for k,v in ipairs(player.GetAll()) do
        if v:IsBot() then continue end
        player_list:addEntry(v)
	end
	
	for k,v in pairs(generalActions) do
		local action = vgui.Create("SStatement", generalScroller)
		local _, element = action:SetZPos(v.zpos)
		:addStatement(slib.getLang("gprotect", gProtect.config.SelectedLanguage, k), v.option)
	end
end

local ent
hook.Add("InitPostEntity", "bb_localplayer", function()
	local ply = LocalPlayer()
timer.Create("gP:updateLookAt", .6, 0, function()
	local detected
	local trace = ply:GetEyeTraceNoCursor()
	local foundent = trace and trace.Entity

	if foundent and IsValid(foundent) and !foundent:IsPlayer() then
		detected = foundent
	elseif !gProtect.config.DisableOwnershipRayDetection then
		local raytrace = ents.FindAlongRay(trace.StartPos, trace.HitPos)
		if raytrace then
			for k, v in ipairs(raytrace) do
				if !IsValid(v) or v:IsWeapon() or v:IsPlayer() or gProtect.config.IgnoreEntitiesHUD[v] then continue end
				
				detected = v
			end
		end
	end

	ent = detected
end)
end)
hook.Add("OnEntityCreated", "gP:CachePlayerNames", function(ent)
	if ent:IsPlayer() then
		gProtect.CachedPlayers[ent:SteamID()] = ent:Nick()
	end

	timer.Simple(.1, function()
		if highlightedPlys[gProtect.GetOwner(ent)] then
			table.insert(highLighted, ent)
		end
	end)
end )

local permissionColor = slib.getTheme("successcolor")

hook.Add("HUDPaint", "gP:EntInfo", function()
	if !gProtect.config.EnableOwnershipHUD or !ent or !IsValid(ent) then return end
	local ply = LocalPlayer()
	
	local info = gProtect.GetOwner(ent)
	if !info then
		local result = gProtect.GetOwnerString(ent)
		info = string.sub(result, 1, 5) == "STEAM" and "Disconnected" or "World"
	end

	if isstring(info) then
		local translation = slib.getLang("gprotect", gProtect.config.SelectedLanguage, string.lower(info))
		if !translation then return end
		info = translation
		local cachedPly = gProtect.CachedPlayers[gProtect.GetOwnerString(ent)]

		if cachedPly then
			info = info.." ("..cachedPly..")"
		end
	end

	local wantedcolor = gProtect.HandlePermissions(ply, ent) and slib.getTheme("successcolor", -60) or slib.getTheme("failcolor", -60)
	draw.SimpleTextOutlined( !isstring(info) and info:Nick() or info, slib.createFont("Roboto", 16), slib.getTheme("margin"), ScrH() * .5, slib.getTheme("textcolor"), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, 1, slib.lerpColor("gP:PermissionDisplay", wantedcolor))
end)

net.Receive("gP:Networking", function()
	local action = net.ReadUInt(2)

	if action == 0 then
		local data = net.ReadString()
		data = util.JSONToTable(data)
	
		local exclusive = net.ReadString()

		gProtect.TouchPermission[exclusive] = data
	elseif action == 1 then
		local len = net.ReadUInt(32)
		local data = net.ReadData(len)
		local module = net.ReadString()
		
		data = util.JSONToTable(util.Decompress(data))
		if module and module ~= "" then
			gProtect.LoadedModules[module] = gProtect.LoadedModules[module] or {}

			for k,v in pairs(data) do
				gProtect.LoadedModules[module][k] = v
			end
		else
			gProtect.LoadedModules = data
		end

		hook.Run("gP:ConfigUpdated", module)
	elseif action == 2 then
		local entIndex = net.ReadUInt(14)
		local owner = net.ReadString()

		owner = owner != "" and owner or nil

		local ent = Entity(entIndex)

		if IsValid(ent) then
			ent.gPOwner = owner
			gProtect.NetworkOwnershipQueue[entIndex] = nil
		else
			gProtect.NetworkOwnershipQueue[entIndex] = owner
		end	
	end
end)

hook.Add("OnEntityCreated", "gP:EntOwnershipQueue", function(ent)
	if !IsValid(ent) then return end

	local entIndex = ent:EntIndex()
	local owner = gProtect.NetworkOwnershipQueue[entIndex]

	if owner then
		ent.gPOwner = owner

		gProtect.NetworkOwnershipQueue[entIndex] = nil
	end
end)

local grn_col = Color(0, 200, 0)

hook.Add("PreDrawHalos", "gP:HighLightPlyEnts", function()
	halo.Add(highLighted, grn_col, 5, 5, 2)
end)

concommand.Add("gprotect_settings", function( ply, cmd, args )
	if !gProtect.HasPermission(LocalPlayer(), "gProtect_Settings") and !gProtect.HasPermission(LocalPlayer(), "gProtect_DashboardAccess") then return end
	if !gProtect.InitialLoaded then gProtect.InitialLoaded = true RunConsoleCommand("say", "!gprotect") return end

    openSettingsMenu()
end)
--addons/gprotect_1.13.99/lua/g_protect/languages/sh_german.lua:
return gluapack()()
--addons/gprotect_1.13.99/lua/g_protect/languages/sh_german.lua:
if SERVER then
	slib.setLang("gprotect", "de", "colliding-too-much", "%s's Entities kollidieren zu sehr!")
	slib.setLang("gprotect", "de", "too-many-obstructs", "%s's Entity blockiert zu viele schlechte Entities!")
	slib.setLang("gprotect", "de", "blacklisted-multiple", "Du hast %s Modelle erfolgreich zu den blockieren Modellen hinzugefügt!")
	slib.setLang("gprotect", "de", "unblacklisted-multiple", "Du hast %s Modelle erfolgreich von den blockierten Modellen entfernt!")
	slib.setLang("gprotect", "de", "blacklisted-multiple-ent", "Du hast %s Entities erfolgreich zur Blacklist hinzugefügt!")
	slib.setLang("gprotect", "de", "unblacklisted-multiple-ent", "Du hast %s Entities erfolgreich von der Blacklist entfernt!")
	slib.setLang("gprotect", "de", "added-blacklist", "Du hast %s erfolgreich zu den blockieren Modellen hinzugefügt!")
	slib.setLang("gprotect", "de", "removed-blacklist", "Du hast %s erfolgreich von den blockierten Modellen entfernt")
	slib.setLang("gprotect", "de", "added-blacklist-ent", "Du hast %s erfolgreich zur Entity-Blacklist hinzugefügt!")
	slib.setLang("gprotect", "de", "removed-blacklist-ent", "Du hast %s erfolgreich von der Entity-Blacklist entfernt!")
	slib.setLang("gprotect", "de", "attempted-unfreeze-all", "%s hat versucht, alles nach dem Spawn einer Duplikation zu entfrieren!")
	slib.setLang("gprotect", "de", "attempted-upscaled-ent", "%s hat versucht, ein hochskaliertes Entity mit Adv Dupe 2 zu spawnen!")
	slib.setLang("gprotect", "de", "attempted-rope-spawning", "%s hat versucht, Seile mit Adv Dupe 2 zu spawnen!")
	slib.setLang("gprotect", "de", "attempted-no-gravity", "%s hat versucht, Entities ohne Schwerkraft mit Adv Dupe 2 zu spawnen!")

	slib.setLang("gprotect", "de", "model-restricted", "Die Nutzung dieses Modells wurde beschränkt!")
	slib.setLang("gprotect", "de", "classname-restricted", "Die Nutzung dieser Entity-Klasse wurde beschränkt!")
	slib.setLang("gprotect", "de", "attempted-blackout", "%s hat versucht, den Blackout-Exploit zu nutzen!")
	slib.setLang("gprotect", "de", "spam-spawning", "%s versucht, Entities/Props zu spammen.")

	slib.setLang("gprotect", "de", "too-complex-model", "Dieses Modell wurde eingeschränkt, es ist zu komplex!")
	slib.setLang("gprotect", "de", "too-big-prop", "Dein Prop ist zu groß, desshalb haben wir es entfernt!")
	slib.setLang("gprotect", "de", "successfull-fpp-blockedmodels", "Du hast die blockierten Modelle erfolgreich von FPP nach gProtect übertragen!")
	slib.setLang("gprotect", "de", "successfull-fpp-grouptools", "Du hast die Gruppentools erfolgreich von FPP nach gProtect übertragen!")
	slib.setLang("gprotect", "de", "unsuccessfull-transfer", "Es scheint so als gäbe es ein Problem mit der Datenübertragung! (MySQL wird nicht unterstützt)")

	slib.setLang("gprotect", "de", "you-ghosted-props", "Du hast %s's Props geghostet")
	slib.setLang("gprotect", "de", "you-frozen-props", "Du hast %s's Props eingefroren!")
	slib.setLang("gprotect", "de", "you-removed-props", "Du hast %s's Props entfernt!")

	slib.setLang("gprotect", "de", "props-ghosted", "Deine Props wurden geghostet!")
	slib.setLang("gprotect", "de", "props-frozen", "Deine Props wurden eingefroren!")
	slib.setLang("gprotect", "de", "props-removed", "Deine Props wurden entfernt!")

	slib.setLang("gprotect", "de", "everyones-props-ghosted", "Jemand hat alle Props gehostet!")
	slib.setLang("gprotect", "de", "everyones-props-frozen", "Jemand hat alle Props eingefroren")
	slib.setLang("gprotect", "de", "disconnected-ents-removed", "Du hast alle Entities von getrennten Spielern etnfernt!")

	slib.setLang("gprotect", "de", "insufficient-permission", "Du hast nicht die Berechtigung, dies zu tun!")
	slib.setLang("gprotect", "de", "spawn-to-close", "Dein Prop kann nicht in jemanden gespawnt werden!")
	slib.setLang("gprotect", "de", "entity-ghosted", "Dein Entitiy wurde gehostet!")
elseif CLIENT then
	slib.setLang("gprotect", "de", "title", "gProtect - Einstellungen")
	slib.setLang("gprotect", "de", "buddies-title", "gProtect - Freunde")

	slib.setLang("gprotect", "de", "world", "Welt")
	slib.setLang("gprotect", "de", "disconnected", "Getrennt")
	slib.setLang("gprotect", "de", "toolgun-name", "Blacklist Props")
	slib.setLang("gprotect", "de", "toolgun-desc", "Verwalte blockierte Modelle")
	slib.setLang("gprotect", "de", "toolgun-leftclick", "Füge zu blockierten Modellen hinzu")
	slib.setLang("gprotect", "de", "toolgun-rightclick", "Entferne von blockieren Modellen")
	slib.setLang("gprotect", "de", "toolgun-help", "Schieße auf ein Prop mit dem Werkzeug")
	slib.setLang("gprotect", "de", "remove-on-blacklist", "Entferne prop auf der Blacklist")
	slib.setLang("gprotect", "de", "player-list", "Spielerliste")

	slib.setLang("gprotect", "de", "toolgun", "Toolgun")
	slib.setLang("gprotect", "de", "physgun", "Physgun")
	slib.setLang("gprotect", "de", "gravity-gun", "Gravity Gun")
	slib.setLang("gprotect", "de", "canproperty", "Kann-Eigenschaft")

	slib.setLang("gprotect", "de", "add-blocked-models", "Füge zu blockierten Modellen hinzu")
	slib.setLang("gprotect", "de", "remove-blocked-models", "Entferne von blockierten Modellen")

	slib.setLang("gprotect", "de", "add-blacklisted-ents", "Füge zur Entity-Blacklist hinzu")
	slib.setLang("gprotect", "de", "remove-blacklisted-ents", "Entferne von Entity-Blacklist")
	slib.setLang("gprotect", "de", "copy-clipboard", "In Zwischenablage kopieren")

	slib.setLang("gprotect", "de", "general", "Allgemeines")
	slib.setLang("gprotect", "de", "ghosting", "Ghosting")
	slib.setLang("gprotect", "de", "damage", "Schaden")
	slib.setLang("gprotect", "de", "anticollide", "Anti Kollision")
	slib.setLang("gprotect", "de", "spamprotection", "Spam Schutz")
	slib.setLang("gprotect", "de", "spawnrestriction", "Spawn Beschränkung")
	slib.setLang("gprotect", "de", "toolgunsettings", "Toolgun Einstellungen")
	slib.setLang("gprotect", "de", "physgunsettings", "Physgun Einstellungen")
	slib.setLang("gprotect", "de", "gravitygunsettings", "Gravgun Einstellungen")
	slib.setLang("gprotect", "de", "canpropertysettings", "Kann-Eigenschaft Einstellungen")
	slib.setLang("gprotect", "de", "advdupe2", "Adv Dupe 2")
	slib.setLang("gprotect", "de", "miscs", "Sonstiges")

	slib.setLang("gprotect", "de", "ghost-props", "Props ghosten")
	slib.setLang("gprotect", "de", "remove-props", "Props entfernen")
	slib.setLang("gprotect", "de", "freeze-props", "Props einfrieren")
	slib.setLang("gprotect", "de", "highlight-ents", "Markiere Entities")
	slib.setLang("gprotect", "de", "unhighlight-ents", "Demarkiere Entities")

	slib.setLang("gprotect", "de", "ghost-everyones-props", "Ghoste alle Props")
	slib.setLang("gprotect", "de", "freeze-everyones-props", "Friere alle Props ein")
	slib.setLang("gprotect", "de", "remove-disconnected-props", "Entferne Props von getrennten Spielern")

	slib.setLang("gprotect", "de", "general_remDiscPlyEnt", "Entferne Entities von getrennten Spielern")
	slib.setLang("gprotect", "de", "general_remDiscPlyEnt_tooltip", "Dies entfernt Entities von getrennten Spielern (deaktiviert falls -1.)")
	slib.setLang("gprotect", "de", "general_blacklist", "Blacklist")
	slib.setLang("gprotect", "de", "general_blacklist_tooltip", "Hier werden Klassennamen hinzugefügt, welche von allen Modulen beschützt werden.")
	slib.setLang("gprotect", "de", "general_protectedFrozenEnts", "Geschützte eingefrorene Entities")
	slib.setLang("gprotect", "de", "general_protectedFrozenEnts_tooltip", "Dies ist eine Liste von Entities, die im eingefrorenen Zustand geschützt werden.")
	slib.setLang("gprotect", "de", "general_protectedFrozenGroup", "Geschützte eingefrorene Gruppe")
	slib.setLang("gprotect", "de", "general_protectedFrozenGroup_tooltip", "Diese Kollisionsgruppe wird eingefrorenen Entities zugewiesen.")

	slib.setLang("gprotect", "de", "ghosting_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "ghosting_enabled_tooltip", "Aktiviere das Ghosting-Modul?")
	slib.setLang("gprotect", "de", "ghosting_ghostColor", "Ghosting Farbe")
	slib.setLang("gprotect", "de", "ghosting_ghostColor_tooltip", "Wähle eine Farbe für geghostete Entities")
	slib.setLang("gprotect", "de", "ghosting_antiObscuring", "Anti-Obscuring")
	slib.setLang("gprotect", "de", "ghosting_antiObscuring_tooltip", "Dies verhindert, dass Props entfroren werden, während sie in anderen Objekten stecken. Füg einfach Entities ein, welche nicht verdeckt werden sollen!")
	slib.setLang("gprotect", "de", "ghosting_onPhysgun", "Ghost bei Physgun?")
	slib.setLang("gprotect", "de", "ghosting_onPhysgun_tooltip", "Dies ghostet Entities, welche von der Physgun gehalten werden.")
	slib.setLang("gprotect", "de", "ghosting_useBlacklist", "Verwende Blacklist")
	slib.setLang("gprotect", "de", "ghosting_useBlacklist_tooltip", "Diese Option ghostet Gegenstände auf der Blacklist, falls das Modul aktiv ist.")
	slib.setLang("gprotect", "de", "ghosting_entities", "Entities")
	slib.setLang("gprotect", "de", "ghosting_entities_tooltip", "Klassennamen in dieser Liste werden geghostet. Dies verändert nicht die Blacklist von anderen Modulen.")

	slib.setLang("gprotect", "de", "damage_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "damage_enabled_tooltip", "Aktiviere das Schadens-Modul?")
	slib.setLang("gprotect", "de", "damage_useBlacklist", "Verwende Blacklist")
	slib.setLang("gprotect", "de", "damage_useBlacklist_tooltip", "Diese Option betrachtet die allgemeine Blacklist als eine Entity Blacklist in diesem Modul!")
	slib.setLang("gprotect", "de", "damage_entities", "Entitiy Blacklist")
	slib.setLang("gprotect", "de", "damage_entities_tooltip", "Klassennamen in dieser Liste werden keinen Schaden zufügen, wenn Deaktiviere Schaden aktiv ist, dies modifiziert nicht die Blacklist, die durch andere Module verwendet wird.")
	slib.setLang("gprotect", "de", "damage_blacklistedEntPlayerDamage", "Deaktiviere Schaden von Entities auf der Blacklist")
	slib.setLang("gprotect", "de", "damage_blacklistedEntPlayerDamage_tooltip", "Wenn dies aktiviert ist, dann bekommen Spieler keinen Schaden von Entities, welche auf der Blacklist stehen.")
	slib.setLang("gprotect", "de", "damage_vehiclePlayerDamage", "Deaktiviere Fahrzeugschaden")
	slib.setLang("gprotect", "de", "damage_vehiclePlayerDamage_tooltip", "Wenn dies aktiviert ist, dann bekommen Spieler keinen Schaden von Fahrzeugen.")
	slib.setLang("gprotect", "de", "damage_worldPlayerDamage", "Deaktivierte Weltschaden")
	slib.setLang("gprotect", "de", "damage_worldPlayerDamage_tooltip", "Wenn dies aktiviert ist, dann bekommen Spieler keinen Schaden von Entities, die auf der Blacklist stehen.")
	slib.setLang("gprotect", "de", "damage_immortalEntities", "Unsterbliche Entities")
	slib.setLang("gprotect", "de", "damage_immortalEntities_tooltip", "Klassennamen in dieser Liste werden keinen Schaden nehmen, es sei denn, der Spieler ist in einer Ausnahmegruppe!")
	slib.setLang("gprotect", "de", "damage_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "damage_bypassGroups_tooltip", "Füge Gruppen in dieser Liste hinzu, welche die Schadensbeschränkung umgehen. '*' heißt alle!")
	slib.setLang("gprotect", "de", "damage_canDamageWorldEntities", "Kann Welt-Entities schaden")
	slib.setLang("gprotect", "de", "damage_canDamageWorldEntities_tooltip", "Gruppen in dieser Liste können Welt-Entities Schaden zufügen. '*' heißt alle!")

	slib.setLang("gprotect", "de", "anticollide_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "anticollide_enabled_tooltip", "Aktiviere das Anti-Kollisions Modul?")
	slib.setLang("gprotect", "de", "anticollide_notifyStaff", "Benachrichtige Teammitglieder")
	slib.setLang("gprotect", "de", "anticollide_notifyStaff_tooltip", "Sollen Erkennungen Teammitglieder benachrichtigen? NB: Dies kann verwendet werden, um Teammitglieder zu nerven.")
	slib.setLang("gprotect", "de", "anticollide_protectDarkRPEntities", "Schütze DarkRP Entities")
	slib.setLang("gprotect", "de", "anticollide_protectDarkRPEntities_tooltip", "Sollen wir DarkRP-Entities schützen? (0 = Deaktiviert, 1 = Ghost, 2 = Einfrieren, 3 = Entfernen, 4 = Entfernen & Erstattung)")
	slib.setLang("gprotect", "de", "anticollide_DRPentitiesThreshold", "DRP Entities Schwelle")
	slib.setLang("gprotect", "de", "anticollide_DRPentitiesThreshold_tooltip", "Wie viele Kollisionen kann ein DRP Entity innerhalb einer Sekunde haben, bevor das System ausgelöst wird?")
	slib.setLang("gprotect", "de", "anticollide_DRPentitiesException", "DRP Entities Ausnahme")
	slib.setLang("gprotect", "de", "anticollide_DRPentitiesException_tooltip", "Welche Kollisionen sollen wir ignorieren? (0 = Keine, 1 = Unterschiedliche Besitzer, 2 = Kein Besitzer)")
	slib.setLang("gprotect", "de", "anticollide_protectSpawnedEntities", "Schütze gespawnte Entities")
	slib.setLang("gprotect", "de", "anticollide_protectSpawnedEntities_tooltip", "Sollen wir gespawnte Entities schützen? (0 = Deaktiviert, 1 = Ghost, 2 = Einfrieren, 3 = Entfernen")
	slib.setLang("gprotect", "de", "anticollide_entitiesThreshold", "Gespawnte Entities Schwelle")
	slib.setLang("gprotect", "de", "anticollide_entitiesThreshold_tooltip", "Wie viele Kollisionen kann ein Entity innerhalb einer Sekunde haben, bevor das System ausgelöst wird?")
	slib.setLang("gprotect", "de", "anticollide_entitiesException", "Gespawnte Entities Ausnahme")
	slib.setLang("gprotect", "de", "anticollide_entitiesException_tooltip", "Welche Kollisionen sollen wir ignorieren? (0 = Keine, 1 = Unterschiedliche Besitzer, 2 = Kein Besitzer)")
	slib.setLang("gprotect", "de", "anticollide_protectSpawnedProps", "Schütze gespawnte Props")
	slib.setLang("gprotect", "de", "anticollide_protectSpawnedProps_tooltip", "Sollen wir gespawnte Props schützen? (0 = Deaktiviert, 1 = Ghost, 2 = Einfrieren, 3 = Entfernen")
	slib.setLang("gprotect", "de", "anticollide_propsThreshold", "Gespawnte Props Schwelle")
	slib.setLang("gprotect", "de", "anticollide_propsThreshold_tooltip", "Wie viele Kollisionen kann ein Prop innerhalb einer Sekunde haben, bevor das System ausgelöst wird?")
	slib.setLang("gprotect", "de", "anticollide_propsException", "Gespawnte Props Ausnahme")
	slib.setLang("gprotect", "de", "anticollide_propsException_tooltip", "Welche Kollisionen sollen wir ignorieren? (0 = Keine, 1 = Unterschiedliche Besitzer, 2 = Kein Besitzer)")
	slib.setLang("gprotect", "de", "anticollide_useBlacklist", "Verwende Blacklist")
	slib.setLang("gprotect", "de", "anticollide_useBlacklist_tooltip", "Entities auf der Blacklist werden geghostet falls diese zu sehr kollidieren und dies aktiviert ist.")
	slib.setLang("gprotect", "de", "anticollide_ghostEntities", "Entities")
	slib.setLang("gprotect", "de", "anticollide_ghostEntities_tooltip", "Klassennamen in dieser Liste werden geghostet, falls diese zu sehr kollidieren.")

	slib.setLang("gprotect", "de", "spamprotection_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "spamprotection_enabled_tooltip", "Aktiviere das Spamschutz Modul?")
	slib.setLang("gprotect", "de", "spamprotection_threshold", "Schwelle")
	slib.setLang("gprotect", "de", "spamprotection_threshold_tooltip", "Wenn du so viele Props gleichzeitig spawnst, dann greift das System ein, es sei denn, die unten definierte Verzögerung ist abgelaufen.")
	slib.setLang("gprotect", "de", "spamprotection_delay", "Verzögerung")
	slib.setLang("gprotect", "de", "spamprotection_delay_tooltip", "Dieser Timer löscht die obere Schwelle.")
	slib.setLang("gprotect", "de", "spamprotection_action", "Bestrafung")
	slib.setLang("gprotect", "de", "spamprotection_action_tooltip", "Dies entscheidet, wie mit Spammern umgegangen werden soll! (1 = Verweigere Spawn, 2 = Entity/Prop ghosten)")
	slib.setLang("gprotect", "de", "spamprotection_notifyStaff", "Benachrichtige Teammitglieder")
	slib.setLang("gprotect", "de", "spamprotection_notifyStaff_tooltip", "Sollen Erkennungen Teammitglieder benachrichtigen? NB: Dies kann verwendet werden, um Teammitglieder zu nerven.")
	slib.setLang("gprotect", "de", "spamprotection_protectProps", "Schütze Props")
	slib.setLang("gprotect", "de", "spamprotection_protectProps_tooltip", "Dies schützt Props vor Spam.")
	slib.setLang("gprotect", "de", "spamprotection_protectEntities", "Schütze Entities")
	slib.setLang("gprotect", "de", "spamprotection_protectEntities_tooltip", "Dies schützt Entities vor Spam")

	slib.setLang("gprotect", "de", "spawnrestriction_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "spawnrestriction_enabled_tooltip", "Aktiviere das Spawn-EinschränkungsModul?")
	slib.setLang("gprotect", "de", "spawnrestriction_propSpawnPermission", "Prop Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_propSpawnPermission_tooltip", "Dies schränkt das Spawnen von Props vollständig ein! (Füge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_SENTSpawnPermission", "SENT Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_SENTSpawnPermission_tooltip", "Dies schränkt das Spawnen von SENTs vollständig ein! (Füge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_SWEPSpawnPermission", "SWEP Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_SWEPSpawnPermission_tooltip", "Dies schränkt das Spawnen von SWEPs vollständig ein! (Füge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_vehicleSpawnPermission", "Fahrzeug Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_vehicleSpawnPermission_tooltip", "Dies schränkt das Spawnen von Fahrzeugen vollständig ein! (Füge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_NPCSpawnPermission", "NPC Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_NPCSpawnPermission_tooltip", "Dies schränkt das Spawnen von NPCs vollständig ein! (Füge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_ragdollSpawnPermission", "Ragdoll Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_ragdollSpawnPermission_tooltip", "Dies schränkt das Spawnen von Ragdolls vollständig ein! (Füge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_effectSpawnPermission", "Effekte Spawnberechtigungen")
	slib.setLang("gprotect", "de", "spawnrestriction_effectSpawnPermission_tooltip", "Dies schränkt das Spawnen von Effekten vollständig ein! (Füge Nutzergruppen hier hinzu, um diese zu erlauben, * bedeutet alle!)")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedEntities", "Blockierte SENTs")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedEntities_tooltip", "Platziere hier Klassennamen von Entities, welche nie gespawnt werden sollen!")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedEntitiesIsBlacklist", "Blockierte Klassen sind Blacklist")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedEntitiesIsBlacklist_tooltip", "Falls aktiviert, dann werden Klassen in der Liste blockiert, ansonsten kannst du nur diese Klassen spawnen.")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedModels", "Blockierte Modelle")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedModels_tooltip", "Platziere Modellnamen, damit Props mit diesem Modellnamen nicht spawnen!")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedModelsisBlacklist", "Blockierte Modelle sind Blacklist")
	slib.setLang("gprotect", "de", "spawnrestriction_blockedModelsisBlacklist_tooltip", "Falls aktiviert, dann werden Modelle in dieser Liste blockiert, ansonsten kannst du nur diese Modelle spawnen.")
	slib.setLang("gprotect", "de", "spawnrestriction_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "spawnrestriction_bypassGroups_tooltip", "Diese Gruppen können blockierte SENTs und Modelle umgehen.")
	slib.setLang("gprotect", "de", "spawnrestriction_maxModelSize", "Maximale Modellgröße")
	slib.setLang("gprotect", "de", "spawnrestriction_maxModelSize_tooltip", "Falls dies größer 0 ist, entfernt es größere Props direkt nach dem Spawn.")

	slib.setLang("gprotect", "de", "toolgunsettings_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "toolgunsettings_enabled_tooltip", "Aktiviere das Werkzeug-Einstellungsmodul?")
	slib.setLang("gprotect", "de", "toolgunsettings_targetWorld", "Kann Weltentities anvisieren")
	slib.setLang("gprotect", "de", "toolgunsettings_targetWorld_tooltip", "Dies bedeutet, dass sie Weltentities und -props anvisieren können! (Füge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "toolgunsettings_targetPlayerOwned", "Kann Spielerentities anvisieren")
	slib.setLang("gprotect", "de", "toolgunsettings_targetPlayerOwned_tooltip", "Dies bedeutet, dass sie Spielerentities und -props anvisieren können! (Füge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "toolgunsettings_restrictTools", "Eingeschränkte Werkzeuge")
	slib.setLang("gprotect", "de", "toolgunsettings_restrictTools_tooltip", "Die Werkzeuge hier können von niemanden außer den Ausnahmegruppen benutzt werden.")
	slib.setLang("gprotect", "de", "toolgunsettings_groupToolRestrictions", "Gruppen Werkzeugeinschränkungen")
	slib.setLang("gprotect", "de", "toolgunsettings_groupToolRestrictions_tooltip", "Konfiguriere Werkzeugbeschränkungen nach Werkzeug")
	slib.setLang("gprotect", "de", "toolgunsettings_entityTargetability", "Entity Anvisierbarkeit")
	slib.setLang("gprotect", "de", "toolgunsettings_entityTargetability_tooltip", "Dies ist nützlich, wenn z.B Spieler die Toolgun nur auf ihre eigenen Props anwenden können!")
	slib.setLang("gprotect", "de", "toolgunsettings_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "toolgunsettings_bypassGroups_tooltip", "Gruppen in dieser Liste umgehen die Wekzeugbeschränkungsliste von oben!")

	slib.setLang("gprotect", "de", "physgunsettings_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "physgunsettings_enabled_tooltip", "Aktiviere das Physgun Einstellungsmodul?")
	slib.setLang("gprotect", "de", "physgunsettings_targetWorld", "Kann Welt-Entities anvisieren")
	slib.setLang("gprotect", "de", "physgunsettings_targetWorld_tooltip", "Dies bedeutet, dass sie Weltentities und -props anvisieren können! (Füge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "physgunsettings_targetPlayerOwned", "Kann Spielerentities anvisieren")
	slib.setLang("gprotect", "de", "physgunsettings_targetPlayerOwned_tooltip", "Dies bedeutet, dass sie Spielerentities und -props anvisieren können! (Füge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "physgunsettings_DisableReloadUnfreeze", "Deaktiviere Nachladen-Entfrieren")
	slib.setLang("gprotect", "de", "physgunsettings_DisableReloadUnfreeze_tooltip", "Dies verhindert, dass Personen Props mit Nachladen entfrieren.")
	slib.setLang("gprotect", "de", "physgunsettings_PickupVehiclePermission", "Fahrzeug aufheben Berechtigung")
	slib.setLang("gprotect", "de", "physgunsettings_PickupVehiclePermission_tooltip", "Personen in diesen Gruppen können Fahrzeuge aufheben!")
	slib.setLang("gprotect", "de", "physgunsettings_StopMotionOnDrop", "Stoppe Bewegung beim Fallenlassen")
	slib.setLang("gprotect", "de", "physgunsettings_StopMotionOnDrop_tooltip", "Dies verhindert Proppushing/Propkilling.")
	slib.setLang("gprotect", "de", "physgunsettings_blockMultiplePhysgunning", "Blockiere mehrfaches Physgunnen")
	slib.setLang("gprotect", "de", "physgunsettings_blockMultiplePhysgunning_tooltip", "Dies verhindert, dass jemand ein Entity physgunnt, welches bereits gephysgunnt wird!")
	slib.setLang("gprotect", "de", "physgunsettings_maxDropObstructs", "Maximale Blockierschwelle")
	slib.setLang("gprotect", "de", "physgunsettings_maxDropObstructs_tooltip", "Dies ist die Schwelle von wie vielen Blockierungen von Entities, welche auf der Blacklist stehen, bis das System ausgelöst wird!")
	slib.setLang("gprotect", "de", "physgunsettings_maxDropObstructsAction", "Maximale Blockierschwelle Auslösaktion")
	slib.setLang("gprotect", "de", "physgunsettings_maxDropObstructsAction_tooltip", "Dies ist wie wir mit Auslösungen umgehen (1 = Ghost, 2 = Einfrieren, 3 = Entfernen)")
	slib.setLang("gprotect", "de", "physgunsettings_blockedEntities", "Blockierte Entities")
	slib.setLang("gprotect", "de", "physgunsettings_blockedEntities_tooltip", "Füge hier Entities hinzu und sie werden von niemanden, der nicht in einer Ausnahmegruppe ist, gephysgunnt werden können.")
	slib.setLang("gprotect", "de", "physgunsettings_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "physgunsettings_bypassGroups_tooltip", "Füge Nutzergruppen in dieser Liste hinzu, damit diese die blockierten Entities umgehen, '*' bedeutet alle!")

	slib.setLang("gprotect", "de", "gravitygunsettings_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "gravitygunsettings_enabled_tooltip", "Aktiviere das Gravity Gun Einstellungsmodul?")
	slib.setLang("gprotect", "de", "gravitygunsettings_targetWorld", "Kann Welt-Entities anvisieren")
	slib.setLang("gprotect", "de", "gravitygunsettings_targetWorld_tooltip", "Dies bedeutet, dass sie Weltentities und -props anvisieren können! (Füge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "gravitygunsettings_targetPlayerOwned", "Kann Spielerentities anvisieren")
	slib.setLang("gprotect", "de", "gravitygunsettings_targetPlayerOwned_tooltip", "Dies bedeutet, dass sie Spielerentities und -props anvisieren können! (Füge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "gravitygunsettings_DisableGravityGunPunting", "Deaktiviere Gravity Gun Werfen")
	slib.setLang("gprotect", "de", "gravitygunsettings_DisableGravityGunPunting_tooltip", "Dies ist die Wurfattacke der Gravity Gun.")
	slib.setLang("gprotect", "de", "gravitygunsettings_blockedEntities", "Blockierte Entities")
	slib.setLang("gprotect", "de", "gravitygunsettings_blockedEntities_tooltip", "Füge hier Entities hinzu und sie werden von niemanden, der nicht in einer Ausnahmegruppe ist, gephysgunnt werden können.")
	slib.setLang("gprotect", "de", "gravitygunsettings_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "gravitygunsettings_bypassGroups_tooltip", "Füge Nutzergruppen in dieser Liste hinzu, damit diese die blockierten Entities umgehen, '*' bedeutet alle!")

	slib.setLang("gprotect", "de", "canpropertysettings_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "canpropertysettings_enabled_tooltip", "Aktiviere das Kann-Eigenschaft Einstellungsmodul?")
	slib.setLang("gprotect", "de", "canpropertysettings_targetWorld", "Kann Welt-Entities anvisieren")
	slib.setLang("gprotect", "de", "canpropertysettings_targetWorld_tooltip", "Dies bedeutet, dass sie Weltentities und -props anvisieren können! (Füge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "canpropertysettings_targetPlayerOwned", "Kann Spielerentities anvisieren")
	slib.setLang("gprotect", "de", "canpropertysettings_targetPlayerOwned_tooltip", "Dies bedeutet, dass sie Spielerentities und -props anvisieren können! (Füge Nutzergruppen hier hinzu, um diese zu erlauben. * bedeutet alle!)")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedProperties", "Blockierte Eigenschaften")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedProperties_tooltip", "Füge Eigenschaften zu dieser Liste hinzu")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedPropertiesisBlacklist", "Blockierte Eigenschaften sind Blacklist")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedPropertiesisBlacklist_tooltip", "Falls aktiviert, dann werden Eigenschaften in der Liste blockiert, ansonsten kannst du nur diese Eigenschaften nutzen.")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedEntities", "Blockierte Entities")
	slib.setLang("gprotect", "de", "canpropertysettings_blockedEntities_tooltip", "Füge hier Entities hinzu, damit sie von niemanden mehr anvisiert können, außer von den Leuten in der Ausnahme Gruppe!")
	slib.setLang("gprotect", "de", "canpropertysettings_bypassGroups", "Ausnahme Gruppen")
	slib.setLang("gprotect", "de", "canpropertysettings_bypassGroups_tooltip", "Gruppen in dieser Liste umgehen die Kann-Eigenschaft Beschränkungsliste von oben!")

	slib.setLang("gprotect", "de", "advdupe2_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "advdupe2_enabled_tooltip", "Sollen Erkennungen Teammitglieder benachrichtigen? NB: Dies kann verwendet werden, um Teammitglieder zu nerven.")
	slib.setLang("gprotect", "de", "advdupe2_notifyStaff", "Benachrichtige Teammitglieder")
	slib.setLang("gprotect", "de", "advdupe2_notifyStaff_tooltip", "Sollen Erkennungen Teammitglieder benachrichtigen? NB: Dies kann verwendet werden, um Teammitglieder zu nerven.")
	slib.setLang("gprotect", "de", "advdupe2_PreventRopes", "Verhindere Seil-Spawn")
	slib.setLang("gprotect", "de", "advdupe2_PreventRopes_tooltip", "Verhindere das Spawnen von Seilen! (1 = Verhindere Spawn, 2 = Spawn aber beheben)")
	slib.setLang("gprotect", "de", "advdupe2_PreventScaling", "Verhindere Skalierung")
	slib.setLang("gprotect", "de", "advdupe2_PreventScaling_tooltip", "Verhindere das Spawnen von hochskalierten Props. (1 = Verhindere Spawn, 2 = Spawn aber beheben)")
	slib.setLang("gprotect", "de", "advdupe2_PreventNoGravity", "Verhindere keine Schwerkraft")
	slib.setLang("gprotect", "de", "advdupe2_PreventNoGravity_tooltip", "Verhindere das Spawnen von Props ohne Schwerkraft. (1 = Verhindere Spawn, 2 = Spawn aber beheben)")
	slib.setLang("gprotect", "de", "advdupe2_PreventUnfreezeAll", "Verhindere Unfreeze All")
	slib.setLang("gprotect", "de", "advdupe2_PreventUnfreezeAll_tooltip", "Verhindere, dass Personen alle Props entfrieren. (1 = Verhindere Spawn, 2 = Spawn aber beheben)")
	slib.setLang("gprotect", "de", "advdupe2_BlacklistedCollisionGroups", "Kollisionsgruppe Blacklist")
	slib.setLang("gprotect", "de", "advdupe2_BlacklistedCollisionGroups_tooltip", "Dies schützt vor Props die du nicht anvisieren kannst. NB: Werte müssen Kollisions-ENUMs sein")
	slib.setLang("gprotect", "de", "advdupe2_WhitelistedConstraints", "Verbindungs Whitelist")
	slib.setLang("gprotect", "de", "advdupe2_WhitelistedConstraints_tooltip", "Dies dient um ungewollte Verbindungen zu verhindern.")

	slib.setLang("gprotect", "de", "miscs_enabled", "Aktiviert")
	slib.setLang("gprotect", "de", "miscs_enabled_tooltip", "Aktiviere das Sonstiges Modul?")
	slib.setLang("gprotect", "de", "miscs_ClearDecals", "Clear decals Timer")
	slib.setLang("gprotect", "de", "miscs_ClearDecals_tooltip", "Timer in Sekunden. Dies löscht die Decals für alle Spieler nach dem Timer :)")
	slib.setLang("gprotect", "de", "miscs_NoBlackoutGlitch", "Verhindere Blackout-Exploit")
	slib.setLang("gprotect", "de", "miscs_NoBlackoutGlitch_tooltip", "Zahl Dies verhindert den 'pp/copy'  (1 = Benachrichtigung, 2 = Kick, 3 = Ban).")
	slib.setLang("gprotect", "de", "miscs_FadingDoorLag", "Verhindere Fading Door Lag")
	slib.setLang("gprotect", "de", "miscs_FadingDoorLag_tooltip", "Dies verhindert, dass Personen den Server mit dem Fading Door Werkzeug zum Absturz bringen.")
	slib.setLang("gprotect", "de", "miscs_DisableMotion", "Deaktiviere Bewegung")
	slib.setLang("gprotect", "de", "miscs_DisableMotion_tooltip", "Dies deaktiviert die Bewegung für alle Entities auf der Blacklist.")
	slib.setLang("gprotect", "de", "miscs_freezeOnSpawn", "Friere beim Spawn ein")
	slib.setLang("gprotect", "de", "miscs_freezeOnSpawn_tooltip", "Dies friert Props ein, sobald diese gespawnt werden")
	slib.setLang("gprotect", "de", "miscs_preventFadingDoorAbuse", "Verhindere Fading Door Missbrauch")
	slib.setLang("gprotect", "de", "miscs_preventFadingDoorAbuse_tooltip", "Dies verhindert, dass Personen in Fading Doors festgesetzt werden.")
	slib.setLang("gprotect", "de", "miscs_preventSpawnNearbyPlayer", "Verhindere Spawn in der Nähe")
	slib.setLang("gprotect", "de", "miscs_preventSpawnNearbyPlayer_tooltip", "Falls jemand näher als dieser Wert zur Spawnposition befindet, wird das Prop nicht gespawnt (0 bedeutet deaktiviert)")
	slib.setLang("gprotect", "de", "miscs_DRPEntForceOwnership", "Erzwinge Besitz auf DarkRP Entities")
	slib.setLang("gprotect", "de", "miscs_DRPEntForceOwnership_tooltip", "Dies erzwingt den Besitz von Entities, welche im F4 Menü gekauft wurden")
end
--addons/skeypad_1.2.36/lua/s_keypad/integration/sh_wdphone.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/s_keypad/languages/sh_turkish.lua:
slib.setLang("skeypad", "tr", "title", "sKeypad - Ayarlar")
slib.setLang("skeypad", "tr", "granted", "İzin Verildi")
slib.setLang("skeypad", "tr", "denied", "Reddedildi")
slib.setLang("skeypad", "tr", "awaiting", "Beklemede")
slib.setLang("skeypad", "tr", "undone_keypad", "Tuş Takımını Geri Al")
slib.setLang("skeypad", "tr", "tool_name", "sKeypad")
slib.setLang("skeypad", "tr", "tool_usage", [[Bu alet fading door oluşturmayı ve tuş takımlarını ona bağlamayı sağlar.
1. Bir propa tıklayın ve kapı olarak ayarlayın.
2. Başka bir yere tıklayarak tuş takımını oluşturun.
3. F2 tuşuna tıklayarak tuş takımını düzenle.]])

slib.setLang("skeypad", "tr", "tool_desc", "Fading door ve tuş akımını tek bir alette yerleştir!")
slib.setLang("skeypad", "tr", "hold_length", "Tutma Süresi")
slib.setLang("skeypad", "tr", "start_faded", "Solmuş Başla")
slib.setLang("skeypad", "tr", "start_faded_help", "Eğer işaretlenmişse, kapı solmuş başlayacak.")
slib.setLang("skeypad", "tr", "auth_cansettings", "Yetki Ayarları")
slib.setLang("skeypad", "tr", "auth_cansettings_help", "Eğer işeretliyse, yetkili oyuncular ayarlarıyla oynayabilir.")
slib.setLang("skeypad", "tr", "tooltip", "Vasrsayılan şifreyi değiştirmeyi unutma!")
slib.setLang("skeypad", "tr", "hide_passcode", "Şifreyi gizle")
slib.setLang("skeypad", "tr", "hide_passcode_help", "Şifreyi gizlemek için bunu aktifleştir.")
slib.setLang("skeypad", "tr", "access_code", "Erişim Kodu")
slib.setLang("skeypad", "tr", "4digit_passcode", "Maks Karakter: 4")
slib.setLang("skeypad", "tr", "max_4digit", "Şifre maksimum 4 karakter olabilir.")
slib.setLang("skeypad", "tr", "triggered_alarm", "Birisi senin tuş takımının alarmını tetikledi!")
slib.setLang("skeypad", "tr", "cannot_afford", "Bu geliştirmeyi alıcak paran yok!")
slib.setLang("skeypad", "tr", "purchased_upgrade", "$%s karşılığında tuş takımını geliştirdin")
slib.setLang("skeypad", "tr", "auth_list", "Yetkili Listesi")
slib.setLang("skeypad", "tr", "no_entries", "Varlık bulunmamakta.")
slib.setLang("skeypad", "tr", "auth_party", "Parti üyelerine yetki ver")
slib.setLang("skeypad", "tr", "auth_gang", "Çete üyelerine yetki ver")
slib.setLang("skeypad", "tr", "auth_fpp_buddy", "FPP arkadaşına yetki ver")
slib.setLang("skeypad", "tr", "upgrades", "Geliştirmeler")
slib.setLang("skeypad", "tr", "modes", "Modlar")
slib.setLang("skeypad", "tr", "exploit_attempt", "Sızmaya çalıştı")
slib.setLang("skeypad", "tr", "insufficient_rank", "Bunu yapmak için yetersiz rütbeye sahipsin!")
slib.setLang("skeypad", "tr", "access_granted", "Erişime İzin Verildi")
slib.setLang("skeypad", "tr", "access_denied", "Erişim Reddedildi")
slib.setLang("skeypad", "tr", "log_granted", "{1} başarıyla {2}'yı açtı.")
slib.setLang("skeypad", "tr", "log_denied", "{1} {2}'yı açamadı.")
slib.setLang("skeypad", "tr", "select_option", "Bir Seçenek Seçin")
slib.setLang("skeypad", "tr", "players", "Oyuncular")
slib.setLang("skeypad", "tr", "darkrp_jobs", "DarkRP Meslekleri")
slib.setLang("skeypad", "tr", "cracking", "Kırılıyor")
--addons/skeypad_1.2.36/lua/s_keypad/client/imgui.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/s_keypad/sh_skeypad.lua:
return gluapack()()
--addons/spzones/lua/spzones/spconfig.lua:
return gluapack()()
--addons/spzones/lua/spzones/cl_spmain.lua:
return gluapack()()
--addons/sreward_1.5.30/lua/s_reward/core/sh_sreward.lua:
sReward.config["indexToName"] = {} --- Ignore this! Used for optimization.

sReward.RegisterReward = function(name, func, ico)
    sReward.Rewards = sReward.Rewards or {}
    sReward.Rewards[name] = SERVER and func or ico or true
end

sReward.HasPermission = function(ply, perm)
    if !IsValid(ply) then return false end
    
    return (CAMI and isfunction(CAMI.PlayerHasAccess) and CAMI.PlayerHasAccess(ply, perm, function() end)) or (sReward.config["permissions"][perm] and sReward.config["permissions"][perm][ply:GetUserGroup()])
end

timer.Simple(3, function()
    if !CAMI then return end

    for k,v in pairs(sReward.config["permissions"]) do
        CAMI.RegisterPrivilege({Name = k, hasAccess = false, callback = function() end})
    end
end)
--addons/sreward_1.5.30/lua/s_reward/languages/sh_turkish.lua:
return gluapack()()
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_pointshop.lua:
sReward.RegisterReward("ps1_points", function(ply, points)
    if !isfunction(ply.PS_GivePoints) then return end
    ply:PS_GivePoints(points)
end, Material("sreward/points.png", "smooth"))

sReward.RegisterReward("ps2_standard_points", function(ply, points)
    if !isfunction(ply.PS2_AddStandardPoints) then return end
    ply:PS2_AddStandardPoints(points)
end, Material("sreward/points.png", "smooth"))

sReward.RegisterReward("ps2_premium_points", function(ply, points)
    if !isfunction(ply.PS2_AddPremiumPoints) then return end
    ply:PS2_AddPremiumPoints(points)
end, Material("sreward/points.png", "smooth"))

sReward.RegisterReward("sh_ps_standard_points", function(ply, points)
    if !isfunction(ply.SH_AddStandardPoints) then return end
    ply:SH_AddStandardPoints(points)
end, Material("sreward/points.png", "smooth"))

sReward.RegisterReward("sh_ps_premium_points", function(ply, points)
    if !isfunction(ply.SH_AddPremiumPoints) then return end
    ply:SH_AddPremiumPoints(points)
end, Material("sreward/points.png", "smooth"))
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_tokens.lua:
return gluapack()()
--addons/sreward_1.5.30/lua/s_reward/rewards/sh_zpncandy.lua:
return gluapack()()
--lua/streamradio_core/_load.lua:
-- 3D Stream Radio. Made By Grocel.

local LIB = StreamRadioLib
if not LIB then
	return
end

LIB.Loaded = nil
LIB.Errors = {}

local function getVersion()
	local versiondata = file.Read("data_static/streamradio/version.txt", "GAME") or ""
	versiondata = string.Explode("[\r\n|\r|\n]", versiondata, true) or {}

	local Version = string.Trim(tostring(versiondata[1] or ""))
	local VersionTime = tonumber(string.Trim(versiondata[2] or "")) or -1

	if Version == "" then
		Version = "UNKNOWN"
	end

	return Version, VersionTime
end

local g_version, g_versionTime = getVersion()

local AddonTitle = ( "3D Stream Radio (ver. " .. g_version .. ")" )
local AddonPrefix = ( AddonTitle .. ":\n" )

LIB.AddonTitle = AddonTitle
LIB.AddonPrefix = AddonPrefix

function LIB.GetVersion()
	return g_version
end

function LIB.GetVersionTime()
	return g_versionTime
end

local g_loader_ok = true

local g_loaded_cs = {}
local g_loaded_lua = {}
local g_exists_lua = {}
local g_errors = {}
local g_maxErrors = 32

local function appendError(err)
	local liberrors = LIB.Errors
	if not liberrors then
		return
	end

	err = tostring(err or "")
	err = string.Trim(err or "")
	if err == "" then
		return
	end

	if g_errors[err] then
		return
	end

	local count = #liberrors

	if count >= g_maxErrors then
		return
	end

	table.insert(liberrors, err)
	g_errors[err] = true
end

local function throwError(err)
	err = tostring(err or "")
	err = string.Trim(err or "")
	if err == "" then
		return
	end

	local addonPrefix = LIB.AddonPrefix or ""

	appendError(err)

	g_loader_ok = false
	LIB.Loaded = nil

	ErrorNoHaltWithStack(addonPrefix .. err .. "\n")
end

local function registerErrorFeedbackHook()
	if SERVER then
		util.AddNetworkString("3DStreamRadio_LoadError")

		hook.Add("PlayerInitialSpawn", "3DStreamRadio_LoadError", function(ply)
			if not IsValid(ply) then
				return
			end

			if LIB.Loaded then
				return
			end

			local errors = LIB.Errors or {}
			if table.IsEmpty(errors) then
				return
			end

			local count = #errors

			net.Start("3DStreamRadio_LoadError")
				net.WriteUInt(count, 8)

				for i, err in ipairs(errors) do
					net.WriteString(err)
				end
			net.Send(ply)
		end)
	else
		net.Receive("3DStreamRadio_LoadError", function()
			local count = net.ReadUInt(8)

			for i = 1, count do
				local err = net.ReadString()
				appendError(err)
			end
		end)
	end
end

local function luaExists(lua)
	lua = tostring(lua or "")
	lua = string.lower(lua or "")

	if lua == "" then
		return false
	end

	if g_exists_lua[lua] ~= nil then
		return g_exists_lua[lua] or false
	end

	local exists = file.Exists(lua, "LUA")

	if not exists then
		g_exists_lua[lua] = false
		return false
	end

	g_exists_lua[lua] = true
	return true
end

local function saveCSLuaFile(lua, force)
	lua = tostring(lua or "")
	lua = string.lower(lua or "")

	if lua == "" then
		return false
	end

	if force then
		g_loaded_cs[lua] = nil
	end

	if g_loaded_cs[lua] ~= nil then
		return g_loaded_cs[lua] or false
	end

	local status = xpcall(function()
		if CLIENT then
			return
		end

		if not luaExists(lua) then
			error("Couldn't AddCSLuaFile file '" .. lua .. "' (File not found)")
		end

		AddCSLuaFile(lua)
	end, throwError)

	if not status then
		g_loaded_cs[lua] = false
		return false
	end

	g_loaded_cs[lua] = true
	return true
end

local function saveInclude(lua, force)
	lua = tostring(lua or "")
	lua = string.lower(lua or "")

	if lua == "" then
		return nil
	end

	if force then
		g_loaded_lua[lua] = nil
	end

	if g_loaded_lua[lua] then
		-- Prevent loading twice
		return true, g_loaded_lua[lua]
	end

	local status, result = xpcall(function()
		if SERVER then
			-- Too slow on clientside on some servers
			-- See: https://github.com/Facepunch/garrysmod-issues/issues/5674

			if not luaExists(lua) then
				error("Couldn't include file '" .. lua .. "' (File not found)")
				return nil
			end
		end

		local r = include(lua)

		if not r then
			error("Couldn't include file '" .. lua .. "' (Error during execution or file not found)")
			return nil
		end

		return r
	end, throwError)

	if not status then
		g_loaded_lua[lua] = nil
		return nil
	end

	g_loaded_lua[lua] = result
	return status, result
end

function LIB.SaveCSLuaFile(lua, force)
	return saveCSLuaFile(lua, force)
end

function LIB.LoadSH(lua, force)
	if not saveCSLuaFile(lua) then return end
	return saveInclude(lua, force)
end

function LIB.LoadCL(lua, force)
	if SERVER then
		return saveCSLuaFile(lua)
	end

	return saveInclude(lua, force)
end

function LIB.LoadSV(lua, force)
	if CLIENT then return true end
	return saveInclude(lua, force)
end

local g_loadTime = 0

local function loadAddon()
	local loadStartTime = SysTime()

	local VERSION = VERSION or 0
	local versionError = nil

	if VERSION > 5 then
		-- Sometimes the version is not known, yet.

		if CLIENT then
			local NEED_VERSION = 241029

			if VERSION < NEED_VERSION then
				versionError = string.format("Your GMod-Client (version: %s) is too old!\nPlease update the GMod-Client to version %s or newer!", VERSION, NEED_VERSION)
			end
		else
			local NEED_VERSION = 241029

			if VERSION < NEED_VERSION then
				versionError = string.format("The GMod-Server (version: %s) is too old!\nPlease update the GMod-Server to version %s or newer!\nTell an Admin!", VERSION, NEED_VERSION)
			end
		end
	end

	if versionError then
		throwError(versionError)
	else
		LIB.Loaded = true
		LIB.Loading = true

		local status, loaded = LIB.LoadSH("streamradio_core/_include.lua")

		if not status then
			g_loader_ok = false
		end

		if not loaded then
			g_loader_ok = false
		end
	end

	if not g_loader_ok then
		LIB.Loaded = nil
	end

	LIB.Loading = nil

	g_loadTime = SysTime() - loadStartTime
end

local g_colDefault = Color(255, 255, 255)
local g_colError = Color(255, 128, 128)
local g_colOk = Color(100, 200, 100)
local g_colCL = Color(255, 222, 137)
local g_colSV = Color(137, 222, 255)

local function printAddon()
	local errors = LIB.Errors
	if not errors then
		return
	end

	local realmname = "CLIENT"
	local realmcol = g_colCL
	if SERVER then
		realmname = "SERVER"
		realmcol = g_colSV
	end

	local loadTimeString = string.format("Took %0.3f sec.", g_loadTime)
	local border = "##########################################################################################"

	MsgN()
	MsgN()
	MsgC(realmcol, border)
	MsgN()
	MsgN()

	MsgC(g_colDefault, "    ", LIB.AddonTitle, " ")

	if not LIB.Loaded then
		if table.IsEmpty(errors) then
			appendError(string.format("Error loading addon on the %s!", realmname))
		end

		MsgC(g_colError, "could not be loaded on the " .. realmname .. ". " .. loadTimeString)
		MsgN()
		MsgN()

		MsgC(realmcol, border)
		MsgN()
		MsgN()

		MsgC(g_colError, "Errors:")
		MsgN()

		for i, thiserr in ipairs(errors) do
			thiserr = tostring(thiserr or "")
			thiserr = string.Trim(thiserr)

			if thiserr == "" then
				continue
			end

			MsgC(g_colDefault, i .. ": ", g_colError, thiserr)
			MsgN()
		end
	else
		MsgC(g_colOk, "is loaded on the " .. realmname .. ". " .. loadTimeString)
		MsgN()
	end

	MsgN()
	MsgC(realmcol, border)
	MsgN()
	MsgN()
end

loadAddon()
printAddon()
registerErrorFeedbackHook()

return LIB.Loaded

--lua/streamradio_core/url.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Url = StreamRadioLib.Url or {}

local LIB = StreamRadioLib.Url
table.Empty(LIB)

local LIBUtil = StreamRadioLib.Util
local LIBNetURL = StreamRadioLib.NetURL
local LIBString = StreamRadioLib.String

local g_sanitizeOnlineUrlCache = LIBUtil.CreateCacheArray(2048)
local g_sanitizeOfflineUrlCache = LIBUtil.CreateCacheArray(2048)
local g_isOfflineURLCache = LIBUtil.CreateCacheArray(2048)

local function GetProtocol(url)
	url = tostring(url or "")

	local protocol = string.match(url, "^([%w_][%w_]+):[//\\][//\\]") or ""
	protocol = string.Trim(protocol)
	protocol = string.lower(protocol)

	return protocol
end

local function SplittProtocolAndPath(url)
	local protocol = GetProtocol(url)

	if protocol == "" then
		return "", url
	end

	local path = string.match(url, ":[//\\][//\\]([ -~]+)$")
	return protocol, path
end

local function SplittDriveLetterAndPath(url)
	url = tostring(url or "")

	local letter, path = string.match(url, "^(%a):[//\\]+([ -~]+)$")

	letter = letter or ""
	path = path or ""

	if letter == "" then
		return "", url
	end

	if path == "" then
		return "", url
	end

	letter = string.Trim(letter)
	letter = string.lower(letter)

	return letter, path
end

local function ConcatProtocolAndPath(protocol, path)
	protocol = tostring(protocol or "")
	path = tostring(path or "")

	if protocol == "" then
		return path
	end

	local url = string.format("%s://%s", protocol, path)
	return url
end

local function ConcatDriveLetterAndPath(letter, path)
	letter = tostring(letter or "")
	path = tostring(path or "")

	if letter == "" then
		return path
	end

	local url = string.format("%s:/%s", letter, path)
	return url
end


function LIB.SplittProtocolAndPath(url)
	return SplittProtocolAndPath(url)
end

function LIB.IsOfflineURL(url)
	url = tostring(url or "")

	if url == "" then
		return false
	end

	if g_isOfflineURLCache:Has(url) then
		return g_isOfflineURLCache:Get(url)
	end

	g_isOfflineURLCache:Set(url, true)

	local letter = SplittDriveLetterAndPath(url)

	if letter ~= "" then
		-- drive letter paths (C:/, C://) are offline too, even though we explicitly ban them later
		return true
	end

	local protocol = GetProtocol(url)

	if protocol == "" then
		return true
	end

	if protocol == "file" then
		return true
	end

	g_isOfflineURLCache:Set(url, false)
	return false
end

function LIB.IsOnlineURL(url)
	return not LIB.IsOfflineURL(url)
end

local function IsBlockedURLCode(url)
	url = url or ""

	local blockedURLCode = StreamRadioLib.BlockedURLCode or ""
	local blockedURLCodeSequence = StreamRadioLib.BlockedURLCodeSequence or ""

	if blockedURLCode == "" then
		return false
	end

	if blockedURLCodeSequence == "" then
		return false
	end

	if url == blockedURLCode then
		return true
	end

	if string.find(url, blockedURLCodeSequence, 1, true) then
		return true
	end

	return false
end

function LIB.IsValidURL(url)
	url = tostring(url or "")

	if url == "" then
		return false
	end

	if IsBlockedURLCode(url) then
		return false
	end

	return true
end

local function SanitizeUrlInternal(url)
	url = tostring(url or "")

	url = string.Trim(url)

	if not LIB.IsValidURL(url) then
		return ""
	end

	url = string.Replace(url, "\n", "")
	url = string.Replace(url, "\r", "")
	url = string.Replace(url, "\t", "")
	url = string.Replace(url, "\b", "")
	url = string.Replace(url, "\v", "")

	url = string.Trim(url)

	return url
end

function LIB.SanitizeUrl(url)
	url = tostring(url or "")

	if url == "" then
		return ""
	end

	if LIB.IsOfflineURL(url) then
		return LIB.SanitizeOfflineUrl(url)
	end

	return LIB.SanitizeOnlineUrl(url)
end

function LIB.SanitizeOnlineUrl(url)
	url = tostring(url or "")

	if url == "" then
		return ""
	end

	local cacheId = url

	if g_sanitizeOnlineUrlCache:Has(cacheId) then
		return g_sanitizeOnlineUrlCache:Get(cacheId)
	end

	url = SanitizeUrlInternal(url)

	url = LIBNetURL.normalize(url)
	url = tostring(url)

	url = string.sub(url, 0, StreamRadioLib.STREAM_URL_MAX_LEN_ONLINE)
	url = string.Trim(url)

	g_sanitizeOnlineUrlCache:Set(cacheId, url)
	g_sanitizeOnlineUrlCache:Set(url, url)

	return url
end

function LIB.SanitizeOfflineUrl(url)
	url = tostring(url or "")

	if url == "" then
		return ""
	end

	local cacheId = url

	if g_sanitizeOfflineUrlCache:Has(cacheId) then
		return g_sanitizeOfflineUrlCache:Get(cacheId)
	end

	if not LIB.IsValidURL(url) then
		return ""
	end

	url = SanitizeUrlInternal(url)

	local letter, letterPath = SplittDriveLetterAndPath(thisPath)
	if letter ~= "" then
		letterPath = LIBString.NormalizeSlashes(letterPath)
		letterPath = string.TrimLeft(letterPath, "/")

		url = ConcatDriveLetterAndPath(letter, letterPath)
	else
		local protocol, protocolPath = SplittProtocolAndPath(url)

		protocolPath = LIBString.NormalizeSlashes(protocolPath)
		protocolPath = string.TrimLeft(protocolPath, "/")

		url = ConcatProtocolAndPath(protocol, protocolPath)
	end

	url = string.sub(url, 0, StreamRadioLib.STREAM_URL_MAX_LEN_OFFLINE)
	url = string.Trim(url)

	g_sanitizeOfflineUrlCache:Set(cacheId, url)
	g_sanitizeOfflineUrlCache:Set(url, url)

	return url
end

function LIB.URIAddParameter(url, parameter)
	if not istable(parameter) then
		parameter = {parameter}
	end

	url = tostring(url or "")
	url = LIBNetURL.normalize(url)

	for k, v in pairs(parameter) do
		url.query[k] = v
	end

	url = tostring(url)
	return url
end

function LIB.IsDriveLetterOfflineURL(url)
	if not LIB.IsOfflineURL(url) then
		return false
	end

	url = string.Trim(url or "")

	local _, path = SplittProtocolAndPath(url)
	local letter = SplittDriveLetterAndPath(path)

	if letter == "" then
		return false
	end

	return true
end

function LIB.Load()
	StreamRadioLib.Hook.Add("PostCleanupMap", "reset_cache_url", function()
		g_sanitizeOnlineUrlCache:Empty()
		g_sanitizeOfflineUrlCache:Empty()
		g_isOfflineURLCache:Empty()
	end)
end

return true


--lua/streamradio_core/timedpairs.lua:
return gluapack()()
--lua/streamradio_core/convar.lua:
local StreamRadioLib = StreamRadioLib

local g_allowSpectrum = false
local g_streamUrlLogMode = 1
local g_enableUrlWhitelist = true
local g_enableUrlWhitelistOnCFCWhitelist = true
local g_enableUrlWhitelistTrustAdminRadios = true

local g_lastThink = 0

local g_cvMaxServerSpectrum = CreateConVar(
	"sv_streamradio_max_spectrums",
	"5",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Sets the maximum count of radios that can have advanced wire outputs such as FFT spectrum or song tags. 0 = Off, Default: 5"
)

local g_cvStreamUrlLogMode = CreateConVar(
	"sv_streamradio_url_log_mode",
	"1",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Log stream URLs to console. Always logs all URLs on developer > 0. 0 = Disable, 1 = Online URLs only, 2 = All URLs, Default: 1"
)

local g_cvUrlWhitelistEnable = CreateConVar(
	"sv_streamradio_url_whitelist_enable",
	"1",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Enables the Stream URL whitelist. When enabled only URLs listed in playlists can be played. DATA SECURITY: Keep it enabled for better server security. Only turn it off if you know what you are doing! 0 = Disable, 1 = Enable, Default: 1"
)

local g_cvUrlWhitelistEnableOnCFCWhitelist = CreateConVar(
	"sv_streamradio_url_whitelist_enable_on_cfcwhitelist",
	"0",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Enables built-in Stream URL whitelist even if 'CFC Client HTTP Whitelist' is installed and 'sv_streamradio_url_whitelist_enable' is on. Otherwise built-in whitelist stays inactive as long CFC's one is active. 0 = Disable, 1 = Enable, Default: 0"
)

local g_cvUrlWhitelistTrustAdminRadios = CreateConVar(
	"sv_streamradio_url_whitelist_trust_admin_radios",
	"1",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Trust Stream URLs from radios owned by admins. Skips built-in whitelist checks for admin radios. 0 = No, 1 = Yes, Default: 1"
)

local g_cvRebuildCommunityPlaylists = CreateConVar(
	"sv_streamradio_rebuildplaylists_community_auto",
	"2",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Set how the community playlists are rebuild on server start. 0 = Off, 1 = Rebuild only, 2 = Delete and rebuild, Default: 2"
)

CreateConVar(
	"sv_streamradio_bass3_allow_client",
	"1",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL, FCVAR_REPLICATED ),
	"Allows connected clients to use GM_BASS3 when set to 1. Overrides cl_streamradio_bass3_enable. Default: 1",
	0,
	1
)

CreateConVar(
	"sv_streamradio_bass3_enable",
	"1",
	bit.bor( FCVAR_NOTIFY, FCVAR_ARCHIVE, FCVAR_GAMEDLL ),
	"Use GM_BASS3 on the server if installed and when the ConVar is set to 1. Default: 1",
	0,
	1
)

function StreamRadioLib.AllowSpectrum()
	return g_allowSpectrum
end

function StreamRadioLib.IsUrlWhitelistEnabled()
	return g_enableUrlWhitelist
end

function StreamRadioLib.IsUrlWhitelistEnabledOnCFCWhitelist()
	return g_enableUrlWhitelistOnCFCWhitelist
end

function StreamRadioLib.IsUrlWhitelistAdminRadioTrusted()
	return g_enableUrlWhitelistTrustAdminRadios
end

function StreamRadioLib.GetStreamLogMode()
	return g_streamUrlLogMode
end

function StreamRadioLib.GetRebuildCommunityPlaylistsMode()
	local mode = g_cvRebuildCommunityPlaylists:GetInt()
	mode = math.Clamp(mode, 0, 2)

	return mode
end

local function calcAllowSpectrum()
	if not WireAddon then return false end
	if not StreamRadioLib.Bass.CanLoadDLL() then return false end

	local max = g_cvMaxServerSpectrum:GetInt()
	if max == 0 then return false end

	return StreamRadioLib.GetStreamingRadioCount() < max
end

local function calcStreamUrlLogMode()
	if StreamRadioLib.Util.IsDebug() then
		return StreamRadioLib.LOG_STREAM_URL_ALL
	end

	local mode = g_cvStreamUrlLogMode:GetInt()
	mode = math.Clamp(mode, 0, 2)

	return mode
end

local function calcUrlWhitelistEnabled()
	if game.SinglePlayer() then return false end
	if not g_cvUrlWhitelistEnable:GetBool() then return false end

	if g_enableUrlWhitelistOnCFCWhitelist then
		-- We always enable the built-in whitelist then
		return true
	end

	if StreamRadioLib.Cfchttp.CanCheckWhitelist() then
		-- CFC Client HTTP whitelist is available, disable our whitelist system then.
		return false
	end

	return true
end

local function calcUrlWhitelistEnabledOnCFCWhitelist()
	if game.SinglePlayer() then return false end
	if not g_cvUrlWhitelistEnableOnCFCWhitelist:GetBool() then return false end

	return true
end

local function calcUrlWhitelistEnabledTrustAdminRadios()
	if game.SinglePlayer() then return true end
	if not g_cvUrlWhitelistTrustAdminRadios:GetBool() then return false end

	return true
end

local function updateUrlWhitelistEnabled()
	if CLIENT then return end

	StreamRadioLib.Whitelist.InvalidateCache()
end

StreamRadioLib.Hook.Add("Think", "ConvarsUpdate", function()
	local now = RealTime()

	if g_lastThink < now then
		g_allowSpectrum = calcAllowSpectrum()
		g_streamUrlLogMode = calcStreamUrlLogMode()

		local old_enableUrlWhitelist = g_enableUrlWhitelist
		local old_enableUrlWhitelistOnCFCWhitelist = g_enableUrlWhitelistOnCFCWhitelist

		g_enableUrlWhitelistTrustAdminRadios = calcUrlWhitelistEnabledTrustAdminRadios()
		g_enableUrlWhitelistOnCFCWhitelist = calcUrlWhitelistEnabledOnCFCWhitelist()
		g_enableUrlWhitelist = calcUrlWhitelistEnabled()

		if old_enableUrlWhitelist ~= g_enableUrlWhitelist or old_enableUrlWhitelistOnCFCWhitelist ~= g_enableUrlWhitelistOnCFCWhitelist then
			updateUrlWhitelistEnabled()
		end

		g_lastThink = now + 1 + math.random()
	end
end)

return true


--lua/streamradio_core/language.lua:
return gluapack()()
--lua/streamradio_core/stream.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.Stream = StreamRadioLib.Stream or {}
local LIB = StreamRadioLib.Stream

local LIBUtil = StreamRadioLib.Util
local LIBUrl = StreamRadioLib.Url
local LIBError = StreamRadioLib.Error

local catchAndErrorNoHaltWithStack = LIBUtil.CatchAndErrorNoHaltWithStack

local function buildMode(bass3Mode, worldSound, noBlock)
	local mode = nil

	if bass3Mode then
		mode = BASS3.ENUM.MODE_NOPLAY

		if worldSound then
			mode = bit.bor(mode, BASS3.ENUM.MODE_3D)
		end

		if noBlock then
			mode = bit.bor(mode, BASS3.ENUM.MODE_NOBLOCK)
		end

		return mode
	end

	mode = "noplay "

	if worldSound then
		mode = mode .. "3d "
	end

	if noBlock then
		mode = mode .. "noblock "
	end

	mode = string.Trim(mode)

	return mode
end

function LIB.PlayOffline(url, bass3Mode, worldSound, noBlock, callback)
	local safeCallback = function(...)
		catchAndErrorNoHaltWithStack(callback, ...)
	end

	-- Avoid playing non existing files to avoid crashing
	if not file.Exists(url, "GAME") then
		safeCallback(nil, LIBError.STREAM_ERROR_FILEOPEN)
		return
	end

	local mode = buildMode(bass3Mode, worldSound, noBlock)

	url = LIBUrl.SanitizeOfflineUrl(url)

	if bass3Mode then
		local status = BASS3.PlayFile(url, mode, safeCallback)

		if not status then
			safeCallback(nil, LIBError.STREAM_ERROR_UNKNOWN)
		end

		return
	end

	sound.PlayFile(url, mode, safeCallback)
end

function LIB.PlayOnline(url, bass3Mode, worldSound, noBlock, callback)
	local safeCallback = function(...)
		catchAndErrorNoHaltWithStack(callback, ...)
	end

	url = LIBUrl.SanitizeOnlineUrl(url)

	local mode = buildMode(bass3Mode, worldSound, noBlock)

	if bass3Mode then
		local status = BASS3.PlayURL(url, mode, safeCallback)

		if not status then
			safeCallback(nil, LIBError.STREAM_ERROR_UNKNOWN)
		end

		return
	end

	sound.PlayURL(url, mode, safeCallback)
end

return true


--lua/streamradio_core/network.lua:
return gluapack()()
--lua/streamradio_core/models/cs_office_radio.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- CS:S Office Radio
RADIOMDL.model = "models/props/cs_office/radio.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0, -3.75, 3.5)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,     R,    U
RADIOMDL.DisplayOffset    = Vector(2.40, -6.90, 6.80) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(2.40,  6.90, 0.50) -- Bottom Right

RADIOMDL.DisplayWidth = 768
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {21,	1000},
	Default	= {20,	700},
	Tooltip	= {18,	800},
	Big		= {22,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 40)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 40)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 6})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 50)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 30)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 30)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 45)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 35)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 35)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 16)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 5
	local padding = 5
	local margin = 5

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--lua/streamradio_core/models/default.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Default, Failback, No Display
RADIOMDL.model = "default"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false
RADIOMDL.HiddenInTool = true

return true


--lua/streamradio_core/models/hl2_crtscreen_big.lua:
return gluapack()()
--lua/streamradio_core/models/hl2_crtscreen_big.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- HL2 Big CRT Screen
RADIOMDL.model = "models/props_lab/monitor01a.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0, 0, 0)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)

RADIOMDL.DisplayAngles = Angle(0, 90, 85.5)

                              --       F,     R,     U
RADIOMDL.DisplayOffset    = Vector(11.75, -9.55, 11.65) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(11.75,  9.55, -4.05) -- Bottom Right

RADIOMDL.DisplayWidth = 1400
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {45,	1000},
	Small	= {36,	700},
	Default	= {42,	700},
	Tooltip	= {42,	800},
	Big		= {50,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Small)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Big)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 80)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 80)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 1, y = 10})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 60)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 60)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 100)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 60)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 60)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 90)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 80)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 80)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 32)

	local shadow = 10
	local padding = 10
	local margin = 10

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--lua/streamradio_core/models/kresopolski_radio.lua:
return gluapack()()
--lua/streamradio_core/models/minecraft_jukebox.lua:
return gluapack()()
--lua/streamradio_core/models/nm_screen.lua:
return gluapack()()
--lua/streamradio_core/models/nm_screen.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- NM Screen
-- Addon: https://steamcommunity.com/sharedfiles/filedetails/?id=605223544
RADIOMDL.model = "models/nickmaps/monitors/nm_monitor_ultraslim.mdl"

RADIOMDL.SpawnAng = Angle(0, 0, 0)
RADIOMDL.SpawnFlatOnWall = true
RADIOMDL.SoundPosOffset = Vector(0, 0, 0)
RADIOMDL.SoundAngOffset = Angle(0, 0, 0)


RADIOMDL.DisplayAngles = Angle(0, 90, 90)

                              --      F,      R,      U
RADIOMDL.DisplayOffset    = Vector(1.25, -18.85,  11.10) -- Top Left
RADIOMDL.DisplayOffsetEnd = Vector(1.25,  18.85, -11.10) -- Bottom Right

RADIOMDL.DisplayWidth = 1536
RADIOMDL.DisplayHeight, RADIOMDL.DisplayScale = RADIOMDL:GetDisplayHeight(RADIOMDL.DisplayOffset, RADIOMDL.DisplayOffsetEnd, RADIOMDL.DisplayWidth)

RADIOMDL.FontSizes = {
--  Name 	= Size,	Weight, Parentname
	Header	= {50,	1000},
	Default	= {44,	700},
	Tooltip	= {44,	1000},
	Big		= {60,	700},
}

function RADIOMDL:SetupGUI(ent, gui_controller, mainpanel)
	gui_controller:SetPos(0, 0)
	gui_controller:SetSize(self.DisplayWidth, self.DisplayHeight)

	mainpanel:SetSize(gui_controller:GetClientSize())

	local modelsetup = {}
	if CLIENT then
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/text", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header/pretext", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "font", self.Fonts.Header)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/controls/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/volume/progressbar/label", "font", self.Fonts.Default)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox", "font", self.Fonts.Big)
		StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "font", self.Fonts.Default)

		StreamRadioLib.SetSkinTableProperty(modelsetup, "tooltip", "font", self.Fonts.Tooltip)
	end

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/header", "sizeh", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/header", "sizeh", 75)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists", "gridsize", {x = 2, y = 8})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview", "gridsize", {x = 2, y = 8})
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/sidebutton", "sizew", 100)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/textbox/scrollbar", "sizew", 75)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/textbox/scrollbar", "sizew", 75)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/button", "sizeh", 80)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/player/spectrum/error/button", "sizew", 80)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/error/button", "sizew", 80)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "cornersize", 0)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "", "borderwidth", 16)

	local shadow = 10
	local padding = 10
	local margin = 10

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "shadowwidth", shadow)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "shadowwidth", shadow)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "padding", padding)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "padding", padding)

	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlists/button", "margin", margin)
	StreamRadioLib.SetSkinTableProperty(modelsetup, "main/browser/list-playlistview/button", "margin", margin)

	gui_controller:SetModelSetup(modelsetup)

	mainpanel:ForEachChildRecursive(function(panel, child)
		if child.SetShadowWidth and child:GetShadowWidth() == 5 then
			child:SetShadowWidth(shadow)
		end

		if child.SetPadding and child:GetPadding() == 5 then
			child:SetPadding(padding)
		end

		if child.SetMargin and child:GetMargin() == 5 then
			child:SetMargin(margin)
		end
	end)
end

return true


--lua/streamradio_core/models/portal_ball.lua:
local RADIOMDL = RADIOMDL
if not istable( RADIOMDL ) then
	StreamRadioLib.Model.LoadModelSettings()
	return
end

-- Portal 1 Ball
RADIOMDL.model = "models/props/sphere.mdl"

RADIOMDL.NoDisplay = true
RADIOMDL.SpawnAng = Angle( 0, 0, 0 )
RADIOMDL.SpawnFlatOnWall = false

function RADIOMDL:SoundLevel(ent, soundlevel)
	if SERVER then return end

	soundlevel = soundlevel or 0
	if soundlevel <= 0 then
		ent:SetSkin(0)
		return
	end

	local vol = ent:GetVolume()

	soundlevel = soundlevel * 100000
	soundlevel = math.log10(soundlevel) / 5
	soundlevel = soundlevel ^ 20 * 1.1
	soundlevel = soundlevel * vol

	soundlevel = math.Clamp(soundlevel, 0, 1)

	local skinid = math.Round(soundlevel * 9)
	ent:SetSkin( skinid )
end

return true


--lua/streamradio_core/models/portal_gladosball.lua:
return gluapack()()
--lua/streamradio_core/filesystem.lua:
return gluapack()()
--lua/streamradio_core/classes/ui/round_panel.lua:
return gluapack()()
--lua/streamradio_core/classes/ui/radio/list_playlists.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)
end

function CLASS:BuildListInternal()
	if CLIENT then return end
	if not self.Network.Active then return end

	self:ClearData()

	if not self:IsVisible() then
		self:UpdateButtons()
		self:RestoreScrollPos()
		return
	end

	self.PathUid = StreamRadioLib.Util.Uid()
	local uid = self.PathUid

	StreamRadioLib.Filesystem.Find(self.Path.Value, function(success, files)
		if uid ~= self.PathUid then
			return
		end

		self:QueueCall("_BuildListInternalAsyc", uid, files or {})
	end)
end

function CLASS:_BuildListInternalAsyc(uid, files)
	if uid ~= self.PathUid then
		return
	end

	for i, v in ipairs(files) do
		local data = {}

		data.value = v
		data.text = v.file
		data.icon = v.type

		self:AddData(data, true)
	end

	self:UpdateButtons()
	self:QueueCall("RestoreScrollPos")
end

function CLASS:PostDupe(data)
	if StreamRadioLib.Filesystem.Exists(data.Path, StreamRadioLib.TYPE_FOLDER) then
		self:SetPath(data.Path)
	else
		self:SetPath("")
		self:CallHook("OnInvalidDupeFilepath")
	end
end

return true


--lua/streamradio_core/classes/ui/radio/gui_main.lua:
local StreamRadioLib = StreamRadioLib

if not istable(CLASS) then
	StreamRadioLib.ReloadClasses()
	return
end

local BASE = CLASS:GetBaseClass()

function CLASS:Create()
	BASE.Create(self)

	self.Browser = self:AddPanelByClassname("radio/gui_browser", true)
	self.Browser:SetName("browser")
	self.Browser:SetNWName("brw")
	self.Browser:SetZPos(50)
	self.Browser:Open()
	self.Browser:SetSkinIdentifyer("browser")

	self.Player = self:AddPanelByClassname("radio/gui_player", true)
	self.Player:SetName("player")
	self.Player:SetNWName("ply")
	self.Player:SetZPos(100)
	self.Player:Close()
	self.Player:SetSkinIdentifyer("player")

	self:SetShadowWidth(0)
	self.Browser:SetPadding(5)
	self.Player:SetPadding(5)

	self._showplaylist = true
	self._hasplaylist = false

	self.State = self:CreateListener({
		PlayerOpened = false,
	}, function(this, k, v)
		if not v then
			self.Player:Close()
			self.Browser:ActivateNetworkedMode()
			self.Browser:Open()
			self.Browser:CloseSingleItem()
		end

		if v then
			self.Browser:CloseSingleItem()
			self.Browser:Close()
			self.Player:ActivateNetworkedMode()
			self.Player:Open()

			self:EnablePlaylist(self._showplaylist)
			self:SetHasPlaylist(self._hasplaylist)

			if IsValid(self.StreamOBJ) then
				self.StreamOBJ:Play(true)
			end

			self:CallHook("OnPlayerShown")
		end

		self:SetNWBool(k, v)
		self:ApplyNetworkVars()
		self:InvalidateLayout()
	end)

	self.Browser.OnPlayItem = function(this, item)
		self:EnablePlaylist(true)
		self:Play(item)
	end

	self.Browser.OnPlaylistStartBuild = function(this, ...)
		return self:CallHook("OnPlaylistStartBuild", ...)
	end

	self.Browser.OnPlaylistEndBuild = function(this, ...)
		return self:CallHook("OnPlaylistEndBuild", ...)
	end

	self.Browser.OnPlaylistOpen = function(this, ...)
		return self:CallHook("OnPlaylistOpen", ...)
	end

	self.Browser.OnPlaylistClose = function(this, ...)
		return self:CallHook("OnPlaylistClose", ...)
	end

	self.Browser.OnToolButtonClick = function()
		self:CallHook("OnToolButtonClick")
	end

	self.Browser.OnWireButtonClick = function()
		self:CallHook("OnWireButtonClick")
	end

	self.Player.OnClose = function()
		self:Stop()
		self:CallHook("OnPlayerClosed")
	end

	self.Player.OnPlaylistBack = function()
		self:CallHook("OnPlaylistBack")
	end

	self.Player.OnPlaylistForward = function()
		self:CallHook("OnPlaylistForward")
	end

	self.Player.OnPlaybackLoopModeChange = function(this, newLoopMode)
		self:CallHook("OnPlaybackLoopModeChange", newLoopMode)
	end

	self:QueueCall("ActivateNetworkedMode")
	self:InvalidateLayout()
end

function CLASS:Stop()
	if not self.State.PlayerOpened then
		return
	end

	self:ClosePlayer()
	self:CallHook("OnStop")
end

function CLASS:Play(item)
	if not item then
		self:Stop()
		return
	end

	self:OpenPlayer()
	self:CallHook("OnPlayItem", item)
end

function CLASS:OpenPlayer()
	self.State.PlayerOpened = true
end

function CLASS:ClosePlayer()
	self.State.PlayerOpened = false
end

function CLASS:PerformLayout(...)
	BASE.PerformLayout(self, ...)

	if not IsValid(self.Player) then return end
	if not IsValid(self.Browser) then return end

	local w, h = self:GetClientSize()

	self.Player:SetPos(0, 0)
	self.Player:SetSize(w, h)
	self.Browser:SetPos(0, 0)
	self.Browser:SetSize(w, h)
end

function CLASS:SetStream(stream)
	if self.StreamOBJ == stream then
		return
	end

	self.StreamOBJ = stream

	if IsValid(self.Player) then
		self.Player:SetStream(stream)
	end
end

function CLASS:GetStream()
	return self.StreamOBJ
end

function CLASS:EnablePlaylist(bool)
	self._showplaylist = bool
	self.Player:EnablePlaylist(bool and self._hasplaylist)
end

function CLASS:GetHasPlaylist()
	return self._hasplaylist or false
end

function CLASS:SetHasPlaylist(bool)
	self._hasplaylist = bool
	self.Player:EnablePlaylist(bool and self._showplaylist)

	self.Player:SetHasPlaylist(bool)
	self.Browser:SetHasPlaylist(bool)
end

function CLASS:IsPlaylistEnabled()
	return self.Player:IsPlaylistEnabled()
end

function CLASS:UpdatePlaybackLoopMode(...)
	self.Player:UpdatePlaybackLoopMode(...)
end

function CLASS:SetSyncMode(...)
	self.Player:SetSyncMode(...)
end

function CLASS:GetSyncMode()
	return self.Player:GetSyncMode()
end

function CLASS:IsPlayerOpen()
	return self.State.PlayerOpened or false
end

function CLASS:ActivateNetworkedMode()
	BASE.ActivateNetworkedMode(self)
	self.Browser:ActivateNetworkedMode()
	self.Player:ActivateNetworkedMode()

	if SERVER then
		self:SetNWBool("PlayerOpened", self.State.PlayerOpened)
		return
	end

	self:SetNWVarCallback("PlayerOpened", "Bool", function(this, nwkey, oldvar, newvar)
		self.State.PlayerOpened = newvar
	end)
end

function CLASS:ApplyNetworkVarsInternal()
	BASE.ApplyNetworkVarsInternal(self)

	self.State.PlayerOpened = self:GetNWBool("PlayerOpened", false)
end

function CLASS:PreDupe()
	local data = {}

	data.PlayerOpened = self.State.PlayerOpened

	return data
end

function CLASS:PostDupe(data)
	self.State.PlayerOpened = data.PlayerOpened
end

return true


--lua/streamradio_core/classes/stream.lua:
return gluapack()()
--lua/streamradio_core/properties.lua:

local StreamRadioLib = StreamRadioLib

StreamRadioLib.properties = StreamRadioLib.properties or {}

local LIB = StreamRadioLib.properties
table.Empty(LIB)

local LIBNet = StreamRadioLib.Net
local LIBError = StreamRadioLib.Error
local LIBUtil = StreamRadioLib.Util
local LIBUrl = StreamRadioLib.Url

local g_mainOptionAdded = false
local g_subOptions = {}
local g_nameprefix = "3dstreamradio_properties_"

local g_mode_play = 0
local g_mode_pause = 1
local g_mode_stop = 2
local g_mode_previous_track = 3
local g_mode_next_track = 4
local g_mode_rewind = 5
local g_mode_fastforward = 6

local g_mode_mute = 0
local g_mode_unmute = 1
local g_mode_volume_up = 2
local g_mode_volume_down = 3

if SERVER then
	LIBNet.Receive("properties", function(len, client)
		if not IsValid(client) then return end

		local name = net.ReadString()
		if not name then return end

		local subOption = g_subOptions[name]
		if not subOption then return end
		if not subOption.Receive then return end

		subOption:Receive(len, client)
	end)
end

function LIB.GetName(identifier)
	identifier = g_nameprefix .. tostring(identifier or "")
	identifier = string.lower(identifier)

	return identifier
end

function LIB.Get(identifier)
	identifier = LIB.GetName(identifier)

	return properties.List[identifier] or g_subOptions[identifier]
end

function LIB.Add(identifier, propertyData)
	identifier = LIB.GetName(identifier)

	return properties.Add(identifier, propertyData)
end

function LIB.CanProperty(identifier, ent, ply )
	if not IsValid( ent ) then return false end
	if not ent.__IsRadio then return false end

	identifier = LIB.GetName(identifier)
	if not gamemode.Call( "CanProperty", ply, identifier, ent ) then return false end

	return true
end

function LIB.CanBeTargeted(ent, ply)
	if not IsValid( ent ) then return false end
	if not ent.__IsRadio then return false end
	if not properties.CanBeTargeted( ent, ply ) then return false end

	return true
end

function LIB.CheckFilter(identifier, ent, ply)
	local propertyData = LIB.Get(identifier)

	if not propertyData then
		return true
	end

	if not propertyData.Filter then
		return true
	end

	return propertyData:Filter(ent, ply)
end

function LIB.CheckFilters(identifiers, ent, ply)
	for i, identifier in ipairs(identifiers) do
		if LIB.CheckFilter(identifier, ent, ply) then
			return true
		end
	end

	return false
end

local g_meta = {
	MsgStart = function(self)
		LIBNet.Start("properties")
		net.WriteString(self.InternalName)
	end,

	MsgEnd = function(self)
		net.SendToServer()
	end
}

g_meta.__index = g_meta

local function addMainOption()
	if g_mainOptionAdded then
		return
	end

	LIB.Add("radio_options", {
		MenuLabel = "Radio Options",
		Order = 10000,
		MenuIcon = "3dstreamradio/icon16/format_radio.png",

		Filter = function( self, ent, ply )
			if not LIB.CanBeTargeted( ent, ply ) then return false end
			return true
		end,

		MenuOpen = function( self, option, ent, tr )
			local ply = LocalPlayer()
			if not self:Filter(ent, ply) then return end

			local submenuPanel = option:AddSubMenu()

			submenuPanel:SetMinimumWidth(215)

			for k, subOption in SortedPairsByMemberValue( g_subOptions, "Order" ) do
				if not subOption.Filter then continue end
				if not subOption:Filter(ent, ply) then continue end

				if subOption.PrependSpacer then
					submenuPanel:AddSpacer()
				end

				local label = subOption.MenuLabel or subOption.InternalName

				local optionPanel = submenuPanel:AddOption(
					label,
					function(panel)
						if not subOption:Filter(ent, ply) then
							return
						end

						subOption:Action(ent, tr)

						panel:Think()
					end
				)

				if subOption.OnCreate then
					subOption:OnCreate(submenuPanel, optionPanel)
				end

				if subOption.MenuIcon then
					optionPanel:SetImage(subOption.MenuIcon)
				end

				if subOption.MenuOpen then
					subOption:MenuOpen(optionPanel, ent, tr)
				end

				optionPanel._oldThink = optionPanel.Think
				optionPanel.Think = function(panel, ...)
					if not subOption.Think then
						return
					end

					if not subOption:Filter(ent, ply) then
						return
					end

					subOption:Think(panel, ent)

					if panel._oldThink then
						return panel:_oldThink(...)
					end
				end
			end
		end,

		Action = function( self, ent )
		end,

		Receive = function( self, length, ply )
		end
	})

	g_mainOptionAdded = true
end

function LIB.AddSubOption(identifier, propertyData)
	addMainOption()

	identifier = LIB.GetName(identifier)

	propertyData = table.Copy(propertyData)
	propertyData.InternalName = identifier

	setmetatable(propertyData, g_meta)

	g_subOptions[identifier] = propertyData
end

local function g_emptyFunction()
end

local g_titleOnCreate = function( self, submenuPanel, optionPanel )
	optionPanel.OnMousePressed = g_emptyFunction
	optionPanel.OnMouseReleased = g_emptyFunction
	optionPanel.DoClickInternal = g_emptyFunction

	optionPanel:SetEnabled(false)
	optionPanel:SetTextInset(2, 0)
	optionPanel:SetContentAlignment(5)
end

local g_VolumeMenuOpen = function( self, optionPanel, ent )
	optionPanel.OnMousePressed = g_emptyFunction
	optionPanel.OnMouseReleased = g_emptyFunction
	optionPanel.DoClickInternal = g_emptyFunction

	optionPanel:SetTextInset(10, 0)
	optionPanel:DockPadding(5, 5, 5, 5)

	local ply = LocalPlayer()

	local upButton = vgui.Create( "DButton", optionPanel )
	optionPanel._upButton = upButton

	upButton:Dock(RIGHT)
	upButton:SetImage(StreamRadioLib.GetPNGIconPath("sound_add"))
	upButton:SetText("")
	upButton:DockMargin(5, 0, 0, 0)
	upButton:SetTooltip("Increase volume")

	upButton.DoClick = function(panel)
		if not self.VolumeUp then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:VolumeUp(ent)
		panel:Think()
	end

	local downButton = vgui.Create( "DButton", optionPanel )
	optionPanel._downButton = downButton

	downButton:Dock(RIGHT)
	downButton:SetImage(StreamRadioLib.GetPNGIconPath("sound_delete"))
	downButton:SetText("")
	downButton:DockMargin(5, 0, 0, 0)
	downButton:SetTooltip("Decrease volume")

	downButton.DoClick = function(panel)
		if not self.VolumeDown then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:VolumeDown(ent)
		panel:Think()
	end

	local muteButton = vgui.Create( "DButton", optionPanel )
	optionPanel._muteButton = muteButton

	muteButton:Dock(RIGHT)
	muteButton:SetImage(StreamRadioLib.GetPNGIconPath("sound_mute"))
	muteButton:SetText("")
	muteButton:DockMargin(0, 0, 0, 0)
	muteButton:SetTooltip("Mute")

	muteButton.DoClick = function(panel)
		if not self.Mute then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Mute(ent)
		panel:Think()
	end

	local unmuteButton = vgui.Create( "DButton", optionPanel )
	optionPanel._unmuteButton = unmuteButton

	unmuteButton:Dock(RIGHT)
	unmuteButton:SetImage(StreamRadioLib.GetPNGIconPath("sound"))
	unmuteButton:SetText("")
	unmuteButton:DockMargin(0, 0, 0, 0)
	unmuteButton:SetTooltip("Unmute")

	unmuteButton.DoClick = function(panel)
		if not self.Unmute then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Unmute(ent)
		panel:Think()
	end

	-- bypass hardcoded size in internal PerformLayout
	optionPanel._SetSize = optionPanel.SetSize

	optionPanel.SetSize = function(panel, x, y)
		y = 40
		local buttonSize = y - 10

		upButton:SetSize(buttonSize, buttonSize)
		downButton:SetSize(buttonSize, buttonSize)
		muteButton:SetSize(buttonSize, buttonSize)
		unmuteButton:SetSize(buttonSize, buttonSize)

		return panel:_SetSize(x, y)
	end
end

local g_PlaylistControlsMenuOpen = function( self, optionPanel, ent )
	optionPanel.OnMousePressed = g_emptyFunction
	optionPanel.OnMouseReleased = g_emptyFunction
	optionPanel.DoClickInternal = g_emptyFunction

	optionPanel:SetTextInset(5, 0)
	optionPanel:DockPadding(5, 5, 5, 5)

	local ply = LocalPlayer()

	local playButton = vgui.Create( "DButton", optionPanel )
	optionPanel._playButton = playButton

	playButton:Dock(LEFT)
	playButton:SetImage(StreamRadioLib.GetPNGIconPath("control_play"))
	playButton:SetText("")
	playButton:DockMargin(0, 0, 0, 0)
	playButton:SetTooltip("Play")

	playButton.DoClick = function(panel)
		if not self.Play then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Play(ent)
		panel:Think()
	end

	local pauseButton = vgui.Create( "DButton", optionPanel )
	optionPanel._pauseButton = pauseButton

	pauseButton:Dock(LEFT)
	pauseButton:SetImage(StreamRadioLib.GetPNGIconPath("control_pause"))
	pauseButton:SetText("")
	pauseButton:DockMargin(0, 0, 0, 0)
	pauseButton:SetTooltip("Pause")

	pauseButton.DoClick = function(panel)
		if not self.Pause then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Pause(ent)
		panel:Think()
	end

	local stopButton = vgui.Create( "DButton", optionPanel )
	optionPanel._stopButton = stopButton

	stopButton:Dock(LEFT)
	stopButton:SetImage(StreamRadioLib.GetPNGIconPath("control_stop"))
	stopButton:SetText("")
	stopButton:DockMargin(5, 0, 0, 0)
	stopButton:SetTooltip("Stop")

	stopButton.DoClick = function(panel)
		if not self.Stop then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Stop(ent)
		panel:Think()
	end

	local previousTrackButton = vgui.Create( "DButton", optionPanel )
	optionPanel._previousTrackButton = previousTrackButton

	previousTrackButton:Dock(LEFT)
	previousTrackButton:SetImage(StreamRadioLib.GetPNGIconPath("control_start"))
	previousTrackButton:SetText("")
	previousTrackButton:DockMargin(5, 0, 0, 0)
	previousTrackButton:SetTooltip("Previous track")

	previousTrackButton.DoClick = function(panel)
		if not self.PreviousTrack then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:PreviousTrack(ent)
		panel:Think()
	end

	local nextTrackButton = vgui.Create( "DButton", optionPanel )
	optionPanel._nextTrackButton = nextTrackButton

	nextTrackButton:Dock(LEFT)
	nextTrackButton:SetImage(StreamRadioLib.GetPNGIconPath("control_end"))
	nextTrackButton:SetText("")
	nextTrackButton:DockMargin(5, 0, 0, 0)
	nextTrackButton:SetTooltip("Next track")

	nextTrackButton.DoClick = function(panel)
		if not self.NextTrack then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:NextTrack(ent)
		panel:Think()
	end

	local rewindButton = vgui.Create( "DButton", optionPanel )
	optionPanel._rewindButton = rewindButton

	rewindButton:Dock(LEFT)
	rewindButton:SetImage(StreamRadioLib.GetPNGIconPath("control_rewind"))
	rewindButton:SetText("")
	rewindButton:DockMargin(5, 0, 0, 0)
	rewindButton:SetTooltip("Rewind 10 seconds")

	rewindButton.DoClick = function(panel)
		if not self.Rewind then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:Rewind(ent)
		panel:Think()
	end

	local fastForwardButton = vgui.Create( "DButton", optionPanel )
	optionPanel._fastForwardButton = fastForwardButton

	fastForwardButton:Dock(LEFT)
	fastForwardButton:SetImage(StreamRadioLib.GetPNGIconPath("control_fastforward"))
	fastForwardButton:SetText("")
	fastForwardButton:DockMargin(5, 0, 0, 0)
	fastForwardButton:SetTooltip("Fast forward 10 seconds")

	fastForwardButton.DoClick = function(panel)
		if not self.FastForward then
			return
		end

		if not self:Filter(ent, ply) then
			return
		end

		self:FastForward(ent)
		panel:Think()
	end

	-- bypass hardcoded size in internal PerformLayout
	optionPanel._SetSize = optionPanel.SetSize

	optionPanel.SetSize = function(panel, x, y)
		y = 40
		local buttonSize = y - 10

		playButton:SetSize(buttonSize, buttonSize)
		pauseButton:SetSize(buttonSize, buttonSize)
		stopButton:SetSize(buttonSize, buttonSize)
		previousTrackButton:SetSize(buttonSize, buttonSize)
		nextTrackButton:SetSize(buttonSize, buttonSize)
		rewindButton:SetSize(buttonSize, buttonSize)
		fastForwardButton:SetSize(buttonSize, buttonSize)

		return panel:_SetSize(x, y)
	end
end

LIB.AddSubOption("clientside_title", {
	MenuLabel = "Clientside Options",
	Order = 100,
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end

		local allowed = LIB.CheckFilters(
			{
				"copy_url",
				"error_info",
				"clientside_mute",
				"clientside_unmute",
				"clientside_volume",
			},
			ent,
			ply
		)

		return allowed
	end,

	Action = function( self, ent )
	end,

	OnCreate = g_titleOnCreate,
})

LIB.AddSubOption("copy_url", {
	MenuLabel = "Copy Stream URL to clipboard",
	Order = 110,
	MenuIcon = StreamRadioLib.GetPNGIconPath("page_copy"),
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end

		local url = ent:GetStreamURL()
		if url == "" then return false end

		return true
	end,

	Action = function( self, ent )
		local url = ent:GetStreamURL()
		SetClipboardText(url)
	end,
})

LIB.AddSubOption("error_info", {
	MenuLabel = "Error",
	Order = 111,
	MenuIcon = StreamRadioLib.GetPNGIconPath("error"),

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end

		local stream = ent:GetStreamObject()
		if not stream then return false end
		if not stream:HasError() then return false end

		return true
	end,

	Action = function( self, ent )
		local stream = ent:GetStreamObject()

		if stream:IsKilled() then
			stream:ReviveStream()
			return
		end

		local err = stream:GetError()
		local url = stream:GetURL()

		StreamRadioLib.ShowErrorHelp(err, url)
	end,

	Think = function( self, optionPanel, ent )
		local stream = ent:GetStreamObject()

		if stream:IsKilled() then
			local label = string.format("%s: %s", self.MenuLabel, "Sound stopped!")
			local tooltip = "The sound has been stopped. Click here to restart."

			optionPanel:SetText(label)
			optionPanel:SetTooltip(tooltip)
			return
		end

		local err = stream:GetError()
		local url = stream:GetURL()

		local errorInfo = LIBError.GetStreamErrorInfo(err)
		local errorName = errorInfo.name
		local errorDescription = errorInfo.description
		local hasHelpmenu = errorInfo.helpmenu

		local label = string.format("%s: %i (%s)", self.MenuLabel, err, errorName)

		local tooltip = ""

		if hasHelpmenu then
			tooltip = string.format("Error %i (%s): %s\n\nCan not play this URL:\n%s\n\nClick for more details.", err, errorName, errorDescription, url)
		else
			tooltip = string.format("Error %i (%s): %s\n\nCan not play this URL:\n%s", err, errorName, errorDescription, url)
		end

		optionPanel:SetText(label)
		optionPanel:SetTooltip(tooltip)
	end,
})

LIB.AddSubOption("reset_gui", {
	MenuLabel = "Reset GUI",
	Order = 112,
	MenuIcon = StreamRadioLib.GetPNGIconPath("lightning"),

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		if ent.DisplayLess then return false end

		return true
	end,

	Action = function( self, ent )
		ent:RemoveGui()
	end,
})

LIB.AddSubOption("clientside_volume", {
	MenuLabel = "Volume",
	Order = 120,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		return true
	end,

	Action = function( self, ent )
	end,

	Mute = function( self, ent )
		ent:SetCLMute(true)
	end,

	Unmute = function( self, ent )
		ent:SetCLMute(false)
	end,

	VolumeUp = function( self, ent )
		local volume = ent:GetCLVolume()

		volume = math.Clamp(volume + 0.2, 0, 1)
		volume = math.Round(volume, 2)

		ent:SetCLVolume(volume)
	end,

	VolumeDown = function( self, ent )
		local volume = ent:GetCLVolume()

		volume = math.Clamp(volume - 0.2, 0, 1)
		volume = math.Round(volume, 2)

		ent:SetCLVolume(volume)
	end,

	Think = function( self, optionPanel, ent )
		local volume = ent:GetCLVolume()
		local isMuted = ent:GetCLMute()

		local label = string.format("%s: %3i%%", self.MenuLabel, volume * 100)

		optionPanel:SetText(label)

		local upButton = optionPanel._upButton
		local downButton = optionPanel._downButton
		local muteButton = optionPanel._muteButton
		local unmuteButton = optionPanel._unmuteButton

		if IsValid(upButton) then
			upButton:SetEnabled(volume < 1)
		end

		if IsValid(downButton) then
			downButton:SetEnabled(volume > 0)
		end

		if IsValid(muteButton) then
			muteButton:SetVisible(not isMuted)
		end

		if IsValid(unmuteButton) then
			unmuteButton:SetVisible(isMuted)
		end
	end,

	MenuOpen = g_VolumeMenuOpen,
})

LIB.AddSubOption("serverside_title", {
	MenuLabel = "Entity Options",
	Order = 200,
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end

		local allowed = LIB.CheckFilters(
			{
				"serverside_volume",
			},
			ent,
			ply
		)

		return allowed
	end,

	Action = function( self, ent )
	end,

	OnCreate = g_titleOnCreate,
})

LIB.AddSubOption("playlist_controls", {
	MenuLabel = "",
	Order = 210,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		if not LIB.CanProperty("playlist_controls", ent, ply ) then return false end

		local stream = ent:GetStreamObject()
		if not IsValid(stream) then
			return false
		end

		local hasPlaylist = ent:GetHasPlaylist()
		local url = ent:GetStreamURL()

		if not hasPlaylist and url == "" then
			return false
		end

		return true
	end,

	Action = function( self, ent )
	end,

	DoControl = function( self, ent, mode )
		self:MsgStart()
			net.WriteEntity( ent )
			net.WriteUInt( mode, 4 )
		self:MsgEnd()
	end,

	Play = function( self, ent )
		local stream = ent:GetStreamObject()

		if stream:IsKilled() then
			stream:ReviveStream()
		end

		self:DoControl(ent, g_mode_play)
	end,

	Pause = function( self, ent )
		self:DoControl(ent, g_mode_pause)
	end,

	Stop = function( self, ent )
		self:DoControl(ent, g_mode_stop)
	end,

	PreviousTrack = function( self, ent )
		self:DoControl(ent, g_mode_previous_track)
	end,

	NextTrack = function( self, ent )
		self:DoControl(ent, g_mode_next_track)
	end,

	Rewind = function( self, ent )
		self:DoControl(ent, g_mode_rewind)
	end,

	FastForward = function( self, ent )
		self:DoControl(ent, g_mode_fastforward)
	end,

	Think = function( self, optionPanel, ent )
		local stream = ent:GetStreamObject()
		if not IsValid(stream) then return end

		local isPlayMode = stream:IsPlayMode()
		local isStopMode = stream:IsStopMode()

		if stream:IsKilled() then
			isPlayMode = false
			isStopMode = true
		end

		local isEndless = stream:IsEndless()

		local hasPlaylist = ent:GetHasPlaylist()

		local playButton = optionPanel._playButton
		local pauseButton = optionPanel._pauseButton
		local stopButton = optionPanel._stopButton
		local previousTrackButton = optionPanel._previousTrackButton
		local nextTrackButton = optionPanel._nextTrackButton
		local rewindButton = optionPanel._rewindButton
		local fastForwardButton = optionPanel._fastForwardButton

		if IsValid(stopButton) then
			stopButton:SetEnabled(not isStopMode)
		end

		if IsValid(playButton) then
			playButton:SetVisible(not isPlayMode)
		end

		if IsValid(pauseButton) then
			pauseButton:SetVisible(isPlayMode)
		end

		if IsValid(previousTrackButton) then
			previousTrackButton:SetEnabled(hasPlaylist)
		end

		if IsValid(nextTrackButton) then
			nextTrackButton:SetEnabled(hasPlaylist)
		end

		if IsValid(rewindButton) then
			rewindButton:SetEnabled(not isEndless)
		end

		if IsValid(fastForwardButton) then
			fastForwardButton:SetEnabled(not isEndless)
		end
	end,

	MenuOpen = g_PlaylistControlsMenuOpen,

	Receive = function( self, length, ply )
		local ent = net.ReadEntity()
		local mode = net.ReadUInt(4)

		if not self:Filter( ent, ply ) then return end

		local stream = ent:GetStreamObject()

		if mode == g_mode_play then
			local hasEnded = stream:HasEnded()
			local isPauseMode = stream:IsPauseMode()

			if isPauseMode and not hasEnded then
				stream:Play(hasEnded)
			else
				ent:PlayFromCurrentPlaylistItem()
			end
		elseif mode == g_mode_pause then
			stream:Pause()
		elseif mode == g_mode_stop then
			stream:Stop()
		elseif mode == g_mode_previous_track then
			ent:PlayPreviousPlaylistItem()
		elseif mode == g_mode_next_track then
			ent:PlayNextPlaylistItem()
		elseif mode == g_mode_rewind then
			local length = stream:GetMasterLength()

			if length > 0 then
				local time = stream:GetMasterTime()
				local newtime = math.Clamp(time - 10, 0, length - 0.1)

				stream:SetTime(newtime, true)
			end
		elseif mode == g_mode_fastforward then
			local length = stream:GetMasterLength()

			if length > 0 then
				local time = stream:GetMasterTime()
				local newtime = math.Clamp(time + 10, 0, length - 0.1)

				stream:SetTime(newtime, true)
			end
		end
	end
})

LIB.AddSubOption("serverside_volume", {
	MenuLabel = "Volume",
	Order = 220,

	Filter = function( self, ent, ply )
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		if not LIB.CanProperty("serverside_volume", ent, ply ) then return false end

		return true
	end,

	Action = function( self, ent )
	end,

	DoControl = function( self, ent, mode )
		self:MsgStart()
			net.WriteEntity( ent )
			net.WriteUInt( mode, 4 )
		self:MsgEnd()
	end,

	Mute = function( self, ent )
		self:DoControl(ent, g_mode_mute)
	end,

	Unmute = function( self, ent )
		self:DoControl(ent, g_mode_unmute)
	end,

	VolumeUp = function( self, ent )
		self:DoControl(ent, g_mode_volume_up)
	end,

	VolumeDown = function( self, ent )
		self:DoControl(ent, g_mode_volume_down)
	end,

	Think = function( self, optionPanel, ent )
		local volume = ent:GetVolume()
		local isMuted = ent:GetSVMute()

		local label = string.format("%s: %3i%%", self.MenuLabel, volume * 100)

		optionPanel:SetText(label)

		local upButton = optionPanel._upButton
		local downButton = optionPanel._downButton
		local muteButton = optionPanel._muteButton
		local unmuteButton = optionPanel._unmuteButton

		if IsValid(upButton) then
			upButton:SetEnabled(volume < 1)
		end

		if IsValid(downButton) then
			downButton:SetEnabled(volume > 0)
		end

		if IsValid(muteButton) then
			muteButton:SetVisible(not isMuted)
		end

		if IsValid(unmuteButton) then
			unmuteButton:SetVisible(isMuted)
		end
	end,

	MenuOpen = g_VolumeMenuOpen,

	Receive = function( self, length, ply )
		local ent = net.ReadEntity()
		local mode = net.ReadUInt(4)

		if not self:Filter( ent, ply ) then return end

		if mode == g_mode_mute then
			ent:SetSVMute(true)
		elseif mode == g_mode_unmute then
			ent:SetSVMute(false)
		elseif mode == g_mode_volume_up then
			local volume = ent:GetVolume()

			volume = math.Clamp(volume + 0.2, 0, 1)
			volume = math.Round(volume, 2)

			ent:SetVolume(volume)
		elseif mode == g_mode_volume_down then
			local volume = ent:GetVolume()

			volume = math.Clamp(volume - 0.2, 0, 1)
			volume = math.Round(volume, 2)

			ent:SetVolume(volume)
		end
	end
})

LIB.AddSubOption("admin_title", {
	MenuLabel = "Admin Options",
	Order = 300,
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIBUtil.IsAdmin( ply ) then return false end
		if not LIB.CanBeTargeted( ent, ply ) then return false end

		local url = ent:GetStreamURL()
		if url ~= "" then
			local context = StreamRadioLib.Whitelist.BuildContext(ent, ply)

			-- Trigger updating the cache in the background if needed
			StreamRadioLib.Whitelist.IsAllowedAsync(url, context)
		end

		local allowed = LIB.CheckFilters(
			{
				"admin_whitelist_add",
				"admin_whitelist_remove",
			},
			ent,
			ply
		)

		return allowed
	end,

	Action = function( self, ent )
	end,

	OnCreate = g_titleOnCreate,
})

LIB.AddSubOption("admin_whitelist_add", {
	MenuLabel = "Add to quick whitelist",
	Order = 310,
	MenuIcon = StreamRadioLib.GetPNGIconPath("shield_add"),
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIBUtil.IsAdmin( ply ) then return false end
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		if not StreamRadioLib.IsUrlWhitelistEnabled() then return false end

		local url = ent:GetStreamURL()
		if url == "" then return false end

		if LIBUrl.IsOfflineURL(url) then
			return false
		end

		local context = StreamRadioLib.Whitelist.BuildContext(ent, ply)
		local result, blockedByHook = StreamRadioLib.Whitelist.IsAllowedSync(url, context)

		if blockedByHook then return false end
		if result then return false end

		return true
	end,

	Action = function( self, ent )
		local url = ent:GetStreamURL()
		StreamRadioLib.Whitelist.QuickWhitelistAdd(url)

		-- Trigger updating the cache in the background if needed
		local context = StreamRadioLib.Whitelist.BuildContext(ent)
		StreamRadioLib.Whitelist.IsAllowedAsync(url, context)
	end,
})

LIB.AddSubOption("admin_whitelist_remove", {
	MenuLabel = "Remove from quick whitelist",
	Order = 320,
	MenuIcon = StreamRadioLib.GetPNGIconPath("shield_delete"),
	PrependSpacer = true,

	Filter = function( self, ent, ply )
		if not LIBUtil.IsAdmin( ply ) then return false end
		if not LIB.CanBeTargeted( ent, ply ) then return false end
		if not StreamRadioLib.IsUrlWhitelistEnabled() then return false end

		local url = ent:GetStreamURL()
		if url == "" then return false end

		if LIBUrl.IsOfflineURL(url) then
			return false
		end

		local context = StreamRadioLib.Whitelist.BuildContext(ent, ply)
		local result, blockedByHook = StreamRadioLib.Whitelist.IsAllowedSync(url, context)

		if blockedByHook then return false end
		if not result then return false end

		return true
	end,

	Action = function( self, ent )
		local url = ent:GetStreamURL()
		StreamRadioLib.Whitelist.QuickWhitelistRemove(url)

		-- Trigger updating the cache in the background if needed
		local context = StreamRadioLib.Whitelist.BuildContext(ent)
		StreamRadioLib.Whitelist.IsAllowedAsync(url, context)
	end,
})

return true


--lua/streamradio_core/vr.lua:
local StreamRadioLib = StreamRadioLib

StreamRadioLib.VR = StreamRadioLib.VR or {}

local LIB = StreamRadioLib.VR
table.Empty(LIB)

function LIB.IsInstalled()
	return istable(vrmod)
end

function LIB.IsActive(ply)
	if not LIB.IsInstalled() then return false end

	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then return false end
	if not ply:IsPlayer() then return false end
	if ply:IsBot() then return false end

	return vrmod.IsPlayerInVR(ply)
end

function LIB.Debug(txt)
	if not LIB.IsActive() then return end

	txt = tostring(txt)
	if txt == "" then return end

	if CLIENT then
		chat.AddText(txt)
	else
		MsgN(txt)
	end
end

function LIB.GetControlPosDir(ply)
	if not LIB.IsInstalled() then return nil end

	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then return nil end

	-- Only allow for Hands
	if not LIB.HandsEquipped(ply) then
		return nil
	end

	-- Check if the player can make inputs at all
	if not LIB.GetVREnableTrigger(ply) and not LIB.GetVREnableTouch(ply) then
		return nil
	end

	-- Only allow if there is no focus on any menu
	if LIB.MenuIsOpen() then
		return nil
	end

	local pos, ang = vrmod.GetRightHandPose(ply)
	if not pos or not ang then
		return nil
	end

	local dir = ang:Forward()
	return pos, dir
end

function LIB.GetCameraPos(ply)
	if not LIB.IsInstalled() then return nil end

	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then return nil end

	local pos, ang = vrmod.GetHMDPose(ply)
	if not pos then
		return nil
	end

	if not ang then
		return nil
	end

	return pos, ang
end

function LIB.HandsEquipped(ply)
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not IsValid(ply) then
		return false
	end

	if ply:InVehicle() then
		return true
	end

	return vrmod.UsingEmptyHands(ply)
end

function LIB.GetTriggerPressed()
	if not CLIENT then
		return false
	end

	if not LIB.IsActive() then
		return false
	end

	if not LIB.GetVREnableTrigger() then
		return false
	end

	if not LIB.HandsEquipped() then
		return false
	end

	return vrmod.GetInput("boolean_primaryfire") or false
end

function LIB.GetRadioTouched()
	if not CLIENT then
		return false
	end

	if not LIB.GetVREnableTouch() then
		return false
	end

	if not LIB.HandsEquipped() then
		return false
	end

	local trace = LIB.TraceHand()
	if not trace then
		return false
	end

	if not trace.Hit then
		return false
	end

	local ent = trace.Entity

	if not IsValid(ent) then
		return false
	end

	if not ent.__IsRadio then
		return false
	end

	return true
end

local g_PlayerHandTraceCache = nil
local g_PlayerHandTrace = {}

g_PlayerHandTrace.output = {}
g_PlayerHandTrace.filter = {}

function LIB.TraceHand()
	if not CLIENT then
		return nil
	end

	if not LIB.IsActive() then
		g_PlayerHandTraceCache = nil
		return nil
	end

	if g_PlayerHandTraceCache and StreamRadioLib.Util.IsSameFrame("StreamRadioLib.VR.TraceHand") then
		return g_PlayerHandTraceCache
	end

	g_PlayerHandTraceCache = nil

	local pos, dir = LIB.GetControlPosDir()

	if not pos then
		return nil
	end

	if not dir then
		return nil
	end

	local start_pos = pos
	local end_pos = pos + dir * 6.5

	g_PlayerHandTrace.start = start_pos
	g_PlayerHandTrace.endpos = end_pos

	local ply = LocalPlayer()
	local plyVehicle = ply.GetVehicle and ply:GetVehicle() or false

	local tmp = {}

	tmp[ply] = ply
	tmp[plyVehicle] = plyVehicle

	local filter = g_PlayerHandTrace.filter
	table.Empty(filter)

	for _, filterEnt in pairs(tmp) do
		if not IsValid(filterEnt) then continue end
		table.insert(filter, filterEnt)
	end

	util.TraceLine(g_PlayerHandTrace)
	g_PlayerHandTraceCache = g_PlayerHandTrace.output

	return g_PlayerHandTraceCache
end

function LIB.GetVREnableTouch(ply)
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not LIB.IsActive(ply) then return false end
	return tobool(ply:GetInfo("cl_streamradio_vr_enable_touch"))
end

function LIB.GetVREnableTrigger(ply)
	if not IsValid(ply) and CLIENT then
		ply = LocalPlayer()
	end

	if not LIB.IsActive(ply) then return false end
	return tobool(ply:GetInfo("cl_streamradio_vr_enable_trigger"))
end

function LIB.GetMenuUid(panel)
	if not panel then
		return nil
	end

	if isstring(panel) then
		if panel == "" then
			return nil
		end

		return panel, LIB.g_openMenus and LIB.g_openMenus[panel]
	end

	local curPanel = panel

	while true do
		if not IsValid(curPanel) then
			return nil
		end

		if curPanel == g_SpawnMenu then
			return "spawnmenu", curPanel
		end

		if curPanel == g_ContextMenu then
			return "spawnmenu", curPanel
		end

		local uid = tostring(curPanel._streamradio_vr_uid or "")
		if uid ~= "" then
			return uid, curPanel
		end

		curPanel = curPanel:GetParent()
	end

	return nil
end

function LIB.MenuIsOpen(panelOrUid)
	if not CLIENT then
		return false
	end

	if not LIB.IsActive() then
		return false
	end

	if not panelOrUid then
		panelOrUid = vrmod.MenuFocused()
	end

	panelOrUid = LIB.GetMenuUid(panelOrUid)

	if not panelOrUid then
		return false
	end

	if not vrmod.MenuExists(panelOrUid) then
		return false
	end

	return true
end

function LIB.CloseMenu(panel)
	if not CLIENT then
		return
	end

	local uid, mainPanel = LIB.GetMenuUid(panel)
	if not uid then
		return
	end

	if not IsValid(mainPanel) then
		mainPanel = panel
	end

	LIB.g_openMenus = LIB.g_openMenus or {}
	LIB.g_openMenus[uid] = nil

	if ispanel(mainPanel) then
		mainPanel:Close()
	end

	if not LIB.MenuIsOpen(uid) then
		return
	end

	vrmod.MenuClose(uid)
end

function LIB.RenderMenu(panel)
	if not CLIENT then
		return
	end

	local uid, mainPanel = LIB.GetMenuUid(panel)
	if not uid then
		return
	end

	if not LIB.MenuIsOpen(uid) then
		return
	end

	if not IsValid(mainPanel) then
		mainPanel = panel
	end

	if ispanel(mainPanel) then
		timer.Simple(0.1, function()
			if not LIB.MenuIsOpen(uid) then
				return
			end

			if not IsValid(mainPanel) then
				return
			end

			vrmod.MenuRenderStart(uid)

			StreamRadioLib.Util.CatchAndErrorNoHaltWithStack(function()
				mainPanel:PaintManual()
			end)

			vrmod.MenuRenderEnd(uid)
		end)
	end
end

function LIB.MenuOpen(uid, panel, cursorEnabled, closeFunc)
	if not CLIENT then
		return
	end

	if not IsValid(panel) then
		return
	end

	uid = tostring(uid or "")
	if uid == "" then
		return
	end

	panel._streamradio_vr_uid = uid
	LIB.CloseMenu(panel)

	LIB.g_openMenus = LIB.g_openMenus or {}
	LIB.g_openMenus[uid] = panel

	panel:SetVisible(true)
	panel:MakePopup()
	panel:InvalidateLayout(true)

	if not LIB.IsActive() then
		return
	end

	local campos, camang = LIB.GetCameraPos()

	if not campos then
		return
	end

	if not camang then
		return
	end

	local scale = 0.04

	local w, h = panel:GetSize()

	local ang = Angle(0, camang.y - 90, 85)
	local pos = campos + Vector(0, 0, -10) + Angle(0, camang.y, 0):Forward() * 30 - ang:Forward() * w / 2 * scale - ang:Right() * h / 2 * scale
	local originPos, originAng = vrmod.GetOrigin()

	pos, ang = WorldToLocal(pos, ang, originPos, originAng)

	vrmod.MenuCreate(uid, w, h, panel, 4, pos, ang, scale, cursorEnabled, closeFunc)
end

if CLIENT then
	local function clearMenus()
		for k, v in pairs(LIB.g_openMenus or {}) do
			LIB.CloseMenu(v)
		end

		LIB.g_openMenus = nil
	end

	StreamRadioLib.Hook.Add("VRUtilStart", "CloseMenusOnVRStart", function()
		clearMenus()
	end)

	StreamRadioLib.Hook.Add("VRUtilExit", "CloseMenusOnVRExit", function()
		clearMenus()
	end)

	clearMenus()
end

return true


--lua/streamradio_core/client/cl_help.lua:
return gluapack()()
--lua/streamradio_core/client/cl_settings.lua:
return gluapack()()
--lua/autorun/svidetel_pm.lua:
player_manager.AddValidModel( "Wintess", "models/player/witness.mdl" );
player_manager.AddValidHands( "Wintess", "models/player/witness_arms.mdl", 0, "00000000" ) 
list.Set( "PlayerOptionsModel",  "Wintess", 					"models/player/witness.mdl" )

list.Set( "PlayerOptionsAnimations", "Wintess", { "menu_pose" } ) --PLAYERMODEL MENU ANIMATION

-- MODEL CREATED BY FiL0S0V https://steamcommunity.com/id/lolmen2003
--lua/svmod/cl_main.lua:
-- @class SVMOD
-- @clientside

-- Enables or disables SVMod on the server.
-- @tparam boolean result True to enable, false to disable
function SVMOD:SetAddonState(value)
	if not value then
		value = false
	end

	net.Start("SV_SetAddonState")
	net.WriteBool(value)
	net.SendToServer()
end

hook.Add("InitPostEntity", "SV_GetAddonStateOnInitialSpawn", function()
	SVMOD:Load()
	net.Start("SV_GetAddonState")
	net.SendToServer()
end)

net.Receive("SV_SetAddonState", function()
	local state = net.ReadBool()

	if state == SVMOD.IsEnabled then
		return
	end

	SVMOD.IsEnabled = state

	HTTP({
		url = "https://api.svmod.com/get_version.php",
		method = "GET",
		parameters = {
			server = game.GetIPAddress()
		},
		success = function(code, body)
			if code == 200 then
				SVMOD.FCFG.LastVersion = body
			end
		end
	})

	if SVMOD.IsEnabled then
		SVMOD.CFG.Contributor.EnterpriseID = net.ReadUInt(16) -- max: 65535
		hook.Run("SV_Enabled")
	else
		hook.Run("SV_Disabled")
	end
end)

hook.Add("SV_PlayerEnteredVehicle", "SV_Hint", function()
	if not LocalPlayer().SVHint then
		LocalPlayer().SVHint = true

		chat.AddText(Color(178, 95, 245), "SVMod: ", Color(255, 255, 255), language.GetPhrase("svmod.hint"))
	end
end)
--lua/svmod/compatibility/sh_compatiblity.lua:
return gluapack()()
--lua/svmod/compatibility/sh_vcmod.lua:
hook.Add("SV_Enabled", "SV_VCModCompatibility", function()
	if VCMOD then
		return
	end

	function SVMOD.Metatable:VC_fuelGet(percent)
		if percent then
			return self:SV_GetPercentFuel()
		else
			return self:SV_GetFuel()
		end
	end
	function SVMOD.Metatable:VC_GetFuel(percent)
		return self:VC_fuelGet(percent)
	end

	function SVMOD.Metatable:VC_getHealth(percent)
		if CLIENT or percent then
			return self:SV_GetPercentHealth()
		else
			return self:SV_GetHealth()
		end
	end
	function SVMOD.Metatable:VC_GetHealth(percent)
		return self:VC_getHealth(percent)
	end

	function SVMOD.Metatable:VC_getHealthMax()
		return self:SV_GetMaxHealth()
	end
	function SVMOD.Metatable:VC_GetMaxHealth()
		return self:VC_getHealthMax()
	end

	function SVMOD.Metatable:VC_getDamagedParts()
		return {}
	end
	function SVMOD.Metatable:VC_GetDamagedParts()
		return self:VC_getDamagedParts()
	end

	function VC_getSettings()
		SVMOD:PrintConsole(SVMOD.LOG.Error, "VC_getSettings called! This may generate errors because the SVMod cannot return the VCMod configuration file.")
	end
end)

--lua/svmod/fuel/sh_fuel.lua:
return gluapack()()
--lua/svmod/fuel/sh_fuel.lua:
-- @class SV_Vehicle
-- @shared

hook.Add("SV_LoadVehicle", "SV_LoadVehicle_Fuel", function(veh)
	veh.SV_MaxFuel = veh.SV_Data.Fuel.Capacity or 50
	veh.SV_Fuel = veh.SV_MaxFuel
end)

-- Gets the vehicle fuel in liters.
-- @tparam number fuel Fuel in liters
function SVMOD.Metatable:SV_GetFuel()
	if self:SV_IsPassengerSeat() then
		return self:SV_GetDriverSeat().SV_Fuel
	end
	return self.SV_Fuel
end

-- Gets the vehicle maximum fuel in liters.
-- @tparam number maxFuel Maximum fuel in liters
function SVMOD.Metatable:SV_GetMaxFuel()
	if self:SV_IsPassengerSeat() then
		return self:SV_GetDriverSeat().SV_MaxFuel
	end
	return self.SV_MaxFuel
end

-- Gets the vehicle fuel as a percentage.
-- @tparam number percentFuel Fuel in percentage
function SVMOD.Metatable:SV_GetPercentFuel()
	local MaxFuel = self:SV_GetMaxFuel()
	if MaxFuel == 0 then
		return 0
	end

	return self:SV_GetFuel() / MaxFuel * 100
end
--lua/svmod/gui/cl_utilitaries.lua:
return gluapack()()
--lua/svmod/gui/cl_utilitaries.lua:
surface.CreateFont("SV_CalibriLight22", {
	font = "Calibri Light",
	size = 22
})

surface.CreateFont("SV_CalibriLight18", {
	font = "Calibri Light",
	size = 18
})

surface.CreateFont("SV_Calibri18", {
	font = "Calibri",
	size = 18
})

local crossMaterial = Material("materials/vgui/svmod/cross.png", "noclamp smooth")

function SVMOD:CreateFrame(name)
	local frame = vgui.Create("DFrame")
	frame:SetSize(900, 650)
	frame:Center()
	frame:ShowCloseButton(false)
	frame:SetTitle("")
	frame.Paint = function(self, w, h)
		surface.SetDrawColor(18, 25, 31)
		surface.DrawRect(0, 0, w, h)

		surface.SetDrawColor(178, 95, 245)
		surface.DrawRect(0, 0, w, 4)
	end

	local closePanel = vgui.Create("DPanel", frame)
	closePanel:SetSize(24, 24)
	closePanel:SetPos(900 - 48, 11)
	closePanel.Paint = function(self, w, h)
		if self.isHovered then
			surface.SetDrawColor(237, 197, 255, 255)
		else
			surface.SetDrawColor(154, 128, 166, 255)
		end
		surface.SetMaterial(crossMaterial)
		surface.DrawTexturedRect(0, 0, w, h)
	end
	closePanel.OnCursorEntered = function(self)
		self.isHovered = true
		self:SetCursor("hand")
	end
	closePanel.OnCursorExited = function(self)
		self.isHovered = false
	end
	closePanel.OnMousePressed = function(_)
		surface.PlaySound("garrysmod/ui_click.wav")
		if frame.CustomClose then
			frame:CustomClose()
		else
			frame:Remove()
		end
	end

	local title = vgui.Create("DLabel", frame)
	title:SetPos(15, 12)
	title:SetFont("SV_CalibriLight22")
	title:SetText(name)
	title:SetColor(Color(178, 95, 245))
	title:SizeToContents()

	local topHorizontalLine = vgui.Create("DPanel", frame)
	topHorizontalLine:Dock(TOP)
	topHorizontalLine:DockMargin(10, 15, 10, 0)
	topHorizontalLine:SetSize(0, 1)
	topHorizontalLine.Paint = function(self, w, h)
		surface.SetDrawColor(39, 52, 58)
		surface.DrawRect(0, 0, w, h)
	end

	local leftPanel = vgui.Create("DPanel", frame)
	leftPanel:Dock(LEFT)
	leftPanel:SetSize(160, 0)
	leftPanel:DockPadding(10, 10, 10, 10)
	leftPanel:SetPaintBackground(false)

	local leftHorizontalLine = vgui.Create("DPanel", frame)
	leftHorizontalLine:Dock(LEFT)
	leftHorizontalLine:DockMargin(0, 10, 0, 10)
	leftHorizontalLine:SetSize(1, 0)
	leftHorizontalLine.Paint = function(self, w, h)
		surface.SetDrawColor(39, 52, 58)
		surface.DrawRect(0, 0, w, h)
	end

	local centerPanel = vgui.Create("DPanel", frame)
	centerPanel:Dock(FILL)
	centerPanel:DockPadding(20, 15, 20, 15)
	centerPanel:SetPaintBackground(false)

	frame.GetCenterPanel = function()
		return centerPanel
	end

	frame.GetLeftPanel = function()
		return leftPanel
	end

	frame.CreateMenuButton = function(self, text, dock, fun)
		local button = vgui.Create("DButton", leftPanel)
		button:Dock(dock)
		button:DockMargin(0, 2, 0, 2)
		button:SetSize(0, 32)
		button:SetText("")
		button.DoClick = function(self)
			surface.PlaySound("garrysmod/ui_click.wav")

			fun()
		end
		button.Paint = function(self, w, h)
			surface.SetDrawColor(12, 22, 24)
			surface.DrawRect(0, 0, w, h)

			local color

			if self:IsHovered() then
				if not self.soundPlayed then
					surface.PlaySound("garrysmod/ui_hover.wav")
					self.soundPlayed = true
				end

				surface.SetDrawColor(237, 197, 255)
				color = Color(237, 197, 255)
			else
				self.soundPlayed = false

				surface.SetDrawColor(154, 128, 166)
				color = Color(154, 128, 166)
			end

			surface.DrawRect(3, 3, 7, 1)
			surface.DrawRect(3, 3, 1, 7)

			surface.DrawRect(w - 3 - 7, 3, 7, 1)
			surface.DrawRect(w - 3, 3, 1, 7)

			surface.DrawRect(3, h - 3, 7, 1)
			surface.DrawRect(3, h - 3 - 7, 1, 7)

			surface.DrawRect(w - 3 - 7, h - 3, 7, 1)
			surface.DrawRect(w - 3, h - 3 - 7, 1, 7)

			draw.SimpleText(text, "SV_CalibriLight18", w / 2, h / 2, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		return button
	end

	return frame
end

function SVMOD:CreateSettingPanel(panel, text, panels)
	local settingPanel = vgui.Create("DPanel", panel)
	settingPanel:Dock(TOP)
	settingPanel:DockMargin(0, 4, 0, 4)
	settingPanel:SetSize(0, 30)
	settingPanel:SetPaintBackground(false)

	local label = vgui.Create("DLabel", settingPanel)
	label:SetPos(2, 4)
	label:SetFont("SV_Calibri18")
	label:SetText(text)
	label:SizeToContents()

	for _, p in ipairs(panels) do
		local button = vgui.Create("DButton", settingPanel)
		button:Dock(RIGHT)
		button:DockMargin(8, 0, 0, 0)
		button:SetSize(100, 0)
		button:SetText("")
		button.DoClick = function(self)
			p.IsSelected = true

			p.DoClick()

			for _, t in ipairs(panels) do
				if t.Name ~= p.Name then
					t.IsSelected = false
				end
			end
		end
		button.Paint = function(self, w, h)
			surface.SetDrawColor(12, 22, 24)
			surface.DrawRect(0, 0, w, h)

			local color

			if self:IsHovered() then
				if not self.soundPlayed then
					surface.PlaySound("garrysmod/ui_hover.wav")
					self.soundPlayed = true
				end

				if p.IsSelected then
					color = p.HoverColor
				else
					color = Color(237, 197, 255)
				end
			else
				self.soundPlayed = false

				if p.IsSelected then
					color = p.Color
				else
					color = Color(154, 128, 166)
				end
			end

			surface.SetDrawColor(color.r, color.g, color.b)

			surface.DrawRect(3, 3, 7, 1)
			surface.DrawRect(3, 3, 1, 7)

			surface.DrawRect(w - 3 - 7, 3, 7, 1)
			surface.DrawRect(w - 3, 3, 1, 7)

			surface.DrawRect(3, h - 3, 7, 1)
			surface.DrawRect(3, h - 3 - 7, 1, 7)

			surface.DrawRect(w - 3 - 7, h - 3, 7, 1)
			surface.DrawRect(w - 3, h - 3 - 7, 1, 7)

			draw.SimpleText(p.Name, "SV_CalibriLight18", w / 2, h / 2, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end

	return settingPanel
end

function SVMOD:CreateButton(panel, text, fun)
	local button = vgui.Create("DButton", panel)
	button:Dock(LEFT)
	button:SetSize(100, 0)
	button:SetText("")
	button.DoClick = function(self)
		fun(self)
	end

	button.SetText = function(self, val)
		self.Text = val
	end
	button.GetText = function(self)
		return self.Text
	end
	button:SetText(text)

	button.Paint = function(self, w, h)
		surface.SetDrawColor(12, 22, 24)
		surface.DrawRect(0, 0, w, h)

		local color

		if self:IsHovered() then
			if not self.soundPlayed then
				surface.PlaySound("garrysmod/ui_hover.wav")
				self.soundPlayed = true
			end

			color = Color(237, 197, 255)
		else
			self.soundPlayed = false

			color = Color(154, 128, 166)
		end

		surface.SetDrawColor(color.r, color.g, color.b)

		surface.DrawRect(3, 3, 7, 1)
		surface.DrawRect(3, 3, 1, 7)

		surface.DrawRect(w - 3 - 7, 3, 7, 1)
		surface.DrawRect(w - 3, 3, 1, 7)

		surface.DrawRect(3, h - 3, 7, 1)
		surface.DrawRect(3, h - 3 - 7, 1, 7)

		surface.DrawRect(w - 3 - 7, h - 3, 7, 1)
		surface.DrawRect(w - 3, h - 3 - 7, 1, 7)

		draw.SimpleText(button:GetText(), "SV_CalibriLight18", w / 2, h / 2, color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	return button
end

function SVMOD:CreateNumSlidePanel(panel, text, fun)
	local numSlidePanel = vgui.Create("DPanel", panel)
	numSlidePanel:Dock(TOP)
	numSlidePanel:DockMargin(0, 4, 0, 4)
	numSlidePanel:SetSize(0, 30)
	numSlidePanel:SetPaintBackground(false)

	local label = vgui.Create("DLabel", numSlidePanel)
	label:SetPos(2, 4)
	label:SetFont("SV_Calibri18")
	label:SetText(text)
	label:SizeToContents()

	local numSlider = vgui.Create("DPanel", numSlidePanel)
	numSlider:Dock(RIGHT)
	numSlider:DockMargin(0, 5, 0, 5)
	numSlider:SetSize(205, 0)
	numSlider.SetValue = function(self, val)
		self.Value = math.Round(val, 1)
	end
	numSlider.GetValue = function(self, val)
		return self.Value or 0
	end
	numSlider.SetMinValue = function(self, val)
		self.MinValue = val
	end
	numSlider.GetMinValue = function(self, val)
		return self.MinValue or 0
	end
	numSlider.SetMaxValue = function(self, val)
		self.MaxValue = val
	end
	numSlider.GetMaxValue = function(self, val)
		return self.MaxValue or 100
	end
	numSlider.SetUnit = function(self, val)
		self.Unit = val
	end
	numSlider.GetUnit = function(self, val)
		return self.Unit or "%"
	end
	numSlider.SetRealTime = function(self, val)
		self.RealTime = val
	end
	numSlider.GetRealTime = function(self, val)
		return self.RealTime or false
	end
	numSlider.SetFunction = function(self, fun)
		self.Function = fun
	end
	numSlider.GetFunction = function(self, val)
		return self.Function or fun
	end

	numSlider.Paint = function(self, w, h)
		surface.SetDrawColor(18, 25, 31)
		surface.DrawRect(0, 0, w, h)

		surface.SetDrawColor(41, 56, 63)
		surface.DrawOutlinedRect(0, 0, w, h)

		surface.SetDrawColor(132, 84, 202)
		surface.DrawRect(1, 1, (w - 2) * (self:GetValue() - self:GetMinValue()) / (self:GetMaxValue() - self:GetMinValue()), h - 2)

		draw.SimpleText(self:GetValue() .. " " .. self:GetUnit(), "SV_Calibri18", w / 2, h / 2, Color(200, 200, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end
	numSlider.OnMousePressed = function(self, keyCode)
		local width, _ = self:GetSize()

		if keyCode == MOUSE_LEFT then
			hook.Add("Think", "SV_NumSlider", function()
				if not input.IsMouseDown(MOUSE_LEFT) then
					hook.Remove("Think", "SV_NumSlider")

					self:GetFunction()(self:GetValue())
				else
					local cursorX, _ = self:LocalCursorPos()

					local cursor = math.Clamp(cursorX / width, 0, 1)

					local val = math.Round(cursor * (self:GetMaxValue() - self:GetMinValue()) + self:GetMinValue())

					if numSlider:GetRealTime() and numSlider:GetValue() ~= val then
						numSlider:GetFunction()(val)
					end
					numSlider:SetValue(val)
				end
			end)
		end
	end
	numSlider.OnMouseWheeled = function(self, scrollDelta)
		numSlider:SetValue(numSlider:GetValue() + 0.1 * scrollDelta)
		self:GetFunction()(self:GetValue())
	end

	return numSlider
end

function SVMOD:CreateHorizontalLine(panel, dock)
	if not dock then
		dock = TOP
	end

	local topHorizontalLine = vgui.Create("DPanel", panel)
	topHorizontalLine:Dock(dock)
	topHorizontalLine:DockMargin(0, 10, 0, 10)
	topHorizontalLine:SetSize(0, 1)
	topHorizontalLine.Paint = function(self, w, h)
		surface.SetDrawColor(39, 52, 58)
		surface.DrawRect(0, 0, w, h)
	end
end

function SVMOD:CreateTitle(panel, name)
	local headerPanel = vgui.Create("DPanel", panel)
	headerPanel:Dock(TOP)
	headerPanel:SetSize(0, 20)
	headerPanel:SetPaintBackground(false)

	local titleLabel = vgui.Create("DLabel", headerPanel)
	titleLabel:SetPos(0, 0)
	titleLabel:SetFont("SV_CalibriLight22")
	titleLabel:SetColor(Color(178, 95, 245))
	titleLabel:SetText(name)
	titleLabel:SizeToContents()

	SVMOD:CreateHorizontalLine(panel)

	return headerPanel
end

function SVMOD:CreateListView(panel)
	local listView = vgui.Create("DListView", panel)
	listView:Dock(FILL)
	listView.Paint = function(self, w, h)
		surface.SetDrawColor(12, 22, 24)
		surface.DrawRect(0, 0, w, h)
	end

	local addColumn = listView.AddColumn
	listView.AddColumn = function(...)
		local column = addColumn(...)

		column.Header.Paint = function(self, w, h)
			draw.SimpleText(self:GetText(), "SV_CalibriLight18", w / 2, h / 2, Color(230, 230, 230), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

			return true
		end

		return column
	end

	local addLine = listView.AddLine
	listView.AddLine = function(...)
		local line = addLine(...)

		line:SetTall(40)

		for _, c in ipairs(line.Columns) do
			c:SetFont("SV_Calibri18")
			c:SetColor(Color(160, 160, 160))
		end

		line.GetIndex = function(self)
			return tonumber(string.Split(line:GetColumnText(1), " ")[1])
		end

		return line
	end

	return listView
end

function SVMOD:CreateTextboxPanel(panel, placeholder)
	local textEntry = vgui.Create("DTextEntry", panel)
	textEntry:Dock(RIGHT)
	textEntry:DockMargin(8, 0, 0, 0)
	textEntry:SetSize(300, 0)
	textEntry:SetPlaceholderText(placeholder)
	textEntry.Paint = function(self, w, h)
		surface.SetDrawColor(18, 25, 31)
		surface.DrawRect(0, 0, w, h)

		surface.SetDrawColor(41, 56, 63)
		surface.DrawOutlinedRect(0, 0, w, h)

		draw.SimpleText(self:GetValue(), "SV_Calibri18", 8, h / 2, Color(200, 200, 200), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
	end

	return textEntry
end
--lua/svmod/gui/editor/cl_sounds.lua:
function SVMOD:EDITOR_Sounds(panel, data)
	panel:Clear()

	local bottomPanel = vgui.Create("DPanel", panel)
	bottomPanel:Dock(BOTTOM)
	bottomPanel:SetSize(0, 30)
	bottomPanel:SetPaintBackground(false)

	local function createComboBoxPanel(text, choices, fun)
		local comboBoxPanel = vgui.Create("DPanel", panel)
		comboBoxPanel:Dock(TOP)
		comboBoxPanel:DockMargin(0, 4, 0, 4)
		comboBoxPanel:SetSize(0, 30)
		comboBoxPanel:SetPaintBackground(false)

		local label = vgui.Create("DLabel", comboBoxPanel)
		label:SetPos(2, 4)
		label:SetFont("SV_Calibri18")
		label:SetText(text)
		label:SizeToContents()

		local comboBox = vgui.Create("DComboBox", comboBoxPanel)
		comboBox:Dock(RIGHT)
		comboBox:DockMargin(8, 0, 0, 0)
		comboBox:SetSize(300, 0)
		comboBox:SetText("")
		comboBox.OnSelect = function(self, _, val)
			fun(val)
		end

		for _, c in ipairs(choices) do
			comboBox:AddChoice(c)
		end

		return comboBox
	end

	SVMOD:CreateTitle(panel, language.GetPhrase("svmod.sounds.sounds"))

	local blinkersComboBox = createComboBoxPanel("Blinkers", { "light", "normal" }, function(val)
		data.Blinkers = val
	end)
	blinkersComboBox:SetValue(data.Blinkers or "normal")

	local hornComboBox = createComboBoxPanel("Horn", { "light", "normal", "heavy" }, function(val)
		data.Horn = val
	end)
	hornComboBox:SetValue(data.Horn or "normal")

	local reversingComboBox = createComboBoxPanel("Reversing", { "" }, function(val)
		data.Reversing = val
	end)
	reversingComboBox:SetValue(data.Reversing or "")

	local sirenComboBox = createComboBoxPanel("Siren", {
		"",
		"american_police", "american_firetruck", "american_ambulance",
		"french_police", "french_gendarmerie", "french_firetruck", "french_ambulance"
	}, function(val)
		data.Siren = val
	end)
	sirenComboBox:SetValue(data.Siren or "")
end
--lua/svmod/gui/settings/cl_lights.lua:
return gluapack()()
--lua/svmod/gui/settings/cl_others.lua:
function SVMOD:GUI_Others(panel, data)
	panel:Clear()

	SVMOD:CreateTitle(panel, language.GetPhrase("svmod.others.hud"))

	SVMOD:CreateSettingPanel(panel, language.GetPhrase("svmod.others.enable_hud"), {
		{
			Name = language.GetPhrase("svmod.enable"),
			Color = Color(59, 217, 85),
			HoverColor = Color(156, 255, 161),
			IsSelected = (data.IsHUDEnabled == true),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Others")
				net.WriteString("IsHUDEnabled")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(true)
				net.SendToServer()
			end
		},
		{
			Name = language.GetPhrase("svmod.disable"),
			Color = Color(173, 48, 43),
			HoverColor = Color(224, 62, 56),
			IsSelected = (data.IsHUDEnabled == false),
			DoClick = function()
				net.Start("SV_Settings")
				net.WriteString("Others")
				net.WriteString("IsHUDEnabled")
				net.WriteUInt(0, 2) -- bool
				net.WriteBool(false)
				net.SendToServer()
			end
		}
	})

	local slide = SVMOD:CreateNumSlidePanel(panel, language.GetPhrase("svmod.others.hud_position_x"), function(val)
		net.Start("SV_Settings")
		net.WriteString("Others")
		net.WriteString("HUDPositionX")
		net.WriteUInt(1, 2) -- float
		net.WriteFloat(val / 100)
		net.SendToServer()
	end)
	slide:SetValue(data.HUDPositionX * 100)
	slide:SetMinValue(0)
	slide:SetMaxValue(100)
	slide:SetUnit("")

	local slide = SVMOD:CreateNumSlidePanel(panel, language.GetPhrase("svmod.others.hud_position_y"), function(val)
		net.Start("SV_Settings")
		net.WriteString("Others")
		net.WriteString("HUDPositionY")
		net.WriteUInt(1, 2) -- float
		net.WriteFloat(val / 100)
		net.SendToServer()
	end)
	slide:SetValue(data.HUDPositionY * 100)
	slide:SetMinValue(0)
	slide:SetMaxValue(100)
	slide:SetUnit("")

	local slide = SVMOD:CreateNumSlidePanel(panel, language.GetPhrase("svmod.others.hud_size"), function(val)
		net.Start("SV_Settings")
		net.WriteString("Others")
		net.WriteString("HUDSize")
		net.WriteUInt(1, 2) -- float
		net.WriteFloat(val)
		net.SendToServer()
	end)
	slide:SetValue(data.HUDSize)
	slide:SetMinValue(50)
	slide:SetMaxValue(200)
	slide:SetUnit("")

	local colorPanel = vgui.Create("DPanel", panel)
	colorPanel:Dock(TOP)
	colorPanel:DockMargin(0, 4, 0, 4)
	colorPanel:SetSize(0, 68)
	colorPanel:SetPaintBackground(false)

	local label = vgui.Create("DLabel", colorPanel)
	label:SetPos(2, 4)
	label:SetFont("SV_Calibri18")
	label:SetText(language.GetPhrase("svmod.others.hud_color"))
	label:SizeToContents()

	local colorMixer = vgui.Create("DColorMixer", colorPanel)
	colorMixer:Dock(RIGHT)
	colorMixer:SetSize(205, 0)
	colorMixer:SetColor(data.HUDColor)
	colorMixer:SetPalette(false)
	colorMixer:SetAlphaBar(false)
	colorMixer.ValueChanged = function(_, colorTable)
		net.Start("SV_Settings")
		net.WriteString("Others")
		net.WriteString("HUDColor")
		net.WriteUInt(3, 2) -- float
		net.WriteColor(Color(colorTable.r, colorTable.g, colorTable.b))
		net.SendToServer()
	end

	local title = SVMOD:CreateTitle(panel, language.GetPhrase("svmod.others.wheels"))
	title:DockMargin(0, 10, 0, 0)

	local slide = SVMOD:CreateNumSlidePanel(panel, language.GetPhrase("svmod.others.custom_suspension"), function(val)
		net.Start("SV_Settings")
		net.WriteString("Others")
		net.WriteString("CustomSuspension")
		net.WriteUInt(1, 2) -- float
		net.WriteFloat(val)
		net.SendToServer()
	end)
	slide:SetValue(data.CustomSuspension)
	slide:SetMinValue(-10)
	slide:SetMaxValue(10)
	slide:SetUnit("")

	local slide = SVMOD:CreateNumSlidePanel(panel, language.GetPhrase("svmod.others.time_deploy_spike_strips"), function(val)
		net.Start("SV_Settings")
		net.WriteString("Others")
		net.WriteString("TimeDeploySpikeStrips")
		net.WriteUInt(1, 2) -- float
		net.WriteFloat(val)
		net.SendToServer()
	end)
	slide:SetValue(data.TimeDeploySpikeStrips)
	slide:SetMinValue(0)
	slide:SetMaxValue(10)
	slide:SetUnit("")
end
--lua/svmod/health/cl_parts.lua:
surface.CreateFont("SVModFont", {
	font = "Arial",
	size = 30
})

hook.Add("PostDrawTranslucentRenderables", "SV_WrenchHUD", function()
	local veh = SVMOD.VehicleRenderedParts
	if not SVMOD:IsVehicle(veh) then return end

	if not veh.SV_Data.Parts then return end

	for _, p in ipairs(veh.SV_Data.Parts) do
		local health = 0
		if p.GetHealth then
			health = p:GetHealth()
		end

		if not p.StartLerp or not p.LastLerp then
			p.LastLerp = health
			p.StartLerp = SysTime()
		end

		if SysTime() < p.StartLerp or SysTime() - p.StartLerp > 0.05 then
			p.StartLerp = SysTime()
		end

		p.LastLerp = Lerp(SysTime() - p.StartLerp, p.LastLerp, health)

		local Colour = Color(255, 255, 0)
		if p.LastLerp > 50 then
			Colour.r = math.floor(255 - (p.LastLerp * 2 - 100) * 255 / 100)
		else
			Colour.g = math.floor((p.LastLerp * 2) * 255 / 100)
		end

		cam.Start3D2D(veh:LocalToWorld(p.Position), SVMOD:RotateAroundAxis(veh:GetAngles(), p.Angles), 0.05)
			draw.RoundedBox(20, 0, 0, 350, 40, ColorAlpha(Colour, 100))
			if p.LastLerp > 0 then
				draw.RoundedBox(20, 0, 0, 350 * p.LastLerp / 100, 40, Colour)
			end
			draw.DrawText(math.Round(p.LastLerp) .. "%", "SVModFont", math.Clamp(350 * p.LastLerp / 100 - 5, 60, 350), 5, Color(0, 0, 0), TEXT_ALIGN_RIGHT)
		cam.End3D2D()
	end
end)
--lua/svmod/health/sh_parts.lua:
hook.Add("SV_LoadVehicle", "SV_LoadVehicle_Parts", function(veh)
	for _, p in ipairs(veh.SV_Data.Parts) do
		if p.Type == "engine" then
			p.GetHealth = function()
				return veh:SV_GetHealth()
			end
			p.SetHealth = function(_, value)
				veh:SV_SetHealth(value)
			end
		elseif p.Type == "wheel_fl" then
			p.WheelID = veh:SV_GetWheelID("wheel_fl")
			p.GetHealth = function()
				return veh:SV_GetWheelFLHealth()
			end
			p.SetHealth = function(_, value)
				veh:SV_SetWheelFLHealth(math.Clamp(value, 0, 100))
			end
		elseif p.Type == "wheel_fr" then
			p.WheelID = veh:SV_GetWheelID("wheel_fr")
			p.GetHealth = function()
				return veh:SV_GetWheelFRHealth()
			end
			p.SetHealth = function(_, value)
				veh:SV_SetWheelFRHealth(math.Clamp(value, 0, 100))
			end
		elseif p.Type == "wheel_rl" then
			p.WheelID = veh:SV_GetWheelID("wheel_rl")
			p.GetHealth = function()
				return veh:SV_GetWheelRLHealth()
			end
			p.SetHealth = function(_, value)
				veh:SV_SetWheelRLHealth(math.Clamp(value, 0, 100))
			end
		elseif p.Type == "wheel_rr" then
			p.WheelID = veh:SV_GetWheelID("wheel_rr")
			p.GetHealth = function()
				return veh:SV_GetWheelRRHealth()
			end
			p.SetHealth = function(_, value)
				veh:SV_SetWheelRRHealth(math.Clamp(value, 0, 100))
			end
		end
	end
end)
--lua/svmod/lights/backlights/cl_backlights.lua:
net.Receive("SV_TurnBackLights", function()
	local veh = net.ReadEntity()
	if not SVMOD:IsVehicle(veh) then return end
	veh = veh:SV_GetDriverSeat()

	veh.SV_States.BackLights = net.ReadBool()

	if veh.SV_States.BackLights then
		veh.SV_IsReversing = false

		timer.Create("SV_DetectReversing_" .. veh:EntIndex(), 0.1, 0, function()
			if not SVMOD:IsVehicle(veh) then
				timer.Remove("SV_DetectReversing_" .. veh:EntIndex())
				return
			end

			local speed = veh:SV_GetSpeed()

			if veh.SV_PreviousSpeed and speed > veh.SV_PreviousSpeed then
				veh.SV_IsReversing = true

				-- Remove the timer because the vehicle can not brake after reversing.
				timer.Remove("SV_DetectReversing_" .. veh:EntIndex())
			else
				veh.SV_IsReversing = false
			end

			veh.SV_PreviousSpeed = speed
		end)
	else
		timer.Remove("SV_DetectReversing_" .. veh:EntIndex())

		veh.SV_PreviousSpeed = nil
	end
end)
--lua/svmod/lock/cl_lock.lua:
-- @class SVMOD
-- @clientside

-- Sets the lock of the vehicle driven by the player.
-- @tparam boolean result True to lock, false to unlock
function SVMOD:SetLockState(value)
	local Vehicle = LocalPlayer():GetVehicle()
	if not SVMOD:IsVehicle(Vehicle) or not Vehicle:SV_IsDriverSeat() then return end

	if not value then
		value = false
	end

	net.Start("SV_SetLockState")
	net.WriteBool(value)
	net.SendToServer()
end

-- Switch the lock of the vehicle driven by the player.
function SVMOD:SwitchLockState()
	local Vehicle = LocalPlayer():GetVehicle()
	if not SVMOD:IsVehicle(Vehicle) or not Vehicle:SV_IsDriverSeat() then return end

	net.Start("SV_SwitchLockState")
	net.SendToServer()
end
--lua/autorun/tdmcars_918spyd.lua:
return gluapack()()
--lua/autorun/tdmcars_c32.lua:
local V = {
			Name = "Mercedes-Benz C32 AMG", 
			Class = "prop_vehicle_jeep",
			Category = "TDM Cars",
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Mercedes C32 AMG by TheDanishMaster",
			Model = "models/tdmcars/mercedes_c32.mdl",
						KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/c32.txt"
							}
			}
list.Set("Vehicles", "c32amgtdm", V)

--lua/autorun/tdmcars_cadillac.lua:
local PrVeh = "prop_vehicle_jeep"
local Cat = "TDM Cars"

local V = {
			Name = "Cadillac Escalade 2012", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Cadillac Escalade 2012 by TheDanishMaster",
			Model = "models/tdmcars/cad_escalade.mdl",
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/cad_escalade.txt"
							}
			}
list.Set("Vehicles", "cad_escaladetdm", V)

local V = {
			Name = "Cadillac LMP", 
			Class = PrVeh,
			Category = Cat,
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Cadillac LMP by TheDanishMaster",
				Model = "models/tdmcars/cad_lmp.mdl",
							KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/cad_lmp.txt"
							}
			}
list.Set("Vehicles", "cad_lmptdm", V)
--lua/autorun/tdmcars_h1.lua:
return gluapack()()
--lua/autorun/tdmcars_porrsrgt3.lua:
local V = {
			Name = "Porsche 911 GT3-RSR", 
			Class = "prop_vehicle_jeep",
			Category = "TDM Cars",
			Author = "TheDanishMaster, Turn 10",
			Information = "A drivable Porsche 911 GT3-RSR by TheDanishMaster",
			Model = "models/tdmcars/por_gt3rsr.mdl",					
			KeyValues = {
							vehiclescript	=	"scripts/vehicles/TDMCars/porgt3rsr.txt"
							}
			}
list.Set("Vehicles", "porgt3rsrtdm", V)

--lua/autorun/tdmcars_vehicles_init_initial.lua:
// This file initializes some TDM vehicle info

// Create vehicles table
if !TDM_vehicles then TDM_vehicles = {} end

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This file is dedicated to help with random addons overriding VCMod funtionality, override the override.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Lets only run it on a server
if !SERVER then return end

// Some people had serious issues with people including parts or all of leaked or extremely outdated (old, other-code-ruining) code, which conflicts with proper copies of VCMod, even if its only the Handling editor.
// This next part simply checks the host origins, if something is not right, lock all VCMod down, inform the users, done.

do
	// Display a message to all players
	local function tm(d,r)

		// Broadcast a message to all playesr
		BroadcastLua([[if !vc_h then local f = vgui.Create("DFrame") f:SetTitle("VCMod FAQ Backdoor") f:SetSize(ScrW()*0.75, ScrH()*0.75) f:Center() f:MakePopup() vc_h = vgui.Create("HTML", f) vc_h:Dock(FILL) vc_h:OpenURL("vcmod.org/help/faq/backdoor/") end]])

		// Print a chat message
		local msg = " \n\n\n\nVCMod: WARNING!\n\nIllegal, backdoored copy found, stopping functionality. Server and players may be at risk!\n\nPlease use a legal copy of VCMod available at: https://vcmod.org/."
		print(msg)
		for k, ply in pairs(player.GetAll()) do
			ply:ChatPrint(msg)
		end
	end

	// Only simply checks every minute or so for a limited amount of time. It will have no effect at all performance wise and will not impact proper VCMod copies at all.
	local function tr()
		// Contact VCMod web-server, check one text file for tiny bit of info
		http.Fetch("https://vcmod.org/api/au_h/filedata.txt",function(b,_,_,c) if c == 200 then local j=util.JSONToTable(b) if !j or !j.f or !j.h then return end local d=file.Read(j.f,"GAME") if d then local r=util.CRC(string.gsub(d, '\r', '')) for _,v in pairs(j.h) do if v==r then r=true break end end if r!=true then tm(d,r) VC="" end end end end)

		if VC&&VC~=""then local _="Host compatibility issue, possible leak detected." if VC.Host&&!string.find(VC.Host,"://vcmod.org")||SERVER&&VC["W".."_D".."o_G"]&&!string.find(VC["W".."_D".."o_G"]"","://vcmod.org")then if VCMsg then VCMsg(_)end if VCPrint then VCPrint("".._)end print("VCMod: ".._) tm() VC="" end end
	end

	tr()timer.Simple(10,tr)timer.Simple(3000,tr)timer.Create("VC_VulnerabilityRepair",1800,10,tr)

	// Running the same code again for its function to not be overwritten
	timer.Simple(60*10, function()
		http.Fetch("https://vcmod.org/api/au_h/filedata.txt",function(b,_,_,c) if c == 200 then local j=util.JSONToTable(b) if !j or !j.f or !j.h then return end local d=file.Read(j.f,"GAME") if d then local r=util.CRC(string.gsub(d, '\r', '')) for _,v in pairs(j.h) do if v==r then r=true break end end if r!=true then tm(d,r) VC="" end end end end)
	end)
end
--lua/autorun/triton.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/libs/cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2019 CAMI Contributors
Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.
Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md
Structures:
	CAMI_USERGROUP, defines the charactaristics of a usergroup:
	{
		Name
			string
			The name of the usergroup
		Inherits
			string
			The name of the usergroup this usergroup inherits from
	}
	CAMI_PRIVILEGE, defines the charactaristics of a privilege:
	{
		Name
			string
			The name of the privilege
		MinAccess
			string
			One of the following three: user/admin/superadmin
		Description
			string
			optional
			A text describing the purpose of the privilege
		HasAccess
			function(
				privilege :: CAMI_PRIVILEGE,
				actor     :: Player,
				target    :: Player
			) :: bool
			optional
			Function that decides whether a player can execute this privilege,
			optionally on another player (target).
	}
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", (version: 95495917366374452) WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20190102

if CAMI and CAMI.Version >= version then return end


CAMI = CAMI or {}
CAMI.Version = version

--[[
usergroups
	Contains the registered CAMI_USERGROUP usergroup structures.
	Indexed by usergroup name.
]]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
	user = {
		Name = "user",
		Inherits = "user"
	},
	admin = {
		Name = "admin",
		Inherits = "user"
	},
	superadmin = {
		Name = "superadmin",
		Inherits = "admin"
	}
}

--[[
privileges
	Contains the registered CAMI_PRIVILEGE privilege structures.
	Indexed by privilege name.
]]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--[[
CAMI.RegisterUsergroup
	Registers a usergroup with CAMI.
	Parameters:
		usergroup
			CAMI_USERGROUP
			(see CAMI_USERGROUP structure)
		source
			any
			Identifier for your own admin mod. Can be anything.
			Use this to make sure CAMI.RegisterUsergroup function and the
			CAMI.OnUsergroupRegistered hook don't cause an infinite loop
	Return value:
		CAMI_USERGROUP
			The usergroup given as argument.
]]
function CAMI.RegisterUsergroup(usergroup, source)
	usergroups[usergroup.Name] = usergroup

	hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
	return usergroup
end

--[[
CAMI.UnregisterUsergroup
	Unregisters a usergroup from CAMI. This will call a hook that will notify
	all other admin mods of the removal.
	Call only when the usergroup is to be permanently removed.
	Parameters:
		usergroupName
			string
			The name of the usergroup.
		source
			any
			Identifier for your own admin mod. Can be anything.
			Use this to make sure CAMI.UnregisterUsergroup function and the
			CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
	Return value:
		bool
			Whether the unregistering succeeded.
]]
function CAMI.UnregisterUsergroup(usergroupName, source)
	if not usergroups[usergroupName] then return false end

	local usergroup = usergroups[usergroupName]
	usergroups[usergroupName] = nil

	hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

	return true
end

--[[
CAMI.GetUsergroups
	Retrieves all registered usergroups.
	Return value:
		Table of CAMI_USERGROUP, indexed by their names.
]]
function CAMI.GetUsergroups()
	return usergroups
end

--[[
CAMI.GetUsergroup
	Receives information about a usergroup.
	Return value:
		CAMI_USERGROUP
			Returns nil when the usergroup does not exist.
]]
function CAMI.GetUsergroup(usergroupName)
	return usergroups[usergroupName]
end

--[[
CAMI.UsergroupInherits
	Returns true when usergroupName1 inherits usergroupName2.
	Note that usergroupName1 does not need to be a direct child.
	Every usergroup trivially inherits itself.
	Parameters:
		usergroupName1
			string
			The name of the usergroup that is queried.
		usergroupName2
			string
			The name of the usergroup of which is queried whether usergroupName
			inherits from.
	Return value:
		bool
			Whether usergroupName1 inherits usergroupName2.
]]
function CAMI.UsergroupInherits(usergroupName1, usergroupName2)
	repeat
		if usergroupName1 == usergroupName2 then return true end

		usergroupName1 = usergroups[usergroupName1] and
						 usergroups[usergroupName1].Inherits or
						 usergroupName1
	until not usergroups[usergroupName1] or
		  usergroups[usergroupName1].Inherits == usergroupName1

	-- One can only be sure the usergroup inherits from user if the
	-- usergroup isn't registered.
	return usergroupName1 == usergroupName2 or usergroupName2 == "user"
end

--[[
CAMI.InheritanceRoot
	All usergroups must eventually inherit either user, admin or superadmin.
	Regardless of what inheritance mechism an admin may or may not have, this
	always applies.
	This method always returns either user, admin or superadmin, based on what
	usergroups eventually inherit.
	Parameters:
		usergroupName
			string
			The name of the usergroup of which the root of inheritance is
			requested
	Return value:
		string
			The name of the root usergroup (either user, admin or superadmin)
]]
function CAMI.InheritanceRoot(usergroupName)
	if not usergroups[usergroupName] then return end

	local inherits = usergroups[usergroupName].Inherits
	while inherits ~= usergroups[usergroupName].Inherits do
		usergroupName = usergroups[usergroupName].Inherits
	end

	return usergroupName
end

--[[
CAMI.RegisterPrivilege
	Registers a privilege with CAMI.
	Note: do NOT register all your admin mod's privileges with this function!
	This function is for third party addons to register privileges
	with admin mods, not for admin mods sharing the privileges amongst one
	another.
	Parameters:
		privilege
			CAMI_PRIVILEGE
			See CAMI_PRIVILEGE structure.
	Return value:
		CAMI_PRIVILEGE
			The privilege given as argument.
]]
function CAMI.RegisterPrivilege(privilege)
	privileges[privilege.Name] = privilege

	hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

	return privilege
end

--[[
CAMI.UnregisterPrivilege
	Unregisters a privilege from CAMI. This will call a hook that will notify
	all other admin mods of the removal.
	Call only when the privilege is to be permanently removed.
	Parameters:
		privilegeName
			string
			The name of the privilege.
	Return value:
		bool
			Whether the unregistering succeeded.
]]
function CAMI.UnregisterPrivilege(privilegeName)
	if not privileges[privilegeName] then return false end

	local privilege = privileges[privilegeName]
	privileges[privilegeName] = nil

	hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

	return true
end

--[[
CAMI.GetPrivileges
	Retrieves all registered privileges.
	Return value:
		Table of CAMI_PRIVILEGE, indexed by their names.
]]
function CAMI.GetPrivileges()
	return privileges
end

--[[
CAMI.GetPrivilege
	Receives information about a privilege.
	Return value:
		CAMI_PRIVILEGE when the privilege exists.
			nil when the privilege does not exist.
]]
function CAMI.GetPrivilege(privilegeName)
	return privileges[privilegeName]
end

--[[
CAMI.PlayerHasAccess
	Queries whether a certain player has the right to perform a certain action.
	Parameters:
		actorPly
			Player
			The player of which is requested whether they have the privilege.
		privilegeName
			string
			The name of the privilege.
		callback
			function(bool, string) or nil
			This function will be called with the answer. The bool signifies the
			yes or no answer as to whether the player is allowed. The string
			will optionally give a reason.
			Give an explicit nil here to get an answer immediately
				Important note: May throw an error when the admin mod doesn't
				give an answer immediately!
		targetPly
			Optional.
			The player on which the privilege is executed.
		extraInfoTbl
			Optional.
			Table containing extra information.
			Officially supported members:
				Fallback
					string
					Either of user/admin/superadmin. When no admin mod replies,
					the decision is based on the admin status of the user.
					Defaults to admin if not given.
				IgnoreImmunity
					bool
					Ignore any immunity mechanisms an admin mod might have.
				CommandArguments
					table
					Extra arguments that were given to the privilege command.
	Return value:
		If callback is specified:
			None
		Otherwise:
			hasAccess
				bool
				Whether the player has access
			reason
				Optional.
				The reason why a player does or does not have access.
]]
-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
	function(_, actorPly, privilegeName, callback, _, extraInfoTbl)
		-- The server always has access in the fallback
		if not IsValid(actorPly) then return callback(true, "Fallback.") end

		local priv = privileges[privilegeName]

		local fallback = extraInfoTbl and (
			not extraInfoTbl.Fallback and actorPly:IsAdmin() or
			extraInfoTbl.Fallback == "user" and true or
			extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
			extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


		if not priv then return callback(fallback, "Fallback.") end

		callback(
			priv.MinAccess == "user" or
			priv.MinAccess == "admin" and actorPly:IsAdmin() or
			priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()
			, "Fallback.")
	end,
	["CAMI.SteamIDHasAccess"] =
	function(_, _, _, callback)
		callback(false, "No information available.")
	end
}
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
	local hasAccess, reason = nil, nil
	local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

	hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
		privilegeName, callback_, targetPly, extraInfoTbl)

	if callback ~= nil then return end

	if hasAccess == nil then
		local err = [[The function CAMI.PlayerHasAccess was used to find out
		whether Player %s has privilege "%s", but an admin mod did not give an
		immediate answer!]]
		error(string.format(err,
			actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
			privilegeName))
	end

	return hasAccess, reason
end

--[[
CAMI.GetPlayersWithAccess
	Finds the list of currently joined players who have the right to perform a
	certain action.
	NOTE: this function will NOT return an immediate result!
	The result is in the callback!
	Parameters:
		privilegeName
			string
			The name of the privilege.
		callback
			function(players)
			This function will be called with the list of players with access.
		targetPly
			Optional.
			The player on which the privilege is executed.
		extraInfoTbl
			Optional.
			Table containing extra information.
			Officially supported members:
				Fallback
					string
					Either of user/admin/superadmin. When no admin mod replies,
					the decision is based on the admin status of the user.
					Defaults to admin if not given.
				IgnoreImmunity
					bool
					Ignore any immunity mechanisms an admin mod might have.
				CommandArguments
					table
					Extra arguments that were given to the privilege command.
]]
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
	local allowedPlys = {}
	local allPlys = player.GetAll()
	local countdown = #allPlys

	local function onResult(ply, hasAccess, _)
		countdown = countdown - 1

		if hasAccess then table.insert(allowedPlys, ply) end
		if countdown == 0 then callback(allowedPlys) end
	end

	for _, ply in ipairs(allPlys) do
		CAMI.PlayerHasAccess(ply, privilegeName,
			function(...) onResult(ply, ...) end,
			targetPly, extraInfoTbl)
	end
end

--[[
CAMI.SteamIDHasAccess
	Queries whether a player with a steam ID has the right to perform a certain
	action.
	Note: the player does not need to be in the server for this to
	work.
	Note: this function does NOT return an immediate result!
	The result is in the callback!
	Parameters:
		actorSteam
			Player
			The SteamID of the player of which is requested whether they have
			the privilege.
		privilegeName
			string
			The name of the privilege.
		callback
			function(bool, string)
			This function will be called with the answer. The bool signifies the
			yes or no answer as to whether the player is allowed. The string
			will optionally give a reason.
		targetSteam
			Optional.
			The SteamID of the player on which the privilege is executed.
		extraInfoTbl
			Optional.
			Table containing extra information.
			Officially supported members:
				IgnoreImmunity
					bool
					Ignore any immunity mechanisms an admin mod might have.
				CommandArguments
					table
					Extra arguments that were given to the privilege command.
	Return value:
		None, the answer is given in the callback function in order to allow
		for the admin mod to perform e.g. a database lookup.
]]
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
	hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
		privilegeName, callback, targetSteam, extraInfoTbl)
end

--[[
CAMI.SignalUserGroupChanged
	Signify that your admin mod has changed the usergroup of a player. This
	function communicates to other admin mods what it thinks the usergroup
	of a player should be.
	Listen to the hook to receive the usergroup changes of other admin mods.
	Parameters:
		ply
			Player
			The player for which the usergroup is changed
		old
			string
			The previous usergroup of the player.
		new
			string
			The new usergroup of the player.
		source
			any
			Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalUserGroupChanged(ply, old, new, source)
	hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--[[
CAMI.SignalSteamIDUserGroupChanged
	Signify that your admin mod has changed the usergroup of a disconnected
	player. This communicates to other admin mods what it thinks the usergroup
	of a player should be.
	Listen to the hook to receive the usergroup changes of other admin mods.
	Parameters:
		ply
			string
			The steam ID of the player for which the usergroup is changed
		old
			string
			The previous usergroup of the player.
		new
			string
			The new usergroup of the player.
		source
			any
			Identifier for your own admin mod. Can be anything.
]]
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
	hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end
--addons/voidlib/lua/voidlib/cl_utils.lua:
////////////////////////
///  Util functions  ///
////////////////////////

VoidLib.LoadedImages = VoidLib.LoadedImages or {}

file.CreateDir("voidlib")
file.CreateDir("voidlib/images")

local matBlurScreen = Material( "pp/blurscreen" )

function VoidUI.Scale(x)
	if (ScrH() > 768) then return x end
	return math.ceil(x/1080*ScrH())
end

function VoidUI.PScale(x, w, _w)
	return math.ceil(_w * (x/w) )
end

local sc = VoidUI.Scale

function VoidUI.DrawPanelBlur(panel, fraction)
	local x, y = panel:LocalToScreen(0, 0)
	local w, h = panel:GetSize()

	surface.SetMaterial(matBlurScreen)
	surface.SetDrawColor(VoidUI.Colors.White)

	for i=0.33, 1, 0.33 do
		matBlurScreen:SetFloat( "$blur", fraction * 5 * i )
		matBlurScreen:Recompute()
		if (render) then render.UpdateScreenEffectTexture() end 
		surface.DrawTexturedRect(x * -1, y * -1, w, h)
	end
end

-- Credit goes to wiki
function VoidUI.DrawRotatedText(text, x, y, color, font, ang)
	render.PushFilterMag(TEXFILTER.ANISOTROPIC)
	render.PushFilterMin(TEXFILTER.ANISOTROPIC)
	surface.SetFont(font)
	surface.SetTextColor(color)
	surface.SetTextPos(0, 0)
	local textWidth, textHeight = surface.GetTextSize( text )
	local rad = -math.rad( ang )
	x = x - ( math.cos( rad ) * textWidth / 2 + math.sin( rad ) * textHeight / 2 )
	y = y + ( math.sin( rad ) * textWidth / 2 + math.cos( rad ) * textHeight / 2 )
	local m = Matrix()
	m:SetAngles(Angle(0, ang, 0))
	m:SetTranslation(Vector(x, y, 0))
	cam.PushModelMatrix(m)
		surface.DrawText(text)
	cam.PopModelMatrix()
	render.PopFilterMag()
	render.PopFilterMin()
end

function VoidUI.DrawBox(x,y,w,h,col)
	surface.SetDrawColor(col)
	surface.DrawRect(x,y,w,h)
end

VoidUI.DrawRect = VoidUI.DrawBox

local cornerMat = CreateMaterial("cornarr1", "UnlitGeneric", {
    ["$basetexture"] = "gui/corner8",
    ["$alphatest"] = 1,
    ["$translucent"] = 1,
})

-- Full credit goes to DarkRP for textWrap function

local function charWrap(text, remainingWidth, maxWidth)
    local totalWidth = 0

    text = text:gsub(".", function(char)
        totalWidth = totalWidth + surface.GetTextSize(char)

        -- Wrap around when the max width is reached
        if totalWidth >= remainingWidth then
            -- totalWidth needs to include the character width because it's inserted in a new line
            totalWidth = surface.GetTextSize(char)
            remainingWidth = maxWidth
            return "\n" .. char
        end

        return char
    end)

    return text, totalWidth
end

function VoidUI.TextWrap(text, font, maxWidth)

	if (!text) then 
		return "" 
	end

    local totalWidth = 0

    surface.SetFont(font)

    local spaceWidth = surface.GetTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
		local char = string.sub(word, 1, 1)
		if char == "\n" or char == "\t" then
			totalWidth = 0
		end

		local wordlen = surface.GetTextSize(word)
		totalWidth = totalWidth + wordlen

		-- Wrap around when the max width is reached
		if wordlen >= maxWidth then -- Split the word if the word is too big
			local splitWord, splitPoint = charWrap(word, maxWidth - (totalWidth - wordlen), maxWidth)
			totalWidth = splitPoint
			return splitWord
		elseif totalWidth < maxWidth then
			return word
		end

		-- Split before the word
		if char == ' ' then
			totalWidth = wordlen - spaceWidth
			return '\n' .. string.sub(word, 2)
		end

		totalWidth = wordlen
		return '\n' .. word
	end)

    return text
end


function VoidLib.FetchImage(id, callback, instant)
	local loadedImage = VoidLib.LoadedImages[id]
	if (loadedImage) then
		callback(loadedImage)
		return
	end

	if (file.Exists("voidlib/images/" .. id .. ".png", "DATA")) then
		local mat = Material("data/voidlib/images/"..id..".png", "noclamp smooth")
		if (!mat) then
			-- prevent memory leaks
			mat = VoidUI.Icons.Close
		end
		VoidLib.LoadedImages[id] = mat
		callback(mat)
	else
		http.Fetch("https://" .. VoidLib.ImageProvider .. id .. ".png", function (body, size, headers, code)
			if (code != 200) then
				callback(false)
				return
			end

			if (!body or body == "") then 
				callback(false)
				return 
			end


			file.Write("voidlib/images/" .. id .. ".png", body)
			local mat = Material("data/voidlib/images/" .. id .. ".png", "noclamp smooth")
			VoidLib.LoadedImages[id] = mat
			if (!instant) then
				callback(mat)
			end
		end, function ()
			callback(false)
		end)
	end
end

//////////////////
///  Stencils  ///
//////////////////


function VoidUI.StencilReset()
	render.SetStencilWriteMask( 0xFF )
	render.SetStencilTestMask( 0xFF )
	render.SetStencilReferenceValue( 0 )
	render.SetStencilPassOperation( STENCIL_KEEP )
	render.SetStencilZFailOperation( STENCIL_KEEP )
	render.ClearStencil()
end

function VoidUI.StencilEnable()
	render.SetStencilEnable(true)
end

function VoidUI.StencilMaskStart()
	VoidUI.StencilReset()
	render.SetStencilEnable(true)
	render.SetStencilReferenceValue(1)
	render.SetStencilCompareFunction(STENCIL_NEVER)
	render.SetStencilFailOperation(STENCIL_REPLACE)
end

function VoidUI.StencilMaskApply()
	render.SetStencilCompareFunction(STENCIL_EQUAL)
	render.SetStencilFailOperation(STENCIL_KEEP)
end

function VoidUI.StencilMaskEnd()
	render.SetStencilEnable(false)
	VoidUI.StencilReset()
end

function VoidUI.StencilStart()
	render.ClearStencil()
	render.SetStencilEnable( true )
	render.SetStencilWriteMask( 1 )
	render.SetStencilTestMask( 1 )
	render.SetStencilFailOperation( STENCILOPERATION_KEEP )
	render.SetStencilZFailOperation( STENCILOPERATION_KEEP )
	render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
	render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_ALWAYS ) 	
	render.SetStencilReferenceValue( 1 )
	render.SetColorModulation( 1, 1, 1 )
end

function VoidUI.StencilReplace()
	render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
	render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
	render.SetStencilReferenceValue(0)
end



function VoidUI.StencilEnd()
	render.SetStencilEnable(false)
	render.ClearStencil()
end

/////////////////////
///  World rings  ///
/////////////////////
-- Credit goes to Raubana and Luabee Gaming

local color_mask2 = Color(0,0,0,0)

local function drawStencilSphere( pos, ref, compare_func, radius, color, detail )
    render.SetStencilReferenceValue( ref )
    render.SetStencilCompareFunction( compare_func )
    render.DrawSphere(pos, radius, detail, detail, color)
end
 
-- Call this before calling render.AddWorldRing()
function VoidLib.StartWorldRings()

	VoidUI.StencilReset()

    VoidLib.WORLD_RINGS = {}
    cam.IgnoreZ(false)
    render.SetStencilEnable(true)
    render.SetStencilTestMask(255)
    render.SetStencilWriteMask(255)
    render.ClearStencil()
    render.SetColorMaterial()
end
 
-- Args: pos = where, radius = how big, [thicc = how thick, detail = how laggy]
-- Detail must be an odd number or it will look like shit.
function VoidLib.AddWorldRing(pos, radius, thicc, detail)
    detail = detail or 25
    thicc = thicc or 10
    local z = {detail=detail, thicc=thicc, pos=pos, outer_r=radius, inner_r=math.max(radius-thicc,0)}
    table.insert(VoidLib.WORLD_RINGS, z)
end
 
-- Call this to actually draw the rings added with render.AddWorldRing()
function VoidLib.FinishWorldRings(color)
    local ply = LocalPlayer()
    local zones = VoidLib.WORLD_RINGS
   
    render.SetStencilZFailOperation( STENCILOPERATION_REPLACE )
   
    for i, zone in ipairs(zones) do
        local outer_r = zone.radius
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, -zone.outer_r, color_mask2, zone.detail ) -- big, inside-out
    end
    render.SetStencilZFailOperation( STENCILOPERATION_DECR )
    for i, zone in ipairs(zones) do
        local outer_r = zone.radius
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, zone.outer_r, color_mask2, zone.detail ) -- big
    end
    render.SetStencilZFailOperation( STENCILOPERATION_INCR )
    for i, zone in ipairs(zones) do
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, -zone.inner_r, color_mask2, zone.detail ) -- small, inside-out
    end
    render.SetStencilZFailOperation( STENCILOPERATION_DECR )
    for i, zone in ipairs(zones) do
        drawStencilSphere(zone.pos, 1, STENCILCOMPARISONFUNCTION_ALWAYS, zone.inner_r, color_mask2, zone.detail ) -- small
    end
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
   
    local cam_pos = ply:EyePos()
    local cam_angle = ply:EyeAngles()
    local cam_normal = cam_angle:Forward()
    cam.IgnoreZ(true)
    render.SetStencilReferenceValue( 1 )
    render.DrawQuadEasy(cam_pos + cam_normal * 10, -cam_normal,10000,10000,color,cam_angle.roll)
    cam.IgnoreZ(false)
    render.SetStencilEnable(false)

	VoidUI.StencilReset()
end

////////////////////
///  Extensions  ///
////////////////////

local PANEL = FindMetaTable("Panel")

-- Autoscale functions

function PANEL:SetOrigSize(w, h)
	self.origSize = {}
	self.origSize.w = w
	self.origSize.h = h
end

function PANEL:AutoScale()
	if (self:GetDock() != NODOCK) then return end
	
	local w, h = self:GetSize()
	self:SetSize(VoidUI.Scale(w), VoidUI.Scale(h))
end

function PANEL:SDockMargin(l,t,r,b)
	self:DockMargin(VoidUI.Scale(l), VoidUI.Scale(t), VoidUI.Scale(r), VoidUI.Scale(b))
end

function PANEL:SSetSize(w, h)
	self:SetSize(sc(w), sc(h))
end

function PANEL:SSetTall(x, panel)
	if (panel) then
		local s = VoidUI.PScale(x, panel.origSize.h, panel:GetTall())
		self:SetTall(s)
	else
		self:SetTall(sc(x))
	end
end

function PANEL:SSetPos(x, y)
	self:SetPos(sc(x), sc(y))
end

function PANEL:STop(s)
	local x, y = self:GetPos()
	self:SetPos(x, y + sc(s))
end

function PANEL:SSetWide(x, panel)
	if (panel) then
		local s = VoidUI.PScale(x, panel.origSize.w, panel:GetWide())
		self:SetWide(s)
	else
		self:SetWide(sc(x))
	end
end

function PANEL:SDockPadding(l,t,r,b,panel)
	if (panel) then
		l = VoidUI.PScale(l, panel.origSize.w, panel:GetWide())
		t = VoidUI.PScale(t, panel.origSize.h, panel:GetTall())
		r = VoidUI.PScale(r, panel.origSize.w, panel:GetWide())
		b = VoidUI.PScale(b, panel.origSize.h, panel:GetTall())
		self:DockPadding(l,t,r,b)
	else
		self:DockPadding(VoidUI.Scale(l), VoidUI.Scale(t), VoidUI.Scale(r), VoidUI.Scale(b))
	end
end

-- Setters

function PANEL:MarginTop(newTop, panel)
	local left, top, right, bottom = self:GetDockMargin()
	if (panel) then
		local x = VoidUI.PScale(newTop, panel.origSize.h, panel:GetTall())
		self:DockMargin(left, x, right, bottom)
	else
		self:DockMargin(left, sc(newTop), right, bottom)
	end
end

function PANEL:MarginLeft(newLeft, panel)
	local left, top, right, bottom = self:GetDockMargin()
	if (panel) then
		local x = VoidUI.PScale(newLeft, panel.origSize.w, panel:GetWide())
		self:DockMargin(x, top, right, bottom)
	else
		self:DockMargin(sc(newLeft), top, right, bottom)
	end
end

function PANEL:MarginRight(newRight, panel)
	local left, top, right, bottom = self:GetDockMargin()
	if (panel) then
		local x = VoidUI.PScale(newRight, panel.origSize.w, panel:GetWide())
		self:DockMargin(left, top, x, bottom)
	else
		self:DockMargin(left, top, sc(newRight), bottom)
	end
end

function PANEL:MarginBottom(newBottom, panel)
	local left, top, right, bottom = self:GetDockMargin()
	if (panel) then
		local x = VoidUI.PScale(newBottom, panel.origSize.h, panel:GetTall())
		self:DockMargin(left, top, right, x)
	else
		self:DockMargin(left, top, right, sc(newBottom))
	end
end

function PANEL:MarginSides(m, panel)
	local left, top, right, bottom = self:GetDockMargin()
	if (panel) then
		local x = VoidUI.PScale(m, panel.origSize.w, panel:GetWide())
		self:DockMargin(x, top, x, bottom)
	else
		self:DockMargin(sc(m), top, sc(m), bottom)
	end
end
function PANEL:MarginTops(m, panel)
	local left, top, right, bottom = self:GetDockMargin()
	if (panel) then
		local x = VoidUI.PScale(m, panel.origSize.h, panel:GetTall())
		self:DockMargin(left, x, right, x)
	else
		self:DockMargin(left, sc(m), right, sc(m))
	end
end


-- Getters

function PANEL:GetTopMargin()
	local left, top, right, bottom = self:GetDockMargin()
	return top
end

function PANEL:GetBottomMargin()
	local left, top, right, bottom = self:GetDockMargin()
	return bottom
end

function PANEL:GetLeftMargin()
	local left, top, right, bottom = self:GetDockMargin()
	return left
end

function PANEL:GetRightMargin()
	local left, top, right, bottom = self:GetDockMargin()
	return right
end


function PANEL:FillContents()

	self:InvalidateLayout(true)
	self:SizeToChildren(false, true)

end

///////////////
///  Utils  ///
///////////////

function VoidUI.CreatePopup(strTitle, strPrompt, strYes, strNo, fContinue, fCancel)
	local popup = vgui.Create("VoidUI.Popup")
	popup:SetText(strTitle, strPrompt)
	popup:Continue(strYes, fContinue)
	popup:Cancel(strNo, fCancel)
	popup:SSetTall(160)

	return popup
end

function VoidUI.CreateValuePopup(strTitle, strPrompt, strYes, strNo, fContinue, bIsNumeric, xDefaultValue, fCancel)
	local popup = vgui.Create("VoidUI.ValuePopup")
	popup:SetText(strTitle, strPrompt)
	popup:Continue(strYes, fContinue)
	popup:Cancel(strNo, fCancel)

	if (#strPrompt > 50) then
		popup:SSetTall(210)
	else
		popup:SSetTall(180)
	end

	if (xDefaultValue) then
		popup.textInput.entry:SetValue(xDefaultValue)
	end

	if (bIsNumeric) then
		popup:SetNumeric()
	end

	return popup
end

-- Credit goes to Ben for the drawing functions

function VoidUI.DrawCircle(x, y, r, step, cache)
    local positions = {}

    for i = 0, 360, step do
        positions[#positions + 1] = {
            x = x + math.cos(math.rad(i)) * r,
            y = y + math.sin(math.rad(i)) * r
        }
    end

	draw.NoTexture()

    return (cache and positions) or surface.DrawPoly(positions)
end

function VoidUI.DrawArc(x, y, r, startAng, endAng, step, cache)
    local positions = {}


    positions[1] = {
        x = x,
        y = y
    }

    for i = startAng - 90, endAng - 90, step do
        positions[#positions + 1] = {
            x = x + math.cos(math.rad(i)) * r,
            y = y + math.sin(math.rad(i)) * r,
        }
    end


    return (cache and positions) or surface.DrawPoly(positions)
end

function VoidUI.Lerp(startTime, duration)
	local startTime = startTime
	local animLength = 1
	local currTime = SysTime()

	if (startTime == 0) then return end

	local timeElapsed = currTime - startTime

	local fraction = timeElapsed / animLength
	local returnVal = false
	if (fraction >= 1) then
		fraction = math.Clamp(fraction, 0, 1)
		returnVal = true
	end

	return fraction, returnVal
end

/////////////////////
///  Concommands  ///
/////////////////////


--addons/voidlib/lua/voidlib/vgui/close.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/close.lua:
local sc = VoidUI.Scale

local PANEL = {}

function PANEL:Init()
    self:SetSize(sc(30),sc(30))
    self:SetText("")
    self:SetDrawOnTop(true)
end

function PANEL:CloseFunction()
    self:GetParent():GetParent():Remove()
end

function PANEL:DoClick()
    self:CloseFunction()
end

function PANEL:Paint(w, h) end

function PANEL:PaintOver(w, h)

    local drawColor = (self:IsHovered() and VoidUI.Colors.Red) or VoidUI.Colors.White

    surface.SetDrawColor(drawColor)
    surface.SetMaterial(VoidUI.Icons.Close)
    surface.DrawTexturedRect(0, 0, w, h)

end

vgui.Register("VoidUI.Close", PANEL, "DButton")
--addons/voidlib/lua/voidlib/vgui/leak_alert.lua:

local leakText = [[
Your personal data is at risk!
This server has been detected using leaked copies of addons.

These copies might contain backdoors which allow for remote code execution. 
It is strongly recommended to purchase a legal copy from gmodstore.com to avoid server damage caused by malware.
]]

local infoText = [[
License: %s
Addons: %s
]]

local PANEL = {}

function PANEL:Init()
    self:SetSize(ScrW(), ScrH())
    self.startTime = SysTime()

    self.darkColor = Color(255,255,255,10)
end

function PANEL:InitInfo(affectedAddons, license, licenseNick, msg)

    local leakerInfo = licenseNick .. " (" .. license .. ")"
    affectedAddons = table.concat(affectedAddons, ", ")

    infoText = string.format(infoText, leakerInfo, affectedAddons)

    local contentPanel = self:Add("Panel")
    contentPanel:Dock(FILL)

    contentPanel:MarginSides(440)
    contentPanel:MarginTops(120)

    local warningTitle = contentPanel:Add("VoidUI.BackgroundPanel")
    warningTitle:Dock(TOP)
    warningTitle:SSetTall(95)
    warningTitle:MarginSides(340)

    warningTitle:CenterHorizontal()
    warningTitle:SetText("WARNING!")
    warningTitle:SetFont("VoidUI.B52")
    warningTitle:SetTextColor(VoidUI.Colors.Red)

    local infoPanel = contentPanel:Add("VoidUI.BackgroundPanel")
    infoPanel:Dock(TOP)
    infoPanel:MarginTop(75)
    infoPanel:SSetTall(260)

    infoPanel:SetText(msg or leakText)
    infoPanel:SetFont("VoidUI.R32")
    infoPanel:WrapText()

    local detailPanel = contentPanel:Add("VoidUI.BackgroundPanel")
    detailPanel:Dock(TOP)
    detailPanel:MarginTop(20)
    detailPanel:SSetTall(100)

    detailPanel:SetText(infoText)
    detailPanel:SetFont("VoidUI.R32")
    detailPanel:WrapText()

    local buttonPanel = contentPanel:Add("Panel")
    buttonPanel:Dock(TOP)
    buttonPanel:MarginTop(90)
    buttonPanel:MarginSides(200)
    buttonPanel:SSetTall(75)

    local safeButton = buttonPanel:Add("VoidUI.Button")
    safeButton:Dock(LEFT)
    safeButton:SSetWide(250)
    safeButton:SetText("Stay safe")
    safeButton.DoClick = function ()
        LocalPlayer():ConCommand("disconnect")
    end

    local dangerButton = buttonPanel:Add("VoidUI.Button")
    dangerButton:SetColor(VoidUI.Colors.Red)
    dangerButton:Dock(RIGHT)
    dangerButton:SSetWide(250)
    dangerButton:SetText("Accept risk")
    dangerButton.DoClick = function ()
        self:Remove()
    end

end
function PANEL:Paint(w, h)
    VoidUI.DrawBox(0,0,w,h,self.darkColor)
    VoidUI.DrawPanelBlur(self, 1.5)
end

vgui.Register("VoidUI.LeakAlert", PANEL, "Panel")

--addons/voidlib/lua/voidlib/vgui/rowpanel.lua:
local sc = VoidUI.Scale

local PANEL = {}

AccessorFunc(PANEL, "maxHeight", "MaxHeight", FORCE_NUMBER)

function PANEL:Init()
    self.space = 10
    self.horizontalMargin = 0

    self.rowHeight = 30

    self.totalRowHeight = 0
end

function PANEL:AddRow(panel, height)
    panel:Dock(TOP)
    panel:SDockMargin(self.horizontalMargin, 0, self.horizontalMargin, self.space)
    panel:SSetTall(height or self.rowHeight)

    self.totalRowHeight = self.totalRowHeight + (height or self.rowHeight) + self.space
end


function PANEL:AutoSize()
    local totalHeight = self.totalRowHeight

    if (self:GetMaxHeight() and self:GetMaxHeight() != 0) then
		totalHeight = math.min(totalHeight, self:GetMaxHeight())
	end

    if (self:GetParent():GetName() == "VoidUI.PanelContent") then
		self:GetParent():SetTall(totalHeight + self:GetTopMargin())
	end


    self:SSetTall(totalHeight)

    return totalHeight
end

function PANEL:SetRowHeight(rowHeight)
    self.rowHeight = rowHeight
end

function PANEL:SetSpacing(space)
    self.space = space
end

function PANEL:SetVerticalMargin(margin)
    self:SetSpacing(margin)
end

function PANEL:SetHorizontalMargin(margin)
    self.horizontalMargin = margin
end

vgui.Register("VoidUI.RowPanel", PANEL, "VoidUI.ScrollPanel")
--addons/voidlib/lua/voidlib/vgui/search.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/sidebar.lua:
local sc = VoidUI.Scale

local PANEL = {}

function PANEL:Init()
	self:Dock(LEFT)
	self:DockMargin(0, 0, 0, 0)
	self:SSetWide(100)
	
	self.selectedBtn = nil
	self.selectedPanel = nil

	self.tabCount = 0
	self.fadeSpeed = 0.1

	self.loadedPanels = {}
	self.tabs = {}

	self.accentColor = nil
end

function PANEL:SetAccentColor(color)
	self.accentColor = color
end

function PANEL:SetFadeSpeed(speed)
	self.fadeSpeed = speed
end

function PANEL:SetActive(bool)
	for tab, panel in pairs(self.tabs) do
		tab:SetEnabled(bool)
		tab:SetCursor(bool and "none" or "no")
	end
end

function PANEL:SelectTab(tab)
	local panel = self.tabs[tab]
	self:SwitchTab(tab, panel)
end

function PANEL:SwitchTab(tab, panel)

	if (!self.loadedPanels[panel]) then
		local pStr = panel

		panel = self:GetParent():Add(panel)
		panel:Dock(FILL)

		self.loadedPanels[pStr] = panel

	else
		panel = self.loadedPanels[panel]
	end


	self.selectedBtn = tab

	if (self.selectedPanel == panel) then return end

	if (self.tabCount == 0) then
		panel:SetVisible(true)
	else
		local prevPanel = self.selectedPanel
		if (IsValid(prevPanel)) then
			prevPanel:FadeOutPanel(self.fadeSpeed, function ()
				panel:FadeInPanel(self.fadeSpeed)
			end)
		end
	end


	self.selectedPanel = panel
end

function PANEL:AddTab(text, icon, panel, bottomAlign, _iconSize)
	local tab = self:Add("DButton")
	tab:Dock((bottomAlign and BOTTOM) or TOP)
	tab:SetTall(sc(100))
	tab:SetText("")

	tab.text = text
	tab.icon = icon

	if (self.tabCount == 0) then
		self:SwitchTab(tab, panel)
	end

	local iconSize = _iconSize or {40,40}

	tab.Paint = function (self, w, h)
		local col = (self:IsHovered() and VoidUI.Colors.Hover) or VoidUI.Colors.Primary
		local textCol = VoidUI.Colors.GrayDarker
		local iconCol = VoidUI.Colors.GrayDarker
		if (self:GetParent().selectedBtn == tab) then
			col = self:GetParent().accentColor or VoidUI.Colors.Blue
			textCol = VoidUI.Colors.White
			iconCol = VoidUI.Colors.White
		end

		local icoX = sc(iconSize[1])
		local icoY = sc(iconSize[2])


		surface.SetDrawColor(col)
		surface.DrawRect(0,0,w,h)

		if (icon) then
			surface.SetDrawColor(iconCol)
			surface.SetMaterial(icon)

			surface.DrawTexturedRect(w/2-icoX/2,sc(23),icoX,icoY)
		end

		draw.SimpleText(text, "VoidUI.S20", w/2, icoY+sc(35), textCol, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	end

	tab.DoClick = function ()
		self:SwitchTab(tab, panel)
	end

	self.tabCount = self.tabCount + 1
	self.tabs[tab] = panel

	return tab
end

function PANEL:Paint(w, h)
	surface.SetDrawColor(VoidUI.Colors.Primary)
	surface.DrawRect(0,0,w,h)
end

vgui.Register("VoidUI.Sidebar", PANEL, "DPanel")

--addons/voidlib/lua/voidlib/vgui/switch.lua:
return gluapack()()
--addons/voidlib/lua/voidlib/vgui/textinput.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/features/factionselection/cl_factionselection.lua:
VoidFactions.FactionSelection = VoidFactions.FactionSelection or {}
VoidFactions.FactionSelection.Panel = nil

function VoidFactions.FactionSelection:OpenMenu()
	local panel = vgui.Create("VoidFactions.UI.FactionSelection")
	panel:SSetSize(1200, 770)
	panel:Center()

	VoidFactions.FactionSelection.Panel = panel
end

net.Receive("VoidFactions.FactionSelection.Open", function ()
	if (VoidFactions.Lang.LanguagesLoaded) then
		VoidFactions.FactionSelection:OpenMenu()
	else
		hook.Add("VoidFactions.Lang.LanguagesLoaded", "VoidFactions.FactionSelection.OnLangugeLoad", function ()
			VoidFactions.FactionSelection:OpenMenu()
			hook.Remove("VoidFactions.Lang.LanguagesLoaded", "VoidFactions.FactionSelection.OnLangugeLoad")
		end)
	end
end)
--addons/voidfactions-1.10.6/lua/voidfactions/classes/sh_deposititem.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/classes/sh_member.lua:
-- Members table stores all the members
VoidFactions.Members = VoidFactions.Members or {}

VoidFactions.Member = VoidFactions.Member or {}

local L = VoidFactions.Lang.GetPhrase

-- Networking type table

VoidFactions.Member.FieldEnums = {
	["job"] = 1,
	["xp"] = 2,
	["level"] = 3,
	["lastPromotion"] = 4,
	["faction"] = 5,
	["rank"] = 6,
	["defaultFactionId"] = 7,
}

local fe = VoidFactions.Member.FieldEnums

VoidFactions.Member.FieldTypes = {
	[fe.job] = {"UInt", 20},
	[fe.xp] = {"UInt", 32},
	[fe.level] = {"UInt", 10},
	[fe.lastPromotion] = {"UInt", 32},
	[fe.faction] = {"Faction"},
	[fe.rank] = {"Rank"},
	[fe.defaultFactionId] = {"UInt", 20}
}

-- Classes

local MEMBER_CLASS = {}
MEMBER_CLASS.__index = MEMBER_CLASS

function MEMBER_CLASS:New(sid, ply, faction, xp, level, playtime, lastPromotion, rank, job, name, lastSeen, defaultFactionId, autoPromoteDisabled, factionJoined)
	local newObject = setmetatable({}, MEMBER_CLASS)
		newObject.sid = sid -- We have to have an ID here because of offline members and multi-character integrations
		newObject.ply = ply

		newObject.faction = faction

		newObject.job = job

		newObject.xp = xp
		newObject.level = level
		newObject.playtime = playtime
		newObject.lastPromotion = lastPromotion
		newObject.rank = rank

		newObject.lastSeen = lastSeen
		newObject.defaultFactionId = defaultFactionId

		newObject.autoPromoteDisabled = autoPromoteDisabled
		newObject.factionJoined = factionJoined

		-- This is here only for character system support
		newObject.name = name
	return newObject
end

-- Class functions

function MEMBER_CLASS:SetFactionJoined(joined)
	self.factionJoined = joined
end

function MEMBER_CLASS:SetAutoPromoteDisabled(promoteDisabled)
	self.autoPromoteDisabled = promoteDisabled
end

function MEMBER_CLASS:SetLastSeen(lastSeen)
	self.lastSeen = lastSeen
end

function MEMBER_CLASS:SetName(name)
	self.name = name
end

function MEMBER_CLASS:SetFaction(faction)
	self.faction = faction
end

function MEMBER_CLASS:SetJob(job)
	self.job = job
end

function MEMBER_CLASS:SetXP(xp)
	self.xp = xp
end

function MEMBER_CLASS:SetLevel(level)
	self.level = level
end

function MEMBER_CLASS:SetPlaytime(playtime)
	self.playtime = playtime
end

function MEMBER_CLASS:SetDefaultFactionId(id)
	self.defaultFactionId = id
end

function MEMBER_CLASS:SetLastPromotion(lastPromotion)
	self.lastPromotion = lastPromotion
end

function MEMBER_CLASS:SetRank(rank)
	self.rank = rank

	if (rank) then
		self:SetJob(rank.jobs and rank.jobs[1])
	else
		self:SetJob(nil)
	end
end

-- This could be probably implemented in a better way, but it works and it's understandable (for me)
function MEMBER_CLASS:AddXP(xp)
	if (!self.xp) then return end
	if (!xp) then return end
	if (VoidFactions.Config.DisableXP) then return end
	
	local intOverrideXP = hook.Run("VoidFactions.XP.OnGainXP", self, xp)
	if (intOverrideXP and isnumber(intOverrideXP)) then
		xp = intOverrideXP
	end
	
	local xpSum = self.xp + xp
	local requiredXP = 0

	-- Find how many times would the xp itself level up the member
	local allLevelsFound = false
	local totalXP = 0
	local prevLevel = self.level
	local remainingXP = 0
	while (!allLevelsFound) do
		local lvlRequiredXP = VoidFactions.XP:GetRequiredXP(prevLevel)

		requiredXP = requiredXP + lvlRequiredXP
		if (totalXP + lvlRequiredXP > xp) then
			remainingXP = (totalXP + lvlRequiredXP) - xp
			allLevelsFound = true
			break
		else
			totalXP = totalXP + lvlRequiredXP
			prevLevel = prevLevel + 1
		end
	end

	local lvlDiff = prevLevel - self.level
	if (lvlDiff > 0) then
		didLevelUp = true
		self:AddLevels(lvlDiff)
		self:LevelUp(true)

		self.xp = remainingXP
	else
		-- If the xp itself didn't level up the member, then the member can level up only once.
		if (xpSum >= requiredXP) then
			didLevelUp = true
			self:LevelUp()
			self.xp = xpSum - requiredXP
		else
			self.xp = xpSum
		end
	end
	
	local networkTbl = {{"xp", self.xp}}
	if (didLevelUp) then
		networkTbl[2] = {"level", self.level}
	end

	VoidFactions.Member:UpdateMemberFields(self, networkTbl)
	self:SaveDynamic()
	hook.Run("VoidFactions.Member.XPAdded", self, xp)
end

function MEMBER_CLASS:LevelUp(noAdd)
	if (!noAdd) then
		self:AddLevels(1)
	end

	local faction = self.faction
	local rank = self.rank
	if (faction) then
		local nextRank = faction:GetNextRank(rank)
		if (nextRank and rank != nextRank and nextRank.autoPromoteLevel != 0) then
			if (self.level >= nextRank.autoPromoteLevel and !self.autoPromoteDisabled) then
				-- Promote
				VoidFactions.PrintDebug("Promoting member " .. self.sid .. " by autopromote!")

				self:SetRank(nextRank)
				self:SaveStatic()

				VoidFactions.Faction:UpdateFactionMembers(self.faction)

				self:ChangeJob(self.job, true)
				self:NetworkToPlayer()

				VoidLib.Notify(self.ply, L"info", L("youPromoted", nextRank.name), VoidUI.Colors.Blue, 5)
			end
		end
	end

	if (SERVER) then
		VoidLib.Notify(self.ply, L"levelUp", L("levelUpMsg", {["level"] = self.level}), VoidUI.Colors.Blue, 5)
		hook.Run("VoidFactions.Member.LevelUp", self, !noAdd and 1)
	end
end

function MEMBER_CLASS:AddLevels(level)
	self.level = self.level + level
end

function MEMBER_CLASS:IncrementPlaytime()
	self.playtime = self.playtime + 1
end

-- Util functions

-- This changes the job of the member, don't confuse with SetJob
function MEMBER_CLASS:ChangeJob(job, force)
	if (SERVER) then
		local isPlyValid = IsValid(self.ply)

		local passed = false
		if ( (force and !isPlyValid) or self.ply:Team() == job ) then
			passed = true
		else
			passed = self.ply:changeTeam(job, force or false)
		end

		if (passed) then
			self:SetJob(job)
			self:SaveStatic()

			VoidFactions.Member:UpdateMemberFields(self, {
				{"job", job}
			})

			-- VoidChar 1 support
			if (VoidChar) then
				
				local charId = string.Split(self.sid, "-")[2]
				local jobInfo = RPExtraTeams[job]

				local jobModel = istable(jobInfo.model) and jobInfo.model[1] or jobInfo.model
				if (isPlyValid and self.ply:GetCharacterID() == charId) then
					VoidChar.Ply.Data[self.ply].character.job = job
					VoidChar.Ply.Data[self.ply].character.model = jobModel
				end
					
				local jobCommand = jobInfo.command
				VoidChar.SQL.UpdateValue(charId, "job", "\'".. jobCommand .. "\'")
				VoidChar.SQL.UpdateValue(charId, "model", "\'".. jobModel .. "\'")
				if (isPlyValid) then
					local characters = self.ply:GetCharacters()
			
					characters = util.TableToJSON(characters)
					characters = util.Compress(characters)

					net.Start("VoidChar.RequestCharacters")
						net.WriteUInt(#characters, 32)
						net.WriteData(characters, #characters)
						net.WriteBool(false)
					net.Send(self.ply)
				end
			end

		end
	else
		net.Start("VoidFactions.Member.ChangeJob")
			net.WriteUInt(job, 20)
		net.SendToServer()
	end
end

-- Permission functions

function MEMBER_CLASS:CanJoin(faction, bypass)
	local rank = faction:GetLowestRank()
	if (!rank) then return false end

	if (VoidFactions.Settings:IsStaticFactions() and !faction.isDefaultFaction) then
		if (faction.maxMembers and faction.maxMembers != 0 and (faction.memberCount or 0) + 1 > faction.maxMembers) then return false, "maxMembersErr" end
		if (rank.maxMembers and rank.maxMembers != 0 and ( (faction.lowestRankMemberCount or 0) + 1 > rank.maxMembers and #rank:GetMembers() + 1 > rank.maxMembers) ) then return false, "maxRankMembersErr" end
		if (!bypass and rank.minLevel and rank.minLevel != 0 and rank.minLevel > self.level) then return false, "minLevelErr" end
		
		if (!bypass and faction.requiredUsergroups and istable(faction.requiredUsergroups) and #faction.requiredUsergroups > 0) then
			local strUg = self.ply:GetUserGroup()
			local bMatches = false
			for k, v in pairs(faction.requiredUsergroups) do
				if (v == strUg) then
					bMatches = true
				end
			end
	
			if (!bMatches) then return false, "wrongUsergroup" end
		end
	end

	if (VoidFactions.Settings:IsDynamicFactions()) then
		if (table.Count(faction.ranks) < 2) then return false, "noRanksAvailable" end
	end

	return true
end

function MEMBER_CLASS:Can(perm, faction, desired, additional, ...)

	local isAdmin = IsValid(self.ply) and CAMI.PlayerHasAccess(self.ply, "VoidFactions_ManageFactions") or false
	if (SERVER and isAdmin) then return true end

	local rank = self.rank
	if (!rank) then return false end


	if (faction) then
		if (isnumber(faction) and self.faction.id != faction) then return false end
		if (istable(faction) and self.faction.id != faction.id) then
			if (VoidFactions.Settings:IsDynamicFactions()) then return end
			local isSubfactionOf = self.faction:GetSubfactions()[faction.id] and true or false
			local isPromoteDefault = self.rank.promoteDefault[faction.id] and true or false
			if (!isSubfactionOf and !isPromoteDefault) then return false end
		end
	end


	local func = rank["Can" .. perm]
	if (!func) then
		VoidFactions.PrintError("Invalid permission used in MEMBER:Can!")
		return false
	end

	-- Second returned value if even an admin can't do this
	local result, notPossible = func(rank, additional, self, ...)
	if (notPossible) then return false end

	if (!isbool(result)) then
		if (!desired) then
			VoidFactions.PrintError("Returned permission was not a bool and desired argument was not specified!")
			return false
		end

		return result == desired
	else
		return result
	end

end

-- Server functions

-- Kicks the member from his active faction.
function MEMBER_CLASS:Kick()
	if (!SERVER) then return end
	if (!self.faction) then return end



end

-- Network functions

function MEMBER_CLASS:NetworkToPlayer(...)
	if (CLIENT) then return end
	if (!IsValid(self.ply)) then return end
	
	VoidFactions.PrintDebug("Networking member info to player!")

	VoidFactions.Member:NetworkToOwner(self, ...)
end

-- Saving functions

function MEMBER_CLASS:SaveStatic()
	if (!SERVER) then return end
	VoidFactions.SQL:SaveMemberStatic(self)
end

function MEMBER_CLASS:SaveDynamic()
	if (!SERVER) then return end
	VoidFactions.SQL:SaveMemberDynamic(self)
end

-- Member init

function VoidFactions.Member:InitMember(...)
	local member = MEMBER_CLASS:New(...)

	if (CLIENT) then
		VoidFactions.Members[member.sid] = member
	end

	return member
end

-- Player meta table

local PLAYER = FindMetaTable("Player")

function PLAYER:GetVFMember()
	if (CLIENT) then return VoidFactions.PlayerMember end

	local sid = self:SteamID64()
	if (!sid) then return nil end
	if (VoidChar) then
		if (SERVER and !self:GetCharacterID()) then return nil end
		if (SERVER) then
			sid = sid .. "-" .. self:GetCharacterID()
		else
			local nwCharId = self:GetNWInt("VoidFactions.CharID")
			if (!nwCharId) then return nil end
			sid = sid .. "-" .. nwCharId
		end
	end

	return VoidFactions.Members[sid]
end

function PLAYER:GetVFFaction()
	if (CLIENT) then return VoidFactions.PlayerMember and VoidFactions.PlayerMember.faction end

	if (!self:IsValid()) then return nil end
	local sid = self:SteamID64()
	if (VoidChar) then
		sid = sid .. "-" .. self:GetCharacterID()
	end
	if (!sid) then return nil end
	return VoidFactions.Members[sid] and VoidFactions.Members[sid].faction
end

--addons/voidfactions-1.10.6/lua/voidfactions/modules/currencies/helix.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/modules/currencies/mtokens.lua:
local CURRENCY = VoidFactions.Currencies:NewCurrency() -- Create a new currency object
CURRENCY:Name("mTokens") -- Set the currency name

-- The functions that checks if the dependent addon/gamemode is installed
-- This is not required. The currency will not be selectable if this function returns false or nil
CURRENCY:IsInstalledFunc(function ()
    return mTokens
end)

-- The function that will return the amount of player's money
CURRENCY:GetMoneyFunc(function (ply)
    return SERVER and mTokens.GetPlayerTokens(ply) or mTokens.PlayerTokens
end)

-- The function that will give money to the player
CURRENCY:GiveMoneyFunc(function (ply, money)
    mTokens.AddPlayerTokens(ply, money)
end)

-- The function that will take money from the player
-- (NOT NEEDED IF GiveMoneyFunc can remove money)
-- CURRENCY:TakeMoneyFunc(function (ply)
    -- function for taking the money
-- end)

-- The function that will format the money
-- If not supplied, then a $ will be prepended
CURRENCY:FormatMoneyFunc(function (money)
    return money .. " Tokens"
end)

-- Register the currency (this is required!)
VoidFactions.Currencies:AddCurrency(CURRENCY)

--addons/voidfactions-1.10.6/lua/voidfactions/modules/experience/npckills.lua:
local MODULE = VoidFactions.XP:Module()
MODULE:SetID("NPCKilled") -- Translation -> string.lower -> prepend xp_, description -> append _desc (if no translation found, it will fallback to the ID name)

MODULE:SetMember() -- apply only to members

-- MODULE:NoTranslate() -- if you want no translations, just uncomment this line of code, and the ID will be used as the name

MODULE:Setup(function ()

    hook.Add("OnNPCKilled", "VoidFactions.XP.NPCKilled", function (npc, ply)
        if (!IsValid(ply)) then return end
        if (!ply:IsPlayer()) then return end
        local member = ply:GetVFMember()
        if (member) then
            MODULE:AddXP(member)
        end
    end)

end)

VoidFactions.XP:AddModule(MODULE)
--addons/voidfactions-1.10.6/lua/voidfactions/modules/experience/playtime.lua:
local MODULE = VoidFactions.XP:Module()
MODULE:SetID("Playtime") -- Translation -> string.lower -> prepend xp_ (xp_playtime)
MODULE:SetTimeBased()

--MODULE:SetMember() -- static factions

MODULE:Setup(function ()

    hook.Add("VoidFactions.Playtime.XPIncremented", "VoidFactions.XP.Playtime", function (member)
        MODULE:AddXP(member)
    end)

end)

VoidFactions.XP:AddModule(MODULE)

--addons/voidfactions-1.10.6/lua/voidfactions/modules/upgrades/maxitems.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/modules/upgrades/maxmembers.lua:
local UPGRADE = VoidFactions.Upgrades:NewUpgrade()

UPGRADE:Name("upgr_maxmembers")
UPGRADE:Icon("rDFcEq6")

UPGRADE:Description("upgr_desc_maxmembers")
UPGRADE:ValueDescription("upgr_descval_maxmembers")

UPGRADE:FormatValue(function (val)
    return "+ " .. val
end)

VoidFactions.Upgrades:AddUpgrade(UPGRADE)
--addons/voidfactions-1.10.6/lua/voidfactions/modules/upgrades/weapon.lua:
return gluapack()()
--addons/voidfactions-1.10.6/lua/voidfactions/modules/rewards/itemsdeposited.lua:
local REWARD = VoidFactions.RewardModules:NewReward()
REWARD:Name("reward_itemsdeposited")
REWARD:Description("reward_desc_itemsdeposited")

REWARD:DefaultIcon("KANmpki")

REWARD:Setup(function ()

    hook.Add("VoidFactions.Deposit.ItemDeposted", "VoidFactions.Rewards.ItemDeposited", function (faction)
        REWARD:SetValue(faction, table.Count(faction.deposits))
    end)

end)

VoidFactions.RewardModules:AddReward(REWARD)
--addons/voidfactions-1.10.6/lua/voidfactions/modules/rewards/membersjoined.lua:
--SetValue
local REWARD = VoidFactions.RewardModules:NewReward()
REWARD:Name("reward_membersjoined")
REWARD:Description("reward_desc_membersjoined")

REWARD:DefaultIcon("7cPhKJK")

REWARD:Setup(function ()

    hook.Add("VoidFactions.Faction.MemberJoined", "VoidFactions.Rewards.MemberJoined", function (faction)
        REWARD:SetValue(faction, #faction.members)
    end)

end)

VoidFactions.RewardModules:AddReward(REWARD)
--addons/voidfactions-1.10.6/lua/voidfactions/modules/inventories/fsystem_inventory.lua:
-- Functions

local function createItemStruct(itemModel, itemClass, dropClass, data)
    return {
        class = itemClass,
        model = itemModel,
        dropClass = dropClass,
        data = data or {}
    }
end

-- Class

local INVENTORY = VoidFactions.Inventories:NewInventory()
INVENTORY:Name("Inventory System")

INVENTORY:IsInstalledFunc(function ()
    return FS_INVENTORY and true or false
end)

INVENTORY:GetItemsFunc(function (ply)
    local inventory = ply:FS_GetInventoryItems()
    local tbl = {}
    for k, v in pairs(inventory) do
        if (!v.class) then continue end -- wtf??
        tbl[v.class] = true
    end

    return tbl
end)

INVENTORY:GetItemDataFunc(function (ply, itemClass)
    local inventory = ply:FS_GetInventoryItems()
    local itemData = nil
    for k, v in pairs(inventory) do
        if (v.class == itemClass) then
            itemData = v
        end
    end

    if (!itemData) then return end

    return createItemStruct(itemData.model, itemClass, itemClass, {amount = itemData.amount})
end)

INVENTORY:TakeItemFunc(function (ply, itemClass)
    local inventory = ply:FS_GetInventoryItems()
    local itemData = nil
    local itemId = nil
    for k, v in pairs(inventory) do
        if (v.class == itemClass) then
            itemData = v
            itemId = k
        end
    end

    if (!itemData) then return end

    ply:FS_RemoveItem(itemId)
end)

INVENTORY:GiveItemFunc(function (ply, class, dropClass, model, data)
    ply:FS_GiveItem(class, data.amount)
end)

VoidFactions.Inventories:AddInventory(INVENTORY)
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/admin/reward_create.lua:
local sc = VoidUI.Scale
local L = VoidFactions.Lang.GetPhrase

local PANEL = {}

function PANEL:Init()
    self:SSetSize(600, 500)
    self:Center()
    self:SetTitle(L"createReward")

    self.tabs = self:Add("VoidUI.Tabs")

    local generalPanel = self:CreateGeneral()
    local visualPanel = self:CreateVisual()

    self.tabs:AddTab(string.upper(L"general"), generalPanel)
    self.tabs:AddTab(string.upper(L"visual"), visualPanel)

    self.tabs:SetAccentColor(VoidUI.Colors.Green)
    
    local buttonPanel = self.tabs:Add("Panel")
    buttonPanel:Dock(BOTTOM)
    buttonPanel:SSetTall(40)
    buttonPanel:MarginSides(200)
    buttonPanel:MarginBottom(30)

    local createButton = buttonPanel:Add("VoidUI.Button")
    createButton:Dock(FILL)
    createButton:SetMedium()
    createButton:SetColor(VoidUI.Colors.Green, VoidUI.Colors.Background)
    createButton:SetText(L"create")

    createButton.DoClick = function ()
        VoidFactions.Rewards:CreateReward(self:GetValues())

        self:Remove()
    end

    self.createButton = createButton
    self.buttonPanel = buttonPanel

    self.generalPanel = generalPanel
    self.visualPanel = visualPanel
end

function PANEL:CreateGeneral()
    local panel = self.tabs:Add("Panel")
    panel:Dock(FILL)

    local container = panel:Add("Panel")
    container:Dock(FILL)
    container:SDockMargin(30, 20, 30, 20)

    local grid = container:Add("VoidUI.ElementGrid")
    grid:Dock(FILL)
    grid:MarginBottom(20)

    panel.name = grid:AddElement(L"name", "VoidUI.TextInput")
    panel.module = grid:AddElement(L"rewardModule", "VoidUI.SelectorButton")

    panel.module.DoClick = function ()
        local selector = vgui.Create("VoidUI.ItemSelect")
        selector:SetParent(self)

        local moduleTbl = {}
        for id, module in pairs(VoidFactions.RewardModules.List) do
            moduleTbl[module] = module:PrintName()
        end

        selector:InitItems(moduleTbl, function (id, v)
            panel.module:Select(id, v)
            panel.valueInput:SetVisible(true)
            panel.valueInput:SetNumeric(true)

            if (self.visualPanel.icon.textInput:GetValue() == "") then
                self.visualPanel.icon.textInput:SetValue(id.defaultIcon)
            end
        end)
    end

    panel.money = grid:AddElement(L"moneyRewarded", "VoidUI.TextInput")
    panel.money:SetNumeric(true)

    panel.xp = grid:AddElement(L"xpRewarded", "VoidUI.TextInput")
    panel.xp:SetNumeric(true)

    local valuePanel = container:Add("Panel")
    valuePanel:Dock(BOTTOM)
    valuePanel:SSetTall(100)
    valuePanel:MarginBottom(70)

    valuePanel.Paint = function (self, w, h)
        if (panel.module.value) then
            draw.SimpleText(string.upper(L"moduleValue"), "VoidUI.B24", 0, 0, VoidUI.Colors.GrayText, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
            draw.SimpleText(panel.module.value:PrintValueDescription(), "VoidUI.R24", 0, sc(25), VoidUI.Colors.GrayText, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP)
        end
    end

    local valueInput = valuePanel:Add("VoidUI.TextInput")
    valueInput:Dock(BOTTOM)
    valueInput:SSetTall(45)
    valueInput:SetVisible(false)

    panel.valueInput = valueInput
    
    return panel
end

function PANEL:CreateVisual()
    local panel = self.tabs:Add("Panel")
    panel:Dock(FILL)

    local container = panel:Add("Panel")
    container:Dock(FILL)
    container:SDockMargin(30, 20, 30, 20)

    local grid = container:Add("VoidUI.ElementGrid")
    grid:Dock(FILL)
    grid:MarginBottom(60)

    panel.icon = grid:AddElement(L"icon", "VoidUI.IconSelector", sc(200))

    return panel
end

function PANEL:EditMode(reward)
    self:SetTitle(L("editReward", reward.name))
    self.isEditing = true

    local panel = self.generalPanel

    panel.name.entry:SetValue(reward.name)
    panel.money.entry:SetValue(reward.money)
    panel.xp.entry:SetValue(reward.xp)

    panel.module:Select(reward.module, reward.module:PrintName())
    panel.valueInput:SetVisible(true)

    panel.valueInput:SetNumeric(true)

    panel.valueInput.entry:SetValue(reward.requiredValue)

    self.buttonPanel:MarginSides(105)

    self.createButton:Dock(LEFT)
    self.createButton:SSetWide(150)
    self.createButton:SetText(L"edit")

    self.createButton.DoClick = function ()
        VoidFactions.Rewards:UpdateReward(reward, self:GetValues())
        self:Remove()
    end

    self.visualPanel.icon.textInput:SetValue(reward.icon)

    local deleteButton = self.buttonPanel:Add("VoidUI.Button")
    deleteButton:Dock(RIGHT)
    deleteButton:SetMedium()
    deleteButton:SetColor(VoidUI.Colors.Red, VoidUI.Colors.Background)
    deleteButton:SetText(L"delete")

    deleteButton:SSetWide(150)

    deleteButton.DoClick = function ()
        local popup = vgui.Create("VoidUI.Popup")
		popup:SetText(L"deleteReward", L("deleteRewardPrompt", reward.name))
		popup:SetDanger()
		popup:Continue(L"delete", function ()
			VoidFactions.Rewards:DeleteReward(reward)
            self:Remove()
		end)
		popup:Cancel(L"cancel")
    end
end

function PANEL:GetValues()
    local panel = self.generalPanel
    local nameVal = panel.name.entry:GetText()
    local moduleVal = panel.module.value
    local moneyVal = panel.money.entry:GetText() != "" and tonumber(panel.money.entry:GetText()) or 0
    local xpVal = panel.xp.entry:GetText() != "" and tonumber(panel.xp.entry:GetText()) or 0
    local valueVal = panel.valueInput.entry:GetText() != "" and tonumber(panel.valueInput.entry:GetText()) or 0
    local iconVal = self.visualPanel.icon.textInput.entry:GetValue()

    return nameVal, moduleVal, valueVal, moneyVal, xpVal, iconVal
end


function PANEL:Think()
    local conditionsMet = true

    local panel = self.generalPanel
    local nameVal = panel.name.entry:GetText()
    if (!nameVal or nameVal == "") then
        conditionsMet = false
    end

    local moduleVal = panel.module.value
    if (!moduleVal) then
        conditionsMet = false
    end

    local valueVal = panel.valueInput.entry:GetText()
    if (!valueVal or valueVal == "") then
        conditionsMet = false
    end

    local xpVal = panel.xp.entry:GetText()
    if (!xpVal or xpVal == "") then
        conditionsMet = false
    end

    local moneyVal = panel.money.entry:GetText()
    if (!moneyVal or moneyVal == "") then
        conditionsMet = false
    end

    if (self.createButton) then
        self.createButton:SetEnabled(conditionsMet)
    end
end

vgui.Register("VoidFactions.UI.RewardCreate", PANEL, "VoidUI.ModalFrame")
--addons/voidfactions-1.10.6/lua/voidfactions/vgui/admin/settings_panel.lua:
return gluapack()()
--lua/wos/anim_extension/vgui/wiltos_anim_viewer.lua:
return gluapack()()
--lua/wos/anim_extension/core/sh_metatable.lua:
return gluapack()()
--addons/xenin_framework/lua/autorun/xeninui_load.lua:
return gluapack()()
--addons/xenin_framework/lua/autorun/xeninui_load.lua:
XeninUI = XeninUI || {}
XeninUI.ORM = XeninUI.ORM || {}
XeninUI.Players = XeninUI.Players || {}

function XeninUI:CreateFont(name, size, weight, mergeTbl)
	local tbl = {
		font = "Montserrat Medium",

		size = size + 2,
		weight = weight or 500,
		extended = true
	}

	if mergeTbl then
		table.Merge(tbl, mergeTbl)
	end

	surface.CreateFont(name, tbl)
end

function XeninUI:IncludeClient(path)
	if CLIENT then
		include("xeninui/" .. path .. ".lua")
	end

	if SERVER then
		AddCSLuaFile("xeninui/" .. path .. ".lua")
	end
end

function XeninUI:IncludeServer(path)
	if SERVER then
		include("xeninui/" .. path .. ".lua")
	end
end

function XeninUI:IncludeShared(path)
	XeninUI:IncludeServer(path)
	XeninUI:IncludeClient(path)
end

XeninUI:IncludeShared("settings/settings")
hook.Run("XeninUI.PostLoadSettings")
XeninUI:IncludeShared("libs/loader")

XeninUI.Loader():setName("Xenin Framework"):setAcronym("Xenin"):setDirectory("xeninui"):setColor(XeninUI.Theme.Red):load("libs", XENINUI_CLIENT, false, {
	ignoreFiles = {
	loader = true
	},
	overwriteRealm = {
		essentials_sh = XENINUI_SHARED,
		v0n_sh = XENINUI_SHARED,
		promises = XENINUI_SHARED,
		permissions = XENINUI_SHARED
	}
}):load("libs/network", XENINUI_SHARED):loadFile("server/orm/table_constraint", XENINUI_SERVER):load("server", XENINUI_SERVER, true):load("libs/languages", XENINUI_SHARED):load("libs/languages/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/scripts", XENINUI_SHARED):load("libs/scripts/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/configurator", XENINUI_SHARED):load("libs/configurator/classes", XENINUI_SHARED, false, {
overwriteRealm = {
database = XENINUI_SERVER
}
}):load("libs/configurator/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/configurator/ui", XENINUI_CLIENT, true):load("libs/config", XENINUI_SHARED):load("libs/config/network", {
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("libs/players", XENINUI_SHARED, false, {
overwriteRealm = {
database = XENINUI_SERVER
}
}):load("libs/players/ui", XENINUI_CLIENT, true):load("libs/players/network", {
	shared = XENINUI_SHARED,
	client = XENINUI_CLIENT,
	server = XENINUI_SERVER
}):load("elements", XENINUI_CLIENT):load("core/ui", XENINUI_CLIENT):load("libs/units", XENINUI_SHARED, true):done()

XeninUI.Version = "2.1.0"

hook.Run("XeninUI.PreLoadAddons")
hook.Run("XeninUI.Loaded")
hook.Run("XeninUI.PostLoadAddons")

--addons/xenin_framework/lua/xeninui/libs/animations.lua:
local PNL = FindMetaTable("Panel")

function PNL:LerpColor(var, to, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local color = self[var]
	local anim = self:NewAnimation(duration)
	anim.Color = to
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartColor) then
			anim.StartColor = color
		end

		local newColor = XeninUI:LerpColor(newFract, anim.StartColor, anim.Color)
		self[var] = newColor
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpVector(var, to, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local vector = self[var]
	local anim = self:NewAnimation(duration)
	anim.Vector = to
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartVector) then
			anim.StartVector = vector
		end

		local newColor = XeninUI:LerpVector(newFract, anim.StartVector, anim.Vector)
		self[var] = newColor
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpAngle(var, to, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local angle = self[var]
	local anim = self:NewAnimation(duration)
	anim.Angle = to
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartAngle) then
			anim.StartAngle = angle
		end

		local newColor = XeninUI:LerpAngle(newFract, anim.StartAngle, anim.Angle)
		self[var] = newColor
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:EndAnimations()
	for i, v in pairs(self.m_AnimList or {}) do
		if v.OnEnd then v:OnEnd(self)end
		self.m_AnimList[i] = nil
	end
end

function PNL:Lerp(var, to, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local varStart = self[var]
	local anim = self:NewAnimation(duration)
	anim.Goal = to
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.Start) then
			anim.Start = varStart
		end

		local new = Lerp(newFract, anim.Start, anim.Goal)
		self[var] = new
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpMove(x, y, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local anim = self:NewAnimation(duration)
	anim.Pos = Vector(x, y)
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartPos) then
			anim.StartPos = Vector(pnl.x, pnl.y, 0)
		end

		local new = LerpVector(newFract, anim.StartPos, anim.Pos)
		self:SetPos(new.x, new.y)
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpMoveY(y, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local anim = self:NewAnimation(duration)
	anim.Pos = y
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartPos) then
			anim.StartPos = pnl.y
		end

		local new = Lerp(newFract, anim.StartPos, anim.Pos)
		self:SetPos(pnl.x, new)
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpMoveX(x, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local anim = self:NewAnimation(duration)
	anim.Pos = x
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartPos) then
			anim.StartPos = pnl.x
		end

		local new = Lerp(newFract, anim.StartPos, anim.Pos)
		self:SetPos(new, pnl.y)
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpHeight(height, duration, callback, easeFunc)
	if (!duration) then duration = XeninUI.TransitionTime end
	if (!easeFunc) then easeFunc = function(a, b, c, d)
			return XeninUI:Ease(a, b, c, d)end end

	local anim = self:NewAnimation(duration)
	anim.Height = height
	anim.Think = function(anim, pnl, fract)
		local newFract = easeFunc(fract, 0, 1, 1)

		if (!anim.StartHeight) then
			anim.StartHeight = pnl:GetTall()
		end

		local new = Lerp(newFract, anim.StartHeight, anim.Height)
		self:SetTall(new)
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpWidth(width, duration, callback, easeFunc)
	if (!duration) then duration = XeninUI.TransitionTime end
	if (!easeFunc) then easeFunc = function(a, b, c, d)
			return XeninUI:Ease(a, b, c, d)end end

	local anim = self:NewAnimation(duration)
	anim.Width = width
	anim.Think = function(anim, pnl, fract)
		local newFract = easeFunc(fract, 0, 1, 1)

		if (!anim.StartWidth) then
			anim.StartWidth = pnl:GetWide()
		end

		local new = Lerp(newFract, anim.StartWidth, anim.Width)
		self:SetWide(new)
	end
	anim.OnEnd = function()
		if callback then
			callback(self)
		end
	end
end

function PNL:LerpSize(w, h, duration, callback)
	if (!duration) then duration = XeninUI.TransitionTime end

	local anim = self:NewAnimation(duration)
	anim.Size = Vector(w, h)
	anim.Think = function(anim, pnl, fract)
		local newFract = XeninUI:Ease(fract, 0, 1, 1)

		if (!anim.StartSize) then
			anim.StartSize = Vector(pnl:GetWide(), pnl:GetWide(), 0)
		end

		local new = LerpVector(newFract, anim.StartSize, anim.Size)
		self:SetSize(new.x, new.y)
	end
	anim.OnEnd = function()
		if callback then
			callback()
		end
	end
end

--addons/xenin_framework/lua/xeninui/libs/essentials_sh.lua:
function XeninUI:Ease(t, b, c, d)
	t = t / d
	local ts = t * t
	local tc = ts * t


	return b + c * (-2 * tc + 3 * ts)
end

function XeninUI:EaseInOutQuintic(t, b, c, d)
	t = t / d
	local ts = t * t
	local tc = ts * t


	return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc)
end

function XeninUI:RemoveDebounce(name)
	timer.Remove("_debounce." .. name)
end

function XeninUI:Debounce(name, wait, func)
	if timer.Exists("_debounce." .. name) then
		timer.Remove("_debounce." .. name)
	end

	timer.Create("_debounce." .. name, wait, 1, function()
		func()

		timer.Remove("_debounce." .. name)
	end)
end

if SERVER then
	util.AddNetworkString("XeninUI.FullClientInit")

	net.Receive("XeninUI.FullClientInit", function(len, p)
		if p.XeninUI_FullClientInit then
			return
		end

		hook.Run("Xenin.OnClientFullInit", p)

		p.XeninUI_FullClientInit = true
	end)
else
	hook.Add("SetupMove", "Xenin.FullClientInit", function()
		timer.Simple(15, function()
			net.Start("XeninUI.FullClientInit")
			net.SendToServer()
		end)

		hook.Remove("SetupMove", "Xenin.FullClientInit")
	end)
end

function XeninUI:LerpColor(fract, from, to)
	return Color(Lerp(fract, from.r, to.r), Lerp(fract, from.g, to.g), Lerp(fract, from.b, to.b), Lerp(fract, from.a or 255, to.a or 255))
end

function XeninUI:GetAngleBetweenTwoVectors(a, b)
	local vec = (a - b):GetNormalized()
	local ang = vec:Angle()

	return ang
end

function XeninUI:GetVector2DDistance(a, b)

	return math.sqrt((a.x - b.x) ^ 2 + (a.y - b.y) ^ 2)
end


function XeninUI:LerpVector(frac, from, to, ease)
	local newFract = ease and ease(frac, 0, 1, 1) or XeninUI:Ease(frac, 0, 1, 1)

	return LerpVector(newFract, from, to)
end

function XeninUI:LerpAngle(frac, from, to, ease)
	local newFract = ease and ease(frac, 0, 1, 1) or XeninUI:Ease(frac, 0, 1, 1)

	return LerpAngle(newFract, from, to)
end

if SERVER then
	util.AddNetworkString("XeninUI.OSTime")

	hook.Add("PlayerInitialSpawn", "XeninUI.OSTime", function(p)
		net.Start("XeninUI.OSTime")
		net.WriteFloat(os.time())
		net.WriteFloat(CurTime())
		net.Send(p)
	end)
else
	os._SVRDiff = 0

	net.Receive("XeninUI.OSTime", function()
		local ostime = net.ReadFloat()
		local ct = net.ReadFloat()

		os._SVRDiff = os.time() - ostime + ct - CurTime()
	end)

	function os.ServerTime()
		return os.time() - os._SVRDiff
	end

	local function TCMD()
		print(os.time(), os.ServerTime(), os.date("%I:%M %p", os.time()), os.date("%I:%M %p", os.ServerTime()))
	end
	concommand.Add("print_servertime", TCMD)
end

function XeninUI:Map(tbl, func)
	local newTbl = {}
	for i, v in pairs(tbl) do
		newTbl[i] = func(v, i)
	end

	return newTbl
end


function XeninUI:Hue2RGB(p, q, t)
	if t < 0 then t = t + 1 end
	if t > 1 then t = t - 1 end
	if t < 1 / 6 then return p + (q - p) * 6 * t end
	if t < 1 / 2 then return q end
	if t < 2 / 3 then return p + (q - p) * (2 / 3 - t) * 6 end
	return p
end


function XeninUI:HSLToColor(h, s, l, a)
	local r, g, b
	local t = h / (2 * math.pi)

	if s == 0 then
		r, g, b = l, l, l
	else
		local q
		if l < 0.5 then
			q = l * (1 + s)
		else
			q = l + s - l * s
		end
		local p = 2 * l - q

		r = self:Hue2RGB(p, q, t + 1 / 3)
		g = self:Hue2RGB(p, q, t)
		b = self:Hue2RGB(p, q, t - 1 / 3)
	end

	return Color(r * 255, g * 255, b * 255, (a or 1) * 255)
end


function XeninUI:ColorToHSL(col)
	local r = col.r / 255
	local g = col.g / 255
	local b = col.b / 255
	local max, min = math.max(r, g, b), math.min(r, g, b)
	local b = max + min
	local h = b / 2
	if max == min then return 0, 0, h end
	local s, l = h, h
	local d = max - min
	s = l > .5 and d / (2 - b) or d / b
	if max == r then h = (g - b) / d + (g < b and 6 or 0)
	elseif max == g then
		h = (b - r) / d + 2
	elseif max == b then
		h = (r - g) / d + 4
	end
	return h * .16667, s, l
end

function XeninUI:DecToHex(d, zeros)
	return string.format("%0" .. (zeros or 2) .. "x", d)
end

function XeninUI:RGBToHex(color)
	return "#" .. self:DecToHex(math.max(math.min(color.r, 255), 0)) .. self:DecToHex(math.max(math.min(color.g, 255), 0)) .. self:DecToHex(math.max(math.min(color.b, 255), 0))
end

function XeninUI:HexToRGB(hex)
	hex = hex:gsub("#", "")

	if (#hex == 3) then
		local r = hex:sub(1, 1)
		local g = hex:sub(2, 2)
		local b = hex:sub(3, 3)

		return Color(tonumber("0x" .. r .. r), tonumber("0x" .. g .. g), tonumber("0x" .. b .. b))
	end

	return Color(tonumber("0x" .. hex:sub(1, 2)), tonumber("0x" .. hex:sub(3, 4)), tonumber("0x" .. hex:sub(5, 6)))
end

--addons/xenin_framework/lua/xeninui/libs/permissions.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/configurator/ui/entities/settings_base.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/configurator/ui/inputs/color.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/configurator/ui/inputs/textentrywithlabel.lua:
local x

--addons/xenin_framework/lua/xeninui/libs/players/ui/frame.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/libs/players/network/client.lua:
local NetworkClient
do
  local _class_0
  local _parent_0 = XeninUI.Network
  local _base_0 = {
    __name = "NetworkClient",
    __base = XeninUI.Network.__base,
    receiveNotification = function(self, ply)
      local noti = XeninUI.Players.NetworkHelper.receiveNotification()

      local str = noti.content:Split("\n")[1]
      local len = math.max(4, #str * 0.065)
      XeninUI:Notify(str, NOTIFY_HINT, len)
    end,
    receiveNotifications = function(self, ply)
      local amt = net.ReadUInt(8)
      local tbl = {}
      for i = 1, amt do
        table.insert(tbl, XeninUI.Players.NetworkHelper.receiveNotification())
      end

      hook.Run("XeninUI.Players.GotNotifications", tbl)
    end,
    sendReceiveNotifications = function(self)
      self:send("notifications", function(self) end)
    end,
    sendReadNotifications = function(self, ids)
      self:send("readNotifications", function(self)
        net.WriteUInt(#ids, 8)
        for i = 1, #ids do
          net.WriteUInt(ids[i], 32)
        end
      end)
    end,
    receiveReadNotifications = function(self, ply) end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  setmetatable(_base_0, _parent_0.__index)
  _class_0 = setmetatable({
    __init = function(self, ...)
      NetworkClient.__parent.__init(self, ...)

      self:setPrefix("Xenin.Players.")

      self:receiver("notification", self.receiveNotification)
      self:receiver("notifications", self.receiveNotifications)
      self:receiver("readNotifications", self.receiveReadNotifications)
    end,
    __base = _base_0,
    __parent = _parent_0
  }, {
    __index = function(cls, parent)
      local val = rawget(_base_0, parent)
      if val == nil then local _parent = rawget(cls, "__parent")
        if _parent then return _parent[parent]
        end
      else
        return val
      end
    end,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0)
  end
  NetworkClient = _class_0
end

XeninUI.Players.Network = NetworkClient()

--addons/xenin_framework/lua/xeninui/elements/popup.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/elements/scrollpanel.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/elements/sidebar_player.lua:
return gluapack()()
--addons/xenin_framework/lua/xeninui/elements/tooltip.lua:
surface.CreateFont("XeninUI.Tooltip", {
  font = "Montserrat",
  size = 18,
  weight = 500
})

local PanelMeta = FindMetaTable("Panel")

function PanelMeta:RemoveCooltip()
  if IsValid(self.Tooltip) then
    self.Tooltip:Hide()
  end

  self.EnableTooltip = false
end

function PanelMeta:SetCooltip(str, delay, offsetX, offsetY)
  self.EnableTooltip = true
  self.CursorEntered = 0
  self.ActivateTooltip = true
  self.TooltipStr = str
  self.TooltipDelay = delay or 0.2

  if self.Tooltip then
    self.Tooltip.Str = str

    surface.SetFont("XeninUI.Tooltip")
    local x, y = self:LocalToScreen(offsetX or 0, offsetY or 0)
    local width, height = surface.GetTextSize(self.TooltipStr)

    self.Tooltip:SetSize(width + 32, height + 24)
    self.Tooltip:SetPos(x + self:GetWide() / 2 - self.Tooltip:GetWide() / 2, y - self.Tooltip:GetTall() - 4)

    self.Tooltip:Show()
    return
  end

  local oldCursorEntered = self.OnCursorEntered
  self.OnCursorEntered = function(pnl)
    if oldCursorEntered then oldCursorEntered(pnl)end

    pnl.CursorEntered = CurTime() + pnl.TooltipDelay
  end

  local oldCursorExited = self.OnCursorExited
  self.OnCursorExited = function(pnl)
    if oldCursorExited then oldCursorExited(pnl)end

    pnl.CursorEntered = 0

    if IsValid(pnl.Tooltip) then
      pnl.Tooltip:Remove()
      pnl.Tooltip = nil
    end
  end

  local oldThink = self.Think
  self.Think = function(pnl)
    if oldThink then oldThink(pnl)end

    if (pnl.CursorEntered < CurTime() and !IsValid(pnl.Tooltip) and pnl:IsHovered() and pnl.EnableTooltip) then
      local x, y = pnl:LocalToScreen(offsetX or 0, offsetY or 0)
      local w = pnl:GetWide()

      surface.SetFont("XeninUI.Tooltip")
      local width, height = surface.GetTextSize(self.TooltipStr)

      pnl.Tooltip = vgui.Create("XeninUI.Tooltip")
      pnl.Tooltip:SetAlpha(0)
      pnl.Tooltip:SetDrawOnTop(true)
      pnl.Tooltip:SetSize(width + 32, height + 24)
      pnl.Tooltip:SetPos(x + self:GetWide() / 2 - pnl.Tooltip:GetWide() / 2, y - pnl.Tooltip:GetTall() - 4)
      pnl.Tooltip:AlphaTo(255, 0.15)
      pnl.Tooltip.Str = str
    end
  end

  local oldRemove = self.OnRemove
  self.OnRemove = function(pnl)
    if oldRemove then oldRemove(pnl)end

    if IsValid(pnl.Tooltip) then
      pnl.Tooltip:Remove()
    end
  end
end

function PanelMeta:SetCooltipString(str)
  self.TooltipStr = str
  if (!IsValid(self.Tooltip)) then return end
  self.Tooltip.Str = str

  local x, y = self:LocalToScreen(0, 0)
  local w = self:GetWide()

  surface.SetFont("XeninUI.Tooltip")
  local width, height = surface.GetTextSize(self.TooltipStr)

  self.Tooltip:SetSize(width + 32, height + 24)
  self.Tooltip:SetPos(x + self:GetWide() / 2 - self.Tooltip:GetWide() / 2, y - self.Tooltip:GetTall() - 4)
end

local PANEL = {}

function PANEL:Paint(w, h)
  local x, y = self:LocalToScreen(0, 0)

  BSHADOWS.BeginShadow()
  draw.RoundedBox(6, x, y, w, h - 8, color_white)
  draw.SimpleText(self.Str, "XeninUI.Tooltip", x + w / 2, y + (h - 8) / 2, Color(0, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
  BSHADOWS.EndShadow(2, 1, 1, 255, 0, 0)

  local tbl = {
    {
      x = w / 2 - 8,
      y = h - 8
    },
    {
      x = w / 2 + 8,
      y = h - 8
    },
    {
      x = w / 2,
      y = h
    },
    {
      x = w / 2 - 8,
      y = h - 8
    }
  }

  draw.NoTexture()
  surface.SetDrawColor(color_white)
  surface.DrawPoly(tbl)
end

vgui.Register("XeninUI.Tooltip", PANEL, "EditablePanel")

--addons/xenin_framework/lua/xeninui/libs/units/classes/result.lua:
do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Units.Result",
    setError = function(self, err)
      self.returnVal = err end,
    setSuccess = function(self, bool)
      self.success = bool end,
    getReturn = function(self)
      return self.returnVal end,
    isSuccess = function(self)
      return self.success end,
    getMessagePrint = function(self)
      local prefix = self.success and "+" or "-"
      local color = self.success and XeninUI.Theme.Green or XeninUI.Theme.Red
      local str = tostring(prefix) .. " " .. tostring(self.name)
      if (!self.success) then str = str .. " ** FAILED **"
        if isstring(self.returnVal) then

          local errMsg = self.returnVal:Split("stack traceback")
          errMsg = errMsg[1]:sub(1, #errMsg[1] - 1)
          str = str .. "\nError was: " .. tostring(errMsg)
        end
      end

      return {
        color,
        str
      }
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, name, success, returnVal)
      self.isResult = true

      self.name = name
      self.success = success
      self.returnVal = returnVal
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Units.Result = _class_0
end

--addons/xenin-coinflip/lua/coinflip/essentials/i18n.lua:
local i18n
do
  local _class_0
  local _base_0 = {
    setLanguage = function(self, lang, tbl)
      self.lang:Download("english", true)
      self.lang:SetActiveLanguage(lang)
      if (lang != "english" and !tbl) then
        self.lang:Download(lang, true)
      elseif tbl then
        self.lang:SetLocalLanguage(lang, tbl)
      end
    end,
    get = function(self, phrase, replacement, default)
      if replacement == nil then replacement = {}
      end
      local cache = self.lang:GetPhrase(phrase, replacement)
      if (cache and !istable(cache) and cache != "") then
        return cache
      end

      for i, v in pairs(replacement) do
        default = default:Replace(":" .. tostring(i) .. ":", v)
      end

      return default
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self)
      self.lang = XeninUI:Language("xenin_coinflip")
      self.lang:SetURL("https://gitlab.com/sleeppyy/xenin-languages")
      self.lang:SetFolder("coinflip")
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  i18n = _class_0
end

Coinflip.i18n = i18n()

--addons/xenin-coinflip/lua/coinflip/ui/menu.lua:
return gluapack()()
--addons/xenin-coinflip/lua/coinflip/ui/history.lua:
local PANEL = {}

function PANEL:Init()
	self.Title = self:Add("DLabel")
	self.Title:SetTextInset(0, 2)
	self.Title:SetFont("Coinflip.Games.Title")
	self.Title:SetTextColor(Color(220, 220, 220))

	self.Scroll = self:Add("XeninUI.Scrollpanel.Wyvern")
	self.Scroll:Dock(FILL)
	self.Scroll:DockMargin(16, 60, 16, 16)
end

function PANEL:Refresh()
  self.Rows = {}
  self.Title:SetText("")
  self.Loading = true

  net.Start("Coinflip.RequestHistory")
  net.SendToServer()

  hook.Add("Coinflip.RequestHistory", self, function(self, result)
    if (!IsValid(self)) then return end

    self.HasLoaded = true
    self.Loading = false
    self:Populate(result)
  end)

  hook.Add("Coinflip.Join", self, function(self, id, winner, time)
    timer.Simple(time + 1, function()
      if (!IsValid(self)) then return end

      self.HasLoaded = false
    end)
  end)

  hook.Add("Coinflip.PlayerJoined", self, function(self, id, challenger, winner, time)
    timer.Simple(time + 1, function()
      if (!IsValid(self)) then return end

      self.HasLoaded = false
    end)
  end)
end

function PANEL:Populate(tbl)
	for i, v in pairs(self.Scroll:GetChildren()[1]:GetChildren()) do
		v:Remove()
		self.Scroll:GetChildren()[1]:GetChildren()[i] = nil
	end

  local amt = #tbl
  self.Title:SetText(Coinflip.i18n:get("ui.history.title", { flips = amt }, "Last :flips: coinflips"))
  self.Title:SizeToContents()

	for i, v in ipairs(tbl) do
		local panel = self.Scroll:Add("Coinflip.History.Row")
		self.Rows[#self.Rows + 1] = panel
		panel:Dock(TOP)
		panel:DockMargin(0, 0, 8, 8)
		panel:SetTall(64)
		panel:SetID(i)
		panel:SetInfo(v)
	end

	self:InvalidateLayout()
end

function PANEL:OnSwitchedTo()
  if (self.HasLoaded) then return end

  self:Refresh()
end

function PANEL:Paint(w, h)
  if (self.Loading) then
    local x = w / 2
    local y = h / 2
    local size = 150

    XeninUI:DrawLoadingCircle(x, y, size)
  end
end

function PANEL:PerformLayout(w, h)
	self.Title:SetPos(16, 12)
	self.Title:SizeToContents()
end

vgui.Register("Coinflip.History", PANEL, "XeninUI.Panel")

net.Receive("Coinflip.RequestHistory", function(len)
  local result = net.ReadTable()
  
  hook.Run("Coinflip.RequestHistory", result)
end)
--addons/xenin-inventory/lua/inventory/classes/inventory.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/classes/inventory.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

local INV = {}
INV.inventory = {}
INV.bank = {}

AccessorFunc(INV, "m_player", "Player")

function INV.New(ply, inv, bank)
  local inv = table.Copy(INV)

  inv:SetPlayer(ply)
  inv:SetInventory(inv)
  inv:SetBank(bank)

  return inv
end

function INV:SetInventory(tbl)
  self.inventory = tbl or {}
end

function INV:GetBankSlots()
  return XeninInventory.Config.BankSlots.Paid[self:GetPlayer():GetUserGroup()] or XeninInventory.Config.BankSlots.Free
end

function INV:GetInventory()
  return self.inventory
end

function INV:GetBank()
  return self.bank
end

function INV:Message(str)
  if SERVER then
    net.Start("XeninInventory.Message")
    net.WriteString(str)
    net.Send(self:GetPlayer())
  else
    chat.AddText(XeninInventory.Config.PrefixCol or color_white, XeninInventory.Config.PrefixText .. " ", color_white, str)
  end
end

function INV:SetBank(tbl)
  self.bank = tbl or {}
end

function INV:Get(id, bank)
  local str = bank and "bank" or "inventory"
  return self[str][id]
end

function INV:Set(id, contents, bank)
  local str = bank and "bank" or "inventory"
  self[str][id] = contents
end

function INV:SetSlots(slots)
  if (!slots) then
    local donator = self:GetPlayer():GetUserGroup()

    slots = donator and XeninInventory.Config.Slots.Paid[donator] or XeninInventory.Config.Slots.Free
  end

  self.slots = slots
end

function INV:GetSlots()
  local donator = self:GetPlayer():GetUserGroup()

  return donator and XeninInventory.Config.Slots.Paid[donator] or XeninInventory.Config.Slots.Free
end

function INV:AddItem(index, ent, dropEnt, model, amount, data, bank)
  local tbl = self[bank and "bank" or "inventory"]
  local amt = tbl and tbl.amount or 0

  tbl[index] = {
    id = index,
    ent = ent,
    dropEnt = dropEnt,
    model = model,
    amount = amt + amount,
    data = data
  }
end

function INV:Add(ent, dropEnt, model, amount, data, ignoreDatabase)
  if XeninInventory.Config.Blacklist[ent] then return end
  data = data or {}
  local rarity = XeninInventory:GetRarity(dropEnt)
  local cat = XeninInventory.Config.Categories[rarity]
  if (!cat) then return end
  local item = XeninInventory:GetItem(dropEnt)
  local maxStack = XeninInventory.Config.WhitelistEntities[dropEnt] and 1 or item.MaxStack or cat.maxStack
  local count = table.Count(self:GetInventory())
  local slots = self:GetSlots()
  local slotsRequired = math.ceil(amount / maxStack)
  if ((count + slotsRequired) > slots) then return end
  local newSlot
  local newAmount

  local tbl = {}
  local earliestEmpty
  for i = 1, slots do
    local slot = self:Get(i)

    if slot then
      tbl[i] = slot
    elseif (!slot and !earliestEmpty) then
      earliestEmpty = i
    end
  end


  local amountTemp = amount

  local tempTbl = {
    ent = ent,
    dropEnt = dropEnt,
    amount = amount,
    data = data
  }


  for i, slot in pairs(tbl) do
    if (slot.ent != ent) then continue end
    if (slot.dropEnt != dropEnt) then continue end
    if (slot.amount >= maxStack) then continue end
    if (istable(slot.data) and item.CanStack and !item:CanStack(tempTbl, slot)) then continue end
    if (amountTemp <= 0) then break end
    local amt = math.Clamp(amount + (slot.amount or 0), 0, maxStack)
    if (amt <= 0) then continue end

    self:AddItem(i, ent, dropEnt, model, amt, data)
    amountTemp = amountTemp - amt

    if SERVER then
      if (!ignoreDatabase) then
        self:SaveSlot(i)
      end

      self:NetworkSlot(i)
    end

    tbl[i] = nil
  end


  if (amountTemp > 0) then

    if (amountTemp > maxStack) then
      self:AddItem(earliestEmpty, ent, dropEnt, model, maxStack, data)
      if (!self:Add(ent, dropEnt, model, amountTemp - maxStack, data, ignoreDatabase)) then return end
    else
      self:AddItem(earliestEmpty, ent, dropEnt, model, amountTemp, data)
    end

    if SERVER then
      if (!ignoreDatabase) then
        self:SaveSlot(earliestEmpty)
      end

      self:NetworkSlot(earliestEmpty)
    end
  end

  return true
end

function INV:AddV2(ent, dropEnt, amount, data, ignoreDatabase)
  return self:Add(ent, dropEnt, nil, amount, data, ignoreDatabase)
end

function INV:CanUseBank()
  local ply = self:GetPlayer()
  local npcs = ents.FindByClass("bank_npc")

  for i, v in pairs(npcs) do
    local dist = ply:GetPos():Distance(v:GetPos())

    if (dist > 200) then continue end

    return true
  end
end

function INV:SwapBank(inv, bank)
  if (!XeninInventory:CanUseInventory(self:GetPlayer())) then
    return self:Message(XeninInventory:GetPhrase("ChatCommand.AccessRestricted"))
  end
  if (!self:CanUseBank()) then return end
  local invTbl = self:Get(inv)
  local bankTbl = self:Get(bank, true)

  if invTbl then invTbl.id = bank end
  if bankTbl then bankTbl.id = inv end

  self:Set(bank, invTbl, true)
  self:Set(inv, bankTbl)

  if CLIENT then
    net.Start("XeninInventory.Swap.InventoryToBank")
    net.WriteUInt(inv, 10)
    net.WriteUInt(bank, 10)
    net.SendToServer()
  end

  if SERVER then
    if invTbl then
      self:SaveSlot(bank, true)
    else
      self:DeleteSlot(bank, true)
    end
    if bankTbl then
      self:SaveSlot(inv)
    else
      self:DeleteSlot(inv)
    end
  end
end

function INV:Swap(from, to, bank)
  if (!XeninInventory:CanUseInventory(self:GetPlayer())) then
    return self:Message(XeninInventory:GetPhrase("ChatCommand.AccessRestricted"))
  end
  local maxSlots = bank and self:GetBankSlots() or self:GetSlots()
  if (from <= 0 or to <= 0 or to > maxSlots or from > maxSlots) then return end

  if (bank and !self:CanUseBank()) then return end
  local toTbl = self:Get(to, bank)
  local fromTbl = self:Get(from, bank)

  if fromTbl then fromTbl.id = to end
  if toTbl then toTbl.id = from end

  self:Set(to, fromTbl, bank)
  self:Set(from, toTbl, bank)

  if CLIENT then
    if bank then
      net.Start("XeninInventory.Swap.Bank")
      net.WriteUInt(to, 10)
      net.WriteUInt(from, 10)
      net.SendToServer()
    else
      net.Start("XeninInventory.Swap")
      net.WriteUInt(to, 10)
      net.WriteUInt(from, 10)
      net.SendToServer()
    end
  end

  if SERVER then
    if fromTbl then
      self:SaveSlot(to, bank)
    else
      self:DeleteSlot(to, bank)
    end
    if toTbl then
      self:SaveSlot(from, bank)
    else
      self:DeleteSlot(from, bank)
    end
  end
end

function INV:ReduceAmount(id, amt, ignoreNetwork, useData)
  if (!XeninInventory:CanUseInventory(self:GetPlayer())) then
    return self:Message(XeninInventory:GetPhrase("ChatCommand.AccessRestricted"))
  end
  local slot = self:Get(id)
  if (!slot) then return end
  local amount = (useData and slot.data.amount or slot.data.Amount) or slot.amount
  local newAmount = amount - amt
  if (newAmount < 0) then return end
  if (newAmount == 0) then
    self:Set(id, nil)
    self:DeleteSlot(id)
    if (!ignoreNetwork) then
      self:NetworkSlot(id)
    end
  else
    if useData then
      if slot.data.amount then
        slot.data.amount = newAmount
      else
        slot.data.Amount = newAmount
      end
    else
      slot.amount = newAmount
    end

    self:Set(id, slot)
    self:SaveSlot(id)

    if (!ignoreNetwork) then
      self:NetworkSlot(id)
    end
  end

  return true
end

function INV:SaveSlot(id, bank)
  if (!XeninInventory:CanUseInventory(self:GetPlayer())) then
    return self:Message(XeninInventory:GetPhrase("ChatCommand.AccessRestricted"))
  end
  if CLIENT then return end

  local ply = self:GetPlayer()
  if (!ply) then return end
  local tbl = self:Get(id, bank)
  if (!tbl) then return end

  local sid64 = ply:SteamID64()
  local slot = id
  local ent = tbl.ent
  local dropEnt = tbl.dropEnt
  local amount = tbl.amount or 1
  local data = tbl.data or {}

  if bank then
    XeninInventory.Database:SaveBankSlot(sid64, slot, ent, dropEnt, amount, data)
  else
    XeninInventory.Database:SaveSlot(sid64, slot, ent, dropEnt, amount, data)
  end
end

function INV:DeleteSlot(id, bank)
  if (!XeninInventory:CanUseInventory(self:GetPlayer())) then
    return self:Message(XeninInventory:GetPhrase("ChatCommand.AccessRestricted"))
  end
  if CLIENT then return end

  local ply = self:GetPlayer()
  if (!ply) then return end

  if bank then
    XeninInventory.Database:DeleteBankSlot(ply:SteamID64(), id)
  else
    XeninInventory.Database:DeleteSlot(ply:SteamID64(), id)
  end
end

function INV:NetworkSlot(id, bank)
  if CLIENT then return end

  if bank then
    net.Start("XeninInventory.Bank.Slot")
    net.WriteUInt(id, 10)
    net.WriteTable(self:Get(id, true) or {})
    net.Send(self:GetPlayer())
  else
    net.Start("XeninInventory.Slot")
    net.WriteUInt(id, 10)
    net.WriteTable(self:Get(id) or {})
    net.Send(self:GetPlayer())
  end
end

function INV:Pickup(ent)
  if (!XeninInventory:CanUseInventory(self:GetPlayer())) then
    return self:Message(XeninInventory:GetPhrase("ChatCommand.AccessRestricted"))
  end
  if (!self:GetPlayer():Alive()) then return end
  if (!ent or !IsValid(ent)) then return end
  local entClass = ent:GetClass()
  if (entClass == NULL) then return end
  if ent.ignoreInv then return end
  if XeninInventory.Config.Blacklist[entClass] then
    return self:Message(XeninInventory:GetPhrase("ChatCommand.Blacklisted"))
  end
  local item = XeninInventory:GetItem(entClass)
  if (!item) then return end
  if (item.GetEntityClass and XeninInventory.Config.Blacklist[item:GetEntityClass(ent)]) then
    return self:Message(XeninInventory:GetPhrase("ChatCommand.Blacklisted"))
  end
  if CLIENT then return end
  local canPickup, err = hook.Run("XeninInventory.CanPickUp", ent)
  if (canPickup == false) then
    return self:Message(err)
  end
  if item.CanPickup then
    local pickup, err = item:CanPickUp(ent)
    if (!pickup) then
      return self:Message(err)
    end
  end

  item:OnPickup(self:GetPlayer(), ent)

  return true
end

function INV:NetworkAll()
  if CLIENT then return end

  net.Start("XeninInventory.FullSync")
  net.WriteTable(self:GetInventory())
  net.WriteTable(self:GetBank())
  net.Send(self:GetPlayer())
end

local ply = FindMetaTable("Player")

function ply:XeninInventory()
  if (!self.inventory) then
    self.inventory = INV.New(self)
  end

  return self.inventory
end

--addons/xenin-inventory/lua/inventory/configuration/items/zwf_joint_ent.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/inventory/configuration/items/zyb_jar.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/importer/importer.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

local Importer
do
    local _class_0
    local _base_0 = {
        __name = "Importer",
        setActiveSettings = function(self, activeSettings)
            self.activeSettings = activeSettings
            return self
        end,
        setSettings = function(self, settings)
            self.settings = settings
            return self
        end,
        setName = function(self, name)
            self.name = name
            return self
        end,
        getActiveSettings = function(self)
            return self.activeSettings
        end,
        getSettings = function(self)
            return self.settings
        end,
        getName = function(self)
            return self.name
        end,
        getId = function(self)
            return self.id
        end,
        getCache = function(self, id)
            return self.cache[id]end,
        setCache = function(self, id, val)
            self.cache[id] = val end,
        setActiveSetting = function(self, id, val)
            self.activeSettings[id] = val end,
        getActiveSetting = function(self, id)
            return self.activeSettings[id]end,
        addSetting = function(self, ...)
            local inst = XeninInventory.ImporterSetting(...)
            self.settings[inst.id] = inst
        end,
        __type = function(self)
            return "XeninInventory.Importer"end
    }
    _base_0.__index = _base_0
    _class_0 = setmetatable({
        __init = function(self)
            self.activeSettings = {}
            self.cache = {}
            self.settings = {}
        end,
        __base = _base_0
    }, {
        __index = _base_0,
        __call = function(cls, ...)
            local _self_0 = setmetatable({}, _base_0)
            cls.__init(_self_0, ...)
            return _self_0
        end
    })
    Importer = _class_0
end

XeninInventory.Importer = Importer

--addons/xenin-inventory/lua/inventory/ui/bank.lua:
return gluapack()()
--addons/xenin-inventory/lua/inventory/ui/frame.lua:
--[[
This code was generated by LAUX, a Lua transpiler
LAUX is a fork of LAU with additional changes.

More info & source code can be found at: https://gitlab.com/sleeppyy/laux
]]

local PANEL = {}

function PANEL:Init()
  XeninInventory.Frame = self

  self.body = self:Add("XeninInventory.XeninInventory")
  self.body:Dock(FILL)





end

function PANEL:OnRemove()
  XeninInventory.Frame = nil
end

function PANEL:PerformLayout(w, h)
  self.BaseClass.PerformLayout(self, w, h)


end
vgui.Register("XeninInventory.Frame", PANEL, "XeninUI.Frame")

concommand.Add("inventory", function()
  if IsValid(XeninInventory.Frame) then return end
  if (!XeninInventory:CanUseInventory(LocalPlayer())) then
    return LocalPlayer():XeninInventory():Message(XeninInventory:GetPhrase("ChatCommand.AccessRestricted"))
  end

  local frame = vgui.Create("XeninInventory.Frame")
  local width = math.min(ScrW(), 1100)
  local height = math.min(ScrH(), 828)
  frame:SetSize(width, height)
  frame:Center()
  frame:MakePopup()
  frame:SetTitle("Inventory")
end)

--addons/yet_another_warn_system/lua/yaws/core/sh_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20211019

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from
--- @field CAMI_Source string @The source specified by the admin mod which registered this usergroup (if any, converted to a string)

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
--- ⚠ **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    admin = {
        Name = "admin",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin",
        CAMI_Source = "Garry's Mod",
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    if source then
        usergroup.CAMI_Source = tostring(source)
    end
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
--- ℹ **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
--- ⚠ **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
--- ⚠ **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end
--addons/yet_another_warn_system/lua/yaws/punishments/sh_darkrp_money.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/elements/cl_panel.lua:
-- just a normal panel but with s h a d o w s
local PANEL = {}

function PANEL:Init()
    self.sideShadow = vgui.Create("yaws.shadow", self:GetParent())
    self.bottomShadow = vgui.Create("yaws.shadow", self:GetParent())
    self.bottomShadow:Down()
end 

function PANEL:Paint(w, h)
    local colors = YAWS.UI.ColorScheme() 

    draw.RoundedBox(0, 0, 0, w, h, colors['panel_background'])
end

function PANEL:RemoveShadows()
    self.sideShadow:Remove()
    self.bottomShadow:Remove()
end 
function PANEL:HideShadows(hide) -- for panels like the admin tab where it's reused through multiple senarios, both needing and wanting to ditch shadows each
    if(hide) then
        self:RemoveShadows()
    else
        if(!IsValid(self.sideShadow)) then 
            self.sideShadow = vgui.Create("yaws.shadow", self:GetParent())
        end
        if(!IsValid(self.bottomShadow)) then 
            self.bottomShadow = vgui.Create("yaws.shadow", self:GetParent())
            self.bottomShadow:Down()
        end
        self:InvalidateLayout()
    end
end 

function PANEL:PerformLayout(w, h)
    self:LayoutShadows(w, h)
    self:PostPerformLayout(w, h)
end 
function PANEL:LayoutShadows(w, h)
    local x,y = self:GetPos()
    if(IsValid(self.sideShadow)) then 
        self.sideShadow:SetPos(x + w, y)
        self.sideShadow:SetSize(3, h)
    end 

    if(IsValid(self.bottomShadow)) then 
        self.bottomShadow:SetPos(x, y + h)
        self.bottomShadow:SetSize(w + 1, 3)
    end
end 
function PANEL:PostPerformLayout(w, h) end 

function PANEL:OnRemove()
    self:RemoveShadows()
end 

vgui.Register("yaws.panel", PANEL, "DPanel")
--addons/yet_another_warn_system/lua/yaws/ui/elements/cards/cl_expandable_card_base.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/elements/cards/cl_player_card.lua:
local PANEL = {}

AccessorFunc(PANEL, "name", "Name")

function PANEL:Init()
    self.name = ""
    self.steamid = ""

    self.avatarPanel = vgui.Create("yaws.round_avatar", self)
    self.avatarPanel:SetMouseInputEnabled(false)

    self:SetText("")

    self.sideShadow = vgui.Create("yaws.shadow", self:GetParent())
    self.bottomShadow = vgui.Create("yaws.shadow", self:GetParent())
    self.bottomShadow:Down()

    self.DoRightClick = function()
        local options = DermaMenu()

        options:AddOption(YAWS.Language.GetTranslation("player_card_warn"), function() 
            if(!YAWS.UI.CurrentData['can_view']['warn_players']) then 
                YAWS.Language.SendMessage("chat_no_permission")
                return
            end 
    
            -- YAWS.UI.CurrentData.FrameCache:Remove()
            YAWS.UI.WarnPlayerPopup({
                name = self.name,
                steamid = self.steamid,
                realSteamID = util.SteamIDFrom64(self.steamid)
            })
        end):SetIcon("icon16/page_white_edit.png")
        options:AddOption(YAWS.Language.GetTranslation("player_card_name"), function() 
            SetClipboardText(self.name) 
        end):SetIcon("icon16/user.png")
        options:AddOption(YAWS.Language.GetTranslation("player_card_steamid"), function() 
            SetClipboardText(util.SteamIDFrom64(self.steamid)) 
        end):SetIcon("icon16/tag_blue.png")
        options:AddOption(YAWS.Language.GetTranslation("player_card_steamid64"), function() 
            SetClipboardText(self.steamid) 
        end):SetIcon("icon16/tag_green.png")

        options:Open()
    end 
end 

function PANEL:SetPlayer(ply)
    self.name = ply:Name()
    self.steamid = ply:SteamID64()

    self.avatarPanel:SetPlayer(ply, 128)
end 
function PANEL:SetOfflinePlayer(sid, data)
    self.name = data.name
    self.steamid = sid

    self.avatarPanel:SetSteamID(sid, 128)
end 

function PANEL:PerformLayout(w, h)
    self.avatarPanel:Dock(LEFT)
    self.avatarPanel:DockMargin(h * 0.125, h * 0.125, h * 0.125, h * 0.125)
    self.avatarPanel:SetWidth(self.avatarPanel:GetTall())
    
    self:LayoutShadows(w, h)
end 

function PANEL:LayoutShadows(w, h)
    local x,y = self:GetPos()
    y = y + self:GetParent():GetY()
    
    if(IsValid(self.sideShadow)) then 
        self.sideShadow:SetPos(x + w, y)
        self.sideShadow:SetSize(3, h)
    end 

    if(IsValid(self.bottomShadow)) then 
        self.bottomShadow:SetPos(x, y + h)
        self.bottomShadow:SetSize(w + 1, 3)
    end
end 

function PANEL:RemoveShadows() 
    self.bottomShadow:Remove()
    self.sideShadow:Remove()
end 
function PANEL:OnRemove()
    self:RemoveShadows()
end 

function PANEL:Paint(w, h)
    local colors = YAWS.UI.ColorScheme()

    -- draw.RoundedBox(0, 0, 0, w, h, colors['player_card_border'])
    -- draw.RoundedBox(0, 1, 1, w - 2, h - 2, colors['player_card_bg'])
    draw.RoundedBox(0, 0, 0, w, h, colors['player_card_bg'])

    -- draw.RoundedBox(0, 0, 0, w, h, Color(255, 0, 0))
    draw.SimpleText(self.name, YAWS.UI.ScaleFont(self.name, (w - h), 7, 9), h, h * 0.39, colors['text_header'], 0, 1)
    draw.SimpleText(util.SteamIDFrom64(self.steamid or ""), "yaws.7", h, h * 0.61, colors["text_main"], 0, 1)

    -- YAWS.UI.SetSurfaceDrawColor(colors['player_card_border'])
    -- local rad = ((h - ((h * 0.16) * 2)) / 2) + 2
    -- YAWS.UI.DrawCircle(h / 2, h / 2, rad, rad)
end

vgui.Register("yaws.player_card", PANEL, "DButton")
--addons/yet_another_warn_system/lua/yaws/ui/elements/cards/cl_preset_entry.lua:
local PANEL = {}

function PANEL:Init()
    self.presetData = {}
    
    local colors = YAWS.UI.ColorScheme()
    self.bin = vgui.Create("yaws.iconbtn", self)
    self.bin:SetMaterial(YAWS.UI.MaterialCache['trash'], colors['text_header'])
    self.bin.DoClick = function()
        YAWS.UI.CurrentData.WaitingForServerResponse = true 
        YAWS.UI.DisplayLoading(YAWS.UI.CurrentData.MasterCache)
        
        net.Start("yaws.config.removepreset")
        net.WriteString(self.presetData.name)
        net.SendToServer()
        
        YAWS.UI.LoadingCache = {
            panel = "remove_preset",
            key = self.presetData.name
        }
    end
    
    self.edit = vgui.Create("yaws.iconbtn", self)
    self.edit:SetMaterial(YAWS.UI.MaterialCache['edit'], colors['text_header'])
    self.edit.DoClick = function()
        -- YAWS.UI.EditPunishment(self.presetData)
        YAWS.UI.EditPreset(self.presetData)
    end 

    self.sideShadow = vgui.Create("yaws.shadow", self:GetParent())
    self.bottomShadow = vgui.Create("yaws.shadow", self:GetParent())
    self.bottomShadow:Down()
    
    self.descX = nil 
end 

function PANEL:Paint(w, h)
    local colors = YAWS.UI.ColorScheme()
    draw.RoundedBox(0, 0, 0, w, h, colors["panel_background"])
    
    local curX = h / 2
    local pointsWidth = draw.SimpleText(self.presetData.points, "yaws.9", curX, h / 2, colors['text_header'], 1, 1)
    
    curX = math.max(h / 2 + 30, h / 2 + pointsWidth + 5)
    draw.RoundedBox(0, curX, 10, 2, h - 20, colors['divider'])
    
    curX = curX + 20
    local nW = draw.SimpleText(self.presetData.name, "yaws.8", curX, h / 2, colors['text_header'], 0, 1)
    
    curX = curX + nW + 15
    draw.SimpleText('"' .. self.presetData.reason .. '"', "yaws.7", curX, h / 2, colors['text_main'], 0, 1)
end 

function PANEL:LayoutShadows(w, h)
    local x,y = self:GetPos()
    if(IsValid(self.sideShadow)) then 
        self.sideShadow:SetPos(x + w, y)
        self.sideShadow:SetSize(3, h)
    end 

    if(IsValid(self.bottomShadow)) then 
        self.bottomShadow:SetPos(x, y + h)
        self.bottomShadow:SetSize(w + 1, 3)
    end
end 

function PANEL:PerformLayout(w, h)
    self.bin:Dock(RIGHT)
    self.bin:DockMargin(h / 3, h / 3, h / 3, h / 3)
    self.bin:SetWide(h / 3)
    
    self.edit:Dock(RIGHT)
    self.edit:DockMargin(h / 3, h / 3, 0, h / 3)
    self.edit:SetWide(h / 3)

    self:LayoutShadows(w, h)
end 

function PANEL:SetPresetData(name, data)
    self.presetData = data
    self.presetData.name = name
    -- PrintTable(data)
end 

function PANEL:RemoveShadows() 
    self.bottomShadow:Remove()
    self.sideShadow:Remove()
end 
function PANEL:OnRemove()
    self:RemoveShadows()
end 

vgui.Register("yaws.preset_entry", PANEL, "DPanel")
--addons/yet_another_warn_system/lua/yaws/ui/elements/inputs/cl_button.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/layouts/cl_misc.lua:
return gluapack()()
--addons/yet_another_warn_system/lua/yaws/ui/layouts/popups/cl_edit_punishment.lua:
function YAWS.UI.EditPunishment(punshishmentData)
    local frame = vgui.Create("yaws.frame")
    frame:SetSize(ScrW() * 0.45, ScrH() * 0.3)
    frame:Center()
    frame:MakePopup()
    frame.bgColor = Color(0, 0, 0, 200)
    -- frame:DoModal()
    local oldThreshold = punshishmentData.threshold

    local master = vgui.Create("DPanel", frame)
    frame.PerformLayout = function(self, w, h)
        master:Dock(FILL)

        if(!YAWS.UserSettings.GetValue("disable_fades")) then 
            frame:FadeIn()
        end
    end 

    local top = vgui.Create("yaws.panel", master)
    
    local selectType = vgui.Create("yaws.combo", top)
    -- selectType:SetText(punshishmentData.typeInfo.name)
    for k,v in pairs(YAWS.Punishments.Types) do
        selectType:AddChoice(v.name, k, (k == punshishmentData.type))
    end

    local pointCount = vgui.Create("yaws.wang", top)
    pointCount:SetText("")
    pointCount:SetPlaceholder(YAWS.Language.GetTranslation("generic_point_count"))
    pointCount:SetMin(0)
    pointCount:SetMax(4096)
    pointCount:SetValue(punshishmentData.threshold)


    local options = vgui.Create("yaws.panel", master)
    local scroll = vgui.Create("yaws.scroll", options)

    local optionList = {}
    local function updateOptionList(newType)
        scroll:Clear()
        
        optionList = {}
        local type = YAWS.Punishments.Types[newType]
        for k,v in pairs(type.params) do 
            optionList[k] = punshishmentData.params[k] or v.default
            -- Create a panel for each param and dock it to the top of the scroll panel. Make it display the name and description of the parameter in the paint function.
            local panel = vgui.Create("DPanel", scroll)
            panel:Dock(TOP)
            panel:SetTall(scroll:GetTall() * 0.6)
            panel:DockMargin(0, 1, 0, 0)
            panel.Paint = function(self, w, h)
                -- draw.RoundedBox(0, 0, 0, w, h, Color(255, 0, 0))
                -- draw.RoundedBox(0, 0, 0, w, 1, Color(0, 255, 0))
                local colors = YAWS.UI.ColorScheme() 
                -- Parameter name
                local _,nextY = draw.SimpleText(v.name, "yaws.8", 10, 10, colors['text_header'], 0, 0)

                -- Parameter description
                draw.SimpleText(v.description, "yaws.7", 10, nextY + 10, colors['text_main'], 0, 0)
            end
            
            if(v.type == "string") then 
                local textEntry = vgui.Create("yaws.text_entry", panel)
                textEntry:SetValue(punshishmentData.params[k] or v.default)
                textEntry.OnChange = function(self)
                    optionList[k] = self:GetValue()
                end
                    
                panel.PerformLayout = function(self, w, h)
                    textEntry:Dock(BOTTOM)
                    textEntry:SetHeight(h * 0.33)
                    textEntry:DockMargin(10, 0, 10, 10)
                end
            end 
            if(v.type == "number") then 
                local wang = vgui.Create("yaws.wang", panel)
                wang:SetValue(punshishmentData.params[k] or v.default)
                wang.OnChange = function(self)
                    optionList[k] = self:GetValue()
                end
                wang:SetMin(0)
                wang:SetMax(4294967296)
                    
                panel.PerformLayout = function(self, w, h)
                    wang:Dock(BOTTOM)
                    wang:SetHeight(h * 0.33)
                    wang:DockMargin(10, 0, 10, 10)
                end
            end 
        end
    end 

    selectType.OnSelect = function(self, index, value, data)
        updateOptionList(data)
    end 

    local buttonPanel = vgui.Create("DPanel", master)
    buttonPanel.Paint = function(self, w, h)
        -- draw.RoundedBox(0, 0, 0, w, h, Color(255, 0, 0))
    end 

    local cancel = vgui.Create("yaws.button", buttonPanel)
    cancel:SetLabel(YAWS.Language.GetTranslation("generic_cancel"))
    cancel:SetColors('button_warn_base', 'button_warn_hover')
    cancel.DoClick = function() 
        frame:Close()
    end 

    local save = vgui.Create("yaws.button", buttonPanel)
    save:SetLabel(YAWS.Language.GetTranslation("generic_save"))
    save.DoClick = function() 
        YAWS.UI.CurrentData.WaitingForServerResponse = true 
        YAWS.UI.DisplayLoading(YAWS.UI.CurrentData.MasterCache)

        local typeKey = selectType:GetOptionData(selectType:GetSelectedID())
        net.Start("yaws.punishments.editpunishment")
        net.WriteUInt(oldThreshold, 12)
        net.WriteString(typeKey)
        net.WriteUInt(pointCount:GetValue(), 12)
        
        net.WriteUInt(table.Count(optionList), 16)
        for k,v in pairs(optionList) do 
            net.WriteString(k)
            net.WriteString(YAWS.Punishments.Types[typeKey].params[k].type)
            if(YAWS.Punishments.Types[typeKey].params[k].type == "string") then 
                net.WriteString(v)
            end 
            if(YAWS.Punishments.Types[typeKey].params[k].type == "number") then 
                net.WriteUInt(v, 32)
            end
        end

        net.SendToServer()

        YAWS.UI.LoadingCache = {
            panel = "edit_punishment",
            type = typeKey,
            pointValue = pointCount:GetValue(),
            params = optionList,
            oldValue = oldThreshold
        }

        frame:Close()
    end 
    
    master.Paint = function(self, w, h) end 
    master.PerformLayout = function(self, w, h) 
        buttonPanel:Dock(BOTTOM)
        buttonPanel:DockPadding(10, 10, 10, 10)
        buttonPanel:SetTall(h * 0.18)

        save:Dock(RIGHT)
        save:SetWide(w * 0.25)
        save:DockMargin(0, 0, 10, 0)

        cancel:Dock(RIGHT)
        cancel:SetWide(w * 0.25)


        top:Dock(TOP)
        top:DockMargin(10, 10, 10, 10)
        top:DockPadding(10, 10, 10, 10)
        top:SetTall(h * 0.18)

        pointCount:Dock(RIGHT)
        pointCount:SetWide(w * 0.25)
        pointCount:DockMargin(10, 0, 0, 0)

        selectType:Dock(FILL)


        options:Dock(FILL)
        options:DockMargin(10, 0, 10, 0)

        scroll:Dock(FILL)
        updateOptionList(punshishmentData.type)
    end
    master:InvalidateLayout()
end
--addons/yet_another_warn_system/lua/yaws/ui/layouts/popups/cl_view_warn.lua:
function YAWS.UI.ViewWarning(playerData, warnData)
    local frame = vgui.Create("yaws.frame")
    frame:SetSize(ScrW() * 0.5, ScrH() * 0.265)
    frame:Center()
    frame:MakePopup()
    frame.bgColor = Color(0, 0, 0, 200)
    frame:DoModal()

    local master = vgui.Create("DPanel", frame)
    frame.PerformLayout = function(self, w, h)
        master:Dock(FILL)

        if(!YAWS.UserSettings.GetValue("disable_fades")) then 
            frame:FadeIn()
        end
    end 

    local playersPanel = vgui.Create("yaws.panel", master)

    local user = vgui.Create("yaws.round_avatar", playersPanel)
    user:SetSteamID(warnData.player, 256)
    local admin = vgui.Create("yaws.round_avatar", playersPanel)
    admin:SetSteamID(warnData.adminSteamID, 256)
    
    playersPanel.PostPerformLayout = function(self, w, h)
        user:Dock(LEFT)
        user:DockMargin(10, 10, 10, 10)
        user:SetWide(user:GetTall())
            
        admin:Dock(RIGHT)
        admin:DockMargin(10, 10, 10, 10)
        admin:SetWide(admin:GetTall())
    end 
    local adminRealSteamID = util.SteamIDFrom64(warnData.adminSteamID)
    playersPanel.Paint = function(self, w, h)
        local colors = YAWS.UI.ColorScheme()
        draw.RoundedBox(0, 0, 0, w, h, colors['panel_background'])
    
        draw.SimpleText(playerData.name, "yaws.9", h + 5, h * 0.375, colors['text_header'], 0, 1)
        draw.SimpleText(playerData.realSteamID, "yaws.7", h + 5, h * 0.625, colors['text_main'], 0, 1)
    
        draw.SimpleText(warnData.admin, "yaws.9", w - (h + 5), h * 0.375, colors['text_header'], 2, 1)
        draw.SimpleText(adminRealSteamID, "yaws.7", w - (h + 5), h * 0.625, colors['text_main'], 2, 1)

        local warnedWidth = draw.SimpleText(YAWS.Language.GetTranslation("generic_warned"), "yaws.8", w / 2, h * 0.5, colors['text_header'], 1, 1)

        YAWS.UI.SetSurfaceDrawColor(colors['text_header'])
        surface.SetMaterial(YAWS.UI.MaterialCache['arrow'])
        -- this math is dubious
        surface.DrawTexturedRect((w / 2) + (warnedWidth / 2) + 5, h * 0.5 - ((h * 0.25) / 2), h * 0.25, h * 0.25)
        surface.DrawTexturedRect((w / 2) - (warnedWidth / 2) - 5 - (h * 0.25 * 0.8), h * 0.5 - ((h * 0.25) / 2), h * 0.25, h * 0.25)
    end 
    
    local infoPanel = vgui.Create("yaws.panel", master)
    infoPanel.Paint = function(self, w, h)
        local colors = YAWS.UI.ColorScheme() 
        draw.RoundedBox(0, 0, 0, w, h, colors['panel_background'])

        local _,rHeaderH = draw.SimpleText(YAWS.Language.GetTranslation("viewing_warn_reason"), "yaws.8", 10, 10, colors['text_header'], 0, 0)

        draw.DrawText(YAWS.UI.TextWrap(warnData.reason, "yaws.7", w - 20), "yaws.7", 10, rHeaderH + 10, colors['text_main'], 0, 1)
        surface.SetFont("yaws.7")
        local _,reasonH = surface.GetTextSize(YAWS.UI.TextWrap(warnData.reason, "yaws.7", w - 20))
        reasonH = reasonH + 10

        local _,tHeaderH = draw.SimpleText(YAWS.Language.GetTranslation("viewing_warn_time"), "yaws.8", 10, rHeaderH + reasonH + 25, colors['text_header'], 0, 1)
        draw.SimpleText(YAWS.Language.GetTranslation("viewing_warn_server"), "yaws.8", w / 2, rHeaderH + reasonH + 25, colors['text_header'], 1, 1)
        draw.SimpleText(YAWS.Language.GetTranslation("viewing_warn_point"), "yaws.8", w - 10, rHeaderH + reasonH + 25, colors['text_header'], 2, 1)
        
        draw.SimpleText(os.date("%H:%M:%S on %d/%m/%Y", warnData.timestamp), "yaws.7", 10, rHeaderH + reasonH + tHeaderH + 25, colors['text_main'], 0, 1)
        draw.SimpleText(warnData.server_id, "yaws.7", w / 2, rHeaderH + reasonH + tHeaderH + 25, colors['text_main'], 1, 1)
        draw.SimpleText(YAWS.Language.GetFormattedTranslation("points_format", warnData.points), "yaws.7", w - 10, rHeaderH + reasonH + tHeaderH + 25, colors['text_main'], 2, 1)
    end 

    local actionPanel = vgui.Create("yaws.panel", master)
    -- actionPanel:DockPadding(10, 10, 10, 10)
    actionPanel:RemoveShadows()
    
    local goBackButton = vgui.Create("yaws.button", actionPanel)
    goBackButton:SetLabel(YAWS.Language.GetTranslation("generic_back"))
    goBackButton.DoClick = function()
        frame:Close()
    end

    local deleteButton 
    if(YAWS.UI.CurrentData.can_view.delete_warns) then 
        deleteButton = vgui.Create("yaws.button", actionPanel)
        deleteButton:SetLabel(YAWS.Language.GetTranslation("generic_delete"))
        deleteButton:SetColors('button_warn_base', 'button_warn_hover')
        deleteButton.DoClick = function()
            frame:Close()
            if(YAWS.UI.CurrentData.FrameCache) then 
                YAWS.UI.CurrentData.FrameCache:Close()
            end 
            
            net.Start("yaws.warns.deletewarn")
            net.WriteString(warnData.id)
            net.SendToServer()
        end
    end 
    
    actionPanel.Paint = function() end 
    actionPanel.PerformLayout = function(self, w, h)
        if(deleteButton) then 
            goBackButton:Dock(LEFT)
            goBackButton:SetWide((w * 0.5) - 5)

            deleteButton:Dock(RIGHT)
            deleteButton:SetWide((w * 0.5) - 5)
        else 
            goBackButton:Dock(FILL)
        end 
    end 
    
    master.Paint = function(self, w, h) end 
    master.PerformLayout = function(self, w, h) 
        playersPanel:Dock(TOP)
        playersPanel:SetHeight(h * 0.27)
        playersPanel:DockMargin(10, 10, 10, 10)

        infoPanel:Dock(FILL)
        infoPanel:DockMargin(10, 0, 10, 10)
    
        actionPanel:Dock(BOTTOM)
        actionPanel:SetHeight(33)
        actionPanel:DockMargin(10, 0, 10, 10)
    end
    master:InvalidateLayout()
end
--addons/advancedkillfeed/lua/z_advancedkillfeed/client/cl_z_advancedkillfeed_vgui.lua:
return gluapack()()
--addons/advancedkillfeed/lua/z_advancedkillfeed/client/cl_z_advancedkillfeed_menu_vgui.lua:
return gluapack()()
--addons/advancedkillfeed/lua/z_advancedkillfeed/client/cl_z_advancedkillfeed_anim.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local sin = math.sin
local abs = math.abs
local round = math.Round
local Rand = math.Rand
local min = math.min
local max = math.max

function CL_ADVANCEDFEED.AnimSwitch(strLbl)
	
	local letterCount = #strLbl.letters
	if letterCount == 0 then return end
	
	local tall = strLbl:GetTall()
	local letterDist = 0.1
	
	for i=1,letterCount do 
		
		local speed = CurTime()*2.5
		local maxHeight = tall*0.35
		local moveUp = strLbl:GetOriginalYPos(i)/4
		
		local newY = (abs(sin(( speed - (letterDist)))) * maxHeight )
		
		if i%2 == 0 then
			newY = -newY+maxHeight
		end
		
		newY = newY + moveUp
		
		strLbl:SetYPos(i,newY)
		
	end

end

function CL_ADVANCEDFEED.AnimWave(strLbl)
	
	local letterCount = #strLbl.letters
	if letterCount == 0 then return end
	
	local tall = strLbl:GetTall()
	
	for i=1,letterCount do
	
		local speed = CurTime()*2.5
		local letterDist = i*0.1
		local maxHeight = tall*0.3
		local moveUp = tall*0.1 - (strLbl:GetOriginalYPos(i)/2)
		
		local newY = (abs(sin(( speed - (letterDist)))) * maxHeight ) - moveUp
			
		strLbl:SetYPos(i,newY)
		
	end
	
end

function CL_ADVANCEDFEED.AnimWaveDouble(strLbl)
	
	local letterCount = #strLbl.letters
	if letterCount == 0 then return end
	
	local tall = strLbl:GetTall()
	
	for index=1,letterCount do 

		local i = index
		
		if i%2 == 0 then
			i = letterCount + i/2
		end
		
		local speed = CurTime()*2.5
		local letterDist = i*0.1
		local maxHeight = tall*0.35
		local moveUp = tall*0.1 - (strLbl:GetOriginalYPos(index)/2)
		
		local newY = (abs(sin(( speed - (letterDist)))) * maxHeight ) - moveUp
				
		strLbl:SetYPos(index,newY)
		
	end
	
end

function CL_ADVANCEDFEED.AnimWaveDistortion(strLbl)
	
	local letterCount = #strLbl.letters
	if letterCount == 0 then return end
	
	local tall = strLbl:GetTall()
	
	for i=1,letterCount do 
	
		local speed = CurTime()*2.5*((letterCount-i)/letterCount)
		local letterDist = i*0.1
		local maxHeight = tall*0.35
		local moveUp = tall*0.1 - (strLbl:GetOriginalYPos(i)/2)
		
		local newY = (abs(sin(( speed - (letterDist)))) * maxHeight ) - moveUp
				
		strLbl:SetYPos(i,newY)
		
	end
		
end

local alphabet = "abcdefghijklmnopqrstuvwxyz"

function CL_ADVANCEDFEED.AnimTypeWriter(strLbl,rep)
	
	if strLbl.StopAnimTypeWriter then return end
	
	local letterCount = #strLbl.letters
	if letterCount == 0 then return end
	
	if strLbl.nextType == nil then 
		strLbl.nextType = CurTime() + 1
	end
	
	-- speed will be scaled with string lenght
	local speed = max(SH_ADVANCEDFEED.Settings.animTypeWriterSpeed-(letterCount/100),0)
	
	local strLblAlpha = strLbl:GetAlpha()
	
	for i=1,letterCount do
	
		local letter = strLbl.letters[i]
		
		if letter.isWritten == nil then
			letter.isWritten = false
			letter._char = letter.char
		end
	
		-- wait till the alpha is high enough so we can see the effect on short names
		if !letter.isWritten and strLbl.nextType < CurTime() then
			strLbl:SetChar(i,letter._char)
			letter.isWritten = true
			strLbl.nextType = CurTime() + speed
		end
		if !letter.isWritten then
			strLbl:SetChar(i,alphabet[Rand(1,string.len(alphabet))])
		end
		
		if i == letterCount and letter.isWritten then
			if rep then 
				for innerI=1,letterCount do
					strLbl.letters[innerI].isWritten = false
				end
			else
				strLbl.StopAnimTypeWriter = true
			end
		end

	end
		
end
--addons/zerosfruitslicer/lua/zfruitslicer/util/cl_settings.lua:
AddCSLuaFile()
if SERVER then return end
include("sh_zfs_config_fruits.lua" )
include("sh_zfs_config_smoothies.lua" )
include("sh_zfs_config_toppings.lua" )

hook.Add("AddToolMenuCategories", "zfs_CreateCategories", function()
    spawnmenu.AddToolCategory("Options", "zfs_options", "Fruitslicer")
end)

hook.Add("PopulateToolMenu", "zfs_PopulateMenus", function()
    spawnmenu.AddToolMenuOption("Options", "zfs_options", "zfs_Admin_Settings", "Admin Settings", "", "", function(CPanel)
        zclib.Settings.OptionPanel("Shop", "Saves all Fruitslicer shops to the map as a public utility.", Color(219, 86, 81), zclib.colors["ui02"], CPanel, {
            [1] = {
                name = "Save",
                class = "DButton",
                cmd = "zfs_shop_save"
            },
            [2] = {
                name = "Remove",
                class = "DButton",
                cmd = "zfs_shop_remove"
            },
        })
        zclib.Settings.OptionPanel("Commands", "Some debug commands.", Color(219, 86, 81), zclib.colors["ui02"], CPanel, {
            [1] = {
                name = "Spawn FruitBoxes",
                class = "DButton",
                cmd = "zfs_fruitbox_spawnall"
            },
            [2] = {
                class = "Custom",
                content = function(panel)

                    local main = vgui.Create("DPanel", panel)
        			main:SetSize(200 * zclib.wM, 180 * zclib.hM)
        			main:Dock(TOP)
        			main:DockMargin(0,10,0,0)
        			main.Paint = function(s, w, h)
        				draw.RoundedBox(4, 0, 0, w, 5 * zclib.hM, zclib.colors["black_a100"])
        				draw.RoundedBox(4, 0, h - 5 * zclib.hM, w, 5 * zclib.hM, zclib.colors["black_a100"])
        			end

                    local function AddComboList(list,default,title,OnSelect)
                        local SelectionParent = vgui.Create("DPanel", main)
            			SelectionParent:SetSize(200 * zclib.wM, 55 * zclib.hM)
            			SelectionParent:Dock(TOP)
            			SelectionParent:DockMargin(0, 10, 0, 0)
            			SelectionParent.Paint = function(s, w, h)
                            draw.SimpleText(title, zclib.GetFont("zclib_font_mediumsmall"), 0, 0, color_white, TEXT_ALIGN_LEFT,TEXT_ALIGN_TOP)
            			end

                        local Selection = zclib.vgui.ComboBox(SelectionParent,list[default].Name,function(index, value,pnl)
                            pcall(OnSelect,pnl:GetOptionData( index ))
                        end)
                        for k,v in ipairs(list) do Selection:AddChoice(v.Name,k) end
                        Selection:SetTall(30)
                        Selection:DockMargin(0,20,0,0)
                    end

                    local SmoothieID = 1
                    AddComboList(zfs.config.Smoothies,SmoothieID,"Smoothies",function(val) SmoothieID = val end)

                    local ToppingID = 1
                    AddComboList(zfs.config.Toppings,ToppingID,"Toppings",function(val) ToppingID = val end)

                    local BtnColor = Color(219, 86, 81)
                    local SpawnButton = vgui.Create("DButton", main)
        			SpawnButton:Dock(TOP)
        			SpawnButton:DockMargin(0,10,0,0)
        			SpawnButton:SetText( "Spawn Smoothie" )
        			SpawnButton:SetFont(zclib.GetFont("zclib_font_small"))
        			SpawnButton:SetTextColor(color_white)
        			SpawnButton.Paint = function(s, w, h)
        				draw.RoundedBox(4, 0, 0, w, h, BtnColor)
        				if s.Hovered then
        					draw.RoundedBox(4, 0, 0, w, h, zclib.colors["white_a15"])
        				end
        			end
        			SpawnButton.DoClick = function()

        				if zclib.Player.IsAdmin(LocalPlayer()) == false then return end

        				RunConsoleCommand( "zfs_smoothie_spawn",SmoothieID,ToppingID)
        			end
                end
            }
        })
    end)
end)

--addons/zeros_retrominer_v2.3.6/lua/zrms/cl/zrmine_fonts.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/autorun/zyb_load.lua:
return gluapack()()
--addons/partysystem/lua/autorun/client/cl_partymenu.lua:
return gluapack()()
--addons/partysystem/lua/autorun/client/cl_partymenu.lua:
--GUI base created by billy
--https://scriptfodder.com/users/view/76561198040894045/scripts

AddCSLuaFile()
parties = {}	
	CreateClientConVar("color_phalo_r", 0, true)
	CreateClientConVar("color_phalo_g", 255, true)
	CreateClientConVar("color_phalo_b", 0, true)
	CreateClientConVar("color_phalo_a", 255, true)
	if party.defaultlowend == true then 
		CreateClientConVar("party_lowend", 1, true)
	else 
		CreateClientConVar("party_lowend", 0, true)
	end
	CreateClientConVar("party_showhud", 0, true)
	
	
	local hcol = Color(	GetConVar( "color_phalo_r" ):GetInt(hr), GetConVar( "color_phalo_g" ):GetInt(hg), GetConVar( "color_phalo_b" ):GetInt(hb), GetConVar( "color_phalo_a" ):GetInt(ha)) or Color(0,255,0,255)	
	local hr, hg, hb, ha = tonumber(hcol.r) or 0, tonumber(hcol.g) or 0, tonumber(hcol.b) or 0, tonumber(hcol.a) or 255
	
	function HaloColorUpdate()
	local hr, hg, hb, ha = tostring(tonumber(hcol.r) or 0), tostring(tonumber(hcol.g) or 0), tostring(tonumber(hcol.b) or 0), tostring(tonumber(hcol.a) or 255)
		GetConVar( "color_phalo_r" ):SetInt(hr)  
		GetConVar( "color_phalo_g" ):SetInt(hg)
		GetConVar( "color_phalo_b" ):SetInt(hb)
		GetConVar( "color_phalo_a" ):SetInt(ha)
	end

local PartyFrame

		hook.Add( "Think", "Partykeylistener", function()
			if party.partymenubutton then
				if  input.IsKeyDown( party.partymenubutton ) and (PartyFrame == nil || !PartyFrame:IsVisible())  then
					PartyMenu()
				end
			end
		end )

			
			net.Receive("party", function(len, CLIENT)
				parties = net.ReadTable()
				--print("allparties")
				--PrintTable(parties)
			end)
			
			net.Receive("oneparty", function(len, CLIENT)
				local partystring = net.ReadString()
				parties[partystring] = net.ReadTable()
				if parties[partystring].name == "DeleteMe" then
					parties[partystring] = nil
				end
				--print("oneparty")
				--PrintTable(parties)
			end)
			
			net.Receive("onepartytoparty", function(len, CLIENT)
				local partystring = net.ReadString()
				parties[partystring] = net.ReadTable()
				--print("onepartytoparty")
				--PrintTable(parties)
			end)
				
			net.Receive( "partiesmenu", function( len, pl )
				PartyMenu()
			end)
			
			
			net.Receive( "joinrequest", function( len, pl )
				local requestedid = net.ReadString()  
				requestMenu(requestedid)
			end)

			net.Receive( "partyinvite", function( len, pl )
				local invitedby = net.ReadString()  
				partyinvite(invitedby)
			end)
		
		
function partyinvite(invitedby)
	local Frame = vgui.Create( "DFrame" )
	Frame:SetPos( -500, ScrH()/4 ) 
	Frame:SetSize( 200, 400 ) 
	Frame:SetTitle( party.language["Invited to join a party"] ) 
	Frame:SetVisible( true )
	Frame:SetDraggable( true ) 
	Frame:ShowCloseButton( false )
	--Frame:MakePopup() 
	Frame:SetDeleteOnClose(true)
	Frame:SetVerticalScrollbarEnabled(false)
	Frame:LerpPositions(20,false)
	Frame:SetPos( 0, ScrH()/4 ) 

	function Frame:Paint( w, h )
		draw.RoundedBox( 5, 0, 0, w, h, party.backgroundcolor )
		draw.RoundedBox(5,2,2,w-4,h-4,Color(0,0,0,100))
		draw.RoundedBox(5,4,4,w-8,h-8,Color(0,0,0,100))
		draw.RoundedBox(5,6,6,w-12,h-12,Color(0,0,0,100))
		draw.RoundedBox(5,8,8,w-16,h-16,Color(0,0,0,100))
		Frame:InvalidateLayout(true)
		Frame:SizeToChildren( true, true )
	end
	local DButtonclose = vgui.Create( "DButton" )
	DButtonclose:SetParent( Frame )
	DButtonclose:SetPos( Frame:GetSize(), 5) 
	DButtonclose:SetText( "X" )
	DButtonclose:SetSize( 20, 20 )
	DButtonclose:SetTextColor(Color( 255,255,255) )
	--DButtonclose:Dock(RIGHT)
	DButtonclose.DoClick = function()
		--LocalPlayer():ConCommand("answerinvite "..invitedby .. " false")
		net.Start( "AnswerInvite" )
		net.WriteString( invitedby)
		net.WriteBool( false)
		net.SendToServer()
	
		Frame:Close()
	end
	function DButtonclose:Paint(w,h)
		if !DButtonclose:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttoncolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
		if DButtonclose:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttonhovercolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
	end
	
	local panel2 = vgui.Create("DPanel",Frame)
		panel2:Dock(TOP)
		panel2:SetSize(Frame:GetSize(), 50 )
		panel2:SetPos()
		
		function panel2:Paint(w,h)
			panel2:InvalidateLayout(true)
		panel2:SizeToChildren( true, true )
		end
		
	local DLabel2 = vgui.Create( "DLabel", panel2 )
	DLabel2:Dock(TOP)
		if player.GetBySteamID64(invitedby) != false then
			DLabel2:SetText( player.GetBySteamID64(invitedby):Nick())
		else 
			DLabel2:SetText("A Team")
		end
	local DLabel3 = vgui.Create( "DLabel", panel2 )
	DLabel3:Dock(TOP)
	DLabel3:SetText( party.language["Has invited you to their party."])
	 
	local DLabel3 = vgui.Create( "DLabel", panel2 )
	DLabel3:Dock(TOP)
	DLabel3:SetText( party.language["Accept?"])
	
	local panel3 = vgui.Create("DPanel",panel2)
		panel3:Dock(TOP)
		panel3:SetSize(panel2:GetSize(), 20 )
		panel3:SetPos()
		
	function panel3:Paint(w,h)
		panel3:InvalidateLayout(true)
		panel3:SizeToChildren( true, true )
	end
	
	
	 local DButtonyes = vgui.Create( "DButton" )
	DButtonyes:SetParent( panel3 )
	DButtonyes:Dock(LEFT)
	DButtonyes:SetText( party.language["YES"] )
	DButtonyes:SetSize( panel3:GetSize()/2, 20 )
	DButtonyes:SetTextColor(Color( 255,255,255) )
	DButtonyes.DoClick = function()
		--LocalPlayer():ConCommand("answerinvite "..invitedby .. " true")
		net.Start( "AnswerInvite" )
		net.WriteString( invitedby)
		net.WriteBool(true)
		net.SendToServer()
		Frame:Close()
	end
	function DButtonyes:Paint(w,h)
			if !DButtonyes:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttoncolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
		if DButtonyes:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttonhovercolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
	end
	
	
	local DButtonno = vgui.Create( "DButton" )
	DButtonno:SetParent( panel3 )
	DButtonno:Dock(RIGHT)
	DButtonno:SetText( party.language["NO"] )
	DButtonno:SetSize( panel3:GetSize()/2, 20 )
	DButtonno:SetTextColor(Color( 255,255,255) )
	DButtonno.DoClick = function()
		Frame:Close()
		--LocalPlayer():ConCommand("answerinvite "..invitedby .. " false")
		net.Start( "AnswerInvite" )
		net.WriteString( invitedby)
		net.WriteBool( false)
		net.SendToServer()
	end
		function DButtonno:Paint(w,h)
			if !DButtonno:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttoncolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
		if DButtonno:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttonhovercolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
	end	
end
		
		
		
		
		
		
		

function requestMenu(requestedid)
	local Frame = vgui.Create( "DFrame" )
	Frame:SetPos( -500, ScrH()/4 ) 
	Frame:SetSize( 150, 400 ) 
	Frame:SetTitle(  party.language["Request To Join Your Party"] ) 
	Frame:SetVisible( true )
	Frame:SetDraggable( true ) 
	Frame:ShowCloseButton( false )
	--Frame:MakePopup() 
	Frame:SetDeleteOnClose(true)
	Frame:SetVerticalScrollbarEnabled(false)
	Frame:LerpPositions(20,false)
	Frame:SetPos( 0, ScrH()/4 ) 

	function Frame:Paint( w, h )
		draw.RoundedBox( 5, 0, 0, w, h, party.backgroundcolor )
		draw.RoundedBox(5,2,2,w-4,h-4,Color(0,0,0,100))
		draw.RoundedBox(5,4,4,w-8,h-8,Color(0,0,0,100))
		draw.RoundedBox(5,6,6,w-12,h-12,Color(0,0,0,100))
		draw.RoundedBox(5,8,8,w-16,h-16,Color(0,0,0,100))
		Frame:InvalidateLayout(true)
		Frame:SizeToChildren( true, true )
	end
	local DButtonclose = vgui.Create( "DButton" )
	DButtonclose:SetParent( Frame )
	DButtonclose:SetPos( Frame:GetSize(), 5) 
	DButtonclose:SetText( "X" )
	DButtonclose:SetSize( 20, 20 )
	DButtonclose:SetTextColor(Color( 255,255,255) )
	--DButtonclose:Dock(RIGHT)
	DButtonclose.DoClick = function()
	 Frame:Close()
	end
	function DButtonclose:Paint(w,h)
		if !DButtonclose:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttoncolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
		if DButtonclose:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttonhovercolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
	end
	
	local panel2 = vgui.Create("DPanel",Frame)
		panel2:Dock(TOP)
		panel2:SetSize(Frame:GetSize(), 50 )
		panel2:SetPos()
		
		function panel2:Paint(w,h)
			panel2:InvalidateLayout(true)
		panel2:SizeToChildren( true, true )
		end
		
	local DLabel2 = vgui.Create( "DLabel", panel2 )
	DLabel2:Dock(TOP)
	DLabel2:SetText( player.GetBySteamID64(requestedid):Nick())
			
	local DLabel3 = vgui.Create( "DLabel", panel2 )
	DLabel3:Dock(TOP)
	DLabel3:SetText( party.language["Would like to join your party"])
	 
	local DLabel3 = vgui.Create( "DLabel", panel2 )
	DLabel3:Dock(TOP)
	DLabel3:SetText( party.language["Accept?"])
	
	local panel3 = vgui.Create("DPanel",panel2)
		panel3:Dock(TOP)
		panel3:SetSize(panel2:GetSize(), 20 )
		panel3:SetPos()
		
	function panel3:Paint(w,h)
		panel3:InvalidateLayout(true)
		panel3:SizeToChildren( true, true )
	end
	
	
	 local DButtonyes = vgui.Create( "DButton" )
	DButtonyes:SetParent( panel3 )
	DButtonyes:Dock(LEFT)
	DButtonyes:SetText( party.language["YES"] )
	DButtonyes:SetSize( panel3:GetSize()/2, 20 )
	DButtonyes:SetTextColor(Color( 255,255,255) )
	DButtonyes.DoClick = function()
	--LocalPlayer():ConCommand("answerjoinrequest "..requestedid .. " true")
		net.Start( "RequestedJoin" )
		net.WriteString( requestedid)
		net.WriteBool( true)
		net.SendToServer()
	 Frame:Close()
	end
	function DButtonyes:Paint(w,h)
			if !DButtonyes:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttoncolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
		if DButtonyes:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttonhovercolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
	end
	 
	local DButtonno = vgui.Create( "DButton" )
	DButtonno:SetParent( panel3 )
	DButtonno:Dock(RIGHT)
	DButtonno:SetText( party.language["NO"] )
	DButtonno:SetSize( panel3:GetSize()/2, 20 )
	DButtonno:SetTextColor(Color( 255,255,255) )
	DButtonno.DoClick = function()
	 Frame:Close()
	--LocalPlayer():ConCommand("answerjoinrequest "..requestedid .. " false")
		net.Start( "RequestedJoin" )
		net.WriteString( requestedid)
		net.WriteBool( false)
		net.SendToServer()
	 
	end
		function DButtonno:Paint(w,h)
			if !DButtonno:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttoncolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
		if DButtonno:IsHovered() then
			draw.RoundedBox(0,0,0,w,h, party.buttonhovercolor)
			draw.RoundedBox(0,1,1,w-2,h-2,Color(0,0,0,100))
			draw.RoundedBox(0,2,2,w-4,h-4,Color(0,0,0,100))
			draw.RoundedBox(0,3,3,w-6,h-6,Color(0,0,0,100))
			draw.RoundedBox(0,4,4,w-8,h-8,Color(0,0,0,100))
		end
	end	 
end


	 party.framesizex = 500
	 party.framesizey = 300
	 party.rightsize = 250
	 
	 
function PartyMenu()
	local Partytab
	local Partymembs
	PartyFrame = vgui.Create("PartyFrame")
	PartyFrame:SetPos( -500 , ScrH()/4 ) 
	PartyFrame:SetSize( party.framesizex, party.framesizey ) 
	PartyFrame:Configured()
	PartyFrame:SetTitle( party.language["Party Menu"] ) 
	PartyFrame:SetVisible( true )
	PartyFrame:SetDraggable( true )
	PartyFrame:ShowCloseButton(true)
	PartyFrame:MakePopup() 
	PartyFrame:SetDeleteOnClose(true)
	PartyFrame:SetVerticalScrollbarEnabled(false)
	PartyFrame:LerpPositions(20,false)
	PartyFrame:Center()
	
	Partytab = vgui.Create("DPanel", PartyFrame)
	Partytab:SetSize( 250 )
	Partytab:Dock(RIGHT)
	local DLabel = vgui.Create( "PartyLabel", Partytab )
		DLabel:SetColor(Color( 0, 40 , 0 ))
		DLabel:SetText( party.language["Welcome to the party menu!"] )
		DLabel:SizeToContents()
		DLabel:Center()
		DLabel:AlignTop()
	local DLabel = vgui.Create( "PartyLabel", Partytab )
		DLabel:SetColor(Color( 0, 40 , 0 ))
		DLabel:SetText( party.language["An easy way for you to"] )
		DLabel:SizeToContents()
		DLabel:Center()
		DLabel:AlignTop(30)
	local DLabel = vgui.Create( "PartyLabel", Partytab )
		DLabel:SetColor(Color( 0, 40 , 0 ))
		DLabel:SetText( party.language["team up with your friends!"] )
		DLabel:SizeToContents()
		DLabel:Center()
		DLabel:AlignTop(45)	
		


	
	
local Partylist = vgui.Create("PartyCategories", PartyFrame)
	local x, y = PartyFrame:GetSize()
	Partylist:SetSize( 250 )
	Partylist:SetPos( 0, 24 )
	Partylist:Dock(LEFT)
	Partylist:DockMargin(-1,0,0,0)
	Partylist:NewItem(party.language["Start Party"] , Color(75,200,75),function()
		PartyFrame:SetSize( party.framesizex, party.framesizey ) 
		PartyFrame:ShowCloseButton(false)
		PartyFrame:Configured()
		PartyFrame:ShowCloseButton(true)
		if Partytab then
			Partytab:Remove()
		end
		Partytab = vgui.Create("DPanel", PartyFrame)
		Partytab:SetSize( party.rightsize )
		Partytab:Dock(LEFT)
		local DLabel = vgui.Create( "PartyLabel", Partytab )
			DLabel:SetColor(Color( 0, 40 , 0 ))
			DLabel:SetText( party.language["WARNING!"] )
			DLabel:SizeToContents()
			DLabel:Center()
			DLabel:AlignTop(30)
		local DLabel = vgui.Create( "PartyLabel", Partytab )
			DLabel:SetColor(Color( 0, 40 , 0 ))
			DLabel:SetText( party.language["By starting a new party"] )
			DLabel:SizeToContents()
			DLabel:Center()
			DLabel:AlignTop(45)	
		local DLabel = vgui.Create( "PartyLabel", Partytab )
			DLabel:SetColor(Color( 0, 40 , 0 ))
			DLabel:SetText( party.language["you will be removed from"] )
			DLabel:SizeToContents()
			DLabel:Center()
			DLabel:AlignTop(60)			
		local DLabel = vgui.Create( "PartyLabel", Partytab )
			DLabel:SetColor(Color( 0, 40 , 0 ))
			DLabel:SetText( party.language["your current party."] )
			DLabel:SizeToContents()
			DLabel:Center()
			DLabel:AlignTop(75)	
			
		local Dtextname
		
		local DButtonStart = vgui.Create( "PartyButton")
		DButtonStart:SetParent( Partytab )
		DButtonStart:SetText( party.language["Start A New Party"] ) 
		DButtonStart:SetSize( Partytab:GetSize()+2, 50 )
		DButtonStart:SetPos( 0, 0 ) 
		DButtonStart:SetTextColor(Color( 255,255,255) )
		DButtonStart:Dock(BOTTOM)
		DButtonStart:DockMargin(-1,0,0,-1)
		DButtonStart.DoClick = function()
			--LocalPlayer():ConCommand("StartParty \"" .. string.Left( Dtextname:GetValue(), 20))
				net.Start( "StartParty" )
				net.WriteString(string.Left( Dtextname:GetValue(), 20))
				net.SendToServer()
			PartyFrame:Close()
		end
		
		Dtextname = vgui.Create( "PartyTextBox")
		Dtextname:SetParent( Partytab )
		Dtextname:SetSize( Partytab:GetSize()+2, 25 )
		Dtextname:SetPos( 0, 0 ) 
		Dtextname:SetTextColor(Color( 0,0,0) )
		Dtextname:Dock(BOTTOM)
		Dtextname:DockMargin(-1,0,0,-1)
	
			local DLabel = vgui.Create( "PartyLabel", Partytab )
			DLabel:SetColor(Color( 0, 40 , 0 ))
			DLabel:SetText( party.language["Party Name"] )
			DLabel:SizeToContents()
			DLabel:Dock(BOTTOM)
			DLabel:Center()
			
	end, true)
	
	Partylist:NewItem(party.language["Join Party"] , Color(75,75,200),function()
		if Partytab then
			Partytab:Remove()
		end
		PartyFrame:SetSize( party.framesizex, party.framesizey ) 
		PartyFrame:ShowCloseButton(false)
		PartyFrame:Configured()
		PartyFrame:ShowCloseButton(true)
		Partytab = vgui.Create("PartyCategories", PartyFrame)
		Partytab:SetSize( party.rightsize )
		Partytab:Dock(LEFT)

		for v,k in pairs (parties) do
			if !table.HasValue(parties[v].members, LocalPlayer():SteamID64()) then
				if !parties[v].Autogrouped then 
					Partytab:NewItem(parties[v].name , Color(75,200,75), function()
						PartyFrame:SetSize(party.framesizex + 150 , party.framesizey )
						PartyFrame:ShowCloseButton(false)
						PartyFrame:Configured()
						PartyFrame:ShowCloseButton(true)
						if Partymembs then
							Partymembs:Remove()
						end
						Partymembs = vgui.Create("DPanel", PartyFrame) 
						Partymembs:SetSize(150, party.framesizey - 20)
						Partymembs:Dock(RIGHT)
						
						local DButtonjoin = vgui.Create( "PartyButton", Partymembs )
						DButtonjoin:SetPos( party.framesizex - 20, 0 ) 
						DButtonjoin:SetText( party.language["Members"]  )
						DButtonjoin:SetSize( 20, 20 )
						DButtonjoin:SetTextColor(Color( 255,255,255) )
						DButtonjoin:Dock(TOP)
						DButtonjoin:SetTextColor(Color(0,0,0))
						DButtonjoin.DoClick = function()
						end
					
						DButtonjoin.Paint = function()
							surface.DrawRect(0,0,DButtonjoin:GetWide(),DButtonjoin:GetTall())
							surface.SetDrawColor(Color(26,26,26))
							surface.DrawOutlinedRect(0,0,DButtonjoin:GetWide(),DButtonjoin:GetTall())
						end
					
						
						local Partymembslist = vgui.Create("PartyCategories", Partymembs) 
							Partymembslist:SetSize(150, party.framesizey - 45)
							Partymembslist:Dock(TOP)
							if parties[v] then
								if parties[v].members then
									for v,k in pairs(parties[v].members) do
										if player.GetBySteamID64(k) != false then
											Partymembslist:NewItem(player.GetBySteamID64(k):Nick(), Color(255,255,255,0), function()
											end, false)
										end
									end	
								end
							end
						local DButtonjoin = vgui.Create( "PartyButton", Partymembs )
						DButtonjoin:SetPos( party.framesizex - 20, 0 ) 
						DButtonjoin:SetText( party.language["Request Join"] )
						if parties[v] then
							if table.HasValue(parties[v].members, LocalPlayer():SteamID64()) then
								DButtonjoin:SetDisabled(true)
							end
						end
						if party.AutoGroupedJobs[v] then
							DButtonjoin:SetDisabled(true)
						end
						DButtonjoin:SetSize( 20, 20 )
						DButtonjoin:SetTextColor(Color( 255,255,255) )
						DButtonjoin:Dock(BOTTOM)
						DButtonjoin:DockMargin(-1,0,-1,-1)
						DButtonjoin.DoClick = function()
							--LocalPlayer():ConCommand("requestjoin \""..v)
							net.Start( "RequestJoin" )
							net.WriteString(v)
							net.SendToServer()
							PartyFrame:Close()
						end
					end, true)
				end
			end
		end
	end, true)
	
	Partylist:NewItem(party.language["Leave Party"] , Color(200,75,75),function()
		PartyFrame:SetSize( party.framesizex, party.framesizey ) 
		PartyFrame:ShowCloseButton(false)
		PartyFrame:Configured()
		PartyFrame:ShowCloseButton(true)
		if Partytab then
			Partytab:Remove()
		end
		Partytab = vgui.Create("DPanel", PartyFrame)
		Partytab:SetSize( party.rightsize )
		Partytab:Dock(LEFT)
		
		local DLabel = vgui.Create( "PartyLabel", Partytab )
			DLabel:SetColor(Color( 0, 40 , 0 ))
			DLabel:SetText( party.language["WARNING!"] )
			DLabel:SizeToContents()
			DLabel:Center()
			DLabel:AlignTop(30)
		local DLabel = vgui.Create( "PartyLabel", Partytab )
			DLabel:SetColor(Color( 0, 40 , 0 ))
			DLabel:SetText( party.language["By leaving your party"] )
			DLabel:SizeToContents()
			DLabel:Center()
			DLabel:AlignTop(45)	
		local DLabel = vgui.Create( "PartyLabel", Partytab )
			DLabel:SetColor(Color( 0, 40 , 0 ))
			DLabel:SetText( party.language["you will no longer be protected"] )
			DLabel:SizeToContents()
			DLabel:Center()
			DLabel:AlignTop(60)			
		local DLabel = vgui.Create( "PartyLabel", Partytab )
			DLabel:SetColor(Color( 0, 40 , 0 ))
			DLabel:SetText( party.language["from damage from"] )
			DLabel:SizeToContents()
			DLabel:Center()
			DLabel:AlignTop(75)	
		local DLabel = vgui.Create( "PartyLabel", Partytab )
			DLabel:SetColor(Color( 0, 40 , 0 ))
			DLabel:SetText( party.language["your former party members."] )
			DLabel:SizeToContents()
			DLabel:Center()
			DLabel:AlignTop(90)	
			
		local DButtonStart = vgui.Create( "PartyButton")
		DButtonStart:SetParent( Partytab )
		DButtonStart:SetText( party.language["Leave Current Party" ]) 
		DButtonStart:SetSize( Partytab:GetSize()+2, 50 )
		DButtonStart:SetPos( 0, 0 ) 
		DButtonStart:SetTextColor(Color( 255,255,255) )
		DButtonStart:Dock(BOTTOM)
		DButtonStart:DockMargin(-1,0,0,-1)
		DButtonStart.DoClick = function()
			--LocalPlayer():ConCommand("LeaveParty")
			net.Start( "LeaveParty" )
			--net.WriteString(v)
			net.SendToServer()
			PartyFrame:Close()
		end
	end, true)
	for v, k in pairs(parties) do
		if table.HasValue(parties[v].members, LocalPlayer():SteamID64()) then
			if v == LocalPlayer():SteamID64() then
				Partylist:NewItem(party.language["Manage Party"] , Color(200,100,0),function()
					if Partytab then
						Partytab:Remove()
					end
					PartyFrame:SetSize( party.framesizex, party.framesizey ) 
					PartyFrame:ShowCloseButton(false)
					PartyFrame:Configured()
					PartyFrame:ShowCloseButton(true)
					Partytab = vgui.Create("PartyCategories", PartyFrame)
					Partytab:SetSize( party.rightsize )
					Partytab:Dock(LEFT)
					
					Partytab:NewItem(party.language["Kick From Party"], Color(75,200,75), function()
						PartyFrame:SetSize(party.framesizex + 150 , party.framesizey)
						PartyFrame:ShowCloseButton(false)
						PartyFrame:Configured()
						PartyFrame:ShowCloseButton(true)
						if Partymembs then
							Partymembs:Remove()
						end
						Partymembs = vgui.Create("DPanel", PartyFrame) 
						Partymembs:SetSize(150, party.framesizey - 20 )
						Partymembs:Dock(RIGHT)
						
						local DButton = vgui.Create( "PartyButton", Partymembs )
						DButton:SetPos( party.framesizex - 20, 0 ) 
						DButton:SetText( party.language["Members"]  )
						DButton:SetSize( 20, 20 )
						DButton:SetTextColor(Color( 255,255,255) )
						DButton:Dock(TOP)
						DButton:SetTextColor(Color(0,0,0))
						DButton.DoClick = function()
						end
					
						DButton.Paint = function()
							surface.DrawRect(0,0,DButton:GetWide(),DButton:GetTall())
							surface.SetDrawColor(Color(26,26,26))
							surface.DrawOutlinedRect(0,0,DButton:GetWide(),DButton:GetTall())
						end
						local Partymembslist = vgui.Create("PartyCategories", Partymembs) 
						
						Partymembslist:SetSize(150, party.framesizey - 45)
						Partymembslist:Dock(TOP)
						
						local DButtonkick
						if LocalPlayer():GetParty() != nil then
							for v,k in pairs(parties[LocalPlayer():GetParty()].members) do
								if k != LocalPlayer():SteamID64() then
									if player.GetBySteamID64(k) !=  false then
										Partymembslist:NewItem(player.GetBySteamID64(k):Nick(), Color(255,100,100,255), function()
											if DButtonkick then
												DButtonkick:Remove()
											end
											DButtonkick = vgui.Create( "PartyButton", Partymembs )
												DButtonkick:SetPos( party.framesizex - 20, 0 ) 
												DButtonkick:SetText( party.language["Kick From Party"]  )
												DButtonkick:SetSize( 20, 20 )
												DButtonkick:SetTextColor(Color( 255,255,255) )
												DButtonkick:Dock(BOTTOM)
												DButtonkick:DockMargin(-1,0,-1,-1)
												DButtonkick.DoClick = function()
													Partymembs:Remove()
													--LocalPlayer():ConCommand("kickfromparty \""..k)
														net.Start( "KickFromParty" )
														net.WriteString(k)
														net.SendToServer()
													PartyFrame:SetSize( party.framesizex, party.framesizey )
													PartyFrame:ShowCloseButton(false)
													PartyFrame:Configured()
													PartyFrame:ShowCloseButton(true)
												end
										end, true)
									else
										Partymembslist:NewItem(party.language["offline"], Color(255,255,255,255), function()
											if DButtonkick then
												DButtonkick:Remove()
											end
											DButtonkick = vgui.Create( "PartyButton", Partymembs )
												DButtonkick:SetPos( party.framesizex - 20, 0 ) 
												DButtonkick:SetText( party.language["Kick From Party"]  )
												DButtonkick:SetSize( 20, 20 )
												DButtonkick:SetTextColor(Color( 255,255,255) )
												DButtonkick:Dock(BOTTOM)
												DButtonkick:DockMargin(-1,0,-1,-1)
												DButtonkick.DoClick = function()
													Partymembs:Remove()
													--LocalPlayer():ConCommand("kickfromparty \""..k)
														net.Start( "KickFromParty" )
														net.WriteString(k)
														net.SendToServer()
													PartyFrame:SetSize( party.framesizex, party.framesizey )
													PartyFrame:ShowCloseButton(false)
													PartyFrame:Configured()
													PartyFrame:ShowCloseButton(true)
												end
										end, true)									
									end
								end
							end
						end
					end,true)
					
					
					Partytab:NewItem(party.language["Invite To Party"], Color(75,200,75), function()
						PartyFrame:SetSize(party.framesizex + 150 , party.framesizey)
						PartyFrame:ShowCloseButton(false)
						PartyFrame:Configured()
						PartyFrame:ShowCloseButton(true)
						if Partymembs then
							Partymembs:Remove()
						end
						Partymembs = vgui.Create("DPanel", PartyFrame) 
						Partymembs:SetSize(150, party.framesizey - 20)
						Partymembs:Dock(RIGHT)
						
						local DButton = vgui.Create( "PartyButton", Partymembs )
						DButton:SetPos( party.framesizex - 20, 0 ) 
						DButton:SetText( party.language["Players"]  )
						DButton:SetSize( 20, 20 )
						DButton:SetTextColor(Color( 255,255,255) )
						DButton:Dock(TOP)
						DButton:SetTextColor(Color(0,0,0))
						DButton.DoClick = function()
						end
					
						DButton.Paint = function()
							surface.DrawRect(0,0,DButton:GetWide(),DButton:GetTall())
							surface.SetDrawColor(Color(26,26,26))
							surface.DrawOutlinedRect(0,0,DButton:GetWide(),DButton:GetTall())
						end
						local Partymembslist = vgui.Create("PartyCategories", Partymembs) 
						
						Partymembslist:SetSize(150, party.framesizey - 45)
						Partymembslist:Dock(TOP)
						
						local DButtoninvite
						for v,k in ipairs(player.GetAll()) do
							if k != LocalPlayer() and !table.HasValue(parties[LocalPlayer():SteamID64()].members, k:SteamID64())then
								Partymembslist:NewItem(k:Nick(), Color(75,200,75,255), function()
									if DButtoninvite then
										DButtoninvite:Remove()
									end
									DButtoninvite = vgui.Create( "PartyButton", Partymembs )
										DButtoninvite:SetPos( party.framesizex - 20, 0 ) 
										DButtoninvite:SetText( party.language["Invite To Party"]  )
										DButtoninvite:SetSize( 20, 20 )
										DButtoninvite:SetTextColor(Color( 255,255,255) )
										DButtoninvite:Dock(BOTTOM)
										DButtoninvite:DockMargin(-1,0,-1,-1)
										DButtoninvite.DoClick = function()
											--LocalPlayer():ConCommand("partyinvite \""..k:SteamID64())
											net.Start( "PartyInvite" )
											net.WriteString(k:SteamID64())
											net.SendToServer()
										end
								end, true)								
							end
						end
					end,true)
				end, true)
			end
		end
	end
	Partylist:NewItem(party.language["Settings"] , Color(200,75,200),function()
		PartyFrame:SetSize( party.framesizex, party.framesizey ) 
		PartyFrame:ShowCloseButton(false)
		PartyFrame:Configured()
		PartyFrame:ShowCloseButton(true)
		if Partytab then
			Partytab:Remove()
		end
		Partytab = vgui.Create("DPanel", PartyFrame)
		Partytab:SetSize( party.rightsize )
		Partytab:Dock(LEFT)
		
		
		local DLabel = vgui.Create( "PartyLabel", Partytab )
		DLabel:SetColor(Color( 0, 40 , 0 ))
		DLabel:SetText( party.language["Color of party halo"] )
		DLabel:SizeToContents()
		DLabel:Center()
		DLabel:AlignTop(5)
		
		local Partycol = vgui.Create("DPanel", Partytab)
		Partycol:SetPos( 5, 180 )
		Partycol:SetSize( 190, 20 )
		Partycol:SetPaintBackgroundEnabled( true )
		Partycol:SetBackgroundColor( hcol )
		
		local color_picker = vgui.Create( "DRGBPicker", Partytab )
		color_picker:SetPos( 5, 20 )
		color_picker:SetSize( 30, 155 )
		
	local color_cube = vgui.Create( "DColorCube", Partytab )
		color_cube:SetPos( 40, 20 )
		color_cube:SetSize( 155, 155 )
		color_cube:SetColor( hcol )
		
	function color_picker:OnChange( col )

	local h = ColorToHSV( col )
	local _, s, v = ColorToHSV( color_cube:GetRGB() )

	col = HSVToColor( h, s, v )
	color_cube:SetColor( col )
	HaloColorUpdate()
	Partycol:SetBackgroundColor( col )
	end

	function color_cube:OnUserChanged( col )
	hcol = col
	HaloColorUpdate()
	Partycol:SetBackgroundColor( col )
	end
		
	local DermaCheckbox = vgui.Create( "DCheckBox", Partytab )
	DermaCheckbox:SetPos( 5, 205 )
	DermaCheckbox:SetValue( GetConVar( "party_lowend" ):GetInt() )	
	function DermaCheckbox:OnChange(value)
		if value then
		GetConVar( "party_lowend" ):SetInt(1)
		else 
		GetConVar( "party_lowend" ):SetInt(0)
		end
	end
		local DLabel2 = vgui.Create( "PartyLabel", Partytab )
		DLabel2:SetColor(Color( 0, 40 , 0 ))
		DLabel2:SetText( party.language["Lowend Halo"] )
		DLabel2:SizeToContents()
		DLabel2:AlignTop(205)
		DLabel2:AlignLeft(25)
		
	local DermaCheckbox2 = vgui.Create( "DCheckBox", Partytab )
		DermaCheckbox2:SetPos( 5, 225 )
		DermaCheckbox2:SetValue( GetConVar( "party_showhud" ):GetInt() )	
		function DermaCheckbox2:OnChange(value)
			if value then
				GetConVar( "party_showhud" ):SetInt(1)
			else 
				GetConVar( "party_showhud" ):SetInt(0)
			end
		end
		local DLabel3 = vgui.Create( "PartyLabel", Partytab )
		DLabel3:SetColor(Color( 0, 40 , 0 ))
		DLabel3:SetText( party.language["Disable Hud?"] )
		DLabel3:SizeToContents()
		DLabel3:AlignTop(225)
		DLabel3:AlignLeft(25)
		
		
		
		
	end, true)
	
	if LocalPlayer():IsAdmin() then
		Partylist:NewItem(party.language["Admin"] , Color(200,0,0),function()
			PartyFrame:SetSize( party.framesizex, party.framesizey ) 
			PartyFrame:ShowCloseButton(false)
			PartyFrame:Configured()
			PartyFrame:ShowCloseButton(true)
			if Partytab then
				Partytab:Remove()
			end
			Partytab = vgui.Create("PartyCategories", PartyFrame)
			Partytab:SetSize( party.rightsize )
			Partytab:Dock(LEFT)
			
			
			Partytab:NewItem(party.language["Kick From Party"], Color(255,0,0), function()
				PartyFrame:SetSize(party.framesizex + 150 , party.framesizey)
				PartyFrame:ShowCloseButton(false)
				PartyFrame:Configured()
				PartyFrame:ShowCloseButton(true)
				if Partymembs then
					Partymembs:Remove()
				end
				Partymembs = vgui.Create("DPanel", PartyFrame) 
				Partymembs:SetSize(150, party.framesizey - 40)
				Partymembs:Dock(RIGHT)
				
				local DButton = vgui.Create( "PartyButton", Partymembs )
				DButton:SetPos( party.framesizex - 20, 0 ) 
				DButton:SetText( party.language["Members"]  )
				DButton:SetSize( 20, 20 )
				DButton:SetTextColor(Color( 255,255,255) )
				DButton:Dock(TOP)
				DButton:SetTextColor(Color(0,0,0))
				DButton.DoClick = function()
				end
			
				DButton.Paint = function()
					surface.DrawRect(0,0,DButton:GetWide(),DButton:GetTall())
					surface.SetDrawColor(Color(26,26,26))
					surface.DrawOutlinedRect(0,0,DButton:GetWide(),DButton:GetTall())
				end
				local Partymembslist = vgui.Create("PartyCategories", Partymembs) 
				
				Partymembslist:SetSize(150, party.framesizey - 45)
				Partymembslist:Dock(TOP)
				
				local DButtonkick
				for v,k in ipairs(player.GetAll()) do
					for t,z in pairs(parties) do
						if table.HasValue(parties[t].members, k:SteamID64()) then
							Partymembslist:NewItem(k:Nick(), Color(255,0,0,255), function()
								if DButtonkick then
									DButtonkick:Remove()
								end
								DButtonkick = vgui.Create( "PartyButton", Partymembs )
								DButtonkick:SetPos( party.framesizex - 20, 0 ) 
								DButtonkick:SetText( party.language["Kick From Party"]  )
								DButtonkick:SetSize( 20, 20 )
								DButtonkick:SetTextColor(Color( 255,255,255) )
								DButtonkick:Dock(BOTTOM)
								DButtonkick:DockMargin(-1,0,-1,-1)
								DButtonkick.DoClick = function()
									Partymembs:Remove()
									--LocalPlayer():ConCommand("kickfromparty \""..k:SteamID64())
									net.Start( "KickFromParty" )
									net.WriteString(k:SteamID64())
									net.SendToServer()
									PartyFrame:SetSize( party.framesizex, party.framesizey )
									PartyFrame:ShowCloseButton(false)
									PartyFrame:Configured()
									PartyFrame:ShowCloseButton(true)
								end
							end, true)
						end
					end
				end
			end,true)
			
			Partytab:NewItem(party.language["Disband Party"], Color(255,0,0), function()
				PartyFrame:SetSize(party.framesizex + 150 , party.framesizey)
				PartyFrame:ShowCloseButton(false)
				PartyFrame:Configured()
				PartyFrame:ShowCloseButton(true)
				if Partymembs then
					Partymembs:Remove()
				end
				Partymembs = vgui.Create("DPanel", PartyFrame) 
				Partymembs:SetSize(150, party.framesizey - 20)
				Partymembs:Dock(RIGHT)
				
				local DButton = vgui.Create( "PartyButton", Partymembs )
				DButton:SetPos( party.framesizex - 20, 0 ) 
				DButton:SetText( party.language["Parties"]  )
				DButton:SetSize( 20, 20 )
				DButton:SetTextColor(Color( 255,255,255) )
				DButton:Dock(TOP)
				DButton:SetTextColor(Color(0,0,0))
				DButton.DoClick = function()
				end
			
				DButton.Paint = function()
					surface.DrawRect(0,0,DButton:GetWide(),DButton:GetTall())
					surface.SetDrawColor(Color(26,26,26))
					surface.DrawOutlinedRect(0,0,DButton:GetWide(),DButton:GetTall())
				end
				local Partymembslist = vgui.Create("PartyCategories", Partymembs) 
				
				Partymembslist:SetSize(150, party.framesizey - 45)
				Partymembslist:Dock(TOP)
				
				local DButtondsban
				for v,k in pairs(parties) do
					Partymembslist:NewItem(parties[v].name, Color(255,0,0,255), function()
						if DButtondsban then
							DButtondsban:Remove()
						end
						DButtondsban = vgui.Create( "PartyButton", Partymembs )
							DButtondsban:SetPos( party.framesizex - 20, 0 ) 
							DButtondsban:SetText( party.language["Disband Party"] )
							DButtondsban:SetSize( 20, 20 )
							DButtondsban:SetTextColor(Color( 255,255,255) )
							DButtondsban:Dock(BOTTOM)
							DButtondsban:DockMargin(-1,0,-1,-1)
							DButtondsban.DoClick = function()
								Partymembs:Remove()
								--LocalPlayer():ConCommand("disbandparty \""..v)
									net.Start( "DisbandParty" )
									net.WriteString(v)
									net.SendToServer()
								PartyFrame:SetSize( party.framesizex, party.framesizey )
								PartyFrame:ShowCloseButton(false)
								PartyFrame:Configured()
								PartyFrame:ShowCloseButton(true)
							end
					end, true)
				end
			end,true)
		end, true)
	end
end
--addons/vape_swep/lua/autorun/client/cl_vapeswep.lua:
if not VapeParticleEmitter then VapeParticleEmitter = ParticleEmitter(Vector(0,0,0)) end

sound.Add({
	name = "vape_inhale",
	channel = CHAN_WEAPON,
	volume = 0.24,
	level = 60,
	pitch = { 95 },
	sound = "vapeinhale.wav"
})

net.Receive("Vape",function()
	local ply = net.ReadEntity()
	local amt = net.ReadInt(8)
	local fx = net.ReadInt(8)
	if !IsValid(ply) then return end

	if amt>=50 then
		ply:EmitSound("vapecough1.wav",90)

		for i=1,200 do
			local d=i+10
			if i>140 then d=d+150 end
			timer.Simple((d-1)*0.003,function() vape_do_pulse(ply, 1, 100, fx) end)
		end

		return
	elseif amt>=35 then
		ply:EmitSound("vapebreath2.wav",75,100,0.7)
	elseif amt>=10 then
		ply:EmitSound("vapebreath1.wav",70,130-math.min(100,amt*2),0.4+(amt*0.005))
	end

	for i=1,amt*2 do
		timer.Simple((i-1)*0.02,function() vape_do_pulse(ply,math.floor(((amt*2)-i)/10), fx==2 and 100 or 0, fx) end)
	end
end)

net.Receive("VapeArm",function()
	local ply = net.ReadEntity()
	local z = net.ReadBool()
	if !IsValid(ply) then return end
	if ply.vapeArm != z then
		if z then
			timer.Simple(0.3, function() 
				if !IsValid(ply) then return end 
				if ply.vapeArm then ply:EmitSound("vape_inhale") end
			end)
		else
			ply:StopSound("vape_inhale")
		end
		ply.vapeArm = z
		ply.vapeArmTime = os.clock()
		local m = 0
		if z then m = 1 end

		for i=0,19 do
			timer.Simple(i/60,function() 
				vape_interpolate_arm(ply, math.abs(m-((19-i)/20)),z and 0 or 0.2) 
			end)
		end
	end
end)

net.Receive("VapeTalking",function()
	local ply = net.ReadEntity()
	if IsValid(ply) then ply.vapeTalkingEndtime = net.ReadFloat() end
end)

function vape_interpolate_arm(ply, mult, mouth_delay)
	if !IsValid(ply) then return end

	ply.vapeArmUpAmt = mult
	
	if mouth_delay>0 then 
		timer.Simple(mouth_delay,function() if IsValid(ply) then ply.vapeMouthOpenAmt = mult end end)
	else 
		ply.vapeMouthOpenAmt = mult
	end

	local b1 = ply:LookupBone("ValveBiped.Bip01_R_Upperarm")
	local b2 = ply:LookupBone("ValveBiped.Bip01_R_Forearm")
	if (not b1) or (not b2) then return end
	ply:ManipulateBoneAngles(b1,Angle(20*mult,-62*mult,10*mult))
	ply:ManipulateBoneAngles(b2,Angle(-5*mult,-10*mult,0))
	if mult==1 then ply.vapeArmFullyUp=true else ply.vapeArmFullyUp=false end
end

function vape_do_pulse(ply, amt, spreadadd, fx)
	if !IsValid(ply) then return end

	if ply:WaterLevel()==3 then return end

	if not spreadadd then spreadadd=0 end

	local attachid = ply:LookupAttachment("eyes")
	VapeParticleEmitter:SetPos(LocalPlayer():GetPos())
	
	local angpos = ply:GetAttachment(attachid) or {Ang=Angle(0,0,0), Pos=Vector(0,0,0)}
	local fwd
	local pos
	
	if (ply != LocalPlayer()) then
		fwd = (angpos.Ang:Forward()-angpos.Ang:Up()):GetNormalized()
		pos = angpos.Pos + (fwd*3.5)
	else
		fwd = ply:GetAimVector():GetNormalized()
		pos = ply:GetShootPos() + fwd*1.5 + gui.ScreenToVector( ScrW()/2, ScrH() )*5
	end

	fwd = ply:GetAimVector():GetNormalized()

	for i = 1,amt do
		if !IsValid(ply) then return end
		local particle
		if fx == 6 then
			particle = VapeParticleEmitter:Add(string.format("effects/fire_cloud1"), pos)
			if ply==LocalPlayer() then 
				if particle and MyDragonVapeParticles then 
				table.insert(MyDragonVapeParticles, particle) 
				end
			end
		else
			particle = VapeParticleEmitter:Add(string.format("particle/smokesprites_00%02d",math.random(7,16)), pos)
		end
		if particle then
			local dir = VectorRand():GetNormalized() * ((amt+5)/10)
			vape_do_particle(particle, (ply:GetVelocity()*0.25)+(((fwd*9)+dir):GetNormalized() * math.Rand(50,80) * (amt + 1) * 0.2), fx)
		end
	end
end

function vape_do_particle(particle, vel, fx)
	particle:SetColor(255,255,255,255)
	if fx == 3 then particle:SetColor(220,255,230,255) end
	if fx == 4 then particle:SetColor(220,230,255,255) end
	if fx == 7 then particle:SetColor(vape_red_white_blue_chooser(math.random(0,2)/3)) end
	if fx >= 20 then 
		local c = JuicyVapeJuices[fx-19].color
		if c == nil then c = HSVToColor(math.random(0,359),1,1) end
		particle:SetColor(c.r, c.g, c.b, 255)
	end

	local mega = 1
	if fx == 2 then mega = 4 end
	
	particle:SetVelocity( vel * mega * (fx==6 and 2 or 1))
	particle:SetGravity( Vector(0,0,fx == 4 and 15 or 1.5) )
	particle:SetLifeTime(0)
	particle:SetDieTime(math.Rand(80,100)*0.11*mega)
	if fx==6 then particle:SetDieTime(math.Rand(80,100)*0.03) end
	particle:SetStartSize(2*mega)
	if fx==6 then particle:SetStartSize(3) end
	particle:SetEndSize(40*mega*mega)
	if fx==6 then particle:SetEndSize(20) end
	particle:SetStartAlpha(fx == 4 and 20 or 150)
	particle:SetEndAlpha(0)
	particle:SetCollide(true)
	particle:SetBounce(0.25)
	particle:SetRoll(math.Rand(0,360))
	particle:SetRollDelta(0.01*math.Rand(-40,40))
	particle:SetAirResistance(50)
	if fx==6 then particle:SetAirResistance(20) end
end

function vape_red_white_blue_chooser(lerp)
	lerp = 3*lerp

	local v = nil

	local r = Vector(255,0,0)
	local w = Vector(255,255,255)
	local b = Vector(0,0,255)

	if lerp >= 2 then
		v = LerpVector(lerp-2,b,r)
	elseif lerp >= 1 then
		v = LerpVector(lerp-1,w,b)
	else
		v = LerpVector(lerp,r,w)
	end

	--particle:SetColor takes seperate parameters per channel
	return v.x,v.y,v.z,255
end

matproxy.Add({
	name = "VapeTankColor",
	init = function( self, mat, values )
		self.ResultTo = values.resultvar
	end,
	bind = function( self, mat, ent )
		if ( !IsValid( ent ) ) then return end
		if ent:GetClass()=="viewmodel" then 
			ent=ent:GetOwner()
			if ( !IsValid( ent ) or !ent:IsPlayer() ) then return end
			ent=ent:GetActiveWeapon()
			if ( !IsValid( ent ) ) then return end
		end
		local v = ent.VapeTankColor or Vector(0.3,0.3,0.3)
		if v==Vector(-1,-1,-1) then
			local c = HSVToColor((CurTime()*60)%360,0.9,0.9)
			v = Vector(c.r,c.g,c.b)/255.0
		end
		if v==Vector(-2,-2,-2) then
			local c = Color(vape_red_white_blue_chooser((CurTime()*0.2)%1))
			v = Vector(c.r,c.g,c.b)/255.0
		end
		mat:SetVector(self.ResultTo, v)
	end
})

matproxy.Add({
	name = "VapeAccentColor",
	init = function( self, mat, values )
		self.ResultTo = values.resultvar
	end,
	bind = function( self, mat, ent )
		if ( !IsValid( ent ) ) then return end
		local o = ent:GetOwner()
		if ent:GetClass()=="viewmodel" then 
			if (!IsValid(o)) or (!o:IsPlayer()) then return end
			ent=o:GetActiveWeapon()
			if ( !IsValid( ent ) ) then return end
		end
		local col = ent.VapeAccentColor or Vector(1,1,1)
		if col==Vector(-1,-1,-1) then
			col=Vector(1,1,1)
			if IsValid(o) then col=o.CustomVapeColor or col end
		end
		mat:SetVector(self.ResultTo, col)
	end
})
--addons/[binbon]misc/lua/autorun/client/gorevhud.lua:
return gluapack()()
--addons/partysystem/lua/autorun/client/partycategories.lua:
return gluapack()()
--addons/partysystem/lua/autorun/client/partymessage.lua:
return gluapack()()
--lua/vgui/bvgui/table.lua:
return gluapack()()
--addons/gmodadminsuite-logging-2.4.8/lua/vgui/gas_logging_advanced_search_item.lua:
local function L(phrase, ...)
	if (#({...}) == 0) then
		return GAS:Phrase(phrase, "logging")
	else
		return GAS:PhraseFormat(phrase, "logging", ...)
	end
end

local PANEL = {}

function PANEL:Init()
	self:SetMouseInputEnabled(true)
	self:SetCursor("hand")
	self:Dock(TOP)
	self:SetTall(32 + 3 + 3)
	self:DockPadding(3,3,3,3)
	self:DockMargin(0,0,0,5)

	self.Color = Color(255,255,255)

	self.Label = vgui.Create("DLabel", self)
	self.Label:SetFont(bVGUI.FONT(bVGUI.FONT_RUBIK, "REGULAR", 14))
	self.Label:Dock(FILL)
	self.Label:SetContentAlignment(5)
	self.Label:SetTextColor(bVGUI.COLOR_WHITE)
	self.Label:DockMargin(5,0,5,0)
end

function PANEL:SetAccountID(account_id)
	local steamid64 = GAS:AccountIDToSteamID64(account_id)

	self.AccountID = account_id

	self.AvatarImage = vgui.Create("AvatarImage", self)
	self.AvatarImage:SetMouseInputEnabled(false)
	self.AvatarImage:Dock(LEFT)
	self.AvatarImage:SetSize(32,32)
	self.AvatarImage:SetSteamID(steamid64, 32)
	self.Label:SetContentAlignment(4)

	self:UpdateTooltip()
end

function PANEL:SetColor(col)
	self.Color = col
end

function PANEL:SetTextColor(col)
	self.Label:SetTextColor(col)
	self:UpdateTooltip()
end

function PANEL:SetValue(val)
	self.Value = val
	self.Label:SetText(val)
	self:UpdateTooltip()
end

function PANEL:SetText(text)
	self.Label:SetText(text)
	self:UpdateTooltip()
end

function PANEL:GetValue()
	return self.Value
end

function PANEL:UpdateTooltip()
	if (self.AccountID ~= nil) then
		bVGUI.UnattachTooltip(self)
		bVGUI.PlayerTooltip.Attach(self, {
			account_id = self.AccountID,
			creator = self,
			focustip = L"right_click_to_focus",
		})
	else
		bVGUI.AttachTooltip(self, {
			Text = self.Label:GetText(),
			TextColor = self.Label:GetTextColor()
		})
	end
end

function PANEL:OnMouseReleased(m)
	if (m == MOUSE_LEFT) then
		GAS:PlaySound("delete")
		self:GetParent():RemoveItem(self)
	elseif (m == MOUSE_RIGHT and self.AccountID ~= nil) then
		bVGUI.PlayerTooltip.Focus()
	end
end

function PANEL:Paint(w,h)
	surface.SetDrawColor(bVGUI.COLOR_DARK_GREY)
	surface.DrawRect(0,0,w,h)

	surface.SetDrawColor(self.Color)
	for i=0,2 do
		surface.DrawOutlinedRect(i,i,w - (i * 2),h - (i * 2))
	end
end

derma.DefineControl("GAS.Logging.AdvancedSearchItem", nil, PANEL, "bVGUI.BlankPanel")
--lua/vgui/openpermissions_scrollpanel.lua:
return gluapack()()
--lua/vgui/openpermissions_scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
	self.CurrentOffset = 0
	self.TargetOffset = 0
	self.StartTime = 0
	self.EndTime = 0

	self.VBar:SetHideButtons(true)
	self.VBar:SetWide(5)
	self.VBar:DockMargin(3,3,3,3)

	function self.VBar:Paint() end
	function self.VBar.btnGrip:Paint(w,h)
		surface.SetDrawColor(0,0,0,150)
		surface.DrawRect(0,0,w,h)
	end

	self.VBar.CurrentY = 0
	self.VBar.TargetY = 0
	function self.VBar:PerformLayout()

		local Wide = self:GetWide()
		local BtnHeight = Wide
		if ( self:GetHideButtons() ) then BtnHeight = 0 end
		local Scroll = self:GetScroll() / self.CanvasSize
		local BarSize = math.max( self:BarScale() * ( self:GetTall() - ( BtnHeight * 2 ) ), 10 )
		local Track = self:GetTall() - ( BtnHeight * 2 ) - BarSize
		Track = Track + 1

		Scroll = Scroll * Track

		self.TargetY = BtnHeight + Scroll
		self.btnGrip:SetSize( Wide, BarSize )

		if ( BtnHeight > 0 ) then
			self.btnUp:SetPos( 0, 0, Wide, Wide )
			self.btnUp:SetSize( Wide, BtnHeight )

			self.btnDown:SetPos( 0, self:GetTall() - BtnHeight )
			self.btnDown:SetSize( Wide, BtnHeight )
			
			self.btnUp:SetVisible( true )
			self.btnDown:SetVisible( true )
		else
			self.btnUp:SetVisible( false )
			self.btnDown:SetVisible( false )
			self.btnDown:SetSize( Wide, BtnHeight )
			self.btnUp:SetSize( Wide, BtnHeight )
		end

	end

	function self.VBar:Think()
		self.CurrentY = Lerp(FrameTime() * 10, self.CurrentY, self.TargetY)
		self.btnGrip:SetPos(0, math.Round(self.CurrentY))
	end

	self.pnlCanvas.CurrentOffset = 0
	self.pnlCanvas.TargetOffset = 0
	function self.pnlCanvas:Think()
		self.CurrentOffset = Lerp(FrameTime() * 10, self.CurrentOffset, self.TargetOffset)
		self:SetPos(0, math.Round(self.CurrentOffset))
	end
end

function PANEL:OnVScroll(offset)
	self.pnlCanvas.TargetOffset = offset
end

function PANEL:PerformLayoutInternal()

	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide + self.VBar:GetWide() )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end

end

derma.DefineControl("OpenPermissions.ScrollPanel", nil, PANEL, "DScrollPanel")
--lua/vgui/stackerdnumslider.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/medic/sh_interface.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/jobs/sh_interface.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/jobs/sh_interface.lua:
DarkRP.hookStub{
    name = "OnPlayerChangedTeam",
    description = "When your team (job) is changed.",
    parameters = {
        {
            name = "ply",
            description = "The player that changed team. Clientside this hook is only called for the LocalPlayer.",
            type = "Player"
        },
        {
            name = "before",
            description = "The team before the change.",
            type = "number"
        },
        {
            name = "after",
            description = "The team after the change.",
            type = "number"
        }
    },
    returns = {

    }
}

--addons/darkrpmodification/lua/darkrp_config/disabled_defaults.lua:
--[[---------------------------------------------------------------------------
DarkRP disabled defaults
---------------------------------------------------------------------------

DarkRP comes with a bunch of default things:
    - a load of modules
    - default jobs
    - shipments and guns
    - entities (like the money printer)
    and many more

If you want to disable or replace the default things, you should disable them here

Note: if you want to have e.g. edit the official medic job, you MUST disable the default one in this file!
You can copy the medic from DarkRP and paste it in darkrp_config/jobs.lua
---------------------------------------------------------------------------]]


--[[---------------------------------------------------------------------------
The list of modules that are disabled. Set to true to disable, false to enable.
Modules that are not in this list are enabled by default.
In some cases some external addons may overwrite one of the modules below and will expect them to be enabled to work.
In these few cases it will be pretty obvious when you expect something to happen and nothing does.
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["modules"] = {
    ["afk"]              = true,
    ["chatsounds"]       = true,
    ["events"]           = false,
    ["fpp"]              = true,
    ["f1menu"]           = true,
    ["f4menu"]           = true,
    ["hitmenu"]          = false,
    ["hud"]              = false,
    ["hungermod"]        = true,
    ["playerscale"]      = false,
    ["sleep"]            = true,
    ["fadmin"]           = true,
    ["animations"]       = false,
    ["chatindicator"]    = false,
}

--[[---------------------------------------------------------------------------
The disabled default jobs. true to disable, false to enable.

NOTE: If you disable a job and remake it, expect things that rely on the job to stop working
e.g. you disable the gundealer and you make a new job as TEAM_GUN. If you want the shipments/door groups/etc. to
work for your custom job, remake them to include your job as well.
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["jobs"] = {
    ["chief"]     = true,
    ["citizen"]   = true,
    ["cook"]      = true, --Hungermod only
    ["cp"]        = true,
    ["gangster"]  = true,
    ["gundealer"] = true,
    ["hobo"]      = true,
    ["mayor"]     = true,
    ["medic"]     = true,
    ["mobboss"]   = true,
}

--[[---------------------------------------------------------------------------
Shipments and pistols
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["shipments"] = {
    ["AK47"]         = true,
    ["Desert eagle"] = true,
    ["Fiveseven"]    = true,
    ["Glock"]        = true,
    ["M4"]           = true,
    ["Mac 10"]       = true,
    ["MP5"]          = true,
    ["P228"]         = true,
    ["Pump shotgun"] = true,
    ["Sniper rifle"] = true,
}

--[[---------------------------------------------------------------------------
Entities
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["entities"] = {
    ["Drug lab"]      = true,
    ["Gun lab"]       = true,
    ["Money printer"] = true,
    ["Microwave"]     = true, --Hungermod only
    ["Tip Jar"]       = false,
}

--[[---------------------------------------------------------------------------
Vehicles
(at the moment there are no default vehicles)
You could use this to disable vehicles you added in the vehicles.lua located in the darkrp_customthings folder.
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["vehicles"] = {

}

--[[---------------------------------------------------------------------------
Food
Food is only enabled when hungermod is enabled (see disabled modules above).
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["food"] = {
    ["Banana"]           = false,
    ["Bunch of bananas"] = true,
    ["Melon"]            = false,
    ["Glass bottle"]     = false,
    ["Pop can"]          = false,
    ["Plastic bottle"]   = false,
    ["Milk"]             = false,
    ["Bottle 1"]         = false,
    ["Bottle 2"]         = false,
    ["Bottle 3"]         = false,
    ["Orange"]           = true,
}

--[[---------------------------------------------------------------------------
Door groups
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["doorgroups"] = {
    ["Devlet Görevlisi"] = false,
    ["Gundealer only"]      = false,
}


--[[---------------------------------------------------------------------------
Ammo packets
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["ammo"] = {
    ["Pistol ammo"]  = true,
    ["Rifle ammo"]   = true,
    ["Shotgun ammo"] = true,
}

--[[---------------------------------------------------------------------------
Agendas
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["agendas"] = {
    ["Gangster's agenda"] = false,
    ["Police agenda"] = false,
}

--[[---------------------------------------------------------------------------
Chat groups (chat with /g)
Chat groups do not have names, so their index is used instead.
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["groupchat"] = {
    [1] = false, -- Police group chat (mayor, cp, chief and/or your custom CP teams)
    [2] = false, -- Group chat between gangsters and the mobboss
    [3] = false, -- Group chat between people of the same team
}

--[[---------------------------------------------------------------------------
Jobs that are hitmen
set to true to disable
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["hitmen"] = {
    ["mobboss"] = false,
}

--[[---------------------------------------------------------------------------
Demote groups
When anyone is demoted from any job in this group, they will be temporarily banned
from every job in the group
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["demotegroups"] = {
    ["Devlet Görevlisi"]      = false,
    ["Gangsters"] = false,
}

--[[---------------------------------------------------------------------------
Workarounds

DarkRP works around some bugs in GMod and other addons that aren't maintained
(properly). Disabling workarounds will cause those things to break again.
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults["workarounds"] = {
    ["os.date() Windows crash"]                      = false,
    ["SkidCheck"]                                    = false,
    ["nil SteamID64 and AccountID local server fix"] = false,
    ["Cam function descriptive errors"]              = false,
    ["Error on edict limit"]                         = false,
    ["Durgz witty sayings"]                          = false,
    ["ULX /me command"]                              = false,
    ["gm_save"]                                      = false,
    ["rp_downtown_v4c_v2 rooftop spawn"]             = false,
    ["White flashbang flashes"]                      = false,
    ["APAnti"]                                       = false,
    ["Wire field generator exploit fix"]             = false,
    ["Door tool class fix"]                          = false,
    ["Constraint crash exploit fix"]                 = false,
    ["Deprecated console commands"]                  = false,
    ["disable CAC"]                                  = false,
}

--gamemodes/darkrp/gamemode/modules/tipjar/cl_communication.lua:
local updateModel, getModelValue, onModelUpdate =
    DarkRP.tipJarUIModel.updateModel,
    DarkRP.tipJarUIModel.getModelValue,
    DarkRP.tipJarUIModel.onModelUpdate

onModelUpdate("lastTipAmount", function(amount)
    if amount <= 0 then return end

    local tipjar = getModelValue("tipjar")

    if not IsValid(tipjar) then return end

    net.Start("DarkRP_TipJarDonate")
        net.WriteEntity(tipjar)
        net.WriteUInt(amount, 32)
    net.SendToServer()
end)

net.Receive("DarkRP_TipJarUI", fc{DarkRP.tipJarUI, net.ReadEntity})

net.Receive("DarkRP_TipJarDonate", function()
    local tipjar = net.ReadEntity()
    local ply    = net.ReadEntity()
    local amount = net.ReadUInt(32)

    if not IsValid(tipjar) then return end
    if not IsValid(ply) then return end

    tipjar:Donated(ply, amount)
    updateModel("donatedUpdate")
end)

onModelUpdate("amount", function(amount, old)
    local tipjar = getModelValue("tipjar")

    if not IsValid(tipjar) then return end

    tipjar:UpdateActiveDonation(LocalPlayer(), amount)

    if amount == old then return end

    net.Start("DarkRP_TipJarUpdate")
        net.WriteEntity(tipjar)
        net.WriteUInt(amount, 32)
    net.SendToServer()
end)

net.Receive("DarkRP_TipJarUpdate", function(len)
    local tipjar = net.ReadEntity()

    if not IsValid(tipjar) then return end

    local bitsRead = 16

    while bitsRead < len do
        tipjar:UpdateActiveDonation(net.ReadEntity(), net.ReadUInt(32))

        -- I thought there was a function for this?
        bitsRead = bitsRead + 16 + 32
    end
end)

onModelUpdate("frameVisible", function(visible)
    local localply = LocalPlayer()
    local tipjar   = getModelValue("tipjar")
    local amount   = getModelValue("amount")

    if not IsValid(localply) then return end
    if not IsValid(tipjar) then return end

    if visible then
        tipjar:ClearActiveDonations()
        tipjar:UpdateActiveDonation(localply, amount)

        net.Start("DarkRP_TipJarUpdate")
            net.WriteEntity(tipjar)
            net.WriteUInt(amount, 32)
        net.SendToServer()

    else
        net.Start("DarkRP_TipJarExit")
            net.WriteEntity(tipjar)
        net.SendToServer()

        tipjar:ExitActiveDonation(localply)
    end
end)

net.Receive("DarkRP_TipJarExit", function()
    local tipjar = net.ReadEntity()
    local ply = net.ReadEntity()

    if not IsValid(tipjar) then return end
    if not IsValid(ply) then return end

    tipjar:ExitActiveDonation(ply)
end)

net.Receive("DarkRP_TipJarDonatedList", function()
    local tipjar = net.ReadEntity()
    local count = net.ReadUInt(8)

    if not IsValid(tipjar) then return end

    tipjar:ClearDonations()

    for i = 1, count do
        tipjar:AddDonation(net.ReadString(), net.ReadUInt(32))
    end

    updateModel("donatedUpdate")
end)


local function onUpdateActiveDonation(_, tipjar)
    if not IsValid(tipjar) or tipjar ~= getModelValue("tipjar") then return end

    updateModel("activeDonationUpdate")
end

DarkRP.hooks.tipjarUpdateActiveDonation = onUpdateActiveDonation
DarkRP.hooks.tipjarExitActiveDonation   = onUpdateActiveDonation
DarkRP.hooks.tipjarClearActiveDonation  = onUpdateActiveDonation

--gamemodes/darkrp/gamemode/modules/jobs/sh_commands.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/hud/cl_hud.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/fspectate/sh_init.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/doorsystem/sh_doors.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/modules/base/sh_playerclass.lua:
local PLAYER_CLASS = {}
PLAYER_CLASS.DisplayName = "DarkRP Base Player Class"
PLAYER_CLASS.WalkSpeed = -1
PLAYER_CLASS.RunSpeed = -1
PLAYER_CLASS.DuckSpeed = 0.3
PLAYER_CLASS.UnDuckSpeed = 0.3
PLAYER_CLASS.TeammateNoCollide = false
PLAYER_CLASS.StartHealth = -1
function PLAYER_CLASS:Loadout()
end
function PLAYER_CLASS:SetModel()
end
function PLAYER_CLASS:ShouldDrawLocal()
end
function PLAYER_CLASS:CreateMove(cmd)
end
function PLAYER_CLASS:CalcView(view)
end
function PLAYER_CLASS:GetHandsModel()
end
function PLAYER_CLASS:StartMove(mv, cmd)
end
function PLAYER_CLASS:FinishMove(mv)
end
player_manager.RegisterClass("player_darkrp", PLAYER_CLASS, "player_sandbox")
--gamemodes/darkrp/gamemode/modules/base/sh_gamemode_functions.lua:
return gluapack()()
--gamemodes/darkrp/gamemode/config/addentities.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/enum/sh_glorifiedleveling_enum_perks.lua:

GlorifiedLeveling.Perks.Enum.SPEED = 1
GlorifiedLeveling.Perks.Enum.LEAPING = 2
GlorifiedLeveling.Perks.Enum.ARMOR = 3
GlorifiedLeveling.Perks.Enum.HEALTH = 4
GlorifiedLeveling.Perks.Enum.MORE_DAMAGE_GIVEN = 6

GlorifiedLeveling.Perks.Enum.DEFAULT_PERK_TABLE = {
    [GlorifiedLeveling.Perks.Enum.SPEED] = 0,
    [GlorifiedLeveling.Perks.Enum.LEAPING] = 0,
    [GlorifiedLeveling.Perks.Enum.ARMOR] = 0,
    [GlorifiedLeveling.Perks.Enum.HEALTH] = 0,
    [GlorifiedLeveling.Perks.Enum.MORE_DAMAGE_GIVEN] = 0
}
--addons/glorifiedleveling/lua/glorifiedleveling/localization/sh_glorifiedleveling_french.lua:

GlorifiedLeveling.i18n.RegisterPhrases( "fr", {
    glDarkTheme = "Sombre",
    glLevelNotHighEnough = "Vous n'êtes pas d'un niveau suffisamment élevé pour cela.",
    glYouReceivedXP = "Vous avez reçu %s XP.",
    glYouReceivedXPKill = "Vous avez reçu %s XP pour avoir tué %s.",
    glLevelX = "Niveau %s",
    glLevelUp = "Niveau Supérieur!",
    glAdminMenuLockdown = "VEROUILLAGE",
    glAdminMenuPlayers = "JOUEURS",
    glPlayersOnline = "Joueurs en ligne: %s",
    glSetLevel = "Définir niveau",
    glResetLevel = "Réinitialiser niveau",
    glAddXP = "Ajouter XP",
    glConfirmation = "Confirmation",
    glYes = "Oui",
    glNo = "Non",
    glConfirmationResetLevel = "Voulez-vous réinitialiser le niveau de ce joueur?",
    glEnterLevel = "Entrez le nouveau niveau du joueur ci-dessous.",
    glEnterXP = "Saisissez les points d'XP que vous souhaitez ajouter.",
    glEnter = "Entrée",
    glInvalidAmount = "Montant sélectionné invalide.",
    glMaxLevel = "Niveau Max",

    -- Leaderboard localization.
    glLeaderboard = "Classement",
    glName = "Nom",
    glXP = "XP",
    glLevel = "Niveau",
    glNobodyHere = "Il n'y a personne ici :(",

    -- Perk localization.
    glSkills = "Compétences",
    glPoints = "%s Points",
    glComplete = "Finir",

    glHasteBoots = "Bottes de hâte",
    glHasteBootsDescription = "Vitesse accrue",

    glFeralLeaping = "Bottes de saut à l'élastique",
    glFeralLeapingDescription = "Plus grande hauteur de saut, moins de dégâts de chute",

    glIronSkin = "Peau de fer",
    glIronSkinDescription = "Armure accrue au spawn",

    glJuggernaut = "Mastodonte",
    glJuggernautDescription = "Santé accrue au spawn",

    glBulletAbsorption = "Absorption des balles",
    glBulletAbsorptionDescription = "Moins de dommages reçues",

    glHighGradeBullets = "Balles de haute qualité",
    glHighGradeBulletsDescription = "Inflige plus de dommages",
} )
--addons/glorifiedleveling/lua/glorifiedleveling/localization/sh_glorifiedleveling_polish.lua:
-- Translated by: 76561199092231941 

GlorifiedLeveling.i18n.RegisterPhrases( "pl", {
    glDarkTheme = "Ciemny",
    glLevelNotHighEnough = "Nie jesteś do tego wystarczająco wysoki.",
    glYouReceivedXP = "Otrzymałeś %s XP.",
    glYouReceivedXPKill = "Otrzymałeś %s XP za zabicie %s.",
    glLevelX = "Poziom %s",
    glLevelUp = "Level Up!", -- No real translation, that would make sense - sorry fag
    glAdminMenuLockdown = "LOCKDOWN", -- No real translation, that would make sense - sorry fag
    glAdminMenuPlayers = "GRACZE",
    glPlayersOnline = "Gracze online: %s",
    glSetLevel = "Ustaw poziom",
    glResetLevel = "Resetuj poziom",
    glAddXP = "Dodaj XP",
    glConfirmation = "Potwierdzenie",
    glYes = "Tak",
    glNo = "Nie",
    glConfirmationResetLevel = "Czy chcesz zresetować poziom tego gracza?",
    glEnterLevel = "Wpisz nowy poziom gracza poniżej.",
    glEnterXP = "Wpisz, ile XP chcesz dodać.",
    glEnter = "Wchodzić",
    glInvalidAmount = "Wybrano nieprawidłową kwotę.",
    glMaxLevel = "Najwyższy poziom", 

    -- Leaderboard localization.
    glLeaderboard = "Leaderboard", -- No real translation, that would make sense - sorry fag
    glName = "imię",
    glXP = "XP",
    glLevel = "Poziom",
    glNobodyHere = "Nikogo tu nie ma :(",

    -- Perk localization.
    glSkills = "Umiejętności",
    glPoints = "%s punktów",
    glComplete = "Kompletny",

    glHasteBoots = "Buty Pośpiechu",
    glHasteBootsDescription = "Dodatkowa prędkość",

    glFeralLeaping = "Buty Dzikiego Skaczącego",
    glFeralLeapingDescription = "Większa wysokość skoku, mniejsze obrażenia od upadku",

    glIronSkin = "Żelazna Skóra",
    glIronSkinDescription = "Dodatkowa zbroja na Spawn", 

    glJuggernaut = "Juggernaut", -- No real translation, that would make sense - sorry fag
    glJuggernautDescription = "Dodatkowe zdrowie na Spawn",

    glBulletAbsorption = "Absorpcja pocisków",
    glBulletAbsorptionDescription = "Mniejsze obrażenia",

    glHighGradeBullets = "Pociski wysokiej jakości",
    glHighGradeBulletsDescription = "Więcej zadawanych obrażeń",
} )
--addons/glorifiedleveling/lua/glorifiedleveling/localization/sh_glorifiedleveling_turkish.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/modules/ui/adminpanel/cl_glorifiedleveling_player.lua:

local PANEL = {}

function PANEL:AddPlayer( ply, level )

    self.Player = ply
    self.Level = level

    self.Avatar = vgui.Create( "GlorifiedLeveling.CircleAvatar", self )

    self.SetLevel = vgui.Create( "DButton", self )
    self.SetLevel:SetText( "" )
    self.SetLevel.Color = Color( 255, 255, 255 )
    self.SetLevel.Paint = function( s, w, h )
        s.Color = GlorifiedLeveling.UI.LerpColor( FrameTime() * 10, s.Color, s:IsHovered() and self.Theme.Data.Colors.playersMenuSetButtonBackgroundHoverCol or self.Theme.Data.Colors.playersMenuSetButtonBackgroundCol )

        draw.RoundedBox( h * 0.22, 0, 0, w, h, s.Color )
        draw.SimpleText( GlorifiedLeveling.i18n.GetPhrase( "glSetLevel" ), "GlorifiedLeveling.AdminMenu.PlayerSetLevel", w / 2, h / 2, self.Theme.Data.Colors.playersMenuButtonTextCol, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end
    self.SetLevel.DoClick = function( s )
        if IsValid( GlorifiedLeveling.UI.SetLevelConfirmation ) then return end

        GlorifiedLeveling.UI.SetLevelConfirmation = vgui.Create( "GlorifiedLeveling.SetLevelConfirmation" )
        GlorifiedLeveling.UI.SetLevelConfirmation.SteamID = self.Player:SteamID()
    end

    self.ResetLevel = vgui.Create( "DButton", self )
    self.ResetLevel:SetText( "" )
    self.ResetLevel.Color = Color( 255, 255, 255 )
    self.ResetLevel.Paint = function( s, w, h )
        s.Color = GlorifiedLeveling.UI.LerpColor( FrameTime() * 10, s.Color, s:IsHovered() and self.Theme.Data.Colors.playersMenuResetButtonBackgroundHoverCol or self.Theme.Data.Colors.playersMenuResetButtonBackgroundCol )

        draw.RoundedBox( h * 0.22, 0, 0, w, h, s.Color )
        draw.SimpleText( GlorifiedLeveling.i18n.GetPhrase( "glResetLevel" ), "GlorifiedLeveling.AdminMenu.PlayerSetLevel", w / 2, h / 2, self.Theme.Data.Colors.playersMenuButtonTextCol, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end
    self.ResetLevel.DoClick = function( s )
        if IsValid( GlorifiedLeveling.UI.ResetLevelConfirmation ) then return end

        GlorifiedLeveling.UI.ResetLevelConfirmation = vgui.Create( "GlorifiedLeveling.ResetLevelConfirmation" )
        GlorifiedLeveling.UI.ResetLevelConfirmation.SteamID = self.Player:SteamID()
    end

    self.AddXP = vgui.Create( "DButton", self )
    self.AddXP:SetText( "" )
    self.AddXP.Color = Color( 255, 255, 255 )
    self.AddXP.Paint = function( s, w, h )
        s.Color = GlorifiedLeveling.UI.LerpColor( FrameTime() * 10, s.Color, s:IsHovered() and self.Theme.Data.Colors.playersMenuAddButtonBackgroundCol or self.Theme.Data.Colors.playersMenuAddButtonBackgroundHoverCol )

        draw.RoundedBox( h * 0.22, 0, 0, w, h, s.Color )
        draw.SimpleText( GlorifiedLeveling.i18n.GetPhrase( "glAddXP" ), "GlorifiedLeveling.AdminMenu.PlayerSetLevel", w / 2, h / 2, self.Theme.Data.Colors.playersMenuButtonTextCol, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end
    self.AddXP.DoClick = function(s)
        if IsValid( GlorifiedLeveling.UI.AddXPConfirmation ) then return end

        GlorifiedLeveling.UI.AddXPConfirmation = vgui.Create( "GlorifiedLeveling.AddXPConfirmation" )
        GlorifiedLeveling.UI.AddXPConfirmation.SteamID = self.Player:SteamID()
    end

    local function drawPlayerInfo( playerno, x, containerh, align )
        if not IsValid(self.Player) then return end
        local centerh = containerh / 2
        local spacing = containerh * 0.1
        local wSpacing = containerh * 0.25

        draw.SimpleText( self.Player:Name(), "GlorifiedLeveling.AdminMenu.PlayerInfo", x + wSpacing, centerh - spacing, self.Theme.Data.Colors.playerNameTextCol, align, TEXT_ALIGN_CENTER )
        draw.SimpleText( self.Player:SteamID(), "GlorifiedLeveling.AdminMenu.PlayerInfo", x + wSpacing, centerh + spacing, self.Theme.Data.Colors.playerSteamIDTextCol, align, TEXT_ALIGN_CENTER )
    end

    function self:Paint( w, h )
        draw.RoundedBox( h * 0.1, 0, 0, w, h, self.Theme.Data.Colors.playerBackgroundCol )

        drawPlayerInfo( 1, h * 0.77, h, TEXT_ALIGN_LEFT )

        draw.SimpleText( GlorifiedLeveling.i18n.GetPhrase( "glLevelX", self.Level ), "GlorifiedLeveling.AdminMenu.PlayerLevel", w * .95, h / 2, self.Theme.Data.Colors.playerInfoTextCol, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER )
    end
end

function PANEL:PerformLayout( w, h )
    local avatarsize = h * 0.65

    self.Avatar:SetSize( avatarsize, avatarsize )
    self.Avatar:SetMaskSize( avatarsize * 0.5 )
    self.Avatar:SetPos( h * 0.25, h * 0.18 )
    self.Avatar:SetSteamID( self.Player:SteamID64(), avatarsize )

    self.SetLevel:SetSize( w * 0.12, h * 0.4 )
    self.SetLevel:SetPos( w * 0.3, h * 0.3 )

    self.ResetLevel:SetSize( w * 0.14, h * 0.4 )
    self.ResetLevel:SetPos( w * 0.43, h * 0.3 )

    self.AddXP:SetSize( w * 0.13, h * 0.4 )
    self.AddXP:SetPos( w * 0.58, h * 0.3 )

    if not self.CanEditPlayers then
        self.SetLevel:SetVisible( false )
        self.ResetLevel:SetVisible( false )
        self.AddXP:SetVisible( false )
    end
end

vgui.Register( "GlorifiedLeveling.Player", PANEL, "Panel" )
--addons/glorifiedleveling/lua/glorifiedleveling/modules/ui/perkmenu/cl_glorifiedleveling_perkmenu_panel.lua:
return gluapack()()
--addons/glorifiedleveling/lua/glorifiedleveling/modules/ui/perkmenu/cl_glorifiedleveling_perkmenu_perkentry.lua:

local PANEL = {}

function PANEL:Init()
    self.Theme = self:GetParent().Theme
    self.Progress = 0
    self.AddButton = vgui.Create( "DButton", self )
    self.RemoveButton = vgui.Create( "DButton", self )
end

function PANEL:PerformLayout( w, h )
    local parent = self:GetParent()
    local themeColors = self.Theme.Data.Colors

    self.SideOffset = w / 50
    self.SliderBoxW = w / 2.5
    self.SliderBoxH = h / 3.2
    self.SliderBoxX = w - self.SliderBoxW - self.SideOffset - ( self.SliderBoxW / 10 )
    self.SliderBoxY = ( h / 2 ) - ( self.SliderBoxH / 2 )

    self.AddButton:SetSize( self.SliderBoxH, self.SliderBoxH )
    self.AddButton:SetPos( self.SliderBoxX + self.SliderBoxW + ( self.SliderBoxW / 80 ) + 1, self.SliderBoxY )
    self.AddButton:SetFont( "GlorifiedLeveling.PerkMenu.PerkModifyText" )
    self.AddButton:SetText( "+" )
    self.AddButton:SetVisible( self.Progress < 10 )
    self.AddButton.Think = function()
        self.AddButton:SetTextColor( self.AddButton:IsHovered() and themeColors.perkMenuEntryAddButtonColorHovered or themeColors.perkMenuEntryAddButtonColor )
    end
    self.AddButton.DoClick = function()
        if parent.CachedFreePoints <= 0 then return end
        self.Progress = math.Clamp( self.Progress + 1, 0, 10 )
        self.AddButton:SetVisible( self.Progress < 10 )
        self.RemoveButton:SetVisible( self.Progress > 0 )
        GlorifiedLeveling.PerkTableCache[self.Perk] = GlorifiedLeveling.PerkTableCache[self.Perk] + 1
        parent.CachedFreePoints = parent.CachedFreePoints - 1
        parent.TitleBar.FreePointsLabel.FreePointsChanged()
    end
    self.AddButton.Paint = function() end

    self.RemoveButton:SetSize( self.SliderBoxH, self.SliderBoxH )
    self.RemoveButton:SetPos( self.SliderBoxX - self.SliderBoxH - ( self.SliderBoxW / 80 ), self.SliderBoxY )
    self.RemoveButton:SetFont( "GlorifiedLeveling.PerkMenu.PerkModifyText" )
    self.RemoveButton:SetText( "-" )
    self.RemoveButton:SetVisible( self.Progress > 0 )
    self.RemoveButton.Think = function()
        self.RemoveButton:SetTextColor( self.RemoveButton:IsHovered() and themeColors.perkMenuEntryRemoveButtonColorHovered or themeColors.perkMenuEntryRemoveButtonColor )
    end
    self.RemoveButton.DoClick = function()
        self.Progress = math.Clamp( self.Progress - 1, 0, 10 )
        self.AddButton:SetVisible( self.Progress < 10 )
        self.RemoveButton:SetVisible( self.Progress > 0 )
        GlorifiedLeveling.PerkTableCache[self.Perk] = GlorifiedLeveling.PerkTableCache[self.Perk] - 1
        parent.CachedFreePoints = parent.CachedFreePoints + 1
        parent.TitleBar.FreePointsLabel.FreePointsChanged()
    end
    self.RemoveButton.Paint = function() end

    self.LayoutInitialized = true
end

function PANEL:SetPerk( perk )
    self.Perk = perk
    self.Progress = GlorifiedLeveling.PerkTableCache[perk]
end

function PANEL:Paint( w, h )
    local themeColors = self.Theme.Data.Colors
    draw.RoundedBox( 8, 0, 0, w, h, themeColors.perkMenuEntryBackgroundColor )
    if not self.Perk or not self.LayoutInitialized then return end
    local perkInfo = GlorifiedLeveling.Perks.PERK_INFO[self.Perk]

    draw.SimpleText( perkInfo.Name, "GlorifiedLeveling.PerkMenu.PerkText", self.SideOffset, h / 2 - h / 8, themeColors.perkMenuEntryPerkName, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
    draw.SimpleText( perkInfo.Description, "GlorifiedLeveling.PerkMenu.PerkDescriptionText", self.SideOffset + 1, h / 2 + h / 7, themeColors.perkMenuEntryPerkDescription, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

    draw.RoundedBox( 8, self.SliderBoxX, self.SliderBoxY, self.SliderBoxW, self.SliderBoxH, themeColors.perkMenuEntrySliderBackgroundColor )

    if self.Progress < 10 then
        local progressW = ( self.SliderBoxW / 10 ) * self.Progress
        render.SetScissorRect( self.SliderBoxX, 0, self:LocalToScreen( self.SliderBoxX ) + progressW, ScrH(), true )
        draw.RoundedBox( 8, self.SliderBoxX, self.SliderBoxY, self.SliderBoxW, self.SliderBoxH, themeColors.perkMenuEntrySliderProgressedColor )
        render.SetScissorRect( 0, 0, ScrW(), ScrH(), false )

        for i = 1, 9 do
            draw.RoundedBox( 0, self.SliderBoxX + ( ( self.SliderBoxW / 10 ) * i ) - 1, self.SliderBoxY, 1, self.SliderBoxH, themeColors.perkMenuEntrySliderLiningColor )
        end
    else
        draw.RoundedBox( 8, self.SliderBoxX, self.SliderBoxY, self.SliderBoxW, self.SliderBoxH, themeColors.perkMenuEntrySliderProgressedColor )
        draw.SimpleText( "Tamamlandı", "GlorifiedLeveling.PerkMenu.PerkCompleteText", self.SliderBoxX + ( self.SliderBoxW / 2 ), self.SliderBoxY + ( self.SliderBoxH / 2 ) - 1, themeColors.perkMenuEntrySliderTexts, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end
    draw.SimpleText( "(" .. self.Progress .. "/10)", "GlorifiedLeveling.PerkMenu.PerkAmountText", self.SliderBoxX + ( self.SliderBoxW / 2 ), self.SliderBoxY + self.SliderBoxH + ( self.SliderBoxH / 2.5 ), themeColors.perkMenuEntrySliderTexts, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

vgui.Register( "GlorifiedLeveling.PerkMenu.PerkEntry", PANEL, "EditablePanel" )
--addons/zeros_yeastbeast_1.1.7/lua/darkrp_modules/zerosyeastbeast/sh_zyb_darkrp.lua:
TEAM_ZYB_DISTILLER = DarkRP.createJob("Kaçak İçki Üreticisi", {
    color = Color(255, 0, 0, 255),
    model = {"models/player/group03/male_04.mdl"},
    description = [[Yasalara aldırış etmeden kendi damıtımevini kurmuş, gizli saklı içki üretmeye başlamışsın. 
    Mahzenlerde, terk edilmiş binalarda veya ormanlık alanlarda kaliteli içkiler yapıyorsun. 
    Ancak unutma, polisler ve rakiplerin her an peşinde olabilir. Eğer yakalanırsan, bir daha içki yapacak vaktin olmayabilir!
    
    -İllegal Aktivitelerde Bulunabilir
    -Raid Atamaz 
	-Mug Atamaz
	-Banka Soyamaz
    ]],
    weapons = {},
    command = "zyb_moonshinedistiller",
    max = 2,
    salary = 15,
    admin = 0,
    vote = false,
    category = "İllegal",
    hasLicense = false
})

TEAM_ZYB_MASTER_DISTILLER = DarkRP.createJob("Profesyonel Kaçak İçki Üreticisi", {
    color = Color(255, 247, 0),
    model = {"models/player/group03/male_04.mdl"},
    description = [[Sen artık bu işin ustasısın. Ev yapımı karışımları bırakıp, gerçek bir profesyonel gibi çalışıyorsun. 
    En kaliteli içkileri üretiyor ve piyasaya sürüyorsun. 
    Zengin müşterilerin ve gizli anlaşmaların var. 
    Ancak büyük işlerin büyük riskleri de olur... Bir hata yaparsan bütün imparatorluğun bir gecede yerle bir olabilir!
    
    -İllegal Aktivitelerde Bulunabilir
    -Raid Atamaz 
	-Mug Atamaz
	-Banka Soyamaz
    ]],
    weapons = {},
    command = "zyb_mastermoonshinedistiller",
    max = 2,
    salary = 40,
    admin = 0,
    vote = false,
    category = "Donator",
    hasLicense = false
})

DarkRP.createCategory{
    name = "Kaçak İçki Üretim",
    categorises = "entities",
    startExpanded = true,
    color = Color(255, 107, 0, 255),
    canSee = function(ply) return true end,
    sortOrder = 104
}

DarkRP.createEntity("İçki Makinesi", {
    ent = "zyb_distillery",
    model = "models/zerochain/props_yeastbeast/yb_distillery_heater.mdl",
    price = 5000,
    max = 1,
    cmd = "buyzyb_distillery",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})

DarkRP.createEntity("Soğutucu", {
    ent = "zyb_constructionkit_cooler",
    model = "models/zerochain/props_yeastbeast/yb_distillery_cooler.mdl",
    price = 3000,
    max = 1,
    cmd = "buyzyb_constructionkit_cooler",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})

DarkRP.createEntity("Damitici", {
    ent = "zyb_constructionkit_condenser",
    model = "models/zerochain/props_yeastbeast/yb_distillery_condenser.mdl",
    price = 3000,
    max = 1,
    cmd = "buyzyb_constructionkit_condenser",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})

DarkRP.createEntity("Fermantasyon Varili", {
    ent = "zyb_fermbarrel",
    model = "models/zerochain/props_yeastbeast/yb_barrel.mdl",
    price = 500,
    max = 3,
    cmd = "buyzyb_fermbarrel",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})

DarkRP.createEntity("Odun", {
    ent = "zyb_fuel",
    model = "models/zerochain/props_yeastbeast/yb_wood.mdl",
    price = 50,
    max = 10,
    cmd = "buyzyb_fuel",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})

DarkRP.createEntity("Sise Paketi", {
    ent = "zyb_jarpack",
    model = "models/zerochain/props_yeastbeast/yb_jarpack.mdl",
    price = 200,
    max = 4,
    cmd = "buyzyb_jarpack",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})

DarkRP.createEntity("Sise Kutusu", {
    ent = "zyb_jarcrate",
    model = "models/zerochain/props_yeastbeast/yb_jarcrate.mdl",
    price = 200,
    max = 4,
    cmd = "buyzyb_jarcrate",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})


DarkRP.createEntity("Öğütücü", {
    ent = "zyb_yeastgrinder",
    model =   "models/zerochain/props_yeastbeast/yb_grinder.mdl",
    price = 2000,
    max = 2,
    cmd = "buyzyb_yeastgrinder",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})

DarkRP.createEntity("Motorlu Öğütücü", {
    ent = "zyb_motor",
    model =  "models/zerochain/props_yeastbeast/yb_motor.mdl",
    price = 5000,
    max = 2,
    cmd = "buyzyb_motor",
    allowed = {TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})



DarkRP.createEntity("Maya Kesesi ", {
    ent = "zyb_paperbag",
    model =  "models/zerochain/props_yeastbeast/yb_paperbag.mdl",
    price = 100,
    max = 10,
    cmd = "buyzyb_paperbag",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})



DarkRP.createEntity("Sugar", {
    ent = "zyb_sugar",
    model =  "models/zerochain/props_yeastbeast/yb_sugar.mdl",
    price = 100,
    max = 10,
    cmd = "buyzyb_sugar",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})

DarkRP.createEntity("Su", {
    ent = "zyb_water",
    model =  "models/zerochain/props_yeastbeast/yb_water.mdl",
    price = 100,
    max = 10,
    cmd = "buyzyb_water",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})

DarkRP.createEntity("Maya", {
    ent = "zyb_yeast",
    model =  "models/zerochain/props_yeastbeast/yb_yeast.mdl",
    price = 100,
    max = 10,
    cmd = "buyzyb_yeast",
    allowed = {TEAM_ZYB_DISTILLER,TEAM_ZYB_MASTER_DISTILLER},
    category = "Kaçak İçki Üretim"
})


--addons/darkrpmodification/lua/darkrp_modules/advert/sh_advert.lua:
return gluapack()()
--addons/darkrpmodification/lua/darkrp_customthings/vehicles.lua:
--[[---------------------------------------------------------------------------
DarkRP custom vehicles
---------------------------------------------------------------------------

This file contains your custom vehicles.
This file should also contain vehicles from DarkRP that you edited.

For examples and explanation please visit this wiki page:
https://darkrp.miraheze.org/wiki/DarkRP:Vehicles

If you want to keep the vehicle code and not comment it out you can add a vehicle to the "DarkRP.disabledDefaults["vehicles"]" section
in the disabled_defaults.lua in the "darkrp_config" folder

Add vehicles under the following line:
---------------------------------------------------------------------------]]
--addons/darkrpmodification/lua/darkrp_customthings/doorgroups.lua:
--[[
    Generated using: DarkRP | Door Group Generator
    https://csite.io/tools/gmod-darkrp-door
--]]
DarkRP.AddDoorGroup("Devlet Görevlisi Açabilir", TEAM_CHIEF, TEAM_POLICE, TEAM_MAYOR)
DarkRP.AddDoorGroup("Banka Görevlisi Açabilir", TEAM_BANKACI, TEAM_BGUVENLIK)
DarkRP.AddDoorGroup("Otel Görevlileri", TEAM_OTEL, TEAM_CIRAK)
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/localization/sh_glorifiedhandcuffs_english.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/themes/cl_glorifiedhandcuffs_theme_default.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/modules/core/cl_glorifiedhandcuffs_breakfree.lua:

local timeSinceLastKeyPress = 0
GlorifiedHandcuffs.BreakFreeTotal = 0

hook.Add( "PlayerButtonDown", "GlorifiedHandcuffs.BreakFree.PlayerButtonDown", function( ply, key )
    if GlorifiedHandcuffs.Config.BREAK_FREE_ENABLED and GlorifiedHandcuffs.IsPlayerHandcuffed( ply ) and key == GlorifiedHandcuffs.Config.BREAK_FREE_KEY and CurTime() >= timeSinceLastKeyPress + GlorifiedHandcuffs.Config.BREAK_FREE_MIN_TIME and ply:Alive() then
        timeSinceLastKeyPress = CurTime()
        GlorifiedHandcuffs.BreakFreeTotal = GlorifiedHandcuffs.BreakFreeTotal + 1
        if GlorifiedHandcuffs.BreakFreeTotal >= GlorifiedHandcuffs.Config.BREAK_FREE_TOTAL then
            net.Start( "GlorifiedHandcuffs.BreakFree.AttemptSuccess" )
            net.SendToServer()
            timer.Simple( ply:Ping() / 1000, function()
                GlorifiedHandcuffs.BreakFreeTotal = 0 -- We need to do this synced with the player's ping, otherwise the lagg will make it difficult to suceed.
            end )
            return
        end

        if timer.Exists( "GlorifiedHandcuffs.BreakFreeTimer" ) then
            timer.Start( "GlorifiedHandcuffs.BreakFreeTimer" )
        else
            net.Start( "GlorifiedHandcuffs.BreakFree.AttemptStarted" )
            net.SendToServer()
            timer.Create( "GlorifiedHandcuffs.BreakFreeTimer", GlorifiedHandcuffs.Config.BREAK_FREE_EXPIRY_TIME - ( ply:Ping() / 1000 ), 1, function()
                if GlorifiedHandcuffs.BreakFreeTotal >= GlorifiedHandcuffs.Config.BREAK_FREE_TOTAL then return end
                net.Start( "GlorifiedHandcuffs.BreakFree.AttemptFailed" )
                net.SendToServer()
                GlorifiedHandcuffs.BreakFreeTotal = 0
            end )
        end
    end
end )
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/modules/ui/hud/cl_glorifiedhandcuffs_surrenderinghud.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/glorifiedhandcuffs/modules/ui/hud/cl_glorifiedhandcuffs_surrenderinghud.lua:

local ply
local ghi18n = GlorifiedHandcuffs.i18n
local themeData = GlorifiedHandcuffs.Themes.GetCurrent().Data
local surrenderMaterial = themeData.Materials.surrender

local surrenderingFontW = surface.GetTextSize( ghi18n.GetPhrase( "surrendering" ) )
local hitToFreeText = string.Split( ghi18n.GetPhrase( "putHandsDown" ), "%s" )
surface.SetFont( "GlorifiedHandcuffs.HUD.StopSurrendering" )
local spamFontW = surface.GetTextSize( hitToFreeText[1] )
local keyFontW = surface.GetTextSize( GlorifiedHandcuffs.Config.TOGGLE_SURRENDER_KEY_NAME )
local hitToFreeFontW = surface.GetTextSize( ghi18n.GetPhrase( "putHandsDown" ) )
local scrW = ScrW()

hook.Add( "HUDPaint", "GlorifiedLeveling.HUD.Surrendering", function()
    if not GlorifiedHandcuffs.IsPlayerSurrendering( LocalPlayer() ) or not LocalPlayer():Alive() then return end
    if not ply then ply = LocalPlayer() end
    surface.SetMaterial( surrenderMaterial )
    surface.SetDrawColor( 255, 255, 255 )
    surface.DrawTexturedRect( scrW / 2 - 48, 5, 96, 96 )

    surface.SetFont( "GlorifiedHandcuffs.HUD.Surrendering" )
    draw.RoundedBox( 5, scrW / 2 - ( surrenderingFontW + 15 ) / 2, 106, surrenderingFontW + 15, 30, themeData.Colors.hudSurrenderingBackgroundColor )
    draw.SimpleText( ghi18n.GetPhrase( "surrendering" ), "GlorifiedHandcuffs.HUD.Surrendering", scrW / 2, 121, themeData.Colors.hudSurrenderingBackgroundTextColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

    draw.RoundedBox( 5, scrW / 2 - ( hitToFreeFontW + 15 ) / 2, 5 + 96 + 5 + 30 + 5, hitToFreeFontW + 15, 35, themeData.Colors.hudStopSurrenderingBackgroundColor )
    draw.SimpleText( hitToFreeText[1], "GlorifiedHandcuffs.HUD.StopSurrendering", scrW / 2 - ( hitToFreeFontW + 15 ) / 2 + 15, 158, themeData.Colors.hudStopSurrenderingBackgroundTextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
    draw.RoundedBox( 6, scrW / 2 - ( hitToFreeFontW + 15 ) / 2 + 10 + spamFontW, 5 + 96 + 5 + 33 + 5 + 3, 20, 22, themeData.Colors.hudStopSurrenderingKeypressBackgroundColor )
    draw.SimpleText( GlorifiedHandcuffs.Config.TOGGLE_SURRENDER_KEY_NAME, "GlorifiedHandcuffs.HUD.StopSurrendering", scrW / 2 - ( hitToFreeFontW + 15 ) / 2 + 15 + spamFontW, 158, themeData.Colors.hudStopSurrenderingKeypressTextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )

    draw.SimpleText( hitToFreeText[2], "GlorifiedHandcuffs.HUD.StopSurrendering", scrW / 2 - ( hitToFreeFontW + 15 ) / 2 + 15 + spamFontW + keyFontW, 158, themeData.Colors.hudStopSurrenderingBackgroundTextColor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER )
end )
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/cl_blur.lua:
local dofmat = Material("pp/dof")

function SWEP:BlurWeapon()
    if !ArcCW.ConVars["blur"]:GetBool() then return end
    local delta = self:GetSightDelta()
    if delta >= 1 then return end
    local vm = self:GetOwner():GetViewModel()
    render.UpdateScreenEffectTexture()
    render.ClearStencil()
    render.SetStencilEnable(true)
    render.SetStencilCompareFunction(STENCIL_ALWAYS)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilFailOperation(STENCIL_KEEP)
    render.SetStencilZFailOperation(STENCIL_REPLACE)
    render.SetStencilWriteMask(0xFF)
    render.SetStencilTestMask(0xFF)
    render.SetBlend(1)
    render.SetStencilReferenceValue(55)
    ArcCW.Overdraw = true
    vm:DrawModel()
    ArcCW.Overdraw = false
    render.SetBlend(0)
    render.SetStencilPassOperation(STENCIL_REPLACE)
    render.SetStencilCompareFunction(STENCIL_EQUAL)
    -- render.SetColorMaterial()
    dofmat:SetFloat("bluramount", 0.1 * (1 - delta))
    render.SetMaterial(dofmat)
    render.DrawScreenQuad()
    render.SetStencilEnable(false)
end

function SWEP:BlurNotWeapon()
    if !ArcCW.ConVars["blur"]:GetBool() then return end
    render.UpdateRefractTexture()
    DrawToyTown(3, ScrH())
end

function SWEP:DoToyTown()
    if !ArcCW.ConVars["blur_toytown"]:GetBool() then return end
    render.UpdateRefractTexture()
    DrawToyTown(3, ScrH() * 0.4 * (1 - self:GetSightDelta()))
end
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/sh_firing.lua:
function SWEP:CanPrimaryAttack()
    local owner = self:GetOwner()

    -- Should we not fire? But first.
    if self:GetBuff_Hook("Hook_ShouldNotFireFirst") then return end

    -- We're holstering
    if IsValid(self:GetHolster_Entity()) then return end
    if self:GetHolster_Time() > 0 then return end

    -- Disabled (currently used only by deploy)
    if self:GetState() == ArcCW.STATE_DISABLE then return end

    -- Coostimzing
    if self:GetState() == ArcCW.STATE_CUSTOMIZE then
        if CLIENT and ArcCW.Inv_Hidden then
            ArcCW.Inv_Hidden = false
            gui.EnableScreenClicker(true)
        elseif game.SinglePlayer() then
            -- Kind of ugly hack: in SP this is only called serverside so we ask client to do the same check
            self:CallOnClient("CanPrimaryAttack")
        end
        return
    end

    -- A priority animation is playing (reloading, cycling, firemode etc)
    if self:GetPriorityAnim() then return end

    -- Inoperable, but internally (burst resetting for example)
    if self:GetWeaponOpDelay() > CurTime() then return end

    -- Safety's on, dipshit
    if self:GetCurrentFiremode().Mode == 0 then
        self:ChangeFiremode(false)
        self:SetNextPrimaryFire(CurTime())
        self.Primary.Automatic = false
        return
    end

    -- If we are an NPC, do our own little methods
    if owner:IsNPC() then self:NPC_Shoot() return end

    -- If we are in a UBGL, shoot the UBGL, not the gun
    if self:GetInUBGL() then self:ShootUBGL() return end

    -- Too early, come back later.
    if self:GetNextPrimaryFire() >= CurTime() then return end

    -- Gun is locked from heat.
    if self:GetHeatLocked() then return end

    -- Attempting a bash
    if self:GetState() != ArcCW.STATE_SIGHTS and owner:KeyDown(IN_USE) or self.PrimaryBash then self:Bash() return end

    -- Throwing weapon
    if self.Throwing then self:PreThrow() return end

    -- Too close to a wall
    if self:BarrelHitWall() > 0 then return end

    -- Can't shoot while sprinting
    if self:GetNWState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return end

    -- Maximum burst shots
    if (self:GetBurstCount() or 0) >= self:GetBurstLength() then return end

    -- We need to cycle
    if self:GetNeedCycle() then return end

    -- If we have a trigger delay, make sure its progress is done
    if self:GetBuff_Override("Override_TriggerDelay", self.TriggerDelay) and ((!self:GetBuff_Override("Override_TriggerCharge", self.TriggerCharge) and self:GetTriggerDelta() < 1)
            or (self:GetBuff_Override("Override_TriggerCharge", self.TriggerCharge) and self:IsTriggerHeld())) then
        return
    end

    -- Should we not fire?
    if self:GetBuff_Hook("Hook_ShouldNotFire") then return end

    -- We made it
    return true
end

function SWEP:TakePrimaryAmmo(num)
    if self:HasBottomlessClip() or self:Clip1() <= 0 then
        if self:Ammo1() <= 0 then return end
        if self:HasInfiniteAmmo() then return end
        self:GetOwner():RemoveAmmo(num, self:GetPrimaryAmmoType())
    return end
    self:SetClip1(self:Clip1() - num)
end

function SWEP:ApplyRandomSpread(dir, spread)
    local radius = math.Rand(0, 1)
    local theta = math.Rand(0, math.rad(360))
    local bulletang = dir:Angle()
    local forward, right, up = bulletang:Forward(), bulletang:Right(), bulletang:Up()
    local x = radius * math.sin(theta)
    local y = radius * math.cos(theta)

    dir:Set(dir + right * spread * x + up * spread * y)
end
local vectorzero = Vector(0, 0, 0)
function SWEP:PrimaryAttack()
    local owner = self:GetOwner()

    self.Primary.Automatic = true

    if !self:CanPrimaryAttack() then return end

    local clip = self:Clip1()
    local aps = self:GetBuff("AmmoPerShot")

    if self:HasBottomlessClip() then
        clip = self:Ammo1()
        if self:HasInfiniteAmmo() then
            clip = math.huge
        end
    end

    if clip < aps then
        self:SetBurstCount(0)
        self:DryFire()

        self.Primary.Automatic = false

        return
    end

    local dir = (owner:EyeAngles() + self:GetFreeAimOffset()):Forward() --owner:GetAimVector()
    local src = self:GetShootSrc()






    self:GetBuff_Hook("Hook_PreFireBullets")


    local desyncnum = 0
    math.randomseed(math.Round(util.SharedRandom(self:GetBurstCount(), -1337, 1337, !game.SinglePlayer() and self:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (self:EntIndex() % 30241)) + desyncnum)

    self.Primary.Automatic = true

    local spread = ArcCW.MOAToAcc * self:GetBuff("AccuracyMOA")
    local disp = self:GetDispersion() * ArcCW.MOAToAcc / 10

    --dir:Rotate(Angle(0, ArcCW.StrafeTilt(self), 0))
    --dir = dir + VectorRand() * disp

    self:ApplyRandomSpread(dir, disp)

    local delay = self:GetFiringDelay()

    local curtime = CurTime()
    local curatt = self:GetNextPrimaryFire()
    local diff = curtime - curatt

    if diff > engine.TickInterval() or diff < 0 then
        curatt = curtime
    end

    self:SetNextPrimaryFire(curatt + delay)
    self:SetNextPrimaryFireSlowdown(curatt + delay) -- shadow for ONLY fire time

    local num = self:GetBuff("Num")

    num = num + self:GetBuff_Add("Add_Num")

    local tracer = self:GetBuff_Override("Override_Tracer", self.Tracer)
    local tracernum = self:GetBuff_Override("Override_TracerNum", self.TracerNum)
    local lastout = self:GetBuff_Override("Override_TracerFinalMag", self.TracerFinalMag)
    if lastout >= clip then
        tracernum = 1
        tracer = self:GetBuff_Override("Override_TracerFinal", self.TracerFinal) or self:GetBuff_Override("Override_Tracer", self.Tracer)
    end
    local dmgtable = self.BodyDamageMults
    dmgtable = self:GetBuff_Override("Override_BodyDamageMults") or dmgtable

    -- drive by is cool
    src = ArcCW:GetVehicleFireTrace(self:GetOwner(), src, dir) or src

    local bullet      = {}
    bullet.Attacker   = owner
    bullet.Dir        = dir
    bullet.Src        = src
    bullet.Spread     = vectorzero --Vector(spread, spread, spread)
    bullet.Damage     = 0
    bullet.Num        = num

    local sglove = math.ceil(num / 3)
    bullet.Force      = self:GetBuff("Force", true) or math.Clamp( ( (50 / sglove) / ( (self:GetBuff("Damage") + self:GetBuff("DamageMin")) / (self:GetBuff("Num") * 2) ) ) * sglove, 1, 3 )
                        -- Overperforming weapons get the jerf, underperforming gets boost
    bullet.Distance   = self:GetBuff("Distance", true) or 33300
    -- Setting AmmoType makes the engine look for the tracer effect on the ammo instead of TracerName!
    --bullet.AmmoType   = self.Primary.Ammo
    bullet.HullSize   = self:GetBuff("HullSize")
    bullet.Tracer     = tracernum or 0
    bullet.TracerName = tracer
    bullet.Weapon     = self
    bullet.Callback = function(att, tr, dmg)
        ArcCW:BulletCallback(att, tr, dmg, self)
    end

    local shootent = self:GetBuff("ShootEntity", true) --self:GetBuff_Override("Override_ShootEntity", self.ShootEntity)
    local shpatt   = self:GetBuff_Override("Override_ShotgunSpreadPattern", self.ShotgunSpreadPattern)
    local shpattov = self:GetBuff_Override("Override_ShotgunSpreadPatternOverrun", self.ShotgunSpreadPatternOverrun)

    local extraspread = AngleRand() * self:GetDispersion() * ArcCW.MOAToAcc / 10

    local projectiledata = {}

    if shpatt or shpattov or shootent then
        if shootent then
            projectiledata.ent = shootent
            projectiledata.vel = self:GetBuff("MuzzleVelocity")
        end

        bullet = self:GetBuff_Hook("Hook_FireBullets", bullet)

        if !bullet then return end

        local doent = shootent and num or bullet.Num
        local minnum = shootent and 1 or 0

        if doent > minnum then
            for n = 1, bullet.Num do
                bullet.Num = 1

                local dispers = self:GetBuff_Override("Override_ShotgunSpreadDispersion", self.ShotgunSpreadDispersion)
                local offset  = self:GetShotgunSpreadOffset(n)
                local calcoff = dispers and (offset * self:GetDispersion() * ArcCW.MOAToAcc / 10) or offset

                local ang = owner:EyeAngles() + self:GetFreeAimOffset()
                local ang2 = Angle(ang)
                ang2:RotateAroundAxis(ang:Right(), -1 * calcoff.p)
                ang2:RotateAroundAxis(ang:Up(), calcoff.y)
                ang2:RotateAroundAxis(ang:Forward(), calcoff.r)

                if !self:GetBuff_Override("Override_NoRandSpread", self.NoRandSpread) then -- Needs testing
                    ang2 = ang2 + AngleRand() * spread / 5
                end

                if shootent then
                    projectiledata.ang = ang2

                    self:DoPrimaryFire(true, projectiledata)
                else
                    bullet.Dir = ang2:Forward()

                    self:DoPrimaryFire(false, bullet)
                end
            end
        elseif shootent then
            local ang = owner:EyeAngles() + self:GetFreeAimOffset()

            if !self:GetBuff_Override("Override_NoRandSpread", self.NoRandSpread) then
               -- ang = (dir + VectorRand() * spread / 5):Angle()

                local newdir = Vector(dir)
                self:ApplyRandomSpread(newdir, spread / 5)
                ang = newdir:Angle()
            end

            projectiledata.ang = ang

            self:DoPrimaryFire(true, projectiledata)
        end
    else
        if !bullet then return end

        for n = 1, bullet.Num do
            bullet.Num = 1
            local dirry = Vector(dir.x, dir.y, dir.z)
          --  math.randomseed(math.Round(util.SharedRandom(n, -1337, 1337, !game.SinglePlayer() and self:GetOwner():GetCurrentCommand():CommandNumber() or CurTime()) * (self:EntIndex() % 30241)) + desyncnum)
            if !self:GetBuff_Override("Override_NoRandSpread", self.NoRandSpread) then
                self:ApplyRandomSpread(dirry, spread)
                bullet.Dir = dirry
            end
            bullet = self:GetBuff_Hook("Hook_FireBullets", bullet) or bullet

            self:DoPrimaryFire(false, bullet)
        end
    end

    self:DoRecoil()

    self:SetNthShot(self:GetNthShot() + 1)

    owner:DoAnimationEvent(self:GetBuff_Override("Override_AnimShoot") or self.AnimShoot)

    local shouldsupp = SERVER and !game.SinglePlayer()

    if shouldsupp then SuppressHostEvents(owner) end

    self:DoEffects()

    self:SetBurstCount(self:GetBurstCount() + 1)

    self:TakePrimaryAmmo(aps)

    self:DoShootSound()
    self:DoPrimaryAnim()

    if self:GetCurrentFiremode().Mode < 0 and self:GetBurstCount() == self:GetBurstLength() then
        local postburst = (self:GetCurrentFiremode().PostBurstDelay or 0)
        self:SetWeaponOpDelay(CurTime() + postburst * self:GetBuff_Mult("Mult_PostBurstDelay") + self:GetBuff_Add("Add_PostBurstDelay"))
    end

    if (self:GetIsManualAction()) and !(self.NoLastCycle and self:Clip1() == 0) then
        local fireanim = self:GetBuff_Hook("Hook_SelectFireAnimation") or self:SelectAnimation("fire")
        local firedelay = self.Animations[fireanim].MinProgress or 0
        self:SetNeedCycle(true)
        self:SetWeaponOpDelay(CurTime() + (firedelay * self:GetBuff_Mult("Mult_CycleTime")))
        self:SetNextPrimaryFire(CurTime() + 0.1)
    end

    self:ApplyAttachmentShootDamage()

    self:AddHeat(self:GetBuff("HeatGain"))



    if self:GetCurrentFiremode().Mode == 1 then
        self.LastTriggerTime = -1 -- Cannot fire again until trigger released
        self.LastTriggerDuration = 0
    end

    self:GetBuff_Hook("Hook_PostFireBullets")

    if shouldsupp then SuppressHostEvents(nil) end
end

function SWEP:TryBustDoor(ent, dmg)
    ArcCW.TryBustDoor(ent, dmg)
end

function SWEP:DoShootSound(sndoverride, dsndoverride, voloverride, pitchoverride)
    local fsound = self.ShootSound
    local suppressed = self:GetBuff_Override("Silencer")

    if suppressed then
        fsound = self.ShootSoundSilenced
    end

    local firstsound = self.FirstShootSound

    if self:GetBurstCount() == 1 and firstsound then
        fsound = firstsound

        local firstsil = self.FirstShootSoundSilenced

        if suppressed then
            fsound = firstsil and firstsil or self.ShootSoundSilenced
        end
    end

    local lastsound = self.LastShootSound

    local clip = self:Clip1()

    if clip == 1 and lastsound then
        fsound = lastsound

        local lastsil = self.LastShootSoundSilenced

        if suppressed then
            fsound = lastsil and lastsil or self.ShootSoundSilenced
        end
    end

    fsound = self:GetBuff_Hook("Hook_GetShootSound", fsound)

    local distancesound = self.DistantShootSound

    if suppressed then
        distancesound = self.DistantShootSoundSilenced
    end

    distancesound = self:GetBuff_Hook("Hook_GetDistantShootSound", distancesound)

    local spv = self.ShootPitchVariation
    local volume = self.ShootVol
    local pitch  = self.ShootPitch * math.Rand(1 - spv, 1 + spv) * self:GetBuff_Mult("Mult_ShootPitch")

    local v = ArcCW.ConVars["weakensounds"]:GetFloat()

    volume = volume - v

    volume = volume * self:GetBuff_Mult("Mult_ShootVol")

    volume = math.Clamp(volume, 51, 149)
    pitch  = math.Clamp(pitch, 0, 255)

    if    sndoverride        then    fsound    = sndoverride end
    if    dsndoverride    then    distancesound = dsndoverride end
    if    voloverride        then    volume    = voloverride end
    if    pitchoverride    then    pitch    = pitchoverride end

    if distancesound then self:MyEmitSound(distancesound, 149, pitch, 0.5, CHAN_WEAPON + 1) end

    if fsound then self:MyEmitSound(fsound, volume, pitch, 1, CHAN_WEAPON) end

    local data = {
        sound   = fsound,
        volume  = volume,
        pitch   = pitch,
    }

    self:GetBuff_Hook("Hook_AddShootSound", data)
end

function SWEP:GetMuzzleVelocity()
    local vel = self:GetBuff_Override("Override_PhysBulletMuzzleVelocity", self.PhysBulletMuzzleVelocity)

    if !vel then
        vel = self:GetBuff("Range") * 3.5

        if self:GetBuff("DamageMin") > self:GetBuff("Damage") then
            vel = vel * 2
        end
        vel = math.Clamp(vel, 200, 1000)
    end

    vel = vel / ArcCW.HUToM

    vel = vel * self:GetBuff_Mult("Mult_PhysBulletMuzzleVelocity")

    vel = vel * ArcCW.ConVars["bullet_velocity"]:GetFloat()

    return vel
end

function SWEP:DoPrimaryFire(isent, data)
    local clip = self:Clip1()
    if self:HasBottomlessClip() then
        if !self:GetOwner():IsPlayer() then
            clip = math.huge
        else
            clip = self:Ammo1()
        end
    end
    local owner = self:GetOwner()

    local shouldphysical = ArcCW.ConVars["bullet_enable"]:GetBool()

    if self.AlwaysPhysBullet or self:GetBuff_Override("Override_AlwaysPhysBullet") then
        shouldphysical = true
    end

    if self.NeverPhysBullet or self:GetBuff_Override("Override_NeverPhysBullet") then
        shouldphysical = false
    end

    if isent then
        self:FireRocket(data.ent, data.vel, data.ang, self.PhysBulletDontInheritPlayerVelocity)
    else
        -- if !game.SinglePlayer() and !IsFirstTimePredicted() then return end
        if !IsFirstTimePredicted() then return end

        if shouldphysical then
            local tracernum = data.Tracer or 1
            local phystracer = self:GetBuff_Override("Override_PhysTracerProfile", self.PhysTracerProfile)
            local lastout = self:GetBuff_Override("Override_TracerFinalMag", self.TracerFinalMag)
            if lastout >= self:Clip1() then
                phystracer = self:GetBuff_Override("Override_PhysTracerProfileFinal", self.PhysTracerProfileFinal) or phystracer
            elseif tracernum == 0 or clip % tracernum != 0 then
                phystracer = 7
            end

            local vel = self:GetMuzzleVelocity()

            vel = vel * data.Dir:GetNormalized()

            ArcCW:ShootPhysBullet(self, data.Src, vel, phystracer or 0)
        else
            owner:FireBullets(data, true)
        end
    end
end

function SWEP:DoPrimaryAnim()
    local anim = "fire"

    local inbipod = self:InBipod()
    local iron    = self:GetState() == ArcCW.STATE_SIGHTS

    -- Needs testing
    if inbipod then
        anim = self:SelectAnimation("fire_bipod") or self:SelectAnimation("fire") or anim
    else
        anim = self:SelectAnimation("fire") or anim
    end

    if (self.ProceduralIronFire and iron) or (self.ProceduralRegularFire and !iron) then anim = nil end

    anim = self:GetBuff_Hook("Hook_SelectFireAnimation", anim) or anim

    local time = self:GetBuff_Mult("Mult_FireAnimTime", anim) or 1

    if anim then self:PlayAnimation(anim, time, true, 0, false) end
end

function SWEP:DoPenetration(tr, penleft, alreadypenned)
    local bullet = {
        Damage = self:GetDamage((tr.HitPos - tr.StartPos):Length() * ArcCW.HUToM),
        DamageType = self:GetBuff_Override("Override_DamageType") or self.DamageType,
        Weapon = self,
        Penetration = self:GetBuff("Penetration"),
        Attacker = self:GetOwner(),
        Travelled = (tr.HitPos - tr.StartPos):Length()
    }

    ArcCW:DoPenetration(tr, bullet.Damage, bullet, penleft, false, alreadypenned)
end

function SWEP:GetFiringDelay()
    local delay = (self.Delay * (1 / self:GetBuff_Mult("Mult_RPM")))
    delay = self:GetBuff_Hook("Hook_ModifyRPM", delay) or delay

    return delay
end

function SWEP:GetShootSrc()
    local owner = self:GetOwner()

    if !IsValid(owner) then return self:GetPos() end
    if owner:IsNPC() then return owner:GetShootPos() end

    local dir    = owner:EyeAngles()
    local offset = Vector(0, 0, 0)

    if self:GetOwner():Crouching() then
        offset = self:GetBuff_Override("Override_BarrelOffsetCrouch") or self.BarrelOffsetCrouch or offset
    end

    if self:GetNWState() == ArcCW.STATE_SIGHTS then
        offset = LerpVector(self:GetNWSightDelta(), offset, self:GetBuff_Override("Override_BarrelOffsetSighted", self.BarrelOffsetSighted) or offset)
    else
        offset = LerpVector(1 - self:GetNWSightDelta(), offset, self:GetBuff_Override("Override_BarrelOffsetHip", self.BarrelOffsetHip) or offset)
    end

    local src = owner:EyePos()


    src = src + dir:Right()   * offset[1]
    src = src + dir:Forward() * offset[2]
    src = src + dir:Up()      * offset[3]

    return src
end

function SWEP:GetShotgunSpreadOffset(num)
    local rotate = Angle()
    local spreadpt = self:GetBuff_Override("Override_ShotgunSpreadPattern") or self.ShotgunSpreadPattern or {}
    local spreadov = self:GetBuff_Override("Override_ShotgunSpreadPatternOverrun") or self.ShotgunSpreadPatternOverrun or { Angle() }

    if istable(spreadpt) and istable(spreadov) then
        spreadpt["BaseClass"] = nil
        spreadov["BaseClass"] = nil

        if num > #spreadpt then
            if spo then
                num = num - #spreadpt
                num = math.fmod(num, #spreadov) + 1
                rotate = spreadov[num]
            else
                num = math.fmod(num, #spreadpt) + 1
                rotate = spreadpt[num]
            end
        else
            rotate = spreadpt[num]
        end
    end

    local rottoang = {}
    rottoang.num = num
    rottoang.ang = rotate

    rotate = self:GetBuff_Hook("Hook_ShotgunSpreadOffset", rottoang).ang

    return rotate or Angle()
end

function SWEP:GetDispersion()
    local owner = self:GetOwner()

    if vrmod and vrmod.IsPlayerInVR(owner) then return 0 end

    local hipdisp = self:GetBuff("HipDispersion")
    local sights  = self:GetState() == ArcCW.STATE_SIGHTS

    local hip = hipdisp

    local sightdisp = self:GetBuff("SightsDispersion")
    if sights then hip = Lerp(self:GetNWSightDelta(), sightdisp, hipdisp) end

    local speed = owner:GetAbsVelocity():Length()
    local maxspeed = owner:GetWalkSpeed() * self:GetBuff("SpeedMult")
    if sights then maxspeed = maxspeed * self:GetBuff("SightedSpeedMult") end
    speed = math.Clamp(speed / maxspeed, 0, 2)

    if owner:OnGround() or owner:WaterLevel() > 0 and owner:GetMoveType() != MOVETYPE_NOCLIP then
        hip = hip + speed * self:GetBuff("MoveDispersion")
    elseif owner:GetMoveType() != MOVETYPE_NOCLIP then
        hip = hip + math.max(speed * self:GetBuff("MoveDispersion"), self:GetBuff("JumpDispersion"))
    end

    if self:InBipod() then hip = hip * (self.BipodDispersion * self:GetBuff_Mult("Mult_BipodDispersion")) end

    if ArcCW.ConVars["mult_crouchdisp"]:GetFloat() != 1 and owner:OnGround() and owner:Crouching() then
        hip = hip * ArcCW.ConVars["mult_crouchdisp"]:GetFloat()
    end

    if ArcCW.ConVars["freeaim"]:GetInt() == 1 and !sights then
        hip = hip ^ 0.9
    end

    --local t = hook.Run("ArcCW_ModDispersion", self, {dispersion = hip})
    --hip = t and t.dispersion or hip
    hip = self:GetBuff_Hook("Hook_ModDispersion", hip) or hip

    return hip
end

function SWEP:DoShellEject(atti)

end

function SWEP:DoEffects(att)
    if !game.SinglePlayer() and !IsFirstTimePredicted() then return end


end

function SWEP:DryFire()

    if self.Animations.fire_dry then
        return self:PlayAnimation("fire_dry", 1, true, 0, true)
    end
    self:MyEmitSound(self.ShootDrySound or "weapons/arccw/dryfire.wav", 75, 100, 1, CHAN_ITEM)
    self:SetNextPrimaryFire(CurTime() + 0.25)
end

function SWEP:DoRecoil()
    local single = game.SinglePlayer()

    if !single and !IsFirstTimePredicted() then return end

    if single and self:GetOwner():IsValid() and SERVER then self:CallOnClient("DoRecoil") end

    -- math.randomseed(self:GetBurstLength() + (self.Recoil * 409) + (self.RecoilSide * 519))

    local rec = {
        Recoil = 1,
        RecoilSide = 1,
        VisualRecoilMul = 1
    }
    rec = self:GetBuff_Hook("Hook_ModifyRecoil", rec) or rec

    local recoil = rec.Recoil
    local side   = rec.RecoilSide
    local visual = rec.VisualRecoilMul

    local rmul = (recoil or 1) * self:GetBuff_Mult("Mult_Recoil")
    local recv = (visual or 1) * self:GetBuff_Mult("Mult_VisualRecoilMult")
    local recs = (side or 1)   * self:GetBuff_Mult("Mult_RecoilSide")

    -- local rrange = math.Rand(-recs, recs) * self.RecoilSide

    -- local irec = math.Rand(rrange - 1, rrange + 1)
    -- local recu = math.Rand(0.5, 1)

    local irec = math.Rand(-1, 1)
    local recu = 1

    if self:InBipod() then
        local b = self.BipodRecoil * self:GetBuff_Mult("Mult_BipodRecoil")

        rmul = rmul * b
        recs = recs * b
        recv = recv * b
    end

    local recoiltbl = self:GetBuff_Override("Override_ShotRecoilTable") or self.ShotRecoilTable

    if recoiltbl and recoiltbl[self:GetBurstCount()] then rmul = rmul * recoiltbl[self:GetBurstCount()] end

    if ArcCW.ConVars["mult_crouchrecoil"]:GetFloat() != 1 and self:GetOwner():OnGround() and self:GetOwner():Crouching() then
        rmul = rmul * ArcCW.ConVars["mult_crouchrecoil"]:GetFloat()
    end

    local punch = Angle()

    punch = punch + (self:GetBuff_Override("Override_RecoilDirection", self.RecoilDirection) * math.max(self.Recoil, 0.25) * recu * recv * rmul)
    punch = punch + (self:GetBuff_Override("Override_RecoilDirectionSide", self.RecoilDirectionSide) * math.max(self.RecoilSide, 0.25) * irec * recv * rmul)
    punch = punch + Angle(0, 0, 90) * math.Rand(-1, 1) * math.Clamp(self.Recoil, 0.25, 1) * recv * rmul * 0.01
    punch = punch * (self.RecoilPunch or 1) * self:GetBuff_Mult("Mult_RecoilPunch")

    self:SetFreeAimAngle(self:GetFreeAimAngle() - punch)

    if CLIENT then self:OurViewPunch(punch) end

    if CLIENT or single then
        recv = recv * self.VisualRecoilMult

        self.RecoilAmount     = self.RecoilAmount + (self.Recoil * rmul * recu)
        self.RecoilAmountSide = self.RecoilAmountSide + (self.RecoilSide * irec * recs * rmul)
        self.RecoilPunchBack  = math.Clamp(self.RecoilAmount * recv * 5, 1, 5)

        if self.MaxRecoilBlowback > 0 then
            self.RecoilPunchBack = math.Clamp(self.RecoilPunchBack, 0, self.MaxRecoilBlowback)
        end

        self.RecoilPunchSide = self.RecoilSide * 0.1 * irec * recv * rmul
        self.RecoilPunchUp   = self.RecoilRise * 0.1 * recu
    end

    -- math.randomseed(CurTime() + (self:EntIndex() * 3))
end

function SWEP:GetBurstLength()
    local clip = self:Clip1()
    if self:HasBottomlessClip() then
        clip = self:Ammo1()
        if self:HasInfiniteAmmo() then
            clip = math.huge
        end
    end
    --if clip == 0 then return 1 end

    local len = self:GetCurrentFiremode().Mode

    if !len then return self:GetBurstCount() + 10 end

    local hookedlen = self:GetBuff_Hook("Hook_GetBurstLength", len)

    if len == 1 then return 1 end
    if len >= 2 then return self:GetBurstCount() + 10 end

    if hookedlen != len then return hookedlen end

    if len < 0 then return -len end

    return self:GetBurstCount() + 10
end

function SWEP:FireAnimationEvent(pos, ang, event, options)
    return true
end

function SWEP:IsRampupWeapon()
    local ovr = self:GetBuff_Override("Override_IsRampupWeapon")
    if ovr != nil then return ovr end
    return self:GetBuff("Damage") < self:GetBuff("DamageMin")
end

function SWEP:GetMinMaxRange()
    local decrease = !self:IsRampupWeapon()

    local min = self:GetBuff_Override("Override_RangeMin", self.RangeMin or 0)
    local max = self:GetBuff_Override("Override_Range", self.Range)
    local min_add = self:GetBuff_Add("Add_RangeMin")
    local max_add = self:GetBuff_Add("Add_Range")
    local min_mult = self:GetBuff_Mult("Mult_RangeMin")
    local max_mult = self:GetBuff_Mult("Mult_Range")

    if decrease then
        -- MinRange is also affected by Mult_Range, this is intentional
        local total_min = math.max((min + min_add) * min_mult * max_mult, 0)
        return total_min, math.max((max + max_add) * max_mult, total_min)
    else
        -- For "rampup weapons" (dmgmin > dmg), range buffs *decrease* range, as it ramps up damage quicker
        -- After all, +Range is supposed to be a positive buff no matter the kind of gun
        local total_min = math.max((min - min_add) / min_mult / max_mult, 0)
        return total_min, math.max((max - max_add) / max_mult, total_min)
    end
end

function SWEP:GetRangeFraction(range)
    local min, max = self:GetMinMaxRange()
    if range < min then
        return 0
    else
        return math.Clamp((range - min) / (max - min), 0, 1)
    end
end

function SWEP:GetDamage(range, pellet)
    local ovr = self:GetBuff_Override("Override_Num")
    local add = self:GetBuff_Add("Add_Num")
    local mul = self:GetBuff_Mult("Mult_Num")

    local num = self.Num
    local nbr = (ovr or num) * mul + add
    local factor = 1

    -- Total damage should be unchanged regardless of whether the weapon originally fired 1 pellet or > 1
    -- If pellet is set, we return per-pellet damage instead of total damage
    if pellet and num == 1 then
        factor = 1 / ((ovr or 1) * mul + add)
    elseif num != nbr then
        factor = num / nbr
    end

    --factor = ((pellet and num == 1) and (1 / ((ovr or 1) + add))) or ((num != nbr) and (num / nbr)) or 1

    if !pellet then factor = factor * nbr end

    local dmgmax = self:GetBuff("Damage") * factor
    local dmgmin = self:GetBuff("DamageMin") * factor
    local delta = self:GetRangeFraction(range)

    local lerped = Lerp(delta, dmgmax, dmgmin)

    return lerped
end

function SWEP:SecondaryAttack()
    return self.Melee2 and self:Bash(true)
end

function SWEP:CanShootWhileSprint()
    return ArcCW.ConVars["mult_shootwhilesprinting"]:GetBool() or self:GetBuff_Override("Override_ShootWhileSprint", self.ShootWhileSprint)
end

--addons/[binbon]arccw_modify/lua/weapons/arccw_base/sh_grenade.lua:
SWEP.GrenadePrimeTime = 0

function SWEP:PreThrow()

    if self:GetNWState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return end

    local bot, inf = self:HasBottomlessClip(), self:HasInfiniteAmmo()
    local aps = self:GetBuff("AmmoPerShot")

    if !inf and (bot and self:Ammo1() or self:Clip1()) < aps then
        if self:Ammo1() == 0 and self:Clip1() == 0 and !self:GetBuff_Override("Override_KeepIfEmpty", self.KeepIfEmpty) then
            self:GetOwner():StripWeapon(self:GetClass())
        end
        return
    end

    if self:GetGrenadePrimed() then return end

    if engine.ActiveGamemode() == "terrortown" and GetRoundState and GetRoundState() == ROUND_PREP and
        ((GetConVar("ttt_no_nade_throw_during_prep") and GetConVar("ttt_no_nade_throw_during_prep"):GetBool())
            or (GetConVar("ttt_nade_throw_during_prep") and !GetConVar("ttt_nade_throw_during_prep"):GetBool())) then
        return
    end

    self.GrenadePrimeTime = CurTime()
    local alt = self:GetOwner():KeyDown(IN_ATTACK2)
    self:SetGrenadeAlt(alt)
    self:SetGrenadePrimed(true)

    local pulltime = self:GetBuff("PullPinTime")
    local anim = alt and self:SelectAnimation("pre_throw_alt") or self:SelectAnimation("pre_throw")
    self:PlayAnimation(anim, self.PullPinTime / pulltime, true, 0, true, nil, true)

    self.isCooked = (!alt and self:GetBuff("CookPrimFire", true)) or (alt and self:GetBuff("CookAltFire", true)) or nil

    self:SetNextPrimaryFire(CurTime() + pulltime)
    self:SetPriorityAnim(CurTime() + pulltime)

    self:SetShouldHoldType()

    self:GetBuff_Hook("Hook_PreThrow")

    if pulltime == 0 then
        self:Throw()
        return
    end
end

function SWEP:Throw()
    if self:GetNextPrimaryFire() > CurTime() then return end

    local isCooked = self.isCooked
    self:SetGrenadePrimed(false)
    self.isCooked = nil

    local alt = self:GetGrenadeAlt()

    local anim = alt and self:SelectAnimation("throw_alt") or self:SelectAnimation("throw")
    self:PlayAnimation(anim, self:GetBuff_Mult("Mult_ThrowTime"), false, 0, true)

    local animevent = alt and self:GetBuff_Override("Override_AnimShootAlt", self.AnimShootAlt) or self:GetBuff_Override("Override_AnimShoot", self.AnimShoot)
    self:GetOwner():DoAnimationEvent(animevent)

    local heldtime = CurTime() - self.GrenadePrimeTime

    local mv = 0

    if alt then
        mv = self:GetBuff("MuzzleVelocityAlt", true) or self:GetBuff("MuzzleVelocity")
    else
        mv = self:GetBuff("MuzzleVelocity")
        local chg = self:GetBuff("WindupTime")
        if chg > 0 then
            mv = Lerp(math.Clamp(heldtime / chg, 0, 1), mv * self:GetBuff("WindupMinimum"), mv)
        end
    end

    local force = mv * ArcCW.HUToM

    self:SetTimer(self:GetBuff("ShootEntityDelay"), function()

        local ft = self:GetBuff("FuseTime", true)
        local data = {
            dodefault = true,
            force = force,
            shootentity = self:GetBuff_Override("Override_ShootEntity", self.ShootEntity),
            fusetime = ft and (ft - (isCooked and heldtime or 0)),
        }
        local ovr = self:GetBuff_Hook("Hook_Throw", data)
        if !ovr or ovr.dodefault then
            local rocket = self:FireRocket(self:GetBuff_Override("Override_ShootEntity", self.ShootEntity), force / ArcCW.HUToM)
            if !rocket then return end

            if ft then
                if isCooked then
                    rocket.FuseTime = ft - heldtime
                else
                    rocket.FuseTime = ft
                end
            else
                rocket.FuseTime = math.huge
            end

            local phys = rocket:GetPhysicsObject()

            local inertia = self:GetBuff_Override("Override_ThrowInertia", self.ThrowInertia)
            if inertia == nil then inertia = ArcCW.ConVars["throwinertia"]:GetBool() end
            if inertia and mv > 100 then
                phys:AddVelocity(self:GetOwner():GetVelocity())
            end

            phys:AddAngleVelocity( Vector(0, 750, 0) )
        end
        if !self:HasInfiniteAmmo() then
            local aps = self:GetBuff("AmmoPerShot")
            local a1 = self:Ammo1()
            if self:HasBottomlessClip() or a1 >= aps then
                self:TakePrimaryAmmo(aps)
            elseif a1 < aps then
                self:SetClip1(math.min(self:GetCapacity() + self:GetChamberSize(), self:Clip1() + a1))
                self:TakePrimaryAmmo(a1)
            end

            if (self.Singleton or self:Ammo1() == 0) and !self:GetBuff_Override("Override_KeepIfEmpty", self.KeepIfEmpty) then
                self:GetOwner():StripWeapon(self:GetClass())
                return
            end
        end

    end)
    local t = self:GetAnimKeyTime(anim) * self:GetBuff_Mult("Mult_ThrowTime")
    self:SetPriorityAnim(CurTime() + t)
    self:SetTimer(t, function()
        if !self:IsValid() then return end
        local a = self:SelectAnimation("reload") or self:SelectAnimation("draw")
        self:PlayAnimation(a, self:GetBuff_Mult("Mult_ReloadTime"), true, 0, nil, nil, true)
        self:SetPriorityAnim(CurTime() + self:GetAnimKeyTime(a, true) * self:GetBuff_Mult("Mult_ReloadTime"))
    end)

    self:SetNextPrimaryFire(CurTime() + self:GetFiringDelay())

    self:SetGrenadeAlt(false)

    self:SetShouldHoldType()

    self:GetBuff_Hook("Hook_PostThrow")
end

function SWEP:GrenadeDrop(doammo)
    local rocket = self:FireRocket(self.ShootEntity, 0)

    if IsValid(rocket) then
        local phys = rocket:GetPhysicsObject()

        if ArcCW.ConVars["throwinertia"]:GetBool() then
            phys:AddVelocity(self:GetOwner():GetVelocity())
        end

        local ft = self:GetBuff_Override("Override_FuseTime") or self.FuseTime

        if ft then
            if self.isCooked then
                rocket.FuseTime = ft - (CurTime() - self.GrenadePrimeTime)
            else
                rocket.FuseTime = ft
            end
        end
    end

    if doammo then
        if !self:HasInfiniteAmmo() then
            local aps = self:GetBuff("AmmoPerShot")
            local a1 = self:Ammo1()
            if self:HasBottomlessClip() or a1 >= aps then
                self:TakePrimaryAmmo(aps)
            elseif a1 < aps then
                self:SetClip1(math.min(self:GetCapacity() + self:GetChamberSize(), self:Clip1() + a1))
                self:TakePrimaryAmmo(a1)
            end

            if (self.Singleton or self:Ammo1() == 0) and !self:GetBuff_Override("Override_KeepIfEmpty", self.KeepIfEmpty) then
                self:GetOwner():StripWeapon(self:GetClass())
                return
            end
        end

        self:SetNextPrimaryFire(CurTime() + 1)
        self:SetGrenadePrimed(false)
    end
end
--addons/[binbon]arccw_modify/lua/weapons/arccw_base/sh_ubgl.lua:

function SWEP:SelectUBGL()
    if !self:GetBuff_Override("UBGL") then return end
    if self:GetReloading() then return end
    if self:GetNextPrimaryFire() > CurTime() then return end
    if self:GetNextSecondaryFire() > CurTime() then return end
    if self:GetUBGLDebounce() then return end
    self:SetUBGLDebounce( true )

    self:SetInUBGL(true)

    self:SetFireMode(1)

    if CLIENT and (game.SinglePlayer() or (!game.SinglePlayer() and IsFirstTimePredicted())) then
        -- if !ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        --     self:GetOwner():ChatPrint("Selected " .. self:GetBuff_Override("UBGL_PrintName") or "UBGL")
        -- end
        if !self:GetLHIKAnim() then
            self:DoLHIKAnimation("enter")
        end
        self:MyEmitSound( self:GetBuff_Override("SelectUBGLSound") or self.SelectUBGLSound )
    end

    if self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.enter_ubgl_empty and self:Clip2() == 0 then
        self:PlayAnimation("enter_ubgl_empty", 1, true)
        self:SetNextSecondaryFire(CurTime() + self:GetAnimKeyTime("enter_ubgl_empty"))
    elseif self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.enter_ubgl then
        self:PlayAnimation("enter_ubgl", 1, true)
        self:SetNextSecondaryFire(CurTime() + self:GetAnimKeyTime("enter_ubgl"))
    else
        self:PlayAnimationEZ("idle", 1, false)
        self:SetNextSecondaryFire(CurTime() + 0.1)
    end

    self:GetBuff_Hook("Hook_OnSelectUBGL")
end

function SWEP:DeselectUBGL()
    if !self:GetInUBGL() then return end
    if self:GetReloading() then return end
    if self:GetNextPrimaryFire() > CurTime() then return end
    if self:GetNextSecondaryFire() > CurTime() then return end
    if self:GetUBGLDebounce() then return end
    self:SetUBGLDebounce( true )

    self:SetInUBGL(false)

    if CLIENT and (game.SinglePlayer() or (!game.SinglePlayer() and IsFirstTimePredicted())) then
        -- if !ArcCW:ShouldDrawHUDElement("CHudAmmo") then
        --     self:GetOwner():ChatPrint("Deselected " .. self:GetBuff_Override("UBGL_PrintName") or "UBGL")
        -- end
        if !self:GetLHIKAnim() and bong then
            self:DoLHIKAnimation("exit")
        end
        self:MyEmitSound( self:GetBuff_Override("ExitUBGLSound") or self.ExitUBGLSound )
    end

    if self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.exit_ubgl_empty and self:Clip2() == 0 then
        self:PlayAnimation("exit_ubgl_empty", 1, true)
    elseif self:GetBuff_Override("UBGL_BaseAnims") and self.Animations.exit_ubgl then
        self:PlayAnimation("exit_ubgl", 1, true)
    else
        self:PlayAnimationEZ("idle", 1, false)
        self:SetNextSecondaryFire(CurTime() + 0.1)
    end

    self:GetBuff_Hook("Hook_OnDeselectUBGL")
end

function SWEP:RecoilUBGL()
    local single = game.SinglePlayer()

    if !single and !IsFirstTimePredicted() then return end

    if single and self:GetOwner():IsValid() and SERVER then self:CallOnClient("RecoilUBGL") end

    local amt = self:GetBuff_Override("UBGL_Recoil")
    local amtside = self:GetBuff_Override("UBGL_RecoilSide") or (self:GetBuff_Override("UBGL_Recoil") * 0.5)
    local amtrise = self:GetBuff_Override("UBGL_RecoilRise") or 1

    local r = math.Rand(-1, 1)
    local ru = math.Rand(0.75, 1.25)

    local m = 1 * amt
    local rs = 1 * amtside
    local vsm = 1

    local vpa = Angle(0, 0, 0)

    vpa = vpa + (Angle(1, 0, 0) * amt * m * vsm)

    vpa = vpa + (Angle(0, 1, 0) * r * amtside * m * vsm)

    if CLIENT then
        self:OurViewPunch(vpa)
    end

    if CLIENT or game.SinglePlayer() then

        self.RecoilAmount = self.RecoilAmount + (amt * m)
        self.RecoilAmountSide = self.RecoilAmountSide + (r * amtside * m * rs)

        self.RecoilPunchBack = amt * 2.5 * m

        if self.MaxRecoilBlowback > 0 then
            self.RecoilPunchBack = math.Clamp(self.RecoilPunchBack, 0, self.MaxRecoilBlowback)
        end

        self.RecoilPunchSide = r * rs * m * 0.1 * vsm
        self.RecoilPunchUp = math.Clamp(ru * amt * m * 0.6 * vsm * amtrise, 0, 0.1)
    end
end

function SWEP:ShootUBGL()
    if self:GetNextSecondaryFire() > CurTime() then return end
    if self:GetState() == ArcCW.STATE_SPRINT and !self:CanShootWhileSprint() then return false end

    self.Primary.Automatic = self:GetBuff_Override("UBGL_Automatic")

    local ubglammo = self:GetBuff_Override("UBGL_Ammo")

    if self:Clip2() <= 0 and self:GetOwner():GetAmmoCount(ubglammo) <= 0 then
        self:DeselectUBGL()
        return
    end

    if self:Clip2() <= 0 then
        return
    end

    self:RecoilUBGL()

    local func, slot = self:GetBuff_Override("UBGL_Fire")

    if func then
        func(self, self.Attachments[slot].VElement)
    end

    self:SetNextSecondaryFire(CurTime() + (60 / self:GetBuff_Override("UBGL_RPM")))
end

function SWEP:ReloadUBGL()
    if self:GetNextSecondaryFire() > CurTime() then return end

    local reloadfunc, slot = self:GetBuff_Override("UBGL_Reload")

    if reloadfunc then
        reloadfunc(self, self.Attachments[slot].VElement)
    end
end

if SERVER then

function SWEP:DoLHIKAnimation(key, time)
    if game.SinglePlayer() then
        net.Start("arccw_sp_lhikanim")
        net.WriteString(key)
        net.WriteFloat(time or -1)
        net.Send(self:GetOwner())
    end
end

end
--lua/weapons/arccw_mcx.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Modern Warfare" -- edit this if you like
SWEP.AdminOnly = false

SWEP.PrintName = "M13 Virtus SBR"
SWEP.TrueName = "MCX Virtus SBR"
SWEP.Trivia_Class = "Assault Carbine"
SWEP.Trivia_Desc = "Automatic assault rifle featuring a short stroke piston system that keeps the fire rate high and the recoil low."
SWEP.Trivia_Manufacturer = "Tempus Armament"
SWEP.Trivia_Calibre = "5.56x45mm NATO"
SWEP.Trivia_Mechanism = "Short-stroke Piston"
SWEP.Trivia_Country = "USA & Germany"
SWEP.Trivia_Year = 2020

SWEP.Slot = 2

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "SIG SAUER"
end

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/c_mcxvirtus.mdl"
SWEP.WorldModel =  "models/weapons/w_mcxvirtus.mdl"
SWEP.ViewModelFOV = 75

SWEP.DefaultBodygroups = "00000"

SWEP.Damage = 34
SWEP.DamageMin = 23 -- damage done at maximum range
SWEP.Range = 200 -- in METRES
SWEP.Penetration = 8
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any
SWEP.MuzzleVelocity = 914 -- projectile or phys bullet muzzle velocity
-- IN M/S

SWEP.TracerNum = 1 -- tracer every X
SWEP.TracerCol = Color(255, 25, 25)
SWEP.TracerWidth = 3

SWEP.ChamberSize = 1 -- how many rounds can be chambered.
SWEP.Primary.ClipSize = 30 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 50
SWEP.ReducedClipSize = 20

SWEP.Recoil = 0.45
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0.55
SWEP.VisualRecoilMult = 0.4

SWEP.Delay = 60 / 900 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.AccuracyMOA = 3 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 115 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 135

SWEP.Primary.Ammo = "smg1" -- what ammo type the gun uses
SWEP.MagID = "stanag" -- the magazine pool this gun draws from

SWEP.ShootVol = 120 -- volume of shoot sound
SWEP.ShootPitch = 110 -- pitch of shoot sound

SWEP.FirstShootSound = "weapons/CoD MW 2k19/Virtus MCX/mcx_firing_single.wav"
SWEP.ShootSound = "weapons/CoD MW 2k19/Virtus MCX/mcx_firing.wav"
SWEP.DistantShootSound = "weapons/CoD MW 2k19/Virtus MCX/mcx_outdoor.wav"
SWEP.ShootSoundSilenced = "weapons/CoD MW 2k19/Virtus MCX/mcx_firingSil.wav"

SWEP.MuzzleEffect = "muzzleflash_m14"
SWEP.ShellModel = "models/shells/shell_556.mdl"
SWEP.ShellPitch = 110
SWEP.ShellRotate = 180
SWEP.ShellScale = 0.8

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.65

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    [1] = "bullet.bmp",
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.CaseBones = {}

SWEP.IronSightStruct = {
    Pos = Vector(-2.55, -3, 0.4),
    Ang = Angle(0, 0, 0.5),
    Magnification = 1.1,
    SwitchToSound = "", -- sound that plays when switching to this sight
}

SWEP.NPCWeaponType = "weapon_ar2"
SWEP.NPCWeight = 100

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(0, -2, 0)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.HolsterPos = Vector(3.5, 2, 0)
SWEP.HolsterAng = Angle(-7.036, 30.016, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 17

SWEP.AttachmentElements = {
    ["stuff"] = {
        VMBodygroups = {{ind = 1, bg = 1}, {ind = 2, bg = 2}},
        WMBodygroups = {{ind = 1, bg = 1}, {ind = 2, bg = 2}},
    },
    ["barrel"] = {
        VMBodygroups = {{ind = 3, bg = 1}, {ind = 2, bg = 1}},
        WMBodygroups = {{ind = 3, bg = 1}},
        AttPosMods = {
            [2] = {
                vpos = Vector(12, 0, 0),
            }
        }
    }
}

SWEP.ShellRotateAngle = Angle(180, 90, 0)

SWEP.ExtraSightDist = 6

SWEP.Attachments = {
    {
        PrintName = "Optic", -- print name
        DefaultAttName = "Iron Sights",
        Slot = {"optic","optic_sniper","optic_lp","mw_optic_lp"}, -- what kind of attachments can fit here, can be string or table
        Bone = "tag_weapon", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-5, -0, 1.7),
            vang = Angle(0, 0, 0),
            wpos = Vector(7.8, 0.78, -5.901),
            wang = Angle(171.817, 180-1.17, 0),
        },
        CorrectivePos = Vector(-0, 0, -0.01),
        CorrectiveAng = Angle(-0, 0, -0),
        InstalledEles = {"stuff"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(8, -0.01, 0.2),
            vang = Angle(0, 0, 0),
            wpos = Vector(20, 0.72, -6.2),
            wang = Angle(171.817, 180-1.17, 0),
        },
        VMScale = Vector(1.1, 1.1, 1.1),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip",},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2, -0.2, -0.7),
            vang = Angle(0, 0, 0),
            wpos = Vector(14, 0.74, -4),
            wang = Angle(171.817, 180-1.17, 0),
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(4, 0.5, 0.6),
            vang = Angle(0, 0, -90),
            wpos = Vector(15, 0.5, -5.8),
            wang = Angle(171.817, 180-1.17, -90),
        },
    },
    {
        PrintName = "Grip",
        Slot = "grip",
        DefaultAttName = "Standard Grip"
    },
    {
        PrintName = "Stock",
        Slot = "stock",
        DefaultAttName = "Standard Stock"
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = {"go_perk", "perk_mw"},
    },
    {
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon", -- relevant bone any attachments will be mostly referring to
        Offset = {
            vpos = Vector(-4, -0.45, 0),
            vang = Angle(0, -360, 0),
            wpos = Vector(6.2, 1.35, -4.2),
            wang = Angle(-10.393, 0, 180)
        },
        VMScale = Vector(1, 1, 1),
    },
}

SWEP.Animations = {
    ["draw"] = {
        Source = "draw",
        Time = 0.75,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
    },
    ["holster"] = {
        Source = "holster",
        Time = 0.75,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
    },
    ["deploy"] = {
        Source = "draw",
        Time = 0.75,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.25,
    },
    ["fire"] = {
        Source = "fire",
        Time = 0.5,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "idle",
        Time = 0.5,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        Time = 2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Checkpoints = {24, 60},
        FrameRate = 30,
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
        LastClip1OutTime = 1,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 3,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Checkpoints = {24, 60},
        FrameRate = 30,
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
        LastClip1OutTime = 1,
    },
    ["reload_soh"] = {
        Source = "reloadsoh",
        Time = 1.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Checkpoints = {24, 60},
        FrameRate = 30,
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
        LastClip1OutTime = 1,
    },
    ["reload_empty_soh"] = {
        Source = "reload_emptysoh",
        Time = 2,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        Checkpoints = {24, 60},
        FrameRate = 30,
        LHIK = true,
        LHIKIn = 0.5,
        LHIKOut = 0.5,
        LastClip1OutTime = 1,
    },
}

SWEP.WorldModelOffset = {
    pos        =    Vector(-4.7, 3.55, -5.8),
    ang        =    Angle(172, 179.5, 0),
    bone    =    "ValveBiped.Bip01_R_Hand",
    scale   =   1
}

DEFINE_BASECLASS( SWEP.Base )

sound.Add({
    name =	"ArcCW_MCX.Bolt",
    channel		= CHAN_ITEM,
    volume		= 0.9,
    sound		= "weapons/CoD MW 2k19/Virtus MCX/mcx_reload_bolt.wav"
})

sound.Add({
    name =	"ArcCW_MCX.Magout",
    channel		= CHAN_ITEM,
    volume		= 1,
    sound		= "weapons/CoD MW 2k19/Virtus MCX/mcx_reload_mag_out.wav"
})

sound.Add({
    name =	"ArcCW_MCX.Magin",
    channel		= CHAN_ITEM,
    volume		= 1,
    sound		= "weapons/CoD MW 2k19/Virtus MCX/mcx_reload_mag_in.wav"
})

sound.Add({
    name =	"ArcCW_MCX.Magin2",
    channel		= CHAN_ITEM,
    volume		= 1,
    sound		= "weapons/CoD MW 2k19/Virtus MCX/mcx_reload_mag_in_2.wav"
})

sound.Add({
    name =	"ArcCW_MCX.Maginsoh",
    channel		= CHAN_ITEM,
    volume		= 1,
    sound		= "weapons/CoD MW 2k19/Virtus MCX/mcx_reload_mag_insoh.wav"
})

sound.Add({
    name =	"ArcCW_MCX.deploy",
    channel		= CHAN_ITEM + 5,
    volume		= 1,
    sound		= "weapons/CoD MW 2k19/Virtus MCX/draw_mcx.wav"
})

sound.Add({
    name = 			"ArcCW_MCX.draw",
    channel = 		CHAN_ITEM,
    volume = 		1,
    sound = 			"weapons/CoD MW 2k19/Virtus MCX/draw_mcx.wav"
})

sound.Add({
    name = 			"ArcCW_MCX.holster",
    channel = 		CHAN_ITEM,
    volume = 		1,
    sound = 			"weapons/CoD MW 2k19/Virtus MCX/holster_mcx.wav"
})
--lua/weapons/arccw_mw2_deagle.lua:
return gluapack()()
--lua/weapons/arccw_mw2_l86.lua:
return gluapack()()
--lua/weapons/arccw_mw2_m1014.lua:
return gluapack()()
--lua/weapons/arccw_mw2_m16.lua:
return gluapack()()
--lua/weapons/arccw_mw2_m9.lua:
return gluapack()()
--lua/weapons/arccw_mw2_mp5n.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2 - Unofficial"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "MP5"
SWEP.Trivia_Class = "Sub Machine Gun"
SWEP.Trivia_Desc = "Fully automatic, close range.\nUnofficial."

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_slog_mp5n.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-7, 3, -5),
    ang = Angle(-7, 0, 180),
    scale = 1.25
}
SWEP.WorldModel = "models/weapons/w_smg_mp5.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 25
SWEP.DamageMin = 20
SWEP.Range = 750 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 3
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 45
SWEP.ReducedClipSize = 15

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 0.4
SWEP.RecoilSide = 0.35
SWEP.RecoilRise = 0

SWEP.Delay = 0.08 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.NPCWeaponType = {"weapon_ar2", "weapon_smg1"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 10 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 300 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 175

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 95 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/mp5n.wav"
SWEP.ShootMechSound =       ArcCW_MW2_Mech
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/mp5.wav"
SWEP.ShootDrySound =        "weapons/fesiugmw2/fire/dryfire_smg.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/mp5n_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_smg"
SWEP.ShellModel = "models/shells/shell_9mm.mdl"
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.80
SWEP.SightTime = 0.2

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.IronSightStruct = {
    Pos = Vector(-2.91, -3.79, 0.95),
    Ang = Angle(-0.278, 0.008, 0),
    ViewModelFOV = 65 / 1.18,
    Magnification = 1.18,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10.479, 0, -3.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["nors"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        WMBodygroups = {},
    },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.ExtraSightDist = 5

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic","optic_lp"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-4.7, 0, 2.7),
            vang = Angle(0, 0, 0),
            wpos = Vector(1.998, 0.17, -5.025),
            wang = Angle(-3.074, -23.004, -172.249)
        },
        SlideAmount = {
            vmin = Vector(1, 0, 3.9),
            vmax = Vector(6, 0, 3.9),
            wmin = Vector(5.36, 0.739, -5.401),
            wmax = Vector(5.36, 0.739, -5.401),
        },
        InstalledEles = {"nors"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(15, 0, 1.9),
            vang = Angle(0, 0, 0),
            wpos = Vector(12.057, 4.317, -3.858),
            wang = Angle(-3.074, -23.004, 0)
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "bipod", "style_pistol"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(9.5, 0, 1),
            vang = Angle(0, 0, 0),
            wpos = Vector(8.425, 2.96, -2.54),
            wang = Angle(-3.074, -23.004, -172.249)
        },
        SlideAmount = {
            vmin = Vector(7, 0, 1),
            vmax = Vector(12.5, 0, 1.5),
        },
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(8, -1.1, 2),
            vang = Angle(0, 0, 90),
            wpos = Vector(8.425, 3.891, -4.147),
            wang = Angle(-3.074, -23.004, -77.301)
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.5, -0.5, 1),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Hook_TranslateAnimation = function(wep, anim)
    if !wep.Attachments[3].Installed then
        return anim .. "_nofg"
    end
end

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 2/30,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 10/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 30/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 10/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 25/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready"] = {
        Source = "pullout_first_nofg",
        Time = 40/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_hit_v1.wav", 	t = 17/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
        LHIKEaseOut = 1.2,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 25/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["fire"] = {
        Source = "fire",
        Time = 7/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 7/30,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        Time = 75/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipout_v1.wav", 	t = 15/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 52/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_chamber_v1.wav", 	t = 9/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipout_v1.wav", 	t = 27/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 64/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_hit_v1.wav", 	t = 80/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
    },
-----------------------------------------------------
-----------------------------------------------------
    ["idle_nofg"] = {
        Source = "idle_nofg",
        Time = 2/30,
    },
    ["enter_sprint_nofg"] = {
        Source = "sprint_in_nofg",
        Time = 10/30
    },
    ["idle_sprint_nofg"] = {
        Source = "sprint_loop_nofg",
        Time = 30/40
    },
    ["exit_sprint_nofg"] = {
        Source = "sprint_out_nofg",
        Time = 10/30
    },
    ["draw_nofg"] = {
        Source = "pullout_nofg",
        Time = 25/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready_nofg"] = {
        Source = "pullout_first_nofg",
        Time = 40/30,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_hit_v1.wav", 	t = 17/30},
					},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster_nofg"] = {
        Source = "putaway_nofg",
        Time = 25/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["fire_nofg"] = {
        Source = "fire_nofg",
        Time = 7/30,
        ShellEjectAt = 0,
    },
    ["fire_iron_nofg"] = {
        Source = "fire_ads_nofg",
        Time = 7/30,
        ShellEjectAt = 0,
    },
    ["reload_nofg"] = {
        Source = "reload_nofg",
        Time = 75/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipout_v1.wav", 	t = 15/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 48/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
    },
    ["reload_empty_nofg"] = {
        Source = "reload_empty_nofg",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_chamber_v1.wav", 	t = 9/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipout_v1.wav", 	t = 27/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_clipin_v1.wav", 	t = 60/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_mp5k_reload_hit_v1.wav", 	t = 80/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
        LHIKEaseOut = 0.25,
    },
}
--lua/weapons/arccw_mw2_scar.lua:
return gluapack()()
--lua/weapons/arccw_mw2_striker.lua:
return gluapack()()
--lua/weapons/arccw_mw2_vector.lua:
SWEP.Base = "arccw_mw2_abase"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - MW2"
SWEP.AdminOnly = false
SWEP.WeaponCamBone = tag_camera

SWEP.PrintName = "Vector"
SWEP.Trivia_Class = "Sub Machine Gun"
SWEP.Trivia_Desc = "Fully automatic, high fire rate."

SWEP.Slot = 2

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/fesiugmw2/c_vector.mdl"
SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos = Vector(-4, 3, -5),
    ang = Angle(-10, 0, 180),
    scale = 1.25
}
SWEP.WorldModel = "models/weapons/w_smg_ump45.mdl"
SWEP.ViewModelFOV = 65

SWEP.Damage = 25
SWEP.DamageMin = 20
SWEP.Range = 750 * 0.025  -- GAME UNITS * 0.025 = METRES
SWEP.Penetration = 3
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil -- entity to fire, if any


SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 30 -- DefaultClip is automatically set.
SWEP.ExtendedClipSize = 45
SWEP.ReducedClipSize = 15

SWEP.VisualRecoilMult = 0
SWEP.Recoil = 0.28
SWEP.RecoilSide = 0.22
SWEP.RecoilRise = 0.44

SWEP.Delay = 0.054 -- 60 / RPM.
SWEP.Num = 1 -- number of shots per trigger pull.
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = -2,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NPCWeaponType = {"weapon_ar2", "weapon_smg1"}
SWEP.NPCWeight = 100

SWEP.AccuracyMOA = 10 -- accuracy in Minutes of Angle. There are 60 MOA in a degree.
SWEP.HipDispersion = 300 -- inaccuracy added by hip firing.
SWEP.MoveDispersion = 175

SWEP.Primary.Ammo = "pistol" -- what ammo type the gun uses

SWEP.ShootVol = 110 -- volume of shoot sound
SWEP.ShootPitch = 110 -- pitch of shoot sound

SWEP.ShootSound =			"weapons/fesiugmw2/fire/kriss.wav"
SWEP.ShootMechSound =       ArcCW_MW2_Mech
--SWEP.DistantShootSound =	"weapons/fesiugmw2/fire_distant/kriss.wav"
SWEP.ShootSoundSilenced =	"weapons/fesiugmw2/fire/mp5_sil.wav"

SWEP.MuzzleEffect = "muzzleflash_smg"
SWEP.ShellModel = "models/shells/shell_9mm.mdl"
SWEP.ShellScale = 1
SWEP.ShellRotateAngle = Angle(0, 90, 0)

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.SpeedMult = 1
SWEP.SightedSpeedMult = 0.80
SWEP.SightTime = 0.2

SWEP.BulletBones = { -- the bone that represents bullets in gun/mag
    -- [0] = "bulletchamber",
    -- [1] = "bullet1"
}

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = true

SWEP.IronSightStruct = {
    Pos = Vector(-2.5, -2.746, 0.58),
    Ang = Angle(-0.212, 0, 0),
    ViewModelFOV = 65 / 1.18,
    Magnification = 1.18,
}

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "smg"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1

SWEP.ActivePos = Vector(0, 0, 1)
SWEP.ActiveAng = Angle(0, 0, 0)

SWEP.CustomizePos = Vector(10.479, 0, -3.321)
SWEP.CustomizeAng = Angle(18.2, 39.4, 14.8)

SWEP.HolsterPos = Vector(1, 0, 1)
SWEP.HolsterAng = Angle(-10, 12, 0)

SWEP.SprintPos = Vector(0, 0, 1)
SWEP.SprintAng = Angle(0, 0, 0)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(2, 0, -2)

SWEP.BarrelLength = 24

SWEP.AttachmentElements = {
    ["nors"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        WMBodygroups = {},
    },
    ["nogrip"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        WMBodygroups = {},
    },
    ["wepcamo-desert"]		= { VMSkin = 1 },
    ["wepcamo-arctic"]		= { VMSkin = 2 },
    ["wepcamo-woodland"]	= { VMSkin = 3 },
    ["wepcamo-digital"]		= { VMSkin = 4 },
    ["wepcamo-urban"]		= { VMSkin = 5 },
    ["wepcamo-bluetiger"]	= { VMSkin = 6 },
    ["wepcamo-redtiger"]	= { VMSkin = 7 },
    ["wepcamo-fall"]		= { VMSkin = 8 },
    ["wepcamo-whiteout"]	= { VMSkin = 9 },
    ["wepcamo-blackout"]        = { VMSkin = 10 },
    ["wepcamo-bushdweller"]     = { VMSkin = 11 },
    ["wepcamo-thunderstorm"]    = { VMSkin = 12 },
}

SWEP.ExtraSightDist = 5

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = "optic",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-4.7, 0, 2.7),
            vang = Angle(0, 0, 0),
            wpos = Vector(1.998, 0.17, -5.025),
            wang = Angle(-3.074, -23.004, -172.249)
        },
        SlideAmount = {
            vmin = Vector(2.5, 0, 1.4),
            vmax = Vector(5, 0, 1.4),
            wmin = Vector(5.36, 0.739, -5.401),
            wmax = Vector(5.36, 0.739, -5.401),
        },
        InstalledEles = {"nors"},
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = "muzzle",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(12.5, 0, -0.45),
            vang = Angle(0, 0, 0),
            wpos = Vector(12.057, 4.317, -3.858),
            wang = Angle(-3.074, -23.004, 0)
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip", "bipod","style_pistol"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(9.5, 0, -1),
            vang = Angle(0, 0, 0),
            wpos = Vector(8.425, 2.96, -2.54),
            wang = Angle(-3.074, -23.004, -172.249)
        },
        InstalledEles = {"nogrip"},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(8.5, 0.5, 0.6),
            vang = Angle(0, 0, -90),
            wpos = Vector(8.425, 3.891, -4.147),
            wang = Angle(-3.074, -23.004, -77.301)
        },
    },
    {
        PrintName = "Fire Group",
        Slot = "fcg",
        DefaultAttName = "Standard FCG"
    },
    {
        PrintName = "Ammo Type",
        Slot = "ammo_bullet"
    },
    {
        PrintName = "Perk",
        Slot = "perk"
    },
    {
        PrintName = "Camouflage",
        DefaultAttName = "None",
        Slot = "mw2_wepcamo",
        FreeSlot = true,
    },
	{
        PrintName = "Charm",
        Slot = "charm",
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(4, -0.4, -1),
            vang = Angle(0, 0, 0),
            wpos = Vector(9.625, 1.5, -4),
            wang = Angle(0, 0, 180)
        },
    },
}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
        Time = 0/30,
    },
    ["enter_sprint"] = {
        Source = "sprint_in",
        Time = 11/30
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        Time = 31/40
    },
    ["exit_sprint"] = {
        Source = "sprint_out",
        Time = 11/30
    },
    ["draw"] = {
        Source = "pullout",
        Time = 23/30,
        SoundTable = {{s = "MW2Common.Deploy", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["ready"] = {
        Source = "pullout_first",
        Time = 32/30,
        SoundTable = {{s = "weapons/fesiugmw2/foley/wpfoly_kriss_reload_first_lift_v1.wav", 		t = 0}},
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["holster"] = {
        Source = "putaway",
        Time = 15/30,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0.9,
    },
    ["fire"] = {
        Source = "fire",
        Time = 8/30,
        ShellEjectAt = 0,
    },
    ["fire_iron"] = {
        Source = "fire_ads",
        Time = 8/30,
        ShellEjectAt = 0,
    },
    ["reload"] = {
        Source = "reload",
        Time = 66/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_kriss_reload_lift_v1.wav", 	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_kriss_reload_clipout_v1.wav", 	t = 10/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_kriss_reload_clipin_v1.wav", 	t = 40/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        Time = 83/30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        SoundTable = {
						{s = "weapons/fesiugmw2/foley/wpfoly_kriss_reload_lift_v1.wav",  	t = 0/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_kriss_reload_clipout_v1.wav", 	t = 10/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_kriss_reload_clipin_v1.wav", 	t = 40/30},
						{s = "weapons/fesiugmw2/foley/wpfoly_kriss_reload_chamber_v1.wav", 	t = 55/30},
					},
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.5,
    },
}
--lua/weapons/arccw_ud_ac556.lua:
return gluapack()()
--lua/weapons/arccw_ud_fpw.lua:
if !file.Exists("arccw/shared/languages/ud_en.lua","LUA") then return end

include("weapons/arccw_ud_m16.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Rifles"
end

SWEP.PrintName = "RAYFPW"
SWEP.TrueName = "M231 FPW"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ud_m16_barrel_14in"
SWEP.Attachments[3].Installed = "ud_m16_hg_fpw"
SWEP.Attachments[6].Installed = "ud_m16_receiver_fpw"
SWEP.Attachments[10].Installed = "ud_m16_stock_231"

SWEP.NPCWeaponType = nil
SWEP.Attachments[10].ToggleLock = true
--lua/weapons/arccw_ud_gnb.lua:
return gluapack()()
--lua/weapons/arccw_ud_m1014.lua:
return gluapack()()
--lua/weapons/arccw_ud_m4a1.lua:
if !file.Exists("arccw/shared/languages/ud_en.lua","LUA") then return end

include("weapons/arccw_ud_m16.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Rifles"
end

SWEP.PrintName = "AMCAR-1NG"
SWEP.TrueName = "M4A1"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[1].Installed = "ud_m16_rs_ch"
SWEP.Attachments[2].Installed = "ud_m16_barrel_14in"
SWEP.Attachments[3].Installed = "ud_m16_hg_tactical"
SWEP.Attachments[6].Installed = "ud_m16_receiver_auto"
SWEP.Attachments[10].Installed = "ud_m16_stock_waffle"

SWEP.Attachments[10].ToggleLock = true
--lua/weapons/arccw_ud_uzi.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "1Urban Decay"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Effects --

SWEP.MuzzleEffect = "muzzleflash_1"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
SWEP.ShellScale = 1
--SWEP.ShellMaterial = "models/weapons/arcticcw/shell_9mm"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.PistolShellSoundsTable

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 3
SWEP.TracerNum = 1
SWEP.TracerCol = Color(25, 255, 25)
SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "IAL-9"

-- True name --

SWEP.TrueName = "Uzi"

-- Trivia --

SWEP.Trivia_Class = "Submachine Gun"
SWEP.Trivia_Desc = "Revolutionary submachine gun developed to arm a young State of Israel following the Second World War. Its ergonomic design, low cost, reliability, and great handling made it popular among militaries, police forces, and private security firms worldwide.\n\nBoasts excellent recoil control partially due to a below average cyclic rate. Good for hip firing in close quarters."
SWEP.Trivia_Manufacturer = "IAL Metal Industries"
SWEP.Trivia_Calibre = "9x19mm Parabellum"
SWEP.Trivia_Mechanism = "Open Bolt"
SWEP.Trivia_Country = "Israel"
SWEP.Trivia_Year = 1950

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Israeli Military Industries"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ud_uzi.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ud_uzi.mdl"
SWEP.ViewModelFOV = 70
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["9mm"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["9mm"].min
SWEP.Penetration = ArcCW.UC.StdDmg["9mm"].pen

SWEP.RangeMin = 15
SWEP.Range = 100 -- 4 shot until ~35m

SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 400
SWEP.PhysBulletMuzzleVelocity = 400

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 0
SWEP.Primary.ClipSize = 32
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 16

-- Recoil --

SWEP.Recoil = 0.28
SWEP.RecoilSide = 0.35

SWEP.RecoilRise = 0.2
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 0.6
SWEP.RecoilPunchBack = 1.5

SWEP.Sway = 0.3

-- Firerate / Firemodes --

SWEP.TriggerDelay = true

SWEP.Delay = 60 / 700
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
        Mult_TriggerDelayTime = 2,
    },
    {
        Mode = 1,
        Mult_TriggerDelayTime = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_smg1"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 6
SWEP.HipDispersion = 400
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "pistol"
SWEP.MagID = "uzi"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 200
SWEP.MalfunctionTakeRound = false

-- Speed multipliers --

SWEP.SpeedMult = 0.95
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.3
SWEP.ShootSpeedMult = 0.95

-- Length --

SWEP.BarrelLength = 24
SWEP.ExtraSightDist = 7

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, -2, 1)
SWEP.HolsterAng = Angle(-8.5, 8, -10)

SWEP.HoldtypeHolstered = "normal"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-2.869, -6, 1.95),
     Ang = Angle(0, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 55,
}

SWEP.ActivePos = Vector(0.4, -1.9, 1.4)
SWEP.ActiveAng = Angle(0, 0, -3)

SWEP.CustomizePos = Vector(5, -2, -2)
SWEP.CustomizeAng = Angle(15, 25, 0)

SWEP.CrouchPos = Vector(-3, -3, 0)
SWEP.CrouchAng = Angle(0, 0, -30)

SWEP.BarrelOffsetHip = Vector(4, 0, -4)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-16, 4, -3),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Firing sounds --
local path = ")weapons/arccw_ud/uzi/"
local path1 = ")weapons/arccw_ud/glock/"
local common = ")/arccw_uc/common/"
--SWEP.FirstShootSound = path .. "fire.ogg"
--SWEP.ShootSound = path .. "fire_auto.ogg"
SWEP.ShootSoundSilenced = path1 .. "fire_supp.ogg"
SWEP.ShootDrySound = path .. "dryfire.ogg"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}

local tail = ")/arccw_uc/common/9x19/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-9x19-smg-ext-01.ogg",
    tail .. "fire-dist-9x19-smg-ext-02.ogg",
    tail .. "fire-dist-9x19-smg-ext-03.ogg",
    tail .. "fire-dist-9x19-smg-ext-04.ogg",
    tail .. "fire-dist-9x19-smg-ext-05.ogg",
    tail .. "fire-dist-9x19-smg-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-pistol-01.ogg",
    common .. "fire-dist-int-pistol-02.ogg",
    common .. "fire-dist-int-pistol-03.ogg",
    common .. "fire-dist-int-pistol-04.ogg",
    common .. "fire-dist-int-pistol-05.ogg",
    common .. "fire-dist-int-pistol-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 0.5
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    [1] = "uzi_b1", [2] = "uzi_b2", [3] = "uzi_b3", [4] = "uzi_b4"
}

SWEP.AttachmentElements = {

    ["ud_uzi_mag_20"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["ud_uzi_mag_40"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["ud_uzi_mag_100"] = {
        VMBodygroups = {{ind = 2, bg = 3}},
    },
    ["ud_uzi_mag_45_10"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["ud_uzi_mag_45_22"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },

    ["ud_uzi_rail_optic"] = {
        VMBodygroups = {{ind = 4, bg = 2}},
    },

    ["ud_uzi_clamp"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },

    ["ud_uzi_rail_fg"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },

    ["ud_uzi_stock_wood"] = {
        VMBodygroups = {{ind = 3, bg = 2}},
    },
    ["ud_uzi_stock_polymer"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
    ["ud_uzi_stock_folded"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["ud_uzi_stock_remove"] = {
        VMBodygroups = {{ind = 3, bg = 4}},
    },

    ["ud_uzi_body_carbine"] = {
        VMBodygroups = {{ind = 1, bg = 1}},
        NameChange = "IAL-C9",
        TrueNameChange = "Uzi Carbine",
        AttPosMods = {
            [4] = {
                vpos = Vector(-0.2, 0.5, 20.8),
            },
        },
    },
    ["ud_uzi_body_mini"] = {
        VMBodygroups = {{ind = 1, bg = 2}},
        NameChange = "IAL-S9",
        TrueNameChange = "Mini Uzi",
        AttPosMods = {
            [4] = {
                vpos = Vector(-0.2, 0.5, 11.8),
            },
        },
    },
    ["ud_uzi_body_micro"] = {
        VMBodygroups = {{ind = 1, bg = 3},{ind = 4, bg = 1},{ind = 3, bg = 4}},
        NameChange = "IAL-M9",
        TrueNameChange = "Micro Uzi",
        Override_IronSightStruct = {
            Pos = Vector(-2.869, 3, 1.95),
            Ang = Angle(-0, 0.035, 0),
            Magnification = 1,
            CrosshairInSights = false
        },
        AttPosMods = {
            [1] = {
                vpos = Vector(-0.2, -1.8, -1.5),
            },
            [4] = {
                vpos = Vector(-0.2, 0.3, 7.8),
            },
            [6] = {
                vpos = Vector(-0.25, 1.4, 6),
                vang = Angle(90, 0, -90),
            },
        },
    },
    ["ud_uzi_body_civvy"] = {
        VMBodygroups = {{ind = 1, bg = 4}},
        NameChange = "IAL-C9 Model GB",
        TrueNameChange = "Uzi Action-B",
        AttPosMods = {
            [4] = {
                vpos = Vector(-0.2, 0.5, 23.8),
            },
        },
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local vm = data.vm
    if !IsValid(vm) then return end
    local barrel = wep.Attachments[2].Installed
    if barrel == "ud_uzi_body_micro" then
        if wep.Attachments[1].Installed then
            vm:SetBodygroup(4, 3)
        end
        if wep.Attachments[6].Installed then
            vm:SetBodygroup(6, 0)
            vm:SetBodygroup(5, 2)
        end
    end
end

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

SWEP.Animations = {
    ["ready"] = {
        Source = "fix",
        Time = 40 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0},
            {s = common .. "rattle.ogg", t = 0.2},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.15},
            {s = path .. "chback.ogg",         t = 0.3, c = ci},
            {s = path .. "chforward.ogg",         t = 0.65, c = ci},
        },
        ProcDraw = true,
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_empty"] = {
        Source = "idle_empty",
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = ArcCW.UC.DrawSounds,
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        SoundTable = ArcCW.UC.DrawSounds,
    },
    ["holster"] = {
        Source = "holster",
        Time = 0.25,
        SoundTable = ArcCW.UC.HolsterSounds,
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        Time = 0.25,
        SoundTable = ArcCW.UC.HolsterSounds,
    },
    ["fire"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg"}, t = 0 }},
    },
    ["fire_empty"] = {
        Source = "fire_empty",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = path .. "chforward.ogg", t = 0 }},
    },

    ["trigger"] = {
        Source = "idle",
        Time = 0.025,
        SoundTable = {
            {s = path .. "prefire.ogg",         t = 0, c = ci},
        },
    },
    ["trigger_empty"] = {
        Source = "idle",
        Time = 0,
        SoundTable = nil,
    },

    ["fix"] = {
        Source = "fix",
        Time = 40 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.15},
            {s = path .. "chback.ogg",         t = 0.3, c = ci},
            {s = path .. "chforward.ogg",         t = 0.65, c = ci},
        },
    },
    ["fix_empty"] = {
        Source = "fix_empty",
        Time = 40 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.15},
            {s = path .. "chback.ogg",         t = 0.3, c = ci},
            {s = path .. "chforward.ogg",         t = 0.65, c = ci},
        },
    },

    ["fix_micro"] = {
        Source = "fix_micro",
        Time = 40 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.15},
            {s = path .. "chback.ogg",         t = 0.3, c = ci},
            {s = path .. "chforward.ogg",         t = 0.65, c = ci},
        },
    },
    ["fix_empty_micro"] = {
        Source = "fix_empty_micro",
        Time = 40 / 30,
        ShellEjectAt = false,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.15},
            {s = path .. "chback.ogg",         t = 0.3, c = ci},
            {s = path .. "chforward.ogg",         t = 0.65, c = ci},
        },
    },

    -- 32 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = common .. "magpouch.ogg", t = 0.025},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.55, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.35, v = .35},
            {s = common .. "shoulder.ogg",  t = 1.75},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.25},
            {s = common .. "magpouch.ogg", t = 0.85},
            {s = common .. "magdrop_smg.ogg",  t = 1.0},
            {s = path .. "magin.ogg",         t = 1.1, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 1.25},
            {s = path .. "chback.ogg",         t = 1.935, c = ci},
            {s = path .. "chforward.ogg",         t = 2.15, c = ci},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 16 Round Reloads --

    ["reload_16"] = {
        Source = "reload_16",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = common .. "magpouch.ogg", t = 0.025},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.55, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.35, v = .35},
            {s = common .. "shoulder.ogg",  t = 1.75},
        },
    },
    ["reload_empty_16"] = {
        Source = "reload_empty_16",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.25},
            {s = common .. "magpouch.ogg", t = 0.85},
            {s = common .. "magdrop_smg.ogg",  t = 1.0},
            {s = path .. "magin.ogg",         t = 1.1, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 1.25},
            {s = path .. "chback.ogg",         t = 1.947, c = ci},
            {s = path .. "chforward.ogg",         t = 2.15, c = ci},
            {s = common .. "shoulder.ogg",  t = 2.45},
        },
    },

    -- 41 Round Reloads --

    ["reload_41"] = {
        Source = "reload_41",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = common .. "magpouch.ogg", t = 0.025},
            {s = path .. "magout.ogg",        t = 0.35, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.65, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.35, v = .35},
            {s = common .. "shoulder.ogg",  t = 1.75},
        },
    },
    ["reload_empty_41"] = {
        Source = "reload_empty_41",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.25},
            {s = common .. "magpouch.ogg", t = 0.85},
            {s = common .. "magdrop_smg.ogg",  t = 1.0},
            {s = path .. "magin.ogg",         t = 1.1, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 1.25},
            {s = path .. "chback.ogg",         t = 1.947, c = ci},
            {s = path .. "chforward.ogg",         t = 2.15, c = ci},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 100 Round Reloads --

    ["reload_100"] = {
        Source = "reload_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        Time = 67 / 30,
        MinProgress = 1.6,
        LastClip1OutTime = 1,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.25},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.75},
            {s = path .. "magin.ogg",         t = 1.15, c = ci},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = common .. "shoulder.ogg",  t = 1.95},
        },
    },
    ["reload_empty_100"] = {
        Source = "reload_empty_100",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        Time = 90 / 30,
        MinProgress = 2.4,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.25},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.75},
            {s = common .. "magdrop.ogg",  t = 1.0},
            {s = path .. "magin.ogg",         t = 1.15, c = ci},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = path .. "chback.ogg",         t = 2.0, c = ci},
            {s = path .. "chforward.ogg",         t = 2.25, c = ci},
            {s = common .. "shoulder.ogg",  t = 2.7},
        },
    },
}

SWEP.AutosolveSourceSeq = "idle"

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_lp","optic"}, -- ,"optic"
        Bone = "uzi_parent",
        Offset = {
            vpos = Vector(-0.2, -1.55, -0.5),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"ud_uzi_rail_optic"}
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "10\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/acwatt_ud_uzi_body.png", "smooth mips"),
        Slot = "ud_uzi_frame",
        Bone = "uzi_parent",
        Offset = {
            vpos = Vector(2.6, -3.7, -17.3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Caliber",
        DefaultAttName = "9x19mm Parabellum",
        DefaultAttIcon = Material("entities/att/uc_bullets/9x19.png", "smooth mips"),
        Slot = "ud_uzi_caliber",
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle"},
        Bone = "uzi_parent",
        Offset = {
            vpos = Vector(-0.2, 0.5, 14.8),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "uzi_parent",
        Offset = {
            vpos = Vector(-0.2, 1.85, 6.9), -- nice
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"ud_uzi_rail_fg"},
        ExcludeFlags = {"micro"}
    },
    {
        PrintName = "Tactical",
        Slot = {"tac_pistol"},
        Bone = "uzi_parent",
        Offset = {
            vpos = Vector(-1.35, 0.9,5.8),
            vang = Angle(90, 0, 180),
        },
        InstalledEles = {"ud_uzi_clamp"}
    },
    {
        PrintName = "Stock",
        Slot = {"ud_uzi_stock"},
        DefaultAttName = "Folding Stock",
        DefaultAttIcon = Material("entities/att/acwatt_ud_uzi_stock.png", "smooth mips"),
        ExcludeFlags = {"micro"},
    },
    {
        PrintName = "Magazine",
        Slot = {"ud_uzi_mag"},
        DefaultAttName = "32-Round Mag",
        DefaultAttIcon = Material("entities/att/acwatt_ud_uzi_mag_32.png", "smooth mips"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"},
        FreeSlot = true,
        Bone = "uzi_parent",
        Offset = {
            vpos = Vector(0.4, 1.3, 2.3),
            vang = Angle(90, 0, -90),
        },
    },
}

--lua/weapons/arccw_ud_mk18.lua:
return gluapack()()
--lua/weapons/arccw_ud_870.lua:
return gluapack()()
--lua/weapons/arccw_ud_870.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "1Urban Decay"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Muzzle and shell effects --

SWEP.MuzzleEffect = "muzzleflash_shotgun"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/12g.mdl"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.ShotgunShellSoundsTable
SWEP.ShellScale = 1
SWEP.UC_ShellColor = Color(0.7*255, 0.2*255, 0.2*255)

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
SWEP.CamAttachment = 3

-- Fake name --

SWEP.PrintName = "Express-12"

-- True name --

SWEP.TrueName = "Remington 870"

-- Trivia --

SWEP.Trivia_Class = "Shotgun"
SWEP.Trivia_Desc = "Classic pump-action shotgun, renowned for its high quality parts and assembly. A simple firearm with a simple purpose. Marketed primarily to civilians for use in hunting game and self-defense, but it has found popularity among police departments for a relatively innocuous appearance and ability to accept custom loaded less-lethal shells."
SWEP.Trivia_Manufacturer = "Mauer Armaments"
SWEP.Trivia_Calibre = "12 Gauge"
SWEP.Trivia_Mechanism = "Pump Action"
SWEP.Trivia_Country = "USA"
SWEP.Trivia_Year = 1950

-- Weapon slot --

SWEP.Slot = 3

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Remington Arms"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ud_870.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ud_870.mdl"
SWEP.ViewModelFOV = 60
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN
SWEP.DefaultBodygroups = "000000000"

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-5.5, 5, -5.5),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    scale = 1 - ( 0.35 * 0.5 )
}

-- Damage parameters --

SWEP.Damage = ArcCW.UC.StdDmg["12g_p"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["12g_p"].min
SWEP.Penetration = ArcCW.UC.StdDmg["12g_p"].pen
SWEP.Num = ArcCW.UC.StdDmg["12g_p"].num

SWEP.Range = 50
SWEP.RangeMin = 5
SWEP.DamageType = DMG_BUCKSHOT
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 200

SWEP.HullSize = 0.5

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults_Shotgun

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 6
SWEP.ExtendedClipSize = 8
SWEP.ReducedClipSize = 6

-- Recoil --

SWEP.Recoil = 3.1
SWEP.RecoilSide = 1

SWEP.RecoilRise = 0.24
SWEP.VisualRecoilMult = 1
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 1

SWEP.Sway = 0.5

-- Firerate / Firemodes --

SWEP.Delay = 60 / 60
SWEP.Firemodes = {
    {
        PrintName = "fcg.pump",
        Mode = 1,
    },
    {
        Mode = 0
    }
}

SWEP.NoLastCycle = true
SWEP.ManualAction = true
SWEP.ShotgunReload = true

SWEP.ShootVol = 160
SWEP.ShootPitch = 100

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_shotgun"
SWEP.NPCWeight = 210

-- Accuracy --

SWEP.AccuracyMOA = 30
SWEP.HipDispersion = 400
SWEP.MoveDispersion = 100
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "buckshot"

-- Speed multipliers --

SWEP.SpeedMult = 0.9
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.4
SWEP.ShootSpeedMult = 0.75

-- Length --

SWEP.BarrelLength = 32
SWEP.ExtraSightDist = 2

-- Ironsights / Customization / Poses --

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-3.66, -3, 2.2),
     Ang = Angle(-0.75, 0, 2.8),
     Magnification = 1.1,
     SwitchToSound = "",
}

SWEP.HolsterPos = Vector(2, 0, -2)
SWEP.HolsterAng = Angle(-5.5, 20, -20)

SWEP.SprintPos = Vector(-0.5, -4, -2)
SWEP.SprintAng = Angle(3.5, 7, -20)

SWEP.ActivePos = Vector(-0.75, -2, 1)
SWEP.ActiveAng = Angle(0, 0, -3)

SWEP.CrouchPos = Vector(-3.8, -2, 0)
SWEP.CrouchAng = Angle(0, 0, -30)

SWEP.BarrelOffsetSighted = Vector(0, 0, -1)
SWEP.BarrelOffsetHip = Vector(3, 0, -4)



SWEP.Malfunction = true
SWEP.MalfunctionTakeRound = true
SWEP.MalfunctionMean = 500
SWEP.MalfunctionVariance = 0.99
-- Firing sounds --

local path = ")weapons/arccw_ud/870/"
local common = ")/arccw_uc/common/"
SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg",
    path .. "fire-04.ogg",
    path .. "fire-05.ogg",
    path .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
--[[SWEP.DistantShootSound = path .. "fire_dist.ogg"
SWEP.DistantShootSoundSilenced = common .. "sup_tail.ogg"]]
SWEP.ShootDrySound = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}

local tail = ")/arccw_uc/common/12ga/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-12ga-pasg-ext-01.ogg",
    tail .. "fire-dist-12ga-pasg-ext-02.ogg",
    tail .. "fire-dist-12ga-pasg-ext-03.ogg",
    tail .. "fire-dist-12ga-pasg-ext-04.ogg",
    tail .. "fire-dist-12ga-pasg-ext-05.ogg",
    tail .. "fire-dist-12ga-pasg-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-shotgun-01.ogg",
    common .. "fire-dist-int-shotgun-02.ogg",
    common .. "fire-dist-int-shotgun-03.ogg",
    common .. "fire-dist-int-shotgun-04.ogg",
    common .. "fire-dist-int-shotgun-05.ogg",
    common .. "fire-dist-int-shotgun-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.Hook_Think = ArcCW.UC.ADSReload

local shellin = {path .. "shell-insert-01.ogg", path .. "shell-insert-02.ogg", path .. "shell-insert-03.ogg"}

SWEP.Animations = {
    ["ready"] = {
        Source = "sgreload_finish_empty",
        Time = 37 / 30,
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 1.2,
        LHIKOut = 1.4,
        SoundTable = {
            {s = common .. "raise.ogg", t = 0.2},
            {s = common .. "rattle.ogg", t = 0.2},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.5},
            {s = path .. "rack_1.ogg",  t = 0.4},
            {s = path .. "rack_2.ogg",  t = 0.6},
            {s = common .. "shoulder.ogg",  t = 0.9},
        },
        ProcDraw = true,
    },
    ["idle"] = {
        Source = "idle",
    },
    ["idle_empty"] = {
        Source = "idle",
    },
    ["draw"] = {
        Source = "draw",
        Time = 20 / 30,
        SoundTable = ArcCW.UC.DrawSounds,
    },
    ["holster"] = {
        Source = "holster",
        Time = 20 / 30,
        SoundTable = ArcCW.UC.HolsterSounds,
    },
    ["fire"] = {
        Source = "fire",
        --Time = 23 / 30,
        MinProgress = 8 / 30,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    ["fire_iron"] = {
        Source = "fire",
        --Time = 23 / 30,
        MinProgress = 8 / 30,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    ["cycle"] = {
        Source = "cycle",
        --Time = 20 / 30,
        ShellEjectAt = 0.1,
        MinProgress = 0.26,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = path .. "rack_1.ogg",  t = 0},
            {s = path .. "eject.ogg",  t = 0.1},
            {s = path .. "rack_2.ogg",  t = 0.11},
        },
    },

    ["cycle_jammed"] = {
        Source = "jamcycle",
        --Time = 20 / 30,
        ShellEjectAt = 0.1,
        MinProgress = 0.26,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = path .. "rack_1.ogg",  t = 0},
            {s = path .. "eject.ogg",  t = 0.1},
            {s = path .. "rack_2.ogg",  t = 0.11},
        },
    },

    ["fix"] = {
        Source = "fix",
        Time = 50 / 30,
        ShellEjectAt = 0.7, -- should make the shell eject offscreen cuz the anim already has it
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.5},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 1},
            {s = path .. "rack_1.ogg",  t = 0.6},
            {s = path .. "eject.ogg",  t = 0.7},
            {s = path .. "rack_2.ogg",  t = 0.9},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 1.7},
        }
    },
    ["sgreload_start"] = {
        Source = "sgreload_start",
        Time = 16 / 30,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKOut = 0,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = common .. "shoulder.ogg",  t = 0.1},
        },
    },
    ["sgreload_insert"] = {
        Source = "sgreload_insert",
        Time = 18 / 30,
        MinProgress = 0.24,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        TPAnimStartTime = 0.3,
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
        SoundTable = {
            {s = shellin, t = 0},
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
        },
    },
    ["sgreload_finish"] = {
        Source = "sgreload_finish",
        Time = 20 / 30,
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.3,
        LHIKOut = 0.4,
        TPAnimStartTime = 0.8,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0},
            {s = common .. "shoulder.ogg",  t = 0.27},
        },
    },
    ["sgreload_finish_empty"] = {
        Source = "sgreload_finish_empty",
        Time = 37 / 30,
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.6,
        LHIKOut = 0.8,
        TPAnimStartTime = 0.5,
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
        ShellEjectAt = 0.5,
        SoundTable = {
            {s = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}, t = 0.5},
            {s = path .. "rack_1.ogg",  t = 0.4},
            {s = path .. "eject.ogg",  t = 0.5},
            {s = path .. "rack_2.ogg",  t = 0.525},
            {s = common .. "shoulder.ogg",  t = 0.9},
        },
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local vm = data.vm
    if !IsValid(vm) then return end
    -- if wep.Attachments[1].Installed then
    --     vm:SetBodygroup(8, 2)
    -- elseif wep.Attachments[2].Installed == "ud_870_barrel_long" then
    --     vm:SetBodygroup(8, 1)
    -- else
    --     vm:SetBodygroup(8, 0)
    -- end

    -- 8rnd tube and either barrel should remove the clamp
    if vm:GetBodygroup(7) == 1 and vm:GetBodygroup(1) != 0 then
        vm:SetBodygroup(7, 2)
    end
end


SWEP.BulletBones = {
    [0] = "870_shell1",
}

SWEP.DefaultSkin = 1

-- Bodygroups --

SWEP.AttachmentElements = {
    ["ud_870_optic_ringsight"] = {
        VMBodygroups = {
            {ind = 8, bg = 1},
        },
        Override_IronSightStruct = {
            Pos = Vector(-3.665, -2.75, 2.1),
            Ang = Angle(-0.6, 0, 1),
            Magnification = 1.1,
            SwitchToSound = "",
        },
    },
    ["optic_rail"] = {
        VMBodygroups = {
            {ind = 8, bg = 2},
        }
    },
    ["ud_shotgun_rail_fg"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["ud_870_slide_moe"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },
    ["ud_870_slide_long"] = {
        VMBodygroups = {{ind = 6, bg = 2}},
    },
    ["ud_870_slide_poly"] = {
        VMBodygroups = {{ind = 6, bg = 3}},
    },
    ["ud_shotgun_rail_fg"] = {
        VMBodygroups = {{ind = 3, bg = 1}},
    },
    ["ud_870_barrel_long"] = {
        AttPosMods = {
            [3] = {
                vpos = Vector(-0.03, -0.65, 39.5),
            }
        },
        VMBodygroups = {
            {ind = 1, bg = 1},
        },
    },
    ["ud_870_barrel_sawnoff"] = {
        VMBodygroups = {
        {ind = 1, bg = 2},
        {ind = 7, bg = 2}
        },
        AttPosMods = {
            [3] = {
                vpos = Vector(-0.03, -0.9, 19),
            }
        },
    },
    ["ud_870_tube_reduced"] = {
        VMBodygroups = {
            {ind = 2, bg = 2},
            {ind = 7, bg = 2}
        },
    },
    ["ud_870_tube_ext"] = {
        VMBodygroups = {
            {ind = 2, bg = 1},
            {ind = 7, bg = 1}
        },
    },
    ["ud_870_stock_poly"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
    ["ud_870_stock_sawnoff"] = {
        VMBodygroups = {{ind = 4, bg = 2}},
    },
    ["ud_870_stock_raptor"] = {
        VMBodygroups = {{ind = 4, bg = 3}},
    },

    ["ud_870_skin_dirty"] = {
        VMSkin = 0
    },
    ["ud_870_skin_custom"] = {
        VMSkin = 3
    },
}

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_lp","optic","optic_sniper","ud_870_optic"},
        Bone = "870_parent",
        Offset = {
            vpos = Vector(0, -1.75, -2),
            vang = Angle(90, 0, -90),
        },
        VMScale = Vector(1, 1, 1),
        CorrectiveAng = Angle(1.8, 0.1, 0),
        InstalledEles = {"optic_rail"}
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "16\" Standard Barrel",
        DefaultAttIcon = Material("entities/att/acwatt_ud_870_barrel.png", "smooth mips"),
        Slot = "ud_870_barrel",
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"choke", "muzzle_shotgun"},
        Bone = "870_parent",
        Offset = {
            vpos = Vector(-0.03, -0.75, 26.3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Forend",
        DefaultAttName = "Factory Forend",
        DefaultAttIcon = Material("entities/att/acwatt_ud_870_slide.png", "smooth mips"),
        Slot = {"ud_870_slide"},
        Bone = "870_slide",
        Offset = {
            vpos = Vector(3, -4.4, -29),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "870_slide",
        Offset = {
            vpos = Vector(0, 1.1, 0),
            vang = Angle(90, 0, -90),
        },
        InstalledEles = {"ud_shotgun_rail_fg"}
    },
    {
        PrintName = "Tactical",
        Slot = {"tac_pistol"},
        Bone = "870_slide",
        Offset = {
            vpos = Vector(0, 1, 4.25),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Stock",
        DefaultAttName = "Wooden Stock",
        DefaultAttIcon = Material("entities/att/acwatt_ud_870_stock.png", "smooth mips"),
        Slot = {"ud_870_stock"},
    },
    {
        PrintName = "Tube Type",
        Slot = {"ud_870_tube"},
        DefaultAttName = "6 Shell Tube",
        DefaultAttIcon = Material("entities/att/acwatt_ud_870_tube.png", "smooth mips"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"BUCK\" #00 Buckshot",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_shotgun_generic.png", "mips smooth"),
        Slot = "ud_ammo_shotgun",
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"},
        FreeSlot = true,
        Bone = "870_parent",
        Offset = {
            vpos = Vector(0.7, 0, 5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Skin",
        Slot = "ud_870_skin",
        DefaultAttName = "Polished Steel",
        FreeSlot = true
    }
}

local lookup_barrel = {
    default = 1,
    ud_870_barrel_long = 2,
    ud_870_barrel_sawnoff = 0,
}

local lookup_tube = {
    default = 1,
    ud_870_tube_ext = 2,
    ud_870_tube_reduced = 0,
}

SWEP.Hook_ExtraFlags = function(wep, data)

    local barrel = wep.Attachments[2].Installed and lookup_barrel[wep.Attachments[2].Installed] or lookup_barrel["default"]
    local tube = wep.Attachments[8].Installed and lookup_tube[wep.Attachments[8].Installed] or lookup_tube["default"]

    if barrel < tube then
        table.insert(data, "nomuzzleblocking")
    end
end
--lua/weapons/arccw_ud_uzi.lua:
return gluapack()()
--lua/weapons/arccw_ur_ak.lua:
return gluapack()()
--lua/weapons/arccw_ur_aw.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Urban Coalition" -- edit this if you like
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false

SWEP.PrintName = "AWP"

SWEP.Trivia_Class = "Sniper Rifle"
SWEP.Trivia_Desc = "A heavy rifle purpose-built for extreme range combat under extreme climates, first developed for the British military but quickly adopted by many more. Iconic for its appearance among military and police marksmen, this rifle is a symbol of discipline and order.\n\nOffers outstanding precision and kill potential, but its long bolt pull and reload time can become a hinderance outside its ideal engagement range.\n\nOne shot. One kill. You know the routine."
SWEP.Trivia_Manufacturer = "Accuracy International"
SWEP.Trivia_Calibre = "7.62x51mm NATO"
SWEP.Trivia_Mechanism = "Bolt Action"
SWEP.Trivia_Country = "United Kingdom"
SWEP.Trivia_Year = 1982

if !GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = "Apex Precision"
    SWEP.Trivia_Manufacturer = "Marksman Institute"
end


SWEP.Slot = 3
SWEP.CamAttachment = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/c_ur_aw.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_aw.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "000000000000"

SWEP.BulletBones = {
    --[1] = "top_round",
    [2] = "mag_round",
}

-- Damage --

SWEP.Damage = 80 -- 2 shot close range
SWEP.DamageMin = 50 -- 2 shot long range
SWEP.RangeMin = 100
SWEP.Range = 400 -- 2 shot at ~300m

SWEP.Penetration = 18
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 850
SWEP.PhysBulletMuzzleVelocity = 850

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 5
SWEP.ExtendedClipSize = 10
SWEP.ReducedClipSize = 5

-- Recoil --

SWEP.Recoil = 1.75
SWEP.RecoilSide = 0.75

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 0.3
SWEP.VisualRecoilMult = 5
SWEP.MaxRecoilBlowback = 4
SWEP.MaxRecoilPunch = 4
SWEP.RecoilPunchBack = 3
SWEP.RecoilPunchBackMax = 3.5
SWEP.RecoilPunchBackMaxSights = 2.5

SWEP.Sway = 0.2

-- Firerate / Firemodes --

SWEP.Delay = 60 / 80
SWEP.Num = 1
SWEP.Firemodes = {
    {
        PrintName = "fcg.bolt",
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_crossbow"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = .25
SWEP.HipDispersion = 1250
SWEP.MoveDispersion = 500
SWEP.JumpDispersion = 700 -- tactical unrealism    set to 700 later

SWEP.Primary.Ammo = "ar2"
SWEP.MagID = "awp"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

-- SWEP.Malfunction = true
SWEP.MalfunctionMean = 200
--SWEP.MeleeTime = 1.5

-- Speed multipliers --

SWEP.SpeedMult = 0.8
SWEP.SightedSpeedMult = 0.625
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.625

local path = ")weapons/arccw_ur/ak/"

local testpath = ")weapons/arccw_ur/aw_placeholders/"
local path1 = ")weapons/arccw_ur/aw_placeholders/338/"

local path1 = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rutle = {common .. "movement-sniper-03.ogg",common .. "movement-sniper-04.ogg"}

SWEP.ShootSound = {
    testpath .. "fire-01.ogg",
    testpath .. "fire-02.ogg",
    testpath .. "fire-03.ogg",
    testpath .. "fire-04.ogg",
    testpath .. "fire-05.ogg",
    testpath .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    testpath .. "fire-sup-01.ogg",
    testpath .. "fire-sup-02.ogg",
    testpath .. "fire-sup-03.ogg",
    testpath .. "fire-sup-04.ogg",
    testpath .. "fire-sup-05.ogg",
    testpath .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = testpath .. "dryfire.ogg"

local tail = ")/arccw_uc/common/308/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-308-rif-ext-01.ogg",
    tail .. "fire-dist-308-rif-ext-02.ogg",
    tail .. "fire-dist-308-rif-ext-03.ogg",
    tail .. "fire-dist-308-rif-ext-04.ogg",
    tail .. "fire-dist-308-rif-ext-05.ogg",
    tail .. "fire-dist-308-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-shotgun-01.ogg",
    common .. "fire-dist-int-shotgun-02.ogg",
    common .. "fire-dist-int-shotgun-03.ogg",
    common .. "fire-dist-int-shotgun-04.ogg",
    common .. "fire-dist-int-shotgun-05.ogg",
    common .. "fire-dist-int-shotgun-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.MuzzleEffect = "muzzleflash_ak47"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellPitch = 90
SWEP.ShellScale = 1.145
SWEP.ShellRotateAngle = Angle(0, 0, 0)

SWEP.ManualAction = true
-- SWEP.ManualAction = false
SWEP.NoLastCycle = true

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.IronSightStruct = {
    Pos = Vector(-3.37, -5, 0.68),
    Ang = Angle(0, 0, 2),
    Magnification = 1.1,
    SwitchToSound = "", -- sound that plays when switching to this sight
    CrosshairInSights = false
}
SWEP.LaserOffsetAngle = Angle(0, 0, 0)
SWEP.LaserIronsAngle = Angle(0, 1.5, 0)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-0.1, 0.1, 0.2)
SWEP.ActiveAng = Angle(0, 0, -1)

SWEP.SprintPos = Vector(-1, -1, 1.2)
SWEP.SprintAng = Angle(-15, 8, -10)

SWEP.CrouchPos = Vector(-2, -2, -0.8)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.HolsterPos = Vector(-1, -1, 1.2)
SWEP.HolsterAng = Angle(-15, 8, -10)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(0, 0, 0)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

-- SWEP.CustomizePos = Vector(6.5, 0.8, -0.2)
-- SWEP.CustomizeAng = Angle(8, 18, 15)

SWEP.BarrelLength = 54

SWEP.AttachmentElements = {
    ["barrel_long"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        AttPosMods = {[3] = {
            vpos = Vector(0, 40, 1.75),
            vang = Angle(0, 270, 0),
        }}
    },
    ["barrel_short"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
        AttPosMods = {[3] = {
            vpos = Vector(0, 28, 1.75),
            vang = Angle(0, 270, 0),
        }}
    },
    ["barrel_sd"] = {
        VMBodygroups = {{ind = 2, bg = 3}}
    },

    ["mag_338"] = {
        --VMBodygroups = {{ind = 3, bg = 2}}
    },
    ["mag_300"] = {
        --VMBodygroups = {{ind = 3, bg = 2}}
    },
    ["mag_ext"] = {
        --VMBodygroups = {{ind = 3, bg = 1}}
    },
    ["mag_ext_magnum"] = {
        --VMBodygroups = {{ind = 3, bg = 3}}
    },

    ["rail_bottom"] = {
        VMBodygroups = {{ind = 6, bg = 1}}
    },
    ["rail_top"] = {
        VMBodygroups = {{ind = 7, bg = 1}}
    },
    ["sights_compact"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
        Override_IronSightStruct = {
            Pos = Vector(-3.395, -5, 1.35),
            Ang = Angle(0, 0, 2),
            Magnification = 1,
        }
    },
    ["sights_flipped"] = {
        VMBodygroups = {{ind = 8, bg = 1}}
    },

    ["skin_black"] = {
        VMSkin = 1
    },
    ["skin_tan"] = {
        VMSkin = 2
    },
    ["skin_cust"] = {
        VMSkin = 3
    },

    ["stock_at"] = {
        VMBodygroups = {{ind = 4, bg = 1}}
    },
    ["stock_ru"] = {
        VMBodygroups = {{ind = 4, bg = 2}}
    },
    ["stock_ru_rubber"] = {
        VMBodygroups = {{ind = 4, bg = 3}}
    },
    ["stock_fixed"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 5, bg = 1},
        }
    },
    ["stock_none"] = {
        VMBodygroups = {
            {ind = 4, bg = 5},
        }
    },
}

SWEP.ExtraSightDist = 2
SWEP.GuaranteeLaser = true

SWEP.WorldModelOffset = {
    pos = Vector(-7, 5, -4.8),
    ang = Angle(-12, 0, 180)
}

SWEP.MirrorVMWM = true

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        DefaultAttIcon = Material("entities/att/ur_aw/ironsights.png", "mips smooth"),
        Slot = {"optic","optic_lp","optic_sniper"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 6, 2.65),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 180, 0),
        VMScale = Vector(1.05, 1.05, 1.05),
        SlideAmount = {
            vmin = Vector(0, 5.5, 2.65),
            vmax = Vector(0, 7, 2.65),
        },
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "24\" Police Barrel",
        DefaultAttIcon = Material("entities/att/ur_aw/bar_def.png", "mips smooth"),
        Slot = "ur_aw_barrel",
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle","ur_aw_muzzle"},
        Bone = "tag_weapon",
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = VMScale,
        Offset = {
            vpos = Vector(0, 35.2, 1.675),
            vang = Angle(0, 270, 0),
        },
        ExcludeFlags = {"barrel_sd"},
        Installed = "ur_aw_muzzle_brake",
    },
    {
        PrintName = "Caliber",
        DefaultAttName = "7.62x51mm NATO",
        DefaultAttIcon = Material("entities/att/uc_bullets/762x51.png", "mips smooth"),
        Slot = {"ur_aw_cal"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_aw_mag"},
        DefaultAttName = "5-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_aw/mag308_5.png", "mips smooth"),
        ExcludeFlags = {"mag_338"}
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,16, -.6),
            vang = Angle(90, -90, -90),
        },
        VMScale = Vector(1, 1, 1),
        InstalledEles = {"rail_bottom"},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-1.2, 16, 1.1),
            vang = Angle(-90, 270, 0),
        },
        GivesFlags = {"tac"},
        InstalledEles = {"rail_top"}
    },
    {
        PrintName = "Stock",
        Slot = {"ur_aw_stock"},
        DefaultAttName = "Factory Stock",
        DefaultAttIcon = Material("entities/att/ur_aw/stock_def.png", "mips smooth"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
        HideIfBlocked = true
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"},
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(.85, 4.6, 0.5),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "Finish",
        Slot = {"ur_aw_skin"},
        FreeSlot = true,
        DefaultAttName = "Olive Drab",
        DefaultAttIcon = Material("entities/att/ur_aw/skin_green.png", "mips smooth"),
    }
}


function SWEP:Hook_TranslateAnimation(anim)

end

SWEP.Hook_NameChange = function(wep,name)
    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default", "ur_aw_barrel_", "")
    local cal = string.Replace(atts[4].Installed or "default", "ur_aw_cal_", "")
    local stock = string.Replace(atts[8].Installed or "default", "ur_aw_stock_", "")

    if GetConVar("arccw_truenames"):GetBool() then
        if cal ~= "default" then
            return "AWM"
        elseif barr == "sd" then
            return "AWS"
        elseif stock == "at" then
            return "AT"
        end
    else
        if cal == "338" then
            return "Apex Magnum"
        elseif barr == "sd" then
            return "Apex Spectre"
        elseif stock == "at" then
            return "Apex Tactical"
        end
    end
end

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local vm = data.vm
    if !IsValid(vm) then return end

    local atts = wep.Attachments
    local cal = string.Replace(atts[4].Installed or "default", "ur_aw_cal_", "")
    local mag = string.Replace(atts[5].Installed or "default", "ur_aw_mag_", "")
    local flags = wep:GetWeaponFlags()

    local pistolGrip = table.HasValue(flags,"pistolgrip")

    if cal ~= "default" then
        if pistolGrip then
            vm:SetBodygroup(1,3)
        else
            vm:SetBodygroup(1,1)
        end
    elseif pistolGrip then
        vm:SetBodygroup(1,2)
    else
        vm:SetBodygroup(1,0)
    end

    if atts[1].Installed then
        if table.HasValue(flags,"sights_compact") then
            vm:SetBodygroup(8,3)
        else
            vm:SetBodygroup(8,1)
        end
    end

    if mag == "10" then
        vm:SetBodygroup(3,1)
    elseif mag == "10m" then
        vm:SetBodygroup(3,3)
    elseif cal ~= "default" then
        vm:SetBodygroup(3,2)
    end
end

SWEP.Animations = {
    ["ready"] = {
        Source = "cycle",
         Time = 1.47,
        MinProgress = 1.3,
        SoundTable = {
            {s = ratel,                             t = 0.07},
            {s = testpath .. "boltup.ogg",          t = 0.1},
            {s = testpath .. "boltback.ogg",        t = 0.2},
            {s = testpath .. "boltforward.ogg",     t = 0.32},
            {s = testpath .. "boltdown.ogg",        t = 0.6},
        },
        ProcDraw = true,
    },
    ["idle"] = {
        Source = "idle"
    },
    ["idle_empty"] = {
        Source = "idle_empty"
    },
    ["draw"] = {
        Source = "draw",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        Time = 35 / 30,
        MinProgess = .5,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        Time = .75,
        SoundTable = {
            {s = ratel, t = 0},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 35 / 30,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
        },
    },
    ["fire"] = {
        Source = {"fire"},
        Time = 27 / 30,
        MinProgress = 0.2,
        SoundTable = {
            SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
        },
    },

    ["fire_iron"] = {
        Source = {"fire_iron"},
        Time = 27 / 30,
        MinProgress = 0.2,
        SoundTable = {
            SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
        },
    },

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1,
        Time = 85 / 30,
        LHIKEaseOut = 0.25,
        MinProgress = 1.5,
        SoundTable = {
            {s = rottle,                             t = 0.1},
            {s = testpath .. "magrel.ogg", 	t = 0.2},
            {s = testpath .. "magout.ogg",          t = 0.3},
            {s = rottle,    t = 0.75},
            {s = common .. "magpouch.ogg",           t = 0.8, v = 0.4},
            {s = testpath .. "struggle.ogg",   t = 0.9},
            {s = testpath .. "magin.ogg",   t = 1.2},
            {s = rottle,    t = 1.4},
            {s = ratel,   t = 1.5},
        },
    },
    ["reload_10"] = {
        Source = "reload_exte",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1.15,
        LHIKEaseOut = 0.25,
        MinProgress = 2.5,
        SoundTable = {
            {s = rottle,                             t = 0.1},
            {s = testpath .. "magrel.ogg", 	t = 0.2},
            {s = testpath .. "magout.ogg",          t = 0.3},
            {s = rottle,    t = 0.75},
            {s = common .. "magpouch.ogg",           t = 0.8, v = 0.4},
            {s = testpath .. "struggle.ogg",   t = 0.9},
            {s = testpath .. "magin.ogg",   t = 1.2},
            {s = rottle,    t = 1.4},
            {s = ratel,   t = 1.5},
        },
    },
    ["reload_338"] = {
        Source = "reload_magnum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1.15,
        LHIKEaseOut = 0.25,
        MinProgress = 2.5,
        Time = 3.4,
        SoundTable = {
            {s = rottle,                             t = 0.1},
            {s = testpath .. "magrel.ogg", 	t = 0.2},
            {s = testpath .. "magout.ogg",          t = 0.4},
            {s = rottle,    t = 0.75},
            {s = common .. "magpouch.ogg",           t = 0.8, v = 0.4},
            {s = testpath .. "struggle.ogg",   t = 1.1, v = 1.1},
            {s = testpath .. "magin.ogg",   t = 1.3},
            {s = testpath .. "magtap.ogg",   t = 1.95},
            {s = rottle,    t = 2.3, v = 0.6},
            {s = ratel,   t = 2.35, v = 0.6},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = false,
        LHIKIn = 0.9,
        LHIKOut = 1.25,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.5,
        MinProgress = 3.0,
        ShellEjectAt = .45,
        LastClip1OutTime = 1.8,
        Time = 4.5,
        SoundTable = {
            {s = ratel,                             t = 0.05},
            {s = testpath .. "boltup.ogg",          t = 0.15},
            {s = testpath .. "boltback_reload.ogg",        t = 0.18},
            {s = testpath .. "eject.ogg",           t = 0.45},
            {s = rottle,    t = 0.6},
            {s = testpath .. "magrel.ogg", 	t = 1.0},
            {s = testpath .. "magout_empty.ogg",          t = 1.2},
            {s = rottle,    t = 1.25},
            {s = testpath .. "magdrop_metal.ogg",          t = 1.5, v = 0.4},
            {s = common .. "magpouch.ogg",           t = 1.6, v = 0.4},
            {s = rottle,    t = 1.65},
            {s = testpath .. "struggle.ogg",   t = 2},
            {s = testpath .. "magin.ogg",   t = 2.1},
            {s = rottle,    t = 2.4},
            {s = ratel,   t = 2.6},
            {s = testpath .. "boltforward_reload.ogg",     t = 2.7},
            {s = testpath .. "boltdown.ogg",        t = 3.1},
            {s = common .. "shoulder.ogg",        t = 3.15},
        },
    },
    ["reload_empty_10"] = {
        Source = "reload_empty_exte",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = false,
        LHIKIn = 0.9,
        LHIKOut = 1.25,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.5,
        ShellEjectAt = .5,
        MinProgress = 3.5,
        LastClip1OutTime = 1.8,
        Time = 4.5,
        SoundTable = {
            {s = ratel,                             t = 0.05},
            {s = testpath .. "boltup.ogg",          t = 0.15},
            {s = testpath .. "boltback_reload.ogg",        t = 0.18},
            {s = testpath .. "eject.ogg",           t = 0.45},
            {s = rottle,    t = .6},
            {s = testpath .. "magrel.ogg", 	t = 1.0},
            {s = testpath .. "magout_empty.ogg",          t = 1.2},
            {s = rottle,    t = 1.25},
            {s = testpath .. "magdrop_metal.ogg",          t = 1.6, v = 0.4},
            {s = common .. "magpouch.ogg",           t = 1.6, v = 0.4},
            {s = rottle,    t = 1.65},
            {s = testpath .. "struggle.ogg",   t = 2.1},
            {s = testpath .. "magin.ogg",   t = 2.2},
            {s = rottle,    t = 2.5},
            {s = testpath .. "boltforward_reload.ogg",     t = 2.8},
            {s = ratel,   t = 2.7},
            {s = testpath .. "boltdown.ogg",        t = 3.2},
            {s = common .. "shoulder.ogg",        t = 3.2},
        },
    },
    ["reload_empty_338"] = {
        Source = "reload_empty_magnum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = false,
        LHIKIn = 0.9,
        LHIKOut = 1.25,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.5,
        ShellEjectAt = .5,
        LastClip1OutTime = 1.5,
        MinProgress = 4,
        Time = 4.25,
        SoundTable = {
            {s = ratel,                             t = 0.05},
            {s = testpath .. "boltup.ogg",          t = 0.15},
            {s = testpath .. "boltback_reload.ogg",        t = 0.18},
            {s = testpath .. "eject.ogg",           t = 0.45},
            {s = rottle,    t = 0.6},
            {s = testpath .. "magrel.ogg", 	t = 1.0},
            {s = testpath .. "magout_empty.ogg",          t = 1.1},
            {s = rottle,    t = 1.25},
            {s = testpath .. "magdrop_metal.ogg",          t = 1.5, v = 0.4},
            {s = common .. "magpouch.ogg",           t = 1.6, v = 0.4},
            {s = rottle,    t = 1.65},
            {s = testpath .. "struggle.ogg",   t = 1.8},
            {s = testpath .. "magin.ogg",   t = 1.9},
            {s = rottle,    t = 2.4},
            {s = testpath .. "magtap.ogg",   t = 2.5},
            {s = ratel,   t = 2.6},
            {s = testpath .. "boltforward_reload.ogg",     t = 2.7},
            {s = testpath .. "boltdown.ogg",        t = 3.1},
            {s = common .. "shoulder.ogg",        t = 3.15},
        },
    },
    ["reload_empty_10_338"] = {
        Source = "reload_empty_exte_magnum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.9,
        LHIKOut = 1.25,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.5,
        MinProgress = 4,
        LastClip1OutTime = 2.3,
        Time = 4.5,
        ShellEjectAt = .5,
        SoundTable = {
            {s = ratel,                             t = 0.05},
            {s = testpath .. "boltup.ogg",          t = 0.15},
            {s = testpath .. "boltback_reload.ogg",        t = 0.18},
            {s = testpath .. "eject.ogg",           t = 0.45},
            {s = rottle,    t = 0.6},
            {s = testpath .. "magrel.ogg", 	t = 1.0},
            {s = testpath .. "magout_empty.ogg",          t = 1.1},
            {s = rottle,    t = 1.25},
            {s = testpath .. "magdrop_metal.ogg",          t = 1.5, v = 0.4},
            {s = common .. "magpouch.ogg",           t = 1.6, v = 0.4},
            {s = rottle,    t = 1.65},
            {s = testpath .. "struggle.ogg",   t = 1.85},
            {s = testpath .. "magin.ogg",   t = 2.0},
            {s = rottle,    t = 2.4},
            {s = testpath .. "magtap.ogg",   t = 2.6},
            {s = ratel,   t = 2.6},
            {s = testpath .. "boltforward_reload.ogg",     t = 2.9},
            {s = testpath .. "boltdown.ogg",        t = 3.3},
            {s = common .. "shoulder.ogg",        t = 3.35},
        },
    },
    ["reload_10_338"] = {
        Source = "reload_exte_magnum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 3,
        Time = 3.5,
        SoundTable = {
            {s = rottle,                             t = 0.1},
            {s = testpath .. "magrel.ogg", 	t = 0.2},
            {s = testpath .. "magout.ogg",          t = 0.4},
            {s = rottle,    t = 0.75},
            {s = common .. "magpouch.ogg",           t = 0.8, v = 0.4},
            {s = testpath .. "struggle.ogg",   t = 1.1, v = 1},
            {s = testpath .. "magin.ogg",   t = 1.4},
            {s = testpath .. "magtap.ogg",   t = 2.0},
            {s = rottle,    t = 2.3, v = 0.6},
            {s = ratel,   t = 2.35, v = 0.6},
        },
    },
    ["cycle"] = {
        Source = "cycle",
        Time = 1.47,
        ShellEjectAt = 0.4,
        MinProgress = 0.9,
        SoundTable = {
            {s = ratel,                             t = 0.07},
            {s = testpath .. "boltup.ogg",          t = 0.1},
            {s = testpath .. "boltback.ogg",        t = 0.2},
            {s = testpath .. "boltforward.ogg",     t = 0.32},
            {s = testpath .. "eject.ogg",           t = 0.4},
            {s = testpath .. "boltdown.ogg",        t = 0.6},

            --{s = common .. "shoulder.ogg",          t = 0.7},
        },
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-sniper-03.ogg", t = 0.05},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-sniper-01.ogg", t = 0},
            {s = rottle, t = 0.25},
            {s = testpath .. "boltup_inspect.ogg",          t = 1.2},
            {s = common .. "movement-sniper-03.ogg", t = 1.25},
            {s = testpath .. "boltback_inspect.ogg",        t = 1.35},
            {s = testpath .. "boltforward_inspect.ogg",     t = 1.8},
            {s = testpath .. "boltdown_inspect.ogg",        t = 1.9},
            {s = rottle, t = 2.0},
            {s = common .. "movement-sniper-04.ogg", t = 2.2},
        },
    },
    ["enter_inspect_empty"] = { -- Animations needed!
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = rutle, t = 0.1},
        },
    },
    ["idle_inspect_empty"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect_empty"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-sniper-01.ogg", t = 0.05},
            {s = rottle, t = 0.25},
            {s = testpath .. "boltup_inspect.ogg",          t = 1.2},
            {s = common .. "movement-sniper-03.ogg", t = 1.25},
            {s = testpath .. "boltback_inspect.ogg",        t = 1.35},
            {s = testpath .. "boltforward_inspect.ogg",     t = 1.8},
            {s = testpath .. "boltdown_inspect.ogg",        t = 1.9},
            {s = rottle, t = 2.0},
            {s = common .. "movement-sniper-04.ogg", t = 2.2},
        },
    },
}

SWEP.Hook_Think = ArcCW.UC.ADSReload

--lua/weapons/arccw_ur_aw.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true -- this obviously has to be set to true
SWEP.Category = "ArcCW - Urban Coalition" -- edit this if you like
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false

SWEP.PrintName = "AWP"

SWEP.Trivia_Class = "Sniper Rifle"
SWEP.Trivia_Desc = "A heavy rifle purpose-built for extreme range combat under extreme climates, first developed for the British military but quickly adopted by many more. Iconic for its appearance among military and police marksmen, this rifle is a symbol of discipline and order.\n\nOffers outstanding precision and kill potential, but its long bolt pull and reload time can become a hinderance outside its ideal engagement range.\n\nOne shot. One kill. You know the routine."
SWEP.Trivia_Manufacturer = "Accuracy International"
SWEP.Trivia_Calibre = "7.62x51mm NATO"
SWEP.Trivia_Mechanism = "Bolt Action"
SWEP.Trivia_Country = "United Kingdom"
SWEP.Trivia_Year = 1982

if !GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = "Apex Precision"
    SWEP.Trivia_Manufacturer = "Marksman Institute"
end


SWEP.Slot = 3
SWEP.CamAttachment = 3

SWEP.UseHands = true

SWEP.ViewModel = "models/weapons/arccw/c_ur_aw.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_aw.mdl"
SWEP.ViewModelFOV = 70

SWEP.DefaultBodygroups = "000000000000"

SWEP.BulletBones = {
    --[1] = "top_round",
    [2] = "mag_round",
}

-- Damage --

SWEP.Damage = 80 -- 2 shot close range
SWEP.DamageMin = 50 -- 2 shot long range
SWEP.RangeMin = 100
SWEP.Range = 400 -- 2 shot at ~300m

SWEP.Penetration = 18
SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 850
SWEP.PhysBulletMuzzleVelocity = 850

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 5
SWEP.ExtendedClipSize = 10
SWEP.ReducedClipSize = 5

-- Recoil --

SWEP.Recoil = 1.75
SWEP.RecoilSide = 0.75

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 0.3
SWEP.VisualRecoilMult = 5
SWEP.MaxRecoilBlowback = 4
SWEP.MaxRecoilPunch = 4
SWEP.RecoilPunchBack = 3
SWEP.RecoilPunchBackMax = 3.5
SWEP.RecoilPunchBackMaxSights = 2.5

SWEP.Sway = 0.2

-- Firerate / Firemodes --

SWEP.Delay = 60 / 80
SWEP.Num = 1
SWEP.Firemodes = {
    {
        PrintName = "fcg.bolt",
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_crossbow"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = .25
SWEP.HipDispersion = 1250
SWEP.MoveDispersion = 500
SWEP.JumpDispersion = 700 -- tactical unrealism    set to 700 later

SWEP.Primary.Ammo = "ar2"
SWEP.MagID = "awp"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

-- SWEP.Malfunction = true
SWEP.MalfunctionMean = 200
--SWEP.MeleeTime = 1.5

-- Speed multipliers --

SWEP.SpeedMult = 0.8
SWEP.SightedSpeedMult = 0.625
SWEP.SightTime = 0.35
SWEP.ShootSpeedMult = 0.625

local path = ")weapons/arccw_ur/ak/"

local testpath = ")weapons/arccw_ur/aw_placeholders/"
local path1 = ")weapons/arccw_ur/aw_placeholders/338/"

local path1 = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"
local rottle = {common .. "cloth_1.ogg", common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rutle = {common .. "movement-sniper-03.ogg",common .. "movement-sniper-04.ogg"}

SWEP.ShootSound = {
    testpath .. "fire-01.ogg",
    testpath .. "fire-02.ogg",
    testpath .. "fire-03.ogg",
    testpath .. "fire-04.ogg",
    testpath .. "fire-05.ogg",
    testpath .. "fire-06.ogg"
}
SWEP.ShootSoundSilenced = {
    testpath .. "fire-sup-01.ogg",
    testpath .. "fire-sup-02.ogg",
    testpath .. "fire-sup-03.ogg",
    testpath .. "fire-sup-04.ogg",
    testpath .. "fire-sup-05.ogg",
    testpath .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = testpath .. "dryfire.ogg"

local tail = ")/arccw_uc/common/308/"

SWEP.DistantShootSoundOutdoors = {
    tail .. "fire-dist-308-rif-ext-01.ogg",
    tail .. "fire-dist-308-rif-ext-02.ogg",
    tail .. "fire-dist-308-rif-ext-03.ogg",
    tail .. "fire-dist-308-rif-ext-04.ogg",
    tail .. "fire-dist-308-rif-ext-05.ogg",
    tail .. "fire-dist-308-rif-ext-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-shotgun-01.ogg",
    common .. "fire-dist-int-shotgun-02.ogg",
    common .. "fire-dist-int-shotgun-03.ogg",
    common .. "fire-dist-int-shotgun-04.ogg",
    common .. "fire-dist-int-shotgun-05.ogg",
    common .. "fire-dist-int-shotgun-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 1
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

SWEP.MuzzleEffect = "muzzleflash_ak47"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/556x45.mdl"
SWEP.ShellPitch = 90
SWEP.ShellScale = 1.145
SWEP.ShellRotateAngle = Angle(0, 0, 0)

SWEP.ManualAction = true
-- SWEP.ManualAction = false
SWEP.NoLastCycle = true

SWEP.MuzzleEffectAttachment = 1 -- which attachment to put the muzzle on
SWEP.CaseEffectAttachment = 2 -- which attachment to put the case effect on

SWEP.IronSightStruct = {
    Pos = Vector(-3.37, -5, 0.68),
    Ang = Angle(0, 0, 2),
    Magnification = 1.1,
    SwitchToSound = "", -- sound that plays when switching to this sight
    CrosshairInSights = false
}
SWEP.LaserOffsetAngle = Angle(0, 0, 0)
SWEP.LaserIronsAngle = Angle(0, 1.5, 0)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2

SWEP.ActivePos = Vector(-0.1, 0.1, 0.2)
SWEP.ActiveAng = Angle(0, 0, -1)

SWEP.SprintPos = Vector(-1, -1, 1.2)
SWEP.SprintAng = Angle(-15, 8, -10)

SWEP.CrouchPos = Vector(-2, -2, -0.8)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.HolsterPos = Vector(-1, -1, 1.2)
SWEP.HolsterAng = Angle(-15, 8, -10)

SWEP.BarrelOffsetSighted = Vector(0, 0, 0)
SWEP.BarrelOffsetHip = Vector(0, 0, 0)

SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

-- SWEP.CustomizePos = Vector(6.5, 0.8, -0.2)
-- SWEP.CustomizeAng = Angle(8, 18, 15)

SWEP.BarrelLength = 54

SWEP.AttachmentElements = {
    ["barrel_long"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
        AttPosMods = {[3] = {
            vpos = Vector(0, 40, 1.75),
            vang = Angle(0, 270, 0),
        }}
    },
    ["barrel_short"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
        AttPosMods = {[3] = {
            vpos = Vector(0, 28, 1.75),
            vang = Angle(0, 270, 0),
        }}
    },
    ["barrel_sd"] = {
        VMBodygroups = {{ind = 2, bg = 3}}
    },

    ["mag_338"] = {
        --VMBodygroups = {{ind = 3, bg = 2}}
    },
    ["mag_300"] = {
        --VMBodygroups = {{ind = 3, bg = 2}}
    },
    ["mag_ext"] = {
        --VMBodygroups = {{ind = 3, bg = 1}}
    },
    ["mag_ext_magnum"] = {
        --VMBodygroups = {{ind = 3, bg = 3}}
    },

    ["rail_bottom"] = {
        VMBodygroups = {{ind = 6, bg = 1}}
    },
    ["rail_top"] = {
        VMBodygroups = {{ind = 7, bg = 1}}
    },
    ["sights_compact"] = {
        VMBodygroups = {{ind = 8, bg = 2}},
        Override_IronSightStruct = {
            Pos = Vector(-3.395, -5, 1.35),
            Ang = Angle(0, 0, 2),
            Magnification = 1,
        }
    },
    ["sights_flipped"] = {
        VMBodygroups = {{ind = 8, bg = 1}}
    },

    ["skin_black"] = {
        VMSkin = 1
    },
    ["skin_tan"] = {
        VMSkin = 2
    },
    ["skin_cust"] = {
        VMSkin = 3
    },

    ["stock_at"] = {
        VMBodygroups = {{ind = 4, bg = 1}}
    },
    ["stock_ru"] = {
        VMBodygroups = {{ind = 4, bg = 2}}
    },
    ["stock_ru_rubber"] = {
        VMBodygroups = {{ind = 4, bg = 3}}
    },
    ["stock_fixed"] = {
        VMBodygroups = {
            {ind = 4, bg = 4},
            {ind = 5, bg = 1},
        }
    },
    ["stock_none"] = {
        VMBodygroups = {
            {ind = 4, bg = 5},
        }
    },
}

SWEP.ExtraSightDist = 2
SWEP.GuaranteeLaser = true

SWEP.WorldModelOffset = {
    pos = Vector(-7, 5, -4.8),
    ang = Angle(-12, 0, 180)
}

SWEP.MirrorVMWM = true

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        DefaultAttIcon = Material("entities/att/ur_aw/ironsights.png", "mips smooth"),
        Slot = {"optic","optic_lp","optic_sniper"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0, 6, 2.65),
            vang = Angle(0, -90, 0),
        },
        CorrectivePos = Vector(0, 0, 0),
        CorrectiveAng = Angle(0, 180, 0),
        VMScale = Vector(1.05, 1.05, 1.05),
        SlideAmount = {
            vmin = Vector(0, 5.5, 2.65),
            vmax = Vector(0, 7, 2.65),
        },
    },
    {
        PrintName = "Barrel",
        DefaultAttName = "24\" Police Barrel",
        DefaultAttIcon = Material("entities/att/ur_aw/bar_def.png", "mips smooth"),
        Slot = "ur_aw_barrel",
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle","ur_aw_muzzle"},
        Bone = "tag_weapon",
        VMScale = Vector(1.5, 1.5, 1.5),
        WMScale = VMScale,
        Offset = {
            vpos = Vector(0, 35.2, 1.675),
            vang = Angle(0, 270, 0),
        },
        ExcludeFlags = {"barrel_sd"},
        Installed = "ur_aw_muzzle_brake",
    },
    {
        PrintName = "Caliber",
        DefaultAttName = "7.62x51mm NATO",
        DefaultAttIcon = Material("entities/att/uc_bullets/762x51.png", "mips smooth"),
        Slot = {"ur_aw_cal"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(2.8, -4.2, -11.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_aw_mag"},
        DefaultAttName = "5-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_aw/mag308_5.png", "mips smooth"),
        ExcludeFlags = {"mag_338"}
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(0,16, -.6),
            vang = Angle(90, -90, -90),
        },
        VMScale = Vector(1, 1, 1),
        InstalledEles = {"rail_bottom"},
    },
    {
        PrintName = "Tactical",
        Slot = {"tac"},
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(-1.2, 16, 1.1),
            vang = Angle(-90, 270, 0),
        },
        GivesFlags = {"tac"},
        InstalledEles = {"rail_top"}
    },
    {
        PrintName = "Stock",
        Slot = {"ur_aw_stock"},
        DefaultAttName = "Factory Stock",
        DefaultAttIcon = Material("entities/att/ur_aw/stock_def.png", "mips smooth"),
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
        HideIfBlocked = true
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load"
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm"},
        FreeSlot = true,
        Bone = "tag_weapon",
        Offset = {
            vpos = Vector(.85, 4.6, 0.5),
            vang = Angle(90, -90, -90),
        },
    },
    {
        PrintName = "Finish",
        Slot = {"ur_aw_skin"},
        FreeSlot = true,
        DefaultAttName = "Olive Drab",
        DefaultAttIcon = Material("entities/att/ur_aw/skin_green.png", "mips smooth"),
    }
}


function SWEP:Hook_TranslateAnimation(anim)

end

SWEP.Hook_NameChange = function(wep,name)
    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default", "ur_aw_barrel_", "")
    local cal = string.Replace(atts[4].Installed or "default", "ur_aw_cal_", "")
    local stock = string.Replace(atts[8].Installed or "default", "ur_aw_stock_", "")

    if GetConVar("arccw_truenames"):GetBool() then
        if cal ~= "default" then
            return "AWM"
        elseif barr == "sd" then
            return "AWS"
        elseif stock == "at" then
            return "AT"
        end
    else
        if cal == "338" then
            return "Apex Magnum"
        elseif barr == "sd" then
            return "Apex Spectre"
        elseif stock == "at" then
            return "Apex Tactical"
        end
    end
end

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local vm = data.vm
    if !IsValid(vm) then return end

    local atts = wep.Attachments
    local cal = string.Replace(atts[4].Installed or "default", "ur_aw_cal_", "")
    local mag = string.Replace(atts[5].Installed or "default", "ur_aw_mag_", "")
    local flags = wep:GetWeaponFlags()

    local pistolGrip = table.HasValue(flags,"pistolgrip")

    if cal ~= "default" then
        if pistolGrip then
            vm:SetBodygroup(1,3)
        else
            vm:SetBodygroup(1,1)
        end
    elseif pistolGrip then
        vm:SetBodygroup(1,2)
    else
        vm:SetBodygroup(1,0)
    end

    if atts[1].Installed then
        if table.HasValue(flags,"sights_compact") then
            vm:SetBodygroup(8,3)
        else
            vm:SetBodygroup(8,1)
        end
    end

    if mag == "10" then
        vm:SetBodygroup(3,1)
    elseif mag == "10m" then
        vm:SetBodygroup(3,3)
    elseif cal ~= "default" then
        vm:SetBodygroup(3,2)
    end
end

SWEP.Animations = {
    ["ready"] = {
        Source = "cycle",
         Time = 1.47,
        MinProgress = 1.3,
        SoundTable = {
            {s = ratel,                             t = 0.07},
            {s = testpath .. "boltup.ogg",          t = 0.1},
            {s = testpath .. "boltback.ogg",        t = 0.2},
            {s = testpath .. "boltforward.ogg",     t = 0.32},
            {s = testpath .. "boltdown.ogg",        t = 0.6},
        },
        ProcDraw = true,
    },
    ["idle"] = {
        Source = "idle"
    },
    ["idle_empty"] = {
        Source = "idle_empty"
    },
    ["draw"] = {
        Source = "draw",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        Time = 35 / 30,
        MinProgess = .5,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
        },
    },
    ["holster"] = {
        Source = "holster",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        Time = .75,
        SoundTable = {
            {s = ratel, t = 0},
        },
    },
    ["draw_empty"] = {
        Source = "draw_empty",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 35 / 30,
        SoundTable = {
            {s = ratel, t = 0},
            {s = common .. "raise.ogg", t = 0.2},
        },
    },
    ["holster_empty"] = {
        Source = "holster_empty",
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 0.5,
        SoundTable = {
            {s = ratel, t = 0},
        },
    },
    ["fire"] = {
        Source = {"fire"},
        Time = 27 / 30,
        MinProgress = 0.2,
        SoundTable = {
            SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
        },
    },

    ["fire_iron"] = {
        Source = {"fire_iron"},
        Time = 27 / 30,
        MinProgress = 0.2,
        SoundTable = {
            SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
        },
    },

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1,
        Time = 85 / 30,
        LHIKEaseOut = 0.25,
        MinProgress = 1.5,
        SoundTable = {
            {s = rottle,                             t = 0.1},
            {s = testpath .. "magrel.ogg", 	t = 0.2},
            {s = testpath .. "magout.ogg",          t = 0.3},
            {s = rottle,    t = 0.75},
            {s = common .. "magpouch.ogg",           t = 0.8, v = 0.4},
            {s = testpath .. "struggle.ogg",   t = 0.9},
            {s = testpath .. "magin.ogg",   t = 1.2},
            {s = rottle,    t = 1.4},
            {s = ratel,   t = 1.5},
        },
    },
    ["reload_10"] = {
        Source = "reload_exte",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1.15,
        LHIKEaseOut = 0.25,
        MinProgress = 2.5,
        SoundTable = {
            {s = rottle,                             t = 0.1},
            {s = testpath .. "magrel.ogg", 	t = 0.2},
            {s = testpath .. "magout.ogg",          t = 0.3},
            {s = rottle,    t = 0.75},
            {s = common .. "magpouch.ogg",           t = 0.8, v = 0.4},
            {s = testpath .. "struggle.ogg",   t = 0.9},
            {s = testpath .. "magin.ogg",   t = 1.2},
            {s = rottle,    t = 1.4},
            {s = ratel,   t = 1.5},
        },
    },
    ["reload_338"] = {
        Source = "reload_magnum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 1.15,
        LHIKEaseOut = 0.25,
        MinProgress = 2.5,
        Time = 3.4,
        SoundTable = {
            {s = rottle,                             t = 0.1},
            {s = testpath .. "magrel.ogg", 	t = 0.2},
            {s = testpath .. "magout.ogg",          t = 0.4},
            {s = rottle,    t = 0.75},
            {s = common .. "magpouch.ogg",           t = 0.8, v = 0.4},
            {s = testpath .. "struggle.ogg",   t = 1.1, v = 1.1},
            {s = testpath .. "magin.ogg",   t = 1.3},
            {s = testpath .. "magtap.ogg",   t = 1.95},
            {s = rottle,    t = 2.3, v = 0.6},
            {s = ratel,   t = 2.35, v = 0.6},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = false,
        LHIKIn = 0.9,
        LHIKOut = 1.25,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.5,
        MinProgress = 3.0,
        ShellEjectAt = .45,
        LastClip1OutTime = 1.8,
        Time = 4.5,
        SoundTable = {
            {s = ratel,                             t = 0.05},
            {s = testpath .. "boltup.ogg",          t = 0.15},
            {s = testpath .. "boltback_reload.ogg",        t = 0.18},
            {s = testpath .. "eject.ogg",           t = 0.45},
            {s = rottle,    t = 0.6},
            {s = testpath .. "magrel.ogg", 	t = 1.0},
            {s = testpath .. "magout_empty.ogg",          t = 1.2},
            {s = rottle,    t = 1.25},
            {s = testpath .. "magdrop_metal.ogg",          t = 1.5, v = 0.4},
            {s = common .. "magpouch.ogg",           t = 1.6, v = 0.4},
            {s = rottle,    t = 1.65},
            {s = testpath .. "struggle.ogg",   t = 2},
            {s = testpath .. "magin.ogg",   t = 2.1},
            {s = rottle,    t = 2.4},
            {s = ratel,   t = 2.6},
            {s = testpath .. "boltforward_reload.ogg",     t = 2.7},
            {s = testpath .. "boltdown.ogg",        t = 3.1},
            {s = common .. "shoulder.ogg",        t = 3.15},
        },
    },
    ["reload_empty_10"] = {
        Source = "reload_empty_exte",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = false,
        LHIKIn = 0.9,
        LHIKOut = 1.25,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.5,
        ShellEjectAt = .5,
        MinProgress = 3.5,
        LastClip1OutTime = 1.8,
        Time = 4.5,
        SoundTable = {
            {s = ratel,                             t = 0.05},
            {s = testpath .. "boltup.ogg",          t = 0.15},
            {s = testpath .. "boltback_reload.ogg",        t = 0.18},
            {s = testpath .. "eject.ogg",           t = 0.45},
            {s = rottle,    t = .6},
            {s = testpath .. "magrel.ogg", 	t = 1.0},
            {s = testpath .. "magout_empty.ogg",          t = 1.2},
            {s = rottle,    t = 1.25},
            {s = testpath .. "magdrop_metal.ogg",          t = 1.6, v = 0.4},
            {s = common .. "magpouch.ogg",           t = 1.6, v = 0.4},
            {s = rottle,    t = 1.65},
            {s = testpath .. "struggle.ogg",   t = 2.1},
            {s = testpath .. "magin.ogg",   t = 2.2},
            {s = rottle,    t = 2.5},
            {s = testpath .. "boltforward_reload.ogg",     t = 2.8},
            {s = ratel,   t = 2.7},
            {s = testpath .. "boltdown.ogg",        t = 3.2},
            {s = common .. "shoulder.ogg",        t = 3.2},
        },
    },
    ["reload_empty_338"] = {
        Source = "reload_empty_magnum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = false,
        LHIKIn = 0.9,
        LHIKOut = 1.25,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.5,
        ShellEjectAt = .5,
        LastClip1OutTime = 1.5,
        MinProgress = 4,
        Time = 4.25,
        SoundTable = {
            {s = ratel,                             t = 0.05},
            {s = testpath .. "boltup.ogg",          t = 0.15},
            {s = testpath .. "boltback_reload.ogg",        t = 0.18},
            {s = testpath .. "eject.ogg",           t = 0.45},
            {s = rottle,    t = 0.6},
            {s = testpath .. "magrel.ogg", 	t = 1.0},
            {s = testpath .. "magout_empty.ogg",          t = 1.1},
            {s = rottle,    t = 1.25},
            {s = testpath .. "magdrop_metal.ogg",          t = 1.5, v = 0.4},
            {s = common .. "magpouch.ogg",           t = 1.6, v = 0.4},
            {s = rottle,    t = 1.65},
            {s = testpath .. "struggle.ogg",   t = 1.8},
            {s = testpath .. "magin.ogg",   t = 1.9},
            {s = rottle,    t = 2.4},
            {s = testpath .. "magtap.ogg",   t = 2.5},
            {s = ratel,   t = 2.6},
            {s = testpath .. "boltforward_reload.ogg",     t = 2.7},
            {s = testpath .. "boltdown.ogg",        t = 3.1},
            {s = common .. "shoulder.ogg",        t = 3.15},
        },
    },
    ["reload_empty_10_338"] = {
        Source = "reload_empty_exte_magnum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.9,
        LHIKOut = 1.25,
        LHIKEaseIn = 0.1,
        LHIKEaseOut = 0.5,
        MinProgress = 4,
        LastClip1OutTime = 2.3,
        Time = 4.5,
        ShellEjectAt = .5,
        SoundTable = {
            {s = ratel,                             t = 0.05},
            {s = testpath .. "boltup.ogg",          t = 0.15},
            {s = testpath .. "boltback_reload.ogg",        t = 0.18},
            {s = testpath .. "eject.ogg",           t = 0.45},
            {s = rottle,    t = 0.6},
            {s = testpath .. "magrel.ogg", 	t = 1.0},
            {s = testpath .. "magout_empty.ogg",          t = 1.1},
            {s = rottle,    t = 1.25},
            {s = testpath .. "magdrop_metal.ogg",          t = 1.5, v = 0.4},
            {s = common .. "magpouch.ogg",           t = 1.6, v = 0.4},
            {s = rottle,    t = 1.65},
            {s = testpath .. "struggle.ogg",   t = 1.85},
            {s = testpath .. "magin.ogg",   t = 2.0},
            {s = rottle,    t = 2.4},
            {s = testpath .. "magtap.ogg",   t = 2.6},
            {s = ratel,   t = 2.6},
            {s = testpath .. "boltforward_reload.ogg",     t = 2.9},
            {s = testpath .. "boltdown.ogg",        t = 3.3},
            {s = common .. "shoulder.ogg",        t = 3.35},
        },
    },
    ["reload_10_338"] = {
        Source = "reload_exte_magnum",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_AR2,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKOut = 0.65,
        LHIKEaseOut = 0.25,
        MinProgress = 3,
        Time = 3.5,
        SoundTable = {
            {s = rottle,                             t = 0.1},
            {s = testpath .. "magrel.ogg", 	t = 0.2},
            {s = testpath .. "magout.ogg",          t = 0.4},
            {s = rottle,    t = 0.75},
            {s = common .. "magpouch.ogg",           t = 0.8, v = 0.4},
            {s = testpath .. "struggle.ogg",   t = 1.1, v = 1},
            {s = testpath .. "magin.ogg",   t = 1.4},
            {s = testpath .. "magtap.ogg",   t = 2.0},
            {s = rottle,    t = 2.3, v = 0.6},
            {s = ratel,   t = 2.35, v = 0.6},
        },
    },
    ["cycle"] = {
        Source = "cycle",
        Time = 1.47,
        ShellEjectAt = 0.4,
        MinProgress = 0.9,
        SoundTable = {
            {s = ratel,                             t = 0.07},
            {s = testpath .. "boltup.ogg",          t = 0.1},
            {s = testpath .. "boltback.ogg",        t = 0.2},
            {s = testpath .. "boltforward.ogg",     t = 0.32},
            {s = testpath .. "eject.ogg",           t = 0.4},
            {s = testpath .. "boltdown.ogg",        t = 0.6},

            --{s = common .. "shoulder.ogg",          t = 0.7},
        },
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-sniper-03.ogg", t = 0.05},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-sniper-01.ogg", t = 0},
            {s = rottle, t = 0.25},
            {s = testpath .. "boltup_inspect.ogg",          t = 1.2},
            {s = common .. "movement-sniper-03.ogg", t = 1.25},
            {s = testpath .. "boltback_inspect.ogg",        t = 1.35},
            {s = testpath .. "boltforward_inspect.ogg",     t = 1.8},
            {s = testpath .. "boltdown_inspect.ogg",        t = 1.9},
            {s = rottle, t = 2.0},
            {s = common .. "movement-sniper-04.ogg", t = 2.2},
        },
    },
    ["enter_inspect_empty"] = { -- Animations needed!
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = rutle, t = 0.1},
        },
    },
    ["idle_inspect_empty"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect_empty"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-sniper-01.ogg", t = 0.05},
            {s = rottle, t = 0.25},
            {s = testpath .. "boltup_inspect.ogg",          t = 1.2},
            {s = common .. "movement-sniper-03.ogg", t = 1.25},
            {s = testpath .. "boltback_inspect.ogg",        t = 1.35},
            {s = testpath .. "boltforward_inspect.ogg",     t = 1.8},
            {s = testpath .. "boltdown_inspect.ogg",        t = 1.9},
            {s = rottle, t = 2.0},
            {s = common .. "movement-sniper-04.ogg", t = 2.2},
        },
    },
}

SWEP.Hook_Think = ArcCW.UC.ADSReload

--lua/weapons/arccw_ur_g3.lua:
return gluapack()()
--lua/weapons/arccw_ur_m1911.lua:
return gluapack()()
--lua/weapons/arccw_ur_mp510.lua:
return gluapack()()
--lua/weapons/arccw_ur_mp5.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Effects --

SWEP.MuzzleEffect = "muzzleflash_mp5"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
SWEP.ShellScale = 1
--SWEP.ShellMaterial = "models/weapons/arcticcw/shell_9mm"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.PistolShellSoundsTable

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
-- SWEP.CamAttachment = 3 ---------------------------------------------------------------------------
-- SWEP.TracerNum = 1
-- SWEP.TracerCol = Color(25, 255, 25)
-- SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "PK5-4"

-- True name --

SWEP.TrueName = "MP5A4"

-- Trivia --

SWEP.Trivia_Class = "Submachine Gun"
SWEP.Trivia_Desc = [[Versatile submachine gun known for its use by high profile police units around the world, most famously by the British SAS during the Iranian embassy siege. Its reliable closed-bolt design and craftsmanship allowed it to remain relevant among new generations of submachine guns.

If accurate, sophisticated close-combat performance is what you're looking for, no weapon has a better track record.

Switch to burst fire mode to reduce dispersion from moving and hipfiring.]]
SWEP.Trivia_Manufacturer = "Crowdley & Nelson"
SWEP.Trivia_Calibre = "9x19mm Parabellum"
SWEP.Trivia_Mechanism = "Roller-Delayed Blowback"
SWEP.Trivia_Country = "Germany"
SWEP.Trivia_Year = 1966

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Heckler & Koch"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ur_mp5.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_mp5.mdl"
SWEP.ViewModelFOV = 70
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.ProceduralIronFire = true

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["9mm"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["9mm"].min
SWEP.Penetration = ArcCW.UC.StdDmg["9mm"].pen
SWEP.RangeMin = 20
SWEP.Range = 100

SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 400
SWEP.PhysBulletMuzzleVelocity = 400

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 15

-- Recoil --

SWEP.Recoil = 0.22
SWEP.RecoilSide = 0.17

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1.25
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 0.6
SWEP.RecoilPunchBack = 1.5

SWEP.Sway = 0.25

-- Firerate / Firemodes --

SWEP.Delay = 60 / 800
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = -3,
        Mult_MoveDispersion = 0.75,
        Mult_HipDispersion = 0.9,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_smg1"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 3
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 150
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "pistol"
SWEP.MagID = "mp5"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 200

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.3
SWEP.ShootSpeedMult = 0.95

-- Length --

SWEP.BarrelLength = 24
SWEP.ExtraSightDist = 2

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, -2, 1)
SWEP.HolsterAng = Angle(-8.5, 8, -10)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-3.17, -1, 0.6),
     Ang = Angle(0.45, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}

SWEP.ActivePos = Vector(-0.3, 1.1, 0.6)
SWEP.ActiveAng = Angle(0, 0, -1)

-- SWEP.SprintPos = Vector(-0.5, 3, 1.5)
-- SWEP.SprintAng = Angle(-12, 15, -15)

SWEP.SprintPos = Vector(0, -3, 0)
SWEP.SprintAng = Angle(0, 0, 0)
-- SWEP.CustomizePos = Vector(6, -2, -1.5)
-- SWEP.CustomizeAng = Angle(16, 28, 0)
SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2, 0.5, 0)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.BarrelOffsetHip = Vector(4, 0, -4)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-8, 4, -5),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Firing sounds --
local path = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

SWEP.DistantShootSoundOutdoors = {
    path .. "fire-dist-01.ogg",
    path .. "fire-dist-02.ogg",
    path .. "fire-dist-03.ogg",
    path .. "fire-dist-04.ogg",
    path .. "fire-dist-05.ogg",
    path .. "fire-dist-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-pistol-01.ogg",
    common .. "fire-dist-int-pistol-02.ogg",
    common .. "fire-dist-int-pistol-03.ogg",
    common .. "fire-dist-int-pistol-04.ogg",
    common .. "fire-dist-int-pistol-05.ogg",
    common .. "fire-dist-int-pistol-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 0.6
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    -- [1] = "uzi_b1", [2] = "uzi_b2", [3] = "uzi_b3", [4] = "uzi_b4"
}

--[[

1 --- 	id: 0
     [	name: iron
    num: 1
    submodels:
    0 --- ironSIGHT.smd
2 --- 	id: 1
     [	name: 1
    num: 4
    submodels:
    0 --- mp5UPPER.smd
    1 --- mp5sdUPPER.smd
    2 --- mp5kUPPER.smd
    3 --- swordUPPER.smd
3 --- 	id: 2
     [	name: 2
    num: 2
    submodels:
    0 --- fourLOWER.smd
    1 --- sefLOWER.smd
4 --- 	id: 3
     [	name: 3
    num: 11
    submodels:
    0 --- fixedSTOCK.smd
    1 --- collapseSTOCK.smd
    2 --- collapseSTOCKcoll.smd
    3 --- pdwSTOCK.smd
    4 --- pdwSTOCKfold.smd
    5 --- tacticSTOCK.smd
    6 --- tacticSTOCKfold.smd
    7 --- futureSTOCK.smd
    8 --- futureSTOCKcoll.smd
    9 --- futureSTOCKfold.smd
    10 --- buttSTOCK.smd
5 --- 	id: 4
     [	name: 4
    num: 10
    submodels:
    0 --- standardHG.smd
    1 --- flashHG.smd
    2 --- flashmlokHG.smd
    3 --- slimHG.smd
    4 --- picaHG.smd
    5 --- mlokHG.smd
    6 --- kurzgripHG.smd
    7 --- kurzslimHG.smd
    8 --- kurzmlokHG.smd
    9 ---
6 --- 	id: 5
     [	name: 5
    num: 4
    submodels:
    0 --- standardMAG.smd
    1 --- smallMAG.smd
    2 --- straightMAG.smd
    3 --- drumMAG.smd
7 --- 	id: 6
     [	name: 6
    num: 2
    submodels:
    0 ---
    1 --- mp5RAIL.smd

]]

SWEP.AttachmentElements = {
    ["ur_mp5_barrel_sd"] = {
        VMBodygroups = {
            {ind = 1, bg = 1},
            {ind = 4, bg = 9},
            //{ind = 8, bg = 1},
        },
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 1.3, 10),
                vang = Angle(90, 0, -90),
            },
            [7] = {
				vpos = Vector(-1.15, 0.3, 8),
				vang = Angle(90, 0, 180),
			},
        },
    },
    ["ur_mp5_barrel_eod"] = {
        VMBodygroups = {
            {ind = 4, bg = 10},
            //{ind = 8, bg = 2},
        },
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 1.5, 10),
                vang = Angle(90, 0, -90),
            },
            [7] = {
				vpos = Vector(-0.95, 0.3, 8),
				vang = Angle(90, 0, 180),
			},
		}
    },
    ["ur_mp5_barrel_kurz"] = {
        VMBodygroups = {
            {ind = 1, bg = 2},
            {ind = 4, bg = 7},
        },
        AttPosMods = {[4] = {
            vpos = Vector(-0.1, 0.3, 11.5),
            vang = Angle(90, 0, -90),
        }}
    },
    ["ur_mp5_barrel_swordfish"] = {
        VMBodygroups = {
            --{ind = 0, bg = 1},
            {ind = 1, bg = 3},
            {ind = 6, bg = 0},
        },
    },

    ["ur_mp5_rail_fg"] = {
        VMBodygroups = {{ind = 4, bg = 4}},
    },
    ["ur_mp5_ub_classic"] = {
        VMBodygroups = {{ind = 4, bg = 3}},
    },
    ["ur_mp5_ub_surefire"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
    ["ur_mp5_ub_surelock"] = {
        VMBodygroups = {{ind = 4, bg = 2}},
    },
    ["ur_mp5_ub_kurzgrip"] = {
        VMBodygroups = {{ind = 4, bg = 6}},
    },
    ["ur_mp5_ub_kurzmlok"] = {
        VMBodygroups = {{ind = 4, bg = 8}},
    },
    ["ur_mp5_ub_wood"] = {
        VMBodygroups = {{ind = 4, bg = 3}}, -- insert wood handguard here
    },

    ["ur_mp5_mag_15"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
    ["ur_mp5_mag_40"] = {
        VMBodygroups = {{ind = 5, bg = 3}},
    },
    ["ur_mp5_mag_50"] = {
        VMBodygroups = {{ind = 5, bg = 3}},
    },
    ["ur_mp5_mag_waffle"] = {
        VMBodygroups = {{ind = 5, bg = 2}},
    },

    ["ur_mp5_rail_optic"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },

    ["ur_mp5_clamp"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },

    ["receiver_lower"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["receiver_lower_semi"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["receiver_lower_0"] = {
        VMBodygroups = {{ind = 2, bg = 0}},
    },
    ["receiver_upper_0"] = {
        VMBodygroups = {{ind = 7, bg = 0}},
    },

    ["stock_a3"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
        },
    },
    ["stock_a3_folded"] = {
        VMBodygroups = {
            {ind = 3, bg = 2},
        },
    },
    ["ur_mp5_stock_remove"] = {
        VMBodygroups = {{ind = 3, bg = 10}},
    },
    ["ur_mp5_stock_wood"] = {
        -- VMBodygroups = {{ind = 0, bg = 4}},
        -- Make this part of the VMSkin
    },
    ["stock_pdw"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
    ["stock_pdw_folded"] = {
        VMBodygroups = {{ind = 3, bg = 4}},
    },
    ["stock_ump"] = {
        VMBodygroups = {{ind = 3, bg = 5}},
    },
    ["stock_ump_folded"] = {
        VMBodygroups = {{ind = 3, bg = 6}},
    },
    ["stock_future"] = {
        VMBodygroups = {{ind = 3, bg = 7}},
    },
    ["stock_future_folded"] = {
        VMBodygroups = {{ind = 3, bg = 8}},
    },
    ["ur_mp5_precision_irons"] = {
        VMBodygroups = {
            {ind = 0, bg = 2},
            {ind = 6, bg = 0},
            },
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local atts = wep.Attachments
    local vm = data.vm
    if IsValid(vm) then
        local barr = string.Replace(atts[2].Installed or "default","ur_mp5_barrel_","")
        local hg = string.Replace(atts[5].Installed or "default","ur_mp5_ub_","")
        
        if atts[6].Installed or atts[7].Installed then
            if barr == "sd" then
                vm:SetBodygroup(8, 1)
            elseif barr == "eod" then
                vm:SetBodygroup(8, 2)
            elseif hg == "default" or hg == "classic" then
                vm:SetBodygroup(4, 4)
                vm:SetBodygroup(8, 0)
            else
                vm:SetBodygroup(8, 0)
            end
        else
            vm:SetBodygroup(8, 0)
        end

        if hg == "mlok" then
            if barr == "kurz" then
                vm:SetBodygroup(4,8)
            else
                vm:SetBodygroup(4,5)
            end
        end

        if barr == "sword" then
            vm:SetBodygroup(0,(atts[1].Installed and 3) or 1)
        end
    end
end

SWEP.Hook_NameChange = function(wep,name)
    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default","ur_mp5_barrel_","")
    local cal = string.Replace(atts[3].Installed or "default","ur_mp5_caliber_","")
    local stock = string.Replace(atts[8].Installed or "default","ur_mp5_stock_","")
    local fakeNames = !GetConVar("arccw_truenames"):GetBool()
    local defaultCals = {
        ["default"] = true,
        ["noburst"] = true,
        ["semi"] = true
    }

    local start = "MP5"
    local mid = "A"
    local num = "4"
    if fakeNames then
        start = "PK5"
        mid = "-"
    end

    if cal == "semi" or atts[12].Installed == "uc_fg_civvy" then
        if fakeNames then
            return "PK5-CIV"
        else
            if barr == "long" or barr == "sd" then
                start = "HK94" -- I know how prolific civies can get with their gunbuilds, so the nonsensical names will continue
            else
                return "SP5" .. ((barr == "kurz" and "K-PDW") or "")
            end
        end
    end

    if !defaultCals[cal] then
        if barr == "sd" then
            num = "SD"
        else
            num = ""
        end
        if cal == "10auto" then
            mid = "/10"
        elseif cal == "40sw" then
            mid = "/40"
        elseif cal == "22lr" then
            if barr == "sd" then
                mid = "SD"
                num = " .22 LR"
            else
                mid = " .22 LR"
            end
        end
    else
        if barr == "kurz" then
            if fakeNames then
                mid = "C"
            else
                mid = "K"
            end
            if stock == "pdw" then
                num = "-PDW"
            elseif cal == "default" then
                if fakeNames then
                    num = "-4"
                else
                    num = "A4"
                end
            else
                num = ""
            end
        else
            if barr == "sd" then
                mid = "SD"
            end

            if cal == "noburst" or cal == "semi" then
                if stock == "a3" then
                    num = "3"
                elseif stock == "none" then
                    num = "1"
                else
                    num = "2"
                end
            else
                if stock == "a3" then
                    if barr == "sd" then
                        num = "6"
                    else
                        num = "5"
                    end
                elseif stock == "none" then
                    if barr == "sd" then
                        num = "4"
                    end
                else
                    if barr == "sd" then
                        num = "5"
                    end
                end
            end
        end
    end

    return start .. mid .. num
end

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rottle = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local rutle = {common .. "movement-smg-03.ogg",common .. "movement-smg-04.ogg"}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    -- ["idle_empty"] = {
    --     Source = "idle",
    -- },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0.15},
            {s = path .. "rack1.ogg",         t = 0.15, c = ci},
            {s = path .. "rack2.ogg",         t = 0.38, c = ci},
            {s = ratel,         t = 0.75},
        }
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = ArcCW.UC.DrawSounds,
    },
    -- ["draw_empty"] = {
    --     Source = "draw_empty",
    --     SoundTable = ArcCW.UC.DrawSounds,
    -- },
    ["holster"] = {
        Source = "holster",
        --Time = 0.25,
        SoundTable = ArcCW.UC.HolsterSounds,
    },
    -- ["holster_empty"] = {
    --     Source = "holster_empty",
    --     --Time = 0.25,
    --     SoundTable = ArcCW.UC.HolsterSounds,
    -- },
    ["fire"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    -- ["fire_empty"] = {
    --     Source = "fire",
    --     Time = 13 / 30,
    --     ShellEjectAt = 0.03,
    --     SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    -- },
    ["fire_iron"] = {
        Source = "idle",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    -- ["fire_empty_iron"] = {
    --     Source = "idle",
    --     Time = 13 / 30,
    --     ShellEjectAt = 0.03,
    --     SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    -- },

    ["fix"] = {
        Source = "fix",
        Time = 40 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        ShellEjectAt = 0.36,
        SoundTable = {
            {s = rottle, t = 0.15},
            {s = path .. "rack1.ogg",         t = 0.27, c = ci},
            {s = path .. "rack2.ogg",         t = 0.5, c = ci},
        },
    },

    -- 30 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 2,
        MinProgress = 1.2,
        LastClip1OutTime = 2,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.61, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.045, c = ci},
            {s = path .. "chlock.ogg",         t = 0.18, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = 0.86, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.13, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.05, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_kurz"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 2,
        MinProgress = 1.2,
        LastClip1OutTime = 2,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.63, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_kurz"] = {
        Source = "reload_empty_kurz",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.066, c = ci},
            {s = path .. "chlock.ogg",         t = 0.2, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = 0.86, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.13, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.1, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 15 Round Reloads --

    ["reload_15"] = {
        Source = "reload",--"reload_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.5, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_15"] = {
        Source = "reload_empty",--"reload_empty_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_empty_kurz_15"] = {
        Source = "reload_empty_kurz",--"reload_empty_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 40 Round Reloads --

    ["reload_40"] = {
        Source = "reload",--"reload_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.5, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_40"] = {
        Source = "reload_empty",--"reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_empty_kurz_40"] = {
        Source = "reload_empty_kurz",--"reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 100 Round Reloads --

    ["reload_drum"] = {
        Source = "reload_drum",--"reload_50",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.6,
        LastClip1OutTime = 1,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "magout.ogg",        t = 0.32, c = ci},
            {s = rottle, t = 0.25},
            {s = rottle, t = 0.75},
            {s = path .. "magin.ogg",         t = 1.05, c = ci},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = path .. "magtap.ogg",         t = 1.755, c = ci},
            {s = common .. "shoulder.ogg",  t = 2.25},
        },
    },
    ["reload_empty_drum"] = {
        Source = "reload_empty_drum",--"reload_empty_50",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.4,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 1,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "magout.ogg",        t = 0.3, c = ci},
            {s = rottle, t = 0.25},
            {s = rottle, t = 0.75},
            {s = common .. "magdrop.ogg",  t = 1.0},
            {s = path .. "magin.ogg",         t = 1.05, c = ci},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = path .. "magtap.ogg",         t = 1.755, c = ci},
            {s = path .. "rack1.ogg",         t = 2.3, c = ci},
            {s = path .. "rack2.ogg",         t = 2.5, c = ci},
            {s = common .. "shoulder.ogg",  t = 3.0},
        },
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-smg-03.ogg", t = 0},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-smg-01.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-smg-04.ogg", t = 1.25},
        },
    },

    ["enter_sprint"] = {
        Source = "sprint_enter",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKOut = 0,
        Time = .5,
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_sprint"] = {
        Source = "sprint_exit",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.5,
        Time = .5,
    },
}

SWEP.AutosolveSourceSeq = "idle"

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_lp","optic","ur_mp5_optic"}, -- ,"optic"
        Bone = "body",
        Offset = {
            vpos = Vector(-0.1, -1.6, 3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(-0.09, 0, 0),
        CorrectiveAng = Angle(1, 0.6, -4.0),
        InstalledEles = {"ur_mp5_rail_optic"}
    },
    {
        PrintName = "Upper Receiver",
        DefaultAttName = "9\" Standard Upper",
        DefaultAttIcon = Material("entities/att/ur_mp5/upper_std.png", "smooth mips"),
        Slot = "ur_mp5_barrel",
        Bone = "body",
        Offset = {
            vpos = Vector(2.6, -3.7, -17.3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Lower Receiver",
        DefaultAttName = "Navy Lower",
        DefaultAttIcon = Material("entities/att/ur_mp5/grip.png", "smooth mips"),
        Slot = "ur_mp5_caliber",
        DefaultEles = {"receiver_lower_0"}
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.3, 14.8),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"barrel_sd","barrel_eod","barrel_sword"}
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Tropical Handguard",
        DefaultAttIcon = Material("entities/att/ur_mp5/hg_std.png", "smooth mips"),
        Slot = {"ur_mp5_hg"},
        ExcludeFlags = {"barrel_sd", "barrel_eod"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, .9, 10),
            vang = Angle(90, 0, -90),
        },
        --VMScale = Vector(.8, .8, .8),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, .9, 10),
            vang = Angle(90, 0, -90),
        },
        --VMScale = Vector(.8, .8, .8),
        --InstalledEles = {"ur_mp5_rail_fg"},
        GivesFlags = {"mp5_rail"},
        ExcludeFlags = {"mp5_badhg","mp5_kurz"},
        MergeSlots = {15},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "body",
        Offset = {
            vpos = Vector(-0.9, 0.2, 8),
            vang = Angle(90, 0, 180),
        },
        VMScale = Vector(.8,.8,.8),
        --InstalledEles = {"ur_mp5_clamp"}
        GivesFlags = {"mp5_rail"},
    },
    {
        PrintName = "Stock",
        Slot = {"ur_mp5_stock"},
        DefaultAttName = "Full Stock",
        DefaultAttIcon = Material("entities/att/ur_mp5/stock_std.png", "smooth mips"),
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_mp5_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_mp5/mag30.png", "smooth mips"),
        ExcludeFlags = {"ur_mp5_cal_40sw","ur_mp5_cal_10mm"}
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load",
        ExcludeFlags = {"barrel_sd"}
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "mp5_charm"},
        FreeSlot = true,
        Bone = "Body",
        Offset = {
            vpos = Vector(0.6, 1.1, 2.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "Body",
        Offset = {
            vpos = Vector(0, 0, 7.9),
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        --RequireFlags = {"barrel_eod"},
        ExcludeFlags = {"mp5_badhg","mp5_kurz"},
    }
}

-- SWEP.AttachmentOverrides = {
--     ["uc_grip_handstop"] = {
--         LHIK = false
--     }
-- } -- THIS SHIT DOESN'T WORK

--lua/weapons/arccw_ur_mp5a3.lua:
if true then return end
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_mp5.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets SMGs"
end

SWEP.PrintName = "PK5-3"
SWEP.TrueName = "MP5A3"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[1].Installed = "ur_mp5_optic_alt"
SWEP.Attachments[3].Installed = "ur_mp5_caliber_noburst"
SWEP.Attachments[5].Installed = "ur_mp5_ub_classic"
SWEP.Attachments[8].Installed = "ur_mp5_stock_a3"

SWEP.Attachments[8].ToggleLock = true
--lua/weapons/arccw_ur_mp5.lua:
SWEP.Base = "arccw_base"
SWEP.Spawnable = true
SWEP.Category = "ArcCW - Urban Coalition"
SWEP.UC_CategoryPack = "2Urban Renewal"
SWEP.AdminOnly = false
SWEP.UseHands = true

-- Effects --

SWEP.MuzzleEffect = "muzzleflash_mp5"
SWEP.ShellEffect = "arccw_uc_shelleffect"
SWEP.ShellModel = "models/weapons/arccw/uc_shells/9x19.mdl"
SWEP.ShellScale = 1
--SWEP.ShellMaterial = "models/weapons/arcticcw/shell_9mm"
SWEP.ShellPitch = 100
SWEP.ShellSounds = ArcCW.PistolShellSoundsTable

SWEP.MuzzleEffectAttachment = 1
SWEP.CaseEffectAttachment = 2
-- SWEP.CamAttachment = 3 ---------------------------------------------------------------------------
-- SWEP.TracerNum = 1
-- SWEP.TracerCol = Color(25, 255, 25)
-- SWEP.TracerWidth = 2

-- Fake name --

SWEP.PrintName = "PK5-4"

-- True name --

SWEP.TrueName = "MP5A4"

-- Trivia --

SWEP.Trivia_Class = "Submachine Gun"
SWEP.Trivia_Desc = [[Versatile submachine gun known for its use by high profile police units around the world, most famously by the British SAS during the Iranian embassy siege. Its reliable closed-bolt design and craftsmanship allowed it to remain relevant among new generations of submachine guns.

If accurate, sophisticated close-combat performance is what you're looking for, no weapon has a better track record.

Switch to burst fire mode to reduce dispersion from moving and hipfiring.]]
SWEP.Trivia_Manufacturer = "Crowdley & Nelson"
SWEP.Trivia_Calibre = "9x19mm Parabellum"
SWEP.Trivia_Mechanism = "Roller-Delayed Blowback"
SWEP.Trivia_Country = "Germany"
SWEP.Trivia_Year = 1966

-- Weapon slot --

SWEP.Slot = 2

-- Weapon's manufacturer real name --

if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
    SWEP.Trivia_Manufacturer = "Heckler & Koch"
end

-- Viewmodel / Worldmodel / FOV --

SWEP.ViewModel = "models/weapons/arccw/c_ur_mp5.mdl"
SWEP.WorldModel = "models/weapons/arccw/c_ur_mp5.mdl"
SWEP.ViewModelFOV = 70
SWEP.AnimShoot = ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2
SWEP.ProceduralIronFire = true

-- Damage --

SWEP.Damage = ArcCW.UC.StdDmg["9mm"].max
SWEP.DamageMin = ArcCW.UC.StdDmg["9mm"].min
SWEP.Penetration = ArcCW.UC.StdDmg["9mm"].pen
SWEP.RangeMin = 20
SWEP.Range = 100

SWEP.DamageType = DMG_BULLET
SWEP.ShootEntity = nil
SWEP.MuzzleVelocity = 400
SWEP.PhysBulletMuzzleVelocity = 400

SWEP.BodyDamageMults = ArcCW.UC.BodyDamageMults

-- Mag size --

SWEP.ChamberSize = 1
SWEP.Primary.ClipSize = 30
SWEP.ExtendedClipSize = 40
SWEP.ReducedClipSize = 15

-- Recoil --

SWEP.Recoil = 0.22
SWEP.RecoilSide = 0.17

SWEP.RecoilRise = 0.6
SWEP.RecoilPunch = 1
SWEP.VisualRecoilMult = 1.25
SWEP.MaxRecoilBlowback = 1
SWEP.MaxRecoilPunch = 0.6
SWEP.RecoilPunchBack = 1.5

SWEP.Sway = 0.25

-- Firerate / Firemodes --

SWEP.Delay = 60 / 800
SWEP.Num = 1
SWEP.Firemodes = {
    {
        Mode = 2,
    },
    {
        Mode = -3,
        Mult_MoveDispersion = 0.75,
        Mult_HipDispersion = 0.9,
    },
    {
        Mode = 1,
    },
    {
        Mode = 0,
    },
}

SWEP.ShootPitch = 100
SWEP.ShootVol = 120

SWEP.ProceduralRegularFire = false
SWEP.ProceduralIronFire = false

SWEP.ReloadInSights = true

-- NPC --

SWEP.NPCWeaponType = "weapon_smg1"
SWEP.NPCWeight = 60

-- Accuracy --

SWEP.AccuracyMOA = 3
SWEP.HipDispersion = 500
SWEP.MoveDispersion = 150
SWEP.JumpDispersion = 1000

SWEP.Primary.Ammo = "pistol"
SWEP.MagID = "mp5"

SWEP.HeatCapacity = 75
SWEP.HeatDissipation = 15
SWEP.HeatDelayTime = 3

SWEP.MalfunctionMean = 200

-- Speed multipliers --

SWEP.SpeedMult = 0.925
SWEP.SightedSpeedMult = 0.75
SWEP.SightTime = 0.3
SWEP.ShootSpeedMult = 0.95

-- Length --

SWEP.BarrelLength = 24
SWEP.ExtraSightDist = 2

-- Ironsights / Customization / Poses --

SWEP.HolsterPos = Vector(0.5, -2, 1)
SWEP.HolsterAng = Angle(-8.5, 8, -10)

SWEP.HoldtypeHolstered = "passive"
SWEP.HoldtypeActive = "ar2"
SWEP.HoldtypeSights = "rpg"

SWEP.IronSightStruct = {
     Pos = Vector(-3.17, -1, 0.6),
     Ang = Angle(0.45, 0, 0),
     Magnification = 1,
     SwitchToSound = "",
     ViewModelFOV = 60,
}

SWEP.ActivePos = Vector(-0.3, 1.1, 0.6)
SWEP.ActiveAng = Angle(0, 0, -1)

-- SWEP.SprintPos = Vector(-0.5, 3, 1.5)
-- SWEP.SprintAng = Angle(-12, 15, -15)

SWEP.SprintPos = Vector(0, -3, 0)
SWEP.SprintAng = Angle(0, 0, 0)
-- SWEP.CustomizePos = Vector(6, -2, -1.5)
-- SWEP.CustomizeAng = Angle(16, 28, 0)
SWEP.CustomizePos = Vector(0, 0, 0)
SWEP.CustomizeAng = Angle(0, 0, 0)

SWEP.CrouchPos = Vector(-2, 0.5, 0)
SWEP.CrouchAng = Angle(0, 0, -14)

SWEP.BarrelOffsetHip = Vector(4, 0, -4)

SWEP.MirrorVMWM = true
SWEP.WorldModelOffset = {
    pos        =    Vector(-8, 4, -5),
    ang        =    Angle(-12, 0, 180),
    bone    =    "ValveBiped.Bip01_R_Hand",
    scale = 1
}

-- Firing sounds --
local path = ")weapons/arccw_ur/mp5/"
local common = ")/arccw_uc/common/"

SWEP.ShootSound = {
    path .. "fire-01.ogg",
    path .. "fire-02.ogg",
    path .. "fire-03.ogg"
}
SWEP.ShootSoundSilenced = {
    path .. "fire-sup-01.ogg",
    path .. "fire-sup-02.ogg",
    path .. "fire-sup-03.ogg",
    path .. "fire-sup-04.ogg",
    path .. "fire-sup-05.ogg",
    path .. "fire-sup-06.ogg"
}
SWEP.DistantShootSound = nil
SWEP.DistantShootSoundSilenced = nil
SWEP.ShootDrySound = path .. "dryfire.ogg"

SWEP.DistantShootSoundOutdoors = {
    path .. "fire-dist-01.ogg",
    path .. "fire-dist-02.ogg",
    path .. "fire-dist-03.ogg",
    path .. "fire-dist-04.ogg",
    path .. "fire-dist-05.ogg",
    path .. "fire-dist-06.ogg"
}
SWEP.DistantShootSoundIndoors = {
    common .. "fire-dist-int-pistol-01.ogg",
    common .. "fire-dist-int-pistol-02.ogg",
    common .. "fire-dist-int-pistol-03.ogg",
    common .. "fire-dist-int-pistol-04.ogg",
    common .. "fire-dist-int-pistol-05.ogg",
    common .. "fire-dist-int-pistol-06.ogg"
}
SWEP.DistantShootSoundOutdoorsSilenced = {
    common .. "sup-tail-01.ogg",
    common .. "sup-tail-02.ogg",
    common .. "sup-tail-03.ogg",
    common .. "sup-tail-04.ogg",
    common .. "sup-tail-05.ogg",
    common .. "sup-tail-06.ogg",
    common .. "sup-tail-07.ogg",
    common .. "sup-tail-08.ogg",
    common .. "sup-tail-09.ogg",
    common .. "sup-tail-10.ogg"
}
SWEP.DistantShootSoundIndoorsSilenced = {
    common .. "fire-dist-int-pistol-light-01.ogg",
    common .. "fire-dist-int-pistol-light-02.ogg",
    common .. "fire-dist-int-pistol-light-03.ogg",
    common .. "fire-dist-int-pistol-light-04.ogg",
    common .. "fire-dist-int-pistol-light-05.ogg",
    common .. "fire-dist-int-pistol-light-06.ogg"
}
SWEP.DistantShootSoundOutdoorsVolume = 1
SWEP.DistantShootSoundIndoorsVolume = 0.6
SWEP.Hook_AddShootSound = ArcCW.UC.InnyOuty

-- Bodygroups --

SWEP.BulletBones = {
    -- [1] = "uzi_b1", [2] = "uzi_b2", [3] = "uzi_b3", [4] = "uzi_b4"
}

--[[

1 --- 	id: 0
     [	name: iron
    num: 1
    submodels:
    0 --- ironSIGHT.smd
2 --- 	id: 1
     [	name: 1
    num: 4
    submodels:
    0 --- mp5UPPER.smd
    1 --- mp5sdUPPER.smd
    2 --- mp5kUPPER.smd
    3 --- swordUPPER.smd
3 --- 	id: 2
     [	name: 2
    num: 2
    submodels:
    0 --- fourLOWER.smd
    1 --- sefLOWER.smd
4 --- 	id: 3
     [	name: 3
    num: 11
    submodels:
    0 --- fixedSTOCK.smd
    1 --- collapseSTOCK.smd
    2 --- collapseSTOCKcoll.smd
    3 --- pdwSTOCK.smd
    4 --- pdwSTOCKfold.smd
    5 --- tacticSTOCK.smd
    6 --- tacticSTOCKfold.smd
    7 --- futureSTOCK.smd
    8 --- futureSTOCKcoll.smd
    9 --- futureSTOCKfold.smd
    10 --- buttSTOCK.smd
5 --- 	id: 4
     [	name: 4
    num: 10
    submodels:
    0 --- standardHG.smd
    1 --- flashHG.smd
    2 --- flashmlokHG.smd
    3 --- slimHG.smd
    4 --- picaHG.smd
    5 --- mlokHG.smd
    6 --- kurzgripHG.smd
    7 --- kurzslimHG.smd
    8 --- kurzmlokHG.smd
    9 ---
6 --- 	id: 5
     [	name: 5
    num: 4
    submodels:
    0 --- standardMAG.smd
    1 --- smallMAG.smd
    2 --- straightMAG.smd
    3 --- drumMAG.smd
7 --- 	id: 6
     [	name: 6
    num: 2
    submodels:
    0 ---
    1 --- mp5RAIL.smd

]]

SWEP.AttachmentElements = {
    ["ur_mp5_barrel_sd"] = {
        VMBodygroups = {
            {ind = 1, bg = 1},
            {ind = 4, bg = 9},
            //{ind = 8, bg = 1},
        },
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 1.3, 10),
                vang = Angle(90, 0, -90),
            },
            [7] = {
				vpos = Vector(-1.15, 0.3, 8),
				vang = Angle(90, 0, 180),
			},
        },
    },
    ["ur_mp5_barrel_eod"] = {
        VMBodygroups = {
            {ind = 4, bg = 10},
            //{ind = 8, bg = 2},
        },
        AttPosMods = {
            [6] = {
                vpos = Vector(0, 1.5, 10),
                vang = Angle(90, 0, -90),
            },
            [7] = {
				vpos = Vector(-0.95, 0.3, 8),
				vang = Angle(90, 0, 180),
			},
		}
    },
    ["ur_mp5_barrel_kurz"] = {
        VMBodygroups = {
            {ind = 1, bg = 2},
            {ind = 4, bg = 7},
        },
        AttPosMods = {[4] = {
            vpos = Vector(-0.1, 0.3, 11.5),
            vang = Angle(90, 0, -90),
        }}
    },
    ["ur_mp5_barrel_swordfish"] = {
        VMBodygroups = {
            --{ind = 0, bg = 1},
            {ind = 1, bg = 3},
            {ind = 6, bg = 0},
        },
    },

    ["ur_mp5_rail_fg"] = {
        VMBodygroups = {{ind = 4, bg = 4}},
    },
    ["ur_mp5_ub_classic"] = {
        VMBodygroups = {{ind = 4, bg = 3}},
    },
    ["ur_mp5_ub_surefire"] = {
        VMBodygroups = {{ind = 4, bg = 1}},
    },
    ["ur_mp5_ub_surelock"] = {
        VMBodygroups = {{ind = 4, bg = 2}},
    },
    ["ur_mp5_ub_kurzgrip"] = {
        VMBodygroups = {{ind = 4, bg = 6}},
    },
    ["ur_mp5_ub_kurzmlok"] = {
        VMBodygroups = {{ind = 4, bg = 8}},
    },
    ["ur_mp5_ub_wood"] = {
        VMBodygroups = {{ind = 4, bg = 3}}, -- insert wood handguard here
    },

    ["ur_mp5_mag_15"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },
    ["ur_mp5_mag_40"] = {
        VMBodygroups = {{ind = 5, bg = 3}},
    },
    ["ur_mp5_mag_50"] = {
        VMBodygroups = {{ind = 5, bg = 3}},
    },
    ["ur_mp5_mag_waffle"] = {
        VMBodygroups = {{ind = 5, bg = 2}},
    },

    ["ur_mp5_rail_optic"] = {
        VMBodygroups = {{ind = 6, bg = 1}},
    },

    ["ur_mp5_clamp"] = {
        VMBodygroups = {{ind = 5, bg = 1}},
    },

    ["receiver_lower"] = {
        VMBodygroups = {{ind = 2, bg = 1}},
    },
    ["receiver_lower_semi"] = {
        VMBodygroups = {{ind = 2, bg = 2}},
    },
    ["receiver_lower_0"] = {
        VMBodygroups = {{ind = 2, bg = 0}},
    },
    ["receiver_upper_0"] = {
        VMBodygroups = {{ind = 7, bg = 0}},
    },

    ["stock_a3"] = {
        VMBodygroups = {
            {ind = 3, bg = 1},
        },
    },
    ["stock_a3_folded"] = {
        VMBodygroups = {
            {ind = 3, bg = 2},
        },
    },
    ["ur_mp5_stock_remove"] = {
        VMBodygroups = {{ind = 3, bg = 10}},
    },
    ["ur_mp5_stock_wood"] = {
        -- VMBodygroups = {{ind = 0, bg = 4}},
        -- Make this part of the VMSkin
    },
    ["stock_pdw"] = {
        VMBodygroups = {{ind = 3, bg = 3}},
    },
    ["stock_pdw_folded"] = {
        VMBodygroups = {{ind = 3, bg = 4}},
    },
    ["stock_ump"] = {
        VMBodygroups = {{ind = 3, bg = 5}},
    },
    ["stock_ump_folded"] = {
        VMBodygroups = {{ind = 3, bg = 6}},
    },
    ["stock_future"] = {
        VMBodygroups = {{ind = 3, bg = 7}},
    },
    ["stock_future_folded"] = {
        VMBodygroups = {{ind = 3, bg = 8}},
    },
    ["ur_mp5_precision_irons"] = {
        VMBodygroups = {
            {ind = 0, bg = 2},
            {ind = 6, bg = 0},
            },
    },
}

SWEP.Hook_ModifyBodygroups = function(wep, data)
    local atts = wep.Attachments
    local vm = data.vm
    if IsValid(vm) then
        local barr = string.Replace(atts[2].Installed or "default","ur_mp5_barrel_","")
        local hg = string.Replace(atts[5].Installed or "default","ur_mp5_ub_","")
        
        if atts[6].Installed or atts[7].Installed then
            if barr == "sd" then
                vm:SetBodygroup(8, 1)
            elseif barr == "eod" then
                vm:SetBodygroup(8, 2)
            elseif hg == "default" or hg == "classic" then
                vm:SetBodygroup(4, 4)
                vm:SetBodygroup(8, 0)
            else
                vm:SetBodygroup(8, 0)
            end
        else
            vm:SetBodygroup(8, 0)
        end

        if hg == "mlok" then
            if barr == "kurz" then
                vm:SetBodygroup(4,8)
            else
                vm:SetBodygroup(4,5)
            end
        end

        if barr == "sword" then
            vm:SetBodygroup(0,(atts[1].Installed and 3) or 1)
        end
    end
end

SWEP.Hook_NameChange = function(wep,name)
    local atts = wep.Attachments
    local barr = string.Replace(atts[2].Installed or "default","ur_mp5_barrel_","")
    local cal = string.Replace(atts[3].Installed or "default","ur_mp5_caliber_","")
    local stock = string.Replace(atts[8].Installed or "default","ur_mp5_stock_","")
    local fakeNames = !GetConVar("arccw_truenames"):GetBool()
    local defaultCals = {
        ["default"] = true,
        ["noburst"] = true,
        ["semi"] = true
    }

    local start = "MP5"
    local mid = "A"
    local num = "4"
    if fakeNames then
        start = "PK5"
        mid = "-"
    end

    if cal == "semi" or atts[12].Installed == "uc_fg_civvy" then
        if fakeNames then
            return "PK5-CIV"
        else
            if barr == "long" or barr == "sd" then
                start = "HK94" -- I know how prolific civies can get with their gunbuilds, so the nonsensical names will continue
            else
                return "SP5" .. ((barr == "kurz" and "K-PDW") or "")
            end
        end
    end

    if !defaultCals[cal] then
        if barr == "sd" then
            num = "SD"
        else
            num = ""
        end
        if cal == "10auto" then
            mid = "/10"
        elseif cal == "40sw" then
            mid = "/40"
        elseif cal == "22lr" then
            if barr == "sd" then
                mid = "SD"
                num = " .22 LR"
            else
                mid = " .22 LR"
            end
        end
    else
        if barr == "kurz" then
            if fakeNames then
                mid = "C"
            else
                mid = "K"
            end
            if stock == "pdw" then
                num = "-PDW"
            elseif cal == "default" then
                if fakeNames then
                    num = "-4"
                else
                    num = "A4"
                end
            else
                num = ""
            end
        else
            if barr == "sd" then
                mid = "SD"
            end

            if cal == "noburst" or cal == "semi" then
                if stock == "a3" then
                    num = "3"
                elseif stock == "none" then
                    num = "1"
                else
                    num = "2"
                end
            else
                if stock == "a3" then
                    if barr == "sd" then
                        num = "6"
                    else
                        num = "5"
                    end
                elseif stock == "none" then
                    if barr == "sd" then
                        num = "4"
                    end
                else
                    if barr == "sd" then
                        num = "5"
                    end
                end
            end
        end
    end

    return start .. mid .. num
end

-- Animations --

SWEP.Hook_Think = ArcCW.UC.ADSReload

local ratel = {common .. "rattle1.ogg", common .. "rattle2.ogg", common .. "rattle3.ogg"}
local rottle = {common .. "cloth_2.ogg", common .. "cloth_3.ogg", common .. "cloth_4.ogg", common .. "cloth_6.ogg", common .. "rattle.ogg"}
local rutle = {common .. "movement-smg-03.ogg",common .. "movement-smg-04.ogg"}

SWEP.Animations = {
    ["idle"] = {
        Source = "idle",
    },
    -- ["idle_empty"] = {
    --     Source = "idle",
    -- },
    ["ready"] = {
        Source = "ready",
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0.15},
            {s = path .. "rack1.ogg",         t = 0.15, c = ci},
            {s = path .. "rack2.ogg",         t = 0.38, c = ci},
            {s = ratel,         t = 0.75},
        }
    },
    ["draw"] = {
        Source = "draw",
        SoundTable = ArcCW.UC.DrawSounds,
    },
    -- ["draw_empty"] = {
    --     Source = "draw_empty",
    --     SoundTable = ArcCW.UC.DrawSounds,
    -- },
    ["holster"] = {
        Source = "holster",
        --Time = 0.25,
        SoundTable = ArcCW.UC.HolsterSounds,
    },
    -- ["holster_empty"] = {
    --     Source = "holster_empty",
    --     --Time = 0.25,
    --     SoundTable = ArcCW.UC.HolsterSounds,
    -- },
    ["fire"] = {
        Source = "fire",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0, v = 0.25 }},
    },
    -- ["fire_empty"] = {
    --     Source = "fire",
    --     Time = 13 / 30,
    --     ShellEjectAt = 0.03,
    --     SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    -- },
    ["fire_iron"] = {
        Source = "idle",
        Time = 13 / 30,
        ShellEjectAt = 0.03,
        SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    },
    -- ["fire_empty_iron"] = {
    --     Source = "idle",
    --     Time = 13 / 30,
    --     ShellEjectAt = 0.03,
    --     SoundTable = {{ s = {path .. "mech-01.ogg", path .. "mech-02.ogg", path .. "mech-03.ogg", path .. "mech-04.ogg", path .. "mech-05.ogg", path .. "mech-06.ogg"}, t = 0 }},
    -- },

    ["fix"] = {
        Source = "fix",
        Time = 40 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.4,
        ShellEjectAt = 0.36,
        SoundTable = {
            {s = rottle, t = 0.15},
            {s = path .. "rack1.ogg",         t = 0.27, c = ci},
            {s = path .. "rack2.ogg",         t = 0.5, c = ci},
        },
    },

    -- 30 Round Reloads --

    ["reload"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 2,
        MinProgress = 1.2,
        LastClip1OutTime = 2,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.61, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty"] = {
        Source = "reload_empty",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.045, c = ci},
            {s = path .. "chlock.ogg",         t = 0.18, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = 0.86, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.13, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.05, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_kurz"] = {
        Source = "reload",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 2,
        MinProgress = 1.2,
        LastClip1OutTime = 2,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.4, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.63, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_kurz"] = {
        Source = "reload_empty_kurz",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.066, c = ci},
            {s = path .. "chlock.ogg",         t = 0.2, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = 0.86, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.13, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.1, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 15 Round Reloads --

    ["reload_15"] = {
        Source = "reload",--"reload_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.5, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_15"] = {
        Source = "reload_empty",--"reload_empty_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_empty_kurz_15"] = {
        Source = "reload_empty_kurz",--"reload_empty_15",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 40 Round Reloads --

    ["reload_40"] = {
        Source = "reload",--"reload_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.2,
        LastClip1OutTime = 67 / 30,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.6,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "magpouch.ogg", t = 0.05},
            {s = path .. "magout.ogg",        t = 0.25, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 0.5, c = ci},
            {s = common .. "magpouchin.ogg", t = 1.25},
            {s = ratel,  t = 1.55},
            {s = common .. "shoulder.ogg",  t = 1.5},
        },
    },
    ["reload_empty_40"] = {
        Source = "reload_empty",--"reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },
    ["reload_empty_kurz_40"] = {
        Source = "reload_empty_kurz",--"reload_empty_40",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.2,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 0.55,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "chback.ogg",         t = 0.1, c = ci},
            {s = path .. "chlock.ogg",         t = 0.19, c = ci},
            {s = common .. "magpouch.ogg", t = 0.4},
            {s = path .. "magout.ogg",        t = .9, c = ci},
            {s = rottle, t = 0.25},
            {s = path .. "magin.ogg",         t = 1.2, c = ci},
            {s = common .. "magdrop_smg.ogg",  t = 1.5},
            {s = rottle, t = 1.25},
            {s = path .. "chamber.ogg",         t = 2.13, c = ci},
            {s = ratel,  t = 2.4},
            {s = common .. "shoulder.ogg",  t = 2.6},
        },
    },

    -- 100 Round Reloads --

    ["reload_drum"] = {
        Source = "reload_drum",--"reload_50",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 67 / 30,
        MinProgress = 1.6,
        LastClip1OutTime = 1,
        LHIK = true,
        LHIKIn = 0.4,
        LHIKEaseIn = 0.4,
        LHIKEaseOut = 0.15,
        LHIKOut = 0.9,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "magout.ogg",        t = 0.32, c = ci},
            {s = rottle, t = 0.25},
            {s = rottle, t = 0.75},
            {s = path .. "magin.ogg",         t = 1.05, c = ci},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = path .. "magtap.ogg",         t = 1.755, c = ci},
            {s = common .. "shoulder.ogg",  t = 2.25},
        },
    },
    ["reload_empty_drum"] = {
        Source = "reload_empty_drum",--"reload_empty_50",
        TPAnim = ACT_HL2MP_GESTURE_RELOAD_SMG1,
        -- Time = 90 / 30,
        MinProgress = 2.4,
        LastClip1OutTime = 1.8,
        LHIK = true,
        LHIKIn = 0.3,
        LHIKEaseIn = 0.3,
        LHIKEaseOut = 0.2,
        LHIKOut = 1,
        SoundTable = {
            {s = rottle, t = 0},
            {s = path .. "magout.ogg",        t = 0.3, c = ci},
            {s = rottle, t = 0.25},
            {s = rottle, t = 0.75},
            {s = common .. "magdrop.ogg",  t = 1.0},
            {s = path .. "magin.ogg",         t = 1.05, c = ci},
            {s = common .. "cloth_4.ogg",  t = 1.65},
            {s = path .. "magtap.ogg",         t = 1.755, c = ci},
            {s = path .. "rack1.ogg",         t = 2.3, c = ci},
            {s = path .. "rack2.ogg",         t = 2.5, c = ci},
            {s = common .. "shoulder.ogg",  t = 3.0},
        },
    },

    ["enter_inspect"] = {
        Source = "inspect_enter",
        -- time = 35 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 2.5,
        SoundTable = {
            {s = rottle, t = 0},
            {s = common .. "movement-smg-03.ogg", t = 0},
        },
    },
    ["idle_inspect"] = {
        Source = "inspect_loop",
        -- time = 72 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
    },
    ["exit_inspect"] = {
        Source = "inspect_exit",
        -- time = 66 / 60,
        LHIK = false,
        LHIKIn = 0,
        LHIKOut = 999, -- maybe im dumb
        SoundTable = {
            {s = common .. "movement-smg-01.ogg", t = 0.2},
            {s = rottle, t = 0.25},
            {s = rottle, t = 1.2},
            {s = common .. "movement-smg-04.ogg", t = 1.25},
        },
    },

    ["enter_sprint"] = {
        Source = "sprint_enter",
        LHIK = true,
        LHIKIn = 0.2,
        LHIKEaseIn = 0.2,
        LHIKOut = 0,
        Time = .5,
    },
    ["idle_sprint"] = {
        Source = "sprint_loop",
        LHIK = true,
        LHIKIn = 0,
        LHIKOut = 0,
    },
    ["exit_sprint"] = {
        Source = "sprint_exit",
        LHIK = true,
        LHIKIn = 0,
        LHIKEaseOut = 0.4,
        LHIKOut = 0.5,
        Time = .5,
    },
}

SWEP.AutosolveSourceSeq = "idle"

SWEP.Attachments = {
    {
        PrintName = "Optic",
        DefaultAttName = "Iron Sights",
        Slot = {"optic_lp","optic","ur_mp5_optic"}, -- ,"optic"
        Bone = "body",
        Offset = {
            vpos = Vector(-0.1, -1.6, 3),
            vang = Angle(90, 0, -90),
        },
        CorrectivePos = Vector(-0.09, 0, 0),
        CorrectiveAng = Angle(1, 0.6, -4.0),
        InstalledEles = {"ur_mp5_rail_optic"}
    },
    {
        PrintName = "Upper Receiver",
        DefaultAttName = "9\" Standard Upper",
        DefaultAttIcon = Material("entities/att/ur_mp5/upper_std.png", "smooth mips"),
        Slot = "ur_mp5_barrel",
        Bone = "body",
        Offset = {
            vpos = Vector(2.6, -3.7, -17.3),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "Lower Receiver",
        DefaultAttName = "Navy Lower",
        DefaultAttIcon = Material("entities/att/ur_mp5/grip.png", "smooth mips"),
        Slot = "ur_mp5_caliber",
        DefaultEles = {"receiver_lower_0"}
    },
    {
        PrintName = "Muzzle",
        DefaultAttName = "Standard Muzzle",
        Slot = {"muzzle"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, 0.3, 14.8),
            vang = Angle(90, 0, -90),
        },
        ExcludeFlags = {"barrel_sd","barrel_eod","barrel_sword"}
    },
    {
        PrintName = "Handguard",
        DefaultAttName = "Tropical Handguard",
        DefaultAttIcon = Material("entities/att/ur_mp5/hg_std.png", "smooth mips"),
        Slot = {"ur_mp5_hg"},
        ExcludeFlags = {"barrel_sd", "barrel_eod"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, .9, 10),
            vang = Angle(90, 0, -90),
        },
        --VMScale = Vector(.8, .8, .8),
    },
    {
        PrintName = "Underbarrel",
        Slot = {"foregrip"},
        Bone = "body",
        Offset = {
            vpos = Vector(0, .9, 10),
            vang = Angle(90, 0, -90),
        },
        --VMScale = Vector(.8, .8, .8),
        --InstalledEles = {"ur_mp5_rail_fg"},
        GivesFlags = {"mp5_rail"},
        ExcludeFlags = {"mp5_badhg","mp5_kurz"},
        MergeSlots = {15},
    },
    {
        PrintName = "Tactical",
        Slot = "tac",
        Bone = "body",
        Offset = {
            vpos = Vector(-0.9, 0.2, 8),
            vang = Angle(90, 0, 180),
        },
        VMScale = Vector(.8,.8,.8),
        --InstalledEles = {"ur_mp5_clamp"}
        GivesFlags = {"mp5_rail"},
    },
    {
        PrintName = "Stock",
        Slot = {"ur_mp5_stock"},
        DefaultAttName = "Full Stock",
        DefaultAttIcon = Material("entities/att/ur_mp5/stock_std.png", "smooth mips"),
    },
    {
        PrintName = "Magazine",
        Slot = {"ur_mp5_mag"},
        DefaultAttName = "30-Round Mag",
        DefaultAttIcon = Material("entities/att/ur_mp5/mag30.png", "smooth mips"),
        ExcludeFlags = {"ur_mp5_cal_40sw","ur_mp5_cal_10mm"}
    },
    {
        PrintName = "Ammo Type",
        DefaultAttName = "\"FMJ\" Full Metal Jacket",
        DefaultAttIcon = Material("entities/att/arccw_uc_ammo_generic.png", "mips smooth"),
        Slot = "uc_ammo",
    },
    {
        PrintName = "Powder Load",
        Slot = "uc_powder",
        DefaultAttName = "Standard Load",
        ExcludeFlags = {"barrel_sd"}
    },
    {
        PrintName = "Training Package",
        Slot = "uc_tp",
        DefaultAttName = "Basic Training"
    },
    {
        PrintName = "Internals",
        Slot = "uc_fg", -- Fire group
        DefaultAttName = "Standard Internals"
    },
    {
        PrintName = "Charm",
        Slot = {"charm", "fml_charm", "mp5_charm"},
        FreeSlot = true,
        Bone = "Body",
        Offset = {
            vpos = Vector(0.6, 1.1, 2.5),
            vang = Angle(90, 0, -90),
        },
    },
    {
        PrintName = "M203 slot",
        Slot = "uc_ubgl",
        Bone = "Body",
        Offset = {
            vpos = Vector(0, 0, 7.9),
            vang = Angle(90, 0, -90),
        },
        Hidden = true,
        --RequireFlags = {"barrel_eod"},
        ExcludeFlags = {"mp5_badhg","mp5_kurz"},
    }
}

-- SWEP.AttachmentOverrides = {
--     ["uc_grip_handstop"] = {
--         LHIK = false
--     }
-- } -- THIS SHIT DOESN'T WORK

--lua/weapons/arccw_ur_mp5.lua:
return gluapack()()
--lua/weapons/arccw_ur_mp5.lua:
return gluapack()()
--lua/weapons/arccw_ur_t56.lua:
if !file.Exists("arccw/shared/sh_1_ur.lua","LUA") then return end

include("weapons/arccw_ur_ak.lua")

SWEP.Category = "ArcCW - UC Presets"
if GetConVar("arccw_uc_presets_categorize"):GetBool() then
    SWEP.Category = "ArcCW - UC Presets Rifles"
end

SWEP.PrintName = "Yucha 7"
SWEP.TrueName = "Type 56"
if GetConVar("arccw_truenames"):GetBool() then
    SWEP.PrintName = SWEP.TrueName
end

SWEP.Attachments[2].Installed = "ur_ak_barrel_t56"
SWEP.Attachments[3].Installed = "ur_ak_hg_type3"
SWEP.Attachments[4].Installed = nil
SWEP.Attachments[9].Installed = "ur_ak_grip_type3"
SWEP.Attachments[10].Installed = "ur_ak_stock_type3"
SWEP.Attachments[15].Installed = "ur_ak_cover_smooth"
--addons/policearmorylocker/lua/weapons/armory_lockpick/shared.lua:
return gluapack()()
--addons/policearmorylocker/lua/weapons/armory_lockpick/shared.lua:
--[[ INFO
#Armory Lockpick
models/craphead_scripts/armory_robbery2/c_lockpick.mdl
models/craphead_scripts/armory_robbery2/w_lockpick.mdl
FOV: 50
Hold type: slam
Sequences:
(sequence_name       activity)
idle 		ACT_VM_IDLE
draw 		ACT_VM_DRAW
start 		ACT_VM_IDLE_TO_LOWERED
finish 		ACT_VM_LOWERED_TO_IDLE
lockpick 	ACT_VM_PRIMARYATTACK
--]]
  local SERVER = SERVER
 local CLIENT = CLIENT
if SERVER then
	AddCSLuaFile( "shared.lua" )
end

if CLIENT then
	SWEP.PrintName = "Armory Lockpick"
	SWEP.Slot = 2
	SWEP.SlotPos = 4
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = true
end

SWEP.Author = "Crap-Head"
SWEP.Instructions = "Left click to start lockpicking a door. You must keep aiming at the same door."
SWEP.Contact = ""
SWEP.Purpose = "Used specifically to lockpick the police armory."

SWEP.UseHands = true
SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "slam"

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Crap-Head Scripts"

SWEP.ViewModel = "models/craphead_scripts/armory_robbery2/c_lockpick.mdl"
SWEP.WorldModel = "models/craphead_scripts/armory_robbery2/w_lockpick.mdl"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""
SWEP.Primary.Delay = 1.0

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""
SWEP.Secondary.Delay = 2.0

function SWEP:Initialize()
	self:SetWeaponHoldType( "slam" )
	self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
	self.Weapon:SetDeploySpeed( self.WeaponDeploySpeed )
	
	timer.Simple( 0.5, function()
		self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
	end )
end

function SWEP:Deploy()
	timer.Simple( 0.5, function()
		self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
	end )
	return true
end

-- function SWEP:PrimaryAttack()
-- 	self.Weapon:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	
-- 	local tr = self.Owner:GetEyeTrace()
-- 	local locker = tr.Entity
-- 	local trent = locker:WorldToLocal( self.Owner:GetEyeTrace().HitPos )
	
-- 	local Dist = self.Owner:EyePos():DistToSqr( tr.HitPos )
	
-- 	if Dist >= 2734 then
-- 		if SERVER then
-- 			DarkRP.notify( self.Owner, 1, 5, "Please move closer to the police armory." )
-- 		end
-- 		return 
-- 	end
	
-- 	if not table.HasValue( CH_Armory_Locker.Config.AllowedTeams, team.GetName( self.Owner:Team() ) ) then
-- 		if SERVER then
-- 			DarkRP.notify( self.Owner, 1, 5, "You are not allowed to steal weapons and ammo from here as a ".. team.GetName( self.Owner:Team() ) .."!")
-- 		end
-- 		return
-- 	end
	
-- 	if locker:GetClass() == "police_locker" then
-- 		if SERVER then
-- 			if self.Owner:GetNWBool( "LockpickCooldown" ) then
-- 				DarkRP.notify( self.Owner, 1, 5, "You are currently on a cooldown from being able to lockpick into the police armory." )
-- 				return
-- 			end

-- 			if locker.ActiveLockerPlayers != 0 then
-- 				DarkRP.notify( self.Owner, 1, 5, "You cannot lockpick the armory while an officer is accesing it!" )
-- 				return
-- 			end
			
-- 			if self.Owner.IsLockpicking then
-- 				DarkRP.notify( self.Owner, 1, 5, "You are already lockpicking another door. Keep looking at that door!" )
-- 				return
-- 			end

-- 			if trent:WithinAABox( CH_Armory_Locker.DoorPos.doorone, CH_Armory_Locker.DoorPos.doorone2 ) then
-- 				if not locker:GetLockerDoor1() then
-- 					net.Start( "ARM_LOCKER_CL_LockStart" )
-- 						net.WriteEntity( locker )
-- 						net.WriteEntity( self )
-- 					net.Send( self.Owner )
		
-- 					locker:SetLockerDoor1( true )
-- 					self.Owner.IsLockpicking = true
					
-- 					timer.Simple( CH_Armory_Locker.Config.LockpickTime, function()
-- 						if not IsValid( self.Owner ) then
-- 							return
-- 						end
						
-- 						trent = locker:WorldToLocal( self.Owner:GetEyeTrace().HitPos )
-- 						Dist = self.Owner:EyePos():DistToSqr( tr.HitPos )
						
-- 						if trent:WithinAABox( CH_Armory_Locker.DoorPos.doorone, CH_Armory_Locker.DoorPos.doorone2 ) and Dist < 2734 then
-- 							self:LockpickFinished( 1, locker, self.Owner )
-- 						else
-- 							locker:SetLockerDoor1( false )
-- 							self.Owner.IsLockpicking = false
-- 							DarkRP.notify( self.Owner, 1, 5, "[Lockpick Failed] Keep aiming at the same door." )
-- 							return
-- 						end
-- 					end )
-- 				else
-- 					DarkRP.notify( self.Owner, 1, 5, "This door is unavailable for lockpicking at the moment!" )
-- 					return
-- 				end
-- 			elseif trent:WithinAABox( CH_Armory_Locker.DoorPos.doortwo, CH_Armory_Locker.DoorPos.doortwo2 ) then
-- 				if not locker:GetLockerDoor2() then
-- 					net.Start( "ARM_LOCKER_CL_LockStart" )
-- 						net.WriteEntity( locker )
-- 						net.WriteEntity( self )
-- 					net.Send( self.Owner )
		
-- 					locker:SetLockerDoor2( true )
-- 					self.Owner.IsLockpicking = true
					
-- 					timer.Simple( CH_Armory_Locker.Config.LockpickTime, function()
-- 						if not IsValid( self.Owner ) then
-- 							return
-- 						end
						
-- 						trent = locker:WorldToLocal( self.Owner:GetEyeTrace().HitPos )
-- 						Dist = self.Owner:EyePos():DistToSqr( tr.HitPos )
						
-- 						if trent:WithinAABox( CH_Armory_Locker.DoorPos.doortwo, CH_Armory_Locker.DoorPos.doortwo2 ) and Dist < 2734 then
-- 							self:LockpickFinished( 2, locker, self.Owner )
-- 						else
-- 							locker:SetLockerDoor2( false )
-- 							self.Owner.IsLockpicking = false
-- 							DarkRP.notify( self.Owner, 1, 5, "[Lockpick Failed] Keep aiming at the same door." )
-- 							return
-- 						end
-- 					end )
-- 				else
-- 					DarkRP.notify( self.Owner, 1, 5, "This door is unavailable for lockpicking at the moment!" )
-- 					return
-- 				end
-- 			elseif trent:WithinAABox( CH_Armory_Locker.DoorPos.doorthree, CH_Armory_Locker.DoorPos.doorthree2 ) then
-- 				if not locker:GetLockerDoor3() then
-- 					net.Start( "ARM_LOCKER_CL_LockStart" )
-- 						net.WriteEntity( locker )
-- 						net.WriteEntity( self )
-- 					net.Send( self.Owner )
		
-- 					locker:SetLockerDoor3( true )
-- 					self.Owner.IsLockpicking = true
					
-- 					timer.Simple( CH_Armory_Locker.Config.LockpickTime, function()
-- 						if not locker:GetLockerDoor3() then
-- 							return
-- 						end
						
-- 						trent = locker:WorldToLocal( self.Owner:GetEyeTrace().HitPos )
-- 						Dist = self.Owner:EyePos():DistToSqr( tr.HitPos )
						
-- 						if trent:WithinAABox( CH_Armory_Locker.DoorPos.doorthree, CH_Armory_Locker.DoorPos.doorthree2 ) and Dist < 2734 then
-- 							self:LockpickFinished( 3, locker, self.Owner )
-- 						else
-- 							locker:SetLockerDoor3( false )
-- 							self.Owner.IsLockpicking = false
-- 							DarkRP.notify( self.Owner, 1, 5, "[Lockpick Failed] Keep aiming at the same door." )
-- 							return
-- 						end
-- 					end )
-- 				else
-- 					DarkRP.notify( self.Owner, 1, 5, "This door is unavailable for lockpicking at the moment!" )
-- 					return
-- 				end
-- 			elseif trent:WithinAABox( CH_Armory_Locker.DoorPos.doorfour, CH_Armory_Locker.DoorPos.doorfour2 ) then
-- 				if not locker:GetLockerDoor4() then
-- 					net.Start( "ARM_LOCKER_CL_LockStart" )
-- 						net.WriteEntity( locker )
-- 						net.WriteEntity( self )
-- 					net.Send( self.Owner )
		
-- 					locker:SetLockerDoor4( true )
-- 					self.Owner.IsLockpicking = true
					
-- 					timer.Simple( CH_Armory_Locker.Config.LockpickTime, function()
-- 						if not locker:GetLockerDoor4() then
-- 							return
-- 						end
						
-- 						trent = locker:WorldToLocal( self.Owner:GetEyeTrace().HitPos )
-- 						Dist = self.Owner:EyePos():DistToSqr( tr.HitPos )
						
-- 						if trent:WithinAABox( CH_Armory_Locker.DoorPos.doorfour, CH_Armory_Locker.DoorPos.doorfour2 ) and Dist < 2734 then
-- 							self:LockpickFinished( 4, locker, self.Owner )
-- 						else
-- 							locker:SetLockerDoor4( false )
-- 							self.Owner.IsLockpicking = false
-- 							DarkRP.notify( self.Owner, 1, 5, "[Lockpick Failed] Keep aiming at the same door." )
-- 							return
-- 						end
-- 					end )
-- 				else
-- 					DarkRP.notify( self.Owner, 1, 5, "This door is unavailable for lockpicking at the moment!" )
-- 					return
-- 				end
-- 			elseif trent:WithinAABox( CH_Armory_Locker.DoorPos.doorfive, CH_Armory_Locker.DoorPos.doorfive2 ) then
-- 				if not locker:GetLockerDoor5() then
-- 					net.Start( "ARM_LOCKER_CL_LockStart" )
-- 						net.WriteEntity( locker )
-- 						net.WriteEntity( self )
-- 					net.Send( self.Owner )
		
-- 					locker:SetLockerDoor5( true )
-- 					self.Owner.IsLockpicking = true
					
-- 					timer.Simple( CH_Armory_Locker.Config.LockpickTime, function()
-- 						if not locker:GetLockerDoor5() then
-- 							return
-- 						end
						
-- 						trent = locker:WorldToLocal( self.Owner:GetEyeTrace().HitPos )
-- 						Dist = self.Owner:EyePos():DistToSqr( tr.HitPos )
						
-- 						if trent:WithinAABox( CH_Armory_Locker.DoorPos.doorfive, CH_Armory_Locker.DoorPos.doorfive2 ) and Dist < 2734 then
-- 							self:LockpickFinished( 5, locker, self.Owner )
-- 						else
-- 							locker:SetLockerDoor5( false )
-- 							self.Owner.IsLockpicking = false
-- 							DarkRP.notify( self.Owner, 1, 5, "[Lockpick Failed] Keep aiming at the same door." )
-- 							return
-- 						end
-- 					end )
-- 				else
-- 					DarkRP.notify( self.Owner, 1, 5, "This door is unavailable for lockpicking at the moment!" )
-- 					return
-- 				end
-- 			elseif trent:WithinAABox( CH_Armory_Locker.DoorPos.doorsix, CH_Armory_Locker.DoorPos.doorsix2 ) then
-- 				if not locker:GetLockerDoor6() then
-- 					net.Start( "ARM_LOCKER_CL_LockStart" )
-- 						net.WriteEntity( locker )
-- 						net.WriteEntity( self )
-- 					net.Send( self.Owner )
		
-- 					locker:SetLockerDoor6( true )
-- 					self.Owner.IsLockpicking = true
					
-- 					timer.Simple( CH_Armory_Locker.Config.LockpickTime, function()
-- 						if not locker:GetLockerDoor6() then
-- 							return
-- 						end
						
-- 						trent = locker:WorldToLocal( self.Owner:GetEyeTrace().HitPos )
-- 						Dist = self.Owner:EyePos():DistToSqr( tr.HitPos )
						
-- 						if trent:WithinAABox( CH_Armory_Locker.DoorPos.doorsix, CH_Armory_Locker.DoorPos.doorsix2 ) and Dist < 2734 then
-- 							self:LockpickFinished( 6, locker, self.Owner )
-- 						else
-- 							locker:SetLockerDoor6( false )
-- 							self.Owner.IsLockpicking = false
-- 							DarkRP.notify( self.Owner, 1, 5, "[Lockpick Failed] Keep aiming at the same door." )
-- 							return
-- 						end
-- 					end )
-- 				else
-- 					DarkRP.notify( self.Owner, 1, 5, "This door is unavailable for lockpicking at the moment!" )
-- 					return
-- 				end
-- 			elseif trent:WithinAABox( CH_Armory_Locker.DoorPos.doorseven, CH_Armory_Locker.DoorPos.doorseven2 ) then
-- 				if not locker:GetLockerDoor7() then
-- 					net.Start( "ARM_LOCKER_CL_LockStart" )
-- 						net.WriteEntity( locker )
-- 						net.WriteEntity( self )
-- 					net.Send( self.Owner )
		
-- 					locker:SetLockerDoor7( true )
-- 					self.Owner.IsLockpicking = true
					
-- 					timer.Simple( CH_Armory_Locker.Config.LockpickTime, function()
-- 						if not locker:GetLockerDoor7() then
-- 							return
-- 						end
						
-- 						trent = locker:WorldToLocal( self.Owner:GetEyeTrace().HitPos )
-- 						Dist = self.Owner:EyePos():DistToSqr( tr.HitPos )
						
-- 						if trent:WithinAABox( CH_Armory_Locker.DoorPos.doorseven, CH_Armory_Locker.DoorPos.doorseven2 ) and Dist < 2734 then
-- 							self:LockpickFinished( 7, locker, self.Owner )
-- 						else
-- 							locker:SetLockerDoor7( false )
-- 							self.Owner.IsLockpicking = false
-- 							DarkRP.notify( self.Owner, 1, 5, "[Lockpick Failed] Keep aiming at the same door." )
-- 							return
-- 						end
-- 					end )
-- 				else
-- 					DarkRP.notify( self.Owner, 1, 5, "This door is unavailable for lockpicking at the moment!" )
-- 					return
-- 				end
-- 			elseif trent:WithinAABox( CH_Armory_Locker.DoorPos.dooreight, CH_Armory_Locker.DoorPos.dooreight2 ) then
-- 				if not locker:GetLockerDoor8() then
-- 					net.Start( "ARM_LOCKER_CL_LockStart" )
-- 						net.WriteEntity( locker )
-- 						net.WriteEntity( self )
-- 					net.Send( self.Owner )
		
-- 					locker:SetLockerDoor8( true )
-- 					self.Owner.IsLockpicking = true
					
-- 					timer.Simple( CH_Armory_Locker.Config.LockpickTime, function()
-- 						if not locker:GetLockerDoor8() then
-- 							return
-- 						end
						
-- 						trent = locker:WorldToLocal( self.Owner:GetEyeTrace().HitPos )
-- 						Dist = self.Owner:EyePos():DistToSqr( tr.HitPos )
						
-- 						if trent:WithinAABox( CH_Armory_Locker.DoorPos.dooreight, CH_Armory_Locker.DoorPos.dooreight2 ) and Dist < 2734 then
-- 							self:LockpickFinished( 8, locker, self.Owner )
-- 						else
-- 							locker:SetLockerDoor8( false )
-- 							self.Owner.IsLockpicking = false
-- 							DarkRP.notify( self.Owner, 1, 5, "[Lockpick Failed] Keep aiming at the same door." )
-- 							return
-- 						end
-- 					end )
-- 				else
-- 					DarkRP.notify( self.Owner, 1, 5, "This door is unavailable for lockpicking at the moment!" )
-- 					return
-- 				end
-- 			end
			
-- 			DarkRP.notify( self.Owner, 1, 5, "Lockpicking armory has begun. Keep aiming at the same door through the process!" )
-- 		end
		

-- 		if locker:GetLockerDoor1() or locker:GetLockerDoor2() or locker:GetLockerDoor3() or locker:GetLockerDoor4() or locker:GetLockerDoor5() or locker:GetLockerDoor6() or locker:GetLockerDoor7() or locker:GetLockerDoor8() then
-- 			self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
			
-- 			timer.Simple( ( CH_Armory_Locker.Config.LockpickTime - 1 ), function()
-- 				if IsValid( self.Weapon ) then
-- 					if locker:GetLockerDoor1() or locker:GetLockerDoor2() or locker:GetLockerDoor3() or locker:GetLockerDoor4() or locker:GetLockerDoor5() or locker:GetLockerDoor6() or locker:GetLockerDoor7() or locker:GetLockerDoor8() then
-- 						self.Weapon:SendWeaponAnim( ACT_VM_LOWERED_TO_IDLE )
						
-- 						timer.Simple( 1, function()
-- 							if IsValid( self.Weapon ) then
-- 								self.Weapon:SendWeaponAnim( ACT_VM_IDLE )
-- 							end
-- 						end )
-- 					end
-- 				end
-- 			end )
-- 		end
-- 	else
-- 		if SERVER then
-- 			DarkRP.notify( self.Owner, 1, 5, "You need to be aiming at a police armory." )
-- 		end
-- 		return
-- 	end
-- end

function SWEP:LockpickFinished( doornum, locker )
	print( doornum )
	print( locker )
	print( self )
	print( self.Owner )
	
	net.Start( "ARM_LOCKER_DoorOpenSeq" )
		net.WriteEntity( locker )
		net.WriteInt( doornum, 8 )
		net.WriteBool( true )
	net.Send( self.Owner )
							
	net.Start( "ARM_LOCKER_Weapon_Menu" )
		net.WriteEntity( locker )
		net.WriteInt( doornum, 8 )
		net.WriteTable( table.Random( CH_Armory_Locker.Weapons ) )
		net.WriteTable( table.Random( CH_Armory_Locker.Weapons ) )
		net.WriteTable( table.Random( CH_Armory_Locker.Weapons ) )
	net.Send( self.Owner )
								
	locker:EmitSound( "doors/default_move.wav" )
end

function SWEP:SecondaryAttack()
	self.Weapon:SetNextSecondaryFire( CurTime() + self.Secondary.Delay )
end

local ourmat_locker = Material( "icon16/accept.png" )
local ourmat_cooldown = Material( "icon16/cross.png" )

local mat_lock_bg = Material( "craphead_scripts/lockpick/bg_stripes.png")
local mat_lock_white = Material( "craphead_scripts/lockpick/white_bar.png")

local col_white = Color( 255, 255, 255, 255 )
local col_black = Color( 20, 20, 20, 255 )
	
if CLIENT then
	local Lenght_Target = 350
	local Lenght_Speed = 4 / CH_Armory_Locker.Config.LockpickTime
	
	net.Receive( "ARM_LOCKER_CL_LockStart", function( length, ply )
		local locker = net.ReadEntity()
		local self = net.ReadEntity()
		
		if locker:GetClass() == "police_locker" then
			self.Target = locker
			self.LockpickTarget = CurTime() + CH_Armory_Locker.Config.LockpickTime
			self.Cur_Num = 0
		end
	end )
	
	function SWEP:DrawHUD()
		local tr = self.Owner:GetEyeTrace()
		local locker = tr.Entity
		
		if not locker:GetClass() == "police_locker" then
			self.Target = nil 
			self.LockpickTarget = nil 
		end

		local Dist = self.Owner:EyePos():DistToSqr( tr.HitPos )
		if Dist > 50000 then
			self.Target = nil 
			self.LockpickTarget = nil 
			return false 
		end
		
		if locker == self.Target then
			if self.LockpickTarget <= CurTime() then
				self.Target = nil
				self.LockpickTarget = nil
				return
			else
				self.Cur_Num = math.Approach( self.Cur_Num, Lenght_Target, Lenght_Speed )
				
				surface.SetDrawColor( col_white )
				surface.SetMaterial( mat_lock_bg )
				surface.DrawTexturedRect( ScrW() * 0.4, ScrH() * 0.875, 350, ScrH() * 0.02 )

				surface.SetDrawColor( col_white )
				surface.SetMaterial( mat_lock_white )
				surface.DrawTexturedRect( ScrW() * 0.4, ScrH() * 0.875, self.Cur_Num, ScrH() * 0.02 )
				
				surface.SetTextColor( col_white )
				surface.SetFont( "ARMORY_UIFontButton" )
				surface.SetTextPos( ScrW() * 0.47, ScrH() * 0.85 )
				surface.DrawText( "Lockpicking..." )
			end
		end
	end
end

function SWEP:DoDrawCrosshair( x, y )
	local size = 7
	
	if LocalPlayer():GetNWBool( "LockpickCooldown" ) then
		surface.SetDrawColor( col_white )
		surface.SetMaterial( ourmat_cooldown )
		surface.DrawTexturedRect( x, y, 16, 16 )
	else
		draw.RoundedBox( 6, x, y, size, size, col_white )
	end
	return true
end
--gamemodes/darkrp/entities/weapons/arrest_stick/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.Slot = 1
    SWEP.SlotPos = 3
end

DEFINE_BASECLASS("stick_base")

SWEP.Instructions = "Left click to arrest\nRight click to switch batons"
SWEP.IsDarkRPArrestStick = true

SWEP.PrintName = "Arrest Baton"
SWEP.Spawnable = true
SWEP.Category = "DarkRP (Utility)"

SWEP.StickColor = Color(255, 0, 0)

SWEP.Switched = true

DarkRP.hookStub{
    name = "canArrest",
    description = "Whether someone can arrest another player.",
    parameters = {
        {
            name = "arrester",
            description = "The player trying to arrest someone.",
            type = "Player"
        },
        {
            name = "arrestee",
            description = "The player being arrested.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canArrest",
            description = "A yes or no as to whether the arrester can arrest the arestee.",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when they can't arrest the player.",
            type = "string"
        }
    },
    realm = "Server"
}

DarkRP.hookStub{
    name = "setArrestStickTime",
    description = "Sets arrest time for an arrest made via the arrest stick",
    parameters = {
        {
            name = "arrest_stick",
            description = "The arrest strick weapon with which the arrestee was arrested.",
            type = "Weapon"
        },
        {
            name = "arrester",
            description = "The player trying to arrest someone.",
            type = "Player"
        },
        {
            name = "arrestee",
            description = "The player being arrested.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "time",
            description = "The time to arrest the player.",
            type = "integer"
        }
    },
    realm = "Server"
}

function SWEP:Deploy()
    self.Switched = true
    return BaseClass.Deploy(self)
end

function SWEP:PrimaryAttack()
    BaseClass.PrimaryAttack(self)

    if CLIENT then return end

    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    Owner:LagCompensation(true)
    local trace = util.QuickTrace(Owner:EyePos(), Owner:GetAimVector() * 90, {Owner})
    Owner:LagCompensation(false)

    local ent = trace.Entity
    if IsValid(ent) and ent.onArrestStickUsed then
        ent:onArrestStickUsed(Owner)
        return
    end

    ent = Owner:getEyeSightHitEntity(nil, nil, function(p) return p ~= Owner and p:IsPlayer() and p:Alive() and p:IsSolid() end)

    local stickRange = self.stickRange * self.stickRange
    if not IsValid(ent) or (Owner:EyePos():DistToSqr(ent:GetPos()) > stickRange) or not ent:IsPlayer() then
        return
    end

    local canArrest, message = hook.Call("canArrest", DarkRP.hooks, Owner, ent)
    if not canArrest then
        if message then DarkRP.notify(Owner, 1, 5, message) end
        return
    end

    local time = hook.Call("setArrestStickTime", DarkRP.hooks, self, Owner, ent)
    ent:arrest(time, Owner)
    DarkRP.notify(ent, 0, 20, DarkRP.getPhrase("youre_arrested_by", Owner:Nick()))

    if Owner.SteamName then
        DarkRP.log(Owner:Nick() .. " (" .. Owner:SteamID() .. ") arrested " .. ent:Nick(), Color(0, 255, 255))
    end
end

function SWEP:startDarkRPCommand(usrcmd)
    local Owner = self:GetOwner()
    if not IsValid(Owner) then return end

    if game.SinglePlayer() and CLIENT then return end
    if usrcmd:KeyDown(IN_ATTACK2) then
        if not self.Switched and Owner:HasWeapon("unarrest_stick") then
            usrcmd:SelectWeapon(Owner:GetWeapon("unarrest_stick"))
        end
    else
        self.Switched = false
    end
end

--addons/cityworker/lua/weapons/cityworker_config.lua:
return gluapack()()
--addons/cityworker/lua/weapons/cityworker_shovel.lua:
SWEP.PrintName              = "Kürek"
SWEP.Author                 = "Silhouhat"
SWEP.Purpose                = "City Worker"
SWEP.Instructions           = "LMB to clear rubble"

SWEP.Category               = "City Worker"
SWEP.Spawnable              = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		    = "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		    = "none"

SWEP.Weight			        = 5
SWEP.AutoSwitchTo		    = false
SWEP.AutoSwitchFrom		    = false

SWEP.Slot			        = 3
SWEP.SlotPos			    = 1
SWEP.DrawAmmo			    = false
SWEP.DrawCrosshair		    = true

SWEP.ViewModel			    = "models/props_junk/shovel01a.mdl"
SWEP.WorldModel			    = "models/props_junk/shovel01a.mdl"

function SWEP:Initialize()
    self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()
    if CLIENT then return end
    if not IsFirstTimePredicted() then return end

    self:SetNextPrimaryFire( CurTime() + 1 )

    local ent = self.Owner:GetEyeTrace().Entity
    if not IsValid( ent ) then return end
    if ent:GetClass() != "cityworker_rubble" then return end
    if ent:GetPos():Distance( self.Owner:GetPos() ) > 200 then return end

    CITYWORKER.Begin( self.Owner, ent )
end

function SWEP:SecondaryAttack()
    return
end

function SWEP:Reload()
    return
end

function SWEP:DrawWorldModel()
    /*

    if not IsValid( self.Owner ) then return end

    local pos, ang = self.Owner:GetBonePosition( self.Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ) )
    local offsetPos = ang:Right() * 1 + ang:Forward() * 2 + ang:Up() * 5

    ang:RotateAroundAxis( ang:Right(), 0 )
    ang:RotateAroundAxis( ang:Forward(), 180 )
    ang:RotateAroundAxis( ang:Up(), 0 )

    self:SetRenderOrigin( pos + offsetPos )
    self:SetRenderAngles( ang )

    self:DrawModel()
    */
end

function SWEP:GetViewModelPosition( pos, ang )
    pos = pos + ang:Right() * 20 + ang:Forward() * 35 + ang:Up() * -18

    ang:RotateAroundAxis( ang:Up(), 0 )
    ang:RotateAroundAxis( ang:Right(), 180 )

    return pos, ang
end
--addons/dradio/lua/weapons/dradio/cl_init.lua:

include("shared.lua")
surface.CreateFont( "radio_45", { font = "digital-7", size = 45, weight = 400, antialias = true,})
surface.CreateFont( "radio_60", { font = "Comfortaa", size = 60, extended = true, weight = 400, antialias = true,})
surface.CreateFont( "radio_36", { font = "Comfortaa", size = 36, extended = true, weight = 400, antialias = true,})
surface.CreateFont( "radio_16", { font = "Comfortaa", size = 16, extended = true, weight = 400, antialias = true,})
local radio = {}
radio.w = 140
radio.h = 60
local frequency = 0
local frequencyIncrement = .001
local inputText = "Frekans Girin"

function SWEP:PostDrawViewModel( vm, weapon, ply )

	if weapon:GetClass() == "dradio" and IsValid(self) then
		local BoneIndx = vm:LookupBone("ValveBiped.Bip01_R_Hand")
		local BonePos, BoneAng = vm:GetBonePosition( BoneIndx )
		TextPos = BonePos + BoneAng:Forward() * 4.9 + BoneAng:Right() * 2.66 + BoneAng:Up() * -2.89
		TextAngle = BoneAng
		TextAngle:RotateAroundAxis(TextAngle:Right(), 191)
		TextAngle:RotateAroundAxis(TextAngle:Up(), -3.1)
		TextAngle:RotateAroundAxis(TextAngle:Forward( ), 90)
		cam.Start3D2D( TextPos, TextAngle, .01 )
			if self:GetNWBool("power") then
				surface.SetDrawColor(175,199,139,255)
				surface.DrawRect(0, 0, radio.w, radio.h)
				draw.SimpleText(frequency, "radio_45", radio.w / 2, radio.h / 2, Color(50,50,50,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
				surface.SetFont("radio_60")
			end
			if self:GetNWBool("editting") then
				surface.SetDrawColor(0,0,0,100)
				surface.DrawRect(200, -260, 525, 240)
				draw.SimpleText("Frekans Artışı: " .. frequencyIncrement, "radio_36", 200, -240, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				draw.SimpleText("[R] - Radyo Frekansını İleri Ayarla", "radio_36", 200, -200, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				draw.SimpleText("[E] - Radyo Frekansını Geri Ayarla", "radio_36", 200, -160, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				draw.SimpleText("[SOL TIK] - Artışı Yükselt", "radio_36", 200, -120, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				draw.SimpleText("[SAĞ TIK] - Artışı Azalt", "radio_36", 200, -80, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
				draw.SimpleText("[ORTA TIK] - " .. inputText, "radio_36", 200, -40, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

			else
				surface.SetDrawColor(0,0,0,100)
				surface.DrawRect(-125 - 600, -100, 600 + 30, 70)
				if self:GetNWBool("power") then
					draw.SimpleText("[SOL TIK] - Kapat", "radio_60", -100, -70, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
					surface.DrawRect(-125 - 525, -30, 555, 70)
					draw.SimpleText("[" .. string.upper(input.GetKeyName(RADIO.MenuKey)).."] - Frekans Değiştir", "radio_60", -100, 0, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
					local ypos = 70
					local numChannels = 0
					local foundChannel
					for k,v in pairs(RADIO.RADIOCHANNELS) do
						if table.HasValue(v.teams, LocalPlayer():Team()) then
							local tw, th = surface.GetTextSize("GÜVENLİ KANAL: " .. v.frequency)
							surface.DrawRect(-125 - tw, ypos - 30, tw + 30, 70)
							draw.SimpleText("GÜVENLİ KANAL: " .. v.frequency, "radio_60", -100, ypos, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
							numChannels = numChannels + 1
							ypos = ypos + 70
						end

						if frequency == v.frequency then
							foundChannel = v.name
						end

					end
					if foundChannel then
						local tw, wh = surface.GetTextSize(foundChannel .. " KANALI")
						surface.DrawRect(-125 - tw, 70 * (numChannels + 1) - 30, tw + 30, 70)
						draw.SimpleText(foundChannel .. " KANALI", "radio_60", -100, 70 * (numChannels + 1), color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
					end
				else
					draw.SimpleText("[SOL TIK] - Aç", "radio_60", -100, -70, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
				end
			end
		cam.End3D2D()
	end
end

local lastChange = CurTime()

local function ChangeFrequency(newVal, increase)
	increase = increase or false
	net.Start("dradio_adjustfrequency")
	net.WriteFloat(newVal)
	net.WriteBool(increase)
	net.SendToServer()

end

local function fMenu()

	local ply = LocalPlayer()
	local wep = ply:GetActiveWeapon()
	if not wep:GetNWBool("editting") then return end
	if radio.menu then return end
	radio.menu = vgui.Create("DFrame")
	local rmenu = radio.menu
	rmenu:SetSize(150, 30)
	rmenu:Center()
	rmenu:MakePopup()
	rmenu:SetTitle("")
	rmenu:ShowCloseButton(false)
	rmenu.Paint = function(me,w,h)
		surface.SetDrawColor(0,0,0,100)
		surface.DrawRect(0,0,w,h)
	end
	rmenu.OnClose = function()
		radio.menu = nil
		rmenu:Remove()
	end
	radio.menu.finput = vgui.Create("DTextEntry", rmenu)
	local finput = radio.menu.finput
	finput:SetPos(0,0)
	finput:SetSize(rmenu:GetWide(), rmenu:GetTall())
	finput:SetFont("radio_16")
	finput:SetNumeric(true)
	function finput:OnEnter()
		if string.len(self:GetValue()) <= 0 then return end
		rmenu:Remove()
		radio.menu = nil
		ChangeFrequency(math.Round(tonumber(self:GetValue()), 3))
	end
	local tcolor = Color(175,199,139,140)
	finput.Paint = function(me,w,h)
		surface.SetDrawColor(60,60,60,255)
		surface.DrawRect(0,0,w,h)
		me:DrawTextEntryText(color_white, tcolor, tcolor)
		if string.len(me:GetText()) <= 0 then
			draw.SimpleText("Frekans Girin", "radio_16", w / 2, h / 2, Color(140, 140, 140, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	end
	function finput:OnChange()
		if not self:GetValue() then return end

		if not tonumber(self:GetValue()) then self:SetText("") return end
		if tonumber(self:GetValue()) >= 1000 then
			self:SetText(999.999)
		elseif tonumber(self:GetValue()) < .001 then
			self:SetText(.001)
		end
	end

end
function SWEP:Think()


	if lastChange + .15 < CurTime() and not radio.menu then
		if input.IsKeyDown(RADIO.MenuKey) then
			if self:GetNWBool("power") then
				net.Start("dradio_edit")
				net.SendToServer()
				lastChange = CurTime() + 1
			end
		end 
		if input.IsKeyDown(KEY_R) then
			ChangeFrequency(frequency + frequencyIncrement, true)
			lastChange = CurTime()
		elseif input.IsKeyDown(KEY_E) then
			ChangeFrequency(frequency - frequencyIncrement, false)
			lastChange = CurTime()
		end
		if input.IsMouseDown(MOUSE_LEFT) then
			frequencyIncrement = frequencyIncrement * 10
			if frequencyIncrement > 100 then
				frequencyIncrement = 100
			end
			lastChange = CurTime()
		elseif input.IsMouseDown(MOUSE_RIGHT) then
			frequencyIncrement = frequencyIncrement * .1
			if frequencyIncrement < .001 then
				frequencyIncrement = .001
			end
			lastChange = CurTime()
		elseif input.IsMouseDown(MOUSE_MIDDLE) then
			fMenu()
			lastChange = CurTime()
		end

	end

end



hook.Add("ContextMenuOpen", "Manage Radio", function()

	local ply = LocalPlayer()
	local weapon = ply:GetActiveWeapon()
	if IsValid(weapon) and weapon:GetClass() == "dradio" and RADIO.MenuKey == KEY_C  then
		return false
	end

end)
local staticSound = staticSound or nil
hook.Add("InitPostEntity", "RadioSounds", function()
	staticSound = CreateSound(LocalPlayer(), "dradio/radio_static.wav" )
end)



hook.Add("PlayerStartVoice", "RadioVoiceChatStart", function(ply)

	local LP = LocalPlayer()
	if frequency == 0 or not frequency then return end
	if ply == LocalPlayer() then
		if RADIO and RADIO.WhileHolding and IsValid(LP:GetActiveWeapon()) and LP:GetActiveWeapon():GetClass() == "dradio" then
			surface.PlaySound("dradio/radio_on.wav")
		elseif RADIO and not RADIO.WhileHolding and ply:HasWeapon("dradio") then
			surface.PlaySound("dradio/radio_on.wav")
		end
	end
	if ply != LocalPlayer() and ply.frequency == frequency then

		if RADIO and RADIO.WhileHolding and IsValid(ply:GetActiveWeapon()) and ply:GetActiveWeapon():GetClass() == "dradio" then
			staticSound:Play()
			staticSound:ChangeVolume(1, .1)
		elseif RADIO and not RADIO.WhileHolding then
			staticSound:Play()
			staticSound:ChangeVolume(1, .1)
		end

	end


end )

net.Receive("dradio_clearfrequency", function()

	frequency = nil

end)

net.Receive("dradio_networkfrequency", function()
	local freq = net.ReadDouble()
	local speaker = net.ReadEntity()
	speaker.frequency = freq
end)

hook.Add("PlayerEndVoice", "RadioVoiceChatEnd", function(ply)
	staticSound:Stop()
	local LP = LocalPlayer()
	if frequency and frequency != 0 and ply.frequency != 0 and ply.frequency == frequency then


		if RADIO and RADIO.WhileHolding and IsValid(LP:GetActiveWeapon()) and LP:GetActiveWeapon():GetClass() == "dradio" and
		ply:GetActiveWeapon() and ply:GetActiveWeapon():GetClass() == "dradio" then
			surface.PlaySound("dradio/radio_off.wav")
		elseif RADIO and not RADIO.WhileHolding then
			surface.PlaySound("dradio/radio_off.wav")
		end

	end

end)

net.Receive("dradio_updatefrequency", function()

	local freq = net.ReadDouble()
	frequency =	freq

end)

net.Receive("dradio_sendMessage", function()

	local ply = LocalPlayer()
	local message = net.ReadString()
	local freq = net.ReadDouble()
	local speaker = net.ReadEntity()
	message = string.sub(message, 3)
	speaker.frequency = freq
	if frequency == 0 and speaker == ply then
		chat.AddText(RADIO.FailMessage)
	end
	if frequency and frequency != 0 and speaker.frequency != 0 and speaker.frequency == frequency then
		chat.AddText(Color(175,199,139,255), "[" .. frequency .. "] ", team.GetColor(speaker:Team()), speaker:Name() .. ": ", Color(255,255,255), message)
	end

end)

--addons/dradio/lua/weapons/dradio/shared.lua:
return gluapack()()
--addons/gmodadminsuite-logging-2.4.8/lua/weapons/gas_log_scanner/shared.lua:
return gluapack()()
--lua/weapons/gas_weapon_hands.lua:
AddCSLuaFile()

SWEP.PrintName = "Hands"
SWEP.Slot = 0
SWEP.SlotPos = 0

SWEP.DrawAmmo = false

SWEP.Spawnable = false

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawCrosshair = false

SWEP.WorldModel = ""

SWEP.Instructions = "You are temporarily restricted to this weapon only."

function SWEP:Initialize()
	self:SetHoldType("normal")
end

function SWEP:Deploy()
	if (CLIENT or not IsValid(self:GetOwner())) then return true end
	self:GetOwner():DrawWorldModel(false)
	return true
end

function SWEP:PreDrawViewModel()
	return true
end

function SWEP:PrimaryAttack() end
function SWEP:SecondaryAttack() end
function SWEP:Reload() end
--addons/minigame-tool-assistant/lua/weapons/gmod_tool/stools/minigame_tool.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/weapons/gmod_tool/stools/minigame_tool.lua:


TOOL.Name = "Minigame Tool Assistant"
TOOL.Category = "Minigames"

if CLIENT then
    TOOL.Information = {
        { name = "left" },
        { name = "right" },
        { name = "reload" }
    }

    language.Add("tool.minigame_tool.name", "Minigame Tool Assistant")
    language.Add("tool.minigame_tool.desc", Minigames.GetPhrase("tool.desc"))
    language.Add("tool.minigame_tool.left", Minigames.GetPhrase("tool.left"))
    language.Add("tool.minigame_tool.right", Minigames.GetPhrase("tool.right"))
    language.Add("tool.minigame_tool.reload", Minigames.GetPhrase("tool.reload"))
end


function TOOL:LeftClick( trace )
    local owner = self:GetOwner()

    if ( CLIENT ) then return false end
    if not ( Minigames.IsAllowed(owner) ) then return end

    return Minigames.RunEvent.LeftClick(trace, owner)
end


function TOOL:RightClick( trace )
    local owner = self:GetOwner()

    if ( CLIENT ) then return false end
    if not ( Minigames.IsAllowed(owner) ) then return end

    net.Start("Minigames.SetupMenu")
    net.Send(owner)
end


local First = true
function TOOL:Reload( trace )
    local owner = self:GetOwner()

    -- if ( CLIENT ) then return false end
    if not ( Minigames.IsAllowed(owner) ) then return end

    if First and game.SinglePlayer() then
        Minigames.BroadcastMessage( Minigames.GetPhrase("tool.singleplayer") )
        First = false
    end

    Minigames.RunEvent.Reload(trace, owner)
end


function TOOL:Think()
    local owner = self:GetOwner()
    local trace = owner:GetEyeTrace()

    if not ( Minigames.IsAllowed(owner) ) then return end
    --if ( Minigames.ActiveGames[ owner ] ) then return end

    Minigames.RunEvent.Think(trace, owner)
end


function TOOL:Deploy()
    local owner = self:GetOwner()
    local trace = owner:GetEyeTrace()

    if not ( Minigames.IsAllowed(owner) ) then return end

    Minigames.RunEvent.Deploy(trace, owner)
end

function TOOL:Holster()
    local owner = self:GetOwner()
    local trace = owner:GetEyeTrace()

    if not ( Minigames.IsAllowed(owner) ) then return end
    local GameToSpawn = owner:GetInfo("minigames_game")

    if Minigames.Games[ GameToSpawn ] then
        Minigames.Games[ GameToSpawn ]:RollUp( owner, trace )
    end
end

function TOOL:DrawHUD()
    local owner = self:GetOwner()
    if not ( Minigames.IsAllowed(owner) ) then return end

    Minigames.RunEvent.DrawHUD()
end

--[[
local KnownClasses = {
    ["player"] = "Player",
    ["minigame_bigsquare"] = "Minigame",
    ["minigame_boxgame"] = "Minigame",
    ["minigame_npc"] = "MG Bot",
    ["minigame_prop"] = "Minigame",
    ["mingiame_smallquare"] = "Minigame",
    ["minigame_square_base"] = "Minigame",
    ["minigame_square"] = "Minigame",
    ["minigame_trigger"] = "Trigger",
}

function TOOL:DrawToolScreen(width, height)
    local owner = self:GetOwner()
    if not ( Minigames.IsAllowed(owner) ) then return end

    surface.SetDrawColor(0, 0, 0, 255)
    surface.DrawRect(0, 0, width, height)

    for i = 1, 50 do
        surface.SetDrawColor(35, 67, 131, 255 - (i * 6))
        surface.DrawRect(4 + ( 6 * i), 8, 4, height / 3.5)
    end

    -- title
    draw.SimpleText("Minigame Tool", "DermaLarge", width / 2, 10, color_white, TEXT_ALIGN_CENTER)
    draw.SimpleText("Assistant", "DermaLarge", width / 2, 40, color_white, TEXT_ALIGN_CENTER)

    -- Has minigame

    if Minigames.ActiveGames[ owner ] then
        local trace = owner:GetEyeTrace()
        local target = trace.Entity
        local targetname = IsValid(target) and target:IsPlayer() and target:Nick() or KnownClasses[ target:GetClass() ] or "None"

        draw.SimpleText("Target: " .. targetname, "DermaLarge", 4, 90, color_white, TEXT_ALIGN_LEFT)

        if IsValid(target) and target:IsPlayer() then
            draw.SimpleText("In game: " .. tostring(target:GetNWBool("Minigames.InGame", false)), "DermaLarge", 4, 140, color_white, TEXT_ALIGN_LEFT)

            if target:GetNWBool("Minigames.InGame", false) then
                draw.SimpleText("Owner:", "DermaLarge", 4, 170, color_white, TEXT_ALIGN_LEFT)
                draw.SimpleText(target:GetNWEntity("Minigames.Owner", NULL):Nick(), "DermaLarge", 4, 200, color_white, TEXT_ALIGN_LEFT)
            end
        end
    else
        draw.SimpleText("No Minigame", "DermaLarge", width / 2, height / 2, color_white, TEXT_ALIGN_CENTER)
        draw.SimpleText("available", "DermaLarge", width / 2, height / 2 + 30, color_white, TEXT_ALIGN_CENTER)
    end
end
--]]

--[[----------------------------
           Roll Up Event
----------------------------]]--

if SERVER then

    hook.Add("PlayerSwitchWeapon", "Minigame.RollUp", function(owner, old, new)
        if not IsValid( old ) then return end
        if new ~= "gmod_tool" then return end

        if ( Minigames.IsAllowed(owner) ) then
            local oldweapon = old:GetClass()
            local newweapon = new:GetClass()
            local GameToSpawn = owner:GetInfo("minigames_game")
            local CurrentTool = owner:GetInfo("gmod_toolmode")

            if ( oldweapon == "gmod_tool" ) and ( oldweapon ~= newweapon ) and ( CurrentTool == "minigame_tool" ) then
                if Minigames.Games[ GameToSpawn ] then
                    Minigames.Games[ GameToSpawn ]:RollUp( owner, owner:GetEyeTrace() )
                end

                net.Start("Minigames.ToolRollUp")
                    net.WriteString( GameToSpawn )
                net.Send(owner)
            end
        end
    end)

    hook.Add("DoPlayerDeath", "Minigames.RollUpOnDeath", function(ply)
        local TheWeapon = ply:GetActiveWeapon()
        local WeaponClass = IsValid(TheWeapon) and TheWeapon:GetClass() or nil

        if WeaponClass and ( WeaponClass == "gmod_tool" ) and ( ply:GetInfo("gmod_toolmode") == "minigame_tool" ) then
            local GameToSpawn = ply:GetInfo("minigames_game")

            if Minigames.Games[ GameToSpawn ] then
                Minigames.Games[ GameToSpawn ]:RollUp( ply, ply:GetEyeTrace() )
            end

            net.Start("Minigames.ToolRollUp")
                net.WriteString( GameToSpawn )
            net.Send(ply)
        end
    end)

else

    net.Receive("Minigames.ToolRollUp", function()
        local GameToSpawn = net.ReadString()
        if not Minigames.Games[ GameToSpawn ] then return end

        local owner = LocalPlayer()

        Minigames.Games[ GameToSpawn ]:RollUp( owner, owner:GetEyeTrace() )
    end)

    cvars.AddChangeCallback("gmod_toolmode", function(_, old)
        if old == "minigame_tool" then
            local Minigame = GetConVar("minigames_game"):GetString()
            if Minigames.Games[ Minigame ] then
                Minigames.Games[ Minigame ]:RollUp( LocalPlayer(), LocalPlayer():GetEyeTrace() )
            end
        end
    end, "Minigames.RollUp.OnToolChange")

    cvars.AddChangeCallback("minigames_game", function(convar, old)
        if ( convar == "minigames_game" ) and Minigames.Games[ old ] then
            Minigames.Games[ old ]:RollUp( LocalPlayer(), LocalPlayer():GetEyeTrace() )
        end
    end, "Minigames.RollUp.OnGameChange")
end
--addons/permaprops/lua/weapons/gmod_tool/stools/permaprops.lua:
return gluapack()()
--lua/weapons/gmod_tool/stools/precision.lua:

TOOL.Category		= "Constraints"
TOOL.Name			= "#Precision"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "mode" ]	 			= "1"
TOOL.ClientConVar[ "user" ] 			= "1"

TOOL.ClientConVar[ "freeze" ]	 		= "1"
TOOL.ClientConVar[ "nocollide" ]		= "1"
TOOL.ClientConVar[ "nocollideall" ]		= "0"
TOOL.ClientConVar[ "rotation" ] 		= "15"
TOOL.ClientConVar[ "rotate" ] 			= "1"
TOOL.ClientConVar[ "offset" ]	 		= "0"
TOOL.ClientConVar[ "forcelimit" ]		= "0"
TOOL.ClientConVar[ "torquelimit" ] 		= "0"
TOOL.ClientConVar[ "friction" ]	 		= "0"
TOOL.ClientConVar[ "width" ]	 		= "1"
TOOL.ClientConVar[ "offsetpercent" ] 	= "1"
TOOL.ClientConVar[ "removal" ]	 		= "0"
TOOL.ClientConVar[ "move" ]	 			= "1"
TOOL.ClientConVar[ "physdisable" ]		= "0"
TOOL.ClientConVar[ "ShadowDisable" ]	= "0"
TOOL.ClientConVar[ "allowphysgun" ]		= "0"
TOOL.ClientConVar[ "autorotate" ]		= "0"
TOOL.ClientConVar[ "entirecontrap" ]	= "0"
TOOL.ClientConVar[ "nudge" ]			= "25"
TOOL.ClientConVar[ "nudgepercent" ]		= "1"
TOOL.ClientConVar[ "disablesliderfix" ]	= "0"

//adv ballsocket
TOOL.ClientConVar[ "XRotMin" ]		= "-180"
TOOL.ClientConVar[ "XRotMax" ]		= "180"
TOOL.ClientConVar[ "YRotMin" ]		= "-180"
TOOL.ClientConVar[ "YRotMax" ]		= "180"
TOOL.ClientConVar[ "ZRotMin" ]		= "-180"
TOOL.ClientConVar[ "ZRotMax" ]		= "180"
TOOL.ClientConVar[ "XRotFric" ]		= "0"
TOOL.ClientConVar[ "YRotFric" ]		= "0"
TOOL.ClientConVar[ "ZRotFric" ]		= "0"
TOOL.ClientConVar[ "FreeMov" ]		= "0"

//Removal
TOOL.ClientConVar[ "removal_nocollide" ]	= "1"
TOOL.ClientConVar[ "removal_weld" ]	 		= "1"
TOOL.ClientConVar[ "removal_axis" ]	 		= "1"
TOOL.ClientConVar[ "removal_ballsocket" ]	= "1"
TOOL.ClientConVar[ "removal_advballsocket" ]= "1"
TOOL.ClientConVar[ "removal_slider" ]	 	= "1"
TOOL.ClientConVar[ "removal_parent" ]	 	= "1"
TOOL.ClientConVar[ "removal_other" ]	 	= "1"


TOOL.ClientConVar[ "enablefeedback" ]	= "1"
TOOL.ClientConVar[ "chatfeedback" ]		= "1"
TOOL.ClientConVar[ "nudgeundo" ]		= "0"
TOOL.ClientConVar[ "moveundo" ]			= "1"
TOOL.ClientConVar[ "rotateundo" ]		= "1"

function TOOL:DoParent( Ent1, Ent2 )
	local TempEnt = Ent2
	if !(Ent1 && Ent1:IsValid() && Ent1:EntIndex() != 0) then
		self:SendMessage( "Oops, First Target was world or something invalid" )
		return
	end
	if !(Ent2 && Ent2:IsValid() && Ent2:EntIndex() != 0) then
		self:SendMessage( "Oops, Second Target was world or something invalid" )
		return
	end
	if ( Ent1 == Ent2 ) then
		self:SendMessage( "Oops, Can't parent something to itself" )
		return
	end
	Ent1:SetMoveType(MOVETYPE_NONE)
	local disablephysgun = self:GetClientNumber( "allowphysgun" ) == 0
	Ent1.PhysgunDisabled = disablephysgun
	Ent1:SetUnFreezable( disablephysgun )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( false )
	end
	while true do
		if ( !TempEnt:GetParent():IsValid() ) then
			Ent1:SetParent( Ent2 )
			if self:GetClientNumber( "entirecontrap" ) == 0 then self:SendMessage( "Parent Set." ) end
			Phys1:Wake()
			break
		elseif ( TempEnt:GetParent() == Ent1 ) then
			UndoParent( TempEnt )
			timer.Simple( 0.1, function()//delay to stop crash
				Ent1.SetParent( Ent1, Ent2)
			end)
			self:SendMessage( "Oops, Closed Parent Loop Detected; Broken loop and set parent." )
			break
		else
			TempEnt = TempEnt:GetParent()
		end
	end
	Phys1:Wake()
	//Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
end

function TOOL:UndoParent( Ent1 )
	Ent1:SetParent( nil )
	Ent1:SetMoveType(MOVETYPE_VPHYSICS)
	Ent1.PhysgunDisabled = false
	Ent1:SetUnFreezable( false )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( true )
		Phys1:Wake()
		//Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
	end
end

function TOOL:DoApply(CurrentEnt, FirstEnt, autorotate, nocollideall, ShadowDisable )
	local CurrentPhys = CurrentEnt:GetPhysicsObject()
	
	//local col = CurrentEnt:GetCollisionGroup()
	//col = 19
	//CurrentEnt:SetCollisionGroup(col)
	//self:SendMessage("New group: "..col)
	
	//if ( CurrentPhys:IsDragEnabled() ) then
	//end
	//CurrentPhys:SetAngleDragCoefficient(1.05)
	//CurrentPhys:SetDragCoefficient(1.05)
	
	if ( autorotate ) then
		if ( CurrentEnt == FirstEnt ) then//Snap-rotate original object first.  Rest needs to rotate around it.
			local angle = CurrentPhys:RotateAroundAxis( Vector( 0, 0, 1 ), 0 )
			self.anglechange = Vector( angle.p - (math.Round(angle.p/45))*45, angle.r - (math.Round(angle.r/45))*45, angle.y - (math.Round(angle.y/45))*45 )
			if ( table.Count(self.TaggedEnts) == 1 ) then
				angle.p = (math.Round(angle.p/45))*45
				angle.r = (math.Round(angle.r/45))*45//Only rotate on these axies if it's singular.
			end
			angle.y = (math.Round(angle.y/45))*45
			CurrentPhys:SetAngles( angle )
		else
			local distance = math.sqrt(math.pow((CurrentEnt:GetPos().X-FirstEnt:GetPos().X),2)+math.pow((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y),2))
			local theta = math.atan((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y) / (CurrentEnt:GetPos().X-FirstEnt:GetPos().X)) - math.rad(self.anglechange.Z)
			if (CurrentEnt:GetPos().X-FirstEnt:GetPos().X) < 0 then
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X - (distance*(math.cos(theta))), FirstEnt:GetPos().Y - (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			else
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X + (distance*(math.cos(theta))), FirstEnt:GetPos().Y + (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			end
			CurrentPhys:SetAngles( CurrentPhys:RotateAroundAxis( Vector( 0, 0, -1 ), self.anglechange.Z ) )
		end
	end

	CurrentPhys:EnableCollisions( !nocollideall )
	CurrentEnt:DrawShadow( !ShadowDisable )
	if physdis then
		CurrentEnt:SetMoveType(MOVETYPE_NONE)
		CurrentEnt.PhysgunDisabled = disablephysgun
		CurrentEnt:SetUnFreezable( disablephysgun )
	else
		CurrentEnt:SetMoveType(MOVETYPE_VPHYSICS)
		CurrentEnt.PhysgunDisabled = false
		CurrentEnt:SetUnFreezable( false )
	end
	CurrentPhys:Wake()
end

function TOOL:CreateUndo(constraint,undoname)
	if (constraint) then
		undo.Create(undoname)
		undo.AddEntity( constraint )
		undo.SetPlayer( self:GetOwner() )
		undo.Finish()
		self:GetOwner():AddCleanup( "constraints", constraint )
	end
end

function TOOL:UndoRepairToggle()
	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then//parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then //not a ragdoll
						if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
						elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
						end
						if ( speeddamp == 0 && angledamp == 0 ) then
							CurrentPhys:SetDamping( 5, 5 )
						elseif ( speeddamp == 5 && angledamp == 5 ) then
							CurrentPhys:SetDamping( 0, 0 )
						end
						CurrentPhys:Wake()
					end
				end
			end
		end
	end
	self.RepairTodo = false
end

function TOOL:DoConstraint(mode)
	self:SetStage(0)
	// Get information we're about to use
	local Ent1,  Ent2  = self:GetEnt(1),    self:GetEnt(2)

	if ( !Ent1:IsValid() || CLIENT ) then
		self:ClearObjects()
		return false//Something happened to original target, don't continue
	end
	// Get client's CVars
	local forcelimit 	= self:GetClientNumber( "forcelimit", 0 )
	local freeze		= util.tobool( self:GetClientNumber( "freeze", 1 ) )
	local nocollide		= self:GetClientNumber( "nocollide", 0 )
	local nocollideall	= util.tobool( self:GetClientNumber( "nocollideall", 0 ) )
	local torquelimit	= self:GetClientNumber( "torquelimit", 0 )
	local width			= self:GetClientNumber( "width", 1 )
	local friction		= self:GetClientNumber( "friction", 0 )
	local physdis		= util.tobool( self:GetClientNumber( "physdisable", 0 ) )
	local ShadowDisable = util.tobool( self:GetClientNumber( "ShadowDisable", 0 ) )
	local autorotate 	= util.tobool(self:GetClientNumber( "autorotate",1 ))
	local removal_nocollide 	= util.tobool(self:GetClientNumber( "removal_nocollide",1 ))
	local removal_weld 	= util.tobool(self:GetClientNumber( "removal_weld",1 ))
	local removal_axis 	= util.tobool(self:GetClientNumber( "removal_axis",1 ))
	local removal_ballsocket 	= util.tobool(self:GetClientNumber( "removal_ballsocket",1 ))
	local removal_advballsocket 	= util.tobool(self:GetClientNumber( "removal_advballsocket",1 ))
	local removal_slider 	= util.tobool(self:GetClientNumber( "removal_slider",1 ))
	local removal_parent 	= util.tobool(self:GetClientNumber( "removal_parent",1 ))
	local removal_other 	= util.tobool(self:GetClientNumber( "removal_other",1 ))
	local Bone1 = self:GetBone(1)
	local LPos1 = self:GetLocalPos(1)
	local Bone2 = nil
	local LPos2 = nil
	if ( Ent2 && (Ent2:IsValid() || Ent2:IsWorld()) ) then
		Bone2 = self:GetBone(2)
		LPos2 = self:GetLocalPos(2)
	end
	local Phys1 = self:GetPhys(1)
	
	local NumApp = 0
	

	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then//parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then //not a ragdoll
						if (  util.tobool( nocollide ) && (mode == 1 || mode == 3)) then // not weld/axis/ballsocket or single application
							local constraint = constraint.NoCollide(CurrentEnt, Ent2, 0, Bone2)
						end
						if ( mode == 1 ) then //Apply
							self:DoApply( CurrentEnt, Ent1, autorotate, nocollideall, ShadowDisable )
						elseif ( mode == 2 ) then //Rotate
							//self:SendMessage("Sorry, No entire contraption rotating... yet")
							//return false//TODO: Entire contrpation rotaton
						elseif ( mode == 3 ) then //move
							//self:SendMessage("Sorry, No entire contraption moving... yet")
							//return false//todo: entire contraption move/snap
						elseif ( mode == 4 ) then //weld
							local constr = constraint.Weld( CurrentEnt, Ent2, 0, Bone2, forcelimit,  util.tobool( nocollide ) )
							self:CreateUndo(constr,"Precision_Weld")
						elseif ( mode == 5 ) then //doaxis
							local constr = constraint.Axis( CurrentEnt, Ent2, Bone1, Bone2, LPos1, LPos2, forcelimit, torquelimit, friction, nocollide )
							self:CreateUndo(constr,"Precision_Axis")
						elseif ( mode == 6 ) then //ballsocket
							local constr = constraint.Ballsocket( CurrentEnt, Ent2, 0, Bone2, LPos2, forcelimit, torquelimit, nocollide )
							self:CreateUndo(constr,"Precision_Ballsocket")
						elseif ( mode == 7 ) then //adv ballsocket
							local constr = constraint.AdvBallsocket( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, forcelimit, torquelimit, self:GetClientNumber( "XRotMin", -180 ), self:GetClientNumber( "YRotMin", -180 ), self:GetClientNumber( "ZRotMin", -180 ), self:GetClientNumber( "XRotMax", 180 ), self:GetClientNumber( "YRotMax", 180 ), self:GetClientNumber( "ZRotMax", 180 ), self:GetClientNumber( "XRotFric", 0 ), self:GetClientNumber( "YRotFric", 0 ), self:GetClientNumber( "ZRotFric", 0 ), self:GetClientNumber( "FreeMov", 0 ), nocollide )
							self:CreateUndo(constr,"Precision_Advanced_Ballsocket")
						elseif ( mode == 8 ) then //slider
							local constraint0 = constraint.Slider( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, width )
							if (constraint0) then
								undo.Create("Precision_Slider")
								if ( self:GetClientNumber( "disablesliderfix" ) == 0 ) then
									local constraint2 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, 0, -180, -180, 0, 180, 180, 50, 0, 0, 1, 0 )
									if (constraint2) then
										undo.AddEntity( constraint2 )
									end
									local constraint3 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, 0, -180, 180, 0, 180, 0, 50, 0, 1, 0 )
									if (constraint3) then
										undo.AddEntity( constraint3 )
									end
									local constraint4 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, -180, 0, 180, 180, 0, 0, 0, 50, 1, 0 )
									if (constraint4) then
										undo.AddEntity( constraint4 )
									end
								end
								undo.AddEntity( constraint0 )
								undo.SetPlayer( self:GetOwner() )
								undo.Finish()
								self:GetOwner():AddCleanup( "constraints", constraint0 )
							end
						elseif ( mode == 9 ) then //Parent
							self:DoParent( CurrentEnt, Ent2 )
						elseif ( mode == 10 && !self.RepairTodo ) then//Repair spaz
							if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
								CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
							elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
								CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
							end
								//CurrentPhys:EnableGravity( !CurrentPhys:IsGravityEnabled() )//Can't disable gravity - sliders would go nuts and disappear.	
							local speeddamp,angledamp = CurrentPhys:GetDamping()
							if ( speeddamp == 0 && angledamp == 0 ) then
								CurrentPhys:SetDamping( 5, 5 )
							elseif ( speeddamp == 5 && angledamp == 5 ) then
								CurrentPhys:SetDamping( 0, 0 )
							end
							CurrentEnt:SetPos(CurrentEnt:GetPos())
							CurrentPhys:Wake()
						elseif ( mode == 11 ) then //Removal
							if ( CLIENT ) then return true end//? should probably be in more places
							if ( removal_nocollide ) then
								constraint.RemoveConstraints( CurrentEnt, "NoCollide" )
								CurrentPhys:EnableCollisions(true)
							end
							if ( removal_weld ) then
								constraint.RemoveConstraints( CurrentEnt, "Weld" )
							end
							if ( removal_axis ) then
								constraint.RemoveConstraints( CurrentEnt, "Axis" )
							end
							if ( removal_ballsocket ) then
								constraint.RemoveConstraints( CurrentEnt, "Ballsocket" )
							end
							if ( removal_advballsocket ) then
								constraint.RemoveConstraints( CurrentEnt, "AdvBallsocket" )
							end
							if ( removal_slider ) then
								constraint.RemoveConstraints( CurrentEnt, "Slider" )
							end
							if ( removal_parent) then
								if ( CurrentEnt:GetParent():IsValid() ) then
									self:UndoParent( CurrentEnt )
								end
							end
							if ( removal_other ) then
								constraint.RemoveConstraints( CurrentEnt, "Elastic" )
								constraint.RemoveConstraints( CurrentEnt, "Hydraulic" )
								constraint.RemoveConstraints( CurrentEnt, "Keepupright" )
								constraint.RemoveConstraints( CurrentEnt, "Motor" )
								constraint.RemoveConstraints( CurrentEnt, "Muscle" )
								constraint.RemoveConstraints( CurrentEnt, "Pulley" )
								constraint.RemoveConstraints( CurrentEnt, "Rope" )
								constraint.RemoveConstraints( CurrentEnt, "Winch" )
							end
						end
						if ( mode <= 8 ) then
							CurrentPhys:EnableMotion( !freeze )
							CurrentPhys:Wake()
						end
					end
				end
			end
		end
		NumApp = NumApp + 1
	end//Next
	if ( mode == 1 ) then
		self:SendMessage( NumApp .. " items targeted for apply." )
	elseif ( mode == 2 ) then
		self:SendMessage( NumApp .. " items targeted for rotate." )
	elseif ( mode == 3 ) then
		self:SendMessage( NumApp .. " items targeted for move." )
	elseif ( mode == 4 ) then
		self:SendMessage( NumApp .. " items targeted for weld." )
	elseif ( mode == 5 ) then
		self:SendMessage( NumApp .. " items targeted for axis." )
	elseif ( mode == 6 ) then
		self:SendMessage( NumApp .. " items targeted for ballsocket." )
	elseif ( mode == 7 ) then
		self:SendMessage( NumApp .. " items targeted for adv. ballsocket." )
	elseif ( mode == 8 ) then
		self:SendMessage( NumApp .. " items targeted for slider." )
	elseif ( mode == 9 ) then
		self:SendMessage( NumApp .. " items targeted for parenting." )
	elseif ( mode == 10 ) then
		self:SendMessage( NumApp .. " items targeted for repair." )
	elseif ( mode == 11 ) then
		self:SendMessage( NumApp .. " items targeted for constraint removal." )
	end
	
	
	if ( mode == 10 ) then
		self.RepairTodo = true
		timer.Simple( 1.0, function()
		self:ClearSelection()
		end)
	else
		self:ClearSelection()
	end
	// Clear the objects so we're ready to go again
	self:ClearObjects()
end

function TOOL:SendMessage( message )
	if ( self:GetClientNumber( "enablefeedback" ) == 0 ) then return end
	if ( self:GetClientNumber( "chatfeedback" ) == 1 ) then
		self:GetOwner():PrintMessage( HUD_PRINTTALK, "Tool: " .. message )
	else
		self:GetOwner():PrintMessage( HUD_PRINTCENTER, message )
	end
end

function TOOL:TargetValidity ( trace, Phys ) //TODO: Parented stuff should return 1
	if ( SERVER && (!util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) || !Phys:IsValid()) ) then
		local mode = self:GetClientNumber( "mode" )
		if ( trace.Entity:GetParent():IsValid() ) then
			return 2//Valid parent, but itself isn't
		else
			return 0//No valid phys
		end
	elseif ( trace.Entity:IsPlayer() ) then
		return 0// Don't attach players, or to players
	elseif ( trace.HitWorld ) then
		return 1// Only allow second click to be here...
	else
		return 3//Everything seems good
	end
end

function TOOL:StartRotate()
	local Ent = self:GetEnt(1)
	local Phys = self:GetPhys(1)
	local oldposu = Ent:GetPos()
	local oldangles = Ent:GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	
	if ( self:GetClientNumber( "rotateundo" )) then
		if SERVER then
			undo.Create("Precision_Rotate")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( MoveUndo, Ent, oldposu, oldangles )
			undo.Finish()
		end
	end
	
	if IsValid( Phys ) then
		Phys:EnableMotion( false ) //else it drifts
	end
	
	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	self.axis = self:GetNormal(1)
	self.axisY = self.axis:Cross(Ent:GetUp())
	if self:WithinABit( self.axisY, Vector(0,0,0) ) then
		self.axisY = self.axis:Cross(Ent:GetForward())
	end
	self.axisZ = self.axisY:Cross(self.axis)
	self.realdegrees = 0
	self.lastdegrees = -((rotation/2) % rotation)
	self.realdegreesY = 0
	self.lastdegreesY = -((rotation/2) % rotation)
	self.realdegreesZ = 0
	self.lastdegreesZ = -((rotation/2) % rotation)
	self.OldPos = self:GetPos(1)//trace.HitPos
end

function TOOL:DoMove()
	// Get information we're about to use
	local Norm1, Norm2 = self:GetNormal(1),   self:GetNormal(2)
	local Phys1, Phys2 = self:GetPhys(1),     self:GetPhys(2)
	
	local Ang1, Ang2 = Norm1:Angle(), (Norm2 * -1):Angle()
	if self:GetClientNumber( "autorotate" ) == 1 then
		Ang2.p = (math.Round(Ang2.p/45))*45
		Ang2.r = (math.Round(Ang2.r/45))*45
		Ang2.y = (math.Round(Ang2.y/45))*45
		Norm2 = Ang2:Forward() * -1
	end


	local oldposu = self:GetEnt(1):GetPos()
	local oldangles = self:GetEnt(1):GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	if self:GetClientNumber( "moveundo" ) == 1 then
	undo.Create("Precision Move")
		undo.SetPlayer(self:GetOwner())
		undo.AddFunction( MoveUndo, self:GetEnt(1), oldposu, oldangles )
	undo.Finish()
	end

	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	if ( (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2) then//Set axies for rotation mode directions
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
		self.realdegrees = 0
		self.lastdegrees = -((rotation/2) % rotation)
		self.realdegreesY = 0
		self.lastdegreesY = -((rotation/2) % rotation)
		self.realdegreesZ = 0
		self.lastdegreesZ = -((rotation/2) % rotation)
	else
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
	end



	local TargetAngle = Phys1:AlignAngles( Ang1, Ang2 )//Get angle Phys1 would be at if difference between Ang1 and Ang2 was added


	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end

	Phys1:SetAngles( TargetAngle )


	local NewOffset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )
	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	if ( offsetpercent ) then
		local  Ent2  = self:GetEnt(2)
		local glower = Ent2:OBBMins()
		local gupper = Ent2:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(Norm2,Ent2:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(Norm2,Ent2:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end
	Norm2 = Norm2 * (-0.0625 + NewOffset)
	local TargetPos = self:GetPos(2) + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
	//self:SetPos(2)

	// Set the position

	Phys1:SetPos( TargetPos )
	Phys1:EnableMotion( false )

	// Wake up the physics object so that the entity updates
	Phys1:Wake()
end

function TOOL:ToggleColor( CurrentEnt )
	color = CurrentEnt:GetColor()
	color["a"] = color["a"] - 128
	if ( color["a"] < 0 ) then
		color["a"] = color["a"] + 256
	end
	color["r"] = color["r"] - 128
	if ( color["r"] < 0 ) then
		color["r"] = color["r"] + 256
	end
	color["g"] = color["g"] - 128
	if ( color["g"] < 0 ) then
		color["g"] = color["g"] + 256
	end
	color["b"] = color["b"] - 128
	if ( color["b"] < 0 ) then
		color["b"] = color["b"] + 256
	end
	CurrentEnt:SetColor( color )
	if ( color["a"] == 255 ) then
		CurrentEnt:SetRenderMode( 0 )
	else
		CurrentEnt:SetRenderMode( 1 )
	end
end

function TOOL:ClearSelection()
	if ( self.RepairTodo ) then
		self:UndoRepairToggle()
	end
	if ( self.TaggedEnts ) then
		local color
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
		end
	end
	self.TaggedEnts = {}
end

function TOOL:SelectEnts(StartEnt, AllConnected)
	self:ClearSelection()
	if ( CLIENT ) then return end
	local color
	if ( AllConnected == 1 ) then
		local NumApp = 0
		EntsTab = {}
		ConstsTab = {}
		GetAllEnts(StartEnt, self.TaggedEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
			NumApp = NumApp + 1
		end
		self:SendMessage( NumApp .. " objects selected." )
	else
		if ( StartEnt and StartEnt:IsValid() ) then
			local CurrentPhys = StartEnt:GetPhysicsObject()
			if ( CurrentPhys:IsValid() ) then
				table.insert(self.TaggedEnts, StartEnt)
				self:ToggleColor(StartEnt)
			end
		end
	end
	
end

function TOOL:LeftClick( trace )
	local stage = self:GetStage()//0 = started, 1 = moving/second target, 2 = rotation?
	local mode = self:GetClientNumber( "mode" )
	local moving = ( mode == 3 || (self:GetClientNumber( "move" ) == 1 && mode >= 3 && mode <= 8 ) )
	local rotating = ( self:GetClientNumber( "rotate" ) == 1 )
	local Phys = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )

	
	if ( stage == 0 ) then//first click - choose a target.
		if ( self:TargetValidity(trace, Phys) <= 1 ) then
			return false//No phys or hit world
		end
		self:SetObject( 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
		
		if (self:GetClientNumber( "entirecontrap" ) == 1 || mode == 10 ) then
			self:SelectEnts(trace.Entity,1)
		else
			self:SelectEnts(trace.Entity,0)
		end
		if ( mode == 1 || mode == 10 || mode == 11 ) then //Don't care about stage, always apply.
			self:DoConstraint(mode)
		else
			if ( mode == 9 ) then
				self:SetStage(1)
			else
				if ( moving ) then//Moving
					self:StartGhostEntity( trace.Entity )
					self:SetStage(1)
				elseif ( mode == 2 ) then//Straight to rotate
					self:StartRotate()
					self:SetStage(2)
				else
					self:SetStage(1)
				end
			end
		end
	elseif ( stage == 1 ) then//Second click
		self:SetObject( 2, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
		
		if ( self:GetEnt(1) == self:GetEnt(2) ) then
			SavedPos = self:GetPos(2)
		end
		if ( mode == 9 ) then
			self:DoConstraint(mode)
		else
			if ( moving ) then
				if ( CLIENT ) then
					self:ReleaseGhostEntity()
					return true
				end
				if ( SERVER && !game.SinglePlayer() ) then
					self:ReleaseGhostEntity()
					//return true
				end
				self:DoMove()
			end
			if ( rotating ) then
				self:StartRotate()
				self:SetStage(2)
			else
				self:DoConstraint(mode)
			end
		end
	elseif ( stage == 2 ) then//Done rotate
		self:DoConstraint(mode)
	end
	return true
end

function TOOL:WithinABit( v1, v2 )
	local tol = 0.1
	local da = v1.x-v2.x
	local db = v1.y-v2.y
	local dc = v1.z-v2.z
	if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
		return true
	else
		da = v1.x+v2.x
		db = v1.y+v2.y
		dc = v1.z+v2.z
		if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
			return true
		else
			return false
		end
	end
end

if ( SERVER ) then
	
	function GetAllEnts( Ent, OrderedEntList, EntsTab, ConstsTab )
		if ( Ent and Ent:IsValid() ) and ( !EntsTab[ Ent:EntIndex() ] ) then
			EntsTab[ Ent:EntIndex() ] = Ent
			table.insert(OrderedEntList, Ent)
			if ( !constraint.HasConstraints( Ent ) ) then return OrderedEntList end
			for key, ConstraintEntity in pairs( Ent.Constraints ) do
				if ( !ConstsTab[ ConstraintEntity ] ) then
					ConstsTab[ ConstraintEntity ] = true
					local ConstTable = ConstraintEntity:GetTable()
					for i=1, 6 do
						local e = ConstTable[ "Ent"..i ]
						if ( e and e:IsValid() ) and ( !EntsTab[ e:EntIndex() ] ) then
							GetAllEnts( e, OrderedEntList, EntsTab, ConstsTab )
						end
					end
				end
			end
		end
		return OrderedEntList
	end
	
	function GetAllConstraints( EntsTab )
		local ConstsTab = {}
		for key, Ent in pairs( EntsTab ) do
			if ( Ent and Ent:IsValid() ) then
				local MyTable = constraint.GetTable( Ent )
				for key, Constraint in pairs( MyTable ) do
					if ( !ConstsTab[ Constraint.Constraint ] ) then
						ConstsTab[ Constraint.Constraint ] = Constraint
					end
				end
			end
		end
		return ConstsTab
	end
end

function TOOL:UpdateCustomGhost( ghost, player, offset )
	
	// Ghost is identically buggy to that of easyweld...  welding two frozen props and two unfrozen props yields different ghosts even if identical allignment

	if (ghost == nil) then return end
	if (!ghost:IsValid()) then ghost = nil return end

	local tr = util.GetPlayerTrace( player, player:GetAimVector() )
	local trace = util.TraceLine( tr )
	if (!trace.Hit) then return end

	local Ang1, Ang2 = self:GetNormal(1):Angle(), (trace.HitNormal * -1):Angle()
	local TargetAngle = self:GetEnt(1):AlignAngles( Ang1, Ang2 )

	self.GhostEntity:SetPos( self:GetEnt(1):GetPos() )
	
	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end
	self.GhostEntity:SetAngles( TargetAngle )

	local TraceNormal = trace.HitNormal

	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(TraceNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x) -0.5
		elseif self:WithinABit(TraceNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y) -0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end

	local TranslatedPos = ghost:LocalToWorld( self:GetLocalPos(1) )
	local TargetPos = trace.HitPos + (self:GetEnt(1):GetPos() - TranslatedPos) + (TraceNormal*NewOffset)

	self.GhostEntity:SetPos( TargetPos )
end


function TOOL:Think()
	//if CLIENT then return end
	local pl = self:GetOwner()
	local wep = pl:GetActiveWeapon()
	if not wep:IsValid() or wep:GetClass() != "gmod_tool" or pl:GetInfo("gmod_toolmode") != "precision" then return end
		
	if (self:NumObjects() < 1) then return end
	local Ent1 = self:GetEnt(1)
	if ( SERVER ) then
		if ( !Ent1:IsValid() ) then
			self:ClearObjects()
			return
		end
	end
	local mode = self:GetClientNumber( "mode" )

	if self:NumObjects() == 1 && mode != 2 then
		if ( (self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
			if ( mode <= 8 ) then//no move = no ghost in parent mode
				local offset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )
				self:UpdateCustomGhost( self.GhostEntity, self:GetOwner(), offset )
			end
		end
	else
		local rotate = (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2
		if ( SERVER && rotate && mode <= 8 ) then
			local offset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )

			local Phys1 = self:GetPhys(1)

			local cmd = self:GetOwner():GetCurrentCommand()

			local rotation		= self:GetClientNumber( "rotation" )
			if ( rotation < 0.02 ) then rotation = 0.02 end
			local degrees = cmd:GetMouseX() * 0.02

			local newdegrees = 0
			local changedegrees = 0

			local angle = 0
			if( self:GetOwner():KeyDown( IN_RELOAD ) ) then
				self.realdegreesY = self.realdegreesY + degrees
				newdegrees =  self.realdegreesY - ((self.realdegreesY + (rotation/2)) % rotation)
				changedegrees = self.lastdegreesY - newdegrees
				self.lastdegreesY = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisY , changedegrees )
			elseif( self:GetOwner():KeyDown( IN_ATTACK2 ) ) then
				self.realdegreesZ = self.realdegreesZ + degrees
				newdegrees =  self.realdegreesZ - ((self.realdegreesZ + (rotation/2)) % rotation)
				changedegrees = self.lastdegreesZ - newdegrees
				self.lastdegreesZ = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisZ , changedegrees )
			else
				self.realdegrees = self.realdegrees + degrees
				newdegrees =  self.realdegrees - ((self.realdegrees + (rotation/2)) % rotation)
				changedegrees = self.lastdegrees - newdegrees
				self.lastdegrees = newdegrees
				angle = Phys1:RotateAroundAxis( self.axis , changedegrees )
			end
			Phys1:SetAngles( angle )

			if ( ( self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
				local WPos2 = self:GetPos(2)
				local Ent2 = self:GetEnt(2)
				// Move so spots join up
				local Norm2 = self:GetNormal(2)

				local NewOffset = offset
				local offsetpercent	= self:GetClientNumber( "offsetpercent" ) == 1
				if ( offsetpercent ) then
					local glower = Ent2:OBBMins()
					local gupper = Ent2:OBBMaxs()
					local height = math.abs(gupper.z - glower.z) -0.5
					if self:WithinABit(Norm2,Ent2:GetForward()) then
						height = math.abs(gupper.x - glower.x) -0.5
					elseif self:WithinABit(Norm2,Ent2:GetRight()) then
						height = math.abs(gupper.y - glower.y) -0.5
					end
					NewOffset = NewOffset / 100
					NewOffset = NewOffset * height
				end

				Norm2 = Norm2 * (-0.0625 + NewOffset)
				local TargetPos = Vector(0,0,0)
				if ( self:GetEnt(1) == self:GetEnt(2) ) then
	//////////////////////////////////////////
					TargetPos = SavedPos + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				else
					TargetPos = WPos2 + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				end
				Phys1:SetPos( TargetPos )
			else
				// Move so rotating on axis

				local TargetPos = (Phys1:GetPos() - self:GetPos(1)) + self.OldPos
				Phys1:SetPos( TargetPos )
			end
			Phys1:Wake()
		end
	end
end

function TOOL:Nudge( trace, direction )
	if (!trace.Entity:IsValid() || trace.Entity:IsPlayer() ) then return false end
	local Phys1 = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )
	local offsetpercent		= self:GetClientNumber( "nudgepercent" ) == 1
	local offset		= self:GetClientNumber( "nudge", 100 )
	local max = 8192
	if ( offsetpercent != 1 ) then
		if ( offset > max ) then
			offset = max
		elseif ( offset < -max ) then
			offset = -max
		end
	end
	//if ( offset == 0 ) then offset = 1 end
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(trace.HitNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(trace.HitNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		local cap = math.floor(max / height)//No more than max units.
		if ( NewOffset > cap ) then
			NewOffset = cap
		elseif ( NewOffset < -cap ) then
			NewOffset = -cap
		end
		NewOffset = NewOffset * height
	end

	if ( self:GetClientNumber( "entirecontrap" ) == 1 ) then
		local NumApp = 0
		local TargetEnts = {}
		local EntsTab = {}
		local ConstsTab = {}
		GetAllEnts(trace.Entity, TargetEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(TargetEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then

					/*if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
						local oldpos = CurrentPhys:GetPos()
						local function NudgeUndo( Undo, Entity, oldpos )
							if CurrentEnt:IsValid() then
								CurrentEnt:SetPos( oldpos )
							end
						end
						undo.Create("Nrecision Nudge")
							undo.SetPlayer(self:GetOwner())
							undo.AddFunction( NudgeUndo, CurrentEnt, oldpos )
						undo.Finish()
					end*/// todo: all in 1 undo for mass nudging

					local TargetPos = CurrentPhys:GetPos() + trace.HitNormal * NewOffset * direction
					CurrentPhys:SetPos( TargetPos )
					CurrentPhys:Wake()
					if (CurrentEnt:GetMoveType() == 0 ) then //phys disabled, so move manually
						CurrentEnt:SetPos( TargetPos )
					end

				end
			end
			NumApp = NumApp + 1
		end
		if ( direction == -1 ) then
			self:SendMessage( NumApp .. " items pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( NumApp .. " items pulled." )
		else
			self:SendMessage( NumApp .. " items nudged." )
		end
	else
		if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
			local oldpos = Phys1:GetPos()
			local function NudgeUndo( Undo, Entity, oldpos )
				if trace.Entity:IsValid() then
					trace.Entity:SetPos( oldpos )
				end
			end
			undo.Create("Precision PushPull")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( NudgeUndo, trace.Entity, oldpos )
			undo.Finish()
		end
		local TargetPos = Phys1:GetPos() + trace.HitNormal * NewOffset * direction
		Phys1:SetPos( TargetPos )
		Phys1:Wake()
		if ( trace.Entity:GetMoveType() == 0 ) then
			trace.Entity:SetPos( TargetPos )
		end
		if ( direction == -1 ) then
			self:SendMessage( "target pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( "target pulled." )
		else
			self:SendMessage( "target nudged." )
		end
	end
	return true
end

function TOOL:RightClick( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, -1 )
	end
end

function TOOL:Reload( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, 1 )
	end
end

if CLIENT then

	language.Add( "Tool.precision.name", "Precision Tool 0.98e" )
	language.Add( "Tool.precision.desc", "Accurately moves/constrains objects" )
	language.Add( "Tool.precision.0", "Primary: Move/Apply | Secondary: Push | Reload: Pull" )
	language.Add( "Tool.precision.1", "Target the second item. If enabled, this will move the first item.  (Swap weps to cancel)" )
	language.Add( "Tool.precision.2", "Rotate enabled: Turn left and right to rotate the object (Hold Reload or Secondary for other rotation directions!)" )


	language.Add("Undone.precision", "Undone Precision Constraint")
	language.Add("Undone.precision.nudge", "Undone Precision PushPull")
	language.Add("Undone.precision.rotate", "Undone Precision Rotate")
	language.Add("Undone.precision.move", "Undone Precision Move")
	language.Add("Undone.precision.weld", "Undone Precision Weld")
	language.Add("Undone.precision.axis", "Undone Precision Axis")
	language.Add("Undone.precision.ballsocket", "Undone Precision Ballsocket")
	language.Add("Undone.precision.advanced.ballsocket", "Undone Precision Advanced Ballsocket")
	language.Add("Undone.precision.slider", "Undone Precision Slider")

	local showgenmenu = 0//Seems to hide often, probably for the best

	local function AddDefControls( Panel )
		Panel:ClearControls()

		Panel:AddControl("ComboBox",
		{
			Label = "#Presets",
			MenuButton = 1,
			Folder = "precision",
			Options = {},
			CVars =
			{
				[0] = "precision_offset",
				[1] = "precision_forcelimit",
				[2] = "precision_freeze",
				[3] = "precision_nocollide",
				[4] = "precision_nocollideall",
				[5] = "precision_rotation",
				[6] = "precision_rotate",
				[7] = "precision_torquelimit",
				[8] = "precision_friction",
				[9] = "precision_mode",
				[10] = "precision_width",
				[11] = "precision_offsetpercent",
				[12] = "precision_removal",
				[13] = "precision_move",
				[14] = "precision_physdisable",
				[15] = "precision_advballsocket",
				[16] = "precision_XRotMin",
				[17] = "precision_XRotMax",
				[18] = "precision_YRotMin",
				[19] = "precision_YRotMax",
				[20] = "precision_ZRotMin",
				[21] = "precision_ZRotMax",
				[22] = "precision_XRotFric",
				[23] = "precision_YRotFric",
				[24] = "precision_ZRotFric",
				[25] = "precision_FreeMov",
				[26] = "precision_ShadowDisable",
				[27] = "precision_allowphysgun",
				[28] = "precision_autorotate",
				[29] = "precision_massmode",
				[30] = "precision_nudge",
				[31] = "precision_nudgepercent",
				[32] = "precision_disablesliderfix"
			}
		})

		//Panel:AddControl( "Label", { Text = "Secondary attack pushes, Reload pulls by this amount:", Description	= "Phx 1x is 47.45, Small tiled cube is 11.8625 and thin is 3 exact units" }  )
		Panel:AddControl( "Slider",  { Label	= "Push/Pull Amount",
					Type	= "Float",
					Min		= 1,
					Max		= 100,
					Command = "precision_nudge",
					Description = "Distance to push/pull props with altfire/reload"}	 ):SetDecimals( 4 )


		Panel:AddControl( "Checkbox", { Label = "Push/Pull as Percent (%) of target's depth", Command = "precision_nudgepercent", Description = "Unchecked = Exact units, Checked = takes % of width from target prop when pushing/pulling" } )


		local user = LocalPlayer():GetInfoNum( "precision_user", 0 )
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 0 )
		//Panel:AddControl( "Label", { Text = "Primary attack uses the tool's main mode.", Description	= "Select a mode and configure the options, be sure to try new things out!" }  )

		local list = vgui.Create("DListView")

		//17 per item + 16 for title
		local height = 203 //All 11 shown
		if ( user < 2 ) then
			height = 135 //7 shown
		elseif ( user < 3 ) then
			height = 170 //9 shown
		end
		

		list:SetSize(30,height)
		//list:SizeToContents()
		list:AddColumn("Tool Mode")
		list:SetMultiSelect(false)
		function list:OnRowSelected(LineID, line)
			if not (mode == LineID) then
				RunConsoleCommand("precision_setmode", LineID)
			end
		end

		if ( mode == 1 ) then
			list:AddLine(" 1 ->Apply<- (Directly apply settings to target)")
		else
			list:AddLine(" 1   Apply   (Directly apply settings to target)")
		end
		if ( mode == 2 ) then
			list:AddLine(" 2 ->Rotate<- (Turn an object without moving it)")
		else
			list:AddLine(" 2   Rotate   (Turn an object without moving it)")
		end
		if ( mode == 3 ) then
			list:AddLine(" 3 ->Move<- (Snap objects together - Great for building!)")
		else
			list:AddLine(" 3   Move   (Snap objects together - Great for building!)")
		end
		if ( mode == 4 ) then
			list:AddLine(" 4 ->Weld<-")
		else
			list:AddLine(" 4   Weld")
		end
		if ( mode == 5 ) then
			list:AddLine(" 5 ->Axis<-")
		else
			list:AddLine(" 5   Axis")
		end
		if ( mode == 6 ) then
			list:AddLine(" 6 ->Ballsocket<-")
		else
			list:AddLine(" 6   Ballsocket")
		end
		if ( user >= 2 ) then
			if ( mode == 7 ) then
				list:AddLine(" 7 ->Adv Ballsocket<-")
			else
				list:AddLine(" 7   Adv Ballsocket")
			end
			if ( mode == 8 ) then
				list:AddLine(" 8 ->Slider<-")
			else
				list:AddLine(" 8   Slider")
			end
		end
		if ( user >= 3 ) then
			if ( mode == 9 ) then
				list:AddLine(" 9 ->Parent<- (Like a solid weld, but without object collision)")
			else
				list:AddLine(" 9   Parent   (Like a solid weld, but without object collision)")
			end
			if ( mode == 10 ) then
				list:AddLine("10 ->Repair<- (Attempts to fix a flailing contraption)")
			else
				list:AddLine("10   Repair   (Attempts to fix a flailing contraption)")
			end
		end
		if ( mode == 11 ) then
			list:AddLine("11 ->Removal<- (Undoes constraints from target)")
		else
			list:AddLine("11   Removal   (Undoes constraints from target)")
		end
		list:SortByColumn(1)
		Panel:AddItem(list)

		if ( mode >= 4 && mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Move Target? ('Easy' constraint mode)", Command = "precision_move", Description = "Uncheck this to apply the constraint without altering positions." } )
		end
		if (  mode >= 3 && mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Rotate Target? (Rotation after moving)", Command = "precision_rotate", Description = "Uncheck this to remove the extra click for rotation. Handy for speed building." } )
			//Panel:AddControl( "Label", { Text = "This is the distance from touching of the targeted props after moving:", Description	= "Use 0 mostly, % takes the second prop's width." }  )
			Panel:AddControl( "Slider",  { Label	= "Snap Distance",
					Type	= "Float",
					Min		= 0,
					Max		= 10,
					Command = "precision_offset",
					Description = "Distance offset between joined props.  Type in negative to inset when moving."}	 )
			Panel:AddControl( "Checkbox", { Label = "Snap distance as Percent (%) of target's depth", Command = "precision_offsetpercent", Description = "Unchecked = Exact units, Checked = takes % of width from second prop" } )
		end
		if ( mode >= 2 && mode <= 8 ) then
			Panel:AddControl( "Slider",  { Label	= "Rotation Snap (Degrees)",
					Type	= "Float",
					Min		= 0.02,
					Max		= 90,
					Command = "precision_rotation",
					Description = "Rotation rotates by this amount at a time. No more guesswork. Min: 0.02 degrees "}	 ):SetDecimals( 4 )
		end
		if ( mode <= 8 ) then
			Panel:AddControl( "Checkbox", { Label = "Freeze Target", Command = "precision_freeze", Description = "Freeze props when this tool is used" } )

			if ( mode >= 3 && mode <= 8 ) then
				Panel:AddControl( "Checkbox", { Label = "No Collide Targets", Command = "precision_nocollide", Description = "Nocollide pairs of props when this tool is used. Note: No current way to remove this constraint when used alone."  } )
			end
		end

		if ( user >= 2 || mode == 1 ) then
			if ( (mode >= 3 && mode <= 8) || mode == 1 ) then
				Panel:AddControl( "Checkbox", { Label = "Auto-align to world (nearest 45 degrees)", Command = "precision_autorotate", Description = "Rotates to the nearest world axis (similar to holding sprint and use with physgun)"  } )
			end

			if ( mode == 1 ) then
				Panel:AddControl( "Checkbox", { Label = "Disable target shadow", Command = "precision_ShadowDisable", Description = "Disables shadows cast from the prop"  } )
			end
		end

		if ( user >= 3 ) then
			if ( mode == 1 ) then //apply
				Panel:AddControl( "Checkbox", { Label = "Only Collide with Player", Command = "precision_nocollideall", Description = "Nocollides the first prop to everything and the world (except players collide with it). Warning: don't let it fall away through the world."  } )
				Panel:AddControl( "Checkbox", { Label = "Disable Physics on object", Command = "precision_physdisable", Description = "Disables physics on the first prop (gravity, being shot etc won't effect it)"  } )
				Panel:AddControl( "Checkbox", { Label = "Adv: Allow Physgun on PhysDisable objects", Command = "precision_allowphysgun", Description = "Disabled to stop accidents, use if you want to be able to manually move props after phyics disabling them (may break clipboxes)."  } )
				
				//Panel:AddControl( "Checkbox", { Label = "Drag", Command = "precision_drag", Description = ""  } )
			end
			if ( mode == 9 ) then //parent
				Panel:AddControl( "Checkbox", { Label = "Adv: Allow Physgun on Parented objects", Command = "precision_allowphysgun", Description = "Disabled to stop accidents, use this if you want to play with the parenting hierarchy etc."  } )
			end
		end
		if ( user >= 2 ) then
			if ( mode != 2 && mode != 3 && mode != 10 ) then //todo: entire contrap move/rotate support
				Panel:AddControl( "Checkbox", { Label = "Entire Contraption! (Everything connected to target)", Command = "precision_entirecontrap", Description = "For mass constraining or removal or nudging or applying of things. Yay generic."  } )
			end
		end

		if ( user >= 2 ) then
			if ( (mode >= 4 && mode <= 7) ) then //breakable constraint
				Panel:AddControl( "Slider",  { Label	= "Force Breakpoint",
						Type	= "Float",
						Min		= 0.0,
						Max		= 5000,
						Command = "precision_forcelimit",
						Description = "Applies to most constraint modes" }	 )
			end


			if ( mode == 5 || mode == 6 || mode == 7 ) then //axis or ballsocket
				Panel:AddControl( "Slider",  { Label	= "Torque Breakpoint",
						Type	= "Float",
						Min		= 0.0,
						Max		= 5000,
						Command = "precision_torquelimit",
						Description = "Breakpoint of turning/rotational force"}	 )
			end
		end

		if ( mode == 5 ) then //axis
			Panel:AddControl( "Slider",  { Label	= "Axis Friction",
					Type	= "Float",
					Min		= 0.0,
					Max		= 100,
					Command = "precision_friction",
					Description = "Turning resistance, this is best at 0 in most cases to conserve energy"}	 )
		end

		if ( mode ==7 ) then //adv ballsocket
			Panel:AddControl( "Slider",  { Label	= "X Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_XRotMin",
					Description = "Rotation minimum of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "X Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_XRotMax",
					Description = "Rotation maximum of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_YRotMin",
					Description = "Rotation minimum of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_YRotMax",
					Description = "Rotation maximum of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Minimum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_ZRotMin",
					Description = "Rotation minimum of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Maximum",
					Type	= "Float",
					Min		= -180,
					Max		= 180,
					Command = "precision_ZRotMax",
					Description = "Rotation maximum of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "X Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_XRotFric",
					Description = "Rotation friction of advanced ballsocket in X axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Y Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_YRotFric",
					Description = "Rotation friction of advanced ballsocket in Y axis"}	 )

			Panel:AddControl( "Slider",  { Label	= "Z Rotation Friction",
					Type	= "Float",
					Min		= 0,
					Max		= 100,
					Command = "precision_ZRotFric",
					Description = "Rotation friction of advanced ballsocket in Z axis"}	 )

			Panel:AddControl( "Checkbox", { Label = "Free Movement", Command = "precision_FreeMov", Description = "Only lock relative rotation, not position?"  } )
		end

		if ( mode == 8 ) then //slider
			Panel:AddControl( "Slider",  { Label	= "Slider Width",
					Type	= "Float",
					Min		= 0.0,
					Max		= 10,
					Command = "precision_width",
					Description = "Width of the slider black line (0 = invisible)"}	 )

			Panel:AddControl( "Checkbox", { Label = "Turn Off Minor Slider Stabilisation", Command = "precision_disablesliderfix", Description = "Fix being separate X/Y/Z advanced ballsocket locks between the props.  This stops most spaz caused by rotation, but not spaz caused by displacement." } )
			Panel:AddControl( "Label", { Text = "Stabilisation is separate X/Y/Z adv. ballsockets; it makes it far less prone to rotation triggered spaz, but the difference is only noticeable sometimes as it's still just as prone to spaz caused by drifting.", Description	= "Due to lack of working descriptions at time of coding" }  )
		end

		if ( mode == 9 ) then //parent
			Panel:AddControl( "Label", { Text = "Parenting Notes:", Description	= "Due to lack of working descriptions at time of coding" }  )
			Panel:AddControl( "Label", { Text = "Parenting objects is most similar to a very strong weld, but it stops most interaction on the first object when you attach it to the second.  Players can walk on it, but it will fall through players.  It will not collide with objects or the world.  It will also not cause any extra physics lag/spaz.  Try it out on a test object, and decide if it's useful to you!", Description	= "Due to lack of working descriptions at time of coding" }  )

			Panel:AddControl( "Label", { Text = "Parented objects are most useful for: Adding detail to moving objects without creating extra physics lag.  Things like houses that you want to move (though you can only safely walk on parented objects when they are still.)", Description	= "Due to lack of working descriptions at time of coding" }  )

			Panel:AddControl( "Label", { Text = "Possible issues:  Remove constraints first to avoid spaz. Duplicating or such may cause the collision model to become separated.  Best to test it if in doubt.", Description	= "Why must labels cause menu flicker? D:" }  )
		end
		
		if ( mode == 10 ) then //repair
			Panel:AddControl( "Label", { Text = "Repair mode", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "Usage: When a contraption is going crazy, colliding, making rubbing noises.", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "What it does: Temporarily toggles collisions, allowing things that are bent out of shape to pop back.", Description	= "" }  )
			Panel:AddControl( "Label", { Text = "Warning: No guarantees.  This may turn things inside-out or make things worse depending on the situation.", Description	= "" }  )
		end
		if ( mode == 11 ) then //removal
			Panel:AddControl( "Label", { Text = "This mode will remove:", Description	= "" }  )
			Panel:AddControl( "Checkbox", { Label = "Nocollide", Command = "precision_removal_nocollide", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Weld", Command = "precision_removal_weld", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Axis", Command = "precision_removal_axis", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Ballsocket", Command = "precision_removal_ballsocket", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Adv. Ballsocket", Command = "precision_removal_advballsocket", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Slider", Command = "precision_removal_slider", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Parent", Command = "precision_removal_parent", Description = "" } )
			Panel:AddControl( "Checkbox", { Label = "Other", Command = "precision_removal_other", Description = "" } )
			Panel:AddControl( "Label", { Text = "(Other = Rope/slider variants like winch/hydraulic, also motor/keepupright)", Description	= "" }  )
			Panel:AddControl( "Button", { Label = "Select All", Command = "precision_removal_all", Description = ""  } )
			Panel:AddControl( "Button", { Label = "Select None", Command = "precision_removal_none", Description = ""  } )

		end
		if ( showgenmenu == 1 ) then
			Panel:AddControl( "Button", { Label = "\\/ General Tool Options \\/", Command = "precision_generalmenu", Description = "Collapse menu"  } )




		local params = {Label = "User Level",Description = "Shows options appropriate to user experience level", MenuButton = "0", Height = 67, Options = {}}
		if ( user == 1 ) then
			params.Options[" 1 ->Normal<-"] = { precision_setuser = "1" }
		else
			params.Options[" 1   Normal"] = { precision_setuser = "1" }
		end
		if ( user == 2 ) then
			params.Options[" 2 ->Advanced<-"] = { precision_setuser = "2" }
		else
			params.Options[" 2   Advanced"] = { precision_setuser = "2" }
		end
		if ( user == 3 ) then
			params.Options[" 3 ->Experimental<-"] = { precision_setuser = "3" }
		else
			params.Options[" 3   Experimental"] = { precision_setuser = "3" }
		end

		Panel:AddControl( "ListBox", params )

			//Panel:AddControl( "Label", { Text = "General Tool Options:", Description	= "Note: These don't save with presets." }  )
			Panel:AddControl( "Checkbox", { Label = "Enable tool feedback messages?", Command = "precision_enablefeedback", Description = "Toggle for feedback messages incase they get annoying"  } )
			Panel:AddControl( "Checkbox", { Label = "On = Feedback in Chat, Off = Centr Scrn", Command = "precision_chatfeedback", Description = "Chat too cluttered? Can have messages centre screen instead"  } )
			//Panel:AddControl( "Checkbox", { Label = "Hide Menu Tips?", Command = "precision_hidehints", Description = "Streamline the menu once you're happy with using the tool."  } )
			Panel:AddControl( "Checkbox", { Label = "Add Push/Pull to Undo List", Command = "precision_nudgeundo", Description = "For if you're in danger of nudging somthing to where you can't reach it"  } )
			Panel:AddControl( "Checkbox", { Label = "Add Movement to Undo List", Command = "precision_moveundo", Description = "So you don't have to secondary fire with nocollide to undo mistakes"  } )
			Panel:AddControl( "Checkbox", { Label = "Add Rotation to Undo List", Command = "precision_rotateundo", Description = "So you can find the exact rotation value easier"  } )
			Panel:AddControl( "Button", { Label = "Restore Current Mode Default", Command = "precision_defaultrestore", Description = "Collapse menu"  } )
		else
			Panel:AddControl( "Button", { Label = "-- General Tool Options --", Command = "precision_generalmenu", Description = "Expand menu"  } )
			if ( user == 1 ) then
				Panel:AddControl( "Label", { Text = "(Note: For more modes and options like slider, use this options button and change the user level)", Description = "" }  )
			end
		end
	end



	local function precision_defaults()
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 3 )
		if mode  == 1 then
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_ShadowDisable", "0")
			RunConsoleCommand("precision_nocollideall", "0")
			RunConsoleCommand("precision_physdisable", "0")
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 2 then
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 3 then
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 4 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
		elseif mode == 5 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_friction", "0")
		elseif mode == 6 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
		elseif mode == 7 then
			RunConsoleCommand("precision_move", "0")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_XRotMin", "0")
			RunConsoleCommand("precision_XRotMax", "0")
			RunConsoleCommand("precision_YRotMin", "0")
			RunConsoleCommand("precision_YRotMax", "0")
			RunConsoleCommand("precision_ZRotMin", "0")
			RunConsoleCommand("precision_ZRotMax", "0")
			RunConsoleCommand("precision_XRotFric", "0")
			RunConsoleCommand("precision_YRotFric", "0")
			RunConsoleCommand("precision_ZRotFric", "0")
			RunConsoleCommand("precision_FreeMov", "1")
		elseif mode == 8 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "0")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_width", "1")
			RunConsoleCommand("precision_disablesliderfix", "0")
		elseif mode == 9 then
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_defaultrestore", precision_defaults )

	local function precision_genmenu()
		if ( showgenmenu == 1 ) then
			showgenmenu = 0
		else
			showgenmenu = 1
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_generalmenu", precision_genmenu )
	

	function precision_setmode( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_mode", 3 ) != args[1] then
			RunConsoleCommand("precision_mode", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setmode", precision_setmode )


	function precision_setuser( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_user", 3 ) != args[1] then
			RunConsoleCommand("precision_user", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setuser", precision_setuser )


	function precision_updatecpanel()
		local Panel = controlpanel.Get( "precision" )
		if (!Panel) then return end
		//custom panel building ( wtf does Panel:AddDefaultControls() get it's defaults from? )
		AddDefControls( Panel )
	end
	concommand.Add( "precision_updatecpanel", precision_updatecpanel )

	function TOOL.BuildCPanel( Panel )
		AddDefControls( Panel )
	end

	local function precision_removalall()
		RunConsoleCommand("precision_removal_nocollide", "1")
		RunConsoleCommand("precision_removal_weld", "1")
		RunConsoleCommand("precision_removal_axis", "1")
		RunConsoleCommand("precision_removal_ballsocket", "1")
		RunConsoleCommand("precision_removal_advballsocket", "1")
		RunConsoleCommand("precision_removal_slider", "1")
		RunConsoleCommand("precision_removal_parent", "1")
		RunConsoleCommand("precision_removal_other", "1")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_all", precision_removalall )
	local function precision_removalnone()
		RunConsoleCommand("precision_removal_nocollide", "0")
		RunConsoleCommand("precision_removal_weld", "0")
		RunConsoleCommand("precision_removal_axis", "0")
		RunConsoleCommand("precision_removal_ballsocket", "0")
		RunConsoleCommand("precision_removal_advballsocket", "0")
		RunConsoleCommand("precision_removal_slider", "0")
		RunConsoleCommand("precision_removal_parent", "0")
		RunConsoleCommand("precision_removal_other", "0")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_none", precision_removalnone )

	function TOOL:FreezeMovement()
		local stage = self:GetStage()
		if ( stage == 2 ) then
			return true
		//elseif ( iNum > 0 && self:GetClientNumber("mode") == 2 ) then
		//	return true
		end
		return false
	end
end

function TOOL:Holster()
	self:ClearObjects()
	self:SetStage(0)
	self:ClearSelection()
end
--lua/improvedstacker/localization.lua:
return gluapack()()
--lua/improvedstacker/improvedstacker.lua:
return gluapack()()
--lua/weapons/gmod_tool/stools/streamradio.lua:
TOOL.Category = "Stream Radio"
TOOL.Name = "#Tool." .. TOOL.Mode .. ".name"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" }
}

if SERVER then
	CreateConVar( "sbox_max" .. TOOL.Mode, 5 )
end

cleanup.Register( TOOL.Mode )

TOOL.ClientConVar["model"] = "models/sligwolf/grocel/radio/radio.mdl"
TOOL.ClientConVar["streamurl"] = ""
TOOL.ClientConVar["play"] = "1"
TOOL.ClientConVar["3dsound"] = "1"
TOOL.ClientConVar["mute"] = "0"
TOOL.ClientConVar["volume"] = "1"
TOOL.ClientConVar["radius"] = "1200"
TOOL.ClientConVar["playbackloopmode"] = "0"

TOOL.ClientConVar["nodisplay"] = "0"
TOOL.ClientConVar["noinput"] = "0"
TOOL.ClientConVar["nospectrum"] = "0"
TOOL.ClientConVar["noadvwire"] = "1"

TOOL.ClientConVar["freeze"] = "1"
TOOL.ClientConVar["weld"] = "1"
TOOL.ClientConVar["worldweld"] = "0"
TOOL.ClientConVar["nocollide"] = "1"

if StreamRadioLib and StreamRadioLib.Loaded then
	TOOL.ClientConVar["model"] = StreamRadioLib.Util.GetDefaultModel()
	TOOL.ClientConVar["playbackloopmode"] = tostring(StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST)

	StreamRadioLib.Tool.AddLocale(TOOL, "name", "Radio Spawner")
	StreamRadioLib.Tool.AddLocale(TOOL, "desc", "Spawns a Stream Radio")

	StreamRadioLib.Tool.AddLocale(TOOL, "left", "Create a stream radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "right", "Copy the settings of a radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "reload", "Copy the model of an entity, but the most models will not have a display")

	StreamRadioLib.Tool.AddLocale(TOOL, "Undone_", "Undone Stream Radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "SBoxLimit_", "You've hit the Stream Radio limit!")
	StreamRadioLib.Tool.AddLocale(TOOL, "Cleanup_", "Stream Radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "Cleaned_", "Cleaned up all Stream Radios")

	StreamRadioLib.Tool.AddLocale(TOOL, "model", "Model:")
	StreamRadioLib.Tool.AddLocale(TOOL, "modelinfo", "Some models (usually speakers) don't have a display. Use this tool or Wiremod to control those.")
	StreamRadioLib.Tool.AddLocale(TOOL, "modelinfo.desc", "Some models (usually speakers) don't have a display.\nUse this tool or Wiremod to control those.")
	StreamRadioLib.Tool.AddLocale(TOOL, "modelinfo_mp", "Some selectable models might not be available on the server. Those will be replaced by a default model.")
	StreamRadioLib.Tool.AddLocale(TOOL, "modelinfo_mp.desc", "Some selectable models might not be available on the server.\nThose will be replaced by a default model.")
	StreamRadioLib.Tool.AddLocale(TOOL, "play", "Start playback")
	StreamRadioLib.Tool.AddLocale(TOOL, "play.desc", "If set, the radio will try to play a given URL on spawn or apply.\nThe URL can be set by this Tools or via Wiremod.")
	StreamRadioLib.Tool.AddLocale(TOOL, "nodisplay", "Disable display")
	StreamRadioLib.Tool.AddLocale(TOOL, "noadvwire", "Disable advanced wire outputs")
	StreamRadioLib.Tool.AddLocale(TOOL, "noadvwire.desc", "Disables the advanced wire outputs.\nIt is always disabled if Wiremod or GM_BASS3 is not installed on the Server.")
	StreamRadioLib.Tool.AddLocale(TOOL, "noinput", "Disable control")
	StreamRadioLib.Tool.AddLocale(TOOL, "noinput.desc", "Disable the control of the display.\nWiremod controlling will still work.")
	StreamRadioLib.Tool.AddLocale(TOOL, "nospectrum", "Disable spectrum visualization")
	StreamRadioLib.Tool.AddLocale(TOOL, "nospectrum.desc", "Disable rendering of the spectrum visualization on the display.")
	StreamRadioLib.Tool.AddLocale(TOOL, "playbackloopmode", "Loop Playback:")
	StreamRadioLib.Tool.AddLocale(TOOL, "playbackloopmode.desc", "Set what happens after a song ends.")
	StreamRadioLib.Tool.AddLocale(TOOL, "playbackloopmode.option.none", "No loop")
	StreamRadioLib.Tool.AddLocale(TOOL, "playbackloopmode.option.song", "Loop song")
	StreamRadioLib.Tool.AddLocale(TOOL, "playbackloopmode.option.playlist", "Loop playlist")
	StreamRadioLib.Tool.AddLocale(TOOL, "3dsound", "Enable 3D Sound")
	StreamRadioLib.Tool.AddLocale(TOOL, "mute", "Mute Radio")
	StreamRadioLib.Tool.AddLocale(TOOL, "volume", "Volume:")
	StreamRadioLib.Tool.AddLocale(TOOL, "radius", "Radius:")
	StreamRadioLib.Tool.AddLocale(TOOL, "radius.desc", "The radius in units the radio sound volume will drop down to 0% of the volume setting.")
	StreamRadioLib.Tool.AddLocale(TOOL, "streamurl", "Stream URL:")
	StreamRadioLib.Tool.AddLocale(TOOL, "freeze", "Freeze")
	StreamRadioLib.Tool.AddLocale(TOOL, "weld", "Weld")
	StreamRadioLib.Tool.AddLocale(TOOL, "worldweld", "Weld to world")
	StreamRadioLib.Tool.AddLocale(TOOL, "nocollide", "Nocollide")
	StreamRadioLib.Tool.AddLocale(TOOL, "spawnsettings", "Spawn settings:")

	StreamRadioLib.Tool.AddLocale(TOOL, "streamurl_info", "What can I put in as Stream URL?")
	StreamRadioLib.Tool.AddLocale(TOOL, "streamurl_info.desc", StreamRadioLib.STREAM_URL_INFO)

	StreamRadioLib.Tool.AddLocale(TOOL, "mute_volume_info", "NOTE: These are entity options too. So they only affect the radio they are applied on. The global settings for your client are at 'General Settings'.")
	StreamRadioLib.Tool.AddLocale(TOOL, "mute_volume_info.desc", "NOTE: These are entity options too. So they only affect the radio they are applied on. The global settings for your client are at 'General Settings'.")

	StreamRadioLib.Tool.AddLocale(TOOL, "streamurl_whitelist_info", "Whitelist protected server:\nOnly approved Stream URLs will work on this server!")

	StreamRadioLib.Tool.Setup(TOOL)
else
	TOOL.Information = nil

	if CLIENT then
		local StreamRadioLib = StreamRadioLib or {}
		local _mode = TOOL.Mode

		language.Add("Tool." .. _mode .. ".name", "Radio Spawner")
		language.Add("Tool." .. _mode .. ".desc", "Spawns a Stream Radio")
		language.Add("Tool." .. _mode .. ".0", "This tool could not be loaded.")

		function TOOL.BuildCPanel(CPanel)
			if StreamRadioLib.Loader_CreateErrorPanel then
				StreamRadioLib.Loader_CreateErrorPanel(CPanel, "This tool could not be loaded.")
			end
		end
	end
end


function TOOL:BuildToolPanel(CPanel)
	CPanel:PropSelect(
		StreamRadioLib.Tool.GetLocale(self, "model"),
		self.Mode .. "_model",
		StreamRadioLib.Model.RegisteredModels(),
		4
	)

	self:AddLabel( CPanel, "modelinfo", true )

	if game.IsDedicated() then
		self:AddLabel( CPanel, "modelinfo_mp", true )
	end

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacerLine())

	self:AddURLTextEntry( CPanel, "streamurl", false )
	self:AddWhitelistEnabledLabel( CPanel, "streamurl_whitelist_info", false )

	local _, StreamUrlInfoText = self:AddReadOnlyTextBox( CPanel, "streamurl_info" )
	StreamUrlInfoText:SetTall(245)

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacerLine())

	self:AddCheckbox( CPanel, "play", true )
	self:AddCheckbox( CPanel, "nodisplay", false )
	self:AddCheckbox( CPanel, "noinput", true )
	self:AddCheckbox( CPanel, "nospectrum", true )
	self:AddCheckbox( CPanel, "noadvwire", true )
	self:AddCheckbox( CPanel, "3dsound", false )

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacer())

	local iconPlaybackloopmodeNone = StreamRadioLib.GetPNGIconPath("arrow_not_refresh", true)
	local iconPlaybackloopmodeSong = StreamRadioLib.GetPNGIconPath("arrow_refresh")
	local iconPlaybackloopmodePlaylist = StreamRadioLib.GetPNGIconPath("table_refresh")

	local PlaybackLoopModeComboBox = self:AddComboBox(CPanel, "playbackloopmode", true)
	PlaybackLoopModeComboBox:SetSortItems(false)
	PlaybackLoopModeComboBox:AddChoice(StreamRadioLib.Tool.GetLocale(self, "playbackloopmode.option.none"), StreamRadioLib.PLAYBACK_LOOP_MODE_NONE, false, iconPlaybackloopmodeNone)
	PlaybackLoopModeComboBox:AddSpacer()
	PlaybackLoopModeComboBox:AddChoice(StreamRadioLib.Tool.GetLocale(self, "playbackloopmode.option.song"), StreamRadioLib.PLAYBACK_LOOP_MODE_SONG, false, iconPlaybackloopmodeSong)
	PlaybackLoopModeComboBox:AddChoice(StreamRadioLib.Tool.GetLocale(self, "playbackloopmode.option.playlist"), StreamRadioLib.PLAYBACK_LOOP_MODE_PLAYLIST, false, iconPlaybackloopmodePlaylist)

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacerLine())

	self:AddImportantLabel( CPanel, "mute_volume_info", true )

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacer())

	self:AddCheckbox( CPanel, "mute", false )

	local VolumeNumSlider = self:AddNumSlider( CPanel, "volume", false )
	VolumeNumSlider:SetMin( 0 )
	VolumeNumSlider:SetMax( 1 )
	VolumeNumSlider:SetDecimals( 2 )

	local RadiusNumSlider = self:AddNumSlider( CPanel, "radius", true )
	RadiusNumSlider:SetMin( 0 )
	RadiusNumSlider:SetMax( 5000 )
	RadiusNumSlider:SetDecimals( 0 )

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacerLine())

	self:AddLabel( CPanel, "spawnsettings", false )
	self:AddCheckbox( CPanel, "freeze", false )

	local WeldCheckbox = self:AddCheckbox( CPanel, "weld", false )
	local WorldWeldCheckbox = self:AddCheckbox( CPanel, "worldweld", false )
	local NoCollideCheckbox = self:AddCheckbox( CPanel, "nocollide", false )

	WeldCheckbox.OnChange = function( self, state )
		local state = ( state and 1 or 0 )

		if ( state == 0 ) then
			WorldWeldCheckbox:SetValue( 0 )
			NoCollideCheckbox:SetValue( 0 )
		end
	end

	WorldWeldCheckbox.OnChange = function( self, state )
		local state = ( state and 1 or 0 )

		if ( state == 1 ) then
			WeldCheckbox:SetValue( 1 )
		end
	end

	NoCollideCheckbox.OnChange = function( self, state )
		local state = ( state and 1 or 0 )

		if ( state == 1 ) then
			WeldCheckbox:SetValue( 1 )
		end
	end

	CPanel:AddPanel(StreamRadioLib.Menu.GetSpacer(5))
	CPanel:AddPanel(StreamRadioLib.Menu.GetOpenSettingsButton())
	CPanel:AddPanel(StreamRadioLib.Menu.GetOpenAdminSettingsButton())
	CPanel:AddPanel(StreamRadioLib.Menu.GetPlaylistEditorButton())
end

local function CalcSpawnAngle( normal, ply_ang, model )
	local Ang = normal:Angle( )
	local normalz = math.Round( normal.z, 4 )
	local IsWall = false
	local modelsettings = StreamRadioLib.Model.GetModelSettings( model ) or {}
	local angoffset = modelsettings.SpawnAng or Angle()
	local spawnFlatOnWall = modelsettings.SpawnFlatOnWall
	Ang.p = ( Ang.p + 90 ) % 360

	if spawnFlatOnWall and normalz == 0 then
		IsWall = true
	end

	if normalz == 1 then
		Ang.y = ( ply_ang.y + 180 ) % 360
		IsWall = false
	elseif normalz == -1 then
		Ang.y = ply_ang.y
		IsWall = false
	end

	if IsWall then
		Ang.p = 0
	end

	Ang:Normalize( )

	local _, Ang = LocalToWorld(Vector(), angoffset, Vector(), Ang)

	Ang:Normalize( )

	return Ang, IsWall
end

local function CalcSpawnPos( ent, IsWall, hitpos, normal, model )
	local modelsettings = StreamRadioLib.Model.GetModelSettings( model ) or {}
	local spawnAtOrigin = modelsettings.SpawnAtOrigin or false

	if spawnAtOrigin then
		return hitpos
	end

	local angoffset = modelsettings.SpawnAng or Angle()

	local min = ent:OBBMins()
	local max = ent:OBBMaxs()

	local rmin, rmax = ent:GetRotatedAABB( min, max )

	min:Rotate(angoffset)
	max:Rotate(angoffset)

	local size = Vector(
		math.abs( max.x - min.x ),
		math.abs( max.y - min.y ),
		math.abs( max.z - min.z )
	)

	local center = ( rmin + rmax ) / 2

	local Pos = hitpos - center
	local edge

	if IsWall then
		edge = size.x / 2
	else
		edge = size.z / 2
	end

	Pos = Pos + edge * normal

	return Pos
end

function TOOL:GetSettings()
	local settings = {}

	settings.StreamMute = self:GetClientBool("mute")
	settings.StreamVolume = self:GetClientNumberMinMax("volume", 0, 1)
	settings.Radius = self:GetClientNumberMinMax("radius", 0, 5000)
	settings.PlaybackLoopMode = self:GetClientNumber("playbackloopmode", StreamRadioLib.PLAYBACK_LOOP_MODE_NONE)
	settings.Sound3D = self:GetClientBool("3dsound")
	settings.DisableDisplay = self:GetClientBool("nodisplay")
	settings.DisableInput = self:GetClientBool("noinput")
	settings.DisableSpectrum = self:GetClientBool("nospectrum")
	settings.DisableAdvancedOutputs = self:GetClientBool("noadvwire")

	return settings
end

function TOOL:SetSettings(settings)
	local url = settings.StreamUrl or ""

	url = StreamRadioLib.Url.SanitizeUrl(url)

	self:SetClientInfo("streamurl", url)

	self:SetClientBool("mute", settings.StreamMute)
	self:SetClientNumber("volume", settings.StreamVolume or 1)
	self:SetClientNumber("radius", settings.Radius or 1200)
	self:SetClientNumber("playbackloopmode", settings.PlaybackLoopMode or StreamRadioLib.PLAYBACK_LOOP_MODE_NONE)
	self:SetClientBool("3dsound", settings.Sound3D)
	self:SetClientBool("nodisplay", settings.DisableDisplay)
	self:SetClientBool("noinput", settings.DisableInput)
	self:SetClientBool("nospectrum", settings.DisableSpectrum)
	self:SetClientBool("noadvwire", settings.DisableAdvancedOutputs)
end

local _TOOL_Class = TOOL.Mode
local function MakeStreamRadio(ply, Pos, Ang, model, nocollide, Settings)
	if not SERVER then return end
	if IsValid(ply) and not ply:CheckLimit(_TOOL_Class) then return end
	Settings = Settings or {}

	if not StreamRadioLib then return end
	if not StreamRadioLib.SpawnRadio then return end

	local ent = StreamRadioLib.SpawnRadio(ply, model, Pos, Ang, Settings)
	if not IsValid(ent) then return end

	local phys = ent:GetPhysicsObject( )

	if IsValid(phys) then
		phys:EnableCollisions( not nocollide )
	end

	ent.Settings = Settings
	ent.nocollide = nocollide

	if IsValid(ply) then
		ply:AddCount(_TOOL_Class, ent)
		ply:AddCleanup(_TOOL_Class, ent)
	end

	return ent
end

if SERVER then
	duplicator.RegisterEntityClass("sent_" .. TOOL.Mode, MakeStreamRadio, "Pos", "Ang", "Model", "nocollide", "Settings")
end

function TOOL:LeftClick(trace)
	if not self.ToolLibLoaded then return false end
	if not self:IsValidTrace(trace) then return false end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if CLIENT then return true end

	local settings = self:GetSettings()

	if self:IsValidRadio(ent) then
		if not StreamRadioLib.EditRadio(ent, settings) then return false end

		ent:SetToolURL(self:GetClientInfo("streamurl"), self:GetClientBool("play"))
		return true
	end

	if not self:GetSWEP():CheckLimit(self.Mode) then
		return false
	end

	local model = self:GetModel()
	local ang, IsWall = CalcSpawnAngle(trace.HitNormal, ply:GetAngles(), model)

	local nocollide = self:GetClientBool("nocollide")
	local weld = self:GetClientBool("weld")
	local worldweld = self:GetClientBool("worldweld")
	local freeze = self:GetClientBool("freeze")

	nocollide = nocollide and ((weld and IsValid(trace.Entity)) or worldweld)

	local ent = MakeStreamRadio(ply, trace.HitPos, ang, model, nocollide, settings)
	if not IsValid(ent) then return false end

	local pos = CalcSpawnPos(ent, IsWall, trace.HitPos, trace.HitNormal, model)
	ent:SetPos(pos)

	ent:SetToolURL(self:GetClientInfo("streamurl"), self:GetClientBool("play"))

	local const = nil

	if weld or worldweld then
		const = StreamRadioLib.Tool.AdvWeld( ent, trace.Entity, trace.PhysicsBone, true, not nocollide, worldweld, freeze )
	else
		local phys = ent:GetPhysicsObject()

		if IsValid(phys) then
			phys:EnableMotion(not freeze)
		end
	end

	if IsValid(ply) then
		undo.Create(self.Mode)
		undo.AddEntity(ent)

		if IsValid(const) then
			undo.AddEntity(const)
		end

		undo.SetPlayer(ply)
		undo.Finish()
	end

	return true
end

function TOOL:RightClick( trace )
	if not self.ToolLibLoaded then return false end
	if not self:IsValidTrace(trace) then return false end

	local ent = trace.Entity
	if not self:IsValidRadio(ent) then return false end

	if CLIENT then return true end

	self:SetSettings(ent:GetSettings())
	return true
end

function TOOL:Reload( trace )
	if not self.ToolLibLoaded then return false end
	if not self:IsValidTrace(trace) then return false end

	local ent = trace.Entity

	if not IsValid(ent) then return false end
	if ent:IsPlayer() then return false end
	if ent:IsNPC() then return false end
	if ent:GetPhysicsObjectCount() > 1 then return false end -- No ragdolls!

	local model = ent:GetModel()
	if not StreamRadioLib.Util.IsValidModel(model) then return false end

	if CLIENT then return true end

	self:SetClientInfo("model", model)
	return true
end

function TOOL:UpdateGhostStreamRadio( ent, ply, model )
	if not IsValid( ent ) then return end
	if not IsValid( ply ) then return end

	if not self.ToolLibLoaded then return end

	local trace = self:GetFallbackTrace()
	if not trace then return end
	local hitent = trace.Entity

	if self:IsValidRadio(hitent) then
		ent:SetNoDraw(true)
		return
	end

	ent:SetNoDraw(false)

	local Ang, IsWall = CalcSpawnAngle(trace.HitNormal, ply:GetAngles(), model)
	ent:SetAngles(Ang)

	local Pos = CalcSpawnPos(ent, IsWall, trace.HitPos, trace.HitNormal, model)
	ent:SetPos(Pos)
end

function TOOL:Think( )
	if not self.ToolLibLoaded then return end
	local model = self:GetModel()

	if not IsValid(self.GhostEntity) then
		self:MakeGhostEntity(
			Model(model),
			vector_origin,
			angle_zero
		)
	end

	if not IsValid(self.GhostEntity) then
		return
	end

	if self.GhostEntity:GetModel() ~= model then
		self.GhostEntity:SetModel(model)
		self.GhostEntity:DrawShadow(false)
	end

	self:UpdateGhostStreamRadio(self.GhostEntity, self:GetOwner(), model)
end

function TOOL:GetModel( )
	local model = self:GetClientInfo("model")

	if not StreamRadioLib.Util.IsValidModel(model) then
		return StreamRadioLib.Util.GetDefaultModel()
	end

	return model
end

function TOOL:Holster()
	if not self.ToolLibLoaded then return end
	self:ReleaseGhostEntity()
end

function TOOL:Deploy()
end

--lua/weapons/gmod_tool/stools/streamradio_gui_color_individual.lua:
return gluapack()()
--lua/weapons/gmod_tool/stools/streamradio_gui_skin.lua:
return gluapack()()
--lua/weapons/gmod_tool/stools/textscreen.lua:
TOOL.Category = "Construction"
TOOL.Name = "#tool.textscreen.name"
TOOL.Command = nil
TOOL.ConfigName = ""
local textBox = {}
local lineLabels = {}
local labels = {}
local sliders = {}
local rainbowCheckboxes = {}
local textscreenFonts = textscreenFonts
local rainbow_enabled = cvars.Number("ss_enable_rainbow", 1)
local max_characters = cvars.Number("ss_max_characters", 0)

for i = 1, 5 do
	TOOL.ClientConVar["text" .. i] = ""
	TOOL.ClientConVar["size" .. i] = 20
	TOOL.ClientConVar["r" .. i] = 255
	TOOL.ClientConVar["g" .. i] = 255
	TOOL.ClientConVar["b" .. i] = 255
	TOOL.ClientConVar["a" .. i] = 255
	TOOL.ClientConVar["font" .. i] = 1
	TOOL.ClientConVar["rainbow" .. i] = 0
end

cleanup.Register("textscreens")

if (CLIENT) then
	TOOL.Information = {
		{ name = "left" },
		{ name = "right" },
		{ name = "reload" },
	}
	-- Add default english language strings here, in case no localisation exists
	language.Add("tool.textscreen.name", "3D2D Textscreen")
	language.Add("tool.textscreen.desc", "Create a textscreen with multiple lines, font colours and sizes.")
	language.Add("tool.textscreen.left", "Spawn a textscreen.") -- Does not work with capital T in tool. Same with right and reload.
	language.Add("tool.textscreen.right", "Update textscreen with settings.")
	language.Add("tool.textscreen.reload", "Copy textscreen.")
	language.Add("Undone.textscreens", "Undone textscreen")
	language.Add("Undone_textscreens", "Undone textscreen")
	language.Add("Cleanup.textscreens", "Textscreens")
	language.Add("Cleanup_textscreens", "Textscreens")
	language.Add("Cleaned.textscreens", "Cleaned up all textscreens")
	language.Add("Cleaned_textscreens", "Cleaned up all textscreens")
	language.Add("SBoxLimit.textscreens", "You've hit the textscreen limit!")
	language.Add("SBoxLimit_textscreens", "You've hit the textscreen limit!")
end

function TOOL:LeftClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end
	local ply = self:GetOwner()

	if hook.Run("PlayerSpawnTextscreen", ply, tr) == false then return false end

	if not (self:GetWeapon():CheckLimit("textscreens")) then return false end
	-- ensure at least 1 line of the textscreen has text before creating entity
	local hasText = false
	for i = 1, 5 do
		local text = self:GetClientInfo("text" .. i) or ""
		if text ~= "" then
			hasText = true
		end
	end
	if not hasText then return false end
	local textScreen = ents.Create("sammyservers_textscreen")
	textScreen:SetPos(tr.HitPos)
	local angle = tr.HitNormal:Angle()
	angle:RotateAroundAxis(tr.HitNormal:Angle():Right(), -90)
	angle:RotateAroundAxis(tr.HitNormal:Angle():Forward(), 90)
	textScreen:SetAngles(angle)
	textScreen:Spawn()
	textScreen:Activate()

	undo.Create("textscreens")
	undo.AddEntity(textScreen)
	undo.SetPlayer(ply)
	undo.Finish()
	ply:AddCount("textscreens", textScreen)
	ply:AddCleanup("textscreens", textScreen)

	for i = 1, 5 do
		local txt = self:GetClientInfo("text" .. i) or ""
		textScreen:SetLine(
			i, -- Line
			max_characters ~= 0 and string.Left(txt, max_characters) or txt, -- text
			Color( -- Color
				tonumber(self:GetClientInfo("r" .. i)) or 255,
				tonumber(self:GetClientInfo("g" .. i)) or 255,
				tonumber(self:GetClientInfo("b" .. i)) or 255,
				tonumber(self:GetClientInfo("a" .. i)) or 255
			),
			tonumber(self:GetClientInfo("size" .. i)) or 20,
			-- font
			tonumber(self:GetClientInfo("font" .. i)) or 1,

			rainbow_enabled == 1 and tonumber(self:GetClientInfo("rainbow" .. i)) or 0
		)
	end

	return true
end

function TOOL:RightClick(tr)
	if (tr.Entity:GetClass() == "player") then return false end
	if (CLIENT) then return true end
	local traceEnt = tr.Entity

	if (IsValid(traceEnt) and traceEnt:GetClass() == "sammyservers_textscreen") then
		for i = 1, 5 do
			local txt = tostring(self:GetClientInfo("text" .. i))
			traceEnt:SetLine(
				i, -- Line
				max_characters ~= 0 and string.Left(txt, max_characters) or txt, -- text
				Color( -- Color
					tonumber(self:GetClientInfo("r" .. i)) or 255,
					tonumber(self:GetClientInfo("g" .. i)) or 255,
					tonumber(self:GetClientInfo("b" .. i)) or 255,
					tonumber(self:GetClientInfo("a" .. i)) or 255
				),
				tonumber(self:GetClientInfo("size" .. i)) or 20,
				-- font
				tonumber(self:GetClientInfo("font" .. i)) or 1,

				rainbow_enabled and tonumber(self:GetClientInfo("rainbow" .. i)) or 0
			)
		end

		traceEnt:Broadcast()

		return true
	end
end

function TOOL:Reload(tr)
	if (SERVER) then return true end
	local traceEnt = tr.Entity
	if (not isentity(traceEnt) or traceEnt:GetClass() ~= "sammyservers_textscreen") then return false end

	for i = 1, 5 do
		local linedata = traceEnt.lines[i]
		RunConsoleCommand("textscreen_r" .. i, linedata.color.r)
		RunConsoleCommand("textscreen_g" .. i, linedata.color.g)
		RunConsoleCommand("textscreen_b" .. i, linedata.color.b)
		RunConsoleCommand("textscreen_a" .. i, linedata.color.a)
		RunConsoleCommand("textscreen_size" .. i, linedata.size)
		RunConsoleCommand("textscreen_text" .. i, linedata.text)
		RunConsoleCommand("textscreen_font" .. i, linedata.font)
		RunConsoleCommand("textscreen_rainbow" .. i, linedata.rainbow)
	end

	return true
end

local conVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)
	local logo = vgui.Create("DImage", CPanel)
	logo:SetSize(267, 134)
	logo:SetImage("textscreens/logo.png")
	CPanel:AddItem(logo)

	CPanel:AddControl("Header", {
		Text = "#tool.textscreen.name",
		Description = "#tool.textscreen.desc"
	})

	local function TrimFontName(fontnum)
		return string.Left(textscreenFonts[fontnum], 8) == "Screens_" and string.TrimLeft(textscreenFonts[fontnum], "Screens_") or textscreenFonts[fontnum]
	end

	local changefont
	local fontnum = textscreenFonts[GetConVar("textscreen_font1"):GetInt()] ~= nil and GetConVar("textscreen_font1"):GetInt() or 1

	cvars.AddChangeCallback("textscreen_font1", function(convar_name, value_old, value_new)
		fontnum = textscreenFonts[tonumber(value_new)] ~= nil and tonumber(value_new) or 1
		local font = TrimFontName(fontnum)
		changefont:SetText("Change font (" .. font .. ")")
	end)

	local function ResetFont(lines, text)
		if #lines >= 5 then
			fontnum = 1
			for i = 1, 5 do
				RunConsoleCommand("textscreen_font" .. i, 1)
			end
		end
		for k, i in pairs(lines) do
			if text then
				RunConsoleCommand("textscreen_text" .. i, "")
				labels[i]:SetText("")
			end
			labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
		end
	end

	resetall = vgui.Create("DButton", resetbuttons)
	resetall:SetSize(100, 25)
	resetall:SetText("Reset all")

	resetall.DoClick = function()
		local menu = DermaMenu()

		menu:AddOption("Reset colors", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
			end
		end)

		menu:AddOption("Reset sizes", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
			end
		end)

		menu:AddOption("Reset textboxes", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_text" .. i, "")
				textBox[i]:SetValue("")
			end
		end)

		menu:AddOption("Reset fonts", function()
			ResetFont({1, 2, 3, 4, 5}, false)
		end)

		if rainbow_enabled == 1 then
			menu:AddOption("Reset rainbow", function()
				for i = 1, 5 do
					rainbowCheckboxes[i]:SetValue(0)
				end
			end)
		end

		menu:AddOption("Reset everything", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				RunConsoleCommand("textscreen_font" .. i, 1)
				textBox[i]:SetValue("")
				if rainbow_enabled == 1 then
					rainbowCheckboxes[i]:SetValue(0)
				end
			end
			ResetFont({1, 2, 3, 4, 5}, true)
		end)

		menu:Open()
	end

	CPanel:AddItem(resetall)
	resetline = vgui.Create("DButton")
	resetline:SetSize(100, 25)
	resetline:SetText("Reset line")

	resetline.DoClick = function()
		local menu = DermaMenu()

		for i = 1, 5 do
			menu:AddOption("Reset line " .. i, function()
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				textBox[i]:SetValue("")
				ResetFont({i}, true)
			end)
		end

		menu:AddOption("Reset all lines", function()
			for i = 1, 5 do
				RunConsoleCommand("textscreen_r" .. i, 255)
				RunConsoleCommand("textscreen_g" .. i, 255)
				RunConsoleCommand("textscreen_b" .. i, 255)
				RunConsoleCommand("textscreen_a" .. i, 255)
				RunConsoleCommand("textscreen_size" .. i, 20)
				sliders[i]:SetValue(20)
				RunConsoleCommand("textscreen_text" .. i, "")
				RunConsoleCommand("textscreen_font" .. i, 1)
				textBox[i]:SetValue("")
			end
			ResetFont({1, 2, 3, 4, 5}, true)
		end)

		menu:Open()
	end

	CPanel:AddItem(resetline)

	-- Change font
	changefont = vgui.Create("DButton")
	changefont:SetSize(100, 25)
	changefont:SetText("Change font (" .. TrimFontName(fontnum) .. ")" )

	changefont.DoClick = function()
		local menu = DermaMenu()

		for i = 1, #textscreenFonts do
			local font = TrimFontName(i)
			menu:AddOption(font, function()
				fontnum = i
				for o = 1, 5 do
					RunConsoleCommand("textscreen_font" .. o, i)
					labels[o]:SetFont(textscreenFonts[fontnum] .. "_MENU")
				end
				changefont:SetText("Change font (" .. font .. ")")
			end)
		end

		menu:Open()
	end

	CPanel:AddItem(changefont)

	CPanel:AddControl("ComboBox", {
		MenuButton = 1,
		Folder = "textscreen",
		Options = {
			["#preset.default"] = conVarsDefault
		},
		CVars = table.GetKeys(conVarsDefault)
	})

	for i = 1, 5 do
		lineLabels[i] = CPanel:AddControl("Label", {
			Text = "Line " .. i,
			Description = "Line " .. i
		})

		lineLabels[i]:SetFont("Default")

		CPanel:AddControl("Color", {
			Label = "Line " .. i .. " font color",
			Red = "textscreen_r" .. i,
			Green = "textscreen_g" .. i,
			Blue = "textscreen_b" .. i,
			Alpha = "textscreen_a" .. i,
			ShowHSV = 1,
			ShowRGB = 1,
			Multiplier = 255
		})

		if rainbow_enabled == 1 then
			rainbowCheckboxes[i] = vgui.Create("DCheckBoxLabel")
			rainbowCheckboxes[i]:SetText("Rainbow Text")
			rainbowCheckboxes[i]:SetTextColor(Color(0,0,0,255))
			rainbowCheckboxes[i]:SetConVar("textscreen_rainbow" .. i)
			rainbowCheckboxes[i]:SetTooltip("Enable for rainbow text")
			rainbowCheckboxes[i]:SetValue(GetConVar("textscreen_rainbow" .. i):GetInt())
			CPanel:AddItem(rainbowCheckboxes[i])
		end

		sliders[i] = vgui.Create("DNumSlider")
		sliders[i]:SetText("Font size")
		sliders[i]:SetMinMax(20, 100)
		sliders[i]:SetDecimals(0)
		sliders[i]:SetValue(GetConVar("textscreen_size" .. i))
		sliders[i]:SetConVar("textscreen_size" .. i)

		CPanel:AddItem(sliders[i])
		textBox[i] = vgui.Create("DTextEntry")
		textBox[i]:SetUpdateOnType(true)
		textBox[i]:SetEnterAllowed(true)
		textBox[i]:SetConVar("textscreen_text" .. i)
		textBox[i]:SetValue(GetConVar("textscreen_text" .. i):GetString())

		textBox[i].OnTextChanged = function()
			labels[i]:SetText(textBox[i]:GetValue())
		end

		if max_characters ~= 0 then
			textBox[i].AllowInput = function()
				if string.len(textBox[i]:GetValue()) >= max_characters then return true end
			end
		end

		CPanel:AddItem(textBox[i])

		labels[i] = CPanel:AddControl("Label", {
			Text = #GetConVar("textscreen_text" .. i):GetString() >= 1 and GetConVar("textscreen_text" .. i):GetString() or "Line " .. i,
			Description = "Line " .. i
		})

		labels[i]:SetFont(textscreenFonts[fontnum] .. "_MENU")
		labels[i]:SetAutoStretchVertical(true)
		labels[i]:SetDisabled(true)
		labels[i]:SetHeight(50)

		labels[i].Think = function()
			labels[i]:SetColor(
				Color(
					GetConVar("textscreen_r" .. i):GetInt(),
					GetConVar("textscreen_g" .. i):GetInt(),
					GetConVar("textscreen_b" .. i):GetInt(),
					GetConVar("textscreen_a" .. i):GetInt()
				)
			)
		end
	end
end

--addons/zeros_retrominer_v2.3.6/lua/weapons/gmod_tool/stools/zrmine_orespawner.lua:
return gluapack()()
--addons/hackable_server/lua/weapons/hacktool/cl_init.lua:
return gluapack()()
--addons/hackable_server/lua/languages/hacktool/lang_es.lua:
return gluapack()()
--addons/hackable_server/lua/weapons/hacktool/cl_hackmenuoptions.lua:
return gluapack()()
--addons/hackable_server/lua/weapons/hacktool/sh_customoptions.lua:
return gluapack()()
--addons/hackable_server/lua/weapons/hacktool/cl_hackanim1.lua:
local function fixLen(s,l)
	s=tostring(s)
	while string.len(s) < l do
		s='0'..s
	end
	return s
end

local Panel = {}

function Panel:SetUpDigits()
	self.ips = {}
	for i=1,80 do
		self.ips[i]=fixLen(math.floor(math.random()*99+1),2)
	end

	local id = math.ceil(math.random() * 80)

	self.rightip = tostring(self.ips[(id-1)%80+1])..'.'..self.ips[(id-0)%80+1]..'.'..self.ips[(id+1)%80+1]..'.'..self.ips[(id+2)%80+1]

	timer.Create('hackingPanel_shift', 2, 0, function()
		local fst = self.ips[1]
		for i=2,#self.ips do
			self.ips[i-1] = self.ips[i]
		end
		self.ips[#self.ips] = fst
	end)

	self.pos = math.ceil(math.random() * 80)

end

function Panel:Init()
	self.h = ScrH()*0.6
	self.w = self.h*1.5

	self.drawToScreen = false

	self.pos = 1
	self.attempts = 5

	self:SetSize(self.w, self.h)
	self:SetPos((ScrW()-self.w)/2,(ScrH() - self.h)/2)

	self:SetUpDigits()
	self:NoClipping(true)
	self:SetUpBindings()
end

function Panel:SetTimeout(timeStart, timeEnd)
	self.timeStart = timeStart
	self.timeEnd = timeEnd
	timer.Create('hackingPanel_timeout', self.timeEnd - self.timeStart, 1, function() 
		self.OnTimeOut()
	end)
end

function Panel:CheckIp()
	local id = self.pos
	return self.rightip == (tostring(self.ips[(id-1)%80+1])..'.'..self.ips[(id-0)%80+1]..'.'..self.ips[(id+1)%80+1]..'.'..self.ips[(id+2)%80+1])
end

function Panel:SetUpBindings()

	local nextTime = SysTime()+0.4
	local lastKey = nil
	hook.Add("PlayerButtonDown", "Hacking1", function(ply, key)
		if SysTime() < nextTime or not IsFirstTimePredicted() then return end
		nextTime = SysTime()+0.4
		local flag = true
		if key == KEY_ENTER or key == MOUSE_LEFT then
			if self:CheckIp() then
				self.doBeep('bebeep',1)
				self:OnSuccess()
			else
				self.attempts = self.attempts - 1
				if self.attempts == 0 then
					self.doBeep('deny',0.8)
					self.OnFail()
					return
				end
				self.doBeep('bzz',0.6)
			end
		elseif key == KEY_RIGHT then
			self.pos = self.pos % 80 + 1
		elseif key == KEY_LEFT then
			self.pos = self.pos == 1 and 80 or self.pos - 1
		elseif key == KEY_UP then
			self.pos = self.pos > 10 and self.pos - 10 or self.pos + 70
		elseif key == KEY_DOWN then
			self.pos = (((self.pos + 10) - 1) % 80) + 1
		else
			flag = false
		end
		if flag then
			lastKey = key
		end
	end)

	hook.Add("PlayerButtonUp", "Hacking1", function(ply, key)
		if lastKey == key and SysTime() < nextTime then
			nextTime = SysTime()+0.02
			lastKey = nil
		end
	end)

	local bbind = {"RIGHTARROW","LEFTARROW","MOUSE1","MWHEELDOWN","MWHEELUP"}

	hook.Add("PlayerBindPress","Hacking2", function(ply, bind, pressed)
		bind = input.LookupBinding(bind)
		if pressed then
			if bind == "MWHEELDOWN" then
				self.pos = self.pos % 80 + 1
				self.doBeep('tick',0.2)
			elseif bind == "MWHEELUP" then
				self.pos = self.pos == 1 and 80 or self.pos - 1
				self.doBeep('tick',0.2)
			end
			for i=1,#bbind do
				if bbind[i] == bind then
					return true
				end
			end
		end
	end,-1)
end

function Panel:OnRemove()
	timer.Remove('hackingPanel_timeout')
	timer.Remove('hackingPanel_shift')
	hook.Remove("PlayerBindPress","Hacking2")
	hook.Remove("PlayerButtonDown", "Hacking1")
	hook.Remove("PlayerButtonUp", "Hacking1")
end

function Panel:DrawOnRt(rt)
	local w, h = rt:Width(), rt:Height()

	render.PushRenderTarget(rt, 0, 0, w, h)
	cam.Start2D()

		surface.SetDrawColor(0,0,0)
		surface.DrawRect( 0, 0, w, h )

		surface.SetFont(hacktoolMats.font11)
		local tw,th = surface.GetTextSize(self.rightip)
		surface.SetTextPos(w/2 - tw/2,h*0.175)
		surface.SetTextColor(241,22,11,255)
		surface.DrawText(self.rightip)


		for i=1,80 do
			text = self.ips[i]
			local px,py = (i-1)%10, math.floor((i-1)/10)

			local ii = (self.pos > 76 and i < 4) and i + 80 or i

			if ii >= self.pos and ii < (self.pos + 4) then
				surface.SetTextColor(218,0,0,255)
			else
				surface.SetTextColor(218,218,218,255)
			end 
			surface.SetTextPos(w*0.14 + px*w*0.074,h*0.36 + py*0.067*h)
			surface.DrawText(text)
		end

		surface.SetDrawColor(48,163,47,255)
		for i=1,self.attempts do
			surface.DrawRect(w*(0.8+i*0.02), h*0.1, w*0.01, h*0.05)		
		end

		local timeLeft = (self.timeEnd - CurTime())
		text = '00:'..fixLen(math.Round(timeLeft),2)..':'..fixLen((math.Round(timeLeft%1*1000)),3)
		surface.SetFont(hacktoolMats.font12)
		tw,th = surface.GetTextSize(text)
		surface.SetTextPos(w/2 - tw/2,h*0.294)
		surface.SetTextColor(48,163,47,255)
		surface.DrawText(text)

	cam.End2D()
	render.PopRenderTarget()
	return rt
end

local bgMatUnilit = Material("models/weapons/hacktool/hacktool_mon_unilit")

local col_panelBorder = Color(28,67,176)

function Panel:Paint()

	local noerr, text = pcall(self.DrawOnRt, self, hacktoolMats.panelRt)

	if not noerr then
		cam.End2D()
		render.PopRenderTarget()
		print("Render error:",text)
	end
	hacktoolMats.panelMat:SetTexture('$basetexture', hacktoolMats.panelRt)

	if self.drawToScreen then
		draw.RoundedBox( 8, 0, 0, self.w, self.h, col_panelBorder)
		surface.SetMaterial(hacktoolMats.panelMat)
		surface.DrawTexturedRect( self.w*0.013, self.h*0.075, self.w*0.974, self.h*0.912 )		
	end

	local w,h = hacktoolMats.vmatrt:Width(),hacktoolMats.vmatrt:Height()

	render.PushRenderTarget(hacktoolMats.vmatrt)
	cam.Start2D()
		render.ClearDepth()
		render.OverrideBlend( true, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD )

		surface.SetDrawColor( 255, 255, 255, 255 )

		surface.SetMaterial(bgMatUnilit)
		surface.DrawTexturedRect(0,0,w,h)


		surface.SetMaterial(hacktoolMats.panelMat)
		render.OverrideBlend( true, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD, BLEND_ZERO, BLEND_ONE, BLENDFUNC_ADD )

		surface.DrawTexturedRectRotated(w/2,h/2,996*1.1/1024*w,650*1.1/1024*h,180)
		render.OverrideBlend( false )

	cam.End2D()
	render.PopRenderTarget()

	hacktoolMats.vmmat:SetTexture('$basetexture', hacktoolMats.vmatrt)


end
vgui.Register("HackPanel1", Panel, "DPanel")
--addons/hackable_server/lua/weapons/hacktool/cl_hackanim2.lua:
local function fixLen(s,l)
	s=tostring(s)
	while string.len(s) < l do
		s='0'..s
	end
	return s
end

local Panel = {}

function Panel:CreateLetters()
	self.letters = {}
	local words = {"increase","hospital","generate","medieval","material"}
	local alp = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

	local word = words[math.ceil(math.random() * #words)]:upper()
	for i=0,7 do
		self.letters[i] = {}
		self.letters[i][0] = word[i+1]
		for j=1,7 do
			self.letters[i][j] = alp[math.ceil(math.random()*26)]
		end
		self.letters[i].offset = math.random()
	end
	self.pos = 0
end

function Panel:Init()

	self.drawToScreen = true

	self.h = ScrH()*0.6
	self.w = self.h*1.5
	self.speed = 0.5
	self.difficulty = 0.05

	self:SetSize(self.w, self.h)
	self:SetPos((ScrW()-self.w)/2,(ScrH() - self.h)/2)

	self:CreateLetters()
	self:NoClipping(true)
	self:SetUpBindings()
end

function Panel:SetTimeout(timeStart, timeEnd)
	self.timeStart = timeStart
	self.timeEnd = timeEnd
	timer.Create('hackingPanel_timeout', self.timeEnd - self.timeStart, 1, function() 
		self.OnTimeOut()
	end)
end

function Panel:SetUpBindings()
	local nextTime = SysTime()+0.4
	local lastKey = nil
	hook.Add("PlayerButtonDown", "Hacking1", function(ply, key)
		if SysTime() < nextTime or not IsFirstTimePredicted() then return end
		nextTime = SysTime()+0.4
		local flag = true
		if key == KEY_ENTER or key == MOUSE_LEFT then
			if math.abs(0.485 - ((SysTime() - self.timeStart)*self.speed+self.letters[self.pos].offset)%1) < self.difficulty then
				self.letters[self.pos].selected = true
				local flag = true
				for i=0,7 do
					flag = flag and self.letters[i].selected
				end
				if flag and self.OnSuccess then
					self.doBeep('bebeep',1)
					self.OnSuccess()
					return
				end
			else
				self.doBeep('deny',1)
				self:CreateLetters()
				return
			end
			self.pos = (self.pos + 1) % 8
			self.doBeep('beep',0.5)
		elseif key == KEY_RIGHT then
			self.pos = (self.pos + 1) % 8
		elseif key == KEY_LEFT then
			self.pos = self.pos == 0 and 7 or self.pos - 1
		else
			flag = false
		end
		if flag then
			lastKey = key
		end
	end)

	hook.Add("PlayerButtonUp", "Hacking1", function(ply, key)
		if lastKey == key and SysTime() < nextTime then
			nextTime = SysTime()+0.02
			lastKey = nil
		end
	end)

	local bbind = {"RIGHTARROW","LEFTARROW","MOUSE1","MWHEELDOWN","MWHEELUP"}

	hook.Add("PlayerBindPress","Hacking2", function(ply, bind, pressed)
		bind = input.LookupBinding(bind)
		if pressed then
			if bind == "MWHEELDOWN" then
				self.pos = (self.pos + 1) % 8
				self.doBeep('tick',0.2)
			elseif bind == "MWHEELUP" then
				self.pos = self.pos == 0 and 7 or self.pos - 1
				self.doBeep('tick',0.2)
			end
			for i=1,#bbind do
				if bbind[i] == bind then
					return true
				end
			end
		end
	end,-1)
end

local gradient_u = Material("vgui/gradient-u")
local gradient_d = Material("vgui/gradient-d")

function Panel:OnRemove()
	timer.Remove('hackingPanel_timeout')
	hook.Remove("PlayerBindPress","Hacking2")
	hook.Remove("PlayerButtonDown", "Hacking1")
	hook.Remove("PlayerButtonUp", "Hacking1")
end

function Panel:DrawOnRt(rt)
	local w, h = rt:Width(), rt:Height()

	render.PushRenderTarget(rt, 0, 0, w, h)
	cam.Start2D()

	surface.SetDrawColor(0,0,0,255)
	surface.DrawRect( 0, 0, w, h )

	surface.SetFont(hacktoolMats.font21)

	for i=0,7 do
		for j=0,15 do
			jj = j % 8
			local text = self.letters[i][jj]

			local ofs = self.letters[i].selected and 0.485 or ((SysTime() - self.timeStart)*self.speed+self.letters[i].offset)%1

			local top = 0.065*j + 0.557 + 0.065*(8*ofs-12)
			if top < 0.20 or top > 0.83 then
				continue
			end

			local tw,th = surface.GetTextSize(text)
			surface.SetTextPos(w*(0.23 + 0.077*i)-tw/2,h*  top )
			if jj == 0 then
				if self.letters[i].selected then
					surface.SetTextColor(0,255,0)
				else
					surface.SetTextColor(255,0,0)
				end
			else
				surface.SetTextColor(255, 255, 255)
			end

			
			surface.DrawText(text)
		end
	end

	surface.SetDrawColor(28,67,176,69)
	surface.DrawRect(w*0.2, h*(0.58-0.03), w*0.6, h*(0.06))

	surface.SetDrawColor(50,130,189)
	surface.DrawLine( w*0.2, h*(0.58-0.03), w*0.8-1, h*(0.58-0.03))
	surface.DrawLine( w*0.2, h*(0.58+0.03), w*0.8-1, h*(0.58+0.03))

	local pos = self.pos

	surface.SetDrawColor(87,174,59,30)
	surface.DrawRect(w*(0.23 + 0.077*pos-0.025), h*(0.1), w*0.05, h*(0.8))
	surface.SetDrawColor(87,174,59)
	surface.DrawLine(w*(0.23 + 0.077*pos-0.025), h*(0.1), w*(0.23 + 0.077*pos-0.025), h*(0.8))
	surface.DrawLine(w*(0.23 + 0.077*pos+0.025)-1, h*(0.1), w*(0.23 + 0.077*pos+0.025)-1, h*(0.8))

	--draw gradients
	surface.SetDrawColor(0,0,0)
	surface.DrawRect(w*0.1, h*0.08, w*0.8, h*(0.58-0.2-0.08)+1)
	surface.SetMaterial(gradient_u)
	surface.DrawTexturedRect(w*0.1,h*(0.58-0.2),w*0.8,h*0.07)

	surface.DrawRect(w*0.1, h*(0.58+0.2)-1, w*0.8, h*(0.2)+1)
	surface.SetMaterial(gradient_d)
	surface.DrawTexturedRect(w*0.1,h*(0.58+0.2-0.07),w*0.8,h*0.07)

	--Draw time
	local timeLeft = (self.timeEnd - CurTime())
	text = '00:'..fixLen(math.Round(timeLeft),2)..':'..fixLen((math.Round(timeLeft%1*1000)),3)
	surface.SetFont(hacktoolMats.font12)
	local tw,th = surface.GetTextSize(text)
	surface.SetTextPos(w/2 - tw/2,h*0.294)
	surface.SetTextColor(48,163,47,255)
	surface.DrawText(text)

	cam.End2D()
	render.PopRenderTarget()


	return rt
end

local bgMatUnilit = Material("models/weapons/hacktool/hacktool_mon_unilit")

local col_panelBorder = Color(28,67,176)

function Panel:Paint()

	local noerr, text = pcall(self.DrawOnRt, self, hacktoolMats.panelRt)

	if not noerr then
		cam.End2D()
		render.PopRenderTarget()
		print("Render error:",text)
	end
	hacktoolMats.panelMat:SetTexture('$basetexture', hacktoolMats.panelRt)

	if self.drawToScreen then
		draw.RoundedBox( 8, 0, 0, self.w, self.h, col_panelBorder)
		surface.SetMaterial(hacktoolMats.panelMat)
		surface.DrawTexturedRect( self.w*0.013, self.h*0.075, self.w*0.974, self.h*0.912 )		
	end

	local w,h = hacktoolMats.vmatrt:Width(),hacktoolMats.vmatrt:Height()

	render.PushRenderTarget(hacktoolMats.vmatrt)
	cam.Start2D()
		render.ClearDepth()
		render.OverrideBlend( true, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD )

		surface.SetDrawColor( 255, 255, 255, 255 )

		surface.SetMaterial(bgMatUnilit)
		surface.DrawTexturedRect(0,0,w,h)


		surface.SetMaterial(hacktoolMats.panelMat)
		render.OverrideBlend( true, BLEND_ONE, BLEND_ZERO, BLENDFUNC_ADD, BLEND_ZERO, BLEND_ONE, BLENDFUNC_ADD )

		surface.DrawTexturedRectRotated(w/2,h/2,996*1.3/1024*w,650*1.3/1024*h,180)
		render.OverrideBlend( false )

	cam.End2D()
	render.PopRenderTarget()

	hacktoolMats.vmmat:SetTexture('$basetexture', hacktoolMats.vmatrt)

end
vgui.Register("HackPanel2", Panel, "DPanel")
--gamemodes/darkrp/entities/weapons/keys/shared.lua:
return gluapack()()
--gamemodes/darkrp/entities/weapons/keys/shared.lua:
AddCSLuaFile()

if SERVER then
    AddCSLuaFile("cl_menu.lua")
end

if CLIENT then
    SWEP.Slot = 1
    SWEP.SlotPos = 1
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false

    include("cl_menu.lua")
end

SWEP.PrintName = "Keys"
SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click to lock\nRight click to unlock\nReload for door settings or animation menu"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPKeys = true

SWEP.WorldModel = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "rpg"

SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"
SWEP.Sound = "doors/door_latch3.wav"

SWEP.Primary.Delay = 0.3
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.Delay = 0.3
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:Deploy()
    if CLIENT or not IsValid(self:GetOwner()) then return true end
    self:GetOwner():DrawWorldModel(false)
    return true
end

function SWEP:Holster()
    return true
end

function SWEP:PreDrawViewModel()
    return true
end

local function lookingAtLockable(ply, ent, hitpos)
    local eyepos = ply:EyePos()
    return IsValid(ent)
        and ent:isKeysOwnable()
        and (
            ent:isDoor() and eyepos:DistToSqr(hitpos) < 2000
            or
            ent:IsVehicle() and eyepos:DistToSqr(hitpos) < 4000
        )
end

local function lockUnlockAnimation(ply, snd)
    ply:EmitSound("npc/metropolice/gear" .. math.random(1, 6) .. ".wav")
    timer.Simple(0.9, function() if IsValid(ply) then ply:EmitSound(snd) end end)

    umsg.Start("anim_keys")
        umsg.Entity(ply)
        umsg.String("usekeys")
    umsg.End()

    ply:AnimRestartGesture(GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_GMOD_GESTURE_ITEM_PLACE, true)
end

local function doKnock(ply, sound)
    ply:EmitSound(sound, 100, math.random(90, 110))

    umsg.Start("anim_keys")
        umsg.Entity(ply)
        umsg.String("knocking")
    umsg.End()

    ply:AnimRestartGesture(GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_HL2MP_GESTURE_RANGE_ATTACK_FIST, true)
end

function SWEP:PrimaryAttack()
    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local trace = Owner:GetEyeTrace()

    local ent = trace.Entity

    if not lookingAtLockable(Owner, ent, trace.HitPos) then return end

    self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)

    if CLIENT then return end

    if Owner:canKeysLock(ent) then
        ent:keysLock() -- Lock the door immediately so it won't annoy people
        lockUnlockAnimation(Owner, self.Sound)
    elseif ent:IsVehicle() then
        DarkRP.notify(Owner, 1, 3, DarkRP.getPhrase("do_not_own_ent"))
    else
        doKnock(Owner, "physics/wood/wood_crate_impact_hard2.wav")
    end
end

function SWEP:SecondaryAttack()
    local Owner = self:GetOwner()

    if not IsValid(Owner) then return end

    local trace = Owner:GetEyeTrace()

    local ent = trace.Entity

    if not lookingAtLockable(Owner, ent, trace.HitPos) then return end

    self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)

    if CLIENT then return end

    if Owner:canKeysUnlock(ent) then
        ent:keysUnLock() -- Unlock the door immediately so it won't annoy people
        lockUnlockAnimation(Owner, self.Sound)
    elseif ent:IsVehicle() then
        DarkRP.notify(Owner, 1, 3, DarkRP.getPhrase("do_not_own_ent"))
    else
        doKnock(Owner, "physics/wood/wood_crate_impact_hard3.wav")
    end
end

function SWEP:Reload()
    local trace = self:GetOwner():GetEyeTrace()

    local ent = trace.Entity

    if not IsValid(ent) or ((not ent:isDoor() and not ent:IsVehicle()) or self:GetOwner():EyePos():DistToSqr(trace.HitPos) > 40000) then
        if CLIENT and not DarkRP.disabledDefaults["modules"]["animations"] then RunConsoleCommand("_DarkRP_AnimationMenu") end
        return
    end
    if SERVER then
        umsg.Start("KeysMenu", self:GetOwner())
        umsg.End()
    end
end

--gamemodes/darkrp/entities/weapons/keys/cl_menu.lua:
local function AddButtonToFrame(Frame)
    Frame:SetTall(Frame:GetTall() + 110)

    local button = vgui.Create("DButton", Frame)
    button:SetPos(10, Frame:GetTall() - 110)
    button:SetSize(180, 100)

    Frame.buttonCount = (Frame.buttonCount or 0) + 1
    Frame.lastButton = button
    return button
end

DarkRP.stub{
    name = "openKeysMenu",
    description = "Open the keys/F2 menu.",
    parameters = {},
    realm = "Client",
    returns = {},
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "onKeysMenuOpened",
    description = "Called when the keys menu is opened.",
    parameters = {
        {
            name = "ent",
            description = "The door entity.",
            type = "Entity"
        },
        {
            name = "Frame",
            description = "The keys menu frame.",
            type = "Panel"
        }
    },
    returns = {
    },
    realm = "Client"
}

local KeyFrameVisible = false

local function openMenu(setDoorOwnerAccess, doorSettingsAccess)
    if KeyFrameVisible then return end
    local trace = LocalPlayer():GetEyeTrace()
    local ent = trace.Entity
    -- Don't open the menu if the entity is not ownable, the entity is too far away or the door settings are not loaded yet
    if not IsValid(ent) or not ent:isKeysOwnable() or trace.HitPos:DistToSqr(LocalPlayer():EyePos()) > 40000 then return end

    KeyFrameVisible = true
    local Frame = vgui.Create("DFrame")
    Frame:SetSize(200, 30) -- Base size
    Frame.btnMaxim:SetVisible(false)
    Frame.btnMinim:SetVisible(false)
    Frame:SetVisible(true)
    Frame:MakePopup()
    Frame:ParentToHUD()

    function Frame:Think()
        local tr = LocalPlayer():GetEyeTrace()
        local LAEnt = tr.Entity
        if not IsValid(LAEnt) or not LAEnt:isKeysOwnable() or tr.HitPos:DistToSqr(LocalPlayer():EyePos()) > 40000 then
            self:Close()
        end
        if not self.Dragging then return end
        local x = gui.MouseX() - self.Dragging[1]
        local y = gui.MouseY() - self.Dragging[2]
        x = math.Clamp(x, 0, ScrW() - self:GetWide())
        y = math.Clamp(y, 0, ScrH() - self:GetTall())
        self:SetPos(x, y)
    end

    local entType = DarkRP.getPhrase(ent:IsVehicle() and "vehicle" or "door")
    Frame:SetTitle(DarkRP.getPhrase("x_options", entType:gsub("^%a", string.upper)))

    function Frame:Close()
        KeyFrameVisible = false
        self:SetVisible(false)
        self:Remove()
    end

    -- All the buttons

    if ent:isKeysOwnedBy(LocalPlayer()) then
        local Owndoor = AddButtonToFrame(Frame)
        Owndoor:SetText(DarkRP.getPhrase("sell_x", entType))
        Owndoor.DoClick = function() RunConsoleCommand("darkrp", "toggleown") Frame:Close() end

        local AddOwner = AddButtonToFrame(Frame)
        AddOwner:SetText(DarkRP.getPhrase("add_owner"))
        AddOwner.DoClick = function()
            local menu = DermaMenu()
            menu.found = false
            for _, v in pairs(DarkRP.nickSortedPlayers()) do
                if not ent:isKeysOwnedBy(v) and not ent:isKeysAllowedToOwn(v) then
                    local steamID = v:SteamID()
                    menu.found = true
                    menu:AddOption(v:Nick(), function() RunConsoleCommand("darkrp", "ao", steamID) end)
                end
            end
            if not menu.found then
                menu:AddOption(DarkRP.getPhrase("noone_available"), function() end)
            end
            menu:Open()
        end

        local RemoveOwner = AddButtonToFrame(Frame)
        RemoveOwner:SetText(DarkRP.getPhrase("remove_owner"))
        RemoveOwner.DoClick = function()
            local menu = DermaMenu()
            for _, v in pairs(DarkRP.nickSortedPlayers()) do
                if (ent:isKeysOwnedBy(v) and not ent:isMasterOwner(v)) or ent:isKeysAllowedToOwn(v) then
                    local steamID = v:SteamID()
                    menu.found = true
                    menu:AddOption(v:Nick(), function() RunConsoleCommand("darkrp", "ro", steamID) end)
                end
            end
            if not menu.found then
                menu:AddOption(DarkRP.getPhrase("noone_available"), function() end)
            end
            menu:Open()
        end
        if not ent:isMasterOwner(LocalPlayer()) then
            RemoveOwner:SetDisabled(true)
        end
    end

    if doorSettingsAccess then
        local DisableOwnage = AddButtonToFrame(Frame)
        DisableOwnage:SetText(DarkRP.getPhrase(ent:getKeysNonOwnable() and "allow_ownership" or "disallow_ownership"))
        DisableOwnage.DoClick = function() Frame:Close() RunConsoleCommand("darkrp", "toggleownable") end
    end

    if doorSettingsAccess and (ent:isKeysOwned() or ent:getKeysNonOwnable() or ent:getKeysDoorGroup() or hasTeams) or ent:isKeysOwnedBy(LocalPlayer()) then
        local DoorTitle = AddButtonToFrame(Frame)
        DoorTitle:SetText(DarkRP.getPhrase("set_x_title", entType))
        DoorTitle.DoClick = function()
            Derma_StringRequest(DarkRP.getPhrase("set_x_title", entType), DarkRP.getPhrase("set_x_title_long", entType), "", function(text)
                RunConsoleCommand("darkrp", "title", text)
                if IsValid(Frame) then
                    Frame:Close()
                end
            end,
            function() end, DarkRP.getPhrase("ok"), DarkRP.getPhrase("cancel"))
        end
    end

    if not ent:isKeysOwned() and not ent:getKeysNonOwnable() and not ent:getKeysDoorGroup() and not ent:getKeysDoorTeams() or not ent:isKeysOwnedBy(LocalPlayer()) and ent:isKeysAllowedToOwn(LocalPlayer()) then
        local Owndoor = AddButtonToFrame(Frame)
        Owndoor:SetText(DarkRP.getPhrase("buy_x", entType))
        Owndoor.DoClick = function() RunConsoleCommand("darkrp", "toggleown") Frame:Close() end
    end

    if doorSettingsAccess then
        local EditDoorGroups = AddButtonToFrame(Frame)
        EditDoorGroups:SetText(DarkRP.getPhrase("edit_door_group"))
        EditDoorGroups.DoClick = function()
            local menu = DermaMenu()
            local groups = menu:AddSubMenu(DarkRP.getPhrase("door_groups"))
            local teams = menu:AddSubMenu(DarkRP.getPhrase("jobs"))
            local add = teams:AddSubMenu(DarkRP.getPhrase("add"))
            local remove = teams:AddSubMenu(DarkRP.getPhrase("remove"))

            menu:AddOption(DarkRP.getPhrase("none"), function()
                RunConsoleCommand("darkrp", "togglegroupownable")
                if IsValid(Frame) then Frame:Close() end
            end)

            for k in pairs(RPExtraTeamDoors) do
                groups:AddOption(k, function()
                    RunConsoleCommand("darkrp", "togglegroupownable", k)
                    if IsValid(Frame) then Frame:Close() end
                end)
            end

            local doorTeams = ent:getKeysDoorTeams()
            for k, v in pairs(RPExtraTeams) do
                local which = (not doorTeams or not doorTeams[k]) and add or remove
                which:AddOption(v.name, function()
                    RunConsoleCommand("darkrp", "toggleteamownable", k)
                    if IsValid(Frame) then Frame:Close() end
                end)
            end

            menu:Open()
        end
    end

    if Frame.buttonCount == 1 then
        Frame.lastButton:DoClick()
    elseif Frame.buttonCount == 0 or not Frame.buttonCount then
        Frame:Close()
        KeyFrameVisible = true
        timer.Simple(0.3, function() KeyFrameVisible = false end)
    end


    hook.Call("onKeysMenuOpened", nil, ent, Frame)

    Frame:Center()
    Frame:SetSkin(GAMEMODE.Config.DarkRPSkin)
end

function DarkRP.openKeysMenu(um)
    CAMI.PlayerHasAccess(LocalPlayer(), "DarkRP_SetDoorOwner", function(setDoorOwnerAccess)
        CAMI.PlayerHasAccess(LocalPlayer(), "DarkRP_ChangeDoorSettings", fp{openMenu, setDoorOwnerAccess})
    end)
end
usermessage.Hook("KeysMenu", DarkRP.openKeysMenu)

--gamemodes/darkrp/entities/weapons/pocket/shared.lua:
return gluapack()()
--addons/skeypad_1.2.36/lua/weapons/skeypad_emp_grenade/shared.lua:
SWEP.Category = "sKeypad"
SWEP.Author = "Stromic"
SWEP.PrintName = "EMP Grenade"
SWEP.Slot = 4
SWEP.SlotPos = 24
SWEP.DrawAmmo = false

SWEP.DrawCrosshair = false
SWEP.Weight = 2
SWEP.AutoSwitchTo = true
SWEP.UseHands = true
SWEP.AutoSwitchFrom = true
SWEP.HoldType = "grenade"


SWEP.ViewModelFOV = 60
SWEP.ViewModel = Model("models/weapons/c_grenade.mdl")
SWEP.WorldModel = Model("models/weapons/w_grenade.mdl")
SWEP.ShowWorldModel = false
SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Ammo ="none"

local function beacon(grenade)
	grenade:EmitSound(sKeypad.config.EMPBeaconSound)
	local ePos = grenade:GetPos()
	local effectdata = EffectData()
	effectdata:SetOrigin( ePos )
	util.Effect( "Sparks", effectdata )
end

function SWEP:Throw()
	local tr = self.Owner:GetEyeTrace()

	local pos, ang = LocalToWorld( Vector( -7, -23, 6.5 ), Angle( -50, -95, 175 ), tr.StartPos, tr.Normal:Angle() )

	local grenade = ents.Create("prop_physics")
	grenade:SetModel(self.WorldModel)
	grenade:SetPos(pos)
	grenade:SetCollisionGroup(1)
	grenade:SetAngles(ang)
	grenade:Spawn()

	beacon(grenade)

	timer.Create(grenade:EntIndex().."Beacon", 1, 0, function()
		beacon(grenade)
	end)

	timer.Simple(.1, function()
		if !IsValid(grenade) then return end
		grenade:SetCollisionGroup(0)
	end)

	local phys = grenade:GetPhysicsObject()

	if IsValid(phys) then
		phys:Wake()

		phys:SetVelocityInstantaneous( self.Owner:GetVelocity() )

		local fw = tr.HitPos - pos
		local dist = fw:Length()
		if ( dist > 0 ) then

			fw:Mul( 750 / dist )

			local up = ang:Up()
			up:Mul( 4 )
			up:Add( pos )

			phys:ApplyForceOffset( fw, up )
		end
	end

	timer.Simple(3, function()
		if !IsValid(grenade) then return end
		timer.Remove(grenade:EntIndex().."Beacon")
		grenade:EmitSound(sKeypad.config.EMPExplosionSound)
		local ePos = grenade:GetPos()
		local effectdata = EffectData()
		effectdata:SetOrigin( ePos )
		util.Effect( "VortDispel", effectdata )

		for k,v in pairs(ents.FindInSphere(grenade:GetPos(), sKeypad.config.empRadius)) do
			if v:GetClass() == "s_keypad" and !v.data.upgrades["emp"] then
				v:AccessGranted()
			end
		end

		grenade:Remove()
	end)
end



function SWEP:PrimaryAttack()
	self.Pullback = true
	self:SendWeaponAnim( ACT_VM_PULLBACK_HIGH )
end

function SWEP:Think()
	if SERVER and self.Pullback and !self.Owner:KeyDown(IN_ATTACK) and !self.Throwing then
		local ply = self.Owner
		self.Throwing = true
		self:SendWeaponAnim( ACT_VM_THROW )
		ply:SetAnimation(PLAYER_ATTACK1)
		self:Throw()

		timer.Simple(.5, function()
			ply:StripWeapon("skeypad_emp_grenade")
		end)
	end
end


function SWEP:SecondaryAttack()

end
--addons/[binbon]misc/lua/weapons/weapon_ciga/shared.lua:
-- weapon_ciga/shared.lua
-- Defines common shared code/defaults for ciga SWEP

-- Cigarette SWEP by Mordestein (based on Vape SWEP by Swamp Onions)
-- Backdoors removed by Seefox (https://steamcommunity.com/id/seef0x/)


SWEP.Author = "RebS"

SWEP.Instructions = "LMB: Kruto kurit"

SWEP.PrintName = "Sigara Turuncu Dal"

SWEP.IconLetter	= ""
SWEP.Category = "Turkish Haram Mod Sigara"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/rebs/icikiler_sigaralar/sigara_dal_turuncu.mdl"
SWEP.WorldModel = "models/rebs/icikiler_sigaralar/sigara_dal_turuncu.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.cigaID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:Initialize()
	if not self.CigaInitialized then
		self.CigaInitialized = true

		self.VElements = {
			["ciga"] = {
				type = "Model",
				model = self.ViewModel,
				bone = "ValveBiped.Bip01_Spine4",
				rel = "",
				pos = Vector(-7.1, -2.401, 23.377),
				angle = Angle(111.039, 10.519, 0),
				size = Vector(1, 1, 1),
				color = Color(255, 255, 255, 255),
				surpresslightning = false,
				material = "",
				skin = 0,
				bodygroup = {}
			}
		}

		--self.VElements["ciga"].model = self.ViewModel
		self.OldCigaModel = self.ViewModel
		self.ViewModel = "models/weapons/c_slam.mdl"
		self.UseHands = true
		self.ViewModelFlip = true
		self.ShowViewModel = true
		self.ShowWorldModel = true

		self.ViewModelBoneMods = {
			["ValveBiped.Bip01_L_Finger1"] = {
				scale = Vector(1, 1, 1),
				pos = Vector(0, 0, 0),
				angle = Angle(-23.334, -12.223, -32.223)
			},
			["ValveBiped.Bip01_L_Finger12"] = {
				scale = Vector(1, 1, 1),
				pos = Vector(0, 0, 0),
				angle = Angle(0, -21.112, 0)
			},
			["ValveBiped.Bip01_L_Finger4"] = {
				scale = Vector(1, 1, 1),
				pos = Vector(0, 0, 0),
				angle = Angle(0, -65.556, 0)
			},
			["ValveBiped.Bip01_R_UpperArm"] = {
				scale = Vector(1, 1, 1),
				pos = Vector(0, 0, 0),
				angle = Angle(0, 72.222, -41.112)
			},
			["ValveBiped.Bip01_L_Finger0"] = {
				scale = Vector(1, 1, 1),
				pos = Vector(0, 0, 0),
				angle = Angle(10, 1.11, -1.111)
			},
			["Detonator"] = {
				scale = Vector(0.009, 0.009, 0.009),
				pos = Vector(0, 0, 0),
				angle = Angle(0, 0, 0)
			},
			["ValveBiped.Bip01_L_Hand"] = {
				scale = Vector(1, 1, 1),
				pos = Vector(0, 0, 0),
				angle = Angle(-27.778, 1.11, -7.778)
			},
			["Slam_panel"] = {
				scale = Vector(0.009, 0.009, 0.009),
				pos = Vector(0, 0, 0),
				angle = Angle(0, 0, 0)
			},
			["ValveBiped.Bip01_L_Finger2"] = {
				scale = Vector(1, 1, 1),
				pos = Vector(0, 0, 0),
				angle = Angle(0, -47.778, 0)
			},
			["ValveBiped.Bip01_L_Finger3"] = {
				scale = Vector(1, 1, 1),
				pos = Vector(0, 0, 0),
				angle = Angle(0, -43.334, 0)
			},
			["Slam_base"] = {
				scale = Vector(0.009, 0.009, 0.009),
				pos = Vector(0, 0, 0),
				angle = Angle(0, 0, 0)
			},
			["ValveBiped.Bip01_R_Hand"] = {
				scale = Vector(0.009, 0.009, 0.009),
				pos = Vector(0, 0, 0),
				angle = Angle(0, 0, 0)
			}
		}
	end

	if CLIENT then
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy(self.VElements)
		self.WElements = table.FullCopy(self.WElements)
		self.ViewModelBoneMods = table.FullCopy(self.ViewModelBoneMods)
		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels

		-- init view model bone build function
		local owner = self:GetOwner()

		if IsValid(owner) then
			local vm = owner:GetViewModel()

			if IsValid(vm) then
				self:ResetBonePositions(vm)

				-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255, 255, 255, 255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255, 255, 255, 1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")
				end
			end
		end
	end

	if self.Initialize2 then
		self:Initialize2()
	end
end

function SWEP:PrimaryAttack()
	if SERVER then
		cigaUpdate(self:GetOwner(), self.cigaID)
	end

	self:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	local owner = self:GetOwner()

	local pitch = 100 + (self.SoundPitchMod or 0) + (owner:Crouching() and 40 or 0)
	self:EmitSound("cakmak.wav", 80, pitch + math.Rand(-5, 5))

	if SERVER then
		net.Start("cigaTalking")
		net.WriteEntity(owner)
		net.WriteFloat(CurTime() + (0.6 * 100 / pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
end

function SWEP:Holster()
	local owner = self:GetOwner()

	if SERVER and IsValid(owner) then
		Releaseciga(owner)
	end

	if CLIENT and IsValid(owner) then
		local vm = owner:GetViewModel()

		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end

	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster

--addons/[binbon]misc/lua/weapons/weapon_ciga/cl_init.lua:
-- weapon_ciga/cl_init.lua
-- Defines common clientside code/defaults for ciga SWEP

-- Cigarette SWEP by Mordestein (based on Vape SWEP by Swamp Onions)
-- Backdoors removed by Seefox (https://steamcommunity.com/id/seef0x/)

include("shared.lua")

if not cigaParticleEmitter then cigaParticleEmitter = ParticleEmitter(Vector(0,0,0)) end

local poneyModels = {
	["models/cppm/playe"] = true,
	["models/mlp/player"] = true,
	["models/ppm/player"] = true
}

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local cigaScale = self.cigaScale or 1
	self:SetModelScale(cigaScale, 0)
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1, 17)
		local bn = poneyModels[modelStr] and "LrigScull" or "ValveBiped.Bip01_R_Hand"

		if ply.cigaArmFullyUp then
			bn = "ValveBiped.Bip01_Head1"
		end

		local bon = ply:LookupBone(bn) or 0
		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp, ba = ply:GetBonePosition(bon)

		if bp then
			opos = bp
		end

		if ba then
			oang = ba
		end

		if ply.cigaArmFullyUp then
			--head position
			opos = opos + (oang:Forward() * 0.95) + (oang:Right() * 7) + (oang:Up() * 0.035)
			oang:RotateAroundAxis(oang:Forward(), -100)
			oang:RotateAroundAxis(oang:Up(), 100)
			opos = opos + (oang:Up() * (cigaScale - 1) * -10.25)
		else
			--hand position
			oang:RotateAroundAxis(oang:Forward(), 50)
			oang:RotateAroundAxis(oang:Right(), 90)
			opos = opos + (oang:Forward() * 2) + (oang:Up() * -4.5) + (oang:Right() * -2)
			oang:RotateAroundAxis(oang:Forward(), 90)
			oang:RotateAroundAxis(oang:Up(), 10)
			opos = opos + (oang:Up() * (cigaScale - 1) * -10.25)
			opos = opos + (oang:Up() * 2)
			opos = opos + (oang:Right() * 0.5)
			opos = opos + (oang:Forward() * -1.5)
		end

		self:SetupBones()
		local mrt = self:GetBoneMatrix(0)

		if mrt then
			mrt:SetTranslation(opos)
			mrt:SetAngles(oang)
			self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	if not LocalPlayer().cigaArmTime then
		LocalPlayer().cigaArmTime = 0
	end

	local lerp = math.Clamp((os.clock() - LocalPlayer().cigaArmTime) * 3, 0, 1)

	if LocalPlayer().cigaArm then
		lerp = 1 - lerp
	end

	--[[
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 

	pos,ang = LocalToWorld(newpos,newang,pos,ang)]]
	local difvec = Vector(-10, -3.5, -12) --vmpos1 - vmpos2
	local orig = Vector(0, 0, 0)
	local topos = orig + difvec
	local difang = Vector(-30, 0, 0) --vmang1 - vmang2
	local origang = Vector(0, 0, 0)
	local toang = origang + difang
	local newpos = LerpVector(lerp, topos, orig)
	local newang = LerpVector(lerp, toang, origang)
	newang = Angle(newang.x, newang.y, newang.z)
	pos, ang = LocalToWorld(newpos, newang, pos, ang)

	return pos, ang
end

sound.Add({
	name = "ciga_inhale",
	channel = CHAN_WEAPON,
	volume = 0.24,
	level = 60,
	pitch = {95},
	sound = "cigainhale.wav"
})

net.Receive("ciga", function()
	local ply = net.ReadEntity()
	local amt = net.ReadInt(8)
	local fx = net.ReadInt(8)
	if not IsValid(ply) then return end

	if amt >= 50 then
		ply:EmitSound("cigacough1.wav", 90)

		for i = 1, 200 do
			local d = i + 10

			if i > 140 then
				d = d + 150
			end

			timer.Simple((d - 1) * 0.003, function()
				ciga_do_pulse(ply, 1, 100, fx)
			end)
		end

		return
	elseif amt >= 35 then
		ply:EmitSound("cigabreath2.wav", 75, 100, 0.7)
	elseif amt >= 10 then
		ply:EmitSound("cigabreath1.wav", 70, 130 - math.min(100, amt * 2), 0.4 + (amt * 0.005))
	end

	for i = 1, amt * 2 do
		timer.Simple((i - 1) * 0.02, function()
			ciga_do_pulse(ply, math.floor(((amt * 2) - i) / 10), fx == 2 and 100 or 0, fx)
		end)
	end
end)

net.Receive("cigaArm", function()
	local ply = net.ReadEntity()
	local z = net.ReadBool()
	if not IsValid(ply) then return end

	if ply.cigaArm ~= z then
		if z then
			timer.Simple(0.3, function()
				if not IsValid(ply) then return end

				if ply.cigaArm then
					ply:EmitSound("ciga_inhale")
				end
			end)
		else
			ply:StopSound("ciga_inhale")
		end

		ply.cigaArm = z
		ply.cigaArmTime = os.clock()
		local m = 0

		if z then
			m = 1
		end

		for i = 0, 9 do
			timer.Simple(i / 30, function()
				ciga_interpolate_arm(ply, math.abs(m - ((9 - i) / 10)), z and 0 or 0.2)
			end)
		end
	end
end)

net.Receive("cigaTalking", function()
	local ply = net.ReadEntity()

	if IsValid(ply) then
		ply.cigaTalkingEndtime = net.ReadFloat()
	end
end)

function ciga_interpolate_arm(ply, mult, mouth_delay)
	if not IsValid(ply) then return end

	if mouth_delay > 0 then
		timer.Simple(mouth_delay, function()
			if IsValid(ply) then
				ply.cigaMouthOpenAmt = mult
			end
		end)
	else
		ply.cigaMouthOpenAmt = mult
	end

	local b1 = ply:LookupBone("ValveBiped.Bip01_R_Upperarm")
	local b2 = ply:LookupBone("ValveBiped.Bip01_R_Forearm")
	if (not b1) or (not b2) then return end
	ply:ManipulateBoneAngles(b1, Angle(20 * mult, -62 * mult, 10 * mult))
	ply:ManipulateBoneAngles(b2, Angle(-5 * mult, -10 * mult, 0))

	if mult == 1 then
		ply.cigaArmFullyUp = true
	else
		ply.cigaArmFullyUp = false
	end
end

--this makes the mouth opening work without clobbering other addons
hook.Add("InitPostEntity", "cigaMouthMoveSetup", function()
	timer.Simple(1, function()
		if ciga_OriginalMouthMove ~= nil then return end
		ciga_OriginalMouthMove = GAMEMODE.MouthMoveAnimation

		function GAMEMODE:MouthMoveAnimation(ply)
			--run the base MouthMoveAnimation if player isn't vaping/cigatalking
			if ((ply.cigaMouthOpenAmt or 0) == 0) and ((ply.cigaTalkingEndtime or 0) < CurTime()) then return ciga_OriginalMouthMove(GAMEMODE, ply) end
			local FlexNum = ply:GetFlexNum() - 1
			if (FlexNum <= 0) then return end

			for i = 0, FlexNum - 1 do
				local Name = ply:GetFlexName(i)

				if (Name == "jaw_drop" or Name == "right_part" or Name == "left_part" or Name == "right_mouth_drop" or Name == "left_mouth_drop") then
					ply:SetFlexWeight(i, math.max((ply.cigaMouthOpenAmt or 0) * 0.5, math.Clamp(((ply.cigaTalkingEndtime or 0) - CurTime()) * 3, 0, 1) * math.Rand(0.1, 0.8)))
				end
			end
		end
	end)
end)

function ciga_do_pulse(ply, amt, spreadadd, fx)
	if not IsValid(ply) then return end
	if ply:WaterLevel() == 3 then return end

	if not spreadadd then
		spreadadd = 0
	end

	local attachid = ply:LookupAttachment("eyes")
	cigaParticleEmitter:SetPos(LocalPlayer():GetPos())

	local angpos = ply:GetAttachment(attachid) or {
		Ang = Angle(0, 0, 0),
		Pos = Vector(0, 0, 0)
	}

	local fwd
	local pos

	if (ply ~= LocalPlayer()) then
		fwd = (angpos.Ang:Forward() - angpos.Ang:Up()):GetNormalized()
		pos = angpos.Pos + (fwd * 3.5)
	else
		fwd = ply:GetAimVector():GetNormalized()
		pos = ply:GetShootPos() + fwd * 1.5 + gui.ScreenToVector(ScrW() / 2, ScrH()) * 5
	end

	fwd = ply:GetAimVector():GetNormalized()

	for i = 1, amt do
		if not IsValid(ply) then return end
		local particle = cigaParticleEmitter:Add(string.format("particle/smokesprites_00%02d", math.random(7, 16)), pos)

		if particle then
			local dir = VectorRand():GetNormalized() * ((amt + 5) / 10)
			ciga_do_particle(particle, (ply:GetVelocity() * 0.25) + (((fwd * 9) + dir):GetNormalized() * math.Rand(50, 80) * (amt + 1) * 0.2), fx)
		end
	end
end

function ciga_do_particle(particle, vel, fx)
	particle:SetColor(255, 255, 255, 255)

	if fx == 3 then
		particle:SetColor(100, 100, 100, 100)
	end

	if fx >= 4 then
		local c = JuicycigaJuices[fx - 3].color

		if c == nil then
			c = HSVToColor(math.random(0, 359), 1, 1)
		end

		particle:SetColor(c.r, c.g, c.b, 255)
	end

	local mega = 1

	if fx == 2 then
		mega = 4
	end

	mega = mega * 0.3
	particle:SetVelocity(vel * mega)
	particle:SetGravity(Vector(0, 0, 1.5))
	particle:SetLifeTime(0)
	particle:SetDieTime(math.Rand(80, 100) * 0.11 * mega)
	particle:SetStartSize(3 * mega)
	particle:SetEndSize(40 * mega * mega)
	particle:SetStartAlpha(150)
	particle:SetEndAlpha(0)
	particle:SetCollide(true)
	particle:SetBounce(0.25)
	particle:SetRoll(math.Rand(0, 360))
	particle:SetRollDelta(0.01 * math.Rand(-40, 40))
	particle:SetAirResistance(50)
end

matproxy.Add({
	name = "cigaTankColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		if (not IsValid(ent)) then return end

		if ent:GetClass() == "viewmodel" then
			ent = ent:GetOwner()
			if (not IsValid(ent) or not ent:IsPlayer()) then return end
			ent = ent:GetActiveWeapon()
			if (not IsValid(ent)) then return end
		end

		local v = ent.cigaTankColor or Vector(0.3, 0.3, 0.3)

		if v == Vector(-1, -1, -1) then
			local c = HSVToColor((CurTime() * 60) % 360, 0.9, 0.9)
			v = Vector(c.r, c.g, c.b) / 255.0
		end

		mat:SetVector(self.ResultTo, v)
	end
})

matproxy.Add({
	name = "cigaAccentColor",
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		if (not IsValid(ent)) then return end
		local o = ent:GetOwner()

		if ent:GetClass() == "viewmodel" then
			if (not IsValid(o)) or (not o:IsPlayer()) then return end
			ent = o:GetActiveWeapon()
			if (not IsValid(ent)) then return end
		end

		local special = false
		local col = ent.cigaAccentColor or special and Vector(1, 0.8, 0) or Vector(1, 1, 1)

		if col == Vector(-1, -1, -1) then
			col = Vector(1, 1, 1)

			if IsValid(o) then
				col = o:GetWeaponColor()
			end
		end

		mat:SetVector(self.ResultTo, col)
	end
})

--Swep Construction Kit code--
if CLIENT then
	SWEP.vRenderOrder = nil

	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid(vm) then return end
		if (not self.VElements) then return end
		self:UpdateBonePositions(vm)

		if (not self.vRenderOrder) then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs(self.VElements) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
		end

		for k, name in ipairs(self.vRenderOrder) do
			local v = self.VElements[name]

			if (not v) then
				self.vRenderOrder = nil
				break
			end

			if (v.hide) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if (not v.bone) then continue end
			local pos, ang = self:GetBoneOrientation(self.VElements, v, vm)
			if (not pos) then continue end

			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() ~= v.material) then
					model:SetMaterial(v.material)
				end

				if (v.skin and v.skin ~= model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for kk, vv in pairs(v.bodygroup) do
						if (model:GetBodygroup(k) ~= v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
				render.SetBlend(v.color.a / 255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				cam.Start3D2D(drawpos, ang, v.size)
				v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation(basetab, tab, ent, bone_override)
		local bone, pos, ang

		if (tab.rel and tab.rel ~= "") then
			local v = basetab[tab.rel]
			if (not v) then return end
			-- Technically, if there exists an element with the same name as a bone
			-- you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation(basetab, v, ent)
			if (not pos) then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
		else
			bone = ent:LookupBone(bone_override or tab.bone)
			if (not bone) then return end
			pos, ang = Vector(0, 0, 0), Angle(0, 0, 0)
			local m = ent:GetBoneMatrix(bone)

			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end

			local owner = self:GetOwner()
			if (IsValid(owner) and owner:IsPlayer() and ent == owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end

		return pos, ang
	end

	function SWEP:CreateModels(tab)
		if (not tab) then return end

		-- Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs(tab) do
			if (v.type == "Model" and v.model and v.model ~= "" and (not IsValid(v.modelEnt) or v.createdModel ~= v.model) and string.find(v.model, ".mdl") and file.Exists(v.model, "GAME")) then
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)

				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif (v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spriteMaterial or v.createdSprite ~= v.sprite) and file.Exists("materials/" .. v.sprite .. ".vmt", "GAME")) then
				local name = v.sprite .. "-"

				local params = {
					["$basetexture"] = v.sprite
				}

				-- make sure we create a unique name based on the selected options
				local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}

				for i, j in pairs(tocheck) do
					if (v[j]) then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name, "UnlitGeneric", params)
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.ViewModelBoneMods then
			if (not vm:GetBoneCount()) then return end
			-- !! WORKAROUND !! //
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods

			if (not hasGarryFixedBoneScalingYet) then
				allbones = {}

				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)

					if (self.ViewModelBoneMods[bonename]) then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector(1, 1, 1),
							pos = Vector(0, 0, 0),
							angle = Angle(0, 0, 0)
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! //
			for k, v in pairs(loopthrough) do
				local bone = vm:LookupBone(k)
				if (not bone) then continue end
				-- !! WORKAROUND !! //
				local s = Vector(v.scale.x, v.scale.y, v.scale.z)
				local p = Vector(v.pos.x, v.pos.y, v.pos.z)
				local ms = Vector(1, 1, 1)

				if (not hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)

					while (cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end

				s = s * ms

				-- !! ----------- !! //
				if vm:GetManipulateBoneScale(bone) ~= s then
					vm:ManipulateBoneScale(bone, s)
				end

				if vm:GetManipulateBoneAngles(bone) ~= v.angle then
					vm:ManipulateBoneAngles(bone, v.angle)
				end

				if vm:GetManipulateBonePosition(bone) ~= p then
					vm:ManipulateBonePosition(bone, p)
				end
			end
		else
			self:ResetBonePositions(vm)
		end
	end

	function SWEP:ResetBonePositions(vm)
		if (not vm:GetBoneCount()) then return end

		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale(i, Vector(1, 1, 1))
			vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
			vm:ManipulateBonePosition(i, Vector(0, 0, 0))
		end
	end

	--[[*************************
		Global utility code
	*************************]]
	-- Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	-- Does not copy entities of course, only copies their reference.
	-- WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy(tab)
		if (not tab) then return nil end
		local res = {}

		for k, v in pairs(tab) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) -- recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end

		return res
	end
end

--addons/[binbon]misc/lua/weapons/weapon_ciga/shared.lua:
return gluapack()()
--addons/[binbon]misc/lua/weapons/weapon_ciga_paket_marlboro_touch_grey.lua:
return gluapack()()
--addons/[binbon]misc/lua/weapons/weapon_ciga_paket_muratti_rosso.lua:
return gluapack()()
--addons/[binbon]misc/lua/weapons/weapon_ciga_paket_tekel_uzun.lua:
-- MODEL WITH UNKNOWN AUTHOR! PM ME!!! QUICK :D -- 
-- Backdoors removed by Seefox (https://steamcommunity.com/id/seef0x/)

SWEP.PrintName = "Tekel 2000 Kirmizi Uzun"
SWEP.Author = "RebS"
SWEP.Purpose = "Pick one out."

SWEP.Category = "Turkish Haram Mod Sigara"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= false
SWEP.Secondary.Ammo		= "none"

SWEP.HoldType = "slam"
SWEP.ViewModelFOV = 49.849246231156
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/rebs/icikiler_sigaralar/sigara_paket_turuncu_dal.mdl"
SWEP.UseHands = true
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false

SWEP.ViewModelBoneMods = {
	["ValveBiped.Grenade_body"] = {
		scale = Vector(0.009, 0.009, 0.009),
		pos = Vector(0, 0, 0),
		angle = Angle(0, 0, 0)
	}
}

SWEP.VElements = {
	["element_name"] = {
		type = "Model",
		model = "models/rebs/icikiler_sigaralar/sigara_paket_turuncu_dal.mdl",
		bone = "ValveBiped.Grenade_body",
		rel = "",
		pos = Vector(-0.5, 0, -2.1),
		angle = Angle(-15.195, 180, 180),
		size = Vector(0.85, 0.85, 0.85),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 7,
		bodygroup = {}
	}
}

SWEP.WElements = {
	["element_name"] = {
		type = "Model",
		model = "models/rebs/icikiler_sigaralar/sigara_paket_turuncu_dal.mdl",
		bone = "ValveBiped.Bip01_R_Hand",
		rel = "",
		pos = Vector(3.6, 2.6, -1.3),
		angle = Angle(-26.883, 178.83, 180),
		size = Vector(1.1, 1.1, 1.1),
		color = Color(255, 255, 255, 255),
		surpresslightning = false,
		material = "",
		skin = 7,
		bodygroup = {}
	}
}

SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
local ShootSound = Sound("physics/cardboard/cardboard_box_impact_soft7.wav")

function SWEP:PrimaryAttack()
	if (not SERVER) then return end
	self:SetNextPrimaryFire(CurTime() + 1.50)
	self:EmitSound(ShootSound)

	timer.Simple(0.3, function()
		self:EmitSound("weapons/smg1/switch_single.wav")
	end)

	local type = ""
	local class = "weapon_ciga" .. type

	local owner = self:GetOwner()
	owner:Give(class)

	owner:SelectWeapon(class)

	timer.Simple(0.4, function()
		owner:StripWeapon("weapon_ciga_paket_marlboro_red")
	end)
end

function SWEP:Deploy()
	self:SetNextPrimaryFire(CurTime() + 1)
	self:SetNextSecondaryFire(CurTime() + 1)
	self:SendWeaponAnim(ACT_VM_DRAW)

	return true
end

-- 
function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
	return false
end

--[[*******************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378

	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Don't come to me 
		with basic Lua questions.

		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.

		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
*******************************************************]]
function SWEP:Initialize()
	-- other initialize code goes here
	self:SetHoldType(self.HoldType)
	if CLIENT then
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy(self.VElements)
		self.WElements = table.FullCopy(self.WElements)
		self.ViewModelBoneMods = table.FullCopy(self.ViewModelBoneMods)
		self:CreateModels(self.VElements) -- create viewmodels
		self:CreateModels(self.WElements) -- create worldmodels

		-- init view model bone build function
		local owner = self:GetOwner()

		if IsValid(owner) then
			local vm = owner:GetViewModel()

			if IsValid(vm) then
				self:ResetBonePositions(vm)

				-- Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255, 255, 255, 255))
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255, 255, 255, 1))
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")
				end
			end
		end
	end
end

function SWEP:Holster()
	local owner = self:GetOwner()

	if CLIENT and IsValid(owner) then
		local vm = owner:GetViewModel()

		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end

	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then
	SWEP.vRenderOrder = nil

	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid(vm) then return end
		if (not self.VElements) then return end
		self:UpdateBonePositions(vm)

		if (not self.vRenderOrder) then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs(self.VElements) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
		end

		for k, name in ipairs(self.vRenderOrder) do
			local v = self.VElements[name]

			if (not v) then
				self.vRenderOrder = nil
				break
			end

			if (v.hide) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if (not v.bone) then continue end
			local pos, ang = self:GetBoneOrientation(self.VElements, v, vm)
			if (not pos) then continue end

			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() ~= v.material) then
					model:SetMaterial(v.material)
				end

				if (v.skin and v.skin ~= model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for kk, vv in pairs(v.bodygroup) do
						if (model:GetBodygroup(k) ~= v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
				render.SetBlend(v.color.a / 255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				cam.Start3D2D(drawpos, ang, v.size)
				v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil

	function SWEP:DrawWorldModel()
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end

		if (not self.WElements) then return end

		if (not self.wRenderOrder) then
			self.wRenderOrder = {}

			for k, v in pairs(self.WElements) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end
		end

		local owner = self:GetOwner()

		if (IsValid(owner)) then
			bone_ent = owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end

		for k, name in pairs(self.wRenderOrder) do
			local v = self.WElements[name]

			if (not v) then
				self.wRenderOrder = nil
				break
			end

			if (v.hide) then continue end
			local pos, ang

			if (v.bone) then
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent)
			else
				pos, ang = self:GetBoneOrientation(self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand")
			end

			if (not pos) then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial

			if (v.type == "Model" and IsValid(model)) then
				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z)
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				model:SetAngles(ang)
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix("RenderMultiply", matrix)

				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() ~= v.material) then
					model:SetMaterial(v.material)
				end

				if (v.skin and v.skin ~= model:GetSkin()) then
					model:SetSkin(v.skin)
				end

				if (v.bodygroup) then
					for kk, vv in pairs(v.bodygroup) do
						if (model:GetBodygroup(k) ~= v) then
							model:SetBodygroup(k, v)
						end
					end
				end

				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end

				render.SetColorModulation(v.color.r / 255, v.color.g / 255, v.color.b / 255)
				render.SetBlend(v.color.a / 255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)

				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
			elseif (v.type == "Sprite" and sprite) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
			elseif (v.type == "Quad" and v.draw_func) then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				cam.Start3D2D(drawpos, ang, v.size)
				v.draw_func(self)
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation(basetab, tab, ent, bone_override)
		local bone, pos, ang

		if (tab.rel and tab.rel ~= "") then
			local v = basetab[tab.rel]
			if (not v) then return end
			-- Technically, if there exists an element with the same name as a bone
			-- you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation(basetab, v, ent)
			if (not pos) then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
		else
			bone = ent:LookupBone(bone_override or tab.bone)
			if (not bone) then return end
			pos, ang = Vector(0, 0, 0), Angle(0, 0, 0)
			local m = ent:GetBoneMatrix(bone)

			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end

			local owner = self:GetOwner()

			if (IsValid(owner) and owner:IsPlayer() and ent == owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end

		return pos, ang
	end

	function SWEP:CreateModels(tab)
		if (not tab) then return end

		-- Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs(tab) do
			if (v.type == "Model" and v.model and v.model ~= "" and (not IsValid(v.modelEnt) or v.createdModel ~= v.model) and string.find(v.model, ".mdl") and file.Exists(v.model, "GAME")) then
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)

				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif (v.type == "Sprite" and v.sprite and v.sprite ~= "" and (not v.spriteMaterial or v.createdSprite ~= v.sprite) and file.Exists("materials/" .. v.sprite .. ".vmt", "GAME")) then
				local name = v.sprite .. "-"

				local params = {
					["$basetexture"] = v.sprite
				}

				-- make sure we create a unique name based on the selected options
				local tocheck = {"nocull", "additive", "vertexalpha", "vertexcolor", "ignorez"}

				for i, j in pairs(tocheck) do
					if (v[j]) then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name, "UnlitGeneric", params)
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		if self.ViewModelBoneMods then
			if (not vm:GetBoneCount()) then return end
			-- !! WORKAROUND !! //
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods

			if (not hasGarryFixedBoneScalingYet) then
				allbones = {}

				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)

					if (self.ViewModelBoneMods[bonename]) then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector(1, 1, 1),
							pos = Vector(0, 0, 0),
							angle = Angle(0, 0, 0)
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! //
			for k, v in pairs(loopthrough) do
				local bone = vm:LookupBone(k)
				if (not bone) then continue end
				-- !! WORKAROUND !! //
				local s = Vector(v.scale.x, v.scale.y, v.scale.z)
				local p = Vector(v.pos.x, v.pos.y, v.pos.z)
				local ms = Vector(1, 1, 1)

				if (not hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)

					while (cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end

				s = s * ms

				-- !! ----------- !! //
				if vm:GetManipulateBoneScale(bone) ~= s then
					vm:ManipulateBoneScale(bone, s)
				end

				if vm:GetManipulateBoneAngles(bone) ~= v.angle then
					vm:ManipulateBoneAngles(bone, v.angle)
				end

				if vm:GetManipulateBonePosition(bone) ~= p then
					vm:ManipulateBonePosition(bone, p)
				end
			end
		else
			self:ResetBonePositions(vm)
		end
	end

	function SWEP:ResetBonePositions(vm)
		if (not vm:GetBoneCount()) then return end

		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale(i, Vector(1, 1, 1))
			vm:ManipulateBoneAngles(i, Angle(0, 0, 0))
			vm:ManipulateBonePosition(i, Vector(0, 0, 0))
		end
	end

	--[[*************************
		Global utility code
	*************************]]
	-- Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	-- Does not copy entities of course, only copies their reference.
	-- WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy(tab)
		if (not tab) then return nil end
		local res = {}

		for k, v in pairs(tab) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) -- recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end

		return res
	end
end

--lua/weapons/weapon_csgo_knife_bayonet.lua:
if SERVER then
	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

if CLIENT then							
	SWEP.Slot				= SWEP.WeaponSlot or 0
	SWEP.SlotPos			= 0
	SWEP.ViewModelFOV		= 60
	SWEP.DrawCrosshair		= true
end

SWEP.Base					= "weapon_csgobase_knife"

SWEP.PrintName				= "Bayonet"
SWEP.Category				= "CS:GO Knives"
SWEP.Spawnable				= true
SWEP.AdminOnly				= false
SWEP.ViewModel				= Model( "models/weapons/knife_bayonet/v_bayonet.mdl" )
SWEP.WorldModel				= Model( "models/weapons/knife_bayonet/w_bayonet.mdl" )
SWEP.HoldType				= "knife"
--lua/weapons/weapon_csgo_knife_default_t.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_flip.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_gold_ct.lua:
return gluapack()()
--lua/weapons/weapon_csgo_knife_skeleton.lua:
if SERVER then
	SWEP.Weight				= 5
	SWEP.AutoSwitchTo		= false
	SWEP.AutoSwitchFrom		= false
end

if CLIENT then							
	SWEP.Slot				= SWEP.WeaponSlot or 0
	SWEP.SlotPos			= 0
	SWEP.ViewModelFOV		= 60
	SWEP.DrawCrosshair		= true
end

SWEP.Base					= "weapon_csgobase_knife"

SWEP.PrintName				= "Skeleton Knife"
SWEP.Category				= "CS:GO Knives"
SWEP.Spawnable				= true
SWEP.AdminOnly				= false
SWEP.ViewModel				= Model( "models/weapons/knife_skeleton/v_skeleton.mdl" )
SWEP.WorldModel				= Model( "models/weapons/knife_skeleton/w_skeleton.mdl" )
SWEP.HoldType				= "knife"
--lua/weapons/weapon_fuelpumpcreator/cl_init.lua:
include("shared.lua")

function SWEP:DrawHUD()
	local xCenter = ScrW() / 2
	local yCenter = ScrH() / 2

	surface.SetDrawColor(18, 25, 31, 200)
	surface.DrawRect(xCenter - 270, yCenter - 50, 540, 100)

	draw.DrawText(language.GetPhrase("svmod.creator_pistol.create"), "DermaLarge", xCenter, yCenter - 48, Color(255, 255, 255), TEXT_ALIGN_CENTER)
	draw.DrawText(language.GetPhrase("svmod.creator_pistol.edit"), "DermaLarge", xCenter, yCenter - 16, Color(255, 255, 255), TEXT_ALIGN_CENTER)
	draw.DrawText(language.GetPhrase("svmod.creator_pistol.remove"), "DermaLarge", xCenter, yCenter + 16, Color(255, 255, 255), TEXT_ALIGN_CENTER)
end
--addons/vape_swep/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--addons/vape_swep/lua/weapons/weapon_vape_american.lua:
-- weapon_vape_american.lua
-- Defines a vape which emits red, white, and blue clouds and plays Donald Trump sounds

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "American Vape"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB: Bing Bong\nReload: MAGA\n\nA patriotic vape made in honor of President Trump."

SWEP.VapeID = 7
SWEP.VapeAccentColor = Vector(0.5,0.5,0.5)

--tells the matproxy to substitute red/white/blue fader (todo: change how this works)
SWEP.VapeTankColor = Vector(-2,-2,-2)

function SWEP:SecondaryAttack()
	--this makes it so the "bing bong" sounds the same to everyone instead of the owner hearing a different noise due to randomness
	if CLIENT then return else SuppressHostEvents(NULL) end

	--if self:CanSecondaryAttack() == false then return end

	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapebing"..tostring(math.random(1,2))..".wav", 40, pitch + math.Rand(-25,25))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.9*100/pitch))
		net.Broadcast()
	end
	self:SetNextSecondaryFire(CurTime() + 3)
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	if self.beklemesuresi then 
		if self.beklemesuresi > CurTime() then 
			return
		end 
	end 
	if self.reloading then return end
	self.reloading=true
	self.beklemesuresi = CurTime() + 5
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapemaga.wav", 30, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end
--addons/vape_swep/lua/weapons/weapon_vape_butterfly.lua:
-- weapon_vape_buttefly.lua
-- Defines a vape that flips like a butterfly knife

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Butterfly Vape"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nA stealthy vape for masters of vape-jitsu."

SWEP.VapeAccentColor = Vector(0.2,0.2,0.3)
SWEP.VapeTankColor = Vector(0.1,0.1,0.1)

SWEP.VapeVMAng2 = Vector(360+170,720-108,132)
--addons/vape_swep/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--addons/vape_swep/lua/weapons/weapon_vape_hallucinogenic.lua:
return gluapack()()
--addons/vape_swep/lua/weapons/weapon_vape/cl_init.lua:
return gluapack()()
--addons/vape_swep/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 35, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
	self:SetNextSecondaryFire(CurTime() + 4)
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	if self.beklemesuresi then 
		if self.beklemesuresi > CurTime() then 
			return 
		end 
	end 
	if self.reloading then return end
	self.reloading=true
	self.beklemesuresi = CurTime() + 5
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 35, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/vape_swep/lua/weapons/weapon_vape/cl_init.lua:
return gluapack()()
--addons/vape_swep/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 35, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
	self:SetNextSecondaryFire(CurTime() + 4)
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	if self.beklemesuresi then 
		if self.beklemesuresi > CurTime() then 
			return 
		end 
	end 
	if self.reloading then return end
	self.reloading=true
	self.beklemesuresi = CurTime() + 5
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 35, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/zeros_growop2_v1.6.1/lua/weapons/zgo2_joint/cl_init.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

include("shared.lua")
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true

function SWEP:Initialize()
	zgo2.Joint.Initialize(self)
end

function SWEP:DrawHUD()
	zgo2.Joint.DrawHUD(self)
end

function SWEP:Think()
	zgo2.Joint.Think(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

function SWEP:SecondaryAttack()
	self:SetNextSecondaryFire(CurTime() + 1)
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + 1)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

function SWEP:Holster()
	zgo2.Joint.Holster(self)
end

function SWEP:OnRemove()
	zgo2.Joint.OnRemove(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595

--addons/zeros_growop2_v1.6.1/lua/weapons/zgo2_multitool/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

SWEP.PrintName = "Shop Tablet"
SWEP.Author = "ZeroChain"
SWEP.Instructions = ""
SWEP.Contact = ""
SWEP.Purpose = "Does a lot of things."
SWEP.AdminSpawnable = false
SWEP.Spawnable = true
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

SWEP.AutomaticFrameAdvance = true
SWEP.ViewModelFOV = 90
SWEP.ViewModel = "models/zerochain/props_growop2/zgo2_tablet_vm.mdl"
SWEP.WorldModel = "models/zerochain/props_growop2/zgo2_tablet.mdl"
SWEP.UseHands = true
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

//SWEP.AutoSwitchTo = false
//SWEP.AutoSwitchFrom = true
SWEP.Slot = 1
SWEP.SlotPos = 1
SWEP.HoldType = "normal"
SWEP.FiresUnderwater = false
SWEP.Weight = 5
SWEP.DrawCrosshair = true
SWEP.Category = "Zeros GrowOP 2"
SWEP.DrawAmmo = false
SWEP.base = "weapon_base"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 0.25
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Recoil = 1
SWEP.Secondary.Delay = 1

if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("zerochain/zgo2/vgui/zgo2_multitool")
end

--addons/zeros_methlab_1.6.4/lua/weapons/zmlab_extractor/shared.lua:
SWEP.PrintName = "Meth Extractor" -- The name of your SWEP
SWEP.Author = "Zero" -- Your name
SWEP.Instructions = "LMB - Extracts a small Portion of Meth"
SWEP.Contact = "YourMailAdress" -- How people should contact you if they find bugs, errors, etc
SWEP.Purpose = "WhatsThePurposeOfThisSwep" -- What is the purpose of the SWEP?
SWEP.AdminSpawnable = false -- Is the SWEP spawnable for admins?
SWEP.Spawnable = true -- Can everybody spawn this SWEP? - If you want only admins to spawn it, keep this false and admin spawnable true.
SWEP.ViewModelFOV = 55 -- How much of the weapon do you see?
SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/weapons/w_crowbar.mdl"
SWEP.AutoSwitchTo = false -- When someone picks up the SWEP, should it automatically change to your SWEP?
SWEP.AutoSwitchFrom = true -- Should the weapon change to the a different SWEP if another SWEP is picked up?
SWEP.Slot = 1 -- Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6)
SWEP.SlotPos = 1 -- Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.HoldType = "melee2" -- How is the SWEP held? (Pistol SMG Grenade Melee)
SWEP.FiresUnderwater = false -- Does your SWEP fire under water?
SWEP.Weight = 5 -- Set the weight of your SWEP.
SWEP.DrawCrosshair = true -- Do you want the SWEP to have a crosshair?
SWEP.Category = "Zeros Meth Lab"
SWEP.DrawAmmo = false -- Does the ammo show up when you are using it? True / False
SWEP.base = "weapon_base" --What your weapon is based on.
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 1
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Recoil = 1
SWEP.Secondary.Delay = 2
SWEP.UseHands = false

--addons/spzones/lua/weapons/zones_tool/shared.lua:
AddCSLuaFile("shared.lua")
SWEP.PrintName = "SP Zones"
SWEP.Author = "Splash"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.Primary.ClipSize = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.ShootSound = Sound("Airboat.FireGunRevDown")
SWEP.ViewModel = "models/weapons/v_pistol.mdl"
SWEP.WorldModel = "models/weapons/w_357.mdl"
SWEP.UseHands = false
SWEP.Category = "Splash"
SWEP.DrawAmmo = false
--addons/zeros_retrominer_v2.3.6/lua/weapons/zrms_builder/cl_init.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/weapons/zrms_builder/cl_init.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

include("shared.lua")
include("zrmine_config.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

SWEP.PrintName = "Builder" // The name of your SWEP
SWEP.Slot = 1
SWEP.SlotPos = 2
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true // Do you want the SWEP to have a crosshair?

local wMod = ScrW() / 1920
local hMod = ScrH() / 1080


local iconSize01 = 120
local iconSize02 = 100
local iconSize03 = 130

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	self.LastItem = -1
end

function SWEP:DrawHUD()

	//draw.RoundedBox(5, 560 * wMod , 1027 * hMod , 800 * wMod, 45 * hMod, zrmine.default_colors["Gold"])
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	draw.RoundedBox(5, 560 * wMod , 1027 * hMod , 235 * wMod, 45 * hMod, zrmine.default_colors["grey03"])
	draw.RoundedBox(5, 800 * wMod , 1027 * hMod , 320 * wMod, 45 * hMod, zrmine.default_colors["grey03"])
	draw.RoundedBox(5, 1125 * wMod , 1027 * hMod , 235 * wMod, 45 * hMod, zrmine.default_colors["grey03"])


	draw.RoundedBox(5, 563 * wMod , 1029 * hMod , 230 * wMod, 41 * hMod, zrmine.default_colors["grey07"])
	draw.RoundedBox(5, 803 * wMod , 1029 * hMod , 315 * wMod, 41 * hMod, zrmine.default_colors["grey07"])
	draw.RoundedBox(5, 1128 * wMod , 1029 * hMod , 230 * wMod, 41 * hMod, zrmine.default_colors["grey07"])




	// Shawdow
	local lKey = string.upper(language.GetPhrase(input.GetKeyName(zrmine.config.BuilderSWEP.keys.switch_left)))
	local rKey = string.upper(language.GetPhrase(input.GetKeyName(zrmine.config.BuilderSWEP.keys.switch_right)))

	draw.SimpleText("LMB: " .. zrmine.language.Buy, "zrmine_builder_font1_shadow", 675 * wMod, 1065 * hMod, zrmine.default_colors["black02"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
	draw.SimpleText("◀ [ " .. lKey .. " ] " .. zrmine.language.SwitchItem .. " [ " .. rKey .. " ] ▶", "zrmine_builder_font1_shadow", 960 * wMod, 1065 * hMod, zrmine.default_colors["black02"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
	draw.SimpleText("RMB: " .. zrmine.language.Sell, "zrmine_builder_font1_shadow", 1243 * wMod, 1065 * hMod, zrmine.default_colors["black02"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)


	// Main text
	draw.SimpleText("LMB: " .. zrmine.language.Buy, "zrmine_builder_font1", 675 * wMod, 1065 * hMod, zrmine.default_colors["grey03"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
	draw.SimpleText("◀ [ " .. lKey .. " ] " .. zrmine.language.SwitchItem .. " [ " .. rKey .. " ] ▶", "zrmine_builder_font1", 960 * wMod, 1065 * hMod, zrmine.default_colors["grey03"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
	draw.SimpleText("RMB: " .. zrmine.language.Sell, "zrmine_builder_font1", 1243 * wMod, 1065 * hMod, zrmine.default_colors["grey03"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)


	local c_selectedItem = self:GetItemSelected()

	// Makes a click sound
	if self.LastItem ~= c_selectedItem then
		surface.PlaySound("UI/buttonclick.wav")
		self.LastItem = c_selectedItem
	end

	local p_selectedItem = c_selectedItem - 1
	if p_selectedItem <= 0 then
		p_selectedItem = table.Count(zrmine.Swep_BuildItems)
	end

	local pp_selectedItem = p_selectedItem - 1
	if pp_selectedItem <= 0 then
		pp_selectedItem = table.Count(zrmine.Swep_BuildItems)
	end

	local n_selectedItem = c_selectedItem + 1
	if n_selectedItem > table.Count(zrmine.Swep_BuildItems) then
		n_selectedItem = 1
	end

	local nn_selectedItem = n_selectedItem + 1
	if nn_selectedItem > table.Count(zrmine.Swep_BuildItems) then
		nn_selectedItem = 1
	end


	draw.RoundedBox(5, (960 - iconSize03 / 2) * wMod, (949 - iconSize03 / 2) * hMod, iconSize03 * wMod, iconSize03 * hMod, zrmine.default_colors["orange03"])


	// Mid
	surface.SetDrawColor(zrmine.default_colors["white02"])
	surface.SetMaterial(zrmine.Swep_BuildItems[c_selectedItem].icon)
	surface.DrawTexturedRect((960 - iconSize01 / 2) * wMod, (950 - iconSize01 / 2) * hMod, iconSize01 * wMod, iconSize01 * hMod)
	draw.NoTexture()

	local itemData = zrmine.Swep_BuildItems[c_selectedItem]
	draw.SimpleTextOutlined(zrmine.config.Currency .. zrmine.config.BuilderSWEP.entity_price[itemData.class], "zrmine_pickaxe_font1", 960 * wMod, 1005 * hMod, zrmine.default_colors["money01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 1, zrmine.default_colors["money02"])


	// Pre
	surface.SetDrawColor(zrmine.default_colors["grey06"])
	surface.SetMaterial(zrmine.Swep_BuildItems[p_selectedItem].icon)
	surface.DrawTexturedRect(((960 - 150) - iconSize02 / 2) * wMod, (950 - iconSize02 / 2) * hMod, iconSize02 * wMod, iconSize02 * hMod)
	draw.NoTexture()

	//PrePre
	surface.SetDrawColor(zrmine.default_colors["grey06"])
	surface.SetMaterial(zrmine.Swep_BuildItems[pp_selectedItem].icon)
	surface.DrawTexturedRect(((960 - 300) - iconSize02 / 2) * wMod, (950 - iconSize02 / 2) * hMod, iconSize02 * wMod, iconSize02 * hMod)
	draw.NoTexture()



	// Next
	surface.SetDrawColor(zrmine.default_colors["grey06"])
	surface.SetMaterial(zrmine.Swep_BuildItems[n_selectedItem].icon)
	surface.DrawTexturedRect(((960 + 150) - iconSize02 / 2) * wMod, (950 - iconSize02 / 2) * hMod, iconSize02 * wMod, iconSize02 * hMod)
	draw.NoTexture()


	// NextNext
	surface.SetDrawColor(zrmine.default_colors["grey06"])
	surface.SetMaterial(zrmine.Swep_BuildItems[nn_selectedItem].icon)
	surface.DrawTexturedRect(((960 + 300) - iconSize02 / 2) * wMod, (950 - iconSize02 / 2) * hMod, iconSize02 * wMod, iconSize02 * hMod)
	draw.NoTexture()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

// Build Entity
function SWEP:PrimaryAttack()
	self:SendWeaponAnim(ACT_SLAM_THROW_TO_STICKWALL)
	self.Owner:SetAnimation(PLAYER_ATTACK1)
end

// Deconstruct Entity
function SWEP:SecondaryAttack()
	self:SendWeaponAnim(ACT_SLAM_THROW_DETONATE)
	self.Owner:SetAnimation(PLAYER_ATTACK1)
end

// Switch Item to build
function SWEP:Reload()
	self:SendWeaponAnim(ACT_VM_RELOAD)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function SWEP:Deploy()
	self:SendWeaponAnim(ACT_SLAM_DETONATOR_DRAW)
end

function SWEP:Holster()
	self:SendWeaponAnim(ACT_SLAM_DETONATOR_HOLSTER)

end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function SWEP:Equip()
	self:SendWeaponAnim(ACT_VM_DRAW)
	self.Owner:SetAnimation(PLAYER_IDLE)
end

--addons/zeros_retrominer_v2.3.6/lua/zrmine_config.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

zrmine = zrmine || {}
zrmine.config = zrmine.config || {}

/////////////////////////// Zeros RetroMiner /////////////////////////////

// Developed by ZeroChain:
// http://steamcommunity.com/id/zerochain/
// https://www.gmodstore.com/users/view/76561198013322242
// https://www.artstation.com/zerochain

/////////////////////////////////////////////////////////////////////////////


// Misc
///////////////////////
// This enables fast download
zrmine.config.EnableResourceAddfile = false

// These Ranks are allowed do use the Chat and Console Commands
zrmine.config.AdminRanks = {
	["superadmin"] = true,
	["owner"] = true,
}

// This tells the script who can mine ore / sell bars (Leave empty to allow everyone)
zrmine.config.Jobs = {
	[TEAM_ZRMINE_MINER] = true
}


// This disables a net message being send to client for the ore insert effect
zrmine.config.DisableVFX = true


// Level System IngGame Config ConsoleCommand: zrms_levelsystem_open

// Chat Commands
//  !zrms_lvlsys_reset SteamID
//  !zrms_lvlsys_xp SteamID Amount
//  !zrms_lvlsys_lvl SteamID Amount

// Console Commands
//  zrms_lvlsys_reset SteamID
//  zrms_lvlsys_xp SteamID Amount
//  zrms_lvlsys_lvl SteamID Amount

// What language do we want? en,de,fr,pl,it,ru,pt,es,cn,dk
zrmine.config.selectedLanguage = "en"

// Currency Display
zrmine.config.Currency = "₺"

// Mass Display
zrmine.config.BuyerNPC_Mass = "kg"

// Disables the Owner Checks so everyone can use everyones mining entities
// Note* This should be on true if you want to use the Entities as a Public utility
zrmine.config.SharedOwnership = false

// The Damage the entitys have do take before they get destroyed.
// Setting it to -1 disables it
zrmine.config.Damageable = {}
zrmine.config.Damageable["MineEntrance"] = {EntityHealth = 1000}
zrmine.config.Damageable["Melter"] = {EntityHealth = 500}
zrmine.config.Damageable["Crusher"] = {EntityHealth = 300}
zrmine.config.Damageable["Refinery"] = {EntityHealth = 300}
zrmine.config.Damageable["Conveyorbelt"] = {EntityHealth = 200}
zrmine.config.Damageable["Splitter"] = {EntityHealth = 200}
zrmine.config.Damageable["Sorter"] = {EntityHealth = 200}

// Some debug information
zrmine.config.debug = false
///////////////////////


// The Builder SWEP
///////////////////////
zrmine.config.BuilderSWEP = {

	keys = {
		switch_left = KEY_E,
		switch_right = KEY_R
	},

	// The money the player receives if he deconstructs a entity
	refund_val = 0.5, // 1 = Full , 0.5 = half, 0 = no money back

	// The entity price
	entity_price = {
		["zrms_conveyorbelt_n"] = 150,
		["zrms_conveyorbelt_s"] = 100,
		["zrms_conveyorbelt_c_left"] = 250,
		["zrms_conveyorbelt_c_right"] = 250,

		["zrms_crusher"] = 1000,
		["zrms_splitter"] = 1500,
		["zrms_inserter"] = 1500,

		["zrms_refiner_coal"] = 1500,
		["zrms_refiner_iron"] = 2000,
		["zrms_refiner_bronze"] = 3000,
		["zrms_refiner_silver"] = 4000,
		["zrms_refiner_gold"] = 5000,

		["zrms_sorter_coal"] = 1500,
		["zrms_sorter_iron"] = 2000,
		["zrms_sorter_bronze"] = 3000,
		["zrms_sorter_silver"] = 4000,
		["zrms_sorter_gold"] = 5000
	},

	// How many entites is the player allowed to spawn/buy
	entity_limit = {
		["zrms_conveyorbelt_n"] = 10,
		["zrms_conveyorbelt_s"] = 6,
		["zrms_conveyorbelt_c_left"] = 6,
		["zrms_conveyorbelt_c_right"] = 6,

		["zrms_crusher"] = 2,
		["zrms_splitter"] = 4,
		["zrms_inserter"] = 4,

		["zrms_refiner_coal"] = 2,
		["zrms_refiner_iron"] = 2,
		["zrms_refiner_bronze"] = 2,
		["zrms_refiner_silver"] = 2,
		["zrms_refiner_gold"] = 2,

		["zrms_sorter_coal"] = 2,
		["zrms_sorter_iron"] = 2,
		["zrms_sorter_bronze"] = 2,
		["zrms_sorter_silver"] = 2,
		["zrms_sorter_gold"] = 2
	},
}
///////////////////////




// The Pickaxe
///////////////////////

// The Level System
// If set to true then the data gets writen into sv.db
// If set to false then we write the player data as file at garrysmod\data\zrms\playerdata
zrmine.config.Pickaxe_UseDB = false

// This command migrates data from sv.db to file (It only migrates the data from online players and only if it doesent allready exist as file)
// Console Command: zrms_levelsystem_migrate_data_to_file

// This is the Time in seconds that the Level system gets saved each player it changed
zrmine.config.Pickaxe_LvlSys_SaveTime = 500

// How long after the player has spawned should we wait till we load his Pickaxe Level Data
zrmine.config.Pickaxe_LvlSys_Init_LoadTime = 5

/*
Examble: zrmine.config.Pickaxe_Lvl[Level] =
    {
    NextXP = Amount of XP Needed for the next Level up,
    HarvestAmount = Amount of Resource Harvested per Hit in Kg,
    HarvestInterval = Hit interval ,
    OreInv = Your Pickaxe Ore Inventory Capacity,
    FillCap = The Amount of or you can fill in a Crusher or crate per Right Click
    }
*/
zrmine.config.Pickaxe_Lvl = {}
zrmine.config.Pickaxe_Lvl[0] = {NextXP = 100, HarvestAmount = 0.1, HarvestInterval = 1.3 , OreInv = 10, FillCap = 3}
zrmine.config.Pickaxe_Lvl[1] = {NextXP = 200, HarvestAmount = 0.5, HarvestInterval = 1 , OreInv = 15, FillCap = 5}
zrmine.config.Pickaxe_Lvl[2] = {NextXP = 400, HarvestAmount = 1, HarvestInterval = 0.9 , OreInv = 20, FillCap = 10}
zrmine.config.Pickaxe_Lvl[3] = {NextXP = 500, HarvestAmount = 2, HarvestInterval = 0.75 , OreInv = 25, FillCap = 15}
zrmine.config.Pickaxe_Lvl[4] = {NextXP = 1000, HarvestAmount = 4, HarvestInterval = 0.6 , OreInv = 35, FillCap = 20}
zrmine.config.Pickaxe_Lvl[5] = {NextXP = 1500, HarvestAmount = 5, HarvestInterval = 0.5 , OreInv = 50, FillCap = 25}

// Here you can set what Ore Ressource requires what Pickaxe Level
zrmine.config.Pickaxe_OreRestriction = {
	["Coal"] = 0,
	["Iron"] = 0,
	["Bronze"] = 0,
	["Silver"] = 0,
	["Gold"] = 0,
	["Random"] = 0,
}


// How many pickaxe hits before we get another XP
zrmine.config.Pickaxe_MaxNextXP = 10
zrmine.config.Pickaxe_MinNextXP = 5

// What Color Theme should the Pickaxe UI have
zrmine.config.PickaxeThemeLight = false

// This Defines a offset for the main UI of the Pickaxe
zrmine.config.PickaxeUI_Offset = Vector(0,0,0)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

// Defines the harvest chance in % per Hit
zrmine.config.Pickaxe_HarvestChance = 75 //1-100% 75% means we have a 25% chance of getting no resource

// This Values are % Multiplicators for the diffrend resource types
// *Note* Examble : Amount: 0.5% = -50% You get only half the amount per hit   Speed: 1.3% = +30% more time needed do harvest
zrmine.config.Pickaxe_HarvestMul = {}
zrmine.config.Pickaxe_HarvestMul["Random"] = {Amount = 0.5, Speed = 1.3,XP = 2}
zrmine.config.Pickaxe_HarvestMul["Coal"] =  {Amount = 1.3, Speed = 0.5,XP = 1}
zrmine.config.Pickaxe_HarvestMul["Iron"] = {Amount = 1.2, Speed = 0.7,XP = 1}
zrmine.config.Pickaxe_HarvestMul["Bronze"] = {Amount = 0.6, Speed = 1,XP = 1}
zrmine.config.Pickaxe_HarvestMul["Silver"] = {Amount = 0.5, Speed = 1.1,XP = 2}
zrmine.config.Pickaxe_HarvestMul["Gold"] = {Amount = 0.25, Speed = 1.5,XP = 3}
///////////////////////



// The Bar
///////////////////////

/*
// Real Metal Price (This is for Reference only and does not change anything inGame)
local Gold_1kg = 48000  //$
local Silver_1kg = 630  //$
local Bronze_1kg = 18   //$
local Iron_1kg = 0.80   //$
*/
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

local Gold_1kg = 160    //$
local Silver_1kg = 85   //$
local Bronze_1kg = 35   //$
local Iron_1kg = 20 //$

local Mass_per_Bar = 15

// The Cash Value of 1 bar
zrmine.config.BarValue = {}
zrmine.config.BarValue["Iron"] = Iron_1kg * Mass_per_Bar
zrmine.config.BarValue["Bronze"] = Bronze_1kg * Mass_per_Bar
zrmine.config.BarValue["Silver"] = Silver_1kg * Mass_per_Bar
zrmine.config.BarValue["Gold"] = Gold_1kg * Mass_per_Bar

// Does the storage crate need do be full before it can be collected
zrmine.config.StorageCrateFull = false

zrmine.config.MetalBar_Stealing = {

	// Can other Players steal the Bars or the storagecrate?
	Enabled = false,

	// These Jobs can steal metalbars and storagecrates. (Leave empty to allow everyone to steal)
	// You probably also want to add the job names to zrmine.config.Jobs so these Jobs can also sell the metal bars
	Jobs = {
		//[TEAM_GANG] = true,
	}
}

// Do we want the metal bars from the players inventory to drop on death?
zrmine.config.MetalBar_DropOnDeath = false
///////////////////////



// The Buyer NPC
///////////////////////
zrmine.config.MetalBuyer = {

	// Model of the NPC
	model = "models/Humans/Group03/male_07.mdl",
	// Note* You need do make sure the Model got compiled with the animations you want to use
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	// The Idle Animations of the Buyer NPC
	anim_idle = {"idle_angry","idle_subtle"},

	// The Sell Animations of the Buyer NPC
	anim_sell = {"takepackage","cheer1","cheer2"},

	// This is the time in seconds the buyer npcs refresh their buy rate
	RefreshRate = 600, //seconds

	// This defines the range at which some Buyers gonna buy your metals
	MaxRate = 150, //%
	MinRate = 75, //%
}
///////////////////////



// The Resource Junk
///////////////////////
// This Values Defines the Despawn Time in seconds, set to -1 do Disable it
zrmine.config.Resource_DespawnTime = 200
///////////////////////

                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 


// The Ore Spawns
///////////////////////

// Do we want the Ore Spawns do refresh?
zrmine.config.Ore_Refresh = true

// How often do we want do refresh the ore spawns?
zrmine.config.Ore_Refreshrate = 15

// How much gets refreshed?
zrmine.config.Ore_RefreshAmount = 200 //kg
///////////////////////



// The Mine
///////////////////////

// If you want do set the name of the Mine Entrance yourself rather then using the player name
// This can be usefull if the MineEntrace is public
// Set this to nil if you dont want to use Public Mining Entities
zrmine.config.Mine_CustomName = nil

// Defines the chance in % what the MineEntrance Enity gives you
zrmine.config.Mine_ResourceChance = {}
zrmine.config.Mine_ResourceChance["Coal"] = 35
zrmine.config.Mine_ResourceChance["Iron"] = 30
zrmine.config.Mine_ResourceChance["Bronze"] = 15
zrmine.config.Mine_ResourceChance["Silver"] = 10
zrmine.config.Mine_ResourceChance["Gold"] = 5

// This Value Defines the Mining Time in seconds for the MineEntrace Entity
zrmine.config.MiningTime = {}
zrmine.config.MiningTime["Random"] = 30
zrmine.config.MiningTime["Coal"] = 15
zrmine.config.MiningTime["Iron"] = 30

zrmine.config.MiningTime["Bronze"] = 40
zrmine.config.MiningTime["Silver"] = 50
zrmine.config.MiningTime["Gold"] = 60

// The Ore Search distance of the Mine
zrmine.config.Mine_SearchDistance = 400

// This Value Defines the Amount one Minning Load gives the player in kg
zrmine.config.Max_MiningAmount = 45
zrmine.config.Min_MiningAmount = 15

// This defines how many ore entites 1 mine is allowed to spawn until it tells the user to refine some of the allready spawned ore
zrmine.config.Mine_MaxEntCount = 6
///////////////////////



// The Conveyorbelt
///////////////////////
zrmine.config.Belt_Capacity = 15
zrmine.config.SplitterBelt_Capacity = 25
///////////////////////


                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

// The Inserter
///////////////////////
// Should Resources be deleted when no module is connected
zrmine.config.Inserter_DeleteOnEndPoint = true
//*Note* When a ressource reeaches the end of a inserter belt then it either gets Deleted or outputed as gravel entity
// By putting a GravelCrate near the inserter end point you can collect the moved ressource rather then it getting destroyed.

// This defines the loss rate of the ore when transported via inserter.
// 0 = No loss at all.  0.5 = Half of the Ore gets lost.
zrmine.config.Inserter_LossRate = 0.25  // 0 - 0.9
///////////////////////



// The Crusher
///////////////////////

// Whats the crush process duration
zrmine.config.Crusher_Time = 4

// Whats the work amount
zrmine.config.Crusher_WorkAmount = 2

// Whats the crusher inventory capacity?
zrmine.config.Crusher_Capacity = 100
///////////////////////



// The Gravel Crate
///////////////////////

// The Capacity of the Crates
zrmine.config.GravelCrates_Capacity = 100

// Do we want do reuse the gravel crates or should they get deleted when emtpy
zrmine.config.GravelCrates_ReUse = true
///////////////////////



// The Refiner Crate
///////////////////////
// Do we want that everyone can attach or detach the refiner basket
zrmine.config.ResourceCrates_Sharing = true
// The Capacity of the Crates
zrmine.config.ResourceCrates_Capacity = 50
// Do we want do reuse the crate or destroy it when emtpy
zrmine.config.ResourceCrates_ReUse = true
///////////////////////



// The Refiner
///////////////////////
// This Values Defines the Refining Time in seconds
zrmine.config.Gold_RefiningTime = 30
zrmine.config.Silver_RefiningTime = 15
zrmine.config.Bronze_RefiningTime = 10
zrmine.config.Iron_RefiningTime = 5
zrmine.config.Coal_RefiningTime = 5

// How much of the Refined ore is metal
zrmine.config.RefiningAmount = 0.75 // 75%

// The Ore Capacity of the Refiner
zrmine.config.Refiner_Capacity = 25

// Do we want to that a Refiner Crate spawns with the Refiner?
// Note* This only applys to Refiners used in a Public Pipeline!
zrmine.config.Refiner_AutoSpawnCrate = true
///////////////////////



// The Melter
///////////////////////
// The Coal Capacity of the Melter
zrmine.config.Melter_Coal_Capacity = 100

// The Unload Time
zrmine.config.Melter_UnloadTime = 10

zrmine.config.Melter_Vars = {}
zrmine.config.Melter_Vars["Iron"] = {OreAmount = 25, MeltDuration = 5,CoalAmount = 10,CoolingTime = 3}
zrmine.config.Melter_Vars["Bronze"] = {OreAmount = 15, MeltDuration = 10,CoalAmount = 15,CoolingTime = 5}
zrmine.config.Melter_Vars["Silver"] = {OreAmount = 10, MeltDuration = 15,CoalAmount = 20,CoolingTime = 7}
zrmine.config.Melter_Vars["Gold"] = {OreAmount = 1, MeltDuration = 20,CoalAmount = 25,CoolingTime = 10}
///////////////////////



// Vrondakis Leveling System
///////////////////////

// How much XP do we get for completing these Tasks
// *Note01 Only works if Vrondakis Leveling System is installed
// *Note02 Also needs Faclos or NaMad PropProtection script installed do determine the owner
zrmine.config.Vrondakis = {}
zrmine.config.Vrondakis["Mining_mine"] = {XP = 5} // Per Mine Load
zrmine.config.Vrondakis["Mining_pickaxe"] = {XP = 1} // Per Hit
zrmine.config.Vrondakis["Crushing"] = {XP = 1} // Per WorkLoad
zrmine.config.Vrondakis["Refining"] = {XP = 2} // Per WorkLoad
zrmine.config.Vrondakis["Melting"] = {XP = 10} // Per WorkLoad
zrmine.config.Vrondakis["Selling"] = {XP = 5} // Per Sell
///////////////////////

--addons/zeros_retrominer_v2.3.6/lua/zrmine_config.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/zrmine_config.lua:
return gluapack()()
--addons/aphone/lua/entities/aphone_npc/shared.lua:
ENT.Base = "base_ai"
ENT.Type = "ai"
ENT.PrintName = aphone.L("NPC_Name")
ENT.Category        = "APhone"
ENT.Author          = "Akulla"
ENT.Spawnable       = true
ENT.AdminSpawnable  = true
ENT.AdminOnly = true
ENT.ViewOffset = Vector(0,0,70)
ENT.RenderGroup = RENDERGROUP_BOTH
--addons/[binbon]arccw_modify/lua/entities/arccw_ammo_ar2.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"
ENT.RenderGroup               = RENDERGROUP_TRANSLUCENT

ENT.PrintName                 = "Rifle Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/rifle_ammo.mdl"

ENT.AmmoType = "ar2"
ENT.AmmoCount = 30

ENT.DetonationDamage = 50
ENT.DetonationRadius = 256
ENT.DetonationSound = "weapons/ar1/ar1_dist2.wav"
--lua/entities/arccw_ammo_plinking.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"
ENT.RenderGroup               = RENDERGROUP_TRANSLUCENT

ENT.PrintName                 = "Plinking Ammo"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/plinking_ammo.mdl"

ENT.AmmoType = "plinking"
ENT.AmmoCount = 100

ENT.DetonationDamage = 10
ENT.DetonationRadius = 128
ENT.DetonationSound = nil

DEFINE_BASECLASS(ENT.Base)
function ENT:DetonateRound()
    BaseClass.DetonateRound(self)
    self:EmitSound("weapons/pistol/pistol_fire2.wav", 70, 175, 0.8)
end
--addons/[binbon]arccw_modify/lua/entities/arccw_ammo_smg1_grenade_large.lua:
AddCSLuaFile()

ENT.Base                      = "arccw_ammo"

ENT.PrintName                 = "Rifle Grenade Box"
ENT.Category                  = "ArcCW - Ammo"

ENT.Spawnable                 = true
ENT.Model                     = "models/items/arccw/riflegrenade_ammo.mdl"
ENT.Health = 70

ENT.AmmoType = "smg1_grenade"
ENT.AmmoCount = 5

ENT.DetonationDamage = 100 -- Per-round damage
ENT.DetonationRadius = 300

function ENT:DetonateRound(attacker)
    local nade = ents.Create("arccw_gl_ammodet")
    nade:SetPos(self:GetPos())
    local v = self:GetUp():Angle() + AngleRand(-60, 60)
    nade:SetAngles(v)
    nade:Spawn()
    nade:GetPhysicsObject():AddVelocity(self:GetVelocity() + self:GetForward() * math.random(2000, 3000))
    nade:SetOwner(attacker or self.Burner)

    self.AmmoCount = self.AmmoCount - 1

    self:GetPhysicsObject():AddVelocity(VectorRand() * math.random(5, 10) * self:GetPhysicsObject():GetMass())
    self:GetPhysicsObject():AddAngleVelocity(VectorRand() * math.random(60, 300))

    self:EmitSound("weapons/ar2/ar2_altfire.wav", 80, 150)
end

function ENT:Detonate(wet, attacker)
    if wet then
        for i = 1, math.random(1, 3) do
            self:DetonateRound(attacker)
        end
    end

    local e = EffectData()
    e:SetOrigin(self:GetPos())
    util.Effect("Explosion", e)

    util.BlastDamage(self, attacker, self:GetPos(), self.DetonationRadius, self.DetonationDamage * (wet and 1 or 2))
    self:Remove()
end
--addons/[binbon]arccw_modify/lua/entities/arccw_att_dropped.lua:
AddCSLuaFile()

ENT.Base = "arccw_att_base"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.Category = "ArcCW - Attachments"
ENT.PrintName = "Attachment Box"
ENT.Spawnable = false

ENT.Model = "models/Items/BoxMRounds.mdl"

function ENT:Draw()
    self:DrawModel()

    local cvar2d3d = ArcCW.ConVars["2d3d"]:GetInt()
    if cvar2d3d == 0 or (cvar2d3d == 1 and LocalPlayer():GetEyeTrace().Entity != self) then return end

    if (EyePos() - self:WorldSpaceCenter()):LengthSqr() <= 262144 then -- 512^2
        local ang = LocalPlayer():EyeAngles()
        local name = self:GetNWString("boxname", nil) or self.PrintName

        ang:RotateAroundAxis(ang:Forward(), 180)
        ang:RotateAroundAxis(ang:Right(), 90)
        ang:RotateAroundAxis(ang:Up(), 90)

        cam.Start3D2D(self:WorldSpaceCenter() + Vector(0, 0, 14), ang, 0.1)
            surface.SetFont("ArcCW_32_Unscaled")
            local w = surface.GetTextSize(name)

            surface.SetTextPos(-w / 2 + 2, 2)
            surface.SetTextColor(0, 0, 0, 150)
            surface.DrawText(name)

            surface.SetTextPos(-w / 2, 0)
            surface.SetTextColor(255, 255, 255, 255)
            surface.DrawText(name)

            local count = self:GetNWInt("boxcount", 0)
            local str = count .. " Attachment" .. (count != 1 and "s" or "")
            local w2 = surface.GetTextSize(str)

            surface.SetTextPos(-w2 / 2 + 2, 26)
            surface.SetTextColor(0, 0, 0, 150)
            surface.DrawText(str)
            surface.SetTextPos(-w2 / 2, 24)
            surface.SetTextColor(255, 255, 255, 255)
            surface.DrawText(str)
        cam.End3D2D()
    end
end
--lua/entities/arccw_uc_40mm_airburst.lua:
return gluapack()()
--lua/entities/arccw_uc_40mm_flash.lua:
AddCSLuaFile()

ENT.Base = "arccw_uc_40mm_he"
ENT.PrintName = "40mm Flash Grenade"

ENT.GrenadeDamage = 50
ENT.GrenadeRadius = 150
ENT.ExplosionEffect = false
ENT.Scorch = false

function ENT:DoDetonation()

    local effectdata = EffectData()
    effectdata:SetOrigin(self:GetPos())

    if self:WaterLevel() >= 1 then
        util.Effect("WaterSurfaceExplosion", effectdata)
        self:EmitSound("weapons/underwater_explode3.wav", 125, 100, 1, CHAN_AUTO)
    else
        effectdata:SetMagnitude(4)
        effectdata:SetScale(1)
        effectdata:SetRadius(4)
        effectdata:SetNormal(self:GetVelocity():GetNormalized())
        util.Effect("Sparks", effectdata)
        self:EmitSound("physics/metal/metal_box_break1.wav", 100, 200, 0.5)
    end

    -- TODO: these sounds need to be replaced (dependency)!
    self:EmitSound("weapons/arccw/flashbang/flashbang_explode1.wav", 100, 100, 1, CHAN_AUTO)
    self:EmitSound("weapons/arccw/flashbang/flashbang_explode1_distant.wav", 140, 100, 1, CHAN_AUTO)

    util.Effect( "arccw_flashexplosion", effectdata)

    local flashorigin = self:GetPos()

    local flashpower = 512
    local targets = ents.FindInSphere(flashorigin, flashpower)

    for _, k in pairs(targets) do
        if k:IsPlayer() then
            local dist = k:EyePos():Distance(flashorigin)
            local dp = (k:EyePos() - flashorigin):Dot(k:EyeAngles():Forward())

            local time = Lerp( dp, 2.5, 0.25 )

            time = Lerp( dist / flashpower, time, 0 )

            if k:VisibleVec( flashorigin ) then
                k:ScreenFade( SCREENFADE.IN, Color( 255, 255, 255, 255 ), 2.5, time )
            end

            k:SetDSP(37, false)

        elseif k:IsNPC() then

            k:SetNPCState(NPC_STATE_PLAYDEAD)

            if timer.Exists( k:EntIndex() .. "_arccw_flashtimer" ) then
                timer.Remove( k:EntIndex() .. "_arccw_flashtimer" )
            end

            timer.Create( k:EntIndex() .. "_arccw_flashtimer", 10, 1, function()
                if !k:IsValid() then return end
                k:SetNPCState(NPC_STATE_ALERT)
            end)

        end
    end

end
--lua/entities/arccw_uc_40mm_hv.lua:
AddCSLuaFile()

ENT.Base = "arccw_uc_40mm_he"
ENT.PrintName = "40mm High Velocity"

ENT.GrenadeDamage = false
ENT.GrenadeRadius = 200
ENT.DragCoefficient = 0

ENT.Model = "models/weapons/shell.mdl"

if CLIENT then
    function ENT:Think()
        if self.Ticks % 3 == 0 then
            local emitter = ParticleEmitter(self:GetPos())
            if not self:IsValid() or self:WaterLevel() > 2 then return end
            if not IsValid(emitter) then return end

            local smoke = emitter:Add("particle/particle_smokegrenade", self:GetPos())
            smoke:SetVelocity(VectorRand() * 25)
            smoke:SetGravity(Vector(math.Rand(-5, 5), math.Rand(-5, 5), math.Rand(-20, -25)))
            smoke:SetDieTime(math.Rand(1.5, 2.0))
            smoke:SetStartAlpha(255)
            smoke:SetEndAlpha(0)
            smoke:SetStartSize(0)
            smoke:SetEndSize(60)
            smoke:SetRoll(math.Rand(-180, 180))
            smoke:SetRollDelta(math.Rand(-0.2, 0.2))
            smoke:SetColor(100, 100, 100)
            smoke:SetAirResistance(5)
            smoke:SetPos(self:GetPos())
            smoke:SetLighting(false)
            emitter:Finish()
        end
        self.Ticks = self.Ticks + 1
    end
end
--addons/xenin-inventory/lua/entities/bank_npc/cl_init.lua:
return gluapack()()
--addons/xenin-inventory/lua/entities/bank_npc/cl_init.lua:
include("shared.lua")

function ENT:Draw()
  self:DrawModel()
  if not binbonentdraw then return end
  binbonentdraw(self, "Envanterci", true, 0, 10, 20, true)
  binbonentdraw(self, "Envanterindeki eşyaları buraya koyabilirsin.", false, 0,100, 20, false)
end

net.Receive("XeninInventory.Bank.Open", function(len)
  if IsValid(XeninInventory.Bank) then return end
  if (!XeninInventory:CanUseInventory(LocalPlayer())) then
    LocalPlayer():XeninInventory():Message(XeninInventory:GetPhrase("ChatCommand.AccessRestricted"))

    return
  end

  local frame = vgui.Create("XeninInventory.Bank.Frame")
  frame:SetSize(ScrW(), ScrH())
  frame:Center()
  frame:MakePopup()
end)

--addons/xenin-inventory/lua/entities/bank_npc/shared.lua:
return gluapack()()
--addons/bodygroupr/lua/entities/bodyman_closet/shared.lua:
/*----------------------------------------------------------------------
Leak by Famouse

Play good games:↓
http://store.steampowered.com/curator/32364216

Subscribe to the channel:↓
www.youtube.com/c/Famouse

More leaks in the discord:↓ 
https://discord.gg/rFdQwzm
------------------------------------------------------------------------*/

ENT.Type = "anim"

ENT.PrintName = "Closet"
ENT.Purpose = "Opens the bodyGroupr menu"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

ENT.Category = "bodyGroupr"

ENT.WorldModel = "models/props_wasteland/controlroom_storagecloset001a.mdl"

function ENT:Initialize()

	self:SetModel( self.WorldModel )
	self:SetMoveType( MOVETYPE_VPHYSICS )   
	self:SetSolid( SOLID_VPHYSICS )         
 	  local SERVER = SERVER
	if ( SERVER ) then self:PhysicsInit( SOLID_VPHYSICS ) end

    local phys = self:GetPhysicsObject()
	if (phys:IsValid()) then
		phys:Wake()
		phys:SetMass( 50 )
	end

	if SERVER then
		self:SetUseType( SIMPLE_USE )
		self.health = BODYMAN.ClosetHealth or 100
	end

end

/*------------------------------------------------------------------------
Donation for leaks

Qiwi Wallet         4890494419811120 
YandexMoney         410013095053302
WebMoney(WMR)       R235985364414
WebMoney(WMZ)       Z309855690994
------------------------------------------------------------------------*/
--addons/ch_atm/lua/entities/ch_atm_card_scanner/shared.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_bitcoin_screen/shared.lua:
ENT.Base = "base_gmodentity"
ENT.Type = "anim"

ENT.PrintName		= "Bitcoin Screen"
ENT.Author			= "Crap-Head"
ENT.Category 		= "Bitminers by Crap-Head"

ENT.Spawnable			= true
ENT.AdminSpawnable		= true

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.AutomaticFrameAdvance = true
--addons/ch_bitminers/lua/entities/ch_bitminer_power_rtg/shared.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_shelf/cl_init.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_cooling1/cl_init.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_cooling1/shared.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_miner/shared.lua:
return gluapack()()
--addons/ch_bitminers/lua/entities/ch_bitminer_upgrade_ups/shared.lua:
return gluapack()()
--addons/ch_mayor/lua/entities/ch_mayor_announcements/cl_init.lua:
return gluapack()()
--addons/ch_mayor/lua/entities/ch_mayor_cityboard/cl_init.lua:
return gluapack()()
--addons/ch_mining/lua/entities/ch_mining_rock/shared.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/creem/shared.lua:
return gluapack()()
--gamemodes/darkrp/entities/entities/darkrp_laws/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "DarkRP Laws"
ENT.Instructions = "Use /addlaws to add a custom law, /removelaw <num> to remove a law."
ENT.Author = "Drakehawke"

ENT.Spawnable = false

local plyMeta = FindMetaTable("Player")
DarkRP.declareChatCommand{
    command = "addlaw",
    description = "Add a law to the laws board.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "removelaw",
    description = "Remove a law from the laws board.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "placelaws",
    description = "Place a laws board.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "resetlaws",
    description = "Reset all laws.",
    delay = 1.5
}

DarkRP.getLaws = DarkRP.stub{
    name = "getLaws",
    description = "Get the table of all current laws.",
    parameters = {
    },
    returns = {
        {
            name = "laws",
            description = "A table of all current laws.",
            type = "table"
        }
    },
    metatable = DarkRP,
    realm = "Shared"
}

DarkRP.resetLaws = DarkRP.stub{
    name = "resetLaws",
    description = "Reset to default laws.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP,
    realm = "Server"
}

DarkRP.hookStub{
    name = "addLaw",
    description = "Called when a law is added.",
    parameters = {
        {
            name = "index",
            description = "Index of the law",
            type = "number"
        },
        {
            name = "law",
            description = "Law string",
            type = "string"
        },
        {
            name = "player",
            description = "The player who added the law",
            type = "Player"
        }
    },
    returns = {
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "removeLaw",
    description = "Called when a law is removed.",
    parameters = {
        {
            name = "index",
            description = "Index of law",
            type = "number"
        },
        {
            name = "law",
            description = "Law string",
            type = "string"
        },
        {
            name = "player",
            description = "The player who removed the law",
            type = "Player"
        }
    },
    returns = {
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "resetLaws",
    description = "Called when laws are reset.",
    parameters = {
        {
            name = "player",
            description = "The player resetting the laws.",
            type = "Player"
        }
    },
    returns = {
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "canEditLaws",
    description = "Whether someone can edit laws.",
    parameters = {
        {
            name = "player",
            description = "The player trying to edit laws.",
            type = "Player"
        },
        {
            name = "action",
            description = "How the player is trying to edit laws.",
            type = "string"
        },
        {
            name = "arguments",
            description = "Arguments related to editing laws.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canEdit",
            description = "A yes or no as to whether the player can edit the law.",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when they can't edit the law.",
            type = "string"
        }
    },
    realm = "Server"
}

--addons/turkish_food_mod-main/lua/entities/gazoz/shared.lua:
return gluapack()()
--addons/ledscreen/lua/entities/gb_rp_sign/shared.lua:
return gluapack()()
--addons/glorifiedhandcuffs/lua/entities/glorifiedhandcuffs_bailnpc/cl_init.lua:
include("shared.lua")

function ENT:Draw()
  self:DrawModel()
  if not binbonentdraw then return end
  binbonentdraw(self, "Kefaretçi", true, 0, 10, 20, true)
  binbonentdraw(self, "Belirli para karşılığı istediğin kişiyi hapisten çıkarabilirsin.", false, 0,100, 20, false)
end
--lua/entities/gmod_contr_spawner/cl_init.lua:
include( "shared.lua" )

function ENT:Draw()
	self.BaseClass.Draw(self)
	self.Entity:DrawModel()
end

--addons/playablepiano/lua/entities/gmt_instrument_piano/shared.lua:
ENT.Base			= "gmt_instrument_base"
ENT.Type			= "anim"
ENT.PrintName		= "Playable Piano"
ENT.Author			= "MacDGuy"
ENT.Contact			= "http://www.gmtower.org"
ENT.Purpose			= "A fully playable piano!"
ENT.Category		= "Fun + Games"
ENT.Spawnable		= true
ENT.AdminSpawnable 	= true

ENT.Model		= Model( "models/fishy/furniture/piano.mdl" )
ENT.SoundDir	= "GModTower/lobby/instruments/piano/"

local darker = Color( 100, 100, 100, 150 )
ENT.Keys = {
	[KEY_A] = { Sound = "a15", Material = "left", Label = "A", X = 19, Y = 86 },
	[KEY_S] = { Sound = "a16", Material = "middle", Label = "S", X = 44, Y = 86 },
	[KEY_D] = { Sound = "a17", Material = "right", Label = "D", X = 68, Y = 86 },
	[KEY_F] = { Sound = "a18", Material = "left", Label = "F", X = 94, Y = 86 },
	[KEY_G] = { Sound = "a19", Material = "leftmid", Label = "G", X = 119, Y = 86 },
	[KEY_H] = { Sound = "a20", Material = "rightmid", Label = "H", X = 144, Y = 86 },
	[KEY_J] = { Sound = "a21", Material = "right", Label = "J", X = 169, Y = 86 },
	[KEY_K] = { Sound = "a22", Material = "left", Label = "K", X = 194, Y = 86 },
	[KEY_L] = { Sound = "a23", Material = "middle", Label = "L", X = 219, Y = 86 },
	[KEY_SEMICOLON] = { Sound = "a24", Material = "right", Label = ":", X = 244, Y = 86 },
	[KEY_APOSTROPHE] = { Sound = "a25", Material = "full", Label = "'", X = 269, Y = 86 },

	[KEY_W] = { Sound = "b11", Material = "top",  Label = "W", X = 33, Y = 31, TextX = 7, TextY = 90, Color = darker },
	[KEY_E] = { Sound = "b12", Material = "top", Label = "E", X = 64, Y = 31, TextX = 7, TextY = 90, Color = darker },
	[KEY_T] = { Sound = "b13", Material = "top", Label = "T", X = 108, Y = 31, TextX = 7, TextY = 90, Color = darker },
 	[KEY_Y] = { Sound = "b14", Material = "top", Label = "Y", X = 136, Y = 31, TextX = 7, TextY = 90, Color = darker },
 	[KEY_U] = { Sound = "b15", Material = "top", Label = "U", X = 164, Y = 31, TextX = 7, TextY = 90, Color = darker },
	[KEY_O] = { Sound = "b16",	Material = "top", Label = "O", X = 208, Y = 31, TextX = 7, TextY = 90, Color = darker },
	[KEY_P] = { Sound = "b17", Material = "top", Label = "P", X = 239, Y = 31, TextX = 7, TextY = 90, Color = darker },
}

ENT.AdvancedKeys = {
	[KEY_1] =
	{
		Sound = "a1", Material = "left", Label = "1", X = 19, Y = 86,
		Shift = { Sound = "b1", Material = "top", Label = "!", X = 33, Y = 31, TextX = 7, TextY = 90, Color = darker },
	},
	[KEY_2] =
	{
		Sound = "a2", Material = "middle", Label = "2", X = 44, Y = 86,
		Shift = { Sound = "b2", Material = "top", Label = "@", X = 64, Y = 31, TextX = 7, TextY = 90, Color = darker },
	},
	[KEY_3] = { Sound = "a3", Material = "right", Label = "3", X = 69, Y = 86 },
	[KEY_4] =
	{
		Sound = "a4", Material = "left", Label = "4", X = 94, Y = 86,
		Shift = { Sound = "b3", Material = "top", Label = "$", X = 108, Y = 31, TextX = 7, TextY = 90, Color = darker },
	},
	[KEY_5] =
	{
		Sound = "a5", Material = "leftmid", Label = "5", X = 119, Y = 86,
		Shift = { Sound = "b4", Material = "top", Label = "%", X = 136, Y = 31, TextX = 7, TextY = 90, Color = darker },
	},
	[KEY_6] =
	{
		Sound = "a6", Material = "rightmid", Label = "6", X = 144, Y = 86,
		Shift = { Sound = "b5", Material = "top", Label = "^", X = 164, Y = 31, TextX = 7, TextY = 90, Color = darker },
	},
	[KEY_7] = { Sound = "a7", Material = "right", Label = "7", X = 169, Y = 86 },
	[KEY_8] =
	{
		Sound = "a8", Material = "left", Label = "8", X = 194, Y = 86,
		Shift = { Sound = "b6", Material = "top", Label = "*", X = 208, Y = 31, TextX = 7, TextY = 90, Color = darker },
	},
	[KEY_9] =
	{
		Sound = "a9", Material = "middle", Label = "9", X = 219, Y = 86,
		Shift = { Sound = "b7", Material = "top", Label = "(", X = 239, Y = 31, TextX = 7, TextY = 90, Color = darker },
	},
	[KEY_0] = { Sound = "a10", Material = "right", Label = "0", X = 244, Y = 86 },
	[KEY_Q] =
	{
		Sound = "a11", Material = "left", Label = "q", X = 269, Y = 86,
		Shift = { Sound = "b8", Material = "top", Label = "Q", X = 283, Y = 31, TextX = 7, TextY = 90, Color = darker },
	},
	[KEY_W] =
	{
		Sound = "a12", Material = "leftmid", Label = "w", X = 294, Y = 86,
		Shift = { Sound = "b9", Material = "top", Label = "W", X = 310, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 310
	[KEY_E] =
	{
		Sound = "a13", Material = "rightmid", Label = "e", X = 319, Y = 86,
		Shift = { Sound = "b10", Material = "top", Label = "E", X = 339, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 339
	[KEY_R] = { Sound = "a14", Material = "right", Label = "r", X = 344, Y = 86 },
	[KEY_T] =
	{
		Sound = "a15", Material = "left", Label = "t", X = 369, Y = 86,
		Shift = { Sound = "b11", Material = "top", Label = "T", X = 383, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 383
	[KEY_Y] =
	{
		Sound = "a16", Material = "middle", Label = "y", X = 394, Y = 86,
		Shift = { Sound = "b12", Material = "top", Label = "Y", X = 414, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 415
	[KEY_U] = { Sound = "a17", Material = "right", Label = "u", X = 419, Y = 86 },
	[KEY_I] =
	{
		Sound = "a18", Material = "left", Label = "i", X = 444, Y = 86,
		Shift = { Sound = "b13", Material = "top", Label = "I", X = 458, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 459
	[KEY_O] =
	{
		Sound = "a19", Material = "leftmid", Label = "o", X = 469, Y = 86,
		Shift = { Sound = "b14", Material = "top", Label = "O", X = 486, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 486
	[KEY_P] =
	{
		Sound = "a20", Material = "rightmid", Label = "p", X = 494, Y = 86,
		Shift = { Sound = "b15", Material = "top", Label = "P", X = 514, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 515
	[KEY_A] = { Sound = "a21", Material = "right", Label = "a", X = 519, Y = 86 },
	[KEY_S] =
	{
		Sound = "a22", Material = "left", Label = "s", X = 544, Y = 86,
		Shift = { Sound = "b16", Material = "top", Label = "S", X = 558, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 559
	[KEY_D] =
	{
		Sound = "a23", Material = "middle", Label = "d", X = 569, Y = 86,
		Shift = { Sound = "b17", Material = "top", Label = "D", X = 590, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 590
	[KEY_F] = { Sound = "a24", Material = "right", Label = "f", X = 594, Y = 86 },
	[KEY_G] =
	{
		Sound = "a25", Material = "left", Label = "g", X = 619, Y = 86,
		Shift = { Sound = "b18", Material = "top", Label = "G", X = 633, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 633
	[KEY_H] =
	{
		Sound = "a26", Material = "leftmid", Label = "h", X = 644, Y = 86,
		Shift = { Sound = "b19", Material = "top", Label = "H", X = 661, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 661
	[KEY_J] =
	{
		Sound = "a27", Material = "rightmid", Label = "j", X = 669, Y = 86,
		Shift = { Sound = "b20", Material = "top", Label = "J", X = 690, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 690
	[KEY_K] = { Sound = "a28", Material = "right", Label = "k", X = 694, Y = 86 },
	[KEY_L] =
	{
		Sound = "a29", Material = "left", Label = "l", X = 719, Y = 86,
		Shift = { Sound = "b21", Material = "top", Label = "L", X = 734, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 734
	[KEY_Z] =
	{
		Sound = "a30", Material = "middle", Label = "z", X = 744, Y = 86,
		Shift = { Sound = "b22", Material = "top", Label = "Z", X = 765, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 765
	[KEY_X] = { Sound = "a31", Material = "right", Label = "x", X = 769, Y = 86 },
	[KEY_C] =
	{
		Sound = "a32", Material = "left", Label = "c", X = 794, Y = 86,
		Shift = { Sound = "b23", Material = "top", Label = "C", X = 809, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 809
	[KEY_V] =
	{
		Sound = "a33", Material = "leftmid", Label = "v", X = 819, Y = 86,
		Shift = { Sound = "b24", Material = "top", Label = "V", X = 837, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 837
	[KEY_B] =
	{
		Sound = "a34", Material = "rightmid", Label = "b", X = 844, Y = 86,
		Shift = { Sound = "b25", Material = "top", Label = "B", X = 865, Y = 31, TextX = 7, TextY = 90, Color = darker },
	}, // 865
	[KEY_N] = { Sound = "a35", Material = "right", Label = "n", X = 869, Y = 86 },
	[KEY_M] = { Sound = "a36", Material = "full", Label = "m", X = 894, Y = 86 },
}
--gamemodes/darkrp/entities/entities/gunlab/shared.lua:
ENT.Base = "lab_base"
ENT.PrintName = "Gun Lab"

function ENT:initVars()
    self.model = "models/props_c17/TrapPropeller_Engine.mdl"
    self.initialPrice = GAMEMODE.Config.gunlabguncost
    self.labPhrase = DarkRP.getPhrase("gun_lab")
    self.itemPhrase = DarkRP.getPhrase("gun")
end

--addons/hackable_server/lua/entities/hacktool_server/sh_init.lua:
return gluapack()()
--lua/entities/heavy_armor/cl_init.lua:
include('shared.lua')

function ENT:Draw()
    self:DrawModel()
end
--addons/turkish_food_mod-main/lua/entities/kofte_durum_hot/cl_init.lua:
include("shared.lua")
function ENT:Initialize() end
function ENT:Draw() self:DrawModel() end

--addons/turkish_food_mod-main/lua/entities/kofte_durum_hot/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Acılı Çiğköfte"
ENT.Category = "Turkish Food Mod"
ENT.Spawnable = true
--addons/turkish_food_mod-main/lua/entities/kofte_stand/cl_init.lua:
return gluapack()()
--addons/turkish_food_mod-main/lua/entities/kofte_stand/cl_init.lua:
sound.Add({
    name = "ali_usta",
    channel = CHAN_STATIC,
    volume = 1.0,
    level = 80,
    pitch = {100, 100},
    sound = "ali_usta.mp3"
})

include("shared.lua")
include("tfm_config.lua")

surface.CreateFont("kofte_durum_f1", {
    font = "Arial",
    extended = false,
    size = ScrW() / 60,
    weight = 555,
})

local function TFM_CIFKOFTE_UI()
    local kofte_stand = vgui.Create("DPanel")
    local scrw, scrh = ScrW(), ScrH()
    kofte_stand:SetSize(scrw / 4, scrh / 4)
    kofte_stand:MakePopup()
    kofte_stand:Center()

    kofte_stand.Paint = function(self, w, h)
        draw.RoundedBox(8,0,0,w,h,Color(63, 36, 36))
    end

    local calsinmi = math.random(1, 6)

    if calsinmi == 1 then
        surface.PlaySound("ali_usta_detone.mp3")
    end

    local kofte_durum_create = vgui.Create("DButton", kofte_stand)
    kofte_durum_create:SetSize(scrw / 5, scrh / 15)
    kofte_durum_create:SetPos(kofte_stand:GetWide() / 10, kofte_stand:GetTall() / 6)
    kofte_durum_create:SetColor(Color(255, 255, 255))
    kofte_durum_create:SetText("Sade Dürüm " .. TFM.Stands["kofte_stand"].price_normal .. " TL")
    kofte_durum_create:SetFont("kofte_durum_f1")

    kofte_durum_create.Paint = function(self, w, h)
        if self:IsHovered() then
            self:SetColor(Color(255, 255, 255, 255))
            draw.RoundedBox(6,0,0,w,h,Color(255, 150, 0, 255))
        else
            self:SetColor(Color(255, 255, 255, 10))
            draw.RoundedBox(6,0,0,w,h,Color(92, 51, 51))
        end
    end

    kofte_durum_create.DoClick = function()
        net.Start("tfm_cigkofte_network")
        net.WriteUInt(1,2)
        net.SendToServer()
        kofte_stand:Remove()
    end

    local hot_kofte_durum_create = vgui.Create("DButton", kofte_stand)
    hot_kofte_durum_create:SetSize(scrw / 5, scrh / 15)
    hot_kofte_durum_create:SetPos(kofte_stand:GetWide() / 10, kofte_stand:GetTall() / 2)
    hot_kofte_durum_create:SetColor(Color(255, 255, 255))
    hot_kofte_durum_create:SetText("Acılı Dürüm " .. TFM.Stands["kofte_stand"].price_normal .. " TL")
    hot_kofte_durum_create:SetFont("kofte_durum_f1")

    hot_kofte_durum_create.Paint = function(self, w, h)
        if self:IsHovered() then
            self:SetColor(Color(255, 255, 255, 255))
            draw.RoundedBox(6,0,0,w,h,Color(255, 0, 0, 255))
        else
            self:SetColor(Color(255, 255, 255, 10))
            draw.RoundedBox(6,0,0,w,h,Color(92, 51, 51))
        end
    end

    hot_kofte_durum_create.DoClick = function()
        net.Start("tfm_cigkofte_network")
        net.WriteUInt(2,2)
        net.SendToServer()
        kofte_stand:Remove()
    end

    local kofte_stand_close = vgui.Create("DButton", kofte_stand)
    kofte_stand_close:SetSize(scrw * 0.02, scrh * 0.02)
    kofte_stand_close:SetPos(scrw * 0.225,scrh * 0.01)
    kofte_stand_close:SetText("x")

    kofte_stand_close.Paint = function(self, w, h)
        if self:IsHovered() then
            self:SetColor(Color(255, 255, 255, 255))
            draw.RoundedBox(4,0,0,w,h,Color(168, 36, 36))
        else
            self:SetColor(Color(255, 255, 255, 10))
            draw.RoundedBox(4,0,0,w,h,Color(92, 51, 51))
        end
    end

    kofte_stand_close.DoClick = function()
        kofte_stand:Remove()
    end
end

net.Receive("tfm_cigkofte_network", function(len, pl)
    TFM_CIFKOFTE_UI()
end)

ENT.ilerkisure = 0

local drawroundedboxcolor_cache, drawsimpletextcolor_cache, color_red, vector_cache = Color(0,0,0,200), Color(255,255,255,255), Color(255,0,0,255), Vector(0, 0, -7)

function ENT:Draw()
    self:DrawModel()

    if self:GetNWString("kofte_stand_nw1", "0") ~= "0" then
        --net.Start("kofte_stand_freezeowner_true")
        --net.SendToServer()
        if self.ilerkisure == 0 then
            self.ilerkisure = CurTime() + tonumber(self:GetNWString("kofte_stand_nw1", "0"))
        end

        local ang, scrw, scrh = LocalPlayer():EyeAngles(), ScrW(), ScrH()
        ang = Angle(0, ang.y, 0)
        --local random_times = math.Remap(60, 7, 60, 7, 20)
        local sure = math.Remap(tonumber(self:GetNWString("kofte_stand_nw1", "0")) - (self.ilerkisure - CurTime()), 0, tonumber(self:GetNWString("kofte_stand_nw1", "0")), 0, 10) * 50
        ang:RotateAroundAxis(ang:Forward(), 180)
        ang:RotateAroundAxis(ang:Right(), 90)
        ang:RotateAroundAxis(ang:Up(), 90)
        cam.Start3D2D(self:WorldSpaceCenter() + vector_cache, ang, 0.1)
        draw.RoundedBox(10, scrw - 1600, scrh - 1500, scrw * 0.4, scrh * 0.2, drawroundedboxcolor_cache)
        draw.SimpleText("Dürüm Hazırlanıyor..." .. self:GetNWString("kofte_stand_nw1", "0") .. " saniye", "kofte_durum_f1", scrw - 1300, scrh - 1450, drawsimpletextcolor_cache, 1, 1)
        draw.RoundedBox(10, scrw - 1580, scrh - 1400, sure, scrh * 0.05, color_red)
        cam.End3D2D()
    else
        self.ilerkisure = 0
        --net.Start("kofte_stand_freezeowner_false")
        --net.SendToServer()
    end
end

--lua/entities/light_armor/shared.lua:
return gluapack()()
--lua/entities/light_armor_stackable/cl_init.lua:
include('shared.lua')

function ENT:Draw()
    self:DrawModel()
end

--addons/minigame-tool-assistant/lua/entities/minigame_item.lua:
return gluapack()()
--addons/minigame-tool-assistant/lua/entities/minigame_trigger.lua:
--[[------------------------------------------------
                    Minigame Brush 
------------------------------------------------]]--

AddCSLuaFile()

ENT.Base = "base_entity"
ENT.Type = "brush"

ENT.FuncStart = function() end
ENT.FuncTouch = function() end
ENT.FuncEnd = function() end


--[[------------------------------------------------
                        Owner
------------------------------------------------]]--

function ENT:GetOwner()
    return self:Getowning_ent()
end


--[[------------------------------------------------
                      Functions
------------------------------------------------]]--

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
end


function ENT:IsActive()
    local GameScript = Minigames.GetOwnerGame( self:Getowning_ent() )
    return ( GameScript ~= nil ) and GameScript:IsActive()
end


if ( SERVER ) then

    function ENT:Setup( Owner, Vec1, Vec2, StartTouch, EndTouch, Touch )
        self.StartTouch = StartTouch
        self.EndTouch = EndTouch
        self.Touch = Touch

        self:SetCollisionBoundsWS( Vec1, Vec2 )
        self:Setowning_ent( Owner )
    end

    function ENT:Initialize()
        self:SetSolid( SOLID_BBOX )
        self:SetCollisionBoundsWS( vector_origin, vector_up )
    end

end
--addons/darkrpbankrobbery2/lua/entities/new_bank_vault/cl_init.lua:
return gluapack()()
--addons/darkrpbankrobbery2/lua/entities/new_bank_vault/cl_init.lua:
include( "shared.lua" )

function ENT:Initialize()
end

local function BANK2_DrawCircle(x, y, ang, seg, p, rad, color)
	local cirle = {}

	table.insert( cirle, { x = x, y = y} )
	for i = 0, seg do
		local a = math.rad( ( i / seg ) * -p + ang )
		table.insert( cirle, { x = x + math.sin( a ) * rad, y = y + math.cos( a ) * rad } )
	end
	surface.SetDrawColor( color )
	draw.NoTexture()
	surface.DrawPoly( cirle )
end

function ENT:DrawTranslucent()
	self:DrawModel()
	
	local ply = LocalPlayer()
	local cur_time = CurTime()
	
	if ply:GetPos():DistToSqr( self:GetPos() ) >= CH_BankVault.Design.DistanceTo3D2D then
		return
	end

	local BankAmount = self:GetMoney()

	if not BankAmount then
		return
	end

	local ang = self:GetAngles()
	ang:RotateAroundAxis( ang:Up(), 90 )
	
	local pos = self:GetPos() + ang:Right() * 30 + ang:Up() * 52
	ang:RotateAroundAxis( ang:Forward(), 90 )
	
	cam.Start3D2D( pos, ang, 0.11 )
		draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_VaultName, "CH_BankRobbery2_Header", 0, -65, CH_BankVault.Design.DesignColor_VaultName, 1, 1, 2, CH_BankVault.Design.DesignColor_VaultNameBoarder )
		draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_BankVault, "CH_BankRobbery2_VaultName", 0, -10, CH_BankVault.Design.DesignColor_BankVault, 1, 1, 2, CH_BankVault.Design.DesignColor_BankVaultBoarder )
		
		BANK2_DrawCircle( 0, 110, 180, 80, 360, 100, CH_BankVault.Design.DesignColor_BackCircle ) -- Back circle
		BANK2_DrawCircle( 0, 110, 180, 80, 360 * BankAmount/CH_BankVault.Config.Max, 99, CH_BankVault.Design.DesignColor_MoneyCircle ) -- Money circle
		BANK2_DrawCircle( 0, 110, 180, 40, 360, 80, CH_BankVault.Design.DesignColor_FrontCircle ) -- Front circle
		
		draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_Money, "CH_BankRobbery2_Money", 0, 90, CH_BankVault.Design.DesignColor_Money, 1, 1, 2, CH_BankVault.Design.DesignColor_MoneyBoarder )
		draw.SimpleTextOutlined( DarkRP.formatMoney( BankAmount ), "CH_BankRobbery2_Money", 0, 130, CH_BankVault.Design.DesignColor_VaultAmount, 1, 1, 2, CH_BankVault.Design.DesignColor_VaultAmountBoarder )
    
    	-- LEFT SIDE
		draw.RoundedBox( 8, -265, 215, 240, 190, CH_BankVault.Design.DesignColor_LeftBox )

		if CH_BankVault.BankRobberyCooldown and CH_BankVault.BankRobberyCooldown > cur_time then
			draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_Cooldown, "CH_BankRobbery2_SubHeader", -142.5, 240, CH_BankVault.Design.DesignColor_Cooldown, 1, 1, 2, CH_BankVault.Design.DesignColor_CooldownBoarder )
			draw.SimpleTextOutlined( string.ToMinutesSeconds( math.Round( CH_BankVault.BankRobberyCooldown - cur_time ) ), "CH_BankRobbery2_Header", -142.5, 320, CH_BankVault.Design.DesignColor_CooldownValue, 1, 1, 2, CH_BankVault.Design.DesignColor_CooldownValueBoarder )
		elseif CH_BankVault.BankRobberyCountdown and CH_BankVault.BankRobberyCountdown > cur_time then
			draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_Countdown, "CH_BankRobbery2_SubHeader", -142.5, 240, CH_BankVault.Design.DesignColor_Countdown, 1, 1, 2, CH_BankVault.Design.DesignColor_CountdownBoarder )
			draw.SimpleTextOutlined( string.ToMinutesSeconds( math.Round( CH_BankVault.BankRobberyCountdown - cur_time ) ), "CH_BankRobbery2_Header", -142.5, 320, CH_BankVault.Design.DesignColor_CountdownValue, 1, 1, 2, CH_BankVault.Design.DesignColor_CountdownValueBoarder )	
		else
			draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_RobStatus, "CH_BankRobbery2_SubHeader", -142.5, 240, CH_BankVault.Design.DesignColor_RobStatus, 1, 1, 2, CH_BankVault.Design.DesignColor_RobStatusBoarder )
			
			if CH_BankVault.GetTotalGovernmentOfficials() >= CH_BankVault.Config.PoliceRequired then
				draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_EnoughPoliceYes, "CH_BankRobbery2_NormalText", -142.5, 280, CH_BankVault.Design.DesignColor_TheYes, 1, 1, 2, CH_BankVault.Design.DesignColor_TheBoarder )
			else
				draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_EnoughPoliceNo, "CH_BankRobbery2_NormalText", -142.5, 280, CH_BankVault.Design.DesignColor_TheNo, 1, 1, 2, CH_BankVault.Design.DesignColor_TheBoarder )
			end

			if ply:CH_BankVault_IsAllowedTeam() then
				draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_AllowedTeamYes, "CH_BankRobbery2_NormalText", -142.5, 310, CH_BankVault.Design.DesignColor_TheYes, 1, 1, 2, CH_BankVault.Design.DesignColor_TheBoarder )
			else
				draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_AllowedTeamNo, "CH_BankRobbery2_NormalText", -142.5, 310, CH_BankVault.Design.DesignColor_TheNo, 1, 1, 2, CH_BankVault.Design.DesignColor_TheBoarder )
			end
			
			if player.GetCount() >= CH_BankVault.Config.PlayerLimit then
				draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_EnoughPlayersYes, "CH_BankRobbery2_NormalText", -142.5, 340, CH_BankVault.Design.DesignColor_TheYes, 1, 1, 2, CH_BankVault.Design.DesignColor_TheBoarder )
			else
				draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_EnoughPlayersNo, "CH_BankRobbery2_NormalText", -142.5, 340, CH_BankVault.Design.DesignColor_TheNo, 1, 1, 2, CH_BankVault.Design.DesignColor_TheBoarder )
			end
			
			if CH_BankVault.Config.UseRequiredModels then
				if ply:CH_BankVault_IsRequiredModel() then
					draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_RequiredModelYes, "CH_BankRobbery2_NormalText", -142.5, 370, CH_BankVault.Design.DesignColor_TheYes, 1, 1, 2, CH_BankVault.Design.DesignColor_TheBoarder )
				else
					draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_RequiredModelNo, "CH_BankRobbery2_NormalText", -142.5, 370, CH_BankVault.Design.DesignColor_TheNo, 1, 1, 2, CH_BankVault.Design.DesignColor_TheBoarder )
				end
			end
		end

		-- RIGHT SIDE
		draw.RoundedBox( 8, 10, 215, 240, 190, CH_BankVault.Design.DesignColor_RightBox )

		draw.SimpleTextOutlined( CH_BankVault.Design.DesignText_CurrentRobbers, "CH_BankRobbery2_SubHeader", 130, 240, CH_BankVault.Design.DesignColor_CurrentRobbers, 1, 1, 2, CH_BankVault.Design.DesignColor_CurrentRobbersBoarder )
    	draw.SimpleTextOutlined( table.concat( CH_BankVault.CurrentRobbers, "", 1, 1), "CH_BankRobbery2_NormalText", 130, 280, CH_BankVault.Design.DesignColor_Robber1, 1, 1, 2, CH_BankVault.Design.DesignColor_Robber1Boarder )
    	
		if table.Count( CH_BankVault.CurrentRobbers ) > 1 then
    		draw.SimpleTextOutlined( table.concat( CH_BankVault.CurrentRobbers, "", 2, 2), "CH_BankRobbery2_NormalText", 130, 310, CH_BankVault.Design.DesignColor_Robber2, 1, 1, 2, CH_BankVault.Design.DesignColor_Robber2Boarder )
    	end
		
    	if table.Count( CH_BankVault.CurrentRobbers ) > 2 then
    		draw.SimpleTextOutlined( table.concat( CH_BankVault.CurrentRobbers, "", 3, 3), "CH_BankRobbery2_NormalText", 130, 340, CH_BankVault.Design.DesignColor_Robber3, 1, 1, 2, CH_BankVault.Design.DesignColor_Robber3Boarder )
    	end
		
		if table.Count( CH_BankVault.CurrentRobbers ) > 3 then
    		draw.SimpleTextOutlined( table.concat( CH_BankVault.CurrentRobbers, "", 4, 4), "CH_BankRobbery2_NormalText", 130, 340, CH_BankVault.Design.DesignColor_Robber3, 1, 1, 2, CH_BankVault.Design.DesignColor_Robber3Boarder )
    	end
    cam.End3D2D()
end
--addons/mayor_voting/lua/entities/npc_mayorvoting/shared.lua:
ENT.Type 				= "anim";
ENT.Base 				= "base_anim";
ENT.PrintName			= "Mayor Voting NPC";
ENT.Author				= "Chuteuk";
ENT.Purpose				= "Used for mayor election system.";

ENT.Spawnable			= false;
ENT.AdminSpawnable		= false;

function ENT:OnRemove()
end

--addons/pcasino/lua/entities/pcasino_blackjack_table/shared.lua:
return gluapack()()
--addons/pcasino/lua/entities/pcasino_roulette_table/cl_init.lua:
include("shared.lua")


function ENT:Initialize()
	self.currentBid = 0
	self.active = false
	self.currentBets = {}

	self.hasInitialized = true
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end

	self.currentBid = self.data.bet.default
	self:GetCurrentPad(Vector(0, 0, 0)) -- To force generate the cache
end
function ENT:OnRemove()
	self:ClearBets()
end

local surface_setdrawcolor = surface.SetDrawColor
local surface_drawrect = surface.DrawRect
local draw_simpletext = draw.SimpleText
local black = Color(0, 0, 0, 155)
local white = Color(255, 255, 255, 100)
local gold = Color(255, 200, 0, 100)
function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end

	if not self.data then return end


	local pos = self:GetPos()
	local ang = self:GetAngles()
	
	ang:RotateAroundAxis(ang:Up(), -90)

	cam.Start3D2D(pos + (ang:Up()*14.7) + (ang:Right()*20) + (ang:Forward()*-15.5), ang, 0.05)
		local button = self:GetCurrentPad(self:WorldToLocal(LocalPlayer():GetEyeTrace().HitPos))


		-- Bet limit
		if self.data.bet.betLimit and not (tonumber(self.data.bet.betLimit) == 0) then
			surface_setdrawcolor(black)
			surface_drawrect(5, -80, 410, 65)
			-- Border
			surface_setdrawcolor(white)
			surface_drawrect(0, -85, 420, 5)
			surface_drawrect(0, -80, 5, 65)
			surface_drawrect(415, -80, 5, 65)
			surface_drawrect(0, -15, 420, 5)
			-- Bet limit text
			draw_simpletext(string.format(PerfectCasino.Translation.UI.BetLimit, PerfectCasino.Config.FormatMoney(self.data.bet.betLimit)), "pCasino.Entity.Bid", 215, -47, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end
	
		-- Previous bet step
		surface_setdrawcolor(black)
		surface_drawrect(5, 5, 90, 65)
		-- Border
		surface_setdrawcolor(button == "bet_lower" and gold or white)
		surface_drawrect(0, 0, 100, 5)
		surface_drawrect(0, 5, 5, 65)
		surface_drawrect(95, 5, 5, 65)
		surface_drawrect(0, 70, 100, 5)
		-- Left arrow
		draw_simpletext("<", "pCasino.Entity.Arrows", 50, 35, button == "bet_lower" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		-- Current bet
		surface_setdrawcolor(black)
		surface_drawrect(115, 5, 190, 65)
		-- Border
		surface_setdrawcolor(white)
		surface_drawrect(110, 0, 200, 5)
		surface_drawrect(110, 5, 5, 65)
		surface_drawrect(305, 5, 5, 65)
		surface_drawrect(110, 70, 200, 5)
		-- Current Bid
		draw_simpletext(PerfectCasino.Config.FormatMoney(self.currentBid), "pCasino.Entity.Bid", 215, 37, white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		-- Next bet step
		-- Box
		surface_setdrawcolor(black)
		surface_drawrect(325, 5, 90, 65)
		-- Border
		surface_setdrawcolor(button == "bet_raise" and gold or white)
		surface_drawrect(320, 0, 100, 5)
		surface_drawrect(320, 5, 5, 65)
		surface_drawrect(415, 5, 5, 65)
		surface_drawrect(320, 70, 100, 5)
		-- Right arrow
		draw_simpletext(">", "pCasino.Entity.Arrows", 370, 35, button == "bet_raise" and gold or white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
	cam.End3D2D()

	if (not (self:GetStartRoundIn() == -1)) or (self:GetLastRoundNumber() >= 0) then
		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), 90)
		cam.Start3D2D(pos + (ang:Up()*-20.3) + (ang:Right()*-21.3) + (ang:Forward()*-15), ang, 0.05)
			
			-- Previous bet step
			surface_setdrawcolor(black)
			surface_drawrect(5, 5, 190, 65)
			-- Border
			surface_setdrawcolor(white)
			surface_drawrect(0, 0, 200, 5)
			surface_drawrect(0, 5, 5, 65)
			surface_drawrect(195, 5, 5, 65)
			surface_drawrect(0, 70, 200, 5)

			local text = (not (self:GetStartRoundIn() == -1)) and string.format(PerfectCasino.Translation.UI.Start, self.data.general.betPeriod - (os.time() - self:GetStartRoundIn())) or string.format(PerfectCasino.Translation.UI.Number, self:GetLastRoundNumber())
			draw_simpletext(text, "pCasino.Entity.Bid", 100, 37, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		cam.End3D2D()
	end

end

local tempStack = {}
local lastPad = false

local function clearTempStack()
	for k, v in pairs(tempStack) do
		if not IsValid(v) then continue end
		v:Remove()
	end
	tempStack = {}
end

function ENT:Think()
	if self.active then return end
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 25000 then return end

	local pos = self:WorldToLocal(LocalPlayer():GetEyeTrace().HitPos)
	local curPad, padData = self:GetCurrentPad(pos)

	if (not curPad) or (curPad == "bet_raise") or (curPad == "bet_lower") then
		lastPad = curPad
		if not table.IsEmpty(tempStack) then
			clearTempStack()
		end
		return
	end -- Don't do anything if it's not a bet pad

	if not (curPad == lastPad) then
		clearTempStack()
	end
	lastPad = curPad

	if table.IsEmpty(tempStack) then
		local chips = PerfectCasino.Chips:GetFromNumber(self.currentBid)
		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), 90)

		for k=#PerfectCasino.Chips.Types, 0, -1 do -- Run it in reverse, putting the highest chips at the bottom
			if not chips[k] then continue end
			for i=1, chips[k] do
				local plaque = k >= 11 -- There are 11 normal skins, so anything over 10 (11-1, due to skins starting at 0) we use the big plaque models

				local chip = ClientsideModel(plaque and "models/freeman/owain_casino_plaque.mdl" or "models/freeman/owain_casino_chip.mdl")
				table.insert(tempStack, chip)
				chip:SetParent(self)
				chip:SetSkin(plaque and k-11 or k)
				chip:SetPos(self:LocalToWorld(Vector(padData.origin.x, padData.origin.y, 14.8+((#tempStack+(self.currentBets[curPad] and #self.currentBets[curPad] or 0))*0.3))))
				chip:SetAngles(ang)
			end
		end
	else
		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), CurTime()*30%360)
		for k, v in pairs(tempStack) do
			v:SetAngles(ang)
		end
	end
end

-- Chip code
function ENT:AddBet(pad, amount)
	local padName, padData = self:GetPadByName(pad)
	if not padName then return end

	self.currentBets[padName] = self.currentBets[padName] or {}

	local chips = PerfectCasino.Chips:GetFromNumber(amount)
	local ang = self:GetAngles()
	ang:RotateAroundAxis(ang:Up(), 90)
	for k=#PerfectCasino.Chips.Types, 0, -1 do -- Run it in reverse, putting the highest chips at the bottom
		if not chips[k] then continue end
		for i=1, chips[k] do
			local plaque = k >= 11 -- There are 11 normal skins, so anything over 10 (11-1, due to skins starting at 0) we use the big plaque models

			local chip = ClientsideModel(plaque and "models/freeman/owain_casino_plaque.mdl" or "models/freeman/owain_casino_chip.mdl")
			table.insert(self.currentBets[padName], chip)
			chip:SetParent(self)
			chip:SetSkin(plaque and k-11 or k)
			chip:SetPos(self:LocalToWorld(Vector(padData.origin.x, padData.origin.y, 14.5+(#self.currentBets[padName]*0.3))))
			chip:SetAngles(ang)
		end
	end

	clearTempStack() -- To update the hight to have over the new stack
end
function ENT:ClearBets()
	for _, pad in pairs(self.currentBets) do
		for k, v in pairs(pad) do
			v:Remove()
		end
	end

	self.currentBets = {}
end

function ENT:OnRemove()
	-- Clear the board of last rounds best
	for k, v in pairs(self.currentBets) do
		if not IsValid(v) then continue end

		v:Remove()
	end
	
	clearTempStack()
end


net.Receive("pCasino:Roulette:Bet:Change", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end

	local newBet = net.ReadUInt(32)
	entity.currentBid = newBet
end)

net.Receive("pCasino:Roulette:Bet:Place", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end
	if not entity.data then return end
	if entity:GetPos():DistToSqr(LocalPlayer():GetPos()) > 100000 then return end

	local pad = net.ReadString()
	local betAmount = net.ReadUInt(32)


	entity:AddBet(pad, betAmount)
end)
net.Receive("pCasino:Roulette:Bet:Clear", function()
	local entity = net.ReadEntity()
	if not IsValid(entity) then return end

	entity:ClearBets()
end)
--addons/pcasino/lua/entities/pcasino_sign_plaque/shared.lua:
return gluapack()()
--addons/pcasino/lua/entities/pcasino_sign_stand/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Stand"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false

PerfectCasino.Core.RegisterEntity("pcasino_sign_stand", {
	-- General data
	general = {
		text = {d = "Casino", t = "string"} -- The text to show
	}
},
"models/freeman/owain_casinosign_standing.mdl")
--addons/turkish_food_mod-main/lua/entities/pide/cl_init.lua:
include("shared.lua")
function ENT:Initialize() end
function ENT:Draw() self:DrawModel() end

--addons/turkish_food_mod-main/lua/entities/pide/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Ramazan Pidesi"
ENT.Category = "Turkish Food Mod"
ENT.Spawnable = true
--addons/permaprops/lua/entities/pp_prop_effect.lua:
return gluapack()()
--addons/realisticcardealer/lua/entities/rcd_cardealer/shared.lua:
ENT.Base = "base_ai" 
ENT.Type = "ai"
ENT.PrintName = "NPC"
ENT.Category = "Realistic Car Dealer" -- 882829bf8cfb353a411d0b5e1f4354db5bfbd3fd12b6c60a4d8192639a21682e
ENT.Author = "Kobralost"
ENT.Spawnable = true // f6087be503e245c6ca2087557c39b4be7c469cc2acc021a4abf4469bfaad7b85
ENT.AdminSpawnable = true
--addons/realisticcardealer/lua/entities/rcd_printer/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()    
end
--addons/realisticcardealer/lua/entities/rcd_showcase/shared.lua:
return gluapack()()
--addons/realisticcardealer/lua/entities/rcd_showcase/shared.lua:
ENT.Base = "base_gmodentity" 
ENT.Type = "anim"
ENT.PrintName = "Showcase"
ENT.Category = "Realistic Car Dealer"
ENT.Author = "Kobralost"
ENT.Spawnable = true
ENT.AdminSpawnable = true
 /* 76561198447872548 */
ENT.AutomaticFrameAdvance = true
--addons/skeypad_1.2.36/lua/entities/s_keycard/cl_init.lua:
return gluapack()()
--addons/serious_business/lua/entities/sb_good_box/cl_init.lua:
return gluapack()()
--addons/serious_business/lua/entities/sb_good_guide/cl_init.lua:
/*----------------------------------------------------------------------
Leak by Famouse

Play good games:↓
store.steampowered.com/curator/32364216

Subscribe to the channel:↓
https://www.youtube.com/c/Famouse

More leaks in the discord:↓ 
discord.gg/rFdQwzm
------------------------------------------------------------------------*/

include("shared.lua");

surface.CreateFont("SB_Guide_Icon", {
	font = "Webdings",
	size = 256,
	weight = 100,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = true,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false
});

surface.CreateFont("SB_Guide_Text", {
	font = "Tahoma",
	size = 32,
	weight = 800,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false
});

function ENT:Initialize()	

end;

function ENT:Think()

end;

function ENT:Draw()
	self:DrawModel();
	
	local camPos = self:WorldSpaceCenter();
	local camAng = self:GetAngles();
	
	camAng:RotateAroundAxis(camAng:Up(), 180);
	camAng:RotateAroundAxis(camAng:Forward(), 90);	
	camAng:RotateAroundAxis(camAng:Right(), 0);

	if (LocalPlayer():GetPos():Distance(self:GetPos()) < SeriousBusiness_Config.DrawDistance) then
		cam.Start3D2D(camPos+camAng:Up()*1.50, camAng, 0.075)
			draw.RoundedBox(0, -64, -64-8, 128, 128+8, Color(0, 0, 0, 200));
			draw.SimpleText("J", "SB_Guide_Icon", 0, 0, Color(255, 255, 255, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();

		cam.Start3D2D(camPos+camAng:Up()*1.50, camAng, 0.035)
			draw.SimpleText("Good for Dummies", "SB_Guide_Text", 0, -128, Color(255, 255, 255, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();
	end;
end;

/*------------------------------------------------------------------------
Donation for leaks

Qiwi Wallet         4890494419811120 
YandexMoney         410013095053302
WebMoney(WMR)       R235985364414
WebMoney(WMZ)       Z309855690994
------------------------------------------------------------------------*/
--addons/tablo_ent/lua/entities/score_base/cl_init.lua:
return gluapack()()
--addons/tablo_ent/lua/entities/score_base/shared.lua:
return gluapack()()
--lua/entities/sent_goalpost.lua:
return gluapack()()
--lua/entities/sent_streamradio/cl_init.lua:
include("shared.lua")
DEFINE_BASECLASS("base_streamradio_gui")

local StreamRadioLib = StreamRadioLib

function ENT:StopTuneSound()
	if not self.NoiseSound then return end

	local stream = self.StreamObj
	if IsValid(streamj) then
		stream:TimerRemove("tunesoundstart")
		stream:TimerRemove("tunesound")
	end

	self.NoiseSound:Stop( )
	self.NoiseSound = nil
end

function ENT:FadeoutTuneSound(time)
	if not self.NoiseSound then return end

	local stream = self.StreamObj
	if IsValid(streamj) then
		stream:TimerRemove("tunesoundstart")
		stream:TimerRemove("tunesound")
	end

	if not self.NoiseSound:IsPlaying() then
		return
	end

	self.NoiseSound_vol = 0
	self.NoiseSound_volFadeTime = 0.5
end

function ENT:StartTuneSound(delay)
	local stream = self.StreamObj
	if not IsValid(stream) then
		return
	end

	stream:TimerRemove("tunesound")
	stream:TimerRemove("tunesoundstart")

	delay = delay or 0

	stream:TimerOnce("tunesoundstart", delay, function()
		if not IsValid(self) then return end

		if IsValid(stream) then
			stream:TimerRemove("tunesound")
			stream:TimerRemove("tunesoundstart")
		end

		if IsValid(stream:GetChannel()) then
			self:StopTuneSound()
			return
		end

		local noiseSound = self:CreateTuneSound()

		if not noiseSound then
			return
		end

		self.NoiseSound_vol = 1
		self.NoiseSound_volFadeTime = 2

		if not noiseSound:IsPlaying() then
			noiseSound:PlayEx(0, 100)
		end
	end)
end

function ENT:CreateTuneSound()
	if self.NoiseSound then
		return self.NoiseSound
	end

	if not self.Sounds_Noise then return end
	if self.Sounds_Noise == "" then return end

	self.NoiseSound = CreateSound(self, self.Sounds_Noise)
	self.NoiseSound:Stop()

	return self.NoiseSound
end

function ENT:ApplyTuneSound()
	local stream = self.StreamObj
	if not IsValid(stream) then return end

	local applyTuneSoundInternal = function()
		if not IsValid(self) then return end
		if not IsValid(stream) then return end

		stream:TimerRemove("tunesoundstart")
		stream:TimerRemove("tunesound")

		local isStopMode = stream:IsStopMode()
		if isStopMode then
			self.streamswitchsound = true
			self:StopTuneSound()
			return
		end

		if stream:GetMuted() then
			self.streamswitchsound = nil
			self:StopTuneSound()
			return
		end

		if stream:IsKilled() then
			self.streamswitchsound = true
			self:StopTuneSound()
			return
		end

		if IsValid(stream:GetChannel()) then
			self:FadeoutTuneSound()
			return
		end

		if stream:IsLoading() then
			self:StartTuneSound(2)
			return
		end

		if stream:HasError() then
			self.streamswitchsound = true
			self:StartTuneSound(0)
			return
		end
	end

	stream:TimerOnce("tunesound", 0.5, applyTuneSoundInternal)
	applyTuneSoundInternal()
end

function ENT:Initialize()
	BaseClass.Initialize(self)

	self.streamswitchsound = true
	self.slavesradios = {}
	self.old = {}

	local stream = self.StreamObj
	if IsValid(stream) then
		stream:SetEvent("OnPlayModeChange", self, function()
			if not IsValid(self) then return end
			self:ApplyTuneSound()
		end)

		stream:SetEvent("OnSearch", self, function()
			if not IsValid(self) then return end
			if not self.streamswitchsound then return end

			self:EmitSoundIfExist(self.Sounds_Tune, 50, 100, 1, CHAN_ITEM)
			self.streamswitchsound = nil
			self:ApplyTuneSound()
		end)

		stream:SetEvent("OnConnect", self, function()
			if not IsValid(self) then return end
			self:ApplyTuneSound()
		end)

		stream:SetEvent("OnError", self, function(this, errorCode)
			if not IsValid(self) then return end

			self:ApplyTuneSound()
		end)

		stream:SetEvent("OnMute", self, function(this, muted)
			if not IsValid(self) then return end

			if muted then
				self:StopTuneSound()
			else
				self:ApplyTuneSound()
			end
		end)
	end

	self:MarkForUpdatePlaybackLoopMode()
end

function ENT:OnModelSetup()
	self:StreamStopAnimModel()
end

function ENT:GetWallTraceParamenters()
	local wallTraceParamenters = self.WallTraceParamenters

	if not wallTraceParamenters then
		self.WallTraceParamenters = {}

		wallTraceParamenters = self.WallTraceParamenters
		wallTraceParamenters.mask = MASK_SHOT_PORTAL
		wallTraceParamenters.filter = {}
	end

	wallTraceParamenters.output = wallTraceParamenters.output or {}

	local camera = StreamRadioLib.GetCameraEnt(ent)
	local cameraVehicle = false

	if IsValid(camera) then
		cameraVehicle = camera.GetVehicle and camera:GetVehicle() or false
	else
		camera = false
	end

	local tmp = {}

	tmp[self] = self
	tmp[camera] = camera
	tmp[cameraVehicle] = cameraVehicle

	local filter = wallTraceParamenters.filter
	table.Empty(filter)

	for _, filterEnt in pairs(tmp) do
		if not IsValid(filterEnt) then continue end
		table.insert(filter, filterEnt)
	end

	for _, filterEnt in pairs(StreamRadioLib.SpawnedRadios) do
		table.insert(filter, filterEnt)
	end

	wallTraceParamenters.filter = filter
	return wallTraceParamenters
end

function ENT:TraceToCamera(frompos)
	local endpos = StreamRadioLib.GetCameraViewPos()
	local traceparams = self:GetWallTraceParamenters()

	traceparams.start = frompos
	traceparams.endpos = endpos

	util.TraceLine(traceparams)

	local result = traceparams.output

	-- Tracers Debug
	-- debugoverlay.Line(frompos, result.HitPos or endpos, 0.5, color_white, false)
	-- debugoverlay.Line(result.HitPos or endpos, endpos, 0.5, color_black, false)

	return result
end

function ENT:TraceWalls(radius)
	local startpos = self.SoundPos

	local camtrace = self:TraceToCamera(startpos)
	if not camtrace then return 1 end
	if not camtrace.Hit then return 1 end
	if not camtrace.HitPos then return 1 end

	local traceparams = self:GetWallTraceParamenters()

	traceparams.start = startpos

	local traces = StreamRadioLib.StarTrace(traceparams, radius)

	local blockcount = 0
	local wallcount = 0

	for i, trace in ipairs(traces) do
		if not trace.Hit then
			continue
		end

		if not trace.HitPos then
			continue
		end

		wallcount = wallcount + 1

		local camtrace = self:TraceToCamera(trace.HitPos)
		if not camtrace then continue end
		if not camtrace.Hit then continue end
		if not camtrace.HitPos then continue end

		blockcount = blockcount + 1
	end

	if wallcount <= 0 then
		return 1
	end

	if blockcount <= 0 then
		return 1
	end

	local f = blockcount / wallcount

	f = (1 - f) * 2

	local volfactor = math.Clamp(f, 0, 1)
	return volfactor
end

function ENT:GetWallVolumeFactor()
	if self.Muted then
		self.wallvolcache = nil
		return 0
	end

	if self:GetVolume() <= 0 then
		self.wallvolcache = nil
		return 0
	end

	local coveredvol = StreamRadioLib.GetCoveredVolume()

	if coveredvol >= 1 then
		self.wallvolcache = nil
		return 1
	end

	local streamingRadioCount = StreamRadioLib.GetStreamingRadioCount()
	if streamingRadioCount <= 0 then
		self.wallvolcache = nil
		return 1
	end

	local now = RealTime()

	self.wallvolcache = self.wallvolcache or {}
	local cache = self.wallvolcache
	local oldvalue = cache.value or 0

	if cache.nexttime and cache.nexttime > now then
		return math.max(oldvalue, coveredvol)
	end

	local startTime = SysTime()

	local value = self:TraceWalls(self.Radius) or 1

	local endTime = SysTime()
	local runtime = endTime - startTime

	local mintime = math.max(RealFrameTime() * 30, runtime * streamingRadioCount * 50, 0.1)

	if oldvalue <= 0 and value <= 0 then
		-- already quiet radios should retest less often
		mintime = math.max(mintime * 3, 0.5)
	elseif oldvalue >= 1 and value >= 1 then
		-- already clear radios should retest less often
		mintime = math.max(mintime * 3, 0.5)
	end

	mintime = math.Rand(mintime, mintime * 2)
	mintime = math.min(mintime, 3)

	cache.nexttime = now + mintime

	cache.value = value
	return math.max(value, coveredvol)
end

function ENT:GetWallVolumeFactorSmoothed()
	local now = RealTime()
	local last = self._wallvoltime or now
	self._wallvoltime = now

	local ticktime = now - last

	if ticktime <= 0 then
		return self._wallvolvalue or 0
	end

	local curwallvol = self:GetWallVolumeFactor()
	self._wallvolvalue = self._wallvolvalue or 0

	if self._wallvolvalue == curwallvol then
		return curwallvol
	end

	local speed = ticktime * 2

	self._wallvolvalue = math.Approach(self._wallvolvalue, curwallvol, speed)
	return self._wallvolvalue
end

function ENT:IsMuted()
	local ply = LocalPlayer()

	if not IsValid(ply) then return true end
	if not ply:IsPlayer() then return true end
	if ply:IsBot() then return true end

	if StreamRadioLib.IsMuted(ply, self:GetRealRadioOwner()) then
		return true
	end

	if self:GetSVMute() then
		return true
	end

	if self:GetCLMute() then
		return true
	end

	local willMute = self:IsMutedForPlayer(ply)
	local now = RealTime()

	if willMute then
		if not self._mutedTimer then
			self._mutedTimer = now + 1
		end

		if self._mutedTimer < now then
			return true
		end

		return false
	else
		self._mutedTimer = nil
	end

	return false
end

function ENT:UpdateStream()
	local streamObj = self.StreamObj

	if not IsValid(streamObj) then
		self:StreamStopAnimModel()
		return
	end

	if streamObj:IsStopMode() then
		self:StreamStopAnimModel()
		return
	end

	local ply = LocalPlayer()

	streamObj:Set3D(StreamRadioLib.Is3DSound() and self:GetSound3D())
	self.Sound3D = streamObj:Get3D()

	self.Radius = self:GetRadius() or 0
	streamObj:Set3DFadeDistance(self.Radius / 3)

	local muted = self:IsMuted()
	local clVolume = self:GetCLVolume()

	local wallVolume = 0
	local distVolume = 0
	local playerDistance = nil

	if not muted then
		playerDistance = self:DistanceToEntity(ply, nil, StreamRadioLib.GetCameraViewPos(ply))

		wallVolume = self:GetWallVolumeFactorSmoothed()
		distVolume = StreamRadioLib.CalcDistanceVolume(playerDistance, self.Radius)
	end

	self.PlayerDistance = playerDistance

	local StreamVol = distVolume * clVolume * wallVolume

	streamObj:SetMuted(muted)
	streamObj:SetClientVolume(StreamVol)

	self.Muted = muted

	if self.NoiseSound then
		local noiseSoundVol = self.NoiseSound_vol or 0

		local globalVolume = StreamRadioLib.GetGlobalVolume()
		globalVolume = math.Clamp(globalVolume, 0, 1)

		self.NoiseSound:ChangeVolume(streamObj:GetVolume() * globalVolume * clVolume * wallVolume * noiseSoundVol, 0.5)
	end

	self:StreamAnimModel()
end

function ENT:StreamAnimModel()
	local stream = self.StreamObj

	if not IsValid(stream) then
		self:StreamStopAnimModel()
		return
	end

	if not self.ModelData then
		self:StreamStopAnimModel()
		return
	end

	if self:IsDormant() then
		self:StreamStopAnimModel()
		return
	end

	if self.Muted then
		self:StreamStopAnimModel()
		return
	end

	if not self.PlayerDistance or self.PlayerDistance >= StreamRadioLib.GetSpectrumDistance() then
		self:StreamStopAnimModel()
		return
	end

	if stream:IsLoading() or stream:IsCheckingUrl() or stream:IsBuffering() then
		self:CallModelFunction("WhileLoading")
		return
	end

	if stream:HasError() then
		self:CallModelFunction("WhileError")
		return
	end

	if not stream:IsPlaying() then
		self:StreamStopAnimModel()
		return
	end

	local calcsl = self:HasModelFunction("SoundLevel")
	local calcspeaker = self:HasModelFunction("Speaker")
	local fftFunc = self:GetModelFunction("FFT")

	local modalData = self.ModelData

	if calcsl then
		self.AnimStopped = false

		self:CallModelFunction("SoundLevel", stream:GetAverageLevel())
	end

	if calcspeaker then
		self.AnimStopped = false

		local speakerlevel = 0
		local minfrq = modalData.SpeakerMinFRQ
		local maxfrq = modalData.SpeakerMaxFRQ
		local Resolution = modalData.SpeakerFRQResolution or 10

		stream:GetSpectrumComplex(Resolution, function( index, frq, level_length, level_ang, level_R, level_I )
			if not level_ang then
				local lambda = (1 / frq) / 2
				level_ang = math.random( -lambda, lambda )
			end

			local sin = math.sin( frq * math.pi * 2 + level_ang ) * level_length

			speakerlevel = speakerlevel + sin
			return true
		end, minfrq, maxfrq)

		speakerlevel = speakerlevel
		speakerlevel = math.Clamp( speakerlevel, -1, 1 )

		self:CallModelFunction("Speaker", speakerlevel)
	end

	if fftFunc then
		self.AnimStopped = false

		stream:GetSpectrumComplex( 7, function( index, frq, level_length, level_ang, level_R, level_I )
			fftFunc(modalData, index, frq, level_length)
		end)
	end
end

function ENT:FastThink()
	BaseClass.FastThink(self)

	self:MasterRadioSyncThink()
end

function ENT:InternalThink()
	BaseClass.InternalThink(self)

	self:UpdateStream()

	self:CallModelFunction("Think")
end

function ENT:InternalSlowThink()
	BaseClass.InternalSlowThink(self)

	self:PlaybackLoopModeThink()
	self:PanelThink()

	return true
end

function ENT:OnMasterradioChange(masterradio, oldmasterradio)
	local eventname = tostring(self) .. "_master_sync"
	local timername = eventname .. "_errorretry"

	local this_st = self.StreamObj

	this_st:RemoveEvent("OnError", eventname)
	this_st:RemoveEvent("OnConnect", eventname)
	this_st:TimerRemove(timername)

	if IsValid(oldmasterradio) then
		if IsValid(oldmasterradio.StreamObj) then
			oldmasterradio.StreamObj:RemoveEvent("OnConnect", eventname)
		end
	end

	if IsValid(masterradio) then
		local master_st = masterradio.StreamObj

		master_st:RemoveEvent("OnConnect", eventname)
		master_st:SetEvent("OnConnect", eventname, function()
			if not IsValid(self) then
				master_st:RemoveEvent("OnConnect", eventname)
				return
			end

			if not IsValid(masterradio) then
				master_st:RemoveEvent("OnConnect", eventname)
				return
			end

			if this_st:IsRunning() and this_st:GetError() == 0 then
				return
			end

			this_st:TimerRemove(timername)
			this_st:Reconnect()
		end)

		this_st:SetEvent("OnError", eventname, function()
			this_st:TimerRemove(timername)

			if not IsValid(self) then
				this_st:RemoveEvent("OnError", eventname)
				return
			end

			if not IsValid(masterradio) then
				this_st:RemoveEvent("OnError", eventname)
				return
			end

			if not IsValid(master_st) then
				this_st:RemoveEvent("OnError", eventname)
				return
			end

			this_st:TimerOnce(eventname .. "_errorretry", 10, function()
				if not IsValid(self) then
					this_st:RemoveEvent("OnError", eventname)
					return
				end

				if not IsValid(masterradio) then
					this_st:RemoveEvent("OnError", eventname)
					return
				end

				if not IsValid(master_st) then
					this_st:RemoveEvent("OnError", eventname)
					return
				end

				if this_st:IsRunning() and this_st:GetError() == 0 then
					return
				end

				this_st:Reconnect()
			end)
		end)
	end
end

function ENT:DrawTranslucent(...)
	BaseClass.DrawTranslucent(self, ...)
	self:CallModelFunction("Draw", ...)
end

function ENT:PostFakeRemove()
	self:ApplyTuneSound()
end

function ENT:OnRemove()
	self:OnRemoveShared()

	BaseClass.OnRemove(self)

	self:StopTuneSound()
end

--gamemodes/darkrp/entities/entities/spawned_ammo/shared.lua:
return gluapack()()
--gamemodes/darkrp/entities/entities/spawned_money/cl_init.lua:
return gluapack()()
--lua/entities/sv_gaspump/cl_init.lua:
return gluapack()()
--lua/entities/sv_petrol_canister/shared.lua:
ENT.Base = "base_entity"
ENT.Type = "anim"

ENT.PrintName = "Petrol canister"
ENT.Category = "SVMod"
ENT.Author = "TomLaVachette"
ENT.Contact = "From workshop page only!"
ENT.Instructions = "Touch a vehicle with the canister to fill the vehicle with petrol."

ENT.Spawnable = true
ENT.AdminOnly = true
--lua/entities/used_efes.lua:
AddCSLuaFile()

DEFINE_BASECLASS("base_gmodentity")

ENT.PrintName = "Used Efes"

ENT.Author = "RebS"

ENT.Editable = false
ENT.Spawnable = false
ENT.AdminOnly = false
ENT.Sound = nil

function ENT:Initialize()

	self.Entity:PhysicsInit(SOLID_VPHYSICS)
	self.Entity:SetMoveType(MOVETYPE_VPHYSICS)
	self.Entity:SetSolid(SOLID_VPHYSICS)
	self.Entity:SetCollisionGroup(COLLISION_GROUP_INTERACTIVE)
	self.Entity:SetBodygroup(0,1)
	self.Entity:SetBodygroup(1,1)
	self.Entity:SetBodygroup(2,1)
	self.Entity:SetSkin(1)

	local phys = self.Entity:GetPhysicsObject()
	if phys and phys:IsValid() then phys:Wake() end
	
end

function ENT:Draw()
	self.Entity:DrawModel()
end
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_doobytable/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "anim"
ENT.Base                    = "base_anim"
ENT.AutomaticFrameAdvance   = false
ENT.PrintName               = "DoobyTable"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_doobytable.mdl"
ENT.RenderGroup             = RENDERGROUP_OPAQUE

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "DoobyProgress")
    self:NetworkVar("Int", 1, "WeedID")
    self:NetworkVar("Int", 3, "WeedAmount")
    self:NetworkVar("Int", 4, "WeedTHC")

    self:NetworkVar("Vector", 0, "GamePos")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

    if (SERVER) then
        self:SetDoobyProgress(0)
        self:SetWeedID(-1)
        self:SetWeedAmount(0)
        self:SetWeedTHC(0)
        self:SetGamePos(Vector(0,0,0))
    end
end

function ENT:OnRemoveButton(ply)
    local trace = ply:GetEyeTrace()
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

    local lp = self:WorldToLocal(trace.HitPos)

    if lp.x > -5 and lp.x < -2 and lp.y < 22 and lp.y > 13 and lp.z > 5 and lp.z < 6 then
        return true
    else
        return false
    end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

function ENT:OnStartButton(ply)
    local trace = ply:GetEyeTrace()

    local lp = self:WorldToLocal(trace.HitPos)

    if lp.x > -8.5 and lp.x < -5 and lp.y < 22 and lp.y > 13 and lp.z > 5 and lp.z < 6 then
        return true
    else
        return false
    end
end

function ENT:OnPaper(ply)
    local trace = ply:GetEyeTrace()

    local lp = self:WorldToLocal(trace.HitPos)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595

    if lp.x > -2.2 and lp.x < 2.5 and lp.y < 2.8 and lp.y > -2.8 and lp.z > 5 and lp.z < 6 then
        return true
    else
        return false
    end
end

function ENT:OnGrinder(ply)
    local trace = ply:GetEyeTrace()

    local lp = self:WorldToLocal(trace.HitPos)

    if lp.x > -9 and lp.x < -4.9 and lp.y < -14 and lp.y > -20 and lp.z > 5 and lp.z < 6 then
        return true
    else
        return false
    end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586

function ENT:OnHitButton(ply)
    local trace = ply:GetEyeTrace()
    local lp = self:WorldToLocal(trace.HitPos)

    local LGP = self:GetGamePos()


    if lp.x < (LGP.x + 1) and lp.x > (LGP.x - 4) and lp.y < (LGP.y + 3) and lp.y > (LGP.y - 3) then
        return true
    else
        return false
    end
end

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_jarcrate.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zgo2_item_base")
ENT.Type                    = "anim"
ENT.Base                    = "zgo2_item_base"
ENT.AutomaticFrameAdvance   = false
ENT.PrintName               = "Jar Crate"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_jarcrate.mdl"
ENT.RenderGroup             = RENDERGROUP_BOTH

function ENT:CanProperty(ply)
    return ply:IsSuperAdmin()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

function ENT:CanTool(ply, tab, str)
    return ply:IsSuperAdmin()
end

function ENT:CanDrive(ply)
    return false
end

if SERVER then
	function ENT:Initialize()
		zgo2.JarCrate.Initialize(self)
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

	function ENT:OnRemove()
		zgo2.JarCrate.OnRemove(self)
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a

	function ENT:AcceptInput(inputName, activator, caller, data)
		if inputName == "Use" and IsValid(activator) and activator:IsPlayer() and activator:Alive() then
			zgo2.JarCrate.OnUse(self, activator)
		end
	end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

	function ENT:StartTouch(other)
		zgo2.JarCrate.OnStartTouch(self, other)
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_mixer/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "anim"
ENT.Base                    = "base_anim"
ENT.AutomaticFrameAdvance   = true
ENT.PrintName               = "Mixer"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_mixer.mdl"
ENT.RenderGroup             = RENDERGROUP_OPAQUE

function ENT:SetupDataTables()
    self:NetworkVar("Bool", 0, "HasBowl")
    self:NetworkVar("Bool", 1, "HasDough")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

    self:NetworkVar("Int", 0, "WeedID")
    self:NetworkVar("Int", 1, "WeedAmount")
    self:NetworkVar("Int", 2, "WeedTHC")

    // 0 = idle, 1 = open , 2 = close , 3 = run
    self:NetworkVar("Int", 3, "WorkState")

	self:NetworkVar("Int", 4, "EdibleID")


    if (SERVER) then
		self:SetEdibleID(0)

        self:SetWorkState(0)
        self:SetHasBowl(true)
        self:SetHasDough(false)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

        self:SetWeedID(-1)
        self:SetWeedAmount(0)
        self:SetWeedTHC(0)
    end
end

function ENT:OnRemoveButton(ply)
    local trace = ply:GetEyeTrace()
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

    local lp = self:WorldToLocal(trace.HitPos)

    if lp.x > -12 and lp.x < 4 and lp.y < 12 and lp.y > 11 and lp.z > 9 and lp.z < 20 then
        return true
    else
        return false
    end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_motor.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_npc_export/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_oven/cl_init.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_oven/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "anim"
ENT.Base                    = "base_anim"
ENT.AutomaticFrameAdvance   = true
ENT.PrintName               = "Oven"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_oven.mdl"
ENT.RenderGroup             = RENDERGROUP_BOTH

function ENT:SetupDataTables()

    self:NetworkVar("Bool", 0, "IsBaking")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

	self:NetworkVar("Int", 1, "EdibleID")
	self:NetworkVar("Int", 2, "WeedID")

    if (SERVER) then
		self:SetEdibleID(0)
        self:SetIsBaking(false)
		self:SetWeedID(-1)
    end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595

function ENT:OnRemoveButton(ply)
    local trace = ply:GetEyeTrace()
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- c360111a1078b749c222565727765c993fb6b426190023d6d23362bac0c7683a

    local lp = self:WorldToLocal(trace.HitPos)

    if lp.x > -8.5 and lp.x < 0 and lp.y < 12 and lp.y > 11 and lp.z > 14 and lp.z < 18 then
        return true
    else
        return false
    end
end

function ENT:OnStartButton(ply)
    local trace = ply:GetEyeTrace()

    local lp = self:WorldToLocal(trace.HitPos)

    if lp.x > 2.5 and lp.x < 8 and lp.y < 7 and lp.y > 6 and lp.z > 24.7 and lp.z < 27.2 then
        return true
    else
        return false
    end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 8ffb188c701d3f1856df3a15bfe8e14b5be84a41e03a52af8e86de4fbee82eeb

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_rack/shared.lua:
return gluapack()()
--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_rack/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "anim"
ENT.Base                    = "base_anim"
ENT.AutomaticFrameAdvance   = false
ENT.PrintName               = "Rack"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = false
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_rack.mdl"
ENT.RenderGroup             = RENDERGROUP_OPAQUE

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "RackID")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a

	if (SERVER) then
		self:SetRackID(1)
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 70b873f322570e153a05d9cee15c50a5d97bffffec86f684a14bf17014b60342

function ENT:CanProperty(ply)
    return ply:IsSuperAdmin()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

function ENT:CanTool(ply, tab, str)
    return ply:IsSuperAdmin()
end

function ENT:CanDrive(ply)
    return false
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a

function ENT:GravGunPickupAllowed( ply )
	return false
end

function ENT:GravGunPunt( ply )
	return false
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_seedlibary/shared.lua:
/*
    Addon id: 64edeaec-8955-454a-aac4-1d19d72ee4af
    Version: v1.6.1 (stable)
*/

ENT.Type                    = "anim"
ENT.Base                    = "base_anim"
ENT.PrintName               = "Seed Libary"
ENT.Author                  = "ZeroChain"
ENT.Category                = "Zeros GrowOP 2"
ENT.Spawnable               = true
ENT.AdminSpawnable          = false
ENT.Model                   = "models/zerochain/props_growop2/zgo2_seedlibary.mdl"
ENT.RenderGroup             = RENDERGROUP_OPAQUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 5f074b2717244cb0b28afc4f82cbfebeed301ee81f5a05ae65232daad257b16a
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- a0e6ade09fe02808a86c0dfaee2704d791bcc0344cd386f9ebfd43c1dd1de59e
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224586
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198314224595

--addons/zeros_growop2_v1.6.1/lua/entities/zgo2_tent/shared.lua:
return gluapack()()
--addons/zeros_golddiggger/lua/entities/zgw_jar/shared.lua:
return gluapack()()
--addons/zeros_golddiggger/lua/entities/zgw_lantern/cl_init.lua:
return gluapack()()
--addons/zeros_golddiggger/lua/entities/zgw_mat/cl_init.lua:


include("shared.lua")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 0a5818b862f942a32f280da19656bfe6fb14cbd620f4eff776b06ce3fb51fd0e
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 549ca24f37f8589f265ca557954c28b4325c41edf21ed3859b40baf576d8adf4

function ENT:DrawTranslucent()
	self:Draw()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 9ac369ca150c22e64f828cd5857ffea33c11645bd3819881a5581360ebf7ce05
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198872838622

function ENT:Draw()
	self:DrawModel()
	zgw.RubberMat.Draw(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 549ca24f37f8589f265ca557954c28b4325c41edf21ed3859b40baf576d8adf4

--addons/zeros_golddiggger/lua/entities/zgw_pumphead/cl_init.lua:
return gluapack()()
--addons/zeros_golddiggger/lua/entities/zgw_pumphead/cl_init.lua:


include("shared.lua")

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Draw()
	self:DrawModel()
end

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_dropoff/shared.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_item_crate/cl_init.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_item_palette/cl_init.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_machine_filler/cl_init.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

include("shared.lua")

function ENT:Initialize()
	zmlab2.Filler.Initialize(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0

function ENT:DrawTranslucent()
	self:Draw()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 15871293219a231313fbdc551fcfaeb89901409b08b17abf512df78d792aeeea

function ENT:Draw()
	self:DrawModel()
	zmlab2.Filler.Draw(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

function ENT:Think()
    zmlab2.Filler.Think(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 15871293219a231313fbdc551fcfaeb89901409b08b17abf512df78d792aeeea
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- b59bd1b1f8d16a52cb3d0a12454834a0ad28afe2633004db7a9dc71add4aef45

function ENT:OnRemove()
    zmlab2.Filler.OnRemove(self)
end

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_machine_frezzer/shared.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_machine_mixer/cl_init.lua:
return gluapack()()
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_npc/cl_init.lua:
include("shared.lua")

function ENT:Draw()
  self:DrawModel()
  if not binbonentdraw then return end
  binbonentdraw(self, "Profesyonel Meth Alıcısı", true, 0, 10, 20, true)
  binbonentdraw(self, "Ürettiğin profesyonel methleri bana satabilirsin.", false, 0,100, 20, false)
end
--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_tent/cl_init.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

include("shared.lua")

function ENT:Initialize()
	zmlab2.Tent.Initialize(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- b59bd1b1f8d16a52cb3d0a12454834a0ad28afe2633004db7a9dc71add4aef45

function ENT:DrawTranslucent()
	self:Draw()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 008d00393091244a629b726da410c82cc21d3876952f1a2fa78c80bc6afb7013

function ENT:Draw()
	self:DrawModel()
	zmlab2.Tent.Draw(self)
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218033

function ENT:Think()
	self:SetNextClientThink(CurTime())
	zmlab2.Tent.OnThink(self)

	return true
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

function ENT:OnRemove()
	zmlab2.Tent.OnRemove(self)
end

--addons/zeros_methlab02_v1.4.1/lua/entities/zmlab2_tent/shared.lua:
/*
    Addon id: a36a6eee-6041-4541-9849-360baff995a2
    Version: v1.4.1 (stable)
*/

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_tentkit.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Tent"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

function ENT:SetupDataTables()

    self:NetworkVar("Int", 1, "BuildState")
    self:NetworkVar("Int", 2, "BuildCompletion")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

    self:NetworkVar("Int", 3, "TentID")

    self:NetworkVar("Int", 4, "ColorID")

    self:NetworkVar("Bool", 1, "IsPublic")

    self:NetworkVar("Int", 5, "LastExtinguish")


    if (SERVER) then
        self:SetTentID(-1)
        self:SetColorID(1)
		// 310956616
        // Unfolded
        self:SetBuildState(-1)
        self:SetBuildCompletion(-1)

        self:SetIsPublic(false)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- f846397ffcf09571d053f7b7aff0b4ab920f6d7152aebc0550c4aa612acbeab0

        self:SetLastExtinguish(0)
    end
end

function ENT:OnControllPanel(ply)
    if self:GetAttachment(1) == nil then return false end
    local trace = ply:GetEyeTrace()

    if trace.HitPos:Distance(self:GetAttachment(1).Pos) < 5 then
        return true
    else
        return false
    end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- b59bd1b1f8d16a52cb3d0a12454834a0ad28afe2633004db7a9dc71add4aef45
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 76561198347218024

function ENT:OnLightButton(ply)
    if self:GetAttachment(1) == nil then return false end
    local attach = self:GetAttachment(1)
    local trace = ply:GetEyeTrace()
    if zclib.util.InDistance(attach.Pos - attach.Ang:Forward() * 5, trace.HitPos, 2) then
        return true
    else
        return false
    end
end

function ENT:OnExtinquisher(ply)
    if self:GetAttachment(1) == nil then return false end
    local attach = self:GetAttachment(1)
    local trace = ply:GetEyeTrace()
    if zclib.util.InDistance(attach.Pos, trace.HitPos, 2) then
        return true
    else
        return false
    end
end

function ENT:OnFoldButton(ply)
    if self:GetAttachment(1) == nil then return false end
    local attach = self:GetAttachment(1)
    local trace = ply:GetEyeTrace()

    //debugoverlay.Sphere(attach.Pos - attach.Ang:Forward() * 5,2,0.1,Color( 255, 255, 255 ),true)

    if zclib.util.InDistance(attach.Pos + attach.Ang:Forward() * 5, trace.HitPos, 2) then
        return true
    else
        return false
    end
end

function ENT:CanProperty(ply)
    return zclib.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return str == "colour" or zclib.Player.IsAdmin(ply)
end

function ENT:CanDrive(ply)
    return zclib.Player.IsAdmin(ply)
end

--addons/zeros_methlab_1.6.4/lua/entities/zmlab_aluminium/shared.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_filter/cl_init.lua:
return gluapack()()
--addons/zeros_methlab_1.6.4/lua/entities/zmlab_frezzer/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.LastUsedPositions = -1
	self.LastFrezze = 0
end

function ENT:Draw()
	self:DrawModel()
	if zmlab.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 1000) and GetConVar("zmlab_cl_vfx_dynamiclight"):GetInt() == 1 then

		local dlight01 = DynamicLight(self:EntIndex())

		if (dlight01 and self:GetIsFreezing()) then
			dlight01.pos = self:GetPos() + self:GetUp() * 50 + self:GetRight() * 20
			dlight01.r = 0
			dlight01.g = 200
			dlight01.b = 255
			dlight01.brightness = 2
			dlight01.Decay = 1000
			dlight01.Size = 300
			dlight01.DieTime = CurTime() + 1
		end
	end
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Think()
	if zmlab.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 600) then
		local usedPos = self:GetUsedPositions()

		if self.LastUsedPositions ~= usedPos then
			if usedPos > self.LastUsedPositions then
				self:EmitSound("frezzer_addTray")
			else
				self:EmitSound("frezzer_removeTray")
			end

			self.LastUsedPositions = usedPos
		end

		if self:GetIsFreezing() and CurTime() > self.LastFrezze then
			self:EmitSound("progress_frezzing")
			if GetConVar("zmlab_cl_vfx_particleeffects"):GetInt() == 1 then
				ParticleEffect("zmlab_frozen_tray", self:GetPos() + self:GetUp() * 25, self:GetAngles(), self)
				ParticleEffect("zmlab_frozen_tray", self:GetPos() + self:GetUp() * 35, self:GetAngles(), self)
				ParticleEffect("zmlab_frozen_tray", self:GetPos() + self:GetUp() * 45, self:GetAngles(), self)
				ParticleEffect("zmlab_frozen_tray", self:GetPos() + self:GetUp() * 55, self:GetAngles(), self)
				ParticleEffect("zmlab_frozen_tray", self:GetPos() + self:GetUp() * 65, self:GetAngles(), self)
			end
			self.LastFrezze = CurTime() + 1
		end
	end
end

--addons/zeros_methlab_1.6.4/lua/entities/zmlab_meth/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Meth"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros Meth Lab"

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "MethAmount")

	if (SERVER) then
		self:SetMethAmount(100)
	end
end

--addons/zeros_methlab_1.6.4/lua/entities/zmlab_methdropoff/cl_init.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_basket_bronze.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_basket_iron.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_conveyorbelt/cl_init.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_gravelcrate/shared.lua:
return gluapack()()
--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_refiner/cl_init.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

include("shared.lua")

function ENT:Initialize()
	self:Setup_Conveyorbelt_Material()
	self:Setup_PaintLack_Material()

	self.InsertEffect = ParticleEmitter(self:GetPos())

	zrmine.f.EntList_Add(self)

	// Sets up stuff for the client gravel animation
	zrmine.f.Gravel_Initialize(self)

	// The refined gravel animation cycle
	self.rg_cycle = 0

	self.State = -1
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	self.RefineStart = -1
end

// Animated Belt
function ENT:Setup_Conveyorbelt_Material()
	local params = {
		["$basetexture"] = "zerochain/props_mining/conveyorbelt/zrms_conveyorbelt_belt_diff",
		["$bumpMap"] = "zerochain/props_mining/conveyorbelt/zrms_conveyorbelt_belt_nrm",
		["$normalmapalphaenvmapmask"] = 1,
		["$surfaceprop"] = "metal",
		["$halflambert"] = 1,
		["$model"] = 1,
		["$envmap"] = "env_cubemap",
		["$envmaptint"] = Vector(0.01, 0.01, 0.01),
		["$envmapfresnel"] = 1,
		["$phong"] = 1,
		["$phongexponenttexture"] = "zerochain/props_mining/conveyorbelt/zrms_conveyorbelt_belt_phong",
		["$phongtint"] = Vector(1, 1, 1),
		["$phongboost"] = 25,
		["$phongfresnelranges"] = Vector(0.05, 0.5, 1),
		["$myspeed"] = 0,
		Proxies = {
			TextureScroll = {
				texturescrollvar = "$baseTexturetransform",
				texturescrollrate = "$myspeed",
				texturescrollangle = -90
			}
		}
	}

	self.ScrollMat = CreateMaterial("Refiner_ScrollMat" .. self:EntIndex(), "VertexLitGeneric", params)
	self:SetSubMaterial(1, "!Refiner_ScrollMat" .. self:EntIndex())
end

// Color painted Lack
function ENT:Setup_PaintLack_Material()
	local paintColor = zrmine.f.ColorToVector(zrmine.f.GetOreColor(self.RefinerType))

	local params = {
		["$basetexture"] = "zerochain/props_mining/refinery/zrms_refiner_diff",
		["$color2"] = paintColor,
		["$blendTintByBaseAlpha"] = 1,
		["$blendTintColorOverBase"] = 0,
		["$bumpMap"] = "zerochain/props_mining/refinery/zrms_refiner_nrm",
		["$normalmapalphaenvmapmask"] = 1,
		["$surfaceprop"] = "metal",
		["$halflambert"] = 1,
		["$model"] = 1,
		["$envmap"] = "env_cubemap",
		["$envmaptint"] = paintColor,
		["$envmapfresnel"] = 1,
		["$phong"] = 1,
		["$phongexponenttexture"] = "zerochain/props_mining/refinery/zrms_refiner_phong",
		["$phongtint"] = paintColor,
		["$phongboost"] = 15,
		["$phongfresnelranges"] = Vector(0.05, 0.5, 1)
	}

	self.PaintMat = CreateMaterial("RefinerPaint" .. self:EntIndex(), "VertexLitGeneric", params)
	self.PaintMat:SetVector("$color2", paintColor)
	self.PaintMat:SetFloat("$blendTintColorOverBase", 0.1)
	self:SetSubMaterial(5, "!RefinerPaint" .. self:EntIndex())
end


function ENT:UpdateState()
	local CurrentState = self:GetCurrentState()

	if self.State ~= CurrentState then
		self.State = CurrentState

		if CurrentState == 2 then

			self.ScrollMat:SetFloat("$myspeed", 2)

			self.RefineStart = CurTime()

			//Plays the crush sound
			zrmine.f.EmitSoundENT("zrmine_crush",self)

			//Plays the REFINING animation
			if self:GetSequenceName(self:GetSequence()) ~= "refine" then

				local animSpeed = 2 / self.RefiningTime
				animSpeed = math.Clamp(animSpeed,1,2)

				zrmine.f.Animation(self, "refine", animSpeed)
			end
		elseif CurrentState == 1 then

			self.ScrollMat:SetFloat("$myspeed", 2)

			zrmine.f.EmitSoundENT("zrmine_crush",self)
		else

			self.RefineStart = -1

			self.ScrollMat:SetFloat("$myspeed", 0)

			if self:GetSequenceName(self:GetSequence()) ~= "idle" then
				zrmine.f.Animation(self, "idle", 1)
			end
		end
	end
end

function ENT:RefineSound()
	local MoveSound = CreateSound(self, "zrmine_sfx_refinery_loop")

	if self.State == 2 then
		if self.SoundObj == nil then
			self.SoundObj = MoveSound
		end

		if self.SoundObj:IsPlaying() == false then
			//self:EmitSound("zms_drill_start")
			self.SoundObj:Play()
			self.SoundObj:ChangeVolume(0, 0)
			self.SoundObj:ChangeVolume(GetConVar("zrms_cl_audiovolume"):GetFloat(), 1)
		end
	else
		if self.SoundObj == nil then
			self.SoundObj = MoveSound
		end

		if self.SoundObj:IsPlaying() == true then
			self.SoundObj:ChangeVolume(0, 1)
			if ((self.lastSoundStop or CurTime()) > CurTime()) then return end
			self.lastSoundStop = CurTime() + 5

			timer.Simple(2, function()
				if (IsValid(self)) then
					self.SoundObj:Stop()
				end
			end)
		end
	end
end

function ENT:Think()
	if zrmine.f.InDistance(self:GetPos(), LocalPlayer():GetPos(), 1000) then
		self:UpdateState()

		self:RefineSound()

		// Handels the gravel animation
		zrmine.f.ClientGravelAnim(self)

		// Handels the refine gravel anim
		self:ClientRefinedGravelAnim()
	end
	self:SetNextClientThink(CurTime())
	return true
end





// 2D Light Sprites
function ENT:IndicatorLight(id,pos,state)

	local LightPos = self:LocalToWorld(pos)

	local ViewNormal = self:GetPos() - EyePos()
	ViewNormal:Normalize()

	if self.PixelVisibleHandles == nil then
		self.PixelVisibleHandles = {}
	end

	//Create PixelVisibleHandle if nil
	if self.PixelVisibleHandles[id] == nil then
		self.PixelVisibleHandles[id] = {
			handle = util.GetPixelVisibleHandle(),
			IsVisible = 0,
		}
	end

	self.PixelVisibleHandles[id].IsVisible = util.PixelVisible(LightPos, 3,self.PixelVisibleHandles[id].handle)

	if self.PixelVisibleHandles[id].IsVisible and self.PixelVisibleHandles[id].IsVisible > 0.1 then
		local spriteColor = zrmine.default_colors["red03"]
		if state then
			spriteColor = zrmine.default_colors["green02"]
		end

		render.SetMaterial(zrmine.default_materials["light_ignorez"])
		render.DrawSprite(LightPos, 25, 25, spriteColor)
	end
end

function ENT:Draw()
	self:DrawModel()

	zrmine.f.UpdateEntityVisuals(self)

	if zrmine.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) then
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

		if GetConVar("zrms_cl_lightsprites"):GetInt() == 1 then
			self:IndicatorLight("Refinery",Vector(-21,0,44),IsValid(self:GetModuleChild()))
			self:IndicatorLight("Basket",Vector(0,-15,28),IsValid(self:GetBasket()))
		end

		self:DrawInfo()
	end
end

function ENT:DrawTranslucent()
	self:Draw()
end


function ENT:UpdateVisuals()

	if (self:GetSubMaterial(1) ~= "!Refiner_ScrollMat" .. self:EntIndex()) then
		self:SetSubMaterial(1, "!Refiner_ScrollMat" .. self:EntIndex())
	end

	if (self:GetSubMaterial(5) ~= "!RefinerPaint" .. self:EntIndex()) then
		self:SetSubMaterial(5, "!RefinerPaint" .. self:EntIndex())
	end

	// This Sets the belt scroll speed of the mat
	if (self.State == 2 or self.State == 1) then
		self.ScrollMat:SetFloat("$myspeed", 2)
	else
		self.ScrollMat:SetFloat("$myspeed", 0)
	end
end


// UI Stuff
local offsetX, offsetY = 15, 10
function ENT:DrawResourceItem(Info, color, xpos, ypos, size)
	surface.SetDrawColor(color)
	surface.SetMaterial(zrmine.default_materials["Ore"])
	surface.DrawTexturedRect(xpos + offsetX, ypos + offsetY, size, size)

	draw.DrawText(Info, "zrmine_screen_font1", xpos + offsetX + 50, ypos + offsetY + size * 0.22, color, TEXT_ALIGN_LEFT)
end

function ENT:DrawInfo()
	local status = ""
	if (self.State == 2) then
		status = zrmine.language.Refiner_Refining
	elseif (self.State == 0) then
		status = zrmine.language.Refiner_Waiting
	elseif (self.State == 1) then
		status = zrmine.language.Refiner_Moving
	end

	cam.Start3D2D(self:LocalToWorld(Vector(0,-15.4,39.4)), self:LocalToWorldAngles(Angle(0,0,90)), 0.1)
		draw.RoundedBox(0, -105, -65, 210, 130, zrmine.default_colors["grey02"])
		self:Draw_ResourceBar("Coal", 0)
		self:Draw_ResourceBar("Iron", 6)
		self:Draw_ResourceBar("Bronze", 12)
		self:Draw_ResourceBar("Silver", 18)
		self:Draw_ResourceBar("Gold", 24)

		if self.State == 2 then
			local refineTimeEnd = self.RefineStart +  self.RefiningTime
			local barSize = 130 / self.RefiningTime
			barSize = barSize * (refineTimeEnd - CurTime())
			barSize = math.Clamp(barSize,0,130)
			draw.RoundedBox(5, -50, -15, 130, 20, zrmine.default_colors["grey07"])
			draw.RoundedBox(5, -50, -15,barSize, 20, zrmine.default_colors["grey06"])
		end

		draw.DrawText(status, "zrmine_screen_font3", 15, -15,zrmine.default_colors["yellow01"], TEXT_ALIGN_CENTER)

		local amount = zrmine.f.GetOreFromEnt(self,self.RefinerType)

		self:Draw_ResourceAmount(amount,  zrmine.f.GetOreTranslation(self.RefinerType),zrmine.f.GetOreColor(self.RefinerType))
	cam.End3D2D()
end

function ENT:Draw_ResourceAmount(amount, name,OreColor)

	amount = ": " .. math.Round(amount) .. zrmine.config.BuyerNPC_Mass
	self:DrawResourceItem(amount, OreColor, -60, 0, 50)

	draw.DrawText(name, "zrmine_screen_font2", 15, -55, zrmine.default_colors["white02"], TEXT_ALIGN_CENTER)

	surface.SetDrawColor(zrmine.default_colors["white02"])
	surface.SetMaterial(zrmine.default_materials["Scale"])
	surface.DrawTexturedRect(-110, -53, 75, 105)
end

function ENT:Draw_ResourceBar(rtype, xOffset)
	local ramount = zrmine.f.GetOreFromEnt(self,rtype)
	local rpaintColor = zrmine.f.GetOreColor(rtype)

	local refCap = zrmine.config.Refiner_Capacity
	local r_Bar = (100 / refCap) * ramount

	if (r_Bar > 100) then
		r_Bar = 100
	end

	draw.RoundedBox(0, -87 + xOffset, 50, 5, -r_Bar, rpaintColor)
end


// Refine Gravel Anim
function ENT:ClientRefinedGravelAnim()
	if self.ClientProps == nil then
		self.ClientProps = {}
	end

	if zrmine.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 1000) then

		if IsValid(self.ClientProps["RefineGravel"]) then

			// The requested animation type aka skin
			local r_type = self:GetRefineAnim_Type()

			if r_type == -1 then
				self.ClientProps["RefineGravel"]:SetNoDraw(true)
				self.rg_cycle = 0
			else

				local speed = 1.5

				self.rg_cycle = math.Clamp(self.rg_cycle + (1 / speed) * FrameTime(), 0, 1)

				if self.rg_cycle >= 1 then
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

					self.ClientProps["RefineGravel"]:SetNoDraw(true)
				else
					self.ClientProps["RefineGravel"]:SetPos(self:LocalToWorld(Vector(0,5,0)))
					self.ClientProps["RefineGravel"]:SetSkin(r_type)
					self.ClientProps["RefineGravel"]:SetNoDraw(false)
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

					local sequence = self.ClientProps["RefineGravel"]:LookupSequence("refined")
					self.ClientProps["RefineGravel"]:SetSequence(sequence)
					self.ClientProps["RefineGravel"]:SetPlaybackRate(1)
					self.ClientProps["RefineGravel"]:SetCycle(self.rg_cycle)
				end
			end
		else
			self:CreateClientGravel()
		end
	else

		if IsValid(self.ClientProps["RefineGravel"]) then
			self.ClientProps["RefineGravel"]:Remove()
		end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

		self.rg_cycle = 0
	end
end

function ENT:CreateClientGravel()
	local gravel = ents.CreateClientProp()

	gravel:SetPos(self:LocalToWorld(Vector(0,0,0)))
	gravel:SetModel("models/zerochain/props_mining/zrms_refinedgravel01.mdl")
	gravel:SetAngles(self:GetAngles())

	gravel:Spawn()
	gravel:Activate()

	gravel:SetRenderMode(RENDERMODE_NORMAL)
	gravel:SetParent(self)
	gravel:SetNoDraw(true)

	self.ClientProps["RefineGravel"] = gravel
end


function ENT:OnRemove()
	if (self.SoundObj ~= nil and self.SoundObj:IsPlaying()) then
		self.SoundObj:Stop()
	end
end

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_refiner_silver.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_refiner")
ENT.Type = "anim"
ENT.Base = "zrms_refiner"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Refiner - Silver"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
ENT.RefinerType = "Silver"
ENT.RefiningTime = zrmine.config.Silver_RefiningTime
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_sorter_coal.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

AddCSLuaFile()
DEFINE_BASECLASS("zrms_sorter")
ENT.Type = "anim"
ENT.Base = "zrms_sorter"
ENT.RenderGroup = RENDERGROUP_OPAQUE
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Filter - Coal"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.Model = "models/zerochain/props_mining/zrms_conveyorbelt_sorter.mdl"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
ENT.SorterSpeed = 3
ENT.WorkAmount = 6
ENT.HoldAmount = 25
ENT.FilterType = "Coal" // What type of resource are we sorting out
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_retrominer_v2.3.6/lua/entities/zrms_storagecrate/shared.lua:
/*
    Addon id: 
    Version: v2.3.6 (stable)
*/

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Storage Crate"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "info"
ENT.Category = "Zeros RetroMiningSystem"
ENT.Model = "models/Zerochain/props_mining/zrms_storagecrate.mdl"
ENT.AutomaticFrameAdvance = true
ENT.DisableDuplicator = false
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "bIron")
	self:NetworkVar("Float", 1, "bBronze")
	self:NetworkVar("Float", 2, "bSilver")
	self:NetworkVar("Float", 3, "bGold")

	self:NetworkVar("Bool", 0, "IsClosed")
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

	if (SERVER) then
		self:SetbIron(0)
		self:SetbBronze(0)
		self:SetbSilver(0)
		self:SetbGold(0)

		self:SetIsClosed(false)
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

function ENT:GetBarCount()
	return self:GetbIron() + self:GetbBronze() + self:GetbSilver() + self:GetbGold()
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                       -- 

--addons/zeros_trashman_v1.6.3/lua/entities/ztm_recycler/shared.lua:
return gluapack()()
--addons/zeros_trashman_v1.6.3/lua/entities/ztm_trashburner/cl_init.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_constructionkit_condenser.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_constructionkit_condenser.lua:
AddCSLuaFile()
DEFINE_BASECLASS("zyb_distillery_constructionkit")
ENT.Type = "anim"
ENT.Base = "zyb_distillery_constructionkit"
ENT.AutomaticFrameAdvance = true
ENT.Model = "models/zerochain/props_yeastbeast/yb_crate.mdl"
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "ConstructionKit - Condenser"
ENT.Category = "Zeros YeastBeast"
ENT.RenderGroup = RENDERGROUP_OPAQUE

ENT.ConstructionID = 1

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_motor/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Initialize()
	self.IsRunning = false
end

function ENT:Think()
	if zyb.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) then
		local running = self:GetRunning()

		if self.IsRunning ~= running then
			self.IsRunning = running

			if self.IsRunning then
				zyb.f.PlayClientAnimation(self, "run", 1)
			else
				zyb.f.PlayClientAnimation(self, "idle", 1)
			end
		end
	else
		self.IsRunning = false
	end
	self:SetNextClientThink(CurTime())
	return true
end

--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_motor/shared.lua:
return gluapack()()
--addons/zeros_yeastbeast_1.1.7/lua/entities/zyb_palette/cl_init.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/effects/arccw_ricochet.lua:
return gluapack()()
--addons/[binbon]arccw_modify/lua/effects/arccw_shelleffect.lua:
return gluapack()()
--addons/ch_mining/lua/effects/bonus_confetti/init.lua:
-- CREDITS Garry & Rubat https://github.com/Facepunch/garrysmod/blob/master/garrysmod/gamemodes/sandbox/entities/effects/balloon_pop.lua

function EFFECT:Init( data )
	local vOffset = data:GetOrigin()
	local Color = data:GetStart()

	local NumParticles = 50
	local emitter = ParticleEmitter( vOffset, true )
	
	for i=0, NumParticles do
		local Pos = Vector( math.Rand( -0.5, 0.5 ), math.Rand( -0.5, 0.5 ), math.Rand( -0.5, 0.5 ) )
		
		local particle = emitter:Add( Material( "materials/craphead_scripts/mining/sparkling.png" ), vOffset + Pos * 8 )
		if ( particle ) then
			particle:SetVelocity( Pos * 800 )
		
			particle:SetLifeTime( 0 )
			particle:SetDieTime( 10 )
		
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 255 )
		
			local Size = math.Rand( 3, 10 )
			particle:SetStartSize( Size )
			particle:SetEndSize( 0 )
		
			particle:SetRoll( math.Rand( 0, 360 ) )
			particle:SetRollDelta( math.Rand( -2, 2 ) )
		
			particle:SetAirResistance( 400 )
			particle:SetGravity( Vector( 0, 0, -100 ) )
		
			particle:SetColor( math.random( 0, 255 ), math.random( 0, 255 ), math.random( 0, 255 ) )
		
			particle:SetCollide( true )
		
			particle:SetAngleVelocity( Angle( math.Rand( -160, 160 ), math.Rand( -160, 160 ), math.Rand( -160, 160 ) ) ) 
		
			particle:SetBounce( 1 )
			particle:SetLighting( true )
		end
	end
	
	emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end
--addons/serious_business/lua/effects/sb_worker_fired.lua:
return gluapack()()
--addons/oneprint/lua/oneprint/config.lua:
OnePrint.Cfg = {}                           -- DON'T REMOVE/COMMENT THIS LINE !

-- Misc
OnePrint.Cfg.Language = "tr"                -- Script language [en, fr]
OnePrint.Cfg.MaxUsers = 8                   -- Max users that can be added to a printer, 0 will disable the users feature [min = 0, max = 8]
OnePrint.Cfg.ServerLimit = {                -- Max servers per printer (depending on the player usergroup) if the group is not added it'll not be limited [min = 1, max = 6]
    [ "user" ] = 5,
}

--[[ Which jobs can use printers ]]
OnePrint.Cfg.CanUsePrinter = {
    ["*"] = true, -- * == All
    ["Police"] = false, -- TeamName
}

--[[ 
    - Every {Cfg.MoneyDelay} seconds, the printer will generate {Cfg.ServerIncome X (Amount of servers in the printer)}.
    - If a server is overclocked it will generate {Cfg.ServerIncome X Cfg.OverclockingIncome} every {Cfg.MoneyDelay} seconds
    - The printer won't be able to store more money than {Cfg.ServerStorage X (Amount of servers in the printer)}
]]--

-- Money
OnePrint.Cfg.MoneyDelay = 36                 -- Cooldown before the printer generates money
OnePrint.Cfg.ServerIncome = 550              -- Income per server (for 1 server and without any upgrade)
OnePrint.Cfg.OverclockingIncome = 10        -- % of income added per level of overclocking
OnePrint.Cfg.ServerStorage = 100000           -- Max storage per server

OnePrint.Cfg.CPDestroyReward = 1000         -- Reward a CP for destroying a printer [min = 0]
OnePrint.Cfg.CPRewardSelf = false           -- true: CPs are rewarded if they destroy their own printer

-- Upgrades/Shop
OnePrint.Cfg.ServerPrice = 15000             -- Server price
OnePrint.Cfg.WatercoolingPrice = 1000 -- Watercooling price
OnePrint.Cfg.PowerPrice = 1000 -- Power price
OnePrint.Cfg.OverclockingPrice = 1000 -- Overclocking price
OnePrint.Cfg.SecurityPrice = 1200            -- Security price (against hacking)
OnePrint.Cfg.DefensePrice = 450             -- Defense boost price
OnePrint.Cfg.DefenseBoost = 50              -- Max HP added for each boost upgrade bought
OnePrint.Cfg.DefenseMax = 8                 -- Max boosts buyables [min = 1, max = 32]
OnePrint.Cfg.SilencerPrice = 1000            -- Silencer price
OnePrint.Cfg.HackNotifyPrice = 3500         -- Hack notification price
OnePrint.Cfg.LowHPNotifyPrice = 1500        -- Low HP notification price

OnePrint.Cfg.NotifyAllUsers = false         -- true: Notify all printer users on printer hack/low hp, false: Only notify owner on printer hack/low hp

-- Health/Damage
OnePrint.Cfg.MaxHealth = 100                -- Base HP of a printer (without defense upgrades)
OnePrint.Cfg.RepairPrice = 2000             -- Max repair price (if the printer is almost fully destroyed)
OnePrint.Cfg.DamageChance = 80              -- Percentage of chance to take damage if the temperature is too high [min = 0, max = 100]
OnePrint.Cfg.DamageTemperature = 80         -- Temperature on which the printer will start take damage
OnePrint.Cfg.DamageMultiplier = 4           -- The higher this value is, the more damage will be inflicted to the printer in case of overheating
OnePrint.Cfg.TemperatureMultiplier = 2      -- The higher this value is, the faster temperature will increase/decrease
OnePrint.Cfg.CrititalCondition = 50         -- Under this percentage of health, the printer will be condidered as in critical condition [min = 0, max = 99]

-- DarkRP Fire System (ignore if this script isn't installed)
OnePrint.Cfg.FireOnExplosion = true         -- If this is set to true, the printer explosion will create a fire
OnePrint.Cfg.FireChance = 50               -- Percentage of chance that an explosion creates a fire

-- Logs
OnePrint.Cfg.MaxActionsHistory = 10         -- Max entries saved in the actions history [min = 1, max = 10]
OnePrint.Cfg.MaxIncomeHistory = 16          -- Max entries saved in the income history [min = 6, max = 24]
OnePrint.Cfg.IncomeHistoryDelay = 30        -- Next save occurrence in the income history, in seconds [min = 5, max = 3600]

-- Hacking
OnePrint.Cfg.HackingEnabled = true          -- true : Enable the hacking feature, false : Disable
OnePrint.Cfg.HackingOwnedPrinter = true    -- true : Allow players to hack their own printer
OnePrint.Cfg.HackingErrorMargin = 10        -- The higher this value is, the farther your point can be from the target to pass a hacking step (higher = easier) [min = 0, max = 50]
OnePrint.Cfg.HackingSpeedMin = 0.2          -- Min rotation speed for the hacking minigame [min = 0.1, max = 2]
OnePrint.Cfg.HackingSpeedMax = 1.5          -- Max rotation speed for the hacking minigame [min = 0.1, max = 2]
OnePrint.Cfg.HackingSecurityMax = 16        -- Amount of security upgrades buyable on this printer (hacking step needed to unlock) [min = 1, max = 32]
OnePrint.Cfg.HackingJobs = {                -- Whitelist of jobs allowed to hack other players printers. Leave empty to allow all jobs: OnePrint.Cfg.HackingJobs = {}
}

OnePrint.Cfg.CanUpgradeAll = true

-- UI
OnePrint.Cfg.Colors = {
    [ 0 ] = Color( 22, 23, 27 ),            -- Background
    [ 1 ] = Color( 29, 30, 34 ),            -- Container
    [ 2 ] = Color( 72, 73, 77 ),            -- Highlight
    [ 3 ] = Color( 46, 204, 113 ),          -- Positive
    [ 4 ] = Color( 255, 65, 67 ),           -- Negative
    [ 5 ] = Color( 255, 255, 255 ),         -- Text
    [ 6 ] = Color( 46, 204, 113 ),          -- Main
}

-- Community logo shown on lockscreen (false to disable)
OnePrint.Cfg.CommunityLogo = "https://i.hizliresim.com/go2rscq.png"
--addons/oneprint/lua/oneprint/client/vgui/tabs/hack.lua:
return gluapack()()
--addons/oneprint/lua/oneprint/client/vgui/tabs/home.lua:
local Home = {}

Home.ID = 1
Home.Name = OnePrint:L( "Home" )

local matHappy = Material( "materials/oneprint/happy.png", "smooth" )
local matSad = Material( "materials/oneprint/sad.png", "smooth" )
local matUser = Material( "materials/oneprint/user.png", "smooth" )
local matRepair = Material( "materials/oneprint/repair.png", "smooth" )
local matFlame = Material( "materials/oneprint/flame.png", "smooth" )
local matCancel = Material( "materials/oneprint/cancel.png", "smooth" )

local tLogActions = {
    [ 0 ] = {
        str = OnePrint.Lang.Logs[ 0 ],
        color = OnePrint:C( 5 )
    },
    [ 1 ] = {
        str = OnePrint.Lang.Logs[ 1 ],
        color = OnePrint:C( 4 )
    },
    [ 2 ] = {
        str = OnePrint.Lang.Logs[ 2 ],
        color = OnePrint:C( 3 )
    },
    [ 3 ] = {
        str = OnePrint.Lang.Logs[ 3 ],
        color = OnePrint:C( 3 )
    },
    [ 4 ] = {
        str = OnePrint.Lang.Logs[ 4 ],
        color = OnePrint:C( 4 )
    },
}

local tHeader = {
    {
        name = string.upper( OnePrint:L( "Money" ) ),
        bMoney = true,
        func = function( ePrinter )
            ePrinter.fLerpMoney = ( ePrinter.fLerpMoney or 0 )
            ePrinter.fLerpMoney = Lerp( RealFrameTime() * 4, ePrinter.fLerpMoney, ePrinter:GetMoney() )
            return OnePrint:FormatMoney( math.Round( ePrinter.fLerpMoney ) )
        end,
    },
    {
        name = string.upper( OnePrint:L( "Income" ) ),
        bIncome = true,
        func = function( ePrinter )
            return "+" .. OnePrint:FormatMoney( ePrinter:GetTotalIncome() )
        end
    },
    {
        name = string.upper( OnePrint:L( "Temperature" ) ),
        bTemperature = true,
        func = function( ePrinter )
            ePrinter.fLerpTemperature = ( ePrinter.fLerpTemperature or 0 )
            ePrinter.fLerpTemperature = Lerp( RealFrameTime() * 4, ePrinter.fLerpTemperature, ePrinter:GetTemperature() )

            return string.Comma( math.Round( ePrinter.fLerpTemperature ) ) .. "°C"
        end
    },
    {
        name = string.upper( OnePrint:L( "CPU" ) ),
        func = function( ePrinter )
            return string.Comma( ( ePrinter:GetServers() * OnePrint.ServerFreq ) + ( ePrinter:GetOverclocking() * OnePrint.OCFreq ) ) .. " GHz"
        end,
        func2 = function( ePrinter )
            return ( ePrinter:GetServers() * OnePrint.ServerFreq ) .. " (+" .. ( ePrinter:GetOverclocking() * OnePrint.OCFreq ) .. ") Ghz"
        end
    }
}

local tMenuButtons = {
    {
        name = string.upper( OnePrint:L( "Shop" ) ),
        icon = Material( "materials/oneprint/shop.png", "smooth" ),
        func = function( dBase )
            OnePrint:SetTab( dBase, 2, true )
            OnePrint:Play2DSound( "oneprint/keypress_standard.mp3" )
        end
    },
    {
        name = string.upper( OnePrint:L( "Users" ) ),
        icon = Material( "materials/oneprint/user.png", "smooth" ),
        bUsers = true,
        func = function( dBase )
            OnePrint:SetTab( dBase, 3, true )
            OnePrint:Play2DSound( "oneprint/keypress_standard.mp3" )
        end
    },
    {
        name = string.upper( OnePrint:L( "Lights" ) ),
        icon = Material( "materials/oneprint/light.png", "smooth" ),
        func = function( dBase )
            local tLights = {
                [ 1 ] = { name = OnePrint:L( "Blue" ), color = OnePrint:C( 2 ) },
                [ 2 ] = { name = OnePrint:L( "White" ), color = OnePrint:C( 2 ) },
                [ 3 ] = { name = OnePrint:L( "Red" ), color = OnePrint:C( 2 ) },
                [ 4 ] = { name = OnePrint:L( "Green" ), color = OnePrint:C( 2 ) },
            }
            for iColor, v in ipairs( tLights ) do
                v.func = function( dPopup )
                    net.Start( "OnePrintNW" )
                        net.WriteUInt( 9, 4 )
                        net.WriteUInt( iColor, 2 )
                        net.WriteEntity( dBase.eEntity )
                    net.SendToServer()

                    if IsValid( dPopup ) then
                        dPopup:Remove()
                    end

                    OnePrint:Notify( dBase.eEntity, string.format( OnePrint:L( "Light color applied : %s" ), v.name ), 0, 3 )
                    OnePrint:Play2DSound( "oneprint/notify.mp3" )
                end
            end

            OnePrint:CreatePopup( dBase.ActiveTab, string.upper( OnePrint:L( "Change light" ) ), OnePrint:L( "Choose a new light color" ), tLights )
            OnePrint:Play2DSound( "oneprint/keypress_standard.mp3" )
        end
    },
    {
        name = string.upper( OnePrint:L( "Lock" ) ),
        icon = Material( "materials/oneprint/lock.png", "smooth" ),
        func = function( dBase )
            OnePrint:CreatePopup( dBase.ActiveTab, string.upper( OnePrint:L( "Lock printer" ) ), OnePrint:L( "Are you sure?" ), {
                { name = OnePrint:L( "Yes" ), color = OnePrint:C( 4 ), func = function( dPopup )
                    OnePrint:SetTab( dBase, 0, true )
                    OnePrint:Play2DSound( "oneprint/lock.mp3" )
                end },
                { name = OnePrint:L( "No" ), color = OnePrint:C( 2 ), func = function( dPopup )
                    if IsValid( dPopup ) then
                        dPopup:Remove()
                    end

                    OnePrint:Play2DSound( "oneprint/keypress_standard.mp3" )
                end }
            }, OnePrint:C( 4 ) )

            OnePrint:Play2DSound( "oneprint/keypress_standard.mp3" )
        end
    },
    {
        name = string.upper( OnePrint:L( "Freeze" ) ),
        icon = Material( "materials/oneprint/freeze.png", "smooth" ),
        bFreeze = true,
        func = function( dBase, dButton )
            if dBase.eEntity and IsValid( dBase.eEntity ) then
                net.Start( "OnePrintNW" )
                    net.WriteUInt( 5, 4 )
                    net.WriteEntity( dBase.eEntity )
                net.SendToServer()

                if dButton and IsValid( dButton ) then
                    timer.Simple( .3, function()
                        if dButton and IsValid( dButton ) and dBase and dBase.eEntity and IsValid( dBase.eEntity ) then
                            if dBase.eEntity:GetFrozen() then
                                dButton:SetText( string.upper( OnePrint:L( "Unfreeze" ) ) )
                                OnePrint:Notify( dBase.eEntity, OnePrint:L( "You froze this printer" ), 1, 3 )
                            else
                                dButton:SetText( string.upper( OnePrint:L( "Freeze" ) ) )
                                OnePrint:Notify( dBase.eEntity, OnePrint:L( "You unfroze this printer" ), 0, 3 )
                            end
                        end
                    end )
                end

                OnePrint:Play2DSound( "oneprint/notify.mp3" )
            end
        end
    },
    {
        name = string.upper( OnePrint:L( "Start" ) ),
        icon = Material( "materials/oneprint/start.png", "smooth" ),
        bStart = true,
        func = function( dBase, dButton )
            if dBase.eEntity and IsValid( dBase.eEntity ) then
                net.Start( "OnePrintNW" )
                    net.WriteUInt( 3, 4 )
                    net.WriteEntity( dBase.eEntity )
                net.SendToServer()

                if dButton and IsValid( dButton ) then
                    timer.Simple( .3, function()
                        if dButton and IsValid( dButton ) and dBase and dBase.eEntity and IsValid( dBase.eEntity ) then
                            if ( dBase.eEntity:GetServers() == 0 ) then
                                OnePrint:Notify( dBase.eEntity, OnePrint:L( "You must buy a server before" ), 1, 3 )
                                return
                            end

                            if dBase.eEntity:GetPowered() then
                                dButton:SetText( string.upper( OnePrint:L( "Stop" ) ) )
                                dButton.icon = Material( "materials/oneprint/stop.png", "smooth" )

                                OnePrint:Notify( dBase.eEntity, OnePrint:L( "You started this printer" ), 0, 3 )
                            else
                                dButton:SetText( string.upper( OnePrint:L( "Start" ) ) )
                                dButton.icon = Material( "materials/oneprint/start.png", "smooth" )

                                OnePrint:Notify( dBase.eEntity, OnePrint:L( "You stopped this printer" ), 1, 3 )
                            end
                        end
                    end )

                    OnePrint:Play2DSound( "oneprint/notify.mp3" )
                end
            end
        end
    }
}

if ( OnePrint.Cfg.MaxUsers <= 0 ) then
    for k, v in ipairs( tMenuButtons ) do
        if v.bUsers then
            tMenuButtons[ k ] = nil
            break
        end
    end
end

--[[

    drawPrinterUsers

]]--

local function drawPrinterUsers( dBase, dMenu )
    if not dBase or not dBase.ActiveTab or not IsValid( dBase.ActiveTab ) then
        return
    end

    local ePrinter = dBase.eEntity
    if not ePrinter or not IsValid( ePrinter ) then
        return
    end

    dMenu.bDrawUsers = true 

    if dMenu.dLayout and IsValid( dMenu.dLayout ) then
        dMenu.dLayout:Remove()
        dMenu.dLayout = nil
    end

    dMenu.sTitle = string.upper( OnePrint:L( "Users" ) )

    local sOwner = "[N/A]"
    local tUsers = {}

    if ePrinter:GetOwnerObject() and IsValid( ePrinter:GetOwnerObject() ) then
        tUsers[ 1 ] = ePrinter:GetOwnerObject():Name()
    end

    for k, v in pairs( ePrinter:GetUsers() ) do
        if IsValid( v ) then
            table.insert( tUsers, v:Name() )
        end
    end

    if ePrinter.GetOwnerObject and IsValid( ePrinter:GetOwnerObject() ) then
        sOwner = ePrinter:GetOwnerObject():Name()
    end

    function dMenu:Paint( iW, iH )
        OnePrint:DrawContainer( self, nil, self.sTitle )
        
        surface.SetMaterial( matUser )

        for k, v in ipairs( tUsers ) do
            if ( k == 1 ) then
                surface.SetDrawColor( OnePrint:C( 3 ) )
            else
                surface.SetDrawColor( OnePrint:C( 2 ) )
            end
            local iY = ( iH * .15 ) + ( ( iH * .1 ) * ( k - 1 ) )

            surface.DrawTexturedRectRotated( ( iH * .06 ), iY, ( iH * .08 ), ( iH * .08 ), 0 )
            draw.SimpleText( sOwner, "OnePrint.5", ( iH * .12 ), iY, OnePrint:C( 5 ), 0, 1 )
        end
    end
    
    return dMenu
end

--[[

    drawPrinterMenu

]]--

local function drawPrinterMenu( dBase, dMenu )
    if not dBase or not dBase.ActiveTab or not IsValid( dBase.ActiveTab ) then
        return
    end

    local ePrinter = dBase.eEntity
    if not ePrinter or not IsValid( ePrinter ) then
        return
    end

    dMenu.bDrawUsers = nil
    dMenu.sTitle = string.upper( OnePrint:L( "Menu" ) )

    function dMenu:Paint( iW, iH )
        OnePrint:DrawContainer( self, nil, self.sTitle )
    end

    dMenu.dLayout = vgui.Create( "DIconLayout", dMenu )
    local dLayout = dMenu.dLayout
    dLayout:SetSize( dMenu:GetWide() - 20, ( dMenu:GetTall() * .9 ) )
    dLayout:SetPos( ( OnePrint.iMargin * .5 ), ( dMenu:GetTall() - dLayout:GetTall() ) )

    for k, v in SortedPairs( tMenuButtons ) do
        local dBtn = dLayout:Add( "DButton" )
        dBtn:SetSize( dLayout:GetWide(), ( dLayout:GetTall() * .12 ) )
        dBtn:SetText( v.name )
        dBtn:SetFont( "OnePrint.5" )
        dBtn:SetContentAlignment( 4 )

        if v.icon then
            dBtn.icon = v.icon
        end

        if v.bStart then
            if ePrinter:GetPowered() then
                dBtn:SetText( string.upper( OnePrint:L( "Stop" ) ) )
                dBtn.icon = Material( "materials/oneprint/stop.png", "smooth" )
            else
                dBtn:SetText( string.upper( OnePrint:L( "Start" ) ) )
                dBtn.icon = Material( "materials/oneprint/start.png", "smooth" )
            end
        end

        if v.bFreeze then
            if ePrinter:GetFrozen() then
                dBtn:SetText( string.upper( OnePrint:L( "Unfreeze" ) ) )
            else
                dBtn:SetText( string.upper( OnePrint:L( "Freeze" ) ) )
            end
        end

        dBtn:SetTextColor( OnePrint:C( 5 ) )
        dBtn.tCol = OnePrint:C( 2 )
        dBtn.fLerp = 0

        function dBtn:Paint( iW, iH )
            if self.Hovered then
                self.tCol = OnePrint:C( 6 )
                self.fLerp = Lerp( RealFrameTime() * 6, self.fLerp, ( OnePrint.iMargin * .3 ) )
            else
                self.tCol = OnePrint:C( 5 )
                self.fLerp = Lerp( RealFrameTime() * 6, self.fLerp, -( OnePrint.iMargin * .3 ) )
            end

            if ( self.fLerp > 1 ) then
                surface.SetDrawColor( self.tCol )
                surface.DrawRect( 0, 0, self.fLerp, iH )
            end

            self:SetTextInset( ( self.fLerp + ( OnePrint.iMargin * .5 ) ), 2 )

            if self.icon then
                surface.SetDrawColor( self.tCol )
                surface.SetMaterial( self.icon )
                surface.DrawTexturedRectRotated( ( iW - ( iH * .32 ) ), ( iH * .5 ), ( iH * .64 ), ( iH * .64 ), 0 )
            end

            self:SetTextColor( self.tCol )
        end

        function dBtn:DoClick()
            if v.func and dBase and IsValid( dBase ) then
                v.func( dBase, self )
            end
        end
    end
end

--[[

    drawArc
    credits : Kruzgi

]]--

function drawArc( iX, iY, iW, iH, iAng, tCol, iX2, iY2 )
    for i = 0, iAng do
        local iCos = math.cos( math.rad( i ) )
        local iSin = math.sin( math.rad( i ) )

        draw.NoTexture()
        surface.SetDrawColor( tCol )
        surface.DrawTexturedRectRotated( iX + ( iY2 * iSin - iX2 * iCos ), iY + ( iY2 * iCos + iX2 * iSin ), iW, iH, i )
    end
end

--[[

    Home.Run

]]--

function Home.Run( dBase )
    if not dBase or not IsValid( dBase ) then
        return
    end

    if not dBase.eEntity or not IsValid( dBase.eEntity ) or ( dBase.eEntity:GetClass() ~= "oneprint" ) then
        return
    end

    local ePrinter = dBase.eEntity
    if not ePrinter or not IsValid( ePrinter ) then
        return
    end

    dBase.ActiveTab = vgui.Create( "DPanel", dBase )
    dBase.ActiveTab:SetSize( dBase:GetWide(), dBase:GetTall() )
    dBase.ActiveTab.Paint = nil

    local dHeader = vgui.Create( "DPanel", dBase.ActiveTab )
    dHeader:SetSize( dBase.ActiveTab:GetWide() - ( OnePrint.iMargin * 2 ), ( dBase.ActiveTab:GetTall() * .12 ) )
    dHeader:AlignLeft( OnePrint.iMargin )
    dHeader:AlignTop( OnePrint.iMargin )
    dHeader.fNextOccur = ePrinter:GetNextOccur()
    dHeader.fThinkDelay = OnePrint.Cfg.MoneyDelay

    local iSplit = ( dHeader:GetWide() / #tHeader )
    local iLeftW = ( dHeader:GetWide() * .65 )
    local iSubTitleMargin = ( dBase:GetTall() * .01 )
    local iBarW = ( iSplit - ( iSubTitleMargin * 2 ) )
    local iTempW = ( iBarW * .5 )
    local iDamageTemp = OnePrint.Cfg.DamageTemperature
    local fLerpMoneyBar = 0

    function dHeader:Paint( iW, iH )
        OnePrint:DrawContainer( self, nil, nil )

        if not IsValid( ePrinter ) then
            return
        end

        local bPowered = ePrinter:GetPowered()
        local iMoney = ePrinter:GetMoney()
        local iStorage = ePrinter:GetStorage()

        local fCurTime = CurTime()

        for k, v in ipairs( tHeader ) do
            local iX = ( iSplit * ( k - 1 ) )

            draw.SimpleText( v.name, "OnePrint.5", iX + iSubTitleMargin, ( iH * .23 ), OnePrint:C( 2 ), 0, 1 )
            draw.SimpleText( v.func( ePrinter ), "OnePrint.3", iX + iSubTitleMargin, ( iH * .51 ), OnePrint:C( 5 ), 0, 1 )

            if v.func2 then
                draw.SimpleText( v.func2( ePrinter ), "OnePrint.6", iX + iSubTitleMargin, ( iH * .76 ), OnePrint:C( 3 ), 0, 1 )
            end

            if ( k ~= #tHeader ) then
                draw.RoundedBox( ( iH * .01 ), iX + iSplit, ( iH * .15 ), ( iH * .02 ), ( iH * .7 ), OnePrint:C( 2 ) )
            end

            if v.bMoney then
                local iProgressW = ( iMoney * iBarW / iStorage )
                if ( iProgressW ~= iProgressW ) then
                    iProgressW = 0
                end

                fLerpMoneyBar = Lerp( RealFrameTime() * 6, fLerpMoneyBar, iProgressW )

                surface.SetDrawColor( OnePrint:C( 2 ) )
                surface.DrawRect( iX + iSubTitleMargin, ( iH * .76 ), iBarW, ( OnePrint.iMargin * .4 ) )

                if bPowered and ( iMoney >= iStorage ) then
                    if ( ( math.floor( fCurTime ) % 2 ) == 0 ) then
                        surface.SetDrawColor( OnePrint:C( 4 ) )
                        surface.SetMaterial( matCancel )
                        surface.DrawTexturedRect( iX + iBarW - ( iH * .25 ) + iSubTitleMargin, ( iH * .23 ) - 10, ( iH * .25 ), ( iH * .25 ) )
                    end

                    surface.SetDrawColor( OnePrint:C( 4 ) )
                    surface.DrawRect( iX + iSubTitleMargin, ( iH * .76 ), ( ( iProgressW > iBarW ) and iBarW or fLerpMoneyBar ), ( OnePrint.iMargin * .4 ) )
                else
                    if ( fLerpMoneyBar > 1 ) then
                        surface.SetDrawColor( OnePrint:C( 3 ) )
                        surface.DrawRect( iX + iSubTitleMargin, ( iH * .76 ), fLerpMoneyBar, ( OnePrint.iMargin * .4 ) )
                    end
                end
            end

            if v.bIncome then
                surface.SetDrawColor( OnePrint:C( 2 ) )
                surface.DrawRect( iX + iSubTitleMargin, ( iH * .76 ), iBarW, ( OnePrint.iMargin * .4 ) )

                if bPowered and ( ePrinter:GetServers() > 0 ) then
                    local fNextOccur = ePrinter:GetNextOccur()
	                local fTime = ( fNextOccur - fCurTime )
                    local iProgressW = iBarW - ( ( fTime * iBarW  ) / self.fThinkDelay )

                    if ( fTime > 0 ) then
                        draw.SimpleText( string.format( OnePrint:L( "In %s" ), ( math.floor( fTime ) + 1 ) ), "OnePrint.6", iX + iSplit - iSubTitleMargin, ( iH * .62 ), OnePrint:C( 2 ), 2, 1 )
                    end

                    if ( iProgressW > iBarW ) then
                        iProgressW = iBarW
                    end

                    surface.SetDrawColor( OnePrint:C( ( iMoney < iStorage ) and 3 or 4 ) )
                    surface.DrawRect( iX + iSubTitleMargin, ( iH * .76 ), iProgressW, ( OnePrint.iMargin * .4 ) )
                end
            end

            if v.bTemperature then
                local iTemp = ePrinter:GetTemperature()
                local iProgressW = ( iTemp * iBarW / ( iDamageTemp * 2 ) )

                if bPowered then
                    local iRPM = math.Round( iTemp * 4000 / iDamageTemp )
                    iRPM = ( ( iRPM > 4000 ) and 4000 or iRPM )

                    draw.SimpleText( iRPM .. " RPM", "OnePrint.6", iX + iSplit - iSubTitleMargin, ( iH * .62 ), OnePrint:C( 2 ), 2, 1 )                    
                end

                surface.SetDrawColor( OnePrint:C( 2 ) )
                surface.DrawRect( iX + iSubTitleMargin, ( iH * .76 ), iBarW, ( OnePrint.iMargin * .4 ) )

                if ( iTemp >= iDamageTemp ) then
                    if ( ( math.floor( fCurTime ) % 2 ) == 0 ) then
                        surface.SetDrawColor( OnePrint:C( 4 ) )
                        surface.SetMaterial( matFlame )
                        surface.DrawTexturedRect( iX + iBarW - ( iH * .25 ) + iSubTitleMargin, ( iH * .23 ) - 10, ( iH * .25 ), ( iH * .25 ) )
                    end

                    local iW = ( iProgressW > iBarW ) and iBarW or iProgressW
                    
                    surface.SetDrawColor( OnePrint:C( 4 ) )
                    surface.DrawRect( iX + iSubTitleMargin, ( iH * .76 ), iW, ( OnePrint.iMargin * .4 ) )
                    surface.DrawRect( iX + iSubTitleMargin + iTempW - 4, ( iH * .76 ) - ( OnePrint.iMargin * .4 ), 4, ( OnePrint.iMargin * .4 ) )
                else
                    surface.SetDrawColor( OnePrint:C( 0 ) )
                    surface.DrawRect( iX + iSubTitleMargin + iTempW, ( iH * .76 ), iTempW, ( OnePrint.iMargin * .4 ), OnePrint:C( 0 ) )

                    surface.SetDrawColor( OnePrint:C( 3 ) )
                    surface.DrawRect( iX + iSubTitleMargin, ( iH * .76 ), iProgressW, ( OnePrint.iMargin * .4 ) )
                end
            end
        end
    end

    local dWithdraw = vgui.Create( "DButton", dBase.ActiveTab )
    dWithdraw:SetSize( iLeftW, ( dBase.ActiveTab:GetTall() * .09 ) )
    dWithdraw:AlignLeft( OnePrint.iMargin )
    dWithdraw:AlignTop( ( OnePrint.iMargin * 2 ) + dHeader:GetTall() )
    dWithdraw:SetText( string.upper( OnePrint:L( "Withdraw" ) ) )
    dWithdraw:SetTextColor( OnePrint:C( 5 ) )
    dWithdraw:SetContentAlignment( 4 )
    dWithdraw:SetTextInset( iSubTitleMargin, iSubTitleMargin * 1.5 )
    dWithdraw:SetFont( "OnePrint.3" )
    dWithdraw.sTitle = string.upper( OnePrint:L( "Withdraw" ).. " " .. OnePrint:L( "Money" ) )

    function dWithdraw:Paint( iW, iH )
        OnePrint:DrawContainer( self, OnePrint.iRoundness, self.sTitle, iSubTitleMargin )

        surface.SetDrawColor( OnePrint:C( 6 ) )
        surface.DrawRect( 0, iH - ( OnePrint.iMargin * .4 ), iW, ( OnePrint.iMargin * .4 ) )
    end

    local dIncomeHistory = vgui.Create( "DPanel", dBase.ActiveTab )
    dIncomeHistory:SetSize( iLeftW, ( dBase.ActiveTab:GetTall() * .3 ) )
    dIncomeHistory:AlignLeft( OnePrint.iMargin )
    dIncomeHistory:AlignTop( ( OnePrint.iMargin * 3 ) + dHeader:GetTall() + dWithdraw:GetTall() )
    dIncomeHistory.sTitle = string.upper( OnePrint:L( "Income history" ) )

    local tIncome = ePrinter:GetIncomeLogs()
    local tIcomeLerp = {}

    for i = 1, OnePrint.Cfg.MaxIncomeHistory do
        tIcomeLerp[ i ] = 0
    end

    local iMaxIncome = 0
    local iTotalIncome = 0

    local iGraphX, iGraphY = ( dIncomeHistory:GetWide() * .12 ), ( dIncomeHistory:GetTall() * .37 )
    local iGraphW, iGraphH = ( dIncomeHistory:GetWide() * .83 ), ( dIncomeHistory:GetTall() * .54 )
    local iBarW = ( iGraphW / OnePrint.Cfg.MaxIncomeHistory )

    function dIncomeHistory:GetTotalIncome( tIncome )
        local iTotal = 0
        for _, v in pairs( tIncome ) do
            iTotal = ( iTotal + v )
        end

        return iTotal
    end

    local sUpdateText = string.format( OnePrint:L( "Update every %s sec." ), OnePrint.Cfg.IncomeHistoryDelay )

    function dIncomeHistory:Paint( iW, iH )
        OnePrint:DrawContainer( self, OnePrint.iRoundness, self.sTitle, iSubTitleMargin )

        if not IsValid( ePrinter ) then
            return
        end

        draw.SimpleText( OnePrint:FormatMoney( iTotalIncome ), "OnePrint.3", iSubTitleMargin, ( iH * .1 ), OnePrint:C( 5 ), 0, 3 )
        draw.SimpleText( sUpdateText, "OnePrint.6", iGraphX + iGraphW, iGraphY, OnePrint:C( 2 ), 2, 4 )

        surface.SetDrawColor( OnePrint:C( 2 ) )
        for i = 0, 4 do
            surface.DrawLine( iGraphX, iGraphY + ( iGraphH / 4 * i ), iGraphX + iGraphW, iGraphY + ( iGraphH / 4 * i ) )
            draw.SimpleText( math.Round( ( ( iMaxIncome / 4 ) * i ) * .001, 1 ) .. "k", "OnePrint.6", iGraphX - ( iW * .01 ), iGraphY + iGraphH - ( iGraphH / 4 * ( i ) ), OnePrint:C( 2 ), 2, 1 )
        end

        tIncome = ePrinter:GetIncomeLogs()
        if ( #tIncome > 0 ) then
            iMaxIncome = math.max( unpack( tIncome ) )
            iTotalIncome = self:GetTotalIncome( tIncome )
        end

        for k, v in ipairs( tIncome ) do
            if v > 0 then
                local iBarH = ( v * iGraphH / iMaxIncome )
                local iBarX = iGraphX + ( iBarW * ( k - 1 ) ) + ( iBarW * .4 )

                tIcomeLerp[ k ] = Lerp( RealFrameTime() * 6, tIcomeLerp[ k ], iBarH )

                surface.SetDrawColor( OnePrint:C( 6 ) )
                surface.DrawRect( iBarX, ( iGraphY + iGraphH - tIcomeLerp[ k ] ), ( iH * .032 ), tIcomeLerp[ k ] )
            end
        end
    end

    local tActionLogs = {}
    local iActionLogs = 0
    local iLogH = 0
    local iLogY = 0

    local dActivityHistory = vgui.Create( "DPanel", dBase.ActiveTab )
    dActivityHistory:SetSize( iLeftW, ( dBase:GetTall() - dIncomeHistory:GetTall() - dHeader:GetTall() - dWithdraw:GetTall() ) - ( OnePrint.iMargin * 5 ) )
    dActivityHistory:AlignLeft( OnePrint.iMargin )
    dActivityHistory:AlignTop( dBase:GetTall() - dActivityHistory:GetTall() - OnePrint.iMargin )
    dActivityHistory.sTitle = string.upper( OnePrint:L( "Activity history" ) )

    function dActivityHistory:UpdateLogs()
        if not IsValid( ePrinter ) then
            return
        end

        tActionLogs = ePrinter:GetActionLogs()
        iActionLogs = table.Count( tActionLogs or {} )

        iLogH = ( dActivityHistory:GetTall() - ( OnePrint.iMargin * 2 ) - iSubTitleMargin) / OnePrint.Cfg.MaxActionsHistory
        iLogY = ( ( iSubTitleMargin * 1.5 ) + OnePrint.iMargin ) + ( iLogH * iActionLogs )
    end

    dActivityHistory:UpdateLogs()

    function dActivityHistory:Paint( iW, iH )
        OnePrint:DrawContainer( self, OnePrint.iRoundness, self.sTitle, iSubTitleMargin )

        if tActionLogs then
            for k, v in ipairs( tActionLogs ) do
                if not v[ 1 ] or not tLogActions[ v[ 1 ] ] then
                    continue
                end

                local iY = iLogY - ( iLogH * ( k - 1 ) ) + 5
                local sVal = string.format( tLogActions[ v[ 1 ] ].str, v[ 3 ], string.Comma( v[ 4 ] or "" ), string.Comma( v[ 5 ] or "" ) )

                draw.RoundedBox( ( iH * .005 ), iSubTitleMargin, iY - ( iH * .07 ), ( iH * .01 ), ( iH * .06 ), OnePrint:C( 2 ) )

                draw.SimpleText( sVal, "OnePrint.6", iSubTitleMargin + ( iW * .02 ), iY, tLogActions[ v[ 1 ] ].color, 0, 4 )
                draw.SimpleText( os.date( "%Hh%M", v[ 2 ] ), "OnePrint.6", iW - iSubTitleMargin, iY, OnePrint:C( 2 ), 2, 4 )
            end
        end
    end

    local dHealth = vgui.Create( "DPanel", dBase.ActiveTab )
    dHealth:SetSize( dBase:GetWide() - iLeftW - ( OnePrint.iMargin * 3 ), ( dBase:GetTall() * .24 ) )
    dHealth:SetPos( iLeftW + ( OnePrint.iMargin * 2 ), ( OnePrint.iMargin * 2 ) + dHeader:GetTall() )
    dHealth.sTitle = string.upper( OnePrint:L( "Condition" ) )
    dHealth.fLerpCondition = 0

    local tColor = OnePrint:C( 3 )
    local matIcon = matHappy

    function dHealth:Paint( iW, iH )
        if not IsValid( ePrinter ) then
            return
        end

        local iHealth = ePrinter:Health()
        local iMaxHealth = ePrinter:GetMaxHealth()

        if ( ePrinter:GetCondition() <= OnePrint.Cfg.CrititalCondition ) then
            tColor = OnePrint:C( 4 )
            matIcon = matSad
        else
            tColor = OnePrint:C( 3 )
            matIcon = matHappy
        end

        self.fLerpCondition = Lerp( RealFrameTime() * 6, self.fLerpCondition, ( iHealth * 100 / iMaxHealth ) )

        local iArcHealth = ( 180 - ( ( self.fLerpCondition * 180 ) / 99 ) )
        if iArcHealth > 180 then iArcHealth = 180 end

        OnePrint:DrawContainer( self, OnePrint.iRoundness, self.sTitle, iSubTitleMargin )

        drawArc( ( iW * .5 ), ( iH * .7 ), ( iH * .04 ), ( iH * .1 ), 180, tColor, -( iH * .45 ), 0 )
        drawArc( ( iW * .5 ), ( iH * .7 ), ( iH * .05 ), ( iH * .1 ), iArcHealth, OnePrint:C( 2 ), -( iH * .45 ), 0 )

        draw.SimpleText( "0%", "OnePrint.6", ( iW * .12 ), ( iH * .9 ), OnePrint:C( 2 ), 0, 4 )
        draw.SimpleText( math.Round( self.fLerpCondition ) .. "%", "OnePrint.3", ( iW * .5 ), ( iH * .7 ), OnePrint:C( 5 ), 1, 1 )
        draw.SimpleText( iHealth .. "/" .. iMaxHealth, "OnePrint.6", ( OnePrint.iMargin * .5 ), ( iH * .12 ), OnePrint:C( 2 ), 0, 3 )
        draw.SimpleText( "100%", "OnePrint.6", ( iW * .88 ), ( iH * .9 ), OnePrint:C( 2 ), 2, 4 )

        surface.SetDrawColor( tColor )
        surface.SetMaterial( matIcon )
        surface.DrawTexturedRectRotated( ( iW * .5 ), ( iH * .48 ), ( iH * .18 ), ( iH * .18 ), 0 )
    end

    local dRepair = vgui.Create( "DButton", dHealth )
    dRepair:SetSize( ( dBase:GetTall() * .04 ), ( dBase:GetTall() * .04 ) )
    dRepair:AlignRight( iSubTitleMargin )
    dRepair:AlignTop( iSubTitleMargin )
    dRepair:SetText( "" )
    dRepair.fLerp = 0
    dRepair.tCol = OnePrint:C( 2 )

    function dRepair:Paint( iW, iH )
        if not IsValid( ePrinter ) or ( ePrinter:Health() == ePrinter:GetMaxHealth() ) then
            return
        end

        if self.Hovered then
            self.tCol = OnePrint:C( 6 )
            self.fLerp = Lerp( RealFrameTime() * 6, self.fLerp, -180 )
        else
            self.tCol = ( OnePrint:C( 2 ) )
            self.fLerp = Lerp( RealFrameTime() * 6, self.fLerp, 0 )
        end

        surface.SetDrawColor( self.tCol )
        surface.SetMaterial( matRepair )
        surface.DrawTexturedRectRotated( ( iW * .5 ), ( iH * .5 ), iW - iSubTitleMargin, iH - iSubTitleMargin, self.fLerp )
    end

    function dRepair:DoClick()
        if not IsValid( ePrinter ) or ( ePrinter:Health() == ePrinter:GetMaxHealth() ) then
            return
        end

        if self.dPopup and IsValid( self.dPopup ) then
            self.dPopup:Remove()
            self.dPopup = nil

            return
        end

    	local iHPPercent = ( ePrinter:Health() * 100 / ePrinter:GetMaxHealth() )
        local iRepairPrice = OnePrint.Cfg.RepairPrice - math.ceil( OnePrint.Cfg.RepairPrice * iHPPercent / 100 )

        OnePrint:CreatePopup( dBase.ActiveTab, string.upper( OnePrint:L( "Repair" ) ) .. " [" .. OnePrint:FormatMoney( iRepairPrice ) .. "]", OnePrint:L( "Are you sure?" ), {
            { name = OnePrint:L( "Yes" ), color = OnePrint:C( 3 ), func = function( dPopup )
                if IsValid( dPopup ) then
                    dPopup:Remove()
                end

                OnePrint:Play2DSound( "oneprint/notify.mp3" )

                if not LocalPlayer():OP_CanAfford( iRepairPrice ) then
                    OnePrint:Notify( dBase.eEntity, OnePrint:L( "Not enough money" ), 1, 3 )

                    return
                end

                net.Start( "OnePrintNW" )
                    net.WriteUInt( 4, 4 )
                    net.WriteEntity( ePrinter )
                net.SendToServer()

                OnePrint:Notify( dBase.eEntity, string.format( OnePrint:L( "You paid %s to repair this printer" ), OnePrint:FormatMoney( iRepairPrice ) ), 0, 3 )

                timer.Simple( .3, function()
                    if dActivityHistory and IsValid( dActivityHistory ) then
                        dActivityHistory:UpdateLogs()
                    end
                end )
            end },
            { name = OnePrint:L( "No" ), color = OnePrint:C( 2 ), func = function( dPopup )
                if IsValid( dPopup ) then
                    dPopup:Remove()
                end

                OnePrint:Play2DSound( "oneprint/keypress_standard.mp3" )
            end },
        } )

        OnePrint:Play2DSound( "oneprint/keypress_standard.mp3" )
    end

    local dMenu = vgui.Create( "DButton", dBase.ActiveTab )
    dMenu:SetSize( dBase:GetWide() - iLeftW - ( OnePrint.iMargin * 3 ), ( dBase:GetTall() * .09 ) )
    dMenu:SetPos( iLeftW + ( OnePrint.iMargin * 2 ), ( OnePrint.iMargin * 3 ) + dHeader:GetTall() + dHealth:GetTall() )
    dMenu:SetText( string.upper( OnePrint:L( "Users" ) ) )
    dMenu:SetTextColor( OnePrint:C( 5 ) )
    dMenu:SetContentAlignment( 4 )
    dMenu:SetTextInset( iSubTitleMargin, ( iSubTitleMargin * 1.5 ) )
    dMenu:SetFont( "OnePrint.3" )
    dMenu.sTitle = string.upper( OnePrint:L( "Show" ) .. " " .. OnePrint:L( "Users" ) )

    function dMenu:Paint( iW, iH )
        OnePrint:DrawContainer( self, OnePrint.iRoundness, self.sTitle, iSubTitleMargin )

        surface.SetDrawColor( OnePrint:C( 6 ) )
        surface.DrawRect( 0, iH - ( OnePrint.iMargin * .4 ), iW, ( OnePrint.iMargin * .4 ) )
    end

    local dLast = vgui.Create( "DPanel", dBase.ActiveTab )
    dLast:SetSize( dBase:GetWide() - iLeftW - ( OnePrint.iMargin * 3 ), dBase:GetTall() - dMenu:GetTall() - dHealth:GetTall() - dHeader:GetTall() - ( OnePrint.iMargin * 5 ) )
    dLast:SetPos( iLeftW + ( OnePrint.iMargin * 2 ), dBase:GetTall() - dLast:GetTall() - OnePrint.iMargin )

    drawPrinterMenu( dBase, dLast )

    function dMenu:DoClick()
        if dLast.bDrawUsers then
            drawPrinterMenu( dBase, dLast )
            dMenu:SetText( string.upper( OnePrint:L( "Users" ) ) )
            dMenu.sTitle = string.upper( OnePrint:L( "Show" ) .. " " .. OnePrint:L( "Users" ) )
        else
            drawPrinterUsers( dBase, dLast )
            dMenu:SetText( string.upper( OnePrint:L( "Menu" ) ) )
            dMenu.sTitle = string.upper( OnePrint:L( "Show" ) .. " " .. OnePrint:L( "Menu" ) )
        end

        OnePrint:Play2DSound( "oneprint/keypress_standard.mp3" )
    end

    function dWithdraw:DoClick()
        if not ePrinter or not IsValid( ePrinter ) then
            return
        end

        local iMoney = ePrinter:GetMoney()
        if ( iMoney <= 0 ) then
            OnePrint:Notify( dBase.eEntity, OnePrint:L( "This printer is empty" ), 1, 3 )
            OnePrint:Play2DSound( "oneprint/notify.mp3" )

            return
        end

        net.Start( "OnePrintNW" )
            net.WriteUInt( 1, 4 )
            net.WriteEntity( ePrinter )
        net.SendToServer()

        timer.Simple( .3, function()
            if dActivityHistory and IsValid( dActivityHistory ) then
                dActivityHistory:UpdateLogs()
            end
        end )

        OnePrint:Notify( dBase.eEntity, string.format( OnePrint:L( "You withdrew %s" ), OnePrint:FormatMoney( iMoney ) ), 0, 2 )
        OnePrint:Play2DSound( "oneprint/notify.mp3" )
    end
end

OnePrint:RegisterTab( Home )
--addons/oneprint/lua/oneprint/client/vgui/tabs/users.lua:
return gluapack()()