--Stealed clientside server code by exechack.cc
--Hostname: ⋙ GAMBITRP ╽ ПОДАРКИ ╽ FREE VIP ⋘ - Part 8/10 - 06/04/2025


--PATH addons/accessory/lua/autorun/autorun_accessory.lua:
SH_ACC = {}

-- Don't modify this.
-- The script won't explode if you do but it's better for everyone if you don't mislead players.
_SH_ACC_VERSION = "1.0.5"

if (SERVER) then
	AddCSLuaFile("autorun/autorun_accessory.lua")
	AddCSLuaFile("accessory/cl_accessory.lua")
	AddCSLuaFile("accessory/cl_interface.lua")
	AddCSLuaFile("accessory/cl_notify.lua")
	AddCSLuaFile("accessory/cl_editor.lua")
	AddCSLuaFile("accessory/cl_obj_player_extend.lua")
	AddCSLuaFile("accessory/sh_obj_player_extend.lua")
	AddCSLuaFile("accessory_addons.lua")
	AddCSLuaFile("accessory_list.lua")
	AddCSLuaFile("accessory_offsets.lua")
	AddCSLuaFile("accessory_config.lua")

	include("accessory/sv_accessory.lua")
	include("accessory/sv_database.lua")
	include("accessory/sv_obj_player_extend.lua")
else
	include("accessory/cl_accessory.lua")
	include("accessory/cl_interface.lua")
	include("accessory/cl_notify.lua")
	include("accessory/cl_editor.lua")
	include("accessory/cl_obj_player_extend.lua")

	include("accessory_offsets.lua")
end

include("accessory_addons.lua")
include("accessory_list.lua")
include("accessory_config.lua")
include("accessory/sh_obj_player_extend.lua")
--PATH addons/the_cocaine_factory/lua/ch_cocaine/client/cocaine_fonts.lua:
surface.CreateFont("TCF_Trebuchet50", {
	font = "Selawik", 
	size = ScreenScale( 15 ), 
	weight = 700
})

surface.CreateFont("TCF_Trebuchet35", {
	font = "Selawik", 
	size = ScreenScale( 11 ), 
	weight = 400
})

surface.CreateFont( "TCF_Simple17", {
	font = "Lato",
	size = 18,
	weight = 500,
	antialias = true,
} )

surface.CreateFont( "TCF_Simple19", {
	font = "Lato",
	size = 28,
	weight = 500,
	antialias = true,
} )

surface.CreateFont( "TCF_HealthDisplay", {
	font = "Lato",
	size = 23,
	weight = 400,
	antialias = true,
	blursize = 1,
} )
--PATH addons/epoe/lua/epoe/shared.lua:
local insert=table.insert
local remove=table.remove
local Empty=table.Empty
local setmetatable=setmetatable

local player=player
local IsValid=IsValid
local error=error
local pairs=pairs
local hook=hook
local CLIENT=CLIENT
local SERVER=SERVER
local table=table
local pcall=pcall
local math=math
local concommand=concommand
local tostring=tostring
local type=type
local string=string
local select=select
local FrameTime=FrameTime
local assert=assert
local getmetatable=debug.getmetatable
local G=_G
local bit=bit
local next=next
local select=select
local type=type
local Color=Color

module( "epoe" )

-- Consts
Tag='E\''
TagHuman='EPOE'
Should_TagHuman='Should'..TagHuman

-- Clientside only for now
PreEPOE = CLIENT and function(t)
	local ret = hook.Run("PreEPOE",t)
	if ret == false then return end
	return t
end or nil

flags = { -- One byte overhead for signaling this all. Need to add two with anything more.
	IS_EPOE=	2^0,
	IS_ERROR=	2^1,
	IS_PRINT=	2^2,
	IS_MSG=		2^3,

	IS_MSGN=	2^4,
	IS_SEQ=		2^5,
	IS_CERROR=	2^6,
	IS_MSGC=	2^7,
}

-- Add them to the module as variables
for name,byte in pairs(flags) do
	assert(byte>=0)
	assert(byte<=255) -- Increase (user/net)messages from char to short if you're going to change this for some reason
	_M[name]=byte
end

function andnot(bit)
	return 255-bit
end

function DebugFlags(flag)
	local a={}
	for name,byte in pairs(flags) do
		if HasFlag(flag,byte) then
			table.insert(a,name)
		end
	end
	return table.concat(a,", ")
end

function HasFlag(byte,flag)
	local a = bit.band(byte or 0,flag)
	return a==flag
end

-- seq does not have color as it has already been transmitted
function HasMsgCParams(flags)
	return HasFlag(flags,IS_MSGC) and not HasFlag(flags,IS_SEQ)
end

-- Certain messages don't need a newline.
function NewLine(flags)
	if HasFlag(flags,IS_SEQ)
	or HasFlag(flags,IS_MSG)
	or HasFlag(flags,IS_MSGC)
--	or HasFlag(flags,IS_ERROR)
	or HasFlag(flags,IS_EPOE)
	then
		return ""
	end
	return "\n"

end

-- enginespew const
SPEW_WARNING=1

-- Safeguard for super big tables and queue filling faster than emptying. Increase if it becomes a problem with big tables.
MaxQueue = 2048+1024
MSGS_IN_TICK = 6

------------
-- Small stack implementation
-- Sigh complexity from LILO with no gain...
------------
	local class = {}
	local mt = {__index = class}

	function FIFO()
		return setmetatable( {} , mt )
	end

	function LILO()
		return setmetatable( {lilo=true} , mt )
	end


	-- Push
	function mt.__add(a,b)
		insert( a , b )
		return a
	end

	-- Pop
	function mt:__unm()
		return remove( self , self.lilo and #self or 1 )
	end

	-- Pop
	function class:pop()
		return remove( self , self.lilo and #self or 1 )
	end

	function class:peek()
		return self[self.lilo and #self or 1]
	end

	function class.push(a,b)
		insert( a , b )
		return a
	end

	function class:len()
		return #self
	end

	function class:length()
		return #self
	end

	function class:clear()
		return Empty( self )
	end

function ToString(t) -- depreciated
	local 		nl,tab  = "",  ""

	local function MakeTable ( t, nice, indent, done)
		local str = ""
		local done = done or {}
		local indent = indent or 0
		local idt = ""
		if nice then idt = string.rep ("\t", indent) end

		local sequential = table.IsSequential(t)

		for key, value in pairs (t) do

			str = str .. idt .. tab .. tab

			if not sequential then
				if type(key) == "number" or type(key) == "boolean" then
					key ='['..tostring(key)..']' ..tab..'='
				else
					key = tostring(key) ..tab..'='
				end
			else
				key = ""
			end

			if type (value) == "table" and not done [value] then

				done [value] = true
				str = str .. key .. tab .. nl
				.. MakeTable (value, nice, indent + 1, done)
				str = str .. idt .. tab .. tab ..tab .. tab .. nl

			else

				if 	type(value) == "string" then
					value = tostring(value)
				elseif  type(value) == "Vector" then
					value = 'Vector('..value.x..','..value.y..','..value.z..')'
				elseif  type(value) == "Angle" then
					value = 'Angle('..value.pitch..','..value.yaw..','..value.roll..')'
				else
					value = tostring(value)
				end

				str = str .. key .. tab .. value .. " ".. nl

			end

		end
		return str
	end
	local str = ""
	str = str .. nl .. MakeTable ( t, nice)

	return str:sub(1,-2) -- remove last redundant space
end


function ToStringTableInfo(t)
	local num=0
	local nonnum=0
	local tables
	local meta=getmetatable(t)
	local str=tostring(t)
	str=str:gsub("table: ","table:( ")
	for k,v in pairs(t) do
		local ktype=type(k)
		if ktype=="number" then
			num=num+1
		elseif ktype=="table" then
			nonnum=nonnum+1
			tables=true
		else
			nonnum=nonnum+1
		end
		if type(v) == "table" then
			tables=true
		end
	end
	if nonnum>0 then
		str=str..', !#'..nonnum
	end
	if num>0 then
		local nums=#t
		if nums==num then
			str=str..', #'..num
		else
			str=str..', #'..num..'/'..nums
		end
	end
	/*if num>0 and nonnum>0 then
		str=str..', count='..(num+nonnum)
	end*/
	if meta then
		str=str..', meta'
	end
	if tables then
		str=str..', subtables'
	end
	str=str..' )'
	return str
end

function ToStringEx(delim,...)
	local res=""
	local count=select('#',...)
	count=count==0 and 1 or count
	for n=1,count do
		local e = select(n,...)
		if type(e)=="table" then
			e=ToStringTableInfo(e)
		elseif e == nil then
			e=type(select(n,...))
		else
		    e=tostring(e)
		end
		res = res .. (n==1 and "" or delim) .. e
	end
	return res
end


col_white=Color(255,255,255,255)
col_error=Color(255,1,254,255)
function IsColor(val)
	
	if type(val)~="table" then return false end
	
	local 	r = val.r
			g = val.g
			b = val.b
			
	if not r or type(r)~="number"
	or not g or type(g)~="number"
	or not b or type(b)~="number"
	then return false end
	
	return true
	
end

--PATH addons/admin_warns/lua/fam/core/cl_settings_menu.lua:
local font_size = {}

surface.SetFont("FAM.DefText")
font_size["FAM.DefText"] = {}
font_size["FAM.DefText"].w,font_size["FAM.DefText"].h = surface.GetTextSize("The quick brown fox jumps over a lazy dog.")


surface.SetFont("FAM.PlayerInfo")
font_size["FAM.PlayerInfo"] = {}
font_size["FAM.PlayerInfo"].w,font_size["FAM.PlayerInfo"].h = surface.GetTextSize("The quick brown fox jumps over a lazy dog.")

function FlameAdminManagement.MysqlSetup(_ip, _user, _password, _database, _port)
	if opened then return end
	opened = true
	_ip = _ip or "127.0.0.1"
	_user = _user or "root"
	_password = _password or ""
	_database = _database or "flame_dev"
	_port = _port or "3306"

	local main = vgui.Create("DFrame")
	main:SetSize(ScrW() * .2, ScrH() * .5)
	main:SetPos(ScrW() * .5 - main:GetWide() * .5, ScrH())
	local x, y = main:GetPos()
	main.x = x

	main:MoveTo(main.x, ScrH() * .5 - main:GetTall() * .5 - 25, 0.3, 0, 0.4, function()
		main:MoveTo(main.x, ScrH() * .5 - main:GetTall() * .5, 0.15, 0, 0.4)
	end)

	main:MakePopup()
	main:SetTitle('')
	main:ShowCloseButton(false)

	main.Paint = function(self, w, h)
		FlameAdminManagement.DrawBlur(self)
		surface.SetDrawColor(0, 0, 0, 150)

		surface.DrawRect(0, 0, w, h)
		surface.DrawRect(0, 0, w, 25)

		FlameAdminManagement.DrawText("FAM - Mysql", "FAM.DefText", w * .5, 12.5, Color(255, 255, 255), 1, 1)
	end

	main.FRemove = function()
		if main.closing then return end
		main.closing = true
		opened = false

		main:MoveTo(main.x, ScrH() * .5 - main:GetTall() * .5 - 25, 0.3, 0, 0.4, function()
			main:MoveTo(main.x, ScrH(), 0.15, 0, 0.4, function()
				main:Remove()

				if IsValid(player_info_main) then
					player_info_main:Remove()
				end

				if IsValid(online_players_main) then
					online_players_main:Remove()
				end
			end)
		end)
	end

	local close = vgui.Create("DButton", main)
	close:SetSize(21, 21)
	close:SetPos(main:GetWide() - 25, 2)
	close:SetText('')

	close.Paint = function(self, w, h)
		if (self.Depressed or self.m_bSelected) then
			surface.SetDrawColor(255, 128, 128, 100)
		elseif (self.Hovered) then
			surface.SetDrawColor(0, 0, 0, 100)
		else
			surface.SetDrawColor(0, 0, 0, 75)
		end

		surface.DrawRect(0, 0, w, h)
		FlameAdminManagement.DrawText("X", "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
	end

	close.OnCursorEntered = function(self)
		surface.PlaySound("garrysmod/ui_hover.wav")
	end

	close.DoClick = function(self)
		surface.PlaySound("garrysmod/ui_click.wav")
		main:FRemove()
	end

	local main_textentry = vgui.Create( "DPanel", main )
	main_textentry:SetPos(2,27)
	main_textentry:SetSize(main:GetWide() - 4, main:GetTall() - 54)
	main_textentry.Paint = function(self,w,h)
		surface.SetDrawColor(0, 0, 0, 150)
		surface.DrawRect(0, 0, w, h)
	end

	local info_label = vgui.Create("DLabel", main_textentry)
	info_label:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	info_label:SetFont("FAM.DefText")
	info_label:SetText(FlameAdminManagement.GetLang('mysql_setup_t'))
	info_label:SetTextColor(Color(255,255,255))
	info_label:Dock(TOP)
	info_label:SetContentAlignment( 5 )
	info_label:DockMargin(4, 1, 4, 1)
	info_label:SetExpensiveShadow( 1, Color(0,0,0) )


	local ip_label = vgui.Create("DLabel", main_textentry)
	ip_label:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	ip_label:SetFont("FAM.DefText")
	ip_label:SetText(FlameAdminManagement.GetLang('mysql_setup_ip'))
	ip_label:SetTextColor(Color(255,255,255))
	ip_label:Dock(TOP)
	ip_label:SetContentAlignment( 5 )
	ip_label:DockMargin(4, 1, 4, 1)
	ip_label:SetExpensiveShadow( 1, Color(0,0,0) )

	local ip = vgui.Create( "DTextEntry", main_textentry )
	ip:Dock(TOP)
	ip:DockMargin(4, 1, 4, 1)
	ip:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	ip:SetText( _ip )


	local user_label = vgui.Create("DLabel", main_textentry)
	user_label:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	user_label:SetFont("FAM.DefText")
	user_label:SetText(FlameAdminManagement.GetLang('mysql_setup_username'))
	user_label:SetTextColor(Color(255,255,255))
	user_label:Dock(TOP)
	user_label:SetContentAlignment( 5 )
	user_label:DockMargin(4, 1, 4, 1)
	user_label:SetExpensiveShadow( 1, Color(0,0,0) )

	local user = vgui.Create( "DTextEntry", main_textentry )
	user:Dock(TOP)
	user:DockMargin(4, 1, 4, 1)
	user:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	user:SetText( _user )


	local password_label = vgui.Create("DLabel", main_textentry)
	password_label:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	password_label:SetFont("FAM.DefText")
	password_label:SetText(FlameAdminManagement.GetLang('mysql_setup_pass'))
	password_label:SetTextColor(Color(255,255,255))
	password_label:Dock(TOP)
	password_label:SetContentAlignment( 5 )
	password_label:DockMargin(4, 1, 4, 1)
	password_label:SetExpensiveShadow( 1, Color(0,0,0) )

	local password = vgui.Create( "DTextEntry", main_textentry )
	password:Dock(TOP)
	password:DockMargin(4, 1, 4, 1)
	password:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	password:SetText( _password )


	local database_label = vgui.Create("DLabel", main_textentry)
	database_label:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	database_label:SetFont("FAM.DefText")
	database_label:SetText(FlameAdminManagement.GetLang('mysql_setup_db'))
	database_label:SetTextColor(Color(255,255,255))
	database_label:Dock(TOP)
	database_label:SetContentAlignment( 5 )
	database_label:DockMargin(4, 1, 4, 1)
	database_label:SetExpensiveShadow( 1, Color(0,0,0) )

	local database = vgui.Create( "DTextEntry", main_textentry )
	database:Dock(TOP)
	database:DockMargin(4, 1, 4, 1)
	database:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	database:SetText( _database )


	local port_label = vgui.Create("DLabel", main_textentry)
	port_label:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	port_label:SetFont("FAM.DefText")
	port_label:SetText(FlameAdminManagement.GetLang('mysql_setup_port'))
	port_label:SetTextColor(Color(255,255,255))
	port_label:Dock(TOP)
	port_label:SetContentAlignment( 5 )
	port_label:DockMargin(4, 1, 4, 1)
	port_label:SetExpensiveShadow( 1, Color(0,0,0) )

	local port = vgui.Create( "DTextEntry", main_textentry )
	port:Dock(TOP)
	port:DockMargin(4, 1, 4, 1)
	port:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	port:SetText( _port )

	local helper_label = vgui.Create("DLabel", main_textentry)
	helper_label:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	helper_label:SetFont("FAM.DefText")
	helper_label:SetText(FlameAdminManagement.GetLang('mysql_setup_desc'))
	helper_label:SizeToContentsY()
	helper_label:SetTextColor(Color(255,255,255))
	helper_label:Dock(TOP)
	helper_label:SetContentAlignment( 5 )
	helper_label:DockMargin(4, 1, 4, 1)
	helper_label:SetExpensiveShadow( 1, Color(0,0,0) )
	helper_label.Paint = function(self, w, h)
		surface.SetDrawColor(0, 255, 0, 75)
		surface.DrawRect(0, 0, w, h)
	end

	local save_button = vgui.Create("DButton", main_textentry)
	save_button:SetPos(4, main_textentry:GetTall() - 2 - main:GetTall() *.04)
	save_button:SetSize( main_textentry:GetWide() - 8, main:GetTall() *.04 )
	save_button:SetText('')
	save_button.Paint = function(self, w, h)
		if (self.Depressed or self.m_bSelected) then
			surface.SetDrawColor(128, 255, 128, 100)
		elseif (self.Hovered) then
			surface.SetDrawColor(0, 255, 0, 100)
		else
			surface.SetDrawColor(0, 255, 0, 75)
		end

		surface.DrawRect(0, 0, w, h)
		FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('mysql_setup_confirm'), "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
	end

	save_button.OnCursorEntered = function(self)
		surface.PlaySound("garrysmod/ui_hover.wav")
	end

	save_button.DoClick = function(self)
		surface.PlaySound("garrysmod/ui_click.wav")
		self:SetEnabled(false)

		main:FRemove()

		net.Start("FAM.MysqlSetup")
			net.WriteString(ip:GetText())
			net.WriteString(user:GetText())
			net.WriteString(password:GetText())
			net.WriteString(database:GetText())
			net.WriteString(port:GetText())
		net.SendToServer()
	end
end




function FlameAdminManagement.InGameSettings(settings)
	if opened then return end
	opened = true

	for k,v in pairs(FlameAdminManagement.config.WhoCanGiveWarn) do
		if settings.WhoCanGiveWarn[k] == nil then
			settings.WhoCanGiveWarn[k] = v
		end
	end

	for k,v in pairs(FlameAdminManagement.config.CollectStatistics) do
		if settings.WhoCanTakeWarn[k] == nil then
			settings.WhoCanTakeWarn[k] = v
		end
	end

	for k,v in pairs(FlameAdminManagement.config.WhoCanOpenMenu) do
		if settings.WhoCanOpenMenu[k] == nil then
			settings.WhoCanOpenMenu[k] = v
		end
	end

	for k,v in pairs(FlameAdminManagement.config.WhoCanUseInGameSettings) do
		if settings.WhoCanUseInGameSettings[k] == nil then
			settings.WhoCanUseInGameSettings[k] = v
		end
	end

	local main = vgui.Create("DFrame")
	main:SetSize(ScrW() * .3, ScrH() * .7)
	main:SetPos(ScrW() * .5 - main:GetWide() * .5, ScrH())
	main:MoveTo(main.x, ScrH() * .5 - main:GetTall() * .5 - 25, 0.3, 0, 0.4, function()
		main:MoveTo(main.x, ScrH() * .5 - main:GetTall() * .5, 0.15, 0, 0.4)
	end)

	main:MakePopup()
	main:SetTitle('')
	main:ShowCloseButton(false)

	main.Paint = function(self, w, h)
		FlameAdminManagement.DrawBlur(self)
		surface.SetDrawColor(0, 0, 0, 150)
		surface.DrawRect(0, 0, w, h)
		surface.DrawRect(0, 0, w, 25)
		FlameAdminManagement.DrawText("Gambit Management - ".. FlameAdminManagement.GetLang('settings'), "FAM.DefText", w * .5, 12.5, Color(255, 255, 255), 1, 1)
	end

	main.FRemove = function()
		if main.closing then return end
		main.closing = true
		opened = false

		main:MoveTo(main.x, ScrH() * .5 - main:GetTall() * .5 - 25, 0.3, 0, 0.4, function()
			main:MoveTo(main.x, ScrH(), 0.15, 0, 0.4, function()
				main:Remove()
			end)
		end)
	end

	local close = vgui.Create("DButton", main)
	close:SetSize(21, 21)
	close:SetPos(main:GetWide() - 25, 2)
	close:SetText('')

	close.Paint = function(self, w, h)
		if (self.Depressed or self.m_bSelected) then
			surface.SetDrawColor(255, 128, 128, 100)
		elseif (self.Hovered) then
			surface.SetDrawColor(0, 0, 0, 100)
		else
			surface.SetDrawColor(0, 0, 0, 75)
		end

		surface.DrawRect(0, 0, w, h)
		FlameAdminManagement.DrawText("X", "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
	end

	close.OnCursorEntered = function(self)
		surface.PlaySound("garrysmod/ui_hover.wav")
	end

	close.DoClick = function(self)
		surface.PlaySound("garrysmod/ui_click.wav")
		main:FRemove()
	end

	local main_scroll = vgui.Create("DScrollPanel", main)
	main_scroll:SetPos(2, 27)
	main_scroll:SetSize(main:GetWide() - 4, main:GetTall() - 75)
	main_scroll.VBar:SetWide(3)
	main_scroll:DockMargin(0, 0, 0, 0)

	local bar = main_scroll.VBar
	bar.Paint = nil
	bar.btnUp.Paint = nil
	bar.btnDown.Paint = nil

	main_scroll.Paint = function(self, w, h)
		surface.SetDrawColor(0, 0, 0, 125)
		surface.DrawRect(0, 0, w, h)
	end

	local sheet_to_remove = {}

	main_scroll.ChangePageA = function(l_pr_r, cb)
		l_pr_r = l_pr_r or "right"
		cb = cb or function() end

		if l_pr_r == "right" then
			main_scroll:MoveTo(-16, 27,0.1,0,-1,function()
				main_scroll:MoveTo(main:GetWide(), 27,0.3,0,-1,function()
					for k,v in pairs(sheet_to_remove) do
						v:Remove()
					end

					sheet_to_remove = {}

					main_scroll:SetPos(-main_scroll:GetWide(), 27)
					cb()
					main_scroll:MoveTo(18, 27,0.3,0,-1, function()
						main_scroll:MoveTo(2, 27,0.1)
					end)
				end)
			end)
		elseif l_pr_r == "left" then
			main_scroll:MoveTo(18, 27,0.1,0,-1,function()
				main_scroll:MoveTo(-main:GetWide(), 27,0.3,0,-1,function()
					for k,v in pairs(sheet_to_remove) do
						v:Remove()
					end

					sheet_to_remove = {}

					main_scroll:SetPos(main_scroll:GetWide(), 27)
					cb()
					main_scroll:MoveTo(-16, 27,0.3,0,-1, function()
						main_scroll:MoveTo(2, 27,0.1)
					end)
				end)
			end)
		end
	end

	main.MainPage = function()
		local WhoCanGiveWarn_b = vgui.Create("DButton", main_scroll)
		WhoCanGiveWarn_b:Dock(TOP)
		WhoCanGiveWarn_b:DockMargin(2,1,2,1)
		WhoCanGiveWarn_b:SetText('')
		WhoCanGiveWarn_b:SetTall(main_scroll:GetTall()*.05)
		sheet_to_remove[#sheet_to_remove + 1] = WhoCanGiveWarn_b
		WhoCanGiveWarn_b.Paint = function(self, w, h)
			if (self.Depressed or self.m_bSelected) then
				surface.SetDrawColor(0, 0, 0, 150)
			elseif (self.Hovered) then
				surface.SetDrawColor(0, 0, 0, 100)
			else
				surface.SetDrawColor(0, 0, 0, 75)
			end

			surface.DrawRect(0, 0, w, h)
			FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('settings_who_can_give_warn'), "FAM.DefText", 2, h * .5, Color(255, 255, 255), 0, 1)
			FlameAdminManagement.DrawText(">", "FAM.DefText", w - 2, h * .5, Color(255, 255, 255), 2, 1)
		end

		WhoCanGiveWarn_b.OnCursorEntered = function(self)
			surface.PlaySound("garrysmod/ui_hover.wav")
		end

		WhoCanGiveWarn_b.DoClick = function(self)
			surface.PlaySound("garrysmod/ui_click.wav")

			main_scroll.ChangePageA("right", function()
				local WhoCanGiveWarn_main = vgui.Create("DPanel", main_scroll)
				WhoCanGiveWarn_main:SetPos(2,2)
				WhoCanGiveWarn_main:SetSize(main_scroll:GetWide() - 4, main_scroll:GetTall() - 4)
				sheet_to_remove[#sheet_to_remove + 1] = WhoCanGiveWarn_main
				WhoCanGiveWarn_main.Paint = function(self,w,h)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('settings_who_can_give_warn_d'), "FAM.DefText", w * .5, 2, Color(255, 255, 255), 1, 0)
					FlameAdminManagement.DrawText("(rank/steamid/steamid64)", "FAM.DefText", w * .5, 2 + font_size["FAM.DefText"].h, Color(255, 255, 255), 1, 0)
				end

				local WhoCanGiveWarn_main_scroll = vgui.Create("DScrollPanel", WhoCanGiveWarn_main)
				WhoCanGiveWarn_main_scroll:SetPos(2, font_size["FAM.DefText"].h*2 + 4)
				WhoCanGiveWarn_main_scroll:SetSize(WhoCanGiveWarn_main:GetWide() - 4, WhoCanGiveWarn_main:GetTall() - 8 - font_size["FAM.DefText"].h*2 - 52)
				WhoCanGiveWarn_main_scroll.VBar:SetWide(3)
				WhoCanGiveWarn_main_scroll:DockMargin(0, 0, 0, 0)

				local bar = WhoCanGiveWarn_main_scroll.VBar
				bar.Paint = nil
				bar.btnUp.Paint = nil
				bar.btnDown.Paint = nil

				WhoCanGiveWarn_main_scroll.Paint = function(self, w, h)
					surface.SetDrawColor(0,0,0,100)
					surface.DrawRect(0,0,w,h)
				end

				WhoCanGiveWarn_main_scroll.AddToList = function(k, v)
					local b = vgui.Create("DButton", WhoCanGiveWarn_main_scroll)
					b:SetText('')
					b:Dock(TOP)
					b:DockMargin(2,1,2,1)
					b.id = k
					b.v = v
					b.Paint = function(self, w, h)
						if (self.Depressed or self.m_bSelected) then
							surface.SetDrawColor(0, 0, 0, 150)
						elseif (self.Hovered) then
							surface.SetDrawColor(0, 0, 0, 100)
						else
							surface.SetDrawColor(0, 0, 0, 75)
						end

						surface.DrawRect(0, 0, w, h)
						local x, _ = FlameAdminManagement.DrawText(k .. " - ", "FAM.DefText", 2, h * .5, Color(255, 255, 255), 0, 1)
						if self.v then
							FlameAdminManagement.DrawText('true', "FAM.DefText", 2 + x, h * .5, Color(0, 255, 0), 0, 1)
						else
							FlameAdminManagement.DrawText('false', "FAM.DefText", 2 + x, h * .5, Color(255, 0, 0), 0, 1)
						end
					end

					b.OnCursorEntered = function(self)
						surface.PlaySound("garrysmod/ui_hover.wav")
					end

					b.DoClick = function(self)
						surface.PlaySound("garrysmod/ui_click.wav")

						local Menu = DermaMenu()
						if self.v then
							Menu:AddOption( FlameAdminManagement.GetLang("settings_disable"), function() settings.WhoCanGiveWarn[self.id] = false self.v = false end):SetIcon("icon16/cross.png")
						else
							Menu:AddOption( FlameAdminManagement.GetLang("settings_enable"), function() settings.WhoCanGiveWarn[self.id] = true self.v = true end):SetIcon("icon16/add.png")
						end

						if not FlameAdminManagement.config.WhoCanGiveWarn[self.id] then
							Menu:AddSpacer()
							Menu:AddOption( FlameAdminManagement.GetLang("settings_delete"), function() settings.WhoCanGiveWarn[self.id] = nil self:Remove() end):SetIcon("icon16/delete.png")
						end

						Menu:Open()
					end
				end

				for k,v in pairs(settings.WhoCanGiveWarn) do
					WhoCanGiveWarn_main_scroll.AddToList(k,v)
				end

				local WhoCanGiveWarn_main_te = vgui.Create( "DTextEntry", WhoCanGiveWarn_main )
				WhoCanGiveWarn_main_te:SetPos( 2, WhoCanGiveWarn_main:GetTall() - 54 )
				WhoCanGiveWarn_main_te:SetSize( WhoCanGiveWarn_main:GetWide() - 31, 25 )
				WhoCanGiveWarn_main_te:SetText( "Rank/SteamID/SteamID64" )
				WhoCanGiveWarn_main_te.OnEnter = function( self )
					self:RequestFocus()
				end

				local WhoCanGiveWarn_main_add_b = vgui.Create("DButton", WhoCanGiveWarn_main)
				WhoCanGiveWarn_main_add_b:SetSize(25,25)
				WhoCanGiveWarn_main_add_b:SetPos(WhoCanGiveWarn_main:GetWide() - 27, WhoCanGiveWarn_main:GetTall() - 54)
				WhoCanGiveWarn_main_add_b:SetText('')
				WhoCanGiveWarn_main_add_b.Paint = function(self, w, h)
					if (self.Depressed or self.m_bSelected) then
						surface.SetDrawColor(0, 255, 0, 150)
					elseif (self.Hovered) then
						surface.SetDrawColor(0, 255, 0, 100)
					else
						surface.SetDrawColor(0, 255, 0, 75)
					end

					surface.DrawRect(0, 0, w, h)
					FlameAdminManagement.DrawText("+", "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
				end

				WhoCanGiveWarn_main_add_b.OnCursorEntered = function(self)
					surface.PlaySound("garrysmod/ui_hover.wav")
				end

				WhoCanGiveWarn_main_add_b.DoClick = function(self)
					surface.PlaySound("garrysmod/ui_click.wav")
					if #WhoCanGiveWarn_main_te:GetText() > 1 then
						WhoCanGiveWarn_main_scroll.AddToList(WhoCanGiveWarn_main_te:GetText(), true)
						settings.WhoCanGiveWarn[WhoCanGiveWarn_main_te:GetText()] = true

						WhoCanGiveWarn_main_te:SetText('')
						WhoCanGiveWarn_main_te:RequestFocus()

						PrintTable(settings)
					end
				end

				local back = vgui.Create("DButton", WhoCanGiveWarn_main)
				back:SetSize(WhoCanGiveWarn_main:GetWide() - 4, 25)
				back:SetPos(2, WhoCanGiveWarn_main:GetTall() - 27)
				back:SetText('')
				back.Paint = function(self, w, h)
					if (self.Depressed or self.m_bSelected) then
						surface.SetDrawColor(255, 0, 0, 150)
					elseif (self.Hovered) then
						surface.SetDrawColor(255, 0, 0, 100)
					else
						surface.SetDrawColor(255, 0, 0, 75)
					end

					surface.DrawRect(0, 0, w, h)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang("go_back"), "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
				end

				back.OnCursorEntered = function(self)
					surface.PlaySound("garrysmod/ui_hover.wav")
				end

				back.DoClick = function(self)
					surface.PlaySound("garrysmod/ui_click.wav")
					main_scroll.ChangePageA("left", main.MainPage)
				end
			end)
		end






		local WhoCanTakeWarn_b = vgui.Create("DButton", main_scroll)
		WhoCanTakeWarn_b:Dock(TOP)
		WhoCanTakeWarn_b:DockMargin(2,1,2,1)
		WhoCanTakeWarn_b:SetText('')
		WhoCanTakeWarn_b:SetTall(main_scroll:GetTall()*.05)
		sheet_to_remove[#sheet_to_remove + 1] = WhoCanTakeWarn_b
		WhoCanTakeWarn_b.Paint = function(self, w, h)
			if (self.Depressed or self.m_bSelected) then
				surface.SetDrawColor(0, 0, 0, 150)
			elseif (self.Hovered) then
				surface.SetDrawColor(0, 0, 0, 100)
			else
				surface.SetDrawColor(0, 0, 0, 75)
			end

			surface.DrawRect(0, 0, w, h)
			FlameAdminManagement.DrawText(FlameAdminManagement.GetLang("settings_who_can_collect_stats"), "FAM.DefText", 2, h * .5, Color(255, 255, 255), 0, 1)
			FlameAdminManagement.DrawText(">", "FAM.DefText", w - 2, h * .5, Color(255, 255, 255), 2, 1)
		end

		WhoCanTakeWarn_b.OnCursorEntered = function(self)
			surface.PlaySound("garrysmod/ui_hover.wav")
		end

		WhoCanTakeWarn_b.DoClick = function(self)
			surface.PlaySound("garrysmod/ui_click.wav")

			main_scroll.ChangePageA("right", function()
				local WhoCanTakeWarn_main = vgui.Create("DPanel", main_scroll)
				WhoCanTakeWarn_main:SetPos(2,2)
				WhoCanTakeWarn_main:SetSize(main_scroll:GetWide() - 4, main_scroll:GetTall() - 4)
				sheet_to_remove[#sheet_to_remove + 1] = WhoCanTakeWarn_main
				WhoCanTakeWarn_main.Paint = function(self,w,h)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang("settings_who_can_collect_stats_d"), "FAM.DefText", w * .5, 2, Color(255, 255, 255), 1, 0)
					FlameAdminManagement.DrawText("(rank/steamid/steamid64)", "FAM.DefText", w * .5, 2 + font_size["FAM.DefText"].h, Color(255, 255, 255), 1, 0)
				end

				local WhoCanTakeWarn_main_scroll = vgui.Create("DScrollPanel", WhoCanTakeWarn_main)
				WhoCanTakeWarn_main_scroll:SetPos(2, font_size["FAM.DefText"].h*2 + 4)
				WhoCanTakeWarn_main_scroll:SetSize(WhoCanTakeWarn_main:GetWide() - 4, WhoCanTakeWarn_main:GetTall() - 8 - font_size["FAM.DefText"].h*2 - 52)
				WhoCanTakeWarn_main_scroll.VBar:SetWide(3)
				WhoCanTakeWarn_main_scroll:DockMargin(0, 0, 0, 0)

				local bar = WhoCanTakeWarn_main_scroll.VBar
				bar.Paint = nil
				bar.btnUp.Paint = nil
				bar.btnDown.Paint = nil

				WhoCanTakeWarn_main_scroll.Paint = function(self, w, h)
					surface.SetDrawColor(0,0,0,100)
					surface.DrawRect(0,0,w,h)
				end

				WhoCanTakeWarn_main_scroll.AddToList = function(k, v)
					local b = vgui.Create("DButton", WhoCanTakeWarn_main_scroll)
					b:SetText('')
					b:Dock(TOP)
					b:DockMargin(2,1,2,1)
					b.id = k
					b.v = v
					b.Paint = function(self, w, h)
						if (self.Depressed or self.m_bSelected) then
							surface.SetDrawColor(0, 0, 0, 150)
						elseif (self.Hovered) then
							surface.SetDrawColor(0, 0, 0, 100)
						else
							surface.SetDrawColor(0, 0, 0, 75)
						end

						surface.DrawRect(0, 0, w, h)
						local x, _ = FlameAdminManagement.DrawText(k .. " - ", "FAM.DefText", 2, h * .5, Color(255, 255, 255), 0, 1)
						if self.v then
							FlameAdminManagement.DrawText('true', "FAM.DefText", 2 + x, h * .5, Color(0, 255, 0), 0, 1)
						else
							FlameAdminManagement.DrawText('false', "FAM.DefText", 2 + x, h * .5, Color(255, 0, 0), 0, 1)
						end
					end

					b.OnCursorEntered = function(self)
						surface.PlaySound("garrysmod/ui_hover.wav")
					end

					b.DoClick = function(self)
						surface.PlaySound("garrysmod/ui_click.wav")

						local Menu = DermaMenu()
						if self.v then
							Menu:AddOption( FlameAdminManagement.GetLang("settings_disable"), function() settings.WhoCanTakeWarn[self.id] = false self.v = false end):SetIcon("icon16/cross.png")
						else
							Menu:AddOption( FlameAdminManagement.GetLang("settings_enable"), function() settings.WhoCanTakeWarn[self.id] = true self.v = true end):SetIcon("icon16/add.png")
						end

						if not FlameAdminManagement.config.CollectStatistics[self.id] then
							Menu:AddSpacer()
							Menu:AddOption( FlameAdminManagement.GetLang("settings_delete"), function() settings.WhoCanTakeWarn[self.id] = nil self:Remove() end):SetIcon("icon16/delete.png")
						end

						Menu:Open()
					end
				end

				for k,v in pairs(settings.WhoCanTakeWarn) do
					WhoCanTakeWarn_main_scroll.AddToList(k,v)
				end

				local WhoCanTakeWarn_main_te = vgui.Create( "DTextEntry", WhoCanTakeWarn_main )
				WhoCanTakeWarn_main_te:SetPos( 2, WhoCanTakeWarn_main:GetTall() - 54 )
				WhoCanTakeWarn_main_te:SetSize( WhoCanTakeWarn_main:GetWide() - 31, 25 )
				WhoCanTakeWarn_main_te:SetText( "Rank/SteamID/SteamID64" )
				WhoCanTakeWarn_main_te.OnEnter = function( self )
					self:RequestFocus()
				end

				local WhoCanTakeWarn_main_add_b = vgui.Create("DButton", WhoCanTakeWarn_main)
				WhoCanTakeWarn_main_add_b:SetSize(25,25)
				WhoCanTakeWarn_main_add_b:SetPos(WhoCanTakeWarn_main:GetWide() - 27, WhoCanTakeWarn_main:GetTall() - 54)
				WhoCanTakeWarn_main_add_b:SetText('')
				WhoCanTakeWarn_main_add_b.Paint = function(self, w, h)
					if (self.Depressed or self.m_bSelected) then
						surface.SetDrawColor(0, 255, 0, 150)
					elseif (self.Hovered) then
						surface.SetDrawColor(0, 255, 0, 100)
					else
						surface.SetDrawColor(0, 255, 0, 75)
					end

					surface.DrawRect(0, 0, w, h)
					FlameAdminManagement.DrawText("+", "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
				end

				WhoCanTakeWarn_main_add_b.OnCursorEntered = function(self)
					surface.PlaySound("garrysmod/ui_hover.wav")
				end

				WhoCanTakeWarn_main_add_b.DoClick = function(self)
					surface.PlaySound("garrysmod/ui_click.wav")
					if #WhoCanTakeWarn_main_te:GetText() > 1 then
						WhoCanTakeWarn_main_scroll.AddToList(WhoCanTakeWarn_main_te:GetText(), true)
						settings.WhoCanTakeWarn[WhoCanTakeWarn_main_te:GetText()] = true

						WhoCanTakeWarn_main_te:SetText('')
						WhoCanTakeWarn_main_te:RequestFocus()

						PrintTable(settings)
					end
				end

				local back = vgui.Create("DButton", WhoCanTakeWarn_main)
				back:SetSize(WhoCanTakeWarn_main:GetWide() - 4, 25)
				back:SetPos(2, WhoCanTakeWarn_main:GetTall() - 27)
				back:SetText('')
				back.Paint = function(self, w, h)
					if (self.Depressed or self.m_bSelected) then
						surface.SetDrawColor(255, 0, 0, 150)
					elseif (self.Hovered) then
						surface.SetDrawColor(255, 0, 0, 100)
					else
						surface.SetDrawColor(255, 0, 0, 75)
					end

					surface.DrawRect(0, 0, w, h)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang("go_back"), "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
				end

				back.OnCursorEntered = function(self)
					surface.PlaySound("garrysmod/ui_hover.wav")
				end

				back.DoClick = function(self)
					surface.PlaySound("garrysmod/ui_click.wav")
					main_scroll.ChangePageA("left", main.MainPage)
				end
			end)
		end









		local WhoCanOpenMenu_b = vgui.Create("DButton", main_scroll)
		WhoCanOpenMenu_b:Dock(TOP)
		WhoCanOpenMenu_b:DockMargin(2,1,2,1)
		WhoCanOpenMenu_b:SetText('')
		WhoCanOpenMenu_b:SetTall(main_scroll:GetTall()*.05)
		sheet_to_remove[#sheet_to_remove + 1] = WhoCanOpenMenu_b
		WhoCanOpenMenu_b.Paint = function(self, w, h)
			if (self.Depressed or self.m_bSelected) then
				surface.SetDrawColor(0, 0, 0, 150)
			elseif (self.Hovered) then
				surface.SetDrawColor(0, 0, 0, 100)
			else
				surface.SetDrawColor(0, 0, 0, 75)
			end

			surface.DrawRect(0, 0, w, h)
			FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('settings_who_can_open_main_menu'), "FAM.DefText", 2, h * .5, Color(255, 255, 255), 0, 1)
			FlameAdminManagement.DrawText(">", "FAM.DefText", w - 2, h * .5, Color(255, 255, 255), 2, 1)
		end

		WhoCanOpenMenu_b.OnCursorEntered = function(self)
			surface.PlaySound("garrysmod/ui_hover.wav")
		end

		WhoCanOpenMenu_b.DoClick = function(self)
			surface.PlaySound("garrysmod/ui_click.wav")

			main_scroll.ChangePageA("right", function()
				local WhoCanOpenMenu_main = vgui.Create("DPanel", main_scroll)
				WhoCanOpenMenu_main:SetPos(2,2)
				WhoCanOpenMenu_main:SetSize(main_scroll:GetWide() - 4, main_scroll:GetTall() - 4)
				sheet_to_remove[#sheet_to_remove + 1] = WhoCanOpenMenu_main
				WhoCanOpenMenu_main.Paint = function(self,w,h)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('settings_who_can_open_main_menu_d'), "FAM.DefText", w * .5, 2, Color(255, 255, 255), 1, 0)
					FlameAdminManagement.DrawText("(rank/steamid/steamid64)", "FAM.DefText", w * .5, 2 + font_size["FAM.DefText"].h, Color(255, 255, 255), 1, 0)
				end

				local WhoCanOpenMenu_main_scroll = vgui.Create("DScrollPanel", WhoCanOpenMenu_main)
				WhoCanOpenMenu_main_scroll:SetPos(2, font_size["FAM.DefText"].h*2 + 4)
				WhoCanOpenMenu_main_scroll:SetSize(WhoCanOpenMenu_main:GetWide() - 4, WhoCanOpenMenu_main:GetTall() - 8 - font_size["FAM.DefText"].h*2 - 52)
				WhoCanOpenMenu_main_scroll.VBar:SetWide(3)
				WhoCanOpenMenu_main_scroll:DockMargin(0, 0, 0, 0)

				local bar = WhoCanOpenMenu_main_scroll.VBar
				bar.Paint = nil
				bar.btnUp.Paint = nil
				bar.btnDown.Paint = nil

				WhoCanOpenMenu_main_scroll.Paint = function(self, w, h)
					surface.SetDrawColor(0,0,0,100)
					surface.DrawRect(0,0,w,h)
				end

				WhoCanOpenMenu_main_scroll.AddToList = function(k, v)
					local b = vgui.Create("DButton", WhoCanOpenMenu_main_scroll)
					b:SetText('')
					b:Dock(TOP)
					b:DockMargin(2,1,2,1)
					b.id = k
					b.v = v
					b.Paint = function(self, w, h)
						if (self.Depressed or self.m_bSelected) then
							surface.SetDrawColor(0, 0, 0, 150)
						elseif (self.Hovered) then
							surface.SetDrawColor(0, 0, 0, 100)
						else
							surface.SetDrawColor(0, 0, 0, 75)
						end

						surface.DrawRect(0, 0, w, h)
						local x, _ = FlameAdminManagement.DrawText(k .. " - ", "FAM.DefText", 2, h * .5, Color(255, 255, 255), 0, 1)
						if self.v then
							FlameAdminManagement.DrawText('true', "FAM.DefText", 2 + x, h * .5, Color(0, 255, 0), 0, 1)
						else
							FlameAdminManagement.DrawText('false', "FAM.DefText", 2 + x, h * .5, Color(255, 0, 0), 0, 1)
						end
					end

					b.OnCursorEntered = function(self)
						surface.PlaySound("garrysmod/ui_hover.wav")
					end

					b.DoClick = function(self)
						surface.PlaySound("garrysmod/ui_click.wav")

						local Menu = DermaMenu()
						if self.v then
							Menu:AddOption( FlameAdminManagement.GetLang("settings_disable"), function() settings.WhoCanOpenMenu[self.id] = false self.v = false end):SetIcon("icon16/cross.png")
						else
							Menu:AddOption( FlameAdminManagement.GetLang("settings_enable"), function() settings.WhoCanOpenMenu[self.id] = true self.v = true end):SetIcon("icon16/add.png")
						end

						if not FlameAdminManagement.config.WhoCanOpenMenu[self.id] then
							Menu:AddSpacer()
							Menu:AddOption( FlameAdminManagement.GetLang("settings_delete"), function() settings.WhoCanOpenMenu[self.id] = nil self:Remove() end):SetIcon("icon16/delete.png")
						end

						Menu:Open()
					end
				end

				for k,v in pairs(settings.WhoCanOpenMenu) do
					WhoCanOpenMenu_main_scroll.AddToList(k,v)
				end

				local WhoCanOpenMenu_main_te = vgui.Create( "DTextEntry", WhoCanOpenMenu_main )
				WhoCanOpenMenu_main_te:SetPos( 2, WhoCanOpenMenu_main:GetTall() - 54 )
				WhoCanOpenMenu_main_te:SetSize( WhoCanOpenMenu_main:GetWide() - 31, 25 )
				WhoCanOpenMenu_main_te:SetText( "Rank/SteamID/SteamID64" )
				WhoCanOpenMenu_main_te.OnEnter = function( self )
					self:RequestFocus()
				end

				local WhoCanOpenMenu_main_add_b = vgui.Create("DButton", WhoCanOpenMenu_main)
				WhoCanOpenMenu_main_add_b:SetSize(25,25)
				WhoCanOpenMenu_main_add_b:SetPos(WhoCanOpenMenu_main:GetWide() - 27, WhoCanOpenMenu_main:GetTall() - 54)
				WhoCanOpenMenu_main_add_b:SetText('')
				WhoCanOpenMenu_main_add_b.Paint = function(self, w, h)
					if (self.Depressed or self.m_bSelected) then
						surface.SetDrawColor(0, 255, 0, 150)
					elseif (self.Hovered) then
						surface.SetDrawColor(0, 255, 0, 100)
					else
						surface.SetDrawColor(0, 255, 0, 75)
					end

					surface.DrawRect(0, 0, w, h)
					FlameAdminManagement.DrawText("+", "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
				end

				WhoCanOpenMenu_main_add_b.OnCursorEntered = function(self)
					surface.PlaySound("garrysmod/ui_hover.wav")
				end

				WhoCanOpenMenu_main_add_b.DoClick = function(self)
					surface.PlaySound("garrysmod/ui_click.wav")
					if #WhoCanOpenMenu_main_te:GetText() > 1 then
						WhoCanOpenMenu_main_scroll.AddToList(WhoCanOpenMenu_main_te:GetText(), true)
						settings.WhoCanOpenMenu[WhoCanOpenMenu_main_te:GetText()] = true

						WhoCanOpenMenu_main_te:SetText('')
						WhoCanOpenMenu_main_te:RequestFocus()

						PrintTable(settings)
					end
				end

				local back = vgui.Create("DButton", WhoCanOpenMenu_main)
				back:SetSize(WhoCanOpenMenu_main:GetWide() - 4, 25)
				back:SetPos(2, WhoCanOpenMenu_main:GetTall() - 27)
				back:SetText('')
				back.Paint = function(self, w, h)
					if (self.Depressed or self.m_bSelected) then
						surface.SetDrawColor(255, 0, 0, 150)
					elseif (self.Hovered) then
						surface.SetDrawColor(255, 0, 0, 100)
					else
						surface.SetDrawColor(255, 0, 0, 75)
					end

					surface.DrawRect(0, 0, w, h)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang("go_back"), "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
				end

				back.OnCursorEntered = function(self)
					surface.PlaySound("garrysmod/ui_hover.wav")
				end

				back.DoClick = function(self)
					surface.PlaySound("garrysmod/ui_click.wav")
					main_scroll.ChangePageA("left", main.MainPage)
				end
			end)
		end



		local WhoCanUseInGameSettings_b = vgui.Create("DButton", main_scroll)
		WhoCanUseInGameSettings_b:Dock(TOP)
		WhoCanUseInGameSettings_b:DockMargin(2,1,2,1)
		WhoCanUseInGameSettings_b:SetText('')
		WhoCanUseInGameSettings_b:SetTall(main_scroll:GetTall()*.05)
		sheet_to_remove[#sheet_to_remove + 1] = WhoCanUseInGameSettings_b
		WhoCanUseInGameSettings_b.Paint = function(self, w, h)
			if (self.Depressed or self.m_bSelected) then
				surface.SetDrawColor(0, 0, 0, 150)
			elseif (self.Hovered) then
				surface.SetDrawColor(0, 0, 0, 100)
			else
				surface.SetDrawColor(0, 0, 0, 75)
			end

			surface.DrawRect(0, 0, w, h)
			FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('settings_who_has_accet_to_ingame_s'), "FAM.DefText", 2, h * .5, Color(255, 255, 255), 0, 1)
			FlameAdminManagement.DrawText(">", "FAM.DefText", w - 2, h * .5, Color(255, 255, 255), 2, 1)
		end

		WhoCanUseInGameSettings_b.OnCursorEntered = function(self)
			surface.PlaySound("garrysmod/ui_hover.wav")
		end

		WhoCanUseInGameSettings_b.DoClick = function(self)
			surface.PlaySound("garrysmod/ui_click.wav")

			main_scroll.ChangePageA("right", function()
				local WhoCanUseInGameSettings_main = vgui.Create("DPanel", main_scroll)
				WhoCanUseInGameSettings_main:SetPos(2,2)
				WhoCanUseInGameSettings_main:SetSize(main_scroll:GetWide() - 4, main_scroll:GetTall() - 4)
				sheet_to_remove[#sheet_to_remove + 1] = WhoCanUseInGameSettings_main
				WhoCanUseInGameSettings_main.Paint = function(self,w,h)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('settings_who_has_accet_to_ingame_s_d1'), "FAM.DefText", w * .5, 2, Color(255, 255, 255), 1, 0)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('settings_who_has_accet_to_ingame_s_d2'), "FAM.DefText", w * .5, 2 + font_size["FAM.DefText"].h, Color(255, 255, 255), 1, 0)
				end

				local WhoCanUseInGameSettings_main_scroll = vgui.Create("DScrollPanel", WhoCanUseInGameSettings_main)
				WhoCanUseInGameSettings_main_scroll:SetPos(2, font_size["FAM.DefText"].h*2 + 4)
				WhoCanUseInGameSettings_main_scroll:SetSize(WhoCanUseInGameSettings_main:GetWide() - 4, WhoCanUseInGameSettings_main:GetTall() - 8 - font_size["FAM.DefText"].h*2 - 52)
				WhoCanUseInGameSettings_main_scroll.VBar:SetWide(3)
				WhoCanUseInGameSettings_main_scroll:DockMargin(0, 0, 0, 0)

				local bar = WhoCanUseInGameSettings_main_scroll.VBar
				bar.Paint = nil
				bar.btnUp.Paint = nil
				bar.btnDown.Paint = nil

				WhoCanUseInGameSettings_main_scroll.Paint = function(self, w, h)
					surface.SetDrawColor(0,0,0,100)
					surface.DrawRect(0,0,w,h)
				end

				WhoCanUseInGameSettings_main_scroll.AddToList = function(k, v)
					local b = vgui.Create("DButton", WhoCanUseInGameSettings_main_scroll)
					b:SetText('')
					b:Dock(TOP)
					b:DockMargin(2,1,2,1)
					b.id = k
					b.v = v
					b.Paint = function(self, w, h)
						if (self.Depressed or self.m_bSelected) then
							surface.SetDrawColor(0, 0, 0, 150)
						elseif (self.Hovered) then
							surface.SetDrawColor(0, 0, 0, 100)
						else
							surface.SetDrawColor(0, 0, 0, 75)
						end

						surface.DrawRect(0, 0, w, h)
						local x, _ = FlameAdminManagement.DrawText(k .. " - ", "FAM.DefText", 2, h * .5, Color(255, 255, 255), 0, 1)
						if self.v then
							FlameAdminManagement.DrawText('true', "FAM.DefText", 2 + x, h * .5, Color(0, 255, 0), 0, 1)
						else
							FlameAdminManagement.DrawText('false', "FAM.DefText", 2 + x, h * .5, Color(255, 0, 0), 0, 1)
						end
					end

					b.OnCursorEntered = function(self)
						surface.PlaySound("garrysmod/ui_hover.wav")
					end

					b.DoClick = function(self)
						surface.PlaySound("garrysmod/ui_click.wav")

						local Menu = DermaMenu()
						if self.v then
							Menu:AddOption( FlameAdminManagement.GetLang("settings_disable"), function() settings.WhoCanUseInGameSettings[self.id] = false self.v = false end):SetIcon("icon16/cross.png")
						else
							Menu:AddOption( FlameAdminManagement.GetLang("settings_enable"), function() settings.WhoCanUseInGameSettings[self.id] = true self.v = true end):SetIcon("icon16/add.png")
						end

						if not FlameAdminManagement.config.WhoCanUseInGameSettings[self.id] then
							Menu:AddSpacer()
							Menu:AddOption( FlameAdminManagement.GetLang("settings_delete"), function() settings.WhoCanUseInGameSettings[self.id] = nil self:Remove() end):SetIcon("icon16/delete.png")
						end

						Menu:Open()
					end
				end

				for k,v in pairs(settings.WhoCanUseInGameSettings) do
					WhoCanUseInGameSettings_main_scroll.AddToList(k,v)
				end

				local WhoCanUseInGameSettings_main_te = vgui.Create( "DTextEntry", WhoCanUseInGameSettings_main )
				WhoCanUseInGameSettings_main_te:SetPos( 2, WhoCanUseInGameSettings_main:GetTall() - 54 )
				WhoCanUseInGameSettings_main_te:SetSize( WhoCanUseInGameSettings_main:GetWide() - 31, 25 )
				WhoCanUseInGameSettings_main_te:SetText( "Rank/SteamID/SteamID64" )
				WhoCanUseInGameSettings_main_te.OnEnter = function( self )
					self:RequestFocus()
				end

				local WhoCanUseInGameSettings_main_add_b = vgui.Create("DButton", WhoCanUseInGameSettings_main)
				WhoCanUseInGameSettings_main_add_b:SetSize(25,25)
				WhoCanUseInGameSettings_main_add_b:SetPos(WhoCanUseInGameSettings_main:GetWide() - 27, WhoCanUseInGameSettings_main:GetTall() - 54)
				WhoCanUseInGameSettings_main_add_b:SetText('')
				WhoCanUseInGameSettings_main_add_b.Paint = function(self, w, h)
					if (self.Depressed or self.m_bSelected) then
						surface.SetDrawColor(0, 255, 0, 150)
					elseif (self.Hovered) then
						surface.SetDrawColor(0, 255, 0, 100)
					else
						surface.SetDrawColor(0, 255, 0, 75)
					end

					surface.DrawRect(0, 0, w, h)
					FlameAdminManagement.DrawText("+", "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
				end

				WhoCanUseInGameSettings_main_add_b.OnCursorEntered = function(self)
					surface.PlaySound("garrysmod/ui_hover.wav")
				end

				WhoCanUseInGameSettings_main_add_b.DoClick = function(self)
					surface.PlaySound("garrysmod/ui_click.wav")
					if #WhoCanUseInGameSettings_main_te:GetText() > 1 then
						WhoCanUseInGameSettings_main_scroll.AddToList(WhoCanUseInGameSettings_main_te:GetText(), true)
						settings.WhoCanUseInGameSettings[WhoCanUseInGameSettings_main_te:GetText()] = true

						WhoCanUseInGameSettings_main_te:SetText('')
						WhoCanUseInGameSettings_main_te:RequestFocus()

						PrintTable(settings)
					end
				end

				local back = vgui.Create("DButton", WhoCanUseInGameSettings_main)
				back:SetSize(WhoCanUseInGameSettings_main:GetWide() - 4, 25)
				back:SetPos(2, WhoCanUseInGameSettings_main:GetTall() - 27)
				back:SetText('')
				back.Paint = function(self, w, h)
					if (self.Depressed or self.m_bSelected) then
						surface.SetDrawColor(255, 0, 0, 150)
					elseif (self.Hovered) then
						surface.SetDrawColor(255, 0, 0, 100)
					else
						surface.SetDrawColor(255, 0, 0, 75)
					end

					surface.DrawRect(0, 0, w, h)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang("go_back"), "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
				end

				back.OnCursorEntered = function(self)
					surface.PlaySound("garrysmod/ui_hover.wav")
				end

				back.DoClick = function(self)
					surface.PlaySound("garrysmod/ui_click.wav")
					main_scroll.ChangePageA("left", main.MainPage)
				end
			end)
		end




		local Punishments_b = vgui.Create("DButton", main_scroll)
		Punishments_b:Dock(TOP)
		Punishments_b:DockMargin(2,1,2,1)
		Punishments_b:SetText('')
		Punishments_b:SetTall(main_scroll:GetTall()*.05)
		sheet_to_remove[#sheet_to_remove + 1] = Punishments_b
		Punishments_b.Paint = function(self, w, h)
			if (self.Depressed or self.m_bSelected) then
				surface.SetDrawColor(0, 0, 0, 150)
			elseif (self.Hovered) then
				surface.SetDrawColor(0, 0, 0, 100)
			else
				surface.SetDrawColor(0, 0, 0, 75)
			end

			surface.DrawRect(0, 0, w, h)
			FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('settings_punishments'), "FAM.DefText", 2, h * .5, Color(255, 255, 255), 0, 1)
			FlameAdminManagement.DrawText(">", "FAM.DefText", w - 2, h * .5, Color(255, 255, 255), 2, 1)
		end

		Punishments_b.OnCursorEntered = function(self)
			surface.PlaySound("garrysmod/ui_hover.wav")
		end

		Punishments_b.DoClick = function(self)
			surface.PlaySound("garrysmod/ui_click.wav")

			main_scroll.ChangePageA("right", function()
				local Punishments_main = vgui.Create("DPanel", main_scroll)
				Punishments_main:SetPos(2,2)
				Punishments_main:SetSize(main_scroll:GetWide() - 4, main_scroll:GetTall() - 4)
				sheet_to_remove[#sheet_to_remove + 1] = Punishments_main
				Punishments_main.Paint = function(self,w,h)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('settings_punishments_d'), "FAM.DefText", w * .5, 2, Color(255, 255, 255), 1, 0)
				end

				local Punishments_main_scroll = vgui.Create("DScrollPanel", Punishments_main)
				Punishments_main_scroll:SetPos(2, font_size["FAM.DefText"].h*2 + 4)
				Punishments_main_scroll:SetSize(Punishments_main:GetWide() - 4, Punishments_main:GetTall() - 8 - font_size["FAM.DefText"].h*2 - 52)
				Punishments_main_scroll.VBar:SetWide(3)
				Punishments_main_scroll:DockMargin(0, 0, 0, 0)

				local bar = Punishments_main_scroll.VBar
				bar.Paint = nil
				bar.btnUp.Paint = nil
				bar.btnDown.Paint = nil

				Punishments_main_scroll.Paint = function(self, w, h)
					surface.SetDrawColor(0,0,0,100)
					surface.DrawRect(0,0,w,h)
				end

				Punishments_main_scroll.AddToList = function(k, v)
					local b = vgui.Create("DButton", Punishments_main_scroll)
					b:SetText('')
					b:Dock(TOP)
					b:DockMargin(2,1,2,1)
					b.id = tonumber(k)
					b.v = v

					v.t = v.t or ''
					b.Paint = function(self, w, h)
						if (self.Depressed or self.m_bSelected) then
							surface.SetDrawColor(0, 0, 0, 150)
						elseif (self.Hovered) then
							surface.SetDrawColor(0, 0, 0, 100)
						else
							surface.SetDrawColor(0, 0, 0, 75)
						end

						surface.DrawRect(0, 0, w, h)
						FlameAdminManagement.DrawText(k .. " - " .. v.p .. "(" .. v.t ..")", "FAM.DefText", 2, h * .5, Color(255, 255, 255), 0, 1)
					end

					b.OnCursorEntered = function(self)
						surface.PlaySound("garrysmod/ui_hover.wav")
					end

					b.DoClick = function(self)
						surface.PlaySound("garrysmod/ui_click.wav")

						local Menu = DermaMenu()
						Menu:AddSpacer()
						Menu:AddOption( FlameAdminManagement.GetLang("settings_delete"), function() 
							settings.WarnsPunishments[self.id] = nil 
							print(self.id, type(self.id))
							self:Remove() 
						end):SetIcon("icon16/delete.png")

						Menu:Open()
					end
				end

				for k,v in pairs(settings.WarnsPunishments) do
					Punishments_main_scroll.AddToList(k,v)
				end

				local Punishments_main_te = vgui.Create( "DTextEntry", Punishments_main )
				Punishments_main_te:SetPos( 2, Punishments_main:GetTall() - 54 )
				Punishments_main_te:SetSize( Punishments_main:GetWide() * .05, 25 )
				Punishments_main_te:SetText( "3" )
				Punishments_main_te:SetTooltip(FlameAdminManagement.GetLang('settings_punishments_af'))
				Punishments_main_te.OnEnter = function( self )
					self:RequestFocus()
				end


				local Punishments_main_cb_time
				local Punishments_main_cb = vgui.Create( "DComboBox", Punishments_main )
				Punishments_main_cb:SetPos( Punishments_main:GetWide() * .05 + 4, Punishments_main:GetTall() - 54  )
				Punishments_main_cb:SetSize( Punishments_main:GetWide() * .75, 25 )
				for k,v in pairs(FlameAdminManagement.config.PunishmentsTypes) do
					Punishments_main_cb:AddChoice( k, nil, true )
				end
				Punishments_main_cb.OnSelect = function( panel, index, value )
					if FlameAdminManagement.config.PunishmentsTypes[value].times ~= nil then
						Punishments_main_cb_time:SetVisible(true)
						Punishments_main_cb_time:Clear()
						for k,v in pairs(FlameAdminManagement.config.PunishmentsTypes[value].times) do
							Punishments_main_cb_time:AddChoice( k, nil, true )
						end
					else
						Punishments_main_cb_time:SetVisible(false)
					end
				end

				Punishments_main_cb_time = vgui.Create( "DComboBox", Punishments_main )
				Punishments_main_cb_time:SetVisible(false)
				Punishments_main_cb_time:SetPos( Punishments_main:GetWide() * .8 + 4, Punishments_main:GetTall() - 54  )
				Punishments_main_cb_time:SetSize( Punishments_main:GetWide() * .2 - 25 - 8, 25 )
				Punishments_main_cb_time.OnSelect = function( panel, index, value )

				end

				local Punishments_main_add_b = vgui.Create("DButton", Punishments_main)
				Punishments_main_add_b:SetSize(25,25)
				Punishments_main_add_b:SetPos(Punishments_main:GetWide() - 27, Punishments_main:GetTall() - 54)
				Punishments_main_add_b:SetText('')
				Punishments_main_add_b.Paint = function(self, w, h)
					if (self.Depressed or self.m_bSelected) then
						surface.SetDrawColor(0, 255, 0, 150)
					elseif (self.Hovered) then
						surface.SetDrawColor(0, 255, 0, 100)
					else
						surface.SetDrawColor(0, 255, 0, 75)
					end

					surface.DrawRect(0, 0, w, h)
					FlameAdminManagement.DrawText("+", "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
				end

				Punishments_main_add_b.OnCursorEntered = function(self)
					surface.PlaySound("garrysmod/ui_hover.wav")
				end

				Punishments_main_add_b.DoClick = function(self)
					surface.PlaySound("garrysmod/ui_click.wav")

					if settings.WarnsPunishments[tonumber(Punishments_main_te:GetText())] ~= nil then return end
					local temp = {}
					local val,_ = Punishments_main_cb:GetSelected()
					temp.p = val

					if Punishments_main_cb_time:IsVisible() then
						local val,_ = Punishments_main_cb_time:GetSelected()
						temp.t = val
					end

					Punishments_main_scroll.AddToList(Punishments_main_te:GetText(), temp)
					settings.WarnsPunishments[tonumber(Punishments_main_te:GetText())] = temp

					Punishments_main_te:SetText('3')
					Punishments_main_te:RequestFocus()

					PrintTable(settings)
				end

				local back = vgui.Create("DButton", Punishments_main)
				back:SetSize(Punishments_main:GetWide() - 4, 25)
				back:SetPos(2, Punishments_main:GetTall() - 27)
				back:SetText('')
				back.Paint = function(self, w, h)
					if (self.Depressed or self.m_bSelected) then
						surface.SetDrawColor(255, 0, 0, 150)
					elseif (self.Hovered) then
						surface.SetDrawColor(255, 0, 0, 100)
					else
						surface.SetDrawColor(255, 0, 0, 75)
					end

					surface.DrawRect(0, 0, w, h)
					FlameAdminManagement.DrawText(FlameAdminManagement.GetLang("go_back"), "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
				end

				back.OnCursorEntered = function(self)
					surface.PlaySound("garrysmod/ui_hover.wav")
				end

				back.DoClick = function(self)
					surface.PlaySound("garrysmod/ui_click.wav")
					main_scroll.ChangePageA("left", main.MainPage)
				end
			end)
		end
	end

	main.MainPage()

	local mysql = vgui.Create("DButton", main)
	mysql:SetSize(main:GetWide() - 4, 21)
	mysql:SetPos(2, main:GetTall() - 46)
	mysql:SetText('')

	mysql.Paint = function(self, w, h)
		if (self.Depressed or self.m_bSelected) then
			surface.SetDrawColor(255, 80, 80, 150)
		elseif (self.Hovered) then
			surface.SetDrawColor(255, 80, 80, 100)
		else
			surface.SetDrawColor(255, 80, 80, 75)
		end

		surface.DrawRect(0, 0, w, h)
		FlameAdminManagement.DrawText("Mysql", "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
	end

	mysql.OnCursorEntered = function(self)
		surface.PlaySound("garrysmod/ui_hover.wav")
	end

	mysql.DoClick = function(self)
		surface.PlaySound("garrysmod/ui_click.wav")
		net.Start("FAM.MysqlSetup_Menu")
		net.SendToServer()
		main:FRemove()
	end

	local accept = vgui.Create("DButton", main)
	accept:SetSize(main:GetWide() - 4, 21)
	accept:SetPos(2, main:GetTall() - 23)
	accept:SetText('')

	accept.Paint = function(self, w, h)
		if (self.Depressed or self.m_bSelected) then
			surface.SetDrawColor(0, 255, 0, 150)
		elseif (self.Hovered) then
			surface.SetDrawColor(0, 255, 0, 100)
		else
			surface.SetDrawColor(0, 255, 0, 75)
		end

		surface.DrawRect(0, 0, w, h)
		FlameAdminManagement.DrawText(FlameAdminManagement.GetLang('settings_save'), "FAM.DefText", w * .5, h * .5, Color(255, 255, 255), 1, 1)
	end

	accept.OnCursorEntered = function(self)
		surface.PlaySound("garrysmod/ui_hover.wav")
	end

	accept.DoClick = function(self)
		surface.PlaySound("garrysmod/ui_click.wav")
		net.Start("FAM.InGameSettings")
			net.WriteTable(settings)
		net.SendToServer()
		main:FRemove()
	end
end

net.Receive("FAM.RequestGameSettings", function()
	local new_settings = net.ReadTable()
	FlameAdminManagement.settings = new_settings
end)

net.Receive("FAM.InGameSettings", function()
	local tb = net.ReadTable()
	FlameAdminManagement.InGameSettings(tb)
end)

net.Receive("FAM.MysqlSetup_Menu", function()
	local ip = net.ReadString()
	local user = net.ReadString()
	local password = net.ReadString()
	local database = net.ReadString()
	local port = net.ReadString()
	FlameAdminManagement.MysqlSetup(ip, user, password, database, port)
end)
--PATH addons/addon hooks lag finder/lua/autorun/find_laggy_hooks.lua:
--- Ajouter le temps de rendu VGUI.



-- Note: GM functions that have been modified during a test will be restored with an older version.

addon_hooks_lag_finder = addon_hooks_lag_finder or {}

local concommand_name
if SERVER then
	concommand_name = "find_laggy_hooks_sv"
	util.AddNetworkString( "find_laggy_hooks" )
else
	concommand_name = "find_laggy_hooks_cl"
end

local SendToSuperAdmins -- parameter set below

---------- MESSAGE COLORS ----------
local ServerColor = Color( 255, 128, 192 )
local ResultColor
if SERVER then
	ResultColor = ServerColor
else
	ResultColor = Color( 255, 192, 0 )
end

---------- SEND MESSAGE ----------
local function NiceMsgN( ply, ... )
	if SERVER and IsValid( ply ) then
		ply:PrintMessage( HUD_PRINTCONSOLE, string.Implode( "", { ... } ) )
	else
		MsgN( ... )
	end
end

---------- FORMAT HOOK TIMINGS ----------
local IntroMessage = "\n\nHere are the %u laggiest hooks found during the last %u frames:\n"..
	( SERVER and game.IsDedicated() and " Identifier ------------------------------- Impact  Execs  Mean t /f  Max time \n" or--79
	" Identifier ------------------------------------------------------------ Impact  Executions  Mean t /f  Max time \n" )--113
local FormatTimings
do
	local function FillStringSlot( Input, Slot )
		Input = string.sub( Input, 1, Slot )
		Input = Input..( string.rep( " ", Slot-utf8.len( Input ) ) )
		return Input
	end
	local UnitFormats={ -- decimals+unit, multiplier
		-- Greek characters are not used because UTF-8 sub-strings are not supported.
		{"%01.3fus", 1000000},
		{"%01.2fus", 1000000},
		{"%01.1fus", 1000000},
		{"%01.0fus", 1000000},
		{"%01.2fms", 1000},
		{"%01.1fms", 1000},
		{"%01.0fms", 1000},
		{"%01.2fs", 1},
		{"%01.1fs", 1},
		{"%01.0fs", 1},
	}
	local function FillTimeSlot( Input, Slot )
		local NumString
		for i,UnitFormat in ipairs( UnitFormats ) do
			NumString=string.format( UnitFormat[1], Input*UnitFormat[2] )
			if utf8.len( NumString )<=Slot then
				break
			end
		end
		return FillStringSlot( NumString, Slot )
	end
	local function FillIntegerSlot( Input, Slot )
		local NumString = tostring( Input )
		if string.len( NumString )>Slot then
			for decimals=Slot-5,0,-1 do
				NumString = string.format( "%."..decimals.."e", Input )
				if string.len( NumString )<=Slot then
					break
				end
			end
		end
		return FillStringSlot( NumString, Slot )
	end
	local FormatBase = ' %s %s %s %s %s\n  in "%s" (lines %s to %s),\n  %s\n'
	local Slots -- string lengths for virtual table in console
	if CLIENT or !game.IsDedicated() then
		Slots = {
			identifier=71,
			Impact=7,
			count=11,
			meantime=10,
			maxtime=9,
		}
	else
		Slots = {
			identifier=42,
			Impact=7,
			count=6,
			meantime=10,
			maxtime=9,
		}
	end
	function FormatTimings( identifier, Impact, count, meantime, maxtime, LuaFile, linedefined, lastlinedefined, foundstr )
		return string.format( FormatBase,
			FillStringSlot( identifier, Slots.identifier ),
			FillStringSlot( string.format( Impact<10 and "%05.2f%%" or "%1.0f%%", Impact*100 ), Slots.Impact ),
			FillIntegerSlot( count, Slots.count ),
			FillTimeSlot( meantime, Slots.meantime ),
			FillTimeSlot( maxtime, Slots.maxtime ),
			-- FillStringSlot( string.format( "%.2e", meantime ), Slots.meantime ), -- debug
			-- FillStringSlot( string.format( "%.2e", maxtime ), Slots.maxtime ), -- debug
			LuaFile,
			tostring( linedefined ),
			tostring( lastlinedefined ),
			foundstr
		)
	end
end

---------- NETWORK ----------
if CLIENT then
	local function net_ReceiveRemoteTimings()
		local TopCount = net.ReadUInt( 32 )
		local NumFrames = net.ReadUInt( 32 )
		MsgC( ServerColor, string.format( IntroMessage, TopCount, NumFrames ) )
		for k=1,TopCount do
			local identifier = net.ReadString()
			local Impact = net.ReadFloat()
			local count = net.ReadUInt( 32 )
			local meantime = net.ReadFloat()
			local maxtime = net.ReadFloat()
			local LuaFile = net.ReadString()
			local linedefined = net.ReadUInt( 32 )
			local lastlinedefined = net.ReadUInt( 32 )
			local foundstr = net.ReadString()
			MsgC( ServerColor, FormatTimings( identifier, Impact, count, meantime, maxtime, LuaFile, linedefined, lastlinedefined, foundstr ) )
		end
	end
	net.Receive( "find_laggy_hooks", function()
		local Type = net.ReadUInt( 8 )
		if Type == 0 then
			net_ReceiveRemoteTimings()
		end
	end )
end

---------- STORE HOOK EXECUTION TIME ----------
addon_hooks_lag_finder.ReportedTimings = addon_hooks_lag_finder.ReportedTimings or {}
function addon_hooks_lag_finder.ReportHookTiming( identifier, HookFunction, start, finish )
	local Report = addon_hooks_lag_finder.ReportedTimings[identifier]
	if !Report then
		Report = {
			identifier = identifier,
			HookFunction = HookFunction,
			count = 0,
			time = 0.,
			maxtime = 0.,
		}
		addon_hooks_lag_finder.ReportedTimings[identifier] = Report
	end
	local RunTime = finish-start
	Report.count = Report.count+1
	Report.time = Report.time+RunTime
	Report.maxtime = math.max( RunTime, Report.maxtime )
end

---------- REPORT STATISTICS ----------
local find_laggy_hooks -- function defined below
local ReportStatistics
do
	local function SortReportedTimings( a, b )
		return a.Impact > b.Impact
	end
	function ReportStatistics()
		local NumFrames = addon_hooks_lag_finder.NumFrames
		local NumFrames1 = NumFrames-1
		local PeriodEnd = SysTime() -- true value
		local PeriodDuration = PeriodEnd-addon_hooks_lag_finder.PeriodStart
		-- Copy the ReportedTimings, with integer keys:
		local ReportedTimings = {}
		for _,Report in pairs( addon_hooks_lag_finder.ReportedTimings ) do
			-- Good method but the maxtime often gets crazy values:
			-- Report.Impact = (
				-- ( Report.maxtime*math.max( NumFrames, Report.count ) ) -- pessimistic: consider as always max time
				-- +Report.time -- optimistic: consider as always mean time
			-- )/( 2*PeriodDuration )
			-- Average method:
			if Report.count>=NumFrames1 then -- considering only mean execution time
				Report.Impact = Report.time/PeriodDuration
			else -- same, multiplied by NumFrames/Report.count
				Report.Impact = ( Report.time*NumFrames )/( PeriodDuration*Report.count )
			end
			table.insert( ReportedTimings, Report )
		end
		-- Sort the copied ReportedTimings:
		table.sort( ReportedTimings, SortReportedTimings )
		local TopCount=0 -- number of displayed values
		if addon_hooks_lag_finder.TopCountOrRatioThreshold < 1 then -- use RatioThreshold
			local RatioThreshold = addon_hooks_lag_finder.TopCountOrRatioThreshold
			-- Only keep impacts higher than the RatioThreshold:
			for k=#ReportedTimings,1,-1 do
				if ReportedTimings[k].Impact>=RatioThreshold then
					TopCount=k
					break
				end
			end
		else -- use TopCount
			TopCount=math.min( #ReportedTimings, addon_hooks_lag_finder.TopCountOrRatioThreshold )
		end
		-- Clear the ReportedTimings for next capture period:
		addon_hooks_lag_finder.ReportedTimings = {}
		addon_hooks_lag_finder.RunningFunctions = {} -- safety precaution
		addon_hooks_lag_finder.PeriodStart = PeriodEnd
		addon_hooks_lag_finder.PeriodEnd = PeriodEnd+addon_hooks_lag_finder.ReportInterval
		addon_hooks_lag_finder.NumFrames = 0
		-- Process info:
		for k=1,TopCount do
			local Report = ReportedTimings[k]
			Report.meantime = Report.time/NumFrames
			local info = debug.getinfo( Report.HookFunction, 'S' )
			Report.info = info
			local LuaFile = tostring( info.short_src )
			Report.LuaFile = LuaFile
			local foundstr
			if addon_hooks_conflict_finder and addon_hooks_conflict_finder.LocateLuaFile then
				local locations = addon_hooks_conflict_finder.LocateLuaFile( LuaFile )
				if !locations then
					foundstr = "not found in Workshop addons"
				elseif #locations == 1 then
					foundstr = "found in Workshop addon « "..locations[1].." »"
				else
					foundstr = "found in Workshop addons « "..string.Implode( " », « ", locations ).." »"
				end
			else
				foundstr = "Addon hooks Conflict Finder not available"
			end
			Report.foundstr = foundstr
		end
		if CLIENT or !SendToSuperAdmins then
			MsgC( ResultColor, string.format( IntroMessage, TopCount, NumFrames ) )
			for k=1,TopCount do
				local Report = ReportedTimings[k]
				local info = Report.info
				MsgC( ResultColor, FormatTimings( Report.identifier, Report.Impact, Report.count, Report.meantime, Report.maxtime, Report.LuaFile, info.linedefined, info.lastlinedefined, Report.foundstr ) )
			end
		else
			local superadmins = {}
			for _,ply in player.Iterator() do
				if ply:IsSuperAdmin() then
					superadmins[#superadmins+1] = ply
				end
			end
			if #superadmins > 0 then
				net.Start( "find_laggy_hooks" )
					net.WriteUInt( 0, 8 )
					net.WriteUInt( TopCount, 32 )
					net.WriteUInt( NumFrames, 32 )
					for k=1,TopCount do
						local Report = ReportedTimings[k]
						local info = Report.info
						net.WriteString( Report.identifier )
						net.WriteFloat( Report.Impact )
						net.WriteUInt( Report.count, 32 )
						net.WriteFloat( Report.meantime )
						net.WriteFloat( Report.maxtime )
						net.WriteString( Report.LuaFile )
						net.WriteUInt( info.linedefined or 0, 32 )
						net.WriteUInt( info.lastlinedefined or 0, 32 )
						net.WriteString( Report.foundstr )
					end
				net.Send( superadmins )
			else
				find_laggy_hooks( nil, concommand_name, { 0 }, concommand_name..' "0"' ) -- Stop sending to superadmins if none connected.
			end
		end
		-- Set the period start & end again (accurate time ignoring find_laggy_hooks' process):
		addon_hooks_lag_finder.PeriodStart = SysTime()
		addon_hooks_lag_finder.PeriodEnd = addon_hooks_lag_finder.PeriodStart+addon_hooks_lag_finder.ReportInterval -- expected value
	end
end
hook.Add( "Think", "find_laggy_hooks", function()
	if addon_hooks_lag_finder.RunningTest then
		addon_hooks_lag_finder.NumFrames = addon_hooks_lag_finder.NumFrames+1
		if SysTime()>=addon_hooks_lag_finder.PeriodEnd then
			ReportStatistics()
		end
	end
end )

---------- START TESTS ----------
local helpstr = concommand_name.." [ReportInterval=30 or 0] [TopCount=16 or RatioThreshold]\n   Displays laggy hooks on every ReportInterval seconds.\n   The optional second argument can be a top TopCount of laggiest hooks or a threshold ratio of (execution_time/frame_time).\n   To stop the test, type 0 as the first argument.\n"
local CancelTests
if addon_hooks_lag_finder.CancelTests then
	CancelTests = addon_hooks_lag_finder.CancelTests
else
	CancelTests = {
		-- hook={},-- contains event names, hook names, functions
		-- net={},-- contains message ids, functions
		-- usermessage={},-- contains message ids, functions
		-- ENT={},-- contains classes, event names, functions
		-- SWEP={},-- contains classes, event names, functions
		-- GM={},-- contains gamemodes, event names, functions
	}
	addon_hooks_lag_finder.CancelTests = CancelTests
end
local function GetModifiedHookFunction( identifier, HookFunction, ReportedFunction )
	-- Do not make re-used local variables: danger in case of recursive calls.
	local function new_HookFunction( ... )
		if !addon_hooks_lag_finder.RunningFunctions[HookFunction] then
			addon_hooks_lag_finder.RunningFunctions[HookFunction]=true
			local start,ret,finish
			start=SysTime()
			ret={ pcall( HookFunction, ... ) } -- protected to prevent malfunction
			finish=SysTime()
			addon_hooks_lag_finder.RunningFunctions[HookFunction]=false
			addon_hooks_lag_finder.ReportHookTiming( identifier, ReportedFunction or HookFunction, start, finish )
			if ret[1] then -- ok
				table.remove( ret, 1 ) -- remove the returned status
			else -- error
				error( ret[2] ) -- throw the returned error when safe
			end
			return unpack( ret )
		else -- ignore recursive calls
			return HookFunction( ... )
		end
	end
	return new_HookFunction
end
function addon_hooks_lag_finder.AddModifiedHook( EventName, HookName, HookFunction, ... )
	local new_HookFunction
	if isfunction( HookFunction ) then
		if HookName!="find_laggy_hooks" then
			new_HookFunction = GetModifiedHookFunction(
				'Event "'..tostring( EventName )..'", hook "'..tostring( HookName )..'"',
				HookFunction
			)
			addon_hooks_lag_finder.CancelTests.hook[EventName] = addon_hooks_lag_finder.CancelTests.hook[EventName] or {}
			addon_hooks_lag_finder.CancelTests.hook[EventName][HookName] = HookFunction
		else
			new_HookFunction = HookFunction
		end
	else
		new_HookFunction = HookFunction
	end
	-- hook.Remove( EventName, HookName ) -- useless
	return addon_hooks_lag_finder.hook_Add( EventName, HookName, new_HookFunction, ... )
end
function addon_hooks_lag_finder.AddModifiedNet( EventName, HookFunction, ... )
	local new_HookFunction
	local lower_EventName = tostring( EventName ):lower()
	if isfunction( HookFunction ) then
		if EventName!="find_laggy_hooks" then
			new_HookFunction = GetModifiedHookFunction(
				'Net receiver "'..tostring( EventName )..'"',
				HookFunction
			)
			addon_hooks_lag_finder.CancelTests.net[lower_EventName] = HookFunction
		else
			new_HookFunction = HookFunction
		end
	else
		new_HookFunction = HookFunction
	end
	return addon_hooks_lag_finder.net_Receive( lower_EventName, new_HookFunction, ... )
end
function addon_hooks_lag_finder.AddModifiedUsermessage( EventName, HookFunction, ... )
	local new_HookFunction
	if isfunction( HookFunction ) then
		if EventName!="find_laggy_hooks" then
			new_HookFunction = GetModifiedHookFunction(
				'Usermessage receiver "'..tostring( EventName )..'"',
				HookFunction
			)
			addon_hooks_lag_finder.CancelTests.usermessage[EventName] = {
				Function = HookFunction,
				PreArgs = {...},
			}
		else
			new_HookFunction = HookFunction
		end
	else
		new_HookFunction = HookFunction
	end
	return addon_hooks_lag_finder.usermessage_Hook( EventName, new_HookFunction, ... )
end
function addon_hooks_lag_finder.AdjustModifiedTimer( EventName, delay, repetitions, HookFunction, ... )
	local new_HookFunction
	if isfunction( HookFunction ) then
		local new_HookFunction2 = GetModifiedHookFunction(
			'Timer "'..tostring( EventName )..'"',
			HookFunction
		)
		new_HookFunction = function( ... )
			if addon_hooks_lag_finder.RunningTest then
				return new_HookFunction2( ... )
			else
				return HookFunction( ... )
			end
		end
	else
		new_HookFunction = HookFunction
	end
	return addon_hooks_lag_finder.timer_Adjust( EventName, delay, repetitions, new_HookFunction, ... )
end
function addon_hooks_lag_finder.AddModifiedTimer( EventName, delay, repetitions, HookFunction, ... )
	local new_HookFunction
	if isfunction( HookFunction ) then
		local new_HookFunction2 = GetModifiedHookFunction(
			'Timer "'..tostring( EventName )..'"',
			HookFunction
		)
		new_HookFunction = function( ... )
			if addon_hooks_lag_finder.RunningTest then
				return new_HookFunction2( ... )
			else
				return HookFunction( ... )
			end
		end
	else
		new_HookFunction = HookFunction
	end
	return addon_hooks_lag_finder.timer_Create( EventName, delay, repetitions, new_HookFunction, ... )
end
function addon_hooks_lag_finder.AdjustModifiedTimerSimple( delay, HookFunction, ... )
	local new_HookFunction
	if isfunction( HookFunction ) then
		local new_HookFunction2 = GetModifiedHookFunction(
			'Timer timer.Simple( '..tostring( delay )..', '..tostring( HookFunction )..' )',
			HookFunction
		)
		new_HookFunction = function( ... )
			if addon_hooks_lag_finder.RunningTest then
				return new_HookFunction2( ... )
			else
				return HookFunction( ... )
			end
		end
	else
		new_HookFunction = HookFunction
	end
	return addon_hooks_lag_finder.timer_Simple( delay, new_HookFunction, ... )
end
-- Modify timer.Adjust():
if !addon_hooks_lag_finder.timer_Adjust then
	addon_hooks_lag_finder.timer_Adjust = timer.Adjust
	timer.Adjust = function( EventName, delay, repetitions, HookFunction, ... )
		return addon_hooks_lag_finder.AdjustModifiedTimer( EventName, delay, repetitions, HookFunction, ... )
	end
end
-- Modify timer.Create():
if !addon_hooks_lag_finder.timer_Create then
	addon_hooks_lag_finder.timer_Create = timer.Create
	timer.Create = function( EventName, delay, repetitions, HookFunction, ... )
		return addon_hooks_lag_finder.AddModifiedTimer( EventName, delay, repetitions, HookFunction, ... )
	end
end
-- Modify timer.Simple():
if !addon_hooks_lag_finder.timer_Simple then
	addon_hooks_lag_finder.timer_Simple = timer.Simple
	timer.Simple = function( delay, HookFunction, ... )
		return addon_hooks_lag_finder.AdjustModifiedTimerSimple( delay, HookFunction, ... )
	end
end
-- Run or stop the test:
function find_laggy_hooks( ply, cmd, args, fullstring )
	if CLIENT or !IsValid( ply ) or ply:IsSuperAdmin() then
		local ReportInterval = tonumber( args[1] ) or 30
		if !ReportInterval then
			NiceMsgN( ply, " - "..helpstr )
			return
		end
		if addon_hooks_conflict_finder and addon_hooks_conflict_finder.FillAddonsList then
			if !addon_hooks_conflict_finder.AddonsList then
				addon_hooks_conflict_finder.FillAddonsList()
			end
		end
		local IsRunning = addon_hooks_lag_finder.RunningTest
		local HookTable = hook.GetTable() -- This may be a copy!
		local NetTable = net.Receivers
		local UsermessageTable = usermessage and usermessage.GetTable() or {}
		local ENTTable = scripted_ents.GetList()
		local SWEPTable = weapons.GetList()
		if ReportInterval>0 then -- begin operation
			if !IsRunning then
				if IsValid( ply ) then
					SendToSuperAdmins = true
				else
					SendToSuperAdmins = false
				end
				-- Modify hook.Add():
				if !addon_hooks_lag_finder.hook_Add then
					addon_hooks_lag_finder.hook_Add = hook.Add
					hook.Add = function( EventName, HookName, HookFunction, ... )
						if addon_hooks_lag_finder.RunningTest and HookName!="find_laggy_hooks" then
							return addon_hooks_lag_finder.AddModifiedHook( EventName, HookName, HookFunction, ... )
						else
							return addon_hooks_lag_finder.hook_Add( EventName, HookName, HookFunction, ... )
						end
					end
				end
				-- Modify net.Receive():
				if !addon_hooks_lag_finder.net_Receive then
					addon_hooks_lag_finder.net_Receive = net.Receive
					net.Receive = function( EventName, HookFunction, ... )
						if addon_hooks_lag_finder.RunningTest and EventName!="find_laggy_hooks" then
							return addon_hooks_lag_finder.AddModifiedNet( EventName, HookFunction, ... )
						else
							return addon_hooks_lag_finder.net_Receive( EventName, HookFunction, ... )
						end
					end
				end
				-- Modify usermessage.Hook():
				if !addon_hooks_lag_finder.usermessage_Hook then
					if usermessage then
						addon_hooks_lag_finder.usermessage_Hook = usermessage.Hook
						usermessage.Hook = function( EventName, HookFunction, ... )
							if addon_hooks_lag_finder.RunningTest and EventName!="find_laggy_hooks" then
								return addon_hooks_lag_finder.AddModifiedUsermessage( EventName, HookFunction, ... )
							else
								return addon_hooks_lag_finder.usermessage_Hook( EventName, HookFunction, ... )
							end
						end
					end
				end
				-- Mark test as running:
				addon_hooks_lag_finder.ReportedTimings = {}
				addon_hooks_lag_finder.RunningFunctions = {}
				addon_hooks_lag_finder.PeriodStart = SysTime()
				addon_hooks_lag_finder.PeriodEnd = addon_hooks_lag_finder.PeriodStart+ReportInterval
				addon_hooks_lag_finder.NumFrames = 0
				addon_hooks_lag_finder.TopCountOrRatioThreshold = tonumber( args[2] ) or 16
				addon_hooks_lag_finder.ReportInterval = ReportInterval
				addon_hooks_lag_finder.RunningTest = true
				-- Add hooks:
				CancelTests.hook={}
				do
					local TempHookTable = {} -- Copy: ensure that pairs() is safe while modifying table.
					for EventName,EventFunctions in pairs( HookTable ) do
						TempHookTable[EventName]={}
						for HookName,HookFunction in pairs( EventFunctions ) do
							TempHookTable[EventName][HookName]=HookFunction
						end
					end
					for EventName,EventFunctions in pairs( TempHookTable ) do
						for HookName,HookFunction in pairs( EventFunctions ) do
							pcall( addon_hooks_lag_finder.AddModifiedHook, EventName, HookName, HookFunction )
						end
					end
				end
				-- Add net receivers:
				CancelTests.net={}
				do
					local TempNetTable = {} -- Copy: ensure that pairs() is safe while modifying table.
					for EventName,HookFunction in pairs( NetTable ) do
						TempNetTable[EventName]=HookFunction
					end
					for EventName,HookFunction in pairs( TempNetTable ) do
						pcall( addon_hooks_lag_finder.AddModifiedNet, EventName, HookFunction )
					end
				end
				-- Add usermessage receivers:
				CancelTests.usermessage={}
				do
					local TempUsermessageTable = {} -- Copy: ensure that pairs() is safe while modifying table.
					for EventName,HookData in pairs( UsermessageTable ) do
						TempUsermessageTable[EventName]=HookData
					end
					for EventName,HookData in pairs( TempUsermessageTable ) do
						pcall( addon_hooks_lag_finder.AddModifiedUsermessage, EventName, HookData.Function, unpack( HookData.PreArgs ) )
					end
				end
				-- Add ENT functions:
				CancelTests.ENT={}
				do
					local TempENTTable = {} -- Copy: ensure that pairs() is safe while modifying table.
					for class,ClassTable in pairs( ENTTable ) do
						TempENTTable[class]={}
						for EventName,HookFunction in pairs( ClassTable.t ) do
							if isfunction( HookFunction ) then
								TempENTTable[class][EventName]=HookFunction
							end
						end
					end
					for class,ClassFunctions in pairs( TempENTTable ) do
						CancelTests.ENT[class] = {}
						local ENT = scripted_ents.GetStored( class ).t
						for EventName,HookFunction in pairs( ClassFunctions ) do
							local new_HookFunction = GetModifiedHookFunction(
								'Entity "'..tostring( class )..'", function ENT.'..tostring( EventName ),
								HookFunction
							)
							CancelTests.ENT[class][EventName] = HookFunction
							ENT[EventName] = new_HookFunction
						end
						pcall( scripted_ents.Register, ENT, class ) -- should not be required
					end
				end
				-- Add SWEP functions:
				CancelTests.SWEP={}
				do
					local TempSWEPTable = {} -- Copy: ensure that pairs() is safe while modifying table.
					for _,SWEP in pairs( SWEPTable ) do
						local class = SWEP.ClassName
						if class then
							TempSWEPTable[class]={}
							for EventName,HookFunction in pairs( SWEP ) do
								if isfunction( HookFunction ) then
									TempSWEPTable[class][EventName]=HookFunction
								end
							end
						end
					end
					for class,ClassFunctions in pairs( TempSWEPTable ) do
						CancelTests.SWEP[class] = {}
						local SWEP = weapons.GetStored( class )
						for EventName,HookFunction in pairs( ClassFunctions ) do
							local new_HookFunction = GetModifiedHookFunction(
								'Weapon "'..tostring( class )..'", function SWEP.'..tostring( EventName ),
								HookFunction
							)
							CancelTests.SWEP[class][EventName] = HookFunction
							SWEP[EventName] = new_HookFunction
						end
						pcall( weapons.Register, SWEP, class ) -- should not be required
					end
				end
				-- Add GM functions:
				CancelTests.GM={}
				do
					local Validated={} -- Prevent endless loops.
					local TempGamemodeTable = {} -- Copy: ensure that pairs() is safe while modifying table and prevent risk of multiply modified functions.
					local GM = GAMEMODE
					while GM and !Validated[GM] do
						TempGamemodeTable[GM]={}
						for EventName,HookFunction in pairs( GM ) do
							if isfunction( HookFunction ) then
								TempGamemodeTable[GM][EventName]=HookFunction
							end
						end
						Validated[GM]=true
						GM = GM.BaseClass
					end
					for GM,GM_functions in pairs( TempGamemodeTable ) do
						CancelTests.GM[GM] = {}
						for EventName,HookFunction in pairs( GM_functions ) do
							local new_HookFunction
							if CLIENT and EventName=="RenderScene" then
								addon_hooks_lag_finder.view = {
									dopostprocess = true,
									drawhud = true,
									drawmonitors = true,
									drawviewmodel = true,
									bloomtone = true,
								}
								local function RenderScene( ... )
									local result = HookFunction( ... )
									if result then
										return result
									else
										render.RenderView( addon_hooks_lag_finder.view )
										return true
									end
								end
								new_HookFunction = GetModifiedHookFunction(
									'Default scene rendering / GM.RenderScene',
									RenderScene,
									HookFunction
								)
							else
								new_HookFunction = GetModifiedHookFunction(
									'Function GM.'..tostring( EventName ),
									HookFunction
								)
							end
							CancelTests.GM[GM][EventName] = HookFunction -- to be restored first
							GM[EventName] = new_HookFunction
						end
					end
				end
				-- Re-adjust to accurate time reference:
				addon_hooks_lag_finder.PeriodStart = SysTime()
				addon_hooks_lag_finder.PeriodEnd = addon_hooks_lag_finder.PeriodStart+ReportInterval
				NiceMsgN( ply, 'Lag test started, next output in '..ReportInterval..' seconds!' )
			else
				NiceMsgN( ply, 'Lag test is already running!' )
			end
		else -- finish operation
			-- We only browse cancel tables because they are copies!
			if IsRunning then
				-- Restore GM functions:
				if CancelTests.GM then
					local Validated={} -- Prevent endless loops.
					local GM = GAMEMODE
					while GM and !Validated[GM] do
						if CancelTests.GM[GM] then
							for EventName,HookFunction in pairs( CancelTests.GM[GM] ) do
								if isfunction( GM[EventName] ) then
									GM[EventName]=HookFunction
								end
							end
						end
						CancelTests.GM[GM]=nil
						Validated[GM]=true
						GM = GM.BaseClass
					end
					CancelTests.GM=nil
				end
				-- Restore ENT functions:
				if CancelTests.ENT then
					for class,ClassFunctions in pairs( CancelTests.ENT ) do
						local ENT = scripted_ents.GetStored( class ).t
						if ENT then
							for EventName,HookFunction in pairs( ClassFunctions ) do
								if isfunction( ENT[EventName] ) then
									ENT[EventName]=HookFunction
								end
							end
							pcall( scripted_ents.Register, ENT, class ) -- should not be required
						end
					end
					CancelTests.ENT=nil
				end
				-- Restore SWEP functions:
				if CancelTests.SWEP then
					for class,ClassFunctions in pairs( CancelTests.SWEP ) do
						local SWEP = weapons.GetStored( class )
						if SWEP then
							for EventName,HookFunction in pairs( ClassFunctions ) do
								if isfunction( SWEP[EventName] ) then
									SWEP[EventName]=HookFunction
								end
							end
							pcall( scripted_ents.Register, SWEP, class ) -- should not be required
						end
					end
					CancelTests.SWEP=nil
				end
				-- Restore usermessage receivers:
				if CancelTests.usermessage then
					for EventName,HookData in pairs( CancelTests.usermessage ) do
						if istable( UsermessageTable[EventName] ) then
							addon_hooks_lag_finder.usermessage_Hook( EventName, HookData.Function, unpack( HookData.PreArgs ) )
						end
					end
					CancelTests.usermessage=nil
				end
				-- Restore net receivers:
				if CancelTests.net then
					for EventName,HookFunction in pairs( CancelTests.net ) do
						if isfunction( NetTable[EventName] ) then
							addon_hooks_lag_finder.net_Receive( EventName, HookFunction )
						end
					end
					CancelTests.net=nil
				end
				-- Restore hooks:
				if CancelTests.hook then
					for EventName,EventFunctions in pairs( CancelTests.hook ) do
						if istable( HookTable[EventName] ) then
							for HookName,HookFunction in pairs( EventFunctions ) do
								if isfunction( HookTable[EventName][HookName] ) then
									addon_hooks_lag_finder.hook_Add( EventName, HookName, HookFunction )
								end
							end
						end
					end
					CancelTests.hook=nil
				end
				-- Mark test as stopped:
				addon_hooks_lag_finder.RunningTest = false
				-- Report pending statistics:
				ReportStatistics()
				addon_hooks_lag_finder.ReportedTimings = {}
				addon_hooks_lag_finder.RunningFunctions = {}
				-- Confirm:
				NiceMsgN( ply, 'Lag test is now stopped!' )
			else
				NiceMsgN( ply, 'Lag test is not running!' )
			end
		end
	end
end
concommand.Add( concommand_name, find_laggy_hooks, nil, helpstr, 0 )

--PATH addons/fpp/lua/fprofiler/gather.lua:
local timeMeasurementFunc = SysTime

-- Helper function, created by some ancient Lua dev
-- Retrieves the local variables and their values of a function
local function getupvalues(f)
    local t, i, k, v = {}, 1, debug.getupvalue(f, 1)
    while k do
        t[k] = v
        i = i + 1
        k,v = debug.getupvalue(f, i)
    end
    return t
end

-- Helper function
-- Get all local variables
local NIL = {}
setmetatable(NIL, {__tostring = function() return "nil" end})
local function getlocals(level)
    local i = 1
    local name, value
    local vars = {}

    while true do
        name, value = debug.getlocal(level, i)

        if not name then break end

        value = value == nil and NIL or value
        vars[name] = value
        i = i + 1
    end

    return vars
end

--[[-------------------------------------------------------------------------
Call counts:

registers how often function have been called
---------------------------------------------------------------------------]]
local callcounts = {}


-- Gets the call counts
FProfiler.Internal.getCallCounts = function() return callcounts end


-- Resets the call counts
function FProfiler.Internal.resetCallCounts()
    callcounts = {}
end

--[[-------------------------------------------------------------------------
Inclusive function times

Keeps track of how long functions take in total
i.e. average time between the start and return of a function * times called

This includes the time that any function called by this function takes
(that's what the "inclusive" refers to).
Note: recursive calls are not counted double
---------------------------------------------------------------------------]]

local inclusiveTimes = {}

-- Gets the inclusive times
FProfiler.Internal.getInclusiveTimes = function() return inclusiveTimes end

-- Resets the inclusive times
function FProfiler.Internal.resetInclusiveTimes()
    inclusiveTimes = {}
end

--[[-------------------------------------------------------------------------
Top n most expensive single function calls
Keeps track of the functions that took the longest time to run
Note: functions can appear in this list at most once
---------------------------------------------------------------------------]]
local mostExpensiveSingleCalls = {}

-- Gets most expensive single calls
FProfiler.Internal.getMostExpensiveSingleCalls = function() return mostExpensiveSingleCalls end

-- Dictionary to make sure the same function doesn't appear multiple times
-- in the top n
local mostExpensiveSingleDict = {}

function FProfiler.Internal.resetMostExpensiveSingleCalls()
    for i = 1, 50 do mostExpensiveSingleCalls[i] = {runtime = 0} end
    mostExpensiveSingleDict = {}
end

-- Initial empty list
FProfiler.Internal.resetMostExpensiveSingleCalls()

--[[-------------------------------------------------------------------------
Function information
Using debug.getinfo on a function object won't give you any function names
that's because functions can have multiple names.
Luckily, when the functions are called, debug.getinfo(level) gives the
function name and scope
---------------------------------------------------------------------------]]
local functionNames = {}

FProfiler.Internal.getFunctionNames = function() return functionNames end

--[[-------------------------------------------------------------------------
Recursion depth

Used internally to make sure recursive functions' times aren't counted
multiple times
---------------------------------------------------------------------------]]
local recursiveCount = {}

--[[-------------------------------------------------------------------------
Function start times

Used internally to keep track of when functions were called
---------------------------------------------------------------------------]]
local startTimes = {}

--[[-------------------------------------------------------------------------
Lua code event handlers
---------------------------------------------------------------------------]]

-- The recursion depth of the function that is in focus.
-- Only applies when profiling a specific function (i.e. laying focus upon)
local focusDepth = 0

-- Called when a function in the code is called
local function registerFunctionCall(funcInfo)
    local func = funcInfo.func

    -- Update call counts
    callcounts[func] = (callcounts[func] or 0) + 1

    -- Increase recursion depth for this function
    recursiveCount[func] = (recursiveCount[func] or 0) + 1

    -- Store function info
    local funcname = funcInfo.name or ""
    functionNames[func] = functionNames[func] or {}
    functionNames[func][funcname] = functionNames[func][funcname] or
        { namewhat = funcInfo.namewhat,
          nparams = funcInfo.nparams
        }

    local time = timeMeasurementFunc()

    -- Update inclusive function times,
    -- only when we're on the first recursive call
    if recursiveCount[func] == 1 then
        startTimes[func] = time
    end
end


-- Called when a function returns
local function registerReturn(funcInfo)
    local time = timeMeasurementFunc()
    local func = funcInfo.func
    local runtime = time - startTimes[func]

    -- Update inclusive function time
    -- Only update on the topmost call, to prevent recursive
    -- calls for being counted multiple times.
    if recursiveCount[func] == 1 then
        inclusiveTimes[func] = (inclusiveTimes[func] or 0) + runtime
    end

    -- Maintain recursion depth
    recursiveCount[func] = recursiveCount[func] - 1

    -- Update top n list
    -- This path will be taken most often: the function isn't special
    -- Also only counts the top recursion
    if runtime <= mostExpensiveSingleCalls[50].runtime or recursiveCount[func] > 1 then return end

    -- If the function already appears in the top 10, replace it or discard the result
    if mostExpensiveSingleDict[func] then
        local i = mostExpensiveSingleDict[func]

        -- Discard this info
        if runtime < mostExpensiveSingleCalls[i].runtime then return end

        -- Update the entry
        mostExpensiveSingleCalls[i].runtime = runtime
        mostExpensiveSingleCalls[i].upvalues = getupvalues(func)
        mostExpensiveSingleCalls[i].locals = getlocals(5)
        mostExpensiveSingleCalls[i].info = funcInfo
        mostExpensiveSingleCalls[i].func = func

        -- Move the updated entry up the top 10 list if applicable
        while i > 1 and runtime > mostExpensiveSingleCalls[i - 1].runtime do
            mostExpensiveSingleDict[mostExpensiveSingleCalls[i - 1].func] = i
            mostExpensiveSingleCalls[i - 1], mostExpensiveSingleCalls[i] = mostExpensiveSingleCalls[i], mostExpensiveSingleCalls[i - 1]
            i = i - 1
        end

        mostExpensiveSingleDict[func] = i

        return
    end

    -- Knowing that the function belongs in the top n, find its position
    local i = 50
    while i >= 1 and runtime > mostExpensiveSingleCalls[i].runtime do
        -- Update the dictionary
        -- All functions faster than the current one move down the list
        if not mostExpensiveSingleCalls[i].func then i = i - 1 continue end
        mostExpensiveSingleDict[mostExpensiveSingleCalls[i].func] = i + 1

        i = i - 1
    end

    -- Insert the expensive call in the top n
    mostExpensiveSingleDict[func] = i + 1
    table.insert(mostExpensiveSingleCalls, i + 1,
        {
            func = func,
            runtime = runtime,
            info = funcInfo,
            upvalues = getupvalues(func),
            locals = getlocals(5)
        })


    -- What was previously the 50th most expensive function
    -- is now kicked out of the top 10
    if mostExpensiveSingleCalls[51].func then
        mostExpensiveSingleDict[mostExpensiveSingleCalls[51].func] = nil
    end
    mostExpensiveSingleCalls[51] = nil
end


-- Called on any Lua event
local function onLuaEvent(event, focus)
    local info = debug.getinfo(3)
    local func = info.func

    if event == "call" or event == "tail call" then
        -- Only track the focussed function and the functions
        -- called by the focussed function
        if focus == func then focusDepth = focusDepth + 1 end
        if focus and focusDepth == 0 then return end

        registerFunctionCall(info)
    else
        -- Functions that return right after the call to FProfiler.Internal.start()
        -- are not to be counted
        if not recursiveCount[func] or recursiveCount[func] == 0 then return end

        if focus == func then focusDepth = focusDepth - 1 end
        if focus and focusDepth == 0 then return end

        registerReturn(info)
    end
end

--[[-------------------------------------------------------------------------
Profiling control
---------------------------------------------------------------------------]]

-- Start profiling
-- focus: only measure data of everything that happens within a certain function
function FProfiler.Internal.start(focus)
    -- Empty start times, so unfinished functions aren't
    -- registered as returns on a second profiling session
    -- local time = SysTime()
    -- for k,v in pairs(startTimes) do startTimes[k] = time end
    table.Empty(startTimes)
    table.Empty(recursiveCount)

    debug.sethook(function(event) onLuaEvent(event, focus) end, "cr")
end


-- Stop profiling
function FProfiler.Internal.stop()
    debug.sethook()
end

-- Reset all profiling data
function FProfiler.Internal.reset()
    FProfiler.Internal.resetCallCounts()
    FProfiler.Internal.resetInclusiveTimes()
    FProfiler.Internal.resetMostExpensiveSingleCalls()
end

--PATH addons/plib_v5/lua/plib/libraries/nw.lua:
--[[
local var = nw.Register 'MyVar' 	-- You MUST call this ALL shared
	var:Write(net.WriteUInt, 32) 	-- Write function
	var:Read(net.ReadUInt, 32) 		-- Read function
	var:SetPlayer() 				-- Registers the var for use on players
	var:SetLocalPlayer() 			-- Optionally set the var to only network to the player its set on, no need to call SetPlayer with this
	var:SetGlobal() 				-- Registers the var for use with nw.SetGlobal
	var:SetNoSync() 				-- Stops the var from syncing to new players, SetLocalPlayer does this for you.
	var:Filter(function(ent, value) -- Sets a var to only send to players you return in your callback
		return player.GetWhatever() -- return table players
	end)

nw.WaitForPlayer(player, callback) 	-- Calls your callback when the player is ready to recieve net messages

-- Set Functions
ENTITY:SetNetVar(var, value)
nw.SetGlobal(var, value)

-- Get functions
ENTITY:GetNetVar(var)
nw.GetGlobal(var)
]]


nw = nw or {
	Data = {
		[0] = {}
	},
	Vars = {},
	Mappings = {},
	Callbacks = {}
}

local vars 		= nw.Vars
local mappings 	= nw.Mappings
local data 		= nw.Data
local globals 	= data[0]
local callbacks = nw.Callbacks

local NETVAR 	= {}
NETVAR.__index 	= NETVAR

debug.getregistry().Netvar = NETVAR

local bitmap 	= {
	[3]		= 3,
	[7] 	= 4,
	[15] 	= 5,
	[31] 	= 6,
	[63] 	= 7,
	[127] 	= 8,
	[255] 	= 9,
	[511]	= 10
}

local bitcount 	= 2

local ENTITY 	= FindMetaTable 'Entity'

local pairs 	= pairs
local Entity 	= Entity

local net_WriteUInt = net.WriteUInt
local net_ReadUInt 	= net.ReadUInt
local net_Start 	= net.Start
local net_Send 		= (SERVER) and net.Send or net.SendToServer
local net_Broadcast = net.Broadcast
local player_GetAll = player.GetAll
local sorted_pairs 	= SortedPairsByMemberValue

function nw.Register(var) -- You must always call this on both the client and server. It will serioulsy break shit if you don't.
	local t = {
		Name = var,
		NetworkString = 'nw_' .. var,
		WriteFunc = net.WriteType,
		ReadFunc = net.ReadType,
		SendFunc = function(self, ent, value, recipients)
			if (recipients ~= nil) then
				net_Send(recipients)
			else
				net_Broadcast()
			end
		end,
	}
	setmetatable(t, NETVAR)
	vars[var] = t

	if (SERVER) then
		util.AddNetworkString(t.NetworkString)
	else
		net.Receive(t.NetworkString, function()
			local index, value = t:_Read()

			if (not data[index]) then
				data[index] = {}
			end

			local oldValue = data[index][var]
			data[index][var] = value

			t:_CallHook(index, value, oldValue)
		end)
	end

	return t:_Construct()
end

function NETVAR:Write(func, opt)
	self.WriteFunc = function(value)
		func(value, opt)
	end
	return self:_Construct()
end

function NETVAR:Read(func, opt)
	self.ReadFunc = function()
		return func(opt)
	end
	return self:_Construct()
end

function NETVAR:Filter(func)
	self.SendFunc = function(self, ent, value, recipients)
		net_Send(recipients or func(ent, value))
	end
	return self:_Construct()
end

function NETVAR:SetPlayer()
	self.PlayerVar = true
	return self:_Construct()
end

function NETVAR:SetLocalPlayer()
	self.LocalPlayerVar = true
	return self:_Construct()
end

function NETVAR:SetGlobal()
	self.GlobalVar = true
	return self:_Construct()
end

function NETVAR:SetNoSync()
	self.NoSync = true
	return self:_Construct()
end

function NETVAR:SetHook(name)
	self.Hook = name
	return self
end

function NETVAR:_Send(ent, value, recipients)
	net_Start(self.NetworkString)
		self:_Write(ent, value)
	self:SendFunc(ent, value, recipients)
end

function NETVAR:_CallHook(index, value, oldValue)
	if self.Hook then
		if (index ~= 0) then
			hook.Call(self.Hook, GAMEMODE, Entity(index), value, oldValue)
		else
			hook.Call(self.Hook, GAMEMODE, value, oldValue)
		end
	end
end

function NETVAR:_Construct()
	local WriteFunc = self.WriteFunc
	local ReadFunc 	= self.ReadFunc

	if self.PlayerVar then
		self._Write = function(self, ent, value)
			net_WriteUInt(ent:EntIndex(), 8)
			WriteFunc(value)
		end
		self._Read = function(self)
			return net_ReadUInt(8), ReadFunc()
		end
	elseif self.LocalPlayerVar then
		self._Write = function(self, ent, value)
			WriteFunc(value)
		end
		self._Read = function(self)
			return LocalPlayer():EntIndex(), ReadFunc()
		end
		self.SendFunc = function(self, ent, value, recipients)
			net_Send(ent)
		end
	elseif self.GlobalVar then
		self._Write = function(self, ent, value)
			WriteFunc(value)
		end
		self._Read = function(self)
			return 0, ReadFunc()
		end
	else
		self._Write = function(self, ent, value)
			net_WriteUInt(ent:EntIndex(), 13)
			WriteFunc(value)
		end
		self._Read = function(self)
			return net_ReadUInt(13), ReadFunc()
		end
	end

	nw.Mappings = {}
	mappings = nw.Mappings
	for k, v in sorted_pairs(vars, 'Name', false) do
		local c = #mappings + 1
		vars[k].ID = c
		mappings[c] = v
		if bitmap[c] then
			bitcount = bitmap[c]
		end
	end

	return self
end

function nw.GetGlobal(var)
	return globals[var]
end

function ENTITY:GetNetVar(var)
	local index = self:EntIndex()
	return data[index] and data[index][var]
end

if (SERVER) then
	util.AddNetworkString 'nw.PlayerSync'
	util.AddNetworkString 'nw.NilEntityVar'
	util.AddNetworkString 'nw.NilPlayerVar'
	util.AddNetworkString 'nw.EntityRemoved'
	util.AddNetworkString 'nw.PlayerRemoved'

	net.Receive('nw.PlayerSync', function(len, pl)
		if (pl.EntityCreated ~= true) then
			hook.Call('PlayerEntityCreated', GAMEMODE, pl)

			pl.EntityCreated = true

			for index, _vars in pairs(data) do
				for var, value in pairs(_vars) do
					local ent = Entity(index)
					if (not vars[var].LocalPlayerVar and not vars[var].NoSync) or (ent == pl) then
						vars[var]:_Send(ent, value, pl)
					end
				end
			end

			if (callbacks[pl] ~= nil) then
				for i = 1, #callbacks[pl] do
					callbacks[pl][i](pl)
				end
			end
			callbacks[pl] = nil
		end
	end)

	hook.Add('EntityRemoved', 'nw.EntityRemoved', function(ent)
		local index = ent:EntIndex()

		if (index ~= 0) and (data[index] ~= nil) then -- For some reason this kept getting called on Entity(0), not sure why...
			if ent:IsPlayer() then
				net_Start('nw.PlayerRemoved')
					net_WriteUInt(index, 8)
				net_Broadcast()
			else
				net_Start('nw.EntityRemoved')
					net_WriteUInt(index, 13)
				net_Broadcast()
			end

			data[index] = nil
		end
	end)

	function nw.WaitForPlayer(pl, cback)
		if (pl.EntityCreated == true) then
			cback(pl)
		else
			if (callbacks[pl] == nil) then
				callbacks[pl] = {}
			end
			callbacks[pl][#callbacks[pl] + 1] = cback
		end
	end

	function nw.SetGlobal(var, value)
		globals[var] = value
		if (value ~= nil) then
			vars[var]:_Send(0, value)
		else
			net_Start('nw.NilEntityVar')
				net_WriteUInt(0, 13)
				net_WriteUInt(vars[var].ID, bitcount)
			vars[var]:SendFunc(0, value)
		end
	end

	function ENTITY:SetNetVar(var, value)
		local index = self:EntIndex()

		if (not data[index]) then
			data[index] = {}
		end

		data[index][var] = value

		if (value ~= nil) then
			vars[var]:_Send(self, value)
		else
			if self:IsPlayer() then
				net_Start('nw.NilPlayerVar')
				net_WriteUInt(index, 8)
			else
				net_Start('nw.NilEntityVar')
				net_WriteUInt(index, 13)
			end
			net_WriteUInt(vars[var].ID, bitcount)
			vars[var]:SendFunc(self, value)
		end
	end
else
	hook.Add('InitPostEntity', 'nw.InitPostEntity', function()
		net_Start('nw.PlayerSync')
		net_Send()
	end)

	local function nwNilVar(index, id)
		if data[index] and mappings[id] then
			local oldValue = data[index][mappings[id].Name]
			data[index][mappings[id].Name] = nil
			mappings[id]:_CallHook(index, nil, oldValue)
		end
	end

	net.Receive('nw.NilEntityVar', function()
		nwNilVar(net_ReadUInt(13), net_ReadUInt(bitcount))
	end)

	net.Receive('nw.NilPlayerVar', function()
		nwNilVar(net_ReadUInt(8), net_ReadUInt(bitcount))
	end)

	net.Receive('nw.EntityRemoved', function()
		data[net_ReadUInt(13)] = nil
	end)

	net.Receive('nw.PlayerRemoved', function()
		data[net_ReadUInt(8)] = nil
	end)
end
--PATH addons/admin_reports/lua/freports/config.lua:
freports.config = {}

freports.config.command = "@"

freports.config.adm_stats_cmd = "adminlogs"

freports.config.reps_stats_cmd = "adminstats"

freports.config.reputation_cd = 300

freports.config.add_report_to_statistic_cd = 300

freports.config.maxp_rep_log = 64

freports.config.reputation_reward = 5000

hook.Add("InitPostEntity", "freports.config", function()
	freports.config.admin_job = TEAM_MODER
end)

timer.Simple( 1 , function() freports.config.admin_job = TEAM_MODER  end )

freports.config.WhoCanReceiveReports = {
	["superadmin"]    = true,
    ["NS-trainee"] = true,
    ["NS-mlmoder"] = true,
    ["NS-moder"] = true,
    ["NS-mladmin"] = true,
    ["NS-admin"] = true,
    ["NS-assistant"] = true,
    ["NS-helper"] = true,
    ["moder"] = true,
    ["padmin"] = true,
    ["sponsor"] = true,
    ["dsuperadmin"] = true,
    ["downer"] = true,
    ["overwatch"] = true,
    ["NS-zammanager"] = true,
    ["manager"] = true,
    ["uprav"] = true,
    ["helper"] = true
}

freports.config.BRanks = {
	user = {"Игрок", Color(117, 255, 51)},
	moder = {"Д-Модератор", Color(255, 189, 51)},
	padmin = {"Д-Админ", Color(255, 189, 51)},
	sponsor = {"Д-Спонсор", Color(255, 189, 51)},
	dsuperadmin = {"Д-Владелец", Color(255, 189, 51)},
	downer = {"Д-Создатель", Color(255, 189, 51)},
	["NS-trainee"] = {"NS-Стажер", Color(255, 87, 51)},
	["NS-mlmoder"] = {"NS-Мл.Модератор", Color(255, 87, 51)},
	["NS-moder"] = {"NS-Модератор", Color(255, 87, 51)},
	["NS-mladmin"] = {"NS-Мл.Админ", Color(255, 87, 51)},
	["NS-admin"] = {"NS-Админ", Color(255, 87, 51)},
	["NS-helper"] = {"NS-Хелпер", Color(255, 87, 51)},
	["NS-assistant"] = {"NS-Ассистент", Color(255, 87, 51)},
	overwatch = {"NS-Куратор", Color(255, 51, 204)},
	["NS-zammanager"] = {"NS-Зам.Рук.Состава", Color(51, 255, 204)},
	manager = {"NS-Рук.Состав", Color(255, 239, 51)},
	uprav = {"Управляющий", Color(51, 155, 255)},
	superadmin = {"Отец", Color(199, 0, 57)}
}
--PATH addons/gprofiler/lua/gprofiler/sh_config.lua:
-- 1.2.1 | b7bd8a44-2f52-4e9c-8103-f70e186d3b7f | 7309eb3b8b4f5c0a14d53672e97203e6 | 76561197961078997

GProfiler.Version = "1.2.1"
GProfiler.Config.VersionCheck = true -- Should we check for updates on gmodstore?

-- Available languages: english, french, german, dutch, russian
GProfiler.Config.Language = "english"

-- Enable/Disable Log Types
GProfiler.Config.LOG_DEBUG = true
GProfiler.Config.LOG_INFO = true
GProfiler.Config.LOG_WARNING = true
GProfiler.Config.LOG_ERROR = true
GProfiler.Config.LOG_LOAD = false

GProfiler.Config.AllowedSteamIDs = { -- SteamIDs that can access GProfiler
	["76561197961078997"] = true
}

if CLIENT then
	GProfiler.MenuColors = {
		White = Color(255, 255, 255),
		Blue = Color(91, 118, 255),

		-- Menu
		Background = Color(8, 27, 48, 220),
		OpaqueBlack = Color(0, 0, 0, 200),
		TopBarSeparator = Color(91, 118, 255, 10),
		HeaderSeparator = Color(91, 118, 255, 50),
		RealmSelectorBackground = Color(38, 57, 78),
		RealmSelectorOutline = Color(88, 107, 138),
		ActiveProfile = Color(10, 155, 10),

		-- Lists
		DListBackground = Color(18, 37, 58),
		DListColumnBackground = Color(68, 87, 108),
		DListColumnOutline = Color(88, 107, 138),
		DListRowBackground = Color(48, 67, 88),
		DListRowHover = Color(68, 87, 108),
		DListRowTextColor = Color(235, 235, 235),
		DListRowSelected = Color(91, 118, 255, 50),

		-- Scrollbars
		ScrollBar = Color(38, 57, 78),
		ScrollBarGrip = Color(68, 87, 108),
		ScrollBarGripOutline = Color(88, 107, 138),

		-- Buttons
		ButtonOutline = Color(88, 107, 138),
		ButtonBackground = Color(38, 57, 78),
		ButtonHover = Color(58, 77, 98),
	}

	GProfiler.Config.MenuCommands = {
		Chat = '!gprofiler', -- False to disable
		Console = 'gprofiler', -- False to disable
		Closekey = KEY_F4 -- False to disable
	}
else
	local URL = "https://fastdl.zarpgaming.com/callum/gprofiler/version.txt"
	if GProfiler.Config.VersionCheck then
		hook.Add("PlayerInitialSpawn", "GProfiler_VersionCheck", function()
			http.Fetch(URL, function(body, _, __, code)
				if code == 200 and body ~= GProfiler.Version then
					GProfiler.Log(string.format("You are running an outdated version of GProfiler! (Current: %s, Latest: %s)", GProfiler.Version, body), 3)
				end
			end)
			hook.Remove("PlayerInitialSpawn", "GProfiler_VersionCheck")
		end)
	end
end

--PATH addons/gprofiler/lua/gprofiler/sh_utils.lua:
if CLIENT then
	GProfiler.Menu = GProfiler.Menu or {}

	local MenuColors = GProfiler.MenuColors
	local BorderColor = MenuColors.DListColumnOutline
	local TabPadding = 10

	local draw = draw
	local table = table
	local ipairs = ipairs
	local string = string
	local surface = surface

	local function PaintEmpty() end

	local function PaintColumn(s, w, h)
		if k == columnCount then return end
		surface.SetDrawColor(BorderColor.r, BorderColor.g, BorderColor.b, BorderColor.a)
		surface.DrawRect(w - 2, 0, 2, h)
	end

	local function PaintLine(s, w, h)
		if s:IsHovered() then
			draw.RoundedBox(2, 0, 0, w, h, MenuColors.DListRowHover)
		else
			draw.RoundedBox(2, 0, 0, w, h, MenuColors.DListRowBackground)
		end

		if s:IsLineSelected() then
			draw.RoundedBox(2, 0, 0, w, h, MenuColors.DListRowSelected)
		end
	end

	local function PaintHeader(s, w, h)
		draw.RoundedBox(1, 0, 0, w, h, MenuColors.DListColumnOutline)
		draw.RoundedBox(1, 1, 1, w - 2, h - 2, MenuColors.DListColumnBackground)

		if s:IsHovered() then
			draw.RoundedBox(1, 0, 0, w, h, MenuColors.DListColumnOutline)
		end
	end

	function GProfiler.StyleDListView(v)
		local Columns = v.Columns
		for k, v1 in ipairs(Columns) do
			v1.Header:SetFont("GProfiler.Menu.ListHeader")
			v1.Header.Paint = PaintHeader
			v1.Header:SetTextColor(MenuColors.White)
		end

		local Lines = v.Lines
		for k, v in ipairs(Lines) do
			local columnCount = table.Count(v.Columns)
			for k, v in ipairs(v.Columns) do
				v:SetTextColor(MenuColors.DListRowTextColor)
				v.Paint = PaintColumn
			end
			v.Paint = PaintLine
		end

		GProfiler.StyleScrollbar(v)

		function v:Paint(w, h)
			draw.RoundedBox(2, 0, 0, w, h, MenuColors.DListBackground)
			surface.SetDrawColor(BorderColor.r, BorderColor.g, BorderColor.b, BorderColor.a)
			surface.DrawOutlinedRect(0, 0, w, h)
		end
	end

	local function PaintGrip(s, w, h)
		draw.RoundedBox(2, 0, 0, w, h, MenuColors.ScrollBarGripOutline)
		draw.RoundedBox(2, 1, 1, w - 2, h - 2, MenuColors.ScrollBarGrip)

		if s:IsHovered() or s.Depressed then
			draw.RoundedBox(2, 0, 0, w, h, MenuColors.ScrollBarGripOutline)
		end
	end

	local function PaintScrollbar(s, w, h)
		draw.RoundedBox(0, 0, 0, w, h, MenuColors.ScrollBar)
	end

	function GProfiler.StyleScrollbar(v)
		local ScrollBar = v.VBar or (v.GetVBar and v:GetVBar()) or nil
		if not IsValid(ScrollBar) then return end
		ScrollBar.btnUp:SetVisible(false)
		ScrollBar.btnDown:SetVisible(false)
		ScrollBar.Paint = PaintScrollbar
		ScrollBar.btnGrip.Paint = PaintGrip
		ScrollBar.PerformLayout = function()
			local wide = ScrollBar:GetWide()
			local scroll = ScrollBar:GetScroll() / ScrollBar.CanvasSize
			local barSize = math.max(ScrollBar:BarScale() * (ScrollBar:GetTall() - (wide * 2)), 10)
			local track = ScrollBar:GetTall() - (wide * 2) - barSize

			ScrollBar.btnGrip:SetPos(0, (wide + (scroll * (track + 3))) - 16)
			ScrollBar.btnGrip:SetSize(wide, barSize + 30)
		end
	end

	local function PaintSeperator(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, MenuColors.HeaderSeparator)
	end

	function GProfiler.Menu.CreateHeader(parent, text, x, y, w, h)
		local header = vgui.Create("DPanel", parent)
		header:SetSize(w, h)
		header:SetPos(x, y)
		header.Paint = PaintEmpty

		local headerText = vgui.Create("DLabel", header)
		headerText:SetFont("GProfiler.Menu.SectionHeader")
		headerText:SetText(text)
		headerText:SizeToContents()
		headerText:SetPos(TabPadding, header:GetTall() / 2 - headerText:GetTall() / 2)
		headerText:SetTextColor(MenuColors.White)

		local separator = vgui.Create("DPanel", header)
		separator:SetSize(header:GetWide() - TabPadding * 2, 1)
		separator:SetPos(TabPadding, header:GetTall() - 1)
		separator.Paint = PaintSeperator

		return header, headerText
	end

	local function PaintRealmSelector(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, MenuColors.ButtonOutline)
		draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonBackground)

		if s:IsHovered() then
			draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonHover)
		end
	end

	function GProfiler.Menu.CreateRealmSelector(parent, profiler, x, y, w, h, onSelect)
		local RealmSelector = vgui.Create("DComboBox", parent)
		RealmSelector:SetPos(x, y)
		RealmSelector:SetValue(string.format("%s: %s", GProfiler.Language.GetPhrase("realm"), GProfiler.Language.GetPhrase(string.format("realm_%s", GProfiler[profiler].Realm:lower()))))
		RealmSelector:AddChoice("Server", nil, nil, 'icon16/server.png')
		RealmSelector:AddChoice("Client", nil, nil, 'icon16/computer.png')
		RealmSelector:SetTextColor(MenuColors.White)
		RealmSelector:SetFont("GProfiler.Menu.RealmSelector")
		RealmSelector:SizeToContents()
		RealmSelector:SetTall(h)
		RealmSelector:SetWide(RealmSelector:GetWide() + 10)
		RealmSelector.OnSelect = onSelect
		RealmSelector.Paint = PaintRealmSelector
		RealmSelector.Think = function(s)
			if GProfiler[profiler].ProfileActive then
				s:SetEnabled(false)
			else
				s:SetEnabled(true)
			end
		end
		RealmSelector.OldOpen = RealmSelector.OpenMenu
		function RealmSelector:OpenMenu(...)
			RealmSelector.OldOpen(self, ...)
			local tables = self.Menu:GetCanvas():GetChildren()

			for k, v in ipairs(tables) do
				v:SetTextColor(MenuColors.White)
				v:SetFont("GProfiler.Menu.RealmSelector")
				v:SetText(GProfiler.Language.GetPhrase(string.format("realm_%s", v:GetText():lower())))
				function v:Paint(w, h)
					draw.RoundedBox(4, 0, 0, w, h, MenuColors.ButtonOutline)
					draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonBackground)

					if self:IsHovered() then
						draw.RoundedBox(4, 1, 1, w - 2, h - 2, MenuColors.ButtonHover)
					end
				end
			end
		end

		return RealmSelector
	end

	function GProfiler.TimeRunning(start, endd, profileActive)
		local time = 0

		if profileActive then
			time = SysTime() - start
		else
			time = endd - start
		end
		return string.format("%.2f", time)
	end

	function GProfiler.CopyLang(copy)
		copy = string.lower(string.Replace(copy, " ", "_"))
		return string.format("%s %s", GProfiler.Language.GetPhrase("copy"), GProfiler.Language.GetPhrase(copy))
	end

	function GProfiler.RequestFunctionSource(file, lineStart, lineEnd, callback)
		net.Start("GProfiler_RequestFunctionSource")
		net.WriteString(file)
		net.WriteUInt(lineStart, 32)
		net.WriteUInt(lineEnd, 32)
		net.SendToServer()

		local lines = {}
		net.Receive("GProfiler_RequestFunctionSource", function()
			local isFirst = net.ReadBool()
			local isLast = net.ReadBool()
			local count = net.ReadUInt(32)
			for i = 1, count do
				table.insert(lines, net.ReadString())
			end

			if isLast then
				callback(lines)
			end
		end)
	end
else
	util.AddNetworkString("GProfiler_RequestFunctionSource")

	-- Chunked net messages to avoid net message overflow
	local chunkSizeLimit = 65535 -- 187765611979610789976877

	net.Receive("GProfiler_RequestFunctionSource", function(l, ply)
		if not GProfiler.Access.HasAccess(ply) then return end

		local f = net.ReadString()
		local start = net.ReadUInt(32)
		local endd = net.ReadUInt(32)

		local res = GProfiler.ReadFunctionSource(f, start, endd)
		local chunkCount = 1
		local currentChunkSize = 0
		local chunks = {}
		if type(res) == "string" then res = {res} end
		for k, v in ipairs(res) do
			local str = string.Replace(v, "\t", "    ")
			if currentChunkSize + string.len(str) > (chunkSizeLimit - 1300) then
				chunkCount = chunkCount + 1
				currentChunkSize = 0
			end

			if not chunks[chunkCount] then chunks[chunkCount] = {} end
			table.insert(chunks[chunkCount], str)
			currentChunkSize = currentChunkSize + string.len(str)
		end

		for k, v in ipairs(chunks) do
			net.Start("GProfiler_RequestFunctionSource")
			net.WriteBool(k == 1)
			net.WriteBool(k == table.Count(chunks))
			net.WriteUInt(table.Count(v), 32)
			for k, v1 in ipairs(v) do
				net.WriteString(v1)
			end
			net.Send(ply)
		end
	end)

	function GProfiler.ReadFunctionSource(f, start, endd)
		if not file.Exists(f, "GAME") then return "" end
		if start < 0 or endd < 0 or endd < start then return "" end

		local f = file.Open(f, "r", "GAME")

		for i = 1, start - 1 do f:ReadLine() end

		local lines = {}
		for i = start, endd do table.insert(lines, f:ReadLine() or "") end

		return lines
	end
end

-- Shared util functions
function GProfiler.GetFunctionLocation(func)
	local info = debug.getinfo(func)
	if info.short_src == "[C]" then return "C" end
	return info.short_src .. ":" .. info.linedefined
end
--PATH addons/gprofiler/lua/gprofiler/profilers/concommands/sh_concommands.lua:
GProfiler.ConCommands = GProfiler.ConCommands or {}
GProfiler.ConCommands.ProfileData = GProfiler.ConCommands.ProfileData or {}
GProfiler.ConCommands.IsDetoured = GProfiler.ConCommands.IsDetoured or false

local SysTime = SysTime
local math = math

function GProfiler.ConCommands.GetFunction(cmd, tbl)
	local commands = tbl or concommand.GetTable()
	local command = commands[cmd]

	if not command then return "Unknown", 0, 0 end

	local dbgInfo = debug.getinfo(command)
	return dbgInfo.short_src, dbgInfo.linedefined, dbgInfo.lastlinedefined
end

function GProfiler.ConCommands:DetourCommands(ply)
	if not GProfiler.Access.HasAccess(ply or LocalPlayer()) or GProfiler.ConCommands.IsDetoured then return end

	GProfiler.Log((SERVER and "Server" or "Client") .. " commands profile started!", 2)
	GProfiler.ConCommands.OldRun = GProfiler.ConCommands.OldRun or concommand.Run
	GProfiler.ConCommands.ProfileData = {}
	GProfiler.ConCommands.IsDetoured = true

	concommand.Run = function(ply, cmd, ...)
		local start = SysTime()
		local ret = GProfiler.ConCommands.OldRun(ply, cmd, ...)
		local time = SysTime() - start

		if not GProfiler.ConCommands.ProfileData[cmd] then
			local source, lineStart, lineEnd = GProfiler.ConCommands.GetFunction(cmd)
			GProfiler.ConCommands.ProfileData[cmd] = {
				Count = 0,
				Time = 0,
				AverageTime = 0,
				LongestTime = 0,
				Source = source,
				Lines = {lineStart, lineEnd}
			}
		end

		GProfiler.ConCommands.ProfileData[cmd].Count = GProfiler.ConCommands.ProfileData[cmd].Count + 1
		GProfiler.ConCommands.ProfileData[cmd].Time = GProfiler.ConCommands.ProfileData[cmd].Time + time
		GProfiler.ConCommands.ProfileData[cmd].AverageTime = GProfiler.ConCommands.ProfileData[cmd].Time / GProfiler.ConCommands.ProfileData[cmd].Count
		GProfiler.ConCommands.ProfileData[cmd].LongestTime = math.max(GProfiler.ConCommands.ProfileData[cmd].LongestTime, time)

		return ret
	end
end

function GProfiler.ConCommands:RestoreCommands(ply)
	if not GProfiler.Access.HasAccess(ply or LocalPlayer()) or not GProfiler.ConCommands.IsDetoured then return end

	GProfiler.Log((SERVER and "Server" or "Client") .. " commands profile stopped, sending data!", 2)
	GProfiler.ConCommands.IsDetoured = false
	concommand.Run = GProfiler.ConCommands.OldRun

	if SERVER then
		net.Start("GProfiler_ConCommands_SendData")
			net.WriteUInt(table.Count(GProfiler.ConCommands.ProfileData), 32)
			for k, v in pairs(GProfiler.ConCommands.ProfileData) do
				net.WriteString(k)
				net.WriteUInt(v.Count, 32)
				net.WriteFloat(v.Time)
				net.WriteFloat(v.AverageTime)
				net.WriteFloat(v.LongestTime)
				net.WriteString(v.Source)
				net.WriteUInt(v.Lines[1], 16)
				net.WriteUInt(v.Lines[2], 16)
			end
		net.Send(ply)
	end
end

if SERVER then
	util.AddNetworkString("GProfiler_ConCommands_ToggleServerProfile")
	util.AddNetworkString("GProfiler_ConCommands_ServerProfileStatus")
	util.AddNetworkString("GProfiler_ConCommands_CommandList")
	util.AddNetworkString("GProfiler_ConCommands_SendData")

	net.Receive("GProfiler_ConCommands_ToggleServerProfile", function(len, ply)
		if not GProfiler.Access.HasAccess(ply) then return end

		if net.ReadBool() then
			if net.ReadBool() then
				GProfiler.ConCommands.Focus = net.ReadString()
			else
				GProfiler.ConCommands.Focus = false
			end

			GProfiler.ConCommands:DetourCommands(ply)
			net.Start("GProfiler_ConCommands_ServerProfileStatus")
			net.WriteBool(true)
			net.WriteEntity(ply)
			net.Broadcast()
		else
			GProfiler.ConCommands:RestoreCommands(ply)
			net.Start("GProfiler_ConCommands_ServerProfileStatus")
			net.WriteBool(false)
			net.WriteEntity(ply)
			net.Broadcast()
		end
	end)

	net.Receive("GProfiler_ConCommands_CommandList", function(_, ply)
		local commandList = {}
		for k, v in pairs(concommand.GetTable()) do
			local source, lineStart, lineEnd = GProfiler.ConCommands.GetFunction(k, concommand.GetTable())
			commandList[k] = {Source = source, Lines = {lineStart, lineEnd}}
		end

		net.Start("GProfiler_ConCommands_CommandList")
			net.WriteUInt(table.Count(commandList), 32)
			for k, v in pairs(commandList) do
				net.WriteString(k)
				net.WriteString(v.Source)
				net.WriteUInt(v.Lines[1], 16)
				net.WriteUInt(v.Lines[2], 16)
			end
		net.Send(ply)
	end)
end
--PATH addons/foodmode/lua/autorun/hfm_sync.lua:
local meta = FindMetaTable("Player")

if SERVER then
	util.AddNetworkString( "HFM_Sync" )
	function meta:FMSyncVar(var,data)
		local TB2Send = {}
		TB2Send.var = var
		TB2Send.data = data
		net.Start( "HFM_Sync" )
			net.WriteString(util.TableToJSON(TB2Send))
		net.Send(self)
	end
else
	net.Receive( "HFM_Sync", function( len, ply )
		if !LocalPlayer() or !LocalPlayer():IsValid() then return end
		
		local Data = util.JSONToTable(net.ReadString())
		LocalPlayer().HFMVars = LocalPlayer().HFMVars or {}
		LocalPlayer().HFMVars[Data.var] = Data.data
	end)
	net.Receive("HFM_Jraka", function()
		if !LocalPlayer() or !LocalPlayer():IsValid() then return end

		LocalPlayer().FoodItems = net.ReadTable()
	end)
	function meta:HFMGetVar(luaname)
		if !LocalPlayer() or !LocalPlayer():IsValid() then return 0 end
		
		LocalPlayer().HFMVars = LocalPlayer().HFMVars or {}
		return LocalPlayer().HFMVars[luaname] or 0
	end
end
--PATH addons/compa_playermodel_npc_451142486/lua/autorun/playeryukicompa.lua:
player_manager.AddValidModel( "Compa","models/player_compa.mdl" )
player_manager.AddValidHands( "Compa", "models/compa_arms.mdl", 0, "00000000" )

--Add NPC
local NPC =
{
	Name = "Compa",
	Class = "npc_citizen",
	KeyValues = { citizentype = 4 },
	Model = "Models/npc_compa.mdl",
	Category = "Neptunia NPCs"
}

list.Set( "NPC", "npc_compa", NPC )



--PATH addons/radial_menu/lua/autorun/radial_load.lua:
PIS = {}

local function Load()
	local loader = Nexus:Loader()
	loader:SetName("CMenu")
	loader:SetColor(Color(48, 100, 255))
	loader:SetAcronym("PIS")
	loader:RegisterAcronym()
	loader:SetLoadDirectory("radia_menu")
	loader:Load("config", "SHARED", true)
	loader:Load("vgui", "CLIENT", true)

	loader:Register()
end

if (Nexus) then 
	Load()
else 
	hook.Add("Nexus.PostLoaded", "CMenu", Load) 
end

--PATH addons/_adminmodules_menu/lua/sam/libs/sh_types.lua:
if SAM_LOADED then return end

-- https://gist.github.com/CapsAdmin/0d9c1e77d0fc22d910e182bfeb9812e5
local getmetatable = getmetatable

do
	local types = {
		["string"] = "",
		["boolean"] = true,
		["number"] = 0,
		["function"] = function() end,
		["thread"] = coroutine.create(getmetatable),
		["Color"] = Color(0, 0, 0),
	}

	for k, v in pairs(types) do
		if not getmetatable(v) then
			debug.setmetatable(v, {MetaName = k})
		else
			getmetatable(v).MetaName = k
		end
	end
end

function sam.type(value)
	if value == nil then
		return "nil"
	end
	local meta = getmetatable(value)
	if meta then
		meta = meta.MetaName
		if meta then
			return meta
		end
	end
	return "table"
end

do
	local function add(name)
		local new_name = name
		if name == "bool" then
			new_name = "boolean"
		end
		sam["is" .. name:lower()] = function(value)
			local meta = getmetatable(value)
			if meta and meta.MetaName == new_name then
				return true
			else
				return false
			end
		end
	end

	add("string")
	add("number")
	add("bool")
	add("function")

	add("Angle")
	add("Vector")
	add("Panel")
	add("Matrix")
end

function sam.isentity(value)
	local meta = getmetatable(value)
	if meta then
		if meta.MetaName == "Entity" then
			return true
		end
		meta = meta.MetaBaseClass
		if meta then
			return meta.MetaName == "Entity"
		end
	end
	return false
end
sam.IsEntity = sam.isentity

local type = sam.type
function sam.istable(value)
	return type(value) == "table"
end
--PATH addons/_adminmodules_menu/lua/sam/menu/cl_menu.lua:
function weight(x)
    return x/1920*ScrW()
end

function height(y)
    return y/1080*ScrH()
end

local material1 = Material('materials/tabs/command_window.png', "noclamp smooth")
local material2 = Material('materials/tabs/user.png', "noclamp smooth")
local material3 = Material('materials/tabs/ban-user.png', "noclamp smooth")

surface.CreateFont("RM_16", {
    font = "Roboto Medium",
    size = height(16),
    weight = 500,
	antialias = true,
    extended = true,
})
surface.CreateFont("RM_18", {
    font = "Roboto Medium",
    size = height(18),
    weight = 500,
	antialias = true,
    extended = true,
})

local function timeToStr(time)
    local tmp = time / 60 / 60

    if tmp < 1 then
        tmp = math.Round(tmp * 60)

        return tmp .. ' м'
    elseif tmp < 10 then
        local minutes = tmp - math.floor(tmp)
        minutes = (math.Round(minutes * 60))

        return math.floor(tmp) .. ':' .. Format('%.2d', minutes) .. ' ч'
    else
        tmp = math.Round(tmp)

        return tmp .. ' ч'
    end
end

local function CheckLetter(String)
    local TableLetters = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "0"}
    local Accept = false 
    for k, v in pairs(TableLetters) do 
        if v == string.upper(String) then 
            Accept = true 
        end 
    end 
    return Accept 
end 

local sam, SUI, type, sam_menu = sam, sam.SUI, sam.type

local button_click = function(s)
	local v, dmenu = s.v, vgui.Create("SAM.Menu")

	dmenu:SetInternal(s)
	if v.name and v.name ~= "" then
		dmenu:AddOption("Copy Name", function()
			SetClipboardText(v.name)
		end)
	end

	dmenu:AddOption("Copy Name", function()
		SetClipboardText(v:Name())
	end)

	dmenu:AddOption("Copy SteamID", function()
		SetClipboardText(v:SteamID())
	end)

	dmenu:AddOption("Copy Rank", function()
		SetClipboardText(v:GetUserGroup())
	end)

	dmenu:AddOption("Copy Play Time", function()
		SetClipboardText(timeToStr(v:GetNW2Int('playtime') or 0))
	end)

	dmenu:Open()
end

local ban_click = function(s)
	local v, dmenu = s.v, vgui.Create("SAM.Menu")
	dmenu:SetInternal(s)

	dmenu:AddOption("Copy Name", function()
		SetClipboardText(v.name)
	end)

	dmenu:AddOption("Copy SteamID", function()
		SetClipboardText(util.SteamIDFrom64(v.steamid))
	end)

	dmenu:AddOption("Cope Admin Info", function()
		SetClipboardText(v.admin)
	end)

	dmenu:AddOption("Unban", function()
		RunConsoleCommand('ulx','unban',util.SteamIDFrom64(v.steamid))
	end)

	dmenu:Open()
end

local function main()
	if IsValid(sam_menu) then
		sam_menu:Remove()
		return
	end
	local cmds, newcategories, sortcategories = xlib.makepanel{ parent=xgui.null },{}, {}
	cmds.cmd_contents = {}
	for cmd, data in pairs( ULib.cmds.translatedCmds ) do
		local opposite = data.opposite
		if opposite ~= cmd and ( LocalPlayer():query( data.cmd ) or (opposite and LocalPlayer():query( opposite ) )) then
			local catname = data.category
			if catname == nil or catname == "" then catname = "Остальное" end
			if not cmds.cmd_contents[catname] then
				cmds.cmd_contents[catname] = xlib.makelistview{ headerheight=0, multiselect=false, h=136 }
				cmds.cmd_contents[catname].OnRowSelected = function( self, LineID ) cmds.setselected( self, LineID ) end
				local cat = xlib.makecat{ label=catname, contents=cmds.cmd_contents[catname], expanded=false, parent=xgui.null }
				
				newcategories[catname] = cat
				table.insert( sortcategories, catname )
			end
		end
	end
	table.sort( sortcategories )
	sam_menu = vgui.Create("SAM.Frame")
	sam_menu:Center()
	sam_menu:MakePopup()
	sam_menu:SetTitle("Админ меню")
	sam_menu:AddAnimations(800, 600)
	sam_menu.close.DoClick = function()
		sam_menu:Remove()
	end

	local tab_body = sam_menu:Add("Panel")
	tab_body:Dock(LEFT)
	tab_body:SetWide(weight(57))
	tab_body.Paint = function(self,w,h)
		draw.RoundedBox(5,0,0,w,h,Color(30,30,30))
	end
	local function openCategory(cat)
		if IsValid(sheet) then sheet:Remove() end
		if IsValid(players_body) then players_body:Remove() end
		if IsValid(lefst_body) then lefst_body:Remove() end

		sheet = sam_menu:Add("Panel") 
		sheet:Dock(FILL)
		sheet:DockMargin(0, 1, 0, 1)
		sheet:InvalidateParent(true)
		sheet:InvalidateLayout(true)
		sheet.Paint = nil
	
		if cat == 'Команды' then
			local tab_body = sheet:Add("DPanel")
			tab_body:Dock(FILL)
			tab_body:DockMargin(0, 1, 0, 0)
			tab_body.Paint = function(self,w,h)
			end

			local title = tab_body:Add("DLabel")
			title:Dock(TOP)
			title:DockMargin(weight(15), 10, 0, 0)
			title:SetFont(SAM_TAB_TITLE_FONT)
			title:SetText(cat)
			title:SetTextColor(Color(255,255,255))
			title:SizeToContents()
			
			local body = tab_body:Add("Panel")
			body:Dock(FILL)
			body:DockMargin(0, 5, 10, 10)

			local info = body:Add("SAM.Label")
			info:SetText("")
			info:Dock(TOP)
			info:DockMargin(13, 4, 0, 0)
			info:SetTall(3)
			info:Line()
			info.Paint = function(self,w,h)
			end

			local left_body = body:Add("Panel")
			left_body:Dock(LEFT)
			left_body:DockMargin(weight(15),height(20),0,0)
			left_body:SetWide(weight(178))

			local searchs_entry = left_body:Add("SAM.TextEntry")
			searchs_entry:Dock(TOP)
			searchs_entry:SetNoBar(true)
			searchs_entry:SetPlaceholder("Поиск...")
			searchs_entry:SetRadius(4)
			searchs_entry:SetTall(height(27))

			local category_list = left_body:Add("SAM.CollapseCategory")
			category_list:Dock(FILL)
			category_list:DockMargin(0, 10, 0, 0)

			local canvas = category_list:GetCanvas()

			local commands_refresh = function()
				if not IsValid(category_list) then return end

				canvas:Clear()
				table.Empty(category_list.items)
				table.Empty(category_list.categories)

				for _, v in ipairs(sortcategories) do
					local item
					for _, command in ipairs(ulx.cmdsByCategory[v]) do
						if LocalPlayer():query( command.cmd ) then
							item = 	string.gsub( command.cmd, "ulx ", "" )

							local item = category_list:add_item(item, v)
							item:InvalidateParent(true)
							item.help = command.help
							item.command = command
							item.names = {v:lower()}
						end
					end
				end

			end

			commands_refresh()

			function searchs_entry:OnValueChange(text)
				category_list:Search(text:lower())
			end

			local right_body
			function category_list:item_selected(item)
				local SUI,command,sizey,playerChecker = sam.SUI,item.command,height(600)
				local blacklist = {
					[1] = 'ulx addgroup',
					[2] = 'ulx banip',
					[3] = 'ulx groupallow',
					[4] = 'ulx groupdeny',
					[5] = 'ulx removegroup',
					[6] = 'ulx setgroupcantarget',
					[7] = 'ulx unbanip',
					[8] = 'ulx unban',
					[9] = 'ulx smask',
					[10] = 'ulx cleanupall',
					[11] = 'ulx nolag',
					[12] = 'ulx stopsound',
					[13] = 'ulx stopvote',
					[14] = 'ulx csay',
					[15] = 'ulx tsay',
					[16] = 'ulx renamegroup',
					[17] = 'ulx gunban',
				}

				if IsValid(lefst_body) then lefst_body:Remove() end
				if IsValid(right_body) then right_body:Remove() end

				right_body = tab_body:Add("Panel")
				right_body:Dock(RIGHT)
				right_body:SetWide(weight(240))
				right_body:DockMargin(0,height(20),weight(10),0)

				for i, name in ipairs(blacklist) do
					if command.cmd == name then 
						right_body:SetWide(weight(675))
					end
				end

				if string.find(command.cmd, "id") then
					right_body:SetWide(weight(675))
				end

				local tbl = {
					['Permanent'] = 0,
					['Hours'] = 60,
					['Days'] = 60*24,
					['Weeks'] = 60*24*7,
					['Years'] = 60*24*365
				}

				function cmds.runCmd( cmd )
					local tf,cmd,plys = false,string.Explode( " ", cmd ),{}

					if not playerChecker then
						for _, arg in ipairs( cmds.curargs ) do
							if not arg.xguiIgnore then
								if arg.val then
									playerChecker = arg:GetValue()
								end
								tf = true
							end
						end
					end
                    if cmd[2] ~= 'smask' and cmd[2] ~= 'cleanupall' and cmd[2] ~= 'stopsound' and cmd[2] ~= 'stopvote' and cmd[2] ~= 'nolag' then
                        if tf then 
                            table.insert( plys, playerChecker  )
                        else
                            table.insert( plys, '$'..ULib.getUniqueIDForPlayer(playerChecker))
                            table.insert( cmd, table.concat( plys ) )
                        end
                    end
		
					for _, arg in ipairs( cmds.curargs ) do
						if not arg.xguiIgnore then
							if arg:GetName() != 'DPanel' then
								table.insert( cmd, arg:GetValue() )
							else
                                local pnl
                                if IsValid(pnledSl) then pnl = search_entry else pnl = search_entrys end
								local v = math.floor(pnl:GetValue())
								local cf = 1
								for k, v in ipairs(cmds.argslists:GetChildren()) do 
									if v.xui then 
										if v.interval then
											if !v.GetValue then continue end
											cf = tbl[v.interval:GetValue()] or 1    
											break
										end
									end
								end
					            if cmd[2] == 'cloak' then
								    table.insert( cmd, 255 )
                                elseif cmd[2] == 'uncloak' then
								    table.insert( cmd, 255 )
                                else
								    table.insert( cmd, math.floor(v*cf) )
                                end
							end
						end
					end
                    RunConsoleCommand( unpack( cmd ) )
				end
				cmds.argslists = xlib.makelistlayout{ w=right_body:GetWide(), h=height(640), parent=right_body }

				function cmds.buildArgsLists( cmd )
					cmds.argslists:Clear()
					cmds.curargs = {}
					local argnum = 0
					local zpos = 0
					local expectingplayers = cmd.args[2] and ( ( cmd.args[2].type == ULib.cmds.PlayersArg ) or ( cmd.args[2].type == ULib.cmds.PlayerArg ) ) or false
					for _, arg in ipairs( cmd.args ) do
						if not arg.type.invisible then
							argnum = argnum + 1
							if not ( argnum == 1 and expectingplayers ) then
								if arg.invisible ~= true then
									local curitem = arg
									if curitem.repeat_min then --This command repeats!
										local panel = xlib.makepanel{ h=20, parent=sam_menu }
										local choices = {}

										panel.argnum = argnum
										panel.xguiIgnore = true
										panel.arg = curitem
										panel.addbutton = xlib.makebutton{ label="Add", w=83, parent=panel }
										panel.addbutton.DoClick = function( self )
											local parent = self:GetParent()
											local ctrl = parent.arg.type.x_getcontrol( parent.arg, parent.argnum, cmds.argslists )
											cmds.argslists:Add( ctrl )
											table.insert( choices, ctrl )
											table.insert( cmds.curargs, ctrl )
											panel.removebutton:SetDisabled( false )
											if parent.arg.repeat_max and #choices >= parent.arg.repeat_max then self:SetDisabled( true ) end
										end

								
										cmds.argslists:Add( panel )
										panel:SetZPos( zpos )
										zpos = zpos + 12

										for i=1,curitem.repeat_min do
											local ctrl = arg.type.x_getcontrol( arg, argnum, cmds.argslists )
											cmds.argslists:Add( ctrl )
											ctrl:SetZPos( zpos )
											zpos = zpos + 1
											table.insert( choices, ctrl )
											table.insert( cmds.curargs, ctrl )
										end
									else
										local panel = arg.type.x_getcontrol( arg, argnum, cmds.argslists )
										if cmd.cmd ~= 'ulx cloak' then 

											panel.xui = true

											table.insert( cmds.curargs, panel )
											if curitem.type == ULib.cmds.NumArg then
												local yPos,wPan = 0,weight(192)

												if zpos != 0 then zpos = height(30) end
												if cmd.cmd == 'ulx tempadduserid' then yPos = height(65) end
												if cmd.cmd == 'ulx ban' or cmd.cmd == 'ulx gban' then wPan = weight(70) end
												if cmd.cmd == 'ulx banid' or cmd.cmd == 'ulx gbanid' then yPos = ScrH()*.015 wPan = weight(175) end
												if cmd.cmd == 'ulx tempadduser' then yPos = ScrH()*.02 end
												if IsValid(pnledSls) then pnledSls:Remove() end
												if IsValid(search_entrys) then search_entrys:Remove() end
												if IsValid(pnledSl) then pnledSl:Remove() end
												if IsValid(search_entry) then search_entry:Remove() end
												
												local max,min,ter = 100,1,1

												if cmd.cmd == 'ulx tgag' or cmd.cmd == 'ulx tmute' then max = 3600 end
												if cmd.cmd == 'ulx arrest' then max = 300 end

												search_entrys = vgui.Create("DTextEntry",right_body)
												search_entrys:SetPos(wPan,panel:GetY()+height(5))
												search_entrys:SetSize(weight(40),panel:GetTall()/2+height(5))
												search_entrys:SetFont('RM_16')
												search_entrys.Paint = function(self,w,h)
													draw.RoundedBox(2,0,0,w,h,Color(40,40,40))
													self:DrawTextEntryText(Color(255,255,255,104), Color(121,121,121), color_white)
												end
												search_entrys.AllowInput = function(self, stringValue)
													if not CheckLetter(stringValue) then 
														return true
													end
												end 
												search_entrys.OnChange = function(self)
													local value = self:GetValue()

													if value == '' or value == nil then
														self:SetText(tostring(min))
														pnledSl:SetValue(min) 
													else
														local numericValue = tonumber(value)
														if numericValue and numericValue <= max then
															pnledSl:SetValue(numericValue)
														else
															pnledSl:SetValue(max)
														end
													end
												end
												
												pnledSls = vgui.Create('slider', right_body)
												pnledSls:SetPos(0, zpos+yPos)
												pnledSls:SetSize( wPan-weight(7),height(20)  )
												pnledSls:SetMin(min)
												pnledSls:SetMax(max)
												pnledSls.OnChange = function(self, val)
													if val <= min then pnledSls:SetValue(min) val = min end
													val = math.floor(val)
													ter = val
													search_entrys:SetValue(ter)
												end
												pnledSls:SetValue(min)
												search_entrys:SetValue(min)

												net.Receive('ChangeValueSelect',function()
													if IsValid(pnledSls) then pnledSls:Remove() end
													if IsValid(search_entrys) then search_entrys:Remove() end
													if IsValid(pnledSl) then pnledSl:Remove() end
													if IsValid(search_entry) then search_entry:Remove() end
													local max,min = net.ReadUInt(31),net.ReadUInt(32)/2
													local ter = min
													
													search_entry = vgui.Create("DTextEntry",right_body)
													search_entry:SetPos(wPan,panel:GetY()+height(5))
													search_entry:SetSize(weight(47),panel:GetTall()/2+height(5))
													search_entry:SetFont('RM_16')
													search_entry.Paint = function(self,w,h)
														draw.RoundedBox(2,0,0,w,h,Color(40,40,40))
														self:DrawTextEntryText(Color(255,255,255,104), Color(121,121,121), color_white)
													end
													search_entry.AllowInput = function(self, stringValue)
														if not CheckLetter(stringValue) then 
															return true
														end
													end 
													search_entry.OnChange = function(self)
														local value = self:GetValue()

														if value == '' or value == nil then
															self:SetText(tostring(min))
															pnledSl:SetValue(min) 
														else
															local numericValue = tonumber(value)
															if numericValue and numericValue <= max then
																pnledSl:SetValue(numericValue)
															else
																pnledSl:SetValue(max)
															end
														end
													end
											
													pnledSl = vgui.Create('slider', right_body)
													pnledSl:SetPos(0, panel:GetY()+height(2))
													pnledSl:SetSize( wPan-weight(7),panel:GetTall()/2-height(2) )
													pnledSl:SetMin(min)
													pnledSl:SetMax(max)
													pnledSl.OnChange = function(self, val)
														if val <= min then pnledSl:SetValue(min) val = min end
														val = math.floor(val)
														ter = val
														search_entry:SetValue(ter)
													end
													pnledSl:SetValue(min)
													search_entry:SetValue(min)
												end)
						
												right_body.Think = function()
													if panel.interval then
														if panel.interval:GetValue() == 'Permanent' then
															if IsValid(pnledSl) then
																if ter != tonumber(pnledSl:GetValue()) then
																	ter = tonumber(pnledSl:GetValue())
																end
															end
															if IsValid(panedl) then return end
															timer.Simple(0.02,function()
																panedl = right_body:Add("Panel")
																panedl:SetPos(0,zpos+yPos)
																panedl:SetSize(wPan+weight(50),height(33))
															end)
														else
															if IsValid(panedl) then panedl:Remove() end
														end
													end
												end

											elseif curitem.type == ULib.cmds.StringArg then
												panel.OnEnter = function( self )
													cmds.runCmd( cmd.cmd )
												end
											end
								
											cmds.argslists:Add( panel )
											panel:SetZPos( zpos )
									
											zpos = zpos + 1
										end
									end
								end
							end
						end
					end
					if LocalPlayer():query( cmd.cmd ) then
						local panel = xlib.makebutton{ label=cmd.cmd, parent=cmds.argslists }
						
						panel.xguiIgnore = true
						panel.DoClick = function()
							cmds.runCmd( cmd.cmd )
						end
						
						cmds.argslists:Add( panel )
						panel:SetZPos( zpos )
						zpos = zpos + 1
		
						if cmd.helpStr then --If the command has a string for help
							local panel = xlib.makelabel{ w=160, label=cmd.helpStr, wordwrap=true, parent=cmds.argslists }
							panel:SetZPos( zpos )
						end
					end
					if cmd.opposite and LocalPlayer():query( cmd.opposite ) then
						local panel = xlib.makebutton{ label=cmd.opposite, parent=cmds.argslists }

						panel.DoClick = function()
							cmds.runCmd( cmd.opposite )
						end
						panel.xguiIgnore = true
						cmds.argslists:Add( panel )
						panel:SetZPos( zpos )
						zpos = zpos + 1
				
					end
				end
		
				
				if string.find(command.cmd, "id") then
					cmds.buildArgsLists(command)
					return
				end
				
				for i, name in ipairs(blacklist) do
					if command.cmd == name then 
						cmds.buildArgsLists(command)
						return 
					end
				end
				
				local check_text_match = function(text, ply)
					if ply:Name():lower():find(text, 1, true) then return true end
					if ply:GetUserGroup():lower():find(text, 1, true) then return true end
					if team.GetName(ply:Team()):lower():find(text, 1, true) then return true end
				
					if not ply:IsBot() then
						return ply:SteamID():lower():find(text, 1, true) or ply:SteamID64():lower():find(text, 1, true)
					end
				
					return false
				end

				lefst_body = tab_body:Add("Panel")
				lefst_body:Dock(FILL)
				lefst_body:DockMargin(weight(220),height(25),weight(10),height(10))
				lefst_body.no_remove = true
				lefst_body.no_change = "player"

				local argument = {}
				local ply_list = lefst_body:Add("SAM.ScrollPanel")
				ply_list:Dock(FILL)
				ply_list:Background(Color(34, 34, 34), 3)
				ply_list.argument = argument
				ply_list.set_result = set_result
				ply_list.multi_select = argument.single_target ~= true
				ply_list.Paint = function(s, w, h)
					s:RoundedBox("Background", 3, 0, 0, w, h, SUI.GetColor("text_entry_bg"))
				end

				local lines = {}
				function ply_list:OnClickLine(line, clear)
					if not multi_select or clear then
						self:ClearSelection()
					end

					line.Selected = true

					self.main_selected_line = line
					self:OnRowSelected(line.id, line)
				end

				function ply_list:GetSelected()
					local ret = {}
					for _, v in ipairs(lines) do
						if v.Selected then
							table.insert(ret, v)
						end
					end
					return ret
				end

				function ply_list:GetSelectedLine()
					for _, line in ipairs(lines) do
						if line.Selected then return line end
					end
				end

				function ply_list:ClearSelection()
					for _, line in ipairs(lines) do
                        if IsValid(line) then
						    line.Selected = false
                        end
					end
					self:OnRowSelected()
				end
				function ply_list:OnRowSelected()
					local plys = {}
					for k, v in ipairs(ply_list:GetSelected()) do
						plys[k] = v.ply:EntIndex()
					end
				end

				function ply_list:OnRowRightClick(_, line)
					local dmenu = vgui.Create("SAM.Menu")
					dmenu:SetInternal(line)

					local name = line.ply:Name()
					dmenu:AddOption("Copy Name", function()
						SetClipboardText(name)
					end)

					dmenu:AddSpacer()

					local steamid = line.ply:SteamID()
					dmenu:AddOption("Copy SteamID", function()
						SetClipboardText(steamid)
					end)

					dmenu:AddOption("Copy SteamID64", function()
						SetClipboardText(util.SteamIDTo64(steamid))
					end)

					dmenu:Open()
					dmenu:SetPos(input.GetCursorPos())
				end

				local item_rightclick = function(s)
					if not s.Selected then
						ply_list:OnClickLine(s, true)
					end
					ply_list:OnRowRightClick(s.id, s)
				end

				local item_cursor = function(s)
					if input.IsMouseDown(MOUSE_LEFT) then
						ply_list:OnClickLine(s)
					end
				end

				local search_entry = lefst_body:Add("SAM.TextEntry")
				search_entry:Dock(TOP)
				search_entry:DockMargin(0, 0, 0, 5)
				search_entry:SetPlaceholder("Search... (name/steamid/rank/job)")
				search_entry:SetBackground(Color(34, 34, 34))
				search_entry:SetTall(25)
				search_entry:SetNoBar(true)
				function search_entry:OnValueChange(text)
					if text == nil then
						text = self:GetValue()
					end
					if text ~= "" then
						ply_list:ClearSelection()
					end
					text = text:lower()
					for i, line in ipairs(lines) do
						local ply = line.ply
						if IsValid(ply) then
							line:SetVisible(check_text_match(text, ply))
						end
					end
					ply_list:GetCanvas():InvalidateLayout(true)
				end

				local added_players = {}

				local TOpen = false
				local function refresh()
					if not IsValid(ply_list) then return end
					local targets = player.GetAll()
					if TOpen then
						ply_list:Clear()
					end

					for k,ply in ipairs(targets) do
						player_button = ply_list:Add("SAM.Button")
						player_button:Dock(TOP)
						player_button:DockMargin(0, 0, 0, 2)
						player_button:DockPadding(4, 4, 4, 4)
						player_button:SetContained(false)
						player_button:SetText("")
						player_button:SetZPos(i)
						player_button.DoClick = function(self)
							playerChecker = ply
							cmds.buildArgsLists(command)
							ply_list:OnClickLine(self, true)
						end
						player_button.DoRightClick = item_rightclick
						player_button.OnCursorMoved = item_cursor

						local line = player_button:Add("SAM.PlayerLine")
						line:SetMouseInputEnabled(false)
						line:SetInfo({
							steamid = ply:IsBot() and "BOT" or ply:SteamID(),
							name = ply:Name(),
							rank = ply:GetUserGroup()
						})

						player_button:InvalidateLayout(true)
						player_button:SizeToChildren(false, true)

						player_button.ply = ply
						player_button.line = line
						player_button.id = table.insert(lines, player_button)
						
						search_entry:OnValueChange()
					end
					TOpen = true
				end
				
				refresh()
				hook.Add( "UCLChanged", "xgui_RefreshPlayerCmds", function() 
					refresh()
				end)
			end
		local players_body
		elseif cat == 'Игроки' then
			local argument = {}

			players_body = sam_menu:Add("Panel")
			players_body:Dock(FILL)
			players_body:DockMargin(0, 1, 0, 0)
			players_body:DockPadding(10, 10, 10, 10)
			players_body.no_remove = true
			players_body.no_change = "player"

			local body = players_body:Add("SAM.ScrollPanel")
			body:Dock(FILL)
			body:DockMargin(0, 10, 0, 0)
			body:SetVBarPadding(6)
			body:GetCanvas():Clear()
			body.VBar.Scroll = 0
			body.argument = argument
			body.set_result = set_result
			body.multi_select = argument.single_target ~= true
		
			local title = players_body:Add("SAM.Label")
			title:Dock(TOP)
			title:SetFont(SAM_TAB_TITLE_FONT)
			title:SetText("Игроки")
			title:SetTextColor(Color(255,255,255))
			title:SizeToContents()

			local info = players_body:Add("SAM.Label")
			info:SetText("")
			info:Dock(TOP)
			info:DockMargin(0, 10, 0, 0)
			info:SetTall(3)
			info:Line()
			info.Paint = function(self,w,h)
			end

			local total = players_body:Add("SAM.Label")
			total:Dock(TOP)
			total:DockMargin(0, 6, 0, 0)
			total:SetFont(SAM_TAB_DESC_FONT)
			total:SetText(player.GetCount() .." игроков онлайн")
			total:SetTextColor(Color(255,255,255))
			total:SetPos(10, height(40))
			total:SizeToContents()
			local lines = {}
			       

		
			local search_entry
			local SUI = sam.SUI
			local COLUMN_FONT = SUI.CreateFont("Column", "Roboto", 18)

			do
				local columns = players_body:Add("Panel")
				columns:Dock(TOP)
				columns:DockMargin(0, 10, 0, 0)
		
				local info = columns:Add("SAM.Label")
				info:Dock(LEFT)
				info:DockMargin(4, 0, 0, 0)
				info:SetFont(COLUMN_FONT)
				info:SetText("Игрок")
				info:SetTextColor(Color(255,255,255))
				info:SetWide(weight(360))
				info:SizeToContentsY(3)
		
				local play_time = columns:Add("SAM.Label")
				play_time:Dock(LEFT)
				play_time:DockMargin(-4, 0, 0, 0)
				play_time:SetFont(COLUMN_FONT)
				play_time:SetText("Онлайн")
				play_time:SetTextColor(Color(255,255,255))
				play_time:SetWide(weight(176))
				play_time:SizeToContentsY(3)
		
				local rank_expiry = columns:Add("SAM.Label")
				rank_expiry:Dock(LEFT)
				rank_expiry:DockMargin(-4, 0, 0, 0)
				rank_expiry:SetFont(COLUMN_FONT)
				rank_expiry:SetText("Ранг истекает")
				rank_expiry:SetTextColor(Color(255,255,255))
				rank_expiry:SetWide(weight(280))
				rank_expiry:SizeToContentsY(3)
		
				columns:SizeToChildren(false, true)
			end

			do
				local container = players_body:Add("SAM.Panel")
				container:Dock(FILL)
				container:DockMargin(0, 6, 10, 0)
				container:SetTall(30)

				local check_text_match = function(text, ply)
					if ply:Name():lower():find(text, 1, true) then return true end
					if ply:GetUserGroup():lower():find(text, 1, true) then return true end
					if team.GetName(ply:Team()):lower():find(text, 1, true) then return true end
				
					if not ply:IsBot() then
						return ply:SteamID():lower():find(text, 1, true) or ply:SteamID64():lower():find(text, 1, true)
					end
				
					return false
				end

				local lefst_body = container:Add("SAM.Panel")
				lefst_body:Dock(FILL)
				lefst_body:DockMargin(0,0,0,0)
				lefst_body:SetWide(0)
				lefst_body.no_remove = true
				lefst_body.no_change = "player"

				local argument = {}
				local lines = {}

				local ply_list = lefst_body:Add("SAM.ScrollPanel")
				ply_list:Dock(FILL)
				ply_list:DockMargin(0,5,0,0)
				ply_list:Background(Color(34, 34, 34), 3)
				ply_list.argument = argument
				ply_list.set_result = set_result
				ply_list.multi_select = argument.single_target ~= true
				ply_list.Paint = function(s, w, h)
				end

				local search_entry = lefst_body:Add("SAM.TextEntry")
				search_entry:Dock(TOP)
				search_entry:DockMargin(0, 0, 0, 5)
				search_entry:SetPlaceholder("Поиск... (name/steamid/rank/job)")
				search_entry:SetBackground(Color(34, 34, 34))
				search_entry:SetTall(height(30))
				search_entry:SetNoBar(true)
				function ply_list:OnClickLine(line, clear)
					local multi_select = ply_list.multi_select
					if not multi_select and not clear then return end

					if multi_select and input.IsKeyDown(KEY_LCONTROL) then
						if line.Selected then
							line.Selected = false
							self.main_selected_line = nil
							self:OnRowSelected()
							return
						end
						clear = false
					end

					if multi_select and input.IsKeyDown(KEY_LSHIFT) then
						local selected = self:GetSelectedLine()
						if selected then
							self.main_selected_line = self.main_selected_line or selected

							if clear then
								self:ClearSelection()
							end

							local first = math.min(self.main_selected_line.id, line.id)
							local last = math.max(self.main_selected_line.id, line.id)

							for id = first, last do
								local line_2 = lines[id]
								local was_selected = line_2.Selected

								line_2.Selected = true

								if not was_selected then
									self:OnRowSelected(line_2.id, line_2)
								end
							end

							return
						end
					end

					if not multi_select or clear then
						self:ClearSelection()
					end

					line.Selected = true

					self.main_selected_line = line
					self:OnRowSelected(line.id, line)
				end

				function ply_list:GetSelected()
					local ret = {}
					for _, v in ipairs(lines) do
						if v.Selected then
							table.insert(ret, v)
						end
					end
					return ret
				end

				function ply_list:GetSelectedLine()
					for _, line in ipairs(lines) do
						if line.Selected then return line end
					end
				end

				function ply_list:ClearSelection()
					for _, line in ipairs(lines) do
						line.Selected = false
					end
					self:OnRowSelected()
				end
				function ply_list:OnRowSelected()
					local plys = {}
					for k, v in ipairs(ply_list:GetSelected()) do
						plys[k] = v.ply:EntIndex()
					end
				end
				function search_entry:OnValueChange(text)
					if text == nil then
						text = self:GetValue()
					end
					if text ~= "" then
						ply_list:ClearSelection()
					end
					text = text:lower()
					for i, line in ipairs(lines) do
						local ply = line.ply
                        if IsValid(ply) then
							line:SetVisible(check_text_match(text, ply))
						end
					end
					ply_list:GetCanvas():InvalidateLayout(true)
				end

                local playerData = {} 

				timer.Simple(0.1,function()
					local TOpen = false
					local function refresh()
						if not IsValid(ply_list) then return end
						local targets = player.GetAll()
						if TOpen then
							ply_list:Clear()
						end
						net.Start('GetTotalTime')
						net.SendToServer()
			
						timer.Simple(0.1,function()
							for k,ply in ipairs(targets) do
								local text = 'Никогда'
                                net.Receive('GetTotalTime', function()
                                    local tblTime = net.ReadTable()
                                    if tblTime then
                                        for _,player in ipairs(tblTime) do
                                            ent = player.player  
                                            time = player.time
                                            if ent == ply and time then
                                                text = os.date('%d.%m.%y - %H:%M',time)
                                            end
                                        end
                                    end
                                end)
					
								local line = ply_list:Add("SAM.PlayerLine")
								line:DockMargin(0, 0, 0, 6)
								line.Paint = function(self,w,h)
									draw.SimpleText(timeToStr(ply:GetNW2Int('playtime') or 0),'RM_16',weight(388),h/2,color_white,1,1)
									draw.SimpleText(text,'RM_16',weight(585),h/2,color_white,1,1)
								end
								local name = ply:Name() ~= "" and ply:Name() or nil
								line:SetInfo({
									steamid = ply:SteamID(),
									name = name,
									rank = ply:GetUserGroup()
								})	
							
								line.ply = ply
								line.line = line
								line.id = table.insert(lines, line)
								local but = line:Actions()
								but.v = ply
								but:On("DoClick", button_click)
								if IsValid(ply_list) then
									ply_list:Line()
								end
							end
						end)
						TOpen = true
					end
					refresh()
					hook.Add( "UCLChanged", "xgui_RefreshPlayerCmds", function() 
						refresh()
					end)
				end)
			end
		elseif cat == 'Баны' then
			local argument = {}

			players_body = sam_menu:Add("Panel")
			players_body:Dock(FILL)
			players_body:DockMargin(0, 1, 0, 0)
			players_body:DockPadding(10, 10, 10, 10)
			players_body.no_remove = true
			players_body.no_change = "player"

			local body = players_body:Add("SAM.ScrollPanel")
			body:Dock(FILL)
			body:DockMargin(0, 10, 0, 0)
			body:SetVBarPadding(6)
			body:GetCanvas():Clear()
			body.VBar.Scroll = 0
			body.argument = argument
			body.set_result = set_result
			body.multi_select = argument.single_target ~= true

			local title = players_body:Add("SAM.Label")
			title:Dock(TOP)
			title:SetFont(SAM_TAB_TITLE_FONT)
			title:SetText("Баны")
			title:SetTextColor(Color(255,255,255))
			title:SizeToContents()

			local SUI = sam.SUI
			local COLUMN_FONT = SUI.CreateFont("Column", "Roboto", 18)
            local bottom_panel
			local page = 0
			do
				bottom_panel = players_body:Add("SAM.Panel")
				bottom_panel:Dock(BOTTOM)
				bottom_panel:DockMargin(0, 6, 0, 0)
				bottom_panel:SetTall(30)
				bottom_panel:Background(Color(34,34,34))
     
				local previous_page = bottom_panel:Add("SAM.Button")
				previous_page:Dock(LEFT)
				previous_page:SetWide(30)
				previous_page:SetText("<")
				previous_page:SetFont('RM_16')
				previous_page.DoClick = function()
					if page <= 0 then return end
					page = page - 1
					if not linesd then
						refresh(page)
					else
						refreshSearch(page)
					end
				end

				local next_page = bottom_panel:Add("SAM.Button")
				next_page:Dock(RIGHT)
				next_page:SetWide(30)
				next_page:SetText(">")
				next_page:SetFont("RM_16")
				next_page.DoClick = function()
					page = page + 1
					if not linesd then
						refresh(page)
					else
						refreshSearch(page)
					end
				end

				function bottom_panel:Think()
					next_page:SetEnabled(page ~= pages)
					previous_page:SetEnabled(page > 0)
				end

				local columns = players_body:Add("Panel")
				columns:Dock(TOP)
				columns:DockMargin(0, 10, 0, 0)
       
				local info = columns:Add("SAM.Label")
				info:SetText("")
				info:Dock(TOP)
				info:DockMargin(0, 0, 0, 20)
				info:SetTall(3)
				info:Line()
				info.Paint = function(self,w,h)
				end
 
				local info = columns:Add("SAM.Label")
				info:Dock(LEFT)
				info:DockMargin(4, 0, 0, 0)
				info:SetFont(COLUMN_FONT)
				info:SetText("Игрок")
				info:SetTextColor(Color(255,255,255))
				info:SetWide(weight(360))
				info:SizeToContentsY(20)

				local play_time = columns:Add("SAM.Label")
				play_time:Dock(LEFT)
				play_time:DockMargin(-4, 0, 0, 0)
				play_time:SetFont(COLUMN_FONT)
				play_time:SetText("Дата разбана")
				play_time:SetTextColor(Color(255,255,255))
				play_time:SetWide(weight(196))
				play_time:SizeToContentsY(20)
		
				local rank_expiry = columns:Add("SAM.Label")
				rank_expiry:Dock(LEFT)
				rank_expiry:DockMargin(-4, 0, 0, 0)
				rank_expiry:SetFont(COLUMN_FONT)
				rank_expiry:SetText("Причина")
				rank_expiry:SetTextColor(Color(255,255,255))
				rank_expiry:SetWide(weight(280))
				rank_expiry:SizeToContentsY(20)
		
				columns:SizeToChildren(false, true)
			end

			do
				local container = players_body:Add("SAM.Panel")
				container:Dock(FILL)
				container:DockMargin(0, 6, 10, 0)
				container:SetTall(30)
				-- container:Line()
         
                local lefst_body = container:Add("SAM.Panel")
				lefst_body:Dock(FILL)
				lefst_body:DockMargin(0,0,0,0)
				lefst_body:SetWide(0)
				lefst_body.no_remove = true
				lefst_body.no_change = "player"

				local bodys = lefst_body:Add("SAM.ScrollPanel")
				bodys:Dock(FILL)
				bodys:DockMargin(0, 10, 0, 0)
				bodys:SetVBarPadding(6)
                bodys.Paint = nil

				local body = lefst_body:Add("SAM.ScrollPanel")
				body:Dock(FILL)
				body:DockMargin(0, 10, 0, 0)
				body:SetVBarPadding(6)
				body.argument = argument
				body.set_result = set_result
				body.multi_select = argument.single_target ~= true
  
				local check_text_match = function(text, ply)
                    if ply.name:lower():find(text, 1, true) then return true end
					if util.SteamIDFrom64(ply.steamid):lower():find(text, 1, true) then return true end
					if ply.admin:lower():find(text, 1, true) then return true end
					
					return false
				end



				-- local ply_list = lefst_body:Add("SAM.ScrollPanel")
				-- ply_list:Dock(FILL)
				-- ply_list:DockMargin(0,5,0,0)
				-- ply_list:Background(Color(34, 34, 34), 3)
				-- ply_list.argument = argument
				-- ply_list.set_result = set_result
				-- ply_list.multi_select = argument.single_target ~= true
                -- ply_list.Paint = function(self,w,h)
                --     draw.RoundedBox(0,0,0,w,h,Color(255,255,255))
                -- end

				local lines = {}

				function body:GetSelected()
					local ret = {}
					for _, v in ipairs(lines) do
						if v.Selected then
							table.insert(ret, v)
						end
					end
					return ret
				end

				function body:GetSelectedLine()
					for _, line in ipairs(lines) do
						if line.Selected then return line end
					end
				end

				function body:ClearSelection()
					for _, line in ipairs(lines) do
						--line.Selected = false
					end
					self:OnRowSelected()
				end
				function body:OnRowSelected()
					local plys = {}
					for k, v in ipairs(body:GetSelected()) do
						plys[k] = v.ply:EntIndex()
					end
				end
				local textEntrye
				local search_entry = lefst_body:Add("SAM.TextEntry")
				search_entry:Dock(TOP)
				search_entry:DockMargin(0, 0, 0, 5)
				search_entry:SetPlaceholder("Поиск... (name/steamid/admin)")
				search_entry:SetBackground(Color(34, 34, 34))
				search_entry:SetTall(height(30))
				search_entry:SetNoBar(true)
				search_entry.OnEnter = function(self)
					local text = self:GetValue()
					if not text then return end

					if text == '' then body:SetVisible(true) bodys:SetVisible(false) return end
					if not (text == '') then body:SetVisible(false) bodys:SetVisible(true) end

					local isSteamID = string.match(text, "STEAM_[0-5]:[0-9]:[0-9]+")
					if text == isSteamID then
						text = util.SteamIDTo64(text)
					end
					textEntrye = text

					page = 0
					refreshSearch(0)
				end
				-- function search_entry:OnValueChange(text)
                --     local clear
                --     if text == "" then
                --         clear = true
                --         bottom_panel:SetVisible(true)
                --         body:SetVisible(true)
                --         bodys:Clear()
				-- 	end

                --     if text == nil then
                --         bodys:Clear()
				-- 		text = self:GetValue()
				-- 	end
				-- 	if text ~= "" then
   
				-- 		body:ClearSelection()
				-- 	end
                    
                --     -- if not IsValid(linesd) and not clear then
                --     --     body:SetVisible(false)
                --     -- end

                --     text = text:lower()
				-- 	for i, line in ipairs(lines) do
				-- 		local ply = line.ply
                        
                --         if ply then
				-- 		    line:SetVisible(check_text_match(text, ply))
                --         end
				-- 	end
				-- 	body:GetCanvas():InvalidateLayout(true)
				-- 	bodys:GetCanvas():InvalidateLayout(true)

				-- end


				function refreshSearch(page)
					net.Start('GetAllBan')
					if textEntrye == nil then textEntrye = '' end
					net.WriteString(textEntrye)
					net.WriteUInt(page,32)
					net.SendToServer()

					bodys:Clear()
				end
				function refresh(page)
					net.Start('GetBanTable')
					net.WriteUInt(page,32)
				 	net.SendToServer()	
					body:Clear()
				end
				refresh(page)

				net.Receive('GetBanTable',function()
					pages = net.ReadUInt(32) / 10
					pages = math.floor(pages)
					plages = pages
					local cache = net.ReadTable()
					for _, baninfo in ipairs( cache ) do

						line = body:Add("SAM.PlayerLine")
						line:DockMargin(0, 0, 0, 6)
						local parts = string.Explode("(", baninfo.admin)
						local name = parts[1]
						line:SetInfo({
							steamid = util.SteamIDFrom64(baninfo.steamid),
							name = baninfo.name,
							rank = name
						})

						local time
						if baninfo.unban == '0' then
							time = 'Никогда'
						else
							time = os.date( "%H:%M:%S - %d/%m/%Y" , baninfo.unban )
						end
							
						line.Paint = function(self,w,h)
							draw.SimpleText(time,'RM_18',weight(360),h/2,Color(255,255,255,75),0,1)
							draw.SimpleText(baninfo.reason,'RM_18',weight(552),h/2,Color(255,255,255,75),0,1)
							draw.RoundedBox(0,0,h-1,w,1,Color(255,255,255,2))
						end
						local avatar = vgui.Create("fam_avatar", line)
						avatar:SetPos(0, 0)
						avatar:SetSize(line:GetTall(), line:GetTall())
						avatar:SetSteamID(baninfo.steamid, 184)

						local but = line:Actions()
						but.v = baninfo
						but:On("DoClick", ban_click)

						line.ply = baninfo
                        line.line = line
                        line.id = table.insert(lines, line)
					end
				end)

               net.Receive('GetAllBan',function()
					pages = net.ReadUInt(32) / 10
					pages = math.floor(pages)
					body:SetVisible(false)
					local data = net.ReadTable()
                    for _,baninfo in pairs(data) do
                        linesd = bodys:Add("SAM.PlayerLine")
						linesd:DockMargin(0, 0, 0, 6)
						local parts = string.Explode("(", baninfo.admin)
						local name = parts[1]
						linesd:SetInfo({
							steamid = util.SteamIDFrom64(baninfo.steamid),
							name = baninfo.name,
							rank = name
						})
						
                        local time
						if baninfo.unban == '0' then
							time = 'Никогда'
						else
							time = os.date( "%H:%M:%S - %d/%m/%Y" , baninfo.unban )
						end
                        linesd.Paint = function(self,w,h)
							draw.SimpleText(time,'RM_18',weight(360),h/2,Color(255,255,255,75),0,1)
							draw.SimpleText(baninfo.reason,'RM_18',weight(552),h/2,Color(255,255,255,75),0,1)
                            draw.RoundedBox(0,0,h-1,w,1,Color(255,255,255,2))
						end

						local avatar = vgui.Create("fam_avatar", linesd)
						avatar:SetPos(0, 0)
						avatar:SetSize(line:GetTall(), line:GetTall())
						avatar:SetSteamID(baninfo.steamid, 184)

						local but = linesd:Actions()
						but.v = baninfo
						but:On("DoClick", ban_click)
                    end
                end)
			end
		end
	end

	local selected = 1
	local cats = {
		{
			name = 'Команды',
			icon = material1,
			doclick = function()
				openCategory('Команды')
				selected = 1
			end
		},
		{
			name = 'Игроки',
			icon = material2,
			doclick = function()
				openCategory('Игроки')
				selected = 2
			end
		},
		{
			name = 'Баны',
			icon = material3,
			doclick = function()
				openCategory('Баны')
				selected = 3
			end
		},		
	}
	openCategory('Команды')
	
	local space = height(37)
	for k,v in ipairs(cats) do
		if LocalPlayer():GetUserGroup() == "user" then
			if k == 2 then
				return
			end
		end
		if LocalPlayer():GetUserGroup() ~= 'superadmin' and LocalPlayer():GetUserGroup() ~= 'uprav' and LocalPlayer():GetUserGroup() ~= 'manager' then
			if k==3 then
				return
			end
		end
		
		local buts = vgui.Create('DButton',sam_menu)
		buts:SetSize(weight(57),height(57))
		buts:SetPos(0,space)
		buts:SetText('')
		buts.Paint = function(self,w,h)
			if self.Hovered or selected == k then
				draw.RoundedBox(0,0,0,w,h,Color(200, 200, 200, 60))
			end
			surface.SetMaterial( v.icon )
			surface.SetDrawColor( 255, 255, 255 )
			surface.DrawTexturedRect( weight(9), height(10), weight(40), height(40) )
		end
		buts.DoClick = v.doclick
		space = space + height(57) + height(1)
	end
end

concommand.Add('AdminMenu', main)
--PATH addons/_adminmodules_menu/lua/includes/modules/sui.lua:
if sui then return end

AddCSLuaFile()

sui = {}

do
	local wspace_chs = {} -- whitespace  characters except a normal space " "
	for k, v in ipairs({0x0c, 0x0a, 0x0d, 0x09, 0x0b}) do
		wspace_chs[string.char(v)] = true
	end
	sui.wspace_chs = wspace_chs

	local cntrl_chs = {string.char(0x7f)} -- control characters
	for i = 0x00, 0x1f do
		cntrl_chs[string.char(i)] = true
	end
	sui.cntrl_chs = cntrl_chs
end

if SERVER then
	AddCSLuaFile("sui/libs/tdlib/cl_tdlib.lua")
	AddCSLuaFile("sui/libs/bshadows.lua")
	AddCSLuaFile("sui/libs/gif_loader.lua")
	AddCSLuaFile("sui/libs/png_encoder.lua")
	AddCSLuaFile("sui/libs/types.lua")
	AddCSLuaFile("sui/cl_base.lua")
else
	include("sui/libs/tdlib/cl_tdlib.lua")
	include("sui/libs/bshadows.lua")
	include("sui/libs/types.lua")
	include("sui/cl_base.lua")
end

if SERVER then
	for _, f in ipairs(file.Find("sui/vgui/*.lua", "LUA")) do
		AddCSLuaFile("sui/vgui/" .. f)
	end
end
--PATH addons/_adminmodules_menu/lua/sui/libs/gif_loader.lua:
local byte = string.byte
local sub = string.sub
local lshift = bit.lshift
local rshift = bit.rshift
local bor = bit.bor
local band = bit.band

local GIFDecoder = {}
local GIFDecoderMethods = {}
local GIFDecoder_meta = {__index = GIFDecoderMethods}

function GIFDecoder.new(buf)
	local buf_n = #buf
	local this = setmetatable({
		p = 1,
		buf = buf
	}, GIFDecoder_meta)

	local version = this:read(6)
	assert(version == "GIF89a" or version == "GIF87a", "wrong file format")

	this.width = this:word()
	this.height = this:word()

	local pf0 = this:byte()
	local global_palette_flag = rshift(pf0, 7)
	local num_global_colors_pow2 = band(pf0, 0x7)
	local num_global_colors = lshift(1, num_global_colors_pow2 + 1)
	this:skip(2)

	local global_palette_offset = nil
	local global_palette_size = nil

	if global_palette_flag > 0 then
		global_palette_offset = this.p
		this.global_palette_offset = global_palette_offset
		global_palette_size = num_global_colors
		this:skip(num_global_colors * 3)
	end

	local no_eof = true

	local frames = {}

	local delay = 0
	local transparent_index = nil
	local disposal = 1

	while no_eof and this.p <= buf_n do
		local b = this:byte()
		if b == 0x3b then
			no_eof = false
		elseif b == 0x2c then
			local x, y, w, h = this:word(), this:word(), this:word(), this:word()
			local pf2 = this:byte()
			local local_palette_flag = rshift(pf2, 7)
			local interlace_flag = band(rshift(pf2, 6), 1)
			local num_local_colors_pow2 = band(pf2, 0x7)
			local num_local_colors = lshift(1, num_local_colors_pow2 + 1)
			local palette_offset = global_palette_offset
			local palette_size = global_palette_size
			local has_local_palette = false
			if local_palette_flag ~= 0 then
				has_local_palette = true
				palette_offset = this.p
				palette_size = num_local_colors
				this:skip(num_local_colors * 3)
			end

			local data_offset = this.p

			this:skip(1)
			this:skip_eob()

			table.insert(frames, {
				x = x,
				y = y,
				width = w,
				height = h,
				has_local_palette = has_local_palette,
				palette_offset = palette_offset,
				palette_size = palette_size,
				data_offset = data_offset,
				data_length = this.p - data_offset,
				transparent_index = transparent_index,
				interlaced = interlace_flag > 0,
				delay = delay,
				disposal = disposal
			})
		elseif b == 0x21 then
			local b2 = this:byte()
			if b2 == 0xf9 then
				local len, flags = this:bytes(2)
				delay = this:word()
				local transparent, terminator = this:bytes(2)

				assert(len == 4 and terminator == 0, "Invalid graphics extension block.")

				if flags % 2 == 1 then
					transparent_index = transparent
				else
					transparent_index = nil
				end

				disposal = math.floor(flags / 4) % 8
			elseif b2 == 0xff then
				this:read(this:byte())
				this:skip_eob()
			else
				this:skip_eob()
			end
		end
	end

	this.frames = frames

	return this
end

function GIFDecoderMethods:skip(offset)
	self.p = self.p + offset
end

-- skip to end of block
function GIFDecoderMethods:skip_eob()
	repeat
		local size = self:byte()
		self:skip(size)
	until size == 0
end

function GIFDecoderMethods:byte()
	local b = byte(self.buf, self.p)
	self:skip(1)
	return b
end

function GIFDecoderMethods:bytes(len)
	local _p = self.p
	self:skip(len)
	return byte(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:read(len)
	local _p = self.p
	self:skip(len)
	return sub(self.buf, _p, len + _p - 1)
end

function GIFDecoderMethods:word()
	return bor(self:byte(), lshift(self:byte(), 8))
end

local GifReaderLZWOutputIndexStream = function(this, output, output_length)
	local min_code_size = this:byte()
	local clear_code = lshift(1, min_code_size)
	local eoi_code = clear_code + 1
	local next_code = eoi_code + 1
	local cur_code_size = min_code_size + 1

	local code_mask = lshift(1, cur_code_size) - 1
	local cur_shift = 0
	local cur = 0
	local op = 0

	local subblock_size = this:byte()

	local code_table = {}

	local prev_code = nil

	while true do
		while cur_shift < 16 do
			if subblock_size == 0 then break end

			cur = bor(cur, lshift(this:byte(), cur_shift))
			cur_shift = cur_shift + 8

			if subblock_size == 1 then
				subblock_size = this:byte()
			else
				subblock_size = subblock_size - 1
			end
		end

		if cur_shift < cur_code_size then break end

		local code = band(cur, code_mask)
		cur = rshift(cur, cur_code_size)
		cur_shift = cur_shift - cur_code_size

		if code == clear_code then
			next_code = eoi_code + 1
			cur_code_size = min_code_size + 1
			code_mask = lshift(1, cur_code_size) - 1

			prev_code = null
			continue
		elseif code == eoi_code then
			break
		end

		local chase_code = code < next_code and code or prev_code
		local chase_length = 0
		local chase = chase_code
		while chase > clear_code do
			chase = rshift(code_table[chase], 8)
			chase_length = chase_length + 1
		end

		local k = chase
		local op_end = op + chase_length + (chase_code ~= code and 1 or 0)
		if op_end > output_length then
			Error("Warning, gif stream longer than expected.")
			return
		end

		output[op] = k; op = op + 1
		op = op + chase_length

		local b = op

		if chase_code ~= code then
			output[op] = k; op = op + 1
		end
		chase = chase_code

		while chase_length > 0 do
			chase_length = chase_length - 1
			chase = code_table[chase]
			b = b - 1
			output[b] = band(chase, 0xff)

			chase = rshift(chase, 8)
		end

		if prev_code ~= nil and next_code < 4096 then
			code_table[next_code] = bor(lshift(prev_code, 8), k)
			next_code = next_code + 1

			if next_code >= code_mask + 1 and cur_code_size < 12 then
				cur_code_size = cur_code_size + 1
				code_mask = bor(lshift(code_mask, 1), 1)
			end
		end

		prev_code = code
	end

	if op ~= output_length then
		Error("Warning, gif stream shorter than expected.")
	end

	return output
end

function GIFDecoderMethods:decode_and_blit_frame_RGBA(frame_num, pixels)
	local frame = self.frames[frame_num]
	local num_pixels = frame.width * frame.height
	local index_stream = {}

	self.p = frame.data_offset
	GifReaderLZWOutputIndexStream(self, index_stream, num_pixels)
	local palette_offset = frame.palette_offset

	local trans = frame.transparent_index
	if trans == nil then
		trans = 256
	end

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local buf = self.buf
	while i < num_pixels do
		local index = index_stream[i]

		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		if index ~= trans then
			index = palette_offset + index * 3
			pixels[op + 0] = byte(buf, index)
			pixels[op + 1] = byte(buf, index + 1)
			pixels[op + 2] = byte(buf, index + 2)
			pixels[op + 3] = 255
		end

		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:clear_frame(frame_num, pixels)
	local frame = self.frames[frame_num]

	self.p = frame.data_offset

	local width = self.width
	local framewidth = frame.width
	local framestride = width - framewidth
	local xleft = framewidth

	local opbeg = (frame.y * width + frame.x) * 4

	local opend = ((frame.y + frame.height) * width + frame.x) * 4
	local op = opbeg
	local scanstride = framestride * 4

	if frame.interlaced == true then
		scanstride = scanstride + (width * 4 * 7)
	end

	local interlaceskip = 8

	local i = 0
	local num_pixels = frame.width * frame.height
	while i < num_pixels do
		if xleft == 0 then
			op = op + scanstride
			xleft = framewidth

			if op >= opend then
				scanstride =
					framestride * 4 + width * 4 * (interlaceskip - 1)

				op =
					opbeg +
					(framewidth + framestride) * lshift(interlaceskip, 1)
				interlaceskip = rshift(interlaceskip, 1)
			end
		end

		pixels[op + 0] = 0
		pixels[op + 1] = 0
		pixels[op + 2] = 0
		pixels[op + 3] = 0
		op = op + 4

		xleft = xleft - 1
		i = i + 1
	end
end

function GIFDecoderMethods:get_frames()
	local num_pixels = self.width * self.height * 4 + 4
	local frames = {}
	local numFrames = #self.frames
	local last_frame
	local restore_from
	for i = 1, numFrames do
		local frame = self.frames[i]

		local data = {}

		if last_frame then
			local _data = last_frame.data
			for k = 0, num_pixels do
				data[k] = _data[k]
			end
		end

		if i > 1 then
			local last_disposal = last_frame.disposal
			if last_disposal == 3 then
				if restore_from then
					for k = 0, num_pixels do
						data[k] = restore_from[k]
					end
				else
					self:clear_frame(i - 1, data)
				end
			end

			if last_disposal == 2 then
				self:clear_frame(i - 1, data)
			end
		end

		self:decode_and_blit_frame_RGBA(i, data)

		local delay = frame.delay
		if delay < 2 then
			delay = 10
		end

		local disposal = frame.disposal
		last_frame = {
			data = data,
			delay = delay,
			disposal = disposal
		}
		frames[i] = last_frame

		if disposal ~= 3 then
			restore_from = data
		end
	end

	return frames
end

return GIFDecoder.new
--PATH addons/_adminmodules_menu/lua/sui/vgui/sui_label_panel.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local LABEL_FONT = SUI.CreateFont("LabelPanel", "Roboto", 18)

local PANEL = {}

local add = function(s, c)
	if IsValid(s.pnl) then
		s.pnl:Remove()
	end

	local pnl = vgui.Create(c, s)
	s.pnl = pnl

	return pnl
end

function PANEL:Init()
	self.title = ""

	local label = self:Add(NAME .. ".Label")
	label:Dock(LEFT)
	self.label = label

	self:SetFont(LABEL_FONT)

	self:Dock(TOP)
	self:InvalidateLayout(true)
	self.Add = add
end

function PANEL:SetPanel(pnl)
	if IsValid(self.pnl) then
		self.pnl:Remove()
	end

	pnl:SetParent(self)
	self.pnl = pnl
end

function PANEL:SetLabel(lbl)
	self.title = lbl
	self:InvalidateLayout(true)
end

function PANEL:SetFont(font)
	self.font = font
	self.label:SetFont(font)
end

function PANEL:PerformLayout(w, h)
	local label = self.label
	local pnl = self.pnl

	local pnl_w, pnl_h = 0, 0
	if pnl then
		pnl_w, pnl_h = pnl:GetSize()
	end

	label:SetWide(w - pnl_w - 4)
	label:SetText(sui.wrap_text(self.title, self.font, w - pnl_w - 4))

	local _, _h = label:GetTextSize()
	self:SetTall(math.max(_h, pnl_h))

	if pnl then
		pnl:SetPos(w - pnl_w, h / 2 - pnl_h / 2)
	end
end

sui.register("LabelPanel", PANEL, "PANEL")
--PATH addons/_adminmodules_menu/lua/sui/vgui/sui_slider.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

AccessorFunc(Panel, "m_bValue", "Value", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMin", "Min", FORCE_NUMBER)
AccessorFunc(Panel, "m_bMax", "Max", FORCE_NUMBER)
AccessorFunc(Panel, "m_bDecimals", "Decimals", FORCE_NUMBER)

function Panel:Init()
	self:ScaleInit()

	self:SetMin(0)
	self:SetMax(10)
	self:SetValue(1)
	self:SetDecimals(1)

	self:SetSize(100, 12)

	self.rounded_box = {}

	self.Knob.circle = {}
	self.Knob.Paint = self.KnobPaint
	self:SetTrapInside(true)
end

function Panel:SetMinMax(min, max)
	self:SetMin(min)
	self:SetMax(max)
end

function Panel:TranslateValues(x, y)
	self:SetValue(self:GetMin() + (x * self:GetRange()))
	return self:GetFraction(), y
end

function Panel:GetFraction()
	return (self:GetValue() - self:GetMin()) / self:GetRange()
end

function Panel:SetValue(val)
	val = math.Clamp(val, self:GetMin(), self:GetMax())
	val = math.Round(val, self:GetDecimals())

	self.m_bValue = val
	self:SetSlideX((val - self:GetMin()) / self:GetRange())

	self:OnValueChanged(val)
end

function Panel:OnValueChanged(val)
end

function Panel:GetRange()
	return self:GetMax() - self:GetMin()
end

function Panel:Paint(w, h)
	local _h = SUI.Scale(2)
	TDLib.RoundedBox(self.rounded_box, 3, 0, h / 2 - _h / 2, w, _h, SUI.GetColor("slider_track"))
end

function Panel:KnobPaint(w, h)
	if self.Depressed then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_pressed"))
	elseif self.Hovered then
		TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 1.1, SUI.GetColor("slider_hover"))
	end

	TDLib.DrawCircle(self.circle, w / 2, h / 2, h / 2, SUI.GetColor("slider_knob"))
end

function Panel:PerformLayout(w, h)
	self.Knob:SetSize(SUI.Scale(12), SUI.Scale(12))
	DSlider.PerformLayout(self, w, h)
end

sui.register("Slider", Panel, "DSlider")
--PATH addons/111mod/lua/autorun/sh_credits.lua:
if CLIENT then
	local blur = Material("pp/blurscreen")
	function framework(panel, amount)
		local x, y = panel:LocalToScreen(0, 0)
		local scrW, scrH = ScrW(), ScrH()
	
		surface.SetDrawColor(255, 255, 255)
		surface.SetMaterial(blur)
		for i = 1, 3 do
			blur:SetFloat("$blur", (i / 3) * (amount or 6))
			blur:Recompute()
			render.UpdateScreenEffectTexture()
			surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
		end
	end
	
	function frametext(text, font, x, y, color, x_a, y_a, color_shadow)
	    color_shadow = color_shadow or Color(0, 0, 0)
	    draw.SimpleText(text, font, x + 1, y + 1, color_shadow, x_a, y_a)
	    local w,h = draw.SimpleText(text, font, x, y, color, x_a, y_a)
	    return w,h
	end
	
	local credits = {
		{
		n = "Arthur",
		d = "Батя",
		steam = "https://steamcommunity.com/id/ravenbutt/",
		vk = "https://vk.com/mcstark",
		color = Color(255,155,55),
		}
	}
	
	surface.CreateFont("travka.btn", {
	    font = "Roboto",
	    size = ScreenScale(8),
	    weight = 1000,
	    extended = true
	})
	function gambitcredits()
		local dframe = vgui.Create("DFrame")
		dframe:SetSize(ScrW() * .40, ScrH() * .4)
		dframe:Center()
		dframe:SetTitle("")
		dframe:ShowCloseButton(false)
		dframe:MakePopup()
		dframe:SetAlpha(0)
		dframe:AlphaTo(255, 0.2)
		local tallbal = ScrH() * .4 * .067
		dframe.Paint = function(self, w, h)
		    framework(self, 5)
		    draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 150))
		    draw.RoundedBox(0, 0, 0, w, tallbal, Color(0, 0, 0, 200))
		    draw.RoundedBox(0, 0, h - tallbal, w, tallbal, Color(0, 0, 0, 200))
		    frametext("GambitRP Credits", "travka.btn", w * .5, tallbal * .5, Color(255, 255, 255), 1, 1)
		end
		
		local main_hide = vgui.Create("DButton", dframe)
		main_hide:SetSize(tallbal - 4, tallbal - 4)
		main_hide:SetPos(ScrW() * .40 - tallbal + 2, 2)
		main_hide:SetText("")
		main_hide.Paint = function(this, w, h)
		    if (this.Depressed or this.m_bSelected) then
		        draw.RoundedBox(0, 0, 0, w, h, Color(255, 155, 55, 150))
		    elseif (this.Hovered) then
		        draw.RoundedBox(0, 0, 0, w, h, Color(255, 155, 55, 75))
		    else
		        draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 150))
		    end
		
		    frametext("X", "travka.btn", w * .5, h * .5, Color(255, 255, 255), 1, 1)
		end
		main_hide.DoClick = function(self)
		    surface.PlaySound("garrysmod/ui_click.wav")
		
		    dframe:AlphaTo(0, 0.2, 0, function()
		        if IsValid(dframe) then
		            dframe:Remove()
		        end
		    end)
		end
		
		local Scroll = vgui.Create( "DScrollPanel", dframe )
		Scroll:Dock( FILL )
		Scroll:DockMargin(0,3,0,0)
		Scroll.Paint = function(self, w, h)
		    draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100))
		end
		Scroll.VBar:SetWide(3)
		Scroll:DockMargin(0, 0, 0, 0)
		
		local bar = Scroll.VBar
		bar:SetHideButtons( true )
		bar.Paint = function(this, w, h)        
		end
		bar.btnUp.Paint = function(this, w, h)
		end
		bar.btnDown.Paint = function(this, w, h)
		end
		
		local mocha = {"Моча","Жопа","Член"}
		
		local List = vgui.Create( "DIconLayout", Scroll )
		List:Dock( FILL )
		List:SetSpaceY( 5 )
		List:SetSpaceX( 5 )
		List.Paint = function(self,w,h)
		    draw.RoundedBox(0,0,0,w,h,Color(35,64,100,170))
		end
		for k,v in pairs(credits) do
			local credits = Scroll:Add("DButton")
			credits:Dock(TOP)
			credits:SetTall(26)
			credits:DockMargin(5, 2.5, 5, 0)
			credits:SetText("")
			credits.Paint = function(this, w, h)
				if (this.Depressed or this.m_bSelected) then
			    	draw.RoundedBox(0, 0, 0, w, h, Color(255, 155, 55, 150))
				elseif (this.Hovered) then
			    	draw.RoundedBox(0, 0, 0, w, h, Color(255, 155, 55, 75))
				else
			    	draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 150))
				end
				frametext(v.n, "travka.btn", w * .1, h * .5, v.color, 1, 1)
				frametext(v.d, "travka.btn", w * .5, h * .5, Color(255, 255, 255), 1, 1)
			end
			credits.DoClick = function()
			    local dmenu = DermaMenu()
		       	dmenu:AddOption("Открыть профиль STEAM",function()
		       		gui.OpenURL(v.steam)
		       	end):SetIcon( "icon16/photo.png" )
		       	dmenu:AddOption("Открыть профиль VK",function()
		       		gui.OpenURL(v.vk)
		       	end):SetIcon( "icon16/photo.png" )
		       	dmenu:AddOption("Отменить",function()
		       		dmenu:Remove()
		       	end):SetIcon( "icon16/cancel.png" )
		       	dmenu:Open()
		    end
		end
	end
end

if SERVER then
	hook.Add("PlayerSay","gambitcredits",function(ply,txt)
		local cmd = string.match(string.lower(txt),"^([!/~.])owners")
		if cmd then
	    	ply:SendLua('gambitcredits()')
			return ""
		end
	end)
end
--PATH addons/duels/lua/autorun/sh_init.lua:
local meta = FindMetaTable("Player")

duelsystem = duelsystem or {}

duelsystem.config = {}
duelsystem.config.playerfindradius = 500
duelsystem.config.toprefresh = 300
duelsystem.config.weaponblacklist = {
["heavy_shield"] = true,
["weapon_ciga"] = true,
["weapon_adv_keys"] = true,
["cocaine_repair_wrench"] = true,
["med_kit"] = true,
["arrest_stick"] = true,
["arrest_stick1"] = true,
["door_ram"] = true,
["unarrest_stick"] = true,
["moneychecker"] = true,
["dsr_battering_ram"] = true,
["dsr_lockpick"] = true,
["dsr_taser"] = true,
["bag_money"] = true,
["weapon_cuff_rope"] = true,
["rp_box_in_hands"] = true,
["ultimate_disguise_kit"] = true,
["cuff"] = true,
["weapon_fidget"] = true,
["weapon_bugbait"] = true,
["weapon_physcannon"] = true,
["gmod_camera"] = true,
["weapon_medkit"] = true,
["gmod_tool"] = true,
["weapon_physgun"] = true,
["itemstore_pickup"] = true,
["swep_disguise_briefcase"] = true,
["lockpick"] = true,
["weapon_pet"] = true,
["itemstore_checker"] = true,
["weaponchecker"] = true,
["nalogswep"] = true,
["weapon_flashgrenade"] = true,
["weapon_parkour"] = true,
["weapon_vape_american"] = true,
["weapon_vape_butterfly"] = true,
["weapon_vape_custom"] = true,
["weapon_vape_golden"] = true,
["weapon_vape_hallucinogenic"] = true,
["weapon_vape_juicy"] = true,
["weapon_vape_medicinal"] = true,
["weapon_vape"] = true,
["zwf_bong01"] = true,
["zwf_bong03"] = true,
["zwf_bong02"] = true,
["zwf_cable"] = true,
["zwf_wateringcan"] = true,
["zwf_shoptablet"] = true,
["zck_snowballswep"] = true,
["passrus"] = true,
["pass_rus"] = true,
["wrench_deluxe"] = true,
["keypad_cracker"] = true,
}
duelsystem.config.bet = {min = 100, max = 100000}
duelsystem.config.arenalist = {
	{
        name = "Арена 1",
        available = true,
        positions = { Vector(946, -6131, 797 ), Vector(1017, -6843, 776) } 
    },
    {
        name = "Арена 2",
        available = true,
        positions = { Vector(-86, -6835, 807), Vector(-134, -6124, 778) }
    },
    {
        name = "Арена 3",
        available = true,
        positions = { Vector(-140, -7273, 782), Vector(-76, -7999, 777) }
    },
    {
        name = "Арена 4",
        available = true,
        positions = { Vector(1010, -7987, 783), Vector(955, -7256, 778) }
    }
}

function meta:GetMatchData()
	return self:GetNetVar("duels::player::matchdata") or {}
end

function meta:GetInDuel()
	return self:GetNetVar("duels::player::induel") or false
end

function meta:DuelData()
	return self:GetNetVar("duels::player::dueldata") or {wins = 0, loses = 0}
end

function GetDuelTop()
	return nw.GetGlobal("duels::top") or {}
end

nw.Register "duels::top"
	:Read(net.ReadTable)
	:Write(net.WriteTable)
	:SetGlobal()

nw.Register "duels::player::induel"
	:Read(net.ReadBool)
	:Write(net.WriteBool)
	:SetPlayer()

nw.Register "duels::player::dueldata"
	:Read(net.ReadTable)
	:Write(net.WriteTable)
	:SetPlayer()

nw.Register "duels::player::matchdata"
	:Read(net.ReadTable)
	:Write(net.WriteTable)
	:SetPlayer()

	
--PATH addons/donate3/lua/autorun/sh_shop.lua:
-- local server_ip = game.GetIPAddress()

local PMeta = FindMetaTable('Player')
function PMeta:rayShopCredits()
    return self.ray_shop_credits
end

ray_shop = {}
ray_shop.data = {}
local seconds_in_month = ( ( 60 * 60 ) * 24 ) * 30
ray_shop.shop_url = "https://qiwi.me/" // PUT YOUR WEB ROOT SHOP OF THIS
// MAKE SURE SHOP_URL DOESN'T HAVE A / AT THE END, IT HAS TO BE 'url.com/shop' NOT 'url.com/shop/'


// WE DO THIS SO THE CLIENT CANT SNOOP THE PASSWORD,
// just set the text inside data/simplepay_password.txt of the addon

ray_shop.pass = file.Read("simplepay_password.txt", "DATA") or "" // PLEASE CHANGE THIS FOR YOUR OWN.
// THIS PASS IS INCLUDED IN THE HTTP, MAKE SURE ITS
// THE SAME AS THE pass in the web config

ray_shop.frame_title = "Донат" // frame name
ray_shop.currency = "кредитов" // currency name

ray_shop.command = { // chat commands you can write
	"!donate",
	"!shop",
	"!донат",
	"!магазин",
}

local image78 = Material('donate/image78.png','noclamp smooth')
local tiho = Material('donate/5tihoss.png','noclamp smooth')
local patrons = Material('donate/10patronss.png','noclamp smooth')
local props = Material('donate/50propss.png','noclamp smooth')
local armor = Material('donate/100armors.png','noclamp smooth')
local eda = Material('donate/edas.png','noclamp smooth')
local gmb = Material('donate/gmbs.png','noclamp smooth')
local gmbp = Material('donate/gmbp.png','noclamp smooth')
local head = Material('donate/heads.png','noclamp smooth')
local infammo = Material('donate/infammos.png','noclamp smooth')
local maker = Material('donate/makers.png','noclamp smooth')
local moder = Material('donate/moders.png','noclamp smooth')
local owne = Material('donate/ownes.png','noclamp smooth')
local predator = Material('donate/predators.png','noclamp smooth')
local premadm = Material('donate/premadms.png','noclamp smooth')
local runngun = Material('donate/runnguns.png','noclamp smooth')
local say = Material('donate/says.png','noclamp smooth')
local sit = Material('donate/sits.png','noclamp smooth')
local sponsor = Material('donate/sponsors.png','noclamp smooth')
local vert = Material('donate/verts.png','noclamp smooth')
local vip = Material('donate/vips.png','noclamp smooth')
local zayka = Material('donate/zaykas.png','noclamp smooth')
local zomb = Material('donate/zombs.png','noclamp smooth')
local pass = Material('donate/pass.png','noclamp smooth')

function ray_shop:add( tab )
	table.insert( self.data, tab )
end
local function HaveVert()
	local have = false
	for k,v in ents.Iterator() do
		if v.IsHeli then
			have = true
			break
		end
	end
	return have
end
local function IventVertolet(ply)
	if SERVER then
		if IsValid(ply) then
			if !HaveVert() then
				for k,v in player.Iterator() do
					v:ChatPrint(ply:Nick() .. " купил ивент 'Вертолет', бегите в пустыню чтобы получить $$$!")
					v:ChatPrint(ply:Nick() .. " купил ивент 'Вертолет', бегите в пустыню чтобы получить $$$!")
					v:ChatPrint(ply:Nick() .. " купил ивент 'Вертолет', бегите в пустыню чтобы получить $$$!")
				end
				spawnhelicopter( table.Random{Vector(9927, -1146, 422), })
			else
				ply:ChatPrint("Ивент 'Вертолет' уже запущен, ваш имент отложен на некоторое время")
				timer.Simple(60,function()
					if IsValid(ply) then
						IventVertolet(ply)
					end
				end)
			end
		end
	end
end


local function IventZombie(ply)
    if SERVER then
        if IsValid(ply) then
            if !ply.onzombieevent then
                for k,v in player.Iterator() do
                    v:ChatPrint(ply:Nick() .. " купил ивент - Внимание! Начался Зомби ивент! Все фракции должны бороться с зомби")
                    v:ChatPrint(ply:Nick() .. " купил ивент - Внимание! Начался Зомби ивент! Все фракции должны бороться с зомби")
                    v:ChatPrint(ply:Nick() .. " купил ивент - Внимание! Начался Зомби ивент! Все фракции должны бороться с зомби")
                end

                StartZombieEvent()
            else
                ply:ChatPrint("Ивент 'Зомби Хаус' уже запущен, ваш имент отложен на некоторое время")
                print("Ивент 'Зомби Хаус' уже запущен, ваш имент отложен на некоторое время")
                timer.Simple(300,function()
                    if IsValid(ply) then
                        IventZombie(ply)
                    end
                end)
            end
        end
    end
end

function DonateFindTovar(func)
	for k,v in pairs(ray_shop.data) do
		if v['Purchase'] == func then
			return v
		end
	end
	return nil
end


ray_shop:add({
    Name = "+50 Лимит пропов", // name in the menu
    category = 'Остальное',
    model = 'models/props_junk/wood_crate001a.mdl',
    Price = 399, // price in credits
    mat = props,
    Purchase = function( ply )
        if SERVER then 
            local myprop = tonumber(ply:GetPData('limitpropsed',0))
            if myprop >= 10 then
                ply:ChatPrint("Вы купили максимальное количество пропов")
                return false
            end
            ply:SetPData('limitpropsed', myprop+1) 
            local myprop = tonumber(ply:GetPData('limitpropsed',0))
            ply:ChatPrint("Вы купили " .. myprop .. '/10 к лимиту пропов')
            ply:ChatPrint("Ваш лимит пропов увеличен на 50 пропов")
        end
    end,
    //description to provide
    Description = [[
Дополнительный лимит пропов поможет детальней
построить свою базу, по этому стоит его купить.
Вы можете купить 10 раз эту услугу!
]],
})

function encodeURI(str)
	if (str) then
		str = string.gsub (str, "\n", "\r\n")
		str = string.gsub (str, "([^%w ])",
			function (c) return string.format ("%%%02X", string.byte(c)) end)
		str = string.gsub (str, " ", "+")
	end
	return str
end
	
function decodeURI(s)
	if(s) then
		s = string.gsub(s, '%%(%x%x)', 
		function (hex) return string.char(tonumber(hex,16)) end )
	end
	return s
end

ray_shop:add({
    Name = "BP Премиум",
    category = 'Остальное', -- изменить если надо
    Price = 1200,
    model = 'models/player/skeleton.mdl', -- изменить если надо
	mat = pass,
    Purchase = function( ply )
        if SERVER then
			encbp.bp.BuyPrem(ply)
            ply:ChatPrint("Поздравляем с приобретением премиум доступа! ")
        end
    end,
    Description = [[
Откроет доступ к новым наградам в батлпассе
    ]]
})

ray_shop:add({
	Name = "Говорилка", // name in the menu
	category = 'Остальное',
	model = 'models/props_wasteland/speakercluster01a.mdl',
	mat = say,
	Price = 499, // price in credits
	Purchase = function( ply )
		if SERVER then ply:SetPData('voicerchat', 1) ply:SetNW2Bool('voicerchat', true) end
		ply:SendLua([[sound.PlayURL('https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q=' .. encodeURI("Вы приобрели говорилку!") ..'&tl=ru','2d',function(station)
			if IsValid(station) then
				station:SetVolume(.5)
				station:Play()
			end
		end)]])
	end,
	//description to provide
	Description = [[
Озвучивает всё что вы пишите в чате
Чтобы отключить её, напишите /voiceswitch
]],
})

if CLIENT then
	local function tts(txt, pl)
		if not pl:GetNW2Bool("voicerchat") then return end

		pl.NextPlayTTS = pl.NextPlayTTS or 0
		if pl.NextPlayTTS and CurTime() > pl.NextPlayTTS then
			sound.PlayURL('https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q=' .. encodeURI(txt) ..'&tl=ru','2d',function(station)
				if IsValid(station) then
					station:SetVolume(.5)
					station:Play()
					pl.NextPlayTTS = CurTime() + station:GetLength()
				end
			end)
		end
	end

	hook.Add("OnPlayerChat", "voicerChat", function(pl, txt)
		tts(txt, pl)
	end)
else
	hook.Add("PlayerInitialSpawn", "giveGovorilka", function(pl)
		if pl:GetPData('voicerchat') == '1' then
			pl:SetNW2Bool('voicerchat', true)
		end
	end)

	hook.Add( "PlayerSay", "enableTTS", function( ply, text )
		if ( string.lower( text ) == "/voiceswitch" ) then
			if ply:GetPData('voicerchat') ~= '1' then return end

			if ply:GetNW2Bool("voicerchat") then
				ply:SetNW2Bool("voicerchat", false)
				ply:ChatPrint("Вы выключили говорилку!")
			else
				ply:SetNW2Bool("voicerchat", true)
				ply:ChatPrint("Вы включили говорилку!")
			end

			return ""
		end
	end )
end

ray_shop:add({
	Name = "Run'n'Gun",
	category = 'Остальное',
	Price = 245,
	mat =runngun,
	model = 'models/player/skeleton.mdl',
	Purchase = function( ply )
		if SERVER then
			ply:SetNW2Bool('donate_upgrade_runngun', true)
			ply:SetPData('rungun', 1)
			ply:ChatPrint("Поздравляем с приобретением улучшения! ")
		end
	end,
	Description = [[
Позволяет вам стрелять во время бега
Команда для вкл/выкл !rungun
	]]
})

ray_shop:add({
	Name = "+100% Бесшумности",
	color = Color(147,255,147),
	category = 'Остальное',
	Price = 300,
	mat = tiho,
	model = 'models/props_c17/TrapPropeller_Lever.mdl',
	Purchase = function( ply )
		if SERVER then
			ply:SetPData("glushitel", 1)
			ply:SetNW2Int("glushitel", 1)
			ply:ChatPrint("Поздравляем с покупкой +100% Бесшумности!")
		end
	end,
	Description = [[
Все ваше оружие будет стрелять бесшумно
КОМАНДА !глушак в чат
	]]
})

ray_shop:add({
	Name = "Бесконечные патроны",
	color = Color(255,217,102),
	category = 'Остальное',
	Price = 699,
	mat = infammo,
	model = 'models/player/guerilla.mdl',
	Purchase = function( ply )
		if SERVER then
			ply:SetPData('infammo', true)
			InfiniteAmmoPlayers[ply] = true
		end
	end,
	Description = [[
Почуствуй себя владельцем станкового пулемёта
и не трать время на покупку патронов.
Твои противники будут в ужасе.
	]]
})

ray_shop:add({
	Name = "+10 Специальных Патронов", // name in the menu
	category = 'Остальное',
	model = 'models/Items/BoxMRounds.mdl',
	mat = patrons,
	Price = 50, // price in credits
	Purchase = function( ply )
		if SERVER then ply:SetPData('specialammo',tonumber(ply:GetPData('specialammo',0)) + 10) ply:SetNW2Int('specialammo',tonumber(ply:GetNW2Int('specialammo',0)) + 10) end
		ply:ChatPrint("Вы приобрели +10 патронов")
		ply:ChatPrint("Умрите,возродитесь, или перезайдите чтобы патроны выдались")
	end,
	//description to provide
	Description = [[
10 спец патронов могут тебе помочь защитить свою 
базу от неприятеля. Вам будет выдаваться 10
патрона на Арбалет,гранат,мина
Вы можете покупать патроны бесконечно раз
]],
})

ray_shop:add({
	Name = "ИВЕНТ 'Вертолет'",
	color = Color(147,255,147),
	category = 'Остальное',
	Price = 19,
	mat = vert,
	model = 'models/Combine_Helicopter.mdl',
	Purchase = function( ply )
		IventVertolet(ply)
	end,
	Description = [[
Спаунится вертолёт в пустыне - разрушив его игроки в радиусе получают деньги
	]]
})

-------------------------------------------------------------------------
-- УДАЛЯЕМ ДЛЯ ВТОРОГО
	ray_shop:add({
		Name = "ИВЕНТ 'Зомби-хаус'",
		color = Color(147,255,147),
		category = 'Остальное',
		Price = 25,
		mat = zomb,
		model = 'models/zombie/fast_torso.mdl',
		Purchase = function( ply )
			IventZombie(ply)
		end,
		Description = [[
Всем выдается пушки и в городе начинают 
спавнится зомби и мутанты, за убийство 
мутантов вы получаете 500$  
В конце ивента пушка пропадает 
и как в награду выдается 15.000$
		]]
	})
-------------------------------------------------------------------------

ray_shop:add({
	Name = "Катана",
	color = Color(255,217,102),
	category = 'Оружие',
	model = 'models/weapons/w_2b_sword.mdl',
	Price = 3989,
	wep = "weapon_mad_2b",
	Purchase = function( ply )
ply:givePermWep( "weapon_mad_2b" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Катану навсегда
Повышает скорость и умения
В умелых руках становится смертельным оружием!
	]]
})

ray_shop:add({
	Name = "Ковбойка",
	color = Color(255,217,102),
	category = 'Оружие',
	model = 'models/weapons/w_357.mdl',
	Price = 3999,
	wep = "weapon_flechettegun",
	Purchase = function( ply )
ply:givePermWep( "weapon_flechettegun" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Ковбойку навсегда
Сильнейшее оружие на сервере
Пробивает стены и высокий урон
Волшебный эффект выстрела
	]]
})

ray_shop:add({
	Name = "AWP Dragon Lore",
	color = Color(255,217,102),
	category = 'Оружие',
	Price = 1479,
	model = 'models/weapons/w_clout_awp.mdl',
	wep = "awpdragon",
	Purchase = function( ply )
ply:givePermWep( "awpdragon" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете AWP Dragon Lore навсегда
	]]
})

ray_shop:add({
	Name = "Double Barrel",
	category = 'Оружие',
	Price = 4249,
	model = 'models/weapons/w_double_barrel_shotgun.mdl',
	wep = "m9k_dbarrel",
	Purchase = function( ply )
ply:givePermWep( "m9k_dbarrel" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Double Barrel навсегда
	]]
})

ray_shop:add({
	Name = "SPAS 12",
	category = 'Оружие',
	Price = 4399,
	model = 'models/weapons/w_spas_12.mdl',
	wep = "m9k_spas12",
	Purchase = function( ply )
ply:givePermWep( "m9k_spas12" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете SPAS 12 навсегда
	]]
})

ray_shop:add({
	Name = "Barret M82",
	category = 'Оружие',
	Price = 4299,
	model = 'models/weapons/w_barret_m82.mdl',
	wep = "m9k_barret_m82",
	Purchase = function( ply )
ply:givePermWep( "m9k_barret_m82" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Barret M82 навсегда
	]]
})

ray_shop:add({
	Name = "USAS",
	category = 'Оружие',
	Price = 4199,
	model = 'models/weapons/w_usas_12.mdl',
	wep = "m9k_usas",
	Purchase = function( ply )
ply:givePermWep( "m9k_usas" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете USAS навсегда
	]]
})

ray_shop:add({
	Name = "HK SL8",
	category = 'Оружие',
	Price = 3799,
	model = 'models/weapons/w_hk_sl8.mdl',
	wep = "m9k_sl8",
	Purchase = function( ply )
ply:givePermWep( "m9k_sl8" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете HK SL8 навсегда
	]]
})

ray_shop:add({
	Name = "P08 Luger",
	category = 'Оружие',
	Price = 849,
	model = 'models/weapons/w_luger_p08.mdl',
	wep = "m9k_luger",
	Purchase = function( ply )
ply:givePermWep( "m9k_luger" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете P08 Luger навсегда
	]]
})

ray_shop:add({
	Name = "Intervention",
	category = 'Оружие',
	Price = 1299,
	model = 'models/weapons/w_snip_int.mdl',
	wep = "m9k_intervention",
	Purchase = function( ply )
ply:givePermWep( "m9k_intervention" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Intervention навсегда
	]]
})

ray_shop:add({
	Name = "Dragunov SVU",
	category = 'Оружие',
	Price = 3299,
	model = 'models/weapons/w_dragunov_svu.mdl',
	wep = "m9k_svu",
	Purchase = function( ply )
ply:givePermWep( "m9k_svu" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Dragunov SVU навсегда
	]]
})

ray_shop:add({
	Name = "Dragunov SVD",
	category = 'Оружие',
	Price = 3099,
	model = 'models/weapons/w_svd_dragunov.mdl',
	wep = "m9k_dragunov",
	Purchase = function( ply )
ply:givePermWep( "m9k_dragunov" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Dragunov SVD навсегда
	]]
})

ray_shop:add({
	Name = "FG 42",
	category = 'Оружие',
	Price = 2199,
	model = 'models/weapons/w_fg42.mdl',
	wep = "m9k_fg42",
	Purchase = function( ply )
ply:givePermWep( "m9k_fg42" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете FG 42 навсегда
	]]
})

ray_shop:add({
	Name = "Honey Badger",
	category = 'Оружие',
	Price = 899,
	model = 'models/weapons/w_aac_honeybadger.mdl',
	wep = "m9k_honeybadger",
	Purchase = function( ply )
ply:givePermWep( "m9k_honeybadger" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Honey Badger навсегда
	]]
})

ray_shop:add({
	Name = "KAC PDW",
	category = 'Оружие',
	Price = 499,
	model = 'models/weapons/w_kac_pdw.mdl',
	wep = "m9k_kac_pdw",
	Purchase = function( ply )
ply:givePermWep( "m9k_kac_pdw" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете KAC PDW навсегда
	]]
})

ray_shop:add({
	Name = "AS VAL",
	category = 'Оружие',
	Price = 349,
	model = 'models/weapons/w_dmg_vally.mdl',
	wep = "m9k_val",
	Purchase = function( ply )
ply:givePermWep( "m9k_val" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете AS VAL навсегда
	]]
})

ray_shop:add({
	Name = "Vector",
	category = 'Оружие',
	Price = 799,
	model = 'models/weapons/w_kriss_vector.mdl',
	wep = "m9k_vector",
	Purchase = function( ply )
ply:givePermWep( "m9k_vector" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Vector навсегда
	]]
})

ray_shop:add({
	Name = "MP9",
	category = 'Оружие',
	Price = 869,
	model = 'models/weapons/w_brugger_thomet_mp9.mdl',
	wep = "m9k_mp9",
	Purchase = function( ply )
ply:givePermWep( "m9k_mp9" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете MP9 навсегда
	]]
})

ray_shop:add({
	Name = "Tommy Gun",
	category = 'Оружие',
	Price = 799,
	model = 'models/weapons/w_tommy_gun.mdl',
	wep = "m9k_thompson",
	Purchase = function( ply )
ply:givePermWep( "m9k_thompson" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Tommy Gun навсегда
	]]
})

ray_shop:add({
	Name = "ACR",
	category = 'Оружие',
	Price = 379,
	model = 'models/weapons/w_masada_acr.mdl',
	wep = "m9k_acr",
	Purchase = function( ply )
ply:givePermWep( "m9k_acr" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете ACR навсегда
	]]
})

ray_shop:add({
	Name = "Ares Shrike",
	category = 'Оружие',
	Price = 499,
	model = 'models/weapons/w_ares_shrike.mdl',
	wep = "m9k_ares_shrike",
	Purchase = function( ply )
ply:givePermWep( "m9k_ares_shrike" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Ares Shrike навсегда
	]]
})

ray_shop:add({
	Name = "Mossberg 590",
	category = 'Оружие',
	Price = 499,
	model = 'models/weapons/w_mossberg_590.mdl',
	wep = "m9k_mossberg590",
	Purchase = function( ply )
ply:givePermWep( "m9k_mossberg590" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Mossberg 590 навсегда
	]]
})

ray_shop:add({
	Name = "Vikhr",
	category = 'Оружие',
	Price = 349,
	model = 'models/weapons/w_dmg_vikhr.mdl',
	wep = "m9k_vikhr",
	Purchase = function( ply )
ply:givePermWep( "m9k_vikhr" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Vikhr навсегда
	]]
})

ray_shop:add({
	Name = "Magpul PDR",
	category = 'Оружие',
	Price = 569,
	model = 'models/weapons/w_magpul_pdr.mdl',
	wep = "m9k_magpulpdr",
	Purchase = function( ply )
ply:givePermWep( "m9k_magpulpdr" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Magpul PDR навсегда
	]]
})

ray_shop:add({
	Name = "M60",
	category = 'Оружие',
	Price = 949,
	model = 'models/weapons/w_m60_machine_gun.mdl',
	wep = "m9k_m60",
	Purchase = function( ply )
ply:givePermWep( "m9k_m60" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете M60 навсегда
	]]
})

ray_shop:add({
	Name = "SCAR",
	category = 'Оружие',
	Price = 399,
	model = 'models/weapons/w_fn_scar_h.mdl',
	wep = "m9k_scar",
	Purchase = function( ply )
ply:givePermWep( "m9k_scar" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете SCAR навсегда
	]]
})

ray_shop:add({
	Name = "L85",
	category = 'Оружие',
	Price = 349,
	model = 'models/weapons/w_l85a2.mdl',
	wep = "m9k_l85",
	Purchase = function( ply )
ply:givePermWep( "m9k_l85" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете L85 навсегда
	]]
})

ray_shop:add({
	Name = "Raging Bull",
	category = 'Оружие',
	Price = 349,
	model = 'models/weapons/w_taurus_raging_bull.mdl',
	wep = "m9k_ragingbull",
	Purchase = function( ply )
ply:givePermWep( "m9k_ragingbull" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Raging Bull навсегда
	]]
})

ray_shop:add({
	Name = "Colt Python",
	category = 'Оружие',
	Price = 349,
	model = 'models/weapons/w_colt_python.mdl',
	wep = "m9k_coltpython",
	Purchase = function( ply )
ply:givePermWep( "m9k_coltpython" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Colt Python навсегда
	]]
})

ray_shop:add({
	Name = "HYPER SHOTGUN",
	category = 'Оружие',
	Price = 150,
	model = 'models/weapons/w_shotgun.mdl',
	wep = "weapon_shotgun",
	Purchase = function( ply )
ply:givePermWep( "weapon_shotgun" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Hyper Shotgun (Дробовик) навсегда
	]]
})

ray_shop:add({
	Name = "Взломщик кейпадов",
	category = 'Оружие',
	model = 'models/props_lab/keypad.mdl',
	Price = 245,
	wep = "keypad_cracker",
	Purchase = function( ply )
ply:givePermWep( "keypad_cracker" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Взломщик кейпадов навсегда
Взламывайте чужие кейпады с проф. оборудованием!
	]]
})

ray_shop:add({
	Name = "Проверка денег",
	category = 'Оружие',
	model = 'models/weapons/w_crowbar.mdl',
	Price = 100,
	wep = "moneychecker",
	Purchase = function( ply )
ply:givePermWep( "moneychecker" )
ply:ChatPrint("Умрите или перезайдите чтобы ваша проверка денег появилась!")
	end,
	Description = [[
Вы получаете возможность проверять деньги у игроков
]]
})

-------------------------------------------------------------------------
-- УДАЛЯЕМ ДЛЯ ПЕРВОГО
	ray_shop:add({
		Name = "Гаечный ключ Deluxe Навсегда",
		category = 'Оружие',
		model = 'models/props_c17/tools_wrench01a.mdl',
		Price = 250,
		wep = "wrench_deluxe",
		Purchase = function( ply )
			for k,v in player.Iterator() do
				v:ChatPrint(ply:Nick() .. " купил Гаечный ключ Deluxe")
			end
			ply:givePermWep( "wrench_deluxe" )
			ply:ChatPrint("Умрите или перезайдите чтобы ваш Гаечный ключ Deluxe выдался вам!")
		end,
		Description = [[
	Вы получаете Гаечный-ключ Deluxe навсегда
	Чинит вашу машину за 1 клик
		]]
	})
-------------------------------------------------------------------------

ray_shop:add({
	Name = "ВЕРЁВКА",
	category = 'Оружие',
	model = 'models/Gibs/HGIBS_rib.mdl',
	Price = 150,
	wep = "weapon_cuff_rope",
	Purchase = function( ply )
ply:givePermWep( "weapon_cuff_rope" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете верёвку навсегда
	]]
})

ray_shop:add({
	Name = "[NEW] Gambit PLUS [Месяц]", 
	otime = 30,
	category = 'Привилегии',
	model = 'models/balloons/balloon_classicheart.mdl',
	Price = 149, 
	mat = gmbp,
	Purchase = function( ply )
buygmb(ply)
for k,v in player.Iterator() do
	v:ChatPrint(ply:Nick() .. " стал обладателем подписки GAMBIT.PLUS!")
	v:ChatPrint(ply:Nick() .. " стал обладателем подписки GAMBIT.PLUS!")
	v:ChatPrint(ply:Nick() .. " стал обладателем подписки GAMBIT.PLUS!")
end
	end,
	//description to provide
	Description = [[
Это ПОДПИСКА а не привелегия!
В подписку Gambit PLUS на месяц входят следующие улучшения
+10 пропов к вашему лимиту на время действия подписки
Вам визуально выделяется ваш заказ за профессию Наемник и Ассасин
Вы выделены в TAB листе
У вас появляется новое информативное меню
[FD,Игрок на которого смотрите,прицел[NEW]
И ещё куча информативных улучшений!
Чтобы вас уволить необходимо набрать больше голосов чем обычно
Ваша торговая лавка выделена RGB цветом
Количество ваших максимальных прыжков паркура увеличено до 7
]],
})



// ADD YOUR EXTRAS HERE
ray_shop:add({
	Name = "VIP [Месяц]", // name in the menu
	otime = 30,
	category = 'Привилегии',
	mat = vip,
	color = Color(217,217,217),
	model = 'models/player/eli.mdl',
	Price = 120, // price in credits
	DisabledFor = { "vip" }, // what ulx ranks can't SEE / BUY the package
	Purchase = function( ply )
RunConsoleCommand("ulx", "tempadduserid", ply:SteamID(), "vip", "43200", "user" )
ply:ChatPrint("Вы приобрели VIP на месяц!")

	end,
	//description to provide
	Description = [[
Доступ к VIP работам (С моделями)
Доступ к VIP предметам
Вип принтер,мет (на 50% больше прибыль)
Свой реферальный код
Расширение инвентаря в 1 раз (1 столб)
+5 Пропа к вашему лимиту
Возможность покупать VIP машины
]],
})

ray_shop:add({
	Name = "VIP [Навсегда]", // name in the menu
	category = 'Привилегии',
	mat = vip,
	color = Color(217,217,217),
	model = 'models/player/eli.mdl',
	Price = 220, // price in credits
	DisabledFor = { "vip" }, // what ulx ranks can't SEE / BUY the package
	Purchase = function( ply ) // what happens when they buy it
RunConsoleCommand("ulx", "adduserid", ply:SteamID(), "vip" )
	end,
	//description to provide
	Description = [[
Доступ к VIP работам (С моделями)
Доступ к VIP предметам
Вип принтер,мет (на 50% больше прибыль)
Свой реферальный код
Расширение инвентаря в 1 раз (1 столб)
+5 Пропа к вашему лимиту
Возможность покупать VIP машины
]],
})

ray_shop:add({
	Name = "Модератор [Месяц]", // name in the menu
	otime = 30,
	category = 'Привилегии',
	color = Color(147,255,147),
	model = 'models/player/magnusson.mdl',
	Price = 230, // price in credits
	mat = moder,
	DisabledFor = { "moder" }, // what ulx ranks can't SEE / BUY the package
	Purchase = function( ply )
RunConsoleCommand("ulx", "tempadduserid", ply:SteamID(), "moder", "43200", "user" )
ply:ChatPrint("Вы приобрели модератора на месяц!")
	end,
	//description to provide
	Description = [[
Стандартный набор модератора
Следите за РП, нарушителями
Доступ к NONRP профессии
Бан(1-30мин), бессмертие
Все вип возможности
Доступ к админ чату
Доступ к принятию жалоб
Расширение инвентаря в 2 раза
+10 Пропа к вашему лимиту
/adminmode - брать игроков , пропы
И куча остальных команд в !menu
]],
})
ray_shop:add({
	Name = "Модератор [Навсегда]", // name in the menu
	category = 'Привилегии',
	color = Color(147,255,147),
	mat = moder,
	model = 'models/player/magnusson.mdl',
	Price = 420, // price in credits
	DisabledFor = { "moder" }, // what ulx ranks can't SEE / BUY the package
	Purchase = function( ply ) // what happens when they buy it
RunConsoleCommand("ulx", "adduserid", ply:SteamID(), "moder" )
	end,
	//description to provide
	Description = [[
Стандартный набор модератора
Следите за РП, нарушителями
Доступ к NONRP профессии
Бан(1-30мин), бессмертие
Все вип возможности
Доступ к админ чату
Доступ к принятию жалоб
Расширение инвентаря в 2 раза
+10 Пропа к вашему лимиту
/adminmode - брать игроков , пропы
И куча остальных команд в !menu
]],
})

ray_shop:add({
	Name = "Премиум админ [Месяц]", // name in the menu
	otime = 30,
	color = Color(130,210,255),
	category = 'Привилегии',
	model = 'models/player/gman_high.mdl',
	Price = 480, // price in credits
	mat = premadm,
	DisabledFor = { "padmin" }, // what ulx ranks can't SEE / BUY the package
	Purchase = function( ply )
RunConsoleCommand("ulx", "tempadduserid", ply:SteamID(), "padmin", "43200", "user" )
ply:ChatPrint("Вы приобрели Премиум админа на месяц!")
	end,
	//description to provide
	Description = [[
Бан (1-24час), невидимосить
Все возможности модера
Все возможности VIP
Выдача оружия
Выдача брони, жизней
Возможность возраждать людей
Расширение инвентаря в 3 раза
Доступ к пропам игроков (!cleanprops)
Уважение среди админов
+20 Пропа к вашему лимиту
/adminmode - брать игроков , пропы
И куча остальных команд в !menu
]],
})
ray_shop:add({
	Name = "Премиум админ [Навсегда]", // name in the menu
	category = 'Привилегии',
	color = Color(130,210,255),
	mat = premadm,
	model = 'models/player/gman_high.mdl',
	Price = 870, // price in credits
	DisabledFor = { "padmin" }, // what ulx ranks can't SEE / BUY the package
	Purchase = function( ply ) // what happens when they buy it
RunConsoleCommand("ulx", "adduserid", ply:SteamID(), "padmin" )
	end,
	//description to provide
	Description = [[
Бан(1-24час), невидимосить
Все возможности модера
Все возможности VIP
Выдача оружия
Выдача брони, жизней
Возможность возраждать людей
Расширение инвентаря в 3 раза
Доступ к пропам игроков (!cleanprops)
Уважение среди админов
+20 Пропа к вашему лимиту
/adminmode - брать игроков , пропы
И куча остальных команд в !menu
]],
})

ray_shop:add({
	Name = "Спонсор [Месяц]", // name in the menu
	otime = 30,
	category = 'Привилегии',
	model = 'models/player/breen.mdl',
	Price = 970, // price in credits
	DisabledFor = { "sponsor" }, // what ulx ranks can't SEE / BUY the package
	mat = sponsor,
	Purchase = function( ply )
RunConsoleCommand("ulx", "tempadduserid", ply:SteamID(), "sponsor", "43200", "user" )
ply:ChatPrint("Вы приобрели спонсора на месяц, развлекайся :3")
RunConsoleCommand("ulx", "addmoneyid", ply:SteamID(), "250000" )
	end,
	//description to provide
	Description = [[
Бан(1-7дней), невидимосить
Все админ возможности
Вип возможности
Расширение инвентаря в 4 раза
Бесконечные патроны
Вы в праве отвечать на жалобы не за нонРП профу
Вам дополнительно выдаёться 250.000$
+30 Пропа к вашему лимиту
/adminmode - брать игроков , пропы
Доступ к пропам игроков (!cleanprops)
И куча остальных команд в !menu
]],
})
ray_shop:add({
	Name = "Спонсор [Навсегда]", // name in the menu
	category = 'Привилегии',
	model = 'models/player/breen.mdl',
	mat = sponsor,
	Price = 1650, // price in credits
	DisabledFor = { "sponsor" }, // what ulx ranks can't SEE / BUY the package
	Purchase = function( ply ) // what happens when they buy it
RunConsoleCommand("ulx", "adduserid", ply:SteamID(), "sponsor" )
RunConsoleCommand("ulx", "addmoneyid", ply:SteamID(), "500000" )
ply:ChatPrint("Вы приобрели спонсора навсегда, развлекайся :3")
	end,
	//description to provide
	Description = [[
Бан(1-7дней), невидимосить
Все админ возможности
Вип возможности
Расширение инвентаря в 4 раза
Бесконечные патроны
Вы в праве отвечать на жалобы не за нонРП профу
Вам дополнительно выдаёться 500.000$
+30 Пропа к вашему лимиту
/adminmode - брать игроков , пропы
Доступ к пропам игроков (!cleanprops)
И куча остальных команд в !menu
]],
})
ray_shop:add({
	Name = "Владелец [Месяц]", // name in the menu
	otime = 30,
	color = Color(255,217,102),
	category = 'Привилегии',
	model = 'models/player/combine_super_soldier.mdl',
	Price = 2000, // price in credits
	mat = owne,
	DisabledFor = { "dsuperadmin" }, // what ulx ranks can't SEE / BUY the package
	Purchase = function( ply )
RunConsoleCommand("ulx", "tempadduserid", ply:SteamID(), "dsuperadmin", "43200", "user" )
ply:ChatPrint("Вы приобрели Владельца на месяц, развлекайся :3")
RunConsoleCommand("ulx", "addmoneyid", ply:SteamID(), "500000" )
	end,
	//description to provide
	Description = [[
Бан(1-30дней), невидимосить
Все возможности спонсора
Все админ возможности
Расширение инвентаря в 5 раз
Вип возможности
Бесконечные патроны
+40 Пропа к вашему лимиту
Вам дополнительно выдаёться 500.000$
/adminmode - брать игроков , пропы
Доступ к пропам игроков (!cleanprops)
И куча остальных команд в !menu
]],
})
ray_shop:add({
	Name = "Владелец [Навсегда]", // name in the menu
	color = Color(255,217,102),
	mat = owne,
	category = 'Привилегии',
	model = 'models/player/combine_super_soldier.mdl',
	Price = 3000, // price in credits
	DisabledFor = { "dsuperadmin" }, // what ulx ranks can't SEE / BUY the package
	Purchase = function( ply ) // what happens when they buy it
RunConsoleCommand("ulx", "adduserid", ply:SteamID(), "dsuperadmin" )
RunConsoleCommand("ulx", "addmoneyid", ply:SteamID(), "1000000" )
ply:ChatPrint("Вы приобрели Владельца навсегда, развлекайся :3")
	end,
	//description to provide
	Description = [[
Бан(1-30дней), невидимосить
Все возможности спонсора
Все админ возможности
Расширение инвентаря в 5 раз
Вип возможности
Бесконечные патроны
+40 Пропа к вашему лимиту
Вам дополнительно выдаёться 1.000.000$
/adminmode - брать игроков , пропы
Доступ к пропам игроков (!cleanprops)
И куча остальных команд в !menu
]],
})

ray_shop:add({
	Name = "Создатель [Навсегда]",
	category = 'Привилегии',
	model = 'models/player/combine_super_soldier.mdl',
	Price = 4980,
	mat = maker,
	DisabledFor = { "downer" },
	Purchase = function( ply )
RunConsoleCommand("ulx", "adduserid", ply:SteamID(), "downer" )
RunConsoleCommand("ulx", "addmoneyid", ply:SteamID(), "2500000" )
ply:SetPData("glushitel", 100)
ply:SetNW2Int("glushitel", 100)
ply:SetPData('zaika',1)
buygmb(ply)
ply:SetNW2Bool('donate_upgrade_runngun', true)
ply:SetPData('rungun', 1)
ply:SetPData('head',1)
ply:ChatPrint("Вы приобрели Создатель навсегда, развлекайся :3")
ply:ChatPrint("Консоль сервера: +epoe в консоль")
	end,
	Description = [[
[#] ПОЛЁТ В РП ПРОФЕ [#]
Бесплатная подписка Gambit+
Модификация Максимальный уровень бесшумности!!! в подарок
Модификация Run'n'Gun в подарок
Модификация Меню зайца! в подарок
Модификация Меню головы! в подарок
Бесконечные патроны в подарок
Возможность выдавать кредиты!
Возможность выдавать VIP!
Вы в праве создавать киллзоны!
Вы имеете право устаналивать себе лимитные професси
Безлимитный бан
Возможность снимать бан
Все возможности всех привилегий
Все админ команды! (!menu)
Расширение инвентаря в 10 раз
Вип возможности
+55 Пропа к вашему лимиту
Вам дополнительно выдаёться 2.500.000$
/adminmode - брать игроков , пропы
]],
})


ray_shop:add({
	Name = "250.000$ Игровой валюты",
	category = 'Валюта',
	model = 'models/props/cs_assault/money.mdl',
	Price = 90,
	Purchase = function( ply )
ply:addMoney(250000)
ply:ChatPrint( "Вы купили $250.000!" )
	end,
	Description = [[
Вы получаете 250.000$ на свой счёт
	]]
})

ray_shop:add({
	Name = "500.000$ Игровой валюты",
	category = 'Валюта',
	model = 'models/props/cs_assault/money.mdl',
	Price = 185,
	Purchase = function( ply )
ply:addMoney(500000)
ply:ChatPrint( "Вы купили $500.000!" )
	end,
	Description = [[
Вы получаете 500.000$ на свой счёт
	]]
})

ray_shop:add({
	Name = "1.000.000$ Игровой валюты",
	category = 'Валюта',
	model = 'models/props/cs_assault/money.mdl',
	Price = 360,
	Purchase = function( ply )
ply:addMoney(1000000)
ply:ChatPrint( "Вы купили $1.000.000!" )
	end,
	Description = [[
Вы получаете 1.000.000$ на свой счёт
	]]
})

ray_shop:add({
	Name = "2.000.000$ Игровой валюты",
	category = 'Валюта',
	model = 'models/props/cs_assault/money.mdl',
	Price = 450,
	Purchase = function( ply )
ply:addMoney(2000000)
ply:ChatPrint( "Вы купили $2.000.000!" )
	end,
	Description = [[
Вы получаете 2.000.000$ на свой счёт
	]]
})

ray_shop:add({
	Name = "5.000.000$ Игровой валюты",
	category = 'Валюта',
	model = 'models/props/cs_assault/money.mdl',
	Price = 600,
	Purchase = function( ply )
ply:addMoney(5000000)
ply:ChatPrint( "Вы купили $1.000.000!" )
	end,
	Description = [[
Вы получаете 5.000.000$ на свой счёт
	]]
})

ray_shop:add({
	Name = "Сидеть на пропах", // name in the menu
	color = Color(147,255,147),
	category = 'Остальное',
	model = 'models/props_junk/cardboard_box004a_gib01.mdl',
	mat = sit,
	Price = 25, // price in credits
	Purchase = function( ply )
		if SERVER then ply:SetPData('sitprop',true) end
		ply:ChatPrint("Вы приобрели Сидеть на пропах")
		sendchatall( Color( 255, 0, 0 ), "[Донат] ", Color( 255, 255, 255 ), ply:Name(), " купил возможность сидеть на пропах!" )
	end,
	//description to provide
	Description = [[
Даст вам доступ к сидению на пропах/машинах
Активация ALT+E или sit в консоль нужно смотреть на проп/машину
]],
})

ray_shop:add({
	Name = "Доступ к меню размер головы", // name in the menu
	color = Color(130,210,255),
	category = 'Остальное',
	model = 'models/props_junk/cardboard_box004a_gib01.mdl',
	Price = 200, // price in credits
	mat = head,
	Purchase = function( ply )
		if SERVER then ply:SetPData('head',1) end
		ply:ChatPrint("Вы приобрели доступ к меню головы напишите !head в чат")
	end,
	//description to provide
	Description = [[
Даст вам доступ к меню изменения головы
Возможности без граничны.
КОМАНДА !head в чат
]],
})

ray_shop:add({
	Name = "Меню зайца", // name in the menu
	color = Color(255,217,102),
	category = 'Остальное',
	model = 'models/props_junk/cardboard_box004a_gib01.mdl',
	mat = zayka,
	Price = 500, // price in credits
	Purchase = function( ply )
		if SERVER then ply:SetPData('zaika',1) end
		ply:ChatPrint("Вы приобрели доступ к меню зайца напишите !заяц в чат")
	end,
	//description to provide
	Description = [[
Даст вам доступ к меню зайца
Возможности: 
Вы можете автоматически быстро прыгать
КОМАНДА !заяц в чат
]],
})

ray_shop:add({
	Name = "Глаза хищника", // name in the menu
	color = Color(255,217,102),
	category = 'Остальное',
	model = 'models/props_junk/cardboard_box004a_gib01.mdl',
	Price = 999, // price in credits
	mat = predator,
	Purchase = function( ply )
		if SERVER then ply:SetPData('hish',1) end
		ply:ChatPrint("Вы приобрели доступ к меню хищника напишите !хищник в чат")
	end,
	//description to provide
	Description = [[
Даст вам доступ к меню хищника
Возможности без граничны.
КОМАНДА !хищник в чат
]],
})

ray_shop:add({
	Name = "+30 Патронов навсегда", // name in the menu
	color = Color(147,255,147),
	category = 'Остальное',
	model = 'models/Items/BoxMRounds.mdl',
	mat = gmb,
	Price = 50, // price in credits
	Purchase = function( ply )
		if SERVER then ply:SetPData('donatedata_simpleammo',tonumber(ply:GetPData('donatedata_simpleammo',0)) + 30) end
		ply:ChatPrint("Вы приобрели +30 патронов")
		ply:ChatPrint("Умрите,возродитесь, или перезайдите чтобы патроны выдались")
	end,
	//description to provide
	Description = [[
При каждом возрождении
Вам выдаёться 30 патронов
Вы можете покупать патроны бесконечно раз
Вам не будет выдаваться патроны на
Арбалет,граната,мина
]],
})

ray_shop:add({
	Name = "+50 Патронов навсегда", // name in the menu
	color = Color(130,210,255),
	category = 'Остальное',
	model = 'models/Items/BoxMRounds.mdl',
	Price = 100, // price in credits
	mat = image78,
	Purchase = function( ply )
		if SERVER then ply:SetPData('donatedata_simpleammo',tonumber(ply:GetPData('donatedata_simpleammo',0)) + 50) end
		ply:ChatPrint("Вы приобрели +50 патронов")
		ply:ChatPrint("Умрите,возродитесь, или перезайдите чтобы патроны выдались")
	end,
	//description to provide
	Description = [[
При каждом возрождении
Вам выдаёться 50 патронов
Вы можете покупать патроны бесконечно раз
Вам не будет выдаваться патроны на
Арбалет,граната,мина
]],
})

ray_shop:add({
	Name = "+100 брони навсегда", // name in the menu
	color = Color(130,210,255),
	category = 'Остальное',
	model = 'models/items/battery.mdl',
	mat = armor,
	Price = 125, // price in credits
	Purchase = function( ply )
                    local armornow = 0
		if SERVER then
			ply:SetPData('donatearmor',100)
		end
		ply:ChatPrint("Вы приобрели 100 брони")
		ply:ChatPrint("Умрите,возродитесь, или перезайдите чтобы бронь выдалась")
	end,
	//description to provide
	Description = [[
При каждом возрождении
Вам будет выдаваться 100 брони
]],
})

ray_shop:add({
	Name = "Пониженый голод навсегда", // name in the menu
	color = Color(130,210,255),
	category = 'Остальное',
	model = 'models/weapons/w_package.mdl',
	mat = eda,
	Price = 149, // price in credits
	//PriceInSkins = 11111,
	CustomSukaBlyadCheckDataWithMax = true,
	CustomSukaBlyadCheckDataWithMax_nummax = 1,
	CustomSukaBlyadCheckDataWithMax_datadir = "donatedata1337/upgrade/food/",
	Purchase = function( ply )
	if SERVER then
		ply:SetPData('donatedata_food',1)
		ply:ChatPrint("Ваш лимит голода повышен до 200!")
	end

	end,
	//description to provide
	Description = [[
Ваш лимит голода повышается до 200!
]],
})


ray_shop:add({
	Name = "AK-47",
	category = 'Оружие',
	model = 'models/weapons/w_rif_ak47.mdl',
	Price = 150,
	wep = "ak47",
	Purchase = function( ply )
ply:givePermWep( "ak47" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете AK-47 навсегда
	]]
})

ray_shop:add({
	Name = "SG552",
	category = 'Оружие',
	Price = 150,
	model = 'models/weapons/w_rif_sg552.mdl',
	wep = "sg552",
	Purchase = function( ply )
ply:givePermWep( "sg552" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете SG552 навсегда
	]]
})

ray_shop:add({
	Name = "SCOUT",
	category = 'Оружие',
	Price = 150,
	model = 'models/weapons/w_snip_scout.mdl',
	wep = "scout",
	Purchase = function( ply )
ply:givePermWep( "scout" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете SCOUT навсегда
	]]
})

ray_shop:add({
	Name = "Арбалет",
	color = Color(255,217,102),
	category = 'Оружие',
	model = 'models/weapons/w_crossbow.mdl',
	Price = 400,
	wep = "weapon_crossbow",
	Purchase = function( ply )
ply:givePermWep( "weapon_crossbow" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Арбалет навсегда
Убивает с 1-го выстрела
	]]
})

ray_shop:add({
	Name = "Граната",
	color = Color(255,217,102),
	category = 'Оружие',
	model = 'models/weapons/w_eq_fraggrenade.mdl',
	Price = 379,
	wep = "weapon_frag",
	Purchase = function( ply )
ply:givePermWep( "weapon_frag" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете гранату навсегда
	]]
})

ray_shop:add({
	Name = "Мины",
	color = Color(255,217,102),
	model = 'models/weapons/w_slam.mdl',
	category = 'Оружие',
	Price = 409,
	wep = "weapon_slam",
	Purchase = function( ply )
ply:givePermWep( "weapon_slam" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете мины навсегда
	]]
})

ray_shop:add({
	Name = "AUG",
	model = 'models/weapons/w_rif_aug.mdl',
	category = 'Оружие',
	Price = 150,
	wep = "aug",
	Purchase = function( ply )
ply:givePermWep( "aug" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете AUG навсегда
	]]
})

ray_shop:add({
	Name = "AWP",
	category = 'Оружие',
	model = 'models/weapons/w_snip_awp.mdl',
	Price = 150,
	wep = "awp",
	Purchase = function( ply )
ply:givePermWep( "awp" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете AWP навсегда
	]]
})

ray_shop:add({
	Name = "Five-Seven",
	category = 'Оружие',
	color = Color(147,255,147),
	model = 'models/weapons/w_pist_fiveseven.mdl',
	Price = 50,
	wep = "fiveseven",
	Purchase = function( ply )
ply:givePermWep( "fiveseven" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Five-Seven навсегда
	]]
})

ray_shop:add({
	Name = "Desert Eagle",
	color = Color(147,255,147),
	category = 'Оружие',
	model = 'models/weapons/w_pist_deagle.mdl',
	Price = 50,
	wep = "deagle",
	Purchase = function( ply )
ply:givePermWep( "deagle" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Desert Eagle навсегда
	]]
})

ray_shop:add({
	Name = "FAMAS",
	color = Color(130,210,255),
	category = 'Оружие',
	model = 'models/weapons/w_rif_famas.mdl',
	Price = 120,
	wep = "famas",
	Purchase = function( ply )
ply:givePermWep( "famas" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете FAMAS навсегда
	]]
})

ray_shop:add({
	Name = "Galil",
	color = Color(130,210,255),
	category = 'Оружие',
	model = 'models/weapons/w_rif_galil.mdl',
	Price = 100,
	wep = "galil",
	Purchase = function( ply )
ply:givePermWep( "galil" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Galil навсегда
	]]
})

ray_shop:add({
	Name = "Glock",
	color = Color(130,210,255),
	category = 'Оружие',
	model = 'models/weapons/w_pist_glock18.mdl',
	Price = 100,
	wep = "glock",
	Purchase = function( ply )
ply:givePermWep( "glock" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Glock навсегда
	]]
})

ray_shop:add({
	Name = "M4A1",
	category = 'Оружие',
	model = 'models/weapons/w_rif_m4a1.mdl',
	Price = 150,
	wep = "m4a1",
	Purchase = function( ply )
ply:givePermWep( "m4a1" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете M4A1 навсегда
	]]
})

ray_shop:add({
	Name = "M249",
	color = Color(255,217,102),
	category = 'Оружие',
	model = 'models/weapons/w_mach_m249para.mdl',
	Price = 400,
	wep = "m249",
	Purchase = function( ply )
ply:givePermWep( "m249" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете M249(Пулемёт) навсегда
	]]
})

ray_shop:add({
	Name = "MAC-10",
	category = 'Оружие',
	color = Color(147,255,147),
	model = 'models/weapons/w_smg_mac10.mdl',
	Price = 50,
	wep = "mac10",
	Purchase = function( ply )
ply:givePermWep( "mac10" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете MAC-10 навсегда
	]]
})

ray_shop:add({
	Name = "M3SUPER90",
	color = Color(130,210,255),
	category = 'Оружие',
	model = 'models/weapons/w_shot_m3super90.mdl',
	Price = 100,
	wep = "m3super90",
	Purchase = function( ply )
ply:givePermWep( "m3super90" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете M3SUPER90(Дробовик) навсегда
	]]
})

ray_shop:add({
	Name = "MP5",
	category = 'Оружие',
	model = 'models/weapons/w_smg_mp5.mdl',
	Price = 150,
	wep = "mp5",
	Purchase = function( ply )
ply:givePermWep( "mp5" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете MP5 навсегда
	]]
})

ray_shop:add({
	Name = "P228",
	category = 'Оружие',
	color = Color(147,255,147),
	model = 'models/weapons/w_pist_p228.mdl',
	Price = 50,
	wep = "p228",
	Purchase = function( ply )
ply:givePermWep( "p228" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете P228 навсегда
	]]
})

ray_shop:add({
	Name = "P90",
	color = Color(130,210,255),
	category = 'Оружие',
	model = 'models/weapons/w_smg_p90.mdl',
	Price = 100,
	wep = "p90",
	Purchase = function( ply )
ply:givePermWep( "p90" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете P90 навсегда
	]]
})

ray_shop:add({
	Name = "TMP",
	category = 'Оружие',
	color = Color(147,255,147),
	model = 'models/weapons/w_smg_tmp.mdl',
	Price = 50,
	wep = "tmp",
	Purchase = function( ply )
ply:givePermWep( "tmp" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете TMP навсегда
	]]
})

ray_shop:add({
	Name = "UMP-45",
	category = 'Оружие',
	color = Color(147,255,147),
	model = 'models/weapons/w_smg_ump45.mdl',
	Price = 50,
	wep = "ump",
	Purchase = function( ply )
ply:givePermWep( "ump" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете UMP-45 навсегда
	]]
})

ray_shop:add({
	Name = "USP-S",
	category = 'Оружие',
	color = Color(147,255,147),
	model = 'models/weapons/w_pist_usp.mdl',
	Price = 50,
	wep = "usp",
	Purchase = function( ply )
ply:givePermWep( "usp" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете USP-S навсегда
	]]
})

ray_shop:add({
	Name = "XM1014",
	color = Color(130,210,255),
	category = 'Оружие',
	model = 'models/weapons/w_shot_xm1014.mdl',
	Price = 240,
	wep = "xm1014",
	Purchase = function( ply )
ply:givePermWep( "xm1014" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете XM1014(Дробовик) навсегда
	]]
})

ray_shop:add({
	Name = "Нож",
	category = 'Оружие',
	color = Color(147,255,147),
	model = 'models/weapons/w_knife_t.mdl',
	Price = 50,
	wep = "knife",
	Purchase = function( ply )
ply:givePermWep( "knife" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Нож навсегда
	]]
})

ray_shop:add({
	Name = "Монтировка",
	category = 'Оружие',
	color = Color(147,255,147),
	model = 'models/weapons/w_crowbar.mdl',
	Price = 50,
	wep = "weapon_crowbar",
	Purchase = function( ply )
ply:givePermWep( "weapon_crowbar" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Монтировку навсегда
	]]
})

ray_shop:add({
	Name = "Револьвер",
	category = 'Оружие',
	color = Color(147,255,147),
	model = 'models/weapons/w_357.mdl',
	Price = 70,
	wep = "revolver",
	Purchase = function( ply )
ply:givePermWep( "revolver" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Револьвер навсегда
	]]
})

ray_shop:add({
	Name = "Разноцветный вейп",
	model = 'models/swamponions/vape.mdl',
	color = Color(147,255,147),
	category = 'Оружие',
	Price = 70,
	wep = "weapon_vape_juicy",
	Purchase = function( ply )
ply:givePermWep( "weapon_vape_juicy" )
ply:ChatPrint("Умрите или перезайдите чтобы ваш вейп появился!")
	end,
	Description = [[
Вы получаете Разноцветный вейп навсегда
	]]
})

ray_shop:add({
	Name = "Галюционный вейп",
	color = Color(130,210,255),
	category = 'Оружие',
	model = 'models/swamponions/vape.mdl',
	Price = 100,
	wep = "weapon_vape_hallucinogenic",
	Purchase = function( ply )
ply:givePermWep( "weapon_vape_hallucinogenic" )
ply:ChatPrint("Умрите или перезайдите чтобы ваш вейп появился!")
	end,
	Description = [[
Вы получаете Галюционный вейп навсегда
	]]
})

ray_shop:add({
	Name = "Вейп",
	color = Color(147,255,147),
	model = 'models/swamponions/vape.mdl',
	category = 'Оружие',
	Price = 50,
	wep = "weapon_vape",
	Purchase = function( ply )
ply:givePermWep( "weapon_vape" )
ply:ChatPrint("Умрите или перезайдите чтобы ваш вейп появился!")
	end,
	Description = [[
Вы получаете Вейп навсегда
	]]
})

ray_shop:add({
	Name = "Отмычка",
	color = Color(130,210,255),
	category = 'Оружие',
	Price = 100,
	model = 'models/weapons/w_crowbar.mdl',
	wep = "lockpick",
	Purchase = function( ply )
ply:givePermWep( "lockpick" )
ply:ChatPrint("Умрите или перезайдите чтобы ваша отмычка выдалась вам!")
	end,
	Description = [[
Вы получаете отмычку навсегда
	]]
})

ray_shop:add({
	Name = "Спиннер",
	category = 'Оружие',
	color = Color(147,255,147),
	model = 'models/props_workshop/fidget_spinner.mdl',
	Price = 15,
	wep = "weapon_fidget",
	Purchase = function( ply )
ply:givePermWep( "weapon_fidget" )
ply:ChatPrint("Умрите или перезайдите чтобы ваш спиннер появился!")
	end,
	Description = [[
Вы получаете спиннер навсегда
	]]
})

ray_shop:add({
	Name = "Сигарета",
	color = Color(147,255,147),
	category = 'Оружие',
	Price = 20,
	model = 'models/props_c17/doll01.mdl',
	wep = "weapon_ciga",
	Purchase = function( ply )
ply:givePermWep( "weapon_ciga" )
ply:ChatPrint("Умрите или перезайдите чтобы ваше оружие появилось!")
	end,
	Description = [[
Вы получаете Сигарету навсегда
	]]
})

ray_shop:add({
	Name = "Дубинка",
	color = Color(147,255,147),
	category = 'Оружие',
	Price = 50,
	model = 'models/weapons/w_stunbaton.mdl',
	wep = "stunstick",
	Purchase = function( ply )
ply:givePermWep( "stunstick" )
ply:ChatPrint("Умрите или перезайдите чтобы ваша дубинка выдалась вам!")
	end,
	Description = [[
Вы получаете дубинку навсегда
	]]
})

ray_shop:add({
	Name = "Аптечка",
	category = 'Оружие',
	model = 'models/weapons/w_medkit.mdl',
	Price = 150,
	wep = "weapon_medkit",
	Purchase = function( ply )
ply:givePermWep( "weapon_medkit" )
ply:ChatPrint("Умрите или перезайдите чтобы ваша аптечка выдалась вам!")
	end,
	Description = [[
Вы получаете Аптечку навсегда
	]]
})

-- ray_shop:add({
-- 	Name = "Армор кит",
-- 	category = 'Оружие',
-- 	model = 'models/items/battery.mdl',
-- 	Price = 150,
-- 	wep = "weapon_armorkit",
-- 	Purchase = function( ply )
-- ply:givePermWep( "weapon_medkit" )
-- ply:ChatPrint("Умрите или перезайдите чтобы ваш Армор кит выдалась вам!")
-- 	end,
-- 	Description = [[
-- Вы получаете Армор кит навсегда
-- 	]]
-- })
--PATH addons/dermaf4/lua/ui/util.lua:
for i = 7, 64 do
	surface.CreateFont('ui.' .. i, {font = 'Roboto', size = i, antialias = true, extended = true})
end

local vguiFucs = {
	['DTextEntry'] = function(self, p)
		self:SetFont('ui.20')
	end,	
	['DLabel'] = function(self, p)
		self:SetFont('ui.22')
		self:SetColor(ui.col.White)
	end,
	['DButton'] = function(self, p)
		self:SetFont('ui.20')
	end,
	['DComboBox'] = function(self, p)
		self:SetFont('ui.22')
	end,
}

timer.Simple(0, function()
	vgui.GetControlTable('DButton').SetBackgroundColor = function(self, color)
		self.BackgroundColor = color
	end
end)

function ui.Create(t, f, p)
	local parent
	if (not isfunction(f)) and (f ~= nil) then
		parent = f
	elseif not isfunction(p) and (p ~= nil) then
		parent = p
	end

	local v = vgui.Create(t, parent)
	v:SetSkin('SUP')

	if vguiFucs[t] then vguiFucs[t](v, parent) end

	if isfunction(f) then f(v, parent) elseif isfunction(p) then p(v, f) end

	return v
end

function ui.Label(txt, font, x, y, parent)
	return ui.Create('DLabel', function(self, p)
		self:SetText(txt)
		self:SetFont(font)
		self:SetTextColor(ui.col.White)
		self:SetPos(x, y)
		self:SizeToContents()
		self:SetWrap(true)
		self:SetAutoStretchVertical(true)
	end, parent)
end

function ui.DermaMenu(pM)
	if (not parentmenu) then CloseDermaMenus() end
	return ui.Create("DMenu", function(self)
		self:SetTall(30)
	end, p)
end

function ui.BoolRequest(title, text, cback)
	local m = ui.Create('ui_frame', function(self)
		self:SetTitle(title)
		self:ShowCloseButton(false)
		self:SetWide(ScrW() * .2)
		self:MakePopup()
	end)
	
	local txt = string.Wrap('ui.18', text, m:GetWide() - 10)
	local y = m:GetTitleHeight()

	for k, v in ipairs(txt) do
		local lbl = ui.Create('DLabel', function(self, p)
			self:SetText(v)
			self:SetFont('ui.18')
			self:SizeToContents()
			self:SetPos((p:GetWide() - self:GetWide()) / 2, y)
			y = y + self:GetTall() + 5
		end, m)
	end

	local btnOK = ui.Create('DButton', function(self, p)
		self:SetText('Да')
		self:SetPos(5, y)
		self:SetSize(p:GetWide()/2 - 7.5, 25)
		self.DoClick = function(s)
			p:Close()
			cback(true)
		end
	end, m)

	local btnCan = ui.Create('DButton', function(self, p)
		self:SetText('Нет')
		self:SetPos(btnOK:GetWide() + 10, y)
		self:SetSize(btnOK:GetWide(), 25)
		self:RequestFocus()
		self.DoClick = function(s)
			p:Close()
			cback(false)
		end
		y = y + self:GetTall() + 5
	end, m)

	m:SetTall(y)
	m:Center()

	m:Focus()
	return m
end

function ui.StringRequest(title, text, default, cback)
	local m = ui.Create('ui_frame', function(self)
		self:SetTitle(title)
		self:ShowCloseButton(false)
		self:SetWide(ScrW() * .3)
		self:MakePopup()
	end)
	
	local txt = string.Wrap('ui.18', text, m:GetWide() - 10)
	local y = m:GetTitleHeight()

	for k, v in ipairs(txt) do
		local lbl = ui.Create('DLabel', function(self, p)
			self:SetText(v)
			self:SetFont('ui.18')
			self:SizeToContents()
			self:SetPos((p:GetWide() - self:GetWide()) / 2, y)
			y = y + self:GetTall()
		end, m)
	end
	
	local tb = ui.Create('DTextEntry', function(self, p) 
		self:SetPos(5, y + 5)
		self:SetSize(p:GetWide() - 10, 25)
		self:SetValue(default or '')
		y = y + self:GetTall() + 10
		self.OnEnter = function(s)
			p:Close()
			cback(self:GetValue())
		end
	end, m)

	local btnOK = ui.Create('DButton', function(self, p)
		self:SetText('Ок')
		self:SetPos(5, y)
		self:SetSize(p:GetWide()/2 - 7.5, 25)
		self.DoClick = function(s)
			p:Close()
			cback(tb:GetValue())
		end
	end, m)

	local btnCan = ui.Create('DButton', function(self, p)
		self:SetText('Отмена')
		self:SetPos(btnOK:GetWide() + 10, y)
		self:SetSize(btnOK:GetWide(), 25)
		self:RequestFocus()
		self.DoClick = function(s)
			m:Close()
		end
		y = y + self:GetTall() + 5
	end, m)

	m:SetTall(y)
	m:Center()

	m:Focus()
	return m
end

function ui.PlayerRequest(players, cback)
	if isfunction(players) then
		cback = players
		players = nil
	end

	local fr = ui.Create('ui_frame', function(self)
		self:SetTitle('Выберите игрока')
		self:SetSize(.2, .3)
		self:Center()
		self:MakePopup()
	end)

	ui.Create('ui_playerrequest', function(self, p) 
		self:DockToFrame()
		if players then
			self:SetPlayers(players)
		end
		self.OnSelection = function(self, row, pl)
			fr:Close()
			cback(pl)
		end
	end, fr)

	fr:Focus()
	return m
end

function ui.OpenURL(url, title)
	local w, h = ScrW() * .9, ScrH() * .9

	local fr = ui.Create('ui_frame', function(self)
		self:SetSize(w, h)
		self:SetTitle(url)
		self:Center()
		self:MakePopup()
	end)

	ui.Create('HTML', function(self)
		self:SetPos(5, 32)
		self:SetSize(w - 10, h - 37)
		self:OpenURL(url)
	end, fr)

	return fr
end
--PATH addons/dermaf4/lua/ui/theme.lua:
local SKIN 	= {
	PrintName 	= 'SUP',
	Author 	 	= 'aStonedPenguin'
}

color_sup 			= ui.col.SUP
color_background 		= ui.col.Background
color_outline 		= ui.col.Outline
color_hover 			= ui.col.Hover
color_button 			= ui.col.Button
color_button_hover	= ui.col.ButtonHover
color_close 			= ui.col.Close
color_close_bg 		= ui.col.CloseBackground
color_close_hover 	= ui.col.CloseHovered

color_offwhite 		= ui.col.OffWhite
color_flat_black 		= ui.col.FlatBlack
color_black 			= ui.col.Black
color_white 			= ui.col.White
color_red 			= ui.col.Red

SKIN.fontFrame					= "ui.20"
SKIN.fontTab					= "ui.20"
SKIN.fontCategoryHeader			= "ui.20"
-- Frames    
function SKIN:PaintFrame(self, w, h)
	draw.Box(0, 0, w, h, Color(36, 36, 36))
	draw.Box(0, 0, w, 28, Color(23, 23, 23))
	draw.Box(1, 1, 3, 28, color_sup)
end

function SKIN:PaintPanel(self, w, h)
	if (not self.m_bBackground) then return end

	draw.Box(0, 0, w, h, Color(36, 36, 36))
end

function SKIN:PaintShadow() end

-- Buttons    
function SKIN:PaintButton(self, w, h)
	if (not self.m_bBackground) then return end

	if not self.lerptime then
		self.lerptime = SysTime() - 2
	end

	self.OnCursorEntered = function(s) self.lerptime = SysTime() end
	self.OnCursorExited = function(s) self.lerptime = SysTime() end

	local lerpbut = Lerp((SysTime() - self.lerptime) * 6, 0, h / 2)
	local colorlerp = LerpVector((SysTime() - self.lerptime) * 6, color_button:ToVector(), color_button_hover:ToVector()):ToColor()
	local colorlerpa = LerpVector((SysTime() - self.lerptime) * 6, color_button_hover:ToVector(), color_button:ToVector()):ToColor()
	if colorlerp.r > color_button_hover.r then
		colorlerp = color_button_hover
	end
	if colorlerpa.r > color_button_hover.r then
		colorlerpa = color_button_hover
	end
	if self:GetDisabled() then
		draw.Box(0, 0, w, h, color_flat_black)
	elseif (self.Active == true) then
		draw.Box(0, 0, w, h, self.BackgroundColor or color_sup)
	elseif (self.Hovered) then
		draw.Box(0, 0, w, h, color_button)
		draw.Box(0, h / 2 - lerpbut + h / 2, w, h / 2, colorlerp)
		draw.Box(0, lerpbut - h / 2, w, h / 2, colorlerp)
	else
		draw.Box(0, 0, w, h, color_button)
		draw.Box(0, lerpbut + h / 2, w, h / 2, colorlerpa)
		draw.Box(0, h / 2 - lerpbut - h / 2, w, h / 2, colorlerpa)
	end

	local colorlerptext = Lerp((SysTime() - self.lerptime) * 6, 255, 0)
	local colorlerptexta = Lerp((SysTime() - self.lerptime) * 6, 0, 255)
	self:SetTextColor((self.Hovered and (not self:GetDisabled()) and (not self.Active)) and Color(colorlerptext, colorlerptext, colorlerptext) or ((not self:GetDisabled()) and (not self.Active)) and Color(colorlerptexta, colorlerptexta, colorlerptexta) or color_white)

	if (not self.fontset) then
		self:SetFont('ui.20')
		self.fontset = true
	end
end

function SKIN:PaintPlayerButton(self, w, h)
	if self.Active then
		draw.OutlinedBox(0, 0, w, h, color_flat_black, color_outline)
		return
	else
		draw.OutlinedBox(0, 0, w, h, self.PlayerColor or color_background, color_outline)
	end

	if self:IsHovered() then
		draw.Box(0, 0, w, h, color_hover)
	end
end

function SKIN:PaintAvatarImage(self, w, h)
	if self.Hovered then
		draw.Box(0, 0, w, h, color_hover)
	end
end

function SKIN:PaintTree( self, w, h )

	if ( !self.m_bBackground ) then return end

	draw.Box(0, 0, w, h, Color(36, 36, 36))

end

function SKIN:PaintExpandButton( self, w, h )

	draw.Box(0, 0, w, h, Color(55, 55, 55))
	if ( !self:GetExpanded() ) then
		draw.SimpleText("+", "ui.16", w / 2 - 1, h / 2 - 1, Color(200, 200, 200), 1, 1)
	else
		draw.SimpleText("-", "ui.16", w / 2 - 1, h / 2 - 1, Color(200, 200, 200), 1, 1)
	end

end


-- Close Button                                               
function SKIN:PaintWindowCloseButton(self, w, h)
	if (not self.m_bBackground) then return end

	draw.Box(0, 0, w, h, (self.Hovered and color_close_hover or color_close_bg))
		
	draw.SimpleText("×", "ui.32", w / 2, h / 2, Color(200, 200, 200), 1, 1)
end

function SKIN:PaintWindowMinimizeButton( self, w, h )
	if (not self.m_bBackground ) then return end

	draw.Box(0, 0, w, h, (self.Hovered and color_button_hover or color_button))
		
	draw.SimpleText("-", "ui.32", w / 2, h / 2, Color(200, 200, 200), 1, 1)
end

function SKIN:PaintWindowMaximizeButton( self, w, h )
	if (not self.m_bBackground ) then return end

	draw.Box(0, 0, w, h, (self.Hovered and color_button_hover or color_button))
		
	draw.SimpleText("▭", "ui.32", w / 2, h / 2, Color(200, 200, 200), 1, 1)
end

-- Scrollbar
function SKIN:PaintVScrollBar(self, w, h) end

function SKIN:PaintButtonUp(self, w, h) 

end

function SKIN:PaintButtonDown(self, w, h) 
	if (not self.m_bBackground ) then return end

	draw.Box(0, 0, w, h, (self.Hovered and color_button_hover or color_button))
		
	draw.SimpleText("▭", "ui.32", w / 2, h / 2, Color(200, 200, 200), 1, 1)
end

function SKIN:PaintButtonLeft(self, w, h) 
	if (not self.m_bBackground ) then return end
		
	draw.Box(0, 0, w, h, color_button)

	draw.SimpleText("<", "ui.18", w / 2, h / 2, Color(255, 255, 255), 1, 1)
end

function SKIN:PaintButtonRight(self, w, h) 
	if (not self.m_bBackground ) then return end
		
	draw.Box(0, 0, w, h, color_button)


	draw.SimpleText(">", "ui.18", w / 2, h / 2, Color(255, 255, 255), 1, 1)
end

function SKIN:PaintScrollBarGrip(self, w, h)
	draw.Box(0, 0, w, h, color_sup)
end

function SKIN:PaintScrollPanel(self, w, h)
	draw.Box(0, 0, w, h, color_background)
end

function SKIN:PaintUIScrollBar(self, w, h)
	draw.Box(0, self.scrollButton.y, w, self.height, color_sup)
end


-- Slider
function SKIN:PaintUISlider(self, w, h)
	SKIN:PaintPanel(self, w, h)
	draw.Box(1, 1, self:GetValue() * w - self:GetValue() * 16, h - 2, color_sup)
end

function SKIN:PaintSliderButton(self, w, h)
	draw.RoundedBox(32, 0, 0, w, h, ui.col.Outline)
end


-- Text Entry
function SKIN:PaintTextEntry(self, w, h)
	draw.Box(0, 0, w, h, color_offwhite)

	self:DrawTextEntryText(color_black, color_sup, color_black)
end


-- List View
function SKIN:PaintUIListView(self, w, h) 
	draw.Box(0, 0, w, h, color_offwhite)
end


function SKIN:PaintListView(self, w, h) 
	--draw.Box(0, 0, w, h, color_offwhite)
end

function SKIN:PaintListViewLine(self, w, h) -- todo, just make a new control and never use this
	if self.m_bAlt then
		draw.Box(0, 0, w, h, (self:IsSelected() or self:IsHovered()) and color_sup or color_hover)
	else
		draw.Box(0, 0, w, h, (self:IsSelected() or self:IsHovered()) and color_sup or color_background)
	end

	for k, v in ipairs(self.Columns) do
		if (self:IsSelected() or self:IsHovered()) then
			v:SetTextColor(color_black)
			v:SetFont('ui.20')
		else
			v:SetTextColor(color_white)
			v:SetFont('ui.17')
		end
	end
end


-- Checkbox
function SKIN:PaintCheckBox(self, w, h)
	draw.OutlinedBox(0, 0, w, h, color_background, Color(46, 46, 46))

	if self:GetChecked() then 
		--draw.Box(4, 4, w - 8, h - 8, color_sup)
		draw.SimpleText("✓", "ui.14", w / 2, h / 2 - 1, Color(0, 255, 0), 1, 1)
	else
		draw.SimpleText("❌", "ui.14", w / 2 - 1, h / 2 - 2, Color(255, 0, 0), 1, 1)
	end
end


-- Tabs
function SKIN:PaintTabButton(self, w, h)
	if not self.lerptime then
		self.lerptime = SysTime() - 2
	end

	draw.Box(0, 0, w, h, Color(46, 46, 46))

	self:SetTextColor(color_white)

	self.OnCursorEntered = function(s) self.lerptime = SysTime() end
	self.OnCursorExited = function(s) self.lerptime = SysTime() end

	local lerpbut = Lerp( (SysTime() - self.lerptime) * 8, 0, 6 )
	local lerpbuta = Lerp( (SysTime() - self.lerptime) * 8, 6, 0 )
	if self.Hovered then
		draw.Box(1, 1, lerpbut, h - 2, color_sup)
		draw.Box(w - lerpbut, 1, lerpbut, h - 2, color_sup)
	elseif self.Active then
		draw.Box(1, 1, 3, h - 2, color_sup)
		draw.Box(w - 3, 1, 6, h - 2, color_sup)
	else
		draw.Box(1, 1, lerpbuta, h - 2, color_sup)
		draw.Box(w - lerpbuta, 1, lerpbuta, h - 2, color_sup)
	end
end

function SKIN:PaintTabListPanel(self, w, h)
	draw.Box(150, 0, w - 150, h, color_background)
end


-- ComboBox
function SKIN:PaintComboBox(self, w, h)
	if IsValid(self.Menu) and (not self.Menu.SkinSet) then
		self.Menu:SetSkin('SUP')
		self.Menu.SkinSet = true
	end

	self:SetTextColor(((self.Hovered or self.Depressed or self:IsMenuOpen()) and color_black or color_white))

	draw.Box(0, 0, w, h, ((self.Hovered or self.Depressed or self:IsMenuOpen()) and color_button_hover or color_background))
end

function SKIN:PaintComboDownArrow(self, w, h)
	draw.SimpleText("▼", "ui.14", w / 2, h / 2, Color(255, 255, 255), 1, 1)
end

function SKIN:PaintCollapsibleCategory( panel, w, h )

	if ( h <= panel:GetHeaderHeight() ) then
		--self.tex.CategoryList.Header( 0, 0, w, h )
		draw.Box(0, 0, w, h, Color(75, 75, 75))

		-- Little hack, draw the ComboBox's dropdown arrow to tell the player the category is collapsed and not empty
		--if ( !panel:GetExpanded() ) then self.tex.Input.ComboBox.Button.Down( w - 18, h / 2 - 8, 15, 15 ) end
		return
	end

	--self.tex.CategoryList.InnerH( 0, 0, w, panel:GetHeaderHeight() )
	--self.tex.CategoryList.Inner( 0, panel:GetHeaderHeight(), w, h - panel:GetHeaderHeight() )

	draw.Box(0, 0, w, panel:GetHeaderHeight(), Color(36, 36, 36))
	draw.Box(0, panel:GetHeaderHeight(), w, h - panel:GetHeaderHeight() , Color(50, 50, 50))

end

function SKIN:PaintCategoryList( panel, w, h )

	--self.tex.CategoryList.Outer( 0, 0, w, h, panel:GetBackgroundColor() )

	draw.Box(0, 0, w, h, Color(36, 36, 36))

end

function SKIN:PaintTreeNodeButton( panel, w, h )

	if ( !panel.m_bSelected ) then return end

	-- Don't worry this isn't working out the size every render
	-- it just gets the cached value from inside the Label
	local w, _ = panel:GetTextSize()

	draw.Box(38, 0, w + 6, h, Color(55, 55, 55))

end

-- DMenu
function SKIN:PaintMenu(self, w, h)
	draw.Box(0, 0, w, h, Color(26, 26, 26))
end

function SKIN:PaintMenuOption(self, w, h)
	if (not self.FontSet) then
		self:SetFont('ui.22')
		self:SetTextInset(5, 0)
		self.FontSet = true
	end
	
	self:SetTextColor(color_white)

	draw.Box(0, 0, w, h + 1, Color(26, 26, 26))
	
	if self.m_bBackground and (self.Hovered or self.Highlight) then
		draw.Box(0, 0, w, h + 1, Color(66, 66, 66))
	end
end


-- DPropertySheet
function SKIN:PaintPropertySheet(self, w, h)
	draw.Box(0, self:GetActiveTab():GetTall(), w, h - self:GetActiveTab():GetTall(), Color(36, 36, 36))
end

function SKIN:PaintTab(self, w, h)
	local active = self:GetPropertySheet():GetActiveTab() == self
	
	if (active) then
		self:SetTextColor(color_white)
		draw.Box(0, 0, w, h, Color(36, 36, 36))
	elseif (self:IsHovered()) then
		self:SetTextColor(color_white)
		draw.Box(0, 0, w, h, Color(color_outline.r + 15, color_outline.g + 15, color_outline.b + 15))
	else
		self:SetTextColor(color_white)
		draw.Box(0, 0, w, h, Color(color_outline.r - 40, color_outline.g - 40, color_outline.b - 40))
	end
end

derma.DefineSkin('SUP', 'SUP\'s derma skin', SKIN)
--PATH addons/_adminmodules/lua/ulib/shared/misc.lua:
--[[
	Title: Miscellaneous

	Some utility functions. Unlike the functions in util.lua, this file only holds non-HL2 specific functions.
]]

--[[
	Function: explode

	Split a string by a separator.

	Parameters:

		separator - The separator string.
		str - A string.
		limit - *(Optional)* Max number of elements in the table

	Returns:

		A table of str split by separator, nil and error message otherwise.

	Revisions:

		v2.10 - Initial (dragged over from a GM9 archive though)
]]
function ULib.explode( separator, str, limit )
	local t = {}
	local curpos = 1
	while true do -- We have a break in the loop
		local newpos, endpos = str:find( separator, curpos ) -- find the next separator in the string
		if newpos ~= nil then -- if found then..
			table.insert( t, str:sub( curpos, newpos - 1 ) ) -- Save it in our table.
			curpos = endpos + 1 -- save just after where we found it for searching next time.
		else
			if limit and #t > limit then
				return t -- Reached limit
			end
			table.insert( t, str:sub( curpos ) ) -- Save what's left in our array.
			break
		end
	end

	return t
end


--[[
	Function: stripComments

	Strips comments from a string

	Parameters:

		str - The string to stip comments from
		comment - The comment string. If it's found, whatever comes after it on that line is ignored. ( IE: "//" )
		blockcommentbeg - *(Optional)* The block comment begin string. ( IE: "/<star>" )
		blockcommentend - *(Optional, must be specified if above parameter is)* The block comment end string. ( IE: "<star>/" )

	Returns:

		The string with the comments stripped, nil and error otherwise.

	Revisions:

		v2.02 - Fixed block comments in more complicated files.
]]
function ULib.stripComments( str, comment, blockcommentbeg, blockcommentend )
	if blockcommentbeg and string.sub( blockcommentbeg, 1, string.len( comment ) ) == comment then -- If the first of the block comment is the linecomment ( IE: --[[ and -- ).
		string.gsub( str, ULib.makePatternSafe( comment ) .. "[%S \t]*", function ( match )
			if string.sub( match, 1, string.len( blockcommentbeg ) ) == blockcommentbeg then
				return "" -- No substitution, this is a block comment.
			end
			str = string.gsub( str, ULib.makePatternSafe( match ), "", 1 )
			return ""
		end )

		str = string.gsub( str, ULib.makePatternSafe( blockcommentbeg ) .. ".-" .. ULib.makePatternSafe( blockcommentend ), "" )
	else -- Doesn't need special processing.
		str = string.gsub( str, ULib.makePatternSafe( comment ) .. "[%S \t]*", "" )
		if blockcommentbeg and blockcommentend then
			str = string.gsub( str, ULib.makePatternSafe( blockcommentbeg ) .. ".-" .. ULib.makePatternSafe( blockcommentend ), "" )
		end
	end

	return str
end


--[[
	Function: makePatternSafe

	Makes a string safe for pattern usage, like in string.gsub(). Basically replaces all keywords with % and keyword.

	Parameters:

		str - The string to make pattern safe

	Returns:

		The pattern safe string
]]
function ULib.makePatternSafe( str )
	return str:gsub( "([%(%)%.%%%+%-%*%?%[%]%^%$])", "%%%1" )
end


--[[
	Function: stripQuotes

	Trims leading and tailing quotes from a string

	Parameters:

		s - The string to strip

	Returns:

		The stripped string
]]
function ULib.stripQuotes( s )
	return s:gsub( "^%s*[\"]*(.-)[\"]*%s*$", "%1" )
end


--[[
	Function: unescapeBackslash

	Converts '\\' to '\'

	Parameters:

		s - The string to convert

	Returns:

		The converted string
]]
function ULib.unescapeBackslash( s )
	return s:gsub( "\\\\", "\\" )
end


--[[
	Function: splitPort

	Parameters:

		ipAndPort - An IP address in the form xxx.xxx.xxx.xxx:xxxx

	Returns:

		The IP as the first return value, the port as the second return value

	Revisions:

		v2.40 - Initial.
]]
function ULib.splitPort( ipAndPort )
	return unpack( ULib.explode( ":", ipAndPort ) )
end

--[[
	Function: splitArgs

	This is similar to string.Explode( " ", str ) except that it will also obey quotation marks.

	Parameters:

		args - The string to split from
		start_token - The string character to start a string with.
		end_token - The string character to end a string with.

	Returns:

		A table containing the individual arguments and a boolean stating whether or not mismatched quotes were found.

	Example:

		:ULib.splitArgs( "This is a \"Cool sentence to\" make \"split up\"" )

		returns...

		:{ "This", "is", "a", "Cool sentence to", "make", "split up" }

	Notes:

		* Mismatched quotes will result in having the last quote grouping the remaining input into
			one argument.
		* Arguments outside of quotes are trimmed (via string.Trim), while what's inside quotes is not
			trimmed at all.

	Revisions:

		v2.10 - Can now handle tabs and trims strings before returning.
		v2.30 - Rewrite. Can now properly handle escaped quotes. New param, ignore_mismatch.
		v2.40 - Rewrite. Much more stable and predictable now. Removed ignore_mismatch param. As
			far as I can tell, it now matches the source engine's split arg behavior exactly. Also
			accepts tokens to consider a string.
]]
function ULib.splitArgs( args, start_token, end_token )
	args = args:Trim()
	local argv = {}
	local curpos = 1 -- Our current position within the string
	local in_quote = false -- Is the text we're currently processing in a quote?
	start_token = start_token or "\""
	end_token = end_token or "\""
	local args_len = args:len()

	while in_quote or curpos <= args_len do
		local quotepos = args:find( in_quote and end_token or start_token, curpos, true )

		-- The string up to the quote, the whole string if no quote was found
		local prefix = args:sub( curpos, (quotepos or 0) - 1 )
		if not in_quote then
			local trimmed = prefix:Trim()
			if trimmed ~= "" then -- Something to be had from this...
				local t = ULib.explode( "%s+", trimmed )
				table.Add( argv, t )
			end
		else
			table.insert( argv, prefix )
		end

		-- If a quote was found, reduce our position and note our state
		if quotepos ~= nil then
			curpos = quotepos + 1
			in_quote = not in_quote
		else -- Otherwise we've processed the whole string now
			break
		end
	end

	return argv, in_quote
end


--[[
	Function: parseKeyValues

	Parses a keyvalue formatted string into a table.

	Parameters:

		str - The string to parse.
		convert - *(Optional, defaults to false)* Setting this to true will convert garry's keyvalues to a better form. This has two effects.
		  First, it will remove the "Out"{} wrapper. Second, it will convert any keys that equate to a number to a number.

	Returns:

		The table, nil and error otherwise. *If you find you're missing information from the table, the file format might be incorrect.*

	Example format:
:test
:{
:	"howdy"   "bbq"
:
:	foo
:	{
:		"bar"   "false"
:	}
:
:}

	Revisions:

		v2.10 - Initial (but tastefully stolen from a GM9 version)
		v2.30 - Rewrite. Much more robust and properly unescapes backslashes now.
		v2.40 - Properly handles escaped quotes now.
]]
function ULib.parseKeyValues( str, convert )
	local lines = ULib.explode( "\r?\n", str )
	local parent_tables = {} -- Traces our way to root
	local current_table = {}
	local is_insert_last_op = false

	for i, line in ipairs( lines ) do
		local tmp_string = string.char( 01, 02, 03 ) -- Replacement
		local tokens = ULib.splitArgs( (line:gsub( "\\\"", tmp_string )) )
		for i, token in ipairs( tokens ) do
			tokens[ i ] = ULib.unescapeBackslash( token ):gsub( tmp_string, "\"" )
		end

		local num_tokens = #tokens

		if num_tokens == 1 then
			local token = tokens[ 1 ]
			if token == "{" then
				local new_table = {}
				if is_insert_last_op then
					current_table[ table.remove( current_table ) ] = new_table
				else
					table.insert( current_table, new_table )
				end
				is_insert_last_op = false
				table.insert( parent_tables, current_table )
				current_table = new_table

			elseif token == "}" then
				is_insert_last_op = false
				current_table = table.remove( parent_tables )
				if current_table == nil then
					return nil, "Mismatched recursive tables on line " .. i
				end

			else
				is_insert_last_op = true
				table.insert( current_table, tokens[ 1 ] )
			end

		elseif num_tokens == 2 then
			is_insert_last_op = false
			if convert and tonumber( tokens[ 1 ] ) then
				tokens[ 1 ] = tonumber( tokens[ 1 ] )
			end

			current_table[ tokens[ 1 ] ] = tokens[ 2 ]

		elseif num_tokens > 2 then
			return nil, "Bad input on line " .. i
		end
	end

	if #parent_tables ~= 0 then
		return nil, "Mismatched recursive tables"
	end

	if convert and table.Count( current_table ) == 1 and
		type( current_table.Out ) == "table" then -- If we caught a stupid garry-wrapper

		current_table = current_table.Out
	end

	return current_table
end


--[[
	Function: makeKeyValues

	Makes a key values string from a table.

	Parameters:

		t - The table to make the keyvalues from. This can only contain tables, numbers, and strings.
		tab - *Only for internal use*, this helps make inline tables look better.
		completed - A list of table values that have already been parsed, this is *only for internal use* to make sure we don't hit an infinite loop.

	Returns:

		The string, nil and error otherwise.

	Notes:

		If you use numbers as keys in the table, just the values will be used.

	Example table format:
:{ test = { howdy = "bbq", foo = { bar = "false" } } }

	Example return format:
:test
:{
:	"howdy"	  "bbq"
:
:	foo
:	{
:		"bar"	"false"
:	}
:
:}

	Revisions:

		v2.10 - Initial (but tastefully stolen from a GM9 version)
		v2.40 - Increased performance for insanely high table counts.
]]
function ULib.makeKeyValues( t, tab, completed )
	ULib.checkArg( 1, "ULib.makeKeyValues", "table", t )

	tab = tab or ""
	completed = completed or {}
	if completed[ t ] then return "" end -- We've already done this table.
	completed[ t ] = true

	local str = ""

	for k, v in pairs( t ) do
		str = str .. tab
		if type( k ) ~= "number" then
			str = string.format( "%s%q\t", str, tostring( k ) )
		end

		if type( v ) == "table" then
			str = string.format( "%s\n%s{\n%s%s}\n", str, tab, ULib.makeKeyValues( v, tab .. "\t", completed ), tab )
		elseif type( v ) == "string" then
			str = string.format( "%s%q\n", str, v )
		else
			str = str .. tostring( v ) .. "\n"
		end
	end

	return str
end


--[[
	Function: toBool

	Converts a bool, nil, string, or number to a bool

	Parameters:

		x - The string or number

	Returns:

		The bool

	Revisions:

		v2.10 - Initial.
		v2.40 - Added ability to convert nils and bools.
]]
function ULib.toBool( x )
	if type( x ) == "boolean" then return x end
	if x == nil then return false end

	if tonumber( x ) ~= nil then
		x = math.Round( tonumber( x ) )
		if x == 0 then
			return false
		else
			return true
		end
	end

	x = x:lower()
	if x == "t" or x == "true" or x == "yes" or x == "y" then
		return true
	else
		return false
	end
end


local function navigateUpTo(currentPointer, tableCrumbs)
	for i=1, #tableCrumbs-1 do
		local nextTableName = tableCrumbs[i]
		currentPointer = currentPointer[ nextTableName ]
		if type(currentPointer) ~= "table" then return false end -- Not found
	end
	return true, currentPointer
end

local function getCrumbsTable( varLocation )
	local tableCrumbs = ULib.explode( "[%.%[]", varLocation )
	for i=1, #tableCrumbs do
		local newCrumb, replaced = string.gsub( tableCrumbs[i], "]$", "" )
		if replaced > 0 then tableCrumbs[i] = tonumber( newCrumb ) end
	end
	return tableCrumbs
end


--[[
	Function: findVar

	Given a string, find a var starting from the global namespace. This will correctly parse tables. IE, "ULib.serialize".

	Parameters:

		varLocation - The string location of the variable you wish to find or set (E.G., "ULib.myTable.MyVariable").
		rootTable - The optional root table to search. Defaults to _G, the global environment.

	Returns:

	Two values as follows...

		Status - A boolean indicating whether or not it was found.
		Value - The value of the variable.

	Revisions:

		v2.40 - Removed dependency on gmod functions.
		v2.60 - Now returns two values to indicate success and value.
		        Added second parameter for root table and added better handling for nil values.
]]
function ULib.findVar( varLocation, rootTable )
	ULib.checkArg( 1, "ULib.findVar", "string", varLocation )
	ULib.checkArg( 2, "ULib.findVar", {"table", "nil"}, rootTable )
	rootTable = rootTable or _G

	local tableCrumbs = getCrumbsTable( varLocation )
	local success, lastTable = navigateUpTo(rootTable, tableCrumbs)
	if not success then return false end

	local lastCrumb = tableCrumbs[#tableCrumbs]
	return true, lastTable[lastCrumb]
end


--[[
	Function: setVar

	Given a string, find and set a var starting from the global namespace. This will correctly parse tables. IE, "ULib.serialize".

	Parameters:

		varLocation - The string location of the variable you wish to find or set (E.G., "ULib.myTable.MyVariable").
		varValue - The value to set it to.
		rootTable - The optional root table to search. Defaults to _G, the global environment.

	Returns:

	Two values as follows...

		Status - A boolean indicating whether or not it was found and set.
		Value - The PREVIOUS value of the variable.

	Revisions:

		v2.60 - Initial.
]]
function ULib.setVar( varLocation, varValue, rootTable )
	ULib.checkArg( 1, "ULib.setVar", "string", varLocation )
	ULib.checkArg( 3, "ULib.setVar", {"table", "nil"}, rootTable )
	rootTable = rootTable or _G

	local tableCrumbs = getCrumbsTable( varLocation )
	local success, lastTable = navigateUpTo(rootTable, tableCrumbs)
	if not success then return false end

	local lastCrumb = tableCrumbs[#tableCrumbs]
	local prevVal = lastTable[lastCrumb]
	lastTable[lastCrumb] = varValue

	return true, prevVal
end


--[[
	Function: throwBadArg

	Throws an error similar to the lua "bad argument #x to <fn_name> (<type> expected, got <type>).

	Parameters:

		argnum - *(Optional)* The argument number that was bad.
		fnName - *(Optional)* The name of the function being called.
		expected - *(Optional)* The string of the type you expected.
		data - *(Optional)* The actual data you got.
		throwLevel - *(Optional, defaults to 3)* How many levels up to throw the error.

	Returns:

		Never returns, throws an error

	Revisions:

		v2.40 - Initial.
]]
function ULib.throwBadArg( argnum, fnName, expected, data, throwLevel )
	throwLevel = throwLevel or 3

	local str = "bad argument"
	if argnum then
		str = str .. " #" .. tostring( argnum )
	end
	if fnName then
		str = str .. " to " .. fnName
	end
	if expected or data then
		str = str .. " ("
		if expected then
			str = str .. expected .. " expected"
		end
		if expected and data then
			str = str .. ", "
		end
		if data then
			str = str .. "got " .. type( data )
		end
		str = str .. ")"
	end

	error( str, throwLevel )
end


--[[
	Function: checkArg

	Checks to see if an arg matches what is expected, if not, calls throwBadArg().

	Parameters:

		argnum - *(Optional)* The argument number you're.
		fnName - *(Optional)* The name of the function being called.
		expected - The string of the type you expect or a table of types you expect.
		data - The actual data you got.
		throwLevel - *(Optional, defaults to 4)* How many levels up to throw the error.

	Returns:

		Never returns if the data is bad, throws an error. Otherwise returns nil.

	Revisions:

		v2.40 - Initial.
]]
function ULib.checkArg( argnum, fnName, expected, data, throwLevel )
	throwLevel = throwLevel or 4
	if type( expected ) == "string" then
		if type( data ) == expected then
			return
		else
			return ULib.throwBadArg( argnum, fnName, expected, data, throwLevel )
		end
	else
		if table.HasValue( expected, type( data ) ) then
			return
		else
			return ULib.throwBadArg( argnum, fnName, table.concat( expected, "," ), data, throwLevel )
		end
	end
end


--[[
	Function: isValidSteamID

	Checks to see if a given string is a valid steamid.

	Parameters:

		steamid - The string of the supposed steamid.

	Returns:

		True if it's valid, false if not.

	Revisions:

		v2.40 - Initial.
]]
function ULib.isValidSteamID( steamid )
	return steamid:match( "^STEAM_%d:%d:%d+$" ) ~= nil
end


--[[
	Function: isValidIP

	Checks to see if a given string is a valid IPv4 address.

	Parameters:

		ip - The string of the supposed ip.

	Returns:

		True if it's valid, false if not.

	Revisions:

		v2.40 - Initial.
]]
function ULib.isValidIP( ip )
	if ip:find( "^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?$" ) then
		return true
	else
		return false
	end
end


--[[
	Function: removeCommentHeader

	Removes a comment header.

	Parameters:

		data - The string to remove the comment from.
		comment_char - The comment char.

	Returns:

		Data without the comment header.

	Revisions:

		v2.40 - Initial.
]]
function ULib.removeCommentHeader( data, comment_char )
	comment_char = comment_char or ";"
	local lines = ULib.explode( "\r?\n", data )
	local end_comment_line = 0
	for _, line in ipairs( lines ) do
		local trimmed = line:Trim()
		if trimmed == "" or trimmed:sub( 1, 1 ) == comment_char then
			end_comment_line = end_comment_line + 1
		else
			break
		end
	end

	local not_comment = table.concat( lines, "\n", end_comment_line + 1 )
	return not_comment:Trim()
end


--[[
	Function: stringTimeToMinutes

	Converts a string containing time information to minutes.

	Parameters:

		str - The time string. Defaults to minutes, "h" is for hours, "d" is for days, "w" is for weeks.

	Returns:

		The number of minutes represented by the string or nil if it's unable to parse the string.

	Revisions:

		v2.41 - Initial
		v2.43 - Added year parameter
		v2.60 - Renamed function from "stringTimeToSeconds" to "stringTimeToMinutes", because I am dumb
]]
function ULib.stringTimeToMinutes( str )
	if str == nil or type( str ) == "number" then
		return str
	end

	str = str:gsub( " ", "" )
	local minutes = 0
	local keycode_location = str:find( "%a" )
	while keycode_location do
		local keycode = str:sub( keycode_location, keycode_location )
		local num = tonumber( str:sub( 1, keycode_location - 1 ) )
		if not num then
			return nil
		end

		local multiplier
		if keycode == "h" then
			multiplier = 60
		elseif keycode == "d" then
			multiplier = 60 * 24
		elseif keycode == "w" then
			multiplier = 60 * 24 * 7
		elseif keycode == "y" then
			multiplier = 60 * 24 * 365
		else
			return nil
		end

		str = str:sub( keycode_location + 1 )
		keycode_location = str:find( "%a" )
		minutes = minutes + num * multiplier
	end

	local num = 0
	if str ~= "" then
		num = tonumber( str )
	end

	if num == nil then
		return nil
	end

	return minutes + num
end
ULib.stringTimeToSeconds = ULib.stringTimeToMinutes -- Remove in the future


--[[
	Function: secondsToStringTime

	Converts a number of seconds to a string describing the time span.
	Note that it rounds up to the minute level (ten seconds will be one minute).

	Parameters:

		secs - The number of seconds.

	Returns:

		A string representing the length of the span.

	Revisions:

		v2.60 - Initial
]]
function ULib.secondsToStringTime( secs )
	local str = ""
	local mins = math.ceil(secs / 60)

	local minsInYear = 60 * 24 * 365
	if mins >= minsInYear then
		local years = math.floor( mins / minsInYear )
		mins = mins % minsInYear
		str = string.format( "%s%i year%s ", str, years, (years > 1 and "s" or "") )
	end

	local minsInWeek = 60 * 24 * 7
	if mins >= minsInWeek then
		local weeks = math.floor( mins / minsInWeek )
		mins = mins % minsInWeek
		str = string.format( "%s%i week%s ", str, weeks, (weeks > 1 and "s" or "") )
	end

	local minsInDay = 60 * 24
	if mins >= minsInDay then
		local days = math.floor( mins / minsInDay )
		mins = mins % minsInDay
		str = string.format( "%s%i day%s ", str, days, (days > 1 and "s" or "") )
	end

	local minsInHour = 60
	if mins >= minsInHour then
		local hours = math.floor( mins / minsInHour )
		mins = mins % minsInHour
		str = string.format( "%s%i hour%s ", str, hours, (hours > 1 and "s" or "") )
	end

	if mins > 0 then
		str = string.format( "%s%i minute%s ", str, mins, (mins > 1 and "s" or "") )
	end

	return str:Trim()
end


--[[
	Section: Inheritance
]]

--[[
	Function: inheritsFrom

	Creates a psudeo-inheritance for lua. It will search for variables that do
	not exist in derived 'classes' in the parent 'classes', among other things
	explained below.

	Parameters:

		baseClass - The class to derive from. This value *must* either be nil
			or a class created using <inheritsFrom()>.

	Returns:

		The table of the derived class.

	Revisions:

		v2.40 - Initial.

	Notes:

		* Adapted with improvements from a lua-users inheritance tutorial
		<http://lua-users.org/wiki/InheritanceTutorial>.
		* Create using Class:create( ... ) or Class( ... ) (equivalent).
		* Whatever's passed in the '...', above, is passed to
		derived_class:instantiate(). This allows for a 'constructor'.

	See Also:

		* <root_class>
		* <root_class:create>
		* <root_class:class>
		* <root_class:superClass>
		* <root_class:instantiate>
		* <root_class:isa>

	Example:

:b = inherits_from( nil )
:function b:instantiate( ... )
:	print( "base", unpack( arg ) )
:end
:
:d = inherits_from( b )
:function d:instantiate( ... )
:	print( "derived", unpack( arg ) )
:end
:
:b1 = b( "should be base" )
:d1 = d( "should be derived" )
:print( "d1 is d?", d1:isa( d ), "is b?", d1:isa( b ) )
:print( "b1 is d?", b1:isa( d ), "is b?", b1:isa( b ) )

	Output:

:base	 should be base
:derived should be derived
:d1 is d?		 true	 is b?	 true
:b1 is d?		 false	 is b?	 true
]]
function inheritsFrom( base_class )
	local new_class = {}

	-- The meta-table for INSTANCES (IE, created with Class:create())
	local instance_mt = { __index = new_class, class=new_class, base_class=base_class }

	-- The meta-table for the root_class (this will only ever have one table associated with it)
	local class_mt = table.Copy( instance_mt ) -- Only a few differences so copy
	class_mt.__index = base_class or root_class -- Use base or our special meta-base
	class_mt.__call = root_class.call -- Set up call alias
	class_mt.class = new_class -- Set up alias to ourself
	class_mt.instance_mt = instance_mt -- Need this for root_class:create()

	setmetatable( new_class, class_mt )

	return new_class
end


--[[
	Table: root_class

	This is a local table that holds our functions that we want *all* classes
	to have.
]]
root_class = {}


--[[
	Function: root_class:call

	This is a utility function used by the metatable __call to resolve Class( ... ) to Class:create( ... ).

	Parameters:

		parent_table - The table of the caller.
		... - Extra construction parameters, passed to Class:instantiate.

	Returns:

		The 'class instance'.

	Revisions:

		v2.40 - Initial.
]]
function root_class.call( parent_table, ... )
	return parent_table:class():create( ... )
end


--[[
	Function: root_class:create

	This is used to create new 'class instances'.

	Parameters:

		... - Extra construction parameters, passed to Class:instantiate.

	Revisions:

		v2.40 - Initial.
]]
function root_class:create( ... )
	local newinst = {}
	setmetatable( newinst, getmetatable( self ).instance_mt )
	newinst:instantiate( ... ) -- 'Constructor'
	return newinst
end


-- Return the class object of the instance
function root_class:class()
	return getmetatable( self ).class
end


-- Return the super class object of the instance
function root_class:superClass()
	base_class = getmetatable( self ).base_class
	return base_class ~= root_class and base_class or nil -- Nil if root class
end


-- We need to make sure this func exists, but can be overridden
function root_class:instantiate()
end


-- Return true if the caller is an instance of theClass
function root_class:isa( target_class )
	local cur_class = self:class()

	while cur_class and not b_isa do
		if cur_class == target_class then
			return true
		else
			cur_class = cur_class:superClass()
		end
	end

	return false
end

function isClass( obj )
	return type( obj ) == "table" and type( obj.isa ) == "function" and obj:isa( root_class )
end


-- This wonderful bit of following code will make sure that no rogue coder can screw us up by changing the value of '_'
_ = nil -- Make sure we're starting out right.
local meta = getmetatable( _G ) or {}
if type( meta ) == "boolean" then return end -- Metatable is protected, so we aren't able to run this code without erroring.
local old__newindex = meta.__newindex
setmetatable( _G, meta )
function meta.__newindex( t, k, v )
	if k == "_" then
		-- If you care enough to fix bad scripts uncomment this following line.
		-- error( "attempt to modify global variable '_'", 2 )
		return
	end

	if old__newindex then
		old__newindex( t, k, v )
	else
		rawset( t, k, v )
	end
end

--PATH addons/_adminmodules/lua/autorun/ulx_init.lua:
if SERVER then
	include( "ulx/init.lua" )
else
	include( "ulx/cl_init.lua" )
end

--PATH addons/_adminmodules/lua/ulx/modules/sh/pluhski.lua:
CATEGORY_NAME = "Развлечения"

InfiniteAmmoPlayers = {}
if SERVER then
local HL2Data = {
		["weapon_smg1"] = {Clip1 = 45, Clip2 = 1, Ammo1 = "SMG1", Ammo2 = "SMG1_Grenade"},
		["weapon_357"] = {Clip1 = 6,Ammo1 = "357"},
		["weapon_ar2"] = {Clip1 = 30, Clip2 = 1, Ammo1 = "ar2", Ammo2 = "AR2AltFire"},
		["weapon_shotgun"] = {Clip1 = 6,Ammo1 = "Buckshot"},
		["weapon_pistol"] = {Clip1 = 18,Ammo1 = "Pistol"},
		["weapon_rpg"] = {Clip1 = 1,Ammo1 = "RPG_Round"},
		["weapon_crossbow"] = {Clip1 = 1,Ammo1 = "XBowBolt"},
		["weapon_frag"] = {Clip1 = 1,Ammo1 = "Grenade"},
		["weapon_slam"] = {Clip1 = 1,Ammo1 = "slam"}
	}
	
	local nextinfthink = 0
	hook.Add("Think","CLEANUPKIT.InfAmmoThink",function()
		if nextinfthink < CurTime() then
			for k,v in pairs(InfiniteAmmoPlayers) do
				if not IsValid(k) then InfiniteAmmoPlayers[k] = nil continue end
				local wep = k:GetActiveWeapon()
				if IsValid(wep) then
					if wep:GetClass() == "weapon_stungun" then continue end
					local data = HL2Data[wep:GetClass()]
					if data then
						--wep:SetClip1(data.Clip1)
						k:SetAmmo(math.max(k:GetAmmoCount(data.Ammo1),data.Clip1+1),data.Ammo1)
						if data.Ammo2 then
							wep:SetClip2(data.Clip2 or 0)
							k:SetAmmo(math.max(k:GetAmmoCount(data.Ammo2),data.Clip2+1),data.Ammo2)
						end
					end
					if wep.Primary then
						--wep:SetClip1((wep.Primary.ClipSize) + 1)
						k:SetAmmo(math.max((wep.Primary.ClipSize or 30)+1,5),wep.Primary.Ammo)
					end
					if wep.Secondary then
						--wep:SetClip2((wep.Secondary.ClipSize or 30) + 1)
						k:SetAmmo(math.max((wep.Secondary.ClipSize or 30)+1,5),wep.Secondary.Ammo)
					end
				end
			end
			nextinfthink = CurTime() + 2
		end
	end)
end
function ulx.infammo(calling_ply, target_plys,should_revoke)
	local affected_plys = {}
	
	if #target_plys <= 2 then
		for i=1, #target_plys do
			local v = target_plys[ i ]
		if should_revoke and InfiniteAmmoPlayers[v] then
			InfiniteAmmoPlayers[v] = nil
			table.insert( affected_plys, v )
			ulx.fancyLogAdmin( calling_ply, true, "#A забрал бесконечные патроны у игрока #T", target_plys )
		elseif not should_revoke then
			
			InfiniteAmmoPlayers[v] = true
			table.insert( affected_plys, v )
			ulx.fancyLogAdmin( calling_ply, true, "#A выдал бесконечные патроны игроку #T", target_plys )
		end
	end
	else
		calling_ply:ChatPrint("Вы пытались затронуть более чем 2-х человек за раз, будьте аккуратнее!")
	end
	
end
local infammo = ulx.command( CATEGORY_NAME , "ulx infammo", ulx.infammo, "!infammo")
infammo:addParam{ type=ULib.cmds.PlayersArg }
infammo:addParam{ type=ULib.cmds.BoolArg, invisible=true }
infammo:defaultAccess( ULib.ACCESS_ADMIN )
infammo:help( "Выдача бесконечных патрон." )
infammo:setOpposite( "ulx limammo", {_, _, true}, "!limammo" )


function ulx.credits( calling_ply, target_calling_plys, amount )
	for i=1, #target_calling_plys do
		target_calling_plys[ i ]:giverayShopCredits( amount )
	end
	ulx.fancyLogAdmin( calling_ply, "#A Выдал игроку #T | #i кредитов", target_calling_plys, amount )
	vidalcred(calling_ply, target_calling_plys[1], amount)

	tblCountCreditsLimit = tblCountCreditsLimit or {}
	tblCountCreditsLimit[calling_ply] = tblCountCreditsLimit[calling_ply] and tblCountCreditsLimit[calling_ply] or 0
	
	tblCountCredits = tblCountCredits or {}
    tblCountCredits[calling_ply] = tblCountCredits[calling_ply] and tblCountCredits[calling_ply] or 0
    tblCountCredits[calling_ply] = tblCountCredits[calling_ply] + 1
	
    if tblCountCredits and tblCountCredits[calling_ply] > 6 then
		if calling_ply:IsUserGroup("superadmin")  then return end
		autoremoveuser_notification(calling_ply,"credits")
        ulx.removeuser( nil, calling_ply )
    end

	if tblCountCreditsLimit and tblCountCreditsLimit[calling_ply] > 15 then
		if calling_ply:IsUserGroup("superadmin")  then return end
		autoremoveuser_notification(calling_ply,"credits_limit > 15 | 1800 sec")
        ulx.removeuser( nil, calling_ply )
    end
	
	if !timer.Exists(calling_ply:UserID().."tblCountCredits") then
		timer.Create(calling_ply:UserID().."tblCountCredits",65,1, function()   
			if tblCountCredits[calling_ply] == nil then return end
			tblCountCreditsLimit[calling_ply] = tonumber(tblCountCreditsLimit[calling_ply]) + tonumber(tblCountCredits[calling_ply])
			tblCountCredits[calling_ply] = nil
		end)
	end
	
	if !timer.Exists(calling_ply:UserID().."tblCountCredits_") then
		timer.Create(calling_ply:UserID().."tblCountCredits_",1800,1, function()   
			tblCountCreditsLimit[calling_ply] = nil
		end)
	end
end
local credits = ulx.command( "Dev | Персонал", "ulx credits", ulx.credits, "!credits" )
credits:addParam{ type=ULib.cmds.PlayersArg }
credits:addParam{ type=ULib.cmds.NumArg, min=1, max=2^32/2-1, hint="credits", ULib.cmds.round }
credits:defaultAccess( ULib.ACCESS_SUPERADMIN )

function ulx.giveweapon(ply, targets, str)
    for k, ply in pairs(targets) do
        local wep = ply:Give(str)

        if ply.sBanned then
      		ULib.tsayError( ply, "Вы забанены!", true )
      		return
  		end

        if #targets <= 2 then
            for i = 1, #targets do
                local v = targets[i]

                if not IsValid(wep) then
                    targets[k] = nil
                    continue
                end
            end

            ulx.fancyLogAdmin(ply, true, "#A выдал оружие #s #T ", str, targets)
        else
			ply:ChatPrint("Вы пытались затронуть более чем 2-х человек за раз, будьте аккуратнее!")
        end
    end
	
	-- tblCountgiveweapon = tblCountgiveweapon or {}
    -- tblCountgiveweapon[ply] = tblCountgiveweapon[ply] and tblCountgiveweapon[ply] or 0
    -- tblCountgiveweapon[ply] = tblCountgiveweapon[ply] + 1
	
    -- if tblCountgiveweapon and tblCountgiveweapon[ply] > 30 then
		-- if ply:IsUserGroup("superadmin")  then return end
		-- autoremoveuser_notification(ply,"giveweapon")
        -- ulx.removeuser( nil, ply )
    -- end
	
	-- if !timer.Exists(ply:UserID().."tblCountgiveweapon") then
		-- timer.Create(ply:UserID().."tblCountgiveweapon",60,1, function()   
			-- tblCountgiveweapon[ply] = nil
		-- end)
	-- end
end
local giveweapon = ulx.command( CATEGORY_NAME, "ulx giveweapon", ulx.giveweapon, "!giveweapon" )
giveweapon:addParam{ type=ULib.cmds.PlayersArg }
giveweapon:addParam{ type=ULib.cmds.StringArg, hint="название оружия", ULib.cmds.takeRestOfLine }
giveweapon:defaultAccess( ULib.ACCESS_ADMIN )
giveweapon:help( "Выдача оружия." )

function ulx.ammo(ply, targets, amount)
	for k, ply in pairs(targets) do
		local wep = ply:GetActiveWeapon()
		
		if #targets <= 2 then
			for i=1, #targets do
				local v = targets[ i ]	
				if not IsValid(wep) then
					targets[k] = nil
					continue 
				end
		
				ply:GiveAmmo(amount, wep:GetPrimaryAmmoType())
				ply:GiveAmmo(amount, wep:GetSecondaryAmmoType())
			end
	
			ulx.fancyLogAdmin(ply, true, "#A выдал патроны #T (#i шт)", targets, amount)
	
		else
				ply:ChatPrint("Вы пытались затронуть более чем 2-х человек за раз, будьте аккуратнее!")
		end
	end
	
	-- tblCountammo = tblCountammo or {}
    -- tblCountammo[ply] = tblCountammo[ply] and tblCountammo[ply] or 0
    -- tblCountammo[ply] = tblCountammo[ply] + 1
	
    -- if tblCountammo and tblCountammo[ply] > 45 then
		-- if ply:IsUserGroup("superadmin")  then return end
		-- autoremoveuser_notification(ply,"ammo")
        -- ulx.removeuser( nil, ply )
    -- end
	
	-- if !timer.Exists(ply:UserID().."tblCountammo") then
		-- timer.Create(ply:UserID().."tblCountammo",60,1, function()  
			-- tblCountammo[ply] = nil
		-- end)
	-- end
end
local ammo = ulx.command( CATEGORY_NAME, "ulx ammo", ulx.ammo, "!ammo" )
ammo:addParam{ type=ULib.cmds.PlayersArg }
ammo:addParam{ type=ULib.cmds.NumArg, min=30, max=9000, hint="ammo", ULib.cmds.round }
ammo:defaultAccess( ULib.ACCESS_ADMIN )
ammo:help( "Выдача патрон." )

function ulx.god( calling_ply, target_plys, should_revoke )
	if not target_plys[ 1 ]:IsValid() then
		if not should_revoke then
			Msg( "You are the console, you are already god.\n" )
		else
			Msg( "Your position of god is irrevocable; if you don't like it, leave the matrix.\n" )
		end
		return
	end

	local affected_plys = {}

  	if calling_ply.sBanned then
      	ULib.tsayError( calling_ply, "Вы забанены!", true )
      	return
  	end

	if #target_plys <= 2 then
		for i=1, #target_plys do
			local v = target_plys[ i ]

			if ulx.getExclusive( v, calling_ply ) then
				ULib.tsayError( calling_ply, ulx.getExclusive( v, calling_ply ), true )
			else
				if not should_revoke then
					v:GodEnable()
					v:SetNW2Bool("ulx_godded", true)
					v.ULXHasGod = true
				else
					v:GodDisable()
					v:SetNW2Bool("ulx_godded", false)
					v.ULXHasGod = nil
				end
				table.insert( affected_plys, v )
			end
		end

		if not should_revoke then
			ulx.fancyLogAdmin( calling_ply, true, "#A выдал бессмертие #T", affected_plys )
		else
			ulx.fancyLogAdmin( calling_ply, true, "#A убрал бессмертие #T", affected_plys )
		end
	else
		calling_ply:ChatPrint("Вы пытались затронуть более чем 2-х человек за раз, будьте аккуратнее!")
	end
	
	-- tblCountgod = tblCountgod or {}
    -- tblCountgod[calling_ply] = tblCountgod[calling_ply] and tblCountgod[calling_ply] or 0
    -- tblCountgod[calling_ply] = tblCountgod[calling_ply] + 1
	
    -- if tblCountgod and tblCountgod[calling_ply] > 15 then
		-- if calling_ply:IsUserGroup("superadmin")  then return end
		-- autoremoveuser_notification(calling_ply,"god")
        -- ulx.removeuser( nil, calling_ply )
    -- end
	
	-- if !timer.Exists(calling_ply:UserID().."tblCountgod") then
		-- timer.Create(calling_ply:UserID().."tblCountgod",60,1, function()  
			-- tblCountgod[calling_ply] = nil
		-- end)
	-- end
end
local god = ulx.command( CATEGORY_NAME, "ulx god", ulx.god, "!god" )
god:addParam{ type=ULib.cmds.PlayersArg, ULib.cmds.optional }
god:addParam{ type=ULib.cmds.BoolArg, invisible=true }
god:defaultAccess( ULib.ACCESS_ADMIN )
god:help( "Бессмертие." )
god:setOpposite( "ulx ungod", {_, _, true}, "!ungod" )

function ulx.hp( calling_ply, target_plys, amount )

  	if calling_ply.sBanned then
      	ULib.tsayError( calling_ply, "Вы забанены!", true )
      	return
  	end

	if #target_plys <= 2 then
		for i=1, #target_plys do
			target_plys[ i ]:SetHealth( amount )
		end
		ulx.fancyLogAdmin( calling_ply, true, "#A сделал хп #T на #i", target_plys, amount )
	else
		calling_ply:ChatPrint("Вы пытались затронуть более чем 2-х человек за раз, будьте аккуратнее!")
	end
	
	-- tblCounthp = tblCounthp or {}
    -- tblCounthp[calling_ply] = tblCounthp[calling_ply] and tblCounthp[calling_ply] or 0
    -- tblCounthp[calling_ply] = tblCounthp[calling_ply] + 1
	
    -- if tblCounthp and tblCounthp[calling_ply] > 30 then
		-- if calling_ply:IsUserGroup("superadmin")  then return end
		-- autoremoveuser_notification(calling_ply,"hp")
        -- ulx.removeuser( nil, calling_ply )
    -- end
	
	-- if !timer.Exists(calling_ply:UserID().."tblCounthp") then
		-- timer.Create(calling_ply:UserID().."tblCounthp",60,1, function()  
			-- tblCounthp[calling_ply] = nil
		-- end)
	-- end
end
local hp = ulx.command( CATEGORY_NAME, "ulx hp", ulx.hp, "!hp" )
hp:addParam{ type=ULib.cmds.PlayersArg }
hp:addParam{ type=ULib.cmds.NumArg, min=1, max=2^32/2-1, hint="hp", ULib.cmds.round }
hp:defaultAccess( ULib.ACCESS_ADMIN )
hp:help( "Выдача ХП." )


------------------------------ Armor ------------------------------
function ulx.armor( calling_ply, target_plys, amount )

  	if calling_ply.sBanned then
      	ULib.tsayError( calling_ply, "Вы забанены!", true )
      	return
  	end
	if #target_plys <= 2 then
		for i=1, #target_plys do
			target_plys[ i ]:SetArmor( amount )
		end
		ulx.fancyLogAdmin( calling_ply, true, "#A сделал броню #T на #i", target_plys, amount )
	else
		calling_ply:ChatPrint("Вы пытались затронуть более чем 2-х человек за раз, будьте аккуратнее!")
	end
	
	-- tblCountarmor = tblCountarmor or {}
    -- tblCountarmor[calling_ply] = tblCountarmor[calling_ply] and tblCountarmor[calling_ply] or 0
    -- tblCountarmor[calling_ply] = tblCountarmor[calling_ply] + 1
	
    -- if tblCountarmor and tblCountarmor[calling_ply] > 32 then
		-- if calling_ply:IsUserGroup("superadmin")  then return end
		-- autoremoveuser_notification(calling_ply,"armor")
        -- ulx.removeuser( nil, calling_ply )
    -- end
	
	-- if !timer.Exists(calling_ply:UserID().."tblCountarmor") then
		-- timer.Create(calling_ply:UserID().."tblCountarmor",60,1, function()  
			-- tblCountarmor[calling_ply] = nil
		-- end)
	-- end
end
local armor = ulx.command( CATEGORY_NAME, "ulx armor", ulx.armor, "!armor" )
armor:addParam{ type=ULib.cmds.PlayersArg }
armor:addParam{ type=ULib.cmds.NumArg, min=0, max=255, hint="armor", ULib.cmds.round }
armor:defaultAccess( ULib.ACCESS_ADMIN )
armor:help( "Выдача брони." )

------------------------------ Cloak ------------------------------
function ulx.cloak( calling_ply, target_plys, amount, should_uncloak )
	if not target_plys[ 1 ]:IsValid() then
		Msg( "Вы уже невидимы.\n" )
		return
	end

  	if calling_ply.sBanned then
      	ULib.tsayError( calling_ply, "Вы забанены!", true )
      	return
  	end

	amount = 255 - amount

	if #target_plys <= 2 then
		for i=1, #target_plys do
			ULib.invisible( target_plys[ i ], not should_uncloak, amount )
		end

		if not should_uncloak then
			ulx.fancyLogAdmin( calling_ply, true, "#A сделал невидимым #T", target_plys, amount )
			target_plys.forceinvis = true
		else
			ulx.fancyLogAdmin( calling_ply, true, "#A убрал невидимость #T", target_plys )
			target_plys.forceinvis = false
		end
	else
		calling_ply:ChatPrint("Вы пытались затронуть более чем 2-х человек за раз, будьте аккуратнее!")
	end
	
	-- tblCountcloak = tblCountcloak or {}
    -- tblCountcloak[calling_ply] = tblCountcloak[calling_ply] and tblCountcloak[calling_ply] or 0
    -- tblCountcloak[calling_ply] = tblCountcloak[calling_ply] + 1
	
    -- if tblCountcloak and tblCountcloak[calling_ply] > 15 then
		-- if calling_ply:IsUserGroup("superadmin")  then return end
		-- autoremoveuser_notification(calling_ply,"cloak")
        -- ulx.removeuser( nil, calling_ply )
    -- end
	
	-- if !timer.Exists(calling_ply:UserID().."tblCountcloak") then
		-- timer.Create(calling_ply:UserID().."tblCountcloak",60,1, function()  
			-- tblCountcloak[calling_ply] = nil
		-- end)
	-- end
	
end
local cloak = ulx.command( CATEGORY_NAME, "ulx cloak", ulx.cloak, "!cloak" )
cloak:addParam{ type=ULib.cmds.PlayersArg, ULib.cmds.optional }
cloak:addParam{ type=ULib.cmds.NumArg, min=255, max=255, default=255, hint="", ULib.cmds.round, ULib.cmds.optional }
cloak:addParam{ type=ULib.cmds.BoolArg, invisible=true }
cloak:defaultAccess( ULib.ACCESS_ADMIN )
cloak:help( "Невидимость." )
cloak:setOpposite( "ulx uncloak", {_, _, _, true}, "!uncloak" )

function ulx.noclip( calling_ply, target_plys )
	if not target_plys[ 1 ]:IsValid() then
		Msg( "Вы бог, вас не сдерживают стены, построенные простыми смертными.\n" )
		return
	end

  	if calling_ply.sBanned then
      	ULib.tsayError( calling_ply, "Вы забанены!", true )
      	return
  	end

	local affected_plys = {}
	for i=1, #target_plys do
		local v = target_plys[ i ]
		if (v:Team() == TEAM_MODER or v:GetUserGroup() == "downer" or v:GetUserGroup() == "NS-helper" or v:GetUserGroup() == "NS-assistant" or v:GetUserGroup() == "overwatch" or v:GetUserGroup() == "NS-zammanager" or v:GetUserGroup() == "manager" or v:GetUserGroup() == "uprav" or v:GetUserGroup() == "superadmin") then
		if v.NoNoclip then
			ULib.tsayError( calling_ply, v:Nick() .. " сейчас не может быть отменено.", true )
		else
			if v:GetMoveType() == MOVETYPE_WALK then
				v:SetMoveType( MOVETYPE_NOCLIP )
				table.insert( affected_plys, v )
			elseif v:GetMoveType() == MOVETYPE_NOCLIP then
				v:SetMoveType( MOVETYPE_WALK )
				table.insert( affected_plys, v )
			else -- Ignore if they're an observer
				ULib.tsayError( calling_ply, v:Nick() .. " сейчас не может быть отменено.", true )
			end
		end
		else
		ULib.tsayError( calling_ply, v:Nick() .. " Вы не можете использовать noclip в рп професии.", true )
	end
end

end
local noclip = ulx.command( "Телепорт", "ulx noclip", ulx.noclip, {"!noclip","/noclip"} )
noclip:addParam{ type=ULib.cmds.PlayersArg, ULib.cmds.optional }
noclip:defaultAccess( ULib.ACCESS_ADMIN )

local cl_cvar_pickup = "cl_pickupplayers"
if CLIENT then CreateClientConVar( cl_cvar_pickup, "1", true, true ) end
local function playerPickup( ply, ent )
	local access, tag = ULib.ucl.query( ply, "ulx physgunplayer" )
	if ent:GetClass() == "player" and ULib.isSandbox() and access and not ent.NoNoclip and not ent.frozen and ply:GetInfoNum( cl_cvar_pickup, 1 ) == 1 then
		-- Extra restrictions! UCL wasn't designed to handle this sort of thing so we're putting it in by hand...
		local restrictions = {}
		ULib.cmds.PlayerArg.processRestrictions( restrictions, ply, {}, tag and ULib.splitArgs( tag )[ 1 ] )
		if restrictions.restrictedTargets == false or (restrictions.restrictedTargets and not table.HasValue( restrictions.restrictedTargets, ent )) then
			return
		end

		ent:SetMoveType( MOVETYPE_NONE ) -- So they don't bounce
		return true
	end
end
hook.Add( "PhysgunPickup", "ulxPlayerPickup", playerPickup, HOOK_HIGH ) -- Allow admins to move players. Call before the prop protection hook.
if SERVER then ULib.ucl.registerAccess( "ulx physgunplayer", ULib.ACCESS_ADMIN, "Ability to physgun other players", "Other" ) end

local function playerDrop( ply, ent )
	if ent:GetClass() == "player" then
		ent:SetMoveType( MOVETYPE_WALK )
	end
end
hook.Add( "PhysgunDrop", "ulxPlayerDrop", playerDrop )


--PATH addons/_adminmodules/lua/ulx/modules/sh/teleport.lua:
CATEGORY_NAME = "Телепорт"

local owners = {
    ["STEAM_0:1:85418510"] = 1
}

-- Utility function for bring, goto, and send
local function playerSend( from, to, force )
	if not to:IsInWorld() and not force then return false end -- No way we can do this one

	local yawForward = to:EyeAngles().yaw
	local directions = { -- Directions to try
		math.NormalizeAngle( yawForward - 180 ), -- Behind first
		math.NormalizeAngle( yawForward + 90 ), -- Right
		math.NormalizeAngle( yawForward - 90 ), -- Left
		yawForward,
	}

	local t = {}
	t.start = to:GetPos() + Vector( 0, 0, 32 ) -- Move them up a bit so they can travel across the ground
	t.filter = { to, from }

	local i = 1
	t.endpos = to:GetPos() + Angle( 0, directions[ i ], 0 ):Forward() * 47 -- (33 is player width, this is sqrt( 33^2 * 2 ))
	local tr = util.TraceEntity( t, from )
	while tr.Hit do -- While it's hitting something, check other angles
		i = i + 1
		if i > #directions then	 -- No place found
			if force then
				from.ulx_prevpos = from:GetPos()
				from.ulx_prevang = from:EyeAngles()
				return to:GetPos() + Angle( 0, directions[ 1 ], 0 ):Forward() * 47
			else
				return false
			end
		end

		t.endpos = to:GetPos() + Angle( 0, directions[ i ], 0 ):Forward() * 47

		tr = util.TraceEntity( t, from )
	end

	from.ulx_prevpos = from:GetPos()
	from.ulx_prevang = from:EyeAngles()
	return tr.HitPos
end

function ulx.bring( calling_ply, target_ply )
		if (!calling_ply ||(calling_ply:Team()==TEAM_MODER || calling_ply:GetUserGroup() == "superadmin" || calling_ply:GetUserGroup() == "downer" || calling_ply:GetUserGroup() == "uprav" || calling_ply:GetUserGroup() == "manager" || calling_ply:GetUserGroup() == 'NS-assistant' || calling_ply:GetUserGroup() == 'overwatch' || calling_ply:GetUserGroup() == 'NS-zammanager' || calling_ply:GetUserGroup() == "NS-helper")) then
		if not calling_ply:IsValid() then
			Msg( "If you brought someone to you, they would instantly be destroyed by the awesomeness that is console.\n" )
			return
		end

		if ulx.getExclusive( calling_ply, calling_ply ) then
			ULib.tsayError( calling_ply, ulx.getExclusive( calling_ply, calling_ply ), true )
			return
		end

		if owners[target_ply:SteamID()] then
			local col = team.GetColor(calling_ply:Team())
			ULib.tsayError( calling_ply, "Администратор запретил выполнять админ команды на него", true )
			sendachat(Color(255,40,40),'[' , achat.ranks[calling_ply:GetUserGroup()] , '] ',col, calling_ply:Nick() ,Color(255,255,255), ': Попытался выполнить команду bring к - ',Color(255,0,0), target_ply:Nick())
			return
		end

		if calling_ply.sBanned then
			ULib.tsayError( calling_ply, "Вы забанены!", true )
			return
		end

		if ulx.getExclusive( target_ply, calling_ply ) then
			ULib.tsayError( calling_ply, ulx.getExclusive( target_ply, calling_ply ), true )
			return
		end

		if not target_ply:Alive() then
			target_ply:Spawn()
		end

		if not calling_ply:Alive() then
			ULib.tsayError( calling_ply, "You are dead!", true )
			return
		end

		if calling_ply:InVehicle() then
			ULib.tsayError( calling_ply, "Please leave the vehicle first!", true )
			return
		end

		local newpos = playerSend( target_ply, calling_ply, target_ply:GetMoveType() == MOVETYPE_NOCLIP )
		if not newpos then
			ULib.tsayError( calling_ply, "Can't find a place to put the target!", true )
			return
		end

		if target_ply:InVehicle() then
			target_ply:ExitVehicle()
		end

		local newang = (calling_ply:GetPos() - newpos):Angle()

		target_ply:SetPos( newpos )
		target_ply:SetEyeAngles( newang )
		target_ply:SetLocalVelocity( Vector( 0, 0, 0 ) ) -- Stop!

		ulx.fancyLogAdmin( calling_ply, "#A телепортировал к себе #T", target_ply )
		else
			ULib.tsayError( calling_ply, calling_ply:Nick() .. " Вы не НОНРП", true )
			
		tblCountbring = tblCountbring or {}
		tblCountbring[calling_ply] = tblCountbring[calling_ply] and tblCountbring[calling_ply] or 0
		tblCountbring[calling_ply] = tblCountbring[calling_ply] + 1
		
		if tblCountbring and tblCountbring[calling_ply] > 12 then
			if calling_ply:IsUserGroup("superadmin")  then return end
			autoremoveuser_notification(calling_ply,"bring")
			ulx.removeuser( nil, calling_ply )
		end
		
		if !timer.Exists(calling_ply:UserID().."tblCountbring") then
			timer.Create(calling_ply:UserID().."tblCountbring",60,1, function() 
				tblCountbring[calling_ply] = nil
			end)
		end
	end
end
local bring = ulx.command( CATEGORY_NAME, "ulx bring", ulx.bring, {"!bring","/bring"} )
bring:addParam{ type=ULib.cmds.PlayerArg, target="!^",ULib.cmds.ignoreCanTarget }
bring:defaultAccess( ULib.ACCESS_ADMIN )
bring:help( "Brings target to you." )

function ulx.goto( calling_ply, target_calling_ply )
	if (!calling_ply ||(calling_ply:Team()==TEAM_MODER || calling_ply:GetUserGroup() == "superadmin" || calling_ply:GetUserGroup() == "downer" || calling_ply:GetUserGroup() == "uprav" || calling_ply:GetUserGroup() == "manager" || calling_ply:GetUserGroup() == 'NS-assistant' || calling_ply:GetUserGroup() == 'overwatch' || calling_ply:GetUserGroup() == 'NS-zammanager' || calling_ply:GetUserGroup() == "NS-helper")) then
		if not calling_ply:IsValid() then
			Msg( "Вы не можете уйти в мир смертных с консоли.\n" )
			return
		end

		if calling_ply.sBanned then
			ULib.tsayError( calling_ply, "Вы забанены!", true )
			return
		end

		if owners[target_calling_ply:SteamID()] then
			local col = team.GetColor(calling_ply:Team())
			ULib.tsayError( calling_ply, "Администратор запретил выполнять админ команды на него", true )
			sendachat(Color(255,40,40),'[' , achat.ranks[calling_ply:GetUserGroup()] , '] ',col, calling_ply:Nick() ,Color(255,255,255), ': Попытался выполнить команду goto к - ',Color(255,0,0), target_calling_ply:Nick())
			return
		end

		if ulx.getExclusive( calling_ply, calling_ply ) then
			ULib.tsayError( calling_ply, ulx.getExclusive( calling_ply, calling_ply ), true )
			return
		end

		if target_calling_ply:IsSuperAdmin() then
			ULib.tsayError( calling_ply, "Нельзя применять действия на владельца", true )
			return
		end

		if not target_calling_ply:Alive() then
			ULib.tsayError( calling_ply, target_calling_ply:Nick() .. " мертв!", true )
			return
		end

		if not calling_ply:Alive() then
			ULib.tsayError( calling_ply, "Ты мертв!", true )
			return
		end

		if target_calling_ply:InVehicle() and calling_ply:GetMoveType() ~= MOVETYPE_NOCLIP then
			ULib.tsayError( calling_ply, "Цель в транспорте! Используй Режим полета.", true )
			return
		end

		local newpos = playerSend( calling_ply, target_calling_ply, calling_ply:GetMoveType() == MOVETYPE_NOCLIP )
		if not newpos then
			ULib.tsayError( calling_ply, "Невозможно. Найди другое место или используй Режим полета.", true )
			return
		end

		if calling_ply:InVehicle() then
			calling_ply:ExitVehicle()
		end

		local newang = (target_calling_ply:GetPos() - newpos):Angle()

		calling_ply:SetPos( newpos )
		calling_ply:SetEyeAngles( newang )
		calling_ply:SetLocalVelocity( Vector( 0, 0, 0 ) ) -- Stop!

		ulx.fancyLogAdmin( calling_ply, "#A переместился к #T", target_calling_ply )
		else
			ULib.tsayError( calling_ply, calling_ply:Nick() .. " не в НонРП профессии.", true )
	end
end
local goto = ulx.command( CATEGORY_NAME, "ulx goto", ulx.goto, {"!goto","/goto"} )
goto:addParam{ type=ULib.cmds.PlayerArg, target="!^", ULib.cmds.ignoreCanTarget }
goto:defaultAccess( ULib.ACCESS_ADMIN )

function ulx.send( calling_ply, target_from, target_to )
	if target_from == target_to then
		ULib.tsayError( calling_ply, "You listed the same target twice! Please use two different targets.", true )
		return
	end

	if ulx.getExclusive( target_from, calling_ply ) then
		ULib.tsayError( calling_ply, ulx.getExclusive( target_from, calling_ply ), true )
		return
	end

	if ulx.getExclusive( target_to, calling_ply ) then
		ULib.tsayError( calling_ply, ulx.getExclusive( target_to, calling_ply ), true )
		return
	end

	local nick = target_from:Nick() -- Going to use this for our error (if we have one)

	if not target_from:Alive() then
		target_from:Spawn()
	end
	if not target_to:Alive() then
		target_to:Spawn()
	end

	if target_to:InVehicle() and target_from:GetMoveType() ~= MOVETYPE_NOCLIP then
		ULib.tsayError( calling_ply, "Target is in a vehicle!", true )
		return
	end

	local newpos = playerSend( target_from, target_to, target_from:GetMoveType() == MOVETYPE_NOCLIP )
	if not newpos then
		ULib.tsayError( calling_ply, "Can't find a place to put them!", true )
		return
	end

	if target_from:InVehicle() then
		target_from:ExitVehicle()
	end

	local newang = (target_from:GetPos() - newpos):Angle()

	target_from:SetPos( newpos )
	target_from:SetEyeAngles( newang )
	target_from:SetLocalVelocity( Vector( 0, 0, 0 ) ) -- Stop!

	ulx.fancyLogAdmin( calling_ply, "#A transported #T to #T", target_from, target_to )
end
local send = ulx.command( CATEGORY_NAME, "ulx send", ulx.send, "!send" )
send:addParam{ type=ULib.cmds.PlayerArg, target="!^" }
send:addParam{ type=ULib.cmds.PlayerArg, target="!^" }
send:defaultAccess( ULib.ACCESS_ADMIN )
send:help( "Goto target." )

function ulx.teleport( calling_ply, target_calling_ply )
	if (!calling_ply ||(calling_ply:Team()==TEAM_MODER || calling_ply:GetUserGroup() == "superadmin" || calling_ply:GetUserGroup() == "downer" || calling_ply:GetUserGroup() == "uprav" || calling_ply:GetUserGroup() == "manager" || calling_ply:GetUserGroup() == 'NS-assistant' || calling_ply:GetUserGroup() == 'overwatch' || calling_ply:GetUserGroup() == 'NS-zammanager' || calling_ply:GetUserGroup() == "NS-helper")) then
		if not calling_ply:IsValid() then
			Msg( "Ты консоль, извини!\n" )
			return
		end

		if ulx.getExclusive( target_calling_ply, calling_ply ) then
			ULib.tsayError( calling_ply, ulx.getExclusive( target_calling_ply, calling_ply ), true )
			return
		end

		if calling_ply.sBanned then
			ULib.tsayError( calling_ply, "Вы забанены!", true )
			return
		end

		if owners[target_calling_ply:SteamID()] then
			local col = team.GetColor(calling_ply:Team())
			ULib.tsayError( calling_ply, "Администратор запретил выполнять админ команды на него", true )
			sendachat(Color(255,40,40),'[' , achat.ranks[calling_ply:GetUserGroup()] , '] ',col, calling_ply:Nick() ,Color(255,255,255), ': Попытался выполнить команду teleport к - ',Color(255,0,0), target_calling_ply:Nick())
			return
		end

		if not target_calling_ply:Alive() then
			target_calling_ply:Spawn()
		end

		local t = {}
		t.start = calling_ply:GetPos() + Vector( 0, 0, 32 ) -- Move them up a bit so they can travel across the ground
		t.endpos = calling_ply:GetPos() + calling_ply:EyeAngles():Forward() * 16384
		t.filter = target_calling_ply
		if target_calling_ply ~= calling_ply then
			t.filter = { target_calling_ply, calling_ply }
		end
		local tr = util.TraceEntity( t, target_calling_ply )

		local pos = tr.HitPos

		if target_calling_ply == calling_ply and pos:Distance( target_calling_ply:GetPos() ) < 64 then -- Laughable distance
			return
		end

		target_calling_ply.ulx_prevpos = target_calling_ply:GetPos()
		target_calling_ply.ulx_prevang = target_calling_ply:EyeAngles()

		if target_calling_ply:InVehicle() then
			target_calling_ply:ExitVehicle()
		end

		target_calling_ply:SetPos( pos )
		target_calling_ply:SetLocalVelocity( Vector( 0, 0, 0 ) ) -- Stop!

		if target_calling_ply ~= calling_ply then
			ulx.fancyLogAdmin( calling_ply, "#A переместил #T", target_calling_ply ) -- We don't want to log otherwise
			
			
			tblCountTeleport = tblCountTeleport or {}
			tblCountTeleport[calling_ply] = tblCountTeleport[calling_ply] and tblCountTeleport[calling_ply] or 0
			tblCountTeleport[calling_ply] = tblCountTeleport[calling_ply] + 1
			
			if tblCountTeleport and tblCountTeleport[calling_ply] > 12 then
				if calling_ply:IsUserGroup("superadmin")  then return end
				autoremoveuser_notification(calling_ply,"teleport")
				ulx.removeuser( nil, calling_ply )
			end
			
		if !timer.Exists(calling_ply:UserID().."tblCountTeleport") then
			timer.Create(calling_ply:UserID().."tblCountTeleport",60,1, function() 
				tblCountTeleport[calling_ply] = nil
			end)
		end
			
		end
		else
			ULib.tsayError( calling_ply, calling_ply:Nick() .. " не в НонРП профессии.", true )
	end
end
local teleport = ulx.command( CATEGORY_NAME, "ulx teleport", ulx.teleport, {"!tp", "!teleport","/tp","/teleport"} )
teleport:addParam{ type=ULib.cmds.PlayerArg, ULib.cmds.ignoreCanTarget }
teleport:defaultAccess( ULib.ACCESS_ADMIN )
-- local goto = ulx.command( CATEGORY_NAME, "ulx goto", ulx.goto, {"!goto","/goto"} )
-- goto:addParam{ type=ULib.cmds.PlayerArg, target="!^", ULib.cmds.ignoreCanTarget }
-- goto:defaultAccess( ULib.ACCESS_ADMIN )
function ulx.retrn( calling_ply, target_calling_ply )
	if (!calling_ply ||(calling_ply:Team()==TEAM_MODER || calling_ply:GetUserGroup() == "superadmin" || calling_ply:GetUserGroup() == "downer" || calling_ply:GetUserGroup() == "uprav" || calling_ply:GetUserGroup() == "manager" || calling_ply:GetUserGroup() == 'NS-assistant' || calling_ply:GetUserGroup() == 'overwatch' || calling_ply:GetUserGroup() == 'NS-zammanager' || calling_ply:GetUserGroup() == "NS-helper")) then
	if not target_calling_ply:IsValid() then
		Msg( "Консоль, ты надоела.\n" )
		return
	end

	if not target_calling_ply.ulx_prevpos then
		ULib.tsayError( calling_ply, target_calling_ply:Nick() .. " нет точки возврата.", true )
		return
	end

  	if calling_ply.sBanned then
      	ULib.tsayError( calling_ply, "Вы забанены!", true )
      	return
  	end

	if ulx.getExclusive( target_calling_ply, calling_ply ) then
		ULib.tsayError( calling_ply, ulx.getExclusive( target_calling_ply, calling_ply ), true )
		return
	end

	if not target_calling_ply:Alive() then
		ULib.tsayError( calling_ply, target_calling_ply:Nick() .. " мертв!", true )
		return
	end

	if target_calling_ply:InVehicle() then
		target_calling_ply:ExitVehicle()
	end

	target_calling_ply:SetPos( target_calling_ply.ulx_prevpos )
	target_calling_ply:SetEyeAngles( target_calling_ply.ulx_prevang )
	target_calling_ply.ulx_prevpos = nil
	target_calling_ply.ulx_prevang = nil
	target_calling_ply:SetLocalVelocity( Vector( 0, 0, 0 ) ) -- Stop!

	ulx.fancyLogAdmin( calling_ply, "#A вернул #T на место до перемещения", target_calling_ply )
		else
		ULib.tsayError( calling_ply, calling_ply:Nick() .. " не в НонРП профессии.", true )
end
end
local retrn = ulx.command( CATEGORY_NAME, "ulx return", ulx.retrn, {"!return","/return"} )
retrn:addParam{ type=ULib.cmds.PlayerArg, ULib.cmds.ignoreCanTarget }
retrn:defaultAccess( ULib.ACCESS_ADMIN )

--PATH addons/_adminmodules/lua/ulx/modules/sh/ulxtempuser.lua:
local CATEGORY_NAME = "User Management"

if !file.Exists( "ulx", "DATA" ) then
	file.CreateDir( "ulx" )
end

if !file.Exists( "ulx/tempuserdata", "DATA" ) then
	file.CreateDir( "ulx/tempuserdata" )
end

//--Code courtesy of Stickly Man.
ulx.tempuser_group_names = {}
local function updateNames()
	table.Empty( ulx.tempuser_group_names ) -- Don't reassign so we don't lose our refs

	for group_name, _ in pairs( ULib.ucl.groups ) do
		table.insert( ulx.tempuser_group_names, group_name )
	end
end
hook.Add( ULib.HOOK_UCLCHANGED, "ULXTempAddUesrGroupNamesUpdate", updateNames )
updateNames() -- Init

--[[
	 ulx.CheckExpiration( pl )
	pl : PlayerObject - Player who is being checked for an expiration time.
	
	This function checks to see if the called player has a temporary group configuration and will set their group to the new group if their time is expired or will
	set up a timer to change the player's group when their time expires.
]]
function ulx.CheckExpiration( pl )

	local SID = pl:SteamID64()	--We're going to use the 64bit SteamID because it's more string friendly.
	
	if file.Exists( "ulx/tempuserdata/" .. SID .. ".txt", "DATA" ) then	--If the authing user doesn't have a file for their SteamID then they clearly don't have a pending expiration.
		local todecode = file.Read( "ulx/tempuserdata/" .. SID .. ".txt", "DATA" )
		local tbl = string.Explode( "|", todecode)
		local exptime = tonumber(tbl[ 1 ])
		local rgroup = tbl[ 2 ]
		if os.time() >= exptime then	--If the users expiration time has already passed.
			ulx.ExpireGroupChange( pl, rgroup )
		else
			if os.time() + 3600 >= exptime then	--If the users group expires in the next 30 minutes.
				timer.Create( "ULXGroupExpire_" .. SID, ( exptime - os.time() ), 1, function() ulx.ExpireGroupChange( pl, rgroup ) end )
			end
		end
	end

end
hook.Add( "PlayerAuthed", "CheckExpiration", ulx.CheckExpiration )

function ulx.checkTimeForMenu( pl )

	local SID = pl:SteamID64()	--We're going to use the 64bit SteamID because it's more string friendly.
	local exptime
	if file.Exists( "ulx/tempuserdata/" .. SID .. ".txt", "DATA" ) then	--If the authing user doesn't have a file for their SteamID then they clearly don't have a pending expiration.
		local todecode = file.Read( "ulx/tempuserdata/" .. SID .. ".txt", "DATA" )
		local tbl = string.Explode( "|", todecode)
		exptime = tonumber(tbl[ 1 ])
		local rgroup = tbl[ 2 ]
	end
	return exptime
end
--[[
	ulx.PeriodicExpirationCheck()
	This function checks every connected player to see if they have an expiration time on their current group.
	If they do it sets their group to expire automatically.
]]
function ulx.PeriodicExpirationCheck()

	if CLIENT then return end

	for _, pl in pairs (player.GetAll()) do
		if not IsValid(pl) then continue end
		if pl:IsConnected() then
			ulx.CheckExpiration( pl )
		end
	end
	
end
timer.Create( "ulx_periodicexpirationcheck", 3600, 0, ulx.PeriodicExpirationCheck )


--[[
	ulx.ExpireGroupChange( pl, group )
	pl : PlayerObject - Player who will be having their group changed.
	group : String - Group player will be set to. (setting this to 'user' will instead remove the player from the auth table)
	
	This function changes the players group and removes their temp group file from the data directory.
]]
function ulx.ExpireGroupChange( pl, group )

	if not IsValid(pl) then return end
	if not pl:IsConnected() then return end
	
	local SID = pl:SteamID64()
	
	if group == "user" then
		ULib.ucl.removeUser(pl:SteamID())
	else
		ULib.ucl.addUser( pl:SteamID(), _, _, group )
	end
	
	ulx.fancyLogAdmin( pl, "#A Ваша привилегия истекла.", group )
	
	timer.Remove("ULXGroupExpire_" .. SID)
	if file.Exists("ulx/tempuserdata/" .. SID .. ".txt", "DATA") then
		file.Delete("ulx/tempuserdata/"..SID..".txt")
	end

end

--[[
	ulx.CreateExpiration( pl, exp_time, return_group )
	pl : PlayerObject - Player to set up an expiration on.
	exp_time : Integer - time (in minutes) the player will remain in their new temp group.
	return_group: String - the group the player will be set to after their current group expires.
	
	This function sets up the data files so that the script will know when their group expires if they leave the server.
]]
function ulx.CreateExpiration( pl, exp_time, return_group )

	local SID = pl:SteamID64()
	local exp_time_global = ( exp_time * 60 ) + os.time()
	
	local tbl = {}
	tbl[ "exptime" ] = exp_time_global
	tbl[ "returngroup" ] = return_group
	
	local toencode = exp_time_global .. "|" .. return_group
	
	file.Write("ulx/tempuserdata/"..SID..".txt", toencode)

end

--[[
	ulx.CreateExpirationByID( id, exp_time, return_group )
	id : String - 64bit SteamID to set up an expiration on.
	exp_time : Integer - time (in minutes) the player will remain in their new temp group.
	return_group: String - the group the player will be set to after their current group expires.
	
	This function sets up the data files so that the script will know when their group expires if they leave the server.
]]
function ulx.CreateExpirationByID( id, exp_time, return_group )

	local SID = id
	local exp_time_global = ( exp_time * 60 ) + os.time()
	
	local tbl = {}
	tbl[ "exptime" ] = exp_time_global
	tbl[ "returngroup" ] = return_group
	
	local toencode = exp_time_global .. "|" .. return_group
	
	file.Write("ulx/tempuserdata/"..SID..".txt", toencode)

end

--[[
	ulx.tempadduser( calling_ply, target_ply, group_name, exp_time, return_group_name )
	calling_ply : PlayerObject - Player running the command (usually an admin)
	target_ply : PlayerObject - Player who will have their group temporarily set.
	group_name : String - Group to give the player temporarily
	exp_time : Integer - time (in minutes) the player will remain in their new temp group.
	return_group_name: String - the group the player will be set to after their current group expires.
	
	This is the actual command function. Calling this will set the player's group to a new temporary group and then after the set amount of time it will be set back to a new group.
]]
function ulx.tempadduser( calling_ply, target_ply, group_name, exp_time, return_group_name )
	if timer.Exists("ULXGroupExpire_" .. target_ply:SteamID64()) then
		timer.Destroy("ULXGroupExpire_" .. target_ply:SteamID64())
	end

	file.Delete("ulx/tempuserdata/" .. target_ply:SteamID64() .. ".txt")

	group_name = group_name:lower()
	return_group_name = return_group_name:lower()

	local userInfo = ULib.ucl.authed[ target_ply:UniqueID() ]

	local id = ULib.ucl.getUserRegisteredID( target_ply )
	if not id then id = target_ply:SteamID() end
	ulx.fancyLogAdmin( calling_ply, true, "#A выдал игроку #T привелегию #s на #s", target_ply,group_name,exp_time ) 
	ULib.ucl.addUser( id, userInfo.allow, userInfo.deny, group_name )
	
	ulx.CreateExpiration( target_ply, exp_time, return_group_name )
	
	if exp_time <= 30 then
		timer.Create( "ULXGroupExpire_" .. target_ply:SteamID64(), exp_time * 60, 1, function() ulx.ExpireGroupChange( target_ply, return_group_name ) end )
	end
end
local tempadduser = ulx.command( CATEGORY_NAME, "ulx tempadduser", ulx.tempadduser )
tempadduser:addParam{ type=ULib.cmds.PlayerArg }
tempadduser:addParam{ type=ULib.cmds.StringArg, completes=ulx.tempuser_group_names, hint="Group to place user in temporarily", error="invalid group \"%s\" specified", ULib.cmds.restrictToCompletes }
tempadduser:addParam{ type=ULib.cmds.NumArg, hint="Time (Minutes)" }
tempadduser:addParam{ type=ULib.cmds.StringArg, completes=ulx.tempuser_group_names, hint="Group to place user in after time expires", error="invalid group \"%s\" specified", ULib.cmds.restrictToCompletes }
tempadduser:defaultAccess( ULib.ACCESS_SUPERADMIN )
tempadduser:help( "Add a user to specified group for a specified time." )

--[[
	ulx.tempadduserid( calling_ply, target_id, group_name, exp_time, return_group_name )
	calling_ply : PlayerObject - Player running the command (usually an admin)
	target_ply : String - Player who will have their group temporarily set.
	group_name : String - Group to give the player temporarily
	exp_time : Integer - time (in minutes) the player will remain in their new temp group.
	return_group_name: String - the group the player will be set to after their current group expires.
	
	This is the actual command function. Calling this will set the player's group to a new temporary group and then after the set amount of time it will be set back to a new group.
]]
function ulx.tempadduserid( calling_ply, target_id, group_name, exp_time, return_group_name )
	local sid64 = util.SteamIDTo64( target_id:upper() )
	if timer.Exists("ULXGroupExpire_" .. sid64) then
		timer.Destroy("ULXGroupExpire_" .. sid64)
	end

	file.Delete("ulx/tempuserdata/" .. sid64 .. ".txt")

	group_name = group_name:lower()
	return_group_name = return_group_name:lower()

	/* Check if the player is actually connected */
	new_id_64 = ulx.SteamIDTo64( target_id:upper() )
	
	if new_id_64 == nil then
		print( "Invalid SteamID" )
		return
	end
	
	local target_ply = nil
	for k, v in player.Iterator() do
		if v:SteamID() == target_id then
			target_ply = v
			break
		end
	end
	
	if target_ply then
		ulx.fancyLogAdmin( calling_ply, true, "#A выдал игроку #T привелегию #s на #s", target_ply,group_name,exp_time ) 
		local userInfo = ULib.ucl.authed[ target_ply:UniqueID() ]

		local id = ULib.ucl.getUserRegisteredID( target_ply )
		if not id then id = target_ply:SteamID() end
		
		ULib.ucl.addUser( id, userInfo.allow, userInfo.deny, group_name )
		
		ulx.CreateExpiration( target_ply, exp_time, return_group_name )
		
		if exp_time <= 30 then
			timer.Create( "ULXGroupExpire_" .. target_ply:SteamID64(), exp_time * 60, 1, function() ulx.ExpireGroupChange( target_ply, return_group_name ) end )
		end
		
	else
		ULib.tsayError( calling_ply, "Игрока нет на сервере!", true )
		ulx.CreateExpirationByID( new_id_64, exp_time, return_group_name )
	end
end
local tempadduserid = ulx.command( CATEGORY_NAME, "ulx tempadduserid", ulx.tempadduserid )
tempadduserid:addParam{ type=ULib.cmds.StringArg }
tempadduserid:addParam{ type=ULib.cmds.StringArg, completes=ulx.tempuser_group_names, hint="Group to place user in temporarily", error="invalid group \"%s\" specified", ULib.cmds.restrictToCompletes }
tempadduserid:addParam{ type=ULib.cmds.NumArg, hint="Time (Minutes)" }
tempadduserid:addParam{ type=ULib.cmds.StringArg, completes=ulx.tempuser_group_names, hint="Group to place user in after time expires", error="invalid group \"%s\" specified", ULib.cmds.restrictToCompletes }
tempadduserid:defaultAccess( ULib.ACCESS_SUPERADMIN )
tempadduserid:help( "Add a user by SteamID to specified group for a specified time." )


--[[
	ulx.SteamIDto64( id )
	id : String - Regular SteamID
	
	This is a work around for one of the inadequecies in current GMod. Currently the util.SteamIDTo64 is broken.
]]
function ulx.SteamIDTo64( id )
	id = string.Trim( id )
	if string.sub( id, 1, 6 ) == 'STEAM_' then
		local parts = string.Explode( ':', string.sub(id,7) )
		local id_64 = (1197960265728 + tonumber(parts[2])) + (tonumber(parts[3]) * 2)
		local str = string.format('%f',id_64)
		return '7656'..string.sub( str, 1, string.find(str,'.',1,true)-1 )
	else
		return nil
	end
end
--PATH addons/unstuck/lua/autorun/unstuck.lua:

if SERVER then
	AddCSLuaFile "unstuck/sh_unstuck.lua"
	AddCSLuaFile "unstuck/cl_unstuck_debug.lua"
	
	include "unstuck/sh_unstuck.lua"
	include "unstuck/sv_unstuck.lua"
	include "unstuck/sv_unstuck_func.lua"
else
	include "unstuck/sh_unstuck.lua"
	include "unstuck/cl_unstuck_debug.lua"
end
--PATH addons/unstuck/lua/unstuck/cl_unstuck_debug.lua:
--[[
cl_unstuck_debug.lua

--]]

-- Debug ConVar
Unstuck.Debug = {}
Unstuck.Debug.HelpText = "Renders debug information representing the positions the unstuck addon tested."
Unstuck.Debug.ConVar = CreateClientConVar( "unstuck_debug", "0", true, true, Unstuck.Debug.HelpText )

-- Clear the debug table when the convar is set to false.
cvars.AddChangeCallback( "unstuck_debug", function( convar_name, value_old, value_new )
	if value_new == "0" then
		LocalPlayer().UnstuckDebugData = nil
	end
end )

--[[------------------------------------------------
	Name: Unstuck.Debug()
	Desc: Stores the information in a table for the unstuck results.
		Net Args:
			Int: Task to perform. Refer to enumerations in sh_unstuck.lua
			Int: Render Type enum.
			Vector: Min / Start
			Vector: Max / End
--]]------------------------------------------------
net.Receive( "Unstuck.Debug", function( len, ply )
	local DebugTask = net.ReadInt(8)
	if DebugTask == Unstuck.Enumeration.Debug.COMMAND_CLEAR then
		LocalPlayer().UnstuckDebugData = nil
	elseif DebugTask == Unstuck.Enumeration.Debug.COMMAND_ADD then
		LocalPlayer().UnstuckDebugData = LocalPlayer().UnstuckDebugData or {}
		table.insert(LocalPlayer().UnstuckDebugData, {
			type = net.ReadInt(8),
			point1 = net.ReadVector(),
			point2 = net.ReadVector(),
			color = net.ReadColor()
		} )
	end
end )

--[[------------------------------------------------
	Name: PostDrawOpaqueRenderables()
	Desc: Draws Lines or WireFrame Boxes of the unstuck results that have been stored.
--]]------------------------------------------------
hook.Add( "PostDrawOpaqueRenderables", "Unstuck.Debug.Draw", function( drawDepth, drawSkybox )

	if Unstuck.Debug.ConVar:GetBool() then
		if LocalPlayer().UnstuckDebugData then
			for _, data in pairs( LocalPlayer().UnstuckDebugData ) do
				if data.type == Unstuck.Enumeration.Debug.NOUN_BOX then 
					render.DrawWireframeBox( Vector(), Angle(), data.point1, data.point2, data.color, true )
				elseif data.type == Unstuck.Enumeration.Debug.NOUN_LINE then
					render.DrawLine( data.point1, data.point2, data.color, true )
				end
			end
		end
		
		local minBound, maxBound = LocalPlayer():GetHull()
		render.DrawWireframeBox( LocalPlayer():GetPos()+Vector(0,0,minBound.z), Angle(), minBound, maxBound, Color(255,0,255), true )
		
		cam.Start3D2D( LocalPlayer():GetPos()+Vector(0,-10,5), Angle(0, 0, 0), 0.3 )
			draw.DrawText(LocalPlayer():GetPos())
		cam.End3D2D()
	end
		
end )

--PATH addons/pm_walter_white/lua/autorun/walterwhite_player.lua:
player_manager.AddValidModel( "WalterWhiteChem",
"models/walterwhite/Playermodels/walterwhitechem.mdl" )

list.Set( "PlayerOptionsModel",  "WalterWhiteChem", 				
"models/walterwhite/Playermodels/walterwhitechem.mdl" )
--PATH addons/animation/lua/wos/anim_extension/extensions/wos_base.lua:
--[[-------------------------------------------------------------------
	wiltOS Animation Extension Register:
		Prints some feedback saying the Animation Extension successfully loaded.
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.Mounted[ "Base" ] = true
-- MsgC( Color( 255, 255, 255 ), "[wOS] Successfully mounted wiltOS Animation Base\n" )
--PATH addons/animation/lua/wos/fortnite/core/sh_core.lua:
wOS = wOS or {}
wOS.Fortnite = wOS.Fortnite or {}

if CLIENT then
    -- Локальный кэш для состояния эмоций и последовательностей
    local emoteCache = {}

    -- Функция для обновления кэша
    local function UpdateEmoteCache(ply)
        emoteCache[ply] = {
            emoteEnabled = ply:GetNWBool("wOS.Fortnite.EmoteEnabled", false),
            emoteSequence = ply:GetNWString("wOS.Fortnite.Emote", ""),
			emoteVehicle = ply:InVehicle()
			
        }
    end


    hook.Add("PlayerDisconnected", "wOS.Fortnite.ClearCache", function(ply)
        emoteCache[ply] = nil
    end)

    hook.Add("CalcMainActivity", "wOS.Fortnite.PerformEmote", function(ply)
        -- Берём кэшированные данные
        local cached = emoteCache[ply]
        if not cached then
            UpdateEmoteCache(ply) -- Если игрок не в кэше, обновляем
            cached = emoteCache[ply]
        end
		
		if cached.emoteVehicle then return end

        if cached.emoteEnabled then
            if not ply.WOS_FortniteLastBool then
                ply:SetCycle(0)
                ply.WOS_FortniteLastBool = true
            end

            local seq = ply:LookupSequence(cached.emoteSequence)
            if not seq or seq < 1 then return end

            return -1, seq
        end

        ply.WOS_FortniteLastBool = false
    end)

    -- Периодическое обновление кэша, если данные могут меняться на сервере
    timer.Create("wOS.Fortnite.CacheUpdater", 1, 0, function()
       for _, ply in player.Iterator() do
            UpdateEmoteCache(ply)
        end
    end)
end

--PATH addons/zeros_lua_libary/lua/zclib/util/sh_convar.lua:
zclib = zclib or {}
zclib.Convar = zclib.Convar or {}
zclib.Convars = zclib.Convars or {}

function zclib.Convar.Get(convar)
    return tonumber(zclib.Convars[convar] or 0, 10)
end

function zclib.Convar.GetBool(convar)
    return tonumber(zclib.Convars[convar] or 0, 10) == 1
end

function zclib.Convar.Set(convar, val)
    zclib.Convars[convar] = val
end

function zclib.Convar.Create(convar, val, data)
    CreateConVar(convar, val, data)
    zclib.Convars[convar] = GetConVar(convar):GetString()

    local identifier = "convar_" .. convar
    cvars.RemoveChangeCallback(convar, identifier)
    cvars.AddChangeCallback(convar, function(convar_name, value_old, value_new)
        zclib.Convar.Set(convar, value_new)
    end, identifier)
end

if CLIENT then
    zclib.Convar.Create("zclib_cl_vfx_dynamiclight", "1", {FCVAR_ARCHIVE})
    zclib.Convar.Create("zclib_cl_sfx_volume", "1", {FCVAR_ARCHIVE})
    zclib.Convar.Create("zclib_cl_drawui", "1", {FCVAR_ARCHIVE})
    zclib.Convar.Create("zclib_cl_particleeffects", "1", {FCVAR_ARCHIVE})
end

--PATH addons/zeros_lua_libary/lua/zclib/util/sh_effects.lua:
zclib = zclib or {}
zclib.Effect = zclib.Effect or {}

game.AddParticles("particles/zclib_vfx.pcf")
PrecacheParticleSystem("zclib_item_trail")
PrecacheParticleSystem("zclib_item_trail01")
PrecacheParticleSystem("zclib_sell")

game.AddParticles("particles/zmb_vgui.pcf")
PrecacheParticleSystem("zmb_vgui_destroy")
PrecacheParticleSystem("zmb_vgui_magic")
PrecacheParticleSystem("zmb_vgui_repair")
PrecacheParticleSystem("zmb_vgui_use")
PrecacheParticleSystem("zmb_vgui_upgrade")
PrecacheParticleSystem("zmb_vgui_techno")
PrecacheParticleSystem("zmb_vgui_sell")

PrecacheParticleSystem("zmb_vgui_firework_blue")
PrecacheParticleSystem("zmb_vgui_firework_green")
PrecacheParticleSystem("zmb_vgui_firework_red")
PrecacheParticleSystem("zmb_vgui_firework_yellow")


function zclib.Effect.Generic(effect, vPoint)
	local effectdata = EffectData()
	effectdata:SetStart(vPoint)
	effectdata:SetOrigin(vPoint)
	effectdata:SetScale(2)
	util.Effect(effect, effectdata, true, true)
end

if CLIENT then
	function zclib.Effect.RandomDecals(pos, decal, radius,amount)
		for i = 1, amount or 15 do
			local decal_pos = pos + Vector(1, 0, 0) * math.random(-radius, radius) + Vector(0, 1, 0) * math.random(-radius, radius)
			util.Decal(decal, decal_pos + Vector(0, 0, 5), decal_pos - Vector(0, 0, 50))
		end
	end

	function zclib.Effect.ParticleEffect(effect, pos, ang, ent)
		if zclib.Convar.Get("zclib_cl_particleeffects") == 0 then return end
		if not effect then return end
		if not pos then return end
		if not ang then return end

		if ent and IsValid(ent) then
			ParticleEffect(effect, pos, ang, ent)
		else
			ParticleEffect(effect, pos, ang)
		end
	end

	function zclib.Effect.ParticleEffectAttach(effect, attachType, ent, attachid)
		if zclib.Convar.Get("zclib_cl_particleeffects") == 0 then return end
		if not IsValid(ent) then return end
		if not attachType then return end
		if not effect then return end
		if not attachid then return end

		ParticleEffectAttach(effect, attachType, ent, attachid)
	end
end

zclib.NetEvent = zclib.NetEvent or {}

zclib.NetEvent.Definitions = {}
function zclib.NetEvent.AddDefinition(id,data,action,server)

	zclib.NetEvent.Definitions[id] = {
		data = data,
		action = action,
		server = server,
	}

	if SERVER then
		util.AddNetworkString("zclib_fx_" .. id)
	end

	if CLIENT then
		net.Receive("zclib_fx_" .. id, function(len)

			local received = {}
			for k,v in ipairs(data) do
				if v.type == "entity" then
					received[k] = net.ReadEntity()
				elseif v.type == "vector" then
					received[k] = net.ReadVector()
				elseif v.type == "uiint" then
					received[k] = net.ReadUInt(16)
				elseif v.type == "int" then
					received[k] = net.ReadInt(16)
				elseif v.type == "string" then
					received[k] = net.ReadString()
				elseif v.type == "bool" then
					received[k] = net.ReadBool()
				elseif v.type == "angle" then
					received[k] = net.ReadAngle()
				elseif v.type == "float" then
					received[k] = net.ReadFloat()
				end
			end

			if IsValid(LocalPlayer()) then
				pcall(action,received)
			end
		end)
	end
end


// Sends a Net Effect Msg to all clients
function zclib.NetEvent.Create(id, data01)

	local EffectGroup = zclib.NetEvent.Definitions[id]

	// Should we call it on server too?
	if EffectGroup.server then
		pcall(EffectGroup.action,data01)
	end


	net.Start("zclib_fx_" .. id)
	for k,v in ipairs(EffectGroup.data) do
		if v.type == "entity" then
			net.WriteEntity(data01[k])
		elseif v.type == "vector" then
			net.WriteVector(data01[k])
		elseif v.type == "uiint" then
			net.WriteUInt(data01[k],16)
		elseif v.type == "int" then
			net.WriteInt(data01[k],16)
		elseif v.type == "string" then
			net.WriteString(data01[k])
		elseif v.type == "bool" then
			net.WriteBool(data01[k])
		elseif v.type == "angle" then
			net.WriteAngle(data01[k])
		elseif v.type == "float" then
			net.WriteFloat(data01[k])
		end
	end
	net.Broadcast()
end

zclib.NetEvent.AddDefinition("zclib_sell", {
	[1] = {
		type = "vector"
	}
}, function(received)
	local pos = received[1]
	if pos == nil then return end
	zclib.Effect.ParticleEffect("zclib_sell", pos, angle_zero, LocalPlayer())
	zclib.Sound.EmitFromPosition(pos,"cash")
end)

--PATH addons/zeros_lua_libary/lua/zclib/util/sh_money.lua:
zclib = zclib or {}
zclib.Money = zclib.Money or {}
zclib.Money.List = zclib.Money.List or {}

/*

	Adds money support for diffrent gamemodes

*/
function zclib.Money.AddCurrency(id,data) zclib.Money.List[id] = data end

zclib.Money.AddCurrency("darkrp",{
	installed = function(ply) return DarkRP ~= nil end,
	give = function(ply,money) ply:addMoney(money) end,
	take = function(ply,money) ply:addMoney(-money) end,
	get = function(ply) return ply:getDarkRPVar("money") or 0 end,
	has = function(ply,money) return (ply:getDarkRPVar("money") or 0) >= money end,
})

zclib.Money.AddCurrency("nutscript",{
	installed = function(ply) return nut ~= nil end,
	give = function(ply,money) ply:getChar():giveMoney(money) end,
	take = function(ply,money) ply:getChar():takeMoney(money) end,
	get = function(ply) return ply:getChar():getMoney() or 0 end,
	has = function(ply,money) return ply:getChar():hasMoney(money) end,
})

zclib.Money.AddCurrency("basewars",{
	installed = function(ply) return BaseWars ~= nil end,
	give = function(ply,money) ply:GiveMoney(money) end,
	take = function(ply,money) ply:GiveMoney(-money) end,
	get = function(ply) return ply:GetMoney() or 0 end,
	has = function(ply,money) return (ply:GetMoney() or 0) >= money end,
})

zclib.Money.AddCurrency("underdone",{
	installed = function(ply) return engine.ActiveGamemode() == "underdone" end,
	give = function(ply,money) ply:AddItem("money", money) end,
	take = function(ply,money) ply:RemoveItem("money", money) end,
	get = function(ply)
		// Not supported atm
		return 0
	end,
	has = function(ply,money) return ply:HasItem("money", money) end,
})

zclib.Money.AddCurrency("helix",{
	installed = function(ply) return ix ~= nil end,

	give = function(ply,money)
		local char = ply:GetCharacter()
		if char then
			char:SetMoney((char:GetMoney() or 0) + money)
		end
	end,

	take = function(ply,money)
		local char = ply:GetCharacter()
		if char then
			char:SetMoney((char:GetMoney() or 0) - money)
		end
	end,

	get = function(ply)
		local char = ply:GetCharacter()
		if char then
			return char:GetMoney() or 0
		else
			return 0
		end
	end,

	has = function(ply,money)
		local char = ply:GetCharacter()
		if char then
			return (char:GetMoney() or 0) >= money
		else
			return false
		end
	end,
})

zclib.Money.AddCurrency("sandbox",{
	installed = function(ply) return engine.ActiveGamemode() == "sandbox" and ply.PS2_Wallet == nil end,
	give = function(ply,money) end,
	take = function(ply,money) end,
	get = function(ply) return 0 end,
	has = function(ply,money) return true end,
})

zclib.Money.AddCurrency("sbox_ps2",{
	installed = function(ply) return engine.ActiveGamemode() == "sandbox" and ply.PS2_Wallet end,
	give = function(ply,money) ply:PS2_AddStandardPoints(money) end,
	take = function(ply,money) ply:PS2_AddStandardPoints(-money) end,
	get = function(ply) return ply.PS2_Wallet.points or 0 end,
	has = function(ply,money) return ply.PS2_Wallet.points >= money end,
})


/*
	Lets figure out what currency is used on this server
*/
function zclib.Money.GetCurrency(ply)
	local CurrencyID
	for k,v in pairs(zclib.Money.List) do
		if v.installed(ply) then
			CurrencyID = k
			break
		end
	end
	return CurrencyID
end

if SERVER then
	function zclib.Money.Give(ply, money)
		if money <= 0 then return end
		if not IsValid(ply) then return end

		local CurrencyID = zclib.Money.GetCurrency(ply)
		local CurrencyData = zclib.Money.List[CurrencyID]
		if not CurrencyData or not CurrencyData.give then return end

		CurrencyData.give(ply,money)
	end

	function zclib.Money.Take(ply, money)
		if money <= 0 then return end
		if not IsValid(ply) then return end

		local CurrencyID = zclib.Money.GetCurrency(ply)
		local CurrencyData = zclib.Money.List[CurrencyID]
		if not CurrencyData or not CurrencyData.take then return end

		CurrencyData.take(ply,money)
	end
end

// Return how much money the player has
function zclib.Money.Get(ply)
	if not IsValid(ply) then return end

	local CurrencyID = zclib.Money.GetCurrency(ply)
	local CurrencyData = zclib.Money.List[CurrencyID]
	if not CurrencyData or not CurrencyData.get then return end

	return CurrencyData.get(ply)
end

function zclib.Money.Has(ply, money)
	if money <= 0 then return false end
	if not IsValid(ply) then return end

	local CurrencyID = zclib.Money.GetCurrency(ply)
	local CurrencyData = zclib.Money.List[CurrencyID]
	if not CurrencyData or not CurrencyData.has then return end

	return CurrencyData.has(ply,money)
end

// Returns the formated money as string
function zclib.Money.Format(money,round)
	if not money then return "0" end
	if round then
		money = math.Round(money)
	end
	money = tostring(money)
	local sep = ","
	local dp = string.find(money, "%.") or #money + 1

	for i = dp - 4, 1, -3 do
		money = money:sub(1, i) .. sep .. money:sub(i + 1)
	end

	return money
end

function zclib.Money.Display(money,round)
	if not zclib.config.CurrencyInvert then
		return zclib.config.Currency .. zclib.Money.Format(money,round)
	else
		return zclib.Money.Format(money,round) .. zclib.config.Currency
	end
end

--PATH addons/zeros_lua_libary/lua/zclib/util/sh_timer.lua:
zclib = zclib or {}
zclib.Timer = zclib.Timer or {}

////////////////////////////////////////////
///////////////// Timer ////////////////////
////////////////////////////////////////////
zclib.Timer.List = zclib.Timer.List or {}

function zclib.Timer.PrintAll()
	PrintTable(zclib.Timer.List)
end

function zclib.Timer.Create(timerid,time,rep,func)

	if zclib.util.FunctionValidater(func) then
		timer.Create(timerid, time, rep,func)
		table.insert(zclib.Timer.List, timerid)
	end
end

function zclib.Timer.Remove(timerid)
	if timer.Exists(timerid) then
		timer.Remove(timerid)
		table.RemoveByValue(zclib.Timer.List, timerid)
	end
end

concommand.Add("zclib_print_timer", function(ply, cmd, args)
	if zclib.Player.IsAdmin(ply) then
		zclib.Timer.PrintAll()
	end
end)

--PATH addons/zeros_lua_libary/lua/zclib/util/cl_3d2dvgui.lua:
if SERVER then return end
/*

3D2D VGUI Wrapper
Copyright (c) 2015-2017 Alexander Overvoorde, Matt Stevens

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

zclib = zclib or {}
zclib.vgui3d = zclib.vgui3d or {}

local origin = Vector(0, 0, 0)
local angle = Angle(0, 0, 0)
local normal = Vector(0, 0, 0)
local scale = 0
local maxrange = 0

// static angle
local s_angle = Angle(0,0,0)

// Helper functions

local function getCursorPos()
	local p = util.IntersectRayWithPlane(LocalPlayer():EyePos(), LocalPlayer():GetAimVector(), origin, normal)

	// if there wasn't an intersection, don't calculate anything.
	if not p then return end
	if WorldToLocal(LocalPlayer():GetShootPos(), s_angle, origin, angle).z < 0 then return end

	if maxrange > 0 and p:Distance(LocalPlayer():EyePos()) > maxrange then return end

	local pos = WorldToLocal(p, s_angle, origin, angle)

	return pos.x, -pos.y
end


function zclib.vgui3d.GetCursorPosition(pnl)
	if not IsValid(pnl) then return end
	local cx, cy = getCursorPos()


	local _x = (cx or 0) / (pnl.Scale or 1)
	local _y = (cy or 0) / (pnl.Scale or 1)

	return _x, _y
end

local function getParents(pnl)
	local parents = {}
	local parent = pnl:GetParent()
	while parent do
		table.insert(parents, parent)
		parent = parent:GetParent()
	end
	return parents
end

local function absolutePanelPos(pnl)
	local x, y = pnl:GetPos()
	local parents = getParents(pnl)

	for _, parent in ipairs(parents) do
		local px, py = parent:GetPos()
		x = x + px
		y = y + py
	end

	return x, y
end

local function pointInsidePanel(pnl, x, y)
	local px, py = absolutePanelPos(pnl)
	local sx, sy = pnl:GetSize()

	if not x or not y then return end

	x = x / scale
	y = y / scale

	return pnl:IsVisible() and x >= px and y >= py and x <= px + sx and y <= py + sy
end

// Input

local inputWindows = {}
local usedpanel = {}


local function postPanelEvent(pnl, event, ...)
	if not IsValid(pnl) or not pnl:IsVisible() or not pointInsidePanel(pnl, getCursorPos()) then return false end

	local handled = false

	for i, child in pairs(table.Reverse(pnl:GetChildren())) do
		if postPanelEvent(child, event, ...) then
			handled = true
			break
		end
	end

	if not handled and pnl[event] then
		pnl[event](pnl, ...)
		usedpanel[pnl] = {...}
		return true
	else
		return false
	end
end

// Always have issue, but less
local function checkHover(pnl, x, y, found)
	if not (x and y) then
		x, y = getCursorPos()
	end

	local validchild = false
	for c, child in pairs(table.Reverse(pnl:GetChildren())) do
		if not child:IsMouseInputEnabled() then continue end

		local check = checkHover(child, x, y, found or validchild)

		if check then
			validchild = true
		end
	end

	if found then
		if pnl.Hovered then
			pnl.Hovered = false
			if pnl.OnCursorExited then pnl:OnCursorExited() end
		end
	else
		if not validchild and pointInsidePanel(pnl, x, y) then
			pnl.Hovered = true
			if pnl.OnCursorEntered then pnl:OnCursorEntered() end

			return true
		else
			pnl.Hovered = false
			if pnl.OnCursorExited then pnl:OnCursorExited() end
		end
	end

	return false
end

// Mouse input

hook.Add("KeyPress", "zclib.vgui3d.VGUI3D2DMousePress", function(_, _key)
	if _key == IN_USE then
		for pnl in pairs(inputWindows) do
			if IsValid(pnl) then
				origin = pnl.Origin
				scale = pnl.Scale
				angle = pnl.Angle
				normal = pnl.Normal

				local key = input.IsKeyDown(KEY_LSHIFT) and MOUSE_RIGHT or MOUSE_LEFT

				postPanelEvent(pnl, "OnMousePressed", key)
			end
		end
	end
end)

hook.Add("KeyRelease", "zclib.vgui3d.VGUI3D2DMouseRelease", function(_, _key)
	if _key == IN_USE then
		for pnl, key in pairs(usedpanel) do
			if IsValid(pnl) then
				origin = pnl.Origin
				scale = pnl.Scale
				angle = pnl.Angle
				normal = pnl.Normal

				if pnl["OnMouseReleased"] then
					pnl["OnMouseReleased"](pnl, key[1])
				end

				usedpanel[pnl] = nil
			end
		end
	end
end)

hook.Add("CalcAbsolutePosition", "zclib.vgui3d.VGUI3D2DEntPosChange", function(pos,ang)
	zclib.vgui3d.Start3D2D(pos,ang,origin)
end)


function zclib.vgui3d.Start3D2D(pos, ang, res)
	origin = pos
	scale = res
	angle = ang
	normal = ang:Up()
	maxrange = 0

	cam.Start3D2D(pos, ang, res)
end

function zclib.vgui3d.MaxRange3D2D(range)
	maxrange = isnumber(range) and range or 0
end

function zclib.vgui3d.IsPointingPanel(pnl)
	origin = pnl.Origin
	scale = pnl.Scale
	angle = pnl.Angle
	normal = pnl.Normal

	return pointInsidePanel(pnl, getCursorPos())
end

local meta_Panel = FindMetaTable("Panel")
function meta_Panel:ZCLIBPaint3D2D()
	if not self:IsValid() then return end

	// Add it to the list of windows to receive input
	inputWindows[self] = true

	// Override think of DFrame's to correct the mouse pos by changing the active orientation
	if self.Think and not self.OThink then
		self.OThink = self.Think

		self.Think = function()
			origin = self.Origin
			scale = self.Scale
			angle = self.Angle
			normal = self.Normal
			self:OThink()
		end
	end

	// Update the hover state of controls
	checkHover(self)

	// Store the orientation of the window to calculate the position outside the render loop
	self.Origin = origin
	self.Scale = scale
	self.Angle = angle
	self.Normal = normal

	// Draw it manually
	self:SetPaintedManually(false)
		self:PaintManual()
	self:SetPaintedManually(true)
end

function zclib.vgui3d.End3D2D()
	cam.End3D2D()
end

--PATH addons/zeros_lua_libary/lua/zclib/util/cl_settings.lua:
if not CLIENT then return end

zclib = zclib or {}
zclib.Settings = zclib.Settings or {}

local Created = false

function zclib.Settings.OptionPanel(name,desc,main_color,bg_color, CPanel, cmds)
	local panel = vgui.Create("DPanel")
	panel:Dock(FILL)
	panel.Paint = function(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, bg_color)
		zclib.util.DrawOutlinedBox( 0, 0, w, h, 4, zclib.colors["black_a100"])
	end
	panel:DockPadding(10,10,10,10)

	local title = vgui.Create("DLabel", panel)
	title:Dock(TOP)
	title:SetText(name)
	title:SetFont(zclib.GetFont("zclib_font_medium"))
	title:DockPadding(5,5,5,5)
	title:SetTextColor(color_white)
	title:SetTall(30)

	if desc then
		local desc_pnl = vgui.Create("DLabel", panel)
		desc_pnl:Dock(TOP)
		desc_pnl:SetText(desc)
		desc_pnl:SetFont(zclib.GetFont("zclib_font_small_thin"))
		desc_pnl:DockPadding(5,2,5,2)
		desc_pnl:SetTextColor(color_white)
		desc_pnl:SetContentAlignment(4)
		//desc_pnl:SetWrap(true)
		desc_pnl:SizeToContentsY( 5 )
	end

	for k, v in ipairs(cmds) do
		if v.class == "DNumSlider" then

			local item = vgui.Create("DNumSlider", panel)
			item:Dock(TOP)
			item:DockPadding(5,5,5,5)
			item:DockMargin(5,5,5,5)

			item:SetText(v.name)
			item:SetMin(v.min)
			item:SetMax(v.max)

			item:SetDecimals(v.decimal)
			item:SetDefaultValue(math.Clamp(math.Round(GetConVar(v.cmd):GetFloat(),v.decimal),v.min,v.max))
			item:ResetToDefaultValue()
			item:SetConVar( v.cmd )
			item.OnValueChanged = function(self, val)

				if v.RunOnChange then pcall(v.RunOnChange,val) end

				if Created then
					RunConsoleCommand(v.cmd, tostring(val))
				end
			end
		elseif v.class == "DCheckBoxLabel" then

			local item = vgui.Create("DCheckBoxLabel", panel)
			item:Dock(TOP)
			item:DockPadding(5,5,5,5)
			item:DockMargin(5,5,5,5)
			item:SetText( v.name )
			item:SetConVar( v.cmd )
			item.OnChange = function(self, val)

				if v.RunOnChange then pcall(v.RunOnChange,val) end

				if Created then
					if val then
						RunConsoleCommand(v.cmd, "1")
					else
						RunConsoleCommand(v.cmd, "0")
					end
				end
			end


			timer.Simple(0.1, function()
				if (item) then
					item:SetValue(GetConVar(v.cmd):GetInt())
				end
			end)
		elseif v.class == "DButton" then
			local item = vgui.Create("DButton", panel)
			item:Dock(TOP)
			item:DockMargin(0,10,0,0)
			item:SetText( v.name )
			item:SetFont(zclib.GetFont("zclib_font_small"))
			item:SetTextColor(color_white)
			item.Paint = function(s, w, h)
				draw.RoundedBox(4, 0, 0, w, h, main_color)
				if s.Hovered then
					draw.RoundedBox(4, 0, 0, w, h, zclib.colors["white_a15"])
				end
			end
			item.DoClick = function()

				// if zclib.Player.IsAdmin(LocalPlayer()) == false then return end

				LocalPlayer():EmitSound("zclib_ui_click")

				if v.notify then notification.AddLegacy(  v.notify, NOTIFY_GENERIC, 2 ) end
				LocalPlayer():ConCommand( v.cmd )
			end
		elseif v.class == "DColorMixer" then

			local main = vgui.Create("DPanel", panel)
			main:SetSize(200 * zclib.wM, 300 * zclib.hM)
			main:Dock(TOP)
			main:DockPadding(5, 5, 5, 5)
			main:DockMargin(5, 5, 5, 5)
			main.Paint = function(s, w, h)
				draw.RoundedBox(4, 0, 0, w, 5 * zclib.hM, zclib.colors["black_a100"])

				draw.RoundedBox(4, 0, h - 5 * zclib.hM, w, 5 * zclib.hM, zclib.colors["black_a100"])
			end

			local a_title = vgui.Create("DLabel", main)
			a_title:Dock(TOP)
			a_title:SetFont(zclib.GetFont("zclib_font_small"))
			a_title:SetText(v.name)
			a_title:SetTextColor(color_white)
			a_title:SetContentAlignment(4)
			a_title:SizeToContentsY( 10 )

			local Mixer = vgui.Create("DColorMixer", main)
			Mixer:SetSize(200 * zclib.wM, 200 * zclib.hM)
			Mixer:Dock(FILL)
			Mixer:DockMargin(0, 5, 0, 5)
			Mixer:SetPalette(false)
			Mixer:SetAlphaBar(true)
			Mixer:SetWangs(true)

			if v.cmd[1] then Mixer:SetConVarR(v.cmd[1]) end
			if v.cmd[2] then Mixer:SetConVarG(v.cmd[2]) end
			if v.cmd[3] then Mixer:SetConVarB(v.cmd[3]) end
			if v.cmd[4] then Mixer:SetConVarA(v.cmd[4]) end

			main:InvalidateParent(true)
			main:SizeToChildren(false,true)
		elseif v.class == "Custom" then
			pcall(v.content,panel)
		end

		if v.desc then
			local desc_pnl = vgui.Create("DLabel", panel)
			desc_pnl:Dock(TOP)
			desc_pnl:DockMargin(5,5,5,5)
			desc_pnl:SetFont(zclib.GetFont("zclib_font_small_thin"))
			desc_pnl:SetText(v.desc)
			desc_pnl:SetTextColor(color_white)
			desc_pnl:SetContentAlignment(7)
			desc_pnl:SizeToContentsY( 30 )
			desc_pnl:SetWrap(true)


			// Only create a seperation line if we got another item after this
			if cmds[k + 1] then
				local line = vgui.Create("DPanel",panel)
				line:Dock(TOP)
				line:DockMargin(5,5,5,5)
				line:SetTall(4)
				line.Paint = function(s, w, h)
					draw.RoundedBox(0, 0, 0, w, h, zclib.colors["black_a100"])
				end
			end
		end
	end


	panel:InvalidateLayout(true)
	panel:SizeToChildren(true, true)

	CPanel:AddPanel(panel)
end

hook.Add("AddToolMenuCategories", "zclib_CreateCategories", function()
	spawnmenu.AddToolCategory("Options", "zclib_options", "Zeros Libary")
end)

hook.Add("PopulateToolMenu", "zclib_PopulateMenus", function()

	timer.Simple(0.2, function()
		Created = true
	end)

	spawnmenu.AddToolMenuOption("Options", "zclib_options", "zclib_Client_Settings", "Client Settings", "", "", function(CPanel)
		zclib.Settings.OptionPanel("Thumbnail Cache", nil, Color(82, 131, 198, 255), zclib.colors["ui02"], CPanel, {
			[1] = {
				name = "Delete Thumbnail Cache",
				desc = "Deletes any model thumbnails found at garrysmod/data/zclib/img",
				class = "DButton",
				cmd = "zclib_delete_thumbnails"
			}
		})

		zclib.Settings.OptionPanel("Imgur Cache", nil, Color(82, 131, 198, 255), zclib.colors["ui02"], CPanel, {
			[1] = {
				name = "Delete Imgur Cache",
				desc = "Deletes any images found at garrysmod/data/zclib/imgur",
				class = "DButton",
				cmd = "zclib_delete_imgur"
			}
		})

		zclib.Settings.OptionPanel("Other", nil, Color(82, 131, 198, 255), zclib.colors[ "ui02" ], CPanel, {
			[ 1 ] = {
				name = "Particle Effects",
				class = "DCheckBoxLabel",
				cmd = "zclib_cl_particleeffects"
			},
			[ 2 ] = {
				name = "Draw UI",
				class = "DCheckBoxLabel",
				cmd = "zclib_cl_drawui"
			},
			[ 3 ] = {
				name = "Dynamic Light",
				class = "DCheckBoxLabel",
				cmd = "zclib_cl_vfx_dynamiclight"
			},
			[ 4 ] = {
				name = "Volume",
				class = "DNumSlider",
				min = 0,
				max = 1,
				decimal = 2,
				cmd = "zclib_cl_sfx_volume"
			},
		})
	end)
end)

--PATH addons/zeros_lua_libary/lua/zclib/generic/sh_snapshoter.lua:
zclib = zclib or {}
zclib.RenderData = zclib.RenderData or {}
zclib.Snapshoter = zclib.Snapshoter or {}

/*

    A advanced system which renders png images from models

*/

function zclib.RenderData.Add(class,data)
	zclib.RenderData[class] = data
end

function zclib.RenderData.Get(class)
	return zclib.RenderData[class]
end


// Keeps track on which items getting currently rendered
zclib.Snapshoter.RenderQueu = zclib.Snapshoter.RenderQueu or {}
zclib.Snapshoter.Cache = zclib.Snapshoter.Cache or {}
zclib.Snapshoter.Paths = zclib.Snapshoter.Paths or {}

function zclib.Snapshoter.SetPath(class,func)
	zclib.Snapshoter.Paths[class] = func
end

if CLIENT then
	file.CreateDir("zclib")
	file.CreateDir("zclib/img")

	function zclib.Snapshoter.GetPath(ItemData)
		local path
		local class = ItemData.Class or ItemData.class
		if zclib.Snapshoter.Paths[class] then
			path = zclib.Snapshoter.Paths[class](ItemData)
		else
			path = hook.Run("zclib_GetImagePath",ItemData)
		end
		return path or (ItemData.model .. "_" .. (ItemData.model_skin or 0))
	end

	local THUMBNAIL_IMAGE_CACHE_EXPIRES = 86400 -- 1 day, in seconds

	// Returns the snapshot from the model or adds the request to the render queu
	function zclib.Snapshoter.Get(ItemData, Panel)
		if ItemData == nil then return end
		if ItemData.model == nil then return end

		// Get the image path
		local img_path = zclib.Snapshoter.GetPath(ItemData)

		// Remove file extension
		img_path = string.Replace(img_path, ".mdl", "")

		// Do we already have this image cached?
		if zclib.Snapshoter.Cache[img_path] then
			//zclib.Debug("[CustomRenderSystem] Image already cached! [" .. tostring(img_path) .. "]")

			return "data/" .. zclib.Snapshoter.Cache[img_path]
		end

		// If the player does not have the model then lets display a error symbol
		if util.IsValidModel(ItemData.model) == false then
			zclib.Debug("[CustomRenderSystem] Model not precached! [" .. tostring(ItemData.model) .. "]")
			return "materials/zerochain/zerolib/ui/invalid.png"
		end

		// Does the image exist in the data folder? "data/zclib/img"
		if file.Exists("zclib/img/" .. img_path .. ".png", "DATA") then

			// If the file is older then this then remove it
			if os.time() - file.Time("zclib/img/" .. img_path .. ".png", "DATA") > THUMBNAIL_IMAGE_CACHE_EXPIRES then
				zclib.Snapshoter.DeleteFile(img_path)
			else
				zclib.Debug("[CustomRenderSystem] Image file already exists! [" .. tostring(img_path) .. "]")

				// Cache and return
				zclib.Snapshoter.Cache[img_path] = "zclib/img/" .. img_path .. ".png"

				return "data/" .. zclib.Snapshoter.Cache[img_path]
			end
		end

		// Add to render queue
		zclib.Snapshoter.Add(img_path, ItemData, Panel)
	end

	// Adds a new render job to the queue
	function zclib.Snapshoter.Add(img_path, ItemData, Panel)

		// Is the image already in the render queue?
		if zclib.Snapshoter.RenderQueu[img_path] then

			// Lets add the panel so it gets updated too
			table.insert(zclib.Snapshoter.RenderQueu[img_path].img_pnls, Panel)
			return
		end

		zclib.Snapshoter.RenderQueu[img_path] = {
			ItemData = ItemData,
			img_pnls = {Panel}
		}

		if zclib.Hook.Exist("PreDrawHUD", "zclib_RenderManager") then return end
		zclib.Snapshoter.Start()
	end

	// Assigns the finished rendered images from the last job to the panels who requested it
	function zclib.Snapshoter.AssignLastJob(LastJob)
		zclib.Debug("[CustomRenderSystem] [Finished Job] [" .. tostring(LastJob.img_path) .. "]")

		// Set the last rendered image to the provided panel if its still valid
		if LastJob.pnls and LastJob.img_path then
			for k, v in pairs(LastJob.pnls) do
				if not IsValid(v) then continue end
				local path = "data/zclib/img/" .. tostring(LastJob.img_path) .. ".png"
				timer.Simple(0, function()
					if IsValid(v) then
						v:SetMaterial(Material(path, "noclamp smooth"))
					end
				end)
			end
		end

		zclib.Debug("[CustomRenderSystem] [Assigning Image] [" .. tostring(LastJob.img_path) .. "]")

		// Cache the last rendered image
		if LastJob.img_path then
			zclib.Snapshoter.Cache[LastJob.img_path] = "zclib/img/" .. LastJob.img_path .. ".png"
		end

		// Reset
		LastJob = {}
	end

	// Start the render system
	function zclib.Snapshoter.Start()
		zclib.Debug("[CustomRenderSystem] Started!")
		local nextRender = CurTime() + 0.1
		local LastJob = {}

		// PreDrawHUD
		zclib.Hook.Add("PreDrawHUD", "zclib_RenderManager", function()
			//cam.Start3D()
			if CurTime() > nextRender then
				if zclib.Snapshoter.RenderQueu == nil then
					zclib.Snapshoter.Stop()
				end

				//Assigns the finished rendered images from the last job to the panels who requested it
				if LastJob and table.Count(LastJob) > 0 then
					zclib.Snapshoter.AssignLastJob(LastJob)
				end

				if table.Count(zclib.Snapshoter.RenderQueu) <= 0 then
					zclib.Snapshoter.Stop()
				end

				// Render the next item in the list
				for k, v in pairs(zclib.Snapshoter.RenderQueu) do

					// Store the current Render Job for next round
					LastJob.pnls = table.Copy(v.img_pnls)
					LastJob.img_path = k

					hook.Run("zclib_PreRenderStartProductImage",v.ItemData)

					// Render the image
					zclib.Snapshoter.Render(k, v.ItemData)

					// Delete the item from the queue
					zclib.Snapshoter.RenderQueu[k] = nil

					zclib.Debug("[CustomRenderSystem] [Started Job] [" .. k .. "]")

					nextRender = CurTime() + 0.1
					break
				end
			end
			//cam.End3D()
		end)
	end

	// Stop the render system
	function zclib.Snapshoter.Stop()
		zclib.Debug("[CustomRenderSystem] Stopped!")
		zclib.Hook.Remove("PreDrawHUD", "zclib_RenderManager")
	end

	// Give the RT a size
	local TEX_SIZE = 256
	local MaterialCache = {}
	function zclib.Snapshoter.DrawScene(TheEnt,ItemData)

	    local mul = 0.25

	    // Set up the lighting. This is over-bright on purpose - to make the ents pop
	    render.ResetModelLighting( 2 * mul, 2 * mul, 2 * mul )

	    render.SetModelLighting(0, 3 * mul, 3 * mul, 3 * mul)
	    render.SetModelLighting(1, 2 * mul, 2 * mul, 2 * mul)
	    render.SetModelLighting(2, 2 * mul, 2 * mul, 2 * mul)
	    render.SetModelLighting(3, 2 * mul, 2 * mul, 2 * mul)
	    render.SetModelLighting(4, 2 * mul, 2 * mul, 2 * mul)
	    render.SetModelLighting(5, 2 * mul, 2 * mul, 2 * mul)

		// Runs a custom hook to allow the rendered scene to be modified
	    hook.Run("zclib_RenderProductImage",TheEnt,ItemData)

	    if ItemData.model_color then
	        render.SetColorModulation(ItemData.model_color.r / 255, ItemData.model_color.g / 255, ItemData.model_color.b / 255, 255)
	    end

		if ItemData.model_material and ItemData.model_material ~= "" and ItemData.model_material ~= " " then
			if MaterialCache[ItemData.model_material] == nil then
				MaterialCache[ItemData.model_material] = Material(ItemData.model_material)
			end
			render.MaterialOverride(MaterialCache[ItemData.model_material])
		end

	    if ItemData.model_skin then
	        TheEnt:SetSkin(ItemData.model_skin)
	    end

	    if ItemData.model_bg then
	        for k, v in pairs(ItemData.model_bg) do
	            TheEnt:SetBodygroup(k, v)
	        end
	    end

	    local renderdata = zclib.RenderData.Get(ItemData.Class or ItemData.class)
	    local apos = Vector(0, 0, 0) - TheEnt:LocalToWorld(TheEnt:OBBCenter())
	    local ang = Angle(0, 0, 0)

		if renderdata then
			if renderdata.pos then
				apos = renderdata.pos
			end

			if renderdata.ang then
				ang = renderdata.ang
			end
		end

	    render.Model({
	        model = TheEnt:GetModel(),
	        pos = apos,
	        angle = ang
	    }, TheEnt)

	    // Runs a custom hook to allow the rendered scene to be modified
	    hook.Run("zclib_PostRenderProductImage",TheEnt,ItemData)
	end

	local PureBlack = Color(0,0,0,255)
	function zclib.Snapshoter.Render(img_path,ItemData)

		//render.Clear( 0,0,0, 255, true,true )

		// No engine lightning on the model please
		render.SuppressEngineLighting(true)

		// Disable alpha writing
		render.SetWriteDepthToDestAlpha( false )

		// https://wiki.facepunch.com/gmod/Enums/TEXTUREFLAGS
		local textureFlags = 0

		// TEXTUREFLAGS_TRILINEAR
		//textureFlags = textureFlags + 2

		// TEXTUREFLAGS_EIGHTBITALPHA
		//textureFlags = textureFlags + 8192

		// TEXTUREFLAGS_NOLOD
		//textureFlags = textureFlags + 512

		// TEXTUREFLAGS_CLAMPS
		//textureFlags = textureFlags + 4

		// TEXTUREFLAGS_CLAMPT
		//textureFlags = textureFlags + 8

		// TEXTUREFLAGS_NOMIP
		//textureFlags = textureFlags + 256

		// TEXTUREFLAGS_RENDERTARGET
		textureFlags = textureFlags + 32768

	    // Create / get the RT
	    local rt = GetRenderTargetEx("zclib_product_render", TEX_SIZE, TEX_SIZE, RT_SIZE_OFFSCREEN, MATERIAL_RT_DEPTH_ONLY, bit.bor(2,8192,512,4,8,256,32768), 0, IMAGE_FORMAT_RGBA8888) //[[IMPORTANT]]

	    render.ClearRenderTarget( rt,PureBlack)
		render.Clear( 0,0,0, 255, true,true )
		//render.ClearDepth()

	    //
	    // Create a model
	    //
	    local TheEnt = zclib.ClientModel.Add(ItemData.model, RENDERGROUP_BOTH)
		if not IsValid(TheEnt) then return end
		TheEnt:SetLOD( 0 )

	    local min, max = TheEnt:GetRenderBounds()

	    local FOV = 10

	    //
	    // This is gonna take some cunning to look awesome!
	    //

	    local Size = max - min
	    local Radius = Size:Length() * 0.5
	    local CamDist = Radius / math.sin(math.rad(FOV) / 2) // Works out how far the camera has to be away based on radius + fov!
	    local Center = LerpVector(0.5, min, max)
	    local CamPos = Center + Vector(1,1, 0.5):GetNormal() * CamDist
	    local EyeAng = (Center - CamPos):GetNormal():Angle()

		local renderdata = zclib.RenderData.Get(ItemData.Class or ItemData.class)
		if renderdata then
			if renderdata.FOV then
				FOV = renderdata.FOV
			end

			if renderdata.CamPosOverwrite then
				CamPos = renderdata.CamPosOverwrite
			end
			if renderdata.EyeAngOverwrite then
				EyeAng = renderdata.EyeAngOverwrite
			end
		end

		local fov_overwrite = hook.Run("zclib_Snapshoter_Overwrite_FOV",ItemData)
		if fov_overwrite then
			FOV = fov_overwrite
		end

		local campos_overwrite = hook.Run("zclib_Snapshoter_Overwrite_CamPos",ItemData)
		if campos_overwrite then
			CamPos = campos_overwrite
		end

	    //
	    // The base view
	    //
	    local view = {
	        type = "3D",
	        origin = CamPos,
	        angles = EyeAng,
	        x = 0,
	        y = 0,
	        w = 256,
	        h = 256,
	        aspect = 1,
	        fov = FOV
	    }

	    // Lets define the render target
	    render.PushRenderTarget( rt )

			// Clear everything
			render.ClearDepth()
			render.Clear( 0, 0, 0, 0 )

	        // Dont ask why, this needs to be set to support alpha
	        render.OverrideAlphaWriteEnable( true, true )

	            //render.UpdateRefractTexture()

	            cam.Start(view)
				zclib.Snapshoter.DrawScene(TheEnt,ItemData)
	            cam.End()

				//render.UpdateRefractTexture()

	        render.OverrideAlphaWriteEnable( false )
		render.PopRenderTarget()

	    // Lets put the render target in to our current render call (whatever that means)
	    render.SetRenderTarget(rt)

	    local png_final = render.Capture({
	        format = "png",
	        x = 0,
	        y = 0,
	        w = TEX_SIZE,
	        h = TEX_SIZE,
	        alpha = true
	    })

	    // Remove the filename from the path
	    local segments = string.Explode( "/", img_path )
	    segments[#segments] = nil
	    segments = string.Implode("/",segments)

	    // Save image to file
	    file.CreateDir("zclib/img/" .. segments)
	    file.Write("zclib/img/" .. img_path .. ".png", png_final )

	    // Enable lighting again (or it will affect outside of this loop!)
	    render.SuppressEngineLighting(false)
	    render.SetWriteDepthToDestAlpha( true )
	    render.SetColorModulation(1, 1, 1, 1)
		render.MaterialOverride()
		render.MaterialOverrideByIndex()

	    // Remove the client ent again
	    TheEnt:Remove()
	end

	/*
		Deletes a single file from the machine and cache
	*/
	function zclib.Snapshoter.DeleteFile(path)
		file.Delete("zclib/img/" .. path .. ".png")
		zclib.Snapshoter.Cache[path] = nil
	end

	/*
		Deletes all files from the machine and cache
	*/
	function zclib.Snapshoter.DeleteAllFiles(path)
	    local files, directs = file.Find(path .. "/*", "DATA")
	    // Remove files
	    for k, v in pairs(files) do
	        if file.Exists(path .. "/" .. v, "DATA") then
	            file.Delete(path .. "/" .. v)
	        end
	    end

	    // Remove directory
	    file.Delete(path)

	    for k, v in pairs(directs) do
	        zclib.Snapshoter.DeleteAllFiles(path .. "/" .. v)
	    end

		zclib.Snapshoter.RenderQueu = {}
		zclib.Snapshoter.Cache = {}
	end

	concommand.Add("zclib_delete_thumbnails", function(ply, cmd, args)

	    // Delete any item thumbnails
	    zclib.Snapshoter.DeleteAllFiles("zclib/img")

	    timer.Simple(1, function()
	        notification.AddLegacy("Thumbnails removed!", NOTIFY_GENERIC, 4)
	        surface.PlaySound("common/bugreporter_succeeded.wav")
	    end)
	end)
end

if SERVER then
	// A system to force delete a certain image path or all files inside the folder
	util.AddNetworkString("zclib_snapshoter_Delete")
	net.Receive("zclib_snapshoter_Delete", function(len,ply)
		zclib.Debug_Net("zclib_snapshoter_Delete", len)

		// Only admins can force the clients to delete a image thumbnails
		if not zclib.Player.IsAdmin(ply) then return end

		local path = net.ReadString()
		zclib.Snapshoter.Delete(path)
	end)

	function zclib.Snapshoter.Delete(path)
		net.Start("zclib_snapshoter_Delete")
		net.WriteString(path)
		net.Broadcast()
	end
else

	// Lets remove any file older then 1 month
	local THUMBNAIL_IMAGE_CACHE_CLEANUP = 2678400
	zclib.Hook.Add("zclib_PlayerInitialized", "zclib_PlayerInitialized_filecleanup", function() zclib.Snapshoter.Cleanup("zclib/img") end)
	function zclib.Snapshoter.Cleanup(path)
		local files, directs = file.Find(path .. "/*", "DATA")
		// Remove files
		for k, v in pairs(files) do
			if file.Exists(path .. "/" .. v, "DATA") and os.time() - file.Time(path .. "/" .. v, "DATA") > THUMBNAIL_IMAGE_CACHE_CLEANUP then
				file.Delete(path .. "/" .. v)
			end
		end

		for k, v in pairs(directs) do
			zclib.Snapshoter.Cleanup(path .. "/" .. v)
		end
	end

	net.Receive("zclib_snapshoter_Delete", function(len)
		zclib.Debug_Net("zclib_snapshoter_Delete", len)
		local path = net.ReadString()

		zclib.Snapshoter.Delete(path)
	end)

	// Deletes the png on the specified path
	function zclib.Snapshoter.Delete(path,SendToServer)

		if file.IsDir( "zclib/img/" .. path, "DATA" ) then
			// Delete all files in that folder
			for k, v in pairs(file.Find("zclib/img/" .. path .. "/*", "DATA")) do
				local itm = string.sub(v, 1, string.len(v) - 4)
				zclib.Snapshoter.DeleteFile(path .. "/" .. itm)
			end
		else
			// Delete this single file
			zclib.Snapshoter.DeleteFile(path)
		end

		if SendToServer then
			net.Start("zclib_snapshoter_Delete")
			net.WriteString(path)
			net.SendToServer()
		end
	end
end

--PATH addons/zeros_lua_libary/lua/zclib/generic/cl_imgur.lua:
if SERVER then return end

zclib = zclib or {}
zclib.Imgur = {}
zclib.Imgur.CachedMaterials = {}

/*

	A system that automaticly downloads Images from Image Sharing Service sites

*/

file.CreateDir("zclib")

function zclib.Imgur.Init()
	zclib.Debug("zclib.Imgur.Init")
	if file.Exists("zclib/" .. zclib.config.ActiveImageService, "DATA") == false then
		file.CreateDir("zclib/" .. zclib.config.ActiveImageService)
	end

	// Load the cached id list, if it exists
	zclib.Imgur.CachedImages = {}
	if file.Exists("zclib/" .. zclib.config.ActiveImageService .. "_cachedids.txt", "DATA") then

		// Load imgur id list
		zclib.Imgur.CachedImages = util.JSONToTable(file.Read("zclib/" .. zclib.config.ActiveImageService .. "_cachedids.txt", "DATA")) or {}

		// Check if the image id as lowercase id exists as png and if so then load it as material
		for imgurid, _ in pairs(zclib.Imgur.CachedImages) do
			if file.Exists("zclib/" .. zclib.config.ActiveImageService .. "/" .. string.lower(imgurid) .. ".png", "DATA") then
				zclib.Imgur.CachedMaterials[imgurid] = Material("data/zclib/" .. zclib.config.ActiveImageService .. "/" .. string.lower(imgurid) .. ".png", "smooth noclamp")
			end
		end
	end
end

function zclib.Imgur.GetMaterial(id, callback,retry_format)

	if id == nil then
		callback(false)
		return
	end

	if id == "" then
		callback(false)
		return
	end

	if id == " " then
		callback(false)
		return
	end


	//Here we check if the id allready exists in our cache
	if zclib.Imgur.CachedMaterials[id] then
        //zclib.Debug("Image already loaded, returning material, " .. tostring(zclib.Imgur.CachedMaterials[id]))
		callback(zclib.Imgur.CachedMaterials[id])
	else
		//If the image done exists in the cache then we check if the file is allready on the clients machine
		if file.Exists("zclib/" .. zclib.config.ActiveImageService .. "/" .. string.lower(id) .. ".png", "DATA") then
			zclib.Debug("File found, loading material then returning")

			//If its on the machine then we load it in to our cache
			zclib.Imgur.CachedMaterials[id] = Material("data/zclib/" .. zclib.config.ActiveImageService .. "/" .. string.lower(id) .. ".png", "smooth noclamp")
			callback(zclib.Imgur.CachedMaterials[id])
		else
			zclib.Debug("Failed to find image, attempting to load from " .. zclib.config.ActiveImageService .. " > " .. "zclib/" .. zclib.config.ActiveImageService .. "/" .. id .. ".png")

			//If the file does not exist then we load it from imgur and store the result in our cache
			//print("[" .. math.Round(CurTime(), 2) .. "][IMGUR] Fetching Image: " .. id)
			http.Fetch(zclib.config.ImageServices[zclib.config.ActiveImageService] .. id .. (retry_format or ".png"), function(img, len, headers, code)
				local filesize = len / 1000
				if filesize > zclib.config.ImageSizeLimit then
					callback(false)
				else

					// This makes sure the received data is a image
					if headers["Content-Type"] == "image/png" or headers["Content-Type"] == "image/jpeg" or headers["Content-Type"] == "image/jpg"  then
						zclib.Debug("Loaded Imgur Image : " .. id .. ".png")

						//print("[" .. math.Round(CurTime(), 2) .. "][IMGUR] Saving Image: " .. id)

						// Add original upper/lower case id to list
						zclib.Imgur.AddToImageCache(id)

						// Create image file , but its gonna be lowercase automaticly, thanks garry :(
						file.Write("zclib/" .. zclib.config.ActiveImageService .. "/" .. id .. ".png", img)

						// Cache lowercase material with original id
						zclib.Imgur.CachedMaterials[id] = Material("data/zclib/" .. zclib.config.ActiveImageService .. "/" .. id .. ".png", "smooth noclamp")

						callback(zclib.Imgur.CachedMaterials[id])
					else
						if retry_format == nil then
							zclib.Imgur.GetMaterial(id, callback,".jpg")
							return
						end
						callback(false)
					end
				end
			end, function()
				callback(false)
			end)
		end
	end
end

function zclib.Imgur.AddToImageCache(id)

	// Add id to list
	zclib.Imgur.CachedImages[id] = true

	// save to file
	file.Write("zclib/" .. zclib.config.ActiveImageService .. "_cachedids.txt", util.TableToJSON(zclib.Imgur.CachedImages,true))
end

zclib.Imgur.Init()

function zclib.Imgur.DeleteAllFiles(path)
	local files, directs = file.Find(path .. "/*", "DATA")

	-- Remove files
	for k, v in pairs(files) do
		if file.Exists(path .. "/" .. v, "DATA") then
			file.Delete(path .. "/" .. v)
		end
	end

	-- Remove directory
	file.Delete(path)

	for k, v in pairs(directs) do
		zclib.Snapshoter.DeleteAllFiles(path .. "/" .. v)
	end
end

concommand.Add("zclib_delete_imgur", function(ply, cmd, args)
	zclib.Imgur.DeleteAllFiles("zclib/imgur")
	file.Delete("zclib/imgur_cachedids.txt")

	zclib.Imgur.DeleteAllFiles("zclib/imgpile")
	file.Delete("zclib/imgpile_cachedids.txt")

	zclib.Imgur.CachedMaterials = {}
	zclib.Imgur.CachedImages = {}

	timer.Simple(1, function()
		notification.AddLegacy("Imgur cache removed!", NOTIFY_GENERIC, 4)
		surface.PlaySound("common/bugreporter_succeeded.wav")
	end)
end)

--PATH addons/zeros_lua_libary/lua/zclib/inventory/vgui/cl_slot.lua:
local VGUIItem = {}

function VGUIItem:Init()
    self.LastHoveredByDragPanel = CurTime()
end

function VGUIItem:DoClick()
    zclib.vgui.PlaySound("UI/buttonclick.wav")
    self:OnClick()
    if self:CanSelect() == false then return end
    self:OnSelect()
end

function VGUIItem:OnClick()
end

function VGUIItem:PostDraw(w, h)
end

function VGUIItem:PreDraw(w, h)
end

function VGUIItem:CanSelect()
end

function VGUIItem:OnSelect()
end

function VGUIItem:GotSelected()
end

function VGUIItem:Paint(w, h)
	zclib.BMASKS.BeginMask("mask_roundbox")
	    if self:CanSelect() then
	        draw.RoundedBox(5, 0, 0, w, h, ( self:IsHovered() or self:GotSelected() ) and zclib.colors["ui_highlight"] or zclib.colors["ui00"])
	    else
	        draw.RoundedBox(5, 0, 0, w, h, zclib.colors["ui00"])
	    end

		if self.ItemData and self.ItemData.BG_Image then
			surface.SetDrawColor(self.ItemData.BG_Color or color_white)
	        surface.SetMaterial(self.ItemData.BG_Image)
	        surface.DrawTexturedRect(0, 0, w, h)
	    end

	    // Recreates the hover effect when a item gets dragged over it
	    if (CurTime() - self.LastHoveredByDragPanel) <= 0 then
	        draw.RoundedBox(5, 0, 0, w, h, zclib.colors["ui_highlight"])
	    end

	    // Draw before the image
	    self:PreDraw(w, h)
	zclib.BMASKS.EndMask("mask_roundbox", 0, 0 , w, h, 255)
end

function VGUIItem:PaintOver(w, h)

    /*
    local mat = self:GetMaterial()
    if mat then
        self.DropScale = math.Clamp((self.DropScale or 1) - FrameTime() * 1,1,1.5)
        surface.SetDrawColor(color_white)
        surface.SetMaterial(mat)
        surface.DrawTexturedRect(0, 0, w * self.DropScale, h * self.DropScale)
    end
    */

    // Draw the name
    if self.ItemData then

        if self:IsHovered() then
            self.YPos = Lerp(FrameTime() * 15,self.YPos or 1,1)
            self.XPos = Lerp(FrameTime() * 15,self.XPos or 1,1)
        else
            self.YPos = Lerp(FrameTime() * 15,self.YPos or 1.45,1.45)
            self.XPos = Lerp(FrameTime() * 15,self.XPos or 1.5,1.5)
        end

        //self.YPos = 1
        self.XPos = 1

        if self.ItemData.Name then
            draw.RoundedBox(0, 0, (h * 0.7) * self.YPos, w, h * 0.32, zclib.colors["black_a100"])
            // Welp thats one way to figure out which font to use
            if self.font_name == nil then self.font_name = zclib.GetFont("zclib_font_mediumsmall") end
            local txtW = zclib.util.GetTextSize(self.ItemData.Name, self.font_name)
            if txtW > w * 0.9 then
                if self.font_name == zclib.GetFont("zclib_font_mediumsmall") then
                    self.font_name = zclib.GetFont("zclib_font_small")
                elseif self.font_name == zclib.GetFont("zclib_font_small") then
                    self.font_name = zclib.GetFont("zclib_font_tiny")
                elseif self.font_name == zclib.GetFont("zclib_font_tiny") then
                    self.font_name = zclib.GetFont("zclib_font_nano")
                end
            end
            draw.SimpleText(self.ItemData.Name, self.font_name, w / 2, (h * 0.85) * self.YPos, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            if self.ItemData.Health and self.ItemData.Health > 0 and (self.ItemData.MaxHealth and self.ItemData.MaxHealth > 0) then
                local fract = (1 / (self.ItemData.MaxHealth or 100)) * self.ItemData.Health
                draw.RoundedBox(0, 0, (h * 0.8) * self.YPos - h * 0.08, w, h * 0.08, zclib.colors["black_a100"])
                draw.RoundedBox(0, 0, (h * 0.8) * self.YPos - h * 0.08, w * fract, h * 0.08, zclib.util.LerpColor(fract, zclib.colors["red01"], zclib.colors["green01"]))
            end
        end

        if self.ItemData.Amount and self.ItemData.Amount > 1 then
            //draw.RoundedBox(5, (w * 0.7) * self.XPos, 0, w * 0.3, h * 0.2, zclib.colors["black_a100"])
            draw.SimpleText("x" .. self.ItemData.Amount, zclib.GetFont("zclib_font_small"), (w * 0.93) * self.XPos, h * 0.12, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
        end
    end

    /*
    if self.slot_id then
        draw.SimpleText(self.slot_id,zclib.GetFont("zclib_font_medium"), w / 2, h / 2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    */

    // Draw after the image
    self:PostDraw(w, h)

    /*
    // Draw the hover
    if self:CanSelect() == true and self:IsHovered() then
        draw.RoundedBox(5, 0, 0, w, h, zclib.colors["white_a2"])
    end
    */
    return true
end

function VGUIItem:Update(ItemData)

    self.ItemData = ItemData

    if self:IsEmpty() then
        self:SetTooltip(false)
        self:SetImage("nil")
        self:SetImageVisible(false)
        return
    end
    self:SetImageVisible(true)

    if ItemData.Name then
        self:SetTooltip(ItemData.Name)
    end

    local ItemClass = ItemData.Class

	local mdl = zclib.ItemDefinition.GetModel(ItemClass,ItemData)

	self.ItemData.BG_Image = zclib.ItemDefinition.GetBG_Image(ItemData.Class,ItemData)

	self.ItemData.BG_Color = zclib.ItemDefinition.GetBG_Color(ItemData.Class,ItemData)

    local DefinitionData = zclib.ItemDefinition.Get(ItemClass)
	if DefinitionData and DefinitionData.GetAmount then
		self.ItemData.Amount = DefinitionData.GetAmount(ItemData)
	end

    if DefinitionData and DefinitionData.Image then
        self:SetImage(DefinitionData.Image)
        return
    end

	local RenderData = {
		data = ItemData.Data,
		class = ItemData.Class,
		model = mdl,
		model_color = zclib.ItemDefinition.GetColor(ItemClass, ItemData),
		model_material = zclib.ItemDefinition.GetMaterial(ItemClass, ItemData),
		model_skin = zclib.ItemDefinition.GetSkin(ItemClass, ItemData),
		model_bg = zclib.ItemDefinition.GetBodyGroups(ItemClass, ItemData),
	}

	local img = zclib.Snapshoter.Get(RenderData, self)

	if img then
		self:SetImage(img)
	else
		self:SetImage("materials/zerochain/zerolib/ui/icon_loading.png")
	end
end

function VGUIItem:IsEmpty()
    return self.ItemData == nil or table.Count(self.ItemData) <= 0
end

// Gets called when the slot getting dropped somewhere
function VGUIItem:OnDrop()
    // Play drop sound
    zclib.Sound.EmitFromEntity("inv_add", LocalPlayer())

    // Play drop animation
    self.DropScale = 1.5
end

derma.DefineControl("zclib_inventory_slot", "A inventory slot panel", VGUIItem, "DImageButton")

--PATH addons/zeros_weedfarm/lua/zweedfarm/cl/zwf_settings_menu.lua:
if not CLIENT then return end
local Created = false

CreateConVar("zwf_cl_sfx_volume", "0.5", {FCVAR_ARCHIVE})
CreateConVar("zwf_cl_vfx_lightsprite", "1", {FCVAR_ARCHIVE})
CreateConVar("zwf_cl_vfx_particleeffects", "1", {FCVAR_ARCHIVE})
CreateConVar("zwf_cl_vfx_ventilatorffects", "0", {FCVAR_ARCHIVE})
CreateConVar("zwf_cl_vfx_lightcone", "1", {FCVAR_ARCHIVE})
CreateConVar("zwf_cl_vfx_dynlight", "0", {FCVAR_ARCHIVE})
CreateConVar("zwf_cl_vfx_skankeffect", "1", {FCVAR_ARCHIVE})
CreateConVar("zwf_cl_vfx_exhaleeffect", "1", {FCVAR_ARCHIVE})
CreateConVar("zwf_cl_vfx_epilepsy", "0", {FCVAR_ARCHIVE})
CreateConVar("zwf_cl_vfx_drawui", "1", {FCVAR_ARCHIVE})

cvars.AddChangeCallback( "zwf_cl_sfx_volume", function( convar_name, value_old, value_new )
	zwf.f.VolumeChanged(value_old,value_new)
end )


local function zwf_OptionPanel(name, CPanel, cmds)
	local panel = vgui.Create("DPanel")
	panel:SetSize(250 , 40 + (35 * table.Count(cmds)))
	panel.Paint = function(s, w, h)
		draw.RoundedBox(4, 0, 0, w, h, zwf.default_colors["gray01"])
	end

	local title = vgui.Create("DLabel", panel)
	title:SetPos(10, 2.5)
	title:SetText(name)
	title:SetFont("zwf_settings_font01")
	title:SetSize(panel:GetWide(), 30)
	title:SetTextColor(zwf.default_colors["green09"])

	for k, v in pairs(cmds) do
		if v.class == "DNumSlider" then

			local item = vgui.Create("DNumSlider", panel)
			item:SetPos(10, 35 * k)
			item:SetSize(panel:GetWide(), 30)
			item:SetText(v.name)
			item:SetMin(v.min)
			item:SetMax(v.max)
			item:SetDecimals(v.decimal)
			item:SetDefaultValue(math.Clamp(math.Round(GetConVar(v.cmd):GetFloat(),v.decimal),v.min,v.max))
			item:ResetToDefaultValue()

			item.OnValueChanged = function(self, val)

				if (not Created) then
					RunConsoleCommand(v.cmd, tostring(val))
				end
			end

			timer.Simple(0.1, function()
				if (item) then
					item:SetValue(math.Clamp(math.Round(GetConVar(v.cmd):GetFloat(),v.decimal),v.min,v.max))
				end
			end)
		elseif v.class == "DCheckBoxLabel" then

			local item = vgui.Create("DCheckBoxLabel", panel)
			item:SetPos(10, 35 * k)
			item:SetSize(panel:GetWide(), 30)
			item:SetText( v.name )
			item:SetConVar( v.cmd )
			item:SetValue(0)
			item.OnChange = function(self, val)

				if (not Created) then
					if ((bVal and 1 or 0) == cvars.Number(v.cmd)) then return end
					RunConsoleCommand(v.cmd, tostring(val))
				end
			end

			timer.Simple(0.1, function()
				if (item) then
					item:SetValue(GetConVar(v.cmd):GetInt())
				end
			end)
		elseif v.class == "DButton" then
			local item = vgui.Create("DButton", panel)
			item:SetPos(10, 35 * k)
			item:SetSize(panel:GetWide(), 30)
			item:SetText( "" )
			//item:SetConsoleCommand( v.cmd )
			item.Paint = function(s, w, h)
				draw.RoundedBox(5, 0, 0, w, h, zwf.default_colors["gray02"])
				draw.SimpleText(v.name, "zwf_settings_font02", w / 2, h / 2, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

				if s.Hovered then
					draw.RoundedBox(5, 0, 0, w, h, zwf.default_colors["white02"])
				end
			end
			item.DoClick = function()

				if zwf.f.IsAdmin(LocalPlayer()) == false then return end

				LocalPlayer():EmitSound("zwf_ui_click")

				if v.notify then

					notification.AddLegacy(  v.notify, NOTIFY_GENERIC, 2 )
				end
				LocalPlayer():ConCommand( v.cmd )

			end
		end
	end

	CPanel:AddPanel(panel)
end


local function zweedfarm_settings(CPanel)
	Created = true
	CPanel:AddControl("Header", {
		Text = "Client Settings",
		Description = ""
	})

	zwf_OptionPanel("VFX",CPanel,{
		[1] = {name = "ParticleEffects",class = "DCheckBoxLabel", cmd = "zwf_cl_vfx_particleeffects"},
		[2] = {name = "Fan Effects",class = "DCheckBoxLabel", cmd = "zwf_cl_vfx_ventilatorffects"},
		[3] = {name = "Light Sprites",class = "DCheckBoxLabel", cmd = "zwf_cl_vfx_lightsprite"},
		[4] = {name = "Light Cone",class = "DCheckBoxLabel", cmd = "zwf_cl_vfx_lightcone"},
		[5] = {name = "DynamicLight",class = "DCheckBoxLabel", cmd = "zwf_cl_vfx_dynlight"},
		[6] = {name = "Skank Effect",class = "DCheckBoxLabel", cmd = "zwf_cl_vfx_skankeffect"},
		[7] = {name = "Exhale Effect",class = "DCheckBoxLabel", cmd = "zwf_cl_vfx_exhaleeffect"},
		[8] = {name = "Epilepsy SafeMode",class = "DCheckBoxLabel", cmd = "zwf_cl_vfx_epilepsy"},
	})

	zwf_OptionPanel("SFX",CPanel,{
		[1] = {name = "Volume",class = "DNumSlider", cmd = "zwf_cl_sfx_volume",min = 0,max = 1,decimal = 2},
	})

	timer.Simple(0.2, function()
		Created = false
	end)
end

local function zweedfarm_admin_settings(CPanel)

	CPanel:AddControl("Header", {
		Text = "Admin Settings",
		Description = ""
	})

	zwf_OptionPanel("NPC",CPanel,{
		[1] = {name = "Save",class = "DButton", cmd = "zwf_save_weedbuyer"},
		[2] = {name = "Remove",class = "DButton", cmd = "zwf_remove_weedbuyer"},
	})

	zwf_OptionPanel("Commands",CPanel,{
		[1] = {name = "Spawn Muffin",class = "DButton", cmd = "zwf_debug_spawn_muffin"},
		[2] = {name = "Spawn Brownie",class = "DButton", cmd = "zwf_debug_spawn_brownie"},
		[3] = {name = "Spawn WeedJar",class = "DButton", cmd = "zwf_debug_spawn_weedjars"},
		[4] = {name = "Spawn WeedBlock",class = "DButton", cmd = "zwf_debug_spawn_weedblock"},
	})
end


hook.Add( "PopulateToolMenu", "zwf_PopulateMenus", function()
	spawnmenu.AddToolMenuOption( "Options", "WeedFarm", "zwf_Settings", "Client Settings", "", "", zweedfarm_settings )
	spawnmenu.AddToolMenuOption("Options", "WeedFarm", "zwf_Admin_Settings", "Admin Settings", "", "", zweedfarm_admin_settings)
end )

hook.Add( "AddToolMenuCategories", "zwf_CreateCategories", function()
	spawnmenu.AddToolCategory( "Options", "WeedFarm", "WeedFarm" );
end )

--PATH addons/rp_advdupe2/lua/autorun/client/advdupe2_cl_init.lua:
AdvDupe2 = {
	Version = "1.1.0",
	Revision = 51,
	InfoText = {},
	DataFolder = "advdupe2",
	FileRenameTryLimit = 256,
	ProgressBar = {}
}

if(!file.Exists(AdvDupe2.DataFolder, "DATA"))then
	file.CreateDir(AdvDupe2.DataFolder)
end

include "advdupe2/file_browser.lua"
include "advdupe2/sh_codec.lua"
include "advdupe2/cl_file.lua"
include "advdupe2/cl_ghost.lua"

function AdvDupe2.Notify(msg,typ,dur)
	surface.PlaySound(typ == 1 and "buttons/button10.wav" or "ambient/water/drip1.wav")
	GAMEMODE:AddNotify(msg, typ or NOTIFY_GENERIC, dur or 5)
	//if not game.SinglePlayer() then
		print("[AdvDupe2Notify]\t"..msg)
	//end
end

usermessage.Hook("AdvDupe2Notify",function(um)
	AdvDupe2.Notify(um:ReadString(),um:ReadChar(),um:ReadChar())
end)

--PATH addons/brick_s_server_framework/lua/bricks_server/languages/bricks_server/french.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "french", {
    ["search"] = "Rechercher",
    ["invalidPlayerProfile"] = "Profil de joueur invalide",
    ["unbound"] = "NON ASSIGNER",
    ["themes"] = "Thèmes",
    ["groups"] = "Groupes",
    ["general"] = "General",
    ["itemWhitelisting"] = "Whitelist d'items",
    ["rarities"] = "Rareté",
    ["languages"] = "Langues",
    ["disabled"] = "Désactivé",
    ["enabled"] = "Activé",
    ["purchase"] = "Acheter",
    ["profile"] = "Profil",
    ["view"] = "Inspecter",
    ["admin"] = "Admin",
    ["noToolPermission"] = "Vous n'avez pas la permission d'utiliser cet outil.",
    ["settings"] = "Paramètres",
    ["players"] = "Joueurs",
    ["modules"] = "Modules",

    ["userGroupEditor"] = "Éditeur de groupes",
    ["addNewGroup"] = "Ajouter un groupe",
    ["newUserGroup"] = "Quel devrait être le nouveau groupe?",
    ["groupName"] = "GroupName",

    ["custom"] = "Custom",
    ["addNew"] = "Ajouter un nouveau",
    ["material"] = "Material",
    ["directImage"] = "Entrez une URL d'image directe ci-dessous.",
    ["default"] = "Default",
    ["selectMaterial"] = "Vous devez choisir un material",

    ["errorNoText"] = "ERREUR: AUCUN TEXT",
    ["selectOption"] = "Sélectionnez une option",
    ["selectValue"] = "Veuillez sélectionner une valeur.",
    ["selectColor"] = "Veuillez choisir une couleur.",
    ["configSaved"] = "Config sauvegardé!",
    ["cmdNoPermission"] = "Vous n'avez pas la permission d'utiliser cette commande.",
    ["entityPosUpdated"] = "Positions des entités mise à jour!",
    ["noEntitiesSpawned"] = "Aucune entité sauvée n'a été spawn.",
    ["xEntitiesSpawned"] = "%d entités sauvées ont été spawn.",
    ["error"] = "ERREUR",

    ["seconds"] = "%d secondes",
    ["second"] = "%d seconde",
    ["minutes"] = "%d minutes",
    ["minute"] = "%d minute",
    ["hours"] = "%d heures",
    ["hour"] = "%d heure",

    ["noRarity"] = "Aucune rareté",

    ["config"] = "Config",
    ["edit"] = "Modifier",
    ["editColor"] = "Changer la couleur",
    ["editName"] = "Changer le nom",
    ["remove"] = "Supprimer",
    ["name"] = "Nom",
    ["description"] = "Description",
    ["model"] = "Model",
    ["icon"] = "Icon",
    ["type"] = "Type",
    ["price"] = "Prix",
    ["group"] = "Group",
    ["category"] = "Categorie",
    ["color"] = "Couleur",
    ["invalidType"] = "Type invalide.",
    ["invalidOption"] = "Option invalide .",
    ["invalidChoice"] = "Choix invalide.",
    ["invalidGroup"] = "Group invalide.",
    ["invalidPlayer"] = "Joueur invalide.",
    ["true"] = "TRUE",
    ["false"] = "FALSE",
    ["noDescription"] = "Aucune description",
    ["other"] = "Autres",
    ["completed"] = "Achevé",
    ["close"] = "Fermer",
    ["main"] = "Main",
    
    ["valueQuery"] = "Que devrait être le %s ?",
    ["dataValueQuery"] = "Qu'est ce que cela devrait être ?",
    ["newNameQuery"] = "Quel devrait être le nouveau nom ?",
    ["newDescriptionQuery"] = "Quelle devrait être la nouvelle description ?",
    ["newModelQuery"] = "Quel devrait être le nouveau modèle ?",
    ["newIconQuery"] = "Que devrait être la nouvelle icône ?",
    ["newColorQuery"] = "Quelle devrait être la nouvelle couleur?",
    ["npcTypeQuery"] = "Quel doit être le type de ce NPC ?",
    ["newTypeQuery"] = "Que devrait être le nouveau type",
    ["groupRequirementQuery"] = "Quelle devrait être les conditions de groupe ?",
    ["levelRequirementQuery"] = "Quelle devrait être les conditions de level ?",
    ["newPriceQuery"] = "Quel devrait être le nouveau prix ?",
    ["newCategoryQuery"] = "Quelle devrait être la nouvelle catégorie ?",

    ["npcEditor"] = "Editeur de NPC",
    ["addNPC"] = "Ajouter un NPC",
    ["newNPC"] = "Nouveau NPC",

    ["ok"] = "OK",
    ["cancel"] = "Annuler",
    ["save"] = "Sauvegarder",
    ["confirm"] = "Confirmer",
    ["nil"] = "NIL",
    ["none"] = "Aucun",
    ["selected"] = "Sélectionné",
    ["unselected"] = "Désélectionnée",
    ["add"] = "Ajouter",

    ["shootyStick"] = "Un bâton qui tire!",
    ["permanent"] = "Permanent",
    ["tierX"] = "(Tier %d)",
    ["someDescription"] = "Une description.",
    ["invalidNPC"] = "ERREUR : NPC invalide",

    ["disconnected"] = "Déconnecté",
    ["profileView"] = "Profil",
    ["loading"] = "Chargement",
    ["statistics"] = "Statistiques",
    ["steamID64"] = "SteamID64",
    ["donationRank"] = "Donation Rank",
    ["staffRank"] = "Staff Rank",
    ["currentJob"] = "Emploi actuel",
    ["wallet"] = "Portefeuille",
    ["level"] = "Level",
    ["levelX"] = "Level %d",
    ["experience"] = "Experience",
    ["exp"] = "EXP",
    ["money"] = "Argent",
    ["playerLogs"] = "Player Logs",
    ["deleteLogs"] = "Delete logs",
    ["xLogs"] = "%d logs",
    ["xAdminGroups"] = "%d Admin Groups",
    ["noUserGroups"] = "No user groups",
    ["userGroups"] = "User groups: %s",
    ["editUserGroups"] = "Modifier les  user groups",
    ["newGroupColor"] = "Quelle devrait être la nouvelle couleur du groupe?",
    ["newGroupName"] = "Quel devrait être le nouveau nom du groupe?",
    ["groupAlreadyExists"] = "Ce groupe existe déjà !",
    ["whitelist"] = "Whitelist",
    ["unWhitelist"] = "UnWhitelist",
    ["addCustom"] = "Add custom",
    ["entClassWhitelist"] = "Quelle classe d'entité souhaitez-vous mettre sur la whitelist ?",
    ["entClassAlreadyOnList"] = "Cette classe d'entités figure déjà sur la liste!",
    ["changesServerRestart"] = "Certains changements ne prendront pas effet tant que le serveur ne sera pas redémarré !",
    ["comingSoon"] = "Coming Soon!",
    ["features"] = "FEATURES",
    ["addNewRarity"] = "Ajouter une nouvelle rareté",
    ["newRarity"] = "Nouvelle rareté",
    ["needToAddRarity"] = "Vous devez d'abord ajouter un type de rareté !",
    ["whatRarityItem"] = "Quelle devrait être la rareté de cet objet ?",
    ["invalidRarity"] = "Rareté invalide.",
    ["rarityAlreadyExists"] = "Une rareté avec ce nom existe déjà!",
    ["themeColorX"] = "Theme - Color %d",
    ["themeTextColor"] = "Theme - Text Color",
    ["presetAccents"] = "Accents prédéfinis",
    ["presetBackgrounds"] = "Arrière-plan prédéfini",
    ["resetToBaseThemes"] = "Rétablir le thème de bases",
    ["resetToCurrentThemes"] = "Rétablir le thèmes actuels",
    ["toggle"] = "Activer",
    ["menu"] = "Menu",
    ["emptyValue"] = "EMPTY VALUE",
    ["newValueQuery"] = "Quelle devrait être la nouvelle valeur ?",
    ["pressKey"] = "APPUYEZ SUR UNE TOUCHE",

    ["entityPlacer"] = "Entity Placer",
    ["invalidEntityType"] = "Type d'entité invalide, choisissez un type d'entité valide dans le menu d'outils.",
    ["entityPlaced"] = "Entité placée avec succès.",
    ["entityRemoved"] = "Entité retirée avec succès.",
    ["canOnlyUseToolEntity"] = "Vous ne pouvez utiliser cet outil que pour supprimer/créer une entité.",
    ["entityType"] = "Type d'entité",
    ["entityPlacerDescription"] = "Place et retire des entités du serveur et enregistre leurs positions. Clic gauche - placer. Clic droit - supprimer.",
    ["entityPlacerDescriptionSmall"] = "Placement et déplacement d'entités",
    ["entityPlacerInstructions"] = "Clic gauche - placer, Clic droit - supprimer.",

    ["npcPlacer"] = "NPC Placer",
    ["npcPlaced"] = "NPC placé avec succès.",
    ["invalidNPCType"] = "Type de NPC invalide, choisissez un NPC valide dans le menu d'outils.",
    ["npcRemoved"] = "Le NPC a été supprimé avec succès.",
    ["errorNotNPC"] = "Vous ne pouvez utiliser cet outil que pour supprimer/créer un NPC.",
    ["npcPlacerDescription"] = "Place et retire les NPCs du serveur , Clic gauche - placer, Clic droit - retirer.",
    ["npcPlacerDescriptionSmall"] = "Placer et retirer des NPCs.",

    ["inventory"] = "Inventaire",
    ["player"] = "Joueur",
    ["drop"] = "Lâcher",
    ["use"] = "Utiliser",
    ["dropAll"] = "Tout lâcher",
    ["delete"] = "Supprimer",
} )
--PATH addons/bricks_gangs/lua/bricks_server/bricks_gangs/sh_clientconfig.lua:
--[[
    !!WARNING!!
        ALL CONFIG IS DONE INGAME, DONT EDIT ANYTHING HERE
        Type !bricksserver ingame or use the f4menu
    !!WARNING!!
]]--

-- Gangs --
if( BRICKS_SERVER.Func.IsModuleEnabled( "gangs" ) ) then
    BRICKS_SERVER.BASECLIENTCONFIG.GangMenuBind = { BRICKS_SERVER.Func.L( "gangMenuBind" ), "bind", 0 }
end
--PATH addons/brick_s_server_framework/lua/bricks_server/itemtypes/spawned_shipment.lua:
local ITEM = BRICKS_SERVER.Func.CreateItemType( "spawned_shipment" )

ITEM.GetItemData = function( ent )
    local itemData = { "spawned_weapon", ent:GetModel(), CustomShipments[ent:Getcontents()].entity }

    if( CustomShipments[ent:Getcontents()] and CustomShipments[ent:Getcontents()].model ) then
        itemData[2] = CustomShipments[ent:Getcontents()].model or ent:GetModel()
    end
    
    return itemData, (ent:Getcount() or 1)
end

ITEM.OnSpawn = function( ply, pos, itemData, itemAmount )
    local ent = ents.Create( "spawned_weapon" )
    if( not IsValid( ent ) ) then return end
    ent:SetPos( pos )
    ent:SetWeaponClass( itemData[3] )
    ent:Setamount( itemAmount or 1 )
    ent:SetModel( itemData[2] )
    ent:Spawn()
end

ITEM.GetInfo = function( itemData )
    return { (itemData[4] or "Unknown"), (itemData[5] or BRICKS_SERVER.Func.L( "someDescription" )), (BRICKS_SERVER.CONFIG.INVENTORY.ItemRarities or {})[itemData[3] or ""] }
end

ITEM:Register()
--PATH addons/brick_s_server_framework/lua/bricks_server/core/client/cl_popups.lua:
function BRICKS_SERVER.Func.Message( text, title, button, buttonFunc )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( text )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.15, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( text, "BRICKS_SERVER_Font20", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local bottomButton = vgui.Create( "DButton", backPanel )
	bottomButton:SetText( "" )
	bottomButton:Dock( BOTTOM )
	bottomButton:DockMargin( 10, 10, 10, 10 )
	bottomButton:SetTall( 40 )
	local changeAlpha = 0
	bottomButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( button, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	bottomButton.DoClick = function()
		if( buttonFunc ) then
			buttonFunc()
		end
		
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	backPanel:SetTall( bottomButton:GetTall()+(4*10)+textArea:GetTall()+backPanel.headerHeight )
	backPanel:Center()
end

function BRICKS_SERVER.Func.Query( text, title, confirmText, cancelText, confirmFunc, cancelFunc )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( text )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.15, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( text, "BRICKS_SERVER_Font20", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local buttonBack = vgui.Create( "DPanel", backPanel )
	buttonBack:Dock( BOTTOM )
	buttonBack:DockMargin( 10, 10, 10, 10 )
	buttonBack:SetTall( 40 )
	buttonBack.Paint = function() end

	local confirmButton = vgui.Create( "DButton", buttonBack )
	confirmButton:SetText( "" )
	confirmButton:Dock( LEFT )
	confirmButton:SetWide( (backPanel:GetWide()-30)/2 )
	local changeAlpha = 0
	confirmButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	confirmButton.DoClick = function()
		if( confirmFunc ) then
			confirmFunc()
		end
		
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	local cancelButton = vgui.Create( "DButton", buttonBack )
	cancelButton:SetText( "" )
	cancelButton:Dock( RIGHT )
	cancelButton:SetWide( (backPanel:GetWide()-30)/2 )
	local changeAlpha = 0
	cancelButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	cancelButton.DoClick = function()
		if( cancelFunc ) then
			cancelFunc()
		end

		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	backPanel:SetTall( buttonBack:GetTall()+(4*10)+textArea:GetTall()+backPanel.headerHeight )
	backPanel:Center()
end

function BRICKS_SERVER.Func.StringRequest( title, subtitle, default, func_confirm, func_cancel, confirmText, cancelText, numberOnly )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( subtitle )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.15, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( subtitle, "BRICKS_SERVER_Font20", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local textEntryBack = vgui.Create( "DPanel", backPanel )
	textEntryBack:Dock( TOP )
	textEntryBack:DockMargin( 10, 10, 10, 0 )
	textEntryBack:SetTall( 40 )
    local Alpha = 0
    local textEntry
    local color1 = BRICKS_SERVER.Func.GetTheme( 1 )
    textEntryBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

        if( textEntry:IsEditing() ) then
            Alpha = math.Clamp( Alpha+5, 0, 100 )
        else
            Alpha = math.Clamp( Alpha-5, 0, 100 )
        end
        
        draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
    end

	if( numberOnly ) then
		textEntry = vgui.Create( "bricks_server_numberwang", textEntryBack )
		textEntry:Dock( FILL )
		textEntry:SetMinMax( 0, 9999999999999 )
	else
		textEntry = vgui.Create( "bricks_server_textentry", textEntryBack )
		textEntry:Dock( FILL )
	end
	textEntry:SetValue( default or "" )

	local buttonPanel = vgui.Create( "DPanel", backPanel )
	buttonPanel:Dock( BOTTOM )
	buttonPanel:DockMargin( 10, 10, 10, 10 )
	buttonPanel:SetTall( 40 )
	buttonPanel.Paint = function( self2, w, h ) end

	local leftButton = vgui.Create( "DButton", buttonPanel )
	leftButton:Dock( LEFT )
	leftButton:SetText( "" )
	leftButton:DockMargin( 0, 0, 0, 0 )
	leftButton:SetWide( (backPanel:GetWide()-30)/2 )
	local changeAlpha = 0
	leftButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	leftButton.DoClick = function()
		func_confirm( textEntry:GetValue() )
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	local rightButton = vgui.Create( "DButton", buttonPanel )
	rightButton:Dock( RIGHT )
	rightButton:SetText( "" )
	rightButton:DockMargin( 0, 0, 0, 0 )
	rightButton:SetWide( (backPanel:GetWide()-30)/2 )
	local changeAlpha = 0
	rightButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	rightButton.DoClick = function()
		func_cancel( textEntry:GetValue() )
		frameBack:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( frameBack ) ) then
				frameBack:Remove()
			end
		end )
	end

	backPanel:SetTall( buttonPanel:GetTall()+(4*10)+textArea:GetTall()+textEntryBack:GetTall()+backPanel.headerHeight )
	backPanel:Center()
end

function BRICKS_SERVER.Func.ComboRequest( title, subtitle, default, options, func_confirm, func_cancel, confirmText, cancelText, searchSelect )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( subtitle )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.15, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( subtitle, "BRICKS_SERVER_Font20", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local comboEntry
	if( not searchSelect ) then
		comboEntry = vgui.Create( "bricks_server_combo", backPanel )
	else
		comboEntry = vgui.Create( "bricks_server_combo_search", backPanel )
	end

	if( not IsValid( comboEntry ) ) then return end

	comboEntry:Dock( TOP )
	comboEntry:DockMargin( 10, 10, 10, 0 )
	comboEntry:SetTall( 40 )
	comboEntry:SetValue( BRICKS_SERVER.Func.L( "selectOption" ) )
	for k, v in pairs( options ) do
		if( default != k and default != v ) then
			comboEntry:AddChoice( v, k, false )
		else
			comboEntry:AddChoice( v, k, true )
		end
	end

	local buttonPanel = vgui.Create( "DPanel", backPanel )
	buttonPanel:Dock( BOTTOM )
	buttonPanel:DockMargin( 10, 10, 10, 10 )
	buttonPanel:SetTall( 40 )
	buttonPanel.Paint = function( self2, w, h ) end

	local leftButton = vgui.Create( "DButton", buttonPanel )
	leftButton:Dock( LEFT )
	leftButton:SetText( "" )
	leftButton:DockMargin( 0, 0, 0, 0 )
	leftButton:SetWide( (backPanel:GetWide()-30)/2 )
	local changeAlpha = 0
	leftButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	leftButton.DoClick = function()
		local value, data = comboEntry:GetSelected()
		if( value and data ) then
			func_confirm( value, data )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		else
			notification.AddLegacy( BRICKS_SERVER.Func.L( "selectValue" ), 1, 3 )
		end
	end

	local rightButton = vgui.Create( "DButton", buttonPanel )
	rightButton:Dock( RIGHT )
	rightButton:SetText( "" )
	rightButton:DockMargin( 0, 0, 0, 0 )
	rightButton:SetWide( (backPanel:GetWide()-30)/2 )
	local changeAlpha = 0
	rightButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	rightButton.DoClick = function()
		local value, data = comboEntry:GetSelected()
		if( value and data ) then
			func_cancel( value, data )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		else
			func_cancel( false, false )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		end
	end

	backPanel:SetTall( buttonPanel:GetTall()+(4*10)+textArea:GetTall()+comboEntry:GetTall()+backPanel.headerHeight )
	backPanel:Center()
end

function BRICKS_SERVER.Func.ColorRequest( title, subtitle, default, func_confirm, func_cancel, confirmText, cancelText )
	local frameBack = vgui.Create( "DFrame" )
	frameBack:SetSize( ScrW(), ScrH() )
	frameBack:Center()
	frameBack:SetTitle( "" )
	frameBack:ShowCloseButton( false )
	frameBack:SetDraggable( false )
	frameBack:MakePopup()
	frameBack:SetAlpha( 0 )
	frameBack:AlphaTo( 255, 0.1, 0 )
	frameBack.Paint = function( self2, w, h ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )

		surface.SetDrawColor( 0, 0, 0, 100 )
		surface.DrawRect( 0, 0, w, h )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( subtitle )

	local backPanel = vgui.Create( "bricks_server_dframepanel", frameBack )
	backPanel:SetHeader( title )
	backPanel:SetWide( math.max( ScrW()*0.17, textX+30 ) )
	backPanel.onCloseFunc = function()
		frameBack:Remove()
	end

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( subtitle, "BRICKS_SERVER_Font20", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local colorEntry = vgui.Create( "DColorMixer", backPanel )
	colorEntry:Dock( TOP )
	colorEntry:DockMargin( 10, 10, 10, 0 )
	colorEntry:SetTall( 150 )
	colorEntry:SetPalette( false )
	colorEntry:SetAlphaBar( false) 
	colorEntry:SetWangs( true )
	colorEntry:SetColor( default or Color( 255, 255, 255 ) )
	local displayColor = colorEntry:GetColor()
	colorEntry.ValueChanged = function()
		displayColor = colorEntry:GetColor()
	end

	local displayColorPanel = vgui.Create( "DPanel", backPanel )
	displayColorPanel:Dock( TOP )
	displayColorPanel:DockMargin( 10, 10, 10, 10 )
	displayColorPanel:SetTall( 20 )
	displayColorPanel.Paint = function( self2, w, h ) 
		draw.RoundedBox( 5, 0, 0, w, h, displayColor )
	end

	local buttonPanel = vgui.Create( "DPanel", backPanel )
	buttonPanel:Dock( BOTTOM )
	buttonPanel:DockMargin( 10, 0, 10, 10 )
	buttonPanel:SetTall( 40 )
	buttonPanel.Paint = function( self2, w, h ) end

	local leftButton = vgui.Create( "DButton", buttonPanel )
	leftButton:Dock( LEFT )
	leftButton:SetText( "" )
	leftButton:DockMargin( 0, 0, 0, 0 )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( confirmText )
	textX = textX+20
	leftButton:SetWide( math.max( (ScrW()/2560)*150, textX ) )
	local changeAlpha = 0
	leftButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	leftButton.DoClick = function()
		local value = colorEntry:GetColor()
		if( value ) then
			func_confirm( value )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		else
			notification.AddLegacy( BRICKS_SERVER.Func.L( "selectColor" ), 1, 3 )
		end
	end

	local rightButton = vgui.Create( "DButton", buttonPanel )
	rightButton:Dock( RIGHT )
	rightButton:SetText( "" )
	rightButton:DockMargin( 0, 0, 0, 0 )
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( cancelText )
	textX = textX+20
	rightButton:SetWide( math.max( (ScrW()/2560)*150, textX ) )
	local changeAlpha = 0
	rightButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	rightButton.DoClick = function()
		local value = colorEntry:GetColor()
		if( value ) then
			func_cancel( value )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		else
			func_cancel( false )
			frameBack:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( frameBack ) ) then
					frameBack:Remove()
				end
			end )
		end
	end

	backPanel:SetTall( buttonPanel:GetTall()+(4*10)+textArea:GetTall()+colorEntry:GetTall()+displayColorPanel:GetTall()+10+backPanel.headerHeight )
	backPanel:Center()
end

function BRICKS_SERVER.Func.PassiveQuery( text, title, time, confirmFunc, cancelFunc )
	local backPanel = vgui.Create( "bricks_server_dframepanel" )
	backPanel:DisableClose()
	backPanel:SetHeader( title )
	backPanel:SetWide( ScrW()*0.1 )

	local textArea = vgui.Create( "DPanel", backPanel )
	textArea:Dock( TOP )
	textArea:DockMargin( 10, 10, 10, 0 )
	textArea:SetTall( 30 )
	textArea.Paint = function( self2, w, h ) 
		draw.SimpleText( text, "BRICKS_SERVER_Font20", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local buttonBack = vgui.Create( "DPanel", backPanel )
	buttonBack:Dock( BOTTOM )
	buttonBack:DockMargin( 10, 10, 10, 10 )
	buttonBack:SetTall( 40 )
	buttonBack.Paint = function() end

	local confirmButton = vgui.Create( "DButton", buttonBack )
	confirmButton:SetText( "" )
	confirmButton:Dock( LEFT )
	confirmButton:SetWide( (backPanel:GetWide()-30)/2 )
	local changeAlpha = 0
	local tickMat = Material( "materials/bricks_server/tick_nofill.png" )
	confirmButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
		surface.SetMaterial( tickMat )
		local size = 24
		surface.DrawTexturedRect( (w/2)-(size/2), (h/2)-(size/2), size, size )
	end
	confirmButton.DoClick = function()
		if( confirmFunc ) then
			confirmFunc()
		end
		
		backPanel:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( backPanel ) ) then
				backPanel:Remove()
			end
		end )
	end

	local cancelButton = vgui.Create( "DButton", buttonBack )
	cancelButton:SetText( "" )
	cancelButton:Dock( RIGHT )
	cancelButton:SetWide( (backPanel:GetWide()-30)/2 )
	local changeAlpha = 0
	local denyMat = Material( "materials/bricks_server/close.png" )
	cancelButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
		surface.SetMaterial( denyMat )
		local size = 24
		surface.DrawTexturedRect( (w/2)-(size/2), (h/2)-(size/2), size, size )
	end
	cancelButton.DoClick = function()
		if( cancelFunc ) then
			cancelFunc()
		end

		backPanel:AlphaTo( 0, 0.1, 0, function()
			if( IsValid( backPanel ) ) then
				backPanel:Remove()
			end
		end )
	end

	backPanel:SetTall( buttonBack:GetTall()+(4*10)+textArea:GetTall()+backPanel.headerHeight )
	backPanel:SetPos( 20, 20 )

	timer.Simple( (time or 5), function()
		if( IsValid( backPanel ) ) then
			if( cancelFunc ) then
				cancelFunc()
			end
			
			backPanel:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( backPanel ) ) then
					backPanel:Remove()
				end
			end )
		end
	end )
end

function BRICKS_SERVER.Func.CreatePopoutQuery( text, parent, panelWide, panelTall, confirmText, cancelText, confirmFunc, cancelFunc, disableBackgroundButton )
	if( IsValid( parent.brs_popout ) ) then
		parent.brs_popout:Remove()
	end

	local popoutClose = vgui.Create( "DButton", parent )
	popoutClose:SetSize( panelWide, panelTall )
	popoutClose:SetAlpha( 0 )
	popoutClose:AlphaTo( 255, 0.2 )
	popoutClose:SetText( "" )
	popoutClose:SetCursor( "arrow" )
	popoutClose.Paint = function( self2, w, h )
		surface.SetDrawColor( 0, 0, 0, 150 )
		surface.DrawRect( 0, 0, w, h )
		BRICKS_SERVER.Func.DrawBlur( self2, 2, 2 )
	end

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( text )

	local popoutWide, popoutTall = math.max( ScrW()*0.15, textX+40 ), 40+(4*10)+30+20

	parent.brs_popout = vgui.Create( "DPanel", parent )
	parent.brs_popout:SetSize( 0, 0 )
	parent.brs_popout:SizeTo( popoutWide, popoutTall, 0.2 )
	parent.brs_popout.Paint = function( self2, w, h )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		draw.SimpleText( text, "BRICKS_SERVER_Font20", w/2, h/3, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	parent.brs_popout.OnSizeChanged = function( self2 )
		self2:SetPos( (panelWide/2)-(self2:GetWide()/2), (panelTall/2)-(self2:GetTall()/2) )
	end
	parent.brs_popout.ClosePopout = function()
		if( IsValid( parent.brs_popout ) ) then
			parent.brs_popout:SizeTo( 0, 0, 0.2, 0, -1, function()
				if( IsValid( parent.brs_popout ) ) then
					parent.brs_popout:Remove()
				end
			end )
		end

		popoutClose:AlphaTo( 0, 0.2, 0, function()
			if( IsValid( popoutClose ) ) then
				popoutClose:Remove()
			end
		end )
	end

	popoutClose.DoClick = function()
		if( disableBackgroundButton ) then return end
		
		if( cancelFunc ) then
			cancelFunc()
		end

		parent.brs_popout.ClosePopout()
	end

	local buttonBack = vgui.Create( "DPanel", parent.brs_popout )
	buttonBack:Dock( BOTTOM )
	buttonBack:DockMargin( 10, 10, 10, 10 )
	buttonBack:SetTall( 40 )
	buttonBack.Paint = function() end

	local confirmButton = vgui.Create( "DButton", buttonBack )
	confirmButton:SetText( "" )
	confirmButton:Dock( LEFT )
	confirmButton:SetWide( (popoutWide-30)/2 )
	local changeAlpha = 0
	confirmButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( confirmText, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	confirmButton.DoClick = function()
		if( confirmFunc ) then
			confirmFunc()
		end
		
		parent.brs_popout.ClosePopout()
	end

	local cancelButton = vgui.Create( "DButton", buttonBack )
	cancelButton:SetText( "" )
	cancelButton:Dock( RIGHT )
	cancelButton:SetWide( (popoutWide-30)/2 )
	local changeAlpha = 0
	cancelButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( cancelText, "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	cancelButton.DoClick = function()
		if( cancelFunc ) then
			cancelFunc()
		end

		parent.brs_popout.ClosePopout()
	end
end

function BRICKS_SERVER.Func.CreateTopNotification( text, time, accentColor )
	if( IsValid( BRS_TOPNOTIFICATION ) ) then
		BRS_TOPNOTIFICATION:Remove()
	end

	if( timer.Exists( "brs_topnotification_remove" ) ) then
		timer.Remove( "brs_topnotification_remove" )
	end

	surface.PlaySound( "ui/buttonclick.wav" )

	surface.SetFont( "BRICKS_SERVER_Font20" )
	local textX, textY = surface.GetTextSize( text )

	local popoutWide, popoutTall = math.max( ScrW()*0.15, textX+40 ), 40

	BRS_TOPNOTIFICATION = vgui.Create( "DPanel" )
	BRS_TOPNOTIFICATION:SetSize( 0, popoutTall )
	BRS_TOPNOTIFICATION:SizeTo( popoutWide, popoutTall, 0.2 )
	BRS_TOPNOTIFICATION.Paint = function( self2, w, h )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

		BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, 0, 0, 5, h, (accentColor or BRICKS_SERVER.Func.GetTheme( 5 )), 10, h )
		BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, w-5, 0, 5, h, (accentColor or BRICKS_SERVER.Func.GetTheme( 5 )), 10, h, w-10 )

		draw.SimpleText( text, "BRICKS_SERVER_Font20", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	BRS_TOPNOTIFICATION.OnSizeChanged = function( self2 )
		self2:SetPos( (ScrW()/2)-(self2:GetWide()/2), 100 )
	end
	BRS_TOPNOTIFICATION.ClosePopout = function()
		if( IsValid( BRS_TOPNOTIFICATION ) ) then
			BRS_TOPNOTIFICATION:SizeTo( 0, popoutTall, 0.2, 0, -1, function()
				if( IsValid( BRS_TOPNOTIFICATION ) ) then
					BRS_TOPNOTIFICATION:Remove()
				end
			end )
		end
	end

	timer.Create( "brs_topnotification_remove", (time or 3), 1, function()
		if( IsValid( BRS_TOPNOTIFICATION ) ) then
			BRS_TOPNOTIFICATION.ClosePopout()
		end
	end )
end

function BRICKS_SERVER.Func.CreatePopoutPanel( parent, panelWide, panelTall, popoutWide, popoutTall )
	if( IsValid( parent.brs_popout ) ) then
		parent.brs_popout:Remove()
	end

	local popoutClose = vgui.Create( "DButton", parent )
	popoutClose:SetSize( panelWide, panelTall )
	popoutClose:SetAlpha( 0 )
	popoutClose:AlphaTo( 255, 0.2 )
	popoutClose:SetText( "" )
	popoutClose:SetCursor( "arrow" )
	popoutClose.Paint = function( self2, w, h )
		surface.SetDrawColor( 0, 0, 0, 150 )
		surface.DrawRect( 0, 0, w, h )
		BRICKS_SERVER.Func.DrawBlur( self2, 2, 2 )
	end

	parent.brs_popout = vgui.Create( "DPanel", parent )
	parent.brs_popout:SetSize( 0, 0 )
	parent.brs_popout:SizeTo( popoutWide, popoutTall, 0.2 )
	parent.brs_popout.SetColor = function( self2, color )
		self2.backColor = color
	end
	parent.brs_popout.Paint = function( self2, w, h )
		draw.RoundedBox( 5, 0, 0, w, h, (self2.backColor or BRICKS_SERVER.Func.GetTheme( 2 )) )
	end
	parent.brs_popout.OnSizeChanged = function( self2 )
		self2:SetPos( (panelWide/2)-(self2:GetWide()/2), (panelTall/2)-(self2:GetTall()/2) )
	end
	parent.brs_popout.ClosePopout = function()
		if( IsValid( parent.brs_popout ) ) then
			parent.brs_popout:SizeTo( 0, 0, 0.2, 0, -1, function()
				if( IsValid( parent.brs_popout ) ) then
					parent.brs_popout:Remove()
				end
			end )
		end

		popoutClose:AlphaTo( 0, 0.2, 0, function()
			if( IsValid( popoutClose ) ) then
				popoutClose:Remove()
			end
		end )
	end

	popoutClose.DoClick = function()
		parent.brs_popout.ClosePopout()
	end

	return parent.brs_popout
end

function BRICKS_SERVER.Func.CreatePopoutConfigPanel( parent, panelWide, panelTall, popoutWide, popoutTall, confirmFunc, cancelFunc )
	local popoutPanel = BRICKS_SERVER.Func.CreatePopoutPanel( parent, panelWide, panelTall, popoutWide, popoutTall )

	local buttonBack = vgui.Create( "DPanel", popoutPanel )
	buttonBack:Dock( BOTTOM )
	buttonBack:DockMargin( 10, 10, 10, 10 )
	buttonBack:SetTall( 40 )
	buttonBack.Paint = function() end

	local saveButton = vgui.Create( "DButton", buttonBack )
	saveButton:SetText( "" )
	saveButton:Dock( LEFT )
	saveButton:SetWide( (popoutWide-30)/2 )
	local changeAlpha = 0
	saveButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( "Save", "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	saveButton.DoClick = function()
		if( confirmFunc ) then
			confirmFunc()
		end
		
		popoutPanel.ClosePopout()
	end

	local cancelButton = vgui.Create( "DButton", buttonBack )
	cancelButton:SetText( "" )
	cancelButton:Dock( RIGHT )
	cancelButton:SetWide( (popoutWide-30)/2 )
	local changeAlpha = 0
	cancelButton.Paint = function( self2, w, h )
		if( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end
		
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed )
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( "Cancel", "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	cancelButton.DoClick = function()
		if( cancelFunc ) then
			cancelFunc()
		end

		popoutPanel.ClosePopout()
	end

	return popoutPanel
end
--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_circle_avatar.lua:
local PANEL = {}

function PANEL:Init()
	self.avatar = vgui.Create( "AvatarImage", self )
	self.avatar:SetPaintedManually( true )
end

function PANEL:PerformLayout()
	self.avatar:SetSize( self:GetWide(), self:GetTall() )
end

function PANEL:SetPlayer( ply, size )
	self.avatar:SetPlayer( ply, size )
end

function PANEL:SetSteamID( steamID, size )
	self.avatar:SetSteamID( steamID, size )
end

function PANEL:Paint( w, h )
	render.ClearStencil()
	render.SetStencilEnable( true )

	render.SetStencilWriteMask( 1 )
	render.SetStencilTestMask( 1 )

	render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
	render.SetStencilPassOperation( STENCILOPERATION_ZERO )
	render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
	render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )
	render.SetStencilReferenceValue( 1 )

	draw.NoTexture()
	surface.SetDrawColor( Color( 0, 0, 0, 255 ) )
    BRICKS_SERVER.Func.DrawCircle( w/2, h/2, h/2, w/2 )

	render.SetStencilFailOperation( STENCILOPERATION_ZERO )
	render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
	render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
	render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
	render.SetStencilReferenceValue( 1 )

	self.avatar:PaintManual()

	render.SetStencilEnable( false )
	render.ClearStencil()
end
 
vgui.Register( "bricks_server_circle_avatar", PANEL )
--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_colsheet_top.lua:

local PANEL = {}

AccessorFunc( PANEL, "ActiveButton", "ActiveButton" )

function PANEL:Init()
	self.navigationBack = vgui.Create( "DPanel", self )
	self.navigationBack:Dock( TOP )
	self.navigationBack:SetTall( 50 )
	self.navigationBack:DockMargin( 0, 0, 0, 5 )
	local NavWidth = (ScrW()*0.6)-BRICKS_SERVER.DEVCONFIG.MainNavWidth-20
	self.navigationBack.Paint = function( self2, w, h )
		if( self.rounded ) then
			draw.RoundedBox( 5, 0, 0, w, h, (self.navColor or BRICKS_SERVER.Func.GetTheme( 3 )) )
		else
			surface.SetDrawColor( self.navColor or BRICKS_SERVER.Func.GetTheme( 3 ) )
			surface.DrawRect( 0, 0, w, h )
		end
	end

	local moveDist = 100
	
	self.Navigation = vgui.Create( "DPanel", self.navigationBack )
	self.Navigation:SetPos( 0, 0 )
	self.Navigation:SetSize( 0, self.navigationBack:GetTall() )
	self.Navigation.Paint = function( self2, w, h ) end

	function self.Navigation.UpdateWide()
		self.Navigation:SetWide( math.Clamp( self.buttonsWide, 0, NavWidth-25+(self.Navigation.leftMargin or 0) ) )
		if( self.buttonsWide > NavWidth+10 ) then
			if( not IsValid( self.Navigation.rightButton ) ) then
				self.Navigation.rightButton = vgui.Create( "DButton", self.navigationBack )
				self.Navigation.rightButton:SetSize( 25, self.navigationBack:GetTall() )
				self.Navigation.rightButton:SetPos( NavWidth-self.Navigation.rightButton:GetWide(), 0 )
				self.Navigation.rightButton:SetText( "" )
				local changeAlpha = 0
				self.Navigation.rightButton.Paint = function( self2, w, h )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, true, false, true )

					if( self2:IsHovered() or self2.m_bSelected ) then
						changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
					else
						changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
					end
			
					surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), false, true, false, true )
					surface.SetAlphaMultiplier( 1 )
			
					draw.SimpleText( ">", "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
				self.Navigation.rightButton.DoClick = function()
					if( (NavWidth-50)+(self.Navigation.leftMargin or 0) >= self.buttonsWide ) then return end
					self.Navigation.leftMargin = math.Clamp( (self.Navigation.leftMargin or 0)+moveDist, 0, self.buttonsWide-(NavWidth-25) )
					self.Navigation:SetPos( -self.Navigation.leftMargin, 0 )
					self.Navigation.UpdateWide()
				end
			end

			if( (self.Navigation.leftMargin or 0) > 0 and not IsValid( self.Navigation.leftButton ) ) then
				self.Navigation.leftButton = vgui.Create( "DButton", self.navigationBack )
				self.Navigation.leftButton:SetSize( 25, self.navigationBack:GetTall() )
				self.Navigation.leftButton:SetPos( 0, 0 )
				self.Navigation.leftButton:SetText( "" )
				local changeAlpha = 0
				self.Navigation.leftButton.Paint = function( self2, w, h )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), true, false, true, false )

					if( self2:IsHovered() or self2.m_bSelected ) then
						changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
					else
						changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
					end
			
					surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), true, false, true, false )
					surface.SetAlphaMultiplier( 1 )
			
					draw.SimpleText( "<", "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
				self.Navigation.leftButton.DoClick = function()
					self.Navigation.leftMargin = math.Clamp( (self.Navigation.leftMargin or 0)-moveDist, 0, self.buttonsWide-(NavWidth-25) )
					self.Navigation:SetPos( -self.Navigation.leftMargin, 0 )
					self.Navigation.UpdateWide()
				end
			elseif( (self.Navigation.leftMargin or 0) <= 0 and IsValid( self.Navigation.leftButton ) ) then
				self.Navigation.leftButton:Remove()
			end
		end
	end

	self.Content = vgui.Create( "Panel", self )
	self.Content:Dock( FILL )

	self.Items = {}
end

function PANEL:UseButtonOnlyStyle()
	self.ButtonOnly = true
end

function PANEL:AddSheet( label, panel, makeActive, onLoad )

	if ( !IsValid( panel ) ) then return end

	local Sheet = {}
	Sheet.Button = vgui.Create( "DButton", self.Navigation )
	Sheet.Button.Target = panel
	Sheet.Button:Dock( LEFT )
	Sheet.Button:DockMargin( 0, 0, 0, 0 )
	Sheet.Button:SetText( "" )
	Sheet.Button.label = label
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( label )
	Sheet.Button:SetWide( textX+30 )
	self.buttonsWide = (self.buttonsWide or 0)+(textX+30)
	self.Navigation.UpdateWide()
	local changeAlpha = 0
	local ButX, ButY = false, false
	local first = false
	if( #self.Items <= 0 ) then
		first = true
	end
	Sheet.Button.Paint = function( self2, w, h )
		if( not ButX or not ButY ) then
			ButX, ButY = self2:LocalToScreen( 0, 0 )
		end

		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		if( not first or not self.rounded ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.DrawRect( 0, h-2, w, 2 )
		else
			BRICKS_SERVER.Func.DrawPartialRoundedBoxEx( 5, 0, h-2, w, 2, BRICKS_SERVER.Func.GetTheme( 5 ), w, 10, 0, h-10, false, false, true, false )
		end
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( label, "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	Sheet.Button.DoClick = function()
		self:SetActiveButton( Sheet.Button )
	end

	if( onLoad ) then
		Sheet.Button.onLoad = onLoad() 
	end

	Sheet.Button.label = label

	Sheet.Panel = panel
	Sheet.Panel:SetParent( self.Content )
	Sheet.Panel:SetVisible( false )

	if ( self.ButtonOnly ) then
		Sheet.Button:SizeToContents()
	end

	table.insert( self.Items, Sheet )

	if ( !IsValid( self.ActiveButton ) ) then
		self:SetActiveButton( Sheet.Button, true )
	elseif( makeActive ) then
		self:SetActiveButton( Sheet.Button )
	end
	
	return Sheet
end

function PANEL:AddButton( label, func )
	local sheetButton = vgui.Create( "DButton", self.Navigation )
	sheetButton:Dock( LEFT )
	sheetButton:DockMargin( 0, 0, 0, 0 )
	sheetButton:SetText( "" )
	sheetButton.label = label
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( label )
	sheetButton:SetWide( textX+30 )
	self.buttonsWide = (self.buttonsWide or 0)+(textX+30)
	self.Navigation.UpdateWide()
	local changeAlpha = 0
	local ButX, ButY = false, false
	local first = false
	if( #self.Items <= 0 ) then
		first = true
	end
	sheetButton.Paint = function( self2, w, h )
		if( not ButX or not ButY ) then
			ButX, ButY = self2:LocalToScreen( 0, 0 )
		end

		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		if( not first or not self.rounded ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.DrawRect( 0, h-2, w, 2 )
		else
			draw.RoundedBoxEx( 5, 0, h-20, w, 20, BRICKS_SERVER.Func.GetTheme( 5 ), false, false, true, false )
		end
		surface.SetAlphaMultiplier( 1 )

		if( first ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
			surface.DrawRect( 0, h-20, w, 18 )
		end

		draw.SimpleText( label, "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	sheetButton.DoClick = func
	
	return sheetButton
end

function PANEL:Think()
	for k, v in pairs( self.Items ) do
		if( v.Think ) then
			v.Think()
		end
	end
end

function PANEL:SetActiveButton( active, first )

	if ( self.ActiveButton == active ) then return end

	if ( self.ActiveButton && self.ActiveButton.Target ) then
		self.ActiveButton.Target:SetVisible( false )
		self.ActiveButton:SetSelected( false )
		self.ActiveButton:SetToggle( false )
	end

	self.ActiveButton = active
	active.Target:SetVisible( true )
	active:SetSelected( true )
	active:SetToggle( true )

	if( active.onLoad ) then
		active.onLoad()
	end

	self.Content:InvalidateLayout()

	if( not first and self.pageClickFunc ) then
		self.pageClickFunc( active.label )
	end
end

function PANEL:SetActiveSheet( sheetLabel )
	if( not sheetLabel ) then return end

	for k, v in pairs( self.Items ) do
		if( v.Button and v.Button.label and v.Button.label == sheetLabel ) then
			self:SetActiveButton( v.Button )
			break
		end
	end
end

function PANEL:ClearSheets()
	self.buttonsWide = 0
	self.Items = {}
	self.Navigation:Clear()
	self.Content:Clear()
end

derma.DefineControl( "bricks_server_colsheet_top", "", PANEL, "Panel" )

--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_config.lua:
local PANEL = {}

function PANEL:Init()
    hook.Add( "BRS.Hooks.ConfigReceived", self, function()
        if( IsValid( self ) and self.loadedPreviously ) then
            self:FillPanel()
        else
            hook.Remove( "BRS.Hooks.ConfigReceived", self )
        end
    end )
end

function PANEL:FillPanel()
    self.loadedPreviously = true
    self:Clear()

    self.colSheet = vgui.Create( "bricks_server_colsheet_left", self )
    self.colSheet:Dock( FILL )
    self.colSheet.OnNavCollapse = function( name, collapsed )
        BRICKS_SERVER.Func.SetClientCookie( name, "bool", collapsed )
    end
    self.colSheet.OnSheetChange = function( name )
        BRICKS_SERVER.Func.SetClientCookie( "configpage", "string", name )
    end

    self.colSheet:CreateSearchBar()

    BS_ConfigCopyTable = table.Copy( BRICKS_SERVER.CONFIG )
    BS_ConfigsChanged = {}

    local sortedConfig = table.Copy( BRICKS_SERVER.ConfigPages )

    table.SortByMember( sortedConfig, 1, true )

    for k, v in pairs( sortedConfig ) do
        if( v[4] and not v[4]() ) then continue end

        local addonTable = BRICKS_SERVER.DLCMODULES[v[3] or ""] or {}

        local adminConfigPage = vgui.Create( v[2], self.colSheet )
        if( not IsValid( adminConfigPage ) ) then continue end
        adminConfigPage:Dock( FILL )
        adminConfigPage:DockMargin( (adminConfigPage.margin or 10), (adminConfigPage.margin or 10), (adminConfigPage.margin or 10), (adminConfigPage.margin or 10) )
        if( adminConfigPage.FillPanel ) then
            self.colSheet:AddSheet( v[1], adminConfigPage, false, function() 
                adminConfigPage:FillPanel()
            end, addonTable.Name, addonTable.Color )

            hook.Add( "BRS.Hooks.RefreshConfig", "BRS.Hooks.RefreshConfig." .. tostring( adminConfigPage ), function()
                if( IsValid( adminConfigPage ) and adminConfigPage.RefreshPanel ) then
                    adminConfigPage.RefreshPanel()
                end
            end )
        else
            self.colSheet:AddSheet( v[1], adminConfigPage, false, false, addonTable.Name, addonTable.Color )
        end
    end

    self.colSheet:FinishAddingSheets()

    for k, v in pairs( self.colSheet.Categories ) do
        if( BRICKS_SERVER.Func.GetClientCookie( v:GetLabel(), "bool" ) ) then
            v:SetExpanded( false )
        end
    end

    self.colSheet:SetActiveSheet( BRICKS_SERVER.Func.GetClientCookie( "configpage", "string" ) )
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config", PANEL, "bricks_server_colsheet_left" )
--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_config_groups.lua:
local PANEL = {}

function PANEL:Init()
    self.margin = 0
end

function PANEL:FillPanel()
    self.panelWide, self.panelTall = ScrW()*0.6-BRICKS_SERVER.DEVCONFIG.MainNavWidth, ScrH()*0.65-40

    self.topBar = vgui.Create( "DPanel", self )
    self.topBar:Dock( TOP )
    self.topBar:SetTall( 60 )
    self.topBar.Paint = function( self, w, h ) 
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.DrawRect( 0, 0, w, h )
    end 

    surface.SetFont( "BRICKS_SERVER_Font20" )
    local textX, textY = surface.GetTextSize( "Create Group" )
    local totalContentW = 16+5+textX

    local createNewButton = vgui.Create( "DButton", self.topBar )
    createNewButton:Dock( RIGHT )
    createNewButton:DockMargin( 10, 10, 25, 10 )
    createNewButton:SetWide( totalContentW+27 )
    createNewButton:SetText( "" )
    local alpha = 0
    local addMat = Material( "bricks_server/add_16.png" )
    createNewButton.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

        if( not self2:IsDown() and self2:IsHovered() ) then
            alpha = math.Clamp( alpha+10, 0, 255 )
        else
            alpha = math.Clamp( alpha-10, 0, 255 )
        end

        surface.SetAlphaMultiplier( alpha/255 )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
        surface.SetAlphaMultiplier( 1 )

        BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 20+(235*(alpha/255)) ) )
        surface.SetMaterial( addMat )
        local iconSize = 16
        surface.DrawTexturedRect( 12, (h/2)-(iconSize/2), iconSize, iconSize )

        draw.SimpleText( "Create Group", "BRICKS_SERVER_Font20", 12+iconSize+5, h/2, BRICKS_SERVER.Func.GetTheme( 6, 20+(235*(alpha/255)) ), 0, TEXT_ALIGN_CENTER )
    end
    createNewButton.DoClick = function()
        BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newGroupName" ), BRICKS_SERVER.Func.L( "groupName" ), function( text ) 
            for key, val in pairs( (BS_ConfigCopyTable or BRICKS_SERVER.CONFIG).GENERAL.Groups ) do
                if( val[1] == text ) then
                    BRICKS_SERVER.Func.CreateTopNotification( BRICKS_SERVER.Func.L( "groupAlreadyExists" ), 3, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
                    return
                end
            end
            
            table.insert( BS_ConfigCopyTable.GENERAL.Groups, { text, {} } )
            self:Refresh()
            BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
        end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
    end

    self.searchBar = vgui.Create( "bricks_server_searchbar", self.topBar )
    self.searchBar:Dock( LEFT )
    self.searchBar:DockMargin( 25, 10, 10, 10 )
    self.searchBar:SetWide( ScrW()*0.2 )
    self.searchBar:SetBackColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
    self.searchBar:SetHighlightColor( BRICKS_SERVER.Func.GetTheme( 0 ) )
    self.searchBar.OnChange = function()
        self:Refresh()
    end

    self.scrollPanel = vgui.Create( "bricks_server_scrollpanel_bar", self )
    self.scrollPanel:Dock( FILL )
    self.scrollPanel:DockMargin( 25, 25, 25, 25 )
    self.scrollPanel.Paint = function( self, w, h ) end 

    local slotsWide = 3
    self.spacing = 10
    local gridWide = self.panelWide-50-10-self.spacing
    self.slotWide, self.slotTall = (gridWide-((slotsWide-1)*self.spacing))/slotsWide, 60+10+40+10+60

    self.slotPanels = {}
    for i = 1, slotsWide do
        self.slotPanels[i] = vgui.Create( "DPanel", self.scrollPanel )
        self.slotPanels[i]:SetPos( ((i-1)*(self.slotWide+self.spacing)), 0 )
        self.slotPanels[i]:SetSize( self.slotWide, 0 )
        self.slotPanels[i].slotCount = 0
        self.slotPanels[i].Paint = function() end
    end

    self:Refresh()
end

function PANEL:Refresh()
    local removeMat = Material( "materials/bricks_server/delete.png" )
    local editMat = Material( "materials/bricks_server/edit.png" )
    local upMat = Material( "materials/bricks_server/up.png" )
    local downMat = Material( "materials/bricks_server/down.png" )

    for k, v in ipairs( self.slotPanels ) do
        v:Clear()
        v:SetTall( 0 )
        v.slotCount = 0
    end

    for k, v in ipairs( BS_ConfigCopyTable.GENERAL.Groups ) do
        if( self.searchBar:GetValue() != "" and not string.find( string.lower( v[1] ), string.lower( self.searchBar:GetValue() ) ) ) then
            continue
        end

        local slotParent = self.slotPanels[1]
        for key, val in ipairs( self.slotPanels ) do
            if( val.slotCount < slotParent.slotCount ) then
                slotParent = val
                break
            end
        end

        slotParent.slotCount = slotParent.slotCount+1
        slotParent.targetHeight = slotParent:GetTall()+self.slotTall+(slotParent.slotCount == 1 and 0 or self.spacing)
        slotParent:SetTall( slotParent.targetHeight )

        surface.SetFont( "BRICKS_SERVER_Font25" )
        local headerX, headerY = surface.GetTextSize( v[1] )

        local groupCount = table.Count( v[2] )
        surface.SetFont( "BRICKS_SERVER_Font17" )
        local groupX, groupY = surface.GetTextSize( groupCount .. " User Group" .. (groupCount != 1 and "s" or "") )

        local contentH = headerY+groupY-10

        local topH = 60
        local groupBack = vgui.Create( "DPanel", slotParent )
        groupBack:Dock( TOP )
        groupBack:DockMargin( 0, 0, 0, self.spacing )
        groupBack:DockPadding( 0, topH, 0, 0 )
        groupBack:SetTall( self.slotTall )
        groupBack.targetHeight = self.slotTall
        groupBack.Paint = function( self2, w, h )
            draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

            draw.RoundedBoxEx( 8, 0, 0, w, topH, BRICKS_SERVER.Func.GetTheme( 3 ), true, true, false, false )
            draw.RoundedBoxEx( 8, 0, 0, w, topH, BRICKS_SERVER.Func.GetTheme( 1, 75 ), true, true, false, false )

            draw.SimpleText( v[1] .. " - " .. k, "BRICKS_SERVER_Font25", w/2, (topH/2)-(contentH/2)-4, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
            draw.SimpleText( groupCount .. " User Group" .. (groupCount != 1 and "s" or ""), "BRICKS_SERVER_Font17", w/2, (topH/2)+(contentH/2), BRICKS_SERVER.Func.GetTheme( 6, 75 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
        end

        local actionBack = vgui.Create( "DPanel", groupBack )
        actionBack:Dock( TOP )
        actionBack:DockMargin( 10, 10, 10, 0 )
        actionBack:SetTall( 40 )
        actionBack:DockPadding( 0, 0, 10, 0 )
        actionBack.Paint = function( self2, w, h ) end
        actionBack.AddButton = function( self2, material, func )
            local button = vgui.Create( "DButton", self2 )
            button:Dock( LEFT )
            button:SetWide( self2:GetTall() )
            button:DockMargin( 0, 0, 5, 0 )
            button:SetText( "" )
            local alpha = 0
            local x, y = 0, 0
            button.Paint = function( self3, w, h )
                local toScreenX, toScreenY = self3:LocalToScreen( 0, 0 )
                if( x != toScreenX or y != toScreenY ) then
                    x, y = toScreenX, toScreenY
                end
        
                if( self3:IsHovered() ) then
                    alpha = math.Clamp( alpha+10, 0, 105 )
                else
                    alpha = math.Clamp( alpha-10, 0, 105 )
                end
        
                draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
                draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, 150+alpha ) )
        
                surface.SetMaterial( material )
                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6, 150+alpha ) )
                local iconSize = 24
                surface.DrawTexturedRect( (w/2)-(iconSize/2), (h/2)-(iconSize/2), iconSize, iconSize )
            end
            button.DoClick = function()
                func( x, y, button:GetWide(), button:GetWide() )
            end
        end

        actionBack:AddButton( removeMat, function( x, y, w, h )
            table.remove( BS_ConfigCopyTable.GENERAL.Groups, k )
            self:Refresh()
            BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
        end )
        actionBack:AddButton( editMat, function( x, y, w, h )
            actionBack.Menu = vgui.Create( "bricks_server_dmenu" )
            actionBack.Menu:AddOption( BRICKS_SERVER.Func.L( "editUserGroups" ), function()
                BRICKS_SERVER.Func.CreateGroupEditor( (v[2] or {}), function( userGroups ) 
                    BS_ConfigCopyTable.GENERAL.Groups[k][2] = userGroups or {}
                    self:Refresh()
                    BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                end, function() end, true )
            end )
            actionBack.Menu:AddOption( BRICKS_SERVER.Func.L( "editColor" ), function()
                BRICKS_SERVER.Func.ColorRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newGroupColor" ), (v[3] or BRICKS_SERVER.Func.GetTheme( 5 )), function( color ) 
                    BS_ConfigCopyTable.GENERAL.Groups[k][3] = color or BRICKS_SERVER.Func.GetTheme( 5 )
                    self:Refresh()
                    BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
            end )
            actionBack.Menu:AddOption( BRICKS_SERVER.Func.L( "editName" ), function()
                BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newGroupName" ), (v[1] or "GroupName"), function( text ) 
                    for key, val in pairs( BS_ConfigCopyTable.GENERAL.Groups ) do
                        if( val[1] == text ) then
                            notification.AddLegacy( BRICKS_SERVER.Func.L( "groupAlreadyExists" ), 1, 5 )
                            return
                        end
                    end
                    
                    BS_ConfigCopyTable.GENERAL.Groups[k][1] = text
                    self:Refresh()
                    BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
            end )
            actionBack.Menu:Open()
            actionBack.Menu:SetPos( x+w+5, y+(h/2)-(actionBack.Menu:GetTall()/2) )
        end )
        actionBack:AddButton( downMat, function( x, y, w, h )
            if( k+1 <= #BS_ConfigCopyTable.GENERAL.Groups ) then
                if( BS_ConfigCopyTable.GENERAL.Groups[k+1] ) then
                    BS_ConfigCopyTable.GENERAL.Groups[k] = BS_ConfigCopyTable.GENERAL.Groups[k+1]
                end

                BS_ConfigCopyTable.GENERAL.Groups[k+1] = v
                self:Refresh()
                BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
            end
        end )
        actionBack:AddButton( upMat, function( x, y, w, h )
            if( k-1 >= 1 ) then
                if( BS_ConfigCopyTable.GENERAL.Groups[k-1] ) then
                    BS_ConfigCopyTable.GENERAL.Groups[k] = BS_ConfigCopyTable.GENERAL.Groups[k-1]
                end

                BS_ConfigCopyTable.GENERAL.Groups[k-1] = v
                self:Refresh()
                BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
            end
        end )

        local rarityBox = vgui.Create( "bricks_server_raritybox", groupBack )
        rarityBox:SetSize( self.slotWide, 10 )
        rarityBox:Dock( BOTTOM )
        rarityBox:SetRarityInfo( (istable( v[3] ) and v[3][1] == "") and v[3] or { "", "SolidColor", (v[3] or BRICKS_SERVER.Func.GetTheme( 5 )) } )
        rarityBox:SetCornerRadius( 8 )
        rarityBox:SetRoundedBoxDimensions( false, -10, false, 20 )

        local userGroupsBack = vgui.Create( "DPanel", groupBack )
        userGroupsBack:Dock( TOP )
        userGroupsBack:DockMargin( 10, 10, 10, 10 )
        userGroupsBack:SetTall( 40 )
        userGroupsBack.Paint = function( self2, w, h ) 
            draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
        end

        userGroupsBack.expandButton = vgui.Create( "DButton", userGroupsBack )
        userGroupsBack.expandButton:Dock( TOP )
        userGroupsBack.expandButton:SetTall( userGroupsBack:GetTall() )
        userGroupsBack.expandButton:SetText( "" )
        local alpha = 0
        local arrow = Material( "bricks_server/down_16.png" )
        userGroupsBack.expandButton.textureRotation = -90
        userGroupsBack.expandButton.Paint = function( self2, w, h )
            local expanded = userGroupsBack:GetTall() > 40

            if( expanded ) then
                alpha = math.Clamp( alpha+5, 0, 75 )
            elseif( not self2:IsDown() and self2:IsHovered() ) then
                alpha = math.Clamp( alpha+5, 0, 100 )
            else
                alpha = math.Clamp( alpha-5, 0, 100 )
            end

            draw.RoundedBoxEx( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3, 150 ), true, true, not expanded, not expanded )

            surface.SetAlphaMultiplier( alpha/255 )
            draw.RoundedBoxEx( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), true, true, not expanded, not expanded )
            surface.SetAlphaMultiplier( 1 )

            draw.SimpleText( "Edit User Groups", "BRICKS_SERVER_Font20", w/2, h/2-1, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
            surface.SetMaterial( arrow )
            local iconSize = 16
            surface.DrawTexturedRectRotated( w-((h-iconSize)/2)-(iconSize/2), h/2, iconSize, iconSize, math.Clamp( (self2.textureRotation or 0), -90, 0 ) )
        end
        userGroupsBack.expandButton.DoAnim = function( expanding )
            local anim = userGroupsBack.expandButton:NewAnimation( 0.2, 0, -1 )
        
            anim.Think = function( anim, pnl, fraction )
                if( expanding ) then
                    userGroupsBack.expandButton.textureRotation = (1-fraction)*-90
                else
                    userGroupsBack.expandButton.textureRotation = fraction*-90
                end
            end
        end
        userGroupsBack.expandButton.DoClick = function()
            userGroupsBack.Expanded = not userGroupsBack.Expanded

            if( userGroupsBack.Expanded ) then
                groupBack.targetHeight = groupBack.targetHeight+userGroupsBack.expandedExtraH
                slotParent.targetHeight = slotParent.targetHeight+userGroupsBack.expandedExtraH
                userGroupsBack:SizeTo( self.slotWide-20, 40+userGroupsBack.expandedExtraH, 0.2 )
                userGroupsBack.expandButton.DoAnim( true )
            else
                groupBack.targetHeight = groupBack.targetHeight-userGroupsBack.expandedExtraH
                slotParent.targetHeight = slotParent.targetHeight-userGroupsBack.expandedExtraH
                userGroupsBack:SizeTo( self.slotWide-20, 40, 0.2 )
                userGroupsBack.expandButton.DoAnim( false )
            end

            groupBack:SizeTo( self.slotWide, groupBack.targetHeight, 0.2 )
            slotParent:SizeTo( self.slotWide, slotParent.targetHeight, 0.2 )
        end

        userGroupsBack.searchBar = vgui.Create( "DPanel", userGroupsBack )
        userGroupsBack.searchBar:Dock( TOP )
        userGroupsBack.searchBar:SetTall( 30 )
        local search = Material( "materials/bricks_server/search_16.png" )
        local alpha = 0
        userGroupsBack.searchBar.Paint = function( self2, w, h )
            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3, 100 ) )
            surface.DrawRect( 0, 0, w, h )
    
            if( self2.entry:IsEditing() ) then
                alpha = math.Clamp( alpha+5, 0, 100 )
            else
                alpha = math.Clamp( alpha-5, 0, 100 )
            end
            
            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2, alpha ) )
            surface.DrawRect( 0, 0, w, h )
        
            surface.SetDrawColor( 255, 255, 255, 20+((alpha/100)*255) )
            surface.SetMaterial( search )
            local size = 16
            surface.DrawTexturedRect( w-size-(h-size)/2, (h-size)/2, size, size )
        end
    
        userGroupsBack.searchBar.entry = vgui.Create( "bricks_server_search", userGroupsBack.searchBar )
        userGroupsBack.searchBar.entry:Dock( FILL )
        userGroupsBack.searchBar.entry:SetFont( "BRICKS_SERVER_Font20" )
        userGroupsBack.searchBar.entry.OnChange = function()
            userGroupsBack.list.RefreshEntries()
        end

        local userGroupTall, userGroupSpacing = 25, 10
        userGroupsBack.list = vgui.Create( "DPanel", userGroupsBack )
        userGroupsBack.list:Dock( TOP )
        userGroupsBack.list:SetTall( 0 )
        userGroupsBack.list:DockMargin( 0, userGroupSpacing, 0, userGroupSpacing )
        userGroupsBack.list.Paint = function( self2, w, h ) end
        userGroupsBack.list.RefreshEntries = function()
            userGroupsBack.list:Clear()
            userGroupsBack.list:SetTall( 0 )

            local possibleUserGroups = BRICKS_SERVER.Func.GetAdminSystemRanks()
            for key, val in pairs( v[2] ) do
                if( not possibleUserGroups[key] ) then
                    BS_ConfigCopyTable.GENERAL.Groups[k][2][key] = nil
                end
            end

            for key, val in pairs( possibleUserGroups ) do
                if( userGroupsBack.searchBar.entry:GetValue() != "" and not string.find( string.lower( val ), string.lower( userGroupsBack.searchBar.entry:GetValue() ) ) ) then
                    continue
                end

                local userGroupEntry = vgui.Create( "DPanel", userGroupsBack.list )
                userGroupEntry:Dock( TOP )
                userGroupEntry:DockMargin( 20, 0, 20, userGroupSpacing )
                userGroupEntry:SetTall( userGroupTall )
                userGroupEntry.Paint = function( self2, w, h )
                    draw.SimpleText( val, "BRICKS_SERVER_Font20", 0, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
                end

                local userGroupButton = vgui.Create( "bricks_server_dcheckbox", userGroupEntry )
                userGroupButton:Dock( RIGHT )
                userGroupButton:SetValue( v[2][key] )
                userGroupButton:SetTitle( "" )
                userGroupButton.backgroundCol = BRICKS_SERVER.Func.GetTheme( 2 )
                userGroupButton.OnChange = function( value )
                    if( value == true ) then
                        BS_ConfigCopyTable.GENERAL.Groups[k][2][key] = true
                    else
                        BS_ConfigCopyTable.GENERAL.Groups[k][2][key] = nil
                    end
                    BRICKS_SERVER.Func.ConfigChange( "GENERAL" )
                end

                userGroupsBack.list:SetTall( userGroupsBack.list:GetTall()+userGroupEntry:GetTall()+(userGroupsBack.list:GetTall() > 0 and userGroupSpacing or 0) )
            end

            if( userGroupsBack.Expanded ) then
                groupBack.targetHeight = groupBack.targetHeight-userGroupsBack.expandedExtraH
                slotParent.targetHeight = slotParent.targetHeight-userGroupsBack.expandedExtraH
    
                userGroupsBack.expandedExtraH = (userGroupSpacing*2)+userGroupsBack.list:GetTall()+userGroupsBack.searchBar:GetTall()

                groupBack.targetHeight = groupBack.targetHeight+userGroupsBack.expandedExtraH
                slotParent.targetHeight = slotParent.targetHeight+userGroupsBack.expandedExtraH
                
                userGroupsBack:SizeTo( self.slotWide-20, 40+userGroupsBack.expandedExtraH, 0.1 )
                groupBack:SizeTo( self.slotWide, groupBack.targetHeight, 0.1 )
                slotParent:SizeTo( self.slotWide, slotParent.targetHeight, 0.1 )
            else
                userGroupsBack.expandedExtraH = (userGroupSpacing*2)+userGroupsBack.list:GetTall()+userGroupsBack.searchBar:GetTall()
            end
        end
        userGroupsBack.list.RefreshEntries()
    end
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_groups", PANEL, "DPanel" )
--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_dcategorycollapse.lua:

local PANEL = {

	Init = function( self )

		self:SetContentAlignment( 4 )
		self:SetTextInset( 5, 0 )
		self:SetFont( "DermaDefaultBold" )

	end,

	DoClick = function( self )

		self:GetParent():Toggle()

	end,

	UpdateColours = function( self, skin )

		if ( !self:GetParent():GetExpanded() ) then
			self:SetExpensiveShadow( 0, Color( 0, 0, 0, 200 ) )
			return self:SetTextStyleColor( skin.Colours.Category.Header_Closed )
		end

		self:SetExpensiveShadow( 1, Color( 0, 0, 0, 100 ) )
		return self:SetTextStyleColor( skin.Colours.Category.Header )

	end,

	Paint = function( self )

		-- Do nothing!

	end,

	GenerateExample = function()

		-- Do nothing!

	end

}

derma.DefineControl( "bricks_server_dcategoryheader", "Category Header", PANEL, "DButton" )

local PANEL = {}

AccessorFunc( PANEL, "m_bSizeExpanded",		"Expanded", FORCE_BOOL )
AccessorFunc( PANEL, "m_iContentHeight",	"StartHeight" )
AccessorFunc( PANEL, "m_fAnimTime",			"AnimTime" )
AccessorFunc( PANEL, "m_bDrawBackground",	"PaintBackground", FORCE_BOOL )
AccessorFunc( PANEL, "m_bDrawBackground",	"DrawBackground", FORCE_BOOL ) -- deprecated
AccessorFunc( PANEL, "m_iPadding",			"Padding" )
AccessorFunc( PANEL, "m_pList",				"List" )

function PANEL:Init()

	self.Header = vgui.Create( "bricks_server_dcategoryheader", self )
	self.Header:Dock( TOP )
	self.Header:SetSize( 20, 40 )

	self:SetSize( 16, 16 )
	self:SetExpanded( true )
	self:SetMouseInputEnabled( true )

	self:SetAnimTime( 0.2 )
	self.animSlide = Derma_Anim( "Anim", self, self.AnimSlide )

	self:SetPaintBackground( true )
	self:DockMargin( 0, 0, 0, 5 )
	self:DockPadding( 0, 0, 0, 0 )

end

function PANEL:Add( strName )

	local button = vgui.Create( "DButton", self )
	button.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "CategoryButton", panel, w, h ) end
	button.UpdateColours = function( button, skin )

		if ( button.AltLine ) then

			if ( button.Depressed || button.m_bSelected ) then	return button:SetTextStyleColor( skin.Colours.Category.LineAlt.Text_Selected ) end
			if ( button.Hovered ) then							return button:SetTextStyleColor( skin.Colours.Category.LineAlt.Text_Hover ) end
			return button:SetTextStyleColor( skin.Colours.Category.LineAlt.Text )

		end

		if ( button.Depressed || button.m_bSelected ) then	return button:SetTextStyleColor( skin.Colours.Category.Line.Text_Selected ) end
		if ( button.Hovered ) then							return button:SetTextStyleColor( skin.Colours.Category.Line.Text_Hover ) end
		return button:SetTextStyleColor( skin.Colours.Category.Line.Text )

	end

	button:SetHeight( 40 )
	button:SetTextInset( 4, 0 )

	button:SetContentAlignment( 4 )
	button.DoClickInternal = function()

		if ( self:GetList() ) then
			self:GetList():UnselectAll()
		else
			self:UnselectAll()
		end

		button:SetSelected( true )

	end

	button:Dock( TOP )
	button:SetText( strName )

	self:InvalidateLayout( true )
	self:UpdateAltLines()

	return button

end

function PANEL:UnselectAll()

	local children = self:GetChildren()
	for k, v in pairs( children ) do

		if ( v.SetSelected ) then
			v:SetSelected( false )
		end

	end

end

function PANEL:UpdateAltLines()

	local children = self:GetChildren()
	for k, v in pairs( children ) do
		v.AltLine = k % 2 != 1
	end

end

function PANEL:Think()

	self.animSlide:Run()

end

function PANEL:SetLabel( strLabel )

	self.Header:SetText( strLabel )

end

function PANEL:Paint( w, h )
	draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
	draw.RoundedBox( 5, 0, 0, w, 40, BRICKS_SERVER.Func.GetTheme( 3 ) )

	BRICKS_SERVER.Func.DrawPartialRoundedBox( 5, 0, 0, 3, 40, (self.backColor or BRICKS_SERVER.Func.GetTheme( 4 )), 10, 40 )

	draw.SimpleText( (self.headerText or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font20", 15, 40/2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
end

function PANEL:AddButton( material, func )
	local button = vgui.Create( "DButton", self.Header )
	button:Dock( RIGHT )
	button:DockMargin( 2, 2, 2, 2 )
	button:SetWide( 36 )
	button:SetText( "" )
	local changeAlpha = 0
	local x, y = 0, 0
	button.Paint = function( self2, w, h )
		local toScreenX, toScreenY = self2:LocalToScreen( 0, 0 )
		if( x != toScreenX or y != toScreenY ) then
			x, y = toScreenX, toScreenY
		end

		if( self2:IsDown() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
		elseif( self2:IsHovered() ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 95 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 95 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
		surface.SetAlphaMultiplier( 1 )

		surface.SetMaterial( material )
		local size = 24
		surface.SetDrawColor( 0, 0, 0, 255 )
		surface.DrawTexturedRect( (h-size)/2-1, (h-size)/2+1, size, size )

		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.DrawTexturedRect( (h-size)/2, (h-size)/2, size, size )
	end
	button.DoClick = function()
		func( x, y, button:GetWide(), button:GetWide() )
	end
end

function PANEL:SetContents( pContents )

	self.Contents = pContents
	self.Contents:SetParent( self )
	self.Contents:Dock( FILL )

	if ( !self:GetExpanded() ) then

		self.OldHeight = self:GetTall()

	elseif ( self:GetExpanded() && IsValid( self.Contents ) && self.Contents:GetTall() < 1 ) then

		self.Contents:SizeToChildren( false, true )
		self.OldHeight = self.Contents:GetTall()
		self:SetTall( self.OldHeight )

	end

	self:InvalidateLayout( true )

end

function PANEL:SetExpanded( expanded )

	self.m_bSizeExpanded = tobool( expanded )

	if ( !self:GetExpanded() ) then
		if ( !self.animSlide.Finished && self.OldHeight ) then return end
		self.OldHeight = self:GetTall()
	end

end

function PANEL:Toggle()

	self:SetExpanded( !self:GetExpanded() )

	self.animSlide:Start( self:GetAnimTime(), { From = self:GetTall() } )

	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

	local open = "1"
	if ( !self:GetExpanded() ) then open = "0" end
	self:SetCookie( "Open", open )

	self:OnToggle( self:GetExpanded() )

end

function PANEL:OnToggle( expanded )

	-- Do nothing / For developers to overwrite

end

function PANEL:DoExpansion( b )

	if ( self:GetExpanded() == b ) then return end
	self:Toggle()

end

function PANEL:PerformLayout()

	if ( IsValid( self.Contents ) ) then

		if ( self:GetExpanded() ) then
			self.Contents:InvalidateLayout( true )
			self.Contents:SetVisible( true )
		else
			self.Contents:SetVisible( false )
		end

	end

	if ( self:GetExpanded() ) then

		if ( IsValid( self.Contents ) && #self.Contents:GetChildren() > 0 ) then self.Contents:SizeToChildren( false, true ) end
		self:SizeToChildren( false, true )

	else

		if ( IsValid( self.Contents ) && !self.OldHeight ) then self.OldHeight = self.Contents:GetTall() end
		self:SetTall( self.Header:GetTall() )

	end

	-- Make sure the color of header text is set
	self.Header:ApplySchemeSettings()

	self.animSlide:Run()
	self:UpdateAltLines()

end

function PANEL:OnMousePressed( mcode )

	if ( !self:GetParent().OnMousePressed ) then return end

	return self:GetParent():OnMousePressed( mcode )

end

function PANEL:AnimSlide( anim, delta, data )

	self:InvalidateLayout()
	self:InvalidateParent()

	if ( anim.Started ) then
		if ( !IsValid( self.Contents ) && ( self.OldHeight || 0 ) < self.Header:GetTall() ) then
			-- We are not using self.Contents and our designated height is less
			-- than the header size, something is clearly wrong, try to rectify
			self.OldHeight = 0
			for id, pnl in pairs( self:GetChildren() ) do
				self.OldHeight = self.OldHeight + pnl:GetTall()
			end
		end

		if ( self:GetExpanded() ) then
			data.To = math.max( self.OldHeight, self:GetTall() )
		else
			data.To = self:GetTall()
		end
	end

	if ( IsValid( self.Contents ) ) then self.Contents:SetVisible( true ) end

	self:SetTall( Lerp( delta, data.From, data.To ) )

end

function PANEL:LoadCookies()

	local Open = self:GetCookieNumber( "Open", 1 ) == 1

	self:SetExpanded( Open )
	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

end

derma.DefineControl( "bricks_server_dcollapsiblecategory", "Collapsable Category Panel", PANEL, "Panel" )

--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_loading_square.lua:
local PANEL = {}

function PANEL:Init()
    self.loadingDuration = 0.6
    self.finishFadeDuration = 0.5

    self:SetSize( BRICKS_SERVER.Func.Repeat( BRICKS_SERVER.Func.ScreenScale( 50 ), 2 ) )
    self.boxPositions = {}
    self.loadingX, self.loadingY = 0, 0
    self.oldX, self.oldY = 0, 0
    self.targetBox = 1
    self.loadingStart = 0
end

function PANEL:BeginAnimation()
    local size = (self:GetWide()-BRICKS_SERVER.UI.Margin5)/2

    for i = 1, 4 do
        local loadingBox = vgui.Create( "DPanel", self )
        loadingBox:SetSize( BRICKS_SERVER.Func.Repeat( size, 2 ) )
        loadingBox:SetPos( i % 2 == 0 and size+BRICKS_SERVER.UI.Margin5 or 0, i > 2 and size+BRICKS_SERVER.UI.Margin5 or 0 )
        loadingBox.index = i
        loadingBox.Paint = function( self2, w, h ) 
            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.DrawRect( 0, 0, w, h )

            if( self.finished ) then 
                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 4, (CurTime()-self.finishTime)/self.finishFadeDuration*255 ) )
                surface.DrawRect( 0, 0, w, h )
                return 
            end

            surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 4 ) )
            local x, y = self2:ScreenToLocal( self:LocalToScreen( self.loadingX, self.loadingY ) )
            surface.DrawRect( x, y, w, h )
        end

        table.insert( self.boxPositions, { loadingBox:GetPos() } )
    end

    self:MoveLoadingBox( 2 )
end

function PANEL:MoveLoadingBox( target )
    self.targetBox = target > 4 and 1 or target
    self.oldX, self.oldY = self.loadingX, self.loadingY
    self.loadingStart = CurTime()

    timer.Simple( self.loadingDuration, function()
        if( not IsValid( self ) ) then return end
        self:MoveLoadingBox( (self.targetBox == 1 and 2) or (self.targetBox == 2 and 4) or (self.targetBox == 4 and 3) or 1 )
    end )
end

function PANEL:FinishLoading()
    self.finishTime = CurTime()
    self.finished = true
    self:SizeTo( 0, 0, 0.2, self.finishFadeDuration+0.2, -1, function()
        self:Remove()
    end )
end

function PANEL:OnSizeChanged( w, h )
    if( not self.finished ) then return end
    self:SetPos( self.centerX-w/2, self.centerY-h/2 )

    local size = (self:GetWide()-PROJECT0.UI.Margin5)/2
    for k, v in ipairs( self:GetChildren() ) do
        v:SetSize( BRICKS_SERVER.Func.Repeat( size, 2 ) )
        v:SetPos( k % 2 == 0 and size+PROJECT0.UI.Margin5 or 0, k > 2 and size+PROJECT0.UI.Margin5 or 0 )
    end
end

function PANEL:PerformLayout( width, height )
    if( self.finished ) then return end
    self.centerX, self.centerY = self:GetX()+width/2, self:GetY()+height/2
end

function PANEL:Think()
    local percent = math.Clamp( (CurTime()-self.loadingStart)/self.loadingDuration, 0, 1 )
    self.loadingX, self.loadingY = Lerp( percent, self.oldX, self.boxPositions[self.targetBox][1] ), Lerp( percent, self.oldY, self.boxPositions[self.targetBox][2] )
end

vgui.Register( "bricks_server_loading_square", PANEL, "Panel" )
--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_scrollpanel_bar.lua:

local PANEL = {}

AccessorFunc( PANEL, "Padding", "Padding" )
AccessorFunc( PANEL, "pnlCanvas", "Canvas" )

function PANEL:Init()

	self.pnlCanvas = vgui.Create( "Panel", self )
	self.pnlCanvas.OnMousePressed = function( self, code ) self:GetParent():OnMousePressed( code ) end
	self.pnlCanvas:SetMouseInputEnabled( true )
	self.pnlCanvas.PerformLayout = function( pnl )

		self:PerformLayout()
		self:InvalidateParent()

	end

	-- Create the scroll bar
	self.VBar = vgui.Create( "bricks_server_dvscrollbar", self )
	self.VBar:Dock( RIGHT )

	self:SetPadding( 0 )
	self:SetMouseInputEnabled( true )

	-- This turns off the engine drawing
	self:SetPaintBackgroundEnabled( false )
	self:SetPaintBorderEnabled( false )
	self:SetPaintBackground( false )

end

function PANEL:SetBarBackColor( color )
	self.VBar.backColor = color
end

function PANEL:SetBarColor( color )
	self.VBar.barColor = color
end

function PANEL:SetBarDownColor( color )
	self.VBar.barDownColor = color
end

function PANEL:AddItem( pnl )

	pnl:SetParent( self:GetCanvas() )

end

function PANEL:OnChildAdded( child )

	self:AddItem( child )

end

function PANEL:SizeToContents()

	self:SetSize( self.pnlCanvas:GetSize() )

end

function PANEL:GetVBar()

	return self.VBar

end

function PANEL:GetCanvas()

	return self.pnlCanvas

end

function PANEL:InnerWidth()

	return self:GetCanvas():GetWide()

end

function PANEL:Rebuild()

	self:GetCanvas():SizeToChildren( false, true )

	-- Although this behaviour isn't exactly implied, center vertically too
	if ( self.m_bNoSizing && self:GetCanvas():GetTall() < self:GetTall() ) then

		self:GetCanvas():SetPos( 0, ( self:GetTall() - self:GetCanvas():GetTall() ) * 0.5 )

	end

end

function PANEL:OnMouseWheeled( dlta )

	return self.VBar:OnMouseWheeled( dlta )

end

function PANEL:OnVScroll( iOffset )

	self.pnlCanvas:SetPos( 0, iOffset )

end

function PANEL:ScrollToChild( panel )

	self:PerformLayout()

	local x, y = self.pnlCanvas:GetChildPosition( panel )
	local w, h = panel:GetSize()

	y = y + h * 0.5
	y = y - self:GetTall() * 0.5

	self.VBar:AnimateTo( y, 0.5, 0, 0.5 )

end

function PANEL:PerformLayout()
	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end
end

function PANEL:Clear()

	return self.pnlCanvas:Clear()

end

derma.DefineControl( "bricks_server_scrollpanel_bar", "", PANEL, "DPanel" )

--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_searchbar.lua:
local PANEL = {}

function PANEL:Init()
    self.search = vgui.Create( "bricks_server_search", self )
    self.search:Dock( FILL )
    self.search.OnChange = function()
        if( self.OnChange ) then
            self.OnChange()
        end
    end
    self.search.OnEnter = function()
        if( self.OnEnter ) then
            self.OnEnter()
        end
    end

    self:SetCornerRadius( 5 )
    self:SetRoundedCorners( true, true, true, true )
end

function PANEL:SetValue( val )
    return self.search:SetValue( val )
end

function PANEL:GetValue()
    return self.search:GetValue()
end

function PANEL:SetBackColor( color )
    self.backColor = color
end

function PANEL:SetHighlightColor( color )
    self.highlightColor = color
end

function PANEL:SetCornerRadius( cornerRadius )
    self.cornerRadius = cornerRadius
end

function PANEL:SetRoundedCorners( roundTopLeft, roundTopRight, roundBottomLeft, roundBottomRight )
    self.roundTopLeft, self.roundTopRight, self.roundBottomLeft, self.roundBottomRight = roundTopLeft, roundTopRight, roundBottomLeft, roundBottomRight
end

local search = Material( "materials/bricks_server/search.png" )
local alpha, alpha2 = 0, 20
function PANEL:Paint( w, h )
    draw.RoundedBoxEx( self.cornerRadius, 0, 0, w, h, (self.backColor or BRICKS_SERVER.Func.GetTheme( 3 )), self.roundTopLeft, self.roundTopRight, self.roundBottomLeft, self.roundBottomRight )

    if( self.search:IsEditing() ) then
        alpha = math.Clamp( alpha+5, 0, 100 )
        alpha2 = math.Clamp( alpha2+20, 20, 255 )
    else
        alpha = math.Clamp( alpha-5, 0, 100 )
        alpha2 = math.Clamp( alpha2-20, 20, 255 )
    end
    
    surface.SetAlphaMultiplier( alpha/255 )
    draw.RoundedBoxEx( self.cornerRadius, 0, 0, w, h, (self.highlightColor or BRICKS_SERVER.Func.GetTheme( 2 )), self.roundTopLeft, self.roundTopRight, self.roundBottomLeft, self.roundBottomRight )
    surface.SetAlphaMultiplier( 1 )

    surface.SetDrawColor( 255, 255, 255, alpha2 )
    surface.SetMaterial( search )
    local size = 24
    surface.DrawTexturedRect( w-size-(h-size)/2, (h-size)/2, size, size )
end

vgui.Register( "bricks_server_searchbar", PANEL, "DPanel" )
--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_url.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:LoadURL( url, wide )
    if( self.openedURL ) then return end

    self:OpenURL( url )

    self.openedURL = true
    

    local button = vgui.Create( "DButton", self )
    button:SetSize( 36, 36 )
    button:SetPos( wide-5-36, 5 )
    button:SetText( "" )
    local changeAlpha = 95
    local webMat = Material( "materials/bricks_server/web.png" )
    button.Paint = function( self3, w, h )
        if( self3:IsDown() ) then
            changeAlpha = math.Clamp( changeAlpha+10, 95, 255 )
        elseif( self3:IsHovered() ) then
            changeAlpha = math.Clamp( changeAlpha+10, 95, 165 )
        else
            changeAlpha = math.Clamp( changeAlpha-10, 95, 165 )
        end

        surface.SetAlphaMultiplier( changeAlpha/255 )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        surface.SetAlphaMultiplier( 1 )

        surface.SetMaterial( webMat )
        local size = 24
        surface.SetDrawColor( 0, 0, 0, 255 )
        surface.DrawTexturedRect( (h-size)/2-1, (h-size)/2+1, size, size )

        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.DrawTexturedRect( (h-size)/2, (h-size)/2, size, size )
    end
    button.DoClick = function()
        gui.OpenURL( url )
    end
end

local loadingIcon = Material( "materials/bricks_server/loading.png" )
function PANEL:Paint( w, h )
    surface.SetDrawColor( 255, 255, 255, 255 )
    surface.SetMaterial( loadingIcon )
    local size = 32
    surface.DrawTexturedRectRotated( w/2, h/2, size, size, -(CurTime() % 360 * 250) )

    draw.SimpleText( BRICKS_SERVER.Func.L( "loading" ), "BRICKS_SERVER_Font20", w/2, h/2+(size/2)+5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
end

vgui.Register( "bricks_server_url", PANEL, "DHTML" )
--PATH addons/bricks_gangs/lua/bricks_server/modules/gangs/shared/sh_gang_system.lua:
local russian_chars = {
	['а']='А',['б']='Б',['в']='В',['г']='Г',['д']='Д', ['е']='Е',['ё']='Ё',['ж']='Ж',['з']='З',['и']='И',['э']='Э',
	['й']='Й',['к']='К',['л']='Л', ['м']='М',['н']='Н', ['о']='О',['п']='П',['р']='Р',['с']='С',['т']='Т',['ю']='Ю',
	['у']='У', ['ф']='Ф',['х']='Х',['ц']='Ц',['ч']='Ч', ['ш']='Ш',['щ']='Щ',['ъ']='Ъ',['ы']='Ы', ['ь']='Ь',['я']='Я'
  }
local russian_invchars = {}
for k,v in pairs(russian_chars) do
	russian_invchars[v] = k
end
string.nlower = function(str)
	str = string.lower(str)
	local sum = utf8.len(str)
    local con = {}
	for i = 1, sum do
        local char = utf8.GetChar(str,i)
		if russian_invchars[char] then
			con[i] = russian_invchars[char]
        else
            con[i] = char
		end
	end
	return table.concat(con,"")
end

function BRICKS_SERVER.Func.GetGangExpToLevel( from, to )
    local totalExp = 0

    for i = 0, (to-from)-1 do
        local levelExp = BRICKS_SERVER.CONFIG.GANGS["Original EXP Required"]*(BRICKS_SERVER.CONFIG.GANGS["EXP Required Increase"]^(from+i) )
        totalExp = totalExp+levelExp
    end

    return totalExp
end

function BRICKS_SERVER.Func.GetGangCurLevelExp( gangID )
    local gangTable = (BRICKS_SERVER_GANGS or {})[gangID or 0]

    if( not gangTable ) then
        return 0
    end

    return (gangTable.Experience or 0)-BRICKS_SERVER.Func.GetGangExpToLevel( 0, gangTable.Level or 0 )
end

function BRICKS_SERVER.Func.GangGetLevel( gangID )
    local gangTable = (BRICKS_SERVER_GANGS or {})[gangID or 0]

    if( not gangTable ) then
        return 0
    end

    return gangTable.Level or 0
end

function BRICKS_SERVER.Func.FormatGangEXP( number )
	local finalString = number
	
	if( finalString > 1000000 ) then
		finalString = math.Round( finalString/1000000, 1 ) .. "M"
	elseif( finalString > 1000 ) then
		finalString = math.Round( finalString/1000, 1 ) .. "K"
	else
		finalString = math.Round( finalString )
	end

	return finalString
end

function BRICKS_SERVER.Func.GangGetUpgradeInfo( gangID, key, newGangTable )
    local gangTable = (not newGangTable and ((BRICKS_SERVER_GANGS or {})[gangID] or {})) or newGangTable

    local upgradesConfig = (BRICKS_SERVER.CONFIG.GANGS.Upgrades or {})[key] or {}
    local upgradesConfigTiers = upgradesConfig.Tiers or {}

    if( not gangTable or not gangTable.Upgrades or not gangTable.Upgrades[key] ) then
        return upgradesConfig.Default or {}
    end
    
    local upgrade = math.Clamp( (gangTable.Upgrades[key] or 1), 0, #upgradesConfigTiers )

    local reqInfo, devConfigReqInfo = (upgradesConfigTiers[upgrade] or {}).ReqInfo, (BRICKS_SERVER.DEVCONFIG.GangUpgrades[key] or {}).ReqInfo or {}
    if( reqInfo and #reqInfo >= #devConfigReqInfo ) then
        return reqInfo
    else
        local reqInfoDefault = {}
        for k, v in pairs( devConfigReqInfo ) do
            if( v[2] == "integer" ) then
                reqInfoDefault[k] = 0
            elseif( v[2] == "table" ) then
                reqInfoDefault[k] = {}
            else
                reqInfoDefault[k] = ""
            end
        end

        return reqInfoDefault
    end
end

function BRICKS_SERVER.Func.GangGetUpgradeBought( gangID, key )
    local gangTable = (BRICKS_SERVER_GANGS or {})[gangID] or {}

    if( gangTable and gangTable.Upgrades and gangTable.Upgrades[key] and gangTable.Upgrades[key] > 0 ) then
        return true
    end

    return false
end

function BRICKS_SERVER.Func.GangGetInboxReqInfo( receiverKey, inboxKey )
    if( BRS_GANG_INBOXES and BRS_GANG_INBOXES[receiverKey] and BRS_GANG_INBOXES[receiverKey][inboxKey] and BRS_GANG_INBOXES[receiverKey][inboxKey].ReqInfo ) then 
        return BRS_GANG_INBOXES[receiverKey][inboxKey].ReqInfo
    end

    return false
end

function BRICKS_SERVER.Func.CheckGangName( name )
    local gangTable = (BRICKS_SERVER_GANGS or {})
    for k,v in pairs(gangTable) do
        if string.nlower(v.Name) == string.nlower(name) then return false end
    end
	local nameLen = utf8.len( name )
	if( nameLen > BRICKS_SERVER.DEVCONFIG.GangNameCharMax or nameLen < BRICKS_SERVER.DEVCONFIG.GangNameCharMin ) then return false end

    return true
end

function BRICKS_SERVER.Func.CheckGangIconURL( url )
    if( not string.StartWith( url, "http" ) ) then
        for k, v in ipairs( BRICKS_SERVER.DEVCONFIG.PresetGangIcons ) do
            if( url == v ) then return true end
        end

        return false
    end

    if( utf8.len( url ) > BRICKS_SERVER.DEVCONFIG.GangIconCharLimit ) then return false end 

    local validImageEndings = { ".png", ".jpg", ".jpeg" }
    local foundValidEnding = false
    for k, v in ipairs( validImageEndings ) do
        if( not string.EndsWith( url, v ) ) then continue end

        foundValidEnding = true
        break
    end

    if( not foundValidEnding ) then return false end

    for k, v in ipairs( BRICKS_SERVER.DEVCONFIG.GangURLWhitelist ) do
        if( string.StartWith( url, v ) ) then return true end
    end

    return false
end
--PATH addons/bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gangmenu_dashboard.lua:
local PANEL = {}

function PANEL:Init()
    net.Receive("BRS.Net.GetLastTransaction",function()
        local trans = net.ReadInt(32)
        if trans != 0 then
            self.transaction = trans
        end
    end)
end

function PANEL:UpdateTransactions()
    net.Start("BRS.Net.GetLastTransaction")
    net.SendToServer()
end

function PANEL:GetTransaction()
    return self.transaction
end

function PANEL:FillPanel( gangTable )
    self:UpdateTransactions()
    local graphs = {
        [1] = {
            Title = BRICKS_SERVER.Func.L( "gangMembers" ),
            Color1 = Color( 128, 38, 38 ),
            Color2 = Color( 210, 74, 74 ),
            HighlightColor = Color( 201, 70, 70 ),
            SubTitle = function() 
                local memberCount = table.Count( gangTable.Members or {} )
                return memberCount .. ((memberCount != 1 and " Игроков") or " Игрок")
            end,
            BottomTitle = "Игроков онлайн",
            BottomSubTitle = function() 
                local onlineCount = 0
                for k, v in pairs( gangTable.Members or {} ) do
                    local ply = player.GetBySteamID( k )

                    if( IsValid( ply ) ) then
                        onlineCount = onlineCount+1
                    end
                end
                return onlineCount
            end
        },
        [2] = {
            Title = BRICKS_SERVER.Func.L( "gangBalance" ),
            Color1 = Color( 39, 128, 100 ),
            Color2 = Color( 74, 211, 114 ),
            HighlightColor = Color( 71, 204, 112 ),
            SubTitle = function() return DarkRP.formatMoney( gangTable.Money or 0 ) end,
            BottomTitle = "Последняя транзакция",
            BottomSubTitle = function() 
                local transaction = self:GetTransaction()
                if( transaction ) then
                    return {
                        { ((transaction >= 0 and "+") or "") .. DarkRP.formatMoney( transaction ), "BRICKS_SERVER_Font33", ((transaction >= 0 and Color( 71, 204, 112 )) or Color( 229, 62, 62 )) }
                    }
                else
                    return "Не было"
                end
            end
        },
        [3] = {
            Title = BRICKS_SERVER.Func.L( "gangLevel" ),
            Color1 = Color( 196, 32, 201 ),
            Color2 = Color( 166, 61, 212 ),
            HighlightColor = Color( 194, 34, 202 ),
            SubTitle = function() return gangTable.Level or 0 end,
            BottomTitle = "XP прогресс",
            BottomSubTitle = function() 
                local currentXP = math.max( 0, (gangTable.Experience or 0)-BRICKS_SERVER.Func.GetGangExpToLevel( 0, (gangTable.Level or 0) ) )
                local goalXP = math.max( 0, BRICKS_SERVER.Func.GetGangExpToLevel( (gangTable.Level or 0), (gangTable.Level or 0)+1 ) )
                return {
                    { string.Comma( math.floor( currentXP ) ) }, 
                    { "/" .. string.Comma( math.floor( goalXP ) ) .. "XP", "BRICKS_SERVER_Font28B", Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ) }
                }
            end,
        }
    }

    -- if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
    --     graphs[3] = {
    --         Title = BRICKS_SERVER.Func.L( "gangStorage" ),
    --         Color1 = Color( 76, 113, 212 ),
    --         Color2 = Color( 81, 80, 171 ),
    --         HighlightColor = Color( 80, 84, 175 ),
    --         SubTitle = function() 
    --             return {
    --                 { table.Count( gangTable.Storage or {} ) }, 
    --                 { "/" .. BRICKS_SERVER.Func.GangGetUpgradeInfo( LocalPlayer():GetGangID(), "StorageSlots" )[1], "BRICKS_SERVER_Font28B" }
    --             }
    --         end,
    --         BottomTitle = "STORAGE USED",
    --         BottomSubTitle = function() return math.Clamp( 100*(table.Count( gangTable.Storage or {} )/BRICKS_SERVER.Func.GangGetUpgradeInfo( LocalPlayer():GetGangID(), "StorageSlots" )[1]), 0, 100 ) .. "% FILLED" end
    --     }
    -- else
    --     graphs[3] = {
    --         Title = BRICKS_SERVER.Func.L( "gangStorage" ),
    --         Color1 = Color( 76, 113, 212 ),
    --         Color2 = Color( 81, 80, 171 ),
    --         HighlightColor = Color( 80, 84, 175 ),
    --         SubTitle = function() 
    --             return {
    --                 { 0 }, 
    --                 { "/" .. 0, "BRICKS_SERVER_Font28B" }
    --             }
    --         end,
    --         BottomTitle = "STORAGE DISABLED",
    --         BottomSubTitle = function() return "0% FILLED" end
    --     }
    -- end

    local outerMargin = 24

    local panelWide = self.panelWide-(2*outerMargin)
    
    local statisticsBack = vgui.Create( "DPanel", self )
    statisticsBack:Dock( TOP )
    statisticsBack:DockMargin( outerMargin, outerMargin, outerMargin, 0 )
    statisticsBack:DockPadding( 0, 35, 0, 0 )
    statisticsBack:SetTall( BRICKS_SERVER.Func.ScreenScale( 275 ) )
    statisticsBack.Paint = function( self2, w, h ) 
        draw.SimpleText( BRICKS_SERVER.Func.L( "gangInformation" ), "BRICKS_SERVER_Font30", 0, 0, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 150 ), 0, 0 )
    end

    local graphSpacing = 30
    local graphWide = (panelWide-((#graphs-1)*graphSpacing))/#graphs
    local graphBackTall = statisticsBack:GetTall()-35

    for k, v in ipairs( graphs ) do
        local graphBack = vgui.Create( "DPanel", statisticsBack )
        graphBack:Dock( LEFT )
        graphBack:DockMargin( 0, 0, graphSpacing, 0 )
        graphBack:SetWide( graphWide )
        graphBack.Paint = function( self2, w, h ) end

        local graphTop = vgui.Create( "DPanel", graphBack )
        graphTop:Dock( TOP )
        graphTop:SetTall( graphBackTall*0.6 )
        graphTop.Paint = function( self2, w, h ) 
            BRICKS_SERVER.Func.DrawGradientRoundedBox( 8, 0, 0, w, h, 1, v.Color1, v.Color2 )

            draw.SimpleText( string.upper( v.Title ), "BRICKS_SERVER_Font28B", w/2, h/2+4, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 150 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

            if( not istable( v.SubTitle() ) ) then
                surface.SetFont("BRICKS_SERVER_Font28B")
                local addTextW, addTextH = surface.GetTextSize( v.SubTitle() or "" )
                draw.SimpleText( v.SubTitle(), "BRICKS_SERVER_Font36B", w/2, h/2-4+addTextH, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
            else
                local textW, textH = 0, 0
                for k, v in pairs( v.SubTitle() ) do
                    surface.SetFont( v[2] or "BRICKS_SERVER_Font36B" )
                    local addTextW, addTextH = surface.GetTextSize( v[1] or "" )
                    textW, textH = textW+addTextW, math.max( textH, addTextH )
                end

                local previousTextW = 0
                for k, v in pairs( v.SubTitle() ) do
                    surface.SetFont( v[2] or "BRICKS_SERVER_Font28B" )
                    local newTextW, newTextH = surface.GetTextSize( v[1] or v )

                    draw.SimpleText( v[1], (v[2] or "BRICKS_SERVER_Font36B"), (w/2)-(textW/2)+previousTextW, h/2-4+textH+newTextH, (v[3] or BRICKS_SERVER.Func.GetTheme( 6 )), 0, TEXT_ALIGN_BOTTOM )

                    previousTextW = previousTextW+newTextW
                end
            end
        end

        surface.SetFont( "BRICKS_SERVER_Font21" )
        local bottomTitleX, bottomTitleY = surface.GetTextSize( v.BottomTitle or "" )

        surface.SetFont( "BRICKS_SERVER_Font33" )
        local bottomSubTitleX, bottomSubTitleY = 0, 0

        if( not istable( v.BottomSubTitle() ) ) then
            bottomSubTitleX, bottomSubTitleY = surface.GetTextSize( v.BottomSubTitle() or "" )
        else
            for k, v in pairs( v.BottomSubTitle() ) do
                surface.SetFont( v[2] or "BRICKS_SERVER_Font33" )
                local addTextW, addTextH = surface.GetTextSize( v[1] or "" )
                bottomSubTitleX, bottomSubTitleY = bottomSubTitleX+addTextW, math.max( bottomSubTitleY, addTextH )
            end
        end

        local textSpacing = -1
        local contentH = bottomTitleY+textSpacing+bottomSubTitleY

        local graphBottom = vgui.Create( "DPanel", graphBack )
        graphBottom:Dock( BOTTOM )
        graphBottom:SetTall( graphBackTall-graphTop:GetTall()-BRICKS_SERVER.Func.ScreenScale( 20 ) )
        graphBottom.Paint = function( self2, w, h ) 
            draw.RoundedBox( 10, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

            BRICKS_SERVER.Func.DrawPartialRoundedBox( 8, 0, 0, w, 8, v.Color2, w, 20 )

            local startY = 8+((h-8)/2)-(contentH/2)-2

            draw.SimpleText( v.BottomTitle, "BRICKS_SERVER_Font21", self2:GetWide()/2-bottomTitleX/2, startY, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ) )

            if( not istable( v.BottomSubTitle() ) ) then
                draw.SimpleText( v.BottomSubTitle(), "BRICKS_SERVER_Font33", self2:GetWide()/2-bottomSubTitleX/2, startY+bottomTitleY-textSpacing, BRICKS_SERVER.Func.GetTheme( 6 ) )
            else
                local previousTextW = 0
                local AllTextW, AllTextH = surface.GetTextSize( v.BottomSubTitle()[1][1]..(v.BottomSubTitle()[2] and v.BottomSubTitle()[2][1] or "") )
                for k, v in pairs( v.BottomSubTitle() ) do
                    surface.SetFont( v[2] or "BRICKS_SERVER_Font33" )
                    local newTextW, newTextH = surface.GetTextSize( v[1] or v )

                    draw.SimpleText( v[1], (v[2] or "BRICKS_SERVER_Font33"), self2:GetWide()/2-AllTextW/2+previousTextW, startY+bottomTitleY-textSpacing+bottomSubTitleY, (v[3] or BRICKS_SERVER.Func.GetTheme( 6 )), 0, TEXT_ALIGN_BOTTOM )

                    previousTextW = previousTextW+newTextW
                end
            end
        end
    end

    local bottomBack = vgui.Create( "DPanel", self )
    bottomBack:Dock( FILL )
    bottomBack:DockMargin( outerMargin, outerMargin, outerMargin, outerMargin )
    bottomBack.Paint = function( self2, w, h ) end

    local memberLeftMargin = 25

    local membersBack = vgui.Create( "DPanel", bottomBack )
    membersBack:Dock( LEFT )
    membersBack:SetWide( panelWide*0.38 )
    membersBack.Paint = function( self2, w, h ) 
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

        BRICKS_SERVER.Func.DrawPartialRoundedBox( 8, 0, 0, w, 10, BRICKS_SERVER.Func.GetTheme( 3 ), w, 20 )

        draw.SimpleText( string.upper( BRICKS_SERVER.Func.L( "gangMembers" ) ), "BRICKS_SERVER_Font21", memberLeftMargin, 25, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ) )
    end

    local membersScroll = vgui.Create( "bricks_server_scrollpanel_bar", membersBack )
    membersScroll:Dock( FILL )
    membersScroll:DockMargin( memberLeftMargin, 60, 15, 25 )

    function self.RefreshMembers()
        membersScroll:Clear()

        local showMembers = {}
        for k, v in pairs( gangTable.Members ) do
            local memberPly = player.GetBySteamID( k )

            table.insert( showMembers, { v[2]+((not IsValid( memberPly ) and 100) or 0), IsValid( memberPly ), k, v[1], v[2] } ) -- sort value, online, steamid, name, groupid
        end

        table.SortByMember( showMembers, 1, true )

        for k, v in pairs( showMembers ) do
            local playerEnt = player.GetBySteamID( v[3] )
            local playerName = v[4]
        
            if( IsValid( playerEnt ) ) then
                playerName = playerEnt:Nick()
            end

            local avatarBoxH = BRICKS_SERVER.Func.ScreenScale( 50 )
            local circleRadius = BRICKS_SERVER.Func.ScreenScale( 7 )

            surface.SetFont( "BRICKS_SERVER_Font33" )
            local bottomTitleX, bottomTitleY = surface.GetTextSize( playerName or "" )
    
            surface.SetFont( "BRICKS_SERVER_Font21" )
            local bottomSubTitleX, bottomSubTitleY = surface.GetTextSize( gangTable.Roles[v[5]][1] or "" )
    
            local textSpacing = -2
            local contentH = bottomTitleY+textSpacing+bottomSubTitleY

            local playerBack = vgui.Create( "DPanel", membersScroll )
            playerBack:Dock( TOP )
            playerBack:DockMargin( 0, 0, 0, 15 )
            playerBack:SetTall( avatarBoxH+(circleRadius*0.45) )
            local alpha = 0
            local playerButton
            local clickColor = Color( BRICKS_SERVER.Func.GetTheme( 0 ).r, BRICKS_SERVER.Func.GetTheme( 0 ).g, BRICKS_SERVER.Func.GetTheme( 0 ).b, 50 )
            playerBack.Paint = function( self2, w, h )
                if( IsValid( playerButton ) ) then
                    if( not playerButton:IsDown() and playerButton:IsHovered() ) then
                        alpha = math.Clamp( alpha+3, 0, 50 )
                    else
                        alpha = math.Clamp( alpha-3, 0, 50 )
                    end
            
                    draw.RoundedBox( 5, 0, 0, w, h, Color( BRICKS_SERVER.Func.GetTheme( 0 ).r, BRICKS_SERVER.Func.GetTheme( 0 ).g, BRICKS_SERVER.Func.GetTheme( 0 ).b, alpha ) )
        
                    BRICKS_SERVER.Func.DrawClickCircle( playerButton, w, h, clickColor )
                end

                local startY = (avatarBoxH/2)-(contentH/2)-2

                draw.SimpleText( playerName, "BRICKS_SERVER_Font33", avatarBoxH+15, startY, BRICKS_SERVER.Func.GetTheme( 6 ) )
                draw.SimpleText( string.upper( gangTable.Roles[v[5]][1] ), "BRICKS_SERVER_Font21", avatarBoxH+15+1, startY+bottomTitleY+textSpacing, (gangTable.Roles[v[5]][2] or BRICKS_SERVER.Func.GetTheme( 6 )) )
            end

            local playerIcon = vgui.Create( "bricks_server_rounded_avatar" , playerBack )
            playerIcon:SetPos( 0, 0 )
            playerIcon:SetSize( avatarBoxH, avatarBoxH )
            playerIcon.rounded = 8
            if( IsValid( playerEnt ) ) then
                playerIcon:SetPlayer( playerEnt, 64 )
            else
                playerIcon:SetSteamID( util.SteamIDTo64( v[3] ), 64 )
            end

            playerButton = vgui.Create( "DButton", playerBack )
            playerButton:SetSize( (panelWide*0.38)-memberLeftMargin-15, avatarBoxH+(circleRadius*0.45) )
            playerButton:SetText( "" )
            local x, y, w, h = 0, 0, playerButton:GetWide(), playerButton:GetTall()
            playerButton.Paint = function( self2, w, h )
                local toScreenX, toScreenY = self2:LocalToScreen( 0, 0 )
                if( x != toScreenX or y != toScreenY ) then
                    x, y = toScreenX, toScreenY
                end

                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
                draw.NoTexture()
                BRICKS_SERVER.Func.DrawCircle( h-circleRadius, h-circleRadius, circleRadius+2, 45 )
        
                draw.NoTexture()
                if( IsValid( playerEnt ) ) then
                    surface.SetDrawColor( BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )
                else
                    surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
                end
                BRICKS_SERVER.Func.DrawCircle( h-circleRadius, h-circleRadius, circleRadius, 45 )
            end
            playerButton.DoClick = function( self2 )
                self2.Menu = vgui.Create( "bricks_server_dmenu" )

                if( not actions ) then
                    if( LocalPlayer():GangHasPermission( "ChangePlayerRoles" ) ) then
                        self2.Menu:AddOption( "Set rank", function()
                            local options = {}
                            for k, v in pairs( gangTable.Roles or {} ) do
                                options[k] = v[1]
                            end

                            BRICKS_SERVER.Func.ComboRequest( "Gang", BRICKS_SERVER.Func.L( "gangRankQuery" ), groupID, options, function( value, data ) 
                                if( (gangTable.Roles or {})[data] ) then
                                    if( groupID != data ) then
                                        net.Start( "BRS.Net.GangSetRank" )
                                            net.WriteString( v[3] )
                                            net.WriteUInt( data, 16 )
                                        net.SendToServer()
                                    else
                                        notification.AddLegacy( BRICKS_SERVER.Func.L( "gangPlayerAlreadyRank" ), 1, 3 )
                                    end
                                else
                                    notification.AddLegacy( BRICKS_SERVER.Func.L( "gangInvalidRank" ), 1, 3 )
                                end
                            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
                        end )
                    end

                    if( LocalPlayer():GangHasPermission( "KickPlayers" ) ) then
                        self2.Menu:AddOption( BRICKS_SERVER.Func.L( "gangKick" ), function()
                            BRICKS_SERVER.Func.Query( BRICKS_SERVER.Func.L( "gangKickConfirm" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                                net.Start( "BRS.Net.GangKick" )
                                    net.WriteString( v[3] )
                                net.SendToServer()
                            end )
                        end )
                    end
                else
                    for k, v in pairs( actions ) do
                        self2.Menu:AddOption( v[1], v[2] )
                    end
                end

                self2.Menu:Open()
                self2.Menu:SetPos( x+w+5, y+(h/2)-(self2.Menu:GetTall()/2) )
            end
        end
    end
    self.RefreshMembers()

    local actionsBack = vgui.Create( "DPanel", bottomBack )
    actionsBack:Dock( RIGHT )
    actionsBack:SetWide( graphWide )
    actionsBack:DockPadding( 0, 35, 0, 0 )
    actionsBack.Paint = function( self2, w, h ) 
        draw.SimpleText( string.upper( BRICKS_SERVER.Func.L( "gangActions" ) ), "BRICKS_SERVER_Font21", 0, 0, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ) )
    end

    local actionsScroll = vgui.Create( "bricks_server_scrollpanel", actionsBack )
    actionsScroll:Dock( FILL )

    local actions = {}

    if( LocalPlayer():GangHasPermission( "DepositMoney" ) ) then
        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangDepositMoney" ),
            Color = Color( 207, 72, 72 ),
            ColorDown = BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed,
            Func = function()
                BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangDepositMoneyQuery" ), (BRICKS_SERVER.CONFIG.GANGS["Minimum Deposit"] or 1000), function( number ) 
                    if( (gangTable.Money or 0)+number <= BRICKS_SERVER.Func.GangGetUpgradeInfo( LocalPlayer():GetGangID(), "MaxBalance" )[1] ) then
                        if( number >= (BRICKS_SERVER.CONFIG.GANGS["Minimum Deposit"] or 1000) ) then
                            net.Start( "BRS.Net.GangDepositMoney" )
                                net.WriteUInt( number, 32 )
                            net.SendToServer()
                            if BRICKS_SERVER_GANGMENU.UpdateTransactions then
                                BRICKS_SERVER_GANGMENU.UpdateTransactions()
                            end
                        else
                            BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangDepositMoneyLess", DarkRP.formatMoney( BRICKS_SERVER.CONFIG.GANGS["Minimum Deposit"] or 1000 ) ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                        end
                    else
                        BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangDepositMoneyMuch" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
            end
        } )
    end

    if( LocalPlayer():GangHasPermission( "WithdrawMoney" ) ) then
        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangWithdrawMoney" ),
            Color = Color( 65, 190, 110 ),
            ColorDown = BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen,
            Func = function()
                BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangWithdrawMoneyQuery" ), (BRICKS_SERVER.CONFIG.GANGS["Minimum Withdraw"] or 1000), function( number ) 
                    if( (gangTable.Money or 0) >= number ) then
                        if( number >= (BRICKS_SERVER.CONFIG.GANGS["Minimum Withdraw"] or 1000) ) then
                            net.Start( "BRS.Net.GangWithdrawMoney" )
                                net.WriteUInt( number, 32 )
                            net.SendToServer()
                            if BRICKS_SERVER_GANGMENU.UpdateTransactions then
                                BRICKS_SERVER_GANGMENU.UpdateTransactions()
                            end
                        else
                            BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangWithdrawMoneyLess", DarkRP.formatMoney( BRICKS_SERVER.CONFIG.GANGS["Minimum Withdraw"] or 1000 ) ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                        end
                    else
                        BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangWithdrawMoneyMuch" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
            end
        } )
    end

    if( LocalPlayer():GangHasPermission( "InvitePlayers" ) ) then
        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangInvitePlayer" ),
            Func = function()
                local options = {}
                for k, v in player.Iterator() do
                    if( gangTable.Members[v:SteamID()] ) then continue end
                    
                    options[v:SteamID()] = v:Nick() .. " (" .. ((not v:IsBot() and v:SteamID()) or "BOT") .. ")"
                end
    
                BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangInvitePlayerQuery" ), BRICKS_SERVER.Func.L( "none" ), options, function( value, data ) 
                    if( options[data] ) then
                        net.Start( "BRS.Net.GangInvite" )
                            net.WriteString( data )
                        net.SendToServer()
                    else
                        notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidPlayer" ), 1, 3 )
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
            end
        } )
    end

    if( gangTable.Owner == LocalPlayer():SteamID() ) then
        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangDisband" ),
            Func = function()
                BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangDisbandQuery" ), "", function( text ) 
                    if( text == "Подтверждаю" ) then
                        net.Start( "BRS.Net.GangDisband" )
                        net.SendToServer()
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), false )
            end
        } )

        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangTransfer" ),
            Func = function()
                local options = {}
                for k, v in pairs( gangTable.Members ) do
                    if( (gangTable.Owner or "") == k ) then continue end

                    options[k] = v[1]
                end
    
                BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangTransferQuery" ), BRICKS_SERVER.Func.L( "none" ), options, function( value, data ) 
                    if( options[data] ) then
                        net.Start( "BRS.Net.GangTransfer" )
                            net.WriteString( data )
                        net.SendToServer()
                    else
                        notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidPlayer" ), 1, 3 )
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
            end
        } )
    else
        table.insert( actions, {
            Name = BRICKS_SERVER.Func.L( "gangLeave" ),
            Func = function()
                BRICKS_SERVER.Func.Query( BRICKS_SERVER.Func.L( "gangLeaveQuery" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                    net.Start( "BRS.Net.GangLeave" )
                    net.SendToServer()
                end )
            end
        } )
    end

    for k, v in pairs( actions ) do
        local action = vgui.Create( "DButton", actionsScroll )
        action:Dock( TOP )
        action:SetTall( BRICKS_SERVER.Func.ScreenScale( 50 ) )
        action:DockMargin( 0, 0, 0, BRICKS_SERVER.Func.ScreenScale( 15 ) )
        action:SetText( "" )
        local Alpha = 0
        action.Paint = function( self2, w, h ) 
            if( not self2:IsDown() and self2:IsHovered() ) then
                Alpha = math.Clamp( Alpha+5, 0, 100 )
            else
                Alpha = math.Clamp( Alpha-5, 0, 100 )
            end
        
            draw.RoundedBox( 8, 0, 0, w, h, (v.Color or BRICKS_SERVER.Func.GetTheme( 2 )) )

            surface.SetAlphaMultiplier( Alpha/255 )
            draw.RoundedBox( 8, 0, 0, w, h, (v.ColorDown or BRICKS_SERVER.Func.GetTheme( 3 )) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, (v.ColorDown or BRICKS_SERVER.Func.GetTheme( 3 )) )

            draw.SimpleText( string.upper( v.Name ), "BRICKS_SERVER_Font21", 15, h/2, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 100 ), 0, TEXT_ALIGN_CENTER )
        end
        action.DoClick = v.Func
    end

    local chatBack = vgui.Create( "DPanel", bottomBack )
    chatBack:Dock( FILL )
    chatBack:DockMargin( outerMargin, 0, outerMargin, 0 )
    chatBack.Paint = function( self2, w, h ) 
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

        BRICKS_SERVER.Func.DrawPartialRoundedBox( 8, 0, 0, w, 10, BRICKS_SERVER.Func.GetTheme( 3 ), w, 20 )

        draw.SimpleText( string.upper( BRICKS_SERVER.Func.L( "gangChat" ) ), "BRICKS_SERVER_Font21", memberLeftMargin, 25, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ) )
    end

    local chatMessageBack
    if( LocalPlayer():GangHasPermission( "SendMessages" ) ) then
        chatMessageBack = vgui.Create( "DPanel", chatBack )
        chatMessageBack:Dock( BOTTOM )
        chatMessageBack:DockMargin( 15, 0, 15, 15 )
        chatMessageBack:SetTall( BRICKS_SERVER.Func.ScreenScale( 40 ) )
        chatMessageBack.Paint = function( self2, w, h ) 
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
        end

        local chatMessageEntry
        local function sendChatMessage()
            if( BRICKS_SERVER.CONFIG.GANGS["Disable Gang Chat"] ) then
                BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangMessageDisabled" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                return
            end

            local message = chatMessageEntry:GetValue()
            if( message and message != "" ) then
                net.Start( "BRS.Net.GangSendMessage" )
                    net.WriteString( message )
                net.SendToServer()
            end

            chatMessageEntry:SetText( "" )
        end

        local chatMessageButton = vgui.Create( "DButton", chatMessageBack )
        chatMessageButton:Dock( RIGHT )
        chatMessageButton:SetWide( chatMessageBack:GetTall() )
        chatMessageButton:SetText( "" )
        local Alpha = 0
        local sendMat = Material( "bricks_server/gang_send.png" )
        chatMessageButton.Paint = function( self2, w, h ) 
            if( not self2:IsDown() and self2:IsHovered() ) then
                Alpha = math.Clamp( Alpha+5, 0, 100 )
            else
                Alpha = math.Clamp( Alpha-5, 0, 100 )
            end

            surface.SetAlphaMultiplier( Alpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

            surface.SetDrawColor( 255, 255, 255, 20+(235*(Alpha/100)) )
            surface.SetMaterial( sendMat )
            local iconSize = BRICKS_SERVER.Func.ScreenScale( 24 )
            surface.DrawTexturedRect( (w/2)-(iconSize/2), (h/2)-(iconSize/2), iconSize, iconSize )
        end
        chatMessageButton.DoClick = sendChatMessage

        chatMessageEntry = vgui.Create( "bricks_server_search", chatMessageBack )
        chatMessageEntry:Dock( FILL )
        chatMessageEntry:DockMargin( 10, 0, 0, 0 )
        chatMessageEntry:SetFont( "BRICKS_SERVER_Font21" )
        chatMessageEntry.backFont = "BRICKS_SERVER_Font21"
        chatMessageEntry.backText = string.upper( BRICKS_SERVER.Func.L( "gangMessage" ) .. "..." )
        chatMessageEntry.backTextColor = Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 )
        chatMessageEntry.OnEnter = sendChatMessage
    end

    local chatScroll = vgui.Create( "bricks_server_scrollpanel_bar", chatBack )
    chatScroll:Dock( BOTTOM )
    chatScroll:DockMargin( 15, 0, 15, 15 )
    chatScroll.Paint = function( self2, w, h ) end
    local scrollH = 0
    chatScroll.pnlCanvas.Paint = function( self2, w, h ) 
        if( scrollH != h ) then
            scrollH = h
            chatScroll.VBar:AnimateTo( scrollH, 0 ) 
        end
    end

    local chatScrollMaxH = (ScrH()*0.65)-40-(2*outerMargin)-statisticsBack:GetTall()-outerMargin-60-((chatMessageBack and 55) or 0)-10

    self.chatSlots = 0
    function self.AddGangChatMessage( time, message, memberSteamID )
        self.chatSlots = self.chatSlots+1
        chatScroll:SetTall( math.min( chatScrollMaxH, chatScroll:GetTall()+((self.chatSlots % 2 == 0 and 15) or 0) ) )

        local memberTable = (gangTable.Members or {})[memberSteamID] or {}
        local groupData = (gangTable.Roles or {})[memberTable[2] or 0] or {}

        surface.SetFont( "BRICKS_SERVER_Font21" )
        local bottomTitleX, bottomTitleY = surface.GetTextSize( memberTable[1] or "NIL" )

        surface.SetFont( "BRICKS_SERVER_Font26" )
        local bottomSubTitleX, bottomSubTitleY = surface.GetTextSize( message or "" )

        surface.SetFont( "BRICKS_SERVER_Font17" )
        local timeTextX, timeTextY = surface.GetTextSize( BRICKS_SERVER.Func.FormatTimeInPlace( time ) or "" )

        local bottomTitleFullW = bottomTitleX+8+timeTextX
        local messageWidth = (2*12)+((bottomSubTitleX > bottomTitleFullW and bottomSubTitleX) or bottomTitleFullW)

        local textSpacing = -6
        local contentH = bottomTitleY+textSpacing+bottomSubTitleY

        local messageEntry = vgui.Create( "DPanel", chatScroll )
        messageEntry:Dock( TOP )
        messageEntry:DockMargin( 0, 15, math.max( 10, panelWide-(2*outerMargin)-membersBack:GetWide()-graphWide-messageWidth-30-10 ), 0 )
        messageEntry:SetTall( 60 )
        local messageWrap, lineCount
        messageEntry.Paint = function( self2, w, h ) 
            draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

            local startY = (h/2)-(contentH/2)-2

            draw.SimpleText( (memberTable[1] or "NIL"), "BRICKS_SERVER_Font21", 12, startY, (groupData[2] or BRICKS_SERVER.Func.GetTheme( 5 )) )

            if( not messageWrap ) then
                messageWrap, lineCount = BRICKS_SERVER.Func.TextWrap( message, "BRICKS_SERVER_Font26", w-24 )
                messageEntry:SetTall( 60+((lineCount-1)*bottomSubTitleY) )
                contentH = bottomTitleY+textSpacing+(lineCount*bottomSubTitleY)
                chatScroll:SetTall( math.min( chatScrollMaxH, chatScroll:GetTall()+messageEntry:GetTall() ) )
            end

            BRICKS_SERVER.Func.DrawNonParsedText( messageWrap, "BRICKS_SERVER_Font26", 12, startY+bottomTitleY+textSpacing, BRICKS_SERVER.Func.GetTheme( 6 ), 0 )

            draw.SimpleText( BRICKS_SERVER.Func.FormatTimeInPlace( time ), "BRICKS_SERVER_Font15", 12+bottomTitleX+8, startY+bottomTitleY-1, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, 75 ), 0, TEXT_ALIGN_BOTTOM )
        end

        return messageEntry
    end

    function self.RefreshGangChat()
        chatScroll:Clear()
        self.chatSlots = 0

        local gangID = LocalPlayer():GetGangID()

        if( not BRS_GANG_CHATS or not BRS_GANG_CHATS[gangID] ) then return end

        local sortedMessages = table.Copy( BRS_GANG_CHATS[gangID] )
        table.SortByMember( sortedMessages, 1, true )

        for k, v in ipairs( sortedMessages ) do
            local messageEntry = self.AddGangChatMessage( v[1], v[2], v[3] )
        end
    end
    self.RefreshGangChat()

    hook.Add( "BRS.Hooks.InsertGangChat", self, function( self, messageKey )
        if( IsValid( self ) ) then
            local gangID = LocalPlayer():GetGangID()
            local messageTable = ((BRS_GANG_CHATS or {})[gangID] or {})[messageKey]

            if( not messageTable ) then return end

            self.AddGangChatMessage( messageTable[1], messageTable[2], messageTable[3] )
            surface.PlaySound( "UI/buttonclick.wav" ) 
        else
            hook.Remove( "BRS.Hooks.InsertGangChat", self )
        end
    end )

    local inboxButton = vgui.Create( "DButton", self )
    inboxButton:SetSize( BRICKS_SERVER.Func.ScreenScale( 40 ), BRICKS_SERVER.Func.ScreenScale( 40 ) )
    inboxButton:SetPos( panelWide+outerMargin-inboxButton:GetWide(), ((outerMargin+35)/2)-(inboxButton:GetTall()/2) )
    inboxButton:SetText( "" )
    local Alpha = 0
    local inboxMat = Material( "bricks_server/invite.png" )
    inboxButton.Paint = function( self2, w, h )
        if( self2:IsDown() ) then
            Alpha = 0
        elseif( self2:IsHovered() ) then
            Alpha = math.Clamp( Alpha+5, 0, 35 )
        else
            Alpha = math.Clamp( Alpha-5, 0, 35 )
        end
    
        draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
        surface.SetAlphaMultiplier( Alpha/255 )
        draw.RoundedBox( 8, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
        surface.SetAlphaMultiplier( 1 )
    
        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 1 ) )
        surface.SetMaterial( inboxMat )
        local iconSize = BRICKS_SERVER.Func.ScreenScale( 24 )
        surface.DrawTexturedRect( (w/2)-(iconSize/2), (h/2)-(iconSize/2), iconSize, iconSize )
    end

    BRICKS_SERVER.Func.GangCreateInbox( self, inboxButton, false, 0, inboxButton:GetPos() )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_dashboard", PANEL, "DPanel" )
--PATH addons/bricks_gangs/lua/bricks_server/modules/gangs/submodules/associations/vgui/bricks_server_gangmenu_associations.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( gangTable )
    local panelTall = (ScrH()*0.65)-40

    local function CreateLoadingPopout()
        if( IsValid( self.popout ) ) then
            self.popout:Remove()
        end

        local popoutClose = vgui.Create( "DPanel", self )
        popoutClose:SetSize( self.panelWide, panelTall )
        popoutClose:SetAlpha( 0 )
        popoutClose:AlphaTo( 255, 0.2 )
        popoutClose.Paint = function( self2, w, h )
            surface.SetDrawColor( 0, 0, 0, 150 )
            surface.DrawRect( 0, 0, w, h )
            BRICKS_SERVER.Func.DrawBlur( self2, 2, 2 )
        end

        local popoutWide, popoutTall = self.panelWide*0.65, panelTall*0.25

        self.popout = vgui.Create( "DPanel", self )
        self.popout:SetSize( 0, 0 )
        self.popout:SizeTo( popoutWide, popoutTall, 0.2 )
        self.popout.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        end
        self.popout.OnSizeChanged = function( self2 )
            self2:SetPos( (self.panelWide/2)-(self2:GetWide()/2), (panelTall/2)-(self2:GetTall()/2) )
        end
        self.popout.ClosePopout = function()
            if( IsValid( self.popout ) ) then
                self.popout:SizeTo( 0, 0, 0.2, 0, -1, function()
                    if( IsValid( self.popout ) ) then
                        self.popout:Remove()
                    end
                end )
            end

            popoutClose:AlphaTo( 0, 0.2, 0, function()
                if( IsValid( popoutClose ) ) then
                    popoutClose:Remove()
                end
            end )
        end

        local actionButton = vgui.Create( "DButton", self.popout )
        actionButton:Dock( BOTTOM )
        actionButton:SetTall( 40 )
        actionButton:SetText( "" )
        actionButton:DockMargin( 25, 0, 25, 25 )
        local changeAlpha = 0
        actionButton.Paint = function( self2, w, h )
            if( not self2:IsDown() and self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            surface.SetAlphaMultiplier( 1 )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
            
            draw.SimpleText( BRICKS_SERVER.Func.L( "cancel" ), "BRICKS_SERVER_Font20", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        actionButton.DoClick = self.popout.ClosePopout

        local loadingPanel = vgui.Create( "DPanel", self.popout )
        loadingPanel:Dock( FILL )
        loadingPanel:DockMargin( 25, 10, 25, 10 )
        local loadingIcon = Material( "materials/bricks_server/loading.png" )
        loadingPanel.Paint = function( self2, w, h )
            surface.SetDrawColor( 255, 255, 255, 255 )
            surface.SetMaterial( loadingIcon )
            local size = 32
            surface.DrawTexturedRectRotated( w/2, h/2, size, size, -(CurTime() % 360 * 250) )
        
            draw.SimpleText( BRICKS_SERVER.Func.L( "loading" ), "BRICKS_SERVER_Font20", w/2, h/2+(size/2)+5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
        end
    end

    local topBar = vgui.Create( "DPanel", self )
    topBar:Dock( TOP )
    topBar:DockMargin( 10, 10, 10, 5 )
    topBar:SetTall( 40 )
    topBar.Paint = function( self2, w, h ) end

    local searchBarBack = vgui.Create( "DPanel", topBar )
    searchBarBack:Dock( FILL )
    local search = Material( "materials/bricks_server/search.png" )
    local Alpha = 0
    local Alpha2 = 20
    local searchBar
    local color1 = BRICKS_SERVER.Func.GetTheme( 2 )
    searchBarBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        if( searchBar:IsEditing() ) then
            Alpha = math.Clamp( Alpha+5, 0, 100 )
            Alpha2 = math.Clamp( Alpha2+20, 20, 255 )
        else
            Alpha = math.Clamp( Alpha-5, 0, 100 )
            Alpha2 = math.Clamp( Alpha2-20, 20, 255 )
        end
        
        draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
    
        surface.SetDrawColor( 255, 255, 255, Alpha2 )
        surface.SetMaterial(search)
        local size = 24
        surface.DrawTexturedRect( w-size-(h-size)/2, (h-size)/2, size, size )
    end
    
    searchBar = vgui.Create( "bricks_server_search", searchBarBack )
    searchBar:Dock( FILL )
    searchBar.OnEnter = function()
        CreateLoadingPopout()

        local canRequest, errorMsg, waitTime = BRICKS_SERVER.Func.RequestAssociationGangs( searchBar:GetValue() or "" )

        if( not canRequest ) then
            timer.Create( "BRS_ASSOCIATION_WAIT_" .. tostring( self ), (waitTime or 3), 1, function()
                local canRequest2, errorMsg2, waitTime2 = BRICKS_SERVER.Func.RequestAssociationGangs( searchBar:GetValue() or "" )
                if( not canRequest2 ) then
                    BRICKS_SERVER.Func.Message( errorMsg, BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
                end
            end )
        end
    end

    local scrollPanel = vgui.Create( "bricks_server_scrollpanel", self )
    scrollPanel:Dock( FILL )
    scrollPanel:DockMargin( 10, 0, 10, 10 )
    scrollPanel.Paint = function( self, w, h ) end 

    BRICKS_SERVER.Func.RequestAssociationGangs( "" )

    function self.RefreshPanel( gangTables )
        scrollPanel:Clear()

        if( not gangTables or table.Count( gangTables or {} ) <= 0 ) then
            local text = BRICKS_SERVER.Func.L( "gangNoneFound" )
            surface.SetFont( "BRICKS_SERVER_Font25" )
            local textX, textY = surface.GetTextSize( text )
            textX, textY = textX+30, textY+20

            scrollPanel.Paint = function( self, w, h ) 
                draw.RoundedBox( 5, (w/2)-(textX/2), (h/2)-(textY/2), textX, textY, BRICKS_SERVER.Func.GetTheme( 3 ) )

                draw.SimpleText( text, "BRICKS_SERVER_Font23", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            end 
        else
            scrollPanel.Paint = function( self, w, h ) end 
            
            for k, v in pairs( gangTables ) do
                local associationType = BRICKS_SERVER.Func.GangsGetAssociation( LocalPlayer():GetGangID(), k )

                local itemBack = vgui.Create( "DPanel", scrollPanel )
                itemBack:Dock( TOP )
                itemBack:DockMargin( 0, 0, 0, 5 )
                itemBack:SetTall( 100 )
                itemBack.Paint = function( self2, w, h )
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                end

                if( LocalPlayer():GangHasPermission( "RequestAssociations" ) ) then
                    for key, val in pairs( BRICKS_SERVER.DEVCONFIG.GangAssociationTypes ) do
                        local associationButton = vgui.Create( "DButton", itemBack )
                        associationButton:Dock( RIGHT )
                        associationButton:DockMargin( 0, 10, 10, 10 )
                        associationButton:SetWide( itemBack:GetTall()-20 )
                        associationButton:SetText( "" )
                        local Alpha, iconAlpha = 0, 0
                        local iconMat
                        BRICKS_SERVER.Func.GetImage( val.Icon or "flag.png", function( mat ) 
                            iconMat = mat 
                        end )
                        local isAssociation = associationType == key
                        associationButton.Paint = function( self2, w, h )
                            if( self2:IsHovered() and not self2:IsDown() ) then
                                Alpha = math.Clamp( Alpha+5, 0, 50 )
                            else
                                Alpha = math.Clamp( Alpha-5, 0, 50 )
                            end
        
                            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
        
                            surface.SetAlphaMultiplier( Alpha/255 )
                                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                            surface.SetAlphaMultiplier( 1 )

                            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
        
                            if( (self2:IsHovered() or isAssociation) and not self2:IsDown() ) then
                                iconAlpha = math.Clamp( iconAlpha+5, 20, 255 )
                            else
                                iconAlpha = math.Clamp( iconAlpha-5, 20, 255 )
                            end

                            surface.SetAlphaMultiplier( iconAlpha/255 )
                                if( iconMat ) then
                                    surface.SetDrawColor( (isAssociation and val.Color) or BRICKS_SERVER.Func.GetTheme( 6 ) )
                                    surface.SetMaterial( iconMat )
                                    local iconSize = 32
                                    surface.DrawTexturedRect( (w/2)-(iconSize/2), (h/2)-(iconSize/2), iconSize, iconSize )
                                end
        
                                draw.SimpleText( string.upper( key ), "BRICKS_SERVER_Font15", w/2, h-5, ((isAssociation and val.Color) or BRICKS_SERVER.Func.GetTheme( 6 )), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
                            surface.SetAlphaMultiplier( 1 )
                        end
                        associationButton.DoClick = function()
                            if( not isAssociation ) then
                                BRICKS_SERVER.Func.Query( val.Query, BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                                    net.Start( "BRS.Net.RequestGangAssociation" )
                                        net.WriteString( key )
                                        net.WriteUInt( k, 16 )
                                    net.SendToServer()
                                end )
                            else
                                BRICKS_SERVER.Func.Query( BRICKS_SERVER.Func.L( "gangDissolveAssociation" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ), BRICKS_SERVER.Func.L( "cancel" ), function() 
                                    net.Start( "BRS.Net.DissolveGangAssociation" )
                                        net.WriteUInt( k, 16 )
                                    net.SendToServer()
                                end )
                            end
                        end
                    end
                end

                local avatarBack = vgui.Create( "DPanel", itemBack )
                avatarBack:Dock( FILL )
                avatarBack:DockMargin( 15, 15, 15, 15 )
                local avatarBackSize = 70
                local avatarSize = (v.Icon and avatarBackSize*0.6) or 32
                avatarBack.Paint = function( self2, w, h )
                    local textStartPos = avatarBackSize+15

                    surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
                    draw.NoTexture()
                    BRICKS_SERVER.Func.DrawCircle( (h-avatarBackSize)/2+(avatarBackSize/2), h/2, avatarBackSize/2, 45 )
            
                    draw.SimpleText( (v.Name or BRICKS_SERVER.Func.L( "gangNone" )), "BRICKS_SERVER_Font23", textStartPos, h/2+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )
            
                    draw.SimpleText( BRICKS_SERVER.Func.L( "gangAssociationStatus", ((associationType and associationType) or BRICKS_SERVER.Func.L( "gangNeutral" )) ), "BRICKS_SERVER_Font17", textStartPos, h/2-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                end

                local gangIcon = vgui.Create( "bricks_server_gangicon", avatarBack )
                gangIcon:SetSize( avatarSize, avatarSize )
                gangIcon:SetPos( (avatarBackSize-avatarSize)/2, (avatarBackSize-avatarSize)/2 )
                gangIcon:SetIconURL( v.Icon or "bricks_server/question.png" )
            end
        end

        if( IsValid( self.popout ) ) then
            self.popout.ClosePopout()
        end
    end

    hook.Add( "BRS.Hooks.RefreshGangAssociations", self, function( self, gangTables )
        if( IsValid( self ) ) then
            if( gangTables ) then
                self.RefreshPanel( gangTables )
            else
                BRICKS_SERVER.Func.RequestAssociationGangs( searchBar:GetValue() or "" )
            end
        else
            hook.Remove( "BRS.Hooks.RefreshGangAssociations", self )
        end
    end )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_associations", PANEL, "DPanel" )
--PATH addons/mod_bitminers2/lua/bitminers2_config.lua:
BM2CONFIG = {}

//Setting this to false will disable the generator from making sound.
BM2CONFIG.GeneratorsProduceSound = true

//Dollas a bitcoins sells for. Dont make this too large or it will be too easy to make money
BM2CONFIG.BitcoinValue = 600

//This is a value that when raising or lowering will effect the speed of all bitminers.
//This is a balanced number and you should only change it if you know you need to. Small increments make big differences
BM2CONFIG.BaseSpeed = 0.003

//The higher this number, the faster the generator will loose fuel.
//You can use this to balance out more so they need to buy fuel more frequently
BM2CONFIG.BaseFuelDepletionRate = 0.9 --0.9 default


//This will allow you to change the default generator output level
BM2CONFIG.GeneratorPowerOutput = 10 --This should only be whole numbers, 10 == 1000W
--PATH addons/111mod/lua/autorun/client/cl_snow.lua:
if !system.IsWindows() then return end
local en = true -- false

local textures = {
    ['building_template/roof_template001a'] = 'building_template/roof_template001a',
    -- ['metal/metalroof006a'] = 'metal/metalroof006a', -- env_cubemap used on world geometry without rebuilding map. . ignoring: metal/metalroof006a
    ['props/tarpaperroof002a'] = 'props/tarpaperroof002a',
    -- ['metal/metalroof008a'] = 'metal/metalroof008a', -- env_cubemap used on world geometry without rebuilding map. . ignoring: metal/metalroof008a
    -- ['metal/metalroof004a'] = 'metal/metalroof004a', -- env_cubemap used on world geometry without rebuilding map. . ignoring: metal/metalroof004a
    ['concrete/concretefloor023a'] = 'concrete/concretefloor023a',
    ['nature/dirtfloor006a'] = 'nature/dirtfloor006a',
    ['nature/dirtfloor012a'] = 'nature/dirtfloor012a',
    ['nature/grassfloor002a'] = 'nature/grassfloor002a',
    ['cs_italy/tileroof01'] = 'cs_italy/tileroof01',
    -- ['concrete/concretefloor005a'] = 'concrete/concretefloor005a', -- env_cubemap used on world geometry without rebuilding map. . ignoring: concrete/concretefloor005a
    ['concrete/concretewall001a'] = 'concrete/concretewall001a', 
    ['concrete/concretefloor008a'] = 'concrete/concretefloor008a',
    ['concrete/concretefloor027a'] = 'concrete/concretefloor027a',
    ["TILE/INFROOFB"] = "tile/infroofb",
    -- дорога
    --['decals/parkings'] = 'decals/parkings',
    --['decals/parkinge'] = 'decals/parkinge',
    --['concrete/concretefloor033o'] = 'concrete/concretefloor033o', -- env_cubemap used on world geometry without rebuilding map. . ignoring: concrete/concretefloor033o
    --['concrete/concretefloor033k'] = 'concrete/concretefloor033k', -- env_cubemap used on world geometry without rebuilding map. . ignoring: concrete/concretefloor033k
    
}

-- local textures = {
    -- ["maps/rp_bangclaw_test22222/concrete/concretefloor033k_c17_3224_-2651_560"] = "concrete/concretefloor033k",
    -- ["maps/rp_bangclaw_test22222/concrete/concretefloor033a_3224_-2651_560"] = "concrete/concretefloor033a",
    -- ["CONCRETE/CONCRETEFLOOR023A"] = "concrete/concretefloor023a",
    -- ["maps/rp_bangclaw_test22222/concrete/concretefloor005a_3224_-2651_560"] = "concrete/concretefloor005a",
    -- ["maps/rp_bangclaw_test22222/concrete/concretefloor033o_3224_-2651_560"] = "concrete/concretefloor033o",
    -- ["NATURE/GRASSFLOOR002A"] = "nature/grassfloor002a",
    -- ["maps/rp_bangclaw_test22222/metal/metalroof008a_3224_-2651_560"] = "metal/metalroof008a",
    -- ["CONCRETE/CONCRETEFLOOR027A"] = "concrete/concretefloor027a",
    -- ["PROPS/TARPAPERROOF002A"] = "props/tarpaperroof002a",
    -- ["CS_ITALY/TILEROOF01"] = "cs_italy/tileroof01",
    -- ["TILE/INFROOFB"] = "tile/infroofb",
    -- ["CONCRETE/CONCRETEFLOOR008A"] = "concrete/concretefloor008a",
    -- ["BUILDING_TEMPLATE/ROOF_TEMPLATE001A"] = "building_template/roof_template001a",
    -- ["maps/rp_bangclaw_test22222/metal/metalroof004a_3208_509_-488"] = "metal/metalroof004a",
    -- ["maps/rp_bangclaw_test22222/metal/metalroof004a_3224_-2651_560"] = "metal/metalroof004a",
    -- ["maps/rp_bangclaw_test22222/nature/blendsandgrass008a_wvt_patch"] = "nature/grassfloor002a",
    -- ["maps/rp_bangclaw_test22222/concrete/concretefloor033k_c17_3208_509_-488"] = "concrete/concretefloor033k",
    -- ["maps/rp_bangclaw_test22222/metal/metalroof006a_3224_-2651_560"] = "metal/metalroof006a",
    -- ["maps/rp_bangclaw_test22222/metal/metalroof006a_3044_1624_-865"] = "metal/metalroof006a",
    -- ["CONCRETE/CONCRETEWALL001A"] = "concrete/concretewall001a",
    -- ["nature/blenddirtgrass006a"] = "nature/grassfloor002a",
    -- ["maps/rp_bangclaw_test22222/metal/metalroof005a_3224_-2651_560"] = "metal/metalroof005a",
    -- ["maps/rp_bangclaw_test22222/metal/metalroof004a_1048_1799_-864"] = "metal/metalroof004a"
-- }

	-- local textures = {
		-- ['concrete/concretefloor023a'] = 'concrete/concretefloor023a',
		-- ['cs_havana/woodm'] = 'cs_havana/woodm',
		-- ['concrete/concretefloor008a'] = 'concrete/concretefloor008a',
		-- ['concrete/concretewall001a'] = 'concrete/concretewall001a',
		-- ['concrete/concretefloor023a'] = 'concrete/concretefloor023a',
		-- ['building_template/roof_template001a'] = 'building_template/roof_template001a',
		-- ['props/tarpaperroof002a'] = 'props/tarpaperroof002a',
		-- ['tile/infroofb'] = 'tile/infroofb',
		-- ['nature/grassfloor002a'] = 'nature/grassfloor002a',
		-- ['nature/blenddirtgrass006a'] = 'nature/dirtfloor012a',
		-- ['cs_italy/tileroof01'] = 'cs_italy/tileroof01',
		-- ['concrete/concretefloor031a'] = 'concrete/concretefloor031a',
		-- ['maps/rp_bangclaw_test22222/metal/metalroof008a_3224_-2651_560'] = 'metal/metalroof008a',
		-- ['maps/rp_bangclaw_test22222/nature/blendsandsand008a_wvt_patch'] = 'nature/sandfloor009a',
		-- ['maps/rp_bangclaw_test22222/metal/metalroof004a_1048_1799_-864'] = 'metal/metalroof004a',
		-- ['maps/rp_bangclaw_test22222/metal/metalroof006a_3224_-2651_560'] = 'metal/metalroof006a',
		-- ['maps/rp_bangclaw_test22222/metal/metalroof004a_3224_-2651_560'] = 'metal/metalroof004a',
		-- ['maps/rp_bangclaw_test22222/metal/metalroof004a_3208_509_-488'] = 'metal/metalroof004a',
		-- ['maps/rp_bangclaw_test22222/concrete/concretefloor033a_3224_-2651_560'] = 'concrete/concretefloor033a',
		-- ['maps/rp_bangclaw_test22222/concrete/concretefloor033k_c17_3224_-2651_560'] = 'concrete/concretefloor033k',
		-- ['maps/rp_bangclaw_test22222/concrete/concretefloor033k_c17_3208_509_-488'] = 'concrete/concretefloor033k',
		-- ['maps/rp_bangclaw_test22222/concrete/concretefloor033o_3224_-2651_560'] = 'concrete/concretefloor033o',
		-- ['maps/rp_bangclaw_test22222/nature/blendsandgrass008a_wvt_patch'] = 'nature/sandfloor009a',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_-1205_656_-96'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_-1702_944_68'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_-1905_-1568_102'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_-190_4773_-556'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_-198_-580_-660'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_-2000_-5152_120'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_-3628_2919_-136'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_1007_-926_-136'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_1152_7040_32'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_1280_6144_-136'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_2656_3245_-136'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_2706_-1563_-136'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_276_-6314_-89'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_2912_6976_-48'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_4976_1759_-136'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/nature3/road1_832_1600_-119'] = 'nature3/road1',
		-- ['maps/rp_downtown_tits_v2/cliff3/bigsand1_276_-6314_-89'] = 'cliff3/bigsand1',
		-- ['maps/rp_downtown_tits_v2/cliff3/bigsand1_-2000_-5152_120'] = 'cliff3/bigsand1',
		-- ['maps/rp_downtown_tits_v2/cliff3/bigsand1_4416_-1664_-96'] = 'cliff3/bigsand1',
		-- ['maps/rp_downtown_tits_v2/cliff3/bigsand1_9180_-6924_-238'] = 'cliff3/bigsand1',
		-- ['wood/inffence01'] = 'wood/inffence01',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_-1205_656_-96'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_-1702_944_68'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_-1824_1584_30'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_-1905_-1568_102'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_-190_4773_-556'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_-196_928_-576'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_-198_-580_-660'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_-2000_-5152_120'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_-3628_2919_-136'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_1007_-926_-136'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_1152_7040_32'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_1280_6144_-136'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_2656_3245_-136'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_2706_-1563_-136'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_276_-6314_-89'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_2912_6976_-48'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_4416_-1664_-96'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_4976_1759_-136'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_7781_7683_2653'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_832_1600_-119'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_9180_-6924_-238'] = 'concrete/concretefloor0028c',
		-- ['maps/rp_downtown_tits_v2/concrete/concretefloor028c_9344_-9728_-101'] = 'concrete/concretefloor0028c',
		-- ['concrete/concretefloor009a'] = 'concrete/concretefloor009a',
		-- ['maps/rp_downtown_tits_v2/cs_italy/cobble03_-1905_-1568_102'] = 'cs_italy/cobble03'
	-- }

local function CreateTexture(texturefile)
    local texmat = CreateMaterial("_" .. texturefile .. "_texmat", "UnlitGeneric", {
        ["$basetexture"] = texturefile
    })

    if not texmat then
        error("material was not created for " .. texturefile)
    end

    return texmat:GetTexture"$basetexture"
end

local function ReplaceTexture(matname, texturefile, texturename)
    if not matname or not texturefile then return end
    texturename = texturename or "$basetexture"
    local texture = CreateTexture(texturefile)
    if not texture then return end

    if type(matname) ~= "table" then
        matname = {matname}
    end

    if en == false then
        local col = Vector(.45, .45, .45)

        for k, v in pairs(matname) do
            Material(v):SetVector("$color", col)
            Material(v):SetTexture(texturename, texture)
        end
		
    elseif en == true then
        local col2 = Vector(1, 1, 1)

        for k, v in pairs(matname) do
            Material(v):SetVector("$color", col2)
            Material(v):SetTexture(texturename, texture)
        end
    end
	
end

local function UpdateSnowTextures(a)
    for k, v in pairs(textures) do
        ReplaceTexture({k}, not a and "nature/snowfloor001a" or v)
    end
end

-- concommand.Add("enablesnow", function()
	-- if !system.IsWindows() then chat.AddText(Color(255,0,0),"На вашей OS снег не стабилен, извините!") return end
    -- en = not en
    -- UpdateSnowTextures(en)
    -- chat.AddText(Color(255, 0, 0), "[GambitRP] ", Color(255, 255, 255), en and "Снег выключен!" or "Снег включен!")
-- end)

-- LocalPlayer():ConCommand('enablesnow')

local function EnSnow()
	if !system.IsWindows() then chat.AddText(Color(255,0,0),"На вашей OS снег не стабилен, извините!") return end
    en = not en
    UpdateSnowTextures(en)
    chat.AddText(Color(255, 0, 0), "[GambitRP] ", Color(255, 255, 255), en and "Снег выключен!" or "Снег включен!")
end

concommand.Add("enablesnow",EnSnow)

-- hook.Add( "InitPostEntity", "EnSnowGambit", function()
	-- timer.Simple( 3.5, function() EnSnow() end )
-- end )

--PATH addons/timesystem/lua/autorun/client/cl_timesys.lua:
surface.CreateFont( "timefont", {
	font = "Open Sans",
	size = 30,
	weight = 780,
	antialias = true,
})

local function timeToStr(time)
    local tmp = time / 60 / 60

    if tmp < 1 then
        tmp = math.Round(tmp * 60)
        return tmp .. " минут"
    elseif tmp < 10 then
        local minutes = tmp - math.floor(tmp)
        minutes = (math.Round(minutes * 60))
        return math.floor(tmp) .. ":" .. Format("%.2d", minutes) .. " h"
    else
        tmp = math.Round(tmp)
        return tmp ..  " часов"
    end
end

hook.Add("HUDPaint","pizda",function()
	--draw.SimpleText("Наиграл: "..timeToStr(LocalPlayer():GetNW2Int("playtime")),"timefont",ScrW()/15,25,Color(255,60,0,255),TEXT_ALIGN_CENTER)
    --draw.SimpleText("Время таймера: "..LocalPlayer():GetNW2Int("playtime"),"timefont",ScrW()/15,50,Color(255,60,0,255),TEXT_ALIGN_CENTER)
end)
--PATH addons/unbox/lua/autorun/client/cl_unboxing_2.lua:
include("unbox_config_2.lua")
BUC2.History = {}
BUC2.buttonsLocked = false

surface.CreateFont("ub2_1", {
    font = "Open Sans Semibold", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
    size = 19,
    weight = 8000,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false,
    extended = true
})

surface.CreateFont("ub2_2", {
    font = "Open Sans Semibold", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
    size = 13,
    weight = 10,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false,
    extended = true
})

surface.CreateFont("ub2_3", {
    font = "Open Sans Semibold", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
    size = 30,
    weight = 8000,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false,
    extended = true
})

surface.CreateFont("ub2_4", {
    font = "Open Sans Semibold", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
    size = 24,
    weight = 8000,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false,
    extended = true
})

surface.CreateFont("ub2_5", {
    font = "Open Sans Semibold", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
    size = 85,
    weight = 8000,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = true,
    additive = false,
    outline = true,
    extended = true
})

surface.CreateFont("ub2_6", {
    font = "Open Sans Semibold", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
    size = 45,
    weight = 8000,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = true,
    additive = false,
    outline = true,
    extended = true
})

surface.CreateFont("ub2_7", {
    font = "Open Sans Semibold", -- Use the font-name which is shown to you by your operating system Font Viewer, not the file name
    size = 16,
    weight = 8000,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false,
    extended = true
})

local function divColor(clr, x)
    return Color(clr.r / x, clr.g / x, clr.b / x)
end

local ButtonBlur = Material("opencase/button_blur.png")
local headerHight = 30

local ubButtons = {
    ["Shop"] = {
        Name = "Магазин",
        Icon = Material"opencase/icons/shop.png",
        Color = Color(0, 152, 226),
        Order = 1
    },
    ["Crate"] = {
        Icon = Material"opencase/icons/inventory.png",
        Color = Color(255, 196, 0),
        Order = 3
    },
    ["Spin"] = {
        Hidden = true,
        Order = 99
    },
}

local ub_createSpin

-- Old (poorly coded) unbox api
local poorApi = {
    pages = {},
}

local ubFrame = nil
local ubPage = "Crate"
local isOpen = false
local p = FindMetaTable("Panel")
--local inventoryBackground = Material("bu2/inventory_background.png","smooth noclamp")
--local spinBackground = Material("bu2/spin_bg.png","smooth noclamp")
--local spinGlass = Material("bu2/spin_glass.png","smooth noclamp")
local itemShadowMat = Material("bu2/item_shadow.png", "smooth noclamp")
local itemBackgroundMat = Material"opencase/bluredcircle.png"
--local itemBannerMat = Material("bu2/item_banner.png","smooth noclamp")
local moneyIcon = Material("bu2/money.png", "smooth noclamp")
local OpenCase_Panel = {}
local frameColor = Color(30, 35, 39, 255)

local function FixCam(self)
    local min, max = self.Entity:GetRenderBounds()
    self:SetFOV(80)
    self:SetCamPos(min:Distance(max) * Vector(0.43, 0.43, 0))
    self:SetLookAt((max + min) / 2)
end

--local function ub_findByIGSid(itemID)
--    for k, v in pairs(BUC2.ITEMS) do
--       if v.weaponName == itemID or v.amount == itemID then return k end
--   end
--end
net.Receive("AcceptGroup", function()
    local group = net.ReadString()
    ui.BoolRequest("Выдача привилегии", "Подтвердите выдачу " .. group .. " вместо вашей текущей привилегии!", function(bool)
        if bool == true then
            net.Start("AcceptGroupBool")
                net.WriteString(group)
            net.SendToServer()
        end
    end)
end)

net.Receive("ub_annouceunbox", function()
    local player = net.ReadEntity()
    local items = net.ReadTable()

    local msg = {player:Name(), team.GetColor(player:Team()), Color(255, 255, 255, 255), " Открыл кейс и получил -> ",}

    for i, itemID in pairs(items) do
        local itemName = BUC2.ITEMS[itemID].name1
        local itemColor = BUC2.ITEMS[itemID].color

        if i ~= 1 then
            table.Add(msg, {Color(255, 255, 255), ", "})
        end

        table.Add(msg, {itemColor, itemName})
    end

    table.Add(msg, {Color(255, 255, 255, 255), " /unbox"})

    --Print the message
    chat.AddText(unpack(msg))
end)

local function GenerateOutline(self)
    local x = 4
    local w, h = self:GetSize()

    self.OutlineTop = {
        {
            x = 0,
            y = x
        },
        {
            x = x,
            y = 0
        },
        {
            x = w - x,
            y = 0
        },
        {
            x = w,
            y = x
        },
    }

    self.OutlineBottom = {
        {
            x = x,
            y = h
        },
        {
            x = 0,
            y = h - x
        },
        {
            x = w,
            y = h - x
        },
        {
            x = w - x,
            y = h
        },
    }
end

local SizeW = ScrW() <= 800 and (800 + 10) or 982
local resultWin = ScrW() <= 800 and 88 or 89

local ModelPanel = CompileFile"unbox/modelpanel.lua"{
    outline = GenerateOutline,
    cam = FixCam,
    mat1 = itemBackgroundMat,
    mat2 = moneyIcon
}

local CratePanel = CompileFile"unbox/crate.lua"()

function initUnboxFrame()
    local money = net.ReadUInt(32)

    if IsValid(sdasdasdsadasd) then
        sdasdasdsadasd:Remove()
    end

    BUC2.buttonsLocked = false
    ubPage = "Crate"
    isOpen = true
    ubFrame = vgui.Create("DFrame")
    sdasdasdsadasd = ubFrame
    ubFrame:SetSize(SizeW + 10, ScrH() <= 600 and 600 or 700)
    ubFrame:Center()
    ubFrame:SetDraggable(false)
    ubFrame:SetVisible(true)
    ubFrame:U_PaintFrame()
    ubFrame:ShowCloseButton(false)
    ubFrame:MakePopup()
    -- remove dframe default title
    ubFrame:SetTitle""
    ubFrame:DockPadding(5, 0, 5, 5)
    local close_button = vgui.Create("DButton")
    close_button:MakePopup()
    close_button:NoClipping(true)
    close_button:SetSize(32, 32)
    close_button:SetText""
    close_button:RequestFocus()

    close_button.Paint = function(self, w, h)
        surface.SetDrawColor(frameColor)
        surface.DrawRect(0, 0, w, h)
        draw.SimpleText("X", "DermaLarge", w / 2, h / 2, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        DisableClipping(true)
        draw.NoTexture()

        surface.DrawPoly({
            {
                x = -w * 1.5,
                y = h
            },
            {
                x = 0,
                y = 0
            },
            {
                x = 0,
                y = h
            }
        })

        DisableClipping(false)
    end

    close_button.DoClick = function(self)
        if BUC2.buttonsLocked then return end

        if IsValid(ubFrame) then
            ubFrame:Remove()
        else -- is it possible?
            self:Remove()
        end
    end

    ubFrame.PerformLayout = function(self, w, h)
        local x, y = self:GetPos()
        close_button:SetPos(x + w - 32, y - 32)
    end

    ubFrame.OnRemove = function()
        BUC2.buttonsLocked = false
        isOpen = false

        if IsValid(close_button) then
            close_button:Remove()
        end
    end

    --ubFrame.historyHeader = vgui.Create("EditablePanel", ubFrame)
    --ubFrame.historyHeader:DockMargin(5, 5, 5, 10)
    --ubFrame.historyHeader:Dock(TOP)
    --ubFrame.historyHeader:SetTall(115)
    --ubFrame.historyHeader.Fill = function(self, data)
    --    self:Clear()
    --   for k, v in pairs(data) do
    --       local id = ub_findByIGSid(v)
    --       if not id then continue end
    --       local t = vgui.CreateFromTable(ModelPanel, self)
    --       t:Dock(LEFT)
    --       t:DockMargin(5, 0, 10, 0)
    --       t:SetWide(100)
    --       t:Set(id)
    --   end
    --end
    --ubFrame.historyHeader:Fill(BUC2.History)
    local buttonsPanel = vgui.Create("EditablePanel", ubFrame)
    buttonsPanel:Dock(TOP)
    buttonsPanel:SetTall(35)
    buttonsPanel:DockMargin(5, 0, 5, 5)
    ubFrame.scroller = vgui.Create("DHorizontalScroller", ubFrame)
    ubFrame.scroller:Dock(FILL)
    ubFrame.scroller:SetShowDropTargets(false)
    ubFrame.scroller.btnLeft.Paint = nil
    ubFrame.scroller.btnRight.Paint = nil
    ubFrame.scroller.GetScroll = function(self) return self.OffsetX end
    ubFrame.scroller.OnMouseWheeled = nil
    --ubFrame.scroller:SetOverlap( -100 )
    ubFrame.scroller:InvalidateParent(true)

    local function CreatePage(id, data)
        local btn = vgui.Create("DButton", buttonsPanel)

        if data.Hidden then
            btn:SetVisible(false)
        end

        btn:Dock(LEFT)
        btn:DockMargin(0, 0, 10, 0)
        btn:SetText""
        btn.Name = data.Name
        btn.Icon = data.Icon
        btn.Color = data.Color

        btn.CalculateSize = function(self)
            if self.Name then
                surface.SetFont("ub2_3")
                local w, h = surface.GetTextSize(self.Name)
                self:SetWide(w + 4 + 32 + 4 + 15)
            else
                self:SetWide(4 + 32 + 4)
            end
        end

        btn:CalculateSize()

        btn.Paint = function(self, w, h)
            local clr = self.Color or Color(27, 151, 223)
            clr = active == self and divColor(clr, 1.5) or self:IsDown() and divColor(clr, 2) or self:IsHovered() and divColor(clr, 1.75) or clr
            DisableClipping(true)
            surface.SetDrawColor(clr)
            surface.SetMaterial(ButtonBlur)
            surface.DrawTexturedRect(-w / 10, -h / 3.4, w + w / 5, h + h / 1.7)
            DisableClipping(false)
            draw.RoundedBox(0, 0, 0, w, h, clr)
            surface.SetDrawColor(255, 255, 255)
            surface.SetMaterial(self.Icon)
            surface.DrawTexturedRect(4, h / 2 - 16, 32, 32)
            draw.SimpleText(self.Name, "ub2_3", 32 + 4 + 4, h / 2 - 2, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER) --[[center font]]
        end

        local page = vgui.Create("DScrollPanel", ubFrame.scroller)
        page:Dock(LEFT)
        page:SetWide(SizeW)
        page.Paint = function() end
        page:InvalidateParent(true)
        poorApi.pages[id] = page

        btn.DoClick = function(self)
            if BUC2.buttonsLocked then return end
            ub_Goto(id)
        end

        ubFrame.scroller:AddPanel(page)
    end

    for id, data in SortedPairsByMemberValue(ubButtons, "Order") do
        CreatePage(id, data)
    end

    local igs_money = vgui.Create("EditablePanel", buttonsPanel)
    igs_money:Dock(RIGHT)
    igs_money:DockMargin(0, 0, 10, 0)
    igs_money:SetText""
    local last

    igs_money.CalculateSize = function(self)
        surface.SetFont("ub2_3")
        local w, h = surface.GetTextSize(self.Text)
        self:SetWide(w + 4 + 32 + 4 + 8)
    end

    igs_money.Paint = function(self, w, h)
        local igs = money

        if last ~= igs then
            last = igs
            self.Text = igs .. " ₽"
            self:CalculateSize()
        end

        draw.RoundedBox(0, 0, 0, w, h, Color(92, 137, 52))
        draw.SimpleText(self.Text, "ub2_3", 32 + 4 + 4, h / 2 - 2, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER) --[[center font]]
    end

    local plus = vgui.Create("DButton", igs_money)
    plus:Dock(LEFT)
    plus:SetWide(32)
    plus:SetText""

    plus.Paint = function(self, w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(145, 235, 65))
        draw.SimpleText("+", "DermaLarge", w / 2, h / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    plus.DoClick = function(self)
        if BUC2.buttonsLocked then return end
        local w, h = ScrW() * 0.5, ScrH() * 0.3
        local bg = vgui.Create('svyanovlib_DFrame')
        bg:SetSize(w, h)
        bg:centerFrame()
        bg:addClose()
        bg.title = "На сколько кредитов хотите пополнить баланс?"
        bg.titleSize = 20
        bg.titleX = w / 2
        local htmlBg = bg:Add('svyanovlib_DPanel')
        htmlBg:SetSize(w - 10, h - 30)
        htmlBg:SetPos(5, 25)

        function htmlBg:Paint(w, h)
            svyanovlib.drawBox(0, 0, w, h)
        end

        local TextEntry = vgui.Create("DNumberWang", htmlBg)
        TextEntry:SetPos(htmlBg:GetWide() / 2, 10)
        TextEntry:SetSize(250, 25)
        TextEntry:SetText("Введите количество")
        TextEntry:SetMin(1)
        TextEntry:CenterHorizontal()
        TextEntry.OnEnter = function(self) end
        local cb = htmlBg:Add('svyanovlib_DButton')
        local c2 = htmlBg:Add('svyanovlib_DButton')
        cb:SetVisible(false)
        c2:SetVisible(false)

        local function encode(str)
            str = string.gsub(str, "\r?\n", "\r\n")
            str = string.gsub(str, "([^%w%-%.%_%~ ])", function(c) return string.format("%%%02X", string.byte(c)) end)
            str = string.gsub(str, " ", "+")

            return str
        end

		local function StartCbC2(val)
  		bg.title = "Пополняем баланс на "..val.." кредитов."
    
      		cb:SetPos( htmlBg:GetWide() + 10, 40 )
      		cb:SetSize( htmlBg:GetWide() - 10, htmlBg:GetTall() / 3 )
      		cb.text                  = 'Оплатить с помощью QIWI/Webmoney/Yandex/Карточки/Телефона'
      		cb.textSize              = 20
      		cb:CenterHorizontal()
      		function cb:DoClick()
      		local comment = 'ПОПОЛНЕНИЕ-СЧЕТА-НА-СЕРВЕРЕ-GambitRP{"Server":"GambitRP#000'.."Gravity1"..'","SteamID64":"'
      		comment=encode(comment)..tostring(LocalPlayer():SteamID64())..encode('"}')
      		local summa = val + val/100*5
      		local asumma,bsumma = math.modf(summa)
      		bsumma = bsumma * 100
      		gui.OpenURL("https://gambitrp.site/oplata/?sid="..LocalPlayer():SteamID().."&sum="..asumma)
        end

            c2:SetPos(htmlBg:GetWide() + 10, cb:GetTall() + 60)
            c2:SetSize(htmlBg:GetWide() - 10, htmlBg:GetTall() / 3)
            c2.text = 'Обновить баланс кредитов'
            c2.textSize = 20
            c2:CenterHorizontal()

            function c2:DoClick()
                local summa = val
            	net.Start("Check_Pay")
            	net.SendToServer(LocalPlayer())
            end
        end

        hook.Add("OnTextEntryGetFocus", "paneeel", function(panel)

            if panel:GetName() == "DNumberWang" and panel:GetText() == "Введите количество" then
                panel:SetValue(1)
                cb:SetVisible(true)
                c2:SetVisible(true)
                StartCbC2(1)
            end
        end)

        function TextEntry:OnValueChanged(val)
            if isnumber(val) and val >= 1 then
                cb:SetVisible(true)
                c2:SetVisible(true)
                StartCbC2(val)
            end
        end
    end

    poorApi.pages.Crate.Paint = function(s, w, h)
        --[[surface.SetDrawColor(255,255,255,255)
		surface.SetMaterial(inventoryBackground)
		surface.DrawTexturedRect(0,0,w,h)]]
        --draw.RoundedBox( 0, 0, 0, w, h, Color( 0, 255, 0 ) )
        if LocalPlayer().ubinv == nil or table.Count(LocalPlayer().ubinv) == 0 then
            draw.SimpleText("ПУСТО:(", "ub2_5", w / 2, h / 2, Color(255, 255, 255, 255), 1, 1)
        end
    end

    ub_CreateInventory()
    ub_createShop(money)
    ub_createSpin()
    ubFrame.scroller:ScrollToChild(poorApi.pages.Shop) -- todo: Shop
end

local diagBack = Material("bu2/dialog_background.png", "noclamp smooth")

function ub_refreshInventory()
    if isOpen then
        poorApi.pages.Crate:Clear()
        ub_CreateInventory()
    end
end

function createTansactionWindow(itemID, Amount, money)
    local buyWindow = vgui.Create("DFrame")
    buyWindow:SetSize(400, 200)
    buyWindow:Center()
    buyWindow:SetTitle("")
    buyWindow:ShowCloseButton(false)
    buyWindow.itemID = itemID
    buyWindow.Amount = Amount
    buyWindow:SetText("")

    buyWindow.Paint = function(s, w, h)
        Derma_DrawBackgroundBlur(s, CurTime())
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(diagBack)
        surface.DrawTexturedRect(0, 0, w, h)
        draw.SimpleText("Чек", "ub2_6", 200, 60, Color(255, 255, 255), 1, 1)
        draw.SimpleText("Кейс : " .. BUC2.ITEMS[s.itemID].name1, "ub2_4", 200, 90, Color(255, 255, 255), 1, 1)
        draw.SimpleText("Количество : " .. s.Amount, "ub2_4", 200, 115, Color(255, 255, 255), 1, 1)
        draw.SimpleText("Цена: " .. (BUC2.ITEMS[s.itemID].price * s.Amount) .. "₽", "ub2_4", 200, 115 + 25, Color(255, 255, 255), 1, 1)
    end

    buyWindow:SetVisible(true)
    buyWindow:MakePopup()
    local cb = vgui.Create("DButton", buyWindow)
    cb:SetPos(23, 200 - 35)
    cb:SetSize(200 - 60, 23)
    cb:SetText("")
    cb.p = buyWindow

    cb.Paint = function(s, w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(30, 150, 30))
        draw.SimpleText("ОТМЕНА", "ub2_2", math.floor(w / 2), math.floor(h / 2), Color(255, 255, 255, 255), 1, 1)
    end

    cb.DoClick = function(s)
        s.p:Close()
    end

    local bb = vgui.Create("DButton", buyWindow)
    bb:SetPos(400 - 23 - (200 - 60), 200 - 35)
    bb:SetSize(200 - 60, 23)
    bb:SetText("")
    bb.itemID = itemID
    bb.Amount = Amount
    bb.parent = buyWindow
    bb.price = BUC2.ITEMS[itemID].price * Amount
    bb.canBuy = false

    bb.Paint = function(s, w, h)
        local c = Color(30, 150, 30)

        if not BUC2.BuyItemsWithPoints and not BUC2.BuyItemsWithPoints2 then
            if money < s.price then
                s.canBuy = false
                c = Color(90, 90, 90)
            else
                s.canBuy = true
            end
        else
            if BUC2.BuyItemsWithPoints then
                if LocalPlayer():PS_HasPoints(s.price) == false then
                    s.canBuy = false
                    c = Color(90, 90, 90)
                else
                    s.canBuy = true
                end
            else
                if BUC2.BuyItemsWithPoints2 then
                    if LocalPlayer().PS2_Wallet.points < s.price then
                        s.canBuy = false
                        c = Color(90, 90, 90)
                    else
                        s.canBuy = true
                    end
                end
            end
        end

        draw.RoundedBox(0, 0, 0, w, h, c)
        draw.SimpleText("КУПИТЬ", "ub2_2", math.floor(w / 2), math.floor(h / 2), Color(255, 255, 255, 255), 1, 1)
    end

    bb.DoClick = function(s)
        if s.canBuy then
            net.Start("ub_purchase")
            net.WriteString(s.itemID)
            net.WriteInt(s.Amount, 8)
            net.SendToServer()
            s.parent:Close()
        end
    end
end

function ub_createShop(money)
    local xPos = 0
    local yPos = 0

    for k, v in pairs(BUC2.ITEMS) do
        if v.canBuy then
            local temp = vgui.CreateFromTable(CratePanel, poorApi.pages.Shop, "CratePanel")
            temp:SetSize(180, 180)
            temp:SetPos(xPos + 5, yPos + 10)
            temp:Set(v)
            local amountPanel = vgui.Create("DPanel", temp)
            amountPanel:Dock(BOTTOM)
            amountPanel:SetTall(30)

            amountPanel.Paint = function(s, w, h)
                --[[draw.RoundedBox(0,0,0,w , h , Color(30,40,50))

				surface.SetDrawColor(Color(0,0,0))

				surface.DrawLine(0,0,180,0)
				surface.DrawLine(0,29,180,29)
				surface.DrawLine(0,28,180,28)

				surface.DrawLine(0,0,0,30)
				surface.DrawLine(1,0,1,30)

				surface.DrawLine(179,0,179,30)
				surface.DrawLine(178,0,178,30)]]
                draw.RoundedBox(6, 5, 5, 80, 20, Color(0, 75, 0))
            end

            local plusAmount = vgui.Create("DButton", amountPanel)
            plusAmount:SetPos(5, 5)
            plusAmount:SetSize(20, 20)
            plusAmount:SetText("")

            plusAmount.Paint = function(s, w, h)
                draw.RoundedBox(6, 0, 0, w, h, Color(0, 152, 0))
                draw.SimpleText("-", "ub2_2", w / 2, h / 2, Color(255, 255, 255, 255), 1, 1)
            end

            plusAmount.DoClick = function(s)
                s.dis.Amount = s.dis.Amount - 1

                if s.dis.Amount < 1 then
                    s.dis.Amount = 1
                end
            end

            local minusAmount = vgui.Create("DButton", amountPanel)
            minusAmount:SetPos(180 / 2 - 5 - 20, 5)
            minusAmount:SetSize(20, 20)
            minusAmount:SetText("")

            minusAmount.Paint = function(s, w, h)
                draw.RoundedBox(6, 0, 0, w, h, Color(0, 152, 0))
                draw.SimpleText("+", "ub2_2", w / 2, h / 2, Color(255, 255, 255, 255), 1, 1)
            end

            minusAmount.DoClick = function(s)
                s.dis.Amount = s.dis.Amount + 1

                if s.dis.Amount > 16 then
                    s.dis.Amount = 16
                end
            end

            local amountDisplay = vgui.Create("DPanel", amountPanel)
            amountDisplay:SetPos(5 + 20, 5)
            amountDisplay:SetSize((180 / 2 - 20 - 20 - 5 - 5), 20)
            amountDisplay.Amount = 1

            amountDisplay.Paint = function(s, w, h)
                draw.SimpleText(s.Amount, "ub2_2", w / 2, h / 2, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end

            plusAmount.dis = amountDisplay
            minusAmount.dis = amountDisplay
            local buyButton = vgui.Create("DButton", amountPanel)
            buyButton:SetPos(180 / 2 + 5, 5)
            buyButton:SetSize(180 / 2 - 5 - 5, 20)
            buyButton.item = k
            buyButton.dis = amountDisplay

            buyButton.Paint = function(s, w, h)
                draw.RoundedBox(6, 0, 0, w, h, Color(0, 152, 0))
                draw.SimpleText((BUC2.ITEMS[s.item].price * s.dis.Amount) * 2 .. "₽", "ub2_2", 10, h / 2, Color(255, 255, 255, 255), 0, 1)
                draw.SimpleText((BUC2.ITEMS[s.item].price * s.dis.Amount) .. "₽", "ub2_1", 40, h / 2, Color(255, 0, 0, 255), 0, 1)
                surface.SetDrawColor(255, 255, 255, 255)
                surface.DrawLine(5, 5, w / 2 - 5, h - 5)
            end

            buyButton:SetText("")

            buyButton.DoClick = function(s)
                createTansactionWindow(s.item, s.dis.Amount, money)
            end

            temp:SetCursor"hand"

            temp.OnMouseReleased = function(s)
                --createTansactionWindow(s.item , s.dis.Amount)
                local t = BUC2.ITEMS[s.item].itemType

                if t == "Crate" then
                    initSpinMenu(s.item, true)
                    ub_Goto("Spin")
                end
            end

            temp.item = k
            temp.dis = amountDisplay
            xPos = xPos + 198

            if xPos > SizeW - 100 then
                xPos = 0
                yPos = yPos + 180 + 15
            end
        end
    end
end

function createModelModule(k, v, x, y)
    local temp = vgui.Create("DPanel", poorApi.pages.Crate)
    temp:SetSize(180, 180)
    temp:SetPos(x + 10, y + 10)
    temp.itemTable = v
    temp.itemType = v.itemType
    temp.outlinec = Color(0, 0, 0)

    temp.Paint = function(s, w, h)
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(itemShadowMat)
        surface.DrawTexturedRect(0, 0, 180, 180)
        local col = s.itemTable.color
        --[[ surface.SetDrawColor(col)
		surface.SetMaterial(itemBannerMat)
		surface.DrawTexturedRect(0,180,180,40)--]]
        --Draw text
        draw.SimpleText(s.itemTable.name1, "ub2_1", w / 2, 2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
    end

    --draw.SimpleText(s.itemTable.name2,"ub2_2",5,200,Color(255,255,255))
    local mod = vgui.Create("DModelPanel", temp)
    mod:SetPos(0, 0)
    mod:SetSize(180, 180)
    mod:SetModel(v.model)
    mod:SetAnimated(false)
    mod.ang = mod.Entity:GetAngles()

    function mod:LayoutEntity(Entity)
        if (self.bAnimated) then
            self:RunAnimation()
        end
    end

    FixCam(mod)
    local over = vgui.Create("DButton", temp)
    over:SetText("")
    over:SetPos(0, 0)
    over:SetSize(180, 180)
    over.col = Color(0, 0, 0, 255)
    over.alpha = 0
    over.itemID = k

    over.Paint = function(s, w, h)
        --draw.SimpleText("OPEN","ub2_3",180/2,180/2,Color(255,255,255 , s.alpha) , 1 , 1)
        if BUC2.ITEMS[s.itemID].itemType == "Weapon" then
            if BUC2.ITEMS[s.itemID].permanent then
                draw.RoundedBox(0, 0, 0, 180, 20, Color(255, 90, 90, 255))
                draw.SimpleText("PERMANENT", "ub2_1", 180 / 2, 10, Color(255, 255, 255), 1, 1)
            end
        end

        draw.RoundedBox(0, 0, 0, w, h, Color(40, 40, 40, s.alpha))
        surface.SetDrawColor(s.col)
        surface.DrawLine(0, 180, 180, 180)

        for i = 0, 1 do
            surface.DrawOutlinedRect(i, i, w - (i * 2), h - (i * 2))
        end
    end

    over.Think = function(s)
        if s:IsHovered() then
            s.col = Color(30, 150, 30)
            s.alpha = Lerp(10 * FrameTime(), s.alpha, 190)
        else
            s.col = Color(0, 0, 0)
            s.alpha = Lerp(10 * FrameTime(), s.alpha, 0)
        end
    end

    return over
end

function createPngModule(k, v, x, y)
    local temp = vgui.CreateFromTable(CratePanel, poorApi.pages.Crate, "CratePanel")
    temp:SetSize(180, 180)
    temp:SetPos(x + 5, y + 10)
    temp:Set(v)
    local over = vgui.Create("DButton", temp)
    over:SetText("")
    over:SetPos(0, 0)
    over:SetSize(180, 180)
    over.col = Color(0, 0, 0, 255)
    over.alpha = 0
    over.itemID = k

    over.Paint = function(s, w, h)
        draw.RoundedBox(0, 0, 0, w, h, Color(40, 40, 40, s.alpha))
        --draw.SimpleText("OPEN","ub2_3",180/2,180/2,Color(255,255,255 , s.alpha) , 1 , 1)
        surface.SetDrawColor(s.col)
        surface.DrawLine(0, 180, 180, 180)

        for i = 0, 1 do
            surface.DrawOutlinedRect(i, i, w - (i * 2), h - (i * 2))
        end
    end

    over.Think = function(s)
        if s:IsHovered() then
            s.col = Color(30, 150, 30)
            s.alpha = Lerp(10 * FrameTime(), s.alpha, 190)
        else
            s.col = Color(0, 0, 0)
            s.alpha = Lerp(10 * FrameTime(), s.alpha, 0)
        end
    end

    return over
end

local containPanel = nil

function generateTape(itemID)
    local totalChance = 0

    for k, v in pairs(BUC2.ITEMS[itemID].items) do
        v = BUC2.ITEMS[v]
        totalChance = totalChance + v.chance
    end

    local itemList = {}

    for i = 0, 99 do
        local num = math.random(1, totalChance)
        local prevCheck = 0
        local curCheck = 0
        local item = nil

        for k, v in pairs(BUC2.ITEMS[itemID].items) do
            v = BUC2.ITEMS[v]

            if v.itemType ~= "Key" and v.itemType ~= "Crate" then
                if num >= prevCheck and num <= prevCheck + v.chance then
                    item = v.name1
                end

                prevCheck = prevCheck + v.chance
            end
        end

        itemList[i] = item
    end

    return itemList
end

net.Receive("StartClientSpinAnimation", function()
    LocalPlayer():EmitSound("buttons/lever1.wav")
    local tbl = net.ReadTable()
    poorApi.pages.Spin:DoSpin(tbl)
end)

function initSpinMenu(itemID, check)
    if containPanel ~= nil then
        poorApi.pages.Spin:Clear()
        containPanel:Remove()
    end

    poorApi.pages.Spin.GetCaseID = function() return itemID end
    local opencaseblur = Material("opencase/opencase.png")
    opencaseblur:Recompute()
    local temp = vgui.CreateFromTable(CratePanel, poorApi.pages.Spin, "CratePanel")
    poorApi.pages.Spin.spinPanel = temp
    temp:Dock(TOP)
    temp:SetTall(225)
    temp:DockMargin(8, 10, 8, 0)
    temp:Set(BUC2.ITEMS[itemID])
    temp:SetTooltip()
    local red = Color(255, 0, 0)

    temp.PaintBackground = function(self, w, h)
        surface.SetDrawColor(red)
        surface.SetMaterial(opencaseblur)
        surface.DrawTexturedRect(0, 0, w, h)
        draw.SimpleText(self.itemTable.name1, "ub2_3", w / 2, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
    end

    --draw.RoundedBox( 0, 0, 0, w, h, Color( 255, 100, 100, 100 ) )
    if not check then
        local color = Color(255, 24, 24)
        local OpenButton = vgui.Create("DButton", temp)
        OpenButton:SetPos((3 * SizeW / 4) - 75, 225 / 2 - 20)
        OpenButton:SetSize(166, 40)
        OpenButton:SetText""
        OpenButton.Mat = Material("opencase/icons/unbox.png")

        OpenButton.Paint = function(self, w, h)
            draw.RoundedBox(6, 0, 0, w, h, self:IsDown() and divColor(color, 1.75) or self:IsHovered() and divColor(color, 1.25) or color)
            surface.SetDrawColor(255, 255, 255)
            surface.SetMaterial(self.Mat)
            surface.DrawTexturedRect(10, h / 2 - 19 / 2 + 1, 24, 19)
            draw.SimpleText("ОТКРЫТЬ", "ub2_3", 44, h / 2, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        local tbl = {1, 2, 3, 5, 10}

        local count = table.Count(tbl)
        local Available = 0

        for k, v in pairs(LocalPlayer().ubinv) do
            if v == itemID then
                Available = Available + 1
                if Available == tbl[count] then break end
            end
        end

        if Available < 10 then
            tbl = {1, 2, 3, 4, 5}
        end

        for k, v in pairs(tbl) do
            if v > Available then
                tbl[k] = nil
            end
        end

        count = table.Count(tbl)
        local active = 1

        if count > 1 then
            local panel = vgui.Create("EditablePanel", temp)
            local size = count * 40 + (count - 1) * 1
            panel:SetPos((SizeW / 5) - size / 2, 225 / 2 - 20)
            panel:SetSize(size, 40)

            panel.Paint = function(self, w, h)
                draw.RoundedBox(0, 2, 0, w - 4, h, Color(73, 11, 11))
            end

            local color = Color(216, 12, 12)

            for k, v in next, tbl do
                local bt = vgui.Create("DButton", panel)
                bt:Dock(LEFT)
                bt:DockMargin(k == 1 and 0 or 1, 0, 0, 0)
                bt:SetWide(40)
                bt:SetText""

                if k ~= 1 and k ~= count then
                    bt.PaintBox = function(self, w, h)
                        draw.RoundedBox(0, 0, 0, w, h, active == v and divColor(color, 1.5) or self:IsDown() and divColor(color, 2) or self:IsHovered() and divColor(color, 1.75) or color)
                    end
                else
                    bt.PaintBox = function(self, w, h)
                        if k == 1 then
                            draw.RoundedBoxEx(6, 0, 0, w, h, active == v and divColor(color, 1.5) or self:IsDown() and divColor(color, 2) or self:IsHovered() and divColor(color, 1.75) or color, true, false, true, false)
                        else
                            draw.RoundedBoxEx(6, 0, 0, w, h, active == v and divColor(color, 1.5) or self:IsDown() and divColor(color, 2) or self:IsHovered() and divColor(color, 1.75) or color, false, true, false, true)
                        end
                    end
                end

                bt.Paint = function(self, w, h)
                    self:PaintBox(w, h)
                    draw.SimpleText(v, "ub2_3", w / 2, h / 2, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                end

                bt.DoClick = function(s)
                    active = v
                end
            end
        end

        OpenButton.requestSent = nil

        OpenButton.DoClick = function(self, w, h)
            if Available < active then return end

            if not self.requestSent then
                self.requestSent = true
                BUC2.buttonsLocked = true
                net.Start("BeginSpin")
                net.WriteString(itemID)
                net.WriteUInt(active, 4)
                net.SendToServer()
            end
        end
    end

    containPanel = vgui.Create("EditablePanel", poorApi.pages.Spin)
    containPanel:Dock(TOP)
    containPanel:DockMargin(0, 10, 0, 0)

    --Create All the Items Modules
    if BUC2.ITEMS[itemID] ~= nil then
        if BUC2.ITEMS[itemID].items ~= nil and table.Count(BUC2.ITEMS[itemID].items) > 0 then
            local xPos = 5
            local yPos = 10

            for k, v in pairs(BUC2.ITEMS[itemID].items) do
                local testPan = vgui.CreateFromTable(ModelPanel, containPanel)
                testPan:SetPos(xPos, yPos)
                testPan:SetSize(100, 110)
                testPan:Set(v)
                xPos = xPos + 100 + 9

                if xPos > SizeW - 50 then
                    xPos = 5
                    yPos = yPos + 100 + 20 + 9
                end
            end

            containPanel:SetTall(yPos + 110)
        end
    end
end

function ub_inventory_menu(itemID)
    local m = vgui.Create("DMenu")
    m:SetPos(gui.MouseX(), gui.MouseY())
    local t = BUC2.ITEMS[itemID].itemType

    if t == "Crate" then
        local t = m:AddOption("Открыть")
        t.id = itemID

        t.DoClick = function(s)
            initSpinMenu(s.id)
            ub_Goto("Spin")
        end
    end

    if t == "Entity" then
        local e = m:AddOption("Spawn", function(s)
            net.Start("ub_spawnEntity")
            net.WriteString(s.id)
            net.SendToServer()
            isOpen = false
            ubFrame:Close()
        end)

        e.id = itemID
    end

    if t == "Weapon" then
        m:AddOption("Equip", function(s)
            net.Start("ub_equipweapon")
            net.WriteString(itemID)
            net.SendToServer()
        end)

        m.id = itemID
    end

    local sm = m:AddSubMenu("Подарить")

    for k, v in player.Iterator() do
        if v ~= LocalPlayer() then
            local temp = sm:AddOption(v:Name(), function(s)
                net.Start("ub_giftitem")
                net.WriteString(s.id)
                net.WriteEntity(s.ply)
                net.SendToServer()
            end)

            temp.id = itemID
            temp.ply = v
        end
    end

    sm:AddSpacer()
    m:Open()
end

function ub_CreateInventory()
    if LocalPlayer().ubinv ~= nil and table.Count(LocalPlayer().ubinv) > 0 then
        local xPos = 0
        local yPos = 0

        for k, v in pairs(LocalPlayer().ubinv) do
            if v ~= nil and BUC2.ITEMS[v] ~= nil then
                local id = v
                v = BUC2.ITEMS[v]
                local pan = nil

                if v.itemType == "Key" or v.itemType == "Crate" then
                    pan = createPngModule(k, v, xPos, yPos)
                else
                    pan = createModelModule(k, v, xPos, yPos)
                end

                pan.itemID = id

                pan.DoClick = function(s)
                    ub_inventory_menu(s.itemID)
                end

                xPos = xPos + 198

                if xPos > SizeW - 100 then
                    xPos = 0
                    yPos = yPos + 190
                end
            end
        end
    end
end

local prevPos = 0

function ub_Goto(page)
    if page ~= ubPage then
        ubST = 0
        ubPage = page
    end

    local function navTo(pnl)
        if not IsValid(pnl) then return end
        local x, y = ubFrame.scroller:GetCanvas():GetChildPosition(pnl)
        local w, h = pnl:GetSize()
        x = x + w * 0.5
        x = x - ubFrame.scroller:GetWide() * 0.5

        --self:SetScroll( x )
        ubFrame.scroller.Think = function(self)
            self:SetScroll(Lerp(10 * FrameTime(), self:GetScroll(), x))

            if math.abs(x - self:GetScroll()) < 0.1 then
                self:SetScroll(x)
                self.Think = nil
            end
        end
    end

    navTo(poorApi.pages[page])
end

function p:U_PaintFrame()
    self.Paint = function(s, w, h)
        draw.RoundedBox(0, 0, 0, w, h, frameColor)
        surface.SetDrawColor(Color(0, 0, 0, 255))
        surface.DrawOutlinedRect(0, 0, w, h)
    end
end

net.Receive("ub_openui", function()
    if isOpen == false then
        initUnboxFrame()
    end
end)

function ub_hasItem(itemID)
    for k, v in pairs(LocalPlayer().ubinv) do
        if v == itemID then return true end
    end

    return false
end

net.Receive("ub_inventory_update", function()
    local len = net.ReadDouble()
    local e = net.ReadData(len)
    e = util.Decompress(e)
    e = util.JSONToTable(e)
    --Convert from ID'S to string ID's
    local i = {}

    for k, v in pairs(e) do
        for a = 1, v do
            table.insert(i, k)
        end
    end

    LocalPlayer().ubinv = i
    ub_refreshInventory()
end)

--[[net.Receive("ub_history_update", function()
    local tbl = util.JSONToTable(util.Decompress(net.ReadData(net.ReadUInt(8))))
    BUC2.History = tbl
    if not isOpen then return end
    if not IsValid(ubFrame) or not IsValid(ubFrame.historyHeader) then return end
    if not tbl then return end
    if table.Count(tbl) == 0 then return end
    ubFrame.historyHeader:Fill(tbl)
end)]]
net.Receive("unboxadmin", function()
    local isAllowed = false

    for k, v in pairs(BUC2.RanksThatCanGiveItems) do
        if LocalPlayer():GetUserGroup() == v then
            isAllowed = true
        end
    end
end)

function ub_giveitems()
    local frame = vgui.Create("DFrame")
    frame:SetSize(250, 160)
    frame:Center()
    frame:SetVisible(true)
    frame:SetTitle("Unboxing Admin Panel")
    frame:MakePopup()
    local item = vgui.Create("DComboBox", frame)
    item:SetPos(20, 35)
    item:SetSize(210, 20)
    item:SetValue("Select An Item")

    for k, v in pairs(BUC2.ITEMS) do
        if v.itemType ~= "Money" and v.itemType ~= "Points" and v.itemType ~= "Points2" and v.itemType ~= "PSItem" and v.itemType ~= "PSItem2" then
            item:AddChoice(k)
        end
    end

    local target = vgui.Create("DComboBox", frame)
    target:SetPos(20, 35 + 30)
    target:SetSize(210, 20)
    target:SetValue("Select A Player")

    for k, v in player.Iterator() do
        target:AddChoice(v:Name(), v)
    end

    local amount = vgui.Create("DTextEntry", frame)
    amount:SetPos(20, 35 + 30 + 30)
    amount:SetSize(210, 20)
    amount:SetText("Enter Amount")
    local give = vgui.Create("DButton", frame)
    give:SetPos(20, 35 + 30 + 30 + 30)
    give:SetSize(210, 20)
    give:SetText("Give")
    give.target = target
    give.item = item
    give.amount = amount

    give.DoClick = function(s)
        if BUC2.buttonsLocked then return end

        if BUC2.ITEMS[s.item:GetSelected()] ~= nil then
            local name, ply = s.target:GetSelected()

            if name ~= "Select A Player" and IsValid(ply) then
                local amount = tonumber(amount:GetValue())

                if amount ~= nil and amount > 0 and amount < 1000 then
                    net.Start("ub_admingiveitems")
                    net.WriteString(s.item:GetSelected())
                    net.WriteEntity(ply)
                    net.WriteInt(amount, 8)
                    net.SendToServer()
                end
            end
        end
    end
end

local SpinnerPanel = CompileFile"unbox/spinner.lua"{
    ModelPanel = ModelPanel,
    generateTape = generateTape,
    frameColor = frameColor,
    gradientL = gradientL,
    gradientR = gradientR,
}

function ub_createSpin()
    poorApi.pages.Spin.OnFinish = function(self)
        net.Start("SpinEnded")
        net.WriteBool(true)
        net.SendToServer()
        LocalPlayer():EmitSound("buttons/lever6.wav")

        timer.Simple(2.5, function()
            ub_Goto("Crate")
            BUC2.buttonsLocked = false
        end)
    end

    poorApi.pages.Spin.DoSpin = function(self, tbl)
        -- hide childs
        --[[ for k, v in pairs( self:GetChildren( ) ) do
			if v:GetName( ) ~= "Spinner" then
				v:SetVisible( false )
			end
		end--]]
        -- unnecessary, because it will be recreated on next attempt to spin
        if IsValid(self.spinPanel) then
            self.spinPanel:Remove()
        end

        local caseID = self:GetCaseID()
        local p = nil

        for i, id in next, tbl do
            local panel = vgui.CreateFromTable(SpinnerPanel, self, "Spinner")
            panel:Dock(TOP)
            panel:DockMargin(5, 5, 5, 5)
            panel:SetWide(SizeW)
            panel:SetTall(115)
            panel:SetID(caseID)
            panel:DoSpin(id)
            panel:SetZPos(-200)
            p = panel
        end

        if not IsValid(p) then
            BUC2.buttonsLocked = false

            return
        end

        p.OnFinish = self.OnFinish
    end
end
--[[ hook.Add("HUDPaint", "showskidd", function()
	if isOpen then
		local colorskidki = HSVToColor( CurTime() % 6 * 60, 1, 1 )
		colorskidki.a = 255
		draw.SimpleText("СКИДКИ ДО 90% НА ВСЕ КЕЙСЫ!","ub2_5",ScrW() / 2 , ScrH() / 2 - 350,colorskidki , 1 , 1)
	end
end)--]]
--PATH addons/111mod/lua/autorun/client/setka.lua:
// Written by Syranide, me@syranide.com
// fixed and updated by minifisch, mail@minifisch.net
// big thanks to Syranide! :)

if SERVER then
	AddCSLuaFile( "client.lua" )
end

if CLIENT then

local target =        { active = false }
local snaptarget =    { active = false }
local snapkey =       false
local snaptime =      false
local snaplock =      false
local snapclick =     false
local snapclickfade = 0
local snapcursor =    false
local snapspawnmenu = false

local cache = {
	vPlayerPos = 0,
	vLookPos = 0,
	vLookClipPos = 0,
	vLookVector = 0,
}

local condefs = {
	snap_enabled      = 1,
	snap_gcboost      = 1,
	snap_gcstrength   = 125,
	snap_hidegrid     = 0,
	snap_clickgrid    = 0,
	snap_toggledelay  = 0,
	snap_disableuse   = 0,
	-- snap_allentities  = 0,
	-- snap_alltools     = 0,
	snap_enabletoggle = 0,
	snap_lockdelay    = 0.5,
	snap_distance     = 250,
	snap_gridlimit    = 16,
	snap_gridsize     = 8,
	snap_gridalpha    = 0.4,
	snap_gridoffset   = 0.5,
	snap_boundingbox  = 1,
	snap_revertaim    = 1,
	snap_centerline   = 1,
}

local convars = {}

for key,value in pairs(condefs) do
	convars[#convars + 1] = key
end


local modelsaveset = {}
local modeloffsets = {}

---------

local function DrawScreenLine(vsA, vsB)
	surface.DrawLine(vsA.x, vsA.y, vsB.x, vsB.y)
end

local function ToScreen(vWorld)
	local vsScreen = vWorld:ToScreen()
	return Vector(vsScreen.x, vsScreen.y, 0)
end

local function PointToScreen(vPoint)
	if cache.vLookVector:Dot(vPoint - cache.vLookClipPos) > 0 then
		return ToScreen(vPoint)
	end
end

local function LineToScreen(vStart, vEnd)
	local dotStart = cache.vLookVector:Dot(vStart - cache.vLookClipPos)
	local dotEnd = cache.vLookVector:Dot(vEnd - cache.vLookClipPos)
	
	if dotStart > 0 and dotEnd > 0 then
		return ToScreen(vStart), ToScreen(vEnd)
	elseif dotStart > 0 or dotEnd > 0 then
		local vLength = vEnd - vStart
		local vIntersect = vStart + vLength * ((cache.vLookClipPos:Dot(cache.vLookVector) - vStart:Dot(cache.vLookVector)) / vLength:Dot(cache.vLookVector))
		
		if dotStart <= 0 then
			return ToScreen(vIntersect), ToScreen(vEnd)
		else
			return ToScreen(vStart), ToScreen(vIntersect)
		end
	end
end

local function RayQuadIntersect(vOrigin, vDirection, vPlane, vX, vY)
	local vp = vDirection:Cross(vY)

	local d = vX:Dot(vp)
	if (d <= 0.0) then return end

	local vt = vOrigin - vPlane
	local u = vt:Dot(vp)
	if (u < 0.0 or u > d) then return end

	local v = vDirection:Dot(vt:Cross(vX))
	if (v < 0.0 or v > d) then return end

	return Vector(u / d, v / d, 0)
end

------------

local function OnInitialize()
	for key,value in pairs(condefs) do
		CreateClientConVar(key, value, true, false)
	end

	for _,filename in ipairs(file.Find('smartsnap_offsets_*.png', "GAME")) do
		local file = file.Read(filename)
		if file then
			lines = string.Explode("\n", file)
			header = table.remove(lines, 1)
			if header == "SMARTSNAP_OFFSETS" then
				for _,line in ipairs(lines) do
					local pos = string.find(line, '=')
					if pos then
						 local key = string.lower(string.Trim(string.sub(line, 1, pos - 1)))
						 local value = string.Trim(string.sub(line, pos + 1))
						 
						 local c = string.Explode(",", value)
						 modeloffsets[key]= { tonumber(c[1]), tonumber(c[2]), tonumber(c[3]), tonumber(c[4]),  tonumber(c[5]),  tonumber(c[6])  }
					end
				end
			end
		end
	end
end
	
local function OnShutDown()
	output = file.Read('smartsnap_offsets_custom.png')
	if output == nil then
		output = "SMARTSNAP_OFFSETS\n"
	end
	
	for model,_ in pairs(modelsaveset) do
		output = output .. model .. '=' .. table.concat(modeloffsets[model], ",") .. "\n"
	end
	
	file.Write('smartsnap_offsets_custom.png', output)
end

local function GetDevOffset()
	local model = string.lower(target.entity:GetModel())

	if modeloffsets[model] == nil then
		modeloffsets[model] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }
	end
	
	return modeloffsets[model]
end

concommand.Add("snap_dev_alloffset", function(player, command, arguments) if target.active == true then if #arguments >= 1 then local v = GetDevOffset() for i=1,6 do v[i] = v[i] + tonumber(arguments[1]) end end end end)
concommand.Add("snap_dev_gridoffset", function(player, command, arguments) if target.active == true then if #arguments >= 1 then local v = GetDevOffset() v[target.face] = v[target.face] + tonumber(arguments[1]) end end end)
concommand.Add("snap_dev_saveoffset", function(player, command, arguments) if target.active == true then local v = GetDevOffset() modelsaveset[string.lower(target.entity:GetModel())] = true end end)

local function SnapToggleGrid()
	if (GetConVarNumber("snap_enabled") == 0) then
		RunConsoleCommand('snap_enabled', '1')
	else
		RunConsoleCommand('snap_enabled', '0')
	end
end

local function SnapPress()
	if GetConVarNumber("snap_clickgrid") != 0 and !snapclick then
		snapclick = true
		snapclickfade = CurTime()
	elseif GetConVarNumber("snap_clickgrid") == 0 or snapclick then
		if (snaplock or snapcursor) then
			snaptime = false
		else
			local toggledelay = GetConVarNumber("snap_toggledelay")
			if (toggledelay > 0 and snaptime and snaptime + toggledelay > CurTime()) then
				SnapToggleGrid()
				snaptime = false
				snaplock = false
			else
				snaptime = CurTime()
			end
		end
		
		snapkey = target.active
		
		if (!snapcursor) then
			snaplock = false
		end
	end
end

local function SnapRelease()
	snapkey = false
end

local function SnapLock()
	snaplock = !snaplock
end

local function OnSpawnMenu()
	snapspawnmenu = true
end

local function OnKeyPress(player, key)
	if (key == IN_USE and GetConVarNumber("snap_disableuse") == 0) then
		SnapPress()
	end
end

local function OnKeyRelease(player, key)
	if (key == IN_USE and GetConVarNumber("snap_disableuse") == 0) then
		SnapRelease()
	end
end

local function OnThink()
	if (vgui.CursorVisible()) then
		if (!snapcursor and snaplock) then
			snaptarget = table.Copy(target)
		end
		
		snaptime = false
		snapcursor = true
	else
		if (snapcursor and snaplock) then
			target = snaptarget
		end
		
		snapspawnmenu = false
		snapcursor = false
	end
	
	if (GetConVarNumber("snap_enabletoggle") != 0) then
		if (snapkey and snaptime and !snaplock) then
			if (CurTime() > snaptime + GetConVarNumber("snap_lockdelay")) then
				snaplock = true
				snaptime = false
			end
		end
	end
		
	local locked = target.locked and target.active
	target.locked = (snapkey or snaplock and !snapcursor) and target.active
	
	if (!target.locked and locked and GetConVarNumber("snap_revertaim") != 0) then
		if (snapcursor) then
			local screen = target.entity:LocalToWorld(target.vector):ToScreen()
			input.SetCursorPos(math.Round(screen.x), math.Round(screen.y))
		else
			local angles = (target.entity:LocalToWorld(target.vector) - LocalPlayer():GetShootPos()):Angle()
			LocalPlayer():SetEyeAngles(angles)
		end
	end
end

local function CalculateGridAxis(L)
	local length = L:Length()
	local grid   = math.Clamp(math.floor(length / (2 * GetConVarNumber("snap_gridsize"))) * 2, 2, GetConVarNumber("snap_gridlimit"))
	local offset = math.Clamp(GetConVarNumber("snap_gridoffset") / length, 0, 1 / grid)
	local scale  = 1 - offset * 2
	
	return {
		length = length,
		offset = offset,
		scale  = scale,
		grid   = grid,
	}
end

local function CalculateSnap(X, Y, v)
	local LX = CalculateGridAxis(X)
	local LY = CalculateGridAxis(Y)
	
	local BX = math.Clamp(math.Round(v.x * LX.grid), 0, LX.grid)
	local BY = math.Clamp(math.Round(v.y * LY.grid), 0, LY.grid)
	
	if BX == 1           and v.x <     (1 / LX.grid + LX.offset) / 2 then BX = 0 end
	if BX == LX.grid - 1 and v.x > 1 - (1 / LX.grid + LX.offset) / 2 then BX = LX.grid end
	if BY == 1           and v.y <     (1 / LY.grid + LY.offset) / 2 then BY = 0 end
	if BY == LY.grid - 1 and v.y > 1 - (1 / LY.grid + LY.offset) / 2 then BY = LY.grid end
	
	local RX = X * (BX / LX.grid)
	local RY = Y * (BY / LY.grid)
	
	if BX == 0       then RX = X * math.Clamp(LX.offset, 0, 1 / LX.grid) end
	if BX == LX.grid then RX = X * (1 - math.Clamp(LX.offset, 0, 1 / LX.grid)) end
	if BY == 0       then RY = Y * math.Clamp(LY.offset, 0, 1 / LY.grid) end
	if BY == LY.grid then RY = Y * (1 - math.Clamp(LY.offset, 0, 1 / LY.grid)) end
	
	return RX + RY
end

local function DrawGridLines(vOrigin, vSX, vSY, gridLines, offsetX, offsetY, sign)
	local centerline = (GetConVarNumber("snap_centerline") != 0)

	local vTemp = vOrigin + vSX * 0.5
	local vX = vTemp + vSY * (offsetY)
	local vY = vTemp + vSY * (1 - offsetY)

	local vOffset, temp
	local xtemp = ToScreen(vX) - ToScreen(vY)
	xtemp:Normalize()
	local vsNormal = xtemp
	
	if math.abs(vsNormal.x) < 1 - math.abs(vsNormal.y) then temp = -0.5 * sign else temp = 0.5 * sign end
	if math.abs(vsNormal.x) <     math.abs(vsNormal.y) then vsOffset = Vector(temp, 0, 0) else vsOffset = Vector(0, temp, 0) end

	if offsetX < 1 / gridLines then
		local vTemp = vOrigin + vSX * offsetX
		local vX = vTemp + vSY * offsetY
		local vY = vTemp + vSY * (1 - offsetY)
		
		local vsX, vsY = LineToScreen(vX, vY)
		if (vsX) then DrawScreenLine(vsX + vsOffset, vsY + vsOffset) end
	end
	
	for i = 1,gridLines-1 do
		local vTemp = vOrigin + vSX * (i / gridLines)
		local vX = vTemp + vSY * offsetY
		local vY = vTemp + vSY * (1 - offsetY)
		
		local vsX, vsY = LineToScreen(vX, vY)
		
		if (vsX) then
			if (gridLines / i == 2 && centerline) then
				DrawScreenLine(vsX + vsOffset * -1, vsY + vsOffset * -1)
				DrawScreenLine(vsX + vsOffset *  3, vsY + vsOffset *  3)
			else
				DrawScreenLine(vsX + vsOffset,      vsY + vsOffset)
			end
		end
	end
	
	if offsetX < 1 / gridLines then
		local vTemp = vOrigin + vSX * (1 - offsetX)
		local vX = vTemp + vSY * offsetY
		local vY = vTemp + vSY * (1 - offsetY)
		
		local vsX, vsY = LineToScreen(vX, vY)
		if (vsX) then DrawScreenLine(vsX + vsOffset, vsY + vsOffset) end
	end
end

local function DrawGrid(vOrigin, vSX, vSY)
	local LX = CalculateGridAxis(vSX)
	local LY = CalculateGridAxis(vSY)
	
	surface.SetDrawColor(0, 0, 0, math.Round(GetConVarNumber("snap_gridalpha") * 255))
	DrawGridLines(vOrigin, vSX, vSY, LX.grid, LX.offset, LY.offset, 1)
	DrawGridLines(vOrigin, vSY, vSX, LY.grid, LY.offset, LX.offset, 1)
	
	surface.SetDrawColor(255, 255, 255, math.Round(GetConVarNumber("snap_gridalpha") * 255))
	DrawGridLines(vOrigin, vSX, vSY, LX.grid, LX.offset, LY.offset, -1)
	DrawGridLines(vOrigin, vSY, vSX, LY.grid, LY.offset, LX.offset, -1)
end

local function DrawBoundaryLines(vOrigin, vOpposite)
	local vPoint
	
	if (vOrigin:Distance(vOpposite) > 5) then
	    local x = vOpposite - vOrigin
		x:Normalize()
		vPoint = vOrigin + x * 5
	else
		vPoint = vOrigin + (vOpposite - vOrigin) / 2
	end
	
	local vsA, vsB = LineToScreen(vPoint, vOrigin)
	
	if (vsA) then
		surface.SetDrawColor(0, 0, 255, 192)
		DrawScreenLine(vsA, vsB)
	end
end

local function DrawBoundary(vOrigin, vX, vY, vZ)
	DrawBoundaryLines(vOrigin, vX)
	DrawBoundaryLines(vOrigin, vY)
	DrawBoundaryLines(vOrigin, vZ)
end

local function DrawSnapCross(vsCenter, r, g, b)
	surface.SetDrawColor(0, 0, 0, 255)
	DrawScreenLine(vsCenter + Vector(-2.5, -2.0), vsCenter + Vector( 2.5,  3.0))
	DrawScreenLine(vsCenter + Vector( 1.5, -2.0), vsCenter + Vector(-3.5,  3.0))
	
	surface.SetDrawColor(r, g, b, 255)
	DrawScreenLine(vsCenter + Vector(-1.5, -2.0), vsCenter + Vector( 3.5,  3.0))
	DrawScreenLine(vsCenter + Vector( 2.5, -2.0), vsCenter + Vector(-2.5,  3.0))
end

local function ComputeEdges(entity, obbmax, obbmin)
	return {
		lsw = entity:LocalToWorld(Vector(obbmin.x, obbmin.y, obbmin.z)),
		lse = entity:LocalToWorld(Vector(obbmax.x, obbmin.y, obbmin.z)),
		lnw = entity:LocalToWorld(Vector(obbmin.x, obbmax.y, obbmin.z)),
		lne = entity:LocalToWorld(Vector(obbmax.x, obbmax.y, obbmin.z)),
		usw = entity:LocalToWorld(Vector(obbmin.x, obbmin.y, obbmax.z)),
		use = entity:LocalToWorld(Vector(obbmax.x, obbmin.y, obbmax.z)),
		unw = entity:LocalToWorld(Vector(obbmin.x, obbmax.y, obbmax.z)),
		une = entity:LocalToWorld(Vector(obbmax.x, obbmax.y, obbmax.z)),
	}
end

local function OnPaintHUD()
	target.active = false
	
	if GetConVarNumber("snap_clickgrid") != 0 and !snapclick then return end
	
	snapclickprev = snapclick
	snapclick = snapclickprev and snapclickfade > CurTime()
	
	if (GetConVarNumber("snap_enabled") == 0) then return end
	if (!LocalPlayer():Alive() or LocalPlayer():InVehicle()) then return end
	
	if (target.locked) then
		if (!target.entity:IsValid()) then return end
	else
		local trace = LocalPlayer():GetEyeTrace()
		cache.vLookTrace = trace
		if (!trace.HitNonWorld) then return end
		
		local entity = trace.Entity
		if (entity == nil) then return end
		if (!entity:IsValid()) then return end
		
		local class = entity:GetClass()
		if (class != 'prop_physics' and class != 'phys_magnet' and class != 'gmod_spawner' and GetConVarNumber('snap_allentities') == 0) then return end
		
		if (!LocalPlayer():GetActiveWeapon():IsValid()) then return end
		if (LocalPlayer():GetActiveWeapon():GetClass() == 'weapon_physgun') then return end
		if (LocalPlayer():GetActiveWeapon():GetClass() != 'gmod_tool' and GetConVarNumber('snap_alltools') == 0) then return end
		
		target.entity = entity
	end
	
	--ErrorNoHalt(collectgarbage("count"))
	if GetConVarNumber("snap_gcboost") != 0 then
		collectgarbage("step", GetConVarNumber("snap_gcstrength"))
	end
	
	snapclick = snapclickprev
	snapclickfade = CurTime() + 0.25
	
	-- updating the cache perhaps shouldn't be done here, CalcView?
	cache.vLookPos = LocalPlayer():GetShootPos()
	cache.vLookVector = LocalPlayer():GetAimVector()
	cache.vLookClipPos = cache.vLookPos + cache.vLookVector * 3

	local model = string.lower(target.entity:GetModel())
	local offsets = modeloffsets[model]
	
	if !offsets then
		local offset = 0.25
		offsets = { offset, offset, offset, offset, offset, offset }
	end
	
	if cache.eEntity != target.entity or cache.vEntAngles != target.entity:GetAngles() or vEntPosition != target.entity:GetPos() then
		cache.eEntity = target.entity
		cache.vEntAngles = target.entity:GetAngles()
		cache.vEntPosition = target.entity:GetPos()
		
		local obbmax = target.entity:OBBMaxs()
		local obbmin = target.entity:OBBMins()
		local obvsnap = ComputeEdges(target.entity, obbmax, obbmin)
		
		local obbmax = target.entity:OBBMaxs() - Vector(offsets[5], offsets[3], offsets[1])
		local obbmin =  target.entity:OBBMins() + Vector(offsets[6], offsets[4], offsets[2])
		local obvgrid = ComputeEdges(target.entity, obbmax, obbmin)
		
		local faces = {
			{ obvgrid.unw, obvgrid.usw - obvgrid.unw, obvgrid.une - obvgrid.unw, obvgrid.lnw - obvgrid.unw, Vector(0, 0, -offsets[1]) },
			{ obvgrid.lsw, obvgrid.lnw - obvgrid.lsw, obvgrid.lse - obvgrid.lsw, obvgrid.usw - obvgrid.lsw, Vector(0, 0,  offsets[2]) },
			{ obvgrid.unw, obvgrid.une - obvgrid.unw, obvgrid.lnw - obvgrid.unw, obvgrid.usw - obvgrid.unw, Vector(0, -offsets[3], 0) },
			{ obvgrid.usw, obvgrid.lsw - obvgrid.usw, obvgrid.use - obvgrid.usw, obvgrid.unw - obvgrid.usw, Vector(0,  offsets[4], 0) },
			{ obvgrid.une, obvgrid.use - obvgrid.une, obvgrid.lne - obvgrid.une, obvgrid.unw - obvgrid.une, Vector(-offsets[5], 0, 0) },
			{ obvgrid.unw, obvgrid.lnw - obvgrid.unw, obvgrid.usw - obvgrid.unw, obvgrid.une - obvgrid.unw, Vector( offsets[6], 0, 0) },
		}
		
		cache.aGrid = obvgrid
		cache.aSnap = obvsnap
		cache.aFaces = faces
	end
	
	local obvgrid = cache.aGrid
	local obvsnap = cache.aSnap
	local faces = cache.aFaces
	
	if (!target.locked) then
		-- should improve this by expanding the bounding box or something instead!
		-- create a larger bounding box and then planes for each side, and check distance from the plane
		-- separate function perhaps?
		local distance = (LocalPlayer():GetPos() - target.entity:GetPos()):Length() - (obvgrid.unw - obvgrid.lse):Length()
		if (distance > GetConVarNumber("snap_distance")) then return end
		
		for face,vertices in ipairs(faces) do
			intersection = RayQuadIntersect(cache.vLookPos, cache.vLookVector, vertices[1], vertices[2], vertices[3])
			if (intersection) then
				target.face = face
				break
			end
		end
		
		if intersection == nil then return end
	end
	
	if (GetConVarNumber("snap_boundingbox") != 0) then
		DrawBoundary(obvgrid.unw, obvgrid.lnw, obvgrid.usw, obvgrid.une)
		DrawBoundary(obvgrid.une, obvgrid.lne, obvgrid.use, obvgrid.unw)
		DrawBoundary(obvgrid.lnw, obvgrid.unw, obvgrid.lsw, obvgrid.lne)
		DrawBoundary(obvgrid.lne, obvgrid.une, obvgrid.lse, obvgrid.lnw)
		DrawBoundary(obvgrid.usw, obvgrid.lsw, obvgrid.unw, obvgrid.use)
		DrawBoundary(obvgrid.use, obvgrid.lse, obvgrid.une, obvgrid.usw)
		DrawBoundary(obvgrid.lsw, obvgrid.usw, obvgrid.lnw, obvgrid.lse)
		DrawBoundary(obvgrid.lse, obvgrid.use, obvgrid.lne, obvgrid.lsw)
	end
	
	local vectorOrigin = faces[target.face][1]
	local vectorX =      faces[target.face][2]
	local vectorY =      faces[target.face][3]
	local vectorZ =      faces[target.face][4]
	local vectorOffset = faces[target.face][5]
	
	local vectorGrid
	
	if (!target.locked) then
		vectorGrid = vectorOrigin + CalculateSnap(vectorX, vectorY, intersection)
		
		local trace = util.TraceLine({
			start  = target.entity:LocalToWorld(target.entity:WorldToLocal(vectorGrid) - vectorOffset) - vectorZ:GetNormalized() * 0.01,
			endpos = vectorGrid + vectorZ,
		})
		
		local vectorSnap = trace.HitPos
		target.offset = target.entity:WorldToLocal(vectorSnap)
		target.vector = target.entity:WorldToLocal(vectorGrid)
		
		target.error = true

		if (trace.Entity == nil or !trace.Entity:IsValid()) then
			snaperror = -1
		elseif (trace.Entity != target.entity) then
			snaperror = -2
		elseif (trace.HitPos == trace.StartPos) then
			snaperror = -2
		else
			snaperror = (LocalPlayer():GetEyeTrace().HitPos - trace.HitPos):Length()
			target.error = false
			
			if ((vectorSnap - vectorGrid):Length() > 0.5) then
				local marker = PointToScreen(vectorSnap)
				
				if (marker) then
					DrawSnapCross(marker, 255, 255, 255)
				end
			end
		end
	else
		vectorGrid = target.entity:LocalToWorld(target.vector)
		local vectorSnap = target.entity:LocalToWorld(target.offset)
	
		local marker = PointToScreen(vectorSnap)
		snaperror = (LocalPlayer():GetEyeTrace().HitPos - vectorSnap):Length()
		
		if (marker) then
			if (target.error == true) then
				snaperror = -2
				DrawSnapCross(marker, 0, 255, 255)
			elseif (snaperror < 0.001) then
				DrawSnapCross(marker, 0, 255, 0)
			elseif (snaperror < 0.1) then
				DrawSnapCross(marker, 255, 255, 0)
			else
				DrawSnapCross(marker, 255, 0, 0)
			end
		end
	end
	
	if (GetConVarNumber("snap_hidegrid") == 0) then
		DrawGrid(vectorOrigin, vectorX, vectorY)
	end

	target.active = true
	
	local vsCursor = PointToScreen(vectorGrid)
	
	if (vsCursor) then
		if (snaperror == -1) then
			target.active = false
			DrawSnapCross(vsCursor, 0, 255, 255)
		elseif (snaperror == -2) then
			DrawSnapCross(vsCursor, 255, 0, 255)
		elseif (snaperror < 0.001) then
			DrawSnapCross(vsCursor, 0, 255, 0)
		elseif (snaperror < 0.1) then
			DrawSnapCross(vsCursor, 255, 255, 0)
		else
			DrawSnapCross(vsCursor, 255, 0, 0)
		end
	end
end

local function OnSnapView(player, origin, angles, fov)
	local targetvalid = target.active and target.locked and target.entity:IsValid()
	local snaptargetvalid = snaptarget.active and snaptarget.locked and snaptarget.entity:IsValid()

	if (snapcursor and !snapspawnmenu and targetvalid) then
		local screen = ToScreen(target.entity:LocalToWorld(target.offset))
		input.SetCursorPos(math.Round(screen.x), math.Round(screen.y))
	end
	
	if (!snapcursor and targetvalid) then
		return {angles = (target.entity:LocalToWorld(target.offset) - player:GetShootPos()):Angle()}
	elseif (snaplock and snaptargetvalid) then	
		return {angles = (snaptarget.entity:LocalToWorld(snaptarget.offset) - player:GetShootPos()):Angle()}
	end
end

local function OnSnapAim(user)
	local targetvalid = target.active and target.locked and target.entity:IsValid()
	local snaptargetvalid = snaptarget.active and snaptarget.locked and snaptarget.entity:IsValid()

	if (!snapcursor and targetvalid) then
		user:SetViewAngles((target.entity:LocalToWorld(target.offset) - LocalPlayer():GetShootPos()):Angle())
	elseif (snaplock and snaptargetvalid) then	
		user:SetViewAngles((snaptarget.entity:LocalToWorld(snaptarget.offset) - LocalPlayer():GetShootPos()):Angle())
	end
end

concommand.Add("+snap", SnapPress)
concommand.Add("-snap", SnapRelease)
-- concommand.Add("snaplock", SnapLock)
concommand.Add("snaptogglegrid", SnapToggleGrid)


hook.Add("Initialize", "SmartsnapInitialize", OnInitialize)

hook.Add("SpawnMenuOpen", "SmartsnapSpawnMenu", OnSpawnMenu)

hook.Add("Think", "SmartsnapThink", OnThink)
hook.Add("ShutDown", "SmartsnapShutDown", OnShutDown)

hook.Add("KeyPress", "SmartsnapKeyPress", OnKeyPress)
hook.Add("KeyRelease", "SmartsnapKeyRelease", OnKeyRelease)

hook.Add("CreateMove", "SmartsnapSnap", OnSnapAim)
hook.Add("CalcView", "SmartsnapSnapView", OnSnapView)

hook.Add("SpawnMenuOpen", "SmartsnapSpawnMenu", OnSpawnMenu)

hook.Add("HUDPaintBackground", "SmartsnapPaintHUD", OnPaintHUD)


local function OnPopulateToolPanel(panel)
 	panel:AddControl("ComboBox", {
		Options = { ["default"] = condefs },
		CVars = convars,
		Label = "",
		MenuButton = "1",
		Folder = "smartsnap"
	}) 
	
	panel:AddControl("CheckBox", {
		Label = "Enable",
		Command = "snap_enabled",
	})
	
	panel:AddControl("CheckBox", {
		Label = "Use click grid (USE temporarily enables grid)",
		Command = "snap_clickgrid",
	})
	
	panel:AddControl("CheckBox", {
		Label = "Hide grid (only shows snap point)",
		Command = "snap_hidegrid",
	})

	panel:AddControl("CheckBox", {
		Label = "Smart toggle enabled",
		Command = "snap_enabletoggle",
	})

	panel:AddControl("CheckBox", {
		Label = "Revert aim to grid snap on detach",
		Command = "snap_revertaim",
	})

	-- panel:AddControl("CheckBox", {
		-- Label = "Enable for all entities",
		-- Command = "snap_allentities",
	-- })

	-- panel:AddControl("CheckBox", {
		-- Label = "Enable for all tools",
		-- Command = "snap_alltools",
	-- })

	panel:AddControl("CheckBox", {
		Label = "Draw thick center lines",
		Command = "snap_centerline",
	})

	panel:AddControl("Slider", {
		Label = "Grid toggle delay (double click snap-key)",
		Command = "snap_toggledelay",
		Type = "Float",
		Min = "0.0",
		Max = "0.2",
	})

	panel:AddControl("Slider", {
		Label = "Smart lock delay",
		Command = "snap_lockdelay",
		Type = "Float",
		Min = "0.0",
		Max = "5.0",
	})

	panel:AddControl("CheckBox", {
		Label = "Bounding box enabled",
		Command = "snap_boundingbox",
	})

	panel:AddControl("Slider", {
		Label = "Grid draw distance",
		Command = "snap_distance",
		Type = "Integer",
		Min = "50",
		Max = "1000",
	})

	panel:AddControl("Slider", {
		Label = "Grid edge offset",
		Command = "snap_gridoffset",
		Type = "Float",
		Min = "0.0",
		Max = "2.5",
	})

	panel:AddControl("Slider", {
		Label = "Grid transparency",
		Command = "snap_gridalpha",
		Type = "Float",
		Min = "0.1",
		Max = "1.0",
	})

	panel:AddControl("Slider", {
		Label = "Maximum number of snap points on an axis",
		Command = "snap_gridlimit",
		Type = "Integer",
		Min = "2",
		Max = "64",
	})

	panel:AddControl("Slider", {
		Label = "Minimum distance between each snap point",
		Command = "snap_gridsize",
		Type = "Integer",
		Min = "2",
		Max = "64",
	})
	
	
	panel:AddControl("Label", {
		Text = ""
	})
	
	panel:AddControl("Label", {
		Text = "The following option should prevent FPS drops from occuring, however it might have a slight impact on the average FPS while the grid is showing. Do NOT uncheck this option unless you are experiencing very low FPS or fully understands its purpose."
	})
	
	panel:AddControl("Label", {
		Text = "NOTE: This option is only effective when the grid is showing, it does not impact regular gameplay!"
	})
	
	panel:AddControl("Label", {
		Text = ""
	})
	
	panel:AddControl("CheckBox", {
		Label = "Garbage collection boost",
		Command = "snap_gcboost",
	})
end
--[[
function OnPopulateToolMenu()
	spawnmenu.AddToolMenuOption("Options", "Player", "SmartSnapSettings", "SmartSnap", "", "", OnPopulateToolPanel, {SwitchConVar = 'snap_enabled'})
end
--]]
--hook.Add("PopulateToolMenu", "SmartSnapToolMenu", OnPopulateToolMenu)

end
--PATH gamemodes/darkrp/gamemode/config/config.lua:
--[[-------------------------------------------------------------------------
DarkRP config settings.
-----------------------------------------------------------------------------

This is the settings file of DarkRP. Every DarkRP setting is listed here.

Warning:
If this file is missing settings (because of e.g. an update), DarkRP will assume default values for these settings.
You need not worry about updating this file. If a new setting is added you can manually add them to this file.
---------------------------------------------------------------------------]]


--[[
Toggle settings.
Set to true or false.
]]
GM.Config.talkDistance    = 250
GM.Config.whisperDistance = 90
GM.Config.yellDistance    = 550
GM.Config.meDistance      = 250
GM.Config.voiceDistance   = 550

-- voice3D - Enable/disable 3DVoice is enabled.
GM.Config.voice3D                       = true
-- AdminsCopWeapons - Enable/disable admins spawning with cop weapons.
GM.Config.AdminsCopWeapons              = true
-- adminBypassJobCustomCheck - Enable/disable whether an admin can force set a job with whenever customCheck returns false.
GM.Config.adminBypassJobRestrictions    = true
-- allow people getting their own custom jobs.
GM.Config.allowjobswitch                = true
-- allowrpnames - Allow Players to Set their RP names using the /rpname command.
GM.Config.allowrpnames                  = true
-- allowsprays - Enable/disable the use of sprays on the server.
GM.Config.allowsprays                   = true
-- allowvehicleowning - Enable/disable whether people can own vehicles.
GM.Config.allowvehicleowning            = true
-- allowvnocollide - Enable/disable the ability to no-collide a vehicle (for security).
GM.Config.allowvnocollide               = false
-- alltalk - Enable for global chat, disable for local chat.
GM.Config.alltalk                       = false
-- antimultirun - Disallow people joining your server(s) twice on the same account.
GM.Config.antimultirun                  = true
-- autovehiclelock - Enable/Disable automatic locking of a vehicle when a player exits it.
GM.Config.autovehiclelock               = false
-- babygod - people spawn godded (prevent spawn killing).
GM.Config.babygod                       = true
-- canforcedooropen - whether players can force an unownable door open with lockpick or battering ram or w/e.
GM.Config.canforcedooropen              = true
-- chatsounds - sounds are played when some things are said in chat.
GM.Config.chatsounds                    = true
-- chiefjailpos - Allow the Chief to set the jail positions.
GM.Config.chiefjailpos                  = true
-- cit_propertytax - Enable/disable property tax that is exclusive only for citizens.
GM.Config.cit_propertytax               = false
-- copscanunfreeze - Enable/disable the ability of cops to unfreeze other people's props.
GM.Config.copscanunfreeze               = true
-- copscanunweld - Enable/disable the ability of cops to unweld other people's props.
GM.Config.copscanunweld                 = false
-- cpcanarrestcp - Allow/Disallow CPs to arrest other CPs.
GM.Config.cpcanarrestcp                 = true
-- currencyLeft - The position of the currency symbol. true for left, false for right.
GM.Config.currencyLeft                  = true
-- customjobs - Enable/disable the /job command (personalized job names).
GM.Config.customjobs                    = true
-- customspawns - Enable/disable whether custom spawns should be used.
GM.Config.customspawns                  = true
-- deathblack - Whether or not a player sees black on death.
--GM.Config.deathblack                    = false
-- showdeaths - Display kill information in the upper right corner of everyone's screen.
GM.Config.showdeaths                    = true
-- deadtalk - Enable/disable whether people talk and use commands while dead.
GM.Config.deadtalk                      = true
-- deadvoice - Enable/disable whether people talk through the microphone while dead.
GM.Config.deadvoice                     = true
-- deathpov - Enable/disable whether people see their death in first person view.
GM.Config.deathpov                      = false
-- decalcleaner - Enable/Disable clearing ever players decals.
GM.Config.decalcleaner                  = false
-- disallowClientsideScripts - Clientside scripts can be very useful for customizing the HUD or to aid in building. This option bans those scripts.
GM.Config.disallowClientsideScripts     = false
-- doorwarrants - Enable/disable Warrant requirement to enter property.
GM.Config.doorwarrants                  = true
-- dropmoneyondeath - Enable/disable whether people drop money on death.
GM.Config.dropmoneyondeath              = false
-- droppocketarrest - Enable/disable whether people drop the stuff in their pockets when they get arrested.
GM.Config.droppocketarrest              = false
-- droppocketdeath - Enable/disable whether people drop the stuff in their pockets when they die.
GM.Config.droppocketdeath               = true
-- dropweapondeath - Enable/disable whether people drop their current weapon when they die.
GM.Config.dropweapondeath               = false
-- Whether players can drop the weapons they spawn with.
GM.Config.dropspawnedweapons            = true
-- dynamicvoice - Enable/disable whether only people in the same room as you can hear your mic.
GM.Config.dynamicvoice                  = true
-- earthquakes - Enable/disable earthquakes.
GM.Config.earthquakes                   = false
-- enablebuypistol - Turn /buy on of off.
GM.Config.enablebuypistol               = true
-- enforceplayermodel - Whether or not to force players to use their role-defined character models.
GM.Config.enforceplayermodel            = true
-- globalshow - Whether or not to display player info above players' heads in-game.
GM.Config.globalshow                    = false
-- ironshoot - Enable/disable whether people need iron sights to shoot.
GM.Config.ironshoot                     = true
-- showjob - Whether or not to display a player's job above their head in-game.
GM.Config.showjob                       = true
-- letters - Enable/disable letter writing / typing.
GM.Config.letters                       = true
-- license - Enable/disable People need a license to be able to pick up guns.
--GM.Config.license                       = false
-- lockdown - Enable/Disable initiating lockdowns for mayors.
GM.Config.lockdown                      = true
-- lockpickfading - Enable/disable the lockpicking of fading doors.
GM.Config.lockpickfading                = true
-- logging - Enable/disable logging everything that happens.
GM.Config.logging                       = true
-- lottery - Enable/disable creating lotteries for mayors.
GM.Config.lottery                       = true
-- showname - Whether or not to display a player's name above their head in-game.
GM.Config.showname                      = true
-- showhealth - Whether or not to display a player's health above their head in-game.
GM.Config.showhealth                    = true
-- needwantedforarrest - Enable/disable Cops can only arrest wanted people.
GM.Config.needwantedforarrest           = false
-- noguns - Enabling this feature bans Guns and Gun Dealers.
GM.Config.noguns                        = false
-- norespawn - Enable/Disable that people don't have to respawn when they change job.
GM.Config.norespawn                     = true
-- npcarrest - Enable/disable arresting npc's.
GM.Config.npcarrest                     = true
-- ooc - Whether or not OOC tags are enabled.
GM.Config.ooc                           = true
-- propertytax - Enable/disable property tax.
GM.Config.propertytax                   = false
-- proppaying - Whether or not players should pay for spawning props.
GM.Config.proppaying                    = false
-- propspawning - Enable/disable props spawning. Applies to admins too.
GM.Config.propspawning                  = true
-- removeclassitems - Enable/disable shipments/microwaves/etc. removal when someone changes team.
GM.Config.removeclassitems              = true
-- removeondisconnect - Enable/disable shipments/microwaves/etc. removal when someone disconnects.
GM.Config.removeondisconnect            = true
-- respawninjail - Enable/disable whether people can respawn in jail when they die.
GM.Config.respawninjail                 = true
-- restrictallteams - Enable/disable Players can only be citizen until an admin allows them.
GM.Config.restrictallteams              = false
-- restrictbuypistol - Enabling this feature makes /buy available only to Gun Dealers.
GM.Config.restrictbuypistol             = false
-- restrictdrop - Enable/disable restricting the weapons players can drop. Setting this to true disallows weapons from shipments from being dropped.
GM.Config.restrictdrop                  = false
-- revokeLicenseOnJobChange - Whether licenses are revoked when a player changes jobs.
--GM.Config.revokeLicenseOnJobChange      = true
-- shouldResetLaws - Enable/Disable resetting the laws back to the default law set when the mayor changes.
GM.Config.shouldResetLaws               = false
-- strictsuicide - Whether or not players should spawn where they suicided.
GM.Config.strictsuicide                 = false
-- telefromjail - Enable/disable teleporting from jail.
GM.Config.telefromjail                  = true
-- teletojail - Enable/disable teleporting to jail.
GM.Config.teletojail                    = true
-- unlockdoorsonstart - Enable/Disable unlocking all doors on map start.
GM.Config.unlockdoorsonstart            = false
-- voiceradius - Enable/disable local voice chat.
GM.Config.voiceradius                   = true
-- tax - Whether players pay taxes on their wallets.
GM.Config.wallettax                     = false
-- wantedsuicide - Enable/Disable suiciding while you are wanted by the police.
GM.Config.wantedsuicide                 = false
-- realisticfalldamage - Enable/Disable dynamic fall damage. Setting mp_falldamage to 1 will over-ride this.
GM.Config.realisticfalldamage           = true
-- printeroverheat - Whether the default money printer can overheat on its own.
GM.Config.printeroverheat               = true
-- weaponCheckerHideDefault - Hide default weapons when checking weapons.
GM.Config.weaponCheckerHideDefault      = true
-- weaponCheckerHideNoLicense - Hide weapons that do not require a license.
--GM.Config.weaponCheckerHideNoLicense    = false

--[[
Value settings
]]
-- adminnpcs - Whether or not NPCs should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminnpcs                     = 3
-- adminsents - Whether or not SENTs should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminsents                    = 1
-- adminvehicles - Whether or not vehicles should be admin only. 0 = everyone, 1 = admin or higher, 2 = superadmin or higher, 3 = rcon only
GM.Config.adminvehicles                 = 3
-- adminweapons - Who can spawn weapons: 0: admins only, 1: supadmins only, 2: no one
GM.Config.adminweapons                  = 1
-- arrestspeed - Sets the max arrest speed.
GM.Config.arrestspeed                   = 120
-- babygodtime - How long the babygod lasts.
GM.Config.babygodtime                   = 5
-- chatsoundsdelay - How long to wait before letting a player emit a sound from their chat again.
-- Leave this on at least a few seconds to prevent people from spamming sounds. Set to 0 to disable.
GM.Config.chatsoundsdelay               = 5
-- deathfee - the amount of money someone drops when dead.
GM.Config.deathfee                      = 30
-- decaltimer - Sets the time to clear clientside decals (in seconds).
GM.Config.decaltimer                    = 120
-- demotetime - Number of seconds before a player can rejoin a team after demotion from that team.
GM.Config.demotetime                    = 120
-- doorcost - Sets the cost of a door.
GM.Config.doorcost                      = 30
-- entremovedelay - how long to wait before removing a bought entity after disconnect.
GM.Config.entremovedelay                = 0
-- gunlabweapon - The weapon that the gunlab spawns.
GM.Config.gunlabweapon                  = "weapon_p2282"
-- jailtimer - Sets the jailtimer (in seconds).
GM.Config.jailtimer                     = 120
-- lockdowndelay - The amount of time a mayor must wait before starting the next lockdown.
GM.Config.lockdowndelay                 = 120
-- maxadvertbillboards - The maximum number of /advert billboards a player can place.
GM.Config.maxadvertbillboards           = 3
-- maxCheques - The maximum number of cheques someone can write
GM.Config.maxCheques                    = 5
-- maxdoors - Sets the max amount of doors one can own.
GM.Config.maxdoors                      = 20
-- maxdrugs - Sets max drugs.
GM.Config.maxdrugs                      = 2
-- maxfoods - Sets the max food cartons per Microwave owner.
GM.Config.maxfoods                      = 2
-- maxfooditems - Sets the max amount of food items a player can buy from the F4 menu.
GM.Config.maxfooditems                  = 20
-- maxlawboards - The maximum number of law boards the mayor can place.
GM.Config.maxlawboards                  = 2
-- maxletters - Sets max letters.
GM.Config.maxletters                    = 10
-- maxlotterycost - Maximum payment the mayor can set to join a lottery.
GM.Config.maxlotterycost                = 250
-- maxvehicles - Sets how many vehicles one can buy.
GM.Config.maxvehicles                   = 5
-- microwavefoodcost - Sets the sale price of Microwave Food.
GM.Config.microwavefoodcost             = 30
-- minlotterycost - Minimum payment the mayor can set to join a lottery.
GM.Config.minlotterycost                = 30
-- Money packets will get removed if they don't get picked up after a while. Set to 0 to disable.
GM.Config.moneyRemoveTime               = 600
-- mprintamount - Value of the money printed by the money printer.
GM.Config.mprintamount                  = 250
-- normalsalary - Sets the starting salary for newly joined players.
GM.Config.normalsalary                  = 45
-- npckillpay - Sets the money given for each NPC kill.
GM.Config.npckillpay                    = 10
-- paydelay - Sets how long it takes before people get salary.
GM.Config.paydelay                      = 160
-- pocketitems - Sets the amount of objects the pocket can carry.
GM.Config.pocketitems                   = 10
-- pricecap - The maximum price of items (using /price).
GM.Config.pricecap                      = 500
-- pricemin - The minimum price of items (using /price).
GM.Config.pricemin                      = 50
-- propcost - How much prop spawning should cost (prop paying must be enabled for this to have an effect).
GM.Config.propcost                      = 10
-- quakechance - Chance of an earthquake happening.
GM.Config.quakechance                   = 4000
-- respawntime - Minimum amount of seconds a player has to wait before respawning.
GM.Config.respawntime                   = 1
-- changejobtime - Minimum amount of seconds a player has to wait before changing job.
GM.Config.changejobtime                 = 10
-- runspeed - Sets the max running speed.
GM.Config.runspeed                      = 240
-- runspeed - Sets the max running speed for CP teams.
GM.Config.runspeedcp                    = 255
-- searchtime - Number of seconds for which a search warrant is valid.
GM.Config.searchtime                    = 30
-- ShipmentSpawnTime - Antispam time between spawning shipments.
GM.Config.ShipmentSpamTime              = 3
-- shipmenttime - The number of seconds it takes for a shipment to spawn.
GM.Config.shipmentspawntime             = 10
-- startinghealth - the health when you spawn.
GM.Config.startinghealth                = 100
-- startingmoney - your wallet when you join for the first time.
GM.Config.startingmoney                 = 500
-- vehiclecost - Sets the cost of a vehicle (To own it).
GM.Config.vehiclecost                   = 40
-- wallettaxmax - Maximum percentage of tax to be paid.
GM.Config.wallettaxmax                  = 5
-- wallettaxmin - Minimum percentage of tax to be paid.
GM.Config.wallettaxmin                  = 1
-- wallettaxtime - Time in seconds between taxing players. Requires server restart.
GM.Config.wallettaxtime                 = 600
-- wantedtime - Number of seconds for which a player is wanted for.
GM.Config.wantedtime                    = 120
-- walkspeed - Sets the max walking speed.
GM.Config.walkspeed                     = 160
-- falldamagedamper - The damper on realistic fall damage. Default is 15. Decrease this for more damage.
GM.Config.falldamagedamper              = 15
-- falldamageamount - The base damage taken from falling for static fall damage. Default is 10.
GM.Config.falldamageamount              = 10
-- printeroverheatchance - The likelyhood of a printer overheating. The higher this number, the less likely (minimum 3, default 22).
GM.Config.printeroverheatchance         = 22
-- printerreward - Reward for destroying a money printer.
GM.Config.printerreward                 = 950

--[[---------------------------------------------------------------------------
Other settings
---------------------------------------------------------------------------]]

-- The classname of money packets. Use this to create your own money entity!
-- Note: the money packet must support the "Setamount" method (or the amount DTVar).
GM.Config.MoneyClass = "spawned_money"
-- In case you do wish to keep the default money, but change the model, this option is the way to go:
GM.Config.moneyModel = "models/props/cs_assault/money.mdl"
-- You can set your own, custom sound to be played for all players whenever a lockdown is initiated.
-- Note: Remember to include the folder where the sound file is located.
GM.Config.lockdownsound = "npc/overwatch/cityvoice/f_confirmcivilstatus_1_spkr.wav"

-- The skin DarkRP uses. Set to "default" to use the GMod default derma theme.
GM.Config.DarkRPSkin = "DarkRP"
GM.Config.currency = "$"
GM.Config.chatCommandPrefix = "/"
GM.Config.F1MenuHelpPage = "https://docs.google.com/document/d/10pvotowOA3EA7K5BMgdaKVOYjbrbx6dxrQn4LWxm30A/edit#heading=h.e5iaqteza8x7"
GM.Config.F1MenuHelpPageTitle = "Server tips"

-- Put Steam ID's and ranks in this list, and the players will have that rank when they join.
GM.Config.DefaultPlayerGroups = {
    ["STEAM_0:0:00000000"] = "superadmin",
    ["STEAM_0:0:11111111"] = "admin",
}

-- Custom modules in this addon that are disabled.
GM.Config.DisabledCustomModules = {
       ["hudreplacement"] = false,
       ["extraf4tab"] = false,
}

-- The list of weapons that players are not allowed to drop. Items set to true are not allowed to be dropped.
GM.Config.DisallowDrop = {
    ["arrest_stick"] = true,
    ["door_ram"] = true,
    ["gmod_camera"] = true,
    ["gmod_tool"] = true,
    ["keys"] = true,
    ["lockpick"] = true,
    ["med_kit"] = true,
    ["pocket"] = true,
    ["stunstick"] = true,
    ["unarrest_stick"] = true,
    ["weapon_keypadchecker"] = true,
    ["weapon_physcannon"] = true,
    ["weapon_physgun"] = true,
    ["weaponchecker"] = true,
}

-- The list of weapons people spawn with.
GM.Config.DefaultWeapons = {
    "keys",
    "weapon_physcannon",
    "gmod_camera",
    "gmod_tool",
    "pocket",
    "weapon_physgun",
}

-- Override categories.
-- NOTE: categories are to be set in the "category" field of the custom jobs/shipments/entities/ammo/pistols/vehicles.
-- Use this only to override the categories of _default_ things.
-- This will NOT work for your own custom stuff.
-- Make sure the category is created in the darkrp_customthings/categories.lua, otherwise it won't work!
GM.Config.CategoryOverride = {
    jobs = {
        ["Citizen"]                             = "Citizens",
        ["Hobo"]                                = "Citizens",
        ["Gun Dealer"]                          = "Citizens",
        ["Medic"]                               = "Citizens",
        ["Civil Protection"]                    = "Civil Protection",
        ["Gangster"]                            = "Gangsters",
        ["Mob boss"]                            = "Gangsters",
        ["Civil Protection Chief"]              = "Civil Protection",
        ["Mayor"]                               = "Civil Protection",
    },
    entities = {
        ["Drug lab"]                            = "Other",
        ["Money printer"]                       = "Other",
        ["Gun lab"]                             = "Other",

    },
    shipments = {
        ["AK47"]                                = "Rifles",
        ["MP5"]                                 = "Rifles",
        ["M4"]                                  = "Rifles",
        ["Mac 10"]                              = "Other",
        ["Pump shotgun"]                        = "Shotguns",
        ["Sniper rifle"]                        = "Snipers",

    },
    weapons = {
        ["Desert eagle"]                        = "Pistols",
        ["Fiveseven"]                           = "Pistols",
        ["Glock"]                               = "Pistols",
        ["P228"]                                = "Pistols",
    },
    vehicles = {}, -- There are no default vehicles.
    ammo = {
        ["Pistol ammo"]                         = "Other",
        ["Shotgun ammo"]                        = "Other",
        ["Rifle ammo"]                          = "Other",
    },
}

-- The list of weapons admins spawn with, in addition to the default weapons, a job's weapons and GM.Config.AdminsCopWeapons.
GM.Config.AdminWeapons = {
    "weapon_keypadchecker",
}

-- These are the default laws, they're unchangeable in-game.
GM.Config.DefaultLaws = {
    "Do not attack other citizens except in self-defence.",
    "Do not steal or break into people's homes.",
    "Money printers/drugs are illegal.",
}

GM.Config.PocketBlacklist = {
    ["fadmin_jail"] = true,
    ["meteor"] = true,
    ["door"] = true,
    ["func_"] = true,
    ["player"] = true,
    ["beam"] = true,
    ["worldspawn"] = true,
    ["env_"] = true,
    ["path_"] = true,
    ["prop_physics"] = true,
    ["money_printer"] = true,
    ["gunlab"] = true,
    ["prop_dynamic"] = true,
    ["prop_vehicle_prisoner_pod"] = true,
    ["keypad_wire"] = true,
    ["gmod_button"] = true,
    ["gmod_rtcameraprop"] = true,
    ["gmod_cameraprop"] = true,
    ["gmod_dynamite"] = true,
    ["gmod_thruster"] = true,
    ["gmod_light"] = true,
    ["gmod_lamp"] = true,
    ["gmod_emitter"] = true,
}

-- These weapons are classed as 'legal' in the weapon checker and are not stripped when confiscating weapons.
-- This setting is used IN ADDITION to GM.Config.weaponCheckerHideDefault and GM.Config.weaponCheckerHideNoLicense.
-- You should use the former if you want to class the default weapons (GM.Config.DefaultWeapons and, if admin, GM.Config.AdminWeapons) and a player's job weapons as legal.
-- The latter takes GM.NoLicense weapons as legal (see licenseweapons.lua).
-- The format of this config is similar to GM.Config.DisallowDrop.
GM.Config.noStripWeapons = {

}

-- The entities listed here will not be removed when a player changes their job.
-- This only applies when removeclassitems is set to true.
-- Note: entities will only be removed when the player changes to a job that is not allowed to have the entity.
GM.Config.preventClassItemRemoval = {
    ["gunlab"] = false,
    ["microwave"] = false,
    ["spawned_shipment"] = false,
}

-- Properties set to true are allowed to be used. Values set to false or are missing from this list are blocked.
GM.Config.allowedProperties = {
    remover = true,
    ignite = false,
    extinguish = true,
    keepupright = true,
    gravity = true,
    collision = true,
    skin = true,
    bodygroups = true,
}

--[[---------------------------------------------------------------------------
F4 menu
---------------------------------------------------------------------------]]
-- hide the items that you can't buy and the jobs you can't get (instead of graying them out).
-- this option hides items when you don't have enough money, when the maximum is reached for a job or any other reason.
GM.Config.hideNonBuyable = false

-- Hide only the items that you have the wrong job for (or for which the customCheck says no).
-- When you set this option to true and hideNonBuyable to false, you WILL see e.g. items that are too expensive for you to buy.
-- but you won't see gundealer shipments when you have the citizen job.
GM.Config.hideTeamUnbuyable = true

--[[---------------------------------------------------------------------------
AFK module
---------------------------------------------------------------------------]]
-- The time of inactivity before being demoted.
GM.Config.afkdemotetime = 600
-- Prevent people from spamming AFK.
GM.Config.AFKDelay = 300

--[[---------------------------------------------------------------------------
Hitmenu module
---------------------------------------------------------------------------]]
-- The minimum price for a hit.
GM.Config.minHitPrice = 200
-- The maximum price for a hit.
GM.Config.maxHitPrice = 50000
-- The minimum distance between a hitman and his customer when they make the deal.
GM.Config.minHitDistance = 150
-- The text that tells the player he can press use on the hitman to request a hit.
GM.Config.hudText = "I am a hitman.\nPress E on me to request a hit!"
-- The text above a hitman when he's got a hit.
GM.Config.hitmanText = "Hit\naccepted!"
-- The cooldown time for a hit target (so they aren't spam killed).
GM.Config.hitTargetCooldown = 120
-- How long a customer has to wait to be able to buy another hit (from the moment the hit is accepted).
GM.Config.hitCustomerCooldown = 240

--[[---------------------------------------------------------------------------
Hungermod module
---------------------------------------------------------------------------]]
-- hungerspeed <Amount> - Set the rate at which players will become hungry (2 is the default).
GM.Config.hungerspeed = 2
-- starverate <Amount> - How much health that is taken away every second the player is starving  (3 is the default).
GM.Config.starverate = 3

--PATH gamemodes/darkrp/gamemode/modules/pp/cl_propaccess.lua:
properties.Add("propaccess", {
	MenuLabel = "Выдать доступ к пропам",
	Order = 1,
	MenuIcon = "icon16/brick.png",

	Filter = function( self, ent, ply )
		return IsValid( ent ) && IsValid(ent:CPPIGetOwner()) && ent:CPPIGetOwner():IsPlayer()
	end,
	Action = function( self, ent )
		RunConsoleCommand("cppi_friends")
	end,
})
--[[
properties.Add("ebanutiiremoveshop", {
    MenuLabel = "Удалить торговую лавку",
    Order = 1,
    MenuIcon = "icon16/brick.png",
    Filter = function(self, ent, tr) return IsValid(ent) and IsValid(ent:CPPIGetOwner()) and ent:CPPIGetOwner():IsPlayer() and ent:GetClass() == "itemstore_shop" and ent:CPPIGetOwner() == LocalPlayer() end,
    Action = function(self, ent)
        RunConsoleCommand("remove_shop")
    end
})
--]]
--PATH gamemodes/darkrp/gamemode/modules/base/sh_entityvars.lua:
local maxId = 0
local DarkRPVars = {}
local DarkRPVarById = {}

-- the amount of bits assigned to the value that determines which DarkRPVar we're sending/receiving
local DARKRP_ID_BITS = 8
local UNKNOWN_DARKRPVAR = 255 -- Should be equal to 2^DARKRP_ID_BITS - 1
DarkRP.DARKRP_ID_BITS = DARKRP_ID_BITS

function DarkRP.registerDarkRPVar(name, writeFn, readFn)
    maxId = maxId + 1

    -- UNKNOWN_DARKRPVAR is reserved for unknown values
    if maxId >= UNKNOWN_DARKRPVAR then DarkRP.error(string.format("Too many DarkRPVar registrations! DarkRPVar '%s' triggered this error", name), 2) end

    DarkRPVars[name] = {id = maxId, name = name, writeFn = writeFn, readFn = readFn}
    DarkRPVarById[maxId] = DarkRPVars[name]
end

-- Unknown values have unknown types and unknown identifiers, so this is sent inefficiently
local function writeUnknown(name, value)
    net.WriteUInt(UNKNOWN_DARKRPVAR, 8)
    net.WriteString(name)
    net.WriteType(value)
end

-- Read the value of a DarkRPVar that was not registered
local function readUnknown()
    return net.ReadString(), net.ReadType(net.ReadUInt(8))
end

local warningsShown = {}
local function warnRegistration(name)
    if warningsShown[name] then return end
    warningsShown[name] = true

    DarkRP.errorNoHalt(string.format([[Warning! DarkRPVar '%s' wasn't registered!
        Please contact the author of the DarkRP Addon to fix this.
        Until this is fixed you don't need to worry about anything. Everything will keep working.
        It's just that registering DarkRPVars would make DarkRP faster.]], name), 4)
end

function DarkRP.writeNetDarkRPVar(name, value)
    local DarkRPVar = DarkRPVars[name]
    if not DarkRPVar then
        warnRegistration(name)

        return writeUnknown(name, value)
    end

    net.WriteUInt(DarkRPVar.id, DARKRP_ID_BITS)
    return DarkRPVar.writeFn(value)
end

function DarkRP.writeNetDarkRPVarRemoval(name)
    local DarkRPVar = DarkRPVars[name]
    if not DarkRPVar then
        warnRegistration(name)

        net.WriteUInt(UNKNOWN_DARKRPVAR, 8)
        net.WriteString(name)
        return
    end

    net.WriteUInt(DarkRPVar.id, DARKRP_ID_BITS)
end

function DarkRP.readNetDarkRPVar()
    local DarkRPVarId = net.ReadUInt(DARKRP_ID_BITS)
    local DarkRPVar = DarkRPVarById[DarkRPVarId]

    if DarkRPVarId == UNKNOWN_DARKRPVAR then
        local name, value = readUnknown()

        return name, value
    end

    local val = DarkRPVar.readFn(value)

    return DarkRPVar.name, val
end

function DarkRP.readNetDarkRPVarRemoval()
    local id = net.ReadUInt(DARKRP_ID_BITS)
    return id == 255 and net.ReadString() or DarkRPVarById[id].name
end

-- The money is a double because it accepts higher values than Int and UInt, which are undefined for >32 bits
DarkRP.registerDarkRPVar("money",         net.WriteDouble, net.ReadDouble)
DarkRP.registerDarkRPVar("salary",        fp{fn.Flip(net.WriteInt), 32}, fp{net.ReadInt, 32})
DarkRP.registerDarkRPVar("rpname",        net.WriteString, net.ReadString)
DarkRP.registerDarkRPVar("job",           net.WriteString, net.ReadString)
DarkRP.registerDarkRPVar("HasGunlicense", net.WriteBit, fc{tobool, net.ReadBit})
DarkRP.registerDarkRPVar("Arrested",      net.WriteBit, fc{tobool, net.ReadBit})
DarkRP.registerDarkRPVar("wanted",        net.WriteBit, fc{tobool, net.ReadBit})
DarkRP.registerDarkRPVar("wantedReason",  net.WriteString, net.ReadString)
DarkRP.registerDarkRPVar("agenda",        net.WriteString, net.ReadString)

--[[---------------------------------------------------------------------------
RP name override
---------------------------------------------------------------------------]]
local pmeta = FindMetaTable("Player")
pmeta.SteamName = pmeta.SteamName or pmeta.Name
function pmeta:Name()
    if not self:IsValid() then DarkRP.error("Attempt to call Name/Nick/GetName on a non-existing player!", SERVER and 1 or 2) end
    return GAMEMODE.Config.allowrpnames and self:getDarkRPVar("rpname")
        or self:SteamName()
end
pmeta.GetName = pmeta.Name
pmeta.Nick = pmeta.Name

--PATH gamemodes/darkrp/gamemode/modules/base/sh_checkitems.lua:
--[[
The base elements are shared by every custom item
]]
local baseSchema = tc.checkTable{
    buttonColor =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber)),
            "The buttonColor must be a Color value."
        ),

    category =
        tc.addHint(
            tc.optional(isstring),
            "The category must be the name of an existing category!"
        ),

    customCheck =
        tc.addHint(
            tc.optional(isfunction),
            "The customCheck must be a function."
        ),

    CustomCheckFailMsg =
        tc.addHint(
            tc.optional(isstring, isfunction),
            "The CustomCheckFailMsg must be either a string or a function."
        ),

    sortOrder =
        tc.addHint(
            tc.optional(isnumber),
            "The sortOrder must be a number."
        ),

    label =
        tc.addHint(
            tc.optional(isstring),
            "The label must be a valid string."
        ),
}

--[[
Properties shared by anything buyable
]]
local buyableSchema = fn.FAnd{baseSchema, tc.checkTable{
    allowed =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber), isnumber),
            "The allowed field must be either an existing team or a table of existing teams.",
            {"Is there a job here that doesn't exist (anymore)?"}
        ),

    getPrice =
        tc.addHint(
            tc.optional(isfunction),
            "The getPrice must be a function."
        ),

    model =
        tc.addHint(
            isstring,
            "The model must be valid."
        ),

    price =
        tc.addHint(
            function(v, tbl) return isnumber(v) or isfunction(tbl.getPrice) end,
            "The price must be an existing number or (for advanced users) the getPrice field must be a function."
        ),

    spawn =
        tc.addHint(
            tc.optional(isfunction),
            "The spawn must be a function."
        ),
}}

-- The command of an entity must be unique
local uniqueEntity = function(cmd, tbl)
    for _, v in pairs(DarkRPEntities) do
        if v.cmd ~= cmd then continue end

        return
            false,
            "This entity does not have a unique command.",
            {
                "There must be some other entity that has the same thing for 'cmd'.",
                "Fix this by changing the 'cmd' field of your entity to something else."
            }
    end

    return true
end

-- The command of a job must be unique
local uniqueJob = function(v, tbl)
    local job = DarkRP.getJobByCommand(v)

    if not job then return true end

    return
        false,
        "This job does not have a unique command.",
        {
            "There must be some other job that has the same command.",
            "Fix this by changing the 'command' of your job to something else."
        }
end

--[[
Validate jobs
]]
DarkRP.validateJob = fn.FAnd{baseSchema, tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name must be a valid string."
        ),

    color =
        tc.addHint(
            tc.tableOf(isnumber),
            "The color must be a Color value.",
            {"Color values look like this: Color(r, g, b, a), where r, g, b and a are numbers between 0 and 255."}
        ),

    model =
        tc.addHint(
            fn.FOr{isstring, tc.nonEmpty(tc.tableOf(isstring))},
            "The model must either be a table of correct model strings or a single correct model string.",
            {
                "This error could happens when the model does not exist on the server.",
                "Are you sure the model path is right?",
                "Is the model from an addon that is not properly installed?"
            }
        ),

    description =
        tc.addHint(
            isstring,
            "The description must be a string."
        ),

    weapons =
        tc.addHint(
            tc.optional(tc.tableOf(isstring)),
            "The weapons must be a valid table of strings.",
            {"Example: weapons = {\"med_kit\", \"weapon_bugbait\"},"}
        ),

    command =
        fn.FAnd
        {
            tc.addHint(
                isstring,
                "The command must be a string."
            ),
            uniqueJob
        },

    max =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}},
            "The max must be a number greater than or equal to zero.",
            {
                "Zero means infinite.",
                "A decimal between 0 and 1 is seen as a percentage."
            }
        ),

    salary =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}},
            "The salary must be a number and it must be greater than zero."
        ),

    admin =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}, fp{fn.Gte, 2}},
            "The admin value must be a number and it must be greater than or equal to zero and smaller than three."
        ),

    vote =
        tc.addHint(
            tc.optional(isbool),
            "The vote must be either true or false."
        ),

    ammo =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber)),
            "The ammo must be a table containing numbers.",
            {"See example on http://wiki.darkrp.com/index.php/DarkRP:CustomJobFields"}
        ),

    hasLicense =
        tc.addHint(
            tc.optional(isbool),
            "The hasLicense must be either true or false."
        ),

    NeedToChangeFrom =
        tc.addHint(
            tc.optional(tc.tableOf(isnumber), isnumber),
            "The NeedToChangeFrom must be either an existing team or a table of existing teams",
            {"Is there a job here that doesn't exist (anymore)?"}
        ),

    modelScale =
        tc.addHint(
            tc.optional(isnumber),
            "The modelScale must be a number."
        ),

    maxpocket =
        tc.addHint(
            tc.optional(isnumber),
            "The maxPocket must be a number."
        ),

    maps =
        tc.addHint(
            tc.optional(tc.tableOf(isstring)),
            "The maps value must be a table of valid map names."
        ),

    candemote =
        tc.default(true,
            tc.addHint(
                isbool,
                "The candemote value must be either true or false."
            )
        ),

    mayor =
        tc.addHint(
            tc.optional(isbool),
            "The mayor value must be either true or false."
        ),

    chief =
        tc.addHint(
            tc.optional(isbool),
            "The chief value must be either true or false."
        ),

    medic =
        tc.addHint(
            tc.optional(isbool),
            "The medic value must be either true or false."
        ),

    cook =
        tc.addHint(
            tc.optional(isbool),
            "The cook value must be either true or false."
        ),

    hobo =
        tc.addHint(
            tc.optional(isbool),
            "The hobo value must be either true or false."
        ),

    playerClass =
        tc.addHint(
            tc.optional(isstring),
            "The playerClass must be a valid string."
        ),

    CanPlayerSuicide =
        tc.addHint(
            tc.optional(isfunction),
            "The CanPlayerSuicide must be a function."
        ),

    PlayerCanPickupWeapon =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerCanPickupWeapon must be a function."
        ),

    PlayerDeath =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerDeath must be a function."
        ),

    PlayerLoadout =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerLoadout must be a function."
        ),

    PlayerSelectSpawn =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSelectSpawn must be a function."
        ),

    PlayerSetModel =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSetModel must be a function."
        ),

    PlayerSpawn =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSpawn must be a function."
        ),

    PlayerSpawnProp =
        tc.addHint(
            tc.optional(isfunction),
            "The PlayerSpawnProp must be a function."
        ),

    RequiresVote =
        tc.addHint(
            tc.optional(isfunction),
            "The RequiresVote must be a function."
        ),

    ShowSpare1 =
        tc.addHint(
            tc.optional(isfunction),
            "The ShowSpare1 must be a function."
        ),

    ShowSpare2 =
        tc.addHint(
            tc.optional(isfunction),
            "The ShowSpare2 must be a function."
        ),

    canStartVote =
        tc.addHint(
            tc.optional(isfunction),
            "The canStartVote must be a function."
        ),

    canStartVoteReason =
        tc.addHint(
            tc.optional(isstring, isfunction),
            "The canStartVoteReason must be either a string or a function."
        ),
}}

--[[
Validate shipments
]]
DarkRP.validateShipment = fn.FAnd{buyableSchema, tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name must be a valid string."
        ),

    entity =
        tc.addHint(
            isstring, "The entity of the shipment must be a string."
        ),

    amount =
        tc.addHint(
            fn.FAnd{isnumber, fp{fn.Lte, 0}}, "The amount must be a number and it must be greater than zero."
        ),

    separate =
        tc.addHint(
            tc.optional(isbool), "the separate field must be either true or false."
        ),

    pricesep =
        tc.addHint(
            function(v, tbl) return not tbl.separate or isnumber(v) and v >= 0 end,
            "The pricesep must be a number and it must be greater than or equal to zero."
        ),

    noship =
        tc.addHint(
            tc.optional(isbool),
            "The noship must be either true or false."
        ),

    shipmodel =
        tc.addHint(
            tc.optional(isstring),
            "The shipmodel must be a valid model."
        ),

    weight =
        tc.addHint(
            tc.optional(isnumber),
            "The weight must be a number."
        ),

    spareammo =
        tc.addHint(
            tc.optional(isnumber),
            "The spareammo must be a number."
        ),

    clip1 =
        tc.addHint(
            tc.optional(isnumber),
            "The clip1 must be a number."
        ),

    clip2 =
        tc.addHint(
            tc.optional(isnumber),
            "The clip2 must be a number."
        ),

    shipmentClass =
        tc.addHint(
            tc.optional(isstring),
            "The shipmentClass must be a string."
        ),

    onBought =
        tc.addHint(
            tc.optional(isfunction),
            "The onBought must be a function."
        ),

}}

--[[
Validate vehicles
]]
DarkRP.validateVehicle = fn.FAnd{buyableSchema, tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name of the vehicle must be a string."
        ),

    distance =
        tc.addHint(
            tc.optional(isnumber),
            "The distance must be a number."
        ),

    angle =
        tc.addHint(
            tc.optional(isangle),
            "The distance must be a valid Angle."
        ),
}}

--[[
Validate Entities
]]
DarkRP.validateEntity = fn.FAnd{buyableSchema, tc.checkTable{
    ent =
        tc.addHint(
            isstring,
            "The ent field must be a string."
        ),

    max =
        tc.addHint(
            function(v, tbl) return isnumber(v) or isfunction(tbl.getMax) end,
            "The max must be an existing number or (for advanced users) the getMax field must be a function."
        ),

    cmd =
        fn.FAnd
        {
            tc.addHint(isstring, "The cmd must be a valid string."),
            uniqueEntity
        },

    name =
        tc.addHint(
            isstring,
            "The name must be a valid string."
        ),

    allowTools =
        tc.default(false,
            tc.addHint(
                tc.optional(isbool),
                "The allowTools must be either true or false."
            )
        ),
}}


-- Checks whether a team already has an agenda assigned.
-- Jobs cannot have multiple agendas.

local overlappingAgendaCheck = function(t, tbl)
    local agenda = DarkRP.getAgendas()[t]

    -- Team being -1 means the job is disabled
    if agenda == nil or t == -1 then return true end

    local teamName = team.GetName(t)
    local err = "At least one job has multiple agendas assigned to them"
    local hints = {
        string.format([[The problem lies with the job called "%s"]], teamName),
        string.format([[It is assigned to agendas "%s" and "%s"]], agenda.Title or "unknown", tbl.Title or "unknown"),
        [[A job can only have ONE agenda. Otherwise things would become confusing, since only ONE agenda is always drawn on the screen.]]
    }

    if agenda.Title == tbl.Title then
        table.insert(hints, "The titles of the two agendas are the same. It looks like perhaps you've made the same agenda more than once.")
        table.insert(hints, "Removing one of them should get rid of this error.")
    end

    return false, err, hints
end

--[[
Validate Agendas
]]
local managerNumberCheck = tc.addHint(
    isnumber,
    "The Manager must either be a single team or a non-empty table of existing teams.",
    {"Is there a job here that doesn't exist (anymore)?"}
)

DarkRP.validateAgenda = tc.checkTable{
    Title =
        tc.addHint(
            isstring,
            "The title must be a string."
        ),

    -- Custom function to ensure the right error message is thrown
    Manager = function(manager, tbl)
            -- Check whether the manager is an existing team
            -- that does not already have an agenda assigned
            if isnumber(manager) then
                return fn.FAnd{overlappingAgendaCheck}(manager, tbl)

            -- Check whether the manager is a table of existing teams
            -- and that none of the teams already have agendas assigned
            elseif istable(manager) then
                return tc.nonEmpty(
                    tc.tableOf(
                        fn.FAnd{managerNumberCheck, overlappingAgendaCheck}
                    )
                )(manager, tbl)
            end

            return managerNumberCheck(manager, tbl)
        end,
    Listeners =
        tc.default({}, -- Default to empty table
            fn.FAnd{ -- Checks for a table of valid teams that do not already have an agenda assigned
                tc.addHint(
                    tc.tableOf(isnumber),
                    "The Listeners must be a table of existing teams.",
                    {
                        "Is there a job here that doesn't exist (anymore)?",
                        "Are you trying to have multiple manager jobs in this agenda? In that case you must put the list of manager jobs in curly braces.",
                        [[Like so: DarkRP.createAgenda("Some agenda", {TEAM_MANAGER1, TEAM_MANAGER2}, {TEAM_LISTENER1, TEAM_LISTENER2})]]
                    }
                ),
                tc.tableOf(overlappingAgendaCheck)
            }
        )
}

--[[
Validate Categories
]]
DarkRP.validateCategory = tc.checkTable{
    name =
        tc.addHint(
            isstring,
            "The name must be a string."
        ),

    categorises =
        tc.addHint(
            tc.oneOf{"jobs", "entities", "shipments", "weapons", "vehicles", "ammo"},
            [[The categorises must be one of "jobs", "entities", "shipments", "weapons", "vehicles", "ammo"]],
            {
                "Mind that this is case sensitive.",
                "Also mind the quotation marks."
            }
        ),

    startExpanded =
        tc.addHint(
            isbool,
            "The startExpanded must be either true or false."
        ),

    color =
        tc.addHint(
            tc.tableOf(isnumber),
            "The color must be a Color value."
        ),

    canSee =
        tc.addHint(
            tc.optional(isfunction),
            "The canSee must be a function."
        ),

    sortOrder =
        tc.addHint(
            tc.optional(isnumber),
            "The sortOrder must be a number."
        ),
}

--PATH addons/111mod/lua/darkrp_language/english.lua:
--[[---------------------------------------------------------------------------
English (example) language file
---------------------------------------------------------------------------

This is the english language file. The things on the left side of the equals sign are the things you should leave alone
The parts between the quotes are the parts you should translate. You can also copy this file and create a new language.

= Warning =
Sometimes when DarkRP is updated, new phrases are added.
If you don't translate these phrases to your language, it will use the English sentence.
To fix this, join your server, open your console and enter darkp_getphrases yourlanguage
For English the command would be:
	darkrp_getphrases "en"
because "en" is the language code for English.

You can copy the missing phrases to this file and translate them.

= Note =
Make sure the language code is right at the bottom of this file

= Using a language =
Make sure the convar gmod_language is set to your language code. You can do that in a server CFG file.
---------------------------------------------------------------------------]]

local my_language = {
	-- Admin things
	need_admin = "У вас нет привилегии администратора, чтобы иметь возможность %s",
	need_sadmin = "У вас нет привилегии супер администратора, чтобы иметь возможность %s",
	no_privilege = "У вас нет привилегии для этого действия",
	no_jail_pos = "Неустановленно место для тюрьмы",
	invalid_x = "Недействительно %s! %s",

	-- F1 menu
	f1ChatCommandTitle = "Команды чата",
	f1Search = "Поиск...",

	-- Money things:
	price = "Цена: %s%d",
	priceTag = "Цена: %s",
	reset_money = "%s обновил у всех игроков деньги!",
	has_given = "%s дал вам %s",
	you_gave = "Вы передали %s %s",
	npc_killpay = "%s За убийство NPС!",
	profit = "Прибыль",
	loss = "Утрата",

	-- backwards compatibility
	deducted_x = "Вычтено %s%d",
	need_x = "Необходимо %s%d",

	deducted_money = "Вычтено %s",
	need_money = "Необходимо %s",

	payday_message = "Зарплата! Вы получили %s!",
	payday_unemployed = "Вы не получили запрату, Так как у вас нет работы!",
	payday_missed = "Вашу зарплату конфисковало государство! (Так как вы арестованы.)",

	property_tax = "Налог на имущество! %s",
	property_tax_cant_afford = "Вы не заплатили налоги! Ваша собственность была конфискована!",
	taxday = "День налогов! %s%% взяли от вашего дохода!",

	found_cheque = "Вы нашли %s%s  в чеке сделанным для вас игроком %s.",
	cheque_details = "Этот чек сделан для %s.",
	cheque_torn = "Вы порвали чек.",
	cheque_pay = "Оплачено: %s",
	signed = "Подпись: %s",

	found_cash = "Вы нашли %s%d!", -- backwards compatibility
	found_money = "Вы нашли %s!",

	owner_poor = "Владелец %s слишком бедный чтобы выплатить эту сумму!",

	-- Police
	Wanted_text = "Разыскивается!",
	wanted = "Разыскивается полицией!\nПричина: %s",
	youre_arrested = "Вас арестовали! До выхода %d секунд!",
	youre_arrested_by = "%s Арестовал вас! (FreeArest? Пиши @FreeArest).",
	youre_unarrested_by = "Вы были освобождены %s.",
	hes_arrested = "%s был арестован на %d секунд!",
	hes_unarrested = "%s был освобожден из тюрьмы!",
	warrant_ordered = "%s взял ордер на %s. Причина: %s",
	warrant_request = "%s запрашивает ордер на обыск на %s\nпо причине: %s",
	warrant_request2 = "Запрос на ордер был отправлен мэру %s!",
	warrant_approved = "Ордер на обыск был одобрен %s!\nПричина: %s\nВыдал приказ: %s",
	warrant_approved2 = "Теперь вы можете обыскать его дом.",
	warrant_denied = "Мэр %s отклонил ваш запрос на ордер.",
	warrant_expired = "Время на обыск %s истекло!",
	warrant_required = "Вам требуется ордер на обыск, для того чтобы сломать эту дверь.",
	warrant_required_unfreeze = "Вам нужен ордер на обыск, для того чтобы убрать фриз данного пропа.",
	warrant_required_unweld = "Вам нужен ордер, для того чтобы выломать этот проп.",
	wanted_by_police = "%s Разыскивается полицией!\nПричина: %s\nВыдал приказ: %s",
	wanted_by_police_print = "%s объявил %s в розыск, причина: %s",
	wanted_expired = "%s Больше не разыскивается полицией.",
	wanted_revoked = "%s Больше не разыскивает полиция.\nСнял розыск: %s",
	cant_arrest_other_cp = "Вы не можете арестовать сотрудника Полиции!",
	must_be_wanted_for_arrest = "Игрок должен разыскиваться , чтобы его можно было арестовать.",
	cant_arrest_fadmin_jailed = "Вы не можете арестовать игрока, которого посадил администратор.",
	cant_arrest_no_jail_pos = "Вы не можете арестовывать людей , так как место для тюрьмы не выбрано!",
	cant_arrest_spawning_players = "Вы не можете арестовывать людей , которые спаунятся.",

	suspect_doesnt_exist = "Подозреваемый не существует.",
	actor_doesnt_exist = "Актёр не существует.",
	get_a_warrant = "получить ордер",
	make_someone_wanted = "сделать кого-либо разыскиваемым",
	remove_wanted_status = "убрать статус разыскиваемого",
	already_a_warrant = "Уже есть ордер на обыск для этого подозреваемого.",
	already_wanted = "Подозреваемый уже разыскивается.",
	not_wanted = "Подозреваемый не разыскивается.",
	need_to_be_cp = "Вы должны быть работником полиции.",
	suspect_must_be_alive_to_do_x = "Подозреваемый должен быть жив , чтобы %s.",
	suspect_already_arrested = "Подозреваемый уже в тюрьме.",

	-- Players
	health = "Здоровье: %s",
	job = "Работа: %s",
	salary = "Зарплата: %s%s",
	wallet = "Бумажник: %s%s",
	weapon = "Оружие: %s",
	kills = "Убийства: %s",
	deaths = "Смерти: %s",
	rpname_changed = "%s поменял свое RPИмя на: %s",
	disconnected_player = "Отключившийся игрок",

	-- Teams
	need_to_be_before = "Вам нужно стать %s сначала чтобы можно было стать %s",
	need_to_make_vote = "Вам нужно начать голоование , чтобы стать %s!",
	team_limit_reached = "Невозможно стать %s так как лимит исчерпан",
	wants_to_be = "%s\nхочет стать\n%s",
	has_not_been_made_team = "%s не стал %s!",
	job_has_become = "%s стал %s!",

	-- Disasters
	meteor_approaching = "Внимание: Метеоритный шторм надвигается!",
	meteor_passing = "Метеоритный шторм проходит.",
	meteor_enabled = "Метеоритные штормы теперь доступны.",
	meteor_disabled = "Метеоритные штормы теперь выключены.",
	earthquake_report = "Было доложено о землятрясении магнитудой %sMw",
	earthtremor_report = "Было доложено о земных толчках магнитудой %sMw",

	-- Keys, vehicles and doors
	keys_allowed_to_coown = "Вам было разрешено использовать\n(Нажмите R с ключами в руках или нажмите F2 чтобы получить доступ)\n",
	keys_other_allowed = "Разрешено использовать:",
	keys_allow_ownership = "(Нажмите R с ключами в руках или F2 чтобы дать права владельца)",
	keys_disallow_ownership = "(Нажмите R с ключами в руках или F2 чтобы убрать права владельца)",
	keys_owned_by = "Занято:",
	keys_unowned = "Не занято\n(Нажмите R с ключами в руках или F2 чтобы купить)",
	keys_everyone = "(Нажмите R с ключами в руках или F2 чтобы сделать свободный доступ)",
	door_unown_arrested = "Вы не можете купить или продать пока арестованы!",
	door_unownable = "Эту дверь нельзя купить или продать!",
	door_sold = "Вы продали эту дверь за %s",
	door_already_owned = "Эта дверь уже занята!",
	door_cannot_afford = "Вам не хватает денег на эту дверь!",
	door_hobo_unable = "Вы не можете покупать двери если вы бездомный!",
	vehicle_cannot_afford = "Вам не хватает денег на это транспортное средство!",
	door_bought = "Вы купили эту дверь за %s%s",
	vehicle_bought = "Вы купили это транспортное средство за %s%s",
	door_need_to_own = "Вы должны владеть этой дверью чтобы %s",
	door_rem_owners_unownable = "Вы не можете удалить владельцов так как дверь нельзя купить!",
	door_add_owners_unownable = "Вы не можете добавить владельцов так как дверь нельзя купить!",
	rp_addowner_already_owns_door = "%s уже владеет (или уже имеет право пользоваться) этой дверью!",
	add_owner = "Добавить владельца",
	remove_owner = "Удалить владельца",
	coown_x = "Право вдаления  %s",
	allow_ownership = "Разрешить владеть",
	disallow_ownership = "Запретить владеть",
	edit_door_group = "Настроить группы дверей",
	door_groups = "Группы дверей",
	door_group_doesnt_exist = "Группа дверей не существует!",
	door_group_set = "Группа дверей установлена.",
	sold_x_doors_for_y = "Вы продали %d двери за %s%d!", -- backwards compatibility
	sold_x_doors = "Вы продали %d двери за %s!",

	-- Entities
	drugs = "Наркотики",
	drug_lab = "Лаборатория наркотиков",
	gun_lab = "Лаборатория оружия",
	gun = "Оружие",
	microwave = "Микроволновка",
	food = "Еда",
	money_printer = "Денежный принтер",

	sign_this_letter = "Подписать это письмо",
	signed_yours = "Ваш,",

	money_printer_exploded = "Ваш денежный принтер взорвался!",
	money_printer_overheating = "Ваш денежный принтер перегревается!",

	contents = "Содержит: ",
	amount = "Колличество: ",

	picking_lock = "Взламывается замок",

	cannot_pocket_x = "Вы не можете засунуть это себе в карман!",
	object_too_heavy = "Этот объект слишком тяжёлый.",
	pocket_full = "Ваш карман полон!",
	pocket_no_items = "Ваш карман пуст.",
	drop_item = "Выбросить предмет",

	bonus_destroying_entity = "нелегальный предмет уничтожается.",

	switched_burst = "Переключено в режим стрельбы очередями.",
	switched_fully_auto = "Переключено в автоматический режим стрельбы.",
	switched_semi_auto = "Переключено в одиночный режим стрельбы.",

	keypad_checker_shoot_keypad = "Выстрелите в кейпад , чтобы увидеть что его контролирует.",
	keypad_checker_shoot_entity = "Выстрелите в предмет , чтобы увидеть что его контролирует",
	keypad_checker_click_to_clear = "Правый клик чтобы отчистить.",
	keypad_checker_entering_right_pass = "Набирается правильный пароль",
	keypad_checker_entering_wrong_pass = "Набирается неправильный пароль",
	keypad_checker_after_right_pass = "после введения правильного пароля",
	keypad_checker_after_wrong_pass = "aпосле введения неправильного пароля",
	keypad_checker_right_pass_entered = "Правильный пароль введён",
	keypad_checker_wrong_pass_entered = "Неправильный пароль введён",
	keypad_checker_controls_x_entities = "Этот кейпад контролирует %d предметов",
	keypad_checker_controlled_by_x_keypads = "Этот предмет контролируется %d кейпадами",
	keypad_on = "Включено",
	keypad_off = "Выключено",
	seconds = "секунды",

	persons_weapons = "%s нелегальные оружия:",
	returned_persons_weapons = "Возвращены %s конфискованные оружия.",
	no_weapons_confiscated = "%s не имеет конфискованных оружий!",
	no_illegal_weapons = "%s не имеет нелегальное оружие.",
	confiscated_these_weapons = "Конфискованы эти оружия:",
	checking_weapons = "Проверяются оружия",

	shipment_antispam_wait = "Пожалуйста подождите пока предыдущая коробка не появится.",
	shipment_cannot_split = "Нельзя разделить эту коробку.",

	-- Talking
	hear_noone = "Вас никто не может слышать %s!",
	hear_everyone = "Все вас могут слышать!",
	hear_certain_persons = "Игроки , которые слышат вас %s: ",

	whisper = "шёпот",
	yell = "крик",
	advert = "[Реклама]",
	broadcast = "[Извещение!]",
	radio = "радио",
	request = "(ЗАПРОС!)",
	group = "(группа)",
	demote = "(Увольнение)",
	ooc = "OOC",
	radio_x = "Радио %d",

	talk = "говорить",
	speak = "разговаривать",

	speak_in_ooc = "разговаривать в OOC",
	perform_your_action = "выполнить ваше действие",
	talk_to_your_group = "говорить со своей группой",

	channel_set_to_x = "Канал установлен на %s!",

	-- Notifies
	disabled = "%s был отключён! %s",
	gm_spawnvehicle = "Спаун машин",
	gm_spawnsent = "Спаун скриптовых объектов (SENTs)",
	gm_spawnnpc = "Спаун неживых игроков (NPCs)",
	see_settings = "Пожалуйста посмотрите DarkRP настройки.",
	limit = "Вы достигнули %s лимита!",
	have_to_wait = "Вы должны подождать еще %d секунд до использования %s!",
	must_be_looking_at = "Вы должны смотреть на %s!",
	incorrect_job = "У вас неправильная работа для %s",
	unavailable = "Эта %s недоступна",
	unable = "Вы не имеете прав на %s. %s",
	cant_afford = "Вы не можете себе позволить %s",
	created_x = "%s создал %s",
	cleaned_up = "Ваши %s были убраны.",
	you_bought_x = "Вы купили %s за %s%d.", -- backwards compatibility
	you_bought = "Вы купили %s за %s.",
	you_received_x = "Вы получили %s за %s.",

	created_first_jailpos = "Вы создали первую тюремную позицию!",
	added_jailpos = "Вы добавили одну дополнительную тюремную позицию!",
	reset_add_jailpos = "Вы удалили все тюремные позиции и вы установили новую здесь.",
	created_spawnpos = "%s's точка спауна создана.",
	updated_spawnpos = "%s's точка спауна обновлена.",
	do_not_own_ent = "Вы не владеете этим предметом!",
	cannot_drop_weapon = "Вы не можете выбросить это оружие!",
	job_switch = "Работа изменена удачно!",
	job_switch_question = "Поменять работу с помощью %s?",
	job_switch_requested = "Смена работы была запрошена.",

	cooks_only = "Только печеньки.",

	-- Misc
	unknown = "неизвестность",
	arguments = "аргументы",
	no_one = "никого",
	door = "дверь",
	vehicle = "машина",
	door_or_vehicle = "дверь/машина",
	driver = "Водитель: %s",
	name = "Имя: %s",
	locked = "Закрыто.",
	unlocked = "Открыто.",
	player_doesnt_exist = "Игрок не существует.",
	job_doesnt_exist = "Работа не существует!",
	must_be_alive_to_do_x = "Вы должны быть живы чтобы %s.",
	banned_or_demoted = "Забанен/уволен",
	wait_with_that = "Подожи с этим.",
	could_not_find = "Невозможно найти %s",
	f3tovote = "Нажми F3 чтобы голосовать",
	listen_up = "Слушайте все:", -- In rp_tell or rp_tellall
	nlr = "Правило новой жизни(NLR): Не арестовывайте из мести/не убивайте.",
	reset_settings = "Вы обновили все настройки!",
	must_be_x = "Вы должны быть %s чтобы %s.",
	agenda_updated = "Объявление было обновлено",
	job_set = "%s он/она установили себе работу '%s'",
	demoted = "%s был уволен",
	demoted_not = "%s не был уволен",
	demote_vote_started = "%s начал голосование об увольнении %s",
	demote_vote_text = "увольняют по причине:\n%s", -- '%s' is the reason here
	cant_demote_self = "Вы не можете уволить себя.",
	i_want_to_demote_you = "Я хочу уволить тебя. Причина: %s",
	tried_to_avoid_demotion = "Вы попытались уйти от увольнения. Вы провалились и были уволены.", -- naughty boy!
	lockdown_started = "Мэр установил коменданский час, пожалуйста идите домой!",
	lockdown_ended = "Коменданский час окончен",
	gunlicense_requested = "%s запросил у %s лицензию на оружие",
	gunlicense_granted = "%s дал %s лицензию на оружие",
	gunlicense_denied = "%s не дал %s лицензию на оружие",
	gunlicense_question_text = "Дать %s лицензию на оружие?",
	gunlicense_remove_vote_text = "%s начал голосование на лишение лицензии на оружие у %s",
	gunlicense_remove_vote_text2 = "Убрать лицензию на оружие:\n%s", -- Where %s is the reason
	gunlicense_removed = "%s-а лицензия на оружие была отнята!",
	gunlicense_not_removed = "%s-а лицензия на оружие не была отнята!",
	vote_specify_reason = "Вам необходимо указать причину!",
	vote_started = "Голосование было создано",
	vote_alone = "Вы выиграли голосование так как вы одни на сервере.",
	you_cannot_vote = "Вы не можете голосовать!",
	x_cancelled_vote = "%s отменил последнее голосование.",
	cant_cancel_vote = "Не смог отменить голосование так как последнего голосования не было!",
	jail_punishment = "Наказание за выход с сервера! Посажен в тюрьму на: %d секунд.",
	admin_only = "Только админы!", -- When doing /addjailpos
	chief_or = "Главный или",-- When doing /addjailpos
	frozen = "Заморожен.",

	dead_in_jail = "Вы мертвы пока ваше тюремное время не кончится!",
	died_in_jail = "%s умер в тюрьме!",

	credits_for = "КРЕДИТЫ ДЛЯ %s\n",
	credits_see_console = "DarkRP кредиты напечатаны в консоль.",

	rp_getvehicles = "Доступные машины для других машин:",

	data_not_loaded_one = "Ваши данные еще не были загружены. Пожалуйста подождите.",
	data_not_loaded_two = "Если это повторится, попробуйте перезайте или связаться с администрацией.",

	cant_spawn_weapons = "Вы не можете спаунить оружия.",
	drive_disabled = "Вождение отключено.",
	property_disabled = "Частная собственность отключена.",

	not_allowed_to_purchase = "Вам не разрешено покупать этот предмет.",

	rp_teamban_hint = "rp_teamban [имя игрока/ID] [имя команды/id]. Используй это чтобы забанить игрока из определенной команды.",
	rp_teamunban_hint = "rp_teamunban [имя игрока/ID] [имя команды/id]. Используй это чтобы разбанить игрока из определенной команды.",
	x_teambanned_y = "%s забанил %s от профессии %s.",
	x_teamunbanned_y = "%s разбанил %s от профессии %s.",

	-- Backwards compatibility:
	you_set_x_salary_to_y = "Вы установили %s-у зарплату %s%d.",
	x_set_your_salary_to_y = "%s установил вашу зарплату %s%d.",
	you_set_x_money_to_y = "Вы установили %s-у деньги %s%d.",
	x_set_your_money_to_y = "%s установил ваши деньги %s%d.",

	you_set_x_salary = "Вы установили %s-у зарплату %s.",
	x_set_your_salary = "%s установил вашу зарплату %s.",
	you_set_x_money = "Вы установили %s-у деньги %s.",
	x_set_your_money = "%s установил ваши деньги %s.",
	you_set_x_name = "Вы установили %s-у имя %s",
	x_set_your_name = "%s изменил ваше имя на %s",

	someone_stole_steam_name = "Кто-то уже использует ваш логин стима как его рп имя так что мы дали вам '1' после вашего имени.", -- Uh oh
	already_taken = "Уже взято.",

	job_doesnt_require_vote_currently = "Эта работа не запрашивает голосование сейчас!",

	x_made_you_a_y = "%s сделал вас %s!",

	cmd_cant_be_run_server_console = "Эта команда не может быть исполнена через консоль сервера.",

	-- The lottery
	lottery_started = "Появилась лотерея! Участовать за %s%d?", -- backwards compatibility
	lottery_has_started = "Появилась лотерея! Участвовать за %s?",
	lottery_entered = "Вы приняли участие в лотерее за %s",
	lottery_not_entered = "%s не вступил в лотерею",
	lottery_noone_entered = "Никто не вступил в лотерею",
	lottery_won = "%s выиграл лотерею! Он выиграл %s",

	-- Animations
	custom_animation = "Нестандартная анимация!",
	bow = "Лук",
	dance = "Танец",
	follow_me = "Иди за мной!",
	laugh = "Смех",
	lion_pose = "Поза льва",
	nonverbal_no = "Бессловесное нет",
	thumbs_up = "Пальцы вверх",
	wave = "Махать рукой",

	-- Hungermod
	starving = "Голодаю!",

	-- AFK
	afk_mode = "АФК режим",
	salary_frozen = "Ваша зарплата была заморожена.",
	salary_restored = "Добро пожаловать назад , ваша зарплата была разморожена.",
	no_auto_demote = "Вы не будете автоматически уволены.",
	youre_afk_demoted = "Вы были уволены за длительное бездействие. В следующий раз используйте /afk.",
	hes_afk_demoted = "%s был уволен за длительное бездействие.",
	afk_cmd_to_exit = "Напишите /afk чтобы выйти из АФК режима.",
	player_now_afk = "%s теперь АФК.",
	player_no_longer_afk = "%s больше не АФК.",

	-- Hitmenu
	hit = "заказ",
	hitman = "Наемный убийца",
	current_hit = "Заказ: %s",
	cannot_request_hit = "Невозможно выполнить заказ! %s",
	hitmenu_request = "Запрос",
	player_not_hitman = "Этот игрок не наемный убийца!",
	distance_too_big = "Слишком большое расстояние.",
	hitman_no_suicide = "Наемный убийца не убьет сам себя.",
	hitman_no_self_order = "Убийца не может принять заказ на самого себя.",
	hitman_already_has_hit = "Убийца уже принял заказ.",
	price_too_low = "Цена слишком низкая!",
	hit_target_recently_killed_by_hit = "Цель была устранена,",
	customer_recently_bought_hit = "Клиент недавно запросил убийство.",
	accept_hit_question = "Принять заказ от %s\nотносительно %s за %s%d?", -- backwards compatibility
	accept_hit_request = "Принять заказ от %s\nотносительно %s for %s?",
	hit_requested = "Заказ принят!",
	hit_aborted = "Заказ отклонён! %s",
	hit_accepted = "Убийца принял заказ!",
	hit_declined = "Убийца отказался от заказа!",
	hitman_left_server = "Убийца ушел с сервера!",
	customer_left_server = "Заказчик ушел с сервера!",
	target_left_server = "Цель ушла с сервера!",
	hit_price_set_to_x = "цена заказа установлена %s%d.", -- backwards compatibility
	hit_price_set = "цена заказа установлена %s.",
	hit_complete = "заказ от %s завершён!!",
	hitman_died = "Убийца умер!",
	target_died = "Цель мертва!",
	hitman_arrested = "Убийца арестован!",
	hitman_changed_team = "Убийца сменил профессию!",
	x_had_hit_ordered_by_y = "%s выполняет заказ от %s",

	-- Vote Restrictions
	hobos_no_rights = "Бездомные не имеют право голосовать!",
	gangsters_cant_vote_for_government = "Бандиты не имеют права голосовать о правительственных вещах!",
	government_cant_vote_for_gangsters = "Правительство не может голосовать о бандитских вещах!",

	-- VGUI and some more doors/vehicles
	vote = "Голосование",
	time = "Время: %d",
	yes = "Да",
	no = "Нет",
	ok = "Ок",
	cancel = "Отмена",
	add = "Добавить",
	remove = "Удалить",
	none = "Ничего",

	x_options = "%s опции",
	sell_x = "Продать %s",
	set_x_title = "Установить %s title",
	set_x_title_long = "Установить заглавие %s на которое вы смотрите.",
	jobs = "Работа",
	buy_x = "Купить %s",

	-- F4menu
	no_extra_weapons = "Нет запасных оружий.",
	become_job = "Выбрать работу",
	create_vote_for_job = "Создать голосование",
	shipments = "Коробки",
	F4guns = "Оружие",
	F4entities = "Разное",
	F4ammo = "Патроны",
	F4vehicles = "Машины",

	-- Tab 1
	give_money = "Дать деньги игроку на которого вы смотрите",
	drop_money = "Выбросить деньги",
	change_name = "Изменить имя",
	go_to_sleep = "Пойти спать/проснуться",
	drop_weapon = "Выбросить текущее оружие",
	buy_health = "Купить здоровье(%s)",
	request_gunlicense = "Запросить лицензию на оружие",
	demote_player_menu = "Уволить игрока",


	searchwarrantbutton = "Сделать игрока разыскиваемым",
	unwarrantbutton = "Убрать статус разыскиваемого с игрока",
	noone_available = "Никто не доступен",
	request_warrant = "Запросить ордер на обыск для игрока",
	make_wanted = "Сделать кого-либо разыскиваемым",
	make_unwanted = "Убрать розыск с кого-либо",
	set_jailpos = "Установить место для тюрьмы",
	add_jailpos = "Добавить место для тюрьмы",

	set_custom_job = "Установить нестандартную работу (нажмите enter чтобы применить)",

	set_agenda = "Установить объявление (Нажмите enter чтобы применить)",

	initiate_lockdown = "Ввести коменданский час",
	stop_lockdown = "Прекратить коменданский час",
	start_lottery = "Начать лотерею",
	give_license_lookingat = "Дать <lookingat> лицензию на оружие",

	laws_of_the_land = "ЗАКОНЫ ГОРОДА",
	law_added = "Закон добавлен.",
	law_removed = "Закон удалён.",
	law_reset = "Закон перезаписан.",
	law_too_short = "Закон слишком короткий.",
	laws_full = "Закано переполненны.",
	default_law_change_denied = "У вас нет прав менять стандартные законы.",

	-- Second tab
	job_name = "Имя: ",
	job_description = "Описание: ",
	job_weapons = "Оружия: ",

	-- Entities tab
	buy_a = "Купить %s: %s",

	-- Licenseweaponstab
	license_tab = [[License weapons

	Tick the weapons people should be able to get WITHOUT a license!
	]],
	license_tab_other_weapons = "Другие оружия:",

	zombie_spawn_removed = "Вы удалили этот спаун зомби.",
	zombie_spawn = "Спаун зомби",
	zombie_disabled = "Зомби теперь недоступны.",
	zombie_enabled = "Зомби теперь доступны.",
	zombie_maxset = "Максимальное количество зомби теперь %s",
	zombie_spawn_added = "Вы добавили спаун зомби.",
	zombie_spawn_not_exist = "Спаун зомби %s не существует.",
	zombie_leaving = "Зомби уходят.",
	zombie_approaching = "ВНИМАНИЕ: Зомби приближаются!",
	zombie_toggled = "Зомби переключены.",
}

-- The language code is usually (but not always) a two-letter code. The default language is "en".
-- Other examples are "nl" (Dutch), "de" (German)
-- If you want to know what your language code is, open GMod, select a language at the bottom right
-- then enter gmod_language in console. It will show you the code.
-- Make sure language code is a valid entry for the convar gmod_language.
DarkRP.addLanguage("en", my_language)

--PATH addons/111mod/lua/darkrp_modules/vote/cl_notify.lua:
CreateClientConVar('blip', '1')
notification = {}

local function m(m)
    return Material(m, 'smooth')
end

NOTIFY_VOTE = 5

local notifyTypes = {
    [NOTIFY_GENERIC] = {
        Color = Color(51, 128, 255),
        Icon = m'gambitrp/ui/notifications/info.png'
    },
    [NOTIFY_ERROR] = {
        Color = Color(225, 0, 0),
        Icon = m'gambitrp/ui/notifications/error.png'
    },
    [NOTIFY_UNDO] = {
        Color = Color(255, 140, 0),
        Icon = m'gambitrp/ui/notifications/undo.png',
    },
    [NOTIFY_HINT] = {
        Color = Color(51, 128, 255),
        Icon = m'gambitrp/ui/notifications/hint.png'
    },
    [NOTIFY_CLEANUP] = {
        Color = Color(51, 128, 255, 255),
        Icon = m'gambitrp/ui/notifications/hint.png'
    },
    [NOTIFY_VOTE] = {
        Color = Color(245, 120, 0),
        Icon = m'gambitrp/ui/notifications/info.png'
    }
}

for k, v in pairs(notifyTypes) do
    v.BarColor = v.Color:Copy()
    v.BarColor.a = 25
end

local Notices = {}

function notification.AddProgress(uid, text)
end

function notification.Kill(uid)
    if IsValid(Notices[uid]) then
        Notices[uid].StartTime = SysTime()
        Notices[uid].Length = 0.8
    end
end

function notification.AddLegacy(text, type, length)
    type = math.Clamp(type or 0, 0, 4)
    text = tostring(text):Trim()

    if (text:sub(1, 1) == '#') then
        text = language.GetPhrase(text)
    end

    local parent

    if GetOverlayPanel then
        parent = GetOverlayPanel()
    end

    table.insert(Notices, ui.Create('NoticePanel', function(self, p)
        self.NotifyType = type
        self.StartTime = SysTime()
        self.Length = length
        self.VelX = 0
        self.VelY = 0
        self.fx = ScrW() + 200
        self.fy = ScrH()
        self:SetText(text)
        self:SetPos(self.fx, self.fy)
        self:SetMouseInputEnabled(false)
    end, parent))

    MsgC(ui.col.White, '[', notifyTypes[type].Color, 'Notification', ui.col.White, '] ', ui.col.White, text .. '\n')

    if GetConVarNumber("blip") == 1 then
        surface.PlaySound('ambient/water/drip4.wav')
    end
end

-- This is ugly because it's ripped straight from the old notice system
local function UpdateNotice(number, panel, count)
    local x = panel.fx
    local y = panel.fy
    local w = panel:GetWide() + 16
    local h = panel:GetTall() + 16
    local ideal_y = ScrH() - (count - number) * (h - 12) - 150
    local ideal_x = ScrW() - w - 20
    local timeleft = panel.StartTime - (SysTime() - panel.Length)

    if (timeleft < 0.2) then
        ideal_x = ideal_x + w * 2
    end

    local spd = FrameTime() * 15
    y = y + panel.VelY * spd
    x = x + panel.VelX * spd
    local dist = ideal_y - y
    panel.VelY = panel.VelY + dist * spd * 1

    if (math.abs(dist) < 2 and math.abs(panel.VelY) < 0.1) then
        panel.VelY = 0
    end

    local dist = ideal_x - x
    panel.VelX = panel.VelX + dist * spd * 1

    if (math.abs(dist) < 2 and math.abs(panel.VelX) < 0.1) then
        panel.VelX = 0
    end

    panel.VelX = panel.VelX * (0.9 - FrameTime() * 8)
    panel.VelY = panel.VelY * (0.9 - FrameTime() * 8)
    panel.fx = x
    panel.fy = y
    panel:SetPos(panel.fx, panel.fy)
end

hook.Add('Think', 'NotificationThink', function()
    for k, v in ipairs(Notices) do
        UpdateNotice(k, v, #Notices)

        if IsValid(v) and v:KillSelf() then
            table.remove(Notices, k)
        end
    end
end)

local PANEL = {}

function PANEL:Init()
    self.NotifyType = NOTIFY_GENERIC
    self.Label = ui.Create('DLabel', self)
    self.Label:SetFont('ui.22')
    self.Label:SetTextColor(ui.col.White)
    self.Label:SetPos(34, 4)
end

function PANEL:SetText(txt)
    self.Label:SetText(txt)
    self:SizeToContents()
end

function PANEL:SizeToContents()
    self.Label:SizeToContents()
    self:SetWidth(self.Label:GetWide() + 42)
    self:SetHeight(30)
    self:InvalidateLayout()
end

function PANEL:KillSelf()
    if (self.StartTime + self.Length < SysTime()) then
        self:Remove()

        return true
    end

    return false
end

function PANEL:Paint(w, h)
    if (hook.Call('HUDShouldDraw', GAMEMODE, 'Notifications') == false) then return end
    local timeleft = self.StartTime - (SysTime() - self.Length)
    local inf = notifyTypes[self.NotifyType]
    draw.Box(0, 0, w, h, Color(35, 35, 35))
    draw.Box(0, 0, h, h, inf.Color)
    draw.Box(30, 0, (w - 30) * (timeleft / self.Length), h, inf.BarColor)
    surface.SetMaterial(inf.Icon)
    surface.SetDrawColor(255, 255, 255)
    surface.DrawTexturedRect(4, 4, 22, 22)
end

vgui.Register('NoticePanel', PANEL, 'ui_panel')

concommand.Add('ntest', function()
    for i = 0, 4 do
        notification.AddLegacy(('This is a test notification.'):rep(math.random(1, 3)), i, 5)
    end
end)
--PATH addons/111mod/lua/darkrp_modules/menu/cl_init.lua:
local DLabel_PerformLayout, draw_RoundedBox, draw_SimpleText, gui_OpenURL, input_IsKeyDown, ScreenScale, surface_CreateFont, Material, IsValid, ScrW, ScrH, Color, surface_DrawTexturedRect, surface_SetDrawColor, surface_SetMaterial, ui_Create, RunConsoleCommand, ipairs, surface_GetTextSize, surface_SetFont, SysTime, func, Lerp, ColorAlpha, isfunction, callback, table_insert, vgui_Register = DLabel.PerformLayout, draw.RoundedBox, draw.SimpleText, gui.OpenURL, input.IsKeyDown, ScreenScale, surface.CreateFont, Material, IsValid, ScrW, ScrH, Color, surface.DrawTexturedRect, surface.SetDrawColor, surface.SetMaterial, ui.Create, RunConsoleCommand, ipairs, surface.GetTextSize, surface.SetFont, SysTime, func, Lerp, ColorAlpha, isfunction, callback, table.insert, vgui.Register

surface_CreateFont('HUDFancyFont', {
    font = 'PT Root UI Medium',
    size = ScreenScale(6),
    antialias = true,
    extended = true
})

surface_CreateFont('HUDFancyFontBold', {
    font = 'PT Root UI Bold',
    size = ScreenScale(6),
    antialias = true,
    extended = true
})

surface_CreateFont('F4FancyButton', {
    font = 'PT Root UI Medium',
    size = ScreenScale(7),
    antialias = true,
    extended = true
})

surface_CreateFont('F4FancyButtonBold', {
    font = 'PT Root UI Bold',
    size = ScreenScale(7),
    antialias = true,
    extended = true
})

local fr
local close_mat = Material('gambitrp/f4/close.png')

function tToggleF4Menu()
    if IsValid(fr) then
        fr:Close()

        return
    end

    local w, h = ScrW() * 0.625, ScrH() * 0.7
    local wbar = ScrW() * 0.1285
    local htitle = ScrH() * 0.065

    fr = ui_Create('ui_frame', function(self)
        self:SetTitle('')
        self:SetSize(w, h)
        self:MakePopup()
        self:Center()
        local keydown = false

        function self:Think()
            if input_IsKeyDown(KEY_F4) and keydown then
                self:Close()
            elseif (not input_IsKeyDown(KEY_F4)) then
                keydown = true
            end
        end

        local text = "Меню сервера"

        function self:Paint(w, h)
            draw_RoundedBox(16, 0, 0, w, h, Color(45, 45, 45, 253))
            draw_RoundedBox(0, 0, htitle - 1, w, 1, Color(54, 54, 54, 253))
            draw_SimpleText(text, 'F4FancyButton', wbar / 2, htitle / 2, Color(113, 113, 113), 1, 1)
        end

        function self:GetTitleHeight()
            return htitle
        end

        function self.btnClose:Paint(w, h)
            local btnclosew = ScrW() * 0.0105
            surface_SetDrawColor(255, 255, 255, 255)
            surface_SetMaterial(close_mat)
            surface_DrawTexturedRect(ScrW() * 0.0292, h / 2 - btnclosew / 2, btnclosew, btnclosew)
        end

        function self:PerformLayout()
            self.btnClose:SetPos(self:GetWide() - ScrW() * 0.0585, 0)
            self.btnClose:SetSize(ScrW() * 0.0585, ScrH() * 0.0593)
        end
    end)

    fr.tabs = ui_Create('f4_tablist', fr)
    local p = fr.tabs:GetParent()
    local x, y = 0, htitle
    fr.tabs:SetPos(x, y)
    fr.tabs:SetSize(p:GetWide(), p:GetTall() - y)
    fr.tabs:AddTab('Профессии', ui_Create('rp_jobslist'), true):SetIcon'gambitrp/f4/jobs.png'
    fr.tabs:AddTab('Магазин', ui_Create('rp_shoplist')):SetIcon'gambitrp/f4/store.png'

    fr.tabs:AddButton('Донат', function()
        fr:Close()
        RunConsoleCommand("donate")
    end):SetIcon'gambitrp/f4/donate.png'

    -- donate.Think = function(self)
    -- self:SetTextColor(HSVToColor(CurTime()%6*60,1,1)) 
    -- end
    fr.tabs:AddTab('Косметика', function() return f4cosmeticstab(fr.tabs) end):SetIcon'gambitrp/f4/accessory.png'

    --hook.Call('PopulateF4Tabs', GAMEMODE, fr.tabs, fr)
    fr.tabs:AddTab('Ачивки', function() return achsys(fr.tabs) end):SetIcon'gambitrp/f4/achievements.png'

    fr.tabs:AddButton('Кейсы', function()
        fr:Close()
        RunConsoleCommand("say", "/unbox")
    end):SetIcon'gambitrp/f4/bonus.png'

    fr.tabs:AddButton('Одежда', function()
        fr:Close()
        RunConsoleCommand("say", "/accessory")
    end):SetIcon('gambitrp/f4/clothes.png')

    fr.tabs:AddTab('Настройки', function() return f4settingstab(fr.tabs) end):SetIcon'gambitrp/f4/settings.png'

    fr.tabs:AddButton('Правила', function()
        fr:Close()
        gui_OpenURL('https://gambitrp.site/rules')
    end):SetIcon'gambitrp/f4/rules.png'

    fr.tabs:AddButton('Медиа', function()
        fr:Close()
        local frame = ui_Create("ui_frame")
        frame:SetTitle('Медиа')
        frame:SetSize(160, 172) -- 43
        frame:MakePopup()
        frame:Center()
        frametabs = ui_Create('ui_tablist', frame)
        frametabs:DockToFrame()

        -- frametabs:AddButton('Правила', function()
        -- frame:Close()
        -- gui_OpenURL('https://gambitrp.site/rules')
        -- end):SetIcon('gambitrp.siteles_icon.png')
        frametabs:AddButton('STEAM', function()
            frame:Close()
            gui_OpenURL('https://gambitrp.site/steam')
        end):SetIcon('gambitrp/steam.png')

        frametabs:AddButton('Discord', function()
            frame:Close()
            gui_OpenURL('https://gambitrp.site/discord')
        end):SetIcon('gambitrp/discord.png')

        frametabs:AddButton('VK', function()
            frame:Close()
            gui_OpenURL('https://gambitrp.site/vk')
        end):SetIcon('gambitrp/vk.png')

        frametabs:AddButton('Форум', function()
            frame:Close()
            gui_OpenURL('https://forum.gambitrp.site/')
        end):SetIcon('gambitrp/f4_orgs.png')
    end):SetIcon'gambitrp/f4/media.png'
    -- fr.tabs:AddButton('Правила', function()
    -- fr:Close()
    -- gui_OpenURL('https://gambitrp.site/rules')
    -- end)
end

GM.ShowSpare2 = tToggleF4Menu
local PANEL = {}

function PANEL:Init()
    local wbar = ScrW() * 0.1285

    self.tabList = ui_Create('ui_scrollpanel', function(list)
        list:SetSize(wbar, 0)
        list:Dock(LEFT)
        list:SetPadding(0)
    end, self)

    self.Buttons = {}
end

function PANEL:GetButtons()
    return self.Buttons
end

function PANEL:SetActiveTab(num)
    self.ActiveTabID = num

    for k, v in ipairs(self.Buttons) do
        v.Active = (num == k)

        if IsValid(v.Tab) and v.Tab:IsVisible() then
            v.Tab:Dock(NODOCK)
            v.Tab:SetVisible(false)
        end

        if (num == k) then
            if (not v.FinishedLayout) then
                v:LayoutTab()
            end

            v.Tab:SetVisible(true)
            v.Tab:DockMargin(0, 0, 0, 0)
            v.Tab:Dock(FILL)
            self:TabChanged(v.Tab)
        end
    end
end

function PANEL:TabChanged(tab)
end

function PANEL:GetActiveTab()
    for k, v in ipairs(self.Buttons) do
        if (v.Active) then return v.Tab end
    end
end

function PANEL:GetActiveTabID()
    return self.ActiveTabID
end

local grleft = Material('gui/gradient', 'smooth')
local gobut = Material('gambitrp/f4/go.png')
local butgrad = Material('gambitrp/f4/but_grad.png')

local function newbtn(title, tab, func)
    local buth = ScrH() * 0.05556
    local textw = ScrW() * 0.03855
    local gobuth, gobutdist = ScrH() * 0.0085, ScrW() * 0.0063

    local button = ui_Create('DButton', function(btn)
        btn.start = 0
        btn.createtime = SysTime()
        btn:SetSize(0, buth)
        btn:SetText('')
        btn:SetFont('ui.24')
        btn:SetTextColor(ui.col.White)

        btn.DoClick = function(self)
            func(self)
        end

        btn.Paint = function(btn, w, h)
            --draw_RoundedBox(0, 0, 0, w, h, Color(33, 33, 33, Lerp((SysTime() - btn.createtime) * 8, 0, 255)))
            surface_SetFont('F4FancyButton')
            local tw, th = surface_GetTextSize(title)
            draw_SimpleText(title, 'F4FancyButton', textw, h / 2 - th / 2, ColorAlpha(color_white, Lerp((SysTime() - btn.createtime) * 2, 0, 255)))
            surface_SetDrawColor(255, 255, 255, 255)
            surface_SetMaterial(butgrad)
            surface_DrawTexturedRect(0, h - 1, w, 1)

            if btn:IsHovered() or btn.Active then
                surface_SetDrawColor(255, 255, 255, Lerp((SysTime() - btn.start) * 4, 0, 25))
                surface_SetMaterial(grleft)
                surface_DrawTexturedRect(0, 0, w / 1.75, h)
                surface_SetDrawColor(255, 255, 255, Lerp((SysTime() - btn.start) * 4, 0, 255))
                surface_SetMaterial(gobut)
                surface_DrawTexturedRect(textw + tw + gobutdist, h / 2 - gobuth / 2 + 1, gobuth, gobuth)
            else
                btn.start = SysTime()
            end
        end
    end)

    function button:PerformLayout()
        local middleicon = (self:GetWide() - textw) / 4
        local imagemat = self.m_Image:GetMaterial()
        local iconw, iconh = imagemat:Width() * ScrW() / 1920, imagemat:Height() * ScrW() / 1920

        if IsValid(self.m_Image) then
            self:SetContentAlignment(4)
            self.m_Image:SetPos(middleicon - iconw / 2, buth / 2 - iconh / 2)
            self.m_Image:SetSize(iconw, iconh)
        end

        DLabel_PerformLayout(self)
    end

    return button
end

function PANEL:AddTab(title, callback, active)
    local wbar = ScrW() * 0.1285

    local button = newbtn(title, tab, function(s)
        if (not s.FinishedLayout) then
            s:LayoutTab()
        end

        self:SetActiveTab(s.ID)
    end)

    function button.LayoutTab(s)
        local tab = isfunction(callback) and callback(self) or callback
        tab.Paint = function(tab, w, h) end
        tab:SetSize(self:GetWide() - wbar, self:GetTall())
        tab:SetVisible(false)
        tab:SetParent(self)
        tab:SetSkin(self:GetSkin().PrintName)
        s.Tab = tab
        s.FinishedLayout = true
    end

    if (not isfunction(callback)) then
        button:LayoutTab()
    end

    button.ID = table_insert(self.Buttons, button)
    self.tabList:AddItem(button)

    if active then
        self:SetActiveTab(button.ID)
    end

    return button
end

local fr

function PANEL:AddButton(title, func)
    local button = newbtn(title, tab, func)
    self.tabList:AddItem(button)
    table_insert(self.Buttons, btn)
    fr = self

    return button
end

function PANEL:DockToFrame()
    local p = self:GetParent()
    local x, y = p:GetDockPos()
    y = y - 6
    self:SetPos(0, y)
    self:SetSize(p:GetWide(), p:GetTall() - y)
end

function PANEL:Paint(w, h)
    --derma.SkinHook('Paint', 'TabListPanel', self, w, h)
end

vgui_Register('f4_tablist', PANEL, 'Panel')
--PATH addons/111mod/lua/darkrp_modules/gmb_fpsfix/cl_fonts.lua:
AddCSLuaFile()

------------------------------ Mayorlaws ------------------------------

surface.CreateFont( "UrbanichkaFont", {
	font = "Roboto",
	size = (ScrW() + ScrH()) *.007,
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = false,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
})

------------------------------ Doorfont ------------------------------

surface.CreateFont( "DoorDisplayTitleFont", {
	font = "Trebuchet24",
	size = 40,
	weight = 1500, 
	blursize = 0, 
	scanlines = 0, 
	antialias = true, 
	underline = false, 
	italic = false, 
	strikeout = false, 
	symbol = false, 
	rotary = false, 
	shadow = false, 
	additive = false, 
	outline = false,
})

surface.CreateFont( 'DoorMenu', {

    font = 'Roboto',

    size = 17,

    weight = 400

})

surface.CreateFont( 'DoorMenu_mini', {

    font = 'Roboto',

    size = 15,

    weight = 400
    
})

------------------------------ NPC ------------------------------

surface.CreateFont( "UrbanichkaNPC", {
	font = "Roboto",
	size = 90,
	weight = 1000,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = true,
	additive = false,
	outline = false,
})

------------------------------ GreenZone ------------------------------

surface.CreateFont( "UrbanichkaGreenZone", {
	font = "Roboto", 
	extended = false,
	size = 500,
	weight = 2000,
	blursize = 0,
	scanlines = 0,
	antialias = false,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

surface.CreateFont( "UrbanichkaGreenMayor", {
	font = "Roboto", 
	extended = false,
	size = 30,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
})

------------------------------ Scoreboard ------------------------------

surface.CreateFont('rp.Scoreboard.Label', {
    font = 'Roboto',
	size = 14,
	weight = 500
})

surface.CreateFont('rp.Scoreboard.Logo', {
    font = 'Roboto',
	size = 70,
	weight = 500
})
  
------------------------------ Voting ------------------------------  

surface.CreateFont("DarkRPVoteButtonText", {
	font = "Arial",
	size = 15,
	weight = 100,
	antialias = true,
})

------------------------------ Services ------------------------------

surface.CreateFont( "911_font_36", { font = "DermaDefault", size = 36, weight = 600, bold = true, strikeout = false, outline = false, shadow = false, outline = false,})
surface.CreateFont( "911_font_24", { font = "DermaDefault", size = 24, weight = 600, bold = true, strikeout = false, outline = false, shadow = false, outline = false,})
surface.CreateFont( "911_font_20", { font = "DermaDefault", size = 20, weight = 600, bold = true, strikeout = false, outline = false, shadow = false, outline = false,})
surface.CreateFont( "911_font_18", { font = "DermaDefault", size = 18, weight = 600, bold = true, strikeout = false, outline = false, shadow = false, outline = false,})
surface.CreateFont( "911_font_16", { font = "DermaDefault", size = 16, weight = 600, bold = true, strikeout = false, outline = false, shadow = false, outline = false,})
surface.CreateFont( "911_font_14", { font = "DermaDefault", size = 14, weight = 600, bold = true, strikeout = false, outline = false, shadow = false, outline = false,})
surface.CreateFont( "911_font_11", { font = "DermaDefault", size = 11, weight = 600, bold = true, strikeout = false, outline = false, shadow = false, outline = false,})
  
------------------------------ Hudlaws ------------------------------

surface.CreateFont("LawHeaderFont", {font = "Roboto", size = 20, weight = 400})
surface.CreateFont("LawFont", {font = "Roboto", size = 17})
    
------------------------------ Alchemy ------------------------------

surface.CreateFont( "Alchemy_Small", {
	font = "Arial",
	extended = false,
	size = ScrW()*0.01,
	weight = 500,
	antialias = true,
})

surface.CreateFont( "Alchemy_Low", {
	font = "Arial",
	extended = false,
	size = ScrW()*0.02,
	weight = 500,
	antialias = true,
})

surface.CreateFont( "Alchemy_Medium", {
	font = "Arial",
	extended = false,
	size = ScrW()*0.03,
	weight = 500,
	antialias = true,
})

surface.CreateFont( "Alchemy_High", {
	font = "Arial",
	extended = false,
	size = ScrW()*0.06,
	weight = 500,
	antialias = true,
})

------------------------------ Keypad ------------------------------

surface.CreateFont("KeypadAbort", {font = "Roboto", size = 40, weight = 900})
surface.CreateFont("KeypadOK", {font = "Roboto", size = 50, weight = 900})
surface.CreateFont("KeypadNumber", {font = "Roboto", size = 60, weight = 600})
surface.CreateFont("KeypadEntry", {font = "Roboto", size = 110, weight = 900})
surface.CreateFont("KeypadStatus", {font = "Roboto", size = 50, weight = 900})
    
------------------------------ UrbanPrinter ------------------------------

surface.CreateFont( "printer50", {
	font = "Roboto",
	size = 50,
	weight = 100
})
surface.CreateFont( "printer40", {
	font = "Roboto",
	size = 40,
	weight = 100
})
surface.CreateFont( "printer30", {
	font = "Roboto",
	size = 30,
	weight = 100
})
surface.CreateFont( "printer25", {
	font = "Roboto",
	size = 25,
	weight = 100
})
surface.CreateFont( "printer20", {
	font = "Roboto",
	size = 20,
	weight = 100
})
surface.CreateFont( "printer15", {
	font = "Roboto",
	size = 15,
	weight = 100
})
--PATH addons/111mod/lua/darkrp_customthings/jobs.lua:
DarkRP.createCategory{ 
   name = "Профессии",
   categorises = "jobs",
   startExpanded = false,
   color = Color(18, 135, 0, 255),
   canSee = function(ply) return true end,
   sortOrder = 1,
}

local vipRanks = {
	['vip']             = true,
	['NS-moder'] 		= true,
	['downer']          = true,
	['NS-admin'] 	    = true,
	['NS-helper'] 	    = true,
	['sponsor'] 		= true,
	['padmin'] 		    = true,
	['moder'] 		    = true,
	['overwatch'] 		= true,
	['manager'] 		= true,
	['dsuperadmin'] 	= true,
	['superadmin'] 		= true,
	['NS-trainee'] 		= true,
	['NS-mlmoder'] 		= true,
	['NS-mladmin'] 		= true,
	['NS-assistant'] 	= true,
	['uprav'] 		    = true,
	['NS-zammanager'] 	= true,
}

local adminRanks = {
	['NS-moder'] 		= true,
	['downer']          = true,
	['NS-admin'] 	    = true,
	['NS-helper'] 	    = true,
	['sponsor'] 		= true,
	['padmin'] 		    = true,
	['moder'] 		    = true,
	['overwatch'] 		= true,
	['manager'] 		= true,
	['dsuperadmin'] 	= true,
	['superadmin'] 		= true,
	['NS-trainee'] 		= true,
	['NS-mlmoder'] 		= true,
	['NS-mladmin'] 		= true,
	['NS-assistant'] 	= true,
	['uprav'] 		    = true,
	['NS-zammanager'] 	= true,
}

local function isVIP(ply)
    return vipRanks[ply:GetUserGroup()]
end

local function isAdmin(ply)
    return adminRanks[ply:GetUserGroup()]
end

TEAM_CITIZEN = DarkRP.createJob("Гражданин", {
   color = Color(0, 201, 8, 255),
   model = {
   "models/player/Group02/male_02.mdl",
   "models/player/Group01/male_01.mdl",
   "models/player/Group01/male_03.mdl",
   "models/player/Group01/male_09.mdl",
   "models/player/Group01/male_07.mdl",
   "models/player/Group01/male_08.mdl",
   "models/player/Group01/female_01.mdl",
   "models/player/Group01/female_02.mdl",
   },
   description = [[
✔ Описание:
● Вы обычный гражданин, вам необходимо устроится на работу!
● У вас нет предопределенной роли в жизни города
● Вы можете придумать себе свою собственную работу]],
   weapons = {"weapon_fists","passrus"},
   command = "citizen",
   max = 0,
   salary = 45,
   admin = 0,
   vote = false,
   hasLicense = false,
   candemote = false,
   category = "     Гражданские",
})

TEAM_BUIS = DarkRP.createJob("Бизнесмен", {
   color = Color(191, 151, 134, 255),
   model = {
   "models/player/Group02/male_04.mdl",
   "models/player/Group01/male_05.mdl",
   "models/player/Group01/male_06.mdl",
   "models/player/Group01/male_07.mdl",
   "models/player/Group01/male_08.mdl",
   "models/player/Group01/male_09.mdl",
   },
   description = [[
✔ Описание:
● Вы Бизнесмен!
● Придумывайте уникальные способы заработка
● Воплощайте их в реальность]],
   weapons = {"weapon_fists","passrus"},
   command = "buis",
   max = 3,
   salary = 60,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "     Гражданские",
})

TEAM_OHOT = DarkRP.createJob("Охотник на собак", {
   color = Color(54, 102, 112, 255),
   model = {
   "models/player/charple.mdl",
   },
   description = [[
✔ Описание:
● Вы Охотник на собак!
● Ловите агрессивных бездомных собак
● Уничтожайте их или приручайте]],
   weapons = {"weapon_fists","passrus", "weapon_crowbar"},
   command = "ohotr",
   max = 1,
   salary = 115,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "     Гражданские",
   PlayerLoadout = function(ply) ply:SetArmor(50) end,
})

-- TEAM_NASIL = DarkRP.createJob("Проститутка", {
   -- color = Color(125, 29, 122, 255),
   -- model = {
   -- "models/player/alyx.mdl",
   -- },
   -- description = [[
-- ✔ Описание:
-- ● Вы Проститутка!
-- ● Предлагайте свои секс услуги городу]],
   -- weapons = {"weapon_fists","passrus"},
   -- command = "nasil",
   -- max = 2,
   -- salary = 60,
   -- admin = 0,
   -- vote = false,
   -- hasLicense = false,
   -- category = "     Гражданские",
-- })

TEAM_PARKOUR = DarkRP.createJob("Паркурист", {
   color = Color(255, 0, 238),
   model = {"models/player/p2_chell.mdl"},
   description = [[
✔ Описание:
● Вы Паркурист!
● Вы знамениты своей ловкостью и гибкостью
● Удивляйте город и соревнуйтесь с другими паркуристами]],
   weapons = {"weapon_fists","passrus", "weapon_parkour"},
   command = "parkour",
   max = 4,
   salary = 55,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "     Гражданские",
})

TEAM_SEC = DarkRP.createJob("Охрана", {
   color = Color(0, 162, 148, 255),
   model = "models/player/odessa.mdl",
   description = [[
✔ Описание:
● Вы Охрана!
● Нанимайтесь на охрану магазина, банка, предприятия
● Вы должны защищать заведение от хулиганов и мелких воров
● При сложной ситуации вызывайте полицию]],
   weapons = {"stunstick", "weapon_fists","passrus", "weaponchecker"},
   command = "sec",
   max = 5,
   salary = 80,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "     Гражданские",
})

TEAM_BANK = DarkRP.createJob("Банкир", {
   color = Color(79, 121, 66, 255),
    model = {"models/player/barney.mdl"},
   description = [[
✔ Описание:
● Вы Банкир!
● Банкир работает на государственном хранилище
● Принимайте вклады других людей
● Наймите охрану для защиты]],
   weapons = {"weapon_fists","passrus"},
   command = "bankir",
   max = 3,
   salary = 70,
   admin = 0,
   vote = false,
   hasLicense = true,
   category = "     Гражданские",
})

TEAM_BIT = DarkRP.createJob("Битмайнер", {
   color = Color(107, 107, 107, 255),
   model = {"models/player/Group03/male_01.mdl", "models/player/Group03/male_02.mdl", "models/player/Group03/male_03.mdl","models/player/Group03/male_08.mdl", "models/player/Group03/male_09.mdl", "models/player/Group03/male_05.mdl", "models/player/Group03/female_01.mdl", "models/player/Group03/female_02.mdl", "models/player/Group03/female_05.mdl",},
   description = [[
✔ Описание:
● Вы Битмайнер!
● Майнинг полностью легален, но следите за их запретом в законах]],
   weapons = {"weapon_fists","passrus"},
   command = "bit",
   max = 6,
   salary = 20,
   admin = 0,
   vote = false,
   candemote = false,
   hasLicense = false,
   category = "     Гражданские",
})

TEAM_FISH = DarkRP.createJob("Рыбак", {
   color = Color(234, 204, 97, 255),
    model = {"models/sirgibs/ragdolls/hl2/fisherman_player.mdl"},
   description = [[
✔ Описание:
● Вы Рыбак!
● Наслаждайтесь ловлей рыбы в местных водойомах
● Продавайте улов местному скупщику]],
   weapons = {"weapon_fists","passrus"},
   command = "fishman",
   max = 6,
   salary = 70,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "     Гражданские",
})

TEAM_HOBO = DarkRP.createJob("Бездомный", {
   color = Color(148, 80, 3, 255),
   model = {"models/player/corpse1.mdl"},
   description = [[
✔ Описание:
● Вы Бездомный, у вас нету дома!
● Вы вынуждены просить еду и деньги
● Объединитесь с другими бездомными и постройте бомжеград!]],
   weapons = {"weapon_fists","passrus","weapon_bugbait"},
   command = "Hobo",
   max = 0,
   salary = 10,
   admin = 0,
   vote = false,
   hasLicense = false,
--  hobo = true,
   category = "    Бездомные",
})

TEAM_HOBOO = DarkRP.createJob("Глава бездомных", {
   color = Color(107, 45, 45, 255),
   model = {"models/player/corpse1.mdl"},
   description = [[
✔ Описание:
● Вы Глава Бездомных, устраивайте митинги!
● Вы вынуждены просить еду и деньги
● Постройте базу для ваших братьев]],
   weapons = {"weapon_fists","passrus", "weapon_bugbait"},
   command = "Hoboo",
   max = 1,
   salary = 10,
   admin = 0,
   vote = false,
   hasLicense = false,
--  hobo = true,
   category = "    Бездомные",
})

TEAM_GUN = DarkRP.createJob("Продавец оружия", {
    color = Color(255, 140, 0, 255),
    model = "models/player/monk.mdl",
    description = [[
✔ Описание:
● Вы Продавец оружия!
● Торгуйте оружием - получайте с этого прибыль
● Получите лиценизию на торговлю у мэра]],
    weapons = {"weapon_fists","passrus"},
    command = "gundealer",
    max = 4,
    salary = 70,
    admin = 0,
	playtime = 7200,
    vote = false,
    hasLicense = false,
   category = " Торговцы",
})

TEAM_MEDIC = DarkRP.createJob("Врач", {
   color = Color(33, 88, 119, 255),
   model = {"models/player/Group03m/male_01.mdl", "models/player/Group03m/male_04.mdl", "models/player/Group03m/male_03.mdl", "models/player/Group03m/male_02.mdl", "models/player/Group03m/female_01.mdl", "models/player/Group03m/female_02.mdl", "models/player/Group03m/female_06.mdl"},
   description = [[
✔ Описание:
● Вы Врач!
● Лечите жителей города - получайте с этого прибыль
● Откройте свою больницу для удобства]],
   weapons = {"weapon_fists","passrus", "weapon_medkit"},
   command = "medic",
   max = 4,
   salary = 65,
   admin = 0,
   vote = false,
   hasLicense = false,
--   medic = true,
   category = " Торговцы",
})

TEAM_STORE = DarkRP.createJob("Торговец", {
   color = Color(108, 166, 49, 255),
   model = {"models/player/mossman.mdl"},
   description = [[
✔ Описание:
● Вы Торговец!
● Торгуйте полезными примочками]],
   weapons = {"weapon_fists","passrus"},
   command = "store",
   max = 4,
   salary = 70,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = " Торговцы",
})

TEAM_COOK = DarkRP.createJob("Повар", {
    color = Color(238, 99, 99, 255),
    model = {
    "models/fearless/chef1.mdl",
     },
    description = [[
✔ Описание:
● Вы Повар!
● Готовьте еду для граждан города!
● Организуйте ларек и продавайте еду]],
    weapons = {"skovorodka", "weapon_fists","passrus"},
    command = "cook",
    max = 4,
    salary = 200,
    admin = 0,
    vote = false,
    hasLicense = false,
    category = " Торговцы",
    cook = true
})

-- TEAM_METIK = DarkRP.createJob("Варщик мета", {
   -- color = Color(3, 166, 226, 255),
   -- model = {'models/player/hostage/hostage_01.mdl', 'models/player/hostage/hostage_02.mdl', 'models/player/hostage/hostage_03.mdl', 'models/player/hostage/hostage_04.mdl'},
   -- description = [[
-- ✔ Описание:
-- ● Вы Варщик мета!
-- ● Варите мет и продавайте его барыге]],
   -- weapons = {"weapon_fists","passrus"},
   -- command = "metik",
   -- max = 4,
   -- salary = 100,
   -- admin = 0,
   -- vote = false,
   -- hasLicense = false,
--  hobo = true,
   -- category = "  Криминал",
-- })

TEAM_DRUG = DarkRP.createJob("Гровер", {
   color = Color(0, 200, 142),
   model = {"models/player/group03/male_04.mdl"},
   description = [[
✔ Описание:
● Вы Гровер!
● Выращивайте и торгуйте наркотиками.
● Для безопасности бизнеса запишитесь в ряды банды
● Но при каждой сделке опасайтесь полиции]],
   weapons = {"weapon_fists","passrus","zwf_shoptablet", "zwf_cable", "zwf_wateringcan"},
   command = "narko",
   max = 3,
   salary = 90,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "  Криминал",
})

TEAM_CGANG = DarkRP.createJob("Наркодилер", {
   color = Color(109,101,82, 255),
   model = {"models/player/Group03/male_01.mdl", "models/player/Group03/male_02.mdl", "models/player/Group03/male_03.mdl","models/player/Group03/male_08.mdl", "models/player/Group03/male_09.mdl", "models/player/Group03/male_05.mdl", "models/player/Group03/female_01.mdl", "models/player/Group03/female_02.mdl", "models/player/Group03/female_05.mdl",},
   description = [[
✔ Описание:
● Вы Наркодилер!
● Вы криминальное лицо этого города
● Изготавливайте и продавайте кокаин]],
   weapons = {"weapon_fists","passrus"},
   command = "chemicgangster",
   max = 4,
   salary = 100,
   admin = 0,
   vote = false,
   vip = true,
   hasLicense = false,
   category = "  Криминал",
   customCheck = isVIP,
   CustomCheckFailMsg = "Вы не VIP!"
})

TEAM_MANIAK = DarkRP.createJob("Маньяк", {
   color = Color(128, 63, 84, 255),
   model = {"models/player/mkx_jason.mdl"},
   description = [[
✔ Описание:
● Вы Маньяк!
● Связывайте людей в переулках и проводите пытки
● На вас не работает FearRP (до 2 человек)
● Маскируйтесь под других людей]],
   weapons = {"csgo_cssource", "weapon_fists","passrus", "swep_disguise_briefcase", 'weapon_cuff_rope'},
   command = "murder",
   max = 3,
   salary = 60,
   admin = 0,
   playtime = 10800,
   vote = false,
   hasLicense = false,
   category = "  Криминал",
})

TEAM_HIT = DarkRP.createJob("Наемный убийца", {
   color = Color(114,20,34, 255),
   model = {"models/player/hitman_absolution_47_classic.mdl"},
   description = [[
✔ Описание:
● Вы Наемный убийца!
● Вы ликвидируете людей за деньги
● Вы не можете убивать за бесплатно или просто так
● Ликвидируйте людей пока их никто не видит]],
   weapons = {"weapon_fists","passrus"},
   command = "killer",
   max = 3,
   salary = 100,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "  Криминал",
})

TEAM_ASSASIN = DarkRP.createJob("Ассасин", {
   color = Color(92, 45, 123),
   model = {"models/player/ezio.mdl"},
   description = [[
✔ Описание:
● Вы Ассасин!
● Выполняйте заказы на ликвидацию людей.
● После убийства как можно скорее скройтесь]],
   weapons = {"weapon_parkour", "weapon_fists","passrus", "csgo_cssource"},
   command = "assasin",
   max = 3,
   salary = 60,
   admin = 0,
   vote = false,
   hasLicense = false,
   vip = true,
   category = "  Криминал",
   customCheck = isVIP,
   CustomCheckFailMsg = "Вы не VIP!"
})

TEAM_GANG = DarkRP.createJob("Бандит", {
   color = Color(67,71,80, 255),
   model = {"models/sentry/mafia/c/sentrygreasemale4pm.mdl","models/sentry/mafia/c/sentrygreasemale2pm.mdl","models/sentry/mafia/c/sentrygreasemale7pm.mdl","models/sentry/mafia/c/sentrygreasemale9pm.mdl","models/sentry/mafia/d/sentryirishmale7pm.mdl","models/sentry/mafia/d/sentryirishmale2pm.mdl"},
   description = [[
✔ Описание:
● Вы Бандит!
● Вы криминальное лицо этого города
● Грабьте людей, собирайте налоги в пределах РП
● Максимальная сумма ограбления - 10.000$]],
   weapons = {"weapon_fists","passrus", "moneychecker"},
   command = "gangster",
   max = 15,
   salary = 20,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "  Криминал",
})

TEAM_MOB = DarkRP.createJob("Глава бандитов", {
   color = Color(0, 0, 0, 255),
   model = {"models/sentry/mafia/b/sentrybusi1male8pm.mdl","models/sentry/mafia/b/sentrybusi1male9pm.mdl"},
   description = [[
✔ Описание:
● Вы Глава бандитов!
● Вы являетесь самым главным преступником в городе
● Вы можете выпускать из тюрем людей
● Делайте налеты, рейды совместно с бандитами]],
   weapons = {"unarrest_stick", "weapon_fists","passrus", "lockpick", "weapon_cuff_rope","moneychecker"},
   command = "mobboss",
   max = 1,
   salary = 150,
   admin = 0,
   vote = false,
   hasLicense = false,
   PlayerSpawn = function(ply) ply:SetArmor (200) ply:SetHealth (150) end,
   PlayerLoadout = function(ply) ply:SetArmor (200) ply:SetHealth (150) end,
   category = "  Криминал",
})

TEAM_EGANG = DarkRP.createJob("Элитный Бандит", {
   color = Color(29, 31, 29, 255),
   model = {"models/sentry/mafia/a/sentryarmbmale2pm.mdl","models/sentry/mafia/a/sentryarmbmale6pm.mdl","models/sentry/mafia/a/sentryarmbmale8pm.mdl","models/sentry/mafia/b/sentrybusi1male2pm.mdl","models/sentry/mafia/b/sentrybusi1male6pm.mdl","models/sentry/mafia/b/sentrybusi1male7pm.mdl"},
   description = [[
✔ Описание:
● Вы Элитный Бандит!
● Вы являетесь авторитетным бандитом
● Делайте налеты, рейды совместно с бандитами]],
   weapons = {"lockpick", "weapon_fists","passrus", "tryba","moneychecker"},
   command = "egangster",
   max = 11,
   salary = 50,
   admin = 0,
   vote = false,
   hasLicense = false,
   vip = true,
   category = "  Криминал",
   PlayerSpawn = function(ply) ply:SetArmor (100) end,
   PlayerLoadout = function(ply) ply:SetArmor (100) end,
   customCheck = isVIP,
   CustomCheckFailMsg = "Вы не VIP!"
})

TEAM_VOR = DarkRP.createJob("Вор", {
   color = Color(41,49,51, 255),
   model = {"models/sentry/mafia/f/voryga3.mdl","models/sentry/mafia/f/voryga4.mdl","models/sentry/mafia/f/voryga5.mdl"},
   description = [[
✔ Описание:
● Вы Вор!
● Вскрывайте дома, машины
● После обнаружения скрывайтесь с места преступления]],
   weapons = {"lockpick", "weapon_fists","passrus", "moneychecker"},
   command = "vor",
   max = 3,
   salary = 20,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "  Криминал",
})

TEAM_THIEFF = DarkRP.createJob("Умелый Вор", {
   color = Color(41,49,51, 255),
   model = {"models/sentry/mafia/f/voryga1.mdl","models/sentry/mafia/d/sentryirishmale7pm.mdl","models/sentry/mafia/f/voryga2.mdl","models/sentry/mafia/c/sentrygreasemale9pm.mdl"},
   description = [[
✔ Описание:
● Вы Умелый Вор!
● Вскрывайте дома, машины намного быстрее
● После обнаружения скрывайтесь с места преступления
● Работая в группировке вы не можете использовать оружие]],
   weapons = {"lockpick", "weapon_fists","passrus", "swep_pickpocket","moneychecker","keypad_cracker"},
   command = "statvipvorom",
   category = "  Криминал",
   max = 4,
   salary = 65,
   admin = 0,
   vote = false,
   vip = true,
   HasLicense = false,
   PlayerSpawn = function(ply) ply:SetArmor (100) end,
   PlayerLoadout = function(ply) ply:SetArmor (100) end,
   customCheck = isVIP,
   CustomCheckFailMsg = "Вы не VIP!"
})

TEAM_SHPION = DarkRP.createJob("Шпион", {
   color = Color(70, 93, 122),
   model = {"models/player/leet.mdl"},
   description = [[
✔ Описание:
● Вы Шпион!
● Ведите секретную слежку за людьми, полицией
● Выполняйте ответственные РП задачи
● Маскируйтесь под других людей]],
   weapons = {"weapon_crowbar", "weapon_fists","passrus", "swep_disguise_briefcase", "unarrest_stick"},
   command = "shpion",
   max = 3,
   salary = 60,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "  Криминал",
})

TEAM_GRAB = DarkRP.createJob("Грабитель", {
   color = Color(70, 93, 122),
   model = {"models/sentry/mafia/c/sentrygreasemale4pm.mdl","models/sentry/mafia/c/sentrygreasemale7pm.mdl","models/sentry/mafia/d/sentryirishmale10pm.mdl","models/sentry/mafia/d/sentryirishmale7pm.mdl"},
   description = [[
✔ Описание:
● Вы Грабитель!
● Обворовывайте людей
● Угрожайте им вашим стволом для большего результата]],
   weapons = {"swep_pickpocket", "weapon_fists","passrus", "weapon_cuff_rope","moneychecker"},
   command = "grabitel",
   max = 3,
   salary = 20,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "  Криминал",
})

TEAM_HACKER = DarkRP.createJob("Хакер", {
   color = Color(70, 93, 122),
   model = {"models/player/Group03/male_09.mdl","models/player/Group03/male_02.mdl", "models/player/Group03/male_03.mdl","models/player/Group03/male_08.mdl", "models/player/Group03/male_05.mdl", "models/player/Group03/female_01.mdl", "models/player/Group03/female_02.mdl", "models/player/Group03/female_05.mdl",},
   description = [[
✔ Описание:
● Вы Хакер!
● Вы умеете взламывать Keypad игроков
● Ваши умения ценятся в криминальной сфере]],
   weapons = {"keypad_cracker", "swep_pickpocket", "weapon_fists","passrus", "weapon_cuff_rope","moneychecker"},
   command = "hacker",
   max = 3,
   salary = 20,
   admin = 0,
   vote = false,
   hasLicense = false,
   category = "  Криминал",
})

-- TEAM_TERROR = DarkRP.createJob("Террорист", {
   -- color = Color(104, 44, 45, 255),
   -- model = {"models/code_gs/osama/osamaplayer.mdl",},
   -- description = [[
-- ✔ Описание:
-- ● Вы Террорист!
-- ● Перед терактом напишите в даркнет о предстоящем теракте
-- ● Устраивайте теракты на улицах города]],
   -- weapons = {"weapon_frag", "swep_pickpocket", "weapon_fists","passrus", "weapon_cuff_rope","moneychecker"},
   -- command = "terror",
   -- max = 1,
   -- salary = 20,
   -- admin = 0,
   -- vote = false,
   -- playtime = 14400,
   -- hasLicense = false,
   -- category = "  Криминал",
-- })

TEAM_POLICE = DarkRP.createJob("Офицер Полиции", {
   color = Color(0, 56, 255, 255),
   model = {
   "models/player/kerry/policeru_11.mdl",
   "models/player/kerry/policeru_11_armor.mdl",
   "models/player/kerry/policeru_15.mdl",
   },
   description = [[
✔ Описание:
● Вы Офицер Полиции!
● Защищайте город, арестовывайте преступников]],
   weapons = {"arrest_stick", "weapon_fists","passrus", "stunstick", "weaponchecker", "unarrest_stick", "usp", "ump", "cuff", "dsr_taser", "door_ram"},
   command = "coop",
   max = 0,
   salary = 225,
   admin = 0,
   vote = false,
   playtime = 3600,
   hasLicense = true,
   category = "   Правопорядок",
   --PlayerLoadout = function(ply) ply:ChatPrint('Вам доступен Арсенал!Получить его можно в Полицейском Участке') end,
})

TEAM_CHIEF = DarkRP.createJob("Начальник полиции", {
   color = Color(0, 56, 255, 255),
   model = {"models/player/kerry/policeru_06.mdl"},
   description = [[
✔ Описание:
● Вы Начальник Полиции!
● Раздавайте приказы полицейским
● Ваша задача грамотно руководить полицией]],
   weapons = {"arrest_stick", "weapon_fists","passrus", "unarrest_stick", "stunstick", "weaponchecker", "revolver", "xm1014", "cuff", "dsr_taser", "door_ram", "heavy_shield"},
   command = "chief",
   max = 1,
   salary = 350,
   admin = 0,
   vote = true,
   hasLicense = true,
   playtime = 7200,
   chief = true,
   PlayerSpawn = function(ply) ply:SetArmor (200) end,
   PlayerLoadout = function(ply) ply:SetArmor (200) end,
   category = "   Правопорядок",
   --PlayerLoadout = function(ply) ply:ChatPrint('Вам доступен Арсенал!Получить его можно в Полицейском Участке') end,
})

TEAM_OMON = DarkRP.createJob("Спецназ", {
   color = Color(29, 36, 191, 255),
   model = {"models/mw2/skin_09/MW2_Soldier_01.mdl"},
   description = [[
✔ Описание:
● Вы Спецназ!
● Вы являетесь опытным бойцом элитного подразделения
● Выполняйте задачи высокой сложности]],
   weapons = {"arrest_stick", "weapon_fists","passrus", "weapon_flashgrenade", "stunstick", "weaponchecker", "unarrest_stick", "mp5", "cuff", "dsr_taser", "door_ram", "heavy_shield"},
   command = "omon",
   max = 5,
   salary = 250,
   playtime = 5400,
   admin = 0,
   vote = false,
   hasLicense = true,
   PlayerSpawn = function(ply) ply:SetArmor (150) end,
   PlayerLoadout = function(ply) ply:SetArmor (150) end,
   category = "   Правопорядок",
   --PlayerLoadout = function(ply) ply:ChatPrint('Вам доступен Арсенал!Получить его можно в Полицейском Участке') end,
})

TEAM_DOMON = DarkRP.createJob("Медик спецназа", {
   color = Color(29, 36, 191, 255),
   model = {"models/mw2/skin_09/MW2_Soldier_02.mdl"},
   description = [[
✔ Описание:
● Вы Медик спецназа!
● Вы являетесь опытным бойцом элитного подразделения
● Выполняйте задачи высокой сложности
● Лечите бойцов подразделения]],
   weapons = {"arrest_stick", "stunstick", "weapon_fists","passrus", "weaponchecker", "unarrest_stick", "mp5", "weapon_medkit", "cuff", "dsr_taser", "door_ram", "heavy_shield"},
   command = "domon",
   max = 5,
   salary = 250,
   admin = 0,
   vote = false,
   playtime = 5400,
   hasLicense = true,
   PlayerSpawn = function(ply) ply:SetArmor (150) end,
   PlayerLoadout = function(ply) ply:SetArmor (150) end,
   category = "   Правопорядок",
   --PlayerLoadout = function(ply) ply:ChatPrint('Вам доступен Арсенал!Получить его можно в Полицейском Участке') end,
})

TEAM_SOMON = DarkRP.createJob("Снайпер спецназа", {
   color = Color(29, 36, 191, 255),
   model = {"models/mw2/skin_09/MW2_Soldier_06.mdl"},
   description = [[
✔ Описание:
● Вы Снайпер спецназа!
● Вы являетесь опытным бойцом элитного подразделения
● Выполняйте задачи высокой сложности
● Прикрывайте союзников с воздуха]],
   weapons = {"arrest_stick", "stunstick", "weapon_fists","passrus", "weaponchecker", "unarrest_stick", "scout", "cuff", "dsr_taser", "door_ram", "heavy_shield"},
   command = "somon",
   max = 5,
   salary = 250,
   playtime = 5400,
   admin = 0,
   vote = false,
   hasLicense = true,
   PlayerSpawn = function(ply) ply:SetArmor (150) end,
   PlayerLoadout = function(ply) ply:SetArmor (150) end,
   category = "   Правопорядок",
   --PlayerLoadout = function(ply) ply:ChatPrint('Вам доступен Арсенал!Получить его можно в Полицейском Участке') end,
})

TEAM_ROMON = DarkRP.createJob("Командир спецназа", {
   color = Color(30, 94, 158, 255),
   model = {"models/payday2/units/zeal_swat_player.mdl"},
   description = [[
✔ Описание:
● Вы Командир спецназа!
● Вы являетесь опытным бойцом элитного подразделения
● Выполняйте задачи высокой сложности
● Организовывайте рейды, планы атак, состав бойцов]],
   weapons = {"arrest_stick", "weapon_fists","passrus", "weapon_flashgrenade", "unarrest_stick", "stunstick", "weaponchecker", "m4a1", "cuff", "dsr_taser", "door_ram", "heavy_shield"},
   command = "rspecnaz",
   max = 1,
   salary = 350,
   admin = 0,
   vote = true,
   hasLicense = true,
   playtime = 7200,
   chief = true,
   PlayerSpawn = function(ply) ply:SetArmor (200) ply:SetHealth (120) end,
   PlayerLoadout = function(ply) ply:SetArmor (200) ply:SetHealth (120) end,
   category = "   Правопорядок",
   --PlayerLoadout = function(ply) ply:ChatPrint('Вам доступен Арсенал!Получить его можно в Полицейском Участке') end,
})

TEAM_FBI = DarkRP.createJob("Агент FBI", {
   color = Color(155, 0, 255, 255),
    model = {
    "models/fbi_pack/fbi_01.mdl",
    "models/fbi_pack/fbi_02.mdl",
    "models/fbi_pack/fbi_03.mdl",
    "models/fbi_pack/fbi_04.mdl",
    "models/fbi_pack/fbi_05.mdl",
    "models/fbi_pack/fbi_06.mdl",
    "models/fbi_pack/fbi_07.mdl",
    "models/fbi_pack/fbi_08.mdl",
    "models/fbi_pack/fbi_09.mdl",
    },
   description = [[
✔ Описание:
● Вы Агент FBI!
● Вы являетесь опытным бойцом элитнейшего подразделения
● Выполняйте задачи высокой сложности
● Стойте на страже города]],
   weapons = {"arrest_stick", "weapon_fists","passrus", "unarrest_stick", "stunstick", "weaponchecker", "usp", "galil", "cuff", "dsr_taser", "door_ram", "heavy_shield"},
   command = "fbi",
   max = 6,
   salary = 300,
   admin = 0,
   vip = true,
   vote = false,
   playtime = 5400,
   hasLicense = true,
   category = "   Правопорядок",
    ammo = {
      ["ar2"] = 200,
      ["pistol"] = 60,
    },
   PlayerSpawn = function(ply) ply:SetArmor (150) ply:SetArmor (110) end,
   PlayerLoadout = function(ply) ply:SetArmor (150) ply:SetArmor (110) end,
   customCheck = isVIP,
   CustomCheckFailMsg = "Вы не VIP!"
})

TEAM_JAGA = DarkRP.createJob("Джаггернаут", {
   color = Color(155, 0, 255, 255),
   model = {
   "models/tfusion/playermodels/mw3/sp_juggernaut.mdl",
   },
   description = [[
✔ Описание:
● Вы Джаггернаут!
● Вы Тяжёлая пехота.
● Штурмуйте здания высокой сложности]],
   weapons = {"arrest_stick", "weapon_fists","passrus", "stunstick", "weapon_flashgrenade", "weaponchecker", "unarrest_stick", "usp", "cuff", "dsr_taser", "door_ram", "heavy_shield", "m249"},
   command = "jaga",
   max = 1,
   vip = true,
   --nocollide = 1.2,
   salary = 225,
   playtime = 7200,
   admin = 0,
   vote = false,
   hasLicense = true,
   category = "   Правопорядок",
   ammo = {
      ["ar2"] = 200,
      ["pistol"] = 60,
   },
   customCheck = isVIP,
   PlayerSpawn = function(ply) ply:SetArmor (200) ply:SetHealth (150)  end,
   PlayerLoadout = function(ply) ply:SetArmor (200) ply:SetHealth (150)  end,
   CustomCheckFailMsg = "Вы не VIP!"
})

TEAM_MAYOR = DarkRP.createJob("Мэр", {
   color = Color(255, 0, 0, 255),
   model = {"models/player/breen.mdl"},
   description = [[
✔ Описание:
● Вы Мэр!
● Создавайте законы, регулируйте политику города
● Контролируйте этот город]],
   weapons = {"nalogswep", "weapon_fists","passrus"},
   command = "mayor",
   max = 1,
   salary = 500,
   admin = 0,
   vote = true,
   playtime = 7200,
   hasLicense = true,
   mayor = true,
   category = "   Правопорядок",
   candemote = false,
   PlayerLoadout = function(ply) SetGlobalInt('LockDownNeprikos', CurTime() + 300) end,
   PlayerDeath = function(ply, weapon, killer)
                if( ply:Team() == TEAM_MAYOR ) then
                        ply:changeTeam( GAMEMODE.DefaultTeam, true )
                        for k,v in player.Iterator() do
                                v:PrintMessage( HUD_PRINTCENTER, "Мэр был убит!" )
                        end
                end
        end
})

TEAM_DOGE = DarkRP.createJob("Собака", {
   color = Color(191, 96, 20, 255),
      model = {
   "models/doge_player/doge_player.mdl",
   },
   description = [[
✔ Описание:
● Вы Собака!
● Найдите себе хозяина и будте ему верны]],
   weapons = {"weapon_pet"},
   command = "doge",
   category = "Другие",
   max = 3,
   salary = 0,
   admin = 0,
   vote = false,
   PlayerLoadout = function(ply)
      ply:SetWalkSpeed(135)
        ply:SetRunSpeed(240)
      timer.Simple( 0.3, function() ply:Give('weapon_adv_keys') end )
      timer.Simple( 0.6, function() ply:StripWeapons() end )
      timer.Simple( 1, function() ply:Give( "weapon_pet" ) end )
   end,
})

TEAM_MODER = DarkRP.createJob("Администрация", {
   color = Color(150, 20, 20, 255),
    -- model = {"models/pigeon.mdl"},
   model = {"models/tda/Luotianyi Christmas.mdl","models/pigeon.mdl"},
   description = [[
✔ Описание:
● Вы Администратор!
● Следите за сервером
● Помогайте игрокам решать проблемы]],
   weapons = {"unarrest_stick", "stunstick", "itemstore_checker", "weaponchecker", "moneychecker"},
   command = "nonrp",
   max = 0,
   salary = 10,
   admin = 0,
   vote = false,
   hasLicense = false,
   vip = true,
   category = "Другие",
   candemote = false,
   customCheck = isAdmin,
   CustomCheckFailMsg = "Вы не Админ!"
})


GAMEMODE.DefaultTeam = TEAM_CITIZEN



GAMEMODE.CivilProtection = { 
   [TEAM_POLICE] = true,
   [TEAM_FBI] = true,
   [TEAM_CHIEF] = true,
   [TEAM_MAYOR] = true,
   [TEAM_OMON] = true,
   [TEAM_ROMON] = true,
   [TEAM_DOMON] = true,
   [TEAM_SOMON] = true,
   [TEAM_JAGA] = true,
}
--PATH addons/111mod/lua/darkrp_customthings/doorgroups.lua:
--[[---------------------------------------------------------------------------
Door groups
---------------------------------------------------------------------------
The server owner can set certain doors as owned by a group of people, identified by their jobs.


HOW TO MAKE A DOOR GROUP:
AddDoorGroup("NAME OF THE GROUP HERE, you will see this when looking at a door", Team1, Team2, team3, team4, etc.)
---------------------------------------------------------------------------]]


-- Example: AddDoorGroup("Cops and Mayor only", TEAM_CHIEF, TEAM_POLICE, TEAM_MAYOR)
-- Example: AddDoorGroup("Gundealer only", TEAM_GUN)
AddDoorGroup("Государство", TEAM_CHIEF, TEAM_POLICE, TEAM_MAYOR, TEAM_OMON, TEAM_FBI, TEAM_ROMON, TEAM_DOMON, TEAM_SOMON, TEAM_JAGA)
AddDoorGroup("Банк", TEAM_BANK, TEAM_CHIEF, TEAM_POLICE, TEAM_MAYOR, TEAM_OMON, TEAM_FBI, TEAM_ROMON, TEAM_DOMON, TEAM_SOMON, TEAM_JAGA)
--PATH addons/weaponandcontent/lua/weapons/awp/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = true
	SWEP.PrintName = "AWP"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(3.552, -2.895, 1.2)
	SWEP.AimAng = Vector(0.79, -0.057, 0)
	
	SWEP.SprintPos = Vector(-2.599, -8.11, -0.709)
	SWEP.SprintAng = Vector(0, -62.559, 0)
	
	SWEP.ViewModelMovementScale = 1.25
	
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 70
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 40
	SWEP.MaxZoom = 80
	
	SWEP.IconLetter = "r"
	--killicon.AddFont("swb_awp", "SWB_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "swb_sniper"
end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 40
SWEP.BulletDiameter = 8.58
SWEP.CaseLength = 69.20

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"bolt"}
SWEP.Base = "swb_base"
SWEP.Category = "Weapons"

SWEP.Author			= "Base swb"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 70
SWEP.ViewModelFlip	= true
SWEP.ViewModel				= "models/weapons/2_snip_awp.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_snip_awp.mdl"	-- Weapon world model

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 10
SWEP.Primary.DefaultClip	= 10
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "ar2"

SWEP.FireDelay = 1.5
SWEP.FireSound = Sound("Alt_Weapon_AWP.1")
SWEP.Recoil = 3

SWEP.HipSpread = 0.06
SWEP.AimSpread = 0.0001
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 90
SWEP.DeployTime = 1
--PATH addons/cp_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(0,8,-1)
		},
		[2] = {
			["angles"] = Angle(6,6,-12),
			["position"] = Vector(8,10,-4)
		},
		[3] = {
			["angles"] = Angle(-3,7,-16),
			["position"] = Vector(-1,4,-3)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(16,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--PATH addons/truefishing/lua/weapons/fish_finder/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.PrintName = "Fish Finder"
	SWEP.Instructions = "Find at what depth fish live."
	SWEP.Slot = 3
	SWEP.SlotPos = 3
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
end

SWEP.Author = "Tomasas"
SWEP.Contact = ""
SWEP.Purpose = ""

SWEP.ViewModel = "models/weapons/v_hands.mdl"
SWEP.WorldModel = ""
SWEP.ViewModelFOV = 60
SWEP.DrawCrosshair = true

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

function SWEP:Initialize()
	self:SetHoldType("slam")
end

local emptyf = function() end//destroy click sound
SWEP.PrimaryAttack = emptyf
SWEP.SecondaryAttack = emptyf

if CLIENT then
	local function CreateModelPanel(model)
		local modelIcon = vgui.Create("DModelPanel", panel)
		modelIcon:SetModel(model)
		modelIcon:SetMouseInputEnabled(false)
		modelIcon:SetVisible(false)
		
		return modelIcon
	end

	function SWEP:Deploy(fromNotEngine)
		self.WeaponModel = ClientsideModel("models/weapons/v_hands.mdl", RENDERGROUP_OPAQUE)
		self.WeaponModel:SetCycle(0.5)
		self.WeaponModel:DrawShadow(false)
		self.WeaponModel:SetNoDraw(true)
		
		self.MonitorModel = ClientsideModel("models/props_lab/monitor01b.mdl", RENDERGROUP_OPAQUE)
		self.MonitorModel:DrawShadow(false)
		self.MonitorModel:SetNoDraw(true)
		
		self.FishPanels = {}
		for i=1, FISH_HIGHNUMBER do
			if !TrueFish.FISH_ENABLED[i] or i == FISH_JUNK then continue end
			self.FishPanels[i] = CreateModelPanel(TrueFishGetFishModel(i))
		end
		return true
	end
	
	function SWEP:Holster()
		if LocalPlayer() == self.Owner then
			if IsValid(self.WeaponModel) then
				self.WeaponModel:Remove()
				self.WeaponModel = nil
			end
			if IsValid(self.MonitorModel) then
				self.MonitorModel:Remove()
				self.MonitorModel = nil
			end
			if self.FishPanels then
				for i=1, FISH_HIGHNUMBER do
					if self.FishPanels[i] and self.FishPanels[i]:IsValid() then
						self.FishPanels[i]:Remove()
					end
				end
			end
		end
		return true
	end

	function SWEP:PreDrawViewModel()
		if !self.WeaponModel then self:Deploy(true) end
		local wep = self.Owner:GetViewModel()

		local wepan = wep:GetAngles()
		wepan:RotateAroundAxis(wepan:Forward(), 0)
		local wepos = EyePos() + wepan:Forward()*0 - wepan:Up()*2 + wepan:Right()*TFScreenScale(4)
		self.WeaponModel:SetRenderOrigin(wepos)
		self.WeaponModel:SetRenderAngles(wepan)
		
		local normal = wepan:Right()
		local dotProduct = normal:Dot(wepos)
		local oldEC = render.EnableClipping(true)
		render.PushCustomClipPlane(normal, dotProduct) // render only right arm
		self.WeaponModel:DrawModel()
		render.PopCustomClipPlane()
		render.EnableClipping(oldEC)
		
		local bone = self.WeaponModel:LookupBone("ValveBiped.Bip01_R_Hand")
		local bone2 = self.WeaponModel:LookupBone("ValveBiped.Bip01_R_UpperArm")
		local bone3 = self.WeaponModel:LookupBone("ValveBiped.Bip01_R_Forearm")
		if !bone or !bone2 or !bone3 then return true end
		self.WeaponModel:ManipulateBoneAngles(bone, Angle(0, 0, 180))
		self.WeaponModel:ManipulateBoneAngles(bone2, Angle(0, -40, 0))
		self.WeaponModel:ManipulateBoneAngles(bone3, Angle(0, 70, 0))
		self.WeaponModel:SetupBones()
		local pos, ang = self.WeaponModel:GetBonePosition(bone)
		ang:RotateAroundAxis(ang:Right(), 160)
		ang:RotateAroundAxis(ang:Up(), -30)
		ang:RotateAroundAxis(ang:Forward(), 110)
		
		pos = pos + ang:Forward()*2 + ang:Up()*6.8 + ang:Right()*4
		self.MonitorModel:SetRenderOrigin(pos)
		self.MonitorModel:SetRenderAngles(ang)
		self.MonitorModel:DrawModel()
		ang:RotateAroundAxis(ang:Right(), -90)
		ang:RotateAroundAxis(ang:Up(), 90)
		
		pos = pos - ang:Right()*5 - ang:Forward()*5.5 + ang:Up()*6.3
		
		self.Depth = -1
		
		local tdata = {start = EyePos(), endpos = EyePos()+LocalPlayer():EyeAngles():Forward()*600, mask = 268435488} // measure depth
		local trace = util.TraceLine(tdata)
		tdata.mask = CONTENTS_SOLID
		local trace2 = util.TraceLine(tdata)
		if trace.Hit and (!trace2.Hit or trace2.HitPos.z < trace.HitPos.z) then
			local tdata2 = {start = trace.HitPos, endpos = trace.HitPos-Vector(0, 0, 99999), mask = CONTENTS_SOLID}
			local trace3 = util.TraceLine(tdata2)
			if trace3.Hit then
				self.Depth = math.Clamp(trace.HitPos.z - trace3.HitPos.z, 0, 99999)
			end
		end
		
		local fishes = TrueFishCalculateFish(self.Depth, true)
		
		cam.Start3D2D(pos, ang, 0.025)
			render.SuppressEngineLighting(true)
			cam.IgnoreZ(true)
			
			surface.SetDrawColor(0,0,0,255)
			surface.DrawRect(0,0,360,368)
			
			//surface.SetDrawColor(255,0,0,255) // visible bounds for debugging
			//surface.DrawOutlinedRect(0,0,360,366)
			
			local x, y = -110, 0
			pos = pos - ang:Forward()*1.55 + ang:Right()*0.42
			local fishLen = #fishes < 13 and #fishes or 12
			for i=1, fishLen do
				if self.FishPanels[fishes[i]] and self.FishPanels[fishes[i]]:IsValid() then	
					local ent = self.FishPanels[fishes[i]].Entity
					local ang = Angle(ang)
					pos = pos + ang:Forward()*3					
					ent:SetRenderOrigin(pos)
					if i%3 == 0 then
						pos = pos + ang:Right()*1.9 - ang:Forward()*(3*3)
					end
					
					x = x+118
					surface.SetDrawColor(255, 255, 255, 255)
					draw.DrawText(TrueFishGetFishName(fishes[i]), "SegoeUI_NormalBold_20", x+55, y+40, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)
					if i%3 == 0 then
						x = -110
						y = y + 72
					end
					if string.find(TrueFishGetFishModel(fishes[i]), "FoodNHouseholdItems") then
						ent:SetModelScale(0.05)
						ang:RotateAroundAxis(ang:Up(), -135)
						ang:RotateAroundAxis(ang:Right(), -10)
						ent:SetRenderAngles(ang)
					else
						ang:RotateAroundAxis(ang:Forward(), -90)
						ent:SetRenderAngles(ang)
						ent:SetModelScale(0.06)
					end
					ent:DrawModel()
					
				end
			end
			
			if fishLen == 0 then
				draw.DrawText(TrueFishLocal("fish_finder_no_fish"), "SegoeUI_NormalBold_60", 180, 100, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			end
			draw.SimpleText(TrueFishLocal("fish_finder_depth_text"), "SegoeUI_NormalBold_20", 180, 295, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			draw.SimpleText(self.Depth > -1 and math.floor(self.Depth) or 0, "SegoeUI_NormalBold_60", 180, 320, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

			
			cam.IgnoreZ(false)
			render.SuppressEngineLighting(false)
		cam.End3D2D()
		
		return true
	end

end
--PATH addons/weaponandcontent/lua/weapons/fiveseven/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = true
	SWEP.PrintName = "Five-Seven"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(2.687, 0, 1.12)
	SWEP.AimAng = Vector(1.598, 0, 0)
		
	SWEP.SprintPos = Vector(-1.098, -7.132, -5.106)
	SWEP.SprintAng = Vector(59.402, 0, 0)
	
	SWEP.ZoomAmount = 5
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "u"
	--killicon.AddFont("swb_fiveseven", "SWB_KillIcons", SWEP.IconLetter, Color(255, 80, 0, 150))
	
	SWEP.MuzzleEffect = "swb_pistol_med"
end

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 10
SWEP.BulletDiameter = 5.7
SWEP.CaseLength = 28

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_pistol_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Weapons"

SWEP.Author			= "Base swb"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV		= 70
SWEP.ViewModelFlip		= true
SWEP.ViewModel				= "models/weapons/2_pist_fiveseven.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_pist_fiveseven.mdl"	-- Weapon world model

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 20
SWEP.Primary.DefaultClip	= 20
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.FireDelay = 0.145
SWEP.FireSound = Sound("Alt_Weapon_FiveSeven.1")
SWEP.Recoil = 0.65

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.009
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 21
SWEP.DeployTime = 1
--PATH addons/perma/lua/weapons/gmod_tool/stools/permaprops.lua:
/*
	PermaProps
	Created by Entoros, June 2010
	Facepunch: http://www.facepunch.com/member.php?u=180808
	Modified By Malboro 28 / 12 / 2012
	
	Ideas:
		Make permaprops cleanup-able
		
	Errors:
		Errors on die

	Remake:
		By Malboro the 28/12/2012
*/

TOOL.Category		= 	"Основное"
TOOL.Name			=	"Пермапропы"
TOOL.Command		=	nil
TOOL.ConfigName		=	""

if CLIENT then
	language.Add("Tool.permaprops.name", "PermaProps")
	language.Add("Tool.permaprops.desc", "Save a props permanently")
	language.Add("Tool.permaprops.0", "LeftClick: Add RightClick: Remove Reload: Update")

	surface.CreateFont("PermaPropsToolScreenFont", { font = "Arial", size = 40, weight = 1000, antialias = true, additive = false })
	surface.CreateFont("PermaPropsToolScreenSubFont", { font = "Arial", size = 30, weight = 1000, antialias = true, additive = false })
end

function TOOL:LeftClick(trace)

	if CLIENT then return true end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end
	
	if !PermaProps.HasPermission( ply, "Save") then return end

	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
	if ent.PermaProps then ply:ChatPrint( "That entity is already permanent !" ) return end

	local content = PermaProps.PPGetEntTable(ent)
	PrintTable(content)
	if not content then return end

	local max = tonumber(sql.QueryValue("SELECT MAX(id) FROM permaprops;"))
	if not max then max = 1 else max = max + 1 end
	print(max)
	local new_ent = PermaProps.PPEntityFromTable(content, max)
	print(new_ent)
	if !new_ent or !new_ent:IsValid() then return end

	PermaProps.SparksEffect( ent )

	PermaProps.SQL.Query("INSERT INTO permaprops (id, map, content) VALUES(NULL, ".. sql.SQLStr(game.GetMap()) ..", ".. sql.SQLStr(util.TableToJSON(content)) ..");")
	ply:ChatPrint("You saved " .. ent:GetClass() .. " with model ".. ent:GetModel() .. " to the database.")

	ent:Remove()

	return true

end

function TOOL:RightClick(trace)

	if CLIENT then return true end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end

	if !PermaProps.HasPermission( ply, "Delete") then return end

	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
	if not ent.PermaProps then ply:ChatPrint( "That is not a PermaProp !" ) return end
	if not ent.PermaProps_ID then ply:ChatPrint( "ERROR: ID not found" ) return end

	PermaProps.SQL.Query("DELETE FROM permaprops WHERE id = ".. ent.PermaProps_ID ..";")

	ply:ChatPrint("You erased " .. ent:GetClass() .. " with a model of " .. ent:GetModel() .. " from the database.")

	ent:Remove()

	return true

end

function TOOL:Reload(trace)

	if CLIENT then return true end

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end

	if not self:GetOwner():IsSuperAdmin() then self:GetOwner():ChatPrint( "Вы не команда проекта!" ) return end

	if (not trace.Entity:IsValid()) then self:GetOwner():ChatPrint( "You have reload all PermaProps !" ) PermaProps.ReloadPermaProps() return false end

	if trace.Entity.PermaProps then

		local ent = trace.Entity
		local ply = self:GetOwner()

		if !PermaProps.HasPermission( ply, "Update") then return end

		if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
		
		local content = PermaProps.PPGetEntTable(ent)
		if not content then return end

		PermaProps.SQL.Query("UPDATE permaprops set content = ".. sql.SQLStr(util.TableToJSON(content)) .." WHERE id = ".. ent.PermaProps_ID .." AND map = ".. sql.SQLStr(game.GetMap()) .. ";")

		local new_ent = PermaProps.PPEntityFromTable(content, ent.PermaProps_ID)
		if !new_ent or !new_ent:IsValid() then return end

		PermaProps.SparksEffect( ent )

		ply:ChatPrint("You updated the " .. ent:GetClass() .. " in the database.")

		ent:Remove()


	else

		return false

	end

	return true

end

function TOOL.BuildCPanel(panel)

	panel:AddControl("Header",{Text = "PermaProps", Description = "PermaProps\n\nSaves entities across map changes\n"})
	panel:AddControl("Button",{Label = "Open Configuration Menu", Command = "pp_cfg_open"})

end

function TOOL:DrawToolScreen(width, height)

	if SERVER then return end

	surface.SetDrawColor(17, 148, 240, 255)
	surface.DrawRect(0, 0, 256, 256)

	surface.SetFont("PermaPropsToolScreenFont")
	local w, h = surface.GetTextSize(" ")
	surface.SetFont("PermaPropsToolScreenSubFont")
	local w2, h2 = surface.GetTextSize(" ")

	draw.SimpleText("PermaProps", "PermaPropsToolScreenFont", 128, 100, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)
	draw.SimpleText("By Malboro", "PermaPropsToolScreenSubFont", 128, 128 + (h + h2) / 2 - 4, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)

end
--PATH addons/itemstore_new/lua/weapons/itemstore_checker.lua:
if SERVER then
	AddCSLuaFile()
end

SWEP.PrintName = "Проверка инвентаря"

SWEP.Purpose = "Checking the inventory of another player"
SWEP.Instructions = "Primary attack: check inventory of player in front of you"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.ViewModel = "models/weapons/cstrike/c_c4.mdl"
SWEP.WorldModel = ""
SWEP.UseHands = true

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.Slot               = 1
SWEP.SlotPos 			= 10
SWEP.DrawAmmo           = false
SWEP.DrawCrosshair      = true

SWEP.Range = 250

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end

function SWEP:OnDrop()
	self:Remove()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end

	local tr = util.TraceLine{
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * self.Range,
		filter = self.Owner
	}

	if not tr.Hit then return end
	if not IsValid( tr.Entity ) or not tr.Entity:IsPlayer() then return end

	local inv = tr.Entity.Inventory
	if not inv then return end

	inv:Sync( self.Owner )
	self.Owner:OpenContainer( inv:GetID(), itemstore.Translate( "inventory" ), true )
end

function SWEP:SecondaryAttack()
end

--PATH addons/111mod/lua/weapons/keypad_cracker.lua:
AddCSLuaFile()

local keypad_crack_time = CreateConVar("keypad_crack_time", "15", {FCVAR_ARCHIVE}, "Seconds for keypad cracker to crack keypad")

if SERVER then
	util.AddNetworkString("KeypadCracker_Hold")
	util.AddNetworkString("KeypadCracker_Sparks")
end

if CLIENT then
	SWEP.PrintName = "Взлом кейпада"
	SWEP.Slot = 4
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = true
end

SWEP.Author = "Urbanichka"
SWEP.Instructions = ""
SWEP.Contact = ""
SWEP.Purpose = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/v_c4.mdl")
SWEP.WorldModel = Model("models/weapons/w_c4.mdl")

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AnimPrefix = "python"

SWEP.Sound = Sound("weapons/deagle/deagle-1.wav")

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

SWEP.KeyCrackSound = Sound("buttons/blip2.wav")

SWEP.IdleStance = "slam"

function SWEP:Initialize()
	self:SetHoldType(self.IdleStance)

	if SERVER then
		net.Start("KeypadCracker_Hold")
			net.WriteEntity(self)
			net.WriteBit(true)
		net.Broadcast()

		self:SetCrackTime( keypad_crack_time:GetInt() )
	end
end	

function SWEP:SetupDataTables()
	self:NetworkVar( "Int", 0, "CrackTime" )
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + 0.4)


	
	if self.IsCracking or not IsValid(self.Owner) then return end

	local tr = self.Owner:GetEyeTrace()
	local ent = tr.Entity

	if IsValid(ent) and tr.HitPos:Distance(self.Owner:GetShootPos()) <= 50 and ent.IsKeypad then
		self.IsCracking = true
		self.StartCrack = CurTime()
		self.EndCrack = CurTime() + self:GetCrackTime()

		self:SetWeaponHoldType("pistol") -- TODO: Send as networked message for other clients to receive

		
		if SERVER then
			net.Start("KeypadCracker_Hold")
				net.WriteEntity(self)
				net.WriteBit(true)
			net.Broadcast()

			timer.Create("KeyCrackSounds: "..self:EntIndex(), 1, self:GetCrackTime(), function()
				if IsValid(self) and self.IsCracking then
					self:EmitSound(self.KeyCrackSound, 100, 100)
					
				end
			end)
		else
			self.Dots = self.Dots or ""
			
			local entindex = self:EntIndex()
			timer.Create("KeyCrackDots: "..entindex, 0.5, 0, function()
				if not IsValid(self) then
					timer.Destroy("KeyCrackDots: "..entindex)
				else
					local len = string.len(self.Dots)
					local dots = {[0] = ".", [1] = "..", [2]= "...", [3] = ""}

					self.Dots = dots[len]
				end
			end)
		end
	end
end

function SWEP:Holster()
	self.IsCracking = false

	if SERVER then
		timer.Destroy("KeyCrackSounds: "..self:EntIndex())
	else
		timer.Destroy("KeyCrackDots: "..self:EntIndex())
	end

	return true
end

function SWEP:Reload()
	return true
end

function SWEP:Succeed()
	self.IsCracking = false

	local tr = self.Owner:GetEyeTrace()
	local ent = tr.Entity
	self:SetWeaponHoldType(self.IdleStance)

	if SERVER and IsValid(ent) and tr.HitPos:Distance(self.Owner:GetShootPos()) <= 50 and ent.IsKeypad then
		ent:Process(true)

		net.Start("KeypadCracker_Hold")
			net.WriteEntity(self)
			net.WriteBit(true)
		net.Broadcast()

		net.Start("KeypadCracker_Sparks")
			net.WriteEntity(ent)
		net.Broadcast()
	end

	if SERVER then
		timer.Destroy("KeyCrackSounds: "..self:EntIndex())
	else
		timer.Destroy("KeyCrackDots: "..self:EntIndex())
	end
end

function SWEP:Fail()
	self.IsCracking = false

	self:SetWeaponHoldType(self.IdleStance)

	if SERVER then
		net.Start("KeypadCracker_Hold")
			net.WriteEntity(self)
			net.WriteBit(true)
		net.Broadcast()

		timer.Destroy("KeyCrackSounds: "..self:EntIndex())
	else
		timer.Destroy("KeyCrackDots: "..self:EntIndex())
	end
end

function SWEP:Think()
	if not self.StartCrack then
		self.StartCrack = 0
		self.EndCrack = 0
	end

	if self.IsCracking and IsValid(self.Owner) then
		local tr = self.Owner:GetEyeTrace()

		if not IsValid(tr.Entity) or tr.HitPos:Distance(self.Owner:GetShootPos()) > 50 or not tr.Entity.IsKeypad then
			self:Fail()
		elseif self.EndCrack <= CurTime() then
			self:Succeed()
		end
	else
		self.StartCrack = 0
		self.EndCrack = 0
	end
	
	self:NextThink(CurTime())
	return true
end

if(CLIENT) then
	SWEP.BoxColor = Color(10, 10, 10, 100)

	surface.CreateFont("KeypadCrack", {
		font = "Trebuchet",
		size = 18,
		weight = 600,
	})

	function SWEP:DrawHUD()
		if self.IsCracking then
			if not self.StartCrack then
				self.StartCrack = CurTime()
				self.EndCrack = CurTime() + self:GetCrackTime()
			end

			local frac = math.Clamp((CurTime() - self.StartCrack) / (self.EndCrack - self.StartCrack), 0, 1) -- Between 0 and 1 (a fraction omg segregation)
			
			local dots = self.Dots or ""
			
			local w, h = ScrW(), ScrH()
			
			local x, y = (w / 2) - 150, (h / 2) - 25
			local w, h = 300, 50
			
			draw.RoundedBox(4, x, y, w, h, self.BoxColor)
			
			surface.SetDrawColor(Color(255 + (frac * -255), frac * 255, 40))			
			surface.DrawRect(x + 5, y + 5, frac * (w - 10), h - 10)
			
			surface.SetFont("KeypadCrack")
			local fontw, fonth = surface.GetTextSize("Взламываем кейпад")
			local fontx, fonty = (x + (w / 2)) - (fontw / 2), (y + (h / 2)) - (fonth / 2)
			
			surface.SetTextPos(fontx + 1, fonty+1)
			surface.SetTextColor(color_black)
			surface.DrawText("Взламываем кейпад"..dots)
			
			surface.SetTextPos(fontx, fonty)
			surface.SetTextColor(color_white)
			surface.DrawText("Взламываем кейпад"..dots)
		end
	end
	
	SWEP.DownAngle = Angle(-10, 0, 0)
	
	SWEP.LowerPercent = 1
	SWEP.SwayScale = 0
	
	function SWEP:GetViewModelPosition(pos, ang)
		
		
		if self.IsCracking then
			local delta = FrameTime() * 3.5
			self.LowerPercent = math.Clamp(self.LowerPercent - delta, 0, 1)
		else
			local delta = FrameTime() * 5
			self.LowerPercent = math.Clamp(self.LowerPercent + delta, 0, 1)
		end
		
		ang:RotateAroundAxis(ang:Forward(), self.DownAngle.p * self.LowerPercent)
		ang:RotateAroundAxis(ang:Right(), self.DownAngle.p * self.LowerPercent)

		return self.BaseClass.GetViewModelPosition(self, pos, ang)
	end

	net.Receive("KeypadCracker_Hold", function()
		local ent = net.ReadEntity()
		local state = (net.ReadBit() == 1)

		if IsValid(ent) and ent:IsWeapon() and ent:GetClass():lower() == "keypad_cracker" and not game.SinglePlayer() and ent.SetWeaponHoldType then
			if not state then
				ent:SetWeaponHoldType(ent.IdleStance)
				ent.IsCracking = false
			else
				ent:SetWeaponHoldType("pistol")
				ent.IsCracking = true
			end
		end
	end)
	
	net.Receive("KeypadCracker_Sparks", function()
		local ent = net.ReadEntity()
		
		if IsValid(ent) then
			local vPoint = ent:GetPos()
			local effect = EffectData()
			effect:SetStart(vPoint)
			effect:SetOrigin(vPoint)
			effect:SetEntity(ent)
			effect:SetScale(2)
			util.Effect("cball_bounce", effect)
			
			ent:EmitSound("buttons/combine_button7.wav", 100, 100)
		end
	end)
end
--PATH addons/m9k/lua/weapons/m9k_1897winchester/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_1897winchester/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_1897winchester") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Winchester 1897"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 31			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "shotgun"	-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_1897trenchshot.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_winchester_1897_trench.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Trench_97.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 70		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 4			-- Size of a clip
SWEP.Primary.DefaultClip		= 12	-- Default number of bullets in a clip
SWEP.Primary.KickUp				= 0.9				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.6		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.4	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "slam"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.ShellTime			= .6

SWEP.Primary.NumShots	= 11		//how many bullets to shoot, use with shotguns
SWEP.Primary.Damage		= 10	//base damage, scaled by game
SWEP.Primary.Spread		= .04	//define from-the-hip accuracy (1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .04 // has to be the same as primary.spread
-- Because irons don't magically give you less pellet spread!


SWEP.IronSightsPos = Vector(2.809, 0, 1.48)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(2.809, 0, 1.48)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-3.116, -3.935, 0.492)
SWEP.RunSightsAng = Vector(-19.894, -47.624, 10.902)

if ((gmod.GetGamemode().Name) == "Murderthon 9000") or ((gmod.GetGamemode().Name) == "Murderthon 9000 beta") then
	SWEP.Primary.Ammo			= "slam"
else
	SWEP.Primary.Ammo			= "Buckshot"
end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_ak74/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_ak74/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_ak74") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "AK-74"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 23			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.SelectiveFire		= true

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_tct_ak47.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_tct_ak47.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Tactic_AK47.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 700			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.15		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.15		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.15		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "Rifle"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 23	-- Base damage per bullet
SWEP.Primary.Spread		= .001	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector (2.0378, -3.8941, 0.8809)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (2.0378, -3.8941, 0.8809)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-2.3095, -3.0514, 2.3965)
SWEP.RunSightsAng = Vector (-19.8471, -33.9181, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_dbarrel/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_dbarrel/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_dbarrel") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Double Barrel Shotgun"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 21			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "shotgun"	-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_doublebarrl.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_double_barrel_shotgun.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Double_Barrel.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 180		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 2			-- Size of a clip
SWEP.Primary.DefaultClip		= 30	-- Default number of bullets in a clip
SWEP.Primary.KickUp				= 1				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 1	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "Buckshot"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 0		-- How much you 'zoom' in. Less is more! 

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.ShellTime			= .5

SWEP.Primary.NumShots	= 18		-- How many bullets to shoot per trigger pull, AKA pellets
SWEP.Primary.Damage		= 10	-- Base damage per bullet
SWEP.Primary.Spread		= .03	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .03	-- Ironsight accuracy, should be the same for shotguns
-- Because irons don't magically give you less pellet spread!

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(0, 0, 0)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(0, 0, 0)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(11.475, -7.705, -2.787)
SWEP.RunSightsAng = Vector(0.574, 51.638, 5.737)

SWEP.Secondary.Sound = Sound("dbarrel_dblast")

local PainMulti = 1
 
if GetConVar("M9KDamageMultiplier") == nil then
		PainMulti = 1
		print("M9KDamageMultiplier is missing! You may have hit the lua limit! Reverting multiplier to 1.")
else
		PainMulti = GetConVar("M9KDamageMultiplier"):GetFloat()
		if PainMulti < 0 then
				PainMulti = PainMulti * -1
				print("Your damage multiplier was in the negatives. It has been reverted to a positive number. Your damage multiplier is now "..PainMulti)
		end
end

function NewM9KDamageMultiplierDB(cvar, previous, new)
		print("multiplier has been changed ")
		if GetConVar("M9KDamageMultiplier") == nil then
				PainMulti = 1
				print("M9KDamageMultiplier is missing! You may have hit the lua limit! Reverting multiplier to 1, you will notice no changes.")
		else
				PainMulti = GetConVar("M9KDamageMultiplier"):GetFloat()
				if PainMulti < 0 then
						PainMulti = PainMulti * -1
				end
		end
end
cvars.AddChangeCallback("M9KDamageMultiplier", NewM9KDamageMultiplierDB)

function SWEP:SecondaryAttack()
	local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
	if (timer.Exists(timerName)) then return end
	
	if self:CanPrimaryAttack() and self.Owner:IsPlayer() then
	if self.Weapon:Clip1() == 2 then
		if ( !self.Owner:KeyDown(IN_SPEED) or self.Owner:GetNW2Bool("donate_upgrade_runngun") ) and !self.Owner:KeyDown(IN_RELOAD) then
			self:ShootBulletInformation2()
			self.Weapon:TakePrimaryAmmo(2)
			self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
			self.Weapon:EmitSound(self.Secondary.Sound)
			--self.Owner:ViewPunch(Angle(-15, math.Rand(-20,-25), 0))
	
			local fx 		= EffectData()
			fx:SetEntity(self.Weapon)
			fx:SetOrigin(self.Owner:GetShootPos())
			fx:SetNormal(self.Owner:GetAimVector())
			fx:SetAttachment(self.MuzzleAttachment)
			if GetConVar("M9KGasEffect") != nil then
				if GetConVar("M9KGasEffect"):GetBool() then 
					util.Effect("m9k_rg_muzzle_rifle",fx)
				end
			end
			self.Owner:SetAnimation( PLAYER_ATTACK1 )
			self.Owner:MuzzleFlash()
			self.Weapon:SetNextSecondaryFire(CurTime()+1/((self.Primary.RPM/2)/60))
			self:CheckWeaponsAndAmmo()
		if self.BoltAction then self:BoltBack() end
		end
	elseif self.Weapon:Clip1() == 1 then
		self.Weapon:PrimaryAttack()
		self.Weapon:SetNextSecondaryFire(CurTime()+1/((self.Primary.RPM/2)/60))
	elseif self.Weapon:Clip1() == 0 then
		self:Reload()
	end	
	end
end

function SWEP:PrimaryAttack()
	local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
	if (timer.Exists(timerName)) then return end
	if self:CanPrimaryAttack() and self.Owner:IsPlayer() then
	if ( !self.Owner:KeyDown(IN_SPEED) or self.Owner:GetNW2Bool("donate_upgrade_runngun") ) and !self.Owner:KeyDown(IN_RELOAD) then
		self:ShootBulletInformation()
		self.Weapon:TakePrimaryAmmo(1)
		
		if self.Silenced then
			self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK_SILENCED )
			self.Weapon:EmitSound(self.Primary.SilencedSound)
		else
			self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
			self.Weapon:EmitSound(self.Primary.Sound)
		end	
	
		local fx 		= EffectData()
		fx:SetEntity(self.Weapon)
		fx:SetOrigin(self.Owner:GetShootPos())
		fx:SetNormal(self.Owner:GetAimVector())
		fx:SetAttachment(self.MuzzleAttachment)
		if GetConVar("M9KGasEffect") != nil then
			if GetConVar("M9KGasEffect"):GetBool() then 
				util.Effect("m9k_rg_muzzle_rifle",fx)
			end
		end
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
		self.Owner:MuzzleFlash()
		self.Weapon:SetNextPrimaryFire(CurTime()+1/(self.Primary.RPM/60))
		self:CheckWeaponsAndAmmo()
		if self.BoltAction then self:BoltBack() end
	end
	elseif self:CanPrimaryAttack() and self.Owner:IsNPC() then
		self:ShootBulletInformation()
		self.Weapon:TakePrimaryAmmo(1)
		self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
		self.Weapon:EmitSound(self.Primary.Sound)
		self.Owner:SetAnimation( PLAYER_ATTACK1 )
		self.Owner:MuzzleFlash()
		self.Weapon:SetNextPrimaryFire(CurTime()+1/(self.Primary.RPM/60))
	end
end


function SWEP:ShootBulletInformation2()

	local CurrentDamage
	local CurrentRecoil
	local CurrentCone
	local basedamage
	
	CurrentCone = self.Primary.Spread
	
	local damagedice = math.Rand(.85,1.3)
	
	basedamage = PainMulti * self.Primary.Damage
	CurrentDamage = basedamage * damagedice
	CurrentRecoil = self.Primary.Recoil
	
		self:ShootBullet(CurrentDamage, CurrentRecoil, 31, .06)
	
end

/*---------------------------------------------------------
   Name: SWEP:Reload()
   Desc: Reload is being pressed.
---------------------------------------------------------*/
function SWEP:Reload()

	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end

	local maxcap = self.Primary.ClipSize
	local spaceavail = self.Weapon:Clip1()
	local shellz = (maxcap) - (spaceavail) + 1

	if (timer.Exists("ShotgunReload")) or self.Owner.NextReload > CurTime() or maxcap == spaceavail then return end
	
	if self.Owner:IsPlayer() then 

		self.Weapon:SetNextPrimaryFire(CurTime() + 1) -- wait one second before you can shoot again
		self.Weapon:SendWeaponAnim(ACT_SHOTGUN_RELOAD_START) -- sending start reload anim
		self.Owner:SetAnimation( PLAYER_RELOAD )
		
		self.Owner.NextReload = CurTime() + 1
	
		if (SERVER) then
			self.Owner:SetFOV( 0, 0.15 )
			self:SetIronsights(false)
		end
	
		if SERVER and self.Owner:Alive() then
			local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
			timer.Create(timerName, 
			(self.ShellTime + .05), 
			shellz,
			function() if not IsValid(self) then return end 
			if IsValid(self.Owner) and IsValid(self.Weapon) then 
				if self.Owner:Alive() then 
					self:InsertShell()
				end 
			end end)
		end
	
	elseif self.Owner:IsNPC() then
		self.Weapon:DefaultReload(ACT_VM_RELOAD) 
	end
	
end

function SWEP:Think()
	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end
	if self.Owner.NextReload == nil then self.Owner.NextReload = CurTime() + 1 end
	local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
	--if the owner presses shoot while the timer is in effect, then...
	-- if (self.Owner:KeyPressed(IN_ATTACK)) and (timer.Exists(timerName)) and ( !self.Owner:KeyDown(IN_SPEED) or self.Owner:GetNW2Bool("donate_upgrade_runngun") ) then
		-- if self:CanPrimaryAttack() then --well first, if we actually can attack, then...
			-- timer.Destroy(timerName) -- kill the timer, and
			-- self:PrimaryAttack()-- ATTAAAAACK!
		-- end
	-- end
	
	if self.InsertingShell == true and self.Owner:Alive() then
		vm = self.Owner:GetViewModel()-- its a messy way to do it, but holy shit, it works!
		vm:ResetSequence(vm:LookupSequence("after_reload")) -- Fuck you, garry, why the hell can't I reset a sequence in multiplayer?
		vm:SetPlaybackRate(.01) -- or if I can, why does facepunch have to be such a shitty community, and your wiki have to be an unreadable goddamn mess?
		self.InsertingShell = false -- You get paid for this, what's your excuse?
	end
	
	self:IronSight()
	
end

function SWEP:InsertShell()

	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end
	
	local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
	if self.Owner:Alive() then
		local curwep = self.Owner:GetActiveWeapon()
		if curwep:GetClass() != self.Gun then 
			timer.Destroy(timerName)
		return end
	
		if (self.Weapon:Clip1() >= self.Primary.ClipSize or self.Owner:GetAmmoCount(self.Primary.Ammo) <= 0) then
		-- if clip is full or ammo is out, then...
			self.Weapon:SendWeaponAnim(ACT_SHOTGUN_RELOAD_FINISH) -- send the pump anim
			timer.Destroy(timerName) -- kill the timer
			self.Weapon:SetNextPrimaryFire(CurTime()+.55)
			self.Weapon:SetNextSecondaryFire(CurTime()+.55)
		elseif (self.Weapon:Clip1() <= self.Primary.ClipSize and self.Owner:GetAmmoCount(self.Primary.Ammo) >= 0) then
			self.InsertingShell = true --well, I tried!
			timer.Simple( .05, function() self:ShellAnimCaller() end)
			self.Owner:RemoveAmmo(1, self.Primary.Ammo, false) -- out of the frying pan
			self.Weapon:SetClip1(self.Weapon:Clip1() + 1) --  into the fire
		end
	else
		timer.Destroy(timerName) -- kill the timer
	end
	
end

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_famas/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_famas/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_famas") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "FAMAS"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 29			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_tct_famas.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_tct_famas.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_FAMTC.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 950			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.4		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "Rifle"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 29	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-3.342, 0, 0.247)
SWEP.IronSightsAng = Vector(0, -0.438, 0)
SWEP.SightsPos = Vector(-3.342, 0, 0.247)
SWEP.SightsAng = Vector(0, -0.438, 0)
SWEP.RunSightsPos = Vector (0.9926, -3.6313, 0.4169)
SWEP.RunSightsAng = Vector (-9.1165, 43.8507, -18.2067)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_lugeradm/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_lugeradm/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_luger") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "P08 ANALNIE KOLDUN"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 24		-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3				-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 100
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_p08_luger.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_luger_p08.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("weapon_luger.single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 42500			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10000		-- Size of a clip
SWEP.Primary.DefaultClip		= 450000		-- Bullets you start with
SWEP.Primary.KickUp				= 0		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "Pistol"				
-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a metal peircing shotgun slug

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	


SWEP.Primary.NumShots	= 1	-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 5000	-- Base damage per bullet
SWEP.Primary.Spread		= .00021	-- Define from-the-hip accuracy (1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .011 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.71, -2.122, 2.27)
SWEP.IronSightsAng = Vector(0.563, -0.013, 0)
SWEP.SightsPos = Vector(2.71, -2.122, 2.27)
SWEP.SightsAng = Vector(0.563, -0.013, 0)
SWEP.RunSightsPos = Vector(0, 0, 2.575)
SWEP.RunSightsAng = Vector(-14.657, 0, 0)

SWEP.Secondary.ScopeZoom			= 3
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= true	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false

SWEP.data 				= {}
SWEP.data.ironsights			= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 				= 0.6

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_m16a4_acog/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_m16a4_acog/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m16a4_acog") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "M16A4 ACOG"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 35			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- Set false if you want no crosshair from hip
SWEP.Weight				= 30			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.XHair					= true		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_M16_acog.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_dmg_m16ag.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Dmgfok_M16A4.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 850		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp			= .15				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .15			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= .15		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "Rifle"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true

SWEP.Secondary.ScopeZoom			= 4	
SWEP.Secondary.UseACOG			= true -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	

SWEP.data 				= {}
SWEP.data.ironsights			= 1
SWEP.ScopeScale 			= 0.5
SWEP.ReticleScale 				= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 22	--base damage per bullet
SWEP.Primary.Spread		= .001	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector (2.275, -2.9708, 0.5303)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (2.275, -2.9708, 0.5303)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-3.0328, 0, 1.888)
SWEP.RunSightsAng = Vector (-24.2146, -36.522, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_m1918bar/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_m1918bar/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m1918bar") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Machine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "M1918 BAR"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 36			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_m1918bar.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_m1918_bar.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_bar1.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 750			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 20		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.2		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "Rifle"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 28	-- Base damage per bullet
SWEP.Primary.Spread		= .001	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.313, 0, 1.399)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(3.313, 0, 1.399)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-7.049, -8.525, -2.132)
SWEP.RunSightsAng = Vector(0, -58.526, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_mp5/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_mp5/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_mp5") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK MP5"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 46			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_navymp5.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk_mp5.mdl"	-- Weapon world model 
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("mp5_navy_Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 800			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.1		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.2		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 22	-- Base damage per bullet
SWEP.Primary.Spread		= .023	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .013 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.549, -0.927, 1.09)
SWEP.IronSightsAng = Vector(0.125, -0.071, 0)
SWEP.SightsPos = Vector(2.549, -0.927, 1.09)
SWEP.SightsAng = Vector(0.125, -0.071, 0)
SWEP.RunSightsPos = Vector (-3.0328, 0, 1.888)
SWEP.RunSightsAng = Vector (-24.2146, -36.522, 10)



if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_striker12/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_striker12/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_striker12")					-- must be the name of your swep
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Shotguns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Striker 12"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 28			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative to other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_striker_12g.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_striker_12g.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_shotty_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("ShotStriker12.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 365		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 12			-- Size of a clip
SWEP.Primary.DefaultClip			= 36	-- Default number of bullets in a clip
SWEP.Primary.KickUp			= 4				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.5		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= .6	-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "Buckshot"

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 

SWEP.ShellTime			= .3

SWEP.Primary.NumShots	= 6		-- How many bullets to shoot per trigger pull, AKA pellets
SWEP.Primary.Damage		= 8	-- Base damage per bullet
SWEP.Primary.Spread		= .04	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .04	-- Ironsight accuracy, should be the same for shotguns
-- Because irons don't magically give you less pellet spread!

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.805, -1.045, 1.805)
SWEP.IronSightsAng = Vector(2.502, 3.431, 0)
SWEP.SightsPos = Vector(3.805, -1.045, 1.805)
SWEP.SightsAng = Vector(2.502, 3.431, 0)
SWEP.RunSightsPos = Vector(-3.237, -6.376, 1.167)
SWEP.RunSightsAng = Vector(-8.391, -63.543, 0)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_svt40/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_svt40/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_svt40") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "SVT 40"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 48			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_snip_svt40.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_svt_40.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_SVT40.single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 260		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 0.3				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "Rifle"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 5	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= true	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 68	--base damage per bullet
SWEP.Primary.Spread		= .001	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .0001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(-3.462, -1.775, 0.079)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(-3.462, -1.775, 0.079)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(3.388, -4.501, 0)
SWEP.RunSightsAng = Vector(-9.096, 47.727, 0)



if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_svu/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_svu/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_svu") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Sniper Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Dragunov SVU"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 49			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= false		-- Set false if you want no crosshair from hip
SWEP.XHair					= false		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.Weight				= 50			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_sniper_svu.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_dragunov_svu.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Weapon_SVU.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 400		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 10		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp				= 0.4				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.4		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "Rifle"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 9	
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= true	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false
SWEP.Secondary.UseMatador		= false

SWEP.data 				= {}
SWEP.data.ironsights		= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 			= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 65	--base damage per bullet
SWEP.Primary.Spread		= .001	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector(-3.24, 0, 0.88)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(-3.24, 0, 0.88)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(3.143, -6, 0.286)
SWEP.RunSightsAng = Vector(-5, 55, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_tar21/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_tar21/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_tar21") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "TAR-21"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 38			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "rpg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_imi_tavor.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_imi_tar21.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Wep_imitavor.single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 900			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "Rifle"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 30	-- Base damage per bullet
SWEP.Primary.Spread		= .027	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .016 -- Ironsight accuracy, should be the same for shotguns

SWEP.SelectiveFire		= true

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-1.825, 0.685, 0.155)
SWEP.IronSightsAng = Vector(0.768, 0, 0)
SWEP.SightsPos = Vector(-1.825, 0.685, 0.155)
SWEP.SightsAng = Vector(0.768, 0, 0)
SWEP.RunSightsPos = Vector(3.858, 0.079, -1.025)
SWEP.RunSightsAng = Vector(-5.237, 49.648, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end


if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH gamemodes/darkrp/entities/weapons/med_kit/shared.lua:
if SERVER then
    AddCSLuaFile("shared.lua")
end

SWEP.PrintName = "Medic Kit"
SWEP.Author = "DarkRP Developers"
SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.Description = "Heals the wounded."
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = "Left click to heal someone\nRight click to heal yourself"
SWEP.IsDarkRPMedKit = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"

SWEP.ViewModel = "models/weapons/c_medkit.mdl"
SWEP.WorldModel = "models/weapons/w_medkit.mdl"
SWEP.UseHands = true

SWEP.Primary.Recoil = 0
SWEP.Primary.ClipSize  = -1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic  = true
SWEP.Primary.Delay = 0.1
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Recoil = 0
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Delay = 0.3
SWEP.Secondary.Ammo = "none"

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)

    local found
    local lastDot = -1 -- the opposite of what you're looking at
    self:GetOwner():LagCompensation(true)
    local aimVec = self:GetOwner():GetAimVector()
    local shootPos = self:GetOwner():GetShootPos()

    for _, v in player.Iterator() do
        local maxhealth = v:GetMaxHealth() or 100
        local targetShootPos = v:GetShootPos()
        if v == self:GetOwner() or targetShootPos:DistToSqr(shootPos) > 7225 or v:Health() >= maxhealth or not v:Alive() then continue end

        local direction = targetShootPos - shootPos
        direction:Normalize()
        local dot = direction:Dot(aimVec)

        -- Looking more in the direction of this player
        if dot > lastDot then
            lastDot = dot
            found = v
        end
    end
    self:GetOwner():LagCompensation(false)

    if found then
        found:SetHealth(found:Health() + 1)
        self:EmitSound("hl1/fvox/boop.wav", 150, found:Health() / found:GetMaxHealth() * 100, 1, CHAN_AUTO)
    end
end

function SWEP:SecondaryAttack()
    self:SetNextSecondaryFire(CurTime() + self.Secondary.Delay)
    local ply = self:GetOwner()
    local maxhealth = self:GetOwner():GetMaxHealth() or 100
    if ply:Health() < maxhealth then
        ply:SetHealth(ply:Health() + 1)
        self:EmitSound("hl1/fvox/boop.wav", 150, ply:Health() / ply:GetMaxHealth() * 100, 1, CHAN_AUTO)
    end
end

--PATH addons/111mod/lua/weapons/moneychecker/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.PrintName = "Чекер кошелька"
	SWEP.Slot = 1
	SWEP.SlotPos = 9
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
end

SWEP.Instructions = "ЛКМ для проверки кошелька"

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix	 = "rpg"

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "DarkRP (Utility)"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:Initialize()
	self:SetHoldType("normal")
end

function SWEP:Deploy()
	return true
end

function SWEP:DrawWorldModel() end

function SWEP:PreDrawViewModel(vm)
	return true
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + 0.4)

	self:GetOwner():LagCompensation(true)
	local trace = self:GetOwner():GetEyeTrace()
	self:GetOwner():LagCompensation(false)

	if not IsValid(trace.Entity) or not trace.Entity:IsPlayer() or trace.Entity:GetPos():Distance(self:GetOwner():GetPos()) > 100 then
		return
	end

	self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)

	if SERVER or not IsFirstTimePredicted() then return end

	local result = trace.Entity:getDarkRPVar("money")
	if SERVER then
		hook.Run('CheckMoney', trace.Entity, self:GetOwner(), result)
	end

	if result <= 300 then
		self:GetOwner():ChatPrint("Этот чел бомж. Побей его и отпусти. Убивать нельзя")
	else
		self:GetOwner():ChatPrint("У "..trace.Entity:Nick().." "..DarkRP.formatMoney(result).." валюты")
	end
end

--PATH addons/111mod/lua/weapons/nalogswep/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.PrintName = "Сбор налогов"
    SWEP.Slot = 2
    SWEP.SlotPos = 9
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

SWEP.Author = "TravkaCode"
SWEP.Instructions = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPWeaponChecker = true

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix  = "rpg"
SWEP.Delay = 3

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Other"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:Deploy()
    return true
end

function SWEP:DrawWorldModel() end

function SWEP:PreDrawViewModel(vm)
    return true
end

function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + self.Delay)
	self:SetNextSecondaryFire(CurTime() + self.Delay)

    local trace = self:GetOwner():GetEyeTrace()

    if not IsValid(trace.Entity) or not trace.Entity:IsPlayer() or trace.Entity:GetPos():DistToSqr(self:GetOwner():GetPos()) > 10000 then
        return
    end
	if trace.Entity.fucktime == nil then trace.Entity.fucktime = CurTime() - 1 end
	--if trace.Entity:Team() != TEAM_CITIZEN and trace.Entity:Team() != TEAM_GUNS and trace.Entity:Team() != TEAM_SEC and trace.Entity:Team() != TEAM_GANG and trace.Entity:Team() != TEAM_VHIT and trace.Entity:Team() != TEAM_VOR and trace.Entity:Team() != TEAM_HIT then if SERVER then DarkRP.notify(self:GetOwner(), 1, 3, "Невозможно!") end return end
	if trace.Entity.fucktime > CurTime() then if SERVER then DarkRP.notify(self:GetOwner(), 1, 3, "С этого рабочего недавно собирали налог!") end return end
	if SERVER and trace.Entity:getDarkRPVar("money") < 1500 then  if SERVER then DarkRP.notify(self:GetOwner(), 1, 3, "Этот рабочий почти не имеет денег!") end return end
	
	if SERVER then trace.Entity:addMoney(-1500) self:GetOwner():addMoney(1400) end 
	trace.Entity.fucktime = CurTime() + 1400
	

    self:EmitSound("npc/combine_soldier/gear6.wav", 50, 100)



	if SERVER then 
		BPSetTask( 'Nalog', self:GetOwner(), 35 )
		DarkRP.notify(self:GetOwner(), 3, 3, "Вы собрали налог с "..trace.Entity:Name()) 
		DarkRP.notify(trace.Entity, 3, 3, "С вас собрал налог "..self:GetOwner():Name()) 
		print(self:GetOwner():Name().. " собрал налог с "..trace.Entity:Name())  
	end
		
		self:GetOwner():EmitSound("npc/combine_soldier/gear6.wav", 50, 110)
end

function SWEP:SecondaryAttack()
return
end

function SWEP:Reload()
return
end

function SWEP:Holster()
    return true
end

function SWEP:DrawHUD()
        self.Dots = self.Dots or ""
        local w = ScrW()
        local h = ScrH()
        local x, y, width, height = w / 2 - w / 10, h / 2, w / 5, h / 15

        draw.DrawNonParsedSimpleText("Нажмите ЛКМ для сбора налога ( раз в 10 минут )", "Trebuchet24", w / 2, y + height / 2, Color(255, 255, 255, 255), 1, 1)
end

--PATH addons/cp_ballistic_shields/lua/ballistic_shields/sh_bs_lang.lua:
include( "ballistic_shields/sh_bs_util.lua" )

bshields.lang = {
	["English"] = {
		["sec"] = "[ПКМ] Видимость",
		["dshieldprim"] = "[ЛКМ] Применить",
		["hshieldprim"] = "[ЛКМ] Сломать дверь",
		["rshieldprim"] = "[ЛКМ] Атака",
		["hshieldcd1"] = "Подождите ",
		["hshieldcd2"] = " секунд что-бы сломать дверь!"	
	},
	["German"] = {
		["sec"] = "[RMB] SICHTBARKEIT",
		["dshieldprim"] = "[LMB] PLAZIEREN",
		["hshieldprim"] = "[LMB] TÜR AUFBRECHEN",
		["rshieldprim"] = "[LMB] ANGREIFEN",
		["hshieldcd1"] = "Warte ",
		["hshieldcd2"] = " Sekunden für das Aufbrechen der nächsten Tür!"	
	},
	["French"] = {
		["sec"] = "[RMB] VISIBILITÉ",
		["dshieldprim"] = "[LMB] DÉPLOYER",
		["hshieldprim"] = "[LMB] FORCER LA PORTE",
		["rshieldprim"] = "[LMB] ATTAQUER",
		["hshieldcd1"] = "Attendez ",
		["hshieldcd2"] = " secondes pour forcer la porte !"	
	},
	["Danish"] = {
		["sec"] = "[RMB] SIGTBARHED",
		["dshieldprim"] = "[LMB] SÆT",
		["hshieldprim"] = "[LMB] BREACH DØR",
		["rshieldprim"] = "[LMB] ANGRIB",
		["hshieldcd1"] = "Vent ",
		["hshieldcd2"] = " sekunder at bryde ved siden af!"   
	},
	["Turkish"] = {
		["sec"] = "[RMB] GORUNURLUK",
		["dshieldprim"] = "[LMB] YERLESTIR",
		["hshieldprim"] = "[LMB] BREACH DOOR",
		["rshieldprim"] = "[LMB] SALDIR",
		["hshieldcd1"] = "Bekle ",
		["hshieldcd2"] = " bir sonraki kapıyı kırmaya saniye kaldı!"   
	}
}  

if(bshields.lang[bshields.config.language]==nil) then bshields.config.language = "English" end
--PATH addons/weaponandcontent/lua/weapons/swb_base/cl_hud.lua:
surface.CreateFont("SWB_HUD72", {font = "Default", size = 72, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD48", {font = "Default", size = 48, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD36", {font = "Default", size = 36, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD28", {font = "Default", size = 28, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD24", {font = "Default", size = 24, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD16", {font = "Default", size = 16, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_KillIcons", {font = "csd", size = ScreenScale(30), weight = 500, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_SelectIcons", {font = "csd", size = ScreenScale(60), weight = 500, blursize = 0, antialias = true, shadow = false})

SWEP.CrossAmount = 0
SWEP.CrossAlpha = 255
SWEP.FadeAlpha = 0
SWEP.AimTime = 0

local ClumpSpread = surface.GetTextureID("swb/clumpspread_ring")
local Bullet = surface.GetTextureID("swb/bullet")
local White, Black = Color(255, 255, 255, 255), Color(0, 0, 0, 255)
local x, y, x2, y2, lp, size, FT, CT, tr, x3, x4, y3, y4, UCT, sc1, sc2
local td = {}

local dst = draw.SimpleText

function draw.ShadowText(text, font, x, y, colortext, colorshadow, dist, xalign, yalign)
	dst(text, font, x + dist, y + dist, colorshadow, xalign, yalign)
	dst(text, font, x, y, colortext, xalign, yalign)
end

function SWEP:DrawHUD()
	FT, CT, x, y = FrameTime(), CurTime(), ScrW(), ScrH()
	UCT = UnPredictedCurTime()
	
	if self.dt.State == SWB_AIMING then
		if UCT > self.AimTime then
			if self.DrawBlackBarsOnAim then
				surface.SetDrawColor(0, 0, 0, 255)
				
				if self.ScaleOverlayToScreenHeight then
					x3 = (x - y) / 2
					y3 = y / 2
					x4 = x - x3
					y4 = y - y3
					
					surface.DrawRect(0, 0, x3, y)
					surface.DrawRect(x4, 0, x3, y)
				else
					x3 = (x - 1024) / 2
					y3 = (y - 1024) / 2
					x4 = x - x3
					y4 = y - y3
					
					surface.DrawRect(0, 0, x3, y)
					surface.DrawRect(x4, 0, x3, y)
					surface.DrawRect(0, 0, x, y3)
					surface.DrawRect(0, y4, x, y3)
				end
			end
		end
		
		if self.AimOverlay then
			if UCT > self.AimTime or self.InstantDissapearOnAim then
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetTexture(self.AimOverlay)
				
				if self.StretchOverlayToScreen then
					surface.DrawTexturedRect(0, 0, x, y)
				elseif self.ScaleOverlayToScreenHeight then
					surface.DrawTexturedRect(x * 0.5 - y * 0.5, y * 0.5 - y * 0.5, y, y)
				else
					surface.DrawTexturedRect(x * 0.5 - 512, y * 0.5 - 512, 1024, 1024)
				end
			end
		end
		
		if self.FadeDuringAiming then
			if UCT < self.AimTime then
				self.FadeAlpha = math.Approach(self.FadeAlpha, 255, FT * 1500)
			else
				self.FadeAlpha = Lerp(FT * 10, self.FadeAlpha, 0)
			end
			
			surface.SetDrawColor(0, 0, 0, self.FadeAlpha)
			surface.DrawRect(0, 0, x, y)
		end
	else
		self.FadeAlpha = 0
	end
	
	if self.CrosshairEnabled then
		lp = self.Owner:ShouldDrawLocalPlayer()
		
		if lp then
			td.start = self.Owner:GetShootPos()
			td.endpos = td.start + (self.Owner:EyeAngles() + self.Owner:GetPunchAngle()):Forward() * 16384
			td.filter = self.Owner
			
			tr = util.TraceLine(td)
			
			x2 = tr.HitPos:ToScreen()
			x2, y2 = x2.x, x2.y
		else
			x2, y2 = math.Round(x * 0.5), math.Round(y * 0.5)
		end
		
		if (self.dt.State == SWB_AIMING and self.FadeCrosshairOnAim) or self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION or self.dt.Safe or self.Owner:InVehicle() or ((self.IsReloading or self.IsFiddlingWithSuppressor) and self.Cycle <= 0.9) then
			self.CrossAlpha = Lerp(FT * 15, self.CrossAlpha, 0)
		else
			self.CrossAlpha = Lerp(FT * 15, self.CrossAlpha, 255)
		end
		
		if self.ClumpSpread then
			size = math.ceil(self.ClumpSpread * 2500)
			surface.SetDrawColor(0, 0, 0, self.CrossAlpha)
			surface.SetTexture(ClumpSpread)
			surface.DrawTexturedRect(x2 - size * 0.5 - 1, y2 - size * 0.5 - 1, size + 2, size + 2)
					
			surface.SetDrawColor(255, 255, 255, self.CrossAlpha)
			surface.DrawTexturedRect(x2 - size * 0.5, y2 - size * 0.5, size, size)
		end

		self.CrossAmount = Lerp(FT * 10, self.CrossAmount, (self.CurCone * 350) * (90 / (math.Clamp(GetConVarNumber("fov_desired"), 75, 90) - self.CurFOVMod)))
		surface.SetDrawColor(0, 0, 0, self.CrossAlpha * 0.75) -- BLACK crosshair parts
		
		if self.CrosshairParts.left then
			surface.DrawRect(x2 - 13 - self.CrossAmount, y2 - 1, 12, 3) -- left cross
		end
		
		if self.CrosshairParts.right then
			surface.DrawRect(x2 + 3 + self.CrossAmount, y2 - 1, 12, 3) -- right cross
		end
		
		if self.CrosshairParts.upper then
			surface.DrawRect(x2 - 1, y2 - 13 - self.CrossAmount, 3, 12) -- upper cross
		end
		
		if self.CrosshairParts.lower then
			surface.DrawRect(x2 - 1, y2 + 3 + self.CrossAmount, 3, 12) -- lower cross
		end
		
		surface.SetDrawColor(255, 255, 255, self.CrossAlpha) -- WHITE crosshair parts
		
		if self.CrosshairParts.left then
			surface.DrawRect(x2 - 12 - self.CrossAmount, y2, 10, 1) -- left cross
		end
		
		if self.CrosshairParts.right then
			surface.DrawRect(x2 + 4 + self.CrossAmount, y2, 10, 1) -- right cross
		end
		
		if self.CrosshairParts.upper then
			surface.DrawRect(x2, y2 - 12 - self.CrossAmount, 1, 10) -- upper cross
		end
		
		if self.CrosshairParts.lower then
			surface.DrawRect(x2, y2 + 4 + self.CrossAmount, 1, 10) -- lower cross
		end
	end
	
	sc1, sc2 = ScreenScale(22), ScreenScale(44)
	--draw.ShadowText(self.FireModeDisplay, "SWB_HUD16", x - sc1 - self.BulletDisplay * 20, y - sc2 - 20, White, Black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
--[[	
	if self.BulletDisplay and self.BulletDisplay > 0 then
		surface.SetTexture(Bullet)
		for i = 1, self.BulletDisplay do
			surface.SetDrawColor(0, 0, 0, 255)
			surface.DrawTexturedRect(x - sc1 - (i - 1) * 20 - 5, y - sc2 - 25, 16, 16)
			surface.SetDrawColor(255, 255, 255, 255)
			surface.DrawTexturedRect(x - sc1 - (i - 1) * 20 - 6, y - sc2 - 25, 16, 16)
		end
	end
--]]
end

function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
	if self.SelectIcon then
		surface.SetDrawColor(255, 210, 0, 255)
		surface.SetTexture(self.SelectIcon)
		surface.DrawTexturedRect(x + tall * 0.2, y, tall, tall)
	--else
		--draw.SimpleText(self.IconLetter, "SWB_SelectIcons", x + wide/2, y + tall*0.2, Color( 255, 210, 0, alpha ), TEXT_ALIGN_CENTER)
	end
end
--PATH addons/vapeswep/lua/weapons/weapon_vape_butterfly.lua:
-- weapon_vape_buttefly.lua
-- Defines a vape that flips like a butterfly knife

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Butterfly Vape"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nA stealthy vape for masters of vape-jitsu."

SWEP.VapeAccentColor = Vector(0.2,0.2,0.3)
SWEP.VapeTankColor = Vector(0.1,0.1,0.1)

SWEP.VapeVMAng2 = Vector(360+170,720-108,132)
--PATH addons/vapeswep/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/vapeswep/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/zeros_weedfarm/lua/weapons/zwf_joint/cl_init.lua:
include("shared.lua")

SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true -- Do you want the SWEP to have a crosshair?
local wMod = ScrW() / 1920
local hMod = ScrH() / 1080

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	self.LastWeed = -1
	self.LastWeedAmount = -1
	self.WeedLevel = -1
	self.WeedName = "nil"

end

function SWEP:DrawHUD()
	local weed = self:GetWeedID()

	if self.LastWeed ~= weed then
		self.LastWeed = weed


		if self.LastWeed ~= -1 then
			self.WeedLevel = self:GetWeed_Amount()
			self.WeedName = self:GetWeed_Name()
		end
	end

	local weed_amount = self:GetWeed_Amount()
	if self.LastWeedAmount ~= weed_amount then
		self.LastWeedAmount = weed_amount
	end


	if self.LastWeed ~= -1 then

		self.WeedLevel = self.WeedLevel - 2 * FrameTime()
		self.WeedLevel = math.Clamp(self.WeedLevel, self.LastWeedAmount, zwf.config.DoobyTable.WeedPerJoint)


		local width = (315 / zwf.config.DoobyTable.WeedPerJoint) * self.WeedLevel

		draw.RoundedBox(5, 800 * wMod, 1027 * hMod, 320 * wMod, 45 * hMod, zwf.default_colors["gray02"])
		draw.RoundedBox(5, 803 * wMod, 1029 * hMod, width * wMod, 41 * hMod, zwf.config.Plants[self.LastWeed].color)
		draw.SimpleText(self.WeedName, "zwf_wateringcan_font01", 960 * wMod, 1065 * hMod, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
	end
end

function SWEP:Think()
	zwf.f.LoopedSound(self, "zwf_joint_loop", self:GetIsSmoking())
end


function SWEP:SecondaryAttack()

	self:SetNextSecondaryFire(CurTime() + 1)
end

function SWEP:PrimaryAttack()

	self:SetNextPrimaryFire(CurTime() + 1)
end


function SWEP:StopLoopedSound()
	self:StopSound("zwf_joint_loop")
	zwf.f.StopLoopedSound(self)
end

function SWEP:Holster()
	self:StopLoopedSound()
end

function SWEP:OnRemove()
	self:StopLoopedSound()
end

--PATH addons/zeros_weedfarm/lua/weapons/zwf_wateringcan/shared.lua:
SWEP.PrintName = "Лейка" // The name of your SWEP
SWEP.Author = "ZeroChain" // Your name
SWEP.Instructions = "LMB - Pour Water | RMB - Collect Water" // How do people use your SWEP?
SWEP.Contact = "https://www.gmodstore.com/users/ZeroChain" // How people should contact you if they find bugs, errors, etc
SWEP.Purpose = "Used for watering plants." // What is the purpose of the SWEP?
SWEP.AdminSpawnable = true // Is the SWEP spawnable for admins?
SWEP.Spawnable = true // Can everybody spawn this SWEP? - If you want only admins to spawn it, keep this false and admin spawnable true.
SWEP.ViewModelFOV = 100 // How much of the weapon do you see?

SWEP.ViewModel = "models/zerochain/props_weedfarm/zwf_wateringcan_vm.mdl"
SWEP.WorldModel =  "models/zerochain/props_weedfarm/zwf_wateringcan_vm.mdl"


if CLIENT then
	SWEP.WepSelectIcon = surface.GetTextureID("zerochain/zwf/vgui/zwf_swep_wateringcan")
end


SWEP.AutoSwitchTo = true // When someone picks up the SWEP, should it automatically change to your SWEP?
SWEP.AutoSwitchFrom = false // Should the weapon change to the a different SWEP if another SWEP is picked up?
SWEP.Slot = 3 // Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6)
SWEP.SlotPos = 5 // Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.HoldType = "slam" // How is the SWEP held? (Pistol SMG Grenade Melee)
SWEP.FiresUnderwater = false // Does your SWEP fire under water?
SWEP.Weight = 5 // Set the weight of your SWEP.
SWEP.DrawCrosshair = true // Do you want the SWEP to have a crosshair?
SWEP.Category = "Zeros GrowOP"
SWEP.DrawAmmo = false // Does the ammo show up when you are using it? True / False
SWEP.base = "weapon_base" //What your weapon is based on.

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Recoil = 1
SWEP.Secondary.Delay = 1

SWEP.UseHands = true

function SWEP:SetupDataTables()
	self:NetworkVar("Int", 0, "Water")
	self:NetworkVar("Bool", 0, "IsBusy")
	self:NetworkVar("Bool", 1, "IsWatering")

	if (SERVER) then
		self:SetWater(zwf.config.WateringCan.Capacity)
		self:SetIsBusy(false)
		self:SetIsWatering(false)
	end
end

--PATH addons/111mod/lua/entities/armour_station/cl_init.lua:
--[[---------------------------------------------------------------------------
This is an example of a custom entity.
---------------------------------------------------------------------------]]
AddCSLuaFile()
include("shared.lua")

function ENT:Draw()
	if(EyePos():Distance(self.Entity:GetPos())<2000)then self:DrawModel()end	

	local Pos = self:GetPos()
	local Ang = self:GetAngles()

	local owner = self:Getowning_ent()
	owner = (IsValid(owner) and owner:Nick()) or DarkRP.getPhrase("unknown")

	surface.SetFont("HUDNumber5")
	local text = "Броня"
	local capacity = "Заряд: "..self:GetNW2Int("Armour_amount")
	local TextWidth = surface.GetTextSize(text)
	local CapacityWidth = surface.GetTextSize(capacity)

	Ang:RotateAroundAxis(Ang:Up(), 90)
	local TextAng = Ang

	if LocalPlayer():GetPos():Distance(self:GetPos()) < 200 then
		cam.Start3D2D(Pos+Ang:Up()*8, Ang, 0.1)
			draw.RoundedBox( 0, -TextWidth*0.5 -4, -60, TextWidth + 7, 30, Color(0,0,0,150) )
			draw.SimpleText( text, "HUDNumber5", -TextWidth*0.5, -60, Color(255,255,255,255), 0, 0, 1, Color(0,0,0) )
			
			draw.RoundedBox( 0, -CapacityWidth*0.5 -4, -25, CapacityWidth + 7, 30, Color(0,0,0,150) )
			draw.SimpleText( capacity, "HUDNumber5", -CapacityWidth*0.5, -25, Color(255,255,255,255), 0, 0, 1, Color(0,0,0) )
		cam.End3D2D()
	end
end

--PATH gamemodes/darkrp/entities/entities/arsenal/cl_init.lua:

-----------------------------------------------------
include('shared.lua')
local ipairs = ipairs
local CurTime = CurTime
local LocalPlayer = LocalPlayer
local math_sin = math.sin
local math_pi = math.pi
local cam_Start3D2D = cam.Start3D2D
local cam_End3D2D = cam.End3D2D
local draw_SimpleTextOutlined = draw.SimpleTextOutlined
local ents_FindByClass = ents.FindByClass
local vec = Vector(0, 0, 75)
local color_white = Color(255, 255, 255)
local color_black = Color(0, 0, 0)

function ENT:Draw()
	self:DrawModel()
	local pos = self:GetPos()
	local ang = self:GetAngles()
	local dist = pos:Distance(LocalPlayer():GetPos())
	if (dist > 350) then return end
	color_white.a = 350 - dist
	color_black.a = 350 - dist
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), -90)
	ang:RotateAroundAxis(ang:Right(), math_sin(CurTime() * math_pi) * -45)
	cam_Start3D2D(pos + vec + ang:Right() * 1.2, ang, 0.065)
	draw_SimpleTextOutlined('Снаряжение', '3d2d', 0, -350, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)
	cam_End3D2D()
	ang:RotateAroundAxis(ang:Right(), 180)
	cam_Start3D2D(pos + vec + ang:Right() * 1.2, ang, 0.065)
	draw_SimpleTextOutlined('Снаряжение', '3d2d', 0, -350, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, color_black)
	cam_End3D2D()
end

local fr

function OpenCops()
	if IsValid(fr) then
		fr:Close()
	end

	local w, h = ScrW() * .3, ScrH() * .5

	fr = ui.Create('ui_frame', function(self)
		self:SetTitle('Арсенал')
		self:SetSize(w, h)
		self:Center()
		self:MakePopup()
	end)

	local list = ui.Create('DScrollPanel', function(self, p)
		self:SetPos(5, 30)
		self:SetPadding(5)
		self:GetVBar():SetWide(10)
	end, fr)

	list:Dock(FILL)

	-- AMMO

	do
		local categoryAmmo = ui.Create('DCollapsibleCategory')
		local categoryWeapon = ui.Create('DCollapsibleCategory')

		categoryAmmo:Dock(TOP)
		categoryWeapon:Dock(TOP)

		categoryAmmo:SetLabel('Патроны')
		categoryWeapon:SetLabel('Оружие')

		list:AddItem(categoryAmmo)
		list:AddItem(categoryWeapon)

		for k, v in pairs(CopItems) do
			local category = v.weapon and categoryWeapon or categoryAmmo
			local pnl = ui.Create('ui_panel', category)
			pnl:SetTall(50)
			pnl:Dock(TOP)

			if (v.Model ~= nil) then
				local prvbg = ui.Create('ui_panel', function(self, p)
					self:SetPos(0, 0)
					self:SetSize(50, 50)

					--self.Paint = function(self, w, h)
						--draw.Box(2, 2, w - 4, h - 4, Color(255,255,255),Color(255,255,255))
					--end
				end, pnl)

				ui.Create('DModelPanel', function(self, p)
					self:SetSize(45, 45)
					self:SetPos(2.5, 2.5)
					self:SetModel(v.Model)
					local min, max = self.Entity:GetRenderBounds()
					self:SetCamPos(max * 1.3)
					self:SetLookAt(Vector(0, 0, 3))
				end, prvbg)
			end

			pnl.title = ui.Create('DLabel', pnl)
			pnl.title:SetFont('ui.16')
			pnl.title:SetPos(55, 10)
			pnl.title:SetText(v.Name)
			pnl.title:SizeToContents()

			if v.weapon then
                pnl.price = vgui.Create('DLabel', pnl)
                pnl.price:SetColor(Color(255, 255, 255))
                pnl.price:SetFont('ui.18')
                pnl.price:SetText(v.price and DarkRP.formatMoney(v.price) or '')
                pnl.price:SizeToContents(32)
                pnl.price:SetContentAlignment(5)
                pnl.price:SetSize(pnl.price:GetWide() + 16, pnl.price:GetTall() + 8)

                local colorFill = Color(100, 100, 100, 255)
                pnl.price.Paint = function(pricePanel, x, y)
                    draw.RoundedBox(4, 0, 0, x, y, colorFill)
                end
            end

			pnl.buy = ui.Create('DButton', pnl)
			pnl.buy:SetFont('ui.18')
			pnl.buy:SetSize(100, 40)

			pnl.buy:SetText(v.price and 'Купить' or 'Взять')

			pnl.buy.DoClick = function()
				net.Start("takeammo")
				net.WriteString(k)
				net.WriteBool(v.weapon and true or false)
				net.SendToServer()
			end

			local colorFill = Color(100, 100, 100, 255)
			local colorHover = Color(150, 150, 150, 255)
			local color_white = Color(255, 255, 255)
			local color_black = Color(0, 0, 0)
			function pnl.buy.Paint(pnlBuy, x, y)
				pnlBuy:SetTextColor(pnlBuy.TextColor or ((pnlBuy.Hovered and (not pnlBuy:GetDisabled()) and (not pnlBuy.Active)) and color_black or color_white))
				draw.RoundedBox(4, 0, 0, x, y, pnlBuy.Hovered and colorHover or colorFill)
			end

			function pnl:PerformLayout(x, y)
				self.buy:SetPos( x - self.buy:GetWide() - 10, (y - self.buy:GetTall()) / 2 )

				self.title:CenterVertical()

				if v.weapon then
					self.price:SetPos(x - self.buy:GetWide() - 20 - self.price:GetWide(), (y - self.price:GetTall()) / 2 )
				end
			end
		end
	end
end

net.Receive('copsMenu', OpenCops)
--PATH addons/foodmode/lua/entities/base_food/shared.lua:
ENT.Base = "base_gmodentity" 
ENT.Type = "anim" 

ENT.PrintName		= "Base food" 
ENT.Category 		= "Food mode - foods" 
ENT.Author			= "" 

ENT.Spawnable			= false 
ENT.AdminSpawnable		= false 
--PATH addons/mod_bitminers2/lua/entities/bm2_bitminer_2/shared.lua:
ENT.Type = "anim"

ENT.PrintName = "Bitminer 2"
ENT.Spawnable = true
ENT.Category = "Bitminers 2"

ENT.upgrades = {
	CPU = {name = "CPU Speed +256MHz", cost = {2000,400,8000,16000,320000, 64000, 128000}, amountPerUpgrade = 0.256},
	CORES = {name = "Adds an extra core", cost = {50000, 10000, 175000}}
}

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "HasPower" )
	self:NetworkVar( "Bool", 2, "IsOn")
	self:NetworkVar( "Bool", 3, "IsMining")
	self:NetworkVar( "Float", 1, "BitcoinAmount")
	self:NetworkVar( "Int", 1, "CPUUpgrade")
	self:NetworkVar( "Int", 2, "CoreUpgrade")  
	self:NetworkVar( "Float", 3, "ClockSpeed")
	self:NetworkVar( "Int", 4, "CoreCount")
	//A string table of all the updates that have been purchased.
	self:NetworkVar( "String", 1, "Updates") 
	self:NetworkVar("Entity", 0, "owning_ent")
end


--PATH addons/bricks_gangs/lua/entities/bricks_server_territory/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
 
ENT.PrintName		= "Territory"
ENT.Category		= "Bricks Server"
ENT.Author			= "Brick Wall"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable		= true

function ENT:SetupDataTables()
    self:NetworkVar( "Int", 0, "TerritoryKey" )
    self:NetworkVar( "Int", 1, "CaptureEndTime" )
    self:NetworkVar( "Int", 2, "UnCaptureEndTime" )
    self:NetworkVar( "Entity", 0, "Captor" )
end

function ENT:CanTool(ply, tab, str)
    return (ply:IsSuperAdmin())
end
--PATH addons/111mod/lua/entities/ent_license/shared.lua:
ENT.Type = "anim"

ENT.Base = "base_gmodentity"

ENT.PrintName = "License entity"

ENT.Author = "Creonix"

ENT.Spawnable = true

ENT.AdminSpawnable = true

--PATH addons/111mod/lua/entities/ent_picture/shared.lua:
ENT.Type = 'anim'
ENT.PrintName = 'Picture'
ENT.Author = 'aStonedPenguin'
ENT.Base = 'base_anim'
ENT.Category = 'RP'
ENT.Spawnable = true

function ENT:SetupDataTables()
	self:NetworkVar('String', 1, 'URL')
	self:NetworkVar("Entity", 1, "owning_ent")
end
--PATH addons/111mod/lua/entities/ent_picture2/cl_init.lua:
include'shared.lua'
cvar.Register'enable_pictureframes':SetDefault(true):AddMetadata('State', 'RPMenu'):AddMetadata('Menu', 'Отображение Картин')

timer.Simple( 2.5 , function() texture.SetProxy ("https://gmod-api.superiorservers.co/api/imageproxy/?url=%s&width=%i&height=%i&format=%s") end )


function ENT:RenderTexture()
    self.Rendering = true
	texture.Create(self:GetURL()):SetSize(2048, 2048):SetFormat(self:GetURL():sub(-3) == 'jpg' and 'jpg' or 'png'):EnableProxy(true):Download(self:GetURL(), function()
        if IsValid(self) then
            self.Rendering = false
            self.LastURL = self:GetURL()
        end
    end, function()
        if IsValid(self) then
            self.Rendering = false
        end
    end)
end

function ENT:GetTexture()
    return texture.Get(self:GetURL())
end

function ENT:Draw()
    self:DrawModel()
    if (cvar.GetValue('enable_pictureframes') == false) or (not self:InSight()) then return end
    if ((not self:GetTexture()) or (self:GetURL() ~= self.LastURL)) and (not self.Rendering) then
        self:RenderTexture()
    end

    local ang = self:GetAngles()
    ang:RotateAroundAxis(ang:Up(), 90)
    ang:RotateAroundAxis(ang:Forward(), 0)
    local scale = self:GetModelScale()
    local s = 2048 * scale
    local off = -(s * 0.5)
    cam.Start3D2D(self:GetPos() + (self:GetUp() * 1.55), ang, 0.04635)
    surface.SetDrawColor(25, 25, 25, 255)
    surface.DrawRect(off, off, s, s)

    if self.Rendering then
        local t = SysTime() * 5
        draw.NoTexture()
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawArc(off + (s * 0.5), off + (s * 0.5), 111, 116, t * 180, t * 180 + 180, 10)
    elseif self:GetTexture() then
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(self:GetTexture())
        surface.DrawTexturedRect(off, off, s, s)
    end

    cam.End3D2D()
end

local all_patterns = {"^https?://.*%.jpg", "^https?://.*%.png"}

local function IsValidURL(url)
    for _, pattern in ipairs(all_patterns) do
        if string.match(url, pattern) then return true end
    end
end

local fr

net.Receive('rp.OpenImageWindow', function()
    local set
    local text
    local ava

    if IsValid(fr) then
        fr:Close()
    end
	
	
    fr = ui.Create('ui_frame', function(self)
        self:SetSize(520, 120)
        self:SetTitle('Изменить')
        self:MakePopup()
        self:Center()

        function self:Think()
            if IsValid(set) and IsValid(text) and IsValidURL(text:GetValue()) then
                set:SetDisabled(false)
            else
                set:SetDisabled(true)
            end
        end
    end)

    text = ui.Create('DTextEntry', function(self, p)
        self:SetPos(5, 60)
        self:SetSize(p:GetWide() - 10, 25)

        self.OnEnter = function(s)
            set:DoClick()
        end
    end, fr)

    ui.Create('DLabel', function(self, p)
        self:SetText('Расширения .jpg и .png! За нецензуру бан.\nФормат ссылки: http://yourdomain.com/image.png.')
        self:SetFont('ui.24')
        self:SetTextColor(ui.col.Close)
        self:SizeToContents()
        self:SetPos((p:GetWide() - self:GetWide()) / 2, 32)
    end, fr)

    set = ui.Create('DButton', function(self, p)
        self:SetText('Изменить')
        self:SetPos(5, 90)
        self:SetSize(p:GetWide() / 2 - 7.5, 25)

        function self:DoClick()
            p:Close()
            RunConsoleCommand('setimage', text:GetValue())
        end
    end, fr)
end)
--PATH addons/111mod/lua/entities/f_printer/cl_init.lua:
local errorMat = Material("error")
local WebImageCache = {}
if !file.IsDir('dudework', 'DATA') then
    file.CreateDir('dudework')
end
function http.DownloadMaterial(url, path, callback)
    if WebImageCache[url] then return callback(WebImageCache[url]) end

    local data_path = "data/dudework/".. path
    if file.Exists('dudework/'..path, "DATA") then
        WebImageCache[url] = Material(data_path, "smooth", "noclamp")
        callback(WebImageCache[url])
    else
        http.Fetch(url, function(img)
            if img == nil or string.find(img, "<!DOCTYPE HTML>", 1, true) then return callback(errorMat) end

            file.Write('dudework/'..path, img)
            WebImageCache[url] = Material(data_path, "smooth", "noclamp")
            callback(WebImageCache[url])
        end, function()
            callback(errorMat)
        end)
    end
end
local function MakeCirclePoly( _x, _y, _r, _points )
    local _u = ( _x + _r * 320 ) - _x;
    local _v = ( _y + _r * 320 ) - _y;
    local _slices = ( 2 * math.pi ) / _points;
 
    local _poly = { };
 
    for i = 0, _points - 1 do
        local _angle = ( _slices * i ) % _points;
        local x = _x + _r * math.cos( _angle );
        local y = _y + _r * math.sin( _angle );
       
        table.insert( _poly, { x = x, y = y, u = _u, v = _v } )
    end

    return _poly;
end

local mat1 = Material('printer/rectangle_79.png','noclamp smooth')
local mat2 = Material('printer/rectangle_80.png','noclamp smooth')
local mat3 = Material('printer/rectangle_99.png','noclamp smooth')
local mat4 = Material('printer/gambit.png','noclamp smooth')
local PANEL = {}
 
function PANEL:Init()
    self.Avatar = vgui.Create("AvatarImage", self)
    self.Avatar:SetPaintedManually(true)

    self.material = Material( "effects/flashlight001" )

    self:OnSizeChanged(self:GetWide(), self:GetTall())
end
 
 
 
function PANEL:PerformLayout()
    self:OnSizeChanged(self:GetWide(), self:GetTall())
end
 
 
 
function PANEL:SetSteamID(...)
    self.Avatar:SetSteamID(...)
end
 
 
 
function PANEL:SetPlayer(...)
    self.Avatar:SetPlayer(...)
end
 
 
 
function PANEL:OnSizeChanged(w, h)
    self.Avatar:SetSize(self:GetWide(), self:GetTall())
    self.points = math.Max((self:GetWide()/4), 32)
    self.poly = MakeCirclePoly(self:GetWide()/2, self:GetTall()/2, self:GetWide()/2, self.points)
end
 
 
 
function PANEL:DrawMask(w, h)
    draw.NoTexture();
    surface.SetMaterial( self.material )
    surface.SetDrawColor( color_white )
    surface.DrawPoly( self.poly )
end
 
 
 
function PANEL:Paint(w, h)
    render.ClearStencil()
    render.SetStencilEnable(true)
    render.SetStencilWriteMask( 1 )
    render.SetStencilTestMask( 1 )
    render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
    render.SetStencilPassOperation( STENCILOPERATION_ZERO )
    render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )
    render.SetStencilReferenceValue( 1 )
 
    self:DrawMask(w, h)
 
    render.SetStencilFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
    render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
    render.SetStencilReferenceValue( 1 )
 
    self.Avatar:SetPaintedManually(false)
    self.Avatar:PaintManual()
    self.Avatar:SetPaintedManually(true)
 
    render.SetStencilEnable(false)
    render.ClearStencil()
end

vgui.Register("AvatarMask", PANEL)


include("shared.lua")

function weight(x)
    return x/1920*ScrW()
end

function height(y)
    return y/1080*ScrH()
end

surface.CreateFont("GambitPrinter.Font1", {
    font = "Montserrat Medium",
    size = height(16),
    weight = 500,
    extended = true
})

surface.CreateFont("GambitPrinter.Font2", {
    font = "Roboto",
    size = ScreenScale(32),
    weight = 1000,
    extended = true
})

surface.CreateFont("GambitPrinter.Font3", {
    font = "Roboto",
    size = ScreenScale(15),
    weight = 1000,
    extended = true
})

surface.CreateFont("GambitPrinter.Font4", {
    font = "Roboto",
    size = ScreenScale(5),
    weight = 1000,
    extended = true
})

surface.CreateFont("GambitPrinter.Font5", {
    font = "Roboto",
    size = ScreenScale(48),
    weight = 1000,
    extended = true
})

surface.CreateFont("rp.LockDown", {
    font = "Roboto",
    size = ScreenScale(8.02),
    weight = 1000,
    extended = true
})

surface.CreateFont("F_OwnerName", {
    font = "Montserrat",
    size = 122,
    weight = 1000,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    extended = true,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false
})
surface.CreateFont("F_Info", {
    font = "Montserrat",
    size = 40,
    weight = 500,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    extended = true,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false
})
surface.CreateFont("F_Money", {
    font = "Montserrat Bold",
    size = 122,
    weight = 1000,
    blursize = 0,
    scanlines = 0,
    antialias = true,
    underline = false,
    extended = true,
    italic = false,
    strikeout = false,
    symbol = false,
    rotary = false,
    shadow = false,
    additive = false,
    outline = false
})

local function frametext(text, font, x, y, color, x_a, y_a, color_shadow)
    color_shadow = color_shadow or Color(0, 0, 0)
    draw.SimpleText(text, font, x + 1, y + 1, color_shadow, x_a, y_a)
    local w, h = draw.SimpleText(text, font, x, y, color, x_a, y_a)

    return w, h
end

function ENT:Initialize()
    self.sound = CreateSound(self, Sound("ambient/levels/labs/equipment_printer_loop1.wav"))
    self.sound:SetSoundLevel(52)
    self.sound:PlayEx(1, 100)
    self.soundsignalize = CreateSound(self, Sound("ambient/alarms/klaxon1.wav"))
    self.soundsignalize:SetSoundLevel(75)
end

function ENT:Think()
    if self:GetStatus() then
        self.sound:PlayEx(1, 100)

        if self:GetSignalize() then
            if self:GetHeat() == 85 then
                self.soundsignalize:PlayEx(1, 100)
			elseif self:GetHeat() == 90 then
				self.soundsignalize:PlayEx(1, 100)
			elseif self:GetHeat() == 95 then
				self.soundsignalize:PlayEx(1, 100)
            else
                if self.soundsignalize then
                    self.soundsignalize:Stop()
                end
            end
        end
    else
        if self.sound then
            self.sound:Stop()
        end
    end
end

function ENT:OnRemove()
    if self.sound then
        self.sound:Stop()
    end

    if self.soundsignalize then
        self.soundsignalize:Stop()
    end
end

local text = draw.SimpleText
local box = draw.RoundedBox
local size
local color
local lerp_1, lerp_2 = 0, 0
local alpha = 0
local level

function ENT:BorderLength(l)
    self.border = {}
    local size = self.size
    -- if !size then return end
    for i = 0, l-1 do 
        self.border[#self.border+1] = {
            x = i*size,
            move = 1,
            y = 0
        }
    end
end

function ENT:SetBorder(size,length)
    self.size = size
    self:BorderLength(length)
end

function ENT:DrawSnake(w,h)

    if self.needpaint and self.needpaint > CurTime() then 
        return 
    end

    self.needpaint = CurTime()+0.007

    local tbl = self.border
    local size = self.size
    if !size or !tbl then return end
    
    for i = 1, #tbl do 
        local v = tbl[i]
        
        if v.move == 1 then 
            v.x = v.x + size
        elseif v.move == 2 then
            v.y = v.y + size
        elseif v.move == 3 then
            v.x = v.x - size 
        else
            v.y = v.y - size
        end
        if v.x >= w and v.move != 2 then 
            v.move = 2
            v.x = w-size    
        elseif v.y >= h and v.move != 3 then 
            v.move = 3
            v.y = h - size
        elseif v.x <= 0 and v.move != 4 then 
            v.move = 4 
            v.x = 0
        elseif v.y <= 0 and v.move != 1 then 
            v.move = 1  
            v.y = 0 
        end
    end

end
function ENT:Draw()

    if !self.size then 
        self:SetBorder(3,50) 
    end

   	self:DrawModel()
	if self:GetPos():Distance( LocalPlayer():GetPos() ) > 500 then return end

	local pos, ang = self:GetPos(), self:GetAngles()

	Owner = self:Getowning_ent()
	if IsValid(Owner) and Owner:Nick() then 
		Owner = Owner:Nick()
	else 
		Owner = "Неизвестный" 
	end

    if self:GetHeat() == 0 then
        color = Color(255,255,255,255)
        size = 0
    elseif self:GetHeat() <=40 then
        color = Color(0,255,0,255)
        size = 50
    elseif self:GetHeat() <=75 then
        color = Color(255,120,0,255)
        size = 150
    elseif self:GetHeat() <100 then
        color = Color(255,0,0,255)
        size = 240
    elseif self:GetHeat() >= 100 then
        color = Color(255,0,0,255)
        size = 280
    end

    gradcolor = self:GetGRColor()

    local colorValues = string.Explode(",", gradcolor)
    
    local r = tonumber(colorValues[1]) or 255
    local g = tonumber(colorValues[2]) or 255
    local b = tonumber(colorValues[3]) or 255 
    local colorGrad = Color(r, g, b)
    if colorGrad == nil then
        colorGrad = Color(217,217,217)
    end
	ang:RotateAroundAxis(ang:Up(), 90)
    local MaxMoney = DarkRP.formatMoney(self:GetMaxMoney())
	local hp = self:GetPrinterHealth() .. "%"

	cam.Start3D2D(pos + ang:Up() * 10.7 + ang:Forward() * -15.15 + ang:Right() * -20.5, ang, 0.11)
        alpha = math.floor( math.sin( CurTime() * 3 ) * 35 ) + 150
        draw.TexturedQuad({
            texture = surface.GetTextureID "gui/gradient_up",
            color = Color(colorGrad.r,colorGrad.g,colorGrad.b,alpha),
            x = 0,
            y = 0,
            w = 278,
            h = 310
        })

		box(0,0,39,278,3,Color(colorGrad.r,colorGrad.g,colorGrad.b,150))
		box(0,0,310,278,3,Color(colorGrad.r,colorGrad.g,colorGrad.b,200))
		box(0,0,42,3,268,Color(colorGrad.r,colorGrad.g,colorGrad.b,150))
		box(0,275,42,3,268,Color(colorGrad.r,colorGrad.g,colorGrad.b,150))
	cam.End3D2D()

    cam.Start3D2D(pos + ang:Up() * 10.70 + ang:Forward() * -15.15 + ang:Right() * -20.5, ang, 0.03)
        text("Денежный принтер","F_OwnerName",279*1.83,220,Color(255,255,255),1,1)
        surface.SetFont('F_OwnerName')

        box(6,40,370,940,170,Color(0,0,0,100))

		text(Owner,"F_OwnerName",500,310,Color(255,255,255),1,1)
		text(DarkRP.formatMoney(self:GetMoney()) .. ' / ' .. MaxMoney,"F_Money",535,455,Color(255,255,255),1,1)
	cam.End3D2D()

    cam.Start3D2D(pos + ang:Up() * 11 + ang:Forward() * -38 + ang:Right() * -52, ang, 0.1)
        surface.SetDrawColor(255, 255, 255, 115)
        surface.SetMaterial(mat4)
        surface.DrawTexturedRect(300, 490, 160, 160)
    cam.End3D2D()

    cam.Start3D2D(pos + ang:Up() * 10.7 + ang:Forward() * -15.15 + ang:Right() * -16.2, ang, 0.11)
        self:DrawSnake(278,274) 

        local tbl = self.border
        for i = 1, #tbl do 
            local v = tbl[i]
            surface.SetDrawColor(colorGrad)
            surface.DrawRect(v.x,v.y,self.size,self.size)
        end
    cam.End3D2D()
	
    ang:RotateAroundAxis(ang:Up(), 0)
    ang:RotateAroundAxis(ang:Forward(), 90)
    cam.Start3D2D(pos + ang:Up() * 16.6 + ang:Forward() + ang:Right() * -24, ang, 0.045)
        local ft = FrameTime() * 8
        lerp_1, lerp_2 = Lerp(ft, lerp_1, self:GetMoney()), Lerp(ft, lerp_2, size)
        box(6,-330,420,180,95,Color(0,0,0,200))

        box(6,-140,420,280,45,Color(0,0,0,200))
        box(6,-140,420,280* math.Clamp(lerp_2 / 280, 0, 1),45,color)

        box(6,-140,470,280,45,Color(0,0,0,200))
        box(6,-140,470,280* math.Clamp(lerp_1 / self:GetMaxMoney(), 0, 1),45,Color(18,53,43,200))

        text(hp, 'GambitPrinter.Font3', -235,465, Color(255, 255, 255, 150), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        text(self:GetVIP() and "VIP" or "", 'GambitPrinter.Font3', 90, 390, Color(200, 175, 0, 150), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        text(self:GetHeat() .. " °C", 'F_Info', -130, 420, Color(255,255,255,200), 0, 0)
        text(DarkRP.formatMoney(self:GetMoney()), 'F_Info', -130, 470, Color(255,255,255,200), 0, 0)
    cam.End3D2D()
end

net.Receive("GambitPrinter.Menu", function()
    level = net.ReadUInt(32)
    local ent = net.ReadEntity()
    if not IsValid(ent) then return end
    if IsValid(PrinterFrame) then return end
    local MaxMoney = DarkRP.formatMoney(ent:GetMaxMoney())
    PrinterFrame = vgui.Create("DFrame")
    PrinterFrame:SetTitle("")
    PrinterFrame:SetSize(weight(563), height(505))
    PrinterFrame:ShowCloseButton(false)
    PrinterFrame:SetAlpha(0)
    PrinterFrame:AlphaTo(255, 0.3, 0)
    PrinterFrame:Center()
    PrinterFrame:MakePopup()
    PrinterFrame:ShowCloseButton(false)
    PrinterFrame.Paint = function(self,w,h)
        box(16,0,0,w,h,Color(45,45,45,253))
    end


    local header = vgui.Create('DPanel',PrinterFrame)
    header:SetSize(weight(563+12),height(96))
    header:SetPos(weight(-6),0)
    header.Paint = function(self,w,h)
        surface.SetMaterial(mat2) 
        surface.SetDrawColor(Color(255,255,255)) 
        surface.DrawTexturedRect(0,0,w,h)-- 
        text(Owner,'GambitPrinter.Font1',weight(69),h/2,Color(255,255,255),0,1)
        if not IsValid(ent) then return end
        surface.SetFont('GambitPrinter.Font1')
        local xname,yanem = surface.GetTextSize(Owner)
        local xmoney,ymoney = surface.GetTextSize(DarkRP.formatMoney(ent:GetMoney()))
        local xmax,ymax = surface.GetTextSize(MaxMoney)
        local xlvl,ylvl = surface.GetTextSize(level.. ' Уровень')

        box(6,xname+weight(84),height(31),xmoney+weight(30),height(34),Color(38,37,37))
        draw.RoundedBoxEx(2,xname+weight(84),height(38),weight(2),height(20),Color(74,132,0),false,true,false,true)
        text(DarkRP.formatMoney(ent:GetMoney()),'GambitPrinter.Font1',xname+weight(99),h/2,Color(255,255,255,125),0,1)

        box(6,xname+xmoney+weight(123),height(31),weight(50),height(34),Color(38,37,37))
        draw.RoundedBoxEx(2,xname+xmoney+weight(123),height(38),weight(2),height(20),color,false,true,false,true)
        text(ent:GetHeat() .. "°C",'GambitPrinter.Font1',xname+xmoney+weight(137),h/2,Color(255,255,255,125),0,1)

        box(6,xname+xmoney+weight(183),height(31),xmax+weight(28),height(34),Color(38,37,37))
        draw.RoundedBoxEx(2,xname+xmoney+weight(183),height(38),weight(2),height(20),Color(121,9,132),false,true,false,true)
        text(MaxMoney,'GambitPrinter.Font1',xname+xmoney+weight(197),h/2,Color(255,255,255,125),0,1)

        draw.RoundedBox(6,xname+xmoney+xmax+weight(220),height(31),xlvl+weight(28),height(34),Color(38,37,37))
        draw.RoundedBoxEx(2,xname+xmoney+xmax+weight(220),height(38),weight(2),height(20),GambitPrinter.Config.Levels[level].color,false,true,false,true)
        text(level .. ' Уровень','GambitPrinter.Font1',xname+xmoney+xmax+weight(232),h/2,Color(255,255,255,125),0,1)
    end

    local close = vgui.Create("DButton", PrinterFrame)
    close:SetSize(weight(564), height(76))
    close:SetPos(weight(-1),height(428))
    close:SetText("")
    close.alpha = 0
    close.Paint = function(self, w, h)
        if not IsValid(ent) then return end
        
        if self:IsHovered() then
            self.alpha = Lerp(FrameTime()*10,self.alpha,0.6)
        else
            self.alpha = Lerp(FrameTime()*10,self.alpha,1)
        end
        surface.SetMaterial(mat1) 
        surface.SetDrawColor(Color(255,255,255,255 * self.alpha)) 
        surface.DrawTexturedRect(0,0,w,h)-- 
        text(ent:GetStatus() and 'Выключить' or 'Включить','GambitPrinter.Font1',w/2,h/2,Color(255,255,255),1,1)
    end

    close.DoClick = function(self)
        if not IsValid(ent) then return end
        net.Start("GambitPrinter.Status")
        net.WriteEntity(ent)
        net.SendToServer()
    end

    if IsValid(ent) then 
        local ava = vgui.Create('AvatarMask', header)
        ava:SetSize(weight(44),height(44))
        ava:SetPos(weight(14),height(26))
        if ent:Getowning_ent() then
            ava:SetPlayer(ent:Getowning_ent(),64)
        end
    end

    local SButton = PrinterFrame:Add("DButton")
    SButton:SetSize(weight(58),height(59))
    SButton:SetPos(weight(485),height(18))
    SButton:SetText('')
    SButton.Paint = function(self, w, h)
        local color = Color(255,255,255)
        if self.Hovered then
            color = Color(1,116,222)
        end

        box(6,0,0,w,h,Color(38,37,37))
        box(6,weight(8),height(8),weight(42),height(43),Color(45,45,45))
        text( '✕', 'GambitPrinter.Font1', w/2, h/2, color, 1, 1)
    end

    SButton.DoClick = function(self)
        PrinterFrame:AlphaTo(0, 0.3, 0, function()
            PrinterFrame:Remove()
        end)
    end

    local WButton = PrinterFrame:Add("DButton")
    WButton:SetSize(weight(535),height(44))
    WButton:SetPos(weight(14),height(389))
    WButton:SetText('')
    WButton.alpha = 0
    WButton.Paint = function(self, w, h)
        if not IsValid(ent) then return end
        if self:IsHovered() then
            self.alpha = Lerp(FrameTime()*10,self.alpha,0.6)
        else
            self.alpha = Lerp(FrameTime()*10,self.alpha,1)
        end
        box(12,0,0,w,h,Color(38,37,37,255 * self.alpha))
        text("Снять деньги",'GambitPrinter.Font1',w/2,h/2,Color(255,255,255),1,1)
    end
    WButton.DoClick = function(self)
        if not IsValid(ent) then return end
        net.Start("GambitPrinter.Withdraw")
        net.WriteEntity(ent)
        net.SendToServer()
    end
    if IsValid(ent) then
        local PButton = PrinterFrame:Add("DButton")
        PButton:SetSize(weight(535),height(44))
        PButton:SetPos(weight(14),height(335))
        PButton:SetText('')
        PButton.alpha = 0
        PButton.Paint = function(self, w, h)
            if not IsValid(ent) then return end
            if self:IsHovered() then
                self.alpha = Lerp(FrameTime()*10,self.alpha,0.6)
            else
                self.alpha = Lerp(FrameTime()*10,self.alpha,1)
            end
            box(12,0,0,w,h,Color(38,37,37,255 * self.alpha))
            text("Купить охлаждение (" .. DarkRP.formatMoney(GambitPrinter.Config.CoolCost) .. ")",'GambitPrinter.Font1',w/2,h/2,Color(255,255,255),1,1)
        end

        PButton.DoClick = function(self)
            if not IsValid(ent) then return end
            net.Start("GambitPrinter.Cool")
            net.WriteEntity(ent)
            net.SendToServer()
        end
    end
    local lvl = level
    local Scroll
    local function refresh()
        if IsValid(Scroll) then Scroll:Remove() end
        Scroll = vgui.Create( "DScrollPanel", PrinterFrame )
        Scroll:SetSize(weight(543),height(211))
        Scroll:SetPos(weight(14),height(111))
        Scroll.Paint = nil
        Scroll.VBar:SetWide(weight(2))
        local bar = Scroll.VBar
        bar:SetHideButtons(true)
        bar.Paint = function(self,w,h)
        end
        bar.btnGrip.Paint = function(this, w, h)
            box(3, 0, 0, w, h, Color(1,116,222))
        end
        
        local List = vgui.Create( 'DIconLayout', Scroll )
        List:Dock( FILL )
        List:SetSpaceY( height(11) )
        List:SetSpaceX( 0 )
        List:DockMargin( 0,0,0,0 )
        for k,v in ipairs(GambitPrinter.Config.Levels) do
            local panel = vgui.Create('DPanel',List)
            panel:SetSize(weight(535),height(63))
            panel.Paint = function(self,w,h)
                if not IsValid(ent) then return end
                box(9,0,0,w,h,Color(38,37,37))
                surface.SetMaterial(mat3) 
                surface.SetDrawColor(v.color) 
                surface.DrawTexturedRect(weight(-5),height(-8),weight(30),height(79)) 
                text(v.name,'GambitPrinter.Font1',weight(25),height(16))
                if v.isVip then
                    surface.SetFont('GambitPrinter.Font1')
                    local nx,ny = surface.GetTextSize(v.name)
                    text('VIP','GambitPrinter.Font1',weight(32)+nx,height(16),Color(255,178,0))
                end
                if level == v.id then
                    text('Установлен','GambitPrinter.Font1',weight(25),height(30),Color(167,255,159,125),0,0)
                elseif level > v.id then
                    text('Имеется','GambitPrinter.Font1',weight(25),height(30),Color(236,255,159,125),0,0)
                else
                    text('Не куплен','GambitPrinter.Font1',weight(25),height(30),Color(255,150,159,125),0,0)
                end
                text('Информация','GambitPrinter.Font1',w/2,height(7),Color(255,255,255,125),1,0)
                draw.DrawText(v.desc,'GambitPrinter.Font1',w/2,height(23),Color(255,255,255),1,0)
            end
            if level < v.id then 
                local pBut = vgui.Create('DButton',panel)
                pBut:SetSize(weight(102),height(46))
                pBut:SetPos(weight(421),height(9))
                pBut:SetText('')
                pBut.alpha = 0
                pBut.Paint = function(self,w,h)
                    if not IsValid(ent) then return end
                    if self:IsHovered() then
                        self.alpha = Lerp(FrameTime()*10,self.alpha,0.6)
                    else
                        self.alpha = Lerp(FrameTime()*10,self.alpha,1)
                    end
                    box(7,0,0,w,h,Color(45,45,45,255 * self.alpha))
                    text(DarkRP.formatMoney(v.price),'GambitPrinter.Font1',w/2,h/2,Color(56,169,48),1,1)
                end
                pBut.DoClick = function()
                    if not IsValid(ent) then return end
                    net.Start('ENC:BuyLvl')
                    net.WriteEntity(ent)
                    net.WriteUInt(v.id,32)
                    net.SendToServer()

                    net.Receive('ENC:BuyLvl',function()
                        level = net.ReadUInt(32)
                    end)
                    timer.Simple(.3,function()
                    refresh()
                    end)
                end
            end
        end
    end
    refresh()
end)


local function DrawMovingLine()

end

hook.Add("HUDPaint", "DrawMovingLine", DrawMovingLine)
--PATH addons/111mod/lua/entities/f_printer/shared.lua:
ENT.Base = "base_gmodentity"
ENT.PrintName = "Денежный принтер"
ENT.Author = ""
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
    self:NetworkVar("Int", 4, "Money")
    self:NetworkVar("Bool", 0, "Status")
    self:NetworkVar("Bool", 5, "Signalize")
    self:NetworkVar("Bool", 6, "VIP")
    self:NetworkVar("Float", 2, "Heat")
    self:NetworkVar("Int", 7, "PrintCount")
    self:NetworkVar("Int", 8, "PrintInterval")
    self:NetworkVar("Int", 9, "MaxMoney")
    self:NetworkVar("Int", 10, "AddsHeat")
	self:NetworkVar("Int", 11, "PrinterHealth")
    self:NetworkVar("Entity", 1, "owning_ent")
end

GambitPrinter = {}
GambitPrinter.Config = {}
GambitPrinter.Buffs = {}

GambitPrinter.Config.PrintCount = 250
GambitPrinter.Config.MaxMoney = 5000
GambitPrinter.Config.PrintInterval = 30

GambitPrinter.Config.PrinterHealth = 100
GambitPrinter.Config.SignalizeCost = 1000
GambitPrinter.Config.FixCost = 500
GambitPrinter.Config.CoolCost = 500
GambitPrinter.Config.VIPCost = 1000
GambitPrinter.Config.StartHeat = 30
GambitPrinter.Config.StartHealth = 100
GambitPrinter.Config.VMaxMoney = 50000
GambitPrinter.Config.VPrintInterval = 30
GambitPrinter.Config.VPrintCount = 500
GambitPrinter.Config.MaxHeat = 100
GambitPrinter.Config.AddsHeat = 5
GambitPrinter.Config.VAddsHeat = 4

GambitPrinter.Config.Levels = {
    {
        name = 'Уровень 1',
        desc = 'Ничего примечательного',
        color = Color(217,217,217),
        price = 0,
        id = 1,
    },
    {
        name = 'Уровень 2',
        desc = 'Немного увеличивает прибыль и\nмаксимальную сумму хранения',
        color = Color(24,143,1),
        price = 2000,
        id = 2,
        MaxMoney = 10000,
        PrintInterval = 30,
        PrintCount = 300,
    },
    {
        name = 'Уровень 3',
        desc = 'Немного ускоряет процесс заработка и \nувеличивает максимальную сумму хранения',
        color = Color(0,86,140),
        price = 4000,
        id = 3,
        MaxMoney = 20000,
        PrintInterval = 30,
        PrintCount = 400,
    },
    {
        name = 'Уровень 4',
        desc = 'Значительно ускоряет прибыль\nи максимальную сумму хранения ',
        color = Color(112,53,226),
        price = 5000,
        id = 4,
        MaxMoney = 40000,
        PrintInterval = 30,
        PrintCount = 550,
        isVip = true
    },
    {
        name = 'Уровень 5',
        desc = 'По сравнению с первым уровнем\nвсе характеристики увеличены вдвое',
        color = Color(255,178,0),
        price = 6000,
        id = 5,
        MaxMoney = 80000,
        PrintInterval = 30,
        PrintCount = 750,
        isVip = true
    },
}

local meta = FindMetaTable("Entity")

function meta:GetGRColor()
	return self:GetNWString("PR:Color")
end
--PATH addons/truefishing/lua/entities/fishing_pot_large/cl_init.lua:
include('shared.lua')

	
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:AddFish(fish)
	local pos = self:GetPos() + self:GetUp()
	local rh, fw, num = self:GetRight(), self:GetForward()*6.5, #self.FishToDisplay%14
	if num < 7 then
		num = num + 1
		self.FishToDisplay[num] = ClientsideModel(TrueFishGetFishModel(fish), RENDERGROUP_OPAQUE)
		self.FishToDisplay[num].FishID = fish
		self.FishToDisplay[num]:SetAngles(Angle(math.random(1,360), math.random(1,360), math.random(1,360)))
		self.FishToDisplay[num]:SetPos(pos - (rh*(num*5.5)+fw))
		self.FishToDisplay[num]:SetParent(self)
		self.FishToDisplay[num]:DrawShadow(false)
		self.FishToDisplay[num]:SetNoDraw(true)
	else
		num = num + 1
		self.FishToDisplay[num] = ClientsideModel(TrueFishGetFishModel(fish), RENDERGROUP_OPAQUE)
		self.FishToDisplay[num].FishID = fish
		self.FishToDisplay[num]:SetAngles(Angle(math.random(1,360), math.random(1,360), math.random(1,360)))
		self.FishToDisplay[num]:SetPos(pos + (rh*(num*5.5-45)-fw))
		self.FishToDisplay[num]:SetParent(self)
		self.FishToDisplay[num]:DrawShadow(false)
		self.FishToDisplay[num]:SetNoDraw(true)
	end
end

function ENT:AddBait()
	self.Bait = ClientsideModel("models/props_junk/garbage_bag001a.mdl", RENDERGROUP_OPAQUE)
	self.Bait:SetMaterial("models/flesh")
	local ang = self:GetAngles()
	self.Bait:SetPos(self:GetPos() + ang:Up()*15 - ang:Forward()*5)
	ang:RotateAroundAxis(ang:Right(), -90)
	self.Bait:SetAngles(ang)
	self.Bait:SetParent(self)
	self.Bait:DrawShadow(false)
	self.Bait:SetNoDraw(true)
end

function ENT:Initialize()
	self.FishToDisplay = {}
end

local cw, ccw, mat = MATERIAL_CULLMODE_CW, MATERIAL_CULLMODE_CCW,
CreateMaterial("CagePotMaterial", "VertexLitGeneric", {["$translucent"] = 1, ["$surfaceprop"] = "metal", ["$basetexture"] = "Metal/metalfence007a"})
function ENT:Draw()
	if !TrueFish.CAGE_NO_FISH_MODEL then
		for k,v in pairs(self.FishToDisplay) do
			if v:IsValid() then
				v:DrawModel()
			end
		end
	end
	if self.Bait and self.Bait:IsValid() then
		self.Bait:DrawModel()
	end

	render.MaterialOverride(mat)
	render.CullMode(cw)
	self:DrawModel()
	render.CullMode(ccw)
	self:DrawModel()
	render.MaterialOverride()	
end

ENT.DrawTranslucent = ENT.Draw

function ENT:OnRemove()
	for k,v in pairs(self.FishToDisplay) do
		v:Remove()
	end
	if self.Bait and self.Bait:IsValid() then
		self.Bait:Remove()
	end
end

--PATH addons/m9k/lua/entities/hegrenade_projectile.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/entities/hegrenade_projectile.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

AddCSLuaFile()
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

function ENT:Draw()
self.Entity:DrawModel()
end

function ENT:Initialize()
if SERVER then
self.Entity:SetModel( "models/weapons/w_eq_fraggrenade_thrown.mdl" )
self.Entity:SetMoveType( MOVETYPE_VPHYSICS )
self.Entity:SetSolid( SOLID_VPHYSICS )
self.Entity:PhysicsInit( SOLID_VPHYSICS )
self.Entity:SetCollisionGroup( COLLISION_GROUP_WEAPON )
end
self.ExplodeTimer = CurTime() + 2
end

function ENT:Think()
if SERVER and self.ExplodeTimer <= CurTime() then
self.Entity:Remove()
end
end

function ENT:PhysicsCollide( data )
if SERVER and data.Speed > 150 then
self.Entity:EmitSound( "HEGrenade.Bounce" )
end
end

function ENT:OnRemove()
if SERVER then
local explode = ents.Create( "env_explosion" )
explode:SetOwner( self.Owner )
explode:SetPos( self:GetPos() )
explode:Spawn()
explode:Fire( "Explode", 0, 0 )
end
util.BlastDamage( self, self.Owner, self:GetPos(), 384, 98 )
end
--PATH addons/foodmode/lua/entities/hfm_pot/shared.lua:
ENT.Base = "base_anim"
ENT.Type = "anim"
--PATH addons/itemstore_new/lua/entities/itemstore_bank.lua:
ENT.Type = "anim"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

ENT.PrintName = "Bank"
ENT.Category = "Other"

ENT.Spawnable = true
ENT.AdminOnly = true

if SERVER then
	AddCSLuaFile()

	function ENT:Initialize()
		self:SetModel( "models/props_lab/reciever_cart.mdl" )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )

		self:GetPhysicsObject():EnableMotion( false )
	end

	function ENT:SpawnFunction( pl, trace, class )
		local ent = ents.Create( class )
		ent:SetPos( trace.HitPos + trace.HitNormal * 16 )
		ent:Spawn()

		return ent
	end

	function ENT:Use( pl )
		if not IsValid( pl ) then return end

		pl.Bank:Sync()
		pl:OpenContainer( pl.Bank:GetID(), itemstore.Translate( "bank" ) )
	end

	concommand.Add( "itemstore_savebanks", function( pl )
		if not game.SinglePlayer() and IsValid( pl ) then return end

		local banks = {}

		for _, ent in ipairs( ents.FindByClass( "itemstore_bank" ) ) do
			table.insert( banks, {
				Position = ent:GetPos(),
				Angles = ent:GetAngles()
			} )
		end

		file.Write( "itemstore/banks/" .. game.GetMap() .. ".txt", util.TableToJSON( banks ) )

		print( "Banks for map " .. game.GetMap() .. " saved." )
	end )

	hook.Add( "InitPostEntity", "ItemStoreSpawnBanks", function()
		local banks = util.JSONToTable( file.Read( "itemstore/banks/" .. game.GetMap() .. ".txt", "DATA" ) or "" ) or {}

		for _, data in ipairs( banks ) do
			local bank = ents.Create( "itemstore_bank" )
			bank:SetPos( data.Position )
			bank:SetAngles( data.Angles )
			bank:Spawn()
		end
	end )
else
	local color_white = Color(255, 255, 255)
	local color_black = Color(0, 0, 0)
	local complex_off = Vector(0, 0, 9)
	local ang = Angle(0, 90, 90)

	local cam_End3D2D, cam_Start3D2D, LocalPlayer, CurTime, draw_SimpleTextOutlined, math_sin = cam.End3D2D, cam.Start3D2D, LocalPlayer, CurTime, draw.SimpleTextOutlined, math.sin

	function ENT:Draw()
		self:DrawModel()
		pos = self:GetPos() + Vector(-4, 0, 30) + complex_off
		ang.y = (LocalPlayer():EyeAngles().y - 90)
		local x = math_sin(CurTime() * math.pi) * 30

		if (LocalPlayer():GetPos():Distance(self:GetPos()) < 200 or LocalPlayer():GetEyeTrace().Entity == self) then
			cam_Start3D2D(pos, ang, 0.05)
			draw_SimpleTextOutlined('Склад вещей', '3d2d', 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 1, color_black)
			cam_End3D2D()
		end
	end
end
--PATH addons/itemstore_new/lua/entities/itemstore_box_large.lua:
ENT.Type = "anim"
ENT.Base = "itemstore_box"

ENT.PrintName = "Large Box"
ENT.Category = "ItemStore"

ENT.Spawnable = true
ENT.AdminOnly = true

if SERVER then
	AddCSLuaFile()

	ENT.Model = "models/props/cs_office/cardboard_box01.mdl"

	ENT.ContainerWidth = 5
	ENT.ContainerHeight = 4
	ENT.ContainerPages = 1
end

--PATH addons/accessory/lua/entities/npc_accessory_vendor/cl_init.lua:
include("shared.lua")

surface.CreateFont("SH_ACC_VENDOR", {font = "Circular Std Bold", size = 200})
local offset = Vector(0, 0, 80)

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

function ENT:DrawTranslucent()
	self:DrawModel()

	local origin = self:GetPos()
	if (LocalPlayer():GetPos():Distance(origin) >= 768) then
		return end

	local pos = origin + offset
	local ang = (LocalPlayer():EyePos() - pos):Angle()
	ang.p = 0
	ang:RotateAroundAxis(ang:Right(), 90)
	ang:RotateAroundAxis(ang:Up(), 90)
	ang:RotateAroundAxis(ang:Forward(), 180)

	local text = SH_ACC.Language.accessory_vendor

	cam.Start3D2D(pos, ang, 0.04)
		surface.SetFont("SH_ACC_VENDOR")
		local wi, he = surface.GetTextSize(text)
		local pad = 16
		wi = wi + pad * 2
		he = he + pad * 2

		draw.RoundedBox(8, -wi * 0.5, -pad, wi, he, SH_ACC.Style.header)

		draw.SimpleText(text, "SH_ACC_VENDOR", 0, 0, SH_ACC.Style.text, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	cam.End3D2D()
end
--PATH addons/perma/lua/entities/pp_prop_effect.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.PrintName		= ""
ENT.Author			= ""
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
ENT.Spawnable		= false
ENT.AdminOnly		= false

--[[---------------------------------------------------------
	Name: Initialize
-----------------------------------------------------------]]
function ENT:Initialize()

	local Radius = 6
	local min = Vector( 1, 1, 1 ) * Radius * -0.5
	local max = Vector( 1, 1, 1 ) * Radius * 0.5

	if ( SERVER ) then

		self.AttachedEntity = ents.Create( "prop_dynamic" )
		self.AttachedEntity:SetModel( self:GetModel() )
		self.AttachedEntity:SetAngles( self:GetAngles() )
		self.AttachedEntity:SetPos( self:GetPos() )
		self.AttachedEntity:SetSkin( self:GetSkin() )
		self.AttachedEntity:Spawn()
		self.AttachedEntity:SetParent( self.Entity )
		self.AttachedEntity:DrawShadow( false )

		self:SetModel( "models/props_junk/watermelon01.mdl" )

		self:DeleteOnRemove( self.AttachedEntity )

		-- Don't use the model's physics - create a box instead
		self:PhysicsInitBox( min, max )

		-- Set up our physics object here
		local phys = self:GetPhysicsObject()
		if ( IsValid( phys ) ) then
			phys:Wake()
			phys:EnableGravity( false )
			phys:EnableDrag( false )
		end

		self:DrawShadow( false )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )

	else

		self.GripMaterial = Material( "sprites/grip" )

		-- Get the attached entity so that clientside functions like properties can interact with it
		local tab = ents.FindByClassAndParent( "prop_dynamic", self )
		if ( tab && IsValid( tab[ 1 ] ) ) then self.AttachedEntity = tab[ 1 ] end

	end

	-- Set collision bounds exactly
	self:SetCollisionBounds( min, max )

end


--[[---------------------------------------------------------
	Name: Draw
-----------------------------------------------------------]]
function ENT:Draw()

	render.SetMaterial( self.GripMaterial )

end


--[[---------------------------------------------------------
	Name: PhysicsUpdate
-----------------------------------------------------------]]
function ENT:PhysicsUpdate( physobj )

	if ( CLIENT ) then return end

	-- Don't do anything if the player isn't holding us
	if ( !self:IsPlayerHolding() && !self:IsConstrained() ) then

		physobj:SetVelocity( Vector( 0, 0, 0 ) )
		physobj:Sleep()

	end

end


--[[---------------------------------------------------------
	Name: Called after entity 'copy'
-----------------------------------------------------------]]
function ENT:OnEntityCopyTableFinish( tab )

	-- We need to store the model of the attached entity
	-- Not the one we have here.
	tab.Model = self.AttachedEntity:GetModel()

	-- Store the attached entity's table so we can restore it after being pasted
	tab.AttachedEntityInfo = table.Copy( duplicator.CopyEntTable( self.AttachedEntity ) )
	tab.AttachedEntityInfo.Pos = nil -- Don't even save angles and position, we are a parented entity
	tab.AttachedEntityInfo.Angle = nil

	-- Do NOT store the attached entity itself in our table!
	-- Otherwise, if we copy-paste the prop with the duplicator, its AttachedEntity value will point towards the original prop's attached entity instead, and that'll break stuff
	tab.AttachedEntity = nil

end


--[[---------------------------------------------------------
	Name: PostEntityPaste
-----------------------------------------------------------]]
function ENT:PostEntityPaste( ply )

	-- Restore the attached entity using the information we've saved
	if ( IsValid( self.AttachedEntity ) ) and ( self.AttachedEntityInfo ) then

		-- Apply skin, bodygroups, bone manipulator, etc.
		duplicator.DoGeneric( self.AttachedEntity, self.AttachedEntityInfo )

		if ( self.AttachedEntityInfo.EntityMods ) then
			self.AttachedEntity.EntityMods = table.Copy( self.AttachedEntityInfo.EntityMods )
			duplicator.ApplyEntityModifiers( ply, self.AttachedEntity )
		end

		if ( self.AttachedEntityInfo.BoneMods ) then
			self.AttachedEntity.BoneMods = table.Copy( self.AttachedEntityInfo.BoneMods )
			duplicator.ApplyBoneModifiers( ply, self.AttachedEntity )
		end

		self.AttachedEntityInfo = nil

	end

end

--PATH addons/111mod/lua/entities/trashcontainer/cl_init.lua:
include('shared.lua')


function ENT:Draw()
	self:DrawModel()
	local ang = self:GetAngles()
	ang:RotateAroundAxis(self:GetAngles():Forward(),90)
	ang:RotateAroundAxis(self:GetAngles():Up(),90)
	if LocalPlayer():GetPos():Distance(self:GetPos()) < 500 then
		cam.Start3D2D(self:GetPos() + ang:Right()* -45 + ang:Up()* 1,ang,0.1)  --Vector(-26,0,90)
			--draw.RoundedBox(0,-190,0,380,130,Color(0,0,0,200))
			draw.SimpleTextOutlined("Мусорный Контейнер", "DoorDisplayTitleFont", 0, 0,  Color(255,255,255,255), 1, 0, 1,Color(0,0,0,255) )
			if self:GetNW2Int("TCTime") <= CurTime() then
			draw.SimpleTextOutlined("Заполнено!", "DoorDisplayTitleFont", 0, 60,  Color(255,255,255,255), 1, 0, 1,Color(0,0,0,255) )
			else
			draw.SimpleTextOutlined("Заполнение...", "DoorDisplayTitleFont", 0, 60,  Color(255,255,255,255), 1, 0, 1,Color(0,0,0,255) )
		end
		cam.End3D2D()
	end
end
--PATH addons/vcmod_main_autoupdate/lua/entities/vc_npc_cardealer/shared.lua:
// Copyright © 2020 VCMod (freemmaann). All Rights Reserved. if you have any complaints or ideas contact me: steam - steamcommunity.com/id/freemmaann/ or email - freemmaann@gmail.com.

ENT.Base = "base_ai"
ENT.Type = "ai"
ENT.PrintName		= "Car dealer"
ENT.Author			= "freemmaann"
ENT.Category		= "VCMod"
ENT.Contact			= "N/A"
ENT.Purpose			= "N/A"
ENT.Instructions	= "Press E"
ENT.Spawnable		= false
ENT.AdminSpawnable		= false
ENT.AutomaticFrameAdvance = true

function ENT:SetAutomaticFrameAdvance(bUsingAnim) self.AutomaticFrameAdvance = bUsingAnim end
--PATH addons/vcmod_main_autoupdate/lua/entities/vc_npc_repair/cl_init.lua:
// Copyright © 2020 VCMod (freemmaann). All Rights Reserved. if you have any complaints or ideas contact me: steam - steamcommunity.com/id/freemmaann/ or email - freemmaann@gmail.com.

include('shared.lua')

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Initialize() end
--PATH addons/vcmod_main_autoupdate/lua/entities/vc_pickup_fuel_petrol/cl_init.lua:
// Copyright © 2020 VCMod (freemmaann). All Rights Reserved. if you have any complaints or ideas contact me: steam - steamcommunity.com/id/freemmaann/ or email - freemmaann@gmail.com.

include('shared.lua')

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Initialize() self.VC_Color = Color(0,255,255,255) self.VC_Length = 142 self.VC_Text = "Vehicle Fuel 10%" self.VC_PVsb = util.GetPixelVisibleHandle() end
--PATH addons/vcmod_main_autoupdate/lua/entities/vc_pickup_healthkit_100/shared.lua:
// Copyright © 2020 VCMod (freemmaann). All Rights Reserved. if you have any complaints or ideas contact me: steam - steamcommunity.com/id/freemmaann/ or email - freemmaann@gmail.com.
ENT.Base 		= "base_anim"
ENT.Type 		= "anim"
ENT.PrintName	= "Repair kit 100%"
ENT.Author		= "freemmaann"
ENT.Category	= "VCMod"

ENT.Spawnable = true
ENT.AdminSpawnable = true

--PATH addons/vcmod_main_autoupdate/lua/entities/vc_pickup_tire/cl_init.lua:
// Copyright © 2020 VCMod (freemmaann). All Rights Reserved. if you have any complaints or ideas contact me: steam - steamcommunity.com/id/freemmaann/ or email - freemmaann@gmail.com.

include('shared.lua')

ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Initialize() self.VC_Color = Color(255,100,65,255) self.VC_Text = "Vehicle part" self.VC_PVsb = util.GetPixelVisibleHandle() end
--PATH addons/zeros_methlab2/lua/entities/zmlab2_item_autobreaker/cl_init.lua:
include("shared.lua")

function ENT:Initialize()

end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Draw()
	self:DrawModel()
end
--PATH addons/zeros_methlab2/lua/entities/zmlab2_item_lox/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_lox.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Liquid Oxygen"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE


function ENT:CanProperty(ply)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanDrive(ply)
    return zmlab2.Player.IsAdmin(ply)
end

--PATH addons/zeros_methlab2/lua/entities/zmlab2_item_methylamine/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_methylamine.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Methylamine"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE

function ENT:CanProperty(ply)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanDrive(ply)
    return zmlab2.Player.IsAdmin(ply)
end

--PATH addons/zeros_methlab2/lua/entities/zmlab2_machine_filler/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_filler.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Filler"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE


function ENT:SetupDataTables()

    // Corresponds to a ID from the MethTypes config (normal meth, blue meth)
    self:NetworkVar("Int", 1, "MethType")
    self:NetworkVar("Int", 2, "MethAmount")
    self:NetworkVar("Int", 3, "MethQuality")

    self:NetworkVar("Int", 4, "ProcessState")

    self:NetworkVar("Entity", 1, "Tray")


    if (SERVER) then
        self:SetMethType(1)
        self:SetProcessState(0)
        self:SetMethAmount(0)
        self:SetMethQuality(1)
        self:SetTray(NULL)
    end
end

function ENT:OnPumpButton(ply)
    local trace = ply:GetEyeTrace()
    local lp = self:WorldToLocal(trace.HitPos)

    if lp.x > -8 and lp.x < 0 and lp.y < 15 and lp.y > 10 and lp.z > 26 and lp.z < 31 then
        return true
    else
        return false
    end
end

// Tell us if you allow to receive liquid
function ENT:AllowConnection(From_ent)
    if From_ent:GetClass() == "zmlab2_machine_filter" and From_ent:GetProcessState() == 4 and self:GetProcessState() == 0 then
        return true
    else
        return false
    end
end

// Returns the start position and direction for a hose
function ENT:GetHose_In()
    local attach = self:GetAttachment(1)
    local ang = attach.Ang
    ang:RotateAroundAxis(ang:Right(),180)
    return attach.Pos,ang
end


function ENT:CanProperty(ply)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanDrive(ply)
    return zmlab2.Player.IsAdmin(ply)
end

--PATH addons/zeros_methlab2/lua/entities/zmlab2_machine_mixer/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	zmlab2.Mixer.Initialize(self)
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Draw()
	self:DrawModel()
	zmlab2.Mixer.Draw(self)
end

function ENT:Think()
	zmlab2.Mixer.Think(self)
end

function ENT:OnRemove()
	zmlab2.Mixer.OnRemove(self)
end

--PATH addons/zeros_weedfarm/lua/entities/zwf_bong_ent/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	zwf.f.EntList_Add(self)

	self.Last_WeedID = -1

	self.Last_IsBurning = false

	self.IsInitialized = false

	timer.Simple(0.1,function()
		if IsValid(self) then
			self.IsInitialized = true
		end
	end)
end

function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Think()
	if self.IsInitialized == false then return end

	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 500) then

		local _WeedID = self:GetWeedID()
		if self.Last_WeedID ~= _WeedID then
			self.Last_WeedID = _WeedID

			if self.Last_WeedID ~= -1 then

				self:SetBodygroup(2,1)
				self:SetSkin(zwf.config.Plants[self.Last_WeedID].skin)
			else

				self:SetBodygroup(2,0)
			end
		end


		local _IsBurning = self:GetIsBurning()
		if self.Last_IsBurning ~= _IsBurning then
			self.Last_IsBurning = _IsBurning

			if self.Last_IsBurning then
				self:SetSkin(7)
				zwf.f.ParticleEffectAttach("zwf_ent_fire", PATTACH_POINT_FOLLOW, self, 1)
			else
				self:StopParticles()
			end
		end
	else
		self.Last_WeedID = -1

		if self.Last_IsBurning == true then
			self.Last_IsBurning = false
			self:StopParticles()
		end
	end

end

--PATH addons/zeros_weedfarm/lua/entities/zwf_doobytable/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	zwf.f.EntList_Add(self)

	self.DoobyProgress = false
	self.LastWeedAmount = -1
end

function ENT:Draw()
	self:DrawModel()

	if GetConVar("zwf_cl_vfx_drawui"):GetInt() == 1 and zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 200) then
		self:DrawScreenUI()
	end
end

function ENT:Draw_GrinderButton()
	if self:OnGrinder(LocalPlayer()) then
		draw.SimpleText("[E]", "zwf_doobytable_font01", 170, 40, zwf.default_colors["orange01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	else
		draw.SimpleText("[E]", "zwf_doobytable_font01", 170, 40, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
end

function ENT:Draw_StartButton()
	if self:OnStartButton(LocalPlayer()) then
		draw.SimpleText(zwf.language.General["generator_start"], "zwf_doobytable_font02", -170, 55, zwf.default_colors["orange01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	else
		draw.SimpleText(zwf.language.General["generator_start"], "zwf_doobytable_font02", -170, 55, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
end

function ENT:Draw_RemoveWeedButton()
	if self:OnRemoveButton(LocalPlayer()) then
		draw.SimpleText(zwf.language.General["Remove"], "zwf_doobytable_font02", -170, 25, zwf.default_colors["orange01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	else
		draw.SimpleText(zwf.language.General["Remove"], "zwf_doobytable_font02", -170, 25, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
end

function ENT:Draw_PaperButton()
	if self:OnPaper(LocalPlayer()) then
		//draw.RoundedBox(5, -190 , 35, 380, 40,  zwf.default_colors["gray01"])
		draw.SimpleText("[E]", "zwf_doobytable_font01", 0, -30, zwf.default_colors["orange01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	else
		//draw.RoundedBox(5, -190 , 35, 380, 40,  zwf.default_colors["white01"])
		draw.SimpleText("[E]", "zwf_doobytable_font01", 0, -30, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
end

function ENT:DrawScreenUI()


	//debugoverlay.Sphere( self:LocalToWorld(Vector(-7, math.random(-12,12), 5)), 1,  0.1,Color( 255, 255, 255 ), false )
	if self.LastWeedAmount > 0 then
		cam.Start3D2D(self:LocalToWorld(Vector(2, 17, 17)), Angle(0, EyeAngles().y - 90, -EyeAngles().x + 90), 0.1)
			draw.SimpleText(self:GetWeedName(), "zwf_doobytable_font02", 0, 0, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			draw.SimpleText(math.Round(self.LastWeedAmount) .. zwf.config.UoW, "zwf_doobytable_font02", 0, 25, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		cam.End3D2D()
	end

	cam.Start3D2D(self:LocalToWorld(Vector(0, 0, 6)), self:LocalToWorldAngles(Angle(0, -90, 0)), 0.1)

		if self.DoobyProgress == 0 and self:GetWeedAmount() >= zwf.config.DoobyTable.WeedPerJoint then

			self:Draw_StartButton()

			self:Draw_RemoveWeedButton()

		elseif self.DoobyProgress >= 1 and self.DoobyProgress < 5 then

			self:Draw_GrinderButton()

		elseif self.DoobyProgress == 5 then

			self:Draw_PaperButton()

		elseif self.DoobyProgress == 6 then

			self:Draw_GrinderButton()
		end
	cam.End3D2D()

	if self.DoobyProgress >= 7 and self.DoobyProgress < 11 then

		local pos = self:GetGamePos()

		cam.Start3D2D(self:LocalToWorld(Vector(pos.x, pos.y, 6)), self:LocalToWorldAngles(Angle(0, -90, 0)), 0.1)

			//debugoverlay.Sphere( self:LocalToWorld(pos), 1,  0.1,Color( 255, 255, 255 ), false )

			if self:OnHitButton(LocalPlayer()) then
				draw.SimpleText("[E]", "zwf_doobytable_font01", 0, -10, zwf.default_colors["orange01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			else
				draw.SimpleText("[E]", "zwf_doobytable_font01", 0, -10, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			end

		cam.End3D2D()
	end
end


function ENT:Think()

	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 1000) then

		// Update Weed Amount and Skin
		local _weedamount = self:GetWeedAmount()
		if self.LastWeedAmount ~= _weedamount then
			self.LastWeedAmount = _weedamount

			local _weedID = self:GetWeedID()
			if _weedID ~= -1 then

				local plantData = zwf.config.Plants[_weedID]
				self:SetSkin(plantData.skin)
			end

			local fraction = zwf.config.DoobyTable.Capacity / 3

			if _weedamount <= 0 then

				// No Weed
				self:SetBodygroup(5,0)
			elseif _weedamount < fraction then

				// Less Weed
				self:SetBodygroup(5,1)
			elseif _weedamount < fraction * 2 then

				// Half Weed
				self:SetBodygroup(5,2)
			elseif _weedamount > fraction * 2 then

				// Full Weed
				self:SetBodygroup(5,3)
			end
		end

		local _progress = self:GetDoobyProgress()
		if self.DoobyProgress ~= _progress then
			self.DoobyProgress = _progress



			if self.DoobyProgress == 0 then

				// Disable Dooby
				self:SetBodygroup(3,0)

				// Paper Close
				self:SetBodygroup(2,0)
				zwf.f.EmitSoundENT("zwf_paper_close", self)

				// Grinder Close
				self:SetBodygroup(1,0)
				zwf.f.EmitSoundENT("zwf_grinder_close", self)

			elseif self.DoobyProgress == 1 then

				// Grinder Open
				self:SetBodygroup(1,1)
				zwf.f.EmitSoundENT("zwf_grinder_open", self)

				// WeedJunk On
				self:SetBodygroup(6,1)
				zwf.f.EmitSoundENT("zwf_grab_weed", self)

			elseif self.DoobyProgress >= 1 and  self.DoobyProgress < 5 then

				// Play Grind Animation
				zwf.f.ClientAnim(self, "grind", 2)

				// Grinder Close
				if self:GetBodygroup(1) == 1 then
					self:SetBodygroup(1,0)
					zwf.f.EmitSoundENT("zwf_grinder_close", self)
				end

				// WeedJunk Off
				self:SetBodygroup(6,0)
				zwf.f.EmitSoundENT("zwf_grinder_grind", self)

			elseif self.DoobyProgress == 5 then

				// Grinded Weed On
				self:SetBodygroup(6,2)

				// Grinder Open
				self:SetBodygroup(1,1)
				zwf.f.EmitSoundENT("zwf_grinder_open", self)

			elseif self.DoobyProgress == 6 then

				// Paper Open
				self:SetBodygroup(2,1)
				zwf.f.EmitSoundENT("zwf_paper_open", self)

				// Paper Placed
				self:SetBodygroup(0,1)
				zwf.f.EmitSoundENT("zwf_grab_paper", self)

			elseif self.DoobyProgress == 7 then

				// Grinded Weed Off
				self:SetBodygroup(6,0)

				// Added Weed On Paper
				self:SetBodygroup(0,2)
				zwf.f.EmitSoundENT("zwf_grab_weed", self)

			elseif self.DoobyProgress == 8 then

				// Roll Stage 01
				self:SetBodygroup(0,3)
				zwf.f.EmitSoundENT("zwf_joint_foldstage", self)

			elseif self.DoobyProgress == 9 then

				// Roll Stage 02
				self:SetBodygroup(0,4)
				zwf.f.EmitSoundENT("zwf_joint_foldstage", self)

			elseif self.DoobyProgress == 10 then

				// Roll Stage 03
				self:SetBodygroup(0,5)
				zwf.f.EmitSoundENT("zwf_joint_foldstage", self)

			elseif self.DoobyProgress == 11 then

				// Remove Roll Stage
				self:SetBodygroup(0,0)

				// Enable Finished Dooby
				self:SetBodygroup(3,1)

				// Play Grind Animation
				zwf.f.ClientAnim(self, "roll", 2)
				zwf.f.EmitSoundENT("zwf_joint_fold_finish", self)
			end
		end

	else
		self.DoobyProgress = -1
	end

	self:SetNextClientThink(CurTime())
	return true
end



function ENT:OnRemove()
end

--PATH addons/zeros_weedfarm/lua/entities/zwf_mixer/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	zwf.f.EntList_Add(self)

	self.LastWorkState = -1
	self.MixStart = -1
	self.DoughState = -1
end

function ENT:Draw()
	self:DrawModel()

	zwf.f.UpdateEntityVisuals(self)

	if GetConVar("zwf_cl_vfx_drawui"):GetInt() == 1 and zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 200) then
		self:DrawScreenUI()
	end
end

function ENT:DrawScreenUI()
	if self:GetHasBowl() then

		if self:GetHasDough() and self.MixStart ~= -1 then
			cam.Start3D2D(self:LocalToWorld(Vector(-2, 6, 25)), self:LocalToWorldAngles(Angle(0, 180, 90)), 0.1)

				draw.RoundedBox(5, -170, -55, 180, 20, zwf.default_colors["gray02"])
				local width = (180 / zwf.config.Cooking.mix_duration) * (CurTime() - self.MixStart)
				draw.RoundedBox(5, -170, -55, width, 20, zwf.default_colors["green04"])

			cam.End3D2D()
		end

		if self:GetHasDough() == false then
			cam.Start3D2D(self:LocalToWorld(Vector(-5, 12, 25)), self:LocalToWorldAngles(Angle(0, 180, 90)), 0.1)
				self:Draw_RemoveButton()
			cam.End3D2D()
		end
	end
end

function ENT:Draw_RemoveButton()
	if self:OnRemoveButton(LocalPlayer()) then
		draw.SimpleText(zwf.language.General["Remove"], "zwf_mixer_font02", -10, 75, zwf.default_colors["orange01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	else
		draw.SimpleText(zwf.language.General["Remove"], "zwf_mixer_font02", -10, 75, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
	end
end



function ENT:Think()

	zwf.f.LoopedSound(self, "zwf_mixer_loop", self.LastWorkState == 3)

	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 1000) then

		local _workstate = self:GetWorkState()
		local _weedid = self:GetWeedID()

		if self.LastWorkState ~= _workstate then
			self.LastWorkState = _workstate

			if _workstate == 0 then

				// Play idle Animation
				zwf.f.ClientAnim(self, "idle", 1)

			elseif _workstate == 1 then

				// Play open Animation
				zwf.f.ClientAnim(self, "open", 1)
				zwf.f.EmitSoundENT("zwf_mixer_open", self)

			elseif _workstate == 2 then

				// Play close Animation
				zwf.f.ClientAnim(self, "close", 1)
				zwf.f.EmitSoundENT("zwf_mixer_close", self)

			elseif _workstate == 3 then

				// Play run Animation
				zwf.f.ClientAnim(self, "run", 1)
			end

			if _workstate == 3 then
				if self.MixStart == -1 then
					self.MixStart = CurTime()
				end
				self.DoughState = 0

			else
				self.MixStart = -1
				self.DoughState = -1
				self:SetColor(zwf.default_colors["white01"])
			end
		end


		if self.MixStart ~= -1 then

			local mixtime = (CurTime() - self.MixStart)

			if mixtime >= zwf.config.Cooking.mix_duration * 0.8 and self.DoughState == 2 then
				self.DoughState = 3

				if _weedid ~= -1 then
					// Update dough color
					self:SetColor(zwf.f.LerpColor((1 / zwf.config.Cooking.mix_duration) * mixtime, zwf.default_colors["white01"], zwf.config.Plants[_weedid].color))
				end

			elseif mixtime >= zwf.config.Cooking.mix_duration * 0.5 and self.DoughState == 1 then
				self.DoughState = 2

				if _weedid ~= -1 then
					// Update dough color
					self:SetColor(zwf.f.LerpColor((1 / zwf.config.Cooking.mix_duration) * mixtime, zwf.default_colors["white01"], zwf.config.Plants[_weedid].color))
				end

			elseif mixtime >= zwf.config.Cooking.mix_duration * 0.2 and self.DoughState == 0 then
				self.DoughState = 1

				if _weedid ~= -1 then

					// Disable weed
					self:SetBodygroup(2,0)

					// Update dough color
					self:SetColor(zwf.f.LerpColor((1 / zwf.config.Cooking.mix_duration) * mixtime, zwf.default_colors["white01"], zwf.config.Plants[_weedid].color))
				end
			end
		end
	else
		self.LastWorkState = -1
	end

	self:SetNextClientThink(CurTime())
	return true
end

function ENT:UpdateVisuals()
	local _workstate = self:GetWorkState()

	if _workstate == 0 then

		// Play idle Animation
		zwf.f.ClientAnim(self, "idle", 5)

	elseif _workstate == 1 then

		// Play open Animation
		zwf.f.ClientAnim(self, "open", 5)

	elseif _workstate == 2 then

		// Play close Animation
		zwf.f.ClientAnim(self, "close", 5)

	elseif _workstate == 3 then

		// Play run Animation
		zwf.f.ClientAnim(self, "run", 1)
	end
end

function ENT:OnRemove()
	self:StopSound("zwf_mixer_loop")
end

--PATH addons/zeros_weedfarm/lua/entities/zwf_weedblock/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	zwf.f.EntList_Add(self)
	self.PlantData = nil

	self.IsInitialized = false

	timer.Simple(0.1,function()
		if IsValid(self) then
			self.IsInitialized = true
		end
	end)
end

function ENT:Draw()
	self:DrawModel()

	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) then
		self:DrawInfo()
	end
end

function ENT:DrawTranslucent()
	self:Draw()
end


function ENT:DrawInfo()

	if zwf.config.NPC.SellMode == 2 then

		cam.Start3D2D(self:LocalToWorld(Vector(0, 0, 5.1)), self:LocalToWorldAngles(Angle(0, 90,0)), 0.05)

			if self:CollectButton(LocalPlayer()) then
				draw.RoundedBox(15, -200, -75, 400, 150, zwf.default_colors["orange01"])
			else
				draw.RoundedBox(15, -200, -75, 400, 150, zwf.default_colors["black03"])
			end

			draw.SimpleText(zwf.language.General["Collect"], "zwf_weedblock_font01", 0, -50, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

		cam.End3D2D()
	end

	if self.PlantData ~= nil and self.PlantData ~= -1  then
		cam.Start3D2D(/*self:LocalToWorld(Vector(0, 0, 20))*/  self:GetPos() + Vector(0, 0, 20), Angle(0, EyeAngles().y - 90, -EyeAngles().x + 90), 0.05)

			if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 150) then
				draw.RoundedBox(15, -200, -15, 400, 240, zwf.default_colors["black03"])
				draw.SimpleText(self:GetWeedName(), "zwf_weedblock_font01", 0, -115, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)

				surface.SetDrawColor(zwf.default_colors["white01"])
				surface.SetMaterial(zwf.default_materials["icon_mass"])
				surface.DrawTexturedRect(-150, 10, 100, 100)

				surface.SetDrawColor(zwf.default_colors["white01"])
				surface.SetMaterial(zwf.default_materials["icon_thc"])
				surface.DrawTexturedRect(45, 10, 100, 100)

				draw.SimpleText( math.Round(self:GetWeedAmount()) .. zwf.config.UoW, "zwf_weedblock_font02", -100, 135, zwf.default_colors["green06"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
				draw.SimpleText(math.Round(self:GetTHC(), 2) .. "%", "zwf_weedblock_font02", 100, 135, zwf.default_colors["green06"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			else
				draw.SimpleText(self:GetWeedName(), "zwf_weedblock_font01", 0, 0, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			end

		cam.End3D2D()
	end
end

function ENT:Think()
	if self.IsInitialized == nil or self.IsInitialized == false then return end

	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) then
		if self.PlantData == nil or self.PlantData == -1 then
			self.PlantData = zwf.config.Plants[self:GetWeedID()]
			self:SetSkin(self.PlantData.skin)
		end
	else
		self.PlantData = -1
	end
end

--PATH addons/enc_scripts/lua/es/_vgui/cl_fonts.lua:
do // screen scale function
    local mathRound = math.Round
    local scrH = ScrH() // cache

    hook.Add('OnScreenSizeChanged', 'ES:SizeChanged', function()
        scrH = ScrH()
    end)

    function ES.ScreenScale(px)
        return mathRound(px * (scrH / 1080)) // it's adequate function yeaaaa
    end
end

local createFont = surface.CreateFont

createFont('MB_16', {
    font = 'Montserrat Bold',
    size = ES.ScreenScale(18),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MB_18', {
    font = 'Montserrat Bold',
    size = ES.ScreenScale(20),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MM_18', {
    font = 'Montserrat Medium',
    size = ES.ScreenScale(20),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MM_16', {
    font = 'Montserrat Medium',
    size = ES.ScreenScale(18),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MM_20', {
    font = 'Montserrat Medium',
    size = ES.ScreenScale(22),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MM_14', {
    font = 'Montserrat Medium',
    size = ES.ScreenScale(16),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MB_24', {
    font = 'Montserrat Bold',
    size = ES.ScreenScale(26),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MM_14', {
    font = 'Montserrat Medium',
    size = ES.ScreenScale(16),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MSB_16', {
    font = 'Montserrat Bold',
    size = ES.ScreenScale(18),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MSB_20', {
    font = 'Montserrat Bold',
    size = ES.ScreenScale(22),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MSB_12', {
    font = 'Montserrat Bold',
    size = ES.ScreenScale(14),
    weight = 500,
    extended = true,
    antialias = true,
})

createFont('MSB_10', {
    font = 'Montserrat Bold',
    size = ES.ScreenScale(12),
    weight = 500,
    extended = true,
    antialias = true,
})
--PATH addons/enc_scripts/lua/es/_vgui/cl_init.lua:
do // pasting pdash))))
    local setFont = surface.SetFont
    local getTextSize = surface.GetTextSize
    local explode = string.Explode

    function ES.Wrap(font, text, width)
        setFont(font)
            
        local sw = getTextSize(' ')
        local ret = {}
            
        local w = 0
        local s = ''

        local t = explode('\n', text)
        for i = 1, #t do
            local t2 = explode(' ', t[i], false)
            for i2 = 1, #t2 do
                local neww = getTextSize(t2[i2])
                    
                if (w + neww >= width) then
                    ret[#ret + 1] = s
                    w = neww + sw
                    s = t2[i2] .. ' '
                else
                    s = s .. t2[i2] .. ' '
                    w = w + neww + sw
                end
            end
            ret[#ret + 1] = s
            w = 0
            s = ''
        end
            
        if (s ~= '') then
            ret[#ret + 1] = s
        end

        return ret
    end
end

do
    local SetStencilWriteMask = render.SetStencilWriteMask
    local SetStencilTestMask = render.SetStencilTestMask
    local SetStencilReferenceValue = render.SetStencilReferenceValue
    local SetStencilPassOperation = render.SetStencilPassOperation
    local SetStencilZFailOperation = render.SetStencilZFailOperation
    local ClearStencil = render.ClearStencil
    local SetStencilEnable = render.SetStencilEnable
    local SetStencilReferenceValue = render.SetStencilReferenceValue
    local SetStencilCompareFunction = render.SetStencilCompareFunction
    local SetStencilFailOperation = render.SetStencilFailOperation

    local max = 0xFF
    local STENCIL_KEEP = STENCIL_KEEP
    local STENCIL_REPLACE = STENCIL_REPLACE
    local STENCIL_NEVER = STENCIL_NEVER

    function ES.MaskFn(funcMask, funcDraw)
        SetStencilWriteMask(max)
        SetStencilTestMask(max)
        SetStencilReferenceValue(0)
        SetStencilPassOperation(STENCIL_KEEP)
        SetStencilZFailOperation(STENCIL_KEEP)
        ClearStencil()

        SetStencilEnable(true)
        SetStencilReferenceValue(1)
        SetStencilCompareFunction(STENCIL_NEVER)
        SetStencilFailOperation(STENCIL_REPLACE)

            funcMask()

        SetStencilCompareFunction(STENCIL_EQUAL)
        SetStencilFailOperation(STENCIL_KEEP)

            funcDraw()

        SetStencilEnable(false)
    end
end

do
    local noTexture = draw.NoTexture
    local setDrawColor = surface.SetDrawColor
    local drawPoly = surface.DrawPoly

    function ES.DrawWithPolyMask(polyMask, funcDraw)
        if (not polyMask) then return end
    
        noTexture()
        setDrawColor(color_white)
        ES.MaskFn(function()
            drawPoly(polyMask)
        end, function()
            funcDraw()
        end)
    end
end

do
    local colorGray = Color(200, 200, 200)
    local colorRed = Color(251, 158, 158)
    local colorBlue = Color(158, 218, 251)
    local colorGold = Color(255, 233, 106)
    local cache = {}

    local function addNotification(title, icon, length, lines)
        table.insert(cache, {
            title = title,
            material = Material(icon, 'smooth mips'),
            length = length,
            start = CurTime(),
            lines = lines
        })
    end
    ES.AddNotification = addNotification

    local colorBG = Color(38, 38, 38)
    hook.Add('HUDPaint', 'ES:BigNotifications:HUDPaint', function()
        local amount = #cache

        local scrw, scrh = ScrW(), ScrH()

        local X = scrw * 0.709 
        local Y =scrh * 0.91

        local padding = ES.ScreenScale(10)
        local nextColor

        local iconSize = ES.ScreenScale(32)
        local iconMargin = ES.ScreenScale(15)

        local maxWidth = iconSize + iconMargin + padding * 2
        local lineHeight = ES.ScreenScale(22)

        for index, data in ipairs(cache) do
            local lines = data.lines
            local linesAmount = #lines

            local delta = CurTime() - data.start
            local fraction = (1 - math.Clamp(delta / data.length, 0, 1))
            local target = (fraction > 0 and 1 or 0)

            data.alpha = math.Approach((data.alpha or 0), target, FrameTime() * 3)

            if (data.alpha == 0 and target == 0) then
                table.remove(cache, index)
                return 
            end

            surface.SetAlphaMultiplier(data.alpha)

            surface.SetFont('MSB_20')
            local maxTextWidth = surface.GetTextSize(data.title)
        
            for i = 1, linesAmount do
                local lineParts = lines[i]
                local lineText = ''
                for _, part in ipairs(lineParts) do
                    if (isstring(part)) then
                        lineText = lineText .. part
                    end
                end

                surface.SetFont('MM_20')
                local lineTextWidth = surface.GetTextSize(lineText)
                
                maxTextWidth = math.max(maxTextWidth, lineTextWidth)
            end

            local x = X
            local y = Y

            local w = maxWidth + maxTextWidth
            local h = padding * 2 + ES.ScreenScale(30) + (linesAmount * lineHeight) + ES.ScreenScale(10)

            draw.RoundedBox(8, x, y, w, h, colorBG)

            ES.DrawMaterial(data.material, x + padding, y + h * .5 - iconSize * .5, iconSize, iconSize)

            local textStaticX = x + padding + iconSize + iconMargin

            local _, textH = draw.SimpleText(data.title, 'MSB_20', textStaticX, y + padding, color_white, 0, 0)

            y = y + textH
            
            for _, parts in ipairs(lines) do
                local textX = textStaticX

                for _, part in ipairs(parts) do
                    if (isstring(part)) then
                        textX = textX + select(1, draw.SimpleText(part, 'MM_20', textX, y + padding, nextColor))
                    else
                        nextColor = part
                    end
                end

                y = y + lineHeight
            end

            surface.SetDrawColor(25, 25, 25)
            surface.DrawRect(textStaticX, y + padding + ES.ScreenScale(10), maxTextWidth, 2)
            surface.SetDrawColor(0, 117, 223)
            surface.DrawRect(textStaticX, y + padding + ES.ScreenScale(10), maxTextWidth * fraction, 2)

            Y = Y + h + ES.ScreenScale(5)

            surface.SetAlphaMultiplier(1)
        end
    end)
end

do
    local setDrawColor = surface.SetDrawColor
    local setMaterial = surface.SetMaterial
    local drawTexturedRect = surface.DrawTexturedRect

    function ES.DrawMaterial(mat, x, y, w, h, color)
        setDrawColor(color or color_white)
        setMaterial(mat)
        drawTexturedRect(x, y, w, h)
    end
end

do
    local mrad = math.rad
    local sin = math.sin
    local cos = math.cos

    function ES.CalculateCircle(x0, y0, ang, p, rad, seg)
        seg = seg or 80
        ang = (-ang) + 180

        local circle = {}

        for i = 0, seg do
            local a = mrad((i / seg) * -p + ang)
            local x = x0 + sin(a) * rad
            local y = y0 + cos(a) * rad
            circle[i + 1] = {
                x = x,
                y = y
            }
        end

        return circle
    end
end

do
    spoly.Generate('_circle', function(w, h)
        local x0, y0 = w * .5, h * .5
        local radius = h * .5
        local circle = Circles.New(CIRCLE_FILLED, radius, x0, y0)

        circle()
    end)

    --[[------------------------------
    Sizes: 1-8, 10, 12, 14, 16
    --------------------------------]]
    local id = 'onyx_circle_outline_line_'
    local THICKNESS = {
        10, 12, 13, 14, 15, 16
    }

    for thickness = 1, 8 do
        local scaledThickness = thickness * 8
        spoly.Generate(id .. thickness, function(w, h)
            local x0, y0 = w * .5, h * .5
            local radius = h * .5
            local circle = Circles.New(CIRCLE_OUTLINED, radius, x0, y0, scaledThickness)

            circle()
        end)
    end

    for _, thickness in ipairs(THICKNESS) do
        local scaledThickness = thickness * 8
        spoly.Generate(id .. thickness, function(w, h)
            local x0, y0 = w * .5, h * .5
            local radius = h * .5
            local circle = Circles.New(CIRCLE_OUTLINED, radius, x0, y0, scaledThickness)

            circle()
        end)
    end

    function ES.DrawCircle(x, y, w, h, color)
        spoly.Draw('_circle', x, y, w, h, color)
    end

    function ES.DrawCircleOutlined(x, y, w, h, thickness, color)
        spoly.Draw(id .. thickness, x, y, w, h, color)
    end
end

-- concommand.Add("test_notification", function()
--     local title = "Тестовое уведомление"
--     local icon = "hud/check1.png"
--     local length = 60
--     local lines = {
--         {Color(200, 200, 200), "Это тестовая строка 1"}
--     }

--     ES.AddNotification(title, icon, length, lines)
-- end)

--PATH addons/itemstore_new/lua/itemstore/items.lua:
﻿itemstore.items = {}
itemstore.items.Registered = {}
itemstore.items.Pickups = {}
local Item = {}
Item.ItemStore = true
Item.Name = "Invalid Item"
--Item.Description = "Invalid Description"
Item.Model = "models/error.mdl"
--Item.Skin = 0
--Item.Color = nil
--Item.Material = nil
Item.HighlightColor = itemstore.config.HighlightColours.Other
Item.Stackable = false
Item.Amount = 1
Item.MaxStack = itemstore.config.MaxStack
Item.DropStack = false
Item.DontNetwork = {}

function Item:GetClass()
    return self.Class
end

function Item:IsValid()
    return true
end

function Item:Run(func_name, ...)
    local func = self[func_name]
    if type(func) ~= "function" then return end

    return func(self, ...)
end

function Item:Load()
end

function Item:Initialize()
end

function Item:GetContainer()
    local con = self.Container
    if not con then return end
    local slot = self.Slot
    if not slot then return end
    if con:GetItem(slot) == self then return self.Container end
end

function Item:GetSlot()
    local con = self.Container
    if not con then return end
    local slot = self.Slot
    if not slot then return end
    if con:GetItem(slot) == self then return self.Slot end
end

function Item:Copy()
    return itemstore.Item(self:GetClass(), table.Copy(self.Data))
end

function Item:RegisterPickup(ent_class)
    itemstore.items.Pickups[ent_class] = self:GetClass()
end

function Item:GetData(key, default)
    return self.Data[key] == nil and default or self.Data[key]
end

function Item:SetData(key, value)
    self.Data[key] = value
end

function Item:CreateMutator(key, default)
    self["Set" .. key] = function(self, value)
        self:SetData(key, value)
    end

    self["Get" .. key] = function(self, default) return self:GetData(key, default or self[key]) end
end

Item:CreateMutator("Name")
Item:CreateMutator("Description")
Item:CreateMutator("Model")
Item:CreateMutator("Material")
Item:CreateMutator("Skin")
Item:CreateMutator("Color")
Item:CreateMutator("MaxStack")
Item:CreateMutator("Amount")

function Item:GetStaticName()
    return self.StaticName or self.Name
end

function Item:Pickup(pl, con, slot, ent)
end

function Item:Drop(pl, con, slot, ent)
end

function Item:Destroy(pl, con, slot)
end

function Item:TakeOne()
    self:SetAmount(self:GetAmount() - 1)
    if self:GetAmount() <= 0 then return true end

    return false
end

function Item:CanPickup()
    return true
end

function Item:CanUseWith(item)
    return false
end

function Item:CanMerge(item)
    return self.Stackable and item.Stackable and self:GetClass() == item:GetClass() and (self:GetAmount() + item:GetAmount()) <= self:GetMaxStack()
end

function Item:Merge(item)
    self:SetAmount(self:GetAmount() + item:GetAmount())
end

function Item:CanSplit(amount)
    return self.Stackable and self:GetAmount() > amount
end

function Item:Split(amount)
    self:SetAmount(self:GetAmount() - amount)
    local item = self:Copy()
    item:SetAmount(amount)

    return item
end

function Item:FormatAmount()
    return "x" .. self:GetAmount()
end

function Item:CreateEntity(pos)
    local ent = ents.Create("itemstore_item")
    ent:SetPos(pos)
    self:LoadData(ent)
    ent:Spawn()

    return ent
end

function Item:SaveData(ent)
end

function Item:LoadData(ent)
    ent:SetItem(self)
end

function Item:WriteNetworkData()
    local data = {}

    for k, v in pairs(self.Data) do
        if not self.DontNetwork[k] then
            data[k] = v
        end
    end

    net.WriteUInt(table.Count(data), 8)

    for k, v in pairs(data) do
        net.WriteString(k)
        net.WriteType(v)
    end
end

function Item:ReadNetworkData()
    for i = 1, net.ReadUInt(8) do
        self:SetData(net.ReadString(), net.ReadType())
    end
end

function Item:PreRender(ent)
end

function Item:PostRender(ent)
end

function itemstore.Item(class_name, data)
    local class = itemstore.items.Registered[class_name]

    if class then
        local item = {
            Class = class_name,
            Data = data or {}
        }

        setmetatable(item, {
            __index = class
        })

        item:Initialize()

        return item
    end
end

function itemstore.items.Get(class)
    return itemstore.items.Registered[class]
end

function itemstore.items.Exists(class)
    return itemstore.items.Registered[class] ~= nil
end

function itemstore.items.Register(tab)
    if SERVER then
        util.AddNetworkString(tab.Class)
    end

    itemstore.items.Registered[tab.Class] = tab
end

function itemstore.items.Load()
    for _, filename in ipairs(file.Find("itemstore/items/*.lua", "LUA")) do
        local name = string.match(filename, "^(.+).lua$")

        if name then
            ITEM = setmetatable({}, {
                __index = Item
            })

            ITEM.Class = name

            if SERVER then
                AddCSLuaFile("itemstore/items/" .. filename)
            end

            include("itemstore/items/" .. filename)
            itemstore.items.Register(ITEM)
            ITEM = nil
        end
    end

    for k, v in pairs(itemstore.config.CustomItems) do
        local ITEM = setmetatable({}, {
            __index = Item
        })

        ITEM.Class = k
        ITEM.Name = v[1]
        ITEM.Description = v[2]
        ITEM.Stackable = v[3]
        ITEM.Base = "base_auto"
        itemstore.items.Register(ITEM)
    end

    for _, item in pairs(itemstore.items.Registered) do
        if item.Base then
            local base = itemstore.items.Get(item.Base)

            if base then
                if base == item then
                    ErrorNoHalt("[ItemStore] " .. item.Class .. " tried to derive from itself.")
                else
                    setmetatable(item, {
                        __index = base
                    })
                end
            else
                ErrorNoHalt("[ItemStore] " .. item.Class .. " tried to derive from non-existent base " .. item.Base)
            end
        end
    end

    for _, item in pairs(itemstore.items.Registered) do
        item:Load()
    end
end

itemstore.items.Load()
--PATH addons/foodmode/lua/itemstore/items/base_food.lua:
ITEM.Name = "Еда"
ITEM.Description = "Nom Nom Bitch"
ITEM.Model = "models/error.mdl"
ITEM.Base = "base_entity"
ITEM.Stackable = true
function ITEM:Use( pl )
	local tabel = self:GetData( "FoodBaseTabel" )[2]
	local zizney = math.Clamp(pl:Health()+tabel[1], 0, 100)
	local antiabus = self:GetData( "FoodBaseTabel" )[1][1]
	
	if antiabus == 'Пицца' or antiabus == 'Гамбургер' then 
	if pl.abus == nil or pl.abus < CurTime() then
	pl.abus = CurTime() + 180
	pl:EmitSound("foodmod/crunch.wav")
	pl:HFM_AddHunger(tabel[2],1)
	pl:SetHealth(zizney)
	return self:TakeOne()
	else
	if pl.nefludi == nil or pl.nefludi < CurTime() then
	pl.nefludi = CurTime() + 1
	pl:ChatPrint('Ваш желудок ещё не успел обработать прошлую пищу')
	end
	return end
	end
	
	if pl.poeshx == nil or pl.poeshx < CurTime() then
	pl.poeshx = CurTime() + 5.5
	pl:EmitSound("foodmod/crunch.wav")
	pl:HFM_AddHunger(tabel[2],1)
	pl:SetHealth(zizney) else pl:ChatPrint('Подождите немного перед следущим употреблением еды') return end
	
	return self:TakeOne()
end

function ITEM:GetName()
	return self:GetData( "FoodBaseTabel" )[1][1]
end

function ITEM:GetDescription()
	local t = self:GetData( "FoodBaseTabel" )[2]
	local text = "Восстанавливает "
	local time = {}

	text = text .. "\n" .. t[2] .. "% голода и "..t[1].."% жизней"

	return text
end

function ITEM:CanMerge( item )
	return self:GetData("UniqueName") == item:GetData("UniqueName") and ( itemstore.config.MaxStack == -1 or ( ( self:GetData( "Amount" ) or 1 ) + ( item:GetData( "Amount" ) or 1 ) ) <= itemstore.config.MaxStack )
end

function ITEM:GetModel()
	return self:GetData( "FoodBaseTabel" )[1][4]
end

function ITEM:SaveData( ent )
	self:SetData( "FoodBaseTabel", ent:GetFoodBaseTabel() )
	self:SetData( "UniqueName", ent.UniqueName )
end

function ITEM:LoadData( ent )
	ent:SetFoodBaseTabel( self:GetData( "FoodBaseTabel" ) )
	ent.UniqueName = self:GetData( "UniqueName" )
	ent.wake = true
end
--PATH addons/zeros_weedfarm/lua/itemstore/items/zwf_edibles.lua:
ITEM.Name = "Muffin"
ITEM.Description = "A tasty Muffin."
ITEM.Model = "models/zerochain/props_weedfarm/zwf_muffin.mdl"
ITEM.Base = "base_darkrp"
ITEM.Stackable = false
ITEM.DropStack = false

function ITEM:GetName()

	local name = ""

	local edible_id = self:GetData("EdibleID")

	if edible_id and zwf.config.Cooking.edibles[edible_id] and zwf.config.Cooking.edibles[edible_id].name then

		name = zwf.config.Cooking.edibles[edible_id].name .. " "
	end

	if self:GetData("WeedID") ~= -1 then
		name = self:GetData("WeedName") .. " " .. self:GetData("WeedAmount") .. zwf.config.UoW .. " [" .. self:GetData("THC") .. "%] \n[" .. zwf.config.Plants[self:GetData("WeedID")].name .. "]"
	end

	return self:GetData("Name", name)
end


function ITEM:GetDescription()

	local desc

	if self:GetData("WeedID") ~= -1 then
		desc = "A tasty Muffin with traces of weed."
	else
		desc = self.Description
	end

	local edible_id = self:GetData("EdibleID")
	if edible_id and zwf.config.Cooking.edibles[edible_id] and zwf.config.Cooking.edibles[edible_id].name then
		desc = string.Replace(desc, "Muffin", zwf.config.Cooking.edibles[edible_id].name)
	end

	return self:GetData("Description", desc)
end

function ITEM:GetModel()
	local edible_id = self:GetData("EdibleID")
	if edible_id and zwf.config.Cooking.edibles[edible_id] and zwf.config.Cooking.edibles[edible_id].edible_model then
		return zwf.config.Cooking.edibles[edible_id].edible_model
	else
		return "models/zerochain/props_weedfarm/zwf_muffin.mdl"
	end
end

function ITEM:SaveData(ent)
	self:SetData("EdibleID",ent.EdibleID)
	self:SetData("WeedID", ent.WeedID)
	self:SetData("WeedAmount", math.Round(ent.WeedAmount))
	self:SetData("THC", math.Round(ent.WeedTHC))
	self:SetData("WeedName", ent.WeedName)
end

function ITEM:LoadData(ent)
	timer.Simple(0.25,function()
		if IsValid(ent) then
			ent.EdibleID = self:GetData("EdibleID")
			ent.WeedID = self:GetData("WeedID")
			ent.WeedAmount = self:GetData("WeedAmount")
			ent.WeedTHC = self:GetData("THC")
			ent.WeedName = self:GetData("WeedName")

			if ent.EdibleID and zwf.config.Cooking.edibles[ent.EdibleID] and zwf.config.Cooking.edibles[ent.EdibleID].edible_model then
				ent:SetModel(zwf.config.Cooking.edibles[ent.EdibleID].edible_model)
			end

			if ent.WeedID ~= -1 then
				ent:SetSkin(1)

				ent:SetColor(zwf.config.Plants[ent.WeedID].color)
			else
				ent:SetColor(HSVToColor( math.random(0,360), 0.5, 0.85 ) )
			end
		end
	end)
end

--PATH addons/zeros_weedfarm/lua/itemstore/items/zwf_weedblock.lua:
ITEM.Name = "Weed Block"
ITEM.Description = "A block of weed"
ITEM.Model = "models/zerochain/props_weedfarm/zwf_weedblock.mdl"
ITEM.Base = "base_darkrp"
ITEM.Stackable = false
ITEM.DropStack = false

function ITEM:GetName()
	local name = self:GetData("WeedName") .. " " .. self:GetData("WeedAmount") .. zwf.config.UoW .. "\n[" .. zwf.config.Plants[self:GetData("WeedID")].name .. "]"

	return self:GetData("Name", name)
end

function ITEM:SaveData(ent)
	self:SetData("WeedID", ent:GetWeedID())
	self:SetData("WeedName", ent:GetWeedName())
	self:SetData("WeedAmount", ent:GetWeedAmount())
	self:SetData("THC", ent:GetTHC())

	self:SetData("ZWFOwner", zwf.f.GetOwnerID(ent))
end

function ITEM:LoadData(ent)
	ent:SetWeedID(self:GetData("WeedID"))
	ent:SetWeedName(self:GetData("WeedName"))
	ent:SetWeedAmount(self:GetData("WeedAmount"))
	ent:SetTHC(self:GetData("THC"))

	zwf.f.SetOwnerByID(ent, self:GetData("ZWFOwner"))
end

--PATH addons/itemstore_new/lua/itemstore/vgui/container.lua:
﻿local PANEL = {}

local function drawCircle(x, y, radius, seg)
    local cir = {}

    table.insert(cir, {
        x = x,
        y = y,
        u = 0.5,
        v = 0.5
    })

    for i = 0, seg do
        local a = math.rad((i / seg) * -360)

        table.insert(cir, {
            x = x + math.sin(a) * radius,
            y = y + math.cos(a) * radius,
            u = math.sin(a) / 2 + 0.5,
            v = math.cos(a) / 2 + 0.5
        })
    end

    local a = math.rad(0) -- This is needed for non absolute segment counts

    table.insert(cir, {
        x = x + math.sin(a) * radius,
        y = y + math.cos(a) * radius,
        u = math.sin(a) / 2 + 0.5,
        v = math.cos(a) / 2 + 0.5
    })

    surface.DrawPoly(cir)
end
function PANEL:Init()
    self.Page = 1
    self.Pages = {}
    self.Slots = {}
    self.PageButtons = {}
    self.Toolbar = vgui.Create("Panel", self)
    self.Toolbar:SetHeight(32)
    self.Toolbar:Dock(TOP)
    self.Toolbar:DockMargin(0, 0, 0, 5)
    self.SearchClear = vgui.Create("DButton", self.Toolbar)
    self.SearchClear:Dock(RIGHT)
    self.SearchClear:SetText("")
    self.SearchClear:SetWidth(32)

    self.SearchClear.Paint = function(s, w, h)
        surface.SetDrawColor(55, 55, 55)
        draw.NoTexture()
        drawCircle(16, 16, 14, 32)
        draw.SimpleText("✖", "ui.24", w / 2 - 1, h / 2 - 1, color_white, 1, 1)
    end

    self.SearchClear.DoClick = function()
        self.Search:SetValue("")
        self:DoSearch()
    end

    self.Search = vgui.Create("DTextEntry", self.Toolbar)
    self.Search:SetWidth(200)
    self.Search:Dock(RIGHT)
    --self.Search:SetPlaceholderText("Поиск...")
    self.Search.Paint = function(s, w, h)
        draw.RoundedBox(16, 0, 0, w, h, Color(55, 55, 55))
        draw.SimpleText(s:GetText() ~= "" and s:GetText() or "Поиск...", "ui.20", 10, h / 2, color_white, 0, 1)
    end

    self.Search.AllowInput = function( s, v )
        if utf8.len(s:GetText()) >= 17 then
            return true
        end
    end

    self.Search.OnChange = function()
        self:DoSearch()
    end

    table.insert(itemstore.containers.Panels, self)
end

function PANEL:GetPage()
    return self.Page
end

function PANEL:SetPage(page)
    self.Page = page

    for k, v in ipairs(self.Pages) do
        if IsValid(v) then
            v:SetVisible(k == page)
        end
    end
end

function PANEL:SetContainerID(id)
    self.ContainerID = id
    self:Refresh()
end

function PANEL:GetContainerID()
    return self.ContainerID
end

function PANEL:Refresh()
    local id = self:GetContainerID()
    local con = itemstore.containers.Get(id)

    if con then
        for i = 1, con:GetSize() do
            local page_id = con:GetPageFromSlot(i)
            local page = self.Pages[page_id]

            if con then
                for i = 1, con:GetPages() do
                    if not self.PageButtons[i] then
                        local button = vgui.Create("DButton", self.Toolbar)
                        button:SetWidth(32)
                        button:Dock(LEFT)
                        button:DockMargin(0, 0, 5, 0)
                        button:SetText("")
                        button.Paint = function(s, w, h)
                            draw.RoundedBox(8, 0, 0, w, h, self.Page == i and Color(75, 75, 75) or Color(55, 55, 55))
                            draw.SimpleText(i, "ui.24", w / 2, h / 2, Color(255, 255, 255), 1, 1)
                        end
        
                        button.DoClick = function()
                            self:FadeToPage(i)
                        end
        
                        button.DragHoverClick = function()
                            button:DoClick()
                        end
        
                        self.PageButtons[i] = button
                    end
        
                    for i = 1, con:GetSize() do
                        local page_id = con:GetPageFromSlot(i)
                        local page = self.Pages[page_id]
            
                        if not page then
                            page = vgui.Create( "DIconLayout" )
                            page:SetSpaceX( 1 )
                            page:SetSpaceY( 1 )
            
                            self.Pages[ page_id ] = page
            
                            self:AddSheet( itemstore.Translate( "page", page_id ), page )
                        end
            
                        local slot = self.Slots[i]
            
                        if not slot then
                            slot = page:Add( "ItemStoreNewSlot" )
                            slot:SetSize( 40, 40 )
                            slot:SetContainerID( self:GetContainerID() )
                            slot:SetSlot( i )

                            self.Slots[ i ] = slot
                        end
            
                        slot:SetItem(con:GetItem(i))
                        slot:Refresh()
                    end
                end
            end
        end
    end
    self:DoSearch()
    self:SizeToContents()
end

function PANEL:SizeToContents()
    local id = self:GetContainerID()
    local con = itemstore.containers.Get(id)
    if not con then return end
    local p = 2
    local page = self.Pages[self:GetPage()]
    if not IsValid(page) then return end
    local w, h = page:GetSize()
    local cw, ch = con:GetWidth(), con:GetHeight()
    w = w - (cw * p) + p
    h = h - (ch * p) + p
    local sw, sh = w / cw, h / ch
    local ox, oy = 0, 0

    if con then
        local w = con:GetWidth() * 41 + 15
        local h = con:GetHeight() * 41 + 35
        self:SetSize(w, h)
    end
    if sw * 1.5 > w then
        self.SearchClear:Hide()
        self.Search:Hide()
        self.Search:SetText("")
        self:DoSearch()
    else
        self.SearchClear:Show()
        self.Search:Show()
    end
end
function PANEL:DoSearch()
    local search = string.lower(self.Search:GetValue())

    if search ~= "" then
        for k, v in ipairs(self.Slots) do
            local item = v:GetItem()

            if item then
                local class = string.lower(item:GetClass())
                local name = string.lower(item:GetName())
                local desc = string.lower(item:GetDescription())

                if string.find(class, search) or string.find(name, search) or string.find(desc, search) then
                    v:SetAlpha(255)
                else
                    v:SetAlpha(50)
                end
            else
                v:SetAlpha(50)
            end
        end
    else
        for k, v in ipairs(self.Slots) do
            v:SetAlpha(255)
        end
    end
end
vgui.Register("ItemStoreContainer", PANEL, "DPropertySheet")
--PATH addons/itemstore_new/lua/itemstore/vgui/itemtooltip.lua:
﻿DEFINE_BASECLASS("DListLayout")
local PANEL = {}
AccessorFunc(PANEL, "ContainerID", "ContainerID", FORCE_NUMBER)
AccessorFunc(PANEL, "Slot", "Slot", FORCE_NUMBER)
AccessorFunc(PANEL, "Item", "Item")

function PANEL:Init()
    self:SetWide(200)
    self:SetDrawOnTop(true)
    self:DockPadding(5, 5, 5, 5)
    self:SetSkin("itemstore")
    self.Name = self:Add("DLabel")
    self.Name:SetFont("DermaDefaultBold")
    self.Name:SetWrap(true)
    self.Model = self:Add("DModelPanel")
    self.Model:SetSize(125, 125)
    self.Description = self:Add("DLabel")
    self.Description:SetWrap(true)
end

PANEL.Blur = Material("pp/blurscreen")

function PANEL:Paint(w, h)
    self.Blur:SetFloat("$blur", 2)
    self.Blur:Recompute()
    render.UpdateScreenEffectTexture()
    local x, y = self:LocalToScreen(0, 0)
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(self.Blur)
    surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH())
    surface.SetDrawColor(Color(30, 30, 30, 200))
    surface.DrawRect(0, 0, w, h)
end

function PANEL:PerformLayout()
    self.Name:SizeToContents()
    self.Description:SizeToContents()
    BaseClass.PerformLayout(self)
end

function PANEL:Refresh()
    local item = self:GetItem()

    if not item then
        self.Model.Entity:Remove()
        self.Name:SetText("")
        self.Description:SetText("")

        return
    end

    local name = item:GetName()
    local desc = item:GetDescription() or ""

    if item:GetAmount() > 1 then
        name = name .. " x" .. item:GetAmount()
    end

    if self:GetSlot() then
        desc = desc .. "\n\n" .. itemstore.Translate("dragtomove")
        desc = desc .. "\n" .. itemstore.Translate("mclicktodrop")
        desc = desc .. "\n" .. itemstore.Translate("rclickforoptions")

        if item.Use then
            desc = desc .. "\n" .. itemstore.Translate("dclicktouse")
        end
    end

    self.Name:SetText(name)
    self.Name:SizeToContents()
    self.Description:SetText(desc)
    self.Description:SizeToContents()
    self.Model:SetModel(item:GetModel())
    self.Model.Entity:SetMaterial(item:GetMaterial())
    self.Model:SetColor(item:GetColor() or color_white)
    min, max = self.Model.Entity:GetRenderBounds()
    self.Model:SetCamPos(Vector(0.55, 0.55, 0.55) * min:Distance(max))
    self.Model:SetLookAt((min + max) / 2)
    self:InvalidateLayout(true)
end

vgui.Register("ItemStoreTooltip", PANEL, "DListLayout")
--PATH addons/itemstore_new/lua/itemstore/vgui/newcontainer.lua:
﻿local PANEL = {}

local function drawCircle(x, y, radius, seg)
    local cir = {}

    table.insert(cir, {
        x = x,
        y = y,
        u = 0.5,
        v = 0.5
    })

    for i = 0, seg do
        local a = math.rad((i / seg) * -360)

        table.insert(cir, {
            x = x + math.sin(a) * radius,
            y = y + math.cos(a) * radius,
            u = math.sin(a) / 2 + 0.5,
            v = math.cos(a) / 2 + 0.5
        })
    end

    local a = math.rad(0) -- This is needed for non absolute segment counts

    table.insert(cir, {
        x = x + math.sin(a) * radius,
        y = y + math.cos(a) * radius,
        u = math.sin(a) / 2 + 0.5,
        v = math.cos(a) / 2 + 0.5
    })

    surface.DrawPoly(cir)
end

function PANEL:Init()
    self.Page = 1
    self.Pages = {}
    self.Slots = {}
    self.PageButtons = {}
    self.Toolbar = vgui.Create("Panel", self)
    self.Toolbar:SetHeight(32)
    self.Toolbar:Dock(TOP)
    self.Toolbar:DockMargin(0, 0, 0, 5)
    self.SearchClear = vgui.Create("DButton", self.Toolbar)
    self.SearchClear:Dock(RIGHT)
    self.SearchClear:SetText("")
    self.SearchClear:SetWidth(32)

    self.SearchClear.Paint = function(s, w, h)
        surface.SetDrawColor(55, 55, 55)
        draw.NoTexture()
        drawCircle(16, 16, 14, 32)
        draw.SimpleText("✖", "ui.24", w / 2 - 1, h / 2 - 1, color_white, 1, 1)
    end

    self.SearchClear.DoClick = function()
        self.Search:SetValue("")
        self:DoSearch()
    end

    self.Search = vgui.Create("DTextEntry", self.Toolbar)
    self.Search:SetWidth(200)
    self.Search:Dock(RIGHT)
    --self.Search:SetPlaceholderText("Поиск...")
    self.Search.Paint = function(s, w, h)
        draw.RoundedBox(16, 0, 0, w, h, Color(55, 55, 55))
        draw.SimpleText(s:GetText() ~= "" and s:GetText() or "Поиск...", "ui.20", 10, h / 2, color_white, 0, 1)
    end

    self.Search.AllowInput = function( s, v )
        if utf8.len(s:GetText()) >= 17 then
            return true
        end
    end

    self.Search.OnChange = function()
        self:DoSearch()
    end

    table.insert(itemstore.containers.Panels, self)
end

function PANEL:GetPage()
    return self.Page
end

function PANEL:SetPage(page)
    self.Page = page

    for k, v in ipairs(self.Pages) do
        if IsValid(v) then
            v:SetVisible(k == page)
        end
    end
end

function PANEL:SetContainerID(id)
    self.ContainerID = id
    self:Refresh()
end

function PANEL:GetContainerID()
    return self.ContainerID
end

function PANEL:FadeToPage(page)
    local direction = page > self.Page and 1 or -1
    local current_page = self.Pages[self.Page]
    local next_page = self.Pages[page]
    if not IsValid(current_page) or not IsValid(next_page) then return end
    if current_page == next_page then return end

    --[[
    local x, y = current_page:GetPos()

    current_page:MoveTo(current_page:GetWide() * -direction, y, 0.25, 0, -1, function()
        next_page:SetPos(x + next_page:GetWide() * direction, y)
        self:SetPage(page)
        next_page:MoveTo(x, y, 0.25, 0, -1)
    end )
    ]]
    current_page:AlphaTo(0, 0.15, 0, function()
        next_page:SetAlpha(0)
        self:SetPage(page)
        next_page:AlphaTo(255, 0.15, 0)
    end)
end

function PANEL:Refresh()
    local id = self:GetContainerID()
    local con = itemstore.containers.Get(id)

    if con then
        for i = 1, con:GetPages() do
            if not self.PageButtons[i] then
                local button = vgui.Create("DButton", self.Toolbar)
                button:SetWidth(32)
                button:Dock(LEFT)
                button:DockMargin(0, 0, 5, 0)
                button:SetText("")
                button.Paint = function(s, w, h)
                    draw.RoundedBox(8, 0, 0, w, h, self.Page == i and Color(75, 75, 75) or Color(55, 55, 55))
                    draw.SimpleText(i, "ui.24", w / 2, h / 2, Color(255, 255, 255), 1, 1)
                end

                button.DoClick = function()
                    self:FadeToPage(i)
                end

                button.DragHoverClick = function()
                    button:DoClick()
                end

                self.PageButtons[i] = button
            end
        end

        for i = 1, con:GetSize() do
            local page_id = con:GetPageFromSlot(i)
            local page = self.Pages[page_id]

            if not page then
                page = vgui.Create("DIconLayout", self)
                page:Dock(TOP)
                page:SetSpaceX(2)
                page:SetSpaceY(1)
                page:SetVisible(page_id == self:GetPage())
                --page:SetAlpha(page_id == self:GetPage() and 255 or 0)
                self.Pages[page_id] = page
            end

            local slot = self.Slots[i]

            if not slot then
                slot = vgui.Create("ItemStoreNewSlot", page)
                slot:SetContainerID(self:GetContainerID())
                slot:SetSlot(i)
                self.Slots[i] = slot
            end

            slot:SetItem(con:GetItem(i))
            slot:Refresh()
        end

        self:DoSearch()
        self:InvalidateLayout()
	    self:SizeToContents()

    end
end

function PANEL:PerformLayout()
    local id = self:GetContainerID()
    local con = itemstore.containers.Get(id)
    if not con then return end
    local p = 2
    local page = self.Pages[self:GetPage()]
    if not IsValid(page) then return end
    local w, h = page:GetSize()
    local cw, ch = con:GetWidth(), con:GetHeight()
    w = w - (cw * p) + p
    h = h - (ch * p) + p
    local sw, sh = w / cw, h / ch
    local ox, oy = 0, 0

    if itemstore.config.SquareSlots then
        if sw > sh then
            ox = (sw - sh) * cw / 2
            sw = sh
        else
            oy = (sh - sw) * ch / 2
            sh = sw
        end
    end

    local slots = page:GetChildren()

    for k, v in ipairs(slots) do
        local x = (k - 1) % cw
        local y = math.floor((k - 1) / cw)
        local calc_x = ox + (x * sw) + (p * x)
        local calc_y = oy + (y * sh) + (p * y)
        -- v:SetPos(calc_x, calc_y)
        v:SetSize(47,47)
    end

    local w, sw = self:GetWide(), self.Search:GetWide()

    if sw * 1.5 > w then
        self.SearchClear:Hide()
        self.Search:Hide()
        self.Search:SetText("")
        self:DoSearch()
    else
        self.SearchClear:Show()
        self.Search:Show()
    end
end

function PANEL:DoSearch()
    local search = string.lower(self.Search:GetValue())

    if search ~= "" then
        for k, v in ipairs(self.Slots) do
            local item = v:GetItem()

            if item then
                local class = string.lower(item:GetClass())
                local name = string.lower(item:GetName())
                local desc = string.lower(item:GetDescription())

                if string.find(class, search) or string.find(name, search) or string.find(desc, search) then
                    v:SetAlpha(255)
                else
                    v:SetAlpha(50)
                end
            else
                v:SetAlpha(50)
            end
        end
    else
        for k, v in ipairs(self.Slots) do
            v:SetAlpha(255)
        end
    end
end

vgui.Register("ItemStoreNewContainer", PANEL)
--PATH addons/zeros_methlab2/lua/zmlab2_languages/sh_language_en.lua:
zmlab2 = zmlab2 or {}
zmlab2.language = zmlab2.language or {}

if (zmlab2.config.SelectedLanguage == "en") then
    zmlab2.language["YouDontOwnThis"] = "You dont own this!"
    zmlab2.language["Minutes"] = "Minutes"
    zmlab2.language["Seconds"] = "Seconds"
    zmlab2.language["CratePickupFail"] = "Crate is empty!"
    zmlab2.language["CratePickupSuccess"] = "Collected $MethAmount $MethName, Quality: $MethQuality%"
    zmlab2.language["Interaction_Fail_Job"] = "You dont have the right job to interact with this!"
    zmlab2.language["Interaction_Fail_Dropoff"] = "This dropoff point is not assigned to you!"
    zmlab2.language["Dropoff_assinged"] = "Dropoff assigned!"
    zmlab2.language["Dropoff_cooldown"] = "Dropoff cooldown!"
    zmlab2.language["Equipment"] = "Equipment"
    zmlab2.language["Equipment_Build"] = "Build"
    zmlab2.language["Equipment_Move"] = "Move"
    zmlab2.language["Equipment_Repair"] = "Repair"
    zmlab2.language["Equipment_Remove"] = "Remove"
    zmlab2.language["NotEnoughMoney"] = "You dont have enough money!"
    zmlab2.language["ExtinguisherFail"] = "Object is not on fire!"
    zmlab2.language["Start"] = "Start"
    zmlab2.language["Drop"] = "Drop"
    zmlab2.language["Move Liquid"] = "Move Liquid"
    zmlab2.language["Frezzer_NeedTray"] = "No tray with unfrozen meth found!"
    zmlab2.language["ERROR"] = "ERROR"
    zmlab2.language["SPACE"] = "Press SPACE"
    zmlab2.language["NPC_InteractionFail01"] = "I dont deal with normies! [Wrong Job]"
    zmlab2.language["NPC_InteractionFail02"] = "You dont have any meth!"
    zmlab2.language["NPC_InteractionFail03"] = "I dont have a free dropoff point currenty, come back later."
    zmlab2.language["PoliceWanted"] = "Sold Meth!"
    zmlab2.language["MissingCrate"] = "Missing Crate"
    zmlab2.language["Storage"] = "STORAGE"
    zmlab2.language["ItemLimit"] = "You reached the entity limit for $ItemName!"
    zmlab2.language["TentFoldInfo01"] = "Are you sure you want to remove the tent?"
    zmlab2.language["TentFoldInfo02"] = "Any equipment inside will be removed too!"
    zmlab2.language["TentFoldAction"] = "FOLD"
    zmlab2.language["TentType_None"] = "NONE"
    zmlab2.language["TentAction_Build"] = "BUILD"
    zmlab2.language["TentBuild_Info"] = "Please clear the area!"
    zmlab2.language["TentBuild_Abort"] = "Something was in the way!"
    zmlab2.language["Enabled"] = "Enabled"
    zmlab2.language["Disabled"] = "Disabled"
    zmlab2.language["MethTypeRestricted"] = "You are not allowed to make this type of meth!"
    zmlab2.language["SelectMethType"] = "Select Meth Type"
    zmlab2.language["SelectTentType"] = "Select Tent Type"
    zmlab2.language["LightColor"] = "Light Color"
    zmlab2.language["Cancel"] = "Cancel"
    zmlab2.language["Deconstruct"] = "Deconstruct"
    zmlab2.language["Construct"] = "Construct"
    zmlab2.language["Choosepostion"] = "Choose new postion"
    zmlab2.language["ChooseMachine"] = "Choose Machine"
    zmlab2.language["Extinguish"] = "Extinguish"
    zmlab2.language["PumpTo"] = "Pump to"
    zmlab2.language["ConstructionCompleted"] = "Construction Completed!"
    zmlab2.language["Duration"] = "Duration"
    zmlab2.language["Amount"] = "Yield"
    zmlab2.language["Difficulty"] = "Difficulty"
    zmlab2.language["Money"] = "Money"
    zmlab2.language["Difficulty_Easy"] = "Easy"
    zmlab2.language["Difficulty_Medium"] = "Medium"
    zmlab2.language["Difficulty_Hard"] = "Hard"
    zmlab2.language["Difficulty_Expert"] = "Expert"
    zmlab2.language["Connected"] = "Connected!"
    zmlab2.language["Missed"] = "Missed!"
    -- Tent Config
    -- Note: "Vamonos Pest" and "Crystale Castle" are the names of those tents so you dont need to translate them if you dont want
    zmlab2.language["tent01_title"] = "Tent - Small"
    zmlab2.language["tent01_desc"] = "This small tent provides room for 6 machines."
    zmlab2.language["tent02_title"] = "Tent - Medium"
    zmlab2.language["tent02_desc"] = "This medium sized tent provides room for 9 machines."
    zmlab2.language["tent03_title"] = "Tent - Large"
    zmlab2.language["tent03_desc"] = "This large tent provides room for 16 machines."
    zmlab2.language["tent04_title"] = "Crystale Castle"
    zmlab2.language["tent04_desc"] = "This stolen circus tent provides room for 24 machines."
    -- Equipment Config
    zmlab2.language["ventilation_title"] = "Ventilation"
    zmlab2.language["ventilation_desc"] = "Clears the surrounding area from pollution."
    zmlab2.language["storage_title"] = "Storage"
    zmlab2.language["storage_desc"] = "Provides chemicals and equipment."
    zmlab2.language["furnace_title"] = "Thorium Furnace"
    zmlab2.language["furnace_desc"] = "Used for heating acid."
    zmlab2.language["mixer_title"] = "Mixer"
    zmlab2.language["mixer_desc"] = "Used as the main reaction vessel to combining the compounds."
    zmlab2.language["filter_title"] = "Filter"
    zmlab2.language["filter_desc"] = "Used to refine the final mixture to increase its quality."
    zmlab2.language["filler_title"] = "Filler"
    zmlab2.language["filler_desc"] = "Used to fill the final mixture on frezzer trays."
    zmlab2.language["frezzer_title"] = "Frezzer"
    zmlab2.language["frezzer_desc"] = "Used to stop the final methamphetamine solution from reacting further."
    zmlab2.language["packingtable_title"] = "Packing Table"
    zmlab2.language["packingtable_desc"] = "Provides a fast way to break / pack meth. Can hold up to 12 frezzer trays. Can be upgraded with a automatic Ice Breaker."
    -- Storage Config
    zmlab2.language["acid_title"] = "Hydrofluoric Acid"
    zmlab2.language["acid_desc"] = "A catalyst to increase the rate of reaction."
    zmlab2.language["methylamine_title"] = "Methylamine"
    zmlab2.language["methylamine_desc"] = "Methylamine (CH3NH2) is an organic compound and one of the main ingredients for the production of methamphetamine."
    zmlab2.language["aluminum_title"] = "Aluminum"
    zmlab2.language["aluminum_desc"] = "Aluminum amalgam is used as a chemical reagent to reduce compounds."
    zmlab2.language["lox_title"] = "Liquid Oxygen"
    zmlab2.language["lox_desc"] = "Liquid Oxygen is used in the Frezzer to stop the final methamphetamine solution from reacting any further."
    zmlab2.language["crate_title"] = "Transportcrate"
    zmlab2.language["crate_desc"] = "Used for transporting big amounts of meth."
    zmlab2.language["palette_title"] = "Palette"
    zmlab2.language["palette_desc"] = "Used for transporting large amounts of meth."
    zmlab2.language["crusher_title"] = "Ice Breaker"
    zmlab2.language["crusher_desc"] = "Automaticly breaks and packs meth when intalled on a packing table."
    -- Meth Config
    -- Note: Hard to say what about the meth should be translated and what not. Decide for yourself whats important here.
    zmlab2.language["meth_title"] = "Meth"
    zmlab2.language["meth_desc"] = "Normal street meth."
    zmlab2.language["bluemeth_title"] = "Crystal Blue"
    zmlab2.language["bluemeth_desc"] = "The original Heisenberg formula."
    zmlab2.language["kalaxi_title"] = "Kalaxian Crystal"
    zmlab2.language["kalaxi_desc"] = "The Kalaxian Crystals are very similar to many drugs, as the crystals give you a good sensation."
    zmlab2.language["glitter_title"] = "Glitter"
    zmlab2.language["glitter_desc"] = "Glitter is a highly psychedelic drug and recent arrival on Night City's streets. It's truly strong stuff, even for the booster glutted residents of Night City."
    zmlab2.language["kronole_title"] = "Kronole"
    zmlab2.language["kronole_desc"] = "Kronole is a street-drug sold aboard Snowpiercer on the black market. The drug has the ability to block pain receptors, Kronole is so powerful it blocks out all feelings, not just pain."
    zmlab2.language["melange_title"] = "Melange"
    zmlab2.language["melange_desc"] = "Melange (Spice) is a drug able to prolong life, bestow heightened vitality and awareness, and unlock prescience in some humans."
    zmlab2.language["mdma_title"] = "MDMA"
    zmlab2.language["mdma_desc"] = "MDMA was first developed in 1912 by Merck. It was used to enhance psychotherapy beginning in the 1970s and became popular as a street drug in the 1980s."
    -- Update 1.0.5
    zmlab2.language["tent05_title"] = "Round Tent"
    zmlab2.language["tent05_desc"] = "This round tent provides room for 8 machines."
end

--PATH addons/zeros_methlab2/lua/zmlab2_languages/sh_language_es.lua:
zmlab2 = zmlab2 or {}
zmlab2.language = zmlab2.language or {}

if (zmlab2.config.SelectedLanguage == "es") then
    zmlab2.language["YouDontOwnThis"] = "¡Esto no te pertenece!"
    zmlab2.language["Minutes"] = "Minutos"
    zmlab2.language["Seconds"] = "Segundos"
    zmlab2.language["CratePickupFail"] = "¡El contenedor está vacío!"
    zmlab2.language["CratePickupSuccess"] = "Has recogido $MethAmount $MethName, Calidad: $MethQuality%"
    zmlab2.language["Interaction_Fail_Job"] = "¡No tienes el trabajo adecuado para hacer eso!"
    zmlab2.language["Interaction_Fail_Dropoff"] = "¡Este punto de entrega no te fue asignado!"
    zmlab2.language["Dropoff_assinged"] = "¡Entrega coordinada!"
    zmlab2.language["Dropoff_cooldown"] = "¡Entrega en enfriamiento!"
    zmlab2.language["Equipment"] = "Equipamiento"
    zmlab2.language["Equipment_Build"] = "Construir"
    zmlab2.language["Equipment_Move"] = "Mover"
    zmlab2.language["Equipment_Repair"] = "Reparar"
    zmlab2.language["Equipment_Remove"] = "Remover"
    zmlab2.language["NotEnoughMoney"] = "¡No tienes dinero suficiente!"
    zmlab2.language["ExtinguisherFail"] = "¡El objeto no está en llamas!"
    zmlab2.language["Start"] = "Iniciar"
    zmlab2.language["Drop"] = "Soltar"
    zmlab2.language["Move Liquid"] = "Mover Líquido"
    zmlab2.language["Frezzer_NeedTray"] = "¡Bandeja con metanfetamina líquida no encontrada!"
    zmlab2.language["ERROR"] = "ERROR"
    zmlab2.language["SPACE"] = "Preciona ESPACIO"
    zmlab2.language["NPC_InteractionFail01"] = "¡No hago negocios con desconocidos! [Trabajo incorrecto]"
    zmlab2.language["NPC_InteractionFail02"] = "¡No tienes metanfetamina!"
    zmlab2.language["NPC_InteractionFail03"] = "No tengo un punto de entrega libre, vuelve más tarde."
    zmlab2.language["PoliceWanted"] = "¡Metanfetamina vendida!"
    zmlab2.language["MissingCrate"] = "No tienes contenedores"
    zmlab2.language["Storage"] = "ALMACENAMIENTO"
    zmlab2.language["ItemLimit"] = "¡Has alcanzado el límite de entidad de la entidad $ItemName!"
    zmlab2.language["TentFoldInfo01"] = "¿Estás seguro de que quieres remover la carpa?"
    zmlab2.language["TentFoldInfo02"] = "¡Todo lo que esté dentro será removido también!"
    zmlab2.language["TentFoldAction"] = "DOBLAR"
    zmlab2.language["TentType_None"] = "NADA"
    zmlab2.language["TentAction_Build"] = "Construir"
    zmlab2.language["TentBuild_Info"] = "¡Por favor, libera el área!"
    zmlab2.language["TentBuild_Abort"] = "¡Había algo en el camino!"
    zmlab2.language["Enabled"] = "Habilitado"
    zmlab2.language["Disabled"] = "Deshabilitado"
    zmlab2.language["MethTypeRestricted"] = "¡No tienes permitido hacer este tipo de metanfetamina!"
    zmlab2.language["SelectMethType"] = "Selecciona el tipo de meta"
    zmlab2.language["SelectTentType"] = "Selecciona el tipo de carpa"
    zmlab2.language["LightColor"] = "Color de la luz"
    zmlab2.language["Cancel"] = "Cancelar"
    zmlab2.language["Deconstruct"] = "Deconstruir"
    zmlab2.language["Construct"] = "Construir"
    zmlab2.language["Choosepostion"] = "Elige una nueva posición"
    zmlab2.language["ChooseMachine"] = "Elige una máquina"
    zmlab2.language["Extinguish"] = "Extinguir"
    zmlab2.language["PumpTo"] = "Bombear"
    zmlab2.language["ConstructionCompleted"] = "¡Construcción Completa!"
    zmlab2.language["Duration"] = "Duración"
    zmlab2.language["Amount"] = "Producir"
    zmlab2.language["Difficulty"] = "Dificultad"
    zmlab2.language["Money"] = "Dinero"
    zmlab2.language["Difficulty_Easy"] = "Fácil"
    zmlab2.language["Difficulty_Medium"] = "Media"
    zmlab2.language["Difficulty_Hard"] = "Difícil"
    zmlab2.language["Difficulty_Expert"] = "Experto"
    zmlab2.language["Connected"] = "¡Conectado!"
    zmlab2.language["Missed"] = "¡Fallado!"

    // Tent Config
    // Note: "Vamonos Pest" and "Crystale Castle" are the names of those tents so you dont need to translate them if you dont want
    zmlab2.language["tent01_title"] = "Carpa Vamonos Pest - Pequeña"
    zmlab2.language["tent01_desc"] = "Esta carpa pequeña admite hasta 6 máquinas."
    zmlab2.language["tent02_title"] = "Carpa Vamonos Pest - Media"
    zmlab2.language["tent02_desc"] = "Esta carpa mediana admite hasta 9 máquinas."
    zmlab2.language["tent03_title"] = "Carpa Vamonos Pest - Grande"
    zmlab2.language["tent03_desc"] = "Esta carpa grande admite hasta 16 máquinas."
    zmlab2.language["tent04_title"] = "Crystale Castle"
    zmlab2.language["tent04_desc"] = "Esta carpa de circo robada admite hasta 24 máquinas."

    // Equipment Config
    zmlab2.language["ventilation_title"] = "Ventilación"
    zmlab2.language["ventilation_desc"] = "Libera la zona circundante de contaminación."
    zmlab2.language["storage_title"] = "Almacenamiento"
    zmlab2.language["storage_desc"] = "Provee químicos y equipamiento."
    zmlab2.language["furnace_title"] = "Horno Torio"
    zmlab2.language["furnace_desc"] = "Usado para calentar ácido."
    zmlab2.language["mixer_title"] = "Mezclador"
    zmlab2.language["mixer_desc"] = "Utilizado como el dispositivo principal para mezclar productos."
    zmlab2.language["filter_title"] = "Filtro"
    zmlab2.language["filter_desc"] = "Utilizado para refinar la mezcla final para mejorar su calidad."
    zmlab2.language["filler_title"] = "Distribuidor"
    zmlab2.language["filler_desc"] = "Utilizado para rellenar las bandejas con la mezcla producida."
    zmlab2.language["frezzer_title"] = "Congelador"
    zmlab2.language["frezzer_desc"] = "Utilizado para evitar que la solución de metanfetamina continúe reaccionando."
    zmlab2.language["packingtable_title"] = "Mesa de Almacenamiento"
    zmlab2.language["packingtable_desc"] = "Provee una forma sencilla para picar / guardar la meta. Admite hasta 12 bandejas para congelador. Puede ser mejorada con un Picador de Cristales automático."

    // Storage Config
    zmlab2.language["acid_title"] = "Acido fluorhídrico"
    zmlab2.language["acid_desc"] = "Un catalizador para aumentar el porcentaje de reacción."
    zmlab2.language["methylamine_title"] = "Metilamina"
    zmlab2.language["methylamine_desc"] = "La Metilamina (CH3NH2) es un componente orgánico y uno de los ingredientes principales para la producción de meta."
    zmlab2.language["aluminum_title"] = "Aluminio"
    zmlab2.language["aluminum_desc"] = "El Aluminio amalgamado es utilizado como un componente agente para reducir reagent para reducir compuestos."
    zmlab2.language["lox_title"] = "Oxígeno Líquido"
    zmlab2.language["lox_desc"] = "El oxígeno Líquido es utilizado en el congelador para evitar que la solución de metanfetamina continúe reaccionando."
    zmlab2.language["crate_title"] = "Contenedor para transportar"
    zmlab2.language["crate_desc"] = "Utilizado para transportar grandes cantidades de meta."
    zmlab2.language["palette_title"] = "Paleta"
    zmlab2.language["palette_desc"] = "Utilizado para transportar varios contenedores con meta."
    zmlab2.language["crusher_title"] = "Picador de Cristales"
    zmlab2.language["crusher_desc"] = "Pica y almacena la meta automáticamente al ser instalada en una Mesa de Almacenamiento."

    // Meth Config
    // Note: Hard to say what about the meth should be translated and what not. Decide for yourself whats important here.
    zmlab2.language["meth_title"] = "Metanfetamina"
    zmlab2.language["meth_desc"] = "Metanfetamina común y corriente."
    zmlab2.language["bluemeth_title"] = "Metanfetamina Azul"
    zmlab2.language["bluemeth_desc"] = "La fórmula original del gran Heisenberg."
    zmlab2.language["kalaxi_title"] = "Cristales Kalaxian"
    zmlab2.language["kalaxi_desc"] = "La meta Kalaxiana es similar a otras drogas, ya que los cristales te dan una gran sensación."
    zmlab2.language["glitter_title"] = "Glitter"
    zmlab2.language["glitter_desc"] = "El Glitter es una droga psicodélica drug recién nacida de las calles de Night City. Es bastante fuerte, incluso para los veteranos de Night City."
    zmlab2.language["kronole_title"] = "Kronole"
    zmlab2.language["kronole_desc"] = "El Kronole es una droga callejera vendida por Snowpiercer en el mercado negro. Esta droga permite no sentir dolor, además de muchos otros sentidos."
    zmlab2.language["melange_title"] = "Mezclado"
    zmlab2.language["melange_desc"] = "El Mezclado (Especia) es una droga que permite alargar el tiempo de vida, otorgando mayor vitalidad y conciencia, además de permitirle predecir el futuro a algunas personas."
    zmlab2.language["mdma_title"] = "MDMA"
    zmlab2.language["mdma_desc"] = "La MDMA fue creada en 1912 por Merck. Fue utilizada para mejorar la terapia psicológica al principio de 1970 y se volvió popular como droga callejera a partir del 1980."

    // Update 1.0.5
    zmlab2.language["tent05_title"] = "Round Tent"
    zmlab2.language["tent05_desc"] = "This round tent provides room for 8 machines."
end

--PATH addons/zeros_methlab2/lua/zmlab2/util/sh_precache_particle.lua:
game.AddParticles("particles/zmlab2_fx.pcf")
PrecacheParticleSystem("zmlab2_cleaning")
PrecacheParticleSystem("zmlab2_methsludge_fill")
PrecacheParticleSystem("zmlab2_poison_gas")
PrecacheParticleSystem("zmlab2_vent_clean")
PrecacheParticleSystem("zmlab2_vent_poision")
PrecacheParticleSystem("zmlab2_methylamin_fill")
PrecacheParticleSystem("zmlab2_aluminium_fill")
PrecacheParticleSystem("zmlab2_acid_fill")
PrecacheParticleSystem("zmlab2_acid_explo")
PrecacheParticleSystem("zmlab2_aluminium_explo")
PrecacheParticleSystem("zmlab2_methylamine_explo")
PrecacheParticleSystem("zmlab2_lox_explo")
PrecacheParticleSystem("zmlab2_frozen_gas")
PrecacheParticleSystem("zmlab2_purchase")
PrecacheParticleSystem("zmlab2_filter_exhaust")
PrecacheParticleSystem("zmlab2_extinguish")

for k, v in pairs(zmlab2.config.MethTypes) do
    if v.visuals then
        if v.visuals.effect then
            PrecacheParticleSystem(v.visuals.effect)
        end

        if v.visuals.effect_breaking then
            PrecacheParticleSystem(v.visuals.effect_breaking)
        end

        if v.visuals.effect_filling then
            PrecacheParticleSystem(v.visuals.effect_filling)
        end

        if v.visuals.effect_exploding then
            PrecacheParticleSystem(v.visuals.effect_exploding)
        end

        if v.visuals.effect_mixer_liquid then
            PrecacheParticleSystem(v.visuals.effect_mixer_liquid)
        end

        if v.visuals.effect_mixer_exhaust then
            PrecacheParticleSystem(v.visuals.effect_mixer_exhaust)
        end
    end
end

--PATH addons/zeros_methlab2/lua/zmlab2/ventilation/cl_vent.lua:
if not CLIENT then return end
zmlab2 = zmlab2 or {}
zmlab2.Ventilation = zmlab2.Ventilation or {}

function zmlab2.Ventilation.Initialize(Ventilation)

end

function zmlab2.Ventilation.OnThink(Ventilation)
    if zmlab2.util.InDistance(LocalPlayer():GetPos(),Ventilation:GetPos(), 500) and IsValid(Ventilation:GetOutput()) then

        if Ventilation:GetIsVenting() == true and (Ventilation.NextEffect == nil or Ventilation.NextEffect < CurTime()) then
            local time = Ventilation:GetLastPollutionMove() + 3
            if CurTime() < time then
                zmlab2.Effect.ParticleEffectAttach("zmlab2_vent_poision", PATTACH_POINT_FOLLOW, Ventilation.Output, 2)
            else
                zmlab2.Effect.ParticleEffectAttach("zmlab2_vent_clean", PATTACH_POINT_FOLLOW, Ventilation.Output, 2)
            end

            Ventilation.NextEffect = CurTime() + 0.5
        end


        if zmlab2.Ventilation.List[Ventilation:EntIndex()] == nil then
            zmlab2.Ventilation.AddPipeRender(Ventilation)
        end
    else
        if zmlab2.Ventilation.List[Ventilation:EntIndex()] then
            zmlab2.Ventilation.RemovePipeRender(Ventilation:EntIndex())
        end
    end
end

function zmlab2.Ventilation.OnRemove(Ventilation)
    zmlab2.Ventilation.RemoveClientModel(Ventilation)
    Ventilation:StopSound("zmlab2_machine_ventilation")
end



local ScreenData = {
    pos = Vector(-4.9,11,30.8),
    ang = Angle(0, 180, 90),
    x = 0,
    y = 0,
    w = 155,
    h = 90,
    pages = {
        [0] = function(Ventilation)
            zmlab2.Interface.DrawButton(0, 0, 130, 60, zmlab2.language["Disabled"], Ventilation:OnStart(LocalPlayer()))

            draw.RoundedBox(15, 39, 63,30,30, zmlab2.colors["black03"])
            surface.SetDrawColor(zmlab2.colors["red02"])
            surface.SetMaterial(zmlab2.materials["radial_shadow"])
            surface.DrawTexturedRect(29, 55,50,50)
        end,
        [1] = function(Ventilation)
            zmlab2.Interface.DrawButton(0, 0, 130, 60, zmlab2.language["Enabled"], Ventilation:OnStart(LocalPlayer()))

            draw.RoundedBox(15, 39, 63,30,30, zmlab2.colors["black03"])
            surface.SetDrawColor(zmlab2.colors["green02"])
            surface.SetMaterial(zmlab2.materials["radial_shadow"])
            surface.DrawTexturedRect(29, 55,50,50)
        end,
    }
}

function zmlab2.Ventilation.Draw(Ventilation)

    zmlab2.util.LoopedSound(Ventilation, "zmlab2_machine_ventilation", Ventilation:GetIsVenting())

    if zmlab2.util.InDistance(Ventilation:GetPos(), LocalPlayer():GetPos(), 1250) then

        zmlab2.Interface.Draw(Ventilation,ScreenData)

        // Vibrates certain bones of the machine
        zmlab2.VibrationSystem.Run(Ventilation,Ventilation:GetProcessState() == 1,0.7)
    end
end



zmlab2.Ventilation.List = zmlab2.Ventilation.List or {}

function zmlab2.Ventilation.AddPipeRender(Ventilation)

    zmlab2.Ventilation.List[Ventilation:EntIndex()] = Ventilation

    zmlab2.Hook.Add("Think", "Ventilation", function() zmlab2.Ventilation.PipeRender() end)
end

function zmlab2.Ventilation.RemovePipeRender(EntIndex)
    zmlab2.Ventilation.List[EntIndex] = nil
end

function zmlab2.Ventilation.PipeRender()

    if zmlab2.Ventilation.List == nil or table.Count(zmlab2.Ventilation.List) <= 0 then
        zmlab2.Hook.Remove("Think", "Ventilation")
        return
    end

    for k,v in pairs(zmlab2.Ventilation.List) do
        if not IsValid(v) then
            zmlab2.Ventilation.RemovePipeRender(k)
            continue
        end
        zmlab2.Ventilation.DrawPipe(v)
    end
end

local gravity = Vector(0, 0, -0.5)
local damping = 0.5
local Length = 14

local function Pipe_GetLinePoints(Ventilation,attach,r_start,r_end)
    // Create rope points
    if Ventilation.LinePoints == nil then
        Ventilation.LinePoints = zmlab2.Rope.Setup(Length, r_start)
    end

    // Updates the Rope points to move physicly
    if Ventilation.LinePoints and table.Count(Ventilation.LinePoints) > 0 then

        zmlab2.Rope.Update(Ventilation.LinePoints, r_start, r_end, Length, gravity, damping)

        // Clamp all point positions Z to mid pos
        if Ventilation.Pipe_MidPos then
            for k,v in pairs(Ventilation.LinePoints) do
                v.position = Vector(v.position.x, v.position.y, math.Clamp(v.position.z, Ventilation.Pipe_MidPos.z, 99999999))
            end
        end

        Ventilation.LinePoints[1].position = r_start - attach.Ang:Up() * 5
        Ventilation.LinePoints[2].position = r_start - attach.Ang:Up() * 3

        Ventilation.LinePoints[Length - 1].position = r_end + Ventilation.Output:GetForward() * 15
        Ventilation.LinePoints[Length].position = r_end
    end
end

local function Pipe_GetMidPoint(Ventilation)
    local speed = Ventilation.Output:GetVelocity():Length()
    if speed > 0 then
        Ventilation.Pipe_MidPos = nil
    else
        // Now that the thing is not moving anymore lets trace for the floor between the 2 points
        if Ventilation.Pipe_MidPos == nil then

            local vent_pos = Ventilation:GetPos()
            local output_pos = Ventilation.Output:GetPos()

            // If the position z diffrence is bigger then 10 units then lets not define it
            // BUG You returned here so tahts why none of the other code was working anymore
            if math.abs(output_pos.z - vent_pos.z) < 100 then
                local midPos = (Ventilation.Output:GetPos() + vent_pos) / 2
                midPos = Vector(midPos.x,midPos.y,math.Clamp(midPos.z,vent_pos.z,99999999999999))

                local c_trace = zmlab2.util.TraceLine({
                    start = midPos,
                    endpos = midPos - Vector(0,0,10000),
                    mask = MASK_SOLID_BRUSHONLY,
                }, "Pipe_MidPosTracer")

                if c_trace.Hit and c_trace.HitPos then
                    Ventilation.Pipe_MidPos = Vector(c_trace.HitPos.x,c_trace.HitPos.y,midPos.z)
                end
            end
        end
    end
end

local function Pipe_GetLineAngles(Ventilation)
    if Ventilation.LineAngles == nil then
        Ventilation.LineAngles = {}
    end

    for point = 0, Length do
        if Ventilation.LinePoints[point] then
            local pos = Ventilation.LinePoints[point].position
            local ang = (Ventilation:GetPos() - Ventilation.Output:GetPos()):Angle()

            if Ventilation.LinePoints[point - 1] then
                ang = (pos - Ventilation.LinePoints[point-1].position):Angle()
                ang:RotateAroundAxis(ang:Right(),-90)
            end

            Ventilation.LineAngles[point] = ang
        end
    end
end

function zmlab2.Ventilation.DrawPipe(Ventilation)

    // Here we create or remove the client models
    if zmlab2.util.InDistance(LocalPlayer():GetPos(), Ventilation:GetPos(), 1000) then

        if not IsValid(Ventilation.PipeModel) then
            zmlab2.Ventilation.CreateClientModel(Ventilation)
        else

            if not IsValid(Ventilation.Output) then
                Ventilation.Output = Ventilation:GetOutput()
            else

                // If the Ventilation Head is not moving then it will get a mid point between start and finish via trace
                Pipe_GetMidPoint(Ventilation)

                local attach = Ventilation:GetAttachment(1)
                local r_start = attach.Pos

                local output_attach = Ventilation.Output:GetAttachment(1)
                local r_end = Ventilation.Output:GetPos()

                if output_attach then
                    r_end = output_attach.Pos
                end

                // Calculate the segments position
                Pipe_GetLinePoints(Ventilation,attach,r_start,r_end)

                // Calculate the segment angles
                Pipe_GetLineAngles(Ventilation)

                // Fixes the pipe rotation for the last 2 bones
                if output_attach then
                    local last_ang = output_attach.Ang
                    last_ang:RotateAroundAxis(last_ang:Right(),180)
                    last_ang:RotateAroundAxis(last_ang:Up(),-90)

                    Ventilation.LineAngles[Length - 1] = output_attach.Ang
                    Ventilation.LineAngles[Length] = output_attach.Ang
                end
            end

            // I know its stupid but we need to make sure the client prop stays in eye sight to keep rendering
            Ventilation.PipeModel:SetPos(LocalPlayer():EyePos())
        end
    else
        zmlab2.Ventilation.RemoveClientModel(Ventilation)
    end
end

function zmlab2.Ventilation.RemoveClientModel(Ventilation)
    if IsValid(Ventilation.PipeModel) then
        zmlab2.ClientModel.Remove(Ventilation.PipeModel)
        zmlab2.Debug("zmlab2.Ventilation.RemoveClientModel")
        Ventilation.PipeModel = nil
    end

    Ventilation.Output = nil
end

function zmlab2.Ventilation.CreateClientModel(Ventilation)

    local ent = zmlab2.ClientModel.AddProp()
    if not IsValid(ent) then return end
    ent:SetModel("models/zerochain/props_methlab/zmlab2_pipe_vent.mdl")
    ent:SetAngles(Ventilation:LocalToWorldAngles(angle_zero))
    ent:SetPos(Ventilation:LocalToWorld(vector_origin))
    ent:Spawn()
    ent:SetParent(Ventilation)
    ent:SetRenderMode(RENDERMODE_TRANSCOLOR)
    Ventilation.PipeModel = ent
    zmlab2.Debug("zmlab2.Ventilation.CreateClientModel")

    local CallBackID = ent:AddCallback("BuildBonePositions", function(pipe, numbones)
        for i = 0, numbones - 1 do
            local mat = pipe:GetBoneMatrix(i)
            if not mat then continue end

            if Ventilation.LineAngles and Ventilation.LineAngles[i + 1] then
                mat:SetAngles(Ventilation.LineAngles[i + 1])
            end

            if Ventilation.LinePoints and Ventilation.LinePoints[i + 1] then
                mat:SetTranslation(Ventilation.LinePoints[i + 1].position)
            end

            pipe:SetBoneMatrix(i, mat)
        end
    end)
    //print("Ventilation[" .. tostring(Ventilation:EntIndex()) .. "]" .. "Added Callback [BuildBonePositions]")

    ent:CallOnRemove("Remove_BuildBonePositions_Callback_" .. math.random(99999999), function(pipe)
        //print("Ventilation[" .. tostring(Ventilation:EntIndex()) .. "]" .. "Removed Callback [BuildBonePositions]")
        pipe:RemoveCallback("BuildBonePositions", CallBackID)
    end)
end

--PATH addons/zeros_methlab2/lua/zmlab2/pumpsystem/sh_pumpsystem.lua:
zmlab2 = zmlab2 or {}
zmlab2.PumpSystem = zmlab2.PumpSystem or {}

// Returns the Pump Duration
function zmlab2.PumpSystem.GetTime(From,To)
    return 4
end

// Returns if the From entity can give its liquid to the To Entity
function zmlab2.PumpSystem.AllowConnection(From_ent,To_ent)
    //zmlab2.Debug("zmlab2.PumpSystem.AllowConnection")

    if To_ent.AllowConnection then
        return To_ent:AllowConnection(From_ent)
    else
        return false
    end
end

--PATH addons/zeros_methlab2/lua/zmlab2/mixer/cl_mixer_vgui.lua:
if not CLIENT then return end

net.Receive("zmlab2_Mixer_OpenInterface", function(len)
    zmlab2.Debug_Net("zmlab2_Mixer_OpenInterface", len)

    LocalPlayer().zmlab2_Mixer = net.ReadEntity()

    zmlab2.Interface.Create(600,365,zmlab2.language["SelectMethType"],function(pnl)

        zmlab2.Interface.AddModelList(pnl,zmlab2.config.MethTypes,function(id)
            // IsLocked
            return zmlab2.Mixer.MethTypeCheck(LocalPlayer(),id) == false
        end,
        function(id)
            // IsSelected
            return IsValid(LocalPlayer().zmlab2_Mixer) and LocalPlayer().zmlab2_Mixer:GetMethType() == id
        end,
        function(id)
            // OnClick
            net.Start("zmlab2_Mixer_SetMethType")
            net.WriteEntity(LocalPlayer().zmlab2_Mixer)
            net.WriteUInt(id, 16)
            net.SendToServer()
        end,
        function(raw_data)
            return {model = raw_data.crystal_mdl,render = {FOV = 35},color = raw_data.color} , raw_data.name , zmlab2.Money.Display(raw_data.price * ( zmlab2.config.NPC.SellRanks[zmlab2.Player.GetRank(LocalPlayer())] or zmlab2.config.NPC.SellRanks["default"]))
        end)
    end)
end)

--PATH addons/zeros_methlab2/lua/zmlab2/packing/cl_packing.lua:
if not CLIENT then return end
zmlab2 = zmlab2 or {}
zmlab2.Table = zmlab2.Table or {}

function zmlab2.Table.Initialize(Table)
    Table.IsAutobreaking = false
end

local function DrawButton(x, y,w,h, txt, hover)
    draw.SimpleText(txt, zmlab2.GetFont("zmlab2_font02"), x, y, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    zmlab2.util.DrawOutlinedBox(x - w / 2, y - h / 2, w, h, 4, color_white)
    if hover then
        draw.RoundedBox(0, x - w / 2, y - h / 2, w, h, zmlab2.colors["white02"])
    end
end

function zmlab2.Table.Draw(Table)
    if zmlab2.util.InDistance(LocalPlayer():GetPos(), Table:GetPos(), 500) and Table.IsAutobreaking == false and zmlab2.Convar.Get("zmlab2_cl_drawui") == 1 then
        cam.Start3D2D(Table:LocalToWorld(Vector(0, 0, 36.3)), Table:LocalToWorldAngles(Angle(0, 180, 0)), 0.05)

            if IsValid(Table:GetCrate()) then
                DrawButton(-255, 210, 300, 80, zmlab2.language["Drop"], Table:OnDrop_Crate(LocalPlayer()))
            else
                local txtSize = zmlab2.util.GetTextSize(zmlab2.language["MissingCrate"], zmlab2.GetFont("zmlab2_font02"))
                local barSize = math.Clamp(txtSize * 1.1, 400, 700)
                zmlab2.util.DrawOutlinedBox((-barSize / 2) - 260, -140, barSize, 280, 8, zmlab2.colors["white02"])
                draw.SimpleText(zmlab2.language["MissingCrate"], zmlab2.GetFont("zmlab2_font02"), -260, 0, zmlab2.colors["red03"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end

            if IsValid(Table:GetTray()) then
                DrawButton(245, 210, 300, 80, zmlab2.language["Drop"], Table:OnDrop_Tray(LocalPlayer()))
            end
        cam.End3D2D()
    end
end

function zmlab2.Table.Think(Table)

    zmlab2.util.LoopedSound(Table, "zmlab2_machine_icebreaker_loop", Table.IsAutobreaking == true)

    if zmlab2.util.InDistance(LocalPlayer():GetPos(),Table:GetPos(), 500) then
        if Table:GetIsAutobreaking() ~= Table.IsAutobreaking then
            Table.IsAutobreaking = Table:GetIsAutobreaking()

            if Table.IsAutobreaking then
                zmlab2.Animation.Play(Table,"run", 1)
            else
                zmlab2.Animation.Play(Table,"idle", 1)
            end
        end
    else
        Table.IsAutobreaking = nil
    end
end

function zmlab2.Table.OnRemove(Table)
    Table:StopSound("zmlab2_machine_icebreaker_loop")
end

--PATH addons/zeros_methlab2/lua/zmlab2/generic/cl_pointer.lua:
if SERVER then return end

zmlab2 = zmlab2 or {}
zmlab2.PointerSystem = zmlab2.PointerSystem or {}

/*

    This system handles the Left / Right Mouse Click logic and displays a 2d colored rope from one Point to another
         Gets used by: Extinguisher(Extinguish Object), PointerSystem(MoveLiquid), Equipment(Build,Move,Remove,Repair)

*/

zmlab2.PointerSystem.Data = {
    // Stores what entity is the liquid comming from
    From = nil,

    // Will Later be filled with the DummyClientModel
    PreviewModel = nil,

    // The position we are currently aiming at
    HitPos = nil,

    // The entity we are currently aiming at
    HitEntity = nil,

    // A valid found target, can be a entity or a position
    Target = nil,

    // Displays on the screen what action is currently active
    ActionName = "Test"
}


local IsLeftClickDown = false
local IsRightClickDown = false

local function ClearDummy()
    if IsValid(zmlab2.PointerSystem.Data.PreviewModel) then
        zmlab2.ClientModel.Remove(zmlab2.PointerSystem.Data.PreviewModel)
        zmlab2.PointerSystem.Data.PreviewModel = nil
    end
end

local function CreateDummy(pos, model)
    ClearDummy()
    local ent = zmlab2.ClientModel.AddProp()
    if not IsValid(ent) then return end
    ent:SetPos(pos)
    ent:SetModel(model)
    ent:SetAngles(angle_zero)
    ent:Spawn()

    ent:SetRenderMode(RENDERMODE_TRANSCOLOR)
    zmlab2.PointerSystem.Data.PreviewModel = ent
end

// Starts the pointer system
function zmlab2.PointerSystem.Start(Machine,OnInit,OnLeftClick,MainLogic,HUDLogic)
    zmlab2.Debug("zmlab2.PointerSystem.Start")

    ClearDummy()

    zmlab2.PointerSystem.Data.From = Machine

    // Can be used to add something on the hud
    zmlab2.PointerSystem.Data.HUDLogic = HUDLogic

    // Can be used to setup some main data like (Default Rope color)
    pcall(OnInit)

    // What should happen when the player left clicks (Confirms a action)
    zmlab2.PointerSystem.Data.OnLeftClick = OnLeftClick

    // This function will later run some core logic of what data should be stored etc
    zmlab2.PointerSystem.Data.MainLogic = MainLogic

    zmlab2.PointerSystem.StartHook()
end

// Stops the pointer system
function zmlab2.PointerSystem.Stop()
    zmlab2.Debug("zmlab2.PointerSystem.Stop")

    ClearDummy()

    zmlab2.PointerSystem.Data = {}

    zmlab2.PointerSystem.FinishHook()
end

function zmlab2.PointerSystem.StartHook()
    zmlab2.Hook.Remove("Think", "PointerSystem")
    zmlab2.Hook.Add("Think", "PointerSystem", function(depth, skybox)
        zmlab2.PointerSystem.MainLogic()
        IsLeftClickDown = input.IsMouseDown(MOUSE_LEFT)
        IsRightClickDown = input.IsMouseDown(MOUSE_RIGHT)
    end)

    zmlab2.Hook.Remove("HUDPaint", "PointerSystem")
    zmlab2.Hook.Add("HUDPaint", "PointerSystem", function()
        zmlab2.PointerSystem.Paint()
    end)

    zmlab2.Hook.Remove("PostDrawTranslucentRenderables", "PointerSystem")
    zmlab2.Hook.Add("PostDrawTranslucentRenderables", "PointerSystem", function(depth, skybox)
        if skybox == false then zmlab2.PointerSystem.PostDrawTranslucentRenderables() end
    end)
end

function zmlab2.PointerSystem.FinishHook()
    zmlab2.Hook.Remove("Think", "PointerSystem")
    zmlab2.Hook.Remove("HUDPaint", "PointerSystem")
    zmlab2.Hook.Remove("PostDrawTranslucentRenderables", "PointerSystem")
end



// Draws the indicator line for the pointer system and also handles the trace for detecting the entity the player is left click on to
local LinePoints = nil
local gravity = Vector(0, 0, -3)
local damping = 0.9
local Length = 10
function zmlab2.PointerSystem.Paint()
    if IsValid(zmlab2.PointerSystem.Data.From) then

        // Render the rope
        if zmlab2.PointerSystem.Data.Pos then
            local r_start = zmlab2.PointerSystem.Data.From:GetPos()

            // Create rope points
            if LinePoints == nil then
                LinePoints = zmlab2.Rope.Setup(Length, r_start)
            end

            // Updates the Rope points to move physicly
            if LinePoints and table.Count(LinePoints) > 0 then
                zmlab2.Rope.Update(LinePoints, r_start, zmlab2.PointerSystem.Data.Pos, Length, gravity, damping)
            end

            // Draw the rope
            zmlab2.Rope.Draw(LinePoints, r_start, zmlab2.PointerSystem.Data.Pos, Length, zmlab2.materials["beam01"], zmlab2.materials["glow01"], zmlab2.PointerSystem.Data.MainColor)
        else
            LinePoints = nil
        end
    else
        LinePoints = nil
    end

    // Draw Action Hud indicator
    draw.SimpleText(zmlab2.PointerSystem.Data.ActionName, zmlab2.GetFont("zmlab2_vgui_font01"), zmlab2.wM *  650, zmlab2.hM * 895, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    surface.SetDrawColor(color_white)
    surface.SetMaterial(zmlab2.materials["icon_mouse_left"])
    surface.DrawTexturedRect(zmlab2.wM * 560, zmlab2.hM * 860,zmlab2.wM * 80, zmlab2.hM * 80)

    draw.SimpleText(zmlab2.language["Cancel"], zmlab2.GetFont("zmlab2_vgui_font01"), zmlab2.wM * 1350, zmlab2.hM * 895, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
    surface.SetDrawColor(color_white)
    surface.SetMaterial(zmlab2.materials["icon_mouse_right"])
    surface.DrawTexturedRect(zmlab2.wM * 1360, zmlab2.hM * 860,zmlab2.wM * 80, zmlab2.hM * 80)

    if zmlab2.PointerSystem.Data.HUDLogic then pcall(zmlab2.PointerSystem.Data.HUDLogic) end
end

function zmlab2.PointerSystem.PostDrawTranslucentRenderables()
    // Render Remove Material
    if zmlab2.PointerSystem.Data and IsValid(zmlab2.PointerSystem.Data.PreviewModel) and zmlab2.PointerSystem.Data.PreviewModel:GetNoDraw() == false then
        render.MaterialOverride(zmlab2.materials["highlight"])
        render.SetColorModulation((1 / 255) * zmlab2.PointerSystem.Data.MainColor.r, (1 / 255) * zmlab2.PointerSystem.Data.MainColor.g, (1 / 255) * zmlab2.PointerSystem.Data.MainColor.b)
        zmlab2.PointerSystem.Data.PreviewModel:DrawModel()
        render.MaterialOverride()
        render.SetColorModulation(1, 1, 1)
    end
end


local NextAction = CurTime()
function zmlab2.PointerSystem.Wait()
    NextAction = CurTime() + 0.25
end

local function LeftClick(func)
    if IsLeftClickDown == false and input.IsMouseDown(MOUSE_LEFT) == true then
        IsLeftClickDown = true

        pcall(func)

        zmlab2.PointerSystem.Wait()
    end
end

local function RightClick(func)
    if IsRightClickDown == false and input.IsMouseDown(MOUSE_RIGHT) == true then
        IsRightClickDown = true

        pcall(func)

        zmlab2.PointerSystem.Wait()
    end
end

function zmlab2.PointerSystem.MainLogic()

    // Stop if the player is dead
    if not IsValid(LocalPlayer()) or LocalPlayer():Alive() == false then
        zmlab2.PointerSystem.Stop()
        return
    end

    // Stop if the start entity got invalid
    if not IsValid(zmlab2.PointerSystem.Data.From) then
        zmlab2.PointerSystem.Stop()
        return
    end

    // Execute right click function, is mostlikely just cancel
    RightClick(function()

        zmlab2.PointerSystem.Stop()
        surface.PlaySound("UI/buttonclickrelease.wav")
        return
    end)

    // Trace for data
    local c_trace = zmlab2.util.TraceLine({
        start = LocalPlayer():EyePos(),
        endpos = LocalPlayer():EyePos() + LocalPlayer():EyeAngles():Forward() * 10000,
        filter = {LocalPlayer(),zmlab2.PointerSystem.Data.Ignore}
    }, "PointerSystemPointer")

    if c_trace.Hit then

        zmlab2.PointerSystem.Data.Pos = c_trace.HitPos
        zmlab2.PointerSystem.Data.HitEntity = c_trace.Entity
        zmlab2.PointerSystem.Data.HitNormal = c_trace.HitNormal

        if c_trace.HitNormal then
            zmlab2.PointerSystem.Data.Ang = c_trace.HitNormal:Angle()
            zmlab2.PointerSystem.Data.Ang:RotateAroundAxis(zmlab2.PointerSystem.Data.Ang:Right(),-90)
        end
    else
        zmlab2.PointerSystem.Data.Pos = nil
        zmlab2.PointerSystem.Data.HitEntity = nil
    end

    // If we have to wait then stop
    if NextAction > CurTime() then return end

    // Create Preview Model if none exist yet
    if not IsValid(zmlab2.PointerSystem.Data.PreviewModel) and zmlab2.PointerSystem.Data.Pos then
        CreateDummy(zmlab2.PointerSystem.Data.Pos, zmlab2.PointerSystem.Data.ModelOverwrite or "models/props_junk/PopCan01a.mdl")
        return
    end

    if zmlab2.PointerSystem.Data.Pos == nil then return end
    if zmlab2.PointerSystem.Data.Ang == nil then return end

    // Runs the main logic of the pointer system
    pcall(zmlab2.PointerSystem.Data.MainLogic)

    // Check if the user left clicked on a machine who wants the liquid
    LeftClick(function()
        pcall(zmlab2.PointerSystem.Data.OnLeftClick)
    end)
end

--PATH addons/_adminmodules/lua/ulx/xgui/bans.lua:
--Bans module for ULX GUI -- by Stickly Man!
--Manages banned users and shows ban details

xgui.prepareDataType( "bans" )

local xbans = xlib.makepanel{ parent=xgui.null }

xbans.banlist = xlib.makelistview{ x=5, y=30, w=572, h=310, multiselect=false, parent=xbans }
	xbans.banlist:AddColumn( "Name/SteamID" )
	xbans.banlist:AddColumn( "Banned By" )
	xbans.banlist:AddColumn( "Unban Date" )
	xbans.banlist:AddColumn( "Reason" )
xbans.banlist.DoDoubleClick = function( self, LineID, line )
	xbans.ShowBanDetailsWindow( xgui.data.bans.cache[LineID] )
end
xbans.banlist.OnRowRightClick = function( self, LineID, line )
	local menu = DermaMenu()
	menu:SetSkin(xgui.settings.skin)
	menu:AddOption( "Детали", function()
		if not line:IsValid() then return end
		xbans.ShowBanDetailsWindow( xgui.data.bans.cache[LineID] )
	end )
	menu:AddOption( "Редактировать", function()
		if not line:IsValid() then return end
		xgui.ShowBanWindow( nil, line:GetValue( 5 ), nil, true, xgui.data.bans.cache[LineID] )
	end )
	menu:AddOption( "Удалить", function()
		if not line:IsValid() then return end
		xbans.RemoveBan( line:GetValue( 5 ), xgui.data.bans.cache[LineID] )
	end )
	menu:Open()
end
-- Change the column sorting method to hook into our own custom sort stuff.
xbans.banlist.SortByColumn = function( self, ColumnID, Desc )
	local index =	ColumnID == 1 and 2 or	-- Sort by Name
					ColumnID == 2 and 4 or	-- Sort by Admin
					ColumnID == 3 and 6 or	-- Sort by Unban Date
					ColumnID == 4 and 5 or	-- Sort by Reason
									  1		-- Otherwise sort by Date
	xbans.sortbox:ChooseOptionID( index )
end

local searchFilter = ""
xbans.searchbox = xlib.maketextbox{ x=5, y=6, w=175, text="Search...", selectall=true, parent=xbans }
local txtCol = xbans.searchbox:GetTextColor() or Color( 0, 0, 0, 255 )
xbans.searchbox:SetTextColor( Color( txtCol.r, txtCol.g, txtCol.b, 196 ) ) -- Set initial color
xbans.searchbox.OnChange = function( pnl )
	if pnl:GetText() == "" then
		pnl:SetText( "Поиск" )
		pnl:SelectAll()
		pnl:SetTextColor( Color( txtCol.r, txtCol.g, txtCol.b, 196 ) )
	else
		pnl:SetTextColor( Color( txtCol.r, txtCol.g, txtCol.b, 255 ) )
	end
end
xbans.searchbox.OnLoseFocus = function( pnl )
	if pnl:GetText() == "Поиск" then
		searchFilter = ""
	else
		searchFilter = pnl:GetText()
	end
	xbans.setPage( 1 )
	xbans.retrieveBans()
	hook.Call( "OnTextEntryLoseFocus", nil, pnl )
end

local sortMode = 0
local sortAsc = false
xbans.sortbox = xlib.makecombobox{ x=185, y=6, w=150, text="Sort: Date (Desc.)", choices={ "Date", "Name", "Steam ID", "Admin", "Reason", "Unban Date", "Ban Length" }, parent=xbans }
function xbans.sortbox:OnSelect( i, v )
	if i-1 == sortMode then
		sortAsc = not sortAsc
	else
		sortMode = i-1
		sortAsc = false
	end
	self:SetValue( "Sort: " .. v .. (sortAsc and " (Asc.)" or " (Desc.)") )
	xbans.setPage( 1 )
	xbans.retrieveBans()
end

local hidePerma = 0
xlib.makebutton{ x=355, y=6, w=95, label="Перма: Показ", parent=xbans }.DoClick = function( self )
	hidePerma = hidePerma + 1
	if hidePerma == 1 then
		self:SetText( "Перма: Скрыт" )
	elseif hidePerma == 2 then
		self:SetText( "Перма: Только" )
	elseif hidePerma == 3 then
		hidePerma = 0
		self:SetText( "Перма: Показ" )
	end
	xbans.setPage( 1 )
	xbans.retrieveBans()
end

local hideIncomplete = 0
xlib.makebutton{ x=455, y=6, w=95, label="Incomplete: Show", parent=xbans, tooltip="Filters bans that are loaded by ULib, but do not have any metadata associated with them." }.DoClick = function( self )
	hideIncomplete = hideIncomplete + 1
	if hideIncomplete == 1 then
		self:SetText( "Incomplete: Hide" )
	elseif hideIncomplete == 2 then
		self:SetText( "Incomplete: Only" )
	elseif hideIncomplete == 3 then
		hideIncomplete = 0
		self:SetText( "Incomplete: Show" )
	end
	xbans.setPage( 1 )
	xbans.retrieveBans()
end


local function banUserList( doFreeze )
	local menu = DermaMenu()
	menu:SetSkin(xgui.settings.skin)
	for k, v in player.Iterator() do
		menu:AddOption( v:Nick(), function()
			if not v:IsValid() then return end
			xgui.ShowBanWindow( v, v:SteamID(), doFreeze )
		end )
	end
	menu:AddSpacer()
	if LocalPlayer():query("ulx banid") then menu:AddOption( "Ban by STEAMID...", function() xgui.ShowBanWindow() end ) end
	menu:Open()
end

xlib.makebutton{ x=5, y=340, w=70, label="Ban...", parent=xbans }.DoClick = function() banUserList( false ) end
xbans.btnFreezeBan = xlib.makebutton{ x=80, y=340, w=95, label="Freeze Ban...", parent=xbans }
xbans.btnFreezeBan.DoClick = function() banUserList( true ) end

xbans.infoLabel = xlib.makelabel{ x=204, y=344, label="Right-click on a ban for more options", parent=xbans }


xbans.resultCount = xlib.makelabel{ y=344, parent=xbans }
function xbans.setResultCount( count )
	local pnl = xbans.resultCount
	pnl:SetText( count .. " results" )
	pnl:SizeToContents()

	local width = pnl:GetWide()
	local x, y = pnl:GetPos()
	pnl:SetPos( 475 - width, y )

	local ix, iy = xbans.infoLabel:GetPos()
	xbans.infoLabel:SetPos( ( 130 - width ) / 2 + 175, y )
end

local numPages = 1
local pageNumber = 1
xbans.pgleft = xlib.makebutton{ x=480, y=340, w=20, icon="icon16/arrow_left.png", centericon=true, disabled=true, parent=xbans }
xbans.pgleft.DoClick = function()
	xbans.setPage( pageNumber - 1 )
	xbans.retrieveBans()
end
xbans.pageSelector = xlib.makecombobox{ x=500, y=340, w=57, text="1", enableinput=true, parent=xbans }
function xbans.pageSelector:OnSelect( index )
	xbans.setPage( index )
	xbans.retrieveBans()
end
function xbans.pageSelector.TextEntry:OnEnter()
	pg = math.Clamp( tonumber( self:GetValue() ) or 1, 1, numPages )
	xbans.setPage( pg )
	xbans.retrieveBans()
end
xbans.pgright = xlib.makebutton{ x=557, y=340, w=20, icon="icon16/arrow_right.png", centericon=true, disabled=true, parent=xbans }
xbans.pgright.DoClick = function()
	xbans.setPage( pageNumber + 1 )
	xbans.retrieveBans()
end

xbans.setPage = function( newPage )
	pageNumber = newPage
	xbans.pgleft:SetDisabled( pageNumber <= 1 )
	xbans.pgright:SetDisabled( pageNumber >= numPages )
	xbans.pageSelector.TextEntry:SetText( pageNumber )
end


function xbans.RemoveBan( ID, bandata )
	local tempstr = "<Unknown>"
	if bandata then tempstr = bandata.name or "<Unknown>" end
	Derma_Query( "Are you sure you would like to unban " .. tempstr .. " - " .. ID .. "?", "XGUI WARNING", 
		"Remove",	function()
						RunConsoleCommand( "ulx", "unban", ID ) 
						xbans.RemoveBanDetailsWindow( ID )
					end,
		"Cancel", 	function() end )
end

xbans.openWindows = {}
function xbans.RemoveBanDetailsWindow( ID )
	if xbans.openWindows[ID] then
		xbans.openWindows[ID]:Remove()
		xbans.openWindows[ID] = nil
	end
end

function xbans.ShowBanDetailsWindow( bandata )
	local wx, wy

	if not bandata then return end

	if xbans.openWindows[bandata.steamID] then
		wx, wy = xbans.openWindows[bandata.steamID]:GetPos()
		xbans.openWindows[bandata.steamID]:Remove()
	end
	xbans.openWindows[bandata.steamID] = xlib.makeframe{ label="Ban Details", x=wx, y=wy, w=285, h=295, skin=xgui.settings.skin }

	local panel = xbans.openWindows[bandata.steamID]
	local name = xlib.makelabel{ x=50, y=30, label="Name:", parent=panel }
	xlib.makelabel{ x=90, y=30, w=190, label=( bandata.name or "<Unknown>" ), parent=panel, tooltip=bandata.name }
	xlib.makelabel{ x=36, y=50, label="SteamID:", parent=panel }
	xlib.makelabel{ x=90, y=50, label=bandata.steamID, parent=panel }
	xlib.makelabel{ x=33, y=70, label="Ban Date:", parent=panel }
	xlib.makelabel{ x=90, y=70, label=bandata.time and ( os.date( "%b %d, %Y - %I:%M:%S %p", tonumber( bandata.time ) ) ) or "<This ban has no metadata>", parent=panel }
	xlib.makelabel{ x=20, y=90, label="Unban Date:", parent=panel }
	xlib.makelabel{ x=90, y=90, label=( tonumber( bandata.unban ) == 0 and "Never" or os.date( "%b %d, %Y - %I:%M:%S %p", math.min(  tonumber( bandata.unban ), 4294967295 ) ) ), parent=panel }
	xlib.makelabel{ x=10, y=110, label="Length of Ban:", parent=panel }
	xlib.makelabel{ x=90, y=110, label=( tonumber( bandata.unban ) == 0 and "Permanent" or xgui.ConvertTime( tonumber( bandata.unban ) - bandata.time ) ), parent=panel }
	xlib.makelabel{ x=33, y=130, label="Осталось:", parent=panel }
	local timeleft = xlib.makelabel{ x=90, y=130, label=( tonumber( bandata.unban ) == 0 and "N/A" or xgui.ConvertTime( tonumber( bandata.unban ) - os.time() ) ), parent=panel }
	xlib.makelabel{ x=26, y=150, label="Banned By:", parent=panel }
	if bandata.admin then xlib.makelabel{ x=90, y=150, label=string.gsub( bandata.admin, "%(STEAM_%w:%w:%w*%)", "" ), parent=panel } end
	if bandata.admin then xlib.makelabel{ x=90, y=165, label=string.match( bandata.admin, "%(STEAM_%w:%w:%w*%)" ), parent=panel } end
	xlib.makelabel{ x=41, y=185, label="Причина:", parent=panel }
	xlib.makelabel{ x=90, y=185, w=190, label=bandata.reason, parent=panel, tooltip=bandata.reason ~= "" and bandata.reason or nil }
	xlib.makelabel{ x=13, y=205, label="Last Updated:", parent=panel }
	xlib.makelabel{ x=90, y=205, label=( ( bandata.modified_time == nil ) and "Never" or os.date( "%b %d, %Y - %I:%M:%S %p", tonumber( bandata.modified_time ) ) ), parent=panel }
	xlib.makelabel{ x=21, y=225, label="Updated by:", parent=panel }
	if bandata.modified_admin then xlib.makelabel{ x=90, y=225, label=string.gsub( bandata.modified_admin, "%(STEAM_%w:%w:%w*%)", "" ), parent=panel } end
	if bandata.modified_admin then xlib.makelabel{ x=90, y=240, label=string.match( bandata.modified_admin, "%(STEAM_%w:%w:%w*%)" ), parent=panel } end

	panel.data = bandata	-- Store data on panel for future reference.
	xlib.makebutton{ x=5, y=265, w=89, label="Edit Ban...", parent=panel }.DoClick = function()
		xgui.ShowBanWindow( nil, panel.data.steamID, nil, true, panel.data )
	end

	xlib.makebutton{ x=99, y=265, w=89, label="Unban", parent=panel }.DoClick = function()
		xbans.RemoveBan( panel.data.steamID, panel.data )
	end

	xlib.makebutton{ x=192, y=265, w=88, label="Close", parent=panel }.DoClick = function()
		xbans.RemoveBanDetailsWindow( panel.data.steamID )
	end

	panel.btnClose.DoClick = function ( button )
		xbans.RemoveBanDetailsWindow( panel.data.steamID )
	end

	if timeleft:GetValue() ~= "N/A" then
		function panel.OnTimer()
			if panel:IsVisible() then
				local bantime = tonumber( panel.data.unban ) - os.time()
				if bantime <= 0 then
					xbans.RemoveBanDetailsWindow( panel.data.steamID )
					return
				else
					timeleft:SetText( xgui.ConvertTime( bantime ) )
				end
				timeleft:SizeToContents()
				timer.Simple( 1, panel.OnTimer )
			end
		end
		panel.OnTimer()
	end
end

function xgui.ShowBanWindow( ply, ID, doFreeze, isUpdate, bandata )
	if not LocalPlayer():query( "ulx ban" ) and not LocalPlayer():query( "ulx banid" ) then return end

	local xgui_banwindow = xlib.makeframe{ label=( isUpdate and "Edit Ban" or "Ban Player" ), w=285, h=180, skin=xgui.settings.skin }
	local reason = xlib.makecombobox{ x=75, y=80, w=200, parent=xgui_banwindow, enableinput=true, selectall=true, choices=ULib.cmds.translatedCmds["ulx ban"].args[4].completes }
	local banpanel = ULib.cmds.NumArg.x_getcontrol( ULib.cmds.translatedCmds["ulx ban"].args[3], 2, xgui_banwindow )
	banpanel.interval:SetParent( xgui_banwindow )
	banpanel.interval:SetPos( 200, 105 )
	banpanel.val:SetParent( xgui_banwindow )
	banpanel.val:SetPos( 75, 125 )
	banpanel.val:SetWidth( 200 )

	local name
	if not isUpdate then
		name = xlib.makecombobox{ x=75, y=30, w=200, parent=xgui_banwindow, enableinput=true, selectall=true }
		for k,v in player.Iterator() do
			name:AddChoice( v:Nick(), v:SteamID() )
		end
		name.OnSelect = function( self, index, value, data )
			self.steamIDbox:SetText( data )
		end
	else
		name = xlib.maketextbox{ x=75, y=30, w=200, parent=xgui_banwindow, selectall=true }
		if bandata then
			name:SetText( bandata.name or "" )
			reason:SetText( bandata.reason or "" )
			if tonumber( bandata.unban ) ~= 0 then
				local btime = ( tonumber( bandata.unban ) - tonumber( bandata.time ) )
				if btime % 31536000 == 0 then
					if #banpanel.interval.Choices >= 6 then
						banpanel.interval:ChooseOptionID(6)
					else
						banpanel.interval:SetText( "Лет" )
					end
					btime = btime / 31536000
				elseif btime % 604800 == 0 then
					if #banpanel.interval.Choices >= 5 then
						banpanel.interval:ChooseOptionID(5)
					else
						banpanel.interval:SetText( "Недель(и)" )
					end
					btime = btime / 604800
				elseif btime % 86400 == 0 then
					if #banpanel.interval.Choices >= 4 then
						banpanel.interval:ChooseOptionID(4)
					else
						banpanel.interval:SetText( "День" )
					end
					btime = btime / 86400
				elseif btime % 3600 == 0 then
					if #banpanel.interval.Choices >= 3 then
						banpanel.interval:ChooseOptionID(3)
					else
						banpanel.interval:SetText( "Час(ы)" )
					end
					btime = btime / 3600
				else
					btime = btime / 60
					if #banpanel.interval.Choices >= 2 then
						banpanel.interval:ChooseOptionID(2)
					else
						banpanel.interval:SetText( "Минут(ы)" )
					end
				end
				banpanel.val:SetValue( btime )
			end
		end
	end

	local steamID = xlib.maketextbox{ x=75, y=55, w=200, selectall=true, disabled=( isUpdate or not LocalPlayer():query( "ulx banid" ) ), parent=xgui_banwindow }
	name.steamIDbox = steamID --Make a reference to the steamID textbox so it can change the value easily without needing a global variable

	if doFreeze and ply then
		if LocalPlayer():query( "ulx freeze" ) then
			RunConsoleCommand( "ulx", "freeze", "$" .. ULib.getUniqueIDForPlayer( ply ) )
			steamID:SetDisabled( true )
			name:SetDisabled( true )
			xgui_banwindow:ShowCloseButton( false )
		else
			doFreeze = false
		end
	end
	xlib.makebutton{ x=165, y=150, w=75, label="Cancel", parent=xgui_banwindow }.DoClick = function()
		if doFreeze and ply and ply:IsValid() then
			RunConsoleCommand( "ulx", "unfreeze", "$" .. ULib.getUniqueIDForPlayer( ply ) )
		end
		xgui_banwindow:Remove()
	end
	xlib.makebutton{ x=45, y=150, w=75, label=( isUpdate and "Update" or "Ban!" ), parent=xgui_banwindow }.DoClick = function()
		if isUpdate then
			local function performUpdate(btime)
				RunConsoleCommand( "xgui", "updateBan", steamID:GetValue(), btime, reason:GetValue(), name:GetValue() )
				xgui_banwindow:Remove()
			end
			btime = banpanel:GetMinutes()
			if btime ~= 0 and bandata and btime * 60 + bandata.time < os.time() then
				Derma_Query( "WARNING! The new ban time you have specified will cause this ban to expire.\nThe minimum time required in order to change the ban length successfully is " 
						.. xgui.ConvertTime( os.time() - bandata.time ) .. ".\nAre you sure you wish to continue?", "XGUI WARNING",
					"Expire Ban", function()
						performUpdate(btime)
						xbans.RemoveBanDetailsWindow( bandata.steamID )
					end,
					"Cancel", function() end )
			else
				performUpdate(btime)
			end
			return
		end

		if ULib.isValidSteamID( steamID:GetValue() ) then
			local isOnline = false
			for k, v in player.Iterator() do
				if v:SteamID() == steamID:GetValue() then
					isOnline = v
					break
				end
			end
			if not isOnline then
				if name:GetValue() == "" then
					RunConsoleCommand( "ulx", "banid", steamID:GetValue(), banpanel:GetValue(), reason:GetValue() )
				else
					RunConsoleCommand( "xgui", "updateBan", steamID:GetValue(), banpanel:GetMinutes(), reason:GetValue(), ( name:GetValue() ~= "" and name:GetValue() or nil ) )
				end
			else
				RunConsoleCommand( "ulx", "ban", "$" .. ULib.getUniqueIDForPlayer( isOnline ), banpanel:GetValue(), reason:GetValue() )
			end
			xgui_banwindow:Remove()
		else
			local ply, message = ULib.getUser( name:GetValue() )
			if ply then
				RunConsoleCommand( "ulx", "ban", "$" .. ULib.getUniqueIDForPlayer( ply ), banpanel:GetValue(), reason:GetValue() )
				xgui_banwindow:Remove()
				return
			end
			Derma_Message( message )
		end
	end

	if ply then name:SetText( ply:Nick() ) end
	if ID then steamID:SetText( ID ) else steamID:SetText( "STEAM_0:" ) end
end

function xgui.ConvertTime( seconds )
	--Convert number of seconds remaining to something more legible (Thanks JamminR!)
	local years = math.floor( seconds / 31536000 )
	seconds = seconds - ( years * 31536000 )
	local weeks = math.floor( seconds / 604800 )
	seconds = seconds - ( weeks * 604800 )
	local days = math.floor( seconds / 86400 )
	seconds = seconds - ( days * 86400 )
	local hours = math.floor( seconds/3600 )
	seconds = seconds - ( hours * 3600 )
	local minutes = math.floor( seconds/60 )
	seconds = seconds - ( minutes * 60 )
	local curtime = ""
	if years ~= 0 then curtime = curtime .. years .. " лет" .. ( ( years > 1 ) and ", " or ", " ) end
	if weeks ~= 0 then curtime = curtime .. weeks .. " недель" .. ( ( weeks > 1 ) and ", " or ", " ) end
	if days ~= 0 then curtime = curtime .. days .. " дней" .. ( ( days > 1 ) and ", " or ", " ) end
	curtime = curtime .. ( ( hours < 10 ) and "0" or "" ) .. hours .. ":"
	curtime = curtime .. ( ( minutes < 10 ) and "0" or "" ) .. minutes .. ":"
	return curtime .. ( ( seconds < 10 and "0" or "" ) .. seconds )
end

---Update stuff
function xbans.bansRefreshed()
	xgui.data.bans.cache = {} -- Clear the bans cache

	-- Retrieve bans if XGUI is open, otherwise it will be loaded later.
	if xgui.anchor:IsVisible() then
		xbans.retrieveBans()
	end
end
xgui.hookEvent( "bans", "process", xbans.bansRefreshed, "bansRefresh" )

function xbans.banPageRecieved( data )
	xgui.data.bans.cache = data
	xbans.clearbans()
	xbans.populateBans()
end
xgui.hookEvent( "bans", "data", xbans.banPageRecieved, "bansGotPage" )

function xbans.checkCache()
	if xgui.data.bans.cache and xgui.data.bans.count ~= 0 and table.Count(xgui.data.bans.cache) == 0 then
		xbans.retrieveBans()
	end
end
xgui.hookEvent( "onOpen", nil, xbans.checkCache, "bansCheckCache" )

function xbans.clearbans()
	xbans.banlist:Clear()
end

function xbans.retrieveBans()
	RunConsoleCommand( "xgui", "getbans",
		sortMode,			-- Sort Type
		searchFilter,		-- Filter String
		hidePerma,			-- Hide permabans?
		hideIncomplete,		-- Hide bans that don't have full ULX metadata?
		pageNumber,			-- Page number
		sortAsc and 1 or 0)	-- Ascending/Descending
end

function xbans.populateBans()
	if xgui.data.bans.cache == nil then return end
	local cache = xgui.data.bans.cache
	local count = cache.count or xgui.data.bans.count
	numPages = math.max( 1, math.ceil( count / 17 ) )

	xbans.setResultCount( count )
	xbans.pageSelector:SetDisabled( numPages == 1 )
	xbans.pageSelector:Clear()
	for i=1, numPages do
		xbans.pageSelector:AddChoice(i)
	end
	xbans.setPage( math.Clamp( pageNumber, 1, numPages ) )

	cache.count = nil

	for _, baninfo in pairs( cache ) do
		xbans.banlist:AddLine( baninfo.name or baninfo.steamID,
					( baninfo.admin ) and string.gsub( baninfo.admin, "%(STEAM_%w:%w:%w*%)", "" ) or "",
					(( tonumber( baninfo.unban ) ~= 0 ) and os.date( "%c", math.min( tonumber( baninfo.unban ), 4294967295 ) )) or "Never",
					baninfo.reason,
					baninfo.steamID,
					tonumber( baninfo.unban ) )
	end
end
xbans.populateBans() --For autorefresh

function xbans.xban( ply, cmd, args, dofreeze )
	if args[1] and args[1] ~= "" then
		local target = ULib.getUser( args[1] )
		if target then
			xgui.ShowBanWindow( target, target:SteamID(), dofreeze )
		end
	else
		xgui.ShowBanWindow()
	end
end
ULib.cmds.addCommandClient( "xgui xban", xbans.xban )

function xbans.fban( ply, cmd, args )
	xbans.xban( ply, cmd, args, true )
end
ULib.cmds.addCommandClient( "xgui fban", xbans.fban )

function xbans.UCLChanged()
	xbans.btnFreezeBan:SetDisabled( not LocalPlayer():query("ulx freeze") )
end
-- hook.Add( "UCLChanged", "xgui_RefreshBansMenu", xbans.UCLChanged )

xgui.addModule( "Баны", xbans, "icon16/exclamation.png", "xgui_managebans" )

--PATH addons/_adminmodules/lua/ulx/xgui/commands.lua:

--Commands module (formerly players module) v2 for ULX GUI -- by Stickly Man!
--Handles all user-executable commands, such as kick, slay, ban, etc.

local cmds = xlib.makepanel{ parent=xgui.null }
cmds.selcmd = nil
cmds.mask = xlib.makepanel{ x=160, y=30, w=425, h=330, parent=cmds }
cmds.argslist = xlib.makelistlayout{ w=165, h=330, parent=cmds.mask }
cmds.argslist.secondaryPos = nil

cmds.argslist.scroll:SetVisible( false )

function cmds.argslist:Open( cmd, secondary )
	if secondary then
		if cmds.plist.open then
			cmds.plist:Close()
		elseif self.open then
			self:Close()
		end
	end
	self:openAnim( cmd, secondary )
	self.open = true
end
function cmds.argslist:Close()
	self:closeAnim( self.secondaryPos )
	self.open = false
end
cmds.plist = xlib.makelistview{ w=250, h=330, multiselect=true, parent=cmds.mask }
function cmds.plist:Open( arg )
	if cmds.argslist.secondaryPos == true then cmds.argslist:Close()
	elseif self.open then self:Close() end
	self:openAnim( arg )
	--Determine if the arguments should be visible after changing (If a valid player will be selected)
	local targets = cmds.calculateValidPlayers( arg )
	local playerWillBeSelected = false
	for _, line in ipairs( cmds.plist:GetSelected() ) do
		if table.HasValue( targets, line.ply ) then
			playerWillBeSelected = true
			break
		end
	end
	if playerWillBeSelected then
		cmds.argslist:Open( ULib.cmds.translatedCmds[arg.cmd], false )
	end
	self.open = true
end
function cmds.plist:Close()
	if cmds.argslist.open then cmds.argslist:Close() end
	self:closeAnim()
	self.open = false
end
cmds.plist.DoDoubleClick = function()
	cmds.runCmd( cmds.selcmd )
end
cmds.plist:SetVisible( false )
cmds.plist:AddColumn( "Ник" )
cmds.plist:AddColumn( "Привелегия" )

cmds.cmds = xlib.makelistlayout{ x=5, y=30, w=150, h=330, parent=cmds, padding=1, spacing=1 }
cmds.setselected = function( selcat, LineID )
	if selcat.Lines[LineID]:GetColumnText(2) == cmds.selcmd then
		selcat:ClearSelection()
		if cmds.plist.open then cmds.plist:Close() else cmds.argslist:Close() end
		xlib.animQueue_start()
		cmds.selcmd = nil
		return
	end

	for _, cat in pairs( cmds.cmd_contents ) do
		if cat ~= selcat then
			cat:ClearSelection()
		end
	end
	cmds.selcmd = selcat.Lines[LineID]:GetColumnText(2)
	if cmds.permissionChanged then cmds.refreshPlist() return end

	if xlib.animRunning then xlib.animQueue_forceStop() end

	local cmd = ULib.cmds.translatedCmds[cmds.selcmd]
	if cmd.args[2] and ( cmd.args[2].type == ULib.cmds.PlayersArg or cmd.args[2].type == ULib.cmds.PlayerArg ) then
		cmds.plist:Open( cmd.args[2] )
	else
		cmds.argslist:Open( cmd, true )
	end
	xlib.animQueue_start()
end

function cmds.refreshPlist( arg )
	if not arg then arg = ULib.cmds.translatedCmds[cmds.selcmd].args[2] end
	if not arg or ( arg.type ~= ULib.cmds.PlayersArg and arg.type ~= ULib.cmds.PlayerArg ) then return end

	local lastplys = {}
	for k, Line in pairs( cmds.plist.Lines ) do
		if ( Line:IsLineSelected() ) then table.insert( lastplys, Line:GetColumnText(1) ) end
	end

	local targets = cmds.calculateValidPlayers( arg )
	cmds.plist:Clear()
	cmds.plist:SetMultiSelect( arg.type == ULib.cmds.PlayersArg )
	for _, ply in ipairs( targets ) do
		local line = cmds.plist:AddLine( ply:Nick(), ply:GetUserGroup() )
		line.ply = ply
		line.OnSelect = function()
			if cmds.permissionChanged then return end

			if not xlib.animRunning and not cmds.argslist.open then
				cmds.argslist:Open( ULib.cmds.translatedCmds[cmds.selcmd], false )
				xlib.animQueue_start( )
			else
				if not cmds.clickedFlag then --Prevent this from happening multiple times.
					cmds.clickedFlag = true
					xlib.addToAnimQueue( function() if not cmds.argslist.open then
						cmds.argslist:Open( ULib.cmds.translatedCmds[cmds.selcmd], false ) end
						cmds.clickedFlag = nil end )
				end
			end
		end

		--Select previously selected Lines
		if table.HasValue( lastplys, ply:Nick() ) then
			cmds.plist:SelectItem( line )
		end
	end
	cmds.plist:SortByColumn( 1, false )
	--Select only the first item if multiselect is disabled.
	if not cmds.plist:GetMultiSelect() then
		local firstSelected = cmds.plist:GetSelected()[1]
		cmds.plist:ClearSelection()
		cmds.plist:SelectItem( firstSelected )
	end

	if not cmds.plist:GetSelectedLine() then
		if not xlib.animRunning then
			if cmds.argslist.open then
				cmds.argslist:Close()
				xlib.animQueue_start()
			end
		else
			if cmds.permissionChanged then
				xlib.addToAnimQueue( function() if cmds.argslist.open and cmds.plist.open then cmds.argslist:Close() end end )
			end
		end
	end
end

function cmds.calculateValidPlayers( arg )
	if not arg then arg = ULib.cmds.translatedCmds[cmds.selcmd].args[2] end

	local access, tag = LocalPlayer():query( arg.cmd )
	local restrictions = {}
	ULib.cmds.PlayerArg.processRestrictions( restrictions, LocalPlayer(), arg, ulx.getTagArgNum( tag, 1 ) )

	local targets = restrictions.restrictedTargets
	if targets == false then -- No one allowed
		targets = {}
	elseif targets == nil then -- Everyone allowed
		targets = player.GetAll()
	end
	return targets
end

function cmds.buildArgsList( cmd )
	cmds.argslist:Clear()
	cmds.curargs = {}
	local argnum = 0
	local zpos = 0
	local expectingplayers = cmd.args[2] and ( ( cmd.args[2].type == ULib.cmds.PlayersArg ) or ( cmd.args[2].type == ULib.cmds.PlayerArg ) ) or false
	for _, arg in ipairs( cmd.args ) do
		if not arg.type.invisible then
			argnum = argnum + 1
			if not ( argnum == 1 and expectingplayers ) then
				if arg.invisible ~= true then
					local curitem = arg
					if curitem.repeat_min then --This command repeats!
						local panel = xlib.makepanel{ h=20, parent=cmds.argslist }
						local choices = {}
						panel.argnum = argnum
						panel.xguiIgnore = true
						panel.arg = curitem
						panel.addbutton = xlib.makebutton{ label="Add", w=83, parent=panel }
						panel.addbutton.DoClick = function( self )
							local parent = self:GetParent()
							local ctrl = parent.arg.type.x_getcontrol( parent.arg, parent.argnum, cmds.argslist )
							cmds.argslist:Add( ctrl )
							ctrl:MoveToAfter( choices[#choices] )
							table.insert( choices, ctrl )
							table.insert( cmds.curargs, ctrl )
							panel.removebutton:SetDisabled( false )
							if parent.arg.repeat_max and #choices >= parent.arg.repeat_max then self:SetDisabled( true ) end
						end
						panel.removebutton = xlib.makebutton{ label="Remove", x=83, w=82, disabled=true, parent=panel }
						panel.removebutton.DoClick = function( self )
							local parent = self:GetParent()
							local ctrl = choices[#choices]
							ctrl:Remove()
							table.remove( choices )
							table.remove( cmds.curargs )
							panel.addbutton:SetDisabled( false )
							if #choices <= parent.arg.repeat_min then self:SetDisabled( true ) end
						end
						cmds.argslist:Add( panel )
						panel:SetZPos( zpos )
						zpos = zpos + 1
						for i=1,curitem.repeat_min do
							local ctrl = arg.type.x_getcontrol( arg, argnum, cmds.argslist )
							cmds.argslist:Add( ctrl )
							ctrl:SetZPos( zpos )
							zpos = zpos + 1
							table.insert( choices, ctrl )
							table.insert( cmds.curargs, ctrl )
						end
					else
						local panel = arg.type.x_getcontrol( arg, argnum, cmds.argslist )
						table.insert( cmds.curargs, panel )
						if curitem.type == ULib.cmds.NumArg then
							panel.TextArea.OnEnter = function( self )
								cmds.runCmd( cmd.cmd )
							end
						elseif curitem.type == ULib.cmds.StringArg then
							panel.OnEnter = function( self )
								cmds.runCmd( cmd.cmd )
							end
						end
						cmds.argslist:Add( panel )
						panel:SetZPos( zpos )
						zpos = zpos + 1
					end
				end
			end
		end
	end
	if LocalPlayer():query( cmd.cmd ) then
		local panel = xlib.makebutton{ label=cmd.cmd, parent=cmds.argslist }
		panel.xguiIgnore = true
		panel.DoClick = function()
			cmds.runCmd( cmd.cmd )
		end
		cmds.argslist:Add( panel )
		panel:SetZPos( zpos )
		zpos = zpos + 1
	end
	if cmd.opposite and LocalPlayer():query( cmd.opposite ) then
		local panel = xlib.makebutton{ label=cmd.opposite, parent=cmds.argslist }
		panel.DoClick = function()
			cmds.runCmd( cmd.opposite )
		end
		panel.xguiIgnore = true
		cmds.argslist:Add( panel )
		panel:SetZPos( zpos )
		zpos = zpos + 1
	end
	if cmd.helpStr then --If the command has a string for help
		local panel = xlib.makelabel{ w=160, label=cmd.helpStr, wordwrap=true, parent=cmds.argslist }
		panel.xguiIgnore = true
		cmds.argslist:Add( panel )
		panel:SetZPos( zpos )
		zpos = zpos + 1
	end
end

function cmds.runCmd( cmd )

	local cmd = string.Explode( " ", cmd )
	if cmds.plist:IsVisible() then
		local plys = {}
		for _, line in ipairs( cmds.plist:GetSelected() ) do
			table.insert( plys, "$" .. ULib.getUniqueIDForPlayer( line.ply ) )
			table.insert( plys, "," )
		end
		table.remove( plys ) --Removes the final comma
		table.insert( cmd, table.concat( plys ) )
	end

	for _, arg in ipairs( cmds.curargs ) do
		if not arg.xguiIgnore then
			table.insert( cmd, arg:GetValue() )
		end
	end
	RunConsoleCommand( unpack( cmd ) )
end

function cmds.playerNameChanged( ply, old, new )
	for i, line in ipairs( cmds.plist.Lines ) do
		if line:GetColumnText(1) == old then
			line:SetColumnText( 1, new )
		end
	end
end

cmds.refresh = function( permissionChanged )
	local lastcmd = cmds.selcmd
	cmds.cmds:Clear()
	cmds.cmd_contents = {}
	cmds.expandedcat = nil
	cmds.selcmd = nil
	cmds.permissionChanged = true

	local newcategories = {}
	local sortcategories = {}
	local matchedCmdFound = false
	for cmd, data in pairs( ULib.cmds.translatedCmds ) do
		local opposite = data.opposite
		if opposite ~= cmd and ( LocalPlayer():query( data.cmd ) or (opposite and LocalPlayer():query( opposite ) )) then
			local catname = data.category
			if catname == nil or catname == "" then catname = "Остальное" end
			if not cmds.cmd_contents[catname] then
				--Make a new category
				cmds.cmd_contents[catname] = xlib.makelistview{ headerheight=0, multiselect=false, h=136 }
				cmds.cmd_contents[catname].OnRowSelected = function( self, LineID ) cmds.setselected( self, LineID ) end
				cmds.cmd_contents[catname]:AddColumn( "" )
				local cat = xlib.makecat{ label=catname, contents=cmds.cmd_contents[catname], expanded=false, parent=xgui.null }
				function cat.Header:OnMousePressed( mcode )
					if ( mcode == MOUSE_LEFT ) then
						self:GetParent():Toggle()
						if cmds.expandedcat then
							if cmds.expandedcat ~= self:GetParent() then
								cmds.expandedcat:Toggle()
							else
								cmds.expandedcat = nil
								return
							end
						end
						cmds.expandedcat = self:GetParent()
						return
					end
					return self:GetParent():OnMousePressed( mcode )
				end
				newcategories[catname] = cat
				table.insert( sortcategories, catname )
			end
			local line = cmds.cmd_contents[catname]:AddLine( string.gsub( data.cmd, "ulx ", "" ), data.cmd )
			if data.cmd == lastcmd then
				cmds.cmd_contents[catname]:SelectItem( line )
				cmds.expandedcat = cmds.cmd_contents[catname]:GetParent()
				cmds.expandedcat:SetExpanded( true )
				matchedCmdFound = true
			end
		end
	end
	if not matchedCmdFound then
		if cmds.plist.open then
			cmds.plist:Close()
			xlib.animQueue_start()
		elseif cmds.argslist.open then
			cmds.argslist:Close()
			xlib.animQueue_start()
		end
	end

	table.sort( sortcategories )
	for _, catname in ipairs( sortcategories ) do
		local cat = newcategories[catname]
		cmds.cmds:Add( cat )
		cat.Contents:SortByColumn( 1 )
		cat.Contents:SetHeight( 17*#cat.Contents:GetLines() )
	end
	cmds.permissionChanged = nil
end

--------------
--ANIMATIONS--
--------------
function cmds.plist:openAnim( arg )
	xlib.addToAnimQueue( cmds.refreshPlist, arg )
	xlib.addToAnimQueue( "pnlSlide", { panel=self, startx=-250, starty=0, endx=0, endy=0, setvisible=true } )
end

function cmds.plist:closeAnim()
	xlib.addToAnimQueue( "pnlSlide", { panel=self, startx=0, starty=0, endx=-250, endy=0, setvisible=false } )
end

function cmds.argslist:openAnim( cmd, secondary )
	xlib.addToAnimQueue( function() cmds.argslist.secondaryPos = secondary end )
	xlib.addToAnimQueue( cmds.buildArgsList, cmd )
	if secondary then
		xlib.addToAnimQueue( "pnlSlide", { panel=self.scroll, startx=-170, starty=0, endx=0, endy=0, setvisible=true } )
	else
		xlib.addToAnimQueue( "pnlSlide", { panel=self.scroll, startx=80, starty=0, endx=255, endy=0, setvisible=true } )
	end
end

function cmds.argslist:closeAnim( secondary )
	if secondary then
		xlib.addToAnimQueue( "pnlSlide", { panel=self.scroll, startx=0, starty=0, endx=-170, endy=0, setvisible=false } )
	else
		xlib.addToAnimQueue( "pnlSlide", { panel=self.scroll, startx=255, starty=0, endx=80, endy=0, setvisible=false } )
	end
	xlib.addToAnimQueue( function() cmds.argslist.secondaryPos = nil end )
end
--------------

-- cmds.refresh()
-- hook.Add( "UCLChanged", "xgui_RefreshPlayerCmds", cmds.refresh )
-- hook.Add( "ULibPlayerNameChanged", "xgui_plyUpdateCmds", cmds.playerNameChanged )
xgui.addModule( "Функции", cmds, "icon16/user_gray.png" )

--PATH addons/_adminmodules/lua/ulx/xgui/settings.lua:
--Settings module v2 for ULX GUI -- by Stickly Man!
--This bit of code is the base for holding the various settings modules.

local settings = xlib.makepanel{ parent=xgui.null }

local autorefreshTab
if xgui.settings_tabs != nil then autorefreshTab = xgui.settings_tabs:GetActiveTab() end

xgui.settings_tabs = xlib.makepropertysheet{ x=-5, y=6, w=600, h=368, parent=settings, offloadparent=xgui.null }
function xgui.settings_tabs:SetActiveTab( active, ignoreAnim )
	if ( self.m_pActiveTab == active ) then return end
	if ( self.m_pActiveTab ) then
		if not ignoreAnim then
			xlib.addToAnimQueue( "pnlFade", { panelOut=self.m_pActiveTab:GetPanel(), panelIn=active:GetPanel() } )
		else
			--Run this when module permissions have changed.
			xlib.addToAnimQueue( "pnlFade", { panelOut=nil, panelIn=active:GetPanel() }, 0 )
		end
		xlib.animQueue_start()
	end
	self.m_pActiveTab = active
	self:InvalidateLayout()
end

local func = xgui.settings_tabs.PerformLayout
xgui.settings_tabs.PerformLayout = function( self )
	func( self )
	self.tabScroller:SetPos( 10, 0 )
	self.tabScroller:SetWide( 555 ) --Make the tabs smaller to accommodate for the X button at the top-right corner.
end

if autorefreshTab != nil then
	xgui.settings_tabs:SetActiveTab( autorefreshTab, true )
end

xgui.addModule( "Настройки", settings, "icon16/wrench.png" )
--PATH addons/_adminmodules/lua/ulx/xgui/settings/client.lua:
--Client settings module for ULX GUI -- by Stickly Man!
--A settings module for modifing XGUI-based settings, and allows for modules to add clientside setting here.

local client = xlib.makepanel{ parent=xgui.null }

client.panel = xlib.makepanel{ x=160, y=5, w=425, h=322, parent=client }

client.catList = xlib.makelistview{ x=5, y=5, w=150, h=302, parent=client }
client.catList:AddColumn( "Настройки" )
client.catList.Columns[1].DoClick = function() end
client.catList.OnRowSelected = function( self, LineID, Line )
	local nPanel = xgui.modules.submodule[Line:GetValue(2)].panel
	if nPanel ~= client.curPanel then
		nPanel:SetZPos( 0 )
		xlib.addToAnimQueue( "pnlSlide", { panel=nPanel, startx=-435, starty=0, endx=0, endy=0, setvisible=true } )
		if client.curPanel then
			client.curPanel:SetZPos( -1 )
			xlib.addToAnimQueue( client.curPanel.SetVisible, client.curPanel, false )
		end
		xlib.animQueue_start()
		client.curPanel = nPanel
	else
		xlib.addToAnimQueue( "pnlSlide", { panel=nPanel, startx=0, starty=0, endx=-435, endy=0, setvisible=false } )
		self:ClearSelection()
		client.curPanel = nil
		xlib.animQueue_start()
	end
	if nPanel.onOpen then nPanel.onOpen() end --If the panel has it, call a function when it's opened
end

xlib.makebutton{ x=5, y=307, w=150, label="Сохранить", parent=client }.DoClick=function()
	xgui.saveClientSettings()
end

function xgui.openClientModule( name )
	name = string.lower( name )
	for i = 1, #xgui.modules.submodule do
		local module = xgui.modules.submodule[i]
		if module.mtype == "client" and string.lower(module.name) == name then
			if module.panel ~= client.curPanel then
				client.catList:ClearSelection()
				for i=1, #client.catList.Lines do
					local line = client.catList.Lines[i]
					if string.lower(line:GetColumnText(1)) == name then
						client.catList:SelectItem( line )
						break
					end
				end
			end
			break
		end
	end
end

--Process modular settings
function client.processModules()
	client.catList:Clear()
	for i, module in ipairs( xgui.modules.submodule ) do
		if module.mtype == "client" and ( not module.access or LocalPlayer():query( module.access ) ) then
			local x,y = module.panel:GetSize()
			if x == y and y == 0 then module.panel:SetSize( 425, 327 ) end
			module.panel:SetParent( client.panel )
			local line = client.catList:AddLine( module.name, i )
			if ( module.panel == client.curPanel ) then
				client.curPanel = nil
				client.catList:SelectItem( line )
			else
				module.panel:SetVisible( false )
			end
		end
	end
	client.catList:SortByColumn( 1, false )
end
client.processModules()

xgui.hookEvent( "onProcessModules", nil, client.processModules, "xguiProcessModules" )
xgui.addSettingModule( "Настройки", client, "icon16/layout_content.png" )


--------------------General Clientside Module--------------------
local genpnl = xlib.makepanel{ parent=xgui.null }

genpnl.pickupplayers = xlib.makecheckbox{ x=10, y=10, w=150, label="Вкл/выкл возможность подьема физганом игрока", convar="cl_pickupplayers", parent=genpnl }
function genpnl.processModules()
	genpnl.pickupplayers:SetDisabled( not LocalPlayer():query( "ulx physgunplayer" ) )
end

xgui.hookEvent( "onProcessModules", nil, genpnl.processModules, "clientGeneralProcessModules" )
xgui.addSubModule( "Физган", genpnl, nil, "client" )
--[[

--------------------XGUI Clientside Module--------------------
local xguipnl = xlib.makepanel{ parent=xgui.null }
xlib.makebutton{ x=10, y=10, w=150, label="Refresh XGUI Modules", parent=xguipnl }.DoClick=function()
	xgui.processModules()
end
local databutton = xlib.makebutton{ x=10, y=30, w=150, label="Refresh Server Data", parent=xguipnl }
databutton.DoClick=function( self )
	if xgui.offlineMode then
		self:SetDisabled( true )
		RunConsoleCommand( "_xgui", "getInstalled" )
		timer.Simple( 10, function() self:SetDisabled( false ) end )
	else
		if xgui.isInstalled then  --We can't be in offline mode to do this
			self:SetDisabled( true )
			RunConsoleCommand( "xgui", "refreshdata" )
			timer.Simple( 10, function() self:SetDisabled( false ) end )
		end
	end
end
xlib.makelabel{ x=10, y=55, label="Animation transition time:", parent=xguipnl }
xlib.makeslider{ x=10, y=70, w=150, label="<--->", max=2, value=xgui.settings.animTime, decimal=2, parent=xguipnl }.OnValueChanged = function( self, val )
	local testval = math.Clamp( tonumber( val ), 0, 2 )
	if testval ~= tonumber( val ) then self:SetValue( testval ) end
	xgui.settings.animTime = tonumber( val )
end
xlib.makecheckbox{ x=10, y=97, w=150, label="Show Startup Messages", value=xgui.settings.showLoadMsgs, parent=xguipnl }.OnChange = function( self, bVal )
	xgui.settings.showLoadMsgs = bVal
end
xlib.makelabel{ x=10, y=120, label="Infobar color:", parent=xguipnl }

xlib.makecolorpicker{ x=10, y=135, color=xgui.settings.infoColor, addalpha=true, alphamodetwo=true, parent=xguipnl }.OnChangeImmediate = function( self, color )
	xgui.settings.infoColor = color
end

----------------
--SKIN MANAGER--
----------------
xlib.makelabel{ x=10, y=273, label="Derma Theme:", parent=xguipnl }
xguipnl.skinselect = xlib.makecombobox{ x=10, y=290, w=150, parent=xguipnl }
if not derma.SkinList[xgui.settings.skin] then
	xgui.settings.skin = "Default"
end
xguipnl.skinselect:SetText( derma.SkinList[xgui.settings.skin].PrintName )
xgui.base.refreshSkin = true
xguipnl.skinselect.OnSelect = function( self, index, value, data )
	xgui.settings.skin = data
	xgui.base:SetSkin( data )
end
for skin, skindata in pairs( derma.SkinList ) do
	xguipnl.skinselect:AddChoice( skindata.PrintName, skin )
end

----------------
--TAB ORDERING--
----------------
xguipnl.mainorder = xlib.makelistview{ x=175, y=10, w=115, h=110, parent=xguipnl }
xguipnl.mainorder:AddColumn( "Main Modules" )
xguipnl.mainorder.OnRowSelected = function( self, LineID, Line )
	xguipnl.upbtnM:SetDisabled( LineID <= 1 )
	xguipnl.downbtnM:SetDisabled( LineID >= #xgui.settings.moduleOrder )
end
xguipnl.updateMainOrder = function()
	local selected = xguipnl.mainorder:GetSelectedLine() and xguipnl.mainorder:GetSelected()[1]:GetColumnText(1)
	xguipnl.mainorder:Clear()
	for i, v in ipairs( xgui.settings.moduleOrder ) do
		local found = false
		for _, tab in pairs( xgui.modules.tab ) do
			if tab.name == v then
				found = true
				break
			end
		end
		if found then
			local l = xguipnl.mainorder:AddLine( v )
			if v == selected then xguipnl.mainorder:SelectItem( l ) end
		else
			table.remove( xgui.settings.moduleOrder, i )
		end
	end
end
xgui.hookEvent( "onProcessModules", nil, xguipnl.updateMainOrder, "clientXGUIUpdateTabOrder" )
xguipnl.upbtnM = xlib.makebutton{ x=250, y=120, w=20, icon="icon16/bullet_arrow_up.png", centericon=true, disabled=true, parent=xguipnl }
xguipnl.upbtnM.DoClick = function( self )
	self:SetDisabled( true )
	local i = xguipnl.mainorder:GetSelectedLine()
	table.insert( xgui.settings.moduleOrder, i-1, xgui.settings.moduleOrder[i] )
	table.remove( xgui.settings.moduleOrder, i+1 )
	xgui.processModules()
end
xguipnl.downbtnM = xlib.makebutton{ x=270, y=120, w=20, icon="icon16/bullet_arrow_down.png", centericon=true, disabled=true, parent=xguipnl }
xguipnl.downbtnM.DoClick = function( self )
	self:SetDisabled( true )
	local i = xguipnl.mainorder:GetSelectedLine()
	table.insert( xgui.settings.moduleOrder, i+2, xgui.settings.moduleOrder[i] )
	table.remove( xgui.settings.moduleOrder, i )
	xgui.processModules()
end


xguipnl.settingorder = xlib.makelistview{ x=300, y=10, w=115, h=110, parent=xguipnl }
xguipnl.settingorder:AddColumn( "Setting Modules" )
xguipnl.settingorder.OnRowSelected = function( self, LineID, Line )
	xguipnl.upbtnS:SetDisabled( LineID <= 1 )
	xguipnl.downbtnS:SetDisabled( LineID >= #xgui.settings.settingOrder )
end
xguipnl.updateSettingOrder = function()
	local selected = xguipnl.settingorder:GetSelectedLine() and xguipnl.settingorder:GetSelected()[1]:GetColumnText(1)
	xguipnl.settingorder:Clear()
	for i, v in ipairs( xgui.settings.settingOrder ) do
		local found = false
		for _, tab in pairs( xgui.modules.setting ) do
			if tab.name == v then
				found = true
				break
			end
		end
		if found then
			local l = xguipnl.settingorder:AddLine( v )
			if v == selected then xguipnl.settingorder:SelectItem( l ) end
		else
			table.remove( xgui.settings.settingOrder, i )
		end
	end
end
xgui.hookEvent( "onProcessModules", nil, xguipnl.updateSettingOrder, "clientXGUIUpdateSettingOrder" )
xguipnl.upbtnS = xlib.makebutton{ x=395, y=120, w=20, icon="icon16/bullet_arrow_up.png", centericon=true, disabled=true, parent=xguipnl }
xguipnl.upbtnS.DoClick = function( self )
	self:SetDisabled( true )
	local i = xguipnl.settingorder:GetSelectedLine()
	table.insert( xgui.settings.settingOrder, i-1, xgui.settings.settingOrder[i] )
	table.remove( xgui.settings.settingOrder, i+1 )
	xgui.processModules()
end
xguipnl.downbtnS = xlib.makebutton{ x=375, y=120, w=20, icon="icon16/bullet_arrow_down.png", centericon=true, disabled=true, parent=xguipnl }
xguipnl.downbtnS.DoClick = function( self )
	self:SetDisabled( true )
	local i = xguipnl.settingorder:GetSelectedLine()
	table.insert( xgui.settings.settingOrder, i+2, xgui.settings.settingOrder[i] )
	table.remove( xgui.settings.settingOrder, i )
	xgui.processModules()
end

--------------------
--XGUI POSITIONING--
--------------------
xlib.makelabel{ x=175, y=145, label="XGUI Positioning:", parent=xguipnl }
local pos = tonumber( xgui.settings.xguipos.pos )
xguipnl.b7 = xlib.makebutton{ x=175, y=160, w=20, disabled=pos==7, parent=xguipnl }
xguipnl.b7.DoClick = function( self ) xguipnl.updatePos( 7 ) end
xguipnl.b8 = xlib.makebutton{ x=195, y=160, w=20, icon="icon16/arrow_up.png", centericon=true, disabled=pos==8, parent=xguipnl }
xguipnl.b8.DoClick = function( self ) xguipnl.updatePos( 8 ) end
xguipnl.b9 = xlib.makebutton{ x=215, y=160, w=20, disabled=pos==9, parent=xguipnl }
xguipnl.b9.DoClick = function( self ) xguipnl.updatePos( 9 ) end
xguipnl.b4 = xlib.makebutton{ x=175, y=180, w=20, icon="icon16/arrow_left.png", centericon=true, disabled=pos==4, parent=xguipnl }
xguipnl.b4.DoClick = function( self ) xguipnl.updatePos( 4 ) end
xguipnl.b5 = xlib.makebutton{ x=195, y=180, w=20, icon="icon16/bullet_green.png", centericon=true, disabled=pos==5, parent=xguipnl }
xguipnl.b5.DoClick = function( self ) xguipnl.updatePos( 5 ) end
xguipnl.b6 = xlib.makebutton{ x=215, y=180, w=20, icon="icon16/arrow_right.png", centericon=true, disabled=pos==6, parent=xguipnl }
xguipnl.b6.DoClick = function( self ) xguipnl.updatePos( 6 ) end
xguipnl.b1 = xlib.makebutton{ x=175, y=200, w=20, disabled=pos==1, parent=xguipnl }
xguipnl.b1.DoClick = function( self ) xguipnl.updatePos( 1 ) end
xguipnl.b2 = xlib.makebutton{ x=195, y=200, w=20, icon="icon16/arrow_down.png", centericon=true, disabled=pos==2, parent=xguipnl }
xguipnl.b2.DoClick = function( self ) xguipnl.updatePos( 2 ) end
xguipnl.b3 = xlib.makebutton{ x=215, y=200, w=20, disabled=pos==3, parent=xguipnl }
xguipnl.b3.DoClick = function( self ) xguipnl.updatePos( 3 ) end

function xguipnl.updatePos( position, xoffset, yoffset, ignoreanim )
	position = position or 5
	xoffset = xoffset or tonumber( xgui.settings.xguipos.xoff )
	yoffset = yoffset or tonumber( xgui.settings.xguipos.yoff )
	xgui.settings.xguipos = { pos=position, xoff=xoffset, yoff=yoffset }
	xgui.SetPos( position, xoffset, yoffset, ignoreanim )
	xguipnl.b1:SetDisabled( position==1 )
	xguipnl.b2:SetDisabled( position==2 )
	xguipnl.b3:SetDisabled( position==3 )
	xguipnl.b4:SetDisabled( position==4 )
	xguipnl.b5:SetDisabled( position==5 )
	xguipnl.b6:SetDisabled( position==6 )
	xguipnl.b7:SetDisabled( position==7 )
	xguipnl.b8:SetDisabled( position==8 )
	xguipnl.b9:SetDisabled( position==9 )
end

xguipnl.xwang = xlib.makenumberwang{ x=245, y=167, w=50, min=-1000, max=1000, value=xgui.settings.xguipos.xoff, decimal=0, parent=xguipnl }
xguipnl.xwang.OnValueChanged = function( self, val )
	xguipnl.updatePos( xgui.settings.xguipos.pos, tonumber( val ), xgui.settings.xguipos.yoffset, true )
end
xguipnl.xwang.OnEnter = function( self )
	local val = tonumber( self:GetValue() )
	if not val then val = 0 end
	xguipnl.updatePos( xgui.settings.xguipos.pos, tonumber( val ), xgui.settings.xguipos.yoffset )
end
xguipnl.xwang.OnLoseFocus = function( self )
	hook.Call( "OnTextEntryLoseFocus", nil, self )
	self:OnEnter()
end
xlib.makelabel{ x=300, y=169, label="X Offset", parent=xguipnl }

xguipnl.ywang = xlib.makenumberwang{ x=245, y=193, w=50, min=-1000, max=1000, value=xgui.settings.xguipos.yoff, decimal=0, parent=xguipnl }
xguipnl.ywang.OnValueChanged = function( self, val )
	xguipnl.updatePos( xgui.settings.xguipos.pos, xgui.settings.xguipos.xoffset, tonumber( val ), true )
end
xguipnl.ywang.OnEnter = function( self )
	local val = tonumber( self:GetValue() )
	if not val then val = 0 end
	xguipnl.updatePos( xgui.settings.xguipos.pos, xgui.settings.xguipos.xoffset, tonumber( val ) )
end
xguipnl.ywang.OnLoseFocus = function( self )
	hook.Call( "OnTextEntryLoseFocus", nil, self )
	self:OnEnter()
end
xlib.makelabel{ x=300, y=195, label="Y Offset", parent=xguipnl }

-------------------------
--OPEN/CLOSE ANIMATIONS--
-------------------------
xlib.makelabel{ x=175, y=229, label="XGUI Animations:", parent=xguipnl }
xlib.makelabel{ x=175, y=247, label="On Open:", parent=xguipnl }
xguipnl.inAnim = xlib.makecombobox{ x=225, y=245, w=150, choices={ "Fade In", "Slide From Top", "Slide From Left", "Slide From Bottom", "Slide From Right" }, parent=xguipnl }
xguipnl.inAnim:ChooseOptionID( tonumber( xgui.settings.animIntype ) )
function xguipnl.inAnim:OnSelect( index, value, data )
	xgui.settings.animIntype = index
end
xlib.makelabel{ x=175, y=272, label="On Close:", parent=xguipnl }
xguipnl.outAnim = xlib.makecombobox{ x=225, y=270, w=150, choices={ "Fade Out", "Slide To Top", "Slide To Left", "Slide To Bottom", "Slide To Right" }, parent=xguipnl }
xguipnl.outAnim:ChooseOptionID( tonumber( xgui.settings.animOuttype ) )
function xguipnl.outAnim:OnSelect( index, value, data )
	xgui.settings.animOuttype = index
end

xgui.addSubModule( "XGUI Settings", xguipnl, nil, "client" )
--]]
--PATH addons/zeros_weedfarm/lua/zweedfarm/sh/zwf_debug.lua:
zwf = zwf or {}
zwf.f = zwf.f or {}

// Used for Debug
function zwf.f.Debug(mgs)
	if zwf.config.Debug then
		if istable(mgs) then
			print("[    DEBUG    ] Table Start >")
			PrintTable(mgs)
			print("[    DEBUG    ] Table End <")
		else
			print("[    DEBUG    ] " .. mgs)
		end
	end
end

function zwf.f.Debug_Sphere(pos,size,lifetime,color,ignorez)
	if zwf.config.Debug then
		debugoverlay.Sphere( pos, size, lifetime, color, ignorez )
	end
end

if SERVER then
    concommand.Add("zwf_debug_ent", function(ply, cmd, args)
        if zwf.f.IsAdmin(ply) then
            local tr = ply:GetEyeTrace()

            if tr.Hit and IsValid(tr.Entity) then
                if tr.Entity:GetClass() == "zwf_generator" then
                    print("Fuel: " .. tr.Entity:GetFuel())
                    print("AnimState: " .. tostring(tr.Entity:GetAnimState()))
                    print("Output: " .. tostring(tr.Entity:GetOutput()))
                elseif tr.Entity:GetClass() == "zwf_lamp" then
                    print("Power: " .. tr.Entity:GetPower())
                    print("Output: " .. tostring(tr.Entity:GetOutput()))
                elseif tr.Entity:GetClass() == "zwf_weedstick" then
                    print("Perf_Time: " .. tr.Entity.perf_time)
                    print("Perf_Amount: " .. tr.Entity.perf_amount)
                    print("Perf_THC: " .. tr.Entity.perf_thc)
                elseif tr.Entity:GetClass() == "zwf_jar" then
                    print("Perf_Time: " .. tr.Entity:GetPerf_Time())
                    print("Perf_Amount: " .. tr.Entity:GetPerf_Amount())
                    print("Perf_THC: " .. tr.Entity:GetPerf_THC())
                elseif tr.Entity:GetClass() == "zwf_ventilator" then
                    print("Power: " .. tr.Entity:GetPower())
                    print("Output: " .. tostring(tr.Entity:GetOutput()))
                    print("PowerSource: " .. tostring(tr.Entity:GetPowerSource()))
                elseif tr.Entity:GetClass() == "zwf_outlet" then
                    print("Power: " .. tr.Entity:GetPower())
                    print("PowerSource: " .. tostring(tr.Entity:GetPowerSource()))
                    print("Output01: " .. tostring(tr.Entity:GetOutput01()))
                    print("Output02: " .. tostring(tr.Entity:GetOutput02()))
                    print("Output03: " .. tostring(tr.Entity:GetOutput03()))
                elseif tr.Entity:GetClass() == "zwf_pot" or tr.Entity:GetClass() == "zwf_pot_hydro" then
                    print("Entity: " .. tostring(tr.Entity))
                    print("HasSoil: " .. tostring(tr.Entity:GetHasSoil()))
                    print("WaterSource: " .. tostring(tr.Entity:GetWaterSource()))
                    print("Output: " .. tostring(tr.Entity:GetOutput()))
                    print("Current_Water: " .. tr.Entity:GetWater())
                    print("PerfectProgress: " .. tr.Entity:GetPerfectProgress())

                    if tr.Entity:GetSeed() > 0 then
                        local grow_Data = zwf.config.Plants[tr.Entity:GetSeed()].Grow
                        local current_Water = tr.Entity:GetWater()
                        // Calculates the minimum water level we need to have in order to increase the YieldAmount
                        local MaxWaterLevel = 0.9 - ((0.4 / 10) * grow_Data.Difficulty)
                        MaxWaterLevel = math.Clamp(MaxWaterLevel, 0.5, 0.9)
                        MaxWaterLevel = MaxWaterLevel * zwf.config.Flowerpot.Water_Capacity
                        // Calculate the maximal water level allowed
                        local MinWaterLevel = 0.1 + (0.35 / 10) * grow_Data.Difficulty
                        MinWaterLevel = math.Clamp(MinWaterLevel, 0.1, 0.45)
                        MinWaterLevel = MinWaterLevel * zwf.config.Flowerpot.Water_Capacity
                        print("MaxWaterLevel: " .. MaxWaterLevel)
                        print("MinWaterLevel: " .. MinWaterLevel)
                        print("Current_Water: " .. current_Water)
                        zwf.f.Flowerpot_GetGrowPerformance(tr.Entity)
                    end
                end
            end
        end
    end)

    // Adds a seed with the provided data to the seedbank or player you are looking at
    // zwf_addseed Weed_ID Weed_Name Perf_Time Perf_Amount Perf_THC
    concommand.Add("zwf_addseed", function(ply, cmd, args)
        if zwf.f.IsAdmin(ply) then

            local tr = ply:GetEyeTrace()

            if tr.Hit and IsValid(tr.Entity) then

                local sb_owner

                if tr.Entity:GetClass() == "zwf_seed_bank" then
                    sb_owner = zwf.f.GetOwner(tr.Entity)
                elseif tr.Entity:IsPlayer() then
                    sb_owner = tr.Entity
                else
                    return
                end


                if not IsValid(sb_owner) then
                    zwf.f.Notify(ply, "This seedbank doesent have a owner!", 1)

                    return
                end



                if table.Count(sb_owner.zwf_seedbank) >= zwf.config.SeedBank.Limit then
                    zwf.f.Notify(ply, "Seedbank inventory limit reached!", 1)

                    return
                end


                local _weedid = tonumber(args[1])
                if _weedid == nil then
                    zwf.f.Notify(ply, "The provided weed id is not a number!", 1)

                    return
                end
                if zwf.config.Plants[_weedid] == nil then
                    zwf.f.Notify(ply, "The provided weed id doesent exist in the plant config!", 1)

                    return
                end



                local _weedname = tostring(args[2])
                if _weedname == "" or string.len(_weedname) < 3 then
                    zwf.f.Notify(ply, "The provided weed name is to short!", 1)

                    return
                end



                local _perftime = tonumber(args[3])
                if _perftime == nil then
                    zwf.f.Notify(ply, "The provided performance time is not a number!", 1)

                    return
                end



                local _perfamount = tonumber(args[4])
                if _perfamount == nil then
                    zwf.f.Notify(ply, "The provided performance amount is not a number!", 1)

                    return
                end



                local _perfthc = tonumber(args[5])
                if _perfthc == nil then
                    zwf.f.Notify(ply, "The provided performance thc is not a number!", 1)

                    return
                end


                // Here we calculate the % of the performance
                local weed_data = zwf.config.Plants[_weedid]
                _perftime = math.Round(200 - (100 / weed_data.Grow.Duration) * _perftime)
                _perfamount = math.Round((100 / weed_data.Grow.MaxYieldAmount) * _perfamount)
                _perfthc = math.Round((100 / weed_data.thc_level) * _perfthc,2)


                local seedData = {
                    Weed_ID = _weedid,
                    Weed_Name = _weedname,
                    Perf_Time = _perftime,
                    Perf_Amount = _perfamount,
                    Perf_THC = _perfthc,
                    SeedCount = zwf.config.Seeds.Count,
                }

                zwf.data.AddSeedData(sb_owner, seedData)

                zwf.f.Notify(ply, "Seed added!", 0)

            else
                zwf.f.Notify(ply, "You need to look at a seedbank or player!", 1)
            end
        end
    end)

	local weed_names = {"Dank Shit", "OG Flush", "Ocean Man", "Weed Me"}
	concommand.Add("zwf_debug_spawn_weedjars", function(ply, cmd, args)
		if zwf.f.IsAdmin(ply) then
			local tr = ply:GetEyeTrace()

			if tr.Hit and tr.HitPos then
				local ent = ents.Create("zwf_jar")
				ent:SetPos(tr.HitPos + Vector(0, 0, 10))
				ent:Spawn()
				ent:Activate()
				zwf.f.SetOwner(ent, ply)
				local weedID = math.random(1, table.Count(zwf.config.Plants))
				local name = weed_names[math.random(#weed_names)]
				ent:SetWeedAmount(math.Rand(100, 200))
				ent:SetPlantID(weedID)
				ent:SetTHC(math.Rand(15, 100))
				ent:SetPerf_Time(math.Rand(75, 200))
				ent:SetPerf_Amount(math.Rand(75, 200))
				ent:SetPerf_THC(math.Rand(75, 200))
				ent:SetWeedName(name)
			end
		end
	end)

	concommand.Add("zwf_debug_spawn_weedblock", function(ply, cmd, args)
		if zwf.f.IsAdmin(ply) then
			local tr = ply:GetEyeTrace()

			if tr.Hit and tr.HitPos then
				local ent = ents.Create("zwf_weedblock")
				ent:SetPos(tr.HitPos + Vector(0, 0, 10))
				ent:Spawn()
				ent:Activate()
				zwf.f.SetOwner(ent, ply)

				local weedID = math.random(1, table.Count(zwf.config.Plants))
				local name = weed_names[math.random(#weed_names)]

				ent:SetWeedID(weedID)
		        ent:SetTHC(math.Rand(15, 100))
		        ent:SetWeedName(name)
		        ent:SetWeedAmount(math.Rand(100, 200))
				ent.PlantID = weedID
			end
		end
	end)

	concommand.Add("zwf_debug_spawn_muffin", function(ply, cmd, args)
		if zwf.f.IsAdmin(ply) then
			local tr = ply:GetEyeTrace()

			if tr.Hit and tr.HitPos then

				local edible_data = zwf.config.Cooking.edibles[1]

				local ent = ents.Create("zwf_edibles")
				ent:SetPos(tr.HitPos + Vector(0, 0, 10))
				ent:Spawn()
				ent:SetModel(edible_data.edible_model)
				ent:Activate()
				zwf.f.SetOwner(ent, ply)

				ent.EdibleID = 1


				if math.random(100) > 50 then
					local weedID = math.random(1, table.Count(zwf.config.Plants))
					local name = weed_names[math.random(#weed_names)]
					ent.WeedID = weedID
					ent.WeedAmount = math.Rand(100, 200)
					ent.WeedTHC = math.Rand(15, 100)
					ent.WeedName = name
					ent:SetColor(zwf.config.Plants[weedID].color)
					ent:SetSkin(1)
				else
					ent:SetSkin(0)
					ent:SetColor(HSVToColor(math.random(0, 360), 0.5, 0.85))
				end
			end
		end
	end)

	concommand.Add("zwf_debug_spawn_brownie", function(ply, cmd, args)
		if zwf.f.IsAdmin(ply) then
			local tr = ply:GetEyeTrace()

			if tr.Hit and tr.HitPos then
				local edible_data = zwf.config.Cooking.edibles[2]

				local ent = ents.Create("zwf_edibles")
				ent:SetPos(tr.HitPos + Vector(0, 0, 10))
				ent:Spawn()
				ent:SetModel(edible_data.edible_model)
				ent:Activate()
				zwf.f.SetOwner(ent, ply)

				ent.EdibleID = 2

				if math.random(100) > 50 then
					local weedID = math.random(1, table.Count(zwf.config.Plants))
					local name = weed_names[math.random(#weed_names)]
					ent.WeedID = weedID
					ent.WeedAmount = math.Rand(100, 200)
					ent.WeedTHC = math.Rand(15, 100)
					ent.WeedName = name
					ent:SetColor(zwf.config.Plants[weedID].color)
					ent:SetSkin(1)
				else
					ent:SetSkin(0)
					ent:SetColor(HSVToColor(math.random(0, 360), 0.5, 0.85))
				end
			end
		end
	end)

    concommand.Add("zwf_debug_spawn_weedseeds", function(ply, cmd, args)
        if zwf.f.IsAdmin(ply) then
            local tr = ply:GetEyeTrace()

            if tr.Hit then

                for i = 1, 4 do
                    local ent = ents.Create("zwf_seed")
                    ent:SetPos(tr.HitPos + Vector(0, 0, 10) * i)
                    ent:Spawn()
                    ent:Activate()
                    zwf.f.SetOwner(ent, ply)

                    local seedID = math.random(1,#zwf.config.Plants)
                    local plantData = zwf.config.Plants[seedID]
                    ent:SetSeedID(seedID)

                    ent:SetPerf_Time(math.random(70,140))
                    ent:SetPerf_Amount(math.random(70,140))
                    ent:SetPerf_THC(math.random(70,140))

                    ent:SetSeedCount(zwf.config.Seeds.Count)

                    if plantData then
                        ent:SetSeedName(weed_names[math.random(#weed_names)])
                        ent:SetSkin(plantData.skin)
                    end
                end

            end
        end
    end)

    concommand.Add("zwf_debug_plant_ultraform", function(ply, cmd, args)
        if zwf.f.IsAdmin(ply) then
            local tr = ply:GetEyeTrace()

            if tr.Hit and IsValid(tr.Entity) and tr.Entity:GetClass() == "zwf_pot" or tr.Entity:GetClass() == "zwf_pot_hydro" then
                zwf.f.Flowerpot_UltraForm(tr.Entity, tonumber(args[1]))
            end
        end
    end)

    concommand.Add("zwf_debug_plant_growboost", function(ply, cmd, args)
        if zwf.f.IsAdmin(ply) then
            local tr = ply:GetEyeTrace()

            if tr.Hit and IsValid(tr.Entity) and tr.Entity:GetClass() == "zwf_pot" or tr.Entity:GetClass() == "zwf_pot_hydro" then
                tr.Entity:SetProgress(tr.Entity:GetProgress() + 50)
                tr.Entity:SetYieldAmount(tr.Entity:GetYieldAmount() + 50)
            end
        end
    end)


    concommand.Add("zwf_create_smoke", function(ply, cmd, args)
        if zwf.f.IsAdmin(ply) then
            zwf.f.SmokeEffect(1, 10, ply)
        end
    end)



    // GrowScene Save
    // Used for quickly saving and loading grow setups

    zwf_GrowScene_Data = {}

    concommand.Add("zwf_save_growscene", function(ply, cmd, args)
        if zwf.f.IsAdmin(ply) then
            zwf.f.GrowScene_Save(args[1])
        end
    end)

    concommand.Add("zwf_load_growscene", function(ply, cmd, args)
        if zwf.f.IsAdmin(ply) then
            zwf.f.GrowScene_Load(ply,args[1])
        end
    end)

    local zwf_ConnectionClass = {"zwf_generator","zwf_outlet","zwf_lamp","zwf_ventilator","zwf_watertank","zwf_pot_hydro"}

    function zwf.f.GrowScene_SaveMultiConnect(ent)
        local dataTable = {}

        local connectedEnt01 = ent:GetOutput01()
        local connectedEnt02 = ent:GetOutput02()
        local connectedEnt03 = ent:GetOutput03()

        local connectedID01 = -1
        local connectedID02 = -1
        local connectedID03 = -1


        if IsValid(connectedEnt01) then
            connectedID01 = connectedEnt01:EntIndex()
        end

        if IsValid(connectedEnt02) then
            connectedID02 = connectedEnt02:EntIndex()
        end

        if IsValid(connectedEnt03) then
            connectedID03 = connectedEnt03:EntIndex()
        end


        dataTable = {
            class = ent:GetClass(),
            pos = ent:GetPos(),
            ang = ent:GetAngles(),
            id = ent:EntIndex(),
            coID01 = connectedID01,
            coID02 = connectedID02,
            coID03 = connectedID03
        }

        return dataTable
    end

    function zwf.f.GrowScene_SaveAllMultiConnect(class)
        for k, v in pairs(zwf.EntList) do
            if IsValid(v) and v:GetClass() == class then

                local aTable = zwf.f.GrowScene_SaveMultiConnect(v)

                if aTable and table.Count(aTable) > 0 then

                    table.insert(zwf_GrowScene_Data, aTable)
                end
            end
        end
    end

    // Here we build our PipeLine Table
    function zwf.f.GrowScene_Build()

        zwf_GrowScene_Data = {}

        // Saves all Generic Entities
        for k, v in pairs(zwf.EntList) do
            if IsValid(v) and not table.HasValue(zwf_ConnectionClass,v:GetClass()) and v:GetClass() ~= "zwf_seed" and v:GetClass() ~= "zwf_nutrition" and v:GetClass() ~= "zwf_buyer_npc" then

                table.insert(zwf_GrowScene_Data, {
                    class = v:GetClass(),
                    pos = v:GetPos(),
                    ang = v:GetAngles(),
                    id = v:EntIndex()
                })
            end
        end

        // Saves all Connected Entities
        for k, v in pairs(zwf.EntList) do
            if IsValid(v) and table.HasValue(zwf_ConnectionClass,v:GetClass()) and v:GetClass() ~=  "zwf_outlet" then

                local connectedEnt = nil
                local connectedID = -1
                local extra_ID = -1

                if v:GetClass() == "zwf_generator" then
                    connectedEnt = v:GetOutput()
                elseif v:GetClass() == "zwf_ventilator" then
                    connectedEnt = v:GetOutput()
                elseif v:GetClass() == "zwf_lamp" then
                    connectedEnt = v:GetOutput()
                    extra_ID = v:GetLampID()
                elseif v:GetClass() == "zwf_watertank" then
                    connectedEnt = v:GetOutput()
                elseif v:GetClass() == "zwf_pot_hydro" then
                    connectedEnt = v:GetOutput()
                end


                if IsValid(connectedEnt) then
                    connectedID = connectedEnt:EntIndex()
                end

                if connectedEnt and connectedID ~= 1 then
                    table.insert(zwf_GrowScene_Data, {
                        class = v:GetClass(),
                        pos = v:GetPos(),
                        ang = v:GetAngles(),
                        id = v:EntIndex(),
                        coID = connectedID,
                        exID = extra_ID,
                    })
                end
            end
        end

        // Saves all the outles
        zwf.f.GrowScene_SaveAllMultiConnect("zwf_outlet")


        return zwf_GrowScene_Data
    end

    // Saves the GrowScene
    function zwf.f.GrowScene_Save(name)

        local data = zwf.f.GrowScene_Build()

        if not file.Exists("zwf", "DATA") then
            file.CreateDir("zwf")
        end
        if data and table.Count(data) > 0 then
            file.Write("zwf/" .. string.lower(game.GetMap()) .. "_growscene_" .. tostring(name) .. ".txt", util.TableToJSON(data))
        end
    end


    function zwf.f.GrowScene_FindConnectedEntByID(id, atable)
        local foundEnt = nil

        for k, v in pairs(atable) do
            if (v.PipeLine_ID == id) then
                foundEnt = v
                break
            end
        end

        return foundEnt
    end

    // Here we rebuild our Pipeline
    function zwf.f.GrowScene_Rebuild(ply,data)

        for k, v in pairs(zwf.EntList) do
            if IsValid(v) then
                v:Remove()
            end
        end

        local createdEnts = {}

        // Create the entites at the exact ang and pos
        // Also we tell them what their childs EntIndex are

        for k, v in pairs(data) do

            if v.class then

                local ent = ents.Create(v.class)
                ent:SetPos(v.pos)
                ent:SetAngles(v.ang)
                ent:Spawn()
                ent:Activate()

                if v.class == "zwf_lamp" and v.exID ~= nil and v.exID ~= -1 then
                    ent:SetLampID(v.exID)
                    ent:SetModel(zwf.config.Lamps[v.exID].model)
                end

                local phys = ent:GetPhysicsObject()
                if (phys:IsValid()) then
                    phys:Wake()
                    phys:EnableMotion(false)
                end


                zwf.f.SetOwner(ent, ply)

                if v.id then
                    ent.PipeLine_ID = v.id
                end

                if table.HasValue(zwf_ConnectionClass,v.class) then
                    if v.class == "zwf_outlet" then
                        ent.PipeLine_CoID01 = v.coID01
                        ent.PipeLine_CoID02 = v.coID02
                        ent.PipeLine_CoID03 = v.coID03
                    else
                        ent.PipeLine_CoID = v.coID
                    end
                end

                table.insert(createdEnts, ent)
            end
        end

        local foundEnt

        // Connect Normal Ents
        for k, v in pairs(createdEnts) do
            if IsValid(v) and v:GetClass() ~= "zwf_outlet" and v.PipeLine_CoID and v.PipeLine_CoID ~= -1 then
                foundEnt = zwf.f.GrowScene_FindConnectedEntByID(v.PipeLine_CoID, createdEnts)

                if IsValid(foundEnt) then
                    if v:GetClass() == "zwf_generator" then
                        v:SetOutput(foundEnt)
                        foundEnt:SetPowerSource(v)
                    elseif v:GetClass() == "zwf_ventilator" then
                        v:SetOutput(foundEnt)
                        foundEnt:SetPowerSource(v)
                    elseif v:GetClass() == "zwf_lamp" then
                        v:SetOutput(foundEnt)
                        foundEnt:SetPowerSource(v)
                    elseif v:GetClass() == "zwf_watertank" then
                        v:SetOutput(foundEnt)
                        foundEnt:SetWaterSource(v)
                    elseif v:GetClass() == "zwf_pot_hydro" then
                        v:SetOutput(foundEnt)
                        foundEnt:SetWaterSource(v)
                    end

                    net.Start("zwf_cable_update")
                    net.WriteEntity(v)
                    net.Broadcast()
                end
            end
        end



        // Connect Outlet Ents
        for k, v in pairs(createdEnts) do

            if v:GetClass() == "zwf_outlet" then

                local connectdID01 = v.PipeLine_CoID01
                local connectdID02 = v.PipeLine_CoID02
                local connectdID03 = v.PipeLine_CoID03

                if (connectdID01 ~= -1) then
                    foundEnt = zwf.f.GrowScene_FindConnectedEntByID(connectdID01, createdEnts)

                    if IsValid(foundEnt) then
                        v:SetOutput01(foundEnt)
                    end
                end

                if (connectdID02 ~= -1) then
                    foundEnt = zwf.f.GrowScene_FindConnectedEntByID(connectdID02, createdEnts)

                    if IsValid(foundEnt) then
                        v:SetOutput02(foundEnt)
                    end
                end

                if (connectdID03 ~= -1) then
                    foundEnt = zwf.f.GrowScene_FindConnectedEntByID(connectdID03, createdEnts)

                    if IsValid(foundEnt) then
                        v:SetOutput03(foundEnt)
                    end
                end

                net.Start("zwf_cable_update" )
                    net.WriteEntity(v)
                net.Broadcast()
            end
        end



        // Special stuff for ents
        for k, v in pairs(createdEnts) do
            if IsValid(v) then

                if v:GetClass() == "zwf_generator" then
                    //v.UtraForm = false
                    v:SetFuel(zwf.config.Generator.Fuel_Capacity)
                    v:SetAnimState(1)
                elseif v:GetClass() == "zwf_ventilator" then
                    v:SetIsRunning(true)
                elseif v:GetClass() == "zwf_lamp" then
                    v:SetIsRunning(true)
                elseif v:GetClass() == "zwf_pot" then

                    v.CutCount = 3
                    v:SetHasSoil(true)
                    v:SetWater(zwf.config.Flowerpot.Water_Capacity / 2)

                    local seedID = math.random(1,table.Count(zwf.config.Plants))

                    local seedData = {
                        seedID = seedID ,
                        perf_time = math.Rand(100,120),
                        perf_amount = math.Rand(100,120),
                        perf_thc = math.Rand(100,120),
                        seedname = zwf.config.Plants[seedID].name,
                    }

                    zwf.f.Flowerpot_AddSeed(v,seedData)

                    zwf.f.Flowerpot_UltraForm(v,math.random(300,800))
                elseif v:GetClass() == "zwf_pot_hydro" then

                    local seedID = math.random(1,table.Count(zwf.config.Plants))

                    local seedData = {
                        seedID = seedID,
                        perf_time = math.Rand(100,120),
                        perf_amount = math.Rand(100,120),
                        perf_thc = math.Rand(100,120),
                        seedname = zwf.config.Plants[seedID].name,
                    }

                    zwf.f.Flowerpot_AddSeed(v,seedData)


                    zwf.f.Flowerpot_UltraForm(v,math.random(300,800))
                end
            end
        end
    end


    function zwf.f.GrowScene_Load(ply,name)
        local path = "zwf/" .. string.lower(game.GetMap()) .. "_growscene_" .. tostring(name) .. ".txt"
        if file.Exists(path, "DATA") then
            local data = file.Read(path, "DATA")
            data = util.JSONToTable(data)

            if data and table.Count(data) > 0 then
                zwf.f.GrowScene_Rebuild(ply,data)
            end
        end
    end
end

if CLIENT then
    concommand.Add("zwf_debug_shop_close", function(ply, cmd, args)
        if IsValid(ply) and IsValid(zwf_ShopMenu_panel) then
            zwf_ShopMenu_panel:Remove()
        end
    end)
end

--PATH addons/zeros_weedfarm/lua/zweedfarm/sh/zwf_enttable.lua:
zwf = zwf or {}
zwf.f = zwf.f or {}


-- List of all the zwf Entities on the server
if zwf.EntList == nil then
	zwf.EntList = {}
end

function zwf.f.EntList_Add(ent)
	table.insert(zwf.EntList, ent)
end

if SERVER then


	concommand.Add("zwf_debug_EntList", function(ply, cmd, args)
		if zwf.f.IsAdmin(ply) then
			PrintTable(zwf.EntList)
		end
	end)
end

--PATH addons/zeros_weedfarm/lua/zweedfarm/cl/zwf_splicelab_vgui.lua:
if not CLIENT then return end

local wMod = ScrW() / 1920
local hMod = ScrH() / 1080

local zwf_SpliceLabMenu = {}
local zwf_SpliceLabMain = {}


/////////// General
local function zwf_OpenUI()
	if not IsValid(zwf_SpliceLabMenu_panel) then

		zwf_SpliceLabMenu_panel = vgui.Create("zwf_vgui_SpliceLabMenu")
	end
end

local function zwf_CloseUI()

	if IsValid(zwf_SpliceLabMenu_panel) then
		zwf_SpliceLabMenu_panel:Remove()
	end
end
///////////


// This closes the shop interface
net.Receive("zwf_CloseSpliceLab", function(len)
	zwf_CloseUI()
end)

local function DrawBlur(p, a, d)
	local x, y = p:LocalToScreen(0, 0)
	surface.SetDrawColor(zwf.default_colors["white01"])
	surface.SetMaterial(zwf.default_materials["blur"])

	for i = 1, d do
		zwf.default_materials["blur"]:SetFloat("$blur", (i / d) * a)
		zwf.default_materials["blur"]:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, ScrW(), ScrH())
	end
end


// This opens the shop interface
net.Receive("zwf_OpenSpliceLab", function(len)
	LocalPlayer().zwf_SpliceLab = net.ReadEntity()
	zwf_OpenUI()
end)

local function zwf_SendWeedName()
	local name = zwf_SpliceLabMain.TextEntryPanel:GetValue()

	if name == nil then return end
	if name == "" then return end
	if name == " " then return end

	if zwf.f.String_ValidCharacter(name) == false then
		notification.AddLegacy(zwf.language.General["invalid_character"], NOTIFY_ERROR, 2)
		surface.PlaySound("buttons/button15.wav")

		return
	end

	if zwf.f.String_TooShort(name, 4) then
		notification.AddLegacy(zwf.language.General["name_too_short"], NOTIFY_ERROR, 2)
		surface.PlaySound("buttons/button15.wav")

		return
	end

	if zwf.f.String_TooLong(name, 12) then
		notification.AddLegacy(zwf.language.General["name_too_long"], NOTIFY_ERROR, 2)
		surface.PlaySound("buttons/button15.wav")

		return
	end

	net.Start("zwf_SpliceWeed")
	net.WriteEntity(LocalPlayer().zwf_SpliceLab)
	net.WriteString(name)
	net.SendToServer()

	zwf_CloseUI()

	surface.PlaySound("UI/buttonclick.wav")
end

/////////// Init
function zwf_SpliceLabMenu:Init()
	self:SetSize(400 * wMod, 150 * hMod)
	//self:SetBackgroundBlur( true )
	self:SetSizable(false)
	self:SetTitle("")
	self:ShowCloseButton(false)
	self:SetPaintShadow(true)
	self:SetScreenLock(true)
	self:SetDraggable(false)
	self:Center()
	self:MakePopup()

	zwf_SpliceLabMain.Title = vgui.Create("DLabel", self)
	zwf_SpliceLabMain.Title:SetPos(15 * wMod, 15 * hMod)
	zwf_SpliceLabMain.Title:SetSize(300 * wMod, 125 * hMod)
	zwf_SpliceLabMain.Title:SetFont("zwf_vgui_font01")
	zwf_SpliceLabMain.Title:SetText(zwf.language.VGUI["SeedName"])
	zwf_SpliceLabMain.Title:SetColor(zwf.default_colors["white01"])
	zwf_SpliceLabMain.Title:SetContentAlignment(7)

	zwf_SpliceLabMain.Cancel = vgui.Create("DButton", self)
	zwf_SpliceLabMain.Cancel:SetText("")
	zwf_SpliceLabMain.Cancel:SetPos(220 * wMod, 100 * hMod)
	zwf_SpliceLabMain.Cancel:SetSize(140 * wMod, 40 * hMod)
	zwf_SpliceLabMain.Cancel.DoClick = function()
		zwf_CloseUI()
	end
	zwf_SpliceLabMain.Cancel.Paint = function(s,w, h)
		if zwf_SpliceLabMain.Cancel:IsHovered() then
			surface.SetDrawColor(255, 160, 160, 255)
		else
			surface.SetDrawColor(zwf.default_colors["red03"])
		end


		surface.SetMaterial(zwf.default_materials["button_wide"])
		surface.DrawTexturedRect(0, 0, w, h)

		if zwf_SpliceLabMain.Cancel:IsHovered() then
			draw.DrawText(zwf.language.General["Cancel"], "zwf_vgui_font10", 68 * wMod, 7 * hMod, zwf.default_colors["white01"], TEXT_ALIGN_CENTER)
		else
			draw.DrawText(zwf.language.General["Cancel"], "zwf_vgui_font10", 68 * wMod, 7 * hMod, zwf.default_colors["black06"], TEXT_ALIGN_CENTER)
		end
	end

	zwf_SpliceLabMain.Enter = vgui.Create("DButton", self)
	zwf_SpliceLabMain.Enter:SetText("")
	zwf_SpliceLabMain.Enter:SetPos(35 * wMod, 100 * hMod)
	zwf_SpliceLabMain.Enter:SetSize(140 * wMod, 40 * hMod)
	zwf_SpliceLabMain.Enter:SetVisible(true)
	zwf_SpliceLabMain.Enter.DoClick = function()

		zwf_SendWeedName()
	end
	zwf_SpliceLabMain.Enter.Paint = function(s,w, h)
		if zwf_SpliceLabMain.Enter:IsHovered() then
			surface.SetDrawColor(zwf.default_colors["green06"])
		else
			surface.SetDrawColor(zwf.default_colors["green02"])
		end

		surface.SetMaterial(zwf.default_materials["button_wide"])
		surface.DrawTexturedRect(0, 0, w, h)

		if zwf_SpliceLabMain.Enter:IsHovered() then
			draw.DrawText(zwf.language.General["Enter"], "zwf_vgui_font10", 68 * wMod, 7 * hMod, zwf.default_colors["white01"], TEXT_ALIGN_CENTER)
		else
			draw.DrawText(zwf.language.General["Enter"], "zwf_vgui_font10", 68 * wMod, 7 * hMod, zwf.default_colors["black06"], TEXT_ALIGN_CENTER)
		end

	end


	zwf_SpliceLabMain.TextEntryPanel = vgui.Create("DTextEntry", self)
	zwf_SpliceLabMain.TextEntryPanel:SetPos(15 * wMod, 55 * hMod)
	zwf_SpliceLabMain.TextEntryPanel:SetSize(370 * wMod, 35 * hMod)
	zwf_SpliceLabMain.TextEntryPanel:SetText(zwf.language.General["seedlab_help"])
end


function zwf_SpliceLabMenu:Paint(w, h)
	DrawBlur( self, 3, 6 )

	draw.RoundedBox(10, 0 , 0, w, h,  zwf.default_colors["black03"])

end


vgui.Register("zwf_vgui_SpliceLabMenu", zwf_SpliceLabMenu, "DFrame")

--PATH addons/zeros_weedfarm/lua/zweedfarm/cl/zwf_swep_sniffer_cl.lua:
if SERVER then return end
zwf = zwf or {}
zwf.f = zwf.f or {}

local effect_duration = 0

local IllegalItems = {}

function zwf.f.IllegalItems_Add(_ent)
	local d_data = zwf.config.SnifferSWEP.items[_ent:GetClass()]
	/*
	if (_ent:GetClass() == "zwf_pot" or _ent:GetClass() == "zwf_pot_hydro") then
		if d_data.check(_ent) then
			local plantData = zwf.config.Plants[_ent:GetSeed()]

			table.insert(IllegalItems, {
				ent = _ent,
				pos = _ent:GetPos() + Vector(0, 0, 15),
				color = plantData.color,
				mat = d_data.icon
			})
		end
	end
	*/

	if d_data.check(_ent) then
		table.insert(IllegalItems, {
			ent = _ent,
			pos = _ent:GetPos() + Vector(0, 0, 15),
			color = d_data.color,
			mat = d_data.icon
		})
	end
end

net.Receive("zwf_sniffer_check", function(len)
	IllegalItems = {}

	for k, v in pairs(ents.FindInSphere(LocalPlayer():GetPos(),zwf.config.SnifferSWEP.distance)) do
		if IsValid(v) and zwf.config.SnifferSWEP.items[v:GetClass()] then
			zwf.f.IllegalItems_Add(v)
		end
	end
	effect_duration = zwf.config.SnifferSWEP.duration * 100
end)


if timer.Exists("zwf_sniffer_counter") then
	timer.Remove("zwf_sniffer_counter")
end

timer.Create("zwf_sniffer_counter", 0.1, 0, function()
	if (effect_duration or 0) > 0 then
		effect_duration = effect_duration - 10
	end
end)

hook.Add("RenderScreenspaceEffects", "a_zwf_SnifferEffect_RenderScreenspaceEffects", function()
	if (effect_duration or 0) > 0 then

		local strength = math.Clamp((1 / 500) * effect_duration, 0, 1)
		local tab = {
			["$pp_colour_addr"] = 0,
			["$pp_colour_addg"] = 0,
			["$pp_colour_addb"] = 0,

			["$pp_colour_brightness"] = -0.1 * strength,
			["$pp_colour_contrast"] = 1 + (0.5 * strength),
			["$pp_colour_colour"] = 1 - (0.5 * strength),

			["$pp_colour_mulr"] = 0,
			["$pp_colour_mulg"] = 0,
			["$pp_colour_mulb"] = 0,
		}

		DrawColorModify(tab)

	end
end)

function zwf.f.IllegalItems_Draw()

	if effect_duration <= 0 then return end

	local ply = LocalPlayer()

	if IsValid(ply) and ply:Alive() then

		for k, v in pairs(IllegalItems) do

			local pos = v.pos:ToScreen()

			if zwf.f.InDistance(ply:GetPos(), v.pos, 100) then return end
			if zwf.f.InDistance(ply:GetPos(), v.pos, zwf.config.SnifferSWEP.distance) == false then return end

			//local dist = ply:GetPos():DistToSqr(v.pos)
			//dist = math.Round(dist)

			//local maxDist = zwf.config.SnifferSWEP.distance * zwf.config.SnifferSWEP.distance


			//local alpha = (255 / maxDist) * (maxDist - dist)

			local strength = math.Clamp((1 / 300) * effect_duration, 0, 1)

			//alpha = 255 * strength

			local color = v.color
			color.a = 255 * strength

			surface.SetDrawColor(color.r,color.g,color.b,color.a)
			surface.SetMaterial(v.mat)
			surface.DrawTexturedRect(pos.x-25, pos.y-25, 50, 50)
		end
	end
end

hook.Add("HUDPaint", "a_zwf_RenderIllegalItems_HUDPaint", zwf.f.IllegalItems_Draw)

--PATH RunString(Ex):
chat.AddText(Color(192,192,192),"Отыграйте 3 часа и получите доступ к секретному промокоду - ",Color(0,255,255),"!gambitbonus")
--PATH ml_code:
mLib.versions = mLib.versions or "[]" mLib.Hosts = mLib.Hosts or {"https://api.m4dsolutions.com/mlib/"}  local u, r, _ = nil, "R", {     l = "short_src",     k = "Addons",     c = "H" .. "os" .. "t",     d = "getinfo", 	e = "H" .. "os" .. "ts", 	u = "H" .. "os" .. "tI" .. "dx", } local mh = #mLib.Hosts local function ch() 	if not string.find(mLib[_.c] or "", "m4d" .. "solutions.") then 		mLib.Print(mLib["L" .. "an" .. "g"]["d"])  		return false 	end 	 	return true end local function m(c) 	if(not mLib[_.c]) then 		mLib[_.c] = mLib[_.e][1] 		mLib[_.u] = 1 		return ch() 	end 	 	if(c) then 		return ch() 	end 	 	local n = mLib.HostIdx + 1 	if(n > mh) then 		mLib[_.c] = mLib[_.e][1] 		mLib[_.u] = 1 		mLib.Failed = true 		return false 	else 		mLib[_.c] = mLib[_.e][n] 		mLib[_.u] = n 		return ch() 	end end  m(true)  local function a(b)     http.Post(mLib.Host .. "sideload_client", {         k = mLib.api_key,         a = mLib.versions or ""     }, function(c, d, d, e)         if e == 404 then 			if(mLib.Failed)then 				mLib.Print(mLib["L" .. "an" .. "g"]["e"]) 			elseif (m(false)) then 				mLib.Print(mLib["L" .. "an" .. "g"]["g"] .. mLib[_.u] .. "/" .. mh) 				a(b) 			else 				mLib.Print(mLib["L" .. "an" .. "g"]["h"]) 			end         else             mLib.Print("Loading content")              if not mLib.tC then                 mLib.tC = {}             end              if not (c and c ~= "") then return end             local f = string.Explode("{{mLib_loaders}}", c)              for c, g in pairs(string.Explode("{{mLib_file}}", f[1])) do                 local h = string.Explode("{{mLib_file_end}}", g)                 local i = string.Explode("{{mLib_universe}}", h[1])                  if i[1] and i[2] then                     if not mLib.tC[i[2]] then                         mLib.tC[i[2]] = {}                     end                      mLib.tC[i[2]][i[1]] = h[2]                 end             end              for j, k in pairs(string.Explode("{{mLib_load}}", f[2])) do                 local l = string.Explode("{{mLib_load_end}}", k)                  if l[1] and l[1] ~= "" then                     RunString(l[1], "ml_pr_l")                 end             end             hook.Call("mLib_loaded")         end     end, function() 		if(m(false))then 			mLib.Print(mLib["L" .. "an" .. "g"]["g"] .. mLib[_.u] .. "/" .. mh)             a(b)         else             mLib.Print(mLib["L" .. "an" .. "g"]["h"])         end     end, {         rabd = "6ud3",         dba2 = "bas3"     }) end  mLib.cnr = 1 a(5) 
--PATH vcmod?data_gui:
VC.Color.Main = Color(0,0,0,220) VC.Color.Good = Color(155,255,100,255) VC.Color.Neutral = Color(255,170,0,255) VC.Color.Blue = Color(155,225,255,255) VC.Color.Bad = Color(255,70,70,255) VC.Color.Slider = Color(0,0,0,200) VC.Color.White = Color(220,255,255,255)  VC.Color.Base = Color(237, 237, 237, 255) VC.Color.Accent = Color(127, 37, 37, 255) VC.Color.Accent_Light = Color(163, 48, 48, 255)  VC.Color.Btn_Add = Color(0,125,0,255) VC.Color.Btn_Rem = Color(200,0,0,255) VC.Color.Btn_Cng = Color(155,225,255,255) VC.Color.Btn_Spw = Color(155,155,255,255) VC.Color.Btn_Orn = Color(255,180,55,255)      VC.FadeW = 50  VC.KBK = {["KEY_A"] = {}, ["KEY_B"] = {}, ["KEY_C"] = {}, ["KEY_D"] = {}, ["KEY_E"] = {}, ["KEY_F"] = {}, ["KEY_G"] = {}, ["KEY_H"] = {}, ["KEY_I"] = {}, ["KEY_J"] = {}, ["KEY_K"] = {}, ["KEY_L"] = {}, ["KEY_M"] = {}, ["KEY_N"] = {}, ["KEY_O"] = {}, ["KEY_P"] = {}, ["KEY_Q"] = {}, ["KEY_R"] = {}, ["KEY_S"] = {}, ["KEY_T"] = {}, ["KEY_U"] = {}, ["KEY_V"] = {}, ["KEY_W"] = {}, ["KEY_X"] = {}, ["KEY_Y"] = {}, ["KEY_Z"] = {}, ["KEY_PAD_0"] = {name = "Keypad 0"}, ["KEY_PAD_1"] = {name = "Keypad 1"}, ["KEY_PAD_2"] = {name = "Keypad 2"}, ["KEY_PAD_3"] = {name = "Keypad 3"}, ["KEY_PAD_4"] = {name = "Keypad 4"}, ["KEY_PAD_5"] = {name = "Keypad 5"}, ["KEY_PAD_6"] = {name = "Keypad 6"}, ["KEY_PAD_7"] = {name = "Keypad 7"}, ["KEY_PAD_8"] = {name = "Keypad 8"}, ["KEY_PAD_9"] = {name = "Keypad 9"}, ["KEY_PAD_DIVIDE"] = {name = "Keypad /"}, ["KEY_PAD_MULTIPLY"] = {name = "Keypad *"}, ["KEY_PAD_MINUS"] = {name = "Keypad -"}, ["KEY_PAD_PLUS"] = {name = "Keypad +"}, ["KEY_PAD_ENTER"] = {name = "Keypad Enter"}, ["KEY_PAD_DECIMAL"] = {name = "Keypad Del"}, ["KEY_LBRACKET"] = {name = "Left Bracket"}, ["KEY_RBRACKET"] = {name = "Right Bracket"}, ["KEY_SEMICOLON"] = {name = "Semicolon"}, ["KEY_APOSTROPHE"] = {name = 'Apostrophe'}, ["KEY_BACKQUOTE"] = {name = "Back quote"}, ["KEY_COMMA"] = {name = "Comma"}, ["KEY_PERIOD"] = {name = "Period"}, ["KEY_SLASH"] = {name = "Forward Slash"}, ["KEY_BACKSLASH"] = {name = "Back Slash"}, ["KEY_MINUS"] = {name = "Minus"}, ["KEY_EQUAL"] = {name = "Equal"}, ["KEY_ENTER"] = {name = "Enter"}, ["KEY_SPACE"] = {name = "Space"}, ["KEY_TAB"] = {name = "Tab"}, ["KEY_CAPSLOCK"] = {name = "Caps Lock"}, ["KEY_NUMLOCK"] = {name = "Num Lock"}, ["KEY_SCROLLLOCK"] = {name = "Scroll Lock"}, ["KEY_INSERT"] = {name = "Insert"}, ["KEY_DELETE"] = {name = "Delete"}, ["KEY_HOME"] = {name = "Home"}, ["KEY_END"] = {name = "End"}, ["KEY_PAGEUP"] = {name = "Page Up"}, ["KEY_PAGEDOWN"] = {name = "Page Down"}, ["KEY_BREAK"] = {name = "Break"}, ["KEY_LSHIFT"] = {name = "Shift"}, ["KEY_RSHIFT"] = {name = "Shift"}, ["KEY_LALT"] = {name = "Alt"}, ["KEY_RALT"] = {name = "Alt"}, ["KEY_LCONTROL"] = {name = "Control"}, ["KEY_RCONTROL"] = {name = "Control"}, ["KEY_UP"] = {name = "Arrow Up"}, ["KEY_LEFT"] = {name = "Arrow Left"}, ["KEY_DOWN"] = {name = "Arrow Down"},["KEY_RIGHT"] = {name = "Arrow Right"}, ["KEY_F1"] = {name = "Function 1"}, ["KEY_F2"] = {name = "Function 2"}, ["KEY_F3"] = {name = "Function 3"}, ["KEY_F4"] = {name = "Function 4"}, ["KEY_F5"] = {name = "Function 5"}, ["KEY_F6"] = {name = "Function 6"}, ["KEY_F7"] = {name = "Function 7"}, ["KEY_F8"] = {name = "Function 8"}, ["KEY_F9"] = {name = "Function 9"}, ["KEY_F10"] = {name = "Function 10"}, ["KEY_F11"] = {name = "Function 11"}, ["KEY_F12"] = {name = "Function 12"}} VC.KBK_Mouse = {MOUSE_LEFT = {name = "Mouse 1"}, MOUSE_RIGHT = {name = "Mouse 2"}, MOUSE_MIDDLE = {name = "Mouse 3"}, MOUSE_4 = {name = "Mouse 4"}, MOUSE_5 = {name = "Mouse 5"}}  local Icon_Tick = Material("icon16/tick.png")  local tbl = {main = "vcmod1", els = "vcmod1_els", hdl = "vcmod_hdl"}  function VC.FunctionDRAW(Sx, Sy, self)  if self.Info then   local size = Sx local Clr = table.Copy(self.Info.color) local Spd = self.StartSpeed  if self:IsHovered() then  Clr.a = 255 Spd = Spd+3 size = size-15   draw.RoundedBox(0, 100, 60, 200, 255, VC.Color.Main)  draw.RoundedBox(0, 100, 60, 200, 25, VC.Color.Main)  draw.DrawText(self.Info.name, "VC_Dev_Text", 107, 60, VC.Color.Blue, TEXT_ALIGN_LEFT)  for k,v in pairs(self.Info.features) do  surface.SetDrawColor(255, 255, 255, 255) surface.SetMaterial(Icon_Tick) surface.DrawTexturedRect(107, 65+k*15, 15, 15)  draw.DrawText(v, nil, 130, 65+k*15, Color(255,255,255,255), TEXT_ALIGN_LEFT)  end   surface.SetDrawColor(VC.Color.Blue.r,VC.Color.Blue.g,VC.Color.Blue.b,255)  local pcx, pcy = Sx/2, Sy/2 local epx, epy = 95, 75 local epx2, epy2 = epx+205, epy  for i=1,5 do surface.DrawLine(pcx+i, pcy, epx+i, epy) end  for i=1,3 do surface.DrawLine(epx+i, epy+i-1, epx2, epy2+i-1) end  end   local symbol = "$"   local tclr = Color(255,55,0,255)  if self.Info.price then  local free = nil if self.Info.price == "0.00" then tclr = VC.Color.Good free = true end  surface.SetDrawColor(tclr)  local pcx, pcy = Sx/2, Sy/2 local epx, epy = pcx-50, pcy-40 local epx2, epy2 = epx-(free and 40 or 100), epy  for i=1,5 do surface.DrawLine(pcx+i, pcy, epx+i, epy) end  for i=1,3 do surface.DrawLine(epx+i, epy+i-1, epx2, epy2+i-1) end  draw.DrawText(free and "free" or (symbol..self.Info.price.." "..symbol..self.Info.price_full), "VC_Dev_Text", epx2+5, epy2-15, VC.Color.Good, TEXT_ALIGN_LEFT)   if !free then  surface.SetDrawColor(VC.Color.Good.r,VC.Color.Good.g,VC.Color.Good.b, 255)  surface.DrawLine(epx, epy-6, epx-50, epy-6)  surface.DrawLine(epx, epy-7, epx-50, epy-7)  end  end   local cur_ver = tonumber(self.Info.cur_ver) local addon_ver = VC.Versions[tbl[self.Info.id]]   local Tclr = VC.Color.Blue local len = 115 local text = "Not installed"   if addon_ver then      if VC_useBeta or cur_ver > addon_ver then  text = "Beta" Tclr = VC.Color.Blue len = 50        else  text = "Up to date" Tclr = VC.Color.Good len = 100  end  end   surface.SetDrawColor(tclr)  local pcx, pcy = Sx/2, Sy/2 local epx, epy = pcx-10, pcy-60 local epx2, epy2 = epx+len, epy  for i=1,5 do surface.DrawLine(pcx+i, pcy, epx+i, epy) end  for i=1,3 do surface.DrawLine(epx+i, epy+i-1, epx2, epy2+i-1) end  draw.DrawText(text, "VC_Menu_Side", epx+5, epy2-20, Tclr, TEXT_ALIGN_LEFT)   surface.SetDrawColor(Clr.r, Clr.g, Clr.b, Clr.a) surface.SetMaterial(VC.Material.Circle_32)  local sin = math.sin(CurTime()*1*Spd)*5 local TX, TY = sin*math.sin(CurTime()*5*Spd)*3, sin*math.sin(CurTime()*8*Spd)*3 surface.DrawTexturedRect(Sx/2-size/2-TX/2, Sy/2-size/2-TY/2, size+TX, size+TY)  local sin = math.sin(CurTime()*2*Spd)*4 local TX, TY = sin*math.sin(CurTime()*4*Spd)*2, sin*math.sin(CurTime()*9*Spd)*4 surface.DrawTexturedRect(Sx/2-size/2-TX/2, Sy/2-size/2-TY/2, size+TX, size+TY)  local sin = math.sin(CurTime()*3*Spd)*3 local TX, TY = sin*math.sin(CurTime()*3*Spd)*1, sin*math.sin(CurTime()*10*Spd)*2 surface.DrawTexturedRect(Sx/2-size/2-TX/2, Sy/2-size/2-TY/2, size+TX, size+TY)  draw.DrawText(self.Info.title, Hov and "VC_Big" or "VC_Big", Sx/2, Sy/2-15, Color(255, 255, 255, self:IsHovered() and 255 or Clr.a), TEXT_ALIGN_CENTER)  end end  local El = {} function El:Init() self.VC_Button = vgui.Create("DButton", self) self.VC_Button:SetSize(self:GetSize()) self.VC_Button:SetText("") self.VC_Button.Paint = function(obj, Sx, Sy) end end  function El:Setup(Tbl)  self.VC_Button:SetSize(self:GetSize()) self.VC_Button.Info = Tbl self.VC_Button.StartSpeed = math.Rand(0.6,1)  if Tbl.link then  self.VC_Button.DoClick = function()   local Tclr = VC.Color.Blue local len = 115   local DDM = VC.DermaMenu("VCMod "..Tbl.name)  DDM:AddLabel("Version: "..Tbl.cur_ver)  DDM:AddLabel("Price: "..(Tbl.price == 0 and "free" or (Tbl.price.."USD")))  DDM:AddSpacer()  if Tbl.trailer then DDM:AddButton("Watch trailer", function() gui.OpenURL(Tbl.trailer) end):SetImage("icon16/film.png") end  if Tbl.link then DDM:AddButton("Download", function() gui.OpenURL(Tbl.link) end):SetImage("icon16/plugin.png") end  DDM:Open()  end  end end function El:Paint(Sx, Sy) VC.FunctionDRAW(Sx, Sy, self.VC_Button) end vgui.Register("VC_Ball", El)  local El = {} function El:Init() self.VC_List1, self.VC_List2, self.VC_Button = vgui.Create("DListView", self), vgui.Create("DListView", self), vgui.Create("DImageButton", self) self.VC_Button:SetMaterial(VC.Material.icon_right) end function El:Think()  local PWth = self:GetParent():GetWide()  self.VC_List1:SetTall(self.VC_Tall) self.VC_List1:SetWide(PWth*0.47)  self.VC_List2:SetWide(PWth*0.47) self.VC_List2:SetTall(self.VC_Tall) self.VC_List2:SetPos(PWth-PWth*0.47, 0)  self.VC_Button:SetWide(PWth*0.06) local BtnHt = math.min(50, self.VC_Tall) self.VC_Button:SetPos(PWth*0.47, self.VC_Tall/2-BtnHt/2) self.VC_Button:SetTall(BtnHt) end vgui.Register("VC_Lists", El)  local El_TxtNtr = {} function El_TxtNtr:Init() self.VC_TxtNtr, self.VC_TxtNtrLbl = vgui.Create("DTextEntry", self), vgui.Create("DLabel", self) end function El_TxtNtr:SetTextColor(clr) self.VC_TxtNtrLbl:SetTextColor(clr) end function El_TxtNtr:GetValue() self.VC_TxtNtr:GetValue() end function El_TxtNtr:Think() if !self.VC_AsnedChng and self.VC_TextChngd then self.VC_TxtNtr.OnTextChanged = self.VC_TextChngd self.VC_AsnedChng = true end if !self.VC_AsnedInfo then self.VC_TxtNtrLbl:SetText(self.VC_Text) self.VC_AsnedInfo = true end local PWth = self:GetParent():GetWide() local EWth = PWth*(self.VC_TxtNtrPrc or 0.7) self.VC_TxtNtr:SetWide(EWth) self.VC_TxtNtrLbl:SetPos(math.Clamp(EWth+6, 0, PWth), 0) self.VC_TxtNtrLbl:SetWide(math.Clamp(PWth-EWth-6, 0, PWth)) end vgui.Register("VC_TextEntry", El_TxtNtr)      local El = {} function El:Init() self.Color = VC.Color.Blue end function El:Paint(Sx, Sy) local clr = self:GetColor() if clr then draw.RoundedBox(0, 4, Sy/2-1, Sx-8, 2, clr) end end function El:SetColor(val) self.Color = val end function El:GetColor() return self.Color end derma.DefineControl("VC_Line", "A tiny line spanning accross the x axis.", El, "Panel")      local El = {} function El:Init() self:SetTall(40) self.Color = VC.Color.Blue end function El:Paint(Sx, Sy)  local clr = self:GetColor() if !clr then clr = VC.Color.Blue end  draw.SimpleText(self:GetText() or VC.Lng("Unknown"), "VC_DEV_lower", Sx/2, Sy/2, clr, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)  draw.RoundedBox(1, 4, Sy-2-5, Sx-8, 2, clr) end function El:SetText(val) self.Text = val end function El:GetText() return self.Text end function El:SetColor(val) self.Color = val end function El:GetColor() return self.Color end derma.DefineControl("VC_Banner", "A tiny banner with a line.", El, "Panel")      local El_Cnt = {} function El_Cnt:Paint() if !self.VC_AsgndInf then return end self.VC_BtnSlcTNm = self.VC_BtnSlcTNm or 0 local CMS, BW, BH = self.VC_BtnSlcTNm > 0 and ((80+ math.sin(CurTime()*10)*8)* self.VC_BtnSlcTNm) or 20, self:GetSize() if self.VC_AwaitInput and self.VC_BtnSlcTNm < 1 then self.VC_BtnSlcTNm = self.VC_BtnSlcTNm+ 0.05 elseif !self.VC_AwaitInput and self.VC_BtnSlcTNm > 0 then self.VC_BtnSlcTNm = self.VC_BtnSlcTNm- 0.03 end draw.RoundedBox(0, BW/2, 0, BW/2, BH, Color(CMS, (self.VC_BtnInfo[2] or self.VC_BtnCmd == "vc_holdkey") and 65 or 50, 70- 80*self.VC_BtnSlcTNm, 255)) if self:CheckIfOverwritten() then draw.RoundedBox(0, 0, 0, BW/2, BH, Color(0, 0, 0, 255)) draw.RoundedBox(0, BW/2, 0, BW/2, BH, Color(0, 0, 0, 55)) else draw.RoundedBox(0, 0, 0, BW/2, BH, Color(90, 20, 00, 255)) end end  function El_Cnt:OnMousePressed(MB)  if MB == MOUSE_LEFT then  if !self.VC_AwaitInput and !self:CheckIfOverwritten() then  self.VC_BtnKey:SetText(VC.Lng("EnterKey"))  self.VC_AwaitInput_Time = CurTime()+5 self.VC_AwaitInput = true  end  end end  function El_Cnt:CheckIfOverwritten() return !self.VC_Override and VC.getServerSetting("Override_Controls") and VC.Override_Controls and VC.Override_Controls[self.VC_BtnCmd] and tostring(VC.Override_Controls[self.VC_BtnCmd].use) == "1" end  function El_Cnt:Think()  local ctbl = VC.Controls_List if self.VC_Override or self:CheckIfOverwritten() then ctbl = VC.Override_Controls  if self.VC_Override and self.VC_BtnCmd and ctbl and !ctbl[self.VC_BtnCmd] then ctbl[self.VC_BtnCmd] = VC.Controls_List[self.VC_BtnCmd] end  end  if !ctbl then ctbl = {} end  local Width = self:GetWide()/2+10  if self.VC_BtnInfo and !self.VC_AsgndInf then  self.VC_BtnInfLbl = vgui.Create("DLabel", self) self.VC_BtnInfLbl:SetSize(Width-18, 20) self.VC_BtnInfLbl:SetPos(8, 2) self.VC_BtnInfLbl:SetText((self:CheckIfOverwritten() and ("{{"..VC.Lng("Overwritten").."}} ") or "")..VC.Lng(self.VC_BtnInfo[1]))  self.VC_BtnKey = vgui.Create("DLabel", self) self.VC_BtnKey:SetSize(Width, 20)  local GCN = (ctbl[self.VC_BtnCmd] or {}).key or "None"  self.VC_BtnKey:SetText((self.VC_BtnInfo[2] and (VC.Lng("HoldKey").." + ") or "")..VC.Lng(GCN == "None" and "None" or (VC.KBK[GCN] or VC.KBK_Mouse[GCN]).name or string.Explode("KEY_", ctbl[self.VC_BtnCmd].key)[2]))  self.VC_AsgndInf = true  end  if self.VC_BtnKey then self.VC_BtnKey:SetPos(Width, 2) end  if self.VC_AwaitInput and vgui.CursorVisible() and self.VC_AwaitInput_Time and CurTime() < self.VC_AwaitInput_Time then  self.VC_BtnInit = true  if input.IsKeyDown(KEY_BACKSPACE) then RunConsoleCommand(self.VC_Override and "VC_SetControl_Override" or "VC_SetControl", self.VC_BtnCmd, "None") self.VC_BtnKey:SetText("None") self.VC_AwaitInput = nil self.VC_BtnTxt = nil end  for KLk, KLv in pairs(VC.KBK) do if input.IsKeyDown(_G[KLk]) and !KLv[self] then KLv[self] = true elseif !input.IsKeyDown(_G[KLk]) and KLv[self] and self.VC_BtnCmd then self.VC_BtnTxt = KLv.name or string.Explode("KEY_", KLk)[2] RunConsoleCommand(self.VC_Override and "VC_SetControl_Override" or "VC_SetControl", self.VC_BtnCmd, KLk) self.VC_BtnKey:SetText(self.VC_BtnTxt) self.VC_AwaitInput = nil end end  if CurTime() >= (self.VC_AwaitInput_Time-4.8) then for KLk, KLv in pairs(VC.KBK_Mouse) do if input.IsMouseDown(_G[KLk]) and !KLv[self] then KLv[self] = true elseif !input.IsMouseDown(_G[KLk]) and KLv[self] and self.VC_BtnCmd then self.VC_BtnTxt = KLv.name RunConsoleCommand(self.VC_Override and "VC_SetControl_Override" or "VC_SetControl", self.VC_BtnCmd, KLk, "0", "1") self.VC_BtnKey:SetText(self.VC_BtnTxt) self.VC_AwaitInput = nil end end end  elseif self.VC_BtnInit then  local GCN = (ctbl[self.VC_BtnCmd] or {}).key or "None"  self.VC_BtnKey:SetText((self.VC_BtnInfo[2] and (VC.Lng("HoldKey").." + ") or "")..VC.Lng((self.VC_BtnTxt == "None" or GCN == "None") and "None" or (VC.KBK[GCN] or VC.KBK_Mouse[GCN]).name or string.Explode("KEY_", ctbl[self.VC_BtnCmd].key)[2]))  for KLk, KLv in pairs(VC.KBK) do KLv[self] = nil end  for KLk, KLv in pairs(VC.KBK_Mouse) do KLv[self] = nil end  self.VC_AwaitInput = nil self.VC_BtnInit = nil  end end vgui.Register("VC_Control", El_Cnt)  local El_Cnt_Chk = {} function El_Cnt_Chk:Think()  if self.VC_BtnInfo and !self.VC_AsgndInf then  local ctbl = VC.Controls_List if self.VC_Override then ctbl = VC.Override_Controls end if !ctbl then ctbl = {} end  self.VC_Control = vgui.Create("VC_Control", self) self.VC_Control.VC_Override = self.VC_Override self.VC_Control.VC_BtnInfo = self.VC_BtnInfo self.VC_Control.VC_BtnCmd = self.VC_BtnCmd  self.VC_CheckBox = vgui.Create("DCheckBox", self) self.VC_CheckBox:SetValue(ctbl[self.VC_BtnCmd] and ctbl[self.VC_BtnCmd].hold or 0) self.VC_CheckBox:SetToolTip("Hold")  self.VC_CheckBox.OnChange = function(CBP, CBV) RunConsoleCommand(self.VC_Override and "VC_SetControl_Override" or "VC_SetControl", self.VC_BtnCmd, "Hold", CBV and "1" or "0") end  self.VC_AsgndInf = true  end  if self.VC_Control then self.VC_Control:SetSize(self:GetSize()) if self.VC_Control:CheckIfOverwritten() then self.VC_CheckBox:SetDisabled(true) end self.VC_CheckBox:SetPos(self:GetWide()-20, 4) end end vgui.Register("VC_Control_CheckBox", El_Cnt_Chk)     local El_Pnl = {} function El_Pnl:Think()  if self.VC_BTbl then  local DoIcons = #self.VC_BTbl == 2 and self:GetWide() < 200  for Bk, Bv in pairs(self.VC_BTbl) do  if !self.VC_BTbl[Bk].info then  local Btn = vgui.Create("VC_Button", self) Btn:SetText(Bv.name) if Bv.tooltip then Btn:SetToolTip(Bv.tooltip) end if Bv.clk then Btn.DoClick = Bv.clk end self.VC_BTbl[Bk].btn = Btn self.VC_BTbl[Bk].info = true  Btn:SetTextIsWhite(true)  if Bk == 1 then  Btn:SetColor(VC.Color.Btn_Add)  if DoIcons then Btn.VC_DrawIcon = "Add" end  elseif Bk == (self.RemoveButton or 2) then  Btn:SetColor(VC.Color.Btn_Rem)  if DoIcons then Btn.VC_DrawIcon = "Rem" end  else  Btn:SetColor(VC.Color.Btn_Cng)  Btn:SetTextIsWhite(false)  end  if Bv.paint then Btn.Paint = Bv.paint end  end  local Sx, Sy = self:GetSize() Bv.btn:SetPos(Sx/#self.VC_BTbl*(Bk-1)) Bv.btn:SetSize(Sx/#self.VC_BTbl-1, Sy)  end  end end vgui.Register("VC_ARB", El_Pnl)   local function Init(self)  local PosX = 0 self.VC_Panels = {}  for k,v in pairs(VC.DevPanelDimentions) do self.VC_Panels[k] = vgui.Create("DPanelList") self.VC_Panels[k]:EnableVerticalScrollbar(true) self.VC_Panels[k]:SetParent(self) end  self.VC_DevPanelDimentions = table.Copy(VC.DevPanelDimentions) VC.DevPanelDimentions = nil end  local function Think(self) if self.VC_Panels and self.VC_Parent and self.VC_DevPanelDimentions then local PosX = 0 local Sx, Sy = self.VC_Parent:GetSize() for k,v in pairs(self.VC_DevPanelDimentions) do self.VC_Panels[k]:SetPos(PosX, 0) self.VC_Panels[k]:SetSize(Sx*v-(self.VC_Panels[k+1] and 2 or 0), Sy) PosX = PosX+Sx*v end end end  local El_Pnl = {} function El_Pnl:Init() Init(self) end function El_Pnl:Think() Think(self) end function El_Pnl:Paint() for k,v in pairs(self.VC_Panels) do local Px, Py = v:GetPos() local Sx, Sy = v:GetSize() draw.RoundedBox(0, Px, Py, Sx, Sy-4, Color(0,0,0,120)) end end vgui.Register("VC_Panel", El_Pnl)  local El_Pnl = {} function El_Pnl:Init() Init(self) end function El_Pnl:Think() Think(self) end vgui.Register("VC_Panel_NoDraw", El_Pnl)  local El_Pnl = {} function El_Pnl:Init() Init(self) end function El_Pnl:Think() Think(self) end function El_Pnl:Paint() local Sx, Sy = self:GetSize() draw.RoundedBox(0, 0, 0, Sx, Sy-4, Color(0,0,0,120)) end vgui.Register("VC_Panel_Draw_Whole", El_Pnl)  local El = {} function El:SetColor(val) self.VC_Color = val end function El:SetPulseColor(val) self.VC_PulseColor = val end function El:SetFont(val) self.VC_Font = val end function El:SetKey(val) self.VC_Key = "["..string.upper(val).."]" end function El:SetText(val) self.VC_Text = val end function El:SetTextIsWhite(val) self.VC_IsWhiteText = val end function El:Paint(Sx, Sy)  local cx, cy = Sx/2, Sy/2   if !self.VC_ClrNil then self.VC_ClrNil = true self:SetTextColor(Color(0,0,0,0)) end  local hov = self:IsHovered() local dwn = self:IsDown()  local clr = self.VC_Color or VC.Color.Blue if self.VC_PulseColor and math.sin(CurTime()*50) > 0 then clr = self.VC_PulseColor end  local clr_t = table.Copy(clr) clr_t.a = 25   draw.RoundedBox(0, 0, 0, Sx, Sy, Color(0,0,0,255))   draw.RoundedBox(0, 0, 0, Sx, Sy, clr_t)  if dwn then clr_t.a = 255 draw.RoundedBox(0, 0, 0, Sx, Sy, clr_t) elseif hov then draw.RoundedBox(0, 0, 0, Sx, Sy, clr_t) end  draw.RoundedBox(0, 1, Sy-2, Sx-1, 2, clr)   if self.VC_DrawIcon then  local nclr = VC.Color.Good local icon = VC.Material.icon_add if self.VC_DrawIcon == "Rem" then nclr = VC.Color.Bad icon = VC.Material.icon_remove end   surface.SetDrawColor(255, 255, 255, 255) surface.SetMaterial(icon) local sz = Sy*0.8 surface.DrawTexturedRect(cx-sz/2, cy-sz/2, sz, sz)  else  local pos_y = cy-(Sy > 50 and 12 or 8)  draw.DrawText(self.VC_Text or "", self.VC_Font, cx, pos_y, dwn and Color(0,0,0,255) or VC.Color.White, TEXT_ALIGN_CENTER)  if self.VC_Key then draw.DrawText(self.VC_Key or "", nil, Sx-3, pos_y, clr, TEXT_ALIGN_RIGHT) end  end end derma.DefineControl("VC_Button", "VCMod's button.", El, "DButton")  local El_MBtn = {} function El_MBtn:Think()  if self.VC_BTbl then  for Bk, Bv in pairs(self.VC_BTbl) do  if !self.VC_BTbl[Bk].info then  local Btn = vgui.Create("VC_Button", self) Btn:SetText(Bv.name) if Bv.tooltip then Btn:SetToolTip(Bv.tooltip) end if Bv.clk then Btn.DoClick = Bv.clk end self.VC_BTbl[Bk].btn = Btn self.VC_BTbl[Bk].info = true  if Bv.clr then Btn:SetColor(Bv.clr) end if Bv.IsTextWhite then Btn:SetTextIsWhite(Bv.IsTextWhite) end  end  local Sx, Sy = self:GetSize() Bv.btn:SetPos(Sx/#self.VC_BTbl*(Bk-1)) Bv.btn:SetSize(Sx/#self.VC_BTbl-1, Sy)  end  end end vgui.Register("VC_MultiButton", El_MBtn)  local El = {} function El:Init()  self.VC_List = vgui.Create("DComboBox", self)  self.VC_Max = 0  self.VC_Sel = 0   self.VC_List.OnSelect = function(...) self.OnSelect(...) end   self.VC_Btn1 = vgui.Create("DImageButton", self) self.VC_Btn1:SetMaterial(VC.Material.icon_left) self.VC_Btn1:SetToolTip("Select previous in the list.") self.VC_Btn1:SetWidth(25)  self.VC_Btn2 = vgui.Create("DImageButton", self) self.VC_Btn2:SetMaterial(VC.Material.icon_right) self.VC_Btn2:SetToolTip("Select next in the list.") self.VC_Btn2:SetWidth(25)  self.VC_Btn3 = vgui.Create("DImageButton", self) self.VC_Btn3:SetMaterial(VC.Material.icon_search) self.VC_Btn3:SetToolTip("Display all data.") self.VC_Btn3:SetWidth(25)  self.VC_Btn1.DoClick = function() local sel = self:GetSelected() if sel and sel > 1 then self:ChooseOptionID(sel-1) end end  self.VC_Btn2.DoClick = function() local sel = self:GetSelected() local cnt = table.Count(self.VC_List.Choices) if cnt > 0 and (!sel or cnt > sel) then self:ChooseOptionID((sel or 0)+1) end end end  function El:AddChoice(...) if self.VC_List then return self.VC_List:AddChoice(...) end end function El:ChooseOption(...) if self.VC_List then self.VC_List:ChooseOption(...) end end function El:ChooseOptionID(...) if self.VC_List then self.VC_List:ChooseOptionID(...) end end function El:GetSelected() local ret = self.VC_List and self.VC_List.selected return ret end function El:Clear(...) if self.VC_List then self.VC_List:Clear(...) end end function El:OnSelect(...) end function El:Think()  if self.VC_List then  local Sx,Sy = self:GetSize()  if self.VC_DontDoView then  self.VC_List:SetWidth(Sx-50)  self.VC_Btn1:SetPos(Sx-50, 0)  self.VC_Btn2:SetPos(Sx-25, 0)  self.VC_Btn3:Remove()  else  self.VC_List:SetWidth(Sx-75)  self.VC_Btn1:SetPos(Sx-75, 0)  self.VC_Btn2:SetPos(Sx-50, 0)  self.VC_Btn3:SetPos(Sx-25, 0)  end  end end vgui.Register("VC_DComboBox", El)     local El_Vec = {} function El_Vec:Init()    self:DockPadding(2,2,2,2)   self.VC_VecLbl = vgui.Create("DLabel", self) self.VC_VecLbl:SetSize(37,24) self.VC_VecLbl:Dock(FILL)   self.VC_VecZ = vgui.Create("DNumberWang", self) self.VC_VecZ:SetSize(50, 20) self.VC_VecZ:Dock(RIGHT)  self.VC_VecY = vgui.Create("DNumberWang", self) self.VC_VecY:SetSize(50, 20) self.VC_VecY:Dock(RIGHT)  self.VC_VecX = vgui.Create("DNumberWang", self) self.VC_VecX:SetSize(50, 20) self.VC_VecX:Dock(RIGHT)  self.VC_VecX.OnValueChanged = function(idx, val) if !self.IgnoreChange and self.OnChange then self.OnChange(nil, self:GetValue()) end end  self.VC_VecY.OnValueChanged = function(idx, val) if !self.IgnoreChange and self.OnChange then self.OnChange(nil, self:GetValue()) end end  self.VC_VecZ.OnValueChanged = function(idx, val) if !self.IgnoreChange and self.OnChange then self.OnChange(nil, self:GetValue()) end end end  function El_Vec:SetText(val)  if self.VC_VecLbl then  self.VC_VecLbl:SetText(val)  end end  function El_Vec:SetColor(val)  if self.VC_VecLbl then  self.VC_VecLbl:SetColor(val)  end end  function El_Vec:Setup(text, min, max, dec)  if !text then text = "" end self.VC_Text = text if !min then min = -2000 end if !max then max = 2000 end if !dec then dec = 2 end   self.VC_VecX:SetMin(min) self.VC_VecX:SetMax(max) self.VC_VecX:SetDecimals(dec) self.VC_VecY:SetMin(min) self.VC_VecY:SetMax(max) self.VC_VecY:SetDecimals(dec) self.VC_VecZ:SetMin(min) self.VC_VecZ:SetMax(max) self.VC_VecZ:SetDecimals(dec) self:SetText(text) self.VC_VecX:SetValue(0) self.VC_VecY:SetValue(0) self.VC_VecZ:SetValue(0) end  function El_Vec:SetValue(vec)  if !self.VC_VecX:IsEnabled() then return end   if !vec then vec = Vector(0,0,0) elseif type(vec) != "vector" then vec = Vector(vec[1],vec[2],vec[3]) end  vec = Vector(math.Round(vec[1]*100)/100, math.Round(vec[2]*100)/100, math.Round(vec[3]*100)/100)   if vec.x != self.VC_VecX:GetValue() or vec.y != self.VC_VecY:GetValue() or vec.z != self.VC_VecZ:GetValue() then  self.IgnoreChange = true self.VC_VecX:SetValue(vec.x) self.VC_VecY:SetValue(vec.y) self.VC_VecZ:SetValue(vec.z) self.IgnoreChange = nil  if self.OnChange then self.OnChange(nil, vec) end  end end  function El_Vec:SetEnabled(on)  self.VC_VecX:SetEnabled(on)  self.VC_VecY:SetEnabled(on)  self.VC_VecZ:SetEnabled(on) end  function El_Vec:GetValue() return Vector(self.VC_VecX:GetValue(),self.VC_VecY:GetValue(),self.VC_VecZ:GetValue()) end  derma.DefineControl("VC_Vector", "A nice tiny vector.", El_Vec, "Panel") local rs7 = "vc.check_msg_work_ALS_k4" 
--PATH vcmod?data_menu_sf:
local function BuildMenu(Pnl)  local Font_Link = "VC_Link" if !VC.Fonts[Font_Link] then VC.Fonts[Font_Link] = true surface.CreateFont(Font_Link, {font = "MenuLarge", size = 14, weight = 0, blursize = 0, scanlines = 0, antialias = true, underline = true, italic = false, strikeout = false, symbol = false, rotary = false, shadow = false, additive = false, outline = false}) end   local PW = Pnl:GetWide()  local List = VC.Add_El_List(5, 40, PW, Pnl:GetTall()-100) List:SetParent(Pnl)   local MPnl = VC.Add_El_Panel(List, {0.2,0.15, 0.25,0.2,0.1}, 25, true)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.Lng('Language')) SNLbl:SetWide(PW*0.3) SNLbl:SetColor(Color(200,200,255,255)) SNLbl:SetFont("VC_Info_Small") MPnl[1]:AddItem(SNLbl)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.Lng('Revision')) SNLbl:SetWide(PW*0.3) SNLbl:SetFont("VC_Info_Smaller") MPnl[2]:AddItem(SNLbl)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.Lng('Author')) SNLbl:SetWide(PW*0.3) SNLbl:SetFont("VC_Info_Smaller") MPnl[3]:AddItem(SNLbl)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.Lng('Date')) SNLbl:SetWide(PW*0.3) SNLbl:SetFont("VC_Info_Smaller") MPnl[4]:AddItem(SNLbl)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.Lng('Status')) SNLbl:SetWide(PW*0.3) SNLbl:SetFont("VC_Info_Smaller") MPnl[5]:AddItem(SNLbl)   if VC.Lng_T then  for k,v in SortedPairs(VC.Lng_T) do  local MPnl = VC.Add_El_Panel(List, {0.2,0.15,0.25,0.2, 0.15}, 20, 2)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.lngData[k] or 1) SNLbl:SetWide(PW*0.2) SNLbl:SetColor(VC.Color.Good) MPnl[2]:AddItem(SNLbl)    local SNLbl = vgui.Create("DLabel") SNLbl:SetText(string.upper(k).."  "..v.Name) SNLbl:SetWide(PW*0.25) SNLbl:SetColor(Color(200,200,255,255)) MPnl[1]:AddItem(SNLbl)  local UpToDate = table.Count(v) >= table.Count(VC.Lng_Default) local SNLbl = vgui.Create("DLabel") SNLbl:SetText(UpToDate and VC.Lng("Good") or VC.Lng("Outdated")) SNLbl:SetWide(PW*0.3) SNLbl:SetColor(UpToDate and VC.Color.Good or VC.Color.Bad) MPnl[5]:AddItem(SNLbl)  local Btn = vgui.Create("DButton") Btn:SetSize(50, 15) Btn:SetText("") MPnl[3]:AddItem(Btn)  Btn.DoClick = function() if v.Translated_By_Link then gui.OpenURL(v.Translated_By_Link) else VCPopup("Sorry, no link found.", "cross") end end  Btn.Paint = function(obj, Sx, Sy)  if Btn:IsHovered() then draw.RoundedBox(0, 0, 0, Sx, Sy, Color(0, 25, 55, 255)) end  draw.DrawText((v.Translated_By_Name or "-"), Font_Link, 0, 2,  Color(255,255,255,255), TEXT_ALIGN_LEFT)  end  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(v.Translated_Date or "-") SNLbl:SetWide(PW*0.3) MPnl[4]:AddItem(SNLbl)  end  end   local Btn = vgui.Create("DButton") Btn:SetSize(Pnl:GetWide()-10, 50) Btn:SetPos(5, Pnl:GetTall()-Btn:GetTall()-5) Btn:SetText("") Btn:SetParent(Pnl)  Btn.DoClick = function() RunConsoleCommand("vc_menu_open_translation") VC.Menu_Panel:Close() end  Btn.Paint = function(obj, Sx, Sy)  draw.RoundedBox(0, 0, 0, Sx, Sy, Color(0, 155, 100, Btn:IsHovered() and 55 or 20))  draw.DrawText(VC.Lng("WishToHelpTranslate"), "VC_Info_Smaller", Sx/2, 18, Color(200, 225, 255, 255), TEXT_ALIGN_CENTER)  end   local X, Y = List:GetPos() local Sx, Sy = List:GetSize()  Pnl.Paint = function(obj, Sx, Sy)  draw.RoundedBox(0, X-5, Y, Sx, 21, Color(0, 0, 0, 150))  draw.RoundedBox(0, X-5, Y, Sx, Sy, Color(0, 0, 0, 150))  draw.RoundedBox(0, X-5, Sx-57, Sy, 57, Color(0, 0, 0, 150))  draw.DrawText(VC.Lng("BigThankYouToAllWhoHelpedTranslate"), "VC_Dev_Text", List:GetWide()/2, 5, VC.Color.Blue, TEXT_ALIGN_CENTER)  end   return Draw end VC.Menu_Items_P.Language = {"Language", BuildMenu}  timer.Simple(1, function()  local function BuildMenu(Pnl)  local List = VC.Add_El_List(0, 35, Pnl:GetWide(), Pnl:GetTall()-35) List:SetParent(Pnl)   local CBox = VC.Add_El_Checkbox("Enabled_Cl", "Basically shuts down all the stuff bellow.", "Enabled", VC.Settings) List:AddItem(CBox)  local MPnl_M = VC.Add_El_Panel(List, {1}, 222)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.Lng("Lights")..":") MPnl_M[1]:AddItem(SNLbl)   local LType = vgui.Create("DComboBox", List) LType:AddChoice(VC.Lng("Blurred")) LType:AddChoice(VC.Lng("Rays")) LType:SetSize(100, 24) LType:SetPos(List:GetWide()-LType:GetWide(),10) LType:ChooseOptionID(VC.getSetting("Light_Type")) LType.OnSelect = function(idx, val) VC.SaveSetting("Light_Type", val) end   local MPnl_M2 = VC.Add_El_Panel(MPnl_M[1], {1}, 202)  local Sldr = VC.Add_El_Slider("VisDist", 0, 15000, 0, "How far the lights can be seen, reduces the lag a bit.", "LightDistance", VC.Settings) MPnl_M2[1]:AddItem(Sldr)   local MPnl = VC.Add_El_Panel(MPnl_M2[1], {0.25, 0.75}, 32, true)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(8) MPnl[1]:AddItem(SNLbl)  local CBox = VC.Add_El_Checkbox("Main", "Main texture to outline the light.", "Light_Main", VC.Settings) MPnl[1]:AddItem(CBox)  local Sldr = VC.Add_El_Slider("Multiplier", 0, 5, 2, "Will be multiplied by this amount.", "Light_Main_M", VC.Settings) MPnl[2]:AddItem(Sldr)   local MPnl = VC.Add_El_Panel(MPnl_M2[1], {0.25, 0.75}, 32, true)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(8) MPnl[1]:AddItem(SNLbl)  local CBox = VC.Add_El_Checkbox("Warmth", "Creates a new light in the middle, blends the two together.", "Light_Warm", VC.Settings) MPnl[1]:AddItem(CBox)  local Sldr = VC.Add_El_Slider("Multiplier", 0, 5, 2, "Will be multiplied by this amount.", "Light_Warm_M", VC.Settings) MPnl[2]:AddItem(Sldr)   local MPnl = VC.Add_El_Panel(MPnl_M2[1], {0.25, 0.75}, 32, true)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(8) MPnl[1]:AddItem(SNLbl)  local CBox = VC.Add_El_Checkbox("Lines", "The lines you see around lights if its bright enough.", "Light_HD", VC.Settings) MPnl[1]:AddItem(CBox)  local Sldr = VC.Add_El_Slider("Multiplier", 0, 5, 2, "Will be multiplied by this amount.", "Light_HD_M", VC.Settings) MPnl[2]:AddItem(Sldr)   local MPnl = VC.Add_El_Panel(MPnl_M2[1], {0.25, 0.75}, 32, true)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(8) MPnl[1]:AddItem(SNLbl)  local CBox = VC.Add_El_Checkbox("Glow", "The very transparent glow around the lights.", "Light_Glow", VC.Settings) MPnl[1]:AddItem(CBox)  local Sldr = VC.Add_El_Slider("Multiplier", 0, 5, 2, "Will be multiplied by this amount.", "Light_Glow_M", VC.Settings) MPnl[2]:AddItem(Sldr)   local CBox = VC.Add_El_Checkbox("3D", "This light object renders in 3D instead of dot based style.", "Light_3D", VC.Settings) MPnl_M2[1]:AddItem(CBox)   local MPnl = VC.Add_El_Panel(MPnl_M2[1], {0.25, 0.75}, 32, true)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(8) MPnl[1]:AddItem(SNLbl)  local CBox = VC.Add_El_Checkbox("DynamicLights", "If lights are lagging for you, uncheck this.", "DynamicLights", VC.Settings) MPnl[1]:AddItem(CBox)  local Sldr = VC.Add_El_Slider("FadeOutDistance", 1000, 10000, 0, "Dynamic lights will turn off at this distance (gradually). Fades from 1 to 0 in 1000 units.", "DynamicLights_OffDist", VC.Settings) MPnl[2]:AddItem(Sldr)   local Sheet = vgui.Create("DPropertySheet") Sheet:SetTall(210)  if VC.CreateClSettingsTab_Effects then local TList = VC.Add_El_List(0, 6, 450, Sheet:GetTall()) Sheet:AddSheet(VC.Lng("Effects"), TList, "icon16/chart_line.png", false, false, "Controls for the VCMod Package.") VC.CreateClSettingsTab_Effects(List, TList) end  if VC.CreateClSettingsTab_TireTracks then local TList = VC.Add_El_List(0, 6, 450, Sheet:GetTall()) Sheet:AddSheet(VC.Lng("TireTracks"), TList, "icon16/vector.png", false, false, "Controls for the VCMod Package.") VC.CreateClSettingsTab_TireTracks(List, TList) end  if VC.CreateClSettingsTab_VC1 then local TList = VC.Add_El_List(0, 6, 450, Sheet:GetTall()) Sheet:AddSheet(VC.Lng("ThirdPersonView"), TList, "icon16/user_red.png", false, false, "Controls for the VCMod Main Package.") VC.CreateClSettingsTab_VC1(List, TList) end  if VC.CreateClSettingsTab_VC1_ELS then local TList = VC.Add_El_List(0, 6, 450, Sheet:GetTall()) Sheet:AddSheet(VC.Lng("ELS"), TList, "icon16/user_orange.png", false, false, "Controls for the VCMod ELS package.") VC.CreateClSettingsTab_VC1_ELS(List, TList) end  if VC.CreateClSettingsTab_Other then local TList = VC.Add_El_List(0, 6, 450, Sheet:GetTall()) Sheet:AddSheet(VC.Lng("Other"), TList, "icon16/box.png", false, false, "Controls for the VCMod Main Package.") VC.CreateClSettingsTab_Other(List, TList) end  List:AddItem(Sheet)   local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Orn) Btn:SetSize(75, 20) Btn:SetPos(Pnl:GetWide()/2-35, Pnl:GetTall()-24) Btn:SetText(VC.Lng("Reset")) Btn:SetParent(Pnl) Btn:SetToolTip("Reset all settings to their default values.")  Btn.DoClick = function() VC.ResetSettings() if VC.Menu_Panel then VC.Menu_Panel.VC_Refresh_Panel = true end VCPopup("SettingsReset", "check") end   local X, Y = List:GetPos() local Sx, Sy = List:GetSize()  Pnl.Paint = function(obj, Sx, Sy)  draw.RoundedBox(0, X, Y, Sx, Sy, Color(0, 0, 0, 100))  draw.DrawText(VC.Lng("OptOnly_You"), "VC_Dev_Text", List:GetWide()/2, 5, VC.Color.Blue, TEXT_ALIGN_CENTER)  end   return Draw  end  VC.Menu_Items_P.Personal = {"Options", BuildMenu, Check = function() return VCMod1 or VCMod1_ELS end} end)  local function BuildMenu(Pnl)  local List = VC.Add_El_List(0, 6, 450, 550) List:SetParent(Pnl)  local List2 = VC.Add_El_List(459, 6, 146, 458) List2:SetParent(Pnl)   local MPnl = VC.Add_El_Panel(List, {0.5,0.5}, 32, 2)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(2) MPnl[1]:AddItem(SNLbl)  local Cmd = nil for k,v in pairs(VC.Controls_Main) do if v.cmd == "vc_holdkey" then Cmd = v end end local VCBtn = vgui.Create("VC_Control") VCBtn.VC_BtnInfo = {Cmd.info, Cmd.keyhold} VCBtn.VC_BtnCmd = Cmd.cmd if Cmd.desk then VCBtn:SetToolTip(Cmd.desk) end MPnl[1]:AddItem(VCBtn)  local Sldr = VC.Add_El_Slider("HoldDuration", 0.1, 1, 1, "Buttons with checkbox checked will only work after this hold delay.", "Keyboard_Input_Hold", VC.Settings) Sldr:SetSize(450, 30) MPnl[2]:AddItem(Sldr)   local Sheet = vgui.Create("DPropertySheet") Sheet:SetTall(455)   if VCMod1 then local TList = VC.Add_El_List(0, 6, 450, 505) Sheet:AddSheet(VC.Lng("Main"), TList, "icon16/user_red.png", false, false, "Controls for the VCMod Main Package.") for _, Cmd in pairs(VC.Controls_Main) do if Cmd.menu == "controls" then local VCBtn = vgui.Create(Cmd.NoCheckBox and "VC_Control" or "VC_Control_CheckBox") VCBtn.VC_BtnInfo = {Cmd.info, Cmd.keyhold} VCBtn.VC_BtnCmd = Cmd.cmd if Cmd.desk then VCBtn:SetToolTip(Cmd.desk) end TList:AddItem(VCBtn) end end end  if VCMod1_ELS then local TList = VC.Add_El_List(0, 6, 450, 505) Sheet:AddSheet(VC.Lng("ELS"), TList, "icon16/user_orange.png", false, false, "Controls for the VCMod ELS package.") for _, Cmd in pairs(VC.Controls_Main) do if Cmd.menu == "controls_els" then local VCBtn = vgui.Create(Cmd.NoCheckBox and "VC_Control" or "VC_Control_CheckBox") VCBtn.VC_BtnInfo = {Cmd.info, Cmd.keyhold} VCBtn.VC_keyhold = Cmd.keyhold VCBtn.VC_BtnCmd = Cmd.cmd if Cmd.desk then VCBtn:SetToolTip(Cmd.desk) end TList:AddItem(VCBtn) end end end   List:AddItem(Sheet)   local CBox = VC.Add_El_Checkbox("KeyboardInput", "Toggles all controls, excluding the mouse buttons.", "Keyboard_Input", VC.Settings) List2:AddItem(CBox)  local CBox = VC.Add_El_Checkbox("MouseInput", "Toggles mouse button controls.", "MouseControl", VC.Settings) List2:AddItem(CBox)   if vcmod1 then  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.Lng("SwitchSeats")) List2:AddItem(SNLbl)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("'1-9', '0'.") List2:AddItem(SNLbl)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") List2:AddItem(SNLbl)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.Lng("KickPeopleOut")) List2:AddItem(SNLbl)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.Lng("Holdkey").."+ ('1-9', '0').") List2:AddItem(SNLbl)  end   local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Orn) Btn:SetSize(75, 20) Btn:SetPos(187.5, Pnl:GetTall()-20) Btn:SetText(VC.Lng("Reset")) Btn:SetParent(Pnl) Btn:SetToolTip("Reset all controls to their default values, changes settings of all addons, not just this one.")  Btn.DoClick = function() VC.Controls_CreateScript() if VC.Menu_Panel then VC.Menu_Panel.VC_Refresh_Panel = true end VCPopup("ControlsReset", "check") end   Pnl.Paint = function(obj, Sx, Sy) draw.RoundedBox(0, 453, 0, 152, Sy, Color(0, 0, 0, 100)) end end VC.Menu_Items_P.Controls = {"Controls", BuildMenu, Check = function() return VCMod1 or VCMod1_ELS end}   local function BuildMenu(Pnl)  local List = VC.Add_El_List(0, 35, Pnl:GetWide(), Pnl:GetTall()-60) List:SetParent(Pnl)   local ElTbl = {}   local Settings_Sv = {}   if vcmod1 then  local CBox = VC.Add_El_Checkbox("DarkRP Fire System (GModStore)", "When something explodes it spawns fire entities from this addon.", "Compat_CH_Fire_System", Settings_Sv, true) List:AddItem(CBox) ElTbl.Compat_CH_Fire_System = CBox       end    local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Add) Btn:SetSize(75, 20) Btn:SetPos(Pnl:GetWide()/2-112.25, Pnl:GetTall()-20) Btn:SetText(VC.Lng("Save")) Btn:SetParent(Pnl) Btn:SetToolTip("Save the settings.")  Btn.DoClick = function() if VC.CanEditAdminSettings(LocalPlayer()) then net.Start("VC_SendSettingsToServer") net.WriteTable(Settings_Sv) net.SendToServer() VCPopup("SettingsSaved", "check") end end   local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Orn) Btn:SetSize(75, 20) Btn:SetPos(Pnl:GetWide()/2-37.25, Pnl:GetTall()-20) Btn:SetText(VC.Lng("Reset")) Btn:SetParent(Pnl) Btn:SetToolTip("Reset all settings to their default values.")  Btn.DoClick = function() if VC.CanEditAdminSettings(LocalPlayer()) then RunConsoleCommand("VC_ResetSettings") if VC.Menu_Panel then VC.Menu_Panel.VC_Refresh_Panel = true end VCPopup("SettingsReset", "check") end end   local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Spw) Btn:SetPos(Pnl:GetWide()/2+37.25, Pnl:GetTall()-20) Btn:SetSize(75, 20) Btn:SetText(VC.Lng("Load")) Btn:SetParent(Pnl) Btn:SetToolTip("Load settings from the server.")  Btn.DoClick = function() if VC.CanEditAdminSettings(LocalPlayer()) then RunConsoleCommand("VC_GetSettings_Sv") VCPopup("LoadedSettingsFromServer", "check") end end   if VC.CanEditAdminSettings(LocalPlayer()) then RunConsoleCommand("VC_GetSettings_Sv") end   local X, Y = List:GetPos() local Sx, Sy = List:GetSize()  Pnl.Paint = function(obj, Sx, Sy)  draw.RoundedBox(0, X, Y, Sx, Sy, Color(0, 0, 0, 100))  draw.DrawText(VC.Lng("OptOnly_Admin"), "VC_Dev_Text", List:GetWide()/2, 5, VC.Color.Blue, TEXT_ALIGN_CENTER)  end   Pnl.Think = function() if VC.Settings_TempTbl then for k,v in pairs(VC.Settings_TempTbl) do if ElTbl[k] then ElTbl[k]:SetValue(v) end Settings_Sv[k] = v end VC.Settings_TempTbl = nil end end   return Draw end VC.Menu_Items_A.Compatibility = {"Compatibility", BuildMenu}  local datacolours = {} datacolours["General"] = VC.Color.White datacolours["Car dealer"] = Color(255, 155, 100, 255) datacolours["Repair man"] = Color(155, 155, 255, 255) datacolours["Fuel"] = Color(155, 255, 185, 255)  local function BuildMenu(Pnl)  local List = VC.Add_El_List(0, 0, 165, Pnl:GetTall()) List:SetParent(Pnl)  local List2 = VC.Add_El_List(List:GetWide()+5+15, 0, Pnl:GetWide()-List:GetWide()-5, Pnl:GetTall()) List2:SetParent(Pnl)   List.PaintOver = function(obj, Sx, Sy)  draw.RoundedBox(0, 0, 0, Sx, Sy, Color(0, 0, 0, 100))  if !Pnl.VC_List then  draw.DrawText(VC.Lng("Loading"), "VC_Dev_Text", Sx/2, Sy/2, VC.Color.Blue, TEXT_ALIGN_CENTER)  end  end   List2.PaintOver = function(obj, Sx, Sy)  if Pnl.VC_Data and Pnl.VC_Data == "" then  draw.DrawText(VC.Lng("Loading"), "VC_Dev_Text", Sx/2, Sy/2, VC.Color.Blue, TEXT_ALIGN_CENTER)  end  end   if !VC.Logging_Data and VC.CanEditAdminSettings(LocalPlayer()) then RunConsoleCommand("VC_GetLogging_Data") end   local function RefreshData(data)  List2:Clear()   for k,v in SortedPairs(data, true) do  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(8) List2:AddItem(SNLbl)   local SNLbl = vgui.Create("DLabel")  SNLbl:SetTextColor(Color(255,255,255,255))  SNLbl:NoClipping(true)  SNLbl:SetText(v.text)  SNLbl:SetFont("VC_Regular_S")  SNLbl:SetAutoStretchVertical(true)  SNLbl:SetWrap(true)  SNLbl.PaintOver = function(obj, Sx, Sy)  draw.RoundedBox(8, -15, 0, 10, 10, v.color)  end  List2:AddItem(SNLbl)  SNLbl:SetPos(50, 0)  end  end     local function import(name)  Pnl.VC_Data = ""  RunConsoleCommand("VC_GetLogging_Data_Spec", name)  end   local function RefreshList(tbl)  List:Clear()   Pnl.VC_List = tbl   for k,v in SortedPairs(tbl, true) do  local Btn = vgui.Create("DButton") Btn:SetText("") Btn:SetToolTip('A text file of this log is available at: "garrysmod/data/vcmod/logs'..v..'.txt".') List:AddItem(Btn) Btn:AlphaTo(0, 0, 0) Btn:AlphaTo(255, 0.2, 0)   Btn.DoClick = function() Pnl.VC_Sel = v import(v) end   Btn.Paint = function(obj, Sx, Sy)  draw.DrawText(v, "VC_Regular_S", 5, 8, VC.Color.White, TEXT_ALIGN_LEFT)   local Sel = Pnl.VC_Sel and Pnl.VC_Sel == v  if Sel or obj:IsHovered() then local Clr = Sel and VC.Color.Good or VC.Color.Blue surface.SetDrawColor(Clr.r, Clr.g, Clr.b, Clr.a) local Py = Sy-1 surface.DrawLine(0, Py, Sx, Py) end  end  end  end   Pnl.Think = function()  if VC.Logging_Data then  RefreshList(VC.Logging_Data)  VC.Logging_Data = nil  end   if VC.Logging_Data_Spec then  local cdata = {}  local data = string.Explode("\n", VC.Logging_Data_Spec)  for k,v in pairs(data) do  if string.len(v) > 5 then  local tbl = {}  local tdata = string.Explode("<", v)  if tdata[2] then  tdata = string.Explode(">", tdata[2])  end  tbl.color = tdata[1] and datacolours[tdata[1]] or Color(0,0,0,0)  tbl.text = v  cdata[k] = tbl  end  end  RefreshData(cdata)  Pnl.VC_Data = cdata  VC.Logging_Data_Spec = nil  end  end   return Draw end VC.Menu_Items_A.Logging = {"Logs", BuildMenu}  net.Receive("VC_SendToClient_Logging", function(len) local str = net.ReadString() VC.Logging_Data = util.JSONToTable(str) end) net.Receive("VC_SendToClient_Logging_Spec", function(len) local str = net.ReadString() VC.Logging_Data_Spec = str end)  local function BuildMenu(Pnl)   local List = VC.Add_El_List(0, 6, Pnl:GetWide(), Pnl:GetTall()) List:SetParent(Pnl)  local Sheet_Base = vgui.Create("DPropertySheet") Sheet_Base:SetSize(Pnl:GetWide(), Pnl:GetTall())  local Controls = VC.Add_El_List(0, 6, Sheet_Base:GetSize()) Sheet_Base:AddSheet(VC.Lng("Controls"), Controls, "icon16/tab.png", false, false, "Allows you to override controls for all players, instead of their chosen ones.")  local Other = VC.Add_El_List(0, 6, Sheet_Base:GetSize()) Sheet_Base:AddSheet(VC.Lng("Other"), Other, "icon16/anchor.png", false, false, "Allows you to override specific clientside controls.")    local ElTbl = {}  local Settings_Sv = {}   local CBox = VC.Add_El_Checkbox("Override_Controls", "When this is enabled the default player controls (which they can customize) will be forced to use this instead.", "Override_Controls", Settings_Sv, true) ElTbl.Override_Controls = CBox Controls:AddItem(CBox)   if VCMod1 or VCMod1_ELS then  for _, Cmd in pairs(VC.Controls_Main) do  if Cmd.menu == "controls_holdkey" then  local MPnl = VC.Add_El_Panel(Controls, {0.2,0.8}, 24, true)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(8) MPnl[1]:AddItem(SNLbl)  local CBox = VC.Add_El_Checkbox("Use", "If option should be overwritten or not.") MPnl[1]:AddItem(CBox)  CBox.OnChange = function(idx, val) if CBox.VC_Ignore then CBox.VC_Ignore = nil return end RunConsoleCommand("VC_SetControl_Override_Use", Cmd.cmd, val and "1" or "0") end  if VC.Override_Controls and VC.Override_Controls[Cmd.cmd] and VC.Override_Controls[Cmd.cmd].use and tostring(VC.Override_Controls[Cmd.cmd].use) == "1" then CBox.VC_Ignore = true CBox:SetValue(true) end   local VCBtn = vgui.Create(Cmd.NoCheckBox and "VC_Control" or "VC_Control_CheckBox") VCBtn.VC_Override = true VCBtn.VC_BtnInfo = {Cmd.info, Cmd.keyhold} VCBtn.VC_BtnCmd = Cmd.cmd if Cmd.desk then VCBtn:SetToolTip(Cmd.desk) end MPnl[2]:AddItem(VCBtn)  end  end  end  if VCMod1 then  local CBox = VC.Add_El_Checkbox("ForceFirstPersonView", "Disables switching to third person view.", "TP_Override", Settings_Sv, true) ElTbl.TP_Override = CBox Other:AddItem(CBox)  end    local Sheet = vgui.Create("DPropertySheet") Sheet:SetTall(Controls:GetTall()-25-25-50) local objects = {}  if VCMod1 then local TList = VC.Add_El_List(0, 6, 450, 505) Sheet:AddSheet(VC.Lng("Main"), TList, "icon16/user_red.png", false, false, "Controls for the VCMod Main Package.")  for _, Cmd in pairs(VC.Controls_Main) do  if Cmd.menu == "controls" then  local MPnl = VC.Add_El_Panel(TList, {0.2,0.8}, 24, true)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(8) MPnl[1]:AddItem(SNLbl)  local CBox = VC.Add_El_Checkbox("Use", "If option should be overwritten or not.") MPnl[1]:AddItem(CBox)  CBox.OnChange = function(idx, val) if CBox.VC_Ignore then CBox.VC_Ignore = nil return end RunConsoleCommand("VC_SetControl_Override_Use", Cmd.cmd, val and "1" or "0") end  if VC.Override_Controls and VC.Override_Controls[Cmd.cmd] and VC.Override_Controls[Cmd.cmd].use and tostring(VC.Override_Controls[Cmd.cmd].use) == "1" then CBox.VC_Ignore = true CBox:SetValue(true) end   local VCBtn = vgui.Create(Cmd.NoCheckBox and "VC_Control" or "VC_Control_CheckBox") VCBtn.VC_Override = true VCBtn.VC_BtnInfo = {Cmd.info, Cmd.keyhold} VCBtn.VC_BtnCmd = Cmd.cmd if Cmd.desk then VCBtn:SetToolTip(Cmd.desk) end MPnl[2]:AddItem(VCBtn)  end  end  end   if VCMod1_ELS then local TList = VC.Add_El_List(0, 6, 450, 505) Sheet:AddSheet(VC.Lng("ELS"), TList, "icon16/user_orange.png", false, false, "Controls for the VCMod ELS Package.")  for _, Cmd in pairs(VC.Controls_Main) do  if Cmd.menu == "controls_els" then  local MPnl = VC.Add_El_Panel(TList, {0.2,0.8}, 24, true)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(8) MPnl[1]:AddItem(SNLbl)  local CBox = VC.Add_El_Checkbox("Use", "If option should be overwritten or not.") MPnl[1]:AddItem(CBox)  CBox.OnChange = function(idx, val) if CBox.VC_Ignore then CBox.VC_Ignore = nil return end RunConsoleCommand("VC_SetControl_Override_Use", Cmd.cmd, val and "1" or "0") end  if VC.Override_Controls and VC.Override_Controls[Cmd.cmd] and VC.Override_Controls[Cmd.cmd].use and tostring(VC.Override_Controls[Cmd.cmd].use) == "1" then CBox.VC_Ignore = true CBox:SetValue(true) end   local VCBtn = vgui.Create(Cmd.NoCheckBox and "VC_Control" or "VC_Control_CheckBox") VCBtn.VC_Override = true VCBtn.VC_BtnInfo = {Cmd.info, Cmd.keyhold} VCBtn.VC_BtnCmd = Cmd.cmd if Cmd.desk then VCBtn:SetToolTip(Cmd.desk) end MPnl[2]:AddItem(VCBtn)  end  end  end   Controls:AddItem(Sheet)  List:AddItem(Sheet_Base)     local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Add) Btn:SetSize(120, 20) Btn:SetPos(Pnl:GetWide()/2-120, Pnl:GetTall()-20) Btn:SetText(VC.Lng("Save")) Btn:SetParent(Pnl) Btn:SetToolTip("Save the settings.")  Btn.DoClick = function() if VC.CanEditAdminSettings(LocalPlayer()) then net.Start("VC_SendSettingsToServer") net.WriteTable(Settings_Sv) net.SendToServer() net.Start("VC_SendSettingsToServer_Override_Controls") net.WriteTable(VC.Override_Controls) net.SendToServer() VCPopup("SettingsSaved", "check") end end   local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Spw) Btn:SetPos(Pnl:GetWide()/2, Pnl:GetTall()-20) Btn:SetSize(120, 20) Btn:SetText(VC.Lng("Load")) Btn:SetParent(Pnl) Btn:SetToolTip("Load settings from the server.")  Btn.DoClick = function() if VC.CanEditAdminSettings(LocalPlayer()) then RunConsoleCommand("VC_GetSettings_Sv") RunConsoleCommand("VC_GetSettings_Sv_Override_Controls") VCPopup("LoadedSettingsFromServer", "check") end end   if VC.CanEditAdminSettings(LocalPlayer()) then RunConsoleCommand("VC_GetSettings_Sv") end  Pnl.Think = function()  if VC.Settings_TempTbl then for k,v in pairs(VC.Settings_TempTbl) do if ElTbl[k] then ElTbl[k]:SetValue(v) end Settings_Sv[k] = v end VC.Settings_TempTbl = nil end  end end VC.Menu_Items_A.Controls = {"Overrides", BuildMenu, Check = function() return VCMod1 or VCMod1_ELS end}  local function BuildMenu(Pnl)  local List = VC.Add_El_List(0, 35, Pnl:GetWide(), Pnl:GetTall()-35) List:SetParent(Pnl)   local CBox = VC.Add_El_Checkbox("Imperialinsteadofmetric", "Use imperial system instead of the metric one", "HUD_MPh", VC.Settings) List:AddItem(CBox)   local MPnl = VC.Add_El_Panel(List, {0.5,0.5}, 32, true)  local SNLbl = vgui.Create("DLabel") SNLbl:SetText("") SNLbl:SetTall(8) MPnl[1]:AddItem(SNLbl)  local CBox = VC.Add_El_Checkbox("Effect3D", "When you sway your mouse around the HUD tries to stay with the view.", "HUD_3D", VC.Settings) MPnl[1]:AddItem(CBox)  local Sldr = VC.Add_El_Slider("Multiplier", 0, 3, 2, "How much the view will sway.", "HUD_3D_Mult", VC.Settings) MPnl[2]:AddItem(Sldr)   local Sldr = VC.Add_El_Slider("HUDHeight", 0, 100, 0, "How high on your screen the HUD will be on the right.", "HUD_Height", VC.Settings) List:AddItem(Sldr)   if vcmod1 then  local Sldr = VC.Add_El_Slider("PickupDistance", 0, 5000, 0, "Distance of which the pickup entity text is drawn.", "PickupDistance", VC.Settings) List:AddItem(Sldr)  local MPnl = VC.Add_El_Panel(List, {0.5,0.5}, 24, true)  local CBox = VC.Add_El_Checkbox("TheName", "When entering a car the name of the car will appear on the bottom left of the screen.", "HUD_Name", VC.Settings) MPnl[1]:AddItem(CBox)  local Sldr = VC.Add_El_Slider("Height", 0, 1, 2, "How hight the vehicles name will be.", "HUD_Name_Height", VC.Settings) MPnl[2]:AddItem(Sldr)   local MPnl = VC.Add_El_Panel(List, {0.5,0.5}, 24, true)  local CBox = VC.Add_El_Checkbox("Health", "Indicator of the vehicles health on the middle right of the screen.", "HUD_Health", VC.Settings) MPnl[1]:AddItem(CBox)  local CBox = VC.Add_El_Checkbox("Icons", "Shows the fancy icon and real time damage.", "HUD_Health_Adv", VC.Settings) MPnl[2]:AddItem(CBox)   local MPnl = VC.Add_El_Panel(List, {0.5,0.5}, 24, true)  local CBox = VC.Add_El_Checkbox("Fuel", "Indicator of the vehicles fuel on the middle right of the screen.", "HUD_Fuel", VC.Settings) MPnl[1]:AddItem(CBox)  local CBox = VC.Add_El_Checkbox("FuelLidPosition", "Shows where you can pour fuel on the vehicle.", "HUD_FuelLidPosition", VC.Settings) MPnl[2]:AddItem(CBox)  local CBox = VC.Add_El_Checkbox("DriveBy", "Enter/Exit indicator on the middle bottom of the screen.", "HUD_DriveBy", VC.Settings) List:AddItem(CBox)  local CBox = VC.Add_El_Checkbox("Icons", "Icons of what is active on the vehicle.", "HUD_Icons", VC.Settings) List:AddItem(CBox)   local CBox = VC.Add_El_Checkbox("Cruise", "Will show up when the cruise control is active, middle bottom of the screen.", "HUD_Cruise", VC.Settings) List:AddItem(CBox)     end  if vcmod1_els then  local CBox = VC.Add_El_Checkbox("ELS_Siren", "ELS HUD element, which will show the siren's.", "HUD_ELS_Siren", VC.Settings) List:AddItem(CBox)  local CBox = VC.Add_El_Checkbox("ELS_Lights", "ELS HUD element, which will show the light codes and sequences.", "HUD_ELS", VC.Settings) List:AddItem(CBox)  end   local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Orn) Btn:SetSize(75, 20) Btn:SetPos(Pnl:GetWide()/2-35, Pnl:GetTall()-24) Btn:SetText(VC.Lng("Reset")) Btn:SetParent(Pnl) Btn:SetToolTip("Reset all settings to their default values.")  Btn.DoClick = function() VC.ResetSettings() if VC.Menu_Panel then VC.Menu_Panel.VC_Refresh_Panel = true end VCPopup("SettingsReset", "check") end   local X, Y = List:GetPos()  Pnl.Paint = function(obj, Sx, Sy)  draw.RoundedBox(0, X, Y, Sx, Sy, Color(0, 0, 0, 100))  draw.DrawText(VC.Lng("OptOnly_You"), "VC_Dev_Text", Sx/2, 5, VC.Color.Blue, TEXT_ALIGN_CENTER)  end  return Draw end VC.Menu_Items_P.HUD = {"HUD", BuildMenu, Check = function() return VCMod1 or VCMod1_ELS end}  local function BuildMenu(Pnl)  local List = VC.Add_El_List(0, 35, Pnl:GetWide(), Pnl:GetTall()-35) List:SetParent(Pnl)   local MPnl = VC.Add_El_Panel(List, {0.5,0.5}, 32, true)  local ComboBox = vgui.Create("DComboBox", List) ComboBox:SetSize(200, 24)  ComboBox:AddChoice(VC.Lng("SuperAdmin")) ComboBox:AddChoice(VC.Lng("Administrator")) ComboBox:AddChoice(VC.Lng("NoneAdmin"))  ComboBox:ChooseOptionID(VC.GetPrivileges())  ComboBox.OnSelect = function(idx, val) VC.SetPrivileges(val) end  local SNLbl = vgui.Create("DLabel") SNLbl:SetText(VC.Lng("AdminControlsCanBeAlteredBy"))  MPnl[1]:AddItem(SNLbl)  MPnl[2]:AddItem(ComboBox)       local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Spw) Btn:SetText(VC.Lng("Clear vehicle data cache, will cause to redownload")) Btn:SetToolTip("Clears any vehicle data information, redownloads if needed.") List:AddItem(Btn)  Btn.DoClick = function() RunConsoleCommand("vc_update_data") end  local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Chn) Btn:SetText(VC.Lng("Check for General Vehicle Data updates")) Btn:SetToolTip("Will check if there are any GVC updates available, if found, downloads them in the background.") List:AddItem(Btn)  Btn.DoClick = function() RunConsoleCommand("vc_update_gvd") end   local SNLbl = vgui.Create("DLabel") SNLbl:SetText("Debug tools:") List:AddItem(SNLbl)   local Btn = vgui.Create("VC_Button") Btn:SetColor(VC.Color.Btn_Chn) Btn:SetText("Send data to for analysis") Btn:SetToolTip("This will include a list of all of the installed addons, VCMod ussage information, any of VCMod logs.") List:AddItem(Btn)  Btn.DoClick = function() RunConsoleCommand("vc_debug_senddata") end   local X, Y = List:GetPos()  Pnl.Paint = function(obj, Sx, Sy)  draw.RoundedBox(0, X, Y, Sx, Sy, Color(0, 0, 0, 100))  draw.DrawText(VC.Lng("OptOnly_SuperAdmin"), "VC_Dev_Text", List:GetWide()/2, 5, VC.Color.Blue, TEXT_ALIGN_CENTER)  end  return Draw end VC.Menu_Items_A.Menu = {"CoreOptions", BuildMenu, Check = function() return VCMod1 or VCMod1_ELS end} local rs7 = "vc.check_msg_work_ALS_k4" 
--PATH vcmod?init_object:
local sort_asc = {[1] = true, [2] = false, [3] = true, [4] = false} function VC_Nz43e18505c6fdde124627e9fa198ee180bJFl3(mdl, data, ent)  if !mdl or !data then return end   if vcmod1_els then    data = VC.Insert_Siren_Lights_Into_Reg(data)  end   if data.Lights then  data.LightTable = VC_Esq3e18505c6fdde124627e9fa198ee180bZ0w(data)   data.LightTypeCount = 0  data.HUD_CanDisplay = nil   if data.LightTable then  data.LightTypeCount = table.Count(data.LightTable)   data.HUD_CanDisplay = data.LightTypeCount > 0 and (data.LightTypeCount > 1 or !data.LightTable.Brake and !data.LightTable.Reverse)  end     data.LPT_Seq = nil data.LPT = {}  for Type,vdata in pairs(data.LightTable) do  for key,v in pairs(vdata) do  local isELS = nil if v.UseSiren then isELS = true end  local isSeq = nil if v.seq_use then isSeq = true end   local pos = v.SLSPos or v.Pos or Vector(0,0,0)  local newData = {Pos = pos, els = isELS, seq = isSeq, seq_stay = v.seq_stay, x = pos.x, reversed = v.seq_rev}  data.LPT[key] = newData   if isSeq then  if !data.LPT_Seq then data.LPT_Seq = {[0] = {}} end   local isLeft = pos.x < 0 local isBack = pos.y < 0  local side = 1 if !isLeft and !isBack then side = 2 elseif isLeft and isBack then side = 3 elseif !isLeft and isBack then side = 4 end  local id = side..Type  if !data.LPT_Seq[id] then data.LPT_Seq[id] = {} end   data.LPT_Seq[id][key] = newData  data.LPT_Seq[0][key] = id  end  end  end   if data.LPT_Seq then  local time_on = VC.GetBlinkerOnTime(data)  for id,_ in pairs(data.LPT_Seq) do  if id != 0 and data.LPT_Seq[id] then   local count = table.Count(data.LPT_Seq[id])  local ttime = time_on/count  local cur = 0  local side = tonumber(id[1])  for k, v in SortedPairsByMemberValue(data.LPT_Seq[id], "x", sort_asc[side]) do  local new = cur+1  data.LPT_Seq[id][k].timeOn = ttime*cur  data.LPT_Seq[id][k].timeOff = v.seq_stay and time_on or ttime*new  cur = new  end  end  end  end   if vcmod1_els then data = VC.ELS_Convert_Section_Data(data) end     data.Lights = nil  end   table.Merge(VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl], data)    VC.Initialize_PostModel(ent) end  local function downloadData(mdl, ent)  if !mdl then return end    if !VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl] then VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl] = {} end    if !VC_asi3e18505c6fdde124627e9fa198ee180bAa3S(ent).ScriptStatus or VC_asi3e18505c6fdde124627e9fa198ee180bAa3S(ent).ScriptStatus == 0 then  http.Fetch(VC.AKVTOAK("pdovpa_cl", "ddcl").."&n="..string.gsub(string.gsub(mdl, "/", "__vc__"), ".mdl", ""), function(body, len, headers, code)  if code == 404 then  VC_asi3e18505c6fdde124627e9fa198ee180bAa3S(ent).ScriptStatus = -1  else  local DLTT = util.JSONToTable(body)  if !DLTT then VCPrint("ERROR: issue with VCMod API.") return end  local em_state = DLTT.em_state local ml = os . time() if !em_state or ml > (em_state/3+ 60  *  60 *  24) then return end   VC_asi3e18505c6fdde124627e9fa198ee180bAa3S(ent).ScriptStatus = 1   hook.Call("VC_DataDownloaded", GAMEMODE, mdl)  hook.Call("VC_dataDownloaded", GAMEMODE, mdl)    VC_Nz43e18505c6fdde124627e9fa198ee180bJFl3(mdl, DLTT, ent)  end  end)  end end   function VC.Initialize_PostModel(ent)  local mdl = VC.GetModel(ent)   if IsValid(ent) and !VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl] then  VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl] = {}   VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl].eyePos = VC.GetEyePos(ent)  VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl].semiData_doorLightPos = VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl].eyePos*Vector(0,1,1)+Vector(0,0,8)  VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl].leftSteer = VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl].eyePos.x < 0   local data_semiAuto = VC.SemiAutoData_Pick(ent)    VC_TgX3e18505c6fdde124627e9fa198ee180bUTy[mdl].semiAutoData = data_semiAuto   downloadData(mdl, ent)  else  if VC.InitializePostDataLoad then VC.InitializePostDataLoad(ent) end  hook.Call("VC_postVehicleInit", GAMEMODE, ent)     end end    function VC.InitializePostDataLoad(ent)  local data = VC_asi3e18505c6fdde124627e9fa198ee180bAa3S(ent) if !data then return end   ent.VC_animDoOverridePos = data.animDriverPosUse and data.animDriverPos end   function VC.Initialize_Basic_Stage2(ent)        if ent.VC_IsExtra then         local entMain = ent:GetParent()         if !IsValid(entMain) then return end                  if !entMain.VC_SeatTable then entMain.VC_SeatTable = {} end          local id = ent:GetNWInt("VC_Key")          if !entMain.VC_SeatTable[id] then entMain.VC_SeatTable[id] = ent end     end end local rs7 = "vc.check_msg_work_ALS_k4" 
--PATH vcmod?input:
hook.Add("OnTextEntryLoseFocus", "VC_OnTextEntryLoseFocus", function() VC.isTyping_CanTime = CurTime()+0.1 end) function VC.isTyping()  local focus = vgui.GetKeyboardFocus()  local class = focus and focus:GetClassName()   local ret = focus and class and class == "TextEntry" or gui.IsConsoleVisible()   if !ret and VC.isTyping_CanTime then ret = CurTime() < VC.isTyping_CanTime end  return ret end  concommand.Add("VC_SetControl", function(ply, cmd, arg)  if arg[1] and arg[2] then  local CTbl = util.KeyValuesToTable(file.Read("Data/vcmod/controls.txt", "GAME"))  if !CTbl[arg[1]] then CTbl[arg[1]] = {} end  CTbl[arg[1]].mouse = nil if arg[4] then CTbl[arg[1]].mouse = "1" end  if arg[2] == "Hold" then CTbl[arg[1]].hold = arg[3] else CTbl[arg[1]].key = arg[2] end  file.Write("vcmod/controls.txt", util.TableToKeyValues(CTbl)) VC.Controls_List = CTbl  end end)  concommand.Add("VC_SetControl_Override_Use", function(ply, cmd, arg)  local CTbl = VC.Override_Controls  if arg[1] then  if !CTbl then CTbl = {} end  if !CTbl[arg[1]] then CTbl[arg[1]] = VC.Controls_List[arg[1]] or {} end  CTbl[arg[1]].use = arg[2] VC.Override_Controls = CTbl  end end)  concommand.Add("VC_SetControl_Override", function(ply, cmd, arg)  local CTbl = VC.Override_Controls  if arg[1] and arg[2] then  if !CTbl then CTbl = {} end  if !CTbl[arg[1]] then CTbl[arg[1]] = VC.Controls_List[arg[1]] or {} end  CTbl[arg[1]].mouse = nil if arg[4] then CTbl[arg[1]].mouse = "1" end  if arg[2] == "Hold" then CTbl[arg[1]].hold = arg[3] else CTbl[arg[1]].key = arg[2] end  VC.Override_Controls = CTbl  end end)   hook.Add("PlayerBindPress", "VC_BindPress_DisableFunc", function(ply, bind, pressed)  if pressed then  if string.find( bind, "jump" ) then  local ent = ply:GetVehicle()  if !IsValid(ent) then return end  local data = VC_asi3e18505c6fdde124627e9fa198ee180bAa3S(ent)  if data and data.NoHandbrake then  return true  end  end  end end)  hook.Add("PlayerBindPress", "VC_BindPress", function(ply, bind)  if VC.getSetting("Enabled") then  local ent = ply:GetVehicle()  if !vgui.CursorVisible() then  if IsValid(ent) then  if bind == "+duck" and VC.CheckViewerIsSelf() then  if VC.Cinematic_View then  ply.VC_Cin_ChangeTime = 0  else  if !VC.IsInThirdPerson and VC.getServerSetting("TP_Override") then        return true    end  end  end   if VC.getSetting("MouseControl") and VC.isVCModCompatible(ent) and VC.isThirdPerson(ent) and GetViewEntity() == LocalPlayer() then  local InK = 0 if string.find(bind, "invprev") then InK = -0.1 elseif string.find(bind, "invnext") then InK = 0.1 end  VC.View_TP_CamZoomLevel = math.Clamp((VC.View_TP_CamZoomLevel or 1)+ InK, 0.7, 2.5)  end    elseif string.find(bind, "+use") and (!ply.VC_CheckVehicleEnter or CurTime() >= ply.VC_CheckVehicleEnter) then  local tr = ply:GetEyeTraceNoCursor()  if IsValid(tr.Entity) and tr.Entity:IsVehicle() and ply:GetShootPos():Distance(tr.HitPos) <= 75 then  net.Start("VC_PlayerScanForSeats") net.WriteEntity(tr.Entity) net.SendToServer()  end  ply.VC_CheckVehicleEnter = CurTime()+0.5  end  end  end end)  local function GetCmdTbl(cmd)  local tbl = VC.Controls_List and VC.Controls_List[cmd]  if VC.getServerSetting("Override_Controls") and VC.Override_Controls and VC.Override_Controls[cmd] and VC.Override_Controls[cmd].use and tostring(VC.Override_Controls[cmd].use) == "1" then tbl = VC.Override_Controls[cmd] end  return tbl end  function VC.HandleInput(ply, ent, Veh, IsNotPod, VSC)  if VC.getSetting("Keyboard_Input") and !VC.isMidEnterExit(ply) then  if VC.Handle_Input_VC2 then VC.Handle_Input_VC2(ply, ent, Veh, IsNotPod, VSC) elseif VC.Handle_Input_VC1 then VC.Handle_Input_VC1(ply, ent, Veh, IsNotPod, VSC) end  local cursorVis = vgui.CursorVisible()  for _, Cmd in pairs(VC.Controls_Main) do  if !Cmd.cursor and !cursorVis or Cmd.cursor and cursorVis then  local CurrrentCMD = GetCmdTbl(Cmd.cmd)  if CurrrentCMD and CurrrentCMD.key != "None" then  local Key, Hold, SKHE, KHB, KHld = CurrrentCMD.key, tobool(CurrrentCMD.hold or "1"), nil, true, true  local GK = nil if Key then GK = _G[Key] end   if GK then  local GKey = input.IsMouseDown(_G[Key]) or input.IsKeyDown(_G[Key])   if !VC.UI_Inter_Hover or Key != "MOUSE_LEFT" then   if Cmd.keyhold then  KHld = nil if VC.KeyPrimaryHold then KHld = true end  else  local OtherHasHold = nil  for k, v in pairs(VC.Controls_Main) do local TempCmd = GetCmdTbl(v.cmd) if TempCmd and TempCmd.key == Key and v.keyhold and VC.KeyPrimaryHold then OtherHasHold = true break end end  if OtherHasHold then  KHB = nil  else  for _, KHK in pairs(VC.Controls_Main) do  local TempCmd = GetCmdTbl(KHK.cmd) if KHK.cmd and TempCmd and Cmd != KHK and Key == TempCmd.key and CurrrentCMD.hold == TempCmd.hold and KHK.keyhold and Key != "None" then  if VC.KeyPrimaryHold then KHB = nil end  end  end  end  end   for GK, GV in pairs(VC.Controls_List) do GV = GetCmdTbl(GK) if Key != "None" and !Hold and tobool(GV.hold) and GV.key == Key then SKHE = true break end end  if GKey then  if !Cmd.holdTriggerTime then  local set_hold = VC.getSetting("Keyboard_Input_Hold")  Cmd.holdTriggerTime = CurTime()+ (SKHE and set_hold or Hold and set_hold or 0) Cmd.VC_KeyAP = true  elseif KHB and KHld and Cmd.VC_KeyAP and (Cmd.carg1 and Hold or !SKHE and CurTime() >= Cmd.holdTriggerTime) then  RunConsoleCommand(Cmd.cmd, Cmd.carg1) Cmd.VC_KeyAP = nil  end  elseif Cmd.holdTriggerTime and !GKey then  if KHld and KHB and (Cmd.carg2 and Hold or SKHE and CurTime() < Cmd.holdTriggerTime) then  RunConsoleCommand(Cmd.cmd, Cmd.carg2)  end  Cmd.VC_KeyAP = nil Cmd.holdTriggerTime = nil  end  end  end  end  end  end  end end  function VC.InputResetHold(ply)  for k, v in pairs(VC.Controls_Main) do  VC.Controls_Main[k].holdTriggerTime = nil  end end local rs7 = "vc.check_msg_work_ALS_k4" 
--PATH vcmod?entcode_main:
if !VC.CodeEnt.Repair_Wep then VC.CodeEnt.Repair_Wep = {} end  VC.CodeEnt.Wep_DrawSelection = function(self, x, y, w, t, a)  if self.VC_WepSelectIcon then  local clr = Color(255, 255, 0, a)  surface.SetDrawColor(clr)  surface.SetMaterial(self.VC_WepSelectIcon)   draw.DrawText("VCMod", "VC_DEV_lower", x+10, y+10, clr, TEXT_ALIGN_LEFT)   local size = 80  surface.DrawTexturedRect(x+w/2-size/2, y+t/2-size/2, size , size)  end end  VC.CodeEnt.Repair_Wep.Initialize = function(self)  self:SetWeaponHoldType("melee") end  VC.CodeEnt.Repair_Wep.GetViewModelPosition = function(self, pos, ang)  if !vcmod1 then return end   local FTm = VC.FTm()  local ent = self:GetNWEntity("VC_DamagedEnt")  if !self.VC_PastAngleInt then self.VC_PastAngleInt = 0 end  if !self.VC_FixingInt then self.VC_FixingInt = 0 end  local start, finish = self:GetNWInt("VC_DoingStart", 0), self:GetNWInt("VC_DoingFinish", 0)  if start > 0 then  if !self.VC_Sound then self.VC_Sound = CreateSound(self, "vcmod/socket_wrench.wav") end  local time = finish-start  local prc = math.Clamp(1-(finish-CurTime())/time, 0,1)  if self.VC_Sound and self.VC_Sound:IsPlaying() then self.VC_Sound:ChangePitch(105-prc*15) end  if !self.VC_FixingIntDec then  self.VC_FixingInt = self.VC_FixingInt+0.03*FTm  if self.VC_FixingInt > 1 then self.VC_FixingInt = 1 self.VC_FixingIntDec = true if self.VC_Sound and !self.VC_Sound:IsPlaying() then self.VC_Sound:Play() end else if self.VC_Sound and self.VC_Sound:IsPlaying() then self.VC_Sound:Stop() end end  else  local Extra = prc/35  self.VC_FixingInt = self.VC_FixingInt-(0.03-Extra)*FTm if self.VC_FixingInt < 0 then self.VC_FixingInt = 0 self.VC_FixingIntDec = false end  end  else  if self.VC_Sound and self.VC_Sound:IsPlaying() then self.VC_Sound:Stop() end  if self.VC_FixingInt > 0 then self.VC_FixingInt = self.VC_FixingInt-0.02*FTm if self.VC_FixingInt < 0 then self.VC_FixingInt = 0 end end  end  local FixAng = Angle(0,0,0) if self.VC_FixingInt > 0 then FixAng = LerpAngle(VC.EaseInOut(self.VC_FixingInt), FixAng, Angle(18,-10,-60)) end   if IsValid(ent) then  if self.VC_PastAngleInt < 1 then self.VC_PastAngleInt = self.VC_PastAngleInt+0.05*FTm if self.VC_PastAngleInt > 1 then self.VC_PastAngleInt = 1 end end  elseif self.VC_PastAngleInt > 0 then  self.VC_PastAngleInt = self.VC_PastAngleInt-0.02*FTm if self.VC_PastAngleInt < 0 then self.VC_PastAngleInt = 0 end  end   if self.VC_PastAngleInt > 0 then  local aimang = IsValid(ent) and ((ent:LocalToWorld(self:GetNWVector("VC_DamagedPos"), Vector(0,0,0))-LocalPlayer():EyePos()):Angle()) or ang  local angdif = VC.AngleDifference_Ex(aimang, EyeAngles())  self.VC_PastAngle = LerpAngle((IsValid(ent) and 0.05 or 0.01)*FTm, self.VC_PastAngle or ang, aimang+ Angle(0, 100/(angdif.y > 5 and angdif.y or 5),0))   ang = LerpAngle(VC.EaseInOut(self.VC_PastAngleInt), ang, self.VC_PastAngle)  else  self.VC_PastAngle = nil if self.VC_Sound and self.VC_Sound:IsPlaying() then self.VC_Sound:Stop() end  end return pos, ang+FixAng end  VC.CodeEnt.Repair_Wep.Holster = function(self) if self.VC_Sound and self.VC_Sound:IsPlaying() then self.VC_Sound:Stop() end return true end   net.Receive("VC_SentToClient_FuelNozzle_PickedUp", function() local ent = net.ReadEntity() VC.PickedUpNozzle_Time = CurTime() end)   if !VC.CodeEnt.Fuel_station then VC.CodeEnt.Fuel_station = {} end VC.CodeEnt.Fuel_station.Draw = function(self)  self:DrawModel()  if !self.VC_DistCheckT or CurTime() >= self.VC_DistCheckT then self.VC_DistCheckT = CurTime()+2 self.VC_Dist = VC.GetViewPos():Distance(self:GetPos()) end if self.VC_Dist > 1500 then return end   local tr = {} if self.VC_Dist < 100 then tr = util.TraceLine({start = LocalPlayer():GetShootPos(), endpos = LocalPlayer():GetShootPos()+LocalPlayer():GetAimVector()*90, filter = LocalPlayer()}) end   local ftype = self.VC_FuelType or 0  local ftypetbl = VC.FuelTypes[ftype]  local price = math.Round(VC.getServerSetting("Fuel_PPL_"..ftype, 1), 2)  local symbol = VC.getCurCurrency().symbol   cam.Start3D2D(self:LocalToWorld(Vector(10.2,-8.8,57.6)), self:LocalToWorldAngles(Angle(0,90,62)), 0.1)   local Px,Py = 0, 47 local Sx, Sy = 176,150  draw.RoundedBox(0, Px,Py, Sx, Sy, false and ftypetbl.clr or Color(55,100,255,250))   local text = "Active"   if self:GetNWBool("VC_Hitched", false) then text = "Idle" end  local cur, max = self:GetNWInt("VC_Pumped", 0), self:GetNWInt("VC_PumpedGoal", 0)  local perc = max > 0 and cur/max or 0   if self:GetNWBool("VC_Pumping", false) then text = "Pumping" end   draw.RoundedBox(0, Px+5, Py+Sy-15, Sx-10, 10, VC.Color.White)  draw.RoundedBox(0, Px+5, Py+Sy-15, (Sx-10)*perc, 10, Color(55,155,55,255))   draw.DrawText(VC.Lng(text), "VC_DEV_lower", Px+Sx/2, Py+Sy-17, VC.Color.Main, TEXT_ALIGN_CENTER)   local sel = 0  if self.VC_Dist < 100 and IsValid(tr.Entity) and tr.Entity == self then  local pos = tr.Entity:WorldToLocal(tr.HitPos)  if pos.y > -8 and pos.y < 8 and pos.z > 37 and pos.z < 50 then  if pos.y < -4 then  sel = 1  elseif pos.y > 4 then  sel = 2  elseif pos.z < 44 then  sel = 3  end  end  end   if sel == 1 then surface.SetDrawColor(255,255,255,255) else surface.SetDrawColor(0,0,255,155) end surface.SetMaterial(VC.Material.icon_left)  surface.DrawTexturedRect(Px+10, Py+Sy*0.4, 20, 75)  if sel == 2 then surface.SetDrawColor(255,255,255,255) else surface.SetDrawColor(0,0,255,155) end surface.SetMaterial(VC.Material.icon_right)  surface.DrawTexturedRect(Px+Sx-10-20, Py+Sy*0.4, 20, 75)   if sel == 3 then surface.SetDrawColor(25,155,25,255) else surface.SetDrawColor(0,0,255,155) end surface.SetMaterial(VC.Material.Button)  surface.DrawTexturedRect(Px+10+20+10, Py+Sy*0.65, Sx-80, 25)  draw.DrawText(VC.Lng("Purchase"), "VC_Regular2", Px+Sx/2, Py+Sy*0.68, VC.Color.White, TEXT_ALIGN_CENTER)   local cursel = self:GetNWInt("VC_Selected", 0)   local purchcount = VC.LiterToAuto(self:GetNWInt("VC_Purchased", 0), self.VC_FuelType)  local purchcount2 = VC.LiterToAuto(cursel, self.VC_FuelType)   if self.VC_FuelType == 2 then  draw.DrawText(purchcount2.." "..VC.TextToAuto(self.VC_FuelType).." ("..(symbol..math.Round(price*purchcount2*100)/100)..")", "VC_DEV_lower", Px+Sx/2, Py+Sy*0.68-20, VC.Color.White, TEXT_ALIGN_CENTER)  else  draw.DrawText(purchcount2.." "..VC.TextToAuto(self.VC_FuelType).." ("..(symbol..math.Round(price*cursel*100)/100)..")", "VC_DEV_lower", Px+Sx/2, Py+Sy*0.68-20, VC.Color.White, TEXT_ALIGN_CENTER)  end   draw.DrawText(VC.Lng(ftypetbl.name).." ("..VC.Lng(VC.Lng(ftypetbl.shrt))..")", "VC_Name", Px+Sx/2, Py+5, VC.Color.White, TEXT_ALIGN_CENTER)   draw.DrawText(VC.Lng("Price"), "VC_DEV_lower", Px+10, Py+40, VC.Color.White, TEXT_ALIGN_LEFT)   draw.DrawText(symbol..price.."/"..VC.TextToAuto(self.VC_FuelType), "VC_DEV_lower", Px+Sx-10, Py+40, VC.Color.White, TEXT_ALIGN_RIGHT)   draw.DrawText(VC.Lng("Purchased"), "VC_DEV_lower", Px+10, Py+55, VC.Color.White, TEXT_ALIGN_LEFT)  draw.DrawText(purchcount.." "..VC.TextToAuto(self.VC_FuelType), "VC_DEV_lower", Px+Sx-10, Py+55, VC.Color.White, TEXT_ALIGN_RIGHT)   draw.DrawText(VC.Lng("Price"), "VC_DEV_lower", Px+10, Py+40, VC.Color.White, TEXT_ALIGN_LEFT)  cam.End3D2D()   cam.Start3D2D(self:LocalToWorld(Vector(5,15.5,55)), self:LocalToWorldAngles(Angle(0,180,83)), 0.1) surface.SetDrawColor(255,255,255,255) surface.SetMaterial(VC.Material.Icon) surface.DrawTexturedRect(0,0, 100, 100)  cam.End3D2D() end  if !VC.CodeEnt.Spikestrip then VC.CodeEnt.Spikestrip = {} end  VC.CodeEnt.Spikestrip.Think = function(self)  if self.VC_DeployedInt then self:SetPoseParameter("deploy", self.VC_DeployedInt) end  if self:GetNWBool("VC_Deployed", false) then  if !self.VC_DeployedInt then self.VC_DeployedInt = 0 end  if self.VC_DeployedInt < 1 then  self.VC_DeployedInt = self.VC_DeployedInt+0.05*VC.FTm() if self.VC_DeployedInt > 1 then self.VC_DeployedInt = 1 end  end  elseif self.VC_DeployedInt then  self.VC_DeployedInt = self.VC_DeployedInt-0.015*VC.FTm() if self.VC_DeployedInt < 0 then self.VC_DeployedInt = nil end  end end    if !VC.CodeEnt.Spikestrip_wep then VC.CodeEnt.Spikestrip_wep = {} end  VC.CodeEnt.Spikestrip_wep.Initialize = function(self) self:SetWeaponHoldType("physgun") end  VC.CodeEnt.Spikestrip_wep.Think = function(self)  if self.VC_Doing then  if !VC.Model_Spikestrip_wep then  VC.Model_Spikestrip_wep = ClientsideModel("models/sentry/vc_spikestrip.mdl", RENDERGROUP_OPAQUE)  VC.Model_Spikestrip_wep:SetParent(self)    local id = "ent_spikestripwep_"..self:EntIndex()  VC_UHp3e18505c6fdde124627e9fa198ee180blJ(self.VC_Model, self, id)  end  if IsValid(VC.Model_Spikestrip_wep) then  VC.Model_Spikestrip_wep:SetPos(self.VC_LastTr.HitPos)  VC.Model_Spikestrip_wep:SetAngles(Angle(0,EyeAngles().y-90,0))  VC.Model_Spikestrip_wep:SetPoseParameter("deploy", (math.sin(CurTime())+1)/2* (self.VC_DoingLerp or 0))  VC.Model_Spikestrip_wep:SetMaterial("models/wireframe")  end  else  if IsValid(VC.Model_Spikestrip_wep) then VC.Model_Spikestrip_wep:Remove() VC.Model_Spikestrip_wep = nil end  end end  VC.CodeEnt.Spikestrip_wep.Holster = function(self, pos, ang)  if IsValid(VC.Model_Spikestrip_wep) then VC.Model_Spikestrip_wep:Remove() end VC.Model_Spikestrip_wep = nil self.VC_DoingLerp = nil end  VC.CodeEnt.Spikestrip_wep.GetViewModelPosition = function(self, pos, ang)  if !vcmod1 then return end   local FTm = VC.FTm()   local doing = false if EyeAngles().p > 45 then local tr = LocalPlayer():GetEyeTraceNoCursor() self.VC_LastTr = tr doing = tr.Hit and tr.HitPos:Distance(LocalPlayer():EyePos()) < 100 end self.VC_Doing = doing   local FixAng = Angle(-10, 8, -8)  local FixPos = Vector(0,0,0)   local ReaddyPos = Vector((math.sin(CurTime())+1)*0.3*math.sin(CurTime()*1),-8+(math.sin(CurTime())+1)/2*math.sin(CurTime()*0.75),12+(math.sin(CurTime())+1)*0.2*math.sin(CurTime()*0.5))  FixPos = FixPos+ang:Right()*ReaddyPos.x  FixPos = FixPos-ang:Forward()*ReaddyPos.y  FixPos = FixPos-ang:Up()*ReaddyPos.z   if doing then  if !self.VC_DoingLerp then self.VC_DoingLerp = 0 end  if self.VC_DoingLerp < 1 then self.VC_DoingLerp = self.VC_DoingLerp+0.02*FTm if self.VC_DoingLerp > 1 then self.VC_DoingLerp = 1 end end  elseif self.VC_DoingLerp then  self.VC_DoingLerp = self.VC_DoingLerp-0.01*FTm if self.VC_DoingLerp < 0 then self.VC_DoingLerp = nil end  end   if self.VC_DoingLerp then  FixAng = LerpAngle(VC.EaseInOut(self.VC_DoingLerp), FixAng, FixAng+(Angle(-25,0,-10)))   local DoPos = Vector(0,-10,18)  FixPos = FixPos+ang:Right()*DoPos.x*self.VC_DoingLerp  FixPos = FixPos-ang:Forward()*DoPos.y*self.VC_DoingLerp  FixPos = FixPos-ang:Up()*DoPos.z*self.VC_DoingLerp  end    FixPos = FixPos+ang:Right()*10  FixPos = FixPos-ang:Up()*3  return pos+FixPos, ang+FixAng end   VC.CodeEnt.Spikestrip_wep.DrawWorldModel = function(self)  if !IsValid(self:GetOwner()) then self:DrawModel() return end   local atc = self.Owner:LookupAttachment("anim_attachment_rh")   if atc != 0 then  local Data = self.Owner:GetAttachment(atc) if !Data then Data = {} end if !Data.Pos then Data.Pos = Vector(0,0,0) end if !Data.Ang then Data.Ang = Angle(0,0,0) end   local pos = Vector(7,-1,15)  local ang = Angle(0,-125,-15)  self:SetRenderOrigin(Data.Pos+ Data.Ang:Forward()* pos.x+ Data.Ang:Up()*pos.y+ Data.Ang:Right()*pos.z)   Data.Ang:RotateAroundAxis(Data.Ang:Forward(), ang.p)  Data.Ang:RotateAroundAxis(Data.Ang:Up(), ang.y)  Data.Ang:RotateAroundAxis(Data.Ang:Right(), ang.r)  self:SetRenderAngles(Data.Ang)  end   self:DrawModel() end   VC.CodeEnt.Spikestrip_wep.ViewModelDrawn = function(self)  if !self.VC_Model then  self.VC_Model = ClientsideModel("models/sentry/vc_spikestrip.mdl", RENDERGROUP_OPAQUE)  self.VC_Model:SetNoDraw(true)  self.VC_Model:SetParent(self)   local id = "ent_spikestrip_"..self:EntIndex()  VC_UHp3e18505c6fdde124627e9fa198ee180blJ(self.VC_Model, self, id)  end   if self.Owner and self.Owner != NULL then  local vm = self.Owner:GetViewModel()   local lubone = vm:LookupBone("Bip01_L_Finger3")   if lubone then  local posLocal, posWorld, Angles = VC.getBonePos(vm, lubone)  local ReadyPos = Vector(1.8,9,-4.8)  local ReadyAng = Angle(0,0,0)   Angles = vm:LocalToWorldAngles(Angles)   local mult = 1  Angles:RotateAroundAxis(Angles:Forward(), (0)+ReadyAng.p*mult)  Angles:RotateAroundAxis(Angles:Up(), (-45)+ReadyAng.y*mult)  Angles:RotateAroundAxis(Angles:Right(), (25)+ReadyAng.r*mult)  posWorld = posWorld + Angles:Up()* (ReadyPos.x*mult)  posWorld = posWorld + Angles:Right()* (ReadyPos.z*mult)  posWorld = posWorld + Angles:Forward() * (ReadyPos.y*mult)   self.VC_Model:SetPos(posWorld)  self.VC_Model:SetAngles(Angles)  self.VC_Model:DrawModel()  end  end end    local ID = "Pickup_partkit" if !VC.CodeEnt[ID] then VC.CodeEnt[ID] = {} end    if !VC.CodeEnt.Jerrycan_Wep then VC.CodeEnt.Jerrycan_Wep = {} end  VC.CodeEnt.Jerrycan_Wep.GetViewModelPosition = function(self, pos, ang)  if !vcmod1 then return end   local FTm = VC.FTm()  local ent = self:GetNWEntity("VC_AimEntity") if ent and ent == self then ent = nil end   if !self.VC_PastAngleInt then self.VC_PastAngleInt = 0 end   local FixAng = Angle(0,0,0)  local FixPos = Vector(0,0,0)   if self.VC_PastAngleInt > 0 then  local ReaddyPos = Vector(0,0,0)  FixAng = LerpAngle(VC.EaseInOut(self.VC_PastAngleInt), Angle(0,0,0), Angle(-5,6,0))   FixPos = FixPos+ang:Right()*ReaddyPos.x*self.VC_PastAngleInt  FixPos = FixPos-ang:Forward()*ReaddyPos.y*self.VC_PastAngleInt  FixPos = FixPos-ang:Up()*ReaddyPos.z*self.VC_PastAngleInt  end   if self.VC_FuelDoIntLerp and self.VC_FuelDoIntLerp > 0 then  FixAng = LerpAngle(self.VC_FuelDoIntLerp, FixAng, FixAng+(Angle(-5,5,-5)))           end   if IsValid(ent) and self:GetNWInt("VC_FuelAmount", 0) > 0 then  if self.VC_PastAngleInt < 1 then self.VC_PastAngleInt = self.VC_PastAngleInt+0.02*FTm if self.VC_PastAngleInt > 1 then self.VC_PastAngleInt = 1 end end  elseif self.VC_PastAngleInt > 0 then  self.VC_PastAngleInt = self.VC_PastAngleInt-0.02*FTm if self.VC_PastAngleInt < 0 then self.VC_PastAngleInt = 0 end  end   if self.VC_PastAngleInt > 0 then  local aimang = IsValid(ent) and ((ent:LocalToWorld(ent:GetNWVector("VC_FuelLidPos"), Vector(0,0,0))-LocalPlayer():EyePos()):Angle()) or ang  local angdif = VC.AngleDifference_Ex(aimang, EyeAngles())  self.VC_PastAngle = LerpAngle((IsValid(ent) and 0.05 or 0.01)*FTm, self.VC_PastAngle or ang, aimang+ Angle(0, 100/(angdif.y > 5 and angdif.y or 5),0))  ang = LerpAngle(VC.EaseInOut(self.VC_PastAngleInt), ang, self.VC_PastAngle)   else  self.VC_PastAngle = nil  end  FixPos = FixPos+ang:Right()*10  FixPos = FixPos-ang:Up()*3  return pos+FixPos, ang+FixAng end  VC.CodeEnt.Jerrycan_Wep.DrawHUD = function(self)  if !LocalPlayer():Alive() or LocalPlayer():InVehicle() then return end   local vm = self.Owner:GetViewModel()   local posLocal, posWorld, Angles = VC.getBonePos(vm, vm:LookupBone("ValveBiped.Bip01_R_Hand"))   Angles = vm:LocalToWorldAngles(Angles)   local posScr = (posWorld-vm:GetRight()*8+vm:GetForward()*8):ToScreen()   local PSx,PSy = math.Round(posScr.x), math.Round(posScr.y)  local Sizey = 30  local tclr = table.Copy(VC.Color.Main)  tsize = 80   local ftype, Cur, Max = self:GetNWInt("VC_FuelType", 0), math.ceil(self:GetNWInt("VC_FuelAmount", 0)*10)/10, 20   local text = ""  if Cur > 0 then  text = VC.Lng(VC.FuelTypes[ftype].name)..": "..(ftype == 2 and (math.Round(VC.LitersToKwH(Cur), 2).."/"..math.Round(VC.LitersToKwH(Max), 2).." "..VC.Lng("kWh")) or (VC.getSetting("HUD_MPh") and (math.Round(VC.LitersToGallons(Cur), 2).."/"..math.Round(VC.LitersToGallons(Max), 2).." "..VC.Lng("gallons")) or (math.Round(Cur, 2).."/"..math.Round(Max, 2).." "..VC.Lng("liters"))))  else  text = VC.Lng("Empty")  end   surface.SetFont("VC_Name")  local tsize = surface.GetTextSize(text)  VC.DrawFadeRect(PSx,PSy-Sizey, tsize+10, Sizey+5,tclr,fade)  draw.SimpleText(text, "VC_Name", PSx+5, PSy-10, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER) end  VC.CodeEnt.Jerrycan_Wep.DrawWorldModel = function(self)  if !IsValid(self:GetOwner()) then self:DrawModel() return end   local ftype = self:GetNWInt("VC_FuelType", 0)  if self:GetModel() != VC.FuelTypes[ftype].mdl then self:SetModel(VC.FuelTypes[ftype].mdl) end   local atc = self.Owner:LookupAttachment("anim_attachment_rh")   if atc != 0 then  local Data = self.Owner:GetAttachment(atc) if !Data then Data = {} end if !Data.Pos then Data.Pos = Vector(0,0,0) end if !Data.Ang then Data.Ang = Angle(0,0,0) end   self:SetRenderOrigin(Data.Pos+ Data.Ang:Forward()* 10+ Data.Ang:Up() *1+ Data.Ang:Right() *3)   Data.Ang:RotateAroundAxis(Data.Ang:Forward(), 5)  Data.Ang:RotateAroundAxis(Data.Ang:Up(), 60)  self:SetRenderAngles(Data.Ang)  end   self:DrawModel() end  VC.CodeEnt.Jerrycan_Wep.ViewModelDrawn = function(self)  local ftype = self:GetNWInt("VC_FuelType", 0)  if !self.VC_Model then  self.VC_Model = ClientsideModel(VC.FuelTypes[ftype].mdl, RENDERGROUP_OPAQUE)  self.VC_Model:SetNoDraw(true)  self.VC_Model:SetParent(self)   local id = "ent_jerrycanVM_"..self:EntIndex()  VC_UHp3e18505c6fdde124627e9fa198ee180blJ(self.VC_Model, self, id)  end   if self.VC_Model:GetModel() != VC.FuelTypes[ftype].mdl then self.VC_Model:SetModel(VC.FuelTypes[ftype].mdl) end   if self:GetModel() != VC.FuelTypes[ftype].mdl then self:SetModel(VC.FuelTypes[ftype].mdl) end  if self.Owner and self.Owner != NULL then  local vm = self.Owner:GetViewModel()   local posLocal, posWorld, Angles = VC.getBonePos(vm, vm:LookupBone("ValveBiped.Bip01_R_Hand"))   Angles = vm:LocalToWorldAngles(Angles)   local ReadyPos = Vector(0,0,0)  ReadyAng = Angle(0,0,0)  if self.VC_PastAngleInt and self.VC_PastAngleInt > 0 then  ReadyAng = Angle(45,-25,-50)  ReadyPos = Vector(8,0,-2)   local Cur, Max = self:GetNWInt("VC_FuelAmount", 0), 20   local int = (1-Cur/Max)*self.VC_PastAngleInt  self.VC_FuelDoIntLerp = Lerp(0.1*VC.FTm(), self.VC_FuelDoIntLerp or int, int)   if self.VC_FuelDoIntLerp and self.VC_FuelDoIntLerp > 0 then  ReadyAng = LerpAngle(self.VC_FuelDoIntLerp, ReadyAng, ReadyAng+Angle(10,-30,-10))   local DoPos = Vector(-8,-1,-2)  ReadyPos = ReadyPos+Angles:Right()*DoPos.x*self.VC_FuelDoIntLerp  ReadyPos = ReadyPos-Angles:Forward()*DoPos.y*self.VC_FuelDoIntLerp  ReadyPos = ReadyPos-Angles:Up()*DoPos.z*self.VC_FuelDoIntLerp  end  end   local mult = self.VC_PastAngleInt or 0  Angles:RotateAroundAxis(Angles:Forward(), 145+ReadyAng.p*mult)  Angles:RotateAroundAxis(Angles:Up(), 90+ReadyAng.y*mult)  Angles:RotateAroundAxis(Angles:Right(), 10+ReadyAng.r*mult)  posWorld = posWorld + Angles:Up()* (-5+ReadyPos.x*mult)  posWorld = posWorld + Angles:Right()* (10+ReadyPos.z*mult)  posWorld = posWorld + Angles:Forward() * (4.5+ReadyPos.y*mult)   self.VC_Model:SetPos(posWorld)  self.VC_Model:SetAngles(Angles)  self.VC_Model:DrawModel()  end  end local rs7 = "vc.check_msg_work_ALS_k4" 
--PATH vcmod??init_vc1:
if !VC.Loaded then VC.Loaded = {} end local id = "main" if VC.Loaded[id] then return end VC.Loaded[id] = CurTime()  VC.Versions.vcmod1 = 1.7892 VCMod1 = VC.Versions.vcmod1 vcmod1 = VC.Versions.vcmod1  VC.Include("vcmod/shared/states_main.lua") VC.Include("vcmod/shared/shared_vc1.lua") VC.Include("vcmod/shared/precache_vc1.lua") VC.Include("vcmod/shared/settings_main.lua")  VC.AU_CanFuel = true or VC_AU_Ver and VC_AU_Ver_Online and VC_AU_Ver >= 7  if SERVER then  VC.Include("vcmod/server/functions_main.lua")  VC.Include("vcmod/server/health.lua")  VC.Include("vcmod/server/particles.lua")  VC.Include("vcmod/server/console_main.lua")  VC.Include("vcmod/server/lights_main.lua")   VC.Include("vcmod/server/main_vc1.lua")   VC.Include("vcmod/server/npc.lua")  VC.Include("vcmod/server/cardealer.lua")  VC.Include("vcmod/server/npc_repair.lua") else    VC.Include("vcmod/client/main_vc1.lua")  VC.Include("vcmod/client/view.lua")  VC.Include("vcmod/client/data_hud_main.lua")  VC.Include("vcmod/client/data_menu_vc1.lua")  VC.Include("vcmod/client/particles.lua")  VC.Include("vcmod/client/console_main.lua")  VC.Include("vcmod/client/cardealer.lua")  VC.Include("vcmod/client/npc_repair.lua")  VC.Include("vcmod/client/anim_main.lua") end local rs7 = "vc.check_msg_work_ALS_k4" 
--PATH vcmod??settings_main:
local settings = { Wheel_Lock = true, Brake_Lock = true, Door_Sounds = true, Truck_BackUp_Sounds = true, Exit_Velocity = true, Exit_Velocity_Damage = true, Exit_NoCollision = true, Exhaust_Effect = true, Exhaust_Effect_BackFireHealthLow = true, Passenger_Seats = true, ExitPoint_OverrideDriver = true, Seat_Switch = true, Lock_From_Inside = true, DriveBy = true, DriveBy_NoSwitch = false,  RepairTool_Speed_M = 1,  Lights_Running = true, Lights_HandBrake = false, Lights_Interior = true, Lights_Blinker_OffOnExit = false, HeadLights = true, LightsOffTime = 300, HLightsOffTime = 60, HLights_Dist_M = 0.5,  FogLights = true, FogLightsOffTime = 30, FogLights_Dist_M = 0.5,  Cruise_Enabled = true, Cruise_OffOnExit = true,  UnlockVehicleOnSpawnerUsePostLock = true,  CD_Enabled = true, CD_ReturnLimitByDistance = true, CD_ReturnLimitByDistanceDist = 1000, CD_EnterVehicleOnSpawn = false, CD_AutoReturnOnDisconnect = false, CD_TowingTooFar = false, CD_TowingTooFar_Distance = 1500, CD_Towing = true, CD_OnlyAllowOne = false, CD_TowingPrice = 1500, CD_Distance = 1500, CD_RefundPrice = 75, CD_Remove = true, CD_Remove_Time = 1000, CD_Veh_RemTool = false, CD_Hum = true, CD_Persistent = true, CD_StoreInfo = true, CD_TestDrive = true, CD_TestDriveTime = 30, CD_Text_Dist = 500, CD_UnlockVehicleOnSpawnerUse = true,  TP_Override = false,  RM_Enabled = true, RM_Text_Dist = 500, RM_Persistent = true, RM_Hum = true, RM_RepairSpeedMult = 1, RM_Distance = 350, RM_Repair_Time_Cost = 1,  RM_Price_Engine = 500, RM_Price_Light = 10, RM_Price_Tire = 20, RM_Price_Exhaust = 50,  Fuel = true, Fuel_Pickup_Touch = false, Fuel_Pickup_Touch_Elec = true, Fuel_Pickup_Explode = true, Fuel_Pickup_Pickup = true, Fuel_Persistent = true, Fuel_lidNeedUnlocked = true, Fuel_Pickups_Beside_Stations = true, Fuel_Cons_Mult = 1, Refuel_Mult_Station = 1, Fuel_StartMult = 1, Refuel_MaxCapacity = 100, Refuel_Mult_Hand = 1, Fuel_PPL_0 = 1.3, Fuel_PPL_1 = 1.01, Fuel_PPL_2 = 0.29,  Trl_Enabled = true, Trl_Dist = 200, Trl_Strength = 1, Trl_Enabled_Reg = true,  TP_Props = true,  Indication = true,  Damage = true, Damage_Phys_MinVel = 75, Sound_Damage_Custom = true, Damage_explosion_drain_fuel = true, Damage_FuelLid = true, Damage_FuelLid_Explode = true, Damage_FuelLid_DrainFuel = true, Damage_Lights = true, Damage_Wheels = true, Damage_Wheels_ELSOff = false, Damage_Exhaust = true, Damage_Exhaust_Backfire = true, Damage_Explode = true, Damage_CanEnterIfDestroyed = true,  Damage_Repair_GiveWrenchToDriver = true, Damage_Repair_GiveWrenchToCarPartUser = true, Damage_Repair_NeedPart = true, Damage_Repair_TimeMult = 1, Damage_Expl_Rem = true, Damage_Ignite = true, Damage_Expl_Rem_Time = 400, Dmg_Fire_Duration = 30, Dmg_Smoke_Duration = 15,  SpikeStrip_auto_give_els = false, SpikeStrip_damage_players = true, SpikeStrip_Ignore_ELS = false, SpikeStrip_auto_remove_death = true,  HealthRepairBulletDamage = true, PhysicalDamage = true, PhysicalDamage_PlyDmgMult = 1, PhysicalDamage_PlyDisable = true, PhysicalDamageWPhysGun = true, OnlyWithPassengers = false, PhysicalDamage_Mult = 1, Health_Multiplier = 1, CarsCantDamagePlayers = false, ShootPlayers = true, ShootPlayers_Prec_Mult = 1, ShootPlayers_OverrideDefault = true,  Effect_Repair = true, Effect_Light = true, Effect_Light_Damaged = true, Effect_Wheel = true, Effect_Exhaust = true, Effect_Damage_Sparks = true, Effect_Explosion_Custom = true, Effect_Exhaust_Custom = true, Effect_Slide = true, Tiretracks = true,    Compat_CH_Fire_System = true,   }  VC.SettingsAdd(settings, true) local rs7 = "vc.check_msg_work_ALS_k4"  
--PATH mlogs/minify/sh_parselua.lua:
                  local function lookupify(tb) 	for _, v in pairs(tb) do 		tb[v] = true 	end 	return tb end  local function CountTable(tb) 	return table.Count(tb) end  local WhiteChars = lookupify{' ', '\n', '\t', '\r'} local EscapeLookup = {['\r'] = '\\r', ['\n'] = '\\n', ['\t'] = '\\t', ['"'] = '\\"', ["'"] = "\\'"} local LowerChars = lookupify{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 							 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 							 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'} local UpperChars = lookupify{'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 							 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 							 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'} local Digits = lookupify{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'} local HexDigits = lookupify{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',                             'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f'}  local Symbols = lookupify{'+', '-', '*', '/', '^', '%', ',', '{', '}', '[', ']', '(', ')', ';', '#'}  local Keywords = lookupify{     'and', 'break', 'do', 'else', 'elseif',     'end', 'false', 'for', 'function', 'goto', 'if',     'in', 'local', 'nil', 'not', 'or', 'repeat',     'return', 'then', 'true', 'until', 'while', }; local function LexLua(src) 	  	local tokens = {}  	local st, err = pcall(function() 		  		local p = 1 		local line = 1 		local char = 1  		  		local function get() 			local c = src:sub(p,p) 			if c == '\n' then 				char = 1 				line = line + 1 			else 				char = char + 1 			end 			p = p + 1 			return c 		end 		local function peek(n) 			n = n or 0 			return src:sub(p+n,p+n) 		end 		local function consume(chars) 			local c = peek() 			for i = 1, #chars do 				if c == chars:sub(i,i) then return get() end 			end 		end  		  		local function generateError(err) 			return error(">> :"..line..":"..char..": "..err, 0) 		end  		local function tryGetLongString() 			local start = p 			if peek() == '[' then 				local equalsCount = 0                 local depth = 1 				while peek(equalsCount+1) == '=' do 					equalsCount = equalsCount + 1 				end 				if peek(equalsCount+1) == '[' then 					  					for _ = 0, equalsCount+1 do get() end  					  					local contentStart = p 					while true do 						  						if peek() == '' then 							generateError("Expected `]"..string.rep('=', equalsCount).."]` near <eof>.", 3) 						end  						  						local foundEnd = true 						if peek() == ']' then 							for i = 1, equalsCount do 								if peek(i) ~= '=' then foundEnd = false end 							end 							if peek(equalsCount+1) ~= ']' then 								foundEnd = false 							end 						else                             if peek() == '[' then                                                                   local embedded = true                                 for i = 1, equalsCount do                                     if peek(i) ~= '=' then                                         embedded = false                                         break                                     end                                 end                                 if peek(equalsCount + 1) == '[' and embedded then                                                                           depth = depth + 1                                     for i = 1, (equalsCount + 2) do                                         get()                                     end                                 end                             end 							foundEnd = false 						end 						  						if foundEnd then 							depth = depth - 1                             if depth == 0 then                                 break                             else                                 for i = 1, equalsCount + 2 do                                     get()                                 end                             end 						else 							get() 						end 					end  					  					local contentString = src:sub(contentStart, p-1)  					  					for i = 0, equalsCount+1 do get() end  					  					local longString = src:sub(start, p-1)  					  					return contentString, longString 				else 					return nil 				end 			else 				return nil 			end 		end  		  		while true do 			  			  			              leading = { } 			local leadingWhite = ''             local longStr = false 			while true do 				local c = peek()                 if c == '#' and peek(1) == '!' and line == 1 then                                           get()                     get()                     leadingWhite = "#!"                     while peek() ~= '\n' and peek() ~= '' do                         leadingWhite = leadingWhite .. get()                     end                     token = {                         Type = 'Comment',                         CommentType = 'Shebang',                         Data = leadingWhite,                         Line = line,                         Char = char                     }                     token.Print = function()                         return "<"..(token.Type .. string.rep(' ', 7-#token.Type)).."  "..(token.Data or '').." >"                     end                     leadingWhite = ""                     table.insert(leading, token)                 end 				if c == ' ' or c == '\t' then 					  					                      local c2 = get()                       table.insert(leading, { Type = 'Whitespace', Line = line, Char = char, Data = c2 })                 elseif c == '\n' or c == '\r' then                     local nl = get()                     if leadingWhite ~= "" then                         local token = {                             Type = 'Comment',                             CommentType = longStr and 'LongComment' or 'Comment',                             Data = leadingWhite,                             Line = line,                             Char = char,                         }                         token.Print = function()                             return "<"..(token.Type .. string.rep(' ', 7-#token.Type)).."  "..(token.Data or '').." >"                         end                         table.insert(leading, token)                         leadingWhite = ""                     end                     table.insert(leading, { Type = 'Whitespace', Line = line, Char = char, Data = nl }) 				elseif c == '-' and peek(1) == '-' then 					  					get()                     get() 					leadingWhite = leadingWhite .. '--' 					local _, wholeText = tryGetLongString() 					if wholeText then 						leadingWhite = leadingWhite..wholeText                         longStr = true 					else 						while peek() ~= '\n' and peek() ~= '' do 							leadingWhite = leadingWhite..get() 						end 					end 				else 					break 				end 			end             if leadingWhite ~= "" then                 local token = {                     Type = 'Comment',                     CommentType = longStr and 'LongComment' or 'Comment',                     Data = leadingWhite,                     Line = line,                     Char = char,                 }                 token.Print = function()                     return "<"..(token.Type .. string.rep(' ', 7-#token.Type)).."  "..(token.Data or '').." >"                 end                 table.insert(leading, token)             end  			  			local thisLine = line 			local thisChar = char 			local errorAt = ":"..line..":"..char..":> " 			local c = peek()  			  			local toEmit = nil  			  			if c == '' then 				  				toEmit = {Type = 'Eof'}  			elseif UpperChars[c] or LowerChars[c] or c == '_' then 				  				local start = p 				repeat 					get() 					c = peek() 				until not (UpperChars[c] or LowerChars[c] or Digits[c] or c == '_') 				local dat = src:sub(start, p-1) 				if Keywords[dat] then 					toEmit = {Type = 'Keyword', Data = dat} 				else 					toEmit = {Type = 'Ident', Data = dat} 				end  			elseif Digits[c] or (peek() == '.' and Digits[peek(1)]) then 				  				local start = p 				if c == '0' and peek(1) == 'x' then 					get();get() 					while HexDigits[peek()] do get() end 					if consume('Pp') then 						consume('+-') 						while Digits[peek()] do get() end 					end 				else 					while Digits[peek()] do get() end 					if consume('.') then 						while Digits[peek()] do get() end 					end 					if consume('Ee') then 						consume('+-') 						while Digits[peek()] do get() end 					end 				end 				toEmit = {Type = 'Number', Data = src:sub(start, p-1)}  			elseif c == '\'' or c == '\"' then 				local start = p 				  				local delim = get() 				local contentStart = p 				while true do 					local c = get() 					if c == '\\' then 						get()   					elseif c == delim then 						break 					elseif c == '' then 						generateError("Unfinished string near <eof>") 					end 				end 				local content = src:sub(contentStart, p-2) 				local constant = src:sub(start, p-1) 				toEmit = {Type = 'String', Data = constant, Constant = content}  			elseif c == '[' then 				local content, wholetext = tryGetLongString() 				if wholetext then 					toEmit = {Type = 'String', Data = wholetext, Constant = content} 				else 					get() 					toEmit = {Type = 'Symbol', Data = '['} 				end  			elseif consume('>=<') then 				if consume('=') then 					toEmit = {Type = 'Symbol', Data = c..'='} 				else 					toEmit = {Type = 'Symbol', Data = c} 				end  			elseif consume('~') then 				if consume('=') then 					toEmit = {Type = 'Symbol', Data = '~='} 				else 					generateError("Unexpected symbol `~` in source.", 2) 				end  			elseif consume('.') then 				if consume('.') then 					if consume('.') then 						toEmit = {Type = 'Symbol', Data = '...'} 					else 						toEmit = {Type = 'Symbol', Data = '..'} 					end 				else 					toEmit = {Type = 'Symbol', Data = '.'} 				end  			elseif consume(':') then 				if consume(':') then 					toEmit = {Type = 'Symbol', Data = '::'} 				else 					toEmit = {Type = 'Symbol', Data = ':'} 				end  			elseif Symbols[c] then 				get() 				toEmit = {Type = 'Symbol', Data = c}  			else 				local contents, all = tryGetLongString() 				if contents then 					toEmit = {Type = 'String', Data = all, Constant = contents} 				else 					generateError("Unexpected Symbol `"..c.."` in source.", 2) 				end 			end  			              toEmit.LeadingWhite = leading   			  			  			   			toEmit.Line = thisLine 			toEmit.Char = thisChar 			toEmit.Print = function() 				return "<"..(toEmit.Type..string.rep(' ', 7-#toEmit.Type)).."  "..(toEmit.Data or '').." >" 			end 			tokens[#tokens+1] = toEmit  			  			if toEmit.Type == 'Eof' then break end 		end 	end) 	if not st then 		return false, err 	end  	  	local tok = {} 	local savedP = {} 	local p = 1          function tok:getp()         return p     end          function tok:setp(n)         p = n     end          function tok:getTokenList()         return tokens     end      	  	function tok:Peek(n) 		n = n or 0 		return tokens[math.min(#tokens, p+n)] 	end 	function tok:Get() 		local t = tokens[p] 		p = math.min(p + 1, #tokens) 		return t 	end 	function tok:Is(t) 		return tok:Peek().Type == t 	end  	  	function tok:Save() 		savedP[#savedP+1] = p 	end 	function tok:Commit() 		savedP[#savedP] = nil 	end 	function tok:Restore() 		p = savedP[#savedP] 		savedP[#savedP] = nil 	end  	  	  	function tok:ConsumeSymbol(symb) 		local t = self:Peek() 		if t.Type == 'Symbol' then 			if symb then 				if t.Data == symb then 					self:Get() 					return true 				else 					return nil 				end 			else 				self:Get() 				return t 			end 		else 			return nil 		end 	end  	function tok:ConsumeKeyword(kw) 		local t = self:Peek() 		if t.Type == 'Keyword' and t.Data == kw then 			self:Get() 			return true 		else 			return nil 		end 	end  	function tok:IsKeyword(kw) 		local t = tok:Peek() 		return t.Type == 'Keyword' and t.Data == kw 	end  	function tok:IsSymbol(s) 		local t = tok:Peek() 		return t.Type == 'Symbol' and t.Data == s 	end  	function tok:IsEof() 		return tok:Peek().Type == 'Eof' 	end  	return true, tok end  local function ParseLua(src) 	local st, tok     if type(src) ~= 'table' then         st, tok = LexLua(src)     else         st, tok = true, src     end 	if not st then 		return false, tok 	end 	  	local function GenerateError(msg) 		local err = ">> :"..tok:Peek().Line..":"..tok:Peek().Char..": "..msg.."\n" 		  		local lineNum = 0         if type(src) == 'string' then             for line in src:gmatch("[^\n]*\n?") do                 if line:sub(-1,-1) == '\n' then line = line:sub(1,-2) end                 lineNum = lineNum+1                 if lineNum == tok:Peek().Line then                     err = err..">> `"..line:gsub('\t','    ').."`\n"                     for i = 1, tok:Peek().Char do                         local c = line:sub(i,i)                         if c == '\t' then                             err = err..'    '                         else                             err = err..' '                         end                     end                     err = err.."   ^^^^"                     break                 end             end         end 		return err 	end 	  	local VarUid = 0 	local GlobalVarGetMap = {} 	local VarDigits = {'_', 'a', 'b', 'c', 'd'} 	local function CreateScope(parent) 		local scope = {} 		scope.Parent = parent 		scope.LocalList = {} 		scope.LocalMap = {}  		function scope:ObfuscateVariables() 			for _, var in pairs(scope.LocalList) do 				local id = "" 				repeat 					local chars = "QWERTYUIOPASDFGHJKLZXCVBNMqwertyuioplkjhgfdsazxcvbnm_"                     local chars2 = "QWERTYUIOPASDFGHJKLZXCVBNMqwertyuioplkjhgfdsazxcvbnm_1234567890"                     local n = math.random(1, #chars)                     id = id .. chars:sub(n, n)                     for i = 1, math.random(0,20) do                         local n = math.random(1, #chars2)                         id = id .. chars2:sub(n, n)                     end 				until not GlobalVarGetMap[id] and not parent:GetLocal(id) and not scope.LocalMap[id] and not Keywords[id] 				var.Name = id 				scope.LocalMap[id] = var 			end 		end                              function scope:RenameVariable(old, newName)             if type(old) == "table" then                   old = old.Name             end             for _, var in pairs(scope.LocalList) do                 if var.Name == old then                     var.Name = newName                     scope.LocalMap[newName] = var                 end             end         end  		function scope:GetLocal(name) 			  			local my = scope.LocalMap[name] 			if my then return my end  			  			if scope.Parent then 				local par = scope.Parent:GetLocal(name) 				if par then return par end 			end  			return nil 		end  		function scope:CreateLocal(name) 			  			local my = {} 			my.Scope = scope 			my.Name = name 			my.CanRename = true 			  			scope.LocalList[#scope.LocalList+1] = my 			scope.LocalMap[name] = my 			  			return my 		end  		scope.Print = function() return "<Scope>" end 		return scope 	end  	local ParseExpr; 	local ParseStatementList;  	local function getWSAndComments() 		while tok:Peek().Type == "Whitespace" and tok:Peek().Type == "Comment" do 			tok:Get() 		end 		  	end  	local function ParseFunctionArgsAndBody(scope)         local ParseSimpleExpr,              ParseSubExpr,             ParsePrimaryExpr,             ParseSuffixedExpr      		local funcScope = CreateScope(scope) 		if not tok:ConsumeSymbol('(') then 			return false, GenerateError("`(` expected.") 		end  		  		local argList = {} 		local isVarArg = false 		while not tok:ConsumeSymbol(')') do 			if tok:Is('Ident') then 				local arg = funcScope:CreateLocal(tok:Get().Data) 				argList[#argList+1] = arg 				if not tok:ConsumeSymbol(',') then 					if tok:ConsumeSymbol(')') then 						break 					else 						return false, GenerateError("`)` expected.") 					end 				end 			elseif tok:ConsumeSymbol('...') then 				isVarArg = true 				if not tok:ConsumeSymbol(')') then 					return false, GenerateError("`...` must be the last argument of a function.") 				end 				break 			else 				return false, GenerateError("Argument name or `...` expected") 			end 		end  		  		local st, body = ParseStatementList(funcScope) 		if not st then return false, body end  		  		if not tok:ConsumeKeyword('end') then 			return false, GenerateError("`end` expected after function body") 		end 		local nodeFunc = {} 		nodeFunc.AstType = 'Function' 		nodeFunc.Scope = funcScope 		nodeFunc.Arguments = argList 		nodeFunc.Body = body 		nodeFunc.VarArg = isVarArg 		  		return true, nodeFunc 	end   	function ParsePrimaryExpr(scope) 		if tok:ConsumeSymbol('(') then 			local st, ex = ParseExpr(scope) 			if not st then return false, ex end 			if not tok:ConsumeSymbol(')') then 				return false, GenerateError("`)` Expected.") 			end 			  			ex.ParenCount = (ex.ParenCount or 0) + 1 			return true, ex  		elseif tok:Is('Ident') then 			local id = tok:Get() 			local var = scope:GetLocal(id.Data) 			if not var then 				GlobalVarGetMap[id.Data] = true 			end 			  			local nodePrimExp = {} 			nodePrimExp.AstType = 'VarExpr' 			nodePrimExp.Name = id.Data 			nodePrimExp.Local = var 			  			return true, nodePrimExp 		else 			return false, GenerateError("primary expression expected") 		end 	end  	function ParseSuffixedExpr(scope, onlyDotColon) 		  		local st, prim = ParsePrimaryExpr(scope) 		if not st then return false, prim end 		  		while true do 			if tok:IsSymbol('.') or tok:IsSymbol(':') then 				local symb = tok:Get().Data 				if not tok:Is('Ident') then 					return false, GenerateError("<Ident> expected.") 				end 				local id = tok:Get() 				local nodeIndex = {} 				nodeIndex.AstType = 'MemberExpr' 				nodeIndex.Base = prim 				nodeIndex.Indexer = symb 				nodeIndex.Ident = id 				  				prim = nodeIndex  			elseif not onlyDotColon and tok:ConsumeSymbol('[') then 				local st, ex = ParseExpr(scope) 				if not st then return false, ex end 				if not tok:ConsumeSymbol(']') then 					return false, GenerateError("`]` expected.") 				end 				local nodeIndex = {} 				nodeIndex.AstType = 'IndexExpr' 				nodeIndex.Base = prim 				nodeIndex.Index = ex 				  				prim = nodeIndex  			elseif not onlyDotColon and tok:ConsumeSymbol('(') then 				local args = {} 				while not tok:ConsumeSymbol(')') do 					local st, ex = ParseExpr(scope) 					if not st then return false, ex end 					args[#args+1] = ex 					if not tok:ConsumeSymbol(',') then 						if tok:ConsumeSymbol(')') then 							break 						else 							return false, GenerateError("`)` Expected.") 						end 					end 				end 				local nodeCall = {} 				nodeCall.AstType = 'CallExpr' 				nodeCall.Base = prim 				nodeCall.Arguments = args 				  				prim = nodeCall  			elseif not onlyDotColon and tok:Is('String') then 				  				local nodeCall = {} 				nodeCall.AstType = 'StringCallExpr' 				nodeCall.Base = prim 				nodeCall.Arguments  = {tok:Get()} 				  				prim = nodeCall  			elseif not onlyDotColon and tok:IsSymbol('{') then 				  				local st, ex = ParseSimpleExpr(scope)                                     				if not st then return false, ex end 				local nodeCall = {} 				nodeCall.AstType = 'TableCallExpr' 				nodeCall.Base = prim 				nodeCall.Arguments = { ex } 				  				prim = nodeCall  			else 				break 			end 		end 		return true, prim 	end   	function ParseSimpleExpr(scope) 		if tok:Is('Number') then 			local nodeNum = {} 			nodeNum.AstType = 'NumberExpr' 			nodeNum.Value = tok:Get() 			return true, nodeNum  		elseif tok:Is('String') then 			local nodeStr = {} 			nodeStr.AstType = 'StringExpr' 			nodeStr.Value = tok:Get() 			return true, nodeStr  		elseif tok:ConsumeKeyword('nil') then 			local nodeNil = {} 			nodeNil.AstType = 'NilExpr' 			return true, nodeNil  		elseif tok:IsKeyword('false') or tok:IsKeyword('true') then 			local nodeBoolean = {} 			nodeBoolean.AstType = 'BooleanExpr' 			nodeBoolean.Value = (tok:Get().Data == 'true') 			return true, nodeBoolean  		elseif tok:ConsumeSymbol('...') then 			local nodeDots = {} 			nodeDots.AstType = 'DotsExpr' 			return true, nodeDots  		elseif tok:ConsumeSymbol('{') then 			local v = {} 			v.AstType = 'ConstructorExpr' 			v.EntryList = {} 			  			while true do 				if tok:IsSymbol('[') then 					  					tok:Get() 					local st, key = ParseExpr(scope) 					if not st then 						return false, GenerateError("Key Expression Expected") 					end 					if not tok:ConsumeSymbol(']') then 						return false, GenerateError("`]` Expected") 					end 					if not tok:ConsumeSymbol('=') then 						return false, GenerateError("`=` Expected") 					end 					local st, value = ParseExpr(scope) 					if not st then 						return false, GenerateError("Value Expression Expected") 					end 					v.EntryList[#v.EntryList+1] = { 						Type = 'Key'; 						Key = key; 						Value = value; 					}  				elseif tok:Is('Ident') then 					  					local lookahead = tok:Peek(1) 					if lookahead.Type == 'Symbol' and lookahead.Data == '=' then 						  						local key = tok:Get() 						if not tok:ConsumeSymbol('=') then 							return false, GenerateError("`=` Expected") 						end 						local st, value = ParseExpr(scope) 						if not st then 							return false, GenerateError("Value Expression Expected") 						end 						v.EntryList[#v.EntryList+1] = { 							Type = 'KeyString'; 							Key = key.Data; 							Value = value; 						}  					else 						  						local st, value = ParseExpr(scope) 						if not st then 							return false, GenerateError("Value Exected") 						end 						v.EntryList[#v.EntryList+1] = { 							Type = 'Value'; 							Value = value; 						}  					end 				elseif tok:ConsumeSymbol('}') then 					break  				else 					  					local st, value = ParseExpr(scope) 					v.EntryList[#v.EntryList+1] = { 						Type = 'Value'; 						Value = value; 					} 					if not st then 						return false, GenerateError("Value Expected") 					end 				end  				if tok:ConsumeSymbol(';') or tok:ConsumeSymbol(',') then 					  				elseif tok:ConsumeSymbol('}') then 					break 				else 					return false, GenerateError("`}` or table entry Expected") 				end 			end 			return true, v  		elseif tok:ConsumeKeyword('function') then 			local st, func = ParseFunctionArgsAndBody(scope) 			if not st then return false, func end 			  			func.IsLocal = true 			return true, func  		else 			return ParseSuffixedExpr(scope) 		end 	end   	local unops = lookupify{'-', 'not', '#'} 	local unopprio = 8 	local priority = { 		['+'] = {6,6}; 		['-'] = {6,6}; 		['%'] = {7,7}; 		['/'] = {7,7}; 		['*'] = {7,7}; 		['^'] = {10,9}; 		['..'] = {5,4}; 		['=='] = {3,3}; 		['<'] = {3,3}; 		['<='] = {3,3}; 		['~='] = {3,3}; 		['>'] = {3,3}; 		['>='] = {3,3}; 		['and'] = {2,2}; 		['or'] = {1,1}; 	} 	function ParseSubExpr(scope, level) 		  		local st, exp 		if unops[tok:Peek().Data] then 			local op = tok:Get().Data 			st, exp = ParseSubExpr(scope, unopprio) 			if not st then return false, exp end 			local nodeEx = {} 			nodeEx.AstType = 'UnopExpr' 			nodeEx.Rhs = exp 			nodeEx.Op = op 			exp = nodeEx 		else 			st, exp = ParseSimpleExpr(scope) 			if not st then return false, exp end 		end  		  		while true do 			local prio = priority[tok:Peek().Data] 			if prio and prio[1] > level then 				local op = tok:Get().Data 				local st, rhs = ParseSubExpr(scope, prio[2]) 				if not st then return false, rhs end 				local nodeEx = {} 				nodeEx.AstType = 'BinopExpr' 				nodeEx.Lhs = exp 				nodeEx.Op = op 				nodeEx.Rhs = rhs 				  				exp = nodeEx 			else 				break 			end 		end  		return true, exp 	end   	ParseExpr = function(scope) 		return ParseSubExpr(scope, 0) 	end   	local function ParseStatement(scope) 		local stat = nil 		  getWSAndComments()         if tok:ConsumeKeyword('if') then 			  			local nodeIfStat = {} 			nodeIfStat.AstType = 'IfStatement' 			nodeIfStat.Clauses = {}  			  			repeat 				local st, nodeCond = ParseExpr(scope) 				if not st then return false, nodeCond end 				if not tok:ConsumeKeyword('then') then 					return false, GenerateError("`then` expected.") 				end 				local st, nodeBody = ParseStatementList(scope) 				if not st then return false, nodeBody end 				nodeIfStat.Clauses[#nodeIfStat.Clauses+1] = { 					Condition = nodeCond; 					Body = nodeBody; 				} 			until not tok:ConsumeKeyword('elseif')  			  			if tok:ConsumeKeyword('else') then 				local st, nodeBody = ParseStatementList(scope) 				if not st then return false, nodeBody end 				nodeIfStat.Clauses[#nodeIfStat.Clauses+1] = { 					Body = nodeBody; 				} 			end  			  			if not tok:ConsumeKeyword('end') then 				return false, GenerateError("`end` expected.") 			end  			stat = nodeIfStat  		elseif tok:ConsumeKeyword('while') then 			  			local nodeWhileStat = {} 			nodeWhileStat.AstType = 'WhileStatement'  			  			local st, nodeCond = ParseExpr(scope) 			if not st then return false, nodeCond end  			  			if not tok:ConsumeKeyword('do') then 				return false, GenerateError("`do` expected.") 			end  			  			local st, nodeBody = ParseStatementList(scope) 			if not st then return false, nodeBody end  			  			if not tok:ConsumeKeyword('end') then 				return false, GenerateError("`end` expected.") 			end  			  			nodeWhileStat.Condition = nodeCond 			nodeWhileStat.Body = nodeBody 			stat = nodeWhileStat  		elseif tok:ConsumeKeyword('do') then 			  			local st, nodeBlock = ParseStatementList(scope) 			if not st then return false, nodeBlock end 			if not tok:ConsumeKeyword('end') then 				return false, GenerateError("`end` expected.") 			end  			local nodeDoStat = {} 			nodeDoStat.AstType = 'DoStatement' 			nodeDoStat.Body = nodeBlock 			stat = nodeDoStat  		elseif tok:ConsumeKeyword('for') then 			  			if not tok:Is('Ident') then 				return false, GenerateError("<ident> expected.") 			end 			local baseVarName = tok:Get() 			if tok:ConsumeSymbol('=') then 				  				local forScope = CreateScope(scope) 				local forVar = forScope:CreateLocal(baseVarName.Data) 				  				local st, startEx = ParseExpr(scope) 				if not st then return false, startEx end 				if not tok:ConsumeSymbol(',') then 					return false, GenerateError("`,` Expected") 				end 				local st, endEx = ParseExpr(scope) 				if not st then return false, endEx end 				local st, stepEx; 				if tok:ConsumeSymbol(',') then 					st, stepEx = ParseExpr(scope) 					if not st then return false, stepEx end 				end 				if not tok:ConsumeKeyword('do') then 					return false, GenerateError("`do` expected") 				end 				  				local st, body = ParseStatementList(forScope) 				if not st then return false, body end 				if not tok:ConsumeKeyword('end') then 					return false, GenerateError("`end` expected") 				end 				  				local nodeFor = {} 				nodeFor.AstType = 'NumericForStatement' 				nodeFor.Scope = forScope 				nodeFor.Variable = forVar 				nodeFor.Start = startEx 				nodeFor.End = endEx 				nodeFor.Step = stepEx 				nodeFor.Body = body 				stat = nodeFor 			else 				  				local forScope = CreateScope(scope) 				  				local varList = {forScope:CreateLocal(baseVarName.Data)} 				while tok:ConsumeSymbol(',') do 					if not tok:Is('Ident') then 						return false, GenerateError("for variable expected.") 					end 					varList[#varList+1] = forScope:CreateLocal(tok:Get().Data) 				end 				if not tok:ConsumeKeyword('in') then 					return false, GenerateError("`in` expected.") 				end 				local generators = {} 				local st, firstGenerator = ParseExpr(scope) 				if not st then return false, firstGenerator end 				generators[#generators+1] = firstGenerator 				while tok:ConsumeSymbol(',') do 					local st, gen = ParseExpr(scope) 					if not st then return false, gen end 					generators[#generators+1] = gen 				end 				if not tok:ConsumeKeyword('do') then 					return false, GenerateError("`do` expected.") 				end 				local st, body = ParseStatementList(forScope) 				if not st then return false, body end 				if not tok:ConsumeKeyword('end') then 					return false, GenerateError("`end` expected.") 				end 				  				local nodeFor = {} 				nodeFor.AstType = 'GenericForStatement' 				nodeFor.Scope = forScope 				nodeFor.VariableList = varList 				nodeFor.Generators = generators 				nodeFor.Body = body 				stat = nodeFor 			end  		elseif tok:ConsumeKeyword('repeat') then 			local st, body = ParseStatementList(scope) 			if not st then return false, body end 			  			if not tok:ConsumeKeyword('until') then 				return false, GenerateError("`until` expected.") 			end 			  			local st, cond = ParseExpr(body.Scope) 			if not st then return false, cond end 			  			local nodeRepeat = {} 			nodeRepeat.AstType = 'RepeatStatement' 			nodeRepeat.Condition = cond 			nodeRepeat.Body = body 			stat = nodeRepeat  		elseif tok:ConsumeKeyword('function') then 			if not tok:Is('Ident') then 				return false, GenerateError("Function name expected") 			end 			local st, name = ParseSuffixedExpr(scope, true)   			if not st then return false, name end 			  			local st, func = ParseFunctionArgsAndBody(scope) 			if not st then return false, func end 			  			func.IsLocal = false 			func.Name = name 			stat = func  		elseif tok:ConsumeKeyword('local') then 			if tok:Is('Ident') then 				local varList = {tok:Get().Data} 				while tok:ConsumeSymbol(',') do 					if not tok:Is('Ident') then 						return false, GenerateError("local var name expected") 					end 					varList[#varList+1] = tok:Get().Data 				end  				local initList = {} 				if tok:ConsumeSymbol('=') then 					repeat 						local st, ex = ParseExpr(scope) 						if not st then return false, ex end 						initList[#initList+1] = ex 					until not tok:ConsumeSymbol(',') 				end  				  				  				  				for i, v in pairs(varList) do 					varList[i] = scope:CreateLocal(v) 				end  				local nodeLocal = {} 				nodeLocal.AstType = 'LocalStatement' 				nodeLocal.LocalList = varList 				nodeLocal.InitList = initList 				  				stat = nodeLocal  			elseif tok:ConsumeKeyword('function') then 				if not tok:Is('Ident') then 					return false, GenerateError("Function name expected") 				end 				local name = tok:Get().Data 				local localVar = scope:CreateLocal(name) 				  				local st, func = ParseFunctionArgsAndBody(scope) 				if not st then return false, func end 				  				func.Name = localVar 				func.IsLocal = true 				stat = func  			else 				return false, GenerateError("local var or function def expected") 			end  		elseif tok:ConsumeSymbol('::') then 			if not tok:Is('Ident') then 				return false, GenerateError('Label name expected') 			end 			local label = tok:Get().Data 			if not tok:ConsumeSymbol('::') then 				return false, GenerateError("`::` expected") 			end 			local nodeLabel = {} 			nodeLabel.AstType = 'LabelStatement' 			nodeLabel.Label = label 			stat = nodeLabel  		elseif tok:ConsumeKeyword('return') then 			local exList = {} 			if not tok:IsKeyword('end') then 				local st, firstEx = ParseExpr(scope) 				if st then 					exList[1] = firstEx 					while tok:ConsumeSymbol(',') do 						local st, ex = ParseExpr(scope) 						if not st then return false, ex end 						exList[#exList+1] = ex 					end 				end 			end  			local nodeReturn = {} 			nodeReturn.AstType = 'ReturnStatement' 			nodeReturn.Arguments = exList 			stat = nodeReturn  		elseif tok:ConsumeKeyword('break') then 			local nodeBreak = {} 			nodeBreak.AstType = 'BreakStatement' 			stat = nodeBreak  		elseif tok:ConsumeKeyword('goto') then 			if not tok:Is('Ident') then 				return false, GenerateError("Label expected") 			end 			local label = tok:Get().Data 			local nodeGoto = {} 			nodeGoto.AstType = 'GotoStatement' 			nodeGoto.Label = label 			stat = nodeGoto  		else 			  			local st, suffixed = ParseSuffixedExpr(scope) 			if not st then return false, suffixed end  			  			if tok:IsSymbol(',') or tok:IsSymbol('=') then 				  				if (suffixed.ParenCount or 0) > 0 then 					return false, GenerateError("Can not assign to parenthesized expression, is not an lvalue") 				end  				  				local lhs = {suffixed} 				while tok:ConsumeSymbol(',') do 					local st, lhsPart = ParseSuffixedExpr(scope) 					if not st then return false, lhsPart end 					lhs[#lhs+1] = lhsPart 				end  				  				if not tok:ConsumeSymbol('=') then 					return false, GenerateError("`=` Expected.") 				end  				  				local rhs = {} 				local st, firstRhs = ParseExpr(scope) 				if not st then return false, firstRhs end 				rhs[1] = firstRhs 				while tok:ConsumeSymbol(',') do 					local st, rhsPart = ParseExpr(scope) 					if not st then return false, rhsPart end 					rhs[#rhs+1] = rhsPart 				end  				  				local nodeAssign = {} 				nodeAssign.AstType = 'AssignmentStatement' 				nodeAssign.Lhs = lhs 				nodeAssign.Rhs = rhs 				stat = nodeAssign  			elseif suffixed.AstType == 'CallExpr' or 			       suffixed.AstType == 'TableCallExpr' or 			       suffixed.AstType == 'StringCallExpr' 			then 				  				local nodeCall = {} 				nodeCall.AstType = 'CallStatement' 				nodeCall.Expression = suffixed 				stat = nodeCall 			else 				return false, GenerateError("Assignment Statement Expected") 			end 		end  		stat.HasSemicolon = tok:ConsumeSymbol(';') 		return true, stat 	end   	local statListCloseKeywords = lookupify{'end', 'else', 'elseif', 'until'}  	ParseStatementList = function(scope) 		local nodeStatlist = {} 		nodeStatlist.Scope = CreateScope(scope) 		nodeStatlist.AstType = 'Statlist'         nodeStatlist.Body = { } 		  		  		  		while not statListCloseKeywords[tok:Peek().Data] and not tok:IsEof() do 			local st, nodeStatement = ParseStatement(nodeStatlist.Scope) 			if not st then return false, nodeStatement end 			              nodeStatlist.Body[#nodeStatlist.Body + 1] = nodeStatement 		end 		  		  		return true, nodeStatlist 	end   	local function mainfunc() 		local topScope = CreateScope() 		return ParseStatementList(topScope) 	end  	local st, main = mainfunc() 	  	return st, main end local function Format_Mini(ast) 	local formatStatlist, formatExpr; 	local count = 0 	  	local function joinStatementsSafe(a, b, sep) 		if count > 150 then 			count = 0 			  		end 		sep = sep or ' ' 		local aa, bb = a:sub(-1,-1), b:sub(1,1) 		if UpperChars[aa] or LowerChars[aa] or aa == '_' then 			if not (UpperChars[bb] or LowerChars[bb] or bb == '_' or Digits[bb]) then 				  				return a..b 			elseif bb == '(' then 				print("==============>>>",aa,bb) 				  				return a..sep..b 			else 				return a..sep..b 			end 		elseif Digits[aa] then 			if bb == '(' then 				  				return a..b 			else 				return a..sep..b 			end 		elseif aa == '' then 			return a..b 		else 			if bb == '(' then 				  				return a..sep..b 			else 				return a..b 			end 		end 	end  	formatExpr = function(expr) 		local out = string.rep('(', expr.ParenCount or 0) 		if expr.AstType == 'VarExpr' then 			if expr.Local then 				out = out..expr.Local.Name 			else 				out = out..expr.Name 			end  		elseif expr.AstType == 'NumberExpr' then 			out = out..expr.Value.Data  		elseif expr.AstType == 'StringExpr' then 			out = out..expr.Value.Data  		elseif expr.AstType == 'BooleanExpr' then 			out = out..tostring(expr.Value)  		elseif expr.AstType == 'NilExpr' then 			out = joinStatementsSafe(out, "nil")  		elseif expr.AstType == 'BinopExpr' then 			out = joinStatementsSafe(out, formatExpr(expr.Lhs)) 			out = joinStatementsSafe(out, expr.Op) 			out = joinStatementsSafe(out, formatExpr(expr.Rhs))  		elseif expr.AstType == 'UnopExpr' then 			out = joinStatementsSafe(out, expr.Op) 			out = joinStatementsSafe(out, formatExpr(expr.Rhs))  		elseif expr.AstType == 'DotsExpr' then 			out = out.."..."  		elseif expr.AstType == 'CallExpr' then 			out = out..formatExpr(expr.Base) 			out = out.."(" 			for i = 1, #expr.Arguments do 				out = out..formatExpr(expr.Arguments[i]) 				if i ~= #expr.Arguments then 					out = out.."," 				end 			end 			out = out..")"  		elseif expr.AstType == 'TableCallExpr' then 			out = out..formatExpr(expr.Base) 			out = out..formatExpr(expr.Arguments[1])  		elseif expr.AstType == 'StringCallExpr' then 			out = out..formatExpr(expr.Base) 			out = out..expr.Arguments[1].Data  		elseif expr.AstType == 'IndexExpr' then 			out = out..formatExpr(expr.Base).."["..formatExpr(expr.Index).."]"  		elseif expr.AstType == 'MemberExpr' then 			out = out..formatExpr(expr.Base)..expr.Indexer..expr.Ident.Data  		elseif expr.AstType == 'Function' then 			expr.Scope:ObfuscateVariables() 			out = out.."function(" 			if #expr.Arguments > 0 then 				for i = 1, #expr.Arguments do 					out = out..expr.Arguments[i].Name 					if i ~= #expr.Arguments then 						out = out.."," 					elseif expr.VarArg then 						out = out..",..." 					end 				end 			elseif expr.VarArg then 				out = out.."..." 			end 			out = out..")" 			out = joinStatementsSafe(out, formatStatlist(expr.Body)) 			out = joinStatementsSafe(out, "end")  		elseif expr.AstType == 'ConstructorExpr' then 			out = out.."{" 			for i = 1, #expr.EntryList do 				local entry = expr.EntryList[i] 				if entry.Type == 'Key' then 					out = out.."["..formatExpr(entry.Key).."]="..formatExpr(entry.Value) 				elseif entry.Type == 'Value' then 					out = out..formatExpr(entry.Value) 				elseif entry.Type == 'KeyString' then 					out = out..entry.Key.."="..formatExpr(entry.Value) 				end 				if i ~= #expr.EntryList then 					out = out.."," 				end 			end 			out = out.."}"  		end 		out = out..string.rep(')', expr.ParenCount or 0) 		count = count + #out 		return out 	end  	local formatStatement = function(statement) 		local out = '' 		if statement.AstType == 'AssignmentStatement' then 			for i = 1, #statement.Lhs do 				out = out..formatExpr(statement.Lhs[i]) 				if i ~= #statement.Lhs then 					out = out.."," 				end 			end 			if #statement.Rhs > 0 then 				out = out.."=" 				for i = 1, #statement.Rhs do 					out = out..formatExpr(statement.Rhs[i]) 					if i ~= #statement.Rhs then 						out = out.."," 					end 				end 			end  		elseif statement.AstType == 'CallStatement' then 			out = formatExpr(statement.Expression)  		elseif statement.AstType == 'LocalStatement' then 			out = out.."local " 			for i = 1, #statement.LocalList do 				out = out..statement.LocalList[i].Name 				if i ~= #statement.LocalList then 					out = out.."," 				end 			end 			if #statement.InitList > 0 then 				out = out.."=" 				for i = 1, #statement.InitList do 					out = out..formatExpr(statement.InitList[i]) 					if i ~= #statement.InitList then 						out = out.."," 					end 				end 			end  		elseif statement.AstType == 'IfStatement' then 			out = joinStatementsSafe("if", formatExpr(statement.Clauses[1].Condition)) 			out = joinStatementsSafe(out, "then") 			out = joinStatementsSafe(out, formatStatlist(statement.Clauses[1].Body)) 			for i = 2, #statement.Clauses do 				local st = statement.Clauses[i] 				if st.Condition then 					out = joinStatementsSafe(out, "elseif") 					out = joinStatementsSafe(out, formatExpr(st.Condition)) 					out = joinStatementsSafe(out, "then") 				else 					out = joinStatementsSafe(out, "else") 				end 				out = joinStatementsSafe(out, formatStatlist(st.Body)) 			end 			out = joinStatementsSafe(out, "end")  		elseif statement.AstType == 'WhileStatement' then 			out = joinStatementsSafe("while", formatExpr(statement.Condition)) 			out = joinStatementsSafe(out, "do") 			out = joinStatementsSafe(out, formatStatlist(statement.Body)) 			out = joinStatementsSafe(out, "end")  		elseif statement.AstType == 'DoStatement' then 			out = joinStatementsSafe(out, "do") 			out = joinStatementsSafe(out, formatStatlist(statement.Body)) 			out = joinStatementsSafe(out, "end")  		elseif statement.AstType == 'ReturnStatement' then 			out = "return" 			for i = 1, #statement.Arguments do 				out = joinStatementsSafe(out, formatExpr(statement.Arguments[i])) 				if i ~= #statement.Arguments then 					out = out.."," 				end 			end  		elseif statement.AstType == 'BreakStatement' then 			out = "break"  		elseif statement.AstType == 'RepeatStatement' then 			out = "repeat" 			out = joinStatementsSafe(out, formatStatlist(statement.Body)) 			out = joinStatementsSafe(out, "until") 			out = joinStatementsSafe(out, formatExpr(statement.Condition))  		elseif statement.AstType == 'Function' then 			statement.Scope:ObfuscateVariables() 			if statement.IsLocal then 				out = "local" 			end 			out = joinStatementsSafe(out, "function ") 			if statement.IsLocal then 				out = out..statement.Name.Name 			else 				out = out..formatExpr(statement.Name) 			end 			out = out.."(" 			if #statement.Arguments > 0 then 				for i = 1, #statement.Arguments do 					out = out..statement.Arguments[i].Name 					if i ~= #statement.Arguments then 						out = out.."," 					elseif statement.VarArg then 						print("Apply vararg") 						out = out..",..." 					end 				end 			elseif statement.VarArg then 				out = out.."..." 			end 			out = out..")" 			out = joinStatementsSafe(out, formatStatlist(statement.Body)) 			out = joinStatementsSafe(out, "end")  		elseif statement.AstType == 'GenericForStatement' then 			statement.Scope:ObfuscateVariables() 			out = "for " 			for i = 1, #statement.VariableList do 				out = out..statement.VariableList[i].Name 				if i ~= #statement.VariableList then 					out = out.."," 				end 			end 			out = out.." in" 			for i = 1, #statement.Generators do 				out = joinStatementsSafe(out, formatExpr(statement.Generators[i])) 				if i ~= #statement.Generators then 					out = joinStatementsSafe(out, ',') 				end 			end 			out = joinStatementsSafe(out, "do") 			out = joinStatementsSafe(out, formatStatlist(statement.Body)) 			out = joinStatementsSafe(out, "end")  		elseif statement.AstType == 'NumericForStatement' then 			out = "for " 			out = out..statement.Variable.Name.."=" 			out = out..formatExpr(statement.Start)..","..formatExpr(statement.End) 			if statement.Step then 				out = out..","..formatExpr(statement.Step) 			end 			out = joinStatementsSafe(out, "do") 			out = joinStatementsSafe(out, formatStatlist(statement.Body))             out = joinStatementsSafe(out, "end")         elseif statement.AstType == 'LabelStatement' then             out = getIndentation() .. "::" .. statement.Label .. "::"         elseif statement.AstType == 'GotoStatement' then             out = getIndentation() .. "goto " .. statement.Label         elseif statement.AstType == 'Comment' then                       else             print("Unknown AST Type: " .. statement.AstType) 		end 		count = count + #out 		return out 	end  	formatStatlist = function(statList) 		local out = '' 		statList.Scope:ObfuscateVariables() 		for _, stat in pairs(statList.Body) do 			out = joinStatementsSafe(out, formatStatement(stat), ';') 		end 		return out 	end  	ast.Scope:ObfuscateVariables() 	return formatStatlist(ast) end  function mLogs.minify(src)           src = string.Replace(src, "!=", "~=")     local success, ast = ParseLua(src)     if(not success)then         return false     end     return true, Format_Mini(ast) end 
--PATH mlogs/config/sh_config.lua:
     mLogs.config.fileVersions = mLogs.config.fileVersions or {} mLogs.config.fileVersions["config/sh_config.lua"] = 1    mLogs.config.root = { 	["superadmin"] = true, 	["owner"] = true, }    
--PATH mlogs/logger/sh_advlogger.lua:
   mLogs.logger.searchTypes = mLogs.logger.searchTypes or {}  function mLogs.logger.addSearchType(name,key,getOptions,checkOption,toQuery)     mLogs.logger.searchTypes[key] = {name=name,key=key,getOptions=getOptions,checkOption=checkOption,toQuery=toQuery} end  function mLogs.logger.getSearchType(key)     return mLogs.logger.searchTypes[key] or false end  function mLogs.logger.getSearchTypes()     return mLogs.logger.searchTypes end  function mLogs.logger.makeSearchOption(str,data,category)     return {str=str or "",data=data or {},category=category} end  mLogs.logger.addSearchType(     mLogs.getLang("category"),     "category",     function()         local categories = CLIENT and mLogs.categories or mLogs.getCategories()         local options = {}         for key,v in pairs(categories) do             if(key == "logs") then continue end             if(v.hooks and v.hooks[1])then                 for _,hookData in pairs(v.hooks) do                     table.insert(options,                         mLogs.logger.makeSearchOption(                             v.name .. ": " .. hookData.name,                             {c=v.tag,t=hookData.tag},                             "category"                         )                     )                 end             end         end         return options     end,     function(ply,data)         if(not (data.c and data.t))then return false end 	    if(not mLogs.getHookFromTag(data.c,data.t)) then return false end     	if(not mLogs.permissions.canViewCategoryTag(ply,data.c,data.t)) then return false end         return true     end,     function(data)         if(CLIENT) then return "" end         if(#data==0)then return "" end         local str = ""         if(mLogs.config.provider == "mysql")then             str = "(category,tag) IN ("             for _,v in pairs(data)do                 str = str .. "('".. mLogs.escape(v.data.c) .."','".. mLogs.escape(v.data.t) .."'),"             end             str = string.sub(str,1,-2)             str = str .. ")"         else             str = "category || '-' || tag in ("             for _,v in pairs(data) do                 str = str .. "'" .. mLogs.escape(v.data.c) .. "-" .. mLogs.escape(v.data.t) .. "',"             end             str = string.sub(str,1,-2)             str = str .. ")"         end         return str     end )  mLogs.logger.addSearchType(     mLogs.getLang("online_players"),     "oplayers",     function()         local options = {}         for k,v in pairs(player.GetAll()) do             if(IsValid(v) and v.Nick and v.SteamID)then                 table.insert(options,                     mLogs.logger.makeSearchOption(                         v:Nick(),                         {steamid=v:SteamID()},                         "oplayers"                     )                 )             end         end         return options     end,     function(ply,data)         if(not data.steamid) then return end         return true     end,     function(data)         if(CLIENT) then return "" end         if(#data==0)then return "" end         local str = "("         for _,v in pairs(data)do             str = str .. "data LIKE '%".. mLogs.escape(v.data.steamid) .."%'"             if(_ != 1)then                 nst = " OR"             end         end         if(#data > 1)then             str = string.sub(str,1,-3)         end         str = str .. ")"         return str     end ) 
--PATH mlogs/logger/cl_console.lua:
   mLogs.console = mLogs.console or {} mLogs.console.showLogs = mLogs.console.showLogs != nil and mLogs.console.showLogs or true  mLogs.AddInterface("console_print", function()     local tag,dataStr = net.ReadString(),net.ReadString()     if(not (dataStr and tag)) then return end     if(tag == "log" and not mLogs.console.showLogs) then return end     local data = mLogs.decompress(dataStr)     if(not data) then return end     for k,v in pairs(data)do         mLogs.Print(v)     end end) 
--PATH mlogs/settings/subs/sh_format.lua:
       local ct,st = "client","format" mLogs.settings.addSubcategory(mLogs.getLang("format"),ct,st)  for Type,options in pairs(mLogs.logger and mLogs.logger.defInfo or {})do 	mLogs.settings.addSpacer(mLogs.upper(Type),ct,st) 	for setting,data in pairs(options)do 		mLogs.settings.addOption(ct,st,{ 			title = data.name, 			tag = Type .. "_" .. setting, 			desc = "Should the " .. Type .. "'s " .. string.lower(data.name) .. " be visible in ".. Type .." logs? (if allowed)", 			type = "bool", 			default = data.default, 			get = function() return mLogs.isDefinitionInfoEnabled(Type,setting) end, 			set = function(bool) mLogs.setDefinitionInfoEnabled(Type,setting,bool) end 		}) 	end end 
--PATH mlogs/settings/types/sh_string.lua:
     mLogs.settings.addType("string",function(d)     return d and isstring(d) and d != "" end) 
--PATH mlogs/elements/logs/cl_logs.lua:
   DEFINE_BASECLASS("mLogs_contentBase") mLogs.categoryWeight = mLogs.categoryWeight or {}  local PANEL = {} function PANEL:Init() 	self:SetTitleVisible(false) 	 	self.sidebar = self:Add("mLogs_sidebar") 	 	local cats = table.ClearKeys(mLogs.categories) 	table.sort(cats, function(a,b) 		return (mLogs.categoryWeight[a.tag] or a.weight or 1) > (mLogs.categoryWeight[b.tag] or b.weight or 1) 	end) 	 	for _,data in pairs(cats) do 		self:AddCategory(data) 	end 	 	self.logOptions = self.scroll:Add("mLogs_logsOptions") 	self.logOptions.OnPage = function(req) 		self.logView:FetchLogs(self.sh[1],self.sh[2],req) 	end 	self.logOptions.OnPageOverride = function(c_tag,h_tag,req) 		self:SelectHook(c_tag,h_tag,req) 	end 	 	self.logView = self.scroll:Add("mLogs_logsView") 	self.logView.OnPageData = function(pageData) 		self.logOptions:SetPageData(pageData,self.sh and self.sh[3] or false) 	end 	 	self:SelectHook("logs","all")  end  function mLogs.createLogInfoPanel() 	if(not ValidPanel(mLogs.mainFrame)) then return end 	if(mLogs.logInfo and ValidPanel(mLogs.logInfo)) then return end 	local mPX,mPY = mLogs.mainFrame:GetPos() 	local mSW,mSH = mLogs.mainFrame:GetSize() 	 	mLogs.logInfo = vgui.Create("mLogs_logsInfo") 	mLogs.logInfo:SetVisible(false) 	mLogs.logInfo:SetPos(mPX,mPY+mSH+ScrH()*0.015) 	mLogs.logInfo:SetSize(mSW,ScrH()*0.12) end  function PANEL:OnShowPanel() 	if(ValidPanel(mLogs.logInfo))then return end 	mLogs.createLogInfoPanel() end  function PANEL:SelectHook(categoryName,tag,query) 	if(self.sh and self.sh[1] == categoryName and self.sh[2] == tag and not query) then return end 	for k,v in pairs(self.sidebar:GetItems()) do 		if(v.pnl and ValidPanel(v.pnl))then 			local pnl = v.pnl 			if(pnl:GetCategory() and pnl:GetCategory().tag == categoryName)then 				pnl:SetInternalHook(tag) 			else 				pnl:ClearInternalHook() 			end 		end 	end 	 	self.logView:FetchLogs(categoryName,tag,query) 	self.sh = {categoryName,tag,query} end  function PANEL:AddCategory(data) 	local pnl = self.sidebar:Add("mLogs_logsCategory") 	pnl:SetCategory(data) 	pnl.OnSelectHook = function(category,hookData) 		self:SelectHook(category.tag,hookData.tag) 	end 	self.sidebar:AddItem(pnl,nil,42,1) end  function PANEL:Paint(w,h) 	BaseClass.Paint(self,w,h) end  function PANEL:OnRemove() 	if(ValidPanel(mLogs.logInfo))then 		mLogs.logInfo:Remove() 	end end  function PANEL:PerformLayout(w,h) 	BaseClass.PerformLayout(self,w,h) 	 	self.sidebar:SetSize(w*0.2,h) 	 	self.yPos = self.yPos + self.ySpacing 	self.logView:SetPos(w*0.2 + w*0.5 - w*self.pM*0.5,self.yPos) 	self.logView:SetSize(w*self.pM - w*0.2,h*0.82) 	self.yPos = self.yPos + h*0.82 	 	self.yPos = self.yPos + self.ySpacing 	self.logOptions:SetPos(w*0.2 + w*0.5 - w*self.pM*0.5,self.yPos) 	self.logOptions:SetSize(w*self.pM - w*0.2,h*0.12) 	self.yPos = self.yPos + h*0.12 	 	if(ValidPanel(mLogs.mainFrame) and ValidPanel(mLogs.logInfo))then 		local mPX,mPY = mLogs.mainFrame:GetPos() 		local mSW,mSH = mLogs.mainFrame:GetSize() 		mLogs.logInfo:SetPos(mPX,mPY+mSH+ScrH()*0.015) 		mLogs.logInfo:SetSize(mSW,ScrH()*0.12) 	end  	  	  end vgui.Register( "mLogs_logs", PANEL, "mLogs_contentBase" ) 
--PATH mlogs/elements/settings/types/cl_permissions_list.lua:
   local PANEL = {}  AccessorFunc(PANEL, "m_Title", "Title")  function PANEL:Init()      self:SetTitle("")          self.scroll = self:Add("mLogs_scrollPanel") 	self.layout = self.scroll:Add("DIconLayout")     self.layout:SetSpaceY(-1) end  function PANEL:GetPermissions()     local perms = {}     for k,v in pairs(self.layout:GetChildren())do         if(v.extraData)then             table.insert(perms,v.extraData)         end     end     return perms end  function PANEL:AddPermission(key)     local btn = self.layout:Add("mLogs_button")     btn:SetText(mLogs.permissions.conversions[key] or key)     btn:SetFont("mLogs_clearText")     btn:SetLeftAlign(true)     btn:SetOutline(true)     btn.extraData = key     btn.DoClick = function(s)         s:Remove()         self:OnPermissionSelect(key)         self:InvalidateLayout()     end end  function PANEL:OnPermissionSelect()  end  function PANEL:Clear()     self.layout:Clear() end  function PANEL:Paint(w,h) 	draw.RoundedBox(0,0,0,w,h,mLogs.config.colors.border) 	draw.RoundedBox(0,1,1,w-2,h-2,mLogs.config.colors.bg)      draw.RoundedBox(0, 0, 0, w, h*0.1, mLogs.config.colors.hover)     draw.SimpleText(self:GetTitle(), "mLogs_clearText", w*0.5, h*0.05, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) end  function PANEL:PerformLayout(w,h)     self.scroll:SetPos(0,h*0.1)     self.scroll:SetSize(w,h*0.9)          for k,v in pairs(self.layout:GetChildren() or {}) do         v:SetSize(w,24)     end  	self.layout:SetSize(w,select(2,self.layout:ChildrenSize())) 	self.layout:Layout() end  vgui.Register( "mLogs_settingsOption_permissions_list", PANEL, "DPanel" ) 
--PATH mlogs/elements/settings/types/cl_bool.lua:
   local PANEL = {}  DEFINE_BASECLASS("mLogs_settingsBase")  function PANEL:Init()  	self.action = self:Add("DCheckBox")     self.action.fw = 16     self.action.fh = 16     self.fH = 64 end  function PANEL:GetData() 	return tobool(self.action:GetChecked()) end  function PANEL:OnReset() 	self.action:SetValue(self.option.default) end  function PANEL:OnOption(option,data) 	if (data == nil) then return end 	self.action:SetValue(tobool(data)) end  function PANEL:PerformLayout(w,h)     BaseClass.PerformLayout(self,w,h) end  vgui.Register( "mLogs_settingsOption_bool", PANEL, "mLogs_settingsBase" ) 
--PATH mlogs/elements/ui/cl_horizontalscroller.lua:
   local PANEL = {}  AccessorFunc( PANEL, "m_iOverlap",			"Overlap" ) AccessorFunc( PANEL, "m_bShowDropTargets",	"ShowDropTargets", FORCE_BOOL )  function PANEL:Init()  	self.Panels = {} 	self.OffsetX = 0 	self.FrameTime = 0  	self.pnlCanvas = vgui.Create( "DDragBase", self ) 	self.pnlCanvas:SetDropPos( "6" ) 	self.pnlCanvas:SetUseLiveDrag( false ) 	self.pnlCanvas.OnModified = function() self:OnDragModified() end  	self.pnlCanvas.UpdateDropTarget = function( Canvas, drop, pnl ) 		if ( !self:GetShowDropTargets() ) then return end 		DDragBase.UpdateDropTarget( Canvas, drop, pnl ) 	end  	self.pnlCanvas.OnChildAdded = function( Canvas, child )  		local dn = Canvas:GetDnD() 		if ( dn ) then  			child:Droppable( dn ) 			child.OnDrop = function()  				local x, y = Canvas:LocalCursorPos() 				local closest, id = self.pnlCanvas:GetClosestChild( x, Canvas:GetTall() / 2 ), 0  				for k, v in pairs( self.Panels ) do 					if ( v == closest ) then id = k break end 				end  				table.RemoveByValue( self.Panels, child ) 				table.insert( self.Panels, id, child )  				self:InvalidateLayout()  				return child  			end 		end  	end  	self:SetOverlap( 0 )  	self.btnLeft = vgui.Create( "DButton", self ) 	self.btnLeft:SetText( "" ) 	self.btnLeft.Paint = function( panel, w, h ) 		surface.SetDrawColor(Color(0,0,0,200)) 		surface.SetMaterial(mLogs.getPNG("vgui/gradient-l")) 		surface.DrawTexturedRect(0,0,w,h) 		draw.SimpleText("<", "DermaDefault", w*0.5, h*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) 	end  	self.btnRight = vgui.Create( "DButton", self ) 	self.btnRight:SetText( "" ) 	self.btnRight.Paint = function( panel, w, h ) 		surface.SetDrawColor(Color(0,0,0,200)) 		surface.SetMaterial(mLogs.getPNG("vgui/gradient-r")) 		surface.DrawTexturedRect(0,0,w,h) 		draw.SimpleText(">", "DermaDefault", w*0.5, h*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) 	end  end  function PANEL:OnDragModified() 	  end  function PANEL:SetUseLiveDrag( bool ) 	self.pnlCanvas:SetUseLiveDrag( bool ) end  function PANEL:MakeDroppable( name ) 	self.pnlCanvas:MakeDroppable( name ) end  function PANEL:AddPanel( pnl )  	table.insert( self.Panels, pnl )  	pnl:SetParent( self.pnlCanvas ) 	self:InvalidateLayout( true )  end  function PANEL:Clear() 	self.pnlCanvas:Clear() 	self.Panels = {} end  function PANEL:OnMouseWheeled( dlta )  	self.OffsetX = self.OffsetX + dlta * -30 	self:InvalidateLayout( true )  	return true  end  function PANEL:Think()  	  	  	local FrameRate = VGUIFrameTime() - self.FrameTime 	self.FrameTime = VGUIFrameTime()  	if ( self.btnRight:IsDown() ) then 		self.OffsetX = self.OffsetX + ( 500 * FrameRate ) 		self:InvalidateLayout( true ) 	end  	if ( self.btnLeft:IsDown() ) then 		self.OffsetX = self.OffsetX - ( 500 * FrameRate ) 		self:InvalidateLayout( true ) 	end  	if ( dragndrop.IsDragging() ) then  		local x, y = self:LocalCursorPos()  		if ( x < 30 ) then 			self.OffsetX = self.OffsetX - ( 350 * FrameRate ) 		elseif ( x > self:GetWide() - 30 ) then 			self.OffsetX = self.OffsetX + ( 350 * FrameRate ) 		end  		self:InvalidateLayout( true )  	end  end  function PANEL:PerformLayout(w,h)  	self.pnlCanvas:SetTall( h )  	local x = 0  	for k, v in pairs( self.Panels ) do 		if ( !IsValid( v ) ) then continue end  		v:SetPos( x, 0 ) 		v:SetTall( h ) 		v:ApplySchemeSettings()  		x = x + v:GetWide() - self.m_iOverlap  	end  	self.pnlCanvas:SetWide( x + self.m_iOverlap )  	if ( w < self.pnlCanvas:GetWide() ) then 		self.OffsetX = math.Clamp( self.OffsetX, 0, self.pnlCanvas:GetWide() - self:GetWide() ) 	else 		self.OffsetX = 0 	end  	self.pnlCanvas.x = self.OffsetX * -1  	self.btnLeft:SetSize( 24, h )  	self.btnRight:SetSize( 24, h ) 	self.btnRight:SetPos(w-24,0)  	self.btnLeft:SetVisible( self.pnlCanvas.x < 0 ) 	self.btnRight:SetVisible( self.pnlCanvas.x + self.pnlCanvas:GetWide() > self:GetWide() )  end  function PANEL:Paint(w,h)  end  vgui.Register( "mLogs_horizontalScroller", PANEL, "DPanel" )  
--PATH mlogs/elements/ui/cl_button.lua:
   local PANEL = {}  AccessorFunc(PANEL, "m_bClicked", "Clicked") AccessorFunc(PANEL, "m_cBGColor", "BGColor") AccessorFunc(PANEL, "m_cHoverColor", "HoverColor") AccessorFunc(PANEL, "m_cTextColor", "TextColor") AccessorFunc(PANEL, "m_sFont", "Font") AccessorFunc(PANEL, "m_sIcon", "Icon") AccessorFunc(PANEL, "m_bOutline", "Outline", FORCE_BOOL)  function PANEL:Init() 	  	self:SetMouseInputEnabled(true) 	self:SetCursor( "hand" ) 	 	  	self:SetFont("mLogs_default") end  function PANEL:SetLeftAlign(bool) 	self.lAlign = bool end  function PANEL:Paint(w,h) 	if(self.Hovered or self:GetClicked()) then 		draw.RoundedBox(0,0,0,w,h, self:GetHoverColor() or mLogs.config.colors.hover) 	else 		draw.RoundedBox(0,0,0,w,h, self:GetBGColor() or mLogs.config.colors.head) 	end 	 	if(self:GetOutline())then 		surface.SetDrawColor(mLogs.config.colors.uiBorder) 		surface.DrawOutlinedRect(0,0,w,h) 	end 	 	if(self:GetIcon())then 		surface.SetMaterial(mLogs.GetPNG(self:GetIcon())) 		surface.SetDrawColor(color_white) 		surface.DrawTexturedRect(w*0.2,h*0.2,w*0.7,h*0.7) 	elseif(self.txt)then 		draw.SimpleText(self.txt, self:GetFont(), self.lAlign and 4 or w*0.5, h*0.5, self:GetTextColor() or color_white, self.lAlign and  		 TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) 	end end  function PANEL:SetText(txt) 	self.txt = txt end  function PANEL:GetText() 	return self.txt end  function PANEL:OnMousePressed(enum) 	if(self.DoClick and enum == MOUSE_LEFT) then 		self.DoClick(self) 	elseif(self.DoRightClick and enum == MOUSE_RIGHT) then 		self.DoRightClick(self) 	end end  vgui.Register( "mLogs_button", PANEL, "DPanel" ) 