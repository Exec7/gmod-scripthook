--[[
███████╗██╗░░██╗███████╗░█████╗░██╗░░██╗░█████╗░░█████╗░██╗░░██╗░░░░█████╗░░█████╗░
██╔════╝╚██╗██╔╝██╔════╝██╔══██╗██║░░██║██╔══██╗██╔══██╗██║░██╔╝░░░██╔══██╗██╔══██╗
█████╗░░░╚███╔╝░█████╗░░██║░░╚═╝███████║███████║██║░░╚═╝█████═╝░░░░██║░░╚═╝██║░░╚═╝
██╔══╝░░░██╔██╗░██╔══╝░░██║░░██╗██╔══██║██╔══██║██║░░██╗██╔═██╗░░░░██║░░██╗██║░░██╗
███████╗██╔╝╚██╗███████╗╚█████╔╝██║░░██║██║░░██║╚█████╔╝██║░╚██╗██╗╚█████╔╝╚█████╔╝
╚══════╝╚═╝░░╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝░╚════╝░╚═╝░░╚═╝╚═╝░╚════╝░░╚════╝░

HOSTNAME: WayZer's Role Play | Быстрая загрузка
IP: 46.174.54.203:27015
GAMEMODE: darkrp
MAP: rp_bangclaw
MAXPLAYERS: 128
ALL SERVER NETS: Undo_Undone, Undo_AddUndo, Undo_FireUndo, properties, drive_base, drive_noclip, editvariable, nw.PlayerSync, nw.NilEntityVar, nw.NilPlayerVar, nw.EntityRemoved, nw.PlayerRemoved, nw_AFKTime, nw_IsAFK, nw_AFKStart, UpdateAFK, nw_IsTyping, wlib.chat.addText, wlib.chat.updateTyping, wlib.chat.say, nw_Delays, nw_Incognito, nw_SteamAvatar, player_default, PlayerKilledNPC, NPCKilledNPC, PlayerKilled, PlayerKilledSelf, PlayerKilledByPlayer, DeathNoticeEvent, antiAvoid.getSyncAccounts, antiAvoid.syncAccounts, antiAvoid.removeSync, antiAvoid.checkCode, nw_wbank.bagMoney, nw_wbank.inProgress, cats.dispatchMessage, cats.syncTickets, cats.claimTicket, cats.closeTicket, cats.setRating, cats.getAdminList, cats.getAdminData, chiefDemote.demote, chiefDemote.createMarker, DDV.MakePee, dEvents.initEvent, dEvents.getEventTable, dEvents.notify, dEvents.giveWeapon, dEvents.getAllEvents, dEvents.stopEvent, dOrgs.networkOrg, dOrgs.unloadOrg, dOrgs.requestChat, dOrgs.sub, dOrgs.unsub, dOrgs.setDiscordWebhook, duelSystem.RequestDuel, duelSystem.CountDownDuel, elpos, hitSystem.PlaceHit, hitSystem.AcceptHit, hitSystem.OpenMenu, wmarket.sendSummary, wmarket.sub, wmarket.unsub, wmarket.getMyOrders, wmarket.removeOrder, wmarket.createOrder, wmarket.getMyStoredItems, wmarket.claimStoredItem, NetStreamWrite, NetStreamRead, OF, OFSKin, WayBan.getBannedData, plogs.Console, plogs.OpenMenu, plogs.LogData, plogs.GetData, PS_ModelOffsets, PS_ReloadMenu, PS_Items, PS_Points, PS_Inventory, PS_BuyItem, PS_UseItem, PS_MoveItem, PS_SellItem, PS_EquipItem, PS_HolsterItem, PS_ModifyItem, PS_SendPoints, PS_GivePoints, PS_TakePoints, PS_SetPoints, PS_GiveItem, PS_TakeItem, PS_AddClientsideModel, PS_RemoveClientsideModel, PS_SendClientsideModels, PS_SendNotification, PS_ToggleMenu, PS_UpdateSlots, ShopNotify, srp_donate.PSNotification, srp_donate.promo, donate.dayreward, rewards.getInfo, rewards.sendLink, rewards.linkMethod, BlaizerEnergy, dMarkers.create, nw_Weed, nw_Meth, nw_Alc, nw_LSD, nw_Heroine, nw_FireAmmo, nw_DruggedUntil, PurchaseItem, nw_SitOnGround, nw_DeathRagdoll, nw_RespawningPlayer, nw_RagdollInfo, waydeath.ragdollaction, nw_IsFeared, nw_CanTouchOthersEnts, nw_PVPStart, Cuffs_GagPlayer, Cuffs_BlindPlayer, Cuffs_FreePlayer, Cuffs_DragPlayer, Cuffs_TiePlayers, Cuffs_UntiePlayers, URLPaint Download, URLPaint Menu, URLPaint Set, URLPaint Update, nw_TotalUTime, nw_UTimeStart, waypass.ChallengeNotify, waypass.ClaimRewards, waypass.BuyLevels, waypass.BuyBP, ML_MapCleanHack_git@871fb36d_68013, nw_weaponSkin, nw_weaponSkin.list, weaponSkins.buy, weaponSkins.select, weaponSkins.send, wowozela_select_Right, wowozela_select_Left, wowozela_customsample, AdvDupe2_ReportClass, AdvDupe2_ReportModel, AdvDupe2Notify, AdvDupe2_RemoveGhosts, AdvDupe2_ResetDupeInfo, AdvDupe2_StartGhosting, AdvDupe2_InitProgressBar, AdvDupe2_DrawSelectBox, AdvDupe2_RemoveSelectBox, AdvDupe2_UpdateProgressBar, AdvDupe2_RemoveProgressBar, AdvDupe2_ResetOffsets, AdvDupe2_SetDupeInfo, AdvDupe2_ReceiveFile, AdvDupe2_CanAutoSave, AdvDupe2_SendGhosts, AdvDupe2_AddGhost, UpdateBeeper, IsBeeping, crashsaver.yes, crashsaver.no, NetData, BodyGroupData, Set2DPlayer, apg_settings_c2s, apg_context_c2s, BM2.OpenTerminal, BM2.Client.TerminalPrint, BM2.Command.Mining, BM2.Command.SellBitcoins, BM2.Command.Upgrade, BM2.Command.Eject, BM2.Command.RemoteInstall, BM2.Command.ChangeRemoteName, BM2.OpenPhone, BM2.TerminalPrintEnum, luadev_strip, anticheat_cslua, size_me, setmodel_admin, adminsettings_sendvars, pp_info_send, gmphone, _Detect, InitSpin, FinishedUnbox, Vape, VapeArm, VapeTalking, WP_GlowingEnt, waygrab.stop, waygrab.fail, waygrab.sendPart, AddWeed, ClearWeed, nw_DarkRP_Lockdown, nw_FAdmin_commandprefix, DoQuestion, KillQuestionVGUI, DarkRP_vote, DarkRP_killVote, nw_License, GotArrested, nw_Laws, FSpectate, FSpectateTarget, FPP_Groups, FPP_GroupMembers, FPP_RestrictedToolList, FPP_BlockedModels, FPP_Settings, FPP_Settings_Update, FPP_CheckBuddy, FPP_BlockedModel, FPP_blockedlist, FPP_TouchabilityData, FAdmin_retrievebans, FADMIN_SendGroups, FAdmin_GlobalSetting, FAdmin_PlayerSetting, FAdmin_GlobalPlayerSettings, FAdmin_Notification, FAdmin_ConsoleMessage, FAdmin_StopSounds, FAdmin_ReceiveAdminMessage, FAdmin_AddPriv, FAdmin_RemovePriv, nw_IsBanned, nw_BanText, nw_UnBanTime, nw_Door.Config, nw_Door.Title, nw_Door.Locked, nw_Door.Owner, nw_Door.CoOwners, DarkRP_Credits, DarkRP_simplerrError, player_darkrp, nw_NextSpawnTime, DarkRP_Chat, DarkRP_preferredjobmodels, DarkRP_preferredjobmodel, OnChangedTeam, nw_dRadio_enabled, nw_dRadio_channel, nw_dRadio_hasRadio, nw_dRadio_isTalking, nw_ToolStage, nw_ToolOp, LiteTool.ShadowRemover.PlayerInitialSpawn, LiteTool.ShadowRemover.ApplyShadow, LiteTool.ShadowRemover.ResetShadow, FPP_ShareSettings, StackGhost, UnstackGhost, KeypadCracker_Sparks, KeysMenu, nw_CanHack, realistic_hook BreakFree, OpenTablet, SWB_FIREMODE, start_army, anim_dropitem, DarkRP_keypadData, VapeTankColor, VapeMessage, nw_SafeClickers, AlcEffect, graffiti.FullUpdate, graffiti.DeltaUpdate, graffiti.Load, graffiti.PreLoadColors, graffiti.UpdateShare, graffiti.OpenMenu, nw_ExplodeTime, nw_EquippedBomb, sendMenu, acceptSetting, ItemStoreSyncItem, nw_KeypadWhitelist, keypad_pattern_com, keypad_pay, keypad_open, keypad_updatesettings, ShowLetter, KillLetter, openRadioMenu, money_clicker_withdraw, money_clicker_steal, money_clicker_click, money_clicker_syncinfo, money_clicker_upgrade, money_clicker_repair, money_clicker_eject, get_score_data, UpdateBatteries, ShowManual, WayCasino.OpenMenu, CasinoSystem.SendInfo, CasinoSystem.Menu, bdon:updateScreenEffect, AteFoodIcon, DarkRP_shipmentSpawn, Tool.TextPlacements.RequestData, Tool.TextPlacements.RespondData, base_auto, base_darkrp, base_entity, craft_electronics, craft_scrap, craft_tools, drug, drug_lab, eml_meth, fake_license, food, gunlab, hobo_trash, lucid_choc_chocolate, microwave, mn_barrel, money_printer, prop_physics, sent_weed_bag, spawned_ammo, spawned_food, spawned_money, spawned_shipment, spawned_weapon, durgz_meth, item_healthvial, durgz_fireammo, durgz_heroine, durgz_alcohol, durgz_aspirin, item_healthkit, durgz_water, entity_rachia, durgz_weed, durgz_cigarette, durgz_lsd, durgz_mushroom, ItemStoreSync, ItemStoreAdminInventory, ItemStoreAdminBank, ItemStoreMove, ItemStoreUse, ItemStoreUseWith, ItemStoreDrop, ItemStoreDestroy, ItemStoreMerge, ItemStoreSplit, ItemStoreOpen, ItemStoreSyncInventory, ItemStoreCraft, detect_cheat, disguise, DisguiseKitOpen, worldspawn, player_manager, vgui_screen, simple_bot, weapon_citizensuitcase, weapon_citizenpackage, weapon_alyxgun, item_battery, weapon_tripmine, weapon_snark, monster_snark, scene_manager, weapon_crowbar_hl1, weaponbox, ammo_buckshot, ammo_rpgclip, ammo_357, ammo_argrenades, ammo_mp5grenades, ammo_9mmbox, ammo_9mmar, ammo_mp5clip, ammo_9mmclip, ammo_glockclip, ammo_gaussclip, ammo_egonclip, ammo_crossbow, weapon_oldmanharpoon, entityflame, weapon_stunstick, weapon_smg1, grenade_ar2, weapon_slam, npc_tripmine, npc_satchel, weapon_shotgun, weapon_rpg, rpg_missile, weapon_pistol, weapon_physcannon, weapon_frag, npc_grenade_frag, weapon_crowbar, weapon_crossbow, crossbow_bolt, weapon_ar2, prop_combine_ball, env_entity_dissolver, weapon_357, weapon_shotgun_hl1, weapon_satchel, weapon_rpg_hl1, weapon_mp5_hl1, weapon_hornetgun, weapon_handgrenade, weapon_glock_hl1, weapon_gauss, weapon_egon, weapon_crossbow_hl1, crossbow_bolt_hl1, weapon_357_hl1, weapon_physgun, weapon_swep, sent_point, info_player_terrorist, prop_door_rotating, func_breakable_surf, func_door, func_wall, func_useableladder, prop_physics_multiplayer, env_sun, trigger_waterydeath, trigger_hurt, env_flare, _firesmoke, window_pane, item_suitcharger, item_healthcharger, prop_dynamic, sent_anim, itemstore_bank, box_ammo, box_armor, phoenix_storms/dome, score_timeplay, models/debug/debugwhite, score_money, bank_vault, unarrest_wood, score_clans, trash_dumpster, sent_ai, npc_waydealer, phoenix_storms/ps_grass, technician_heater, technician_powerpanel, technician_controlbox, bank_vent, nw_dOrgs.OrgMembers, nw_duelSystem.Current, nw_duelSystem.OnDuel, nw_hitSystem.Orders, nw_hitSystem.IsOrdered, nw_hitSystem.DoOrder, nw_hitSystem.MyOrders, nw_Energy, nw_HasGunlicense, nw_wantedReason, nw_Arrested, nw_hitTarget, ItemStoreTrade, ItemStoreCloseTrade, ItemStoreTradeMessage, ItemStoreReadyTrade, ItemStoreAcceptTrade, ItemStoreTradeMoney, ItemStoreTradePoints, ItemStoreTradeDonate, nw_CobwebSlowed, ServerName, predicted_viewmodel, ClimbSlide, keys, gmod_camera, gmod_tool, itemstore_pickup, weapon_fists, gmod_hands, weapon_vape_hp, laserjetpack, ptp_cs_357, weapon_vape_armor, UserGroup, cats_ratingsTotal, cats_averageRating, weapon_svechenik, dark_egon_beam, 0, reserved_spot, weapon_vape_wayzer, wrp_weapon_outbreak, csgo_daggers, wrp_weapon_crimson, cats_adminRating, models/props_lab/xencrystal_sheet, Count.props, weapon_bugbait, npc_grenade_bugbait, env_sporeexplosion, bit_usb, entity_blocker, mp_weapon_smart_pistol, wowozela, Count.hoverboards, modulus_hoverboard, Boost, Boosting, modulus_hoverboard_avatar, Board, Avatar, Effect1, EffectPos1, EffectNormal1, EffectScale1, Effect2, EffectPos2, EffectNormal2, EffectScale2, Player, modulus_hoverboard_hull, ScriptedVehicle, Driver, GrindSoundTime, Grinding, prop_vehicle_prisoner_pod, itemstore_item, lucid_choc_stove, lucid_choc_cocoa, lucid_choc_sugar, lucid_choc_milk, weapon_keypadchecker, models/items/boxsniperrounds, unarrest_stick, !darkrp/unarrest_stick, moneychecker, lockpick, pickpocket, csgo_bayonet, weapon_cuff_rope, sent_tablet, patterns/texture12, phoenix_storms/grey_chrome, phoenix_storms/wood_dome, csgo_falchion, models/wireframe, prop_ragdoll, Count.sents, durgz_cocaine, Models/effects/vol_light001, Count.pattern_keypads, keypad_pattern, models/XQM//LightLinesGB, models/props_combine/tprings_globe, radio, zhits_phone, stungu
LUA TOTAL: 1425
--]]
--Stealed clientside server code by exechack.cc
--Hostname: WayZer's Role Play | Быстрая загрузка - Part 1/5 - 06/04/2025


--addons/_wlib/lua/wlib/init.lua:
wlib = wlib or {}
wlib.debug = false

function wlib.msg(...)
	MsgC('[WRP] ' .. os.date('%H:%M:%S - ', os.time()), ..., '\n')
end

local color_red = Color(255,0,0)
function wlib.dbg(...)
	if not wlib.debug then return end
	MsgC(color_red, '[WRP] ', color_white, os.date('%H:%M:%S - ', os.time()), ..., '\n')
end

if SERVER then
    AddCSLuaFile('wlib/modules/include.lua')
    include('wlib/modules/include.lua')
else
    include('wlib/modules/include.lua')
end

wlib.include.shared('wlib/modules', {'cfg'})

wlib.include.shared('wlib/libraries')
wlib.include.server('wlib/libraries/_server')
wlib.include.client('wlib/libraries/_client')

wlib.include.modules('wlib/modules', {
	'!include',
	'!_server',
	'!_client',
	'!cfg',
	'oop',
	'settings',
	'*',
})
wlib.include.server('wlib/modules/_server')
wlib.include.client('wlib/modules/_client')

wlib.include.client('wlib/vgui')

hook.Run('wlib.loaded')

-- Важные аддоны для использования функуций без хука Think и прочих костылей
wlib.include.shared('autorun', {
	'wayscore_init',
})
--addons/_cfg/lua/config/sh_wlib.lua:
CFG.dev = false

-- Потом перенести
CFG.afkDemoteTime = 300
--addons/_cfg/lua/config/maps/rp_bangclaw.lua:
CFG.bank_carposes = {
    {
        Vector(3020, -2990, 94),
        Angle(0, 180, 0),
    },
    {
        Vector(4988, -1731, 96),
        Angle(0, 30, 0),
    },
}

CFG.bank_aabox = {
    Vector(3712, -3976, 48),
    Vector(4354, -3517, 319),
}

CFG.bank_ventpos = Vector(3640, -3574, 136)
--addons/_wlib/lua/wlib/modules/oop.lua:
function wlib.accessor(tbl, key, name, force)
    tbl['Get'..name] = function(self)
        return self[key]
    end
    tbl['Set'..name] = function(self, val)
        self[key] = val
        return self
    end
end
--addons/_wlib/lua/wlib/modules/notification/client.lua:
local surface = surface
local IsValid = IsValid
local LocalPlayer = LocalPlayer
local math = math
local table = table
local CurTime = CurTime
local string = string
local MsgC = MsgC
local Color = Color
local ipairs = ipairs
local hook = hook
local Material = Material
local ScrW = ScrW
local ScrH = ScrH
local draw = draw

local enabled_notify = CreateClientConVar("wrp_notifies_enabled", "1", true)
local align_notify = CreateClientConVar("wrp_notifies_align", "3", true)
local hudscale_cvar = CreateClientConVar('wayhud_scale', 0.75, true)
cvars.AddChangeCallback('wayhud_scale', function(cvar, old, new)
	surface.CreateFont('wlib_notify', {
		font = 'Roboto Bold',
		size = 19*(new/0.75),
		weight = 500,
		extended = true,
	})
end, 'hudnotify')

local cache = {}

ease = {}
function ease.quadOut( t, b, c, d )
	t = t / d;
	return -c * t * (t - 2) + b
end

surface.CreateFont('wlib_notify', {
	font = 'Roboto Bold',
	size = 19*(hudscale_cvar:GetFloat()/0.75),
	weight = 500,
	extended = true,
})

notification.Aligns = {
	-- снизу справа
	[0] = function(self, w, h, yoff, st)
		local mapoffset = (wmap.minimapEnabled and 455 or 120)*hudscale_cvar:GetFloat()
		local xoff = #g_VoicePanelList:GetChildren()*40 + mapoffset
		local hoffset = self.progress and 20 or 0
		return ScrW()-w-20, ScrH() - xoff - (yoff + h + hoffset) * st
	end,
    -- снизу по центру
	[1] = function(self, w, h, yoff, st)
		local hoffset = self.progress and 20 or 0
		return ScrW()/2-w/2, ScrH() - (yoff + h + hoffset) * st - 10
	end,
	-- справа сверху
	[2] = function(self, w, h, yoff, st)
		return ScrW()-w-20, (yoff + h) * st
	end,
}

function notification.AddLegacy( text, msgType, msgTime, align)
	if not IsValid(LocalPlayer()) then return end
	if not enabled_notify:GetBool() then return end

	LocalPlayer():EmitSound('ambient/water/rain_drip1.wav', 75, math.random(90,110), 0.5)

	text = wlib.string.wrap(text, 'wlib_notify', 400)

	surface.SetFont('wlib_notify')
	local textW, textH = surface.GetTextSize(text)
	
	table.insert(cache, 1, {
		startTime = CurTime(),
		removeTime = CurTime() + msgTime + 1.5,
		text = text,
		type = msgType,
		align = align or align_notify:GetInt(),
		a = 0,
		width = textW+24,
		height = textH+10,
	})

	MsgC(Color(200,150,50), 'УВЕДОМЛЕНИЕ', color_white, ': ' .. text .. '\n')
end

function notification.AddProgress(id, text, frac, type, align)
	if not IsValid(LocalPlayer()) then return end
	if not enabled_notify:GetBool() then return end

	for _, v in ipairs(cache) do
		if v.id and v.id == id then
			v.text = text
			v.frac = frac
			v.type = type
			return
		end
	end

	LocalPlayer():EmitSound('ambient/water/rain_drip1.wav', 75, math.random(90,110), 0.5)

	text = wlib.string.wrap(text, 'wlib_notify', 400)

	surface.SetFont('wlib_notify')
	local textW, textH = surface.GetTextSize(text)
	
	table.insert( cache, 1, {
		startTime = CurTime(),
		text = text,
		type = type,
		a = 0,
		id = id,
		frac = frac,
		progress = true,
		align = align or align_notify:GetInt(),
		width = textW+24,
		height = textH+10,
	})
end

function notification.Kill(id)
	for _, v in ipairs(cache) do
		if v.id and v.id == id then
			v.removeTime = CurTime()+0.5
		end
	end
end

hook.Add('Think', 'wlib_notify', function()
	for k=#cache, 1, -1 do
		local data = cache[k]
		if not data then return end

		local lifeTime = CurTime() - data.startTime
		local timeLeft = (data.removeTime or math.huge) - CurTime()

		data.a = (lifeTime < 1 and lifeTime) or (timeLeft < 0.5 and (timeLeft * 2)) or 1
		if timeLeft <= 0 then
			table.remove(cache, k)
		end
	end
end)

local color_progress_background = Color(35,40,45)
local color_background = Color(47,52,57)
local color_icon = Color(236,113,73)

local progress_back = Color(100,100,100)
local progress_line = Color(236,113,73)
hook.Add('PostRenderVGUI', 'wlib_notify', function()
	if enabled_notify:GetInt() == 0 then return end

	local drawOrder = {}
	local yoffs = {}
	for i = 1, #cache do
		local data = cache[i]

		data.align = notification.Aligns[data.align] and data.align or 0
		
		yoffs[data.align] = yoffs[data.align] or 0
		local yoff = yoffs[data.align]

		local st = ease.quadOut( data.a, 0, 1, 1 )
        
		local width, height = data.width, data.height
		local hoffset = data.progress and 20 or 0

		local align = notification.Aligns[data.align]
		local x, y = align(data, width, height, yoff, st)
		--local x, y = (ScrW() - width - 34) - 15, ScrH() - (yoff + h + hoffset) * st - 70
		yoffs[data.align] = yoff + (height + hoffset + 5) * st

		if data.progress then draw.RoundedBox(6, x, y - 5, width+16, height + hoffset, color_progress_background ) end
		draw.RoundedBox(6, x, y - 5, width+16, height, color_background )
		draw.RoundedBox(6, x, y - 5, 30, height, color_icon )

		draw.DrawText(data.text, 'wlib_notify', x + 34, y, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, st * 255 )
		if data.progress then
			local lineW = width+6
			if data.frac then
				local frac = data.frac
				draw.RoundedBox(0, x+5, y+height, lineW, 10, progress_back)
				draw.RoundedBox(0, x+5, y+height, frac*lineW, 10, progress_line)
			else
				--[[
				local frac = 1 - math.abs(math.sin(CurTime()))
				local width = (w+30)/3
				draw.RoundedBox(0, x-5, y+h+10, w+30, 10, progress_back)
				draw.RoundedBox(0, x-5+frac*(w+30-width), y+h+10, width, 10, progress_line)
				]]
				local frac = math.abs(math.sin(CurTime()))
				draw.RoundedBox(0, x+5, y+height, lineW, 10, progress_back)
				draw.RoundedBox(0, x+5, y+height, frac*lineW, 10, progress_line)
			end
		end

		surface.SetMaterial(notification.Icons[data.type] or notification.Icons[0])
		surface.SetDrawColor(color_white)
		surface.DrawTexturedRect(x+4, y+height/2-16, 22, 22)
	end
end)

net.Receive('wlib.notify', function()
    local type = net.ReadUInt(4)
    local len = net.ReadUInt(16)
    local text = net.ReadString()
    local align = net.ReadUInt(2)

    GAMEMODE:AddNotify(text, type, len, align)
end)
--addons/_wlib/lua/wlib/modules/requests/client.lua:
wlib.requests = wlib.requests or {}
wlib.requests.frames = wlib.requests.frames or {}

local frames = wlib.requests.frames

function wlib.requests.buildFrame(id, fields)
    if IsValid(frames[id]) then frames[id]:Remove() end

    frames[id] = vgui.Create('DFrame')
    local frame = frames[id]
    frame:SetWide(350)
    frame:SetTitle('')
    frame:SetSkin('WayZer')
    frame:MakePopup()
    frame:SetBackgroundBlur(true)
    --frame:ShowCloseButton(false)
    frame:SetDraggable(false)

    frame.OnClose = function(self)
        net.Start('wlib.request.fail')
        net.WriteString(id)
        net.SendToServer()
    end

    local panels = {}

    local scroll = vgui.Create('DScrollPanel', frame)
    scroll:Dock(TOP)
    for _, data in ipairs(fields) do
        local panel = data.field.vgui(data)
        panel:SetParent(scroll)
        panel:Dock(TOP)
        panel:DockMargin(4,6,4,0)

        table.insert(panels, panel)
    end

    local accept = vgui.Create('DButton', frame)
    accept:Dock(TOP)
    accept:DockMargin(0,12,0,0)
    accept:SetTall(25)
    accept:SetText('Готово')
    accept:SetIcon('icon16/accept.png')

    accept.DoClick = function()
        local sending = {}

        net.Start('wlib.request')
        net.WriteString(id)
        for k, data in ipairs(fields) do
            if not data.field.send then continue end

            local value = data.field.getValue(data, panels[k])

            if data.field.check then
                local res, err = data.field.check(data, value)
                if res == false then return notification.AddLegacy(err, 1, 5) end
            end

            data.field.send(value)

            table.insert(sending, value)
        end
        net.SendToServer()

        frame:Remove()
    end

    scroll:InvalidateChildren(true)
    scroll:InvalidateLayout(true)
    scroll:SizeToChildren(false, true)
    scroll:SetTall(math.min(scroll:GetTall(), ScrH()-100))

    frame:InvalidateLayout(true)
    frame:SizeToChildren(false, true)
    frame:Center()

    return frame
end

net.Receive('wlib.request', function()
    local id = net.ReadString()
    local fields = {}

    for i=1, net.ReadUInt(4) do
        local id = net.ReadString()
        local field = wlib.requests.fields[id]
        assert(field, 'Field ID "'..id..'" not found')

        local data = field.receive()
        data.type = id
        data.field = field

        table.insert(fields, data)
    end

    if hook.Run('wlib.requests.customFrame', id, fields) then return end

    wlib.requests.buildFrame(id, fields)
end)

net.Receive('wlib.request.fail', function()
    local id = net.ReadString()
    if IsValid(frames[id]) then frames[id]:Remove() end
end)

local function boolSend(id, value)
    net.Start('wlib.request')
    net.WriteString(id)
    net.WriteBool(value)
    net.SendToServer()
end
hook.Add('wlib.requests.customFrame', '_bool', function(id, fields)
    if #fields ~= 1 then return end
    local field = fields[1]
    if field.type ~= 'bool' then return end

    Derma_Query(field.name, '', 'Да', fp{boolSend, id, true}, 'Нет', fp{boolSend, id, false})
    return true
end)
--addons/_wlib/lua/wlib/modules/string.lua:
wlib.string = wlib.string or {}

local plural_type = function(i)
	return i % 10 == 1 and i % 100 ~= 11 and 1
		or (i % 10 >= 2 and i % 10 <= 4 and (i % 100 < 10 or i % 100 >= 20) and 2
			or 3
		)
end

function wlib.string.formatPlural(plurals, num)
	local type = plural_type(num)
	local suffix = plurals[type]
	return num .. ' ' .. suffix, suffix
end

function wlib.formatPlural(...)
	return wlib.string.formatPlural(...)
end

function wlib.string.isSteamID(str)
	if not isstring(str) then return false end
	return str:find('^STEAM_[0-5]:[01]:%d+$') ~= nil
end

function wlib.string.isSteamID64(str)
	if not isstring(str) then return false end
	return str:gmatch('^7656119%d%d%d%d%d%d%d%d%d%d$') ~= nil
end

-- DarkRP.textWrap
local function charWrap(text, pxWidth)
    local total = 0

    text = text:gsub('.', function(char)
        total = total + surface.GetTextSize(char)

        -- Wrap around when the max width is reached
        if total >= pxWidth then
            total = 0
            return '\n' .. char
        end

        return char
    end)

    return text, total
end

function wlib.string.wrap(text, font, pxWidth)
    local total = 0

    surface.SetFont(font)

    local spaceSize = surface.GetTextSize(' ')
    text = text:gsub('(%s?[%S]+)', function(word)
            local char = string.sub(word, 1, 1)
            if char == '\n' or char == '\t' then
                total = 0
            end

            local wordlen = surface.GetTextSize(word)
            total = total + wordlen

            -- Wrap around when the max width is reached
            if wordlen >= pxWidth then -- Split the word if the word is too big
                local splitWord, splitPoint = charWrap(word, pxWidth - (total - wordlen))
                total = splitPoint
                return splitWord
            elseif total < pxWidth then
                return word
            end

            -- Split before the word
            if char == ' ' then
                total = wordlen - spaceSize
                return '\n' .. string.sub(word, 2)
            end

            total = wordlen
            return '\n' .. word
        end)

    return text
end
--addons/_wlib/lua/wlib/modules/transaction.lua:
local TRANSACTION = {}
TRANSACTION.__index = TRANSACTION

local lastId = 0

function TRANSACTION:func(f)
    local id = #self.funcs + 1
    
    local function finish(error)
        if self.stopped then return end

        if error then
            if self.fallback then self.fallback() end
            self:stop()
            return
        end

        table.insert(self.finished, id)
        if #self.finished >= #self.funcs then
            if self.callback then self.callback() end
        end
    end

    table.insert(self.funcs, function()
        f(finish)
    end)
end

function TRANSACTION:commit(cb, fb)
    if #self.funcs == 0 then
        if cb then cb() end
        return
    end
    
    self.callback = cb
    self.fallback = fb
    for _, func in ipairs(self.funcs) do
        func()
    end
end

function TRANSACTION:stop()
    self.stopped = true
end

function wlib.transaction(timeout)
    lastId = lastId + 1
    local tr = setmetatable({
        funcs = {},
        finished = {},
        timeout = timeout,
        id = lastId,
    }, TRANSACTION)

    return tr
end
--addons/_wlib/lua/wlib/modules/_client/draw.lua:
local surface_SetDrawColor = surface.SetDrawColor
local math_floor = math.floor
local surface_DrawLine = surface.DrawLine

function draw.Grid(x, y, w, h, gw, gh, color)
    surface_SetDrawColor(color)
    
    local wcount, hcount = math_floor(w/gw), math_floor(h/gh)

    for i=0, wcount do
        surface_DrawLine(x+i*gw, y, x+i*gw, y+h)
    end
    for i=0, hcount do
        surface_DrawLine(x, y+i*gh, x+w, y+i*gh)
    end
end
--addons/_wlib/lua/wlib/vgui/circleavatar.lua:
local PANEL = {}

function PANEL:Init()
    self.avatar = vgui.Create('AvatarImage', self)
    self.avatar:SetPaintedManually(true)
    self.avatar:Dock(FILL)
end

local circle = wlib.Circles.New(CIRCLE_FILLED, 0, 0, 0)
function PANEL:Paint(w,h)
    render.ClearStencil()
    render.SetStencilEnable(true)

    render.SetStencilWriteMask(1)
    render.SetStencilTestMask(1)

    render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
    render.SetStencilPassOperation(STENCILOPERATION_ZERO)
    render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
    render.SetStencilReferenceValue(1)

    draw.NoTexture()
    surface.SetDrawColor(color_white)
    circle:SetRadius(h/2)
    circle:SetPos(w/2, h/2)
    circle()

    render.SetStencilFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
    render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
    render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
    render.SetStencilReferenceValue(1)

    self.avatar:PaintManual()

    render.SetStencilEnable(false)
    render.ClearStencil()
end

function PANEL:SetPlayer(...)
    self.avatar:SetPlayer(...)
end

function PANEL:SetSteamID(...)
    self.avatar:SetSteamID(...)
end

vgui.Register('wlib.circleAvatar', PANEL, 'DPanel')
--addons/module_scoreboard/lua/wayscore/vgui/frame.lua:
local opacity = CreateClientConVar('wayscore_opacity', 0.95, true)

local PANEL = {}

local circlered = Material('icon72/red_circle.png')
local yellowcircle = Material('icon72/yellow_circle.png')
local greencircle = Material('icon72/green_circle.png')
local dbackColor = Color(120, 35, 4)
local backColor = Color(186, 55, 14)

function PANEL:Init()
    self:SetSize(math.min(965, ScrW() - 100), math.max(ScrH() - 300, 400))
    self:Center()
    self.Headder = vgui.Create('DPanel', self)
    self.Headder:SetTall(30)
    self.Headder:Dock(TOP)
    self.BackButton = vgui.Create('DButton', self)
    self.BackButton:SetText('')
    self.BackButton:SetPos(10, 5)
    self.BackButton:SetSize(20,20)
    self.BackButton.FontColor = Color( 236, 240, 241)
    
    function self.BackButton:Paint(w, h)
        if wayscore.view == 'main' then return end 
        draw.RoundedBox(2, 0, 0, w, h, dbackColor)
        draw.RoundedBox(2, 0, 0, w, h-2, backColor)
        draw.SimpleText('X', 'wayscore.small', w / 2, h / 2, self.FontColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end

    function self.BackButton:DoClick()
        if wayscore.view == 'main' then return end
        wayscore:SelectView('main')
    end

    function self.Headder:Paint(w, h)
        draw.RoundedBox(6, 0, 0, w, h, Color(47, 52, 57))
        if wayscore.view ~= 'main' then return end 
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( circlered )
        surface.DrawTexturedRect( 16, 10, 12, 12 )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( yellowcircle )
        surface.DrawTexturedRect( 32, 10, 12, 12 )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( greencircle )
        surface.DrawTexturedRect( 48, 10, 12, 12 )
    --    draw.SimpleText(GetHostName(), 'wayscore.small', w/2, h/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText('Онлайн: '..player.GetCount()..'/'..game.MaxPlayers(), 'wayscore.small', w/2, h/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end

function PANEL:Paint(w, h)
    --draw.RoundedBox(0, 0, 10, w, 55, Color(47, 52, 57))
    draw.RoundedBox(6, 0, 0, w, h, Color( 47, 52, 57, math.Clamp(255*opacity:GetFloat(), 0, 255)))
end

vgui.Register('wayscore_frame', PANEL, 'Panel')
--addons/module_antiavoid/lua/autorun/antiavoid_init.lua:
antiAvoid = {}

if SERVER then
    AddCSLuaFile('antiavoid/cl_core.lua')
    AddCSLuaFile('antiavoid/sh_config.lua')

    include('antiavoid/sh_config.lua')
    include('antiavoid/sv_core.lua')

    for _, v in pairs (file.Find('antiavoid/detects/*', 'LUA') or {}) do
        include('antiavoid/detects/'..v)
    end
else
    include('antiavoid/sh_config.lua')
    include('antiavoid/cl_core.lua')
end
--addons/module_cats/lua/cats/client.lua:
surface.CreateFont("cats.small", {
    font = "Roboto Bold",
    extended = true,
    size = 16,
    weight = 500
})

surface.CreateFont("cats.xlarge", {
    font = "Roboto Bold",
    extended = true,
    size = 48,
    weight = 500
})

surface.CreateFont("cats.large", {
    font = "Roboto Bold",
    extended = true,
    size = 36,
    weight = 500
})

surface.CreateFont("cats.medium", {
    font = "Roboto Bold",
    extended = true,
    size = 24,
    weight = 500
})

local c

local function n(t, e, a)
    local e = c[e]

    if not e then
        e = {
            tooltip = 'error',
            icon = Material('icon16/error.png'),
            click = wlib.func.blank
        }
    end

    t:SetToolTip(e.tooltip)
    t.icon = e.icon

    t.DoClick = function(t)
        e.click(t, a)
    end
end

local function r(e)
    local n, a, t
    n = math.floor(e / 60 / 60)
    a = math.floor(e / 60) % 60
    t = math.floor(e) % 60

    return string.format("%02i:%02i:%02i", n, a, t)
end

function drawCircle(n, o, e, t)
    local a = {}

    table.insert(a, {
        x = n,
        y = o,
        u = .5,
        v = .5
    })

    for c = 0, t do
        local t = math.rad((c / t) * -360)

        table.insert(a, {
            x = n + math.sin(t) * e,
            y = o + math.cos(t) * e,
            u = math.sin(t) / 2 + .5,
            v = math.cos(t) / 2 + .5
        })
    end

    local t = math.rad(0)

    table.insert(a, {
        x = n + math.sin(t) * e,
        y = o + math.cos(t) * e,
        u = math.sin(t) / 2 + .5,
        v = math.cos(t) / 2 + .5
    })

    surface.DrawPoly(a)
end

local a = {
    action_claim = Material('icon16/accept.png'),
    action_unclaim = Material('icon16/delete.png'),
    actions = Material('icon16/wand.png'),
    action_callon = Material('icon16/lightbulb_off.png'),
    action_calloff = Material('icon16/lightbulb.png'),
    action_close = Material('icon16/report_delete.png'),
    noStar = Material('icon16/bullet_white.png'),
    star = Material('icon16/star.png')
}

c = {
    action_claim = {
        tooltip = cats.lang.action_claim,
        icon = a.action_claim,
        click = function(t, e)
            net.Start('cats.claimTicket')
            net.WriteString(e:SteamID())
            net.WriteBool(true)
            net.SendToServer()
            n(t, 'action_unclaim', e)
        end
    },
    action_unclaim = {
        tooltip = cats.lang.action_unclaim,
        icon = a.action_unclaim,
        click = function(t, e)
            net.Start('cats.claimTicket')
            net.WriteString(e:SteamID())
            net.WriteBool(false)
            net.SendToServer()
            n(t, 'action_claim', e)
        end
    },
    actions = {
        tooltip = cats.lang.actions,
        icon = a.actions,
        click = function(e, a)
            local e = DermaMenu()

            for n, t in ipairs(cats.config.commands) do
                e:AddOption(t.text, function()
                    t.click(a)
                end):SetIcon('icon16/' .. (t.icon or 'wand') .. '.png')
            end

            e:SetPos(input.GetCursorPos())
            e:Open()
        end
    },
    action_callon = {
        tooltip = cats.lang.action_callon,
        icon = a.action_callon,
        click = function(t, e)
            n(t, 'action_calloff', e)
        end
    },
    action_calloff = {
        tooltip = cats.lang.action_calloff,
        icon = a.action_calloff,
        click = function(e, t)
            n(e, 'action_callon', t)
        end
    },
    action_close = {
        tooltip = cats.lang.action_close,
        icon = a.action_close,
        click = function(t, e)
            net.Start('cats.closeTicket')
            net.WriteString(e:SteamID())
            net.SendToServer()
        end
    }
}

local l = {'action_claim', 'actions', 'action_close'}

local e = {
    user = LocalPlayer(),
    userID = 'STEAM_X:X:XXXXXXXX',
    admin = LocalPlayer(),
    adminID = 'STEAM_X:X:XXXXXXXX',
    chatLog = {{"Зюзя", "Админ тп, застрял", false}, {"СуперВася", "Ща, погоди", true}, {"Зюзя", "Ну где вы???", false}, {"УберПетя", "Бля, Вася, да вытащи ты его уже, наконец, он заебал вопить, как малое дите, сука, ебаный в рот", true}, {"СуперВася", "Ну ща-ща, я дорешаю жалобу", true}, {"УберПетя", "Да с хера ли ты берешь столько жалоб? Разберись сначала с одной, потом уж на другие иди", true}, {"СуперВася", "Да хорошо, блять, но дай сейчас-то разберусь", true}, {"Зюзя", "Идите оба нахуй, я выбрался уже", false}}
}

local bell = Material('icon16/bell.png')

local t

local function i(c)
    surface.PlaySound(cats.config.newTicketSound)
    local e = cats.ticketContainer:Add("DButton")
    e:SetSize(cats.config.spawnSize[1], 180)
    e:SetText('')
    e.expanded = true
    e.notify = false
    e.ticket = c

    e.Paint = function(n, t, a)
        local c, o = n.ticket.user, n.ticket.admin
        surface.SetDrawColor(30, 40, 50, 220)
        surface.DrawRect(0, 0, t, a)

        if n.Hovered then
            surface.SetDrawColor(255, 255, 255, 2)
            surface.DrawRect(0, 0, t, a)
        end

        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawLine(0, -1, 0, a)
        surface.DrawLine(-1, a - 1, t, a - 1)
        surface.DrawLine(t - 1, a, t - 1, -1)

        local offset = 0
        if not n.expanded and n.notify then
            offset = 16
            surface.SetDrawColor(255,255,255,255)
            surface.SetMaterial(bell)
            surface.DrawTexturedRect(4, 8, 16, 16)
        end

        local a = '(' .. os.date("%M:%S", CurTime() - n.ticket.created) .. ')'
        local n = IsValid(c) and c:Name() or cats.lang.userDisconnected
        local c = '★' .. math.Round(IsValid(c) and c:GetNWFloat("cats_averageRating") or 0, 1)
        draw.SimpleText(a .. ' ' .. c .. ' ' .. n, 'cats.small', offset + 8, 15, Color(220, 220, 220), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

        if IsValid(o) then
            local e = '★' .. math.Round(o:GetNWFloat("cats_adminRating"), 1)
            draw.SimpleText(e .. ' ' .. o:Name(), 'cats.small', t - 8, 15, Color(180, 200, 240), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
        end
    end

    e.DoClick = function(t)
        t.expanded = not t.expanded
        t.notify = false

        for t, e in ipairs(cats.ticketContainer:GetChildren()) do
            e:InvalidateLayout(true)
        end

        cats.ticketContainer:Layout()

        timer.Simple(0, function()
            t.chatLog:GotoTextEnd()
        end)
    end

    e.PerformLayout = function(e)
        e:SetSize(e:GetParent():GetWide(), e.expanded and 180 or 30)
        e.controls:SetVisible(e.expanded)
    end

    local t = vgui.Create("DPanel", e)
    t:DockMargin(1, 1, 1, 1)
    t:Dock(BOTTOM)
    t:SetTall(150)
    t.Paint = wlib.func.blank
    e.controls = t
    e.controls.buttons = {}

    for o, a in pairs(l) do
        local t = vgui.Create("DButton", t)
        t:SetSize(30, 30)
        t:SetPos(0, (o - 1) * 30)
        t:SetText('')

        t.Paint = function(e, a, t)
            if e.Hovered then
                draw.RoundedBox(0, 0, 0, a, t, Color(255, 255, 255, 2))
            end

            surface.SetMaterial(e.icon)
            surface.SetDrawColor(255, 255, 255)
            surface.DrawTexturedRect(7, 7, 16, 16)
        end

        n(t, a, e.ticket.user)
        e.controls.buttons[a] = t
    end

    local a = vgui.Create("DPanel", e.controls)
    a:Dock(FILL)
    a:DockMargin(30, 0, 0, 0)

    a.Paint = function(n, a, t)
        surface.SetDrawColor(0, 0, 0, 100)
        surface.DrawRect(0, 0, a, t - 20)
        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawLine(0, t, 0, 0)
        surface.DrawLine(-1, 0, a, 0)
        surface.DrawLine(-1, t - 21, a, t - 21)
    end

    e.chat = a
    local t = vgui.Create("DButton", e.chat)
    t:Dock(BOTTOM)
    t:SetText('')
    t:SetTall(20)
    t:SetCursor('beam')

    t.Paint = function(e, n, a)
        if e.Hovered then
            draw.RoundedBox(0, 0, 0, n, a, Color(255, 255, 255, 1))
        end

        draw.SimpleText(cats.lang.sendMessage, 'cats.small', 8, 10, Color(220, 220, 220, 50), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    t.DoClick = function(e)
        Derma_StringRequest(cats.lang.sendMessage, cats.lang.typeYourMessage, '', function(e)
            if not IsValid(t) then return end
            net.Start("cats.dispatchMessage")
            net.WriteString(c.userID)
            net.WriteString(e)
            net.SendToServer()
        end, wlib.func.blank, cats.lang.ok, cats.lang.cancel)
    end

    local a = vgui.Create("RichText", e.chat)
    a:Dock(FILL)

    a.Paint = function(t)
        t.m_FontName = "cats.small"
        t:SetFontInternal("cats.small")
        t:SetBGColor(Color(0, 0, 0, 0))
        t.Paint = nil
    end

    e.chatLog = a
    cats.ticketContainer[c.userID] = e
    cats.ticketFrame:PerformLayout()
end

local function c(id, a, n, t)
    local e = cats.ticketContainer[id].chatLog
    if not IsValid(e) then return end

    local ticket = cats.ticketContainer[id]
    if not ticket.expanded then ticket.notify = true end

    if t then
        e:InsertColorChange(50, 120, 180, 255)
    else
        e:InsertColorChange(180, 160, 50, 255)
    end

    e:AppendText("\n" .. a)
    e:InsertColorChange(220, 220, 220, 255)
    e:AppendText(": " .. n)
end

local show = Material('icon16/bullet_arrow_up.png')
local hide = Material('icon16/bullet_arrow_down.png')

hook.Add("Think", "cats", function()
    if IsValid(cats.ticketFrame) then
        cats.ticketFrame:Remove()
    end

    local t, a = cats.config.spawnSize[1], cats.config.spawnSize[2]
    local n, o = cats.config.spawnPosAdmin[1], cats.config.spawnPosAdmin[2]
    local e = vgui.Create("DFrame")
    e:SetSize(t, a)
    e:SetPos(n, o)
    e:DockPadding(0, 24, 0, 0)
    e:SetTitle('')
    e:ShowCloseButton(false)

    e.expanded = false

    local toggle = vgui.Create('DButton', e)
    toggle:SetSize(20,20)
    toggle:SetPos(t-26, 2)
    toggle:SetText('')
    toggle.Paint = function(s, w, h)
        surface.SetDrawColor(255,255,255,255)
        surface.SetMaterial(e.expanded and hide or show)
        surface.DrawTexturedRect(0,0,w,h)
    end
    toggle.DoClick = function()
        e.expanded = not e.expanded
        cats.ticketContainer:SetVisible(e.expanded)
    end

    cats.ticketFrame = e
    local t = vgui.Create("DScrollPanel", e)
    t:Dock(FILL)
    local a = t.PerformLayout

    t.PerformLayout = function(e)
        a(e)

        for t, e in ipairs(cats.ticketContainer:GetChildren()) do
            e:InvalidateLayout()
        end
    end

    local t = vgui.Create("DIconLayout", t)
    t:Dock(FILL)
    t:SetSpaceX(0)
    t:SetSpaceY(0)
    t:SetVisible(e.expanded)
    cats.ticketContainer = t
    
    local n = e.PerformLayout

    e.PerformLayout = function(a)
        n(a)
        a:SetTall(math.min(t:GetTall(), ScrH() - 100, 600) + 27)
        a:SetVisible(#t:GetChildren() > 0)
    end

    e.Paint = function(a, e, a)
        surface.SetDrawColor(30, 40, 50, 255)
        surface.DrawRect(0, 0, e, 24)
        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawOutlinedRect(0, 0, e, 24)
        draw.SimpleText(cats.lang.openTickets .. ' (' .. #t:GetChildren() .. ')', 'cats.small', 8, 12, Color(220, 220, 220), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end
    
    local oldthink = e.Think or wlib.func.blank
    e.Think = function(s)
        if hook.Run('HUDShouldDraw', 'cats.ticketFrame') == false then
            s:SetSize(0, 0)
        else
            oldthink(s)
            s:SetSize(cats.config.spawnSize[1], cats.config.spawnSize[2])
        end
    end

    hook.Remove("Think", "cats")
end)

if IsValid(cats.myTicketFrame) then
    cats.myTicketFrame:Remove()
end

local function d(e)
    surface.PlaySound(cats.config.newTicketSound)
    t = e
    local c, e = cats.config.spawnSize[1], cats.config.spawnSize[2]
    local o, n = cats.config.spawnPosUser[1], cats.config.spawnPosUser[2]
    local e = vgui.Create("DFrame")
    e:ShowCloseButton(false)
    e:SetSize(c, 220)
    e:SetPos(o, n)
    e:DockPadding(0, 30, 0, 0)
    e:SetTitle('')
    e.ticket = t

    e.Paint = function(e, a, n)
        local o, t = e.ticket.user, e.ticket.admin
        surface.SetDrawColor(30, 40, 50, 220)
        surface.DrawRect(0, 0, a, n)
        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawOutlinedRect(0, 0, a, n)
        local e = '(' .. os.date("%M:%S", CurTime() - e.ticket.created) .. ')'
        draw.SimpleText(e .. ' ' .. cats.lang.myTicket, 'cats.small', 8, 15, Color(220, 220, 220), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

        if IsValid(t) then
            local e = '★' .. math.Round(t:GetNWFloat("cats_adminRating"), 1)
            draw.SimpleText(e .. ' ' .. t:Name(), 'cats.small', a - 8, 15, Color(180, 200, 240), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
        end
    end

    surface.SetFont('cats.small')
    local o, n = surface.GetTextSize(cats.lang.action_close)
    local n = vgui.Create("DButton", e)
    n:SetText('')
    n:SetSize(o + 16, 30)
    n:AlignRight(1)

    n.Paint = function(a, e, t)
        if a.Hovered then
            draw.RoundedBox(0, 0, 0, e, t, Color(255, 255, 255, 1))
        end

        draw.SimpleText(cats.lang.action_close, 'cats.small', e / 2, t / 2, Color(220, 220, 220), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    n.DoClick = function()
        if t.test then return e:Remove() end

        net.Start('cats.closeTicket')
        net.WriteString(LocalPlayer():SteamID())
        net.SendToServer()
    end

    e.closeBut = n
    local n = vgui.Create("DPanel", e)
    n:Dock(FILL)

    n.Paint = function(n, a, t)
        surface.SetDrawColor(0, 0, 0, 100)
        surface.DrawRect(0, 0, a, t - 20)
        surface.SetDrawColor(0, 0, 0, 255)
        surface.DrawLine(0, t, 0, 0)
        surface.DrawLine(-1, 0, a, 0)
        surface.DrawLine(-1, t - 21, a, t - 21)
    end

    e.chat = n
    local o = vgui.Create("DButton", e.chat)
    o:Dock(BOTTOM)
    o:SetText('')
    o:SetTall(20)
    o:SetCursor('beam')

    o.Paint = function(t, a, e)
        if t.Hovered then
            draw.RoundedBox(0, 0, 0, a, e, Color(255, 255, 255, 1))
        end

        draw.SimpleText(cats.lang.sendMessage, 'cats.small', 8, 10, Color(220, 220, 220, 50), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    o.DoClick = function(e)
        Derma_StringRequest(cats.lang.sendMessage, cats.lang.typeYourMessage, '', function(e)
            net.Start("cats.dispatchMessage")
            net.WriteString(LocalPlayer():SteamID())
            net.WriteString(e)
            net.SendToServer()
        end, wlib.func.blank, cats.lang.ok, cats.lang.cancel)
    end

    local o = vgui.Create("RichText", e.chat)
    o:Dock(FILL)

    o.Paint = function(t)
        t.m_FontName = "cats.small"
        t:SetFontInternal("cats.small")
        t:SetBGColor(Color(0, 0, 0, 0))
        t.Paint = nil
    end

    e.chatLog = o

    e.SwitchToRating = function(e)
        n:Clear()
        n.Paint = wlib.func.blank
        local e = vgui.Create('DButton', n)
        e:DockPadding(1, 0, 1, 1)
        e:SetTall(30)
        e:Dock(BOTTOM)
        e:SetText('')
        e:SetEnabled(false)

        e.Paint = function(t, n, a)
            if t:IsEnabled() then
                if t.Hovered then
                    draw.RoundedBox(0, 0, 0, n, a, Color(255, 255, 255, 2))
                end

                draw.SimpleText(cats.lang.ok, "cats.small", n / 2, a / 2, Color(220, 220, 220), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end

            surface.SetDrawColor(0, 0, 0, 255)
        end

        e.DoClick = function(e)
            net.Start('cats.setRating')
            net.WriteUInt(math.Clamp(t.rating or cats.config.defaultRating, 1, 5), 8)
            net.SendToServer()
            cats.myTicketFrame:Remove()
            t = nil
        end

        local n = vgui.Create('DPanel', n)
        n:Dock(FILL)

        n.Paint = function(a, e, t)
            draw.SimpleText(cats.lang.rateAdmin, "cats.small", e / 2, t / 2 - 24, Color(220, 220, 220), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.RoundedBox(0, 0, 0, e, t, Color(0, 0, 0, 100))
            surface.DrawLine(-1, 0, e, 0)
            surface.DrawLine(-1, t, e, t)
        end

        for o = 1, 5 do
            local l = o - 3
            local n = vgui.Create('DButton', n)
            n:SetText('')
            n:SetSize(64, 64)
            n:SetPos(c / 2 + l * 64 - 32, 160 / 2 - 18)

            n.Paint = function(e, c, c)
                if e.Hovered then
                    draw.RoundedBox(0, 8, 8, 48, 48, Color(255, 255, 255, 2))
                end

                if not t.rating then
                    surface.SetDrawColor(255, 255, 255, 20)
                    surface.SetMaterial(a.star)
                    surface.DrawTexturedRect(16, 16, 32, 32)
                elseif t.rating and o <= t.rating then
                    surface.SetDrawColor(255, 255, 255)
                    surface.SetMaterial(a.star)
                    surface.DrawTexturedRect(16, 16, 32, 32)
                else
                    surface.SetDrawColor(255, 255, 255)
                    surface.SetMaterial(a.noStar)
                    surface.DrawTexturedRect(24, 24, 16, 16)
                end
            end

            n.DoClick = function(a)
                e:SetEnabled(true)
                t.rating = o
            end
        end
    end

    cats.myTicketFrame = e
end

local function l(a, t, n)
    local e = cats.myTicketFrame.chatLog
    if not IsValid(e) then return end

    if n then
        e:InsertColorChange(50, 120, 180, 255)
    else
        e:InsertColorChange(180, 160, 50, 255)
    end

    e:AppendText("\n" .. a)
    e:InsertColorChange(220, 220, 220, 255)
    e:AppendText(": " .. t)
end

net.Receive('cats.dispatchMessage', function(e)
    local e = net.ReadString()
    local a = net.ReadEntity()
    local o = net.ReadString()
    local n = cats.config.getPlayerName(a)
    if not IsValid(a) then return end

    if e == LocalPlayer():SteamID() then
        if t then
            l(n, o, a:SteamID() ~= LocalPlayer():SteamID())
        else
            d({
                created = CurTime()
            })

            l(n, o, a:SteamID() ~= LocalPlayer():SteamID())
        end
    elseif IsValid(cats.ticketContainer[e]) then
        c(e, n, o, a:SteamID() ~= e)
    else
        local t = player.GetBySteamID(e)
        if not IsValid(t) then return end

        i({
            user = t,
            userID = e,
            created = CurTime()
        })

        c(e, n, o, a:SteamID() ~= e)
    end
end)

net.Receive('cats.claimTicket', function(e)
    local o = net.ReadString()
    local a = net.ReadEntity()
    local e = net.ReadBool()
    if e and not IsValid(a) then return end

    if o == LocalPlayer():SteamID() and t then
        t.admin = e and a or nil
        t.adminID = e and a:SteamID() or nil
        cats.myTicketFrame.closeBut:SetVisible(not e)
    elseif IsValid(cats.ticketContainer[o]) then
        local t = cats.ticketContainer[o].ticket
        t.admin = e and a or nil
        t.adminID = e and a:SteamID() or nil

        if t.adminID ~= LocalPlayer():SteamID() then
            local a = cats.ticketContainer[o].controls.buttons['action_claim']

            if e then
                n(a, 'action_unclaim', t.user)
                a:SetEnabled(false)
            else
                n(a, 'action_claim', t.user)
                a:SetEnabled(true)
            end
        end
    end
end)

net.Receive('cats.closeTicket', function(e)
    local e = net.ReadString()

    if e == LocalPlayer():SteamID() and t then
        if IsValid(t.admin) then
            cats.myTicketFrame:SwitchToRating()
        else
            cats.myTicketFrame:Remove()
            t = nil
        end
    elseif IsValid(cats.ticketContainer[e]) then
        cats.ticketContainer[e].ticket = nil
        cats.ticketContainer[e]:Remove()
        cats.ticketFrame:PerformLayout()
    end
end)

net.Receive('cats.setRating', function(e)
    local e = net.ReadString()
    local t = net.ReadUInt(8)

    if e == LocalPlayer():SteamID() then
        cats.myTicketFrame:Remove()
    end
end)

concommand.Add('cats_sync_tickets', function()
    net.Start('cats.syncTickets')
    net.SendToServer()
end)

net.Receive('cats.syncTickets', function(e)
    local e = net.ReadTable()

    cats.ticketContainer:Clear()

    for t, e in pairs(e) do
        local a = player.GetBySteamID(t)

        if IsValid(a) then
            i({
                user = a,
                userID = t,
                created = e.createdGameTime,
                admin = e.admin,
                adminID = e.adminID
            })

            if IsValid(e.admin) then
                local t = cats.ticketContainer[t].controls.buttons['action_claim']
                n(t, 'action_unclaim', e.user)
                t:SetEnabled(false)
            end

            for a, e in pairs(e.chatLog) do
                c(t, e[1], e[2], e[3])
            end
        end
    end
end)

concommand.Add("cats_test_admin", function()
    local e = LocalPlayer():SteamID()

    i({
        user = LocalPlayer(),
        userID = e,
        created = CurTime(),
        admin = LocalPlayer(),
        adminID = e
    })

    --cats.ticketContainer[e]:DoClick()

    c(e, "chelog", "Admin let me test my ticket!", false)
    c(e, "Admin", "Alright.", true)
end)

concommand.Add("cats_test_admin_clear", function()
    cats.ticketContainer:Clear()
end)

concommand.Add("cats_test_myticket", function()
    d({
        created = CurTime(),
        test = true,
    })

    l("chelog", "Admin let me test my ticket!", false)
    l("Admin", "Alright.", true)
end)

local function a()
    surface.PlaySound(cats.config.newTicketSound)

    local e = vgui.Create('DFrame')
    e:SetSize(1024, 768)
    e:SetTitle('CATS - Analytics')
    e:Center()
    e:MakePopup()
    e.cache = {}
    cats.analyticsFrame = e

    local search = vgui.Create('DTextEntry', e)
    search:SetPos(5, 25)
    search:SetSize(160, 20)
    search:SetText('')
    search:SetUpdateOnType(true)
    e.search = search

    local t = vgui.Create('DListView', e)
    t:DockMargin(0, 15, 0, 0)
    t:Dock(LEFT)
    t:SetWide(160)
    t:SetMultiSelect(false)
    t:AddColumn('Rating'):SetFixedWidth(50)
    t:AddColumn('Admin')

    t.OnRowSelected = function(t, t, a)
        e.pnl:Clear()
        local t = vgui.Create('DLabel', e.pnl)
        t:SetText('Loading...')
        t:SizeToContents()
        t:Center()
        net.Start('cats.getAdminData')
        net.WriteString(a.steamID)
        net.SendToServer()
    end
    e.list = t

    function t:RebuildList(query)
        self:Clear()
        for a, e in pairs(e.cache) do
            if not query == '' or e.lastNick:find(query) then
                local t = '★' .. math.Round(e.ratingTotal or 0, 2)
                local e = self:AddLine(t, e.lastNick)
                e.steamID = a
            end
        end
        self:SortByColumn(1, true)
    end
    t:RebuildList('')

    function search:OnValueChange(val)
        t:RebuildList(val)
    end

    local t = vgui.Create('DScrollPanel', e)
    t:DockMargin(5, 0, 0, 0)
    t:Dock(FILL)
    e.pnl = t
    net.Start('cats.getAdminList')
    net.SendToServer()
end

concommand.Add('cats_analytics', a)


net.Receive('cats.getAdminList', function()
	local e = net.ReadTable()
    if not istable(e) then return end
    if not IsValid(cats.analyticsFrame) then return end -- [cats] addons/cats/lua/cats/client.lua:791: Tried to use a NULL Panel!
    cats.analyticsFrame.cache = e
    cats.analyticsFrame.search:SetValue('')
end)

net.Receive('cats.getAdminData', function()
    local e = net.ReadTable()
    if not IsValid(cats.analyticsFrame) or not IsValid(cats.analyticsFrame.pnl) then return end
    local a = cats.analyticsFrame.pnl
    a:Clear()
    local t = vgui.Create('DLabel', a)
    t:DockMargin(20, 10, 20, 0)
    t:Dock(TOP)
    t:SetTall(50)
    t:SetFont('cats.xlarge')
    t:SetText(e.lastNick)
    local t = vgui.Create('DLabel', a)
    t:DockMargin(20, 5, 20, 0)
    t:Dock(TOP)
    t:SetTall(20)
    t:SetFont('cats.medium')
    t:SetText(e.steamID)
    t:SetToolTip('Click to copy SteamID')

    t.DoClick = function(t)
        SetClipboardText(e.steamID)
    end

    local n = {{'РЕЙТИНГ', '★' .. math.Round(e.ratingTotal or 0, 2)}, {'ЖАЛОБЫ', e.claimsTotal}, {'ПОЛЬЗОВАТЕЛИ', e.uniqueUsers}, {'В НЕДЕЛЮ', math.Round((e.claimsTotal or 0) / (e.updateTime - e.createdTime) * 604800)}, {'ВРЕМЯ ЖАЛОБ', r(e.ticketTimeTotal)}}

    if e.playTimeTotal then
        table.insert(n, {'ВРЕМЯ ИГРЫ', r(e.playTimeTotal)})
    end

    local t = vgui.Create('DIconLayout', a)
    t:DockMargin(20, 20, 20, 0)
    t:Dock(TOP)
    t:SetTall(100)

    for e, n in ipairs(n) do
        local e = t:Add('DPanel')
        e:SetSize((a.pnlCanvas:GetWide() - 40) / 3, 100)

        e.Paint = function(o, t, a)
            draw.RoundedBox(8, 5, 5, t - 10, a - 10, Color(0, 0, 0, 60))
            draw.SimpleText(n[1], "cats.medium", t / 2, 30, Color(220, 220, 220), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw.SimpleText(n[2], "cats.xlarge", t / 2, 65, Color(220, 220, 220), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        e.PerformLayout = function(e)
            e:SetWide((a.pnlCanvas:GetWide() - 40) / 3)
        end
    end

    local t = vgui.Create('DLabel', a)
    t:DockMargin(20, 20, 20, 5)
    t:Dock(TOP)
    t:SetTall(20)
    t:SetFont('cats.medium')
    t:SetText('Play time card')
    local d, c, r = cats.lang.dow, cats.config.punchCardMode, cats.config.punchCardStart - 1
    local l = 1

    for t = 1, 7 do
        for a = 1, 24 do
            l = math.max(l, e.timeCard[t][a])
        end
    end

    local n = vgui.Create('DPanel', a)
    n:DockMargin(20, 10, 20, 0)
    n:Dock(TOP)
    n:SetTall(400)

    n.Paint = function(t, e, a)
        draw.RoundedBox(8, 0, 0, e, a, Color(0, 0, 0, 60))
        e, a = e - 55, a - 35
        local n, e = a / 7, e / 24
        draw.NoTexture()

        for e = 1, 7 do
            draw.SimpleText(d[e], "cats.medium", 25, 30 + n * (e) - n / 2, Color(220, 220, 220, 35), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        surface.SetDrawColor(220, 220, 220, 4)

        for o = 1, 24 do
            local t = o - r
            t = t > 0 and t or t + 24
            draw.SimpleText(o ~= 24 and o or 0, "cats.small", 50 + e * (t - 1) + e / 2, 20, Color(220, 220, 220, 35), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            surface.SetDrawColor(220, 220, 220, 4)

            if c == 'dots' then
                surface.DrawLine(50 + e * (t - 1) + e / 2, 30 + n / 2, 50 + e * (t - 1) + e / 2, 30 + a - n / 2)
            elseif c == 'line' then
                surface.DrawLine(50 + e * (t - 1) + e / 2, 30, 50 + e * (t - 1) + e / 2, 30 + a)
            end
        end
    end

    local t = vgui.Create('DPanel', n)
    t:DockMargin(50, 30, 5, 5)
    t:Dock(FILL)

    t.Paint = function(n, a, t)
        local o, a = t / 7, a / 24
        draw.NoTexture()

        for n = 1, 7 do
            for i = 1, 24 do
                local t = i - r
                t = t > 0 and t or t + 24

                if c == 'dots' then
                    local e = math.max(math.floor((a - 4) * e.timeCard[n][i] / l), 2)
                    local a, t = math.floor(a * (t - 1) + a / 2), math.floor(o * (n) - o / 2)
                    surface.SetDrawColor(220, 220, 220)
                    drawCircle(a, t, e / 2, math.max(e, 6))
                elseif c == 'line' then
                    if t < 24 then
                        local i, c = a * (t - 1) + a / 2, o * (n) - (o - 16) * e.timeCard[n][i] / l - 8
                        local e, t = a * (t) + a / 2, o * (n) - (o - 16) * e.timeCard[n][t + 1] / l - 8
                        surface.SetDrawColor(220, 220, 220)
                        surface.DrawLine(math.floor(i), math.floor(c), math.floor(e), math.floor(t))
                    end
                else
                    local e = math.floor(math.floor((o - 8) * e.timeCard[n][i] / l))
                    draw.RoundedBoxEx(math.floor(math.min(e, 4)), a * (t - 1) + 3, math.floor(o * (n) - e), a - 6, e, Color(220, 220, 220), true, true, false, false)
                end
            end
        end
    end

    local t = vgui.Create('DLabel', a)
    t:DockMargin(20, 20, 20, 5)
    t:Dock(TOP)
    t:SetTall(20)
    t:SetFont('cats.medium')
    t:SetText('Ticket claim card')
    local l = 1

    for a = 1, 7 do
        for t = 1, 24 do
            l = math.max(l, e.claimCard[a][t])
        end
    end

    local n = vgui.Create('DPanel', a)
    n:DockMargin(20, 10, 20, 0)
    n:Dock(TOP)
    n:SetTall(400)

    n.Paint = function(t, e, a)
        draw.RoundedBox(8, 0, 0, e, a, Color(0, 0, 0, 60))
        e, a = e - 55, a - 35
        local n, e = a / 7, e / 24
        draw.NoTexture()

        for e = 1, 7 do
            draw.SimpleText(d[e], "cats.medium", 25, 30 + n * (e) - n / 2, Color(220, 220, 220, 35), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end

        surface.SetDrawColor(220, 220, 220, 4)

        for o = 1, 24 do
            local t = o - r
            t = t > 0 and t or t + 24
            draw.SimpleText(o ~= 24 and o or 0, "cats.small", 50 + e * (t - 1) + e / 2, 20, Color(220, 220, 220, 35), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            surface.SetDrawColor(220, 220, 220, 4)

            if c == 'dots' then
                surface.DrawLine(50 + e * (t - 1) + e / 2, 30 + n / 2, 50 + e * (t - 1) + e / 2, 30 + a - n / 2)
            elseif c == 'line' then
                surface.DrawLine(50 + e * (t - 1) + e / 2, 30, 50 + e * (t - 1) + e / 2, 30 + a)
            end
        end
    end

    local t, i, r = cats.lang.dow, cats.config.punchCardMode, cats.config.punchCardStart - 1
    local t = vgui.Create('DPanel', n)
    t:DockMargin(50, 30, 5, 5)
    t:Dock(FILL)

    t.Paint = function(n, a, t)
        local o, a = t / 7, a / 24
        draw.NoTexture()

        for n = 1, 7 do
            for c = 1, 24 do
                local t = c - r
                t = t > 0 and t or t + 24

                if i == 'dots' then
                    local e = math.max(math.floor((a - 4) * e.claimCard[n][c] / l), 2)
                    local t, a = math.floor(a * (t - 1) + a / 2), math.floor(o * (n) - o / 2)
                    surface.SetDrawColor(220, 220, 220)
                    drawCircle(t, a, e / 2, math.max(e, 6))
                elseif i == 'line' then
                    if t < 24 then
                        local i, c = a * (t - 1) + a / 2, o * (n) - (o - 16) * e.claimCard[n][c] / l - 8
                        local t, e = a * (t) + a / 2, o * (n) - (o - 16) * e.claimCard[n][t + 1] / l - 8
                        surface.SetDrawColor(220, 220, 220)
                        surface.DrawLine(math.floor(i), math.floor(c), math.floor(t), math.floor(e))
                    end
                else
                    local e = math.floor(math.floor((o - 8) * e.claimCard[n][c] / l))
                    draw.RoundedBoxEx(math.floor(math.min(e, 4)), a * (t - 1) + 3, math.floor(o * (n) - e), a - 6, e, Color(220, 220, 220), true, true, false, false)
                end
            end
        end
    end
end)
--addons/weapon_climb/lua/autorun/cl_roll.lua:
--yep
--addons/weapon_knifecsgo/lua/autorun/csgo_knife_snd_init.lua:
sound.Add( {
	name = "csgo_knife.Deploy",
	channel = CHAN_WEAPON,
	volume = 0.4,
	level = 65,
	sound = "csgo_knife/knife_deploy1.wav"
} )

sound.Add( {
	name = "csgo_knife.Hit",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 65,
	sound = { "csgo_knife/knife_hit1.wav", "csgo_knife/knife_hit2.wav", "csgo_knife/knife_hit3.wav", "csgo_knife/knife_hit4.wav" }
} )

sound.Add( {
	name = "csgo_knife.HitWall",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 65,
	sound = { "csgo_knife/knife_hit_01.wav", "csgo_knife/knife_hit_02.wav", "csgo_knife/knife_hit_03.wav", "csgo_knife/knife_hit_04.wav", "csgo_knife/knife_hit_05.wav" }
} )

sound.Add( {
	name = "csgo_knife.HitWall_old",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 65,
	sound = { "csgo_knife/knife_hitwall1.wav", "csgo_knife/knife_hitwall2.wav", "csgo_knife/knife_hitwall3.wav", "csgo_knife/knife_hitwall4.wav" }
} )

sound.Add( {
	name = "csgo_knife.Slash",
	channel = CHAN_WEAPON,
	volume = {0.5, 1.0},
	pitch = {97, 105},
	level = 65,
	sound = { "csgo_knife/knife_slash1.wav", "csgo_knife/knife_slash2.wav" }
} )

sound.Add( {
	name = "csgo_knife.Slash_old",
	channel = CHAN_WEAPON,
	volume = {0.5, 1.0},
	pitch = {97, 105},
	level = 65,
	sound = { "csgo_knife/knife_slash1_old.wav", "csgo_knife/knife_slash2_old.wav" }
} )

sound.Add( {
	name = "csgo_knife.Stab",
	channel = CHAN_WEAPON,
	volume = 1.0,
	level = 65,
	sound = "csgo_knife/knife_stab.wav"
} )

-- Butterfly
sound.Add( {
	name = "csgo_ButterflyKnife.backstab01",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_backstab01.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.backstab02",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_backstab02.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.draw01",
	channel = CHAN_ITEM,
	volume = 0.6,
	soundlevel = 65,
	sound = "csgo_knife/bknife_draw01.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.draw02",
	channel = CHAN_ITEM,
	volume = 0.6,
	soundlevel = 65,
	sound = "csgo_knife/bknife_draw02.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look01_a",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look01_a.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look01_b",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look01_b.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look02_a",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look02_a.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look02_b",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look02_b.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look03_a",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look03_a.wav"
} )

sound.Add( {
	name = "csgo_ButterflyKnife.look03_b",
	channel = CHAN_ITEM,
	volume = 0.4,
	soundlevel = 65,
	sound = "csgo_knife/bknife_look03_b.wav"
} )

sound.Add( {
	name = "csgo_KnifeFalchion.inspect",
	channel = CHAN_STATIC,
	volume = 1,
	soundlevel = 65,
	sound = "csgo_knife/knife_falchion_inspect.wav"
} )

sound.Add( {
	name = "csgo_KnifeFalchion.draw",
	channel = CHAN_STATIC,
	volume = {0.4, 0.9},
	pitch = {97, 105},
	soundlevel = 65,
	sound = "csgo_knife/knife_falchion_draw.wav"
} )

sound.Add( {
	name = "csgo_KnifeFalchion.Catch",
	channel = CHAN_STATIC,
	volume = {0.3, 0.7},
	pitch = {97, 105},
	soundlevel = 65,
	sound = "csgo_knife/knife_falchion_catch.wav"
} )

sound.Add( {
	name = "csgo_KnifeFalchion.Idlev2",
	channel = CHAN_STATIC,
	volume = 1,
	soundlevel = 65,
	sound = "csgo_knife/knife_falchion_idle.wav"
} )

sound.Add( {
	name = "csgo_Weapon.WeaponMove1", 
	channel = CHAN_ITEM,
	volume = 0.15,
	soundlevel = 65,
	sound = "csgo_knife/movement1.wav"
} )

sound.Add( {
	name = "csgo_Weapon.WeaponMove3",
	channel = CHAN_ITEM,
	volume = 0.15,
	soundlevel = 65,
	sound = "csgo_knife/movement3.wav"
} )

sound.Add( {
	name = "csgo_Weapon.WeaponMove2",
	channel = CHAN_ITEM,
	volume = 0.15,
	soundlevel = 65,
	sound = "csgo_knife/movement2.wav"
} )

sound.Add( {
	name = "csgo_KnifePush.Attack1Heavy",
	channel = CHAN_STATIC,
	volume = {0.1, 0.2},
	pitch = {98, 105},
	level = 65,
	sound = { "csgo_knife/knife_push_attack1_heavy_01.wav", "csgo_knife/knife_push_attack1_heavy_02.wav", "csgo_knife/knife_push_attack1_heavy_03.wav", "csgo_knife/knife_push_attack1_heavy_04.wav" }
} )

sound.Add( {
	name = "csgo_KnifePush.LookAtStart",
	channel = CHAN_STATIC,
	volume = 0.2,
	level = 65,
	sound = { "csgo_knife/knife_push_lookat_start.wav" }
} )

sound.Add( {
	name = "csgo_KnifePush.LookAtEnd",
	channel = CHAN_STATIC,
	volume = 0.2,
	level = 65,
	sound = { "csgo_knife/knife_push_lookat_end.wav" }
} )

sound.Add( {
	name = "csgo_KnifePush.Draw",
	channel = CHAN_STATIC,
	volume = 0.3,
	level = 65,
	sound = { "csgo_knife/knife_push_draw.wav" }
} )

sound.Add( {
	name = "KnifeBowie.draw",
	channel = CHAN_STATIC,
	volume = {0.7, 0.8},
    pitch = {99, 100},
	level = 65,
	sound = { "csgo_knife/knife_bowie_draw.wav" }
} )

sound.Add( {
	name = "KnifeBowie.LookAtStart",
	channel = CHAN_STATIC,
	volume = {0.2, 0.2},
    pitch = {99, 100},
	level = 65,
	sound = { "csgo_knife/knife_bowie_inspect_start.wav" }
} )

sound.Add( {
	name = "KnifeBowie.LookAtEnd",
	channel = CHAN_STATIC,
	volume = {0.2, 0.3},
    pitch = {99, 101},
	level = 65,
	sound = { "csgo_knife/knife_bowie_inspect_end.wav" }
} )
--addons/module_samogon/lua/autorun/d_load.lua:


local function LoadAllFiles( fdir )

	local files,dirs = file.Find( fdir.."*", "LUA" )
	
	for _,file in ipairs( files ) do
		if string.match( file, ".lua" ) then

			if SERVER then AddCSLuaFile( fdir..file ) end
			include( fdir..file )
		end	
	end
	
	for _,dir in ipairs( dirs ) do
		LoadAllFiles( fdir..dir.."/" )
	
	end
	
end
LoadAllFiles( "moonshine/" )



--addons/module_eventpanel/lua/autorun/devents_init.lua:
dEvents = {}

if SERVER then
    for _, v in pairs (file.Find('devents/interface/*', 'LUA')) do
        AddCSLuaFile('devents/interface/'..v)
    end
    for _, v in pairs (file.Find('devents/interface/vgui/*', 'LUA')) do
        AddCSLuaFile('devents/interface/vgui/'..v)
    end
    AddCSLuaFile('devents/cl_data.lua')

    AddCSLuaFile('devents/sh_config.lua')
    AddCSLuaFile('devents/sh_util.lua')
    AddCSLuaFile('devents/sh_actions.lua')
    include('devents/sh_config.lua')
    include('devents/sh_util.lua')
    include('devents/sh_actions.lua')

    include('devents/sv_core.lua')
    include('devents/sv_actions.lua')
    include('devents/sv_net.lua')
else
    include('devents/sh_config.lua')
    include('devents/sh_util.lua')
    include('devents/sh_actions.lua')
    
    include('devents/cl_data.lua')

    for _, v in pairs (file.Find('devents/interface/*', 'LUA')) do
        include('devents/interface/'..v)
    end
    for _, v in pairs (file.Find('devents/interface/vgui/*', 'LUA')) do
        include('devents/interface/vgui/'..v)
    end
end
--addons/module_eventpanel/lua/devents/cl_data.lua:
function dEvents.checkFolder()
    if not file.Exists('devents', 'DATA') then
        file.CreateDir('devents')
    end
end

dEvents.stripPresets = {}

function dEvents.readStripPresets()
    if not file.Exists('devents/strips.txt', 'DATA') then return end

    local data = util.JSONToTable(file.Read('devents/strips.txt', 'DATA') or '[]')
    dEvents.stripPresets = data
end

function dEvents.writeStripPresets()
    local json = util.TableToJSON(dEvents.stripPresets, true)
    file.Write('devents/strips.txt', json)
end

dEvents.checkFolder()
dEvents.readStripPresets()
--addons/module_eventpanel/lua/devents/interface/vgui/eventmenu.lua:
local panel = {}

function panel:Init()
    self.players = {}
    self.options = {}

    self:SetBackgroundColor(dEvents.config.secondColor)

    self.optionPanel = vgui.Create('DPanel', self)
    self.optionPanel:Dock(RIGHT)
    self.optionPanel:SetWide(self:GetParent():GetWide()*0.3)

    self.stopEvent = vgui.Create('DButton', self.optionPanel)
    self.stopEvent:Dock(BOTTOM)
    self.stopEvent:SetTall(25)
    self.stopEvent:SetText(dEvents.actions.stop.name or '')
    self.stopEvent:SetIcon(dEvents.actions.stop.icon or 'icon16/wand.png')
    self.stopEvent.DoClick = function()
        RunConsoleCommand('devents', 'stop')
    end

    self.optionScroll = vgui.Create('DScrollPanel', self.optionPanel)
    self.optionScroll:Dock(FILL)
    self.optionScroll.Paint = function(s,w,h)
        surface.SetDrawColor(dEvents.config.secondColor)
        surface.DrawRect(0,0,w,h)
    end

    self.playerList = vgui.Create('DListView', self)
    self.playerList:Dock(FILL)
    self.playerList:AddColumn('Ник')
    self.playerList:AddColumn('SteamID')
    self.playerList:SetMultiSelect(true)

    local actions = dEvents.getSortedActions()

    function self.playerList:OnRowRightClick(id, line)
        local tgts = {}
        for _, v in ipairs(self:GetSelected() or {}) do
            tgts[#tgts+1] = v:GetColumnText(2)
        end
        tgts = table.concat(tgts, ';')
        local menu = DermaMenu()

        menu:AddOption(dEvents.getPhrase('vgui_spectate'), function()
            RunConsoleCommand('fspectate', tgts)
        end):SetIcon('icon16/camera.png')

        menu:AddOption(dEvents.getPhrase('vgui_bring'), function()
            RunConsoleCommand('fadmin', 'bring', tgts)
        end):SetIcon('icon16/user_go.png')

        menu:AddOption(dEvents.getPhrase('vgui_goto'), function()
            RunConsoleCommand('fadmin', 'goto', tgts)
        end):SetIcon('icon16/arrow_right.png')

        menu:AddSpacer()

        for _, action in pairs (actions) do
            if action.noButton then continue end
            if action.onlyEveryone then continue end
            menu:AddOption(action.name, function()
                if action.panel then
                    action.panel(action.command, tgts)
                else
                    RunConsoleCommand('devents', action.command, tgts)
                end
            end):SetIcon(action.icon or 'icon16/wand.png')
        end
        menu:Open()
    end

    for _, action in pairs (actions) do
        if action.noButton then continue end
        if action.onePlayer then continue end

        local btn = vgui.Create('DButton', self.optionScroll)
        btn:Dock(TOP)
        btn:SetTall(25)
        btn:SetText(action.name or '')
        btn:SetIcon(action.icon or 'icon16/wand.png')
        btn.DoClick = function()
            if action.panel then
                action.panel(action.command, '*')
            else
                RunConsoleCommand('devents', action.command, '*')
            end
        end
        self.optionScroll:Add(btn)
    end
end

function panel:PerformLayout()
    --self.optionPanel:SetWide(self:GetParent():GetWide()*0.3)
end

function panel:AddPlayer(ply)
    if not IsValid(ply) then return end
    table.insert(self.players, ply)
    self.playerList:AddLine(ply:Name(), ply:SteamID())
end

function panel:RemovePlayer(id)
    local line = self.playerList:GetLine(id)
    if not IsValid(line) then return end

    self.playerList:RemoveLine(id)
    table.remove(self.players, id)
end

function panel:RefreshPlayers()
    local oldPlayers = self.players
    self.players = {}

    for _, v in pairs (oldPlayers) do
        self:AddPlayer(v)
    end
end

function panel:Clear()
    self.players = {}
    self.playerList:Clear()
end

vgui.Register('devents_main', panel, 'DPanel')
--addons/module_clans/lua/dorgs/vgui/vgui_category.lua:
--
--addons/module_duels/lua/duelsystem/nwvars.lua:
hook.Add('Think', 'duelSystem.Load', function()
    hook.Remove('Think', 'duelSystem.Load')

    nw.Register('duelSystem.Current') -- Нвшка текущей дуэли. Структура {weapons = weaponPresetName, players={playerlist}, startTime = SysTime(), prize=int, prizeType=string}
        :Write(net.WriteTable)
        :Read(net.ReadTable)
        :SetGlobal()
        :SetHook('duelSystem.DuelUpdate')
    nw.Register('duelSystem.OnDuel') -- Находится ли человек на дуэли
        :Write(net.WriteBool)
        :Read(net.ReadBool)
        :SetLocalPlayer()
end)
--addons/module_elitef4menu/lua/autorun/elite_config.lua:
MONEYCMD_BUTTONS = {}

local function MenuAddMButton( n, f )
    table.insert(MONEYCMD_BUTTONS, { NAME = n, FUNC = f } )
end

--First Section
MenuAddMButton( "Группа VK", function() gui.OpenURL( "https://vk.com/rpwayzer" ) end )
MenuAddMButton( "Discord", function() gui.OpenURL( "https://discord.gg/W6K5FgSNck" ) end )
MenuAddMButton( "Правила", function() gui.OpenURL( "https://vk.com/@rpwayzer-pravila-servera" ) end )
MenuAddMButton( "Контент CSS", function() gui.OpenURL( "https://docs.google.com/document/d/1ikX4qrMcMv7-rHxW-jiGd4oc_OQpJfM5qtqolFhYb-A/" ) end )
--addons/module_elitef4menu/lua/f4/tabs/clans.lua:
f4menu.addTab('clans', {
	order = 500,
	title = 'Кланы',
	panel = function(tab, parent)
		local pnl = vgui.Create('dorgs.main', parent)
		pnl:Dock(FILL)
		pnl:DockMargin(30, 30, 30, 30)
		--pnl:DockPadding(25, 25, 25, 25)
	
		pnl.OnSelected = function(s)
			local id = LocalPlayer():GetMainOrgID()
			if id then
				s:SetVisible(true)
				s:SetOrg(id)
			else
				s:SetVisible(false)
				Derma_StringRequest( 
					'Создание организации', 
					'Ты не состоишь ни в одной организации, стоимость создания составляет '..DarkRP.formatMoney(dOrgs.config.createPrice), 
					'', 
					function(name) RunConsoleCommand('dorgs', 'createorg', name) end
				)
			end
		end

		return pnl
    end,
	icon = Material('icon72/crossed_swords.png'),
})

hook.Add('dOrgs.networkedOrg', 'f4', function(org)
	f4menu:updateTabs()
end)

hook.Add('f4menu.opened', 'dOrgs', function()
	dOrgs.sub()
end)

hook.Add('f4menu.closed', 'dOrgs', function()
	dOrgs.unsub()
end)
--addons/module_elitef4menu/lua/f4/tabs/donate.lua:
f4menu.addTab('donate', {
	order = 900,
	title = 'Донат',
	callback = function()
        f4menu:close()
        PS:ToggleMenu()
    end,
	icon = Material('icon72/gem.png'),
})
--addons/module_elitef4menu/lua/f4/tabs/elite_ammo.lua:
function LoadAmmoPanel()

	BG_HEADTEXT:SetText( "Патроны" )
	BG_HEADTEXT:SizeToContents()
	
	AMMO_MAIN = vgui.Create( "Panel", BG_MAIN )
	AMMO_MAIN:SetSize( BG_MAIN:GetWide(), BG_MAIN:GetTall() )
	
	local AMMO_WINDOW = vgui.Create( "Panel", AMMO_MAIN )
	AMMO_WINDOW:SetSize( BG_MAIN:GetWide() - 56, BG_MAIN:GetTall() - 50 )
	AMMO_WINDOW:SetPos( -200, 25 )
	AMMO_WINDOW.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color( 239, 239, 239 ) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color( 255, 255, 255 ) )
		
		draw.SimpleText( "Патроны", "f4.main", 24, 20, Color( 190, 190, 190 ) )
		
		surface.SetDrawColor( Color( 242, 242, 242 ) )
		surface.DrawLine( 24, 44, w - 26, 44 )
	end
	
	AMMO_LIST = vgui.Create( "DPanelList", AMMO_WINDOW )
	AMMO_LIST:SetPos( 24, 44 )
	AMMO_LIST:SetSize( AMMO_WINDOW:GetWide() - 30, AMMO_WINDOW:GetTall() - 54 )
	AMMO_LIST:EnableVerticalScrollbar( true )
	AMMO_LIST:DockPadding( 0, 5, 10, 0 )
	AMMO_LIST.VBar.Paint = function( s, w, h )
		draw.RoundedBox( 4, 3, 13, 8, h-24, Color(0,0,0,70))
	end
	AMMO_LIST.VBar.btnUp.Paint = function( s, w, h ) end
	AMMO_LIST.VBar.btnDown.Paint = function( s, w, h ) end
	AMMO_LIST.VBar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox( 4, 5, 0, 4, h+22, Color(0,0,0,70))
	end
	
	for k, v in pairs( GAMEMODE.AmmoTypes ) do
	
		local ammoFrame = vgui.Create( "DPanel" ) -- surface.DrawLine( 24, self:GetTall() - 44, self:GetWide() - 24, self:GetTall() - 44 )
		ammoFrame:SetSize( AMMO_LIST:GetWide(), 60 )
		ammoFrame.Paint = function( self, w, h )
		
			surface.SetDrawColor( Color( 242, 242, 242 ) )
		
			surface.DrawLine( 0, h - 1, w, h - 1 )
			
			draw.SimpleText( string.upper(v.name), "f4.main", 56, 14, Color( 0, 0, 0 ) )
			draw.SimpleText( "Цена: $"..string.upper(v.price), "f4.main", 56, 30, Color( 100, 100, 100 ) )
		end
		ammoFrame.OnCursorEntered = function( self )

		end
		ammoFrame.OnCursorEntered = function( self )

		end
		
		AMMO_LIST:AddItem( ammoFrame )
		
		local ammoButton = vgui.Create( "DButton", ammoFrame )
		ammoButton:SetSize( 90, 35 )
		ammoButton:SetPos( ammoFrame:GetWide() - 110, (ammoFrame:GetTall() / 2) - 17.5 )
		ammoButton:SetText( "Купить" )
		ammoButton:SetFont( "f4.main" )
		ammoButton:SetTextColor( Color( 255, 255, 255 ) )
		ammoButton.Paint = function( self, w, h )
			draw.RoundedBox( 4, 0, 0, w, h, Color( 239, 239, 243 ) )
			draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 232, 76, 82 ) )
			draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 233, 84, 90 ) )
			
			if self.hover then
				draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 206, 68, 73 ) )
			end
		end
		ammoButton.DoClick = function()
			RunConsoleCommand('darkrp', 'buyammo', v.ammoType)
		end
		ammoButton.OnCursorEntered = function(self)
			self.hover = true
		end
		ammoButton.OnCursorExited = function(self)
			self.hover = false
		end
		
		local ammoModel = vgui.Create( "SpawnIcon", ammoFrame )
		ammoModel:SetSize( 52, 52 )
		ammoModel:SetPos( 0, 8 )
		ammoModel:SetModel( v.model )
		
	end
	
	AMMO_WINDOW:MoveTo( 28, 25, 0.2, 0, 0.2 )
	--HOME_STATS:MoveTo( 222, 25, 0.4, 0.2, 0.1 )
	--HOME_INFO:MoveTo( 28, 330, 0.6, 0.2, 0.1 )
end

--addons/module_elitef4menu/lua/f4/tabs/market.lua:
f4menu.addTab('market', {
	order = 800,
	title = 'Рынок',
	panel = function(tab, parent)
		if IsValid(wmarket.mainPanel) then wmarket.mainPanel:Remove() end
        wmarket.mainPanel = vgui.Create('wmarket_main', parent)

		wmarket.mainPanel.OnSelected = function(self)
			self:InvalidateParent(true)
			wmarket.requestSummary()
		end

        return wmarket.mainPanel
    end,
	icon = Material('icon72/chart_with_upwards_trend.png'),
})

hook.Add('f4menu.opened', 'wmarket', function()
	wmarket.sub()
	wmarket.requestSummary()
end)

hook.Add('f4menu.closed', 'wmarket', function()
	wmarket.unsub()
end)
--addons/module_elitef4menu/lua/f4/tabs/skins.lua:
local gradient = Material("gui/center_gradient")

local function GetColorBasedOnPrice(price)
    local minPrice = 5000000
    local maxPrice = 700000000

    local normalized = math.Clamp((price - minPrice) / (maxPrice - minPrice), 0, 1)

    if normalized <= 0.5 then
        local progress = normalized * 2
        local r = math.floor(255 * progress)
        local g = math.floor(255 * progress)
        local b = math.floor(255 * (1 - progress))
        return Color(r, g, b)
    else
        local progress = (normalized - 0.5) * 2
        local r = 255
        local g = math.floor(255 * (1 - progress))
        local b = 0
        return Color(r, g, b)
    end
end

local function LoadSkinsPanel(tab, parent)
	local pnl = vgui.Create('DPanel', parent)
	pnl:Dock(FILL)
	pnl.Paint = function(s,w,h)
		draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
	end
	
	pnl:DockMargin(30, 30, 30, 30)
	pnl:DockPadding(25, 25, 25, 25)

	local lbl = vgui.Create('DLabel', pnl)
	lbl:Dock(TOP)
	lbl:SetAutoStretchVertical(true)
	lbl:SetFont('f4.main')
	lbl:SetTextColor(f4menu.col.text_inactive)
	lbl:SetText('Скины на оружие')
	
	local scroll = vgui.Create('DScrollPanel', pnl)
	scroll:Dock(FILL)
	scroll.VBar.Paint = function( s, w, h )
		draw.RoundedBox( 6, 3, 13, 8, h-24, f4menu.col.color_scroll)
	end
	scroll.VBar.btnUp.Paint = function( s, w, h ) end
	scroll.VBar.btnDown.Paint = function( s, w, h ) end
	scroll.VBar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox( 6, 5, 0, 4, h+22, f4menu.col.color_scroll)
	end

	local panel_list = vgui.Create('DIconLayout', scroll)
	panel_list:Dock(FILL)
	panel_list:SetSpaceX(4)
	panel_list:SetSpaceY(8)
	panel_list:DockMargin(0, 10, 0, 0)
	panel_list:DockPadding( 0, 5, 10, 0 )
	pnl:InvalidateParent(true)
	scroll:InvalidateParent(true)
	scroll:PerformLayoutInternal()
	panel_list:InvalidateParent(true)
	panel_list:InvalidateLayout(true)

	pnl.OnSelected = function()
		local ply = LocalPlayer()
		local selected = ply:GetNetVar('weaponSkin')
		local skins = ply:GetNetVar('weaponSkin.list', {})
		
		panel_list:Clear()
		local i = 1
		for k, v in SortedPairsByValue( weaponSkins.config.skins ) do
			local skinFrame = vgui.Create( "DButton" ) -- surface.DrawLine( 24, self:GetTall() - 44, self:GetWide() - 24, self:GetTall() - 44 )
			skinFrame:SetText("")
			skinFrame.price = GetColorBasedOnPrice(v)
			skinFrame.count = i
			skinFrame.DoClick = function()
				if skins[k] then
					net.Start('weaponSkins.select')
					net.WriteString(selected == k and '' or k)
					net.SendToServer()
				else
					weaponSkins.preview(k)
				end
			end

			if skins[k] then
				skinFrame.gradientColor = selected == k and Color(76, 190, 0) or Color( 236, 113, 73 )
			end
		
			skinFrame.Paint = function( self, w, h )
    			draw.RoundedBox( 4, 0, 0, w, h, f4menu.col.bg)-- v.color )

				if self.gradientColor then
					surface.SetMaterial( gradient )
					surface.SetDrawColor( self.gradientColor )
					surface.DrawTexturedRect( 0, 0, w, h )
				end

				draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.secondcolor )

				draw.SimpleText( 'Скин #'..self.count, "f4.main", 56, 14, color_white )
				draw.SimpleText( "Цена: "..string.upper(DarkRP.formatMoney(v)), "f4.main", 56, 30, Color( 100, 100, 100 ) )
			end
			
			i = i + 1
			
			skinFrame.OnCursorEntered = function( self )

			end
			skinFrame.OnCursorEntered = function( self )

		    end
		
			local skinModel = vgui.Create( "DButton", skinFrame )
			skinModel:SetSize( 45,45 )
			skinModel:SetPos( 10, 5 )
			skinModel:SetIcon( k )
			skinModel:SetText('')
			skinModel.Paint = wlib.func.blank
			skinModel.DoClick = function()
				weaponSkins.preview(k)
			end
			
			skinFrame:SetSize((scroll:GetWide() - scroll.VBar:GetWide())/2 - 8, 60)
			
			panel_list:Add( skinFrame )
		end
		scroll:PerformLayoutInternal()
	end

	return pnl
end

f4menu.addTab('skins', {
	order = 400,
	title = 'Скины',
	panel = LoadSkinsPanel,
	icon = Material('icon72/dizzy.png'),
})

hook.Add('weaponSkin.selectedUpdate', 'f4', fp{f4menu.updateTabs, f4menu})
hook.Add('weaponSkin.listUpdate', 'f4', fp{f4menu.updateTabs, f4menu})
--addons/tool_keypad/lua/autorun/keypad_pattern.lua:
PatternKeypad = PatternKeypad or {}

if SERVER then
    AddCSLuaFile("pkeypad_config.lua")
    AddCSLuaFile("pkeypad/client/dpatterngrid.lua")
    AddCSLuaFile("pkeypad/client/dcolorselector.lua")
end

include("pkeypad_config.lua")

function PatternKeypad.parseCombination(str)
    local arr = string.Explode(":", str)
    local sizeArr = string.Explode(",", arr[1])
    local comboArr = string.Explode(",", arr[2] or "")

    local width = math.Clamp(tonumber(sizeArr[1]) or 2, 2, 4)
    local height = math.Clamp(tonumber(sizeArr[2]) or 2, 2, 4)
    local combination = {}
    local usedIds = {}

    if #comboArr > 1 then
        for i = 1, #comboArr do
            local num = tonumber(comboArr[i])
            if not num then break end

            local id = width + math.Clamp(num, 1, width * height)

            if usedIds[id] then
                combination = {}
                break
            end

            combination[i] = id
            usedIds[id] = true
        end
    end

    return width, height, combination
end

function PatternKeypad.parseColor(str)
	local arr = string.Explode(",", str)

	local r = math.Clamp(tonumber(arr[1]) or 0, 0, 255)
	local g = math.Clamp(tonumber(arr[2]) or 0, 0, 255)
	local b = math.Clamp(tonumber(arr[3]) or 0, 0, 255)
	local a = math.Clamp(tonumber(arr[4]) or 0, 0, 255)

    return Color(r, g, b, a)
end

function PatternKeypad.error(...)
    MsgC(Color(255, 150, 0), "[PKeypad-Error] ", ...)
    MsgC("\n")
end

function PatternKeypad.print(...)
    MsgC(Color(0, 255, 0), "[PKeypad] ", Color(255, 255, 255), ...)
    MsgC("\n")
end

if SERVER then
    include("pkeypad/version.lua")
end

--addons/module_hitregtest/lua/leyhitreg/shared/workarounds/workarounds.lua:
local HL2Ignore = {}
HL2Ignore["weapon_physcannon"] = true
HL2Ignore["weapon_physgun"] = true
HL2Ignore["weapon_frag"] = true
HL2Ignore["weapon_rpg"] = true
HL2Ignore["gmod_camera"] = true
HL2Ignore["gmod_tool"] = true
HL2Ignore["weapon_physcannon"] = true
HL2Ignore["weapon_shotgun"] = true

local MeleeHoldType = {}
MeleeHoldType["knife"] = true
MeleeHoldType["melee"] = true
MeleeHoldType["melee2"] = true

local ExtraIgnores = {}

function LeyHitreg:IsIgnoreWep(wep)
    if (HL2Ignore[wep:GetClass()]) then
        return true
    end

    if (ExtraIgnores[wep:GetClass()]) then
        return true
    end

    -- Ignore all melees
    if (wep.IsMelee or wep.Melee or wep:Clip1() < 0) then
        return true
    end


    if (wep.GetHoldType) then
        local holdType = wep:GetHoldType()

        if (MeleeHoldType[holdType]) then
            return true
        end
    end

    -- Ignore shotguns
    if (wep.Shotgun or wep.IsShotgun or wep.ShotgunReload or wep.ShotGun or wep.Primary and wep.Primary.NumShots and wep.Primary.NumShots > 1) then
        return true
    end
    -- Ignore modern day SWEP creators who are too busy reinventing the wheel to add a single wep.IsShotgun variable
    if (wep.ShotgunEmptyAnim or wep.ShotgunStartAnimShell) then
        return true
    end

    if (wep.Category and string.find(string.lower(wep.Category), "shotgun", 1, true)) then
        return true
    end

    if (wep.Purpose and string.find(string.lower(wep.Purpose), "shotgun", 1, true)) then
        return true
    end

    if (wep.PrintName and string.find(string.lower(wep.PrintName), "shotgun", 1, true)) then
        return true
    end

    if (ACT3_CAT_SHOTGUN and wep.ACT3Cat and wep.ACT3Cat == ACT3_CAT_SHOTGUN) then
        return true
    end

    return false
end

function LeyHitreg:AddIgnoreWeapon(weporclass)
    if (isstring(weporclass)) then
        ExtraIgnores[weporclass] = true
    else
        ExtraIgnores[weporclass:GetClass()] = true
    end
end

function LeyHitreg:GetPlayerFromWeapon(wep)
    local ply = wep:GetOwner()

    if (not IsValid(ply)) then
        return
    end

    return ply
end

local IsValid = IsValid
function LeyHitreg:GetPlayerFromPlyOrBullet(plyorwep, bullet)
    if (not bullet or not IsValid(plyorwep)) then
        return
    end

    local ply = bullet.Attacker

    if (not IsValid(ply) or not ply:IsPlayer()) then
        ply = nil
    end

    if (plyorwep:IsWeapon()) then
        if (ply) then
            return ply, plyorwep
        end

        local owner = plyorwep:GetOwner()

        if (not IsValid(owner) or not owner:IsPlayer()) then
            return
        end

        return owner, plyorwep
    end

    if (not ply) then
        ply = plyorwep

        if (not ply:IsPlayer()) then
            return
        end
    end

    local wep = ply:GetActiveWeapon()

    if (not IsValid(wep)) then
        return
    end

    return ply, wep
end

local vector_origin = vector_origin

function LeyHitreg:GetWeaponSpread(ply, wep, bullet)
    -- MW Swep pack workaround
    if (wep.CalculateCone) then
        return wep:CalculateCone() * 0.1 * 0.7
    end

    -- TFA workaround
    if (wep.CalculateConeRecoil) then
        return wep:CalculateConeRecoil()
    end

    -- ARCCW workaround
    if (wep.GetBuff and wep.ApplyRandomSpread and wep.TryBustDoor and ArcCW) then
        return ArcCW.MOAToAcc * wep:GetBuff("AccuracyMOA") * 4.5
    end


    -- CW2 workaround

    if (wep.AimSpread and wep.recalculateAimSpread and wep.getBaseCone) then
        return wep:getBaseCone()
    end

    if (bullet) then
        local bulletSpread = bullet.Spread

        if (bulletSpread and bulletSpread != vector_origin) then
            return bulletSpread
        end
    end

    if (self.WeaponSpreads and self.WeaponSpreads[wep:GetClass()]) then
        return self.WeaponSpreads[wep:GetClass()]
    end

    if (wep.PrimarySpread) then
        return wep.PrimarySpread
    end

    if (wep.PrimaryCone) then
        return wep.PrimaryCone
    end

    if (wep.Primary) then
        if (wep.Primary.Spread) then
            return wep.Primary.Spread
        end

        if (wep.Primary.Cone) then
            return wep.Primary.Cone
        end

        return bulletSpread
    end

    return vector_origin
end

function LeyHitreg:SetFittingValidClip(wep)
    local clip1 = wep:Clip1()

    if (clip1 == -1 or clip1 > 0) then
        return
    end

    local max = wep:GetMaxClip1()

    if (max > 0) then
        wep:SetClip1(max)
        return
    end

    wep:SetClip1(30)
end

--addons/module_market/lua/market/sh_config.lua:
MARKET_SELL = 0
MARKET_BUY = 1

wmarket.config = wmarket.config or {}
wmarket.config.enabled = true
wmarket.config.maxOrders = 10
wmarket.config.comission = 0.1
wmarket.config.comission_vip = 0.1

wmarket.config.netMaxOrders = 20

wmarket.config.logTypes = wmarket.config.logTypes or {}

MARKET_LOG_BUY = 0
wmarket.config.logTypes[MARKET_LOG_BUY] = function(log)
    local item, cur = wmarket.getItem(log.item) or log.item, wmarket.getCurrency(log.currency) or log.currency
    local itemname = isstring(item) and item or item.name
    return ('%s купил %sx %s за %s у %s'):format(
        log.player_name,
        log.amount,
        itemname,
        isstring(cur) and log.price..' '..cur or cur:formatAmount(log.price),
        log.target_name
    )
end

MARKET_LOG_CREATEORDER_SELL = 1
wmarket.config.logTypes[MARKET_LOG_CREATEORDER_SELL] = function(log)
    local item, cur = wmarket.getItem(log.item) or log.item, wmarket.getCurrency(log.currency) or log.currency
    return ('%s создал лот на продажу %sx за %s'):format(
        log.player_name,
        log.amount,
        isstring(cur) and log.price..' '..cur or cur:formatAmount(log.price)
    )
end

MARKET_LOG_CREATEORDER_BUY = 2
wmarket.config.logTypes[MARKET_LOG_CREATEORDER_BUY] = function(log)
    local item, cur = wmarket.getItem(log.item) or log.item, wmarket.getCurrency(log.currency) or log.currency
    return ('%s создал запрос на покупку %sx за %s'):format(
        log.player_name,
        log.amount,
        isstring(cur) and log.price..' '..cur or cur:formatAmount(log.price)
    )
end

wmarket.config.visibleLogs = {
    MARKET_LOG_BUY,
}

--addons/module_market/lua/market/cl_net.lua:
wmarket.summary = wmarket.summary or {}
net.Receive('wmarket.sendSummary', function(len)
    local itemId = net.ReadString()
    local curId = net.ReadString()
    
    wmarket.summary[curId] = wmarket.summary[curId] or {}

    local oldcount
    if wmarket.summary[curId][itemId] then
        oldcount = wmarket.summary[curId][itemId][MARKET_SELL].totalCount
    end

    wmarket.summary[curId][itemId] = {
        [MARKET_SELL] = {},
        [MARKET_BUY] = {},
        logs = {},
        prices = {},
    }

    local sum = wmarket.summary[curId][itemId]

    for _, type in ipairs({MARKET_SELL, MARKET_BUY}) do
        sum[type].minPrice = net.ReadFloat()
        sum[type].maxPrice = net.ReadFloat()
        sum[type].total = net.ReadFloat()
        sum[type].totalCount = net.ReadUInt(32)

        sum[type].ordersDOM = {}
        for i=1, net.ReadUInt(8) do
            table.insert(sum[type].ordersDOM, {
                price = net.ReadFloat(),
                total = net.ReadUInt(32),
            })
        end
    end

    for i=1, net.ReadUInt(6) do
        table.insert(sum.logs, {
            type = net.ReadUInt(4),
            player = net.ReadUInt64(),
            player_name = net.ReadString(),
            item = net.ReadString(),
            amount = net.ReadUInt(32),
            currency = net.ReadString(),
            price = net.ReadFloat(),
            target = net.ReadUInt64(),
            target_name = net.ReadString(),
            timestamp = net.ReadUInt(32),
        })
    end

    for i=1, net.ReadUInt(6) do
        table.insert(sum.prices, {
            avg_price = net.ReadFloat(),
            max_price = net.ReadFloat(),
            min_price = net.ReadFloat(),
            total_sold = net.ReadUInt(16),
            sale_date = net.ReadString(),
        })
    end

    if wmarket.summary[curId][itemId][MARKET_SELL].totalCount ~= oldcount then
        wmarket.summary[curId][itemId].changed = true
    end

    hook.Run('wmarket.summaryUpdated', itemId, curId)
end)

local lastrequested = 0
wmarket.requestSummary = function()
    if CurTime() - lastrequested < 10 then return end
    lastrequested = CurTime()

    net.Start('wmarket.sendSummary')
    net.SendToServer()
end

wmarket.requestMyOrders = wlib.func.debounce(function()
    net.Start('wmarket.getMyOrders')
    net.SendToServer()
end, 0.15)

wmarket.storage = wmarket.storage or {}
net.Receive('wmarket.getMyStoredItems', function()
    wmarket.storage = {}
    for i=1, net.ReadUInt(8) do
        table.insert(wmarket.storage, {
            id = net.ReadUInt(32),
            item = net.ReadString(),
            amount = net.ReadUInt(32),
            description = net.ReadString(),
            timestamp = net.ReadUInt(32),
        })
    end

    hook.Run('wmarket.storageUpdated')
end)

wmarket.requestMyStoredItems = wlib.func.debounce(function()
    net.Start('wmarket.getMyStoredItems')
    net.SendToServer()
end, 0.3)

local sub = false
function wmarket.sub()
    if sub then return end
    sub = true
    
    net.Start('wmarket.sub')
    net.SendToServer()
end

function wmarket.unsub()
    if not sub then return end
    sub = false

    net.Start('wmarket.unsub')
    net.SendToServer()
end

function wmarket.removeOrder(id)
    net.Start('wmarket.removeOrder')
    net.WriteUInt(id, 32)
    net.SendToServer()
end

function wmarket.createOrder(type, item, amount, currency, price)
    net.Start('wmarket.createOrder')
    net.WriteUInt(type, 1)
    net.WriteString(item)
    net.WriteUInt(amount, 32)
    net.WriteString(currency)
    net.WriteFloat(price)
    net.SendToServer()
end

function wmarket.claimStoredItem(index)
    net.Start('wmarket.claimStoredItem')
    net.WriteUInt(index, 16)
    net.SendToServer()
end
--addons/module_market/lua/market/vgui/itempage.lua:
local PANEL = {}

local color_log = Color(38, 42, 46, 255)

function PANEL:Init()
    self.mainPanel = self:GetParent():GetParent()
    self:DockPadding(8, 4, 8, 4)
    
    
    self.name = vgui.Create('DLabel', self)
    self.name:SetFont('wmarket.32.bold')
    self.name:Dock(TOP)
    self.name:SetAutoStretchVertical(true)
    self.name:SetTextColor(color_white)

    self.desc = vgui.Create('DLabel', self)
    self.desc:SetFont('wmarket.20')
    self.desc:Dock(TOP)
    self.desc:SetTextColor(color_white)

    self.orders = vgui.Create('DPanel', self)
    self.orders:SetPaintBackground(false)
    self.orders:Dock(TOP)
    self.orders:DockMargin(0,6,0,0)
    self.orders:SetTall(220)

    self.orders.sell = vgui.Create('DPanel', self.orders)
    self.orders.sell:Dock(LEFT)
    self.orders.sell:DockPadding(6,4,6,4)
    self.orders.sell.Paint = wlib.func.blank
    
    self.orders.sell.text = vgui.Create('DLabel', self.orders.sell)
    self.orders.sell.text:Dock(TOP)
    self.orders.sell.text:SetAutoStretchVertical(true)
    self.orders.sell.text:SetTextColor(color_white)

    self.orders.sell.list = vgui.Create('DListView', self.orders.sell)
    self.orders.sell.list:Dock(TOP)
    self.orders.sell.list:DockMargin(0,6,0,0)
    self.orders.sell.list:SetMultiSelect(false)
    self.orders.sell.list:AddColumn('Цена (за шт.)'):SetWidth(95)
    self.orders.sell.list:AddColumn('Кол-во'):SetWidth(5)

    self.orders.buyBTN = vgui.Create('DButton', self.orders.sell)
    self.orders.buyBTN:Dock(BOTTOM)
    self.orders.buyBTN:SetTall(25)
    self.orders.buyBTN:SetText('Купить')
    self.orders.buyBTN:SetFont('f4.main')
    self.orders.buyBTN:SetTextColor( Color( 255, 255, 255 ) )
    self.orders.buyBTN.Paint = function( s, w, h )
    --    draw.RoundedBox( 4, 0, 0, w, h, Color( 239, 239, 243 ) )
        draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 10, 168, 105 ) )
        draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 8, 158, 90 ) )
        
        if s.hover then
            draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 206, 68, 73 ) )
        end
    end

    self.orders.buyBTN.DoClick = function()
        wmarket.openCreateOrder(self.mainPanel, self.item, self.currency, MARKET_BUY)
    end

    self.orders.buy = vgui.Create('DPanel', self.orders)
    self.orders.buy:Dock(RIGHT)
    self.orders.buy:DockPadding(6,4,6,4)
    self.orders.buy.Paint = wlib.func.blank
    
    self.orders.buy.text = vgui.Create('DLabel', self.orders.buy)
    self.orders.buy.text:Dock(TOP)
    self.orders.buy.text:SetAutoStretchVertical(true)
    self.orders.buy.text:SetTextColor(color_white)

    self.orders.buy.list = vgui.Create('DListView', self.orders.buy)
    self.orders.buy.list:Dock(TOP)
    self.orders.buy.list:DockMargin(0,6,0,0)
    self.orders.buy.list:SetMultiSelect(false)
    self.orders.buy.list:AddColumn('Цена (за шт.)'):SetWidth(95)
    self.orders.buy.list:AddColumn('Кол-во'):SetWidth(5)

    self.orders.sellBTN = vgui.Create('DButton', self.orders.buy)
    self.orders.sellBTN:Dock(BOTTOM)
    self.orders.sellBTN:SetTall(25)
    self.orders.sellBTN:SetText('Продать')
    self.orders.sellBTN:SetFont('f4.main')
    self.orders.sellBTN:SetTextColor( Color( 255, 255, 255 ) )
    self.orders.sellBTN.DoClick = function()
        if self.item:getAmount(LocalPlayer()) == 0 then return notification.AddLegacy('У тебя нет этого предмета', 1, 3) end
        wmarket.openCreateOrder(self.mainPanel, self.item, self.currency, MARKET_SELL)
    end
    self.orders.sellBTN.Paint = function( s, w, h )
    --    draw.RoundedBox( 4, 0, 0, w, h, Color( 239, 239, 243 ) )
        draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 242, 54, 69 ) )
        draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 232, 44, 59 ) )
        
        if s.hover then
            draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 206, 68, 73 ) )
        end
    end

    self.guide_logs = vgui.Create('DLabel', self)
    self.guide_logs:SetTextColor(color_white)
    self.guide_logs:SetFont('wmarket.24')
    self.guide_logs:Dock(TOP)
    self.guide_logs:DockMargin(0,12,0,0)
    self.guide_logs:SetAutoStretchVertical(true)
    self.guide_logs:SetText('Медиана цен')

    self.scroll = vgui.Create('DScrollPanel', self)
    self.scroll:Dock(FILL)
    self.scroll:DockMargin(0,6,0,0)
    local vbar = self.scroll:GetVBar()
    vbar.Paint = function( s, w, h )
        draw.RoundedBox( 4, 3, 13, 8, h - 20, Color(0,0,0,70))
    end
    vbar.btnUp.Paint = wlib.func.blank
    vbar.btnDown.Paint = wlib.func.blank
    vbar.btnGrip.Paint = function( s, w, h )
        draw.RoundedBox( 4, 5, 0, 4, h, Color(0,0,0,70))
    end

    self.graph = vgui.Create('wlib.graph', self.scroll)
    self.graph:Dock(TOP)
    self.graph:DockMargin(0,6,0,0)
    self.graph:SetTall(300)
    self.graph:SetTooltipTextColor(color_white)
    self.graph:SetTooltipColor(color_log)
    self.graph.GenerateTooltip = function(s, p)
        return ('%s\nМакс: %s\nСред: %s\nМин: %s\nВсего продано: %s'):format(
            p.sale_date,
            self.currency:formatAmount(p.max_price),
            self.currency:formatAmount(p.avg_price),
            self.currency:formatAmount(p.min_price),
            p.total_sold
        )
    end
    self.scroll:AddItem(self.graph)

    self.logs = vgui.Create('DPanel', self.scroll)
    self.logs:Dock(TOP)
    self.logs:DockMargin(0,6,0,0)
    self.logs:SetPaintBackground(false)
    self.scroll:AddItem(self.logs)
end

wlib.accessor(PANEL, 'item', 'Item')
wlib.accessor(PANEL, 'currency', 'Currency')

local btnW = 120
function PANEL:PerformLayout(w, h)
    self.orders.buy:SetWide(self.orders:GetWide()/2)
    self.orders.sell:SetWide(self.orders:GetWide()/2)

    --self:Rebuild()

    local blockW = self.orders.buy:GetWide()

    self.orders.buyBTN:DockMargin((blockW-btnW)/2, 0, (blockW-btnW)/2, 6)
    self.orders.sellBTN:DockMargin((blockW-btnW)/2, 0, (blockW-btnW)/2, 6)
end

function PANEL:Rebuild()
    if not self.item or not self.currency then return end

    self.name:SetText(wlib.string.wrap(self.item.name, self.name:GetFont(), self.name:GetWide()))
    self.name:SizeToContents()
    self.desc:SetText(wlib.string.wrap(self.item.description, self.desc:GetFont(), self.desc:GetWide()))
    self.desc:SizeToContents()

    local sum = wmarket.getSummary(self.currency, self.item)
    if not sum then return end

    local buytext = ('Запросов на покупку: %s\nВсего покупают: %s\nНачальная цена: %s'):format(sum[MARKET_BUY].totalCount or 0, sum[MARKET_BUY].total or 0, self.currency:formatAmount(math.Round(sum[MARKET_BUY].maxPrice or 0, self.currency.decimals or 0)))
    self.orders.buy.text:SetText(wlib.string.wrap(buytext, self.orders.buy.text:GetFont(), self.orders.buy.text:GetWide()))

    local selltext = ('Лотов на продажу: %s\nВсего продают: %s\nНачальная цена: %s'):format(sum[MARKET_SELL].totalCount or 0, sum[MARKET_SELL].total or 0, self.currency:formatAmount(math.Round(sum[MARKET_SELL].minPrice or 0, self.currency.decimals or 0)))
    self.orders.sell.text:SetText(wlib.string.wrap(selltext, self.orders.sell.text:GetFont(), self.orders.sell:GetWide()))

    self.orders.sell.list:Clear()
    local sellDOM = sum[MARKET_SELL].ordersDOM or {}
    local usedCount = 0
    for i=1, 5 do
        local el = sellDOM[i]
        if not el then break end

        usedCount = usedCount + el.total

        local line = self.orders.sell.list:AddLine(self.currency:formatAmount(math.Round(el.price, self.currency.decimals or 0)), el.total)
        line.OnRightClick = function(s)
            local menu = DermaMenu()
            menu:AddOption('Купить', function()
                wmarket.openCreateOrder(self.mainPanel, self.item, self.currency, MARKET_BUY, 1, el.price)
            end):SetIcon('icon16/money_dollar.png')
            menu:Open()
        end
    end
    if sellDOM[6] then
        local nextPrice, totalCount = sellDOM[6].price, sum[MARKET_SELL].total - usedCount

        local line = self.orders.sell.list:AddLine(self.currency:formatAmount(math.Round(nextPrice, self.currency.decimals or 0))..' и более', totalCount)
        line.OnRightClick = function(s)
            local menu = DermaMenu()
            menu:AddOption('Купить', function()
                wmarket.openCreateOrder(self.mainPanel, self.item, self.currency, MARKET_BUY, 1, nextPrice)
            end):SetIcon('icon16/money_dollar.png')
            menu:Open()
        end
    end
    self.orders.sell.list:InvalidateLayout(true)
    self.orders.sell.list:SizeToContents()

    self.orders.buy.list:Clear()
    local buyDOM = sum[MARKET_BUY].ordersDOM or {}
    local usedCount = 0
    for i=1, 5 do
        local el = buyDOM[i]
        if not el then break end

        usedCount = usedCount + el.total

        local line = self.orders.buy.list:AddLine(self.currency:formatAmount(math.Round(el.price, self.currency.decimals or 0)), el.total)
        line.OnRightClick = function(s)
            local menu = DermaMenu()
            menu:AddOption('Продать', function()
                if self.item:getAmount(LocalPlayer()) == 0 then return notification.AddLegacy('У тебя нет этого предмета', 1, 3) end
                wmarket.openCreateOrder(self.mainPanel, self.item, self.currency, MARKET_SELL, 1, nil, el.price)
            end):SetIcon('icon16/money_dollar.png')
            menu:Open()
        end
    end
    if buyDOM[6] then
        local nextPrice, totalCount = buyDOM[6].price, sum[MARKET_BUY].total - usedCount

        local line = self.orders.buy.list:AddLine(self.currency:formatAmount(math.Round(nextPrice, self.currency.decimals or 0))..' и менее', totalCount)
        line.OnRightClick = function(s)
            local menu = DermaMenu()
            menu:AddOption('Продать', function()
                if self.item:getAmount(LocalPlayer()) == 0 then return notification.AddLegacy('У тебя нет этого предмета', 1, 3) end
                wmarket.openCreateOrder(self.mainPanel, self.item, self.currency, MARKET_SELL, 1, nil, nextPrice)
            end):SetIcon('icon16/money_dollar.png')
            menu:Open()
        end
    end
    self.orders.buy.list:InvalidateLayout(true)
    self.orders.buy.list:SizeToContents()

    self.logs:Clear()
    for _, v in ipairs(sum.logs or {}) do
        if not wmarket.config.logTypes[v.type] then continue end

        local pnl = vgui.Create('DPanel', self.logs)
        pnl:Dock(TOP)
        pnl:SetTall(60)
        pnl.Paint = function(s,w,h)
            draw.RoundedBox(6,0,0,w,h,color_log) 
        end

        pnl.text = vgui.Create('DLabel', pnl)
        pnl.text:Dock(TOP)
        pnl.text:SetTextColor(color_white)

        pnl.text:SetFont('wmarket.24')
        local str = wmarket.config.logTypes[v.type](v)
        pnl.text:SetText(wlib.string.wrap(str, pnl.text:GetFont(), self:GetWide()-20))
        pnl.text:SizeToContents()

        pnl.time = vgui.Create('DLabel', pnl)
        pnl.time:Dock(TOP)
        pnl.time:DockMargin(0,4,0,0)
        pnl.time:SetContentAlignment(6)
        pnl.time:SetText(os.date('%X %d.%m.%Y', v.timestamp))
        pnl.time:SizeToContents()
        pnl.time:SetTextColor(color_white)

        pnl:SetTall(pnl.text:GetTall()+pnl.time:GetTall()+12)
        pnl:DockPadding(4,4,4,4)
        pnl:DockMargin(4,4,4,4)

        pnl:InvalidateParent(true)
    end

    self.graph:Clear()
    for k, v in ipairs(table.Reverse(sum.prices or {})) do
        self.graph:AddPoint(k, v.avg_price, v)
    end
    self.graph:AutoMinMax()
    self.graph:AutoGap()

    self.logs:SizeToChildren(false, true)
    
end

function PANEL:Paint()

end

vgui.Register('wmarket_itempage', PANEL, 'DPanel')
--addons/module_market/lua/market/vgui/myorders.lua:
local PANEL = {}

function PANEL:Init()
    self:DockPadding(4,4,4,4)
    
    self.guide = vgui.Create('DLabel', self)
    self.guide:Dock(TOP)
    self.guide:SetAutoStretchVertical(true)
    self.guide:SetText('Нажми ПКМ по лоту чтобы отменить его')
    self.guide:SetDark(true)

    self.list = vgui.Create('DListView', self)
    self.list:Dock(FILL)
    self.list:DockMargin(0,4,0,0)
    self.list:SetMultiSelect(false)
    self.list.DoDoubleClick = function(_, _, line)
        line:SelectItem()
    end
    
    self.list:AddColumn('Дата')
    self.list:AddColumn('Тип')
    self.list:AddColumn('Предмет')
    self.list:AddColumn('Цена (за шт.)')
    self.list:AddColumn('Валюта')
    self.list:AddColumn('Количество')
end

local types = {
    [MARKET_SELL] = 'Продажа',
    [MARKET_BUY] = 'Покупка',
}

function PANEL:AddOrder(d)
    local item, cur = wmarket.getItem(d.item), wmarket.getCurrency(d.currency)
    assert(item and cur, 'couldnt find item or currency')

    local line = self.list:AddLine(
        os.date('%X %d.%m.%Y', d.timestamp),
        types[d.type] or d.type,
        item.name,
        d.price,
        cur.name,
        d.amount
    )

    line.SelectItem = function()
        wmarket.selectItemPage(item, cur)
        self:Remove()
    end

    line.OnRightClick = function(s)
        local menu = DermaMenu()

        menu:AddOption('Перейти', function()
            s:SelectItem()
        end):SetIcon('icon16/arrow_left.png')

        menu:AddOption('Отменить', function()
            wmarket.removeOrder(d.id)
        end):SetIcon('icon16/cancel.png')

        menu:Open()
    end
end

function PANEL:SetData(d)
    self:Clear()
    for _, order in ipairs(d) do
        self:AddOrder(order)
    end
end

function PANEL:Clear()
    self.list:Clear()
end

function PANEL:PerformLayout(w,h)
    self.guide:SetText(wlib.string.wrap(self.guide:GetText(), self.guide:GetFont(), self.guide:GetWide()))
end

vgui.Register('wmarket_myorders', PANEL, 'DPanel')
--addons/module_outfitter/lua/includes/modules/binfuncs.lua:
if SERVER then
	AddCSLuaFile()
end

do -- uint conversion..
	local mod   = math.fmod
	local floor = math.floor

	local function rshift(x,n)
		return floor((x%4294967296)/2^n)
	end

	local function band(x,y)
		local z,i,j = 0,1
		for j = 0,31 do
			if (mod(x,2)==1 and mod(y,2)==1) then
				z = z + i
			end
			x = rshift(x,1)
			y = rshift(y,1)
			i = i*2
		end
		return z
	end
	------------------------------------------------------------------

    local byte,char=string.byte,string.char
    to_u_int = function(i,endian)
        if type(i)~="number" then debug.Trace() error"need unsigned integer" end
        if i<0 then error"bad integer x<0" end
        if i>0xffffffff then error"bad integer x>0xffffffff" end
        return endian and char(
				band(i,255) ,
				band(rshift(i,8),255 ),
				band(rshift(i,16),255 ),
				band(rshift(i,24),255 ))
		or 	char(
				band(rshift(i,24),255 ),
				band(rshift(i,16),255 ),
				band(rshift(i,8),255 ),
				band(i,255) )
    end
    from_u_int = function(s,endian,offset)
		offset=offset and tonumber(offset) or 0
        if type(s)~="string" then error"string required" end
        --if s:len()~=4 then error"this is not a uint" end

        local b1,b2,b3,b4=
			byte(s,offset+(endian and 1 or 4)),
            byte(s,offset+(endian and 2 or 3)),
            byte(s,offset+(endian and 3 or 2)),
            byte(s,offset+(endian and 4 or 1))
        local n = b1 + b2*256 + b3*65536 + b4*16777216

       if n<0 then error"conversion failure, garry/python sucks" end
       if n>0xffffffff then error"conversion failure, garry/python sucks" end
       return n
    end

end

local d=0xFFFFFF00
local a=0x00FFFFFF
assert(from_u_int(to_u_int(a))==a)
assert(from_u_int(to_u_int(d))==d)
assert(from_u_int(to_u_int(d,true),true)==d)
assert(from_u_int(to_u_int(d,true),false)==a)

--addons/module_outfitter/lua/includes/modules/isdormant.lua:
if SERVER then
	AddCSLuaFile()
	return
end

local Tag="isdormant"

local fn=0
local function Think()
	fn = fn + 1
end

hook.Add("Think",Tag,Think)
local t={}

--for k,v in next,player.GetAll() do if not v:IsDormant() then t[v]=fn+1 end end

local t2={}
function player.InPVS()
	local i=0
	for pl,pvsfn in next,t do
		if pvsfn and pvsfn < fn then
			i=i+1
			t2[i]=pl
		end
end

	for i=i+1,#t2 do
		t2[i]=nil
	end

	return t2
end

local Player=FindMetaTable"Player"
function Player:InPVS()
	local t = t[self]
	return  t and t < fn
end

local NaN = 0/0
hook.Add("NotifyShouldTransmit",Tag,function(pl,here)
	if pl:IsPlayer() and pl~=LocalPlayer() then
		t[pl]=here and fn+1 or NaN
	end
end)

hook.Add("EntityRemoved",Tag,function(pl)
	if pl:IsPlayer() then
		t[pl]=nil
	end
end)



-- For entities
--TODO: Make one for weapons too

local Entity = FindMetaTable "Entity"
local Tag = 'EntityShouldTransmit'
local function OnShouldTransmit(ent, should, special, entlist)
	--TODO: remove
	Msg("[ShouldTransmit] ")
	print(ent, should and "IN" or "OUT", should and special and "FIRST" or (not should and special and "LAST") or "")
	local f = ent.OnShouldTransmit
	if not f then
		return
	end

	return f(ent, should, firstlast, entlist)
end

local hooked = {  }
function ents.GetTransmitList()
	return hooked
end

function ents.HookShouldTransmit(class)
	assert(class and #class > 0 and class ~= "player", "invalid class")
	local tbl = scripted_ents.GetStored(class)
	assert(tbl, "class not found (is it an engine class?)")
	local t = hooked[class]
	if not t then
		t = {  }
		for k, v in next, ents.FindByClass(class) do
			if not v:IsDormant() then
				t[v] = true
				print("HOOKING", v)
			end

		end

		hooked[class] = t
	end

	return t
end

function Entity:HookShouldTransmit()
	ents.HookShouldTransmit(self:GetClass())
end

local function assert(ok,...)
	if not ok then
		ErrorNoHalt(addn(...))
	end

	return ok
end

local prevclass
hook.Add("NotifyShouldTransmit", Tag, function(ent, inside)
	local class = ent:GetClass()
	local entlist = hooked[class]
	if not entlist then
		return
	end

	if inside then
		local is_first = not next(entlist)
		entlist[ent] = true
		OnShouldTransmit(ent, true, is_first, entlist)
	else
		assert(entlist[ent], ent, "missing")
		entlist[ent] = nil
		local is_last = not next(entlist)
		OnShouldTransmit(ent, false, is_last, entlist)
	end

end)
hook.Add("EntityRemoved", Tag, function(ent)
	local class = ent:GetClass()
	local entlist = hooked[class]
	if not entlist then
		return
	end

	entlist[ent] = nil
	local is_last = not next(entlist)
	OnShouldTransmit(ent, false, is_last, entlist)
end)

--[[
function ENT:Initialize()
	self:HookShouldTransmit()
end

function ENT:OnShouldTransmit(transmitting, firstlast, entlist)
	if not firstlast then
		return
	end

	if transmitting then
		hook.Add("Think", "myclass", function()
			for ent, _ in next, entlist do
			end

		end)
	else
		hook.Remove("Think", "myclass")
	end

end
--]]


--addons/module_outfitter/lua/includes/modules/urlimage.lua:
if SERVER then
	AddCSLuaFile() 
	return
end

module("urlimage",package.seeall)
_M._MM = setmetatable({},{__index=function(s,k) return rawget(_M,k) end,__newindex=_M})
local inDebug
function setDebug(d)
	inDebug = d
end

if _MM.getDebug then
	setDebug(getDebug())
end

function getDebug()
	return inDebug
end

function dbg(...) 
	if not inDebug then return end
	Msg"[UrlImg] "print(...) 
end

function DBG(...) Msg"[UrlImg] "print(...) end

FindMetaTable"IMaterial".ReloadTexture = function(self,name)
	self:GetTexture(name or "$basetexture"):Download()
end

-- texture parsers for real w/h
local IsPNG = string.IsPNG
if not IsPNG then require'imgparse' IsPNG = string.IsPNG end
local IsJPG = string.IsJPG
local IsVTF = string.IsVTF

local PNG = file.ParsePNG
local VTF = file.ParseVTF
local JPG = file.ParseJPG
local assert_ = assert

local assert = function(a,b)
	if a==nil and b=='nodb' then return end
	return assert_(a,b)
end

if not sql.obj then pcall(require,'sqlext') end
--
local db
function db_init()
	local _db = assert(sql.obj("urlimage"))
	assert(_db.migrate,"Please upgrade urlimage dependencies")
	
	_db=assert(_db:create([[
			`url`		TEXT NOT NULL CHECK(url <> '') UNIQUE,
			`ext`		TEXT NOT NULL CHECK(ext = 'vtf' OR ext = 'png' OR ext = 'jpg'),
			`last_used`	INTEGER NOT NULL DEFAULT 0,
			`fetched`	INTEGER NOT NULL DEFAULT (cast(strftime('%%s', 'now') as int) - 1477777422),
			`locked`	BOOLEAN NOT NULL DEFAULT 1,
			`size`		INTEGER DEFAULT 0,
			`w`			INTEGER(2) NOT NULL DEFAULT 0,
			`h`			INTEGER(2) NOT NULL DEFAULT 0,
			`fileid`	INTEGER PRIMARY KEY AUTOINCREMENT]])
		:migrate(function(db)
			db:alter("ADD COLUMN file_size INTEGER;")
		end)
		:coerce{last_used=tonumber, fileid=tonumber,w=tonumber,file_size=tonumber,h=tonumber, locked=function(l) return l=='1' end })
	local l = assert(_db:update("locked = 0 WHERE locked != 0"))

	if l>0 then dbg("unlocked entries: ",l) end
	db = _db
end

-- print(db:columns())

--  Msg"insert " 		print(assert(		db:insert{url = "http://asd.com/0", last_used = os.time()}))
--  Msg"replace " 		print(				db:insert({url = "http://asd.com/0", last_used = 1337},true))
--  Msg"insert " 		print(assert(		db:insert{url = "http://asd.com/1", last_used = os.time()-123}))
--  Msg"count " 		print(tonumber(		db:select1"count(*) as count".count))
--  Msg"Delete none " 	PrintTable(assert(	db:delete("url = %s",'derp')))
--  Msg"count " 		print(tonumber(		db:select1"count(*) as count".count))
--  Msg"list "			PrintTable(			db:select("*","WHERE URL != %s","http://asd.co"))
--  Msg"update "		PrintTable(			db:update("locked = 1 WHERE fileid=%d",123))
--  Msg"list"			PrintTable(			db:select("*","WHERE URL != %s","http://asd.co"))
--  Msg"raw"			PrintTable(assert(	db:sql1("select * from %s limit %d",db,1)))
--  Msg"Delete all " 	print(assert(		db:delete("url != %s",'derp')))
--do return end
---------------


MAX_ENTRIES = 2048
function find_purgeable()
	if not db then return nil,'nodb' end
	dbg("find_purgeable()")
	local a,b = db:select('*','WHERE locked != 1 ORDER BY last_used ASC LIMIT(select max(0,count(*) - %d) from %s)',MAX_ENTRIES,db)
	if a==true then return false end
	return a,b
end

function get_cache_info()
	if not db then return nil,'nodb' end
	return {
		
		count = tonumber(db:select('count(*) as count')[1].count or -1),
		bytes = db:select('sum(file_size) as file_size')[1].file_size or -1,
		
	}
end


--function find_oldest()
--	if not db then return nil,'nodb' end
--	dbg("find_oldest()")
--	local a,b = db:select('*','WHERE locked != 1 ORDER BY last_used ASC LIMIT(1)')
--	return a,b
--end

function update_dimensions(fileid,w,h)
	if not db then return nil,'nodb' end

	dbg("update_dimensions()",fileid,w,h)
	assert(tonumber(fileid))
	return db:update("w = %d, h=%d WHERE fileid=%d",w,h,fileid)
end
function update_size(fileid,sz)
	if not db then return nil,'nodb' end
	assert(tonumber(fileid))
	assert(tonumber(sz))

	dbg("update_size()",fileid,sz)
	return db:update("file_size = %d WHERE fileid=%d",sz,fileid)
end

function record_use(fileid,nolock)
	if not db then return nil,'nodb' end

	dbg("record_use()",fileid,nolock)
	assert(tonumber(fileid))
	nolock = nolock and "" or ", locked = 1"
	return db:update("last_used = (cast(strftime('%%s', 'now') as int) - 1477777422)"..nolock.." WHERE fileid=%d",fileid)
end

function get_record(urlid)
	if not db then return nil,'nodb' end

	dbg("get_record()",urlid)
	local record = assert(db:select1('*',isnumber(urlid) and "WHERE fileid = %d" or "WHERE url = %s",urlid))
	return record~=true and record
end

function record_validate(r)
	local err
	if not istable(r) then r,err = get_record(r) end
	dbg("record_validate()",r,r and r.url or r.fileid,err)
	if not r or not r.w or r.w==0 then return false end
	
	return r and file.Exists(FPATH(r.fileid,r.ext),'DATA') and r
end

function new_record(url,ext)
	if not db then return nil,'nodb' end

	dbg("new_record()",url,ext)
	local fileid = assert(db:insert{url = url,ext = ext})
	return fileid
end

--print(update_last_used(db:insert{url = "f"}))
--db:insert{url = "http://asd.com/1",last_used = 1}
--db:insert{url = "http://asd.com/2",ext="jpg"}
--db:insert{url = "http://asd.com/3",last_used = 3}
--db:insert{url = "http://asd.com/4"}
--Msg"list "			PrintTable(			db:select("*","WHERE URL != %s","http://asd.co"))

BASE = "cache/uimg"
file.CreateDir("cache",'DATA')
file.CreateDir(BASE,'DATA')
function FPATH(a,ext,open_as)
	--Msg(("FPATH %q %q %q -> "):format(a or "",ext or "",tostring(open_as or "")))
	if ext=="vmt" then
		a=a..'_vmt'
		ext="txt"
	end
	
	local ret =("%s/%s%s%s%s%s"):format(BASE,tostring(a),
		ext and "." or "",
		ext or "",
		open_as and "\n." or "",
		open_as or "")
	--print(ret)
	return ret
end

function ToMaterialPath(...)
	return ("../data/%s"):format(FPATH(...))
end
FPATH_R=ToMaterialPath

local generated = {}
function Material(fileid, ext, isSurface, pngParameters)
	dbg("Material()",fileid,ext,pngParameters)
	local path = ToMaterialPath(fileid,ext )
	local a,b
	
	if ext == 'vtf' or ext == 'VTF' then
		path = ToMaterialPath(fileid)
		local matid = "uimgg".. fileid .. (isSurface and "surface" or "render")
		dbg("_G.CreateMaterial()",("%q"):format(path),isSurface and "UnlitGeneric" or "VertexLitGeneric",matid)
		a,b = CreateMaterial(matid, isSurface and "UnlitGeneric" or "VertexLitGeneric", {
			["$vertexcolor"] = "1",
			["$vertexalpha"] = "1",
			["$nolod"] = "1",
			["$basetexture"] = path,
			["Proxies"] =
			{
				["AnimatedTexture"] =
				{
					["animatedTextureVar"] = "$basetexture",
					["animatedTextureFrameNumVar"] = "$frame",
					["animatedTextureFrameRate"] = 8,
				}
			}
		})
	else
		dbg("_G.Material()",("%q"):format(path),pngParameters)
		a,b = _G.Material(path,pngParameters)
	end
	
	-- should no longer be needed, if it even works
	--if a then a:ReloadTexture() end
	
	return a,b,path,matid
end

function fwrite(fileid,ext,data)
	dbg("fwrite()",fileid,ext,#data)
	local path = FPATH(fileid,ext)
	file.Write(path,data)
	return path
end
function fopen(fileid,ext)
	dbg("fopen()",fileid,ext)
	return file.Open(FPATH(fileid,ext),'rb','DATA')
end

local delete_record delete_record = function(record)
	dbg("delete_record()",record)
	if istable(record) then
		
		if next(record)==nil then return 0 end
		
		if record[1] then
			local aggr = 0
			for k,record in next,record do
				aggr = aggr + assert(delete_record(record))
			end
			return aggr
		else
			return delete_record(record.fileid or record.fileid)
		end
	elseif isnumber(record) then
		if not db then return nil,'nodb' end
		return db:delete('fileid = %d',record)
	elseif isstring(record) then
		if not db then return nil,'nodb' end
		return db:delete('url = %s',record)
	else error"wtf" end
end

function delete_fileid(fileid,ext)
	dbg("delete_fileid()",fileid,ext)
	
	local deleted = false
	local function D(path,place)
		if file.Exists(path,place) then
			deleted = true
			file.Delete(path,place)
			return deleted
		end
	end
	
	if ext then
		D(FPATH(fileid,ext),'DATA')
	end
	D(FPATH(fileid,'vmt'),'DATA')
	D(FPATH(fileid,'jpg'),'DATA')
	D(FPATH(fileid,'png'),'DATA')
	D(FPATH(fileid,'vtf'),'DATA')
	
	return deleted
end



function data_format(bytes)
	if 		IsJPG(bytes) then return 'jpg'
	elseif 	IsPNG(bytes) then return 'png'
	elseif 	IsVTF(bytes) then return 'vtf'
	end
	dbg("data_format()","FAILURE",("%q"):format(bytes))
end

local mw,mh = 	render.MaxTextureWidth(),render.MaxTextureHeight()
mw=mw>2048 and 2048 mh=mh>2048 and 2048
function read_image_dimensions(fh,fmt)
	dbg("read_image_dimensions()",fh,fmt)
	local reader = fmt=='png' and PNG or fmt=='jpg' and JPG or fmt=='vtf' and VTF
	if not reader then return nil,'No reader for format: '..tostring(fmt) end
	
	local w,h
	local t = reader(fh)
	
	w = t.width
	h = t.height
	if not w or not h then
		return nil,'invalid file'
	end
	if w>mw or h>mh then
		return nil,'excessive dimensions'
	end
	return w,h
end

function record_to_material(r, data, isSurface)
	dbg("record_to_material()",r and r.fileid)
	if not r.used then
		assert(record_use(r.fileid))
		r.used = true
	end
	return Material(r.fileid, r.ext, isSurface, data), r.w, r.h
end

local function remove_error(cached,...)
	cached.error = nil
	return ...
end

cache = _MM.cache or {}
local cache = cache

fastdl_override = false
local fastdl = GetConVarString"sv_downloadurl":gsub("/$","")..'/'
function GetFastDL()
	return fastdl_override or fastdl
end

function FixupURL(url)
	if not url:sub(3,10):find("://",1,true) then
		url = GetFastDL()..url
	else

		url = url:gsub([[^http%://onedrive%.live%.com/redir?]],[[https://onedrive.live.com/download?]])
		url = url:gsub( "github.com/([a-zA-Z0-9_]+)/([a-zA-Z0-9_]+)/blob/", "github.com/%1/%2/raw/")

		if url:find("dropbox",1,true) then
			url = url:gsub([[^http%://dl%.dropboxusercontent%.com/]],[[https://dl.dropboxusercontent.com/]])
			url = url:gsub([[^https?://www.dropbox.com/s/(.+)%?dl%=[01]$]],[[https://dl.dropboxusercontent.com/s/%1]])
		end

	end
	
	return url
end



function URLFetchHead(url,cb,headers)
	HTTP{
		url			= url,
		method		= "HEAD",
		parameters = headers,
		success = function( code, body, headers )
			cb(code==200 and assert(headers) or nil,code,headers,body)
		end,
		failed = function( reason )
			cb(nil,reason)
		end
	}
end
function HeadContentSize(t)
	return t['Content-Length']
end



local n = URLIMAGE_EMERGENCY_UID or (10000-1)
local function get_uid()
	n = n + 1
	URLIMAGE_EMERGENCY_UID = n
	DBG("Emergency UID",n)
	return n
end
-- Returns: mat,w,h
-- Returns: false = processing, nil = error
function GetURLImage(url, data, isSurface)
	
	url = FixupURL(url)
	
	local cached = cache[url]
	if cached then
		if cached.processing then
			return false
		elseif cached.error then
			return nil,cached.error
		elseif cached.record then
			return record_to_material(cached.record, data, isSurface)
		else
			cached.error = "invalid cache state"
			error(cached.error)
		end
	end
	
	-- find if record exists --
	
	cached = {error = "failure"}
	cache[url] = cached
	
	local cached_record = get_record(url)
	if cached_record then
		
		assert(next(cached_record)~=nil)
		
		if record_validate(url) then
			record_use(cached_record.fileid)
			cached.record = cached_record
			return remove_error(cached, record_to_material(cached_record, data, isSurface) )
		else
			DBG("INVALID RECORD","DELETING",url)
			assert(delete_record(url))
		end
	end
	
	-- it's a new url --
	dbg("Fetching",url)
	
	local function fail(err)
		delete_record(url)
		cached.processing = false
		cached.error = tostring(err)
		dbg("Fetch failed for",url,": "..cached.error)
	end
	
	local function fetched(data,len,hdr,code)
		
		dbg("fetched()",url,string.NiceSize(len),code)
		
		if code~=200 then
			return fail(code)
		end
		if len<=8 or len>1024*1024*25 then -- 26MB
			return fail'invalid filesize'
		end
		
		local ext = data_format(data)
		if not ext then
			return fail'unknown format'
		end
		
		-- build a new record --
		
		local fileid = assert(new_record(url,ext))
		local nodb
		
		if not fileid then 
			nodb = true
			fileid = get_uid()
		end
		
		assert(fileid)
		
		local record = {fileid = fileid}
		
		fwrite(fileid,ext,data) data = nil
		local fh = fopen(fileid,ext)
		
		local w,h = read_image_dimensions(fh,ext)
		fh:Close()
		if not w then return fail(h) end
		
		if not nodb then
			assert(update_dimensions(fileid,w,h))
			assert(update_size(fileid,len))
				
			-- We don't have to build the record manually, we can just get it again
			record = assert(get_record(url))
			
			assert(record)
			
			cached.record = record
			
		else
			record.url = url
			record.ext = 		ext
			record.last_used = 	os.time()
			record.fetched = 	os.time()
			record.locked = 	true
			record.w = 	w
			record.h = 		h
			record.fileid = fileid
			cached.record = record
		end
	
		if not record_validate(cached.record) then
			return fail'record_validate()'
		end
			
		if not nodb then
			-- we now have some sort of record, so let's use it so it's top of LRU
			record_use(fileid,true) -- maybe remove?
		end
			
		cached.processing = false
		remove_error(cached)
		
		
	end
	URLFetchHead(url,function(h,err)
		if h then
			local sz = HeadContentSize(h)
			if sz and tonumber(sz) then
				
				if tonumber(sz)>15*1000*1000 then
					return fail'filesize'
				end
			end
		else
			dbg("Head query failed",err)
		end
		http.Fetch(url,fetched,fail)	
	end)
	
	cached.processing = true
	
	return false
	
end

local lastFrameCalled = -1
local frameCount
local IKNOWWHATIMDOING=false
local errored = false

function SuppressSanityChecks(s)
	IKNOWWHATIMDOING = s ~= false
end

function URLImage(url, data)
	local fn = FrameNumber()
	if lastFrameCalled == fn - 1 then
		frameCount=frameCount+1
		if frameCount > 18 then
			if not errored then
				errored = true
				if not IKNOWWHATIMDOING then 
					ErrorNoHalt("URLImage called every frame, you must keep a reference to the result of URLImage, url="..tostring(url))
					debug.Trace()
				end
			end
		end
	
	elseif lastFrameCalled ~= fn then
		frameCount = 0
	end
	lastFrameCalled=fn
	
	local mat,w,h = GetURLImage(url, data, true)
	dbg("URLImage",fn,url,mat,w)
	
	local function setmat()
		surface.SetMaterial(mat)
		return w,h, mat
	end
	
	if mat then
		dbg("URLImage",url,"instant mat",mat)
		return setmat
	end
	
	local trampoline trampoline = function()
		mat,w,h = GetURLImage(url, data, true)
		if not mat then
			if mat==nil then
				trampoline = function() return mat,w,h end
				DBG("URLImage failed for ",url,": ",w,h)
			end
			
			return mat
		end
		trampoline = setmat
		return setmat()
	end
	
	local function return_trampoline()
		return trampoline()
	end
	return return_trampoline
end

local WTF=wlib.func.blank

-- Only start downloading when first called
function LazyURLImage(url, data)
	local cb 
	cb = function(...)
		cb = WTF
		cb = surface.URLImage(url, data)
		return cb(...)
	end
	return function(...)
		return cb(...)
	end
end
local lastFrameCalled = -1
local frameCount
local errored = false

function URLMaterial(url, data)
	local fn = FrameNumber()
	if lastFrameCalled == fn - 1 then
		frameCount=frameCount+1
		if frameCount > 18 then
			if not errored then
				errored = true
				if not IKNOWWHATIMDOING then 
					ErrorNoHalt("URLMaterial called every frame, you must keep a reference to the result of URLMaterial, url="..tostring(url))
					debug.Trace()
				end
			end
		end
	elseif lastFrameCalled ~= fn then
		frameCount = 0
	end
	lastFrameCalled=fn
	
	
	local mat,w,h = GetURLImage(url, "vertexlitgeneric " .. (data or ""), false)
	local function setmat()
		render.SetMaterial(mat)
		return w,h, mat
	end
	
	if mat then
		dbg("URLImage",url,"instant mat",mat)
		return setmat
	end
	
	local trampoline trampoline = function()
		mat,w,h = GetURLImage(url, "vertexlitgeneric " .. (data or ""), false)
		if not mat then
			if mat==nil then
				trampoline = function() return mat,w,h end
				DBG("URLMaterial failed for ",url,": ",w,h)
			end
			
			return mat
		end
		trampoline = setmat
		return setmat()
	end
	
	local function return_trampoline()
		return trampoline()
	end
	return return_trampoline
	
end

surface.URLImage = URLImage
surface.LazyURLImage = LazyURLImage
render.URLMaterial = URLMaterial

function do_purge()
	--TODO: Purge
	local purgeables = find_purgeable()
	if not purgeables or purgeables == true or #purgeables == 0 then return end
	local purgestart = SysTime()

	for _, purgeable in next, purgeables do
		if not delete_fileid(purgeable.fileid) then
			dbg("already deleted?", table.ToString(purgeable))
		end

		if not delete_record(purgeable.url) then
			DBG("Could not delete", table.ToString(purgeable))
		end
	end

	local purgelen = SysTime() - purgestart
	DBG("Images purged: ", #purgeables, ". took ", math.Round(purgelen*1000), "ms")
end

local ok,err = xpcall(db_init,debug.traceback)

if not ok then
	ErrorNoHalt(err..'\n')
end


local ok2,err2 = xpcall(do_purge,debug.traceback)

if not ok2 then
	ErrorNoHalt(err2..'\n')
end

function GetStartupFailure()
	return not ok and (err or "Unknown")
end

do return end

local test1 = surface.URLImage "materials/silk_icon_flags.png?b=cdq"
local test2 = surface.URLImage "http://g1.metastruct.net:2095/jpg.jpg?c=dqd"
local test3 = surface.URLImage "http://g1.metastruct.net:2095/vtf.vtf?c=qdq"
hook.Add("DrawOverlay","a",function()
	surface.SetDrawColor(255,255,255,255)
 
	local w,h = test1()
	if w then
		--print(w)
		surface.DrawTexturedRect(0,0,w,h)
	end
	local w1,h1 = test2()
	if w1 then
		surface.DrawTexturedRect(1+(w or 0),0,w1,h1)
	end
	local w2,h2 = test3()
	if w2 then
		surface.DrawTexturedRect(2+(w or 0)+(w1 or 0),0,w2,h2)
	end
end)
 

--addons/module_outfitter/lua/outfitter/sh.lua:
local Tag = 'outfitter'
module(Tag, package.seeall)
local outfitter_sv_distance = CreateConVar("outfitter_sv_distance", "1", {FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY})

function ServerSuggestDistance()
	return outfitter_sv_distance:GetBool()
end

-- Shared Utils
function UrlToWorkshopID(url,numok)
	if not url or not isstring(url) then return end
	

	local ret = url:match'://steamcommunity.com/sharedfiles/filedetails/.*[%?%&]id=(%d+)' or url:match'://steamcommunity.com/workshop/filedetails/.*[%?%&]id=(%d+)'
	if ret then return ret end
	if numok and tonumber(url:Trim()) then
		local num = tonumber(url:Trim())
		if num and num>1337 then return num end
	end
end

function HasMDL(mdl)
	mdl = mdl:gsub("%.mdl$", "")

	return file.Exists(mdl .. '.mdl', 'GAME')
end

function SanityCheckNData(mdl, download_path)
	if not mdl then return false end
	if not download_path then return false end
	if mdl == "" or #mdl > 2048 * 2 then return false end
	if mdl:find("  ", 1, true) or mdl:find("..", 1, true) or mdl:find("\t", 1, true) or mdl:find("\n", 1, true) then return false end

	if tonumber(download_path) then
		if tonumber(download_path) <= 0 then return false end
	else
		if not IsHTTPURL(download_path) then return false end
	end

	return nil
end

-- Find player by userid
function findpl(uid)
	for _, pl in player.Iterator() do
		if pl:UserID() == uid then return pl end
	end
end

-- Encodes the shared payload to be sent to everyone: {model_path,25293523 or "https://example.com/asd.gma" or false}
function EncodeOutfitterPayload(model_path, download_path)
	local encoded = model_path and download_path and util.TableToJSON({assert(model_path:find(".mdl", 2, true) and model_path, 'invalid path: ' .. tostring(model_path)), tostring(download_path) or false}) or nil

	return encoded and #encoded < 32000 and encoded
end

function IsHTTPURL(str)
	return tostring(str or ""):find"^https?://.*/" and true or false
end

-- Decodes the shared payload
function DecodeOutfitterPayload(encoded)
	if not encoded or #encoded == 0 then return nil, 'empty' end
	local decoded = util.JSONToTable(encoded)
	if not decoded then return nil, err or 'json parsing failed' end
	local model_path = decoded[1]
	local download_path = decoded[2]
	if not model_path then return nil, 'empty' end
	model_path = tostring(model_path)
	if not model_path:find("%.mdl$") and not model_path:lower():find("%.mdl$") then return nil, 'not a .mdl' end
	
	-- either workshop id or a http url
	if download_path == nil then return nil, 'empty' end
	if not tonumber(download_path) and not download_path:find"^https?://.*/" and download_path ~= false then return nil, 'invalid' end

	return model_path, download_path
end

-- legacy
EncodeOW = EncodeOutfitterPayload
DecodeOW = DecodeOutfitterPayload

net.Receive(Tag, function(...)
	if this.OnReceive then
		OnReceive(...)
	end
end)

-- parse model from file
function MDLIsPlayermodel(f, sz)
	local mdl, err, err2 = mdlinspect.Open(f)
	if not mdl then return nil, err, err2 end
	if mdl.version < 44 or mdl.version > 49 then return false, "bad model version" end
	local ok, err = mdl:ParseHeader()
	if not ok then return false, err or "hdr" end
	if not mdl.bone_count or mdl.bone_count <= 2 then return false, "nobones" end

	if sz then
		local valid, err = mdl:Validate(sz)

		if not valid then
			dbg("MDLIsPlayermodel", f, "validate error", err)

			return false, "valid"
		end
	end

	--print(mdl,mdl.bodypart_count,mdl.skinreference_count)
	local found = false
	local imdls = mdl:IncludedModels()
	
	if mdl.bonecontroller_count ~= mdl.bone_count then
		--dbg("bonecontroller_count differs?!",mdl.bonecontroller_count,mdl.bone_count)
	end
	
	local found
	local found_anm
	for k,v in next,imdls do
		v=v[2]
		
		if v and v:find("_arms_",1,true) then
			return false,"arms"
		end
		
		if v and not v:find"%.mdl$" then
			return false,"badinclude",v
		end
		if v=="models/m_anm.mdl" or v=="models/f_anm.mdl" or v=="models/z_anm.mdl" then
			found_anm = true
		end
		--if v
		--	and v:find"%.mdl$"
		--	and (
		--		v:find("anim",1,true)
		--		or v:find('/m_',1,true)
		--		or v:find('/f_',1,true)
		--		or v:find('/cs_',1,true) )
		--then
		--	found = true
		--	break
		--end
	end
	
	local attachments = mdl:Attachments()
	if not attachments or not next(attachments) then
		if not found_anm then
			--PrintTable(mdl:Attachments())
			if not IsUnsafe() then
				return false,"noattachments"
			end
		else
			dbg("MDLIsPlayermodel",mdl.name,"no attachments but included")
		end
	else
		--PrintTable("ASD",mdl:BoneNames())
		local found
		for k,v in next,attachments do
			local name = v[1]
			--print(name)
			if name=="eyes" or name=="anim_attachment_head" or name=="mouth" or name=="anim_attachment_RH" or name=="anim_attachment_LH" then found=true break end
		end
		if not found then
			if not found_anm then
				--PrintTable(mdl:Attachments())
				if not IsUnsafe() then
					return false,"attachments"
				end
			else
				dbg("MDLIsPlayermodel",mdl.name,"no attachments but included")
			end
		end
		
	end
	-- UNDONE: guess why
	--if not found then
	--	return false,"includemdls"
	--end
	--UNDONE: Bones are named all over the place
	--local bname = mdl:BoneNames() [1]
	--if not bname or (	not bname:lower():find("pelvis",1,true)
	--					and bname~="Root"
	--					and bname~="pelvis"
	--					and bname~="hip"
	--					and bname~="root")
	--then
	--	return false,"bones",bname
	--end

	return true, found_anm
end

local badbones = {
	["valvebiped.bip01_r_foot"] = true,
	["valvebiped.bip01_head1"] = true,
	["valvebiped.bip01_head"] = true
}

local spines = {
	["valvebiped.bip01_spine4"] = true,
	["valvebiped.bip01_spine3"] = true,
	["valvebiped.bip01_spine2"] = true,
	["valvebiped.bip01_spine1"] = true
}

local findone = {
	["valvebiped.bip01_r_clavicle"] = true,
	["valvebiped.bip01_r_upperarm"] = true,
	["valvebiped.bip01_r_forearm"] = true,
	["valvebiped.bip01_r_hand"] = true,
	["valvebiped.bip01_l_hand"] = true
}

-- parse model from file
function MDLIsHands(f, sz)
	local mdl, err, err2 = mdlinspect.Open(f)
	if not mdl then return nil, err, err2 end
	if mdl.version < 44 or mdl.version > 49 then return false, "version" end
	local ok, err = mdl:ParseHeader()
	if not ok then return false, err or "hdr" end
	if not mdl.bone_count or mdl.bone_count <= 2 then return false, "nobones" end

	if sz then
		local valid, err = mdl:Validate(sz)

		if not valid then
			dbg("MDLIsHands", f, "validate error", err)

			return false, "valid"
		end
	end

	--print(mdl,mdl.bodypart_count,mdl.skinreference_count)
	local found = false
	local imdls = mdl:IncludedModels()
	--TODO: include stuff or have animations (seqs)
	local found_anm

	for k, v in next, imdls do
		v = v[2]
		if v == "models/m_anm.mdl" then return false, "player" end
		--print("----------------",v)
		if v and not v:find"%.mdl$" then return false, "badinclude", v end

		if v:find("/c_arms_", 1, true) then
			found_anm = true
		end
	end

	local bonenames = mdl:BoneNames()
	local hadspine
	local gotone

	for _, name in next, bonenames do
		name = name:lower()
		--print(name)
		local isspine = spines[name]

		if isspine then 
			if hadspine then
				--return false,'bones',name
			end 
			hadspine = true
		end

		
		gotone = gotone or findone[name]
		if badbones[name] then return false, 'bones', name end
	end

	if not gotone or not hadspine then return false, 'bones' end
	local attachments = mdl:Attachments()

	if attachments and next(attachments) then
		for k, v in next, attachments do
			local name = v[1]
			--print(name)
			if name == "eyes" or name == "anim_attachment_head" or name == "mouth" then return false, "player" end
		end
	end

	return true
end

--[[
local fp ="models/player/"
local flist = file.Find(fp..'*.mdl','GAME')
-- flist = {'matress.mdl'}

for _,fn in next,flist do

	local fpath = fp..fn
	local f = file.Open(fpath,'rb','GAME')
	print(('%50s'):format(fn),MDLIsPlayermodel(f))
	f:Close()
	
end--]]
local t = {"", "", "", ""}

local function GenID(_1, _2, _3, _4, _5)
	if not _1 then return end
	t[1] = _1
	t[2] = tostring(_2)
	t[3] = tostring(_3)
	t[4] = tostring(_4)
	assert(not _5)

	return table.concat(t, "|")
end

local Player = FindMetaTable"Player"

function Player.OutfitHash(pl)
	return pl.outfitter_latest
end

function Player.OutfitUpdateHash(pl)
	local hash = GenID(pl:OutfitInfo())
	pl.outfitter_latest = hash

	return hash
end

function Player.OutfitCheckHash(pl, nhash)
	local cur = pl:OutfitHash()
	cur = cur or false
	nhash = nhash or false

	return cur == nhash
end

function Player.OutfitInfo(pl)
	return pl.outfitter_mdl, pl.outfitter_download_path, pl.outfitter_skin, pl.outfitter_bodygroups
end

function Player.OutfitSetInfo(pl, mdl, download_path, skin, bodygroups)
	pl.outfitter_mdl = mdl
	pl.outfitter_download_path = download_path
	pl.outfitter_skin = skin
	pl.outfitter_bodygroups = bodygroups
	pl:OutfitUpdateHash()
end

local function filt(ok, err, ...)
	if not ok then
		ErrorNoHalt(err .. '\n')

		return nil
	end

	return err, ...
end

function SafeRunHook(...)
	return filt(xpcall(hook.Run, debug.traceback, ...))
end

--- Crashing code detector thingy
--TODO: Stack, blacklist of files
function InitCrashSys()
	local Tag = Tag .. '_blacklist'
	local CrashingTagk = Tag .. 'ing2k'
	local CrashingTagv = Tag .. 'ing2v'

	local function SAVE(t)
		local s = json.encode(t)
		util.SetPData("0", Tag, s)
	end

	local function LOAD()
		local s = util.GetPData("0", Tag, false)
		if not s or s == "" or s == "nil" then return {} end
		local ok,t = pcall(json.decode,s)
		if not ok or not t then return {} end

		return t
	end

	local crashlist = LOAD() or {}

	function GetCrashList()
		return crashlist
	end

	local function SaveList()
		SAVE(crashlist)
	end

	if CLIENT then
		concommand.Add(Tag .. "_clear", function()
			local n = table.Count(crashlist)
			table.Empty(crashlist)
			SAVE()
			chat.AddText("Cleared blacklist (had " .. n .. ")")
		end)

		concommand.Add(Tag .. "_dump", function()
			PrintTable(crashlist)
		end)
	end

	function DidCrash(key, val)
		if IsUnsafe() or not AutoblacklistEnabled() then return false end
		local t = crashlist[key]

		return t and t[val]
	end

	function CRITICAL(a, b)
		util.SetPData("0", CrashingTagk, a or "")
		if not a or a == "" then return end
		util.SetPData("0", CrashingTagv, b)
	end

	-- check for crashes
	local key = util.GetPData("0", CrashingTagk, false)
	if not key or key == "" then return end
	local val = util.GetPData("0", CrashingTagv, "")
	local err = ("[%s] CRASH: %s on %q\n"):format(Tag, tostring(key), tostring(val))
	local t = crashlist[key]

	if not t then
		t = {}
		crashlist[key] = t
	end

	local curval = t[val]
	t[val] = (t[val] and tonumber(t[val]) or 0) + 1
	SaveList()
	SetFailsafe()

	util.OnInitialize(function()
		ErrorNoHalt(err)
	end)
end

if CLIENT then
	InitCrashSys()
end

function MakeURLDownloadable(url)
	url = url:Trim()

	if url:find("dropbox", 4, true) then
		url = url:gsub([[^http%://dl%.dropboxusercontent%.com/]], [[https://dl.dropboxusercontent.com/]])
		url = url:gsub([[^https?://dl.dropbox.com/]], [[https://www.dropbox.com/]])
		url = url:gsub([[^https?://www.dropbox.com/s/(.+)%?dl%=[01]$]], [[https://dl.dropboxusercontent.com/s/%1]])
		url = url:gsub([[^https?://www.dropbox.com/s/(.+)$]], [[https://dl.dropboxusercontent.com/s/%1]])
	end

	if url:find("drive.google.com", 4, true) and not url:find("export=download", 4, true) then
		local id = url:match("https://drive.google.com/file/d/(.-)/") or url:match("https://drive.google.com/file/d/(.-)$") or url:match("https://drive.google.com/open%?id=(.-)$")
		if id then return "https://drive.google.com/uc?export=download&id=" .. id end
	end

	if url:find("gitlab.com", 1, true) then
		url = url:gsub("^(https?://.-/.-/.-/)blob", "%1raw")
	end

	url = url:gsub([[^http%://onedrive%.live%.com/redir?]], [[https://onedrive.live.com/download?]])
	url = url:gsub("pastebin%.com/([a-zA-Z0-9]*)$", "pastebin.com/raw.php?i=%1")
	url = url:gsub("github%.com/([a-zA-Z0-9_]+)/([a-zA-Z0-9_]+)/blob/", "github.com/%1/%2/raw/")

	return url
end
--addons/module_outfitter/lua/outfitter/gui_bodygroups.lua:
local Tag='outfitter'

-- lua_openscript_cl srv/outfitter/lua/outfitter/ui.lua;lua_openscript_cl srv/outfitter/lua/outfitter/gui.lua;outfitter_open

module(Tag,package.seeall)



local PANEL={}
function PANEL:Init()
	self:SetSize(24,24)
	--self:Dock(RIGHT)
end

local CCHECKED = Color(111,255,111,255)
local CNORMAL  = Color(66,66,66,255)
local CBG  = Color(30,30,30,255)
function PANEL:Paint(w,h)
	if self.checked then
		surface.SetDrawColor(100,255,100,255)
	else
		surface.SetDrawColor(150,150,150,255)
	end
	draw.RoundedBox(h*0.5,0,0,h,h,CBG)
	draw.RoundedBox(h*0.5,1,1,h-2,h-2,self.checked and CCHECKED or CNORMAL)
	surface.SetFont"BudgetLabel"
	local txt = self.letter or ""
	local tw,th = surface.GetTextSize(txt)
	surface.SetTextColor(255,255,255,255)
	surface.SetTextPos(-tw*.5+h*.5,h*.5-th*.5)
	surface.DrawText(txt)
end

function PANEL:OnMouseReleased()
	self:GetParent():SetChecked(self.n)
end

function PANEL:SetChecked(checked)
	self.checked = checked
end

function PANEL:PerformLayout()
	--self:SetSize(16,16)
	--self:SetWide(self:GetTall())
end

local radiobtn=vgui.RegisterTable(PANEL,"EditablePanel")




local PANEL={}
function PANEL:Init()
	self.lbl = vgui.Create('DLabel',self,'description')
	--self.lbl:Dock(FILL)
	self.lbl:SetTextColor(Color(255,255,255,255))
	self.lbl:SetFont("BudgetLabel")	
	self:SetSpaceX( 2 )
	self:SetSpaceY( 2 )
	self:SetBorder( 2 )
	
	self.lbl:SetText"Radio buttons tester"
	--self:SetLayoutDir( LEFT )
	self.lbl.Paint=function(self,w,h)
		self:NoClipping(false)
	end
end

function PANEL:OnSelected(n,pnl)
	print(self,"OnSelected",n,pnl)
end

function PANEL:SetText(t)
	self.lbl:SetText(t)
	self.lbl:SizeToContents()
	self.lbl:SetContentAlignment(5)
	self.lbl:SetWide(8+self.lbl:GetWide())
	self.lbl:SetTooltip(t)
	
	self:InvalidateLayout()
	
end

function PANEL:AddOption(description,letter)
	self.n=self.n or 0
	self.n=self.n + 1
	local n = self.n
	
	local pnl = vgui.CreateFromTable(radiobtn,self,'radiolist')
	pnl.n=n
	pnl.letter = letter
	
	pnl:SetTooltip(description)
	pnl.d = description:sub(1,1)
	pnl:DockMargin(n>1 and 2 or 1,1,1,1)

	self.radios=self.radios or {}
	self.radios[n]=pnl
	return n,pnl
end


--function PANEL:Think()
--end

function PANEL:SetChecked(n)
	for k,v in next,self.radios do
		v:SetChecked(k==n)
	end
	self:OnSelected(n)
end

--function PANEL:PerformLayout()
--	self:SizeToChildren(true,true)
--end



vgui.Register('OFRadioBatton',PANEL,"DIconLayout")


 
 

local vgui = GetVGUI()
 
 
 
 
 

local PANEL={}
function PANEL:Init()
end

function PANEL:Think()
end

function PANEL:Clear()
	for k,v in next,self:GetChildren() do v:Remove() end
end

function PANEL:Refresh()
	self:Clear()
	dbg("self.model")
	local a = mdlinspect.Open(self.model)
	a:ParseHeader()
	local parts = a:BodyPartsEx()
	self.parts = parts

	self.skins = a:ParseSkins()

	self:CreatePanels()	
	self:InvalidateLayout()
end

function PANEL:UpdateBG()
	local t = {}
	for k,v in next,self.parts do
		if v.n then
			t[#t+1] = ("%s=%s"):format(v.name,v.n)
		end
	end
	
	RunConsoleCommand("outfitter_bodygroups_set",table.concat(t,","))
end

function PANEL:OnSelected(part,n)
	part.n=n
	self:UpdateBG()
end

function PANEL:CreatePanels()


	-- skin
	local r = self:Add("OFRadioBatton")
	r.OnSelected=function(r,setskin_id) 
		RunConsoleCommand("outfitter_skin_set",tostring(setskin_id))
		LocalPlayer().outfitter_skin = setskin_id
	end
	
	r:SetText("#skin")
	r:Dock(TOP)
	r:SizeToContents()

	for id,skindata in pairs(self.skins) do
		r:AddOption(skindata[1][1],tostring(id-1))
	end
	
	r:SetChecked(LocalPlayer().outfitter_skin or 1)

	local divider = self:Add("EditablePanel")
	divider:SetSize(1,16)
	divider:Dock(TOP)
	-- bodygroups
	local activeBodyGroups = LocalPlayer().outfitter_bodygroups or {}
	
	for k,part in next,self.parts do
		
		
		if #part.models<2 then continue end
		
		local r = self:Add("OFRadioBatton")
		r.OnSelected=function(r,n) self:OnSelected(part,n-1) end
		
		r:SetText(part.name:gsub("%.smd$","")
							:gsub("([a-z0-9])([A-Z])([a-z])",
								function(q,a,b) 
									return q..' '..a:lower()..b 
								end)
							:gsub("[_%.%-]"," ")
							:gsub("(%s)%s*","%1"))
		r:Dock(TOP)
		--r:SizeToContents()
		local n=0
		for k,partmdl in next,part.models do
			local name = partmdl.name
							:gsub("%.smd$","")
							:gsub("([a-z0-9])([A-Z])([a-z])",
								function(q,a,b) 
									return q..' '..a:lower()..b 
								end)
							:gsub("[_%.%-]"," ")
							:gsub("(%s)%s*","%1")
			name = name=="" and "" or name
			if name~="" then
				n=n+1
			end
			local n,pnl = r:AddOption(name=="" and "disable" or name,name=="" and "" or n)
			if name=="" then
				pnl:SetZPos(-10)
			end
		
		end
		
		r:SetChecked((activeBodyGroups[part.name] or 0)+1)
	end



end


function PANEL:SetModel(mdl)
	self.model = mdl
	self:Refresh()
end

function PANEL:PerformLayout()
	self:SizeToChildren(false,true)
end



bodygroups_factor=vgui.RegisterTable(PANEL,"EditablePanel")



function GUIOpenBodyGroupOverlay(owner,mdl)
	if not mdl then
		local l = UIGetMDLList()
		if not l then return end
		--print(l)
		local chosen = UIGetChosenMDL()
		if not chosen then return false end
		--print(chosen)
		mdl = l[chosen]
		if not mdl then return false end
		mdl = mdl.Name
		
		if not mdl then return false end
		if not file.Exists(mdl,'workshop') and not file.Exists(mdl,'GAME') then return false end
	end
	
	dbg("GUIOpenBodyGroupOverlay",mdl)
	
	local frame=vgui.Create('DFrame',nil,'bodygroups selector')
	frame:SetDraggable( false )
	frame:SetSizable( false )
	frame:SetScreenLock( true )
	frame:SetDeleteOnClose( true )
	frame:SetTitle( "Bodygroup and skin selector" )
	frame:ShowCloseButton(false)
	frame:SetIcon('icon16/group_edit.png')
	frame.pnlOwner = owner
	frame:MakePopup()
	frame:RequestFocus()
	function frame:Think()
		if not self.fframe then self.fframe=true return end
		
		if not self:IsActive() then print"noactive" self:Remove() return end
		if self.pnlOwner and (not self.pnlOwner:IsValid() or not self.pnlOwner:IsVisible()) then self:Remove() print"noparent" return end
		local x,y = self:GetPos()
		
		local w,h = self:GetSize()
		local sw,sh =ScrW(),ScrH()
		local nx,ny = (x+w)>sw and (sw-w) or x,
					  (y+h)>sh and (sh-h) or y
		if x~=nx or y~=ny then
			self:SetPos(nx,ny)
		end
	end
	

	local W,H=250,400 -- TODO: Autoscale GUI
	frame:SetSize(W,H)
	frame:SetPos(gui.MousePos())
	timer.Simple(60,function() 
		if IsValid(frame) then frame:Remove() end
	end)
	 
	local scrollpanel=vgui.Create('DScrollPanel',frame)
	scrollpanel:Dock(FILL)
	
	local bodygrouper=vgui.CreateFromTable(bodygroups_factor,scrollpanel)
	bodygrouper:Dock(TOP)
	bodygrouper:SetModel(mdl)
	return true
end


 
--GUIOpenBodyGroupOverlay()
--addons/module_wayban/lua/autorun/permaban_init.lua:
if SERVER then
    AddCSLuaFile('permaban/shared.lua')
    AddCSLuaFile('permaban/client.lua')

    include('permaban/shared.lua')

    include('permaban/server.lua')
else
    include('permaban/shared.lua')
    include('permaban/client.lua')
end
--addons/module_wayban/lua/permaban/shared.lua:
WayBan = {}

WayBan.config = {
    userGroups = {
        ['Trusted'] = true,
        ['WayZer Team'] = true,
        ['superadmin'] = true,
    },
    banCooldown = 2,
    defaultReason = 'Без причины',
    consoleName = 'Console',
    unknown = 'Неизвестно',
}
--addons/module_logs/lua/plogs_cfg.lua:
--
-- General configs
--

-- The chat command to open the menu, (DO NOT ADD A ! or /, it does this for you)
plogs.cfg.Command = 'blogs'

-- User groups that can access the logs.
plogs.cfg.UserGroups = {
	['owner'] 		= true,
	['superadmin'] 	= true,
	['admin'] 		= true,
	['Curator'] 	= true,
	['Sponsor'] 	= true,
	['moder'] 	    = true,
	['DAdmin'] 		= true,
    ['Patron']      = true,
	['DModerator']  = true,
	['Helper'] 		= true,
	['Sponsor'] 	= true,
	['DSAdmin'] 	= true,
	['+Helper'] 	= true,
	['Trusted']     = true,
	['WayZer Team'] = true,
	['Eventer']     = true,
	['+Eventer']    = true,
}
-- User groups that can access IP logs
plogs.cfg.IPUserGroups = {
	['superadmin']		= true,
}

-- Window width percentage, I recomend no lower then 0.75
plogs.cfg.Width = 0.75

-- Window height percentage, I recomend no lower then 0.75
plogs.cfg.Height = 0.75

-- Some logs print to your client console. Enable this to print them to your server console too
plogs.cfg.EchoServer = false

-- Allow me to use logs on your server. (Disable if you're paranoid)
plogs.cfg.DevAccess = false

-- Do you want to store IP logs and playerevents? If enabled make sure to edit plogs_mysql_cfg.lua!
plogs.cfg.EnableMySQL = true

-- The log entry limit, the higher you make this the longer the menu will take to open.
plogs.cfg.LogLimit = 200

-- Format names with steamids? If true "aStoned(STEAMID)", if false just "aStoned"
plogs.cfg.ShowSteamID = true

-- Enable/Disable log types here. Set them to true to disable
plogs.cfg.LogTypes = {
	['chat'] 		= false,
	['commands']	= false,
	['connections'] = false,
	['kills'] 		= false,
	['props'] 		= false,
	['tools'] 		= false,
	['darkrp'] 		= false,
	['ulx']			= true,
	['maestro']		= true,
	['pnlr']		= true, -- NLR Zones					|| 	https://scriptfodder.com/scripts/view/583
	['lac']			= true, -- Leys Serverside AntiCheat 	|| 	https://scriptfodder.com/scripts/view/1148
	['awarn2']		= true, -- AWarn2 						||	https://scriptfodder.com/scripts/view/629
	['hhh']			= true, -- HHH 							||	https://scriptfodder.com/scripts/view/3
	['hitmodule']	= true, -- Hitman Module				||	https://scriptfodder.com/scripts/view/1369
	['cuffs'] 		= true, -- Hand Cuffs 					||	https://scriptfodder.com/scripts/view/910
}


--
-- Specific configs, if you disabled the log type that uses one of these the config it doesn't matter
--

-- Command log blacklist, blacklist commands here that dont need to be logged
plogs.cfg.CommandBlacklist = {
	['_sendDarkRPvars']		     = true,
	['_sendAllDoorData']	     = true,
	['ulib_update_cvar']	     = true,
	['ulib_cl_ready'] 		     = true,
	['_xgui']				     = true,
	['ulx']					     = true,
    ['_FSpectatePosUpdate']      = true, 
    ['fspectate']                = true, 
    ['FSpectate_StopSpectating'] = true, 
    ['FSpectate']                = true, 
    ['FTPToPos']                 = true, 
    ['itemstore_syncinventory']  = true, 
    ['_DarkRP_DoAnimation']      = true, 
    ['_FAdmin']                  = true, 
    ['wayban_menu']              = true, 
    ['wayban_search']            = true, 
    ['+dradio']                  = true, 
    ['-dradio']                  = true, 
    ['dradio_bind_key']          = true, 
    ['RAPEDEMBITCHEZ']           = true,
    ['gmod_tool']                = true,
    ['gm_spawn']                 = true,
    ['gmod_undo']                = true,
    ['keypad_open']              = true,
    ['keypad_buy']               = true,
    ['undo']                     = true,
    ['FPP_sendblocked']          = true,
	['sit']						 = true,
}

-- Tool log blacklist, blacklist tools here that dont need to be logged
plogs.cfg.ToolBlacklist = {
	['material'] = true,
	['colour'] = true,
	['fading_door'] = true,
	['keypad_pattern'] = true,
	['precision'] = true,
	['stacker'] = true,
	['creator'] = true,
	['light'] = true,
	['textscreen'] = true,
	
}
--addons/module_logs/lua/plogs/workarounds/sanity_checker.lua:
-- Let's reduce support tickets by 50%
local function LowerKeys(tab)
	for k, v in pairs(tab) do
		tab[string.lower(k)] = v
	end
end

plogs.cfg.Command = string.lower(plogs.cfg.Command or 'plogs')
plogs.cfg.Command = string.Replace(plogs.cfg.Command, '/', '')
plogs.cfg.Command = string.Replace(plogs.cfg.Command, '!', '')

plogs.cfg.UserGroups = plogs.cfg.UserGroups or {
	['owner'] 		= true,
	['superadmin'] 	= true,
	['admin'] 		= true,
	['moderator'] 	= true
}

plogs.cfg.IPUserGroups = plogs.cfg.IPUserGroups or {
	['superadmin'] 	= true
}

plogs.cfg.Width = math.Clamp((plogs.cfg.Width or .65), .25, 1)

plogs.cfg.Height = math.Clamp((plogs.cfg.Height or .65), .25, 1)

plogs.cfg.DarkUI = plogs.cfg.DarkUI or false

plogs.cfg.EchoServer = plogs.cfg.EchoServer or true

plogs.cfg.DevAccess = plogs.cfg.DevAccess or true

plogs.cfg.EnableMySQL = plogs.cfg.EnableMySQL or false

plogs.cfg.LogLimit = plogs.cfg.LogLimit or 128

plogs.cfg.ShowSteamID = plogs.cfg.ShowSteamID or true

plogs.cfg.LogTypes = plogs.cfg.LogTypes or {
	['chat'] 		= false,
	['commands']	= false,
	['connections'] = false,
	['kills'] 		= false,
	['props'] 		= false,
	['tools'] 		= false,
	['darkrp'] 		= true,
	['ulx']			= true,
	['pnlr']		= true, -- NLR Zones					|| 	https://scriptfodder.com/scripts/view/583
	['lac']			= true, -- Leys Serverside AntiCheat 	|| 	https://scriptfodder.com/scripts/view/1148
	['awarn2']		= true, -- AWarn2 						||	https://scriptfodder.com/scripts/view/629
	['hitmodule']	= true, -- Hitman Module				||	https://scriptfodder.com/scripts/view/1369
	['cuffs'] 		= false, -- Hand Cuffs 					||	https://scriptfodder.com/scripts/view/910
}

plogs.cfg.CommandBlacklist = plogs.cfg.CommandBlacklist or {
	['_sendDarkRPvars']		= true,
	['_sendAllDoorData']	= true,
	['ulib_cl_ready'] 		= true,
	['_xgui']				= true,
	['ulx']					= true,
}

LowerKeys(plogs.cfg.UserGroups)
LowerKeys(plogs.cfg.IPUserGroups)
LowerKeys(plogs.cfg.LogTypes)
--addons/module_logs/lua/plogs/menu.lua:
-- To-do recode this mess.
surface.CreateFont('plogs.ui.26', {font = 'roboto', size = 26, weight = 400})
surface.CreateFont('plogs.ui.24', {font = 'roboto', size = 24, weight = 400})
surface.CreateFont('plogs.ui.22', {font = 'roboto', size = 22, weight = 400})
surface.CreateFont('plogs.ui.20', {font = 'roboto', size = 20, weight = 400})
surface.CreateFont('plogs.ui.19', {font = 'roboto', size = 19, weight = 400})
surface.CreateFont('plogs.ui.18', {font = 'roboto', size = 18, weight = 400})
surface.CreateFont('plogs.ui.16', {font = 'roboto', size = 16, weight = 400})

local hidden = {}

local function hide(bool)
	if bool then
		for _, entTbl in pairs(DarkRPEntities) do
			for _, ent in ipairs(ents.FindByClass(entTbl.ent)) do
				if ent:GetNoDraw() then continue end

				table.insert(hidden, ent)
				ent:SetNoDraw(true)
			end
		end

		for _, ent in ipairs(ents.FindByClass('player')) do
			if ent:GetNoDraw() then continue end

			table.insert(hidden, ent)
			ent:SetNoDraw(true)
		end

		for _, ent in ipairs(ents.FindByClass('prop_*')) do
			if ent:GetNoDraw() then continue end

			table.insert(hidden, ent)
			ent:SetNoDraw(true)
		end

		for _, ent in ipairs(ents.FindByClass('ent_door_rotating')) do
			if ent:GetNoDraw() then continue end

			table.insert(hidden, ent)
			ent:SetNoDraw(true)
		end
	else
		for _, ent in ipairs(hidden) do
			if not IsValid(ent) then continue end

			ent:SetNoDraw(false)
		end
		hidden = {}
	end
end

local previewFrame
local function previewLog(data)
	if LocalPlayer():Team() ~= TEAM_ADMIN and not LocalPlayer():IsNabor() then return notification.AddLegacy('Это можно сделать только в профессии Администратора', 1, 5) end 
	if IsValid(previewFrame) then previewFrame:Close() end

    local frame = vgui.Create('DFrame')
	previewFrame = frame
    frame:SetTitle('Просмотр лога')
    frame:SetSize(600,600)
    frame:MakePopup()
    frame:Center()

    local view = vgui.Create('DViewPanel', frame)
    view:Dock(FILL)
    
    local side = vgui.Create('DPanel', view)
    side:Dock(RIGHT)
    side:SetBackgroundColor(Color(100,100,100,100))
    side:SetWide(100)

    local entities = {}

	hide(true)

	local kill_colors = {
		['Убийца'] = Color(255,0,0,255),
		['Жертва'] = Color(0,0,255,255),
	}

    for k, v in pairs(data) do
        if not v.pos then continue end
        local pos = v.pos -- + Vector(0,0,10)

        if k == 1 then view:SetOrigin(pos + Vector(0,0,10)) end

        local btn = vgui.Create('DButton', side)
        btn:SetTall(25)
        btn:Dock(TOP)
        btn:SetText(v.name)
        btn.DoClick = function()
            view:SetOrigin(pos)
        end

        local dummy = ClientsideModel(v.model or 'models/editor/playerstart.mdl')
        dummy:SetPos(pos)
        dummy:SetAngles(v.ang or Angle(0,0,0))
        dummy:SetColor(kill_colors[v.name])
        dummy:SetMaterial("models/debug/debugwhite")
        dummy:Spawn()
        table.insert(entities, dummy)
    end

    frame.OnClose = function()
        for _, v in pairs(entities) do
            v:Remove()
        end
		hide(false)
    end
end

local function Search(command)
	local w, h = ScrW() * .3, 120
	local posx, posy = ScrW()/2 - w/2, ScrH()/2 - h/2

	if IsValid(plogs.SearchMenu) then
		plogs.SearchMenu:Remove()
	end

	if IsValid(plogs.Menu) then
		local x, y = plogs.Menu:GetPos()
		posy = plogs.Menu:GetTall() + y + 10
	end

	local fr = vgui.Create('plogs_frame')
	fr:SetTitle('Search')
	fr:SetSize(w, h)
	fr:SetPos(posx, posy)
	plogs.SearchMenu = fr

	local lbl = vgui.Create('DLabel', fr)
	lbl:SetPos(5, 35)
	lbl:SetText('Enter a SteamID to search')
	lbl:SetFont('plogs.ui.20')
	lbl:SetTextColor(plogs.ui.Close)
	lbl:SizeToContents()

	local txt = vgui.Create('DTextEntry', fr)
	txt:SetPos(5, 60)
	txt:SetSize(w - 10, 25)
	txt:SetFont('plogs.ui.22')

	local srch = vgui.Create('DButton', fr)
	srch:SetPos(5, 90)
	srch:SetSize(w - 10, 25)
	srch:SetText('Search')
	srch.DoClick = function(self)
		LocalPlayer():ConCommand('plogs "' .. command .. '" "' .. txt:GetValue() .. '"')
		fr:Close()
	end
end

local function LogMenu(title, data)
	if IsValid(plogs.Menu) then
		plogs.Menu:SetVisible(false)
	end
	if IsValid(plogs.LogMenu) then
		plogs.LogMenu:Remove()
	end
	
	local w, h = plogs.cfg.Width * ScrW(), plogs.cfg.Height * ScrH()

	local fr = vgui.Create('plogs_frame')
	fr:SetTitle('Search')
	fr:SetSize(w, h)
	fr:SetTitle(title)
	fr:Center()
	fr._Close = fr.Close
	fr.Close = function(self)
		if IsValid(plogs.Menu) then
			plogs.Menu:SetVisible(true)
		end
		fr:_Close()
	end
	plogs.LogMenu = fr

	local logList = vgui.Create('DListView', fr)
	logList:SetPos(0, 29)
	logList:SetSize(fr:GetWide(), fr:GetTall() - 29)
	logList:SetMultiSelect(false)
	logList:AddColumn('Date'):SetFixedWidth(175)
	logList:AddColumn('Data')
	logList.OnRowSelected = function(parent, line)
		local column 	= logList:GetLine(line)
		local log 		= column:GetColumnText(2)
		local menu 		= DermaMenu()

		menu:SetSkin('pLogs')
		menu:AddOption('Copy Line', function() 
			SetClipboardText(log)
			LocalPlayer():ChatPrint('Copied Line')
		end)
		menu:Open()
	end

	for k, v in ipairs(data) do
		logList:AddLine(isstring(v.Date) and v.Date or os.date('%X - %d/%m/%Y', v.Date), v.Data)
	end
end

local c = 1
local saveList
local function OpenMenu()
    
	local w, h = plogs.cfg.Width * ScrW(), plogs.cfg.Height * ScrH()
	c = 1

	local fr = plogs.Menu

	if IsValid(fr) then
		fr:Remove()
	end

	local count = table.Count(plogs.data)
	local fr = vgui.Create('plogs_frame')
	fr:SetSize(w, h)
	fr:Center()
	fr._Close = fr.Close
	fr.Close = function(self)
		if IsValid(plogs.SearchMenu) then
			plogs.SearchMenu:Close()
		end
		fr:_Close()
	end
	fr.PaintOver = function(self, w, h)
		if (c < count) then
			plogs.draw.Box(0, 0, w * c/count , 4, plogs.ui.ProgressBar)
		end
	end
	plogs.Menu = fr

	local tabs = vgui.Create('plogs_tablist', fr)
	tabs:SetPos(0, 29)
	tabs:SetSize(w, h - 29)
	plogs.Menu.Tabs = tabs
	
	local pnl =	vgui.Create('DPanel', tabs)
	tabs:AddTab('Saves', pnl, true)

	local logList = vgui.Create('DListView', pnl)
	logList:SetPos(0, 0)
	logList:SetSize(pnl:GetWide(), pnl:GetTall() - 150)
	logList:SetMultiSelect(false)
	logList:AddColumn('Time'):SetFixedWidth(75)
	logList:AddColumn('Data')
	logList.OnRowSelected = function(parent, line)
		local column 	= logList:GetLine(line)
		local log 		= column:GetColumnText(2)
		local menu 		= DermaMenu()

		if column.Positions then
			menu:AddOption('Просмотреть позиции', function()
				previewLog(column.Positions)
			end)

			menu:AddSpacer()
		end

		menu:SetSkin('pLogs')
		menu:AddOption('Copy Line', function() 
			SetClipboardText(log)
			LocalPlayer():ChatPrint('Copied Line')
		end)
		for name, value in SortedPairs(column.Copy or {}) do
			menu:AddOption('Copy ' .. name, function() 
				SetClipboardText(value or 'ERROR')
				LocalPlayer():ChatPrint('Copied ' .. name)
			end)
		end
		menu:Open()
	end
	logList.AddLogs = function(self, name)
		for k, v in pairs(self:GetLines()) do
			self:RemoveLine(k)
		end
		for _, log in SortedPairs(plogs.OpenSave(name)) do
			local line 	= self:AddLine(log.Date, log.Data)
			line.Copy 	= log.Copy
		end
	end

	local save
	saveList = vgui.Create('DListView', pnl)
	saveList:SetPos(5, pnl:GetTall() - 145)
	saveList:SetSize(pnl:GetWide()/2 - 7.5, 140)
	saveList:SetMultiSelect(false)
	saveList:AddColumn('Saves')
	saveList.OnRowSelected = function(parent, line)
		save = saveList:GetLine(line):GetColumnText(1)
	end
	saveList.AddSaves = function(self)
		for k, v in pairs(self:GetLines()) do
			self:RemoveLine(k)
		end
		for k, v in ipairs(plogs.GetSaves()) do
			self:AddLine(v)
			if (k == 1) then save = v end
		end
	end
	saveList:AddSaves()

	local btn = vgui.Create('DButton', pnl)
	btn:SetPos(pnl:GetWide()/2 + 2.25, pnl:GetTall() - 145)
	btn:SetSize(pnl:GetWide()/2 - 7.5, 25)
	btn:SetText('Open')
	btn.DoClick = function()
		logList:AddLogs(save)
	end

	btn = vgui.Create('DButton', pnl)
	btn:SetPos(pnl:GetWide()/2 + 2.25, pnl:GetTall() - 115)
	btn:SetSize(pnl:GetWide()/2 - 7.5, 25)
	btn:SetText('Delete')
	btn.DoClick = function()
		plogs.DeleteSave(save)
		saveList:AddSaves()
	end

	if plogs.cfg.EnableMySQL then
		tabs:AddButton('Player Events', function()
			Search('playerevents')
		end)

		if plogs.cfg.IPUserGroups[string.lower(LocalPlayer():GetUserGroup())] then
			tabs:AddButton('IP logs', function()
				Search('ipsearch')
			end)
		end
	end
end

net.Receive('plogs.OpenMenu', function()
	if (not IsValid(plogs.Menu)) then OpenMenu() end

	plogs.types = net.ReadTable()

	local d = util.JSONToTable(cookie.GetString('wrp.logs.settings') or '[]')

	local tabs = plogs.Menu.Tabs
	for name, v in pairs(plogs.types) do
		v.preventNetwork = table.HasValue(d.preventNetwork or {}, name)

		local pnl =	vgui.Create('DPanel', tabs)
		tabs:AddTab(name, pnl)

		local lbl = Label('Search:', pnl)
		lbl:SetFont('plogs.ui.22')
		lbl:SetTextColor(plogs.ui.Close)
		lbl:SetPos(5, pnl:GetTall() - 28)

		local txt = vgui.Create('DTextEntry', pnl)
		txt:SetPos(75, pnl:GetTall() - 30)
		txt:SetSize(pnl:GetWide() - 145, 25)
		txt:SetFont('plogs.ui.22')

		local save = vgui.Create('DButton', pnl)
		save:SetPos(pnl:GetWide() - 65, pnl:GetTall() - 30)
		save:SetSize(60, 25)
		save:SetText('Save')
		save.DoClick = function()
			Derma_StringRequest('Save Log', 'What do you want to name this save?', '', function(name)
				if (#pnl.Data == 0) then
					LocalPlayer():ChatPrint('There are no results to save!')
				else
					plogs.SaveLog(name, pnl.Data)
					LocalPlayer():ChatPrint('Saved Log')
				end
				if IsValid(saveList) then saveList:AddSaves() end
			end,
			function(text)
			end)--:SetSkin('pLogs')
		end

		local logList = vgui.Create('DListView', pnl)
		logList:SetPos(0, 0)
		logList:SetSize(pnl:GetWide(), pnl:GetTall() - 35)
		logList:SetMultiSelect(false)
		logList:AddColumn('Time'):SetFixedWidth(75)
		logList:AddColumn('Data')
		logList.OnRowSelected = function(parent, line)
			local column 	= logList:GetLine(line)
			local log 		= column:GetColumnText(2)
			local menu 		= DermaMenu()

			menu:SetSkin('pLogs')

			if column.Positions then
				menu:AddOption('Просмотреть позиции', function()
					previewLog(column.Positions)
				end)
	
				menu:AddSpacer()
			end
			menu:AddOption('Copy Line', function() 
				SetClipboardText(log)
				LocalPlayer():ChatPrint('Copied Line')
			end)
			for name, value in SortedPairs(column.Copy or {}) do
				menu:AddOption('Copy ' .. name, function() 
					SetClipboardText(value or 'ERROR')
					LocalPlayer():ChatPrint('Copied ' .. name)
				end)
			end
			menu:Open()
		end
		logList.LastSearch = ''
		pnl.Data = {}
		logList.Clear = function(self)
			for k, v in pairs(self:GetLines()) do
				self:RemoveLine(k)
			end
		end
		logList.AddLogs = function(self, data)
			for _, log in SortedPairs(pnl.Data) do
				local line 	= self:AddLine(log.Date, log.Data)
				line.Copy 	= log.Copy
				line.Positions = log.Positions
				--pnl.Data[#pnl.Data + 1] = log
			end
		end
		pnl.Clear = function(self)
			logList:Clear()
			self.Data = {}
		end
		pnl.AddLogs = function(self, data)
			self.Data = data
			logList:AddLogs()
		end
		logList.Search = wlib.func.debounce(function(self, find)
			local trueid
			for _, v in player.Iterator() do
				if v:DisplaySteamID() == find then
					trueid = utf8.lower(v:RealSteamID())
					break
				end
			end

			find = utf8.lower(find)
			for _, log in SortedPairs(pnl.Data) do
				local data = utf8.lower(log.Data)

				if utf8.find(data, find, 1, true) or (trueid and utf8.find(data, trueid, 1, true)) then
					local line 	= self:AddLine(log.Date, log.Data)
					line.Copy 	= log.Copy
					line.Positions = log.Positions
					--pnl.Data[#pnl.Data + 1] = log
				end
			end
		end, 0.1)
		
		
		logList.Think = function(self)
			local tosearch = string.Trim(txt:GetValue())
			if (tosearch ~= '') and (tosearch ~= self.LastSearch) then
				self:Clear()
				self:Search(tosearch)
				self.LastSearch = tosearch
			elseif (tosearch == '') and (tosearch ~= self.LastSearch) then
				self:Clear()
				self:AddLogs()
				self.LastSearch = tosearch
			end
		end
		
	end
end)

net.Receive('plogs.GetData', function()
	if not IsValid(plogs.Menu) then return end

	local name = net.ReadString()
	local size = net.ReadUInt(16)
	local data = plogs.Decode(net.ReadData(size))

	for _, v in pairs(plogs.Menu.Tabs.Tabs) do
		if v.title == name then
			v.tab:Clear()
			v.tab:AddLogs(data)
		end
	end
end)

net.Receive('plogs.LogData', function()
	local title = net.ReadString()
	local size = net.ReadUInt(16)
	local data = plogs.Decode(net.ReadData(size))
	LogMenu(title, data)
end)
--addons/module_donate/lua/pointshop/sh_init.lua:
--[[
	pointshop/sh_init.lua
	first file included on both states.
]]--

PS = PS or {}
PS.__index = PS

PS.Items = {}
PS.Categories = {}
PS.ClientsideModels = {}

include("sh_config.lua")
include("sh_player_extension.lua")

local mat_error = Material('error')

-- validation

function PS:ValidateItems(items)
	if type(items) ~= 'table' then return {} end

	-- Remove any items that no longer exist
	if CLIENT then
		for item_id, item in pairs(items) do
			if not self.Items[item_id] then
				items[item_id] = nil
			end
		end
	end

	return items
end

function PS:ValidatePoints(points)
	if type(points) != 'number' then return 0 end

	return points >= 0 and points or 0
end

-- Utils

function PS:FindCategoryByName(cat_name)
	for id, cat in pairs(self.Categories) do
		if cat.Name == cat_name then
			return cat
		end
	end

	return false
end

-- Initialization

function PS:Initialize()
	if SERVER then self:LoadDataProvider() end
	if SERVER and self.Config.CheckVersion then self:CheckVersion() end

	self:LoadItems()
end

-- Loading

function PS:LoadItems()
	local _, dirs = file.Find('pointshop/items/*', 'LUA')

	for _, category in pairs(dirs) do
		local f, _ = file.Find('pointshop/items/' .. category .. '/__category.lua', 'LUA')

		if #f > 0 then
			CATEGORY = {}

			CATEGORY.Name = ''
			CATEGORY.Icon = ''
			CATEGORY.Order = 0
			CATEGORY.AllowedEquipped = -1
			CATEGORY.AllowedUserGroups = {}
			CATEGORY.CanPlayerSee = function() return true end
			CATEGORY.ModifyTab = function(tab) return end

			if SERVER then AddCSLuaFile('pointshop/items/' .. category .. '/__category.lua') end
			include('pointshop/items/' .. category .. '/__category.lua')

			if not PS.Categories[category] then
				PS.Categories[category] = CATEGORY
			end

			local files, _ = file.Find('pointshop/items/' .. category .. '/*.lua', 'LUA')

			for _, name in pairs(files) do
				if name ~= '__category.lua' then
					if SERVER then AddCSLuaFile('pointshop/items/' .. category .. '/' .. name) end

					local item_id = string.gsub(string.lower(name), '.lua', '')

					ITEM = {}

					ITEM.__index = ITEM
					ITEM.ID = item_id
					ITEM.Category = CATEGORY.Name
					ITEM.Price = 0

					-- model and material are missing but there's no way around it, there's a check below anyway

					ITEM.AdminOnly = false
					ITEM.AllowedUserGroups = {} -- this will fail the #ITEM.AllowedUserGroups test and continue
					ITEM.SingleUse = false
					ITEM.NoPreview = false

					ITEM.CanPlayerBuy = true
					ITEM.CanPlayerSell = true
					ITEM.CanPlayerModify = false

					ITEM.CanPlayerEquip = true
					ITEM.CanPlayerHolster = true

					ITEM.OnBuy = wlib.func.blank
					ITEM.OnSell = wlib.func.blank
					ITEM.OnEquip = wlib.func.blank
					ITEM.OnHolster = wlib.func.blank
					ITEM.OnModify = wlib.func.blank
					ITEM.ModifyClientsideModel = function(ITEM, ply, model, pos, ang)
						return model, pos, ang
					end

					include('pointshop/items/' .. category .. '/' .. name)

					if not ITEM.Name then
						ErrorNoHalt("[POINTSHOP] Item missing name: " .. category .. '/' .. name .. "\n")
						continue
					elseif not ITEM.Price then
						ErrorNoHalt("[POINTSHOP] Item missing price: " .. category .. '/' .. name .. "\n")
						continue
					elseif not ITEM.Model and not ITEM.Material then
						ITEM.Material = mat_error
					end

					-- precache

					if ITEM.Model then
						util.PrecacheModel(ITEM.Model)
					end

					-- item hooks
					local item = ITEM

					for prop, val in pairs(item) do
						if type(val) == "function" then -- although this hooks every function, it doesn't matter because the non-hook functions will never get called
							hook.Add(prop, 'PS_Item_' .. item.Name .. '_' .. prop, function(...)
								for _, ply in player.Iterator() do
									if ply:PS_HasItemEquipped(item.ID) then -- hooks are only called if the player has the item equipped
										item[prop](item, ply, ply.PS_Items[item.ID].Modifiers, unpack({...}))
									end
								end
							end)
						end
					end

					self.Items[ITEM.ID] = ITEM

					if ITEM.ImageURL then
						local name = string.Explode('/', ITEM.ImageURL)
						http.DownloadMaterial(ITEM.ImageURL, name[#name], function(mat)
							PS.Items[item_id].Material = mat
						end)
					end

					ITEM = nil
				end
			end

			CATEGORY = nil
		end
	end

	hook.Run( "PS_LoadItems", self )
end

--addons/module_donate/lua/pointshop/cl_player_extension.lua:
local Player = FindMetaTable('Player')

-- items

function Player:PS_GetItems()
	return self.PS_Items or {}
end

function Player:PS_GetItemModifiers(item_id)
	if not self:PS_HasItemEquipped(item_id) then return end
	return self.PS_Items[item_id].Modifiers
end

function Player:PS_HasItem(item_id)
	if not self.PS_Items then return false end
	return self.PS_Items[item_id] and true or false
end

function Player:PS_HasItemEquipped(item_id)
	if not self:PS_HasItem(item_id) then return false end

	return self.PS_Items[item_id].Equipped or false
end

function Player:PS_BuyItem(item_id)
	if not self:PS_HasPoints(PS.Config.CalculateBuyPrice(self, PS.Items[item_id])) then return false end

	net.Start('PS_BuyItem')
		net.WriteString(item_id)
	net.SendToServer()
end

function Player:PS_SellItem(item_id)
	if not self:PS_HasItem(item_id) then return false end

	net.Start('PS_SellItem')
		net.WriteString(item_id)
	net.SendToServer()
end

function Player:PS_UseItem(item_id)
	if not self:PS_InventoryCount(item_id) then return false end

	net.Start('PS_UseItem')
		net.WriteString(item_id)
	net.SendToServer()
end

function Player:PS_MoveItem(item_id, target)
	if not IsValid(target) then return false end
	if not self:PS_InventoryCount(item_id) then return false end

	net.Start('PS_MoveItem')
		net.WriteString(item_id)
		net.WriteEntity(target)
	net.SendToServer()
end

function Player:PS_EquipItem(item_id)
	if not self:PS_HasItem(item_id) then return false end

	net.Start('PS_EquipItem')
		net.WriteString(item_id)
	net.SendToServer()
end

function Player:PS_HolsterItem(item_id)
	if not self:PS_HasItem(item_id) then return false end

	net.Start('PS_HolsterItem')
		net.WriteString(item_id)
	net.SendToServer()
end

-- points

function Player:PS_GetPoints()
	return self.PS_Points or 0
end

function Player:PS_HasPoints(points)
	return self:PS_GetPoints() >= points
end

-- clientside models

function Player:PS_AddClientsideModel(item_id)
	if not PS.Items[item_id] then return false end

	local ITEM = PS.Items[item_id]

	local mdl = ClientsideModel(ITEM.Model, RENDERGROUP_OPAQUE)
	if ITEM.Skin then mdl:SetSkin( ITEM.Skin ) end
	mdl:SetNoDraw(true)

	if not PS.ClientsideModels[self] then PS.ClientsideModels[self] = {} end
	PS.ClientsideModels[self][item_id] = mdl
end

function Player:PS_RemoveClientsideModel(item_id)
	if not PS.Items[item_id] then return false end
	if not PS.ClientsideModels[self] then return false end
	if not PS.ClientsideModels[self][item_id] then return false end

	PS.ClientsideModels[self][item_id] = nil
end

--addons/module_donate/lua/autorun/client/donate.lua:
-- icons
--[[
local images = {
	["moneybox"] = "http://wayzerroleplay.myarena.ru/wimages/moneybox.png",
	["vip_crown"] = "http://wayzerroleplay.myarena.ru/wimages/vip_crown.png",
	["moder_crown"] = "http://wayzerroleplay.myarena.ru/wimages/moder_crown.png",
	["admin_crown"] = "http://wayzerroleplay.myarena.ru/wimages/admin_crown.png",
	["dsadmin_crown"] = "http://wayzerroleplay.myarena.ru/wimages/dsadmin_crown.png",
	["curator_crown"] = "http://wayzerroleplay.myarena.ru/wimages/curator_crown.png",
	["patron_crown"] = "http://wayzerroleplay.myarena.ru/wimages/patron_crown.png",
	["props"] = "http://wayzerroleplay.myarena.ru/wimages/props.png",
	["model_schav"] = "http://wayzerroleplay.myarena.ru/wimages/model_schav.png",
	["cyberpistol"] = "http://wayzerroleplay.myarena.ru/wimages/cyberpistol.png",
	["armor"] = "http://wayzerroleplay.myarena.ru/wimages/armor.png",
	["health"] = "http://wayzerroleplay.myarena.ru/wimages/health.png",
	["case_dollar"] = "http://wayzerroleplay.myarena.ru/wimages/case_dollar.png",
	["case_free"] = "http://wayzerroleplay.myarena.ru/wimages/case_free.png",
	["case_points"] = "http://wayzerroleplay.myarena.ru/wimages/case_points.png",
	["case_usergroup"] = "http://wayzerroleplay.myarena.ru/wimages/case_usergroup.png",
	["doublejump"] = "http://wayzerroleplay.myarena.ru/wimages/doublejump.png",
	["magnum"] = "http://wayzerroleplay.myarena.ru/wimages/magnum.png",
	["smartpistol"] = "http://wayzerroleplay.myarena.ru/wimages/smartpistol.png",
	["vape"] = "http://wayzerroleplay.myarena.ru/wimages/vape.png",
	["wowozela"] = "http://wayzerroleplay.myarena.ru/wimages/wowozela.png",
	["weapon"] = "http://wayzerroleplay.myarena.ru/wimages/weapon.png",
	["stunstick"] = "http://wayzerroleplay.myarena.ru/wimages/stunstick.png",
	["cross"] = "http://wayzerroleplay.myarena.ru/wimages/cross.png",
	["microphone"] = "http://wayzerroleplay.myarena.ru/wimages/microphone.png",
	["gem"] = "http://wayzerroleplay.myarena.ru/wimages/gem.png",
	["dog"] = "http://wayzerroleplay.myarena.ru/wimages/dog.png",
	["bomb"] = "http://wayzerroleplay.myarena.ru/wimages/bomb.png",
	["gman"] = "http://wayzerroleplay.myarena.ru/wimages/gman.png",
	["mossman"] = "http://wayzerroleplay.myarena.ru/wimages/mossman.png",
	["superball"] = "http://wayzerroleplay.myarena.ru/wimages/superball.png",
	["snowman"] = "http://wayzerroleplay.myarena.ru/wimages/snowman.png",
	["skull"] = "http://wayzerroleplay.myarena.ru/wimages/skull.png",
	["scanner"] = "http://wayzerroleplay.myarena.ru/wimages/scanner.png",
	["bp"] = "http://wayzerroleplay.myarena.ru/wimages/bp.png",
}

if not file.IsDir('wimages', 'DATA') then
	file.CreateDir('wimages')
end

for k,v in pairs(images) do
    if not file.Exists('wimages/'..k..'.png', 'DATA') then
    	http.Fetch(v, function(b)
    		file.Write('wimages/'..k..'.png', b)
    	end)
    end	
end
]]

--
-- POINTSHOP NOTIFICATIONS
--

local cvar = CreateClientConVar('pointshop_notify_enable', 1, true)
local color_red = Color(255,0,0)
local color_bright = Color(236,113,73)

net.Receive('ShopNotify', function()
	if not cvar:GetBool() then return end
	local msg = net.ReadString()
	chat.AddText(color_bright, '[Магазин] ', color_red, '> ', color_white, msg)
end)

net.Receive( "srp_donate.PSNotification", function( len )

	local length = net.ReadUInt(8)
	Derma_StringRequest(
		"Сообщение на " .. length .. "мин",
		"Введи текст сообщения длиной до 120 символов:", "",
		function( val )
			if val:len() > 120 then
				notification.AddLegacy('Длина сообщения должна быть меньше 120 символов', 1, 10)
				net.Start( "srp_donate.PSNotification" )
					net.WriteBool( false )
				net.SendToServer()
			else
				net.Start( "srp_donate.PSNotification" )
					net.WriteBool( true )
					net.WriteString( val )
				net.SendToServer()
			end
		end,
		function()
			net.Start( "srp_donate.PSNotification" )
				net.WriteBool( false )
			net.SendToServer()
		end,
		"Отправить", "Отмена"
	)

end)

timer.Remove('srp_donate.afkTick')

--
-- PROMOCODES
--

concommand.Add( "srp_promo",  function()

	Derma_StringRequest(
		"Погасить код",
		"Введи свой промокод:", "",
		function( val )
			net.Start( "srp_donate.promo" )
				net.WriteString( val )
			net.SendToServer()
		end,
		wlib.func.blank,
		"Отправить", "Отмена"
	)

end)

--addons/module_donate/lua/pointshop/items/cases/__category.lua:
CATEGORY.Name = 'Кейсы'
CATEGORY.Icon = 'gift'
CATEGORY.Order = 10

--addons/module_donate/lua/pointshop/items/cases/case_defender.lua:
ITEM.Name = 'Защищенный Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Тычковые ножи"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_defender.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_defender')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_spaceday.lua:
ITEM.Name = 'Космический Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Компаньон космическое устройство"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_spaceday.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_spaceday')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_usergroup.lua:
ITEM.Name = 'Кейс с привилегиями'
ITEM.Price = 179
ITEM.Description = "Что можно выбить?\n- VIP на любой срок\n- DModerator на любой срок\n- DAdmin на любой срок\n-DSAdmin на любой срок\n- Curator на любой срок\n- Patron навсегда"
--ITEM.Material =  Material( "data/wimages/case_usergroup.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_usergroup.png'
ITEM.NoScroll = true
ITEM.SingleUse = true
ITEM.NoPreview = true

function ITEM:OnUse(ply)
	ply:OpenCrate('case_usergroup')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/companions/dragon.lua:
ITEM.Name = 'Дракон'
ITEM.Price = 349
ITEM.Model = 'models/roblox/a_very_special_monster.mdl'
--ITEM.Material = Material( "data/wimages/skull.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/dragon.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.z = plyAng.z + -90
	plyAng.y = plyAng.y - 90
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end


--addons/module_donate/lua/pointshop/items/cover/cover_city.lua:
ITEM.Name = 'Вдали от города'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_city.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_city.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_mooncat.lua:
ITEM.Name = 'Лунный кот'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_mooncat.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_mooncat.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_road.lua:
ITEM.Name = 'Дорога в маями'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_road.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_road.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_ruin.lua:
ITEM.Name = 'Руины цивилизации'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_ruin.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_ruin.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_space.lua:
ITEM.Name = 'Пурпурный космос'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_space.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_space.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/other/doublejump.lua:
ITEM.Name = 'Двойной прыжок на месяц'
ITEM.Description = 'Ты получаешь возможность совершить двойной прыжок за любую профессию'
ITEM.Price = 49
--ITEM.Material =  Material( "data/wimages/doublejump.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/doublejump.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
--addons/module_donate/lua/pointshop/items/other/entity_spawn.lua:
ITEM.Name = 'Спавн Entity через Q меню на месяц'
ITEM.Description = 'Ты получишь возможность спавнить энтити из вкладки Разрешено и Half - Life 2 ( не все предметы )'
ITEM.Price = 99
--ITEM.Material =  Material( "data/wimages/health.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/health.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
--addons/module_donate/lua/pointshop/items/other/unban.lua:
ITEM.Name = 'Разбан'
ITEM.Description = 'Снимает активный бан'
ITEM.Price = 149
--ITEM.Material = Material( "data/wimages/cross.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cross.png'
ITEM.NoScroll = true
ITEM.SingleUse = true
ITEM.NoPreview = true

function ITEM:OnUse( ply )
	FAdmin.UnBan( Entity(0), "", {ply:SteamID()} )
end

function ITEM:CanPlayerUse( ply )
	return ply:GetNetVar( "IsBanned" ), "Ты и так без бана, дружище"
end

--addons/module_donate/lua/pointshop/items/ranks/curator_3m.lua:
ITEM.Name = 'Curator на 3 месяц'
ITEM.Description = "- Имеет все привилегии VIP\n- Имеет все привилегии DModerator\n- Имеет все привилегии DAdmin\n- Имеет все привилегии DSAdmin\n-Имеет доступ к наборной системе жалоб\n- Иммунитет от хелперов\n- Имеет доступ к админ меню наборной администрации\n- Может установить себе размер\n- Может установить себе модель любого предмета\n- Имеет доступ к ивент меню \n- Может скринить экраны игроков \n- При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/curator_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/curator_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "Curator"
ITEM.Time = 60 * 60 * 24 * 30 * 3

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dsadmin_navsegda.lua:
ITEM.Name = 'DSAdmin навсегда'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет все привилегии DAdmin \n Доступ к спавну через Q меню, оружия, энтити, транспорта, но только из категории Разрешено \n - При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 2490
--ITEM.Material = Material( "data/wimages/dsadmin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/dsadmin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DSAdmin"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/vip_15d.lua:
ITEM.Name = 'VIP на 15 дней'
ITEM.Description = " - Имеет доступ ко всем вип профессиям \n - Имеет доступ ко всем VIP предметам \n - Дополнительный кликер"
ITEM.Price = 14
--ITEM.Material = Material( "data/wimages/vip_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vip_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "VIP"
ITEM.Time = 60 * 60 * 24 * 15

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/weapons/__category.lua:
CATEGORY.Name = 'Оружие'
CATEGORY.Icon = 'zap'
CATEGORY.AllowedEquipped = 1
CATEGORY.CustomAngle = 45
CATEGORY.CustomPos = Vector(10,10,-20)

--addons/module_donate/lua/pointshop/items/weapons/cyberitem_navsegda.lua:
ITEM.Name = 'CYBER PACK навсегда'
ITEM.Description = "Набор из двух Кибер предметов, включая Ховерборды и оружие Laser Gun с помощью которого можно летать.\nНикто включая администрацию не способен выдать эти предметы, они не выпадают после вашей смерти."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/cyberpistol.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cyberpistol.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "laserjetpack"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
	ply:StripWeapon(self.WeaponClass)
end

function ITEM:CanPlayerModify(ply, modifications)
    for k, v in pairs(modifications) do
        if k ~= 'color' then return false, 'Куда ты лезешь?' end
    end
    return true
end

function ITEM:Modify(modifications)
    PS:ShowColorChooser(self, modifications)
end
--addons/module_donate/lua/pointshop/items/weapons/dagger_knife.lua:
ITEM.Name = 'Тычковые Ножи'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_daggers"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/hpvape.lua:
ITEM.Name = 'HP Vape навсегда'
ITEM.Description = "Вейп с жижкой, восстанавливает ХП до 110, обходя лимит"
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/vape.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vape.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "weapon_vape_hp"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
	ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/khvostov.lua:
ITEM.Name = 'Khvostov 7G-0X'
ITEM.Description = ''
ITEM.Price = 999
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/khvostov.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wrp_weapon_khvostov"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/wowozela_navsegda.lua:
ITEM.Name = 'Вовозелка навсегда'
ITEM.Description = "Вовозелка\n- Позволяет издавать различные звуки с разноцветным эффектом\n- Еще ты можешь загрузить любые звуки из интернета в вовозелку\n- Даже свой голос с определенными фразами ;)"
ITEM.Price = 499
--ITEM.Material = Material( "data/wimages/wowozela.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/wowozela.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wowozela"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/ent_top/lua/scoresheet/sheets/clans/config.lua:
scoresheet.clans_header_text = "Forbes | Список богатых организаций" // the header text
scoresheet.clans_header_text_color = Color( 50, 50, 255 ) // the color of the header bg

scoresheet.clans_max_count = 10 // how many people does it show?
scoresheet.clans_cut_at_row_count = 5 // how many rows of people untill it cuts to a new line? ( 5 seems to be max )

scoresheet.clans_first_place_icon = Material( "icon16/coins.png" ) // the icon next to #1 name

scoresheet.clans_font_header = "score_row_header" // the font used for the header of the row, # number - name
scoresheet.clans_font_text = "score_row_text" // font used for the text of the row, $ money
--addons/_smallscripts/lua/autorun/sh_bleizer.lua:
local function checkranec(ply)
    if ply:Team() ~= TEAM_BLAIZER then return false end
    if ply:GetNetVar('duelSystem.OnDuel') then return false end

    return true
end

if CLIENT then

    local turboranech = ClientsideModel( "models/thrusters/jetpack.mdl" )
    turboranech:SetNoDraw( true )
 
    local blaizer_cache = {}

    timer.Create("blaizer_cache", 1, 0, function()
        
        local ply = LocalPlayer()

        if IsValid(ply) then
            
            local count = 0
            blaizer_cache = {}

            for k,v in ipairs(ents.FindInSphere(ply:GetPos(), 250)) do
                if v == ply and not ply:ShouldDrawLocalPlayer() then continue end
                if v:GetClass() == "player" and v:Team() == TEAM_BLAIZER and v:Alive() then
                    count = count + 1
                    blaizer_cache[count] = v
                end
            end

        end
    end)

    hook.Add( "PostDrawOpaqueRenderables" , "blaizer_turboranech" , function()
        for _,ply in ipairs(blaizer_cache) do
            if not IsValid(ply) then continue end
            local boneid = ply:LookupBone( "ValveBiped.Bip01_Spine2" )
            
            if not boneid then continue end
            
            local bonePos, boneAng = ply:GetBonePosition( boneid )
            
            if not bonePos then continue end
            if not boneAng then continue end
            
            local offsetPos = bonePos + boneAng:Right() * 5
            local offsetAng = boneAng

            offsetAng:RotateAroundAxis(boneAng:Right(), 90)
            offsetAng:RotateAroundAxis(boneAng:Up(), 90)
            
            turboranech:SetPos( offsetPos )
            turboranech:SetAngles( offsetAng )
            turboranech:DrawModel()
        end
    end)

    local mode = Material( "icon72/rocket.png" )
    local energy = 100
    local background = Color( 0, 0, 0, 125 )
    local progress = Color( 233, 133, 110, 255 )
    local textColor = Color( 255, 255, 255, 255 )
    local scrW, scrH = ScrW(), ScrH()

    net.Receive('BlaizerEnergy', function()
        energy = net.ReadUInt(32)
    end)
    
    hook.Add('HUDPaint', 'blaizer_hud', function()
        
        local ply = LocalPlayer()

        if not checkranec(ply) then return end
        
        local weapon = ply:GetActiveWeapon()
        
        if not weapon:IsValid() then return end
        if weapon:GetClass() == "laserjetpack" then return end
        if weapon:GetClass() == "stungun" then return end
        if weapon:GetClass() == "fridge_shield" then return end
        if weapon:GetClass() == "spidermans_swep" then return end
        
        draw.RoundedBox( 8, (scrW/2)-64, scrH-48, 128, 32, background )
        draw.RoundedBox( 0, (scrW/2)-58, scrH-42, 114*math.Clamp(((CurTime() - energy)/6), 0, 1), 20, progress )
        draw.DrawText("Ранец", "DermaLarge", (scrW/2), scrH-84, textColor, TEXT_ALIGN_CENTER )

        surface.SetDrawColor( 255, 255, 255, 255 ) 
        surface.SetMaterial( mode ) 
        surface.DrawTexturedRect( scrW / 2 + 70, scrH - 45, 24, 24 )

    end)

end

if SERVER then
    util.AddNetworkString('BlaizerEnergy')

    local sound = 'combine.sheild_loop'

    hook.Add( "KeyPress", "blaizer_ability", function( ply, key )
        if not checkranec(ply) then return end
        
        if ( key == IN_SPEED ) then
            if ply:OnGround() then return end
            if not ply:TriggerCooldown('BlaizerCooldown', 6) then return end

            ply:SetVelocity(ply:GetAimVector() * 700)
            ply:EmitSound(sound)

            timer.Simple(0.5, function()
                ply:StopSound(sound)
            end)

            net.Start('BlaizerEnergy')
            net.WriteUInt(CurTime(), 32)
            net.Send(ply)
        end

    end )

end
--addons/module_donate/lua/pointshop/items/cases/__category.lua:
CATEGORY.Name = 'Кейсы'
CATEGORY.Icon = 'gift'
CATEGORY.Order = 10

--addons/module_donate/lua/pointshop/items/cases/case_halloween.lua:
ITEM.Name = 'Хэллоуин Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Компаньон череп"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_halloween.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_halloween')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/companions/ghost.lua:
ITEM.Name = 'Призрак'
ITEM.Price = 999
ITEM.Model = 'models/roblox/ghostly_pursuit.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/ghost.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:CanPlayerSell(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = ply:EyePos(), ply:EyeAngles()
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/gman.lua:
ITEM.Name = 'GMan'
ITEM.Price = 199
ITEM.Model = 'models/maxofs2d/balloon_gman.mdl'
--ITEM.Material = Material( "data/wimages/gman.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/gman.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/penguin.lua:
ITEM.Name = 'Пингвин'
ITEM.Price = 299
ITEM.Model = 'models/roblox/snowboarding_penguin.mdl'
--ITEM.Material = Material( "data/wimages/dog.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/penguin.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y - 120
--	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/plasm.lua:
ITEM.Name = 'Плазмоган'
ITEM.Price = 499
ITEM.Model = 'models/gibs/gunship_gibs_nosegun.mdl'
--ITEM.Material = Material( "data/wimages/mossman.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/plasm.jpg'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-10, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8 + 20), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/skull.lua:
ITEM.Name = 'Череп ( Хэллоуин )'
ITEM.Price = 349
ITEM.Model = 'models/Gibs/HGIBS.mdl'
--ITEM.Material = Material( "data/wimages/skull.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/skull.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/cover/cover_cybercity.lua:
ITEM.Name = 'Город будущего'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_cybercity.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_cybercity.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_mrak.lua:
ITEM.Name = 'Могильный мрак'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_mrak.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_mrak.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_spider.lua:
ITEM.Name = 'Городской герой'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_spider.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_spider.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/moneypacks/__category.lua:
CATEGORY.Name = 'Деньги'
CATEGORY.Icon = 'money_with_wings'

--addons/module_donate/lua/pointshop/items/other/__category.lua:
CATEGORY.Name = 'Разное'
CATEGORY.Icon = 'pill'
CATEGORY.AllowedEquipped = 1

--addons/module_donate/lua/pointshop/items/other/ar_boost.lua:
ITEM.Name = '100 брони при спавне'
ITEM.Description = 'Выдает 100 брони при спавне за любую профессию'
ITEM.Price = 490
--ITEM.Material =  Material( "data/wimages/armor.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/armor.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
--addons/module_donate/lua/pointshop/items/ranks/curator_navsegda.lua:
ITEM.Name = 'Curator навсегда'
ITEM.Description = "- Имеет все привилегии VIP\n- Имеет все привилегии DModerator\n- Имеет все привилегии DAdmin\n- Имеет все привилегии DSAdmin\n-Имеет доступ к наборной системе жалоб\n- Иммунитет от хелперов\n- Имеет доступ к админ меню наборной администрации\n- Может установить себе размер\n- Может установить себе модель любого предмета\n- Имеет доступ к ивент меню \n- Может скринить экраны игроков \n- При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 4990
--ITEM.Material = Material( "data/wimages/curator_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/curator_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "Curator"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dadmin_navsegda.lua:
ITEM.Name = 'DAdmin навсегда'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования \n - Может заморозить игрока \n - Может выдавать оружие \n - Может поджечь игрока \n - Может дать регдолл игроку"
ITEM.Price = 1490
--ITEM.Material = Material( "data/wimages/admin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/admin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DAdmin"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dmoderator_1m.lua:
ITEM.Name = 'DModerator на месяц'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования"
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/moder_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moder_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DModerator"
ITEM.Time = 60 * 60 * 24 * 30

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dmoderator_3m.lua:
ITEM.Name = 'DModerator на 3 месяца'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования"
ITEM.Price = 159
--ITEM.Material = Material( "data/wimages/moder_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moder_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DModerator"
ITEM.Time = 60 * 60 * 24 * 30 * 3

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/vip_15d.lua:
ITEM.Name = 'VIP на 15 дней'
ITEM.Description = " - Имеет доступ ко всем вип профессиям \n - Имеет доступ ко всем VIP предметам \n - Дополнительный кликер"
ITEM.Price = 14
--ITEM.Material = Material( "data/wimages/vip_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vip_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "VIP"
ITEM.Time = 60 * 60 * 24 * 15

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/weapons/crimson.lua:
ITEM.Name = 'Crimson'
ITEM.Description = 'Fight like a beast, yet move like a ghost.'
ITEM.Price = 999
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/crimson.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wrp_weapon_crimson"
ITEM.Hidden = true


function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/cyberitem_navsegda.lua:
ITEM.Name = 'CYBER PACK навсегда'
ITEM.Description = "Набор из двух Кибер предметов, включая Ховерборды и оружие Laser Gun с помощью которого можно летать.\nНикто включая администрацию не способен выдать эти предметы, они не выпадают после вашей смерти."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/cyberpistol.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cyberpistol.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "laserjetpack"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
	ply:StripWeapon(self.WeaponClass)
end

function ITEM:CanPlayerModify(ply, modifications)
    for k, v in pairs(modifications) do
        if k ~= 'color' then return false, 'Куда ты лезешь?' end
    end
    return true
end

function ITEM:Modify(modifications)
    PS:ShowColorChooser(self, modifications)
end
--addons/module_donate/lua/pointshop/items/weapons/mosin_weapon.lua:
ITEM.Name = 'Винтовка мосин навсегда'
ITEM.Description = 'Старенькая винтовка мосин, с отличной пробиваемостью. Доступна для ношения мэру.'
ITEM.Price = 999
--ITEM.Material =  Material( "data/wimages/smartpistol.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/mosin_weapon.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wrp_weapon_mosin"
ITEM.Hidden = true


function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/smartpistol.lua:
ITEM.Name = 'Smart Pistol на месяц'
ITEM.Description = 'Пистолет из игры Titanfall с автоматическим прицеливанием и высокой скорострельностью'
ITEM.Price = 249
--ITEM.Material =  Material( "data/wimages/smartpistol.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/smartpistol.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
ITEM.WeaponClass = "mp_weapon_smart_pistol"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/_smallscripts/lua/autorun/sh_dmarkers.lua:
dMarkers = dMarkers or {}

if CLIENT then
    dMarkers.markers = dMarkers.markers or {}

    surface.CreateFont('dMarkers.title', {
        font = 'Roboto',
        size = 22,
        weight = 500,
        extended = true,
    })
    surface.CreateFont('dMarkers.title-shadow', {
        font = 'Roboto',
        size = 22,
        weight = 500,
        extended = true,
        blursize = 5,
    })

    surface.CreateFont('dMarkers.text', {
        font = 'Roboto',
        extended = true,
        size = 18,
        weight = 300,
    })
    surface.CreateFont('dMarkers.text-shadow', {
        font = 'Roboto',
        extended = true,
        size = 18,
        weight = 300,
        blursize = 5,
    })

    hook.Add('Think', 'dMarkers.distance', function()
        for i = #dMarkers.markers, 1, -1 do
            local marker = dMarkers.markers[i]

            local dist = math.floor((LocalPlayer():GetPos():DistToSqr(marker.pos)^(1/2))/50)
            if dist < 5 then
                local res = hook.Run('dMarkers.shouldRemove', marker, false)
                if res ~= false then dMarkers.remove(i) end
            end

            if marker.target and not IsValid(marker.target) then
                dMarkers.remove(i)
            end

            if marker.time and CurTime() > marker.time then
                dMarkers.remove(i)
            end
        end
    end)

    hook.Add('HUDPaint', 'dMarkers', function()
        for i=1, #dMarkers.markers do
            local v = dMarkers.markers[i]

            local pos = IsValid(v.target) and v.target:GetPos() or v.pos or vector_origin
            local pos2D = pos:ToScreen()
            local x, y = math.floor(pos2D.x), math.floor(pos2D.y)
            local dist = math.floor((LocalPlayer():GetPos():DistToSqr(v.pos)^(1/2))/50)

            if v.icon then
                surface.SetMaterial(v.icon)
                surface.SetDrawColor(color_white)
                surface.DrawTexturedRect(x - 16, y - 16, 32, 32)
            end

            local alpha = math.Clamp(350 - Vector(x,y,0):DistToSqr(Vector(ScrW()/2, ScrH()/2, 0)) / 100, 0, 255)
            if alpha > 0 then
                v.color.a = alpha
                local title = ('%s (%sм)'):format(v.title, dist)

                draw.SimpleText(title, 'dMarkers.title-shadow', x, y + 35, Color(0,0,0, v.color.a), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                draw.SimpleText(title, 'dMarkers.title', x, y + 35, v.color, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                
                draw.DrawText(v.text, 'dMarkers.text-shadow', x, y + 50, Color(0,0,0, v.color.a), TEXT_ALIGN_CENTER)
                draw.DrawText(v.text, 'dMarkers.text', x, y + 50, Color(255,255,255, v.color.a), TEXT_ALIGN_CENTER)
            end
        end
    end)

    function dMarkers.create(d)
        -- Wrapping text
        local textArray = {}
        local cache = {}
        for k, v in ipairs(string.Explode(' ', d.text or '')) do
            table.insert(cache, v)
            if k % 8 == 0 then
                table.insert(textArray, table.concat(cache, ' '))
                cache = {}
            end
        end
        table.insert(textArray, table.concat(cache, ' '))

        d.text = table.concat(textArray, '\n')

        -- Удаляем с таким же UID
        if d.uid then
            for i = #dMarkers.markers, 1, -1 do
                local marker = dMarkers.markers[i]

                if marker.uid and marker.uid == d.uid then
                    dMarkers.remove(i)
                end
            end
        end

        local id = table.insert(dMarkers.markers, {
            title = d.title or '',
            text = d.text or '',
            color = d.color or Color(255,255,255),
            icon = d.icon and Material(d.icon) or nil,
            pos = d.pos or Vector(0,0,0),
            time = d.time and d.time ~= 0 and CurTime()+d.time or nil,
            type = d.type,
            target = d.target,
            uid = d.uid,
        })

        hook.Run('dMarkers.created', id, d)
    end

    function dMarkers.remove(id)
        if not dMarkers.markers[id] then return end

        hook.Run('dMarkers.removed', id)
        table.remove(dMarkers.markers, id)
    end

    function dMarkers.removeAll(type)
        for i = #dMarkers.markers, 1, -1 do
            if not type or dMarkers.markers[i].type == type then
                dMarkers.remove(i)
            end
        end
    end

    net.Receive('dMarkers.create', function()
        local d = net.ReadTable()
        dMarkers.create({
            title = d.title,
            text = d.text,
            color = d.color,
            icon = d.icon,
            pos = d.pos,
            time = d.time,
            type = d.type,
            target = d.target,
            uid = d.uid,
        })
    end)

    concommand.Add('dmarkers_remove', function(ply, cmd, args)
        dMarkers.removeAll(args[1])
    end)

    hook.Add('OnPlayerChangedTeam', 'policemarkers', function(ply)
        if not LocalPlayer():isCP() then dMarkers.removeAll('police') end
    end)
else
    util.AddNetworkString('dMarkers.create')

    function dMarkers.create(targets, data, sound)
        for _, v in pairs(istable(targets) and targets or {targets}) do
            net.Start('dMarkers.create')
            net.WriteTable(data)
            net.Send(v)

            if sound then
                v:ConCommand('play '..sound)
            end
        end
    end
end
--addons/_smallscripts/lua/autorun/sh_nlr.lua:
if CLIENT then
    local convar = CreateClientConVar('wrp_nlr_enabled', 1, true)
    cvars.AddChangeCallback('wrp_nlr_enabled', function(cvar, old, new)
        if tonumber(new) == 0 then
            dMarkers.removeAll('nlr')
        end
    end)

    hook.Add('dMarkers.shouldRemove', 'nlr_timer', function(marker)
        if marker.type == 'nlr' then return false end
    end)

    hook.Add('dMarkers.created', 'nlr_timer', function(id, marker)
        if not convar:GetBool() and marker.type == 'nlr' then
        	timer.Simple(.1, function()
    			dMarkers.remove(id)
    		end)
        end
    end)
else
    hook.Add('PlayerDeath', 'nlr_timer', function(ply)
        dMarkers.create(ply, {
            title = 'NLR',
            color = Color(255,0,0),
            icon = 'icon72/skull_crossbones.png',
            pos = ply:GetPos(),
            time = 300,
            type = 'nlr',
        })
    end)
end
--addons/module_weed/lua/autorun/sh_weed.lua:
--
--addons/module_siting/lua/autorun/simp_sit_init.lua:
SIMPSit = {}
SIMPSit.Core = {}
SIMPSit.Config = {}
SIMPSit.Cooldown = {}

local path = "simp_sit/"
if SERVER then
	local files, folders = file.Find(path .. "*", "LUA")
	
	for _, folder in SortedPairs(folders, true) do
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sh_*.lua", "LUA"), true) do
	        AddCSLuaFile(path .. folder .. "/" .. File)
	        include(path .. folder .. "/" .. File)
	    end
	
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sv_*.lua", "LUA"), true) do
	        include(path .. folder .. "/" .. File)
	    end
	
	    for b, File in SortedPairs(file.Find(path .. folder .. "/cl_*.lua", "LUA"), true) do
	        AddCSLuaFile(path .. folder .. "/" .. File)
	    end
	end
end

if CLIENT then
	local files, folders = file.Find(path .. "*", "LUA")
	
	for _, folder in SortedPairs(folders, true) do
	    for b, File in SortedPairs(file.Find(path .. folder .. "/sh_*.lua", "LUA"), true) do
	        include(path .. folder .. "/" .. File)
	    end

	    for b, File in SortedPairs(file.Find(path .. folder .. "/cl_*.lua", "LUA"), true) do
	        include(path .. folder .. "/" .. File)
	    end
	end
end
--addons/module_siting/lua/simp_sit/core/sh_core.lua:
nw.Register 'SitOnGround'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetPlayer()
--addons/_smallscripts/lua/smallscripts/fear/client.lua:
local fadetime = 3
local fearstart, fearend = 0, 0
hook.Add('PlayerFearUpdated', 'fear', function(ply, val)
    if ply ~= LocalPlayer() then return end
    if val then
        fearend = nil
        fearstart = CurTime()
    else
        fearstart = nil
        fearend = CurTime()
    end
end)

hook.Add('HUDPaint', 'fear', function()
    local frac = fearstart and (CurTime()-fearstart)/fadetime or 1-(CurTime()-fearend)/fadetime
    if frac < 1 or LocalPlayer():IsFeared() then
        surface.SetDrawColor(0, 0, 0, frac > 1 and 150 or 150*frac)
        surface.DrawRect(-1, -1, ScrW()+2, ScrH()+2)
    end
end)
--addons/_smallscripts/lua/smallscripts/physgun.lua:
nw.Register('CanTouchOthersEnts')
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetLocalPlayer()

if CLIENT then
    hook.Add('PhysgunPickup', 'asktotouch', function(ply, ent)
        if not FPP.canTouchEnt(ent, 'Physgun') then return end

        local owner = ent:CPPIGetOwner()
        if IsValid(owner) and owner ~= ply and not ply:GetNetVar('CanTouchOthersEnts') then return false end
    end)
else
    hook.Add('PhysgunPickup', 'asktotouch', function(ply, ent)
        if not FPP.plyCanTouchEnt(ply, ent, 'Physgun') then return end
        
        local owner = ent:CPPIGetOwner()
        if IsValid(owner) and owner ~= ply and not ply:GetNetVar('CanTouchOthersEnts') then
            if ply:TriggerCooldown('physgun_ask', 5) then
                DarkRP.createQuestion(
                    'Ты действительно хочешь дотронуться до чужого пропа Physics Gun\'ом?',
                    'physgun_ask_'..ply:SteamID64(),
                    ply, 15,
                    function(ans)
                        if tobool(ans) then
                            ply:SetNetVar('CanTouchOthersEnts', true)
                            ply:Notify(0, 3, 'Теперь ты можешь трогать чужие пропы')
                            
                            timer.Create('physgun_ask_'..ply:SteamID64(), 300, 1, function()
                                if IsValid(ply) then ply:SetNetVar('CanTouchOthersEnts', nil) end
                            end)
                        end
                    end,
                    nil, ply
                )
            end
            return false
        end
    end)
end
--addons/_smallscripts/lua/smallscripts/pvp/shared.lua:
PVP_DURATION = 30

nw.Register('PVPStart')
    :Write(net.WriteUInt, 32)
    :Read(net.ReadUInt, 32)
    :SetLocalPlayer()
    :SetHook('PVPUpdated')

local meta = FindMetaTable('Player')
function meta:InPVP()
    return self:GetPVPTime() < PVP_DURATION
end

function meta:GetPVPTime()
    return CurTime() - self:GetNetVar('PVPStart', 0)
end
--addons/module_css2/lua/autorun/sound.lua:
sound.Add( {
	name = "TFA_L4D2_RO2_MOSIN.1",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 120,
	pitch = { 95, 110 },
	sound = ")weapons/l4d2_rocky_mosin/gunfire/scout_fire-1.wav"
} )

sound.Add( {
	name = "TFA_L4D2_RO2_MOSIN.Deploy",
	channel = CHAN_USER_BASE+12,
	volume = 1.0,
	level = 80,
	pitch = { 95, 110 },
	sound = ")weapons/l4d2_rocky_mosin/gunother/rifle_deploy_1.wav"
} )

sound.Add( {
	name = "TFA_L4D2_RO2_MOSIN.BoltForward",
	channel = CHAN_USER_BASE+11,
	volume = 1.0,
	level = 80,
	pitch = { 95, 110 },
	sound = ")weapons/l4d2_rocky_mosin/gunother/scout_bolt_forward.wav"
} )

sound.Add( {
	name = "TFA_L4D2_RO2_MOSIN.BoltBack",
	channel = CHAN_USER_BASE+11,
	volume = 1.0,
	level = 80,
	pitch = { 95, 110 },
	sound = ")weapons/l4d2_rocky_mosin/gunother/scout_bolt.wav"
} )

sound.Add( {
	name = "TFA_L4D2_RO2_MOSIN.ClipOut",
	channel = CHAN_USER_BASE+12,
	volume = 1.0,
	level = 80,
	pitch = { 95, 110 },
	sound = ")weapons/l4d2_rocky_mosin/gunother/scout_clipout.wav"
} )

sound.Add( {
	name = "TFA_L4D2_RO2_MOSIN.ClipIn",
	channel = CHAN_USER_BASE+12,
	volume = 1.0,
	level = 80,
	pitch = { 95, 110 },
	sound = ")weapons/l4d2_rocky_mosin/gunother/scout_clipin.wav"
} )

sound.Add( {
	name = "TFA_L4D2_RO2_MOSIN.ClipLocked",
	channel = CHAN_USER_BASE+12,
	volume = 1.0,
	level = 80,
	pitch = { 95, 110 },
	sound = ")weapons/l4d2_rocky_mosin/gunother/scout_clipin_locked.wav"
} )

sound.Add( {
	name = "TFA_L4D2_RO2_MOSIN.HelpingHandRetract",
	channel = CHAN_USER_BASE+11,
	volume = 1.0,
	level = 80,
	pitch = { 95, 110 },
	sound = ")weapons/l4d2_rocky_mosin/gunother/rifle_helpinghandretract.wav"
} )

sound.Add({
	name = "Weapon_SniperRifle.Bolt_Up",
	channel = CHAN_AUTO,
	volume = 0.5,
	level = SNDLVL_NORM,
	sound = {
		"weapons/sniperrifle/sniperrifle_bolt_up_01.wav"
	}
})
sound.Add({
	name = "Weapon_SniperRifle.Bolt_Back",
	channel = CHAN_AUTO,
	volume = 0.75,
	level = SNDLVL_NORM,
	sound = {
		"weapons/sniperrifle/sniperrifle_bolt_back_01.wav"
	}
})
sound.Add({
	name = "Weapon_SniperRifle.Bolt_Forward",
	channel = CHAN_AUTO,
	volume = 0.5,
	level = SNDLVL_NORM,
	sound = {
		"weapons/sniperrifle/sniperrifle_bolt_forward_01.wav"
	}
})
sound.Add({
	name = "Weapon_SniperRifle.Bolt_Down",
	channel = CHAN_AUTO,
	volume = 0.5,
	level = SNDLVL_NORM,
	sound = {
		"weapons/sniperrifle/sniperrifle_bolt_down_01.wav"
	}
})
sound.Add({
	name = "Weapon_SniperRifle.Bullet_Futz",
	channel = CHAN_AUTO,
	volume = 0.25,
	level = SNDLVL_NORM,
	sound = {
		"weapons/sniperrifle/sniperrifle_bullet_futz_01.wav"
	}
})
sound.Add({
	name = "Weapon_SniperRifle.Bullet_Load",
	channel = CHAN_AUTO,
	volume = 0.5,
	level = SNDLVL_NORM,
	sound = {
		"weapons/sniperrifle/sniperrifle_bullet_load_01.wav"
	}
})

sound.Add({
	name = "Weapon_OICW.Mag_Release",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/oicw/oicw_mag_release_01.wav"
})
sound.Add({
	name = "Weapon_OICW.Mag_Out",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/oicw/oicw_mag_out_01.wav"
})
sound.Add({
	name = "Weapon_OICW.Mag_Futz",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/oicw/oicw_mag_futz_01.wav"
})
sound.Add({
	name = "Weapon_OICW.Mag_In",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/oicw/oicw_mag_in_01.wav"
})
sound.Add({
	name = "Weapon_OICW.Mag_Slap",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/oicw/oicw_mag_slap_01.wav"
})
sound.Add({
	name = "Weapon_OICW.Bolt_Release",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/oicw/oicw_bolt_release_01.wav"
})

sound.Add({
	name = "Weapon_HMG.Bolt_Grab",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/hmg/hmg_bolt_grab_01.wav"
})
sound.Add({
	name = "Weapon_HMG.Bolt_Pull",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/hmg/hmg_bolt_pull_01.wav"
})
sound.Add({
	name = "Weapon_HMG.Bolt_Lock",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/hmg/hmg_bolt_lock_01.wav"
})
sound.Add({
	name = "Weapon_HMG.Bolt_Slap",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/hmg/hmg_bolt_slap_01.wav"
})
sound.Add({
	name = "Weapon_HMG.Mag_Release",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/hmg/hmg_mag_release_01.wav"
})
sound.Add({
	name = "Weapon_HMG.Mag_Out",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/hmg/hmg_mag_out_01.wav"
})
sound.Add({
	name = "Weapon_HMG.Mag_Futz",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/hmg/hmg_mag_futz_01.wav"
})
sound.Add({
	name = "Weapon_HMG.Mag_In",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	sound = "weapons/hmg/hmg_mag_in_01.wav"
})

sound.Add( {
    name = "Weapon_Pistol.Mag_Out",
    channel = CHAN_AUTO,
    volume = 1,
    level = SNDLVL_NORM,
    pitch = { 95, 105 },
    sound =  "weapons/reloads/smartpistol_reload_magin_st_01.wav"
} )

sound.Add( {
    name = "Weapon_Pistol.Mag_In",
    channel = CHAN_AUTO,
    volume = 1,
    level = SNDLVL_NORM,
    pitch = { 95, 105 },
    sound =  "weapons/reloads/smartpistol_reload_magout_st_01.wav"
} )

sound.Add( {
    name = "Weapon_Pistol.Slide_Release",
    channel = CHAN_AUTO,
    volume = 1,
    level = SNDLVL_NORM,
    pitch = { 95, 105 },
    sound =  "weapons/p2011/wpn_2011pistol_1p_wpnfire_mech_c_v1_1.wav"
} )

sound.Add(
{
    name = "Weapon_SmartPistol.Single",
    channel = CHAN_WEAPON,
    volume = 1.0,
    soundlevel = SNDLVL_GUNFIRE,
    sound = "weapons/smartpistol/wpn_smartpistol_1p_wpnfire_core_6ch_v1_01.wav"
})
sound.Add(
{
    name = "Weapon_SmartPistol.Lock",
    channel = CHAN_ITEM,
    volume = 1.0,
    soundlevel = SNDLVL_NORM,
    sound = "weapons/smartpistol/wpn_smartpistol_1p_wpnfire_servomech_1ch_v1_02.wav"
})
sound.Add(
{
    name = "Weapon_SmartPistol.TargetLock",
    channel = CHAN_ITEM,
    volume = 1.0,
    soundlevel = SNDLVL_NORM,
    sound = "weapons/smartpistol/smartpistol_targetlock_test_04.wav"
})

sound.Add(
{
    name = "Weapon_P2011.Single",
    channel = CHAN_WEAPON,
    volume = 1.0,
    soundlevel = SNDLVL_GUNFIRE,
    sound = "weapons/p2011/wpn_2011pistol_1p_wpnfire_shot_6ch_v1_01.wav"
})
sound.Add(
{
    name = "Weapon_r1pistol.magout",
    channel = CHAN_ITEM,
    volume = 1.0,
    soundlevel = SNDLVL_NORM,
    sound = "weapons/reloads/smartpistol_reload_magout_st_01.wav"
})
sound.Add(
{
    name = "Weapon_r1pistol.magin",
    channel = CHAN_ITEM,
    volume = 1.0,
    soundlevel = SNDLVL_NORM,
    sound = "weapons/reloads/smartpistol_reload_magin_st_01.wav"
})
sound.Add(
{
    name = "Weapon_r1pistol.slidefront",
    channel = CHAN_ITEM,
    volume = 1.0,
    soundlevel = SNDLVL_NORM,
    sound = "weapons/p2011/wpn_2011pistol_1p_wpnfire_mech_c_v1_1.wav"
})
--addons/module_picture/lua/autorun/urlpaint.lua:
URLPaint = URLPaint or {}
URLPaint.List = URLPaint.List or {}

AddCSLuaFile("urlpaint/client.lua")
AddCSLuaFile("urlpaint/shared.lua")
if SERVER then
	include("urlpaint/server.lua")
	include("urlpaint/shared.lua")
else
	include("urlpaint/client.lua")
	include("urlpaint/shared.lua")
end

if CLIENT then
    CreateClientConVar("urlpaint_enabled", "1", true, false)
    
    cvars.AddChangeCallback("urlpaint_enabled", function(convar_name, value_old, value_new)
        if value_new == '1' then
            net.Start("URLPaint Update")
            net.SendToServer()
        end
    end)

    local materialCache = {}

    timer.Create('refreshurl_pic', 5, 0, function()
        if GetConVar('urlpaint_enabled'):GetInt() <= 0 then return end

        for k,v in ipairs(ents.FindByClass('painting_*')) do
            if not IsValid(v) then continue end
            
            local picID = v:GetPicID()
            
            if picID == "" then continue end

            if not materialCache[picID] then
                materialCache[picID] = Material(picID)
            end

            v.image = materialCache[picID]
        end
    end)
end
--addons/module_utime/lua/autorun/utime_init.lua:
wlib.include.prefixed('utime')
--addons/module_utime/lua/utime/cl_utime.lua:
wayscore.AddInfo('utime_total', {
    name = 'Общий онлайн',
    get = function(ply)
        local time = string.FormattedTime(ply:GetUTimeTotalTime() or 0)
        return string.format('%02i:%02i:%02i', time.h, time.m, time.s)
    end,
    order = 5000,
})
--addons/module_wmap/lua/waymap/vgui_marker.lua:
--[[
wayMap.marker = {
    __index = wayMap.marker,
}

function wayMap.marker:New(d)
    local obj = {
        name = 'Маркер',
        color = color_white,
        icon = mat,
        pos = Vector(0,0,0),
    }

    table.Merge(obj, d)
    setmetatable(obj, self)
    
    return obj
end

AccessorFunc(wayMap.marker, 'name', 'Name')
AccessorFunc(wayMap.marker, 'color', 'Color')
AccessorFunc(wayMap.marker, 'pos', 'Pos')
AccessorFunc(wayMap.marker, 'icon', 'Material')

function wayMap.marker:SetIcon(icon)
    self:SetMaterial(icon and Material(icon) or mat)
end

]]
local mat = Material('icon16/bullet_white.png')

local PANEL = {}

function PANEL:Init()
    self.name = 'Маркер'
    self.icon = nil
    self.origin = Vector(0,0,0)
    self.category = nil
    self.target = nil
    self.think = nil
    self.order = 1

    self:SetMaterial(mat)
end

AccessorFunc(PANEL, 'name', 'Name')
AccessorFunc(PANEL, 'icon', 'Icon')
AccessorFunc(PANEL, 'origin', 'Origin')
AccessorFunc(PANEL, 'category', 'Category')
AccessorFunc(PANEL, 'target', 'Target')
AccessorFunc(PANEL, 'think', 'Think')
AccessorFunc(PANEL, 'order', 'Order')

function PANEL:Think()
    if IsValid(self.target) then
        self:SetOrigin(self.target:GetPos())
    end

    if self.think then
        self.think(self)
    end
end

function PANEL:OnRemove()
    table.RemoveByValue(wayMap.markers, self)

    if IsValid(wayMap.map) then
        wayMap.map:RebuildSidebar()
    end
end

vgui.Register('waymap_marker', PANEL, 'DImageButton')
--addons/module_wmap/lua/waymap/cl_marker.lua:
wmap.markers = wmap.markers or {}

local MARKER = {}
MARKER.__index = MARKER

local mat_default = Material('icon72/sad.png')

function wmap.createMarker(id)
    local m = setmetatable({
        id = id,
        name = 'Маркер',
        material = mat_default,
        order = 0,
    }, MARKER)

    m:SetPos(0, 0)

    local _, index = wlib.array.find(wmap.markers, function(i) return i.id == id end)
    if index then table.remove(wmap.markers, index) end

    table.insert(wmap.markers, m)
    table.sort(wmap.markers, function(a, b) return a.order < b.order end)

    return m
end

function MARKER:Remove()
    local _, index = wlib.array.find(wmap.markers, function(i) return i.id == self.id end)
    if not index then return end
    table.remove(wmap.markers, index)
end

wlib.accessor(MARKER, 'id', 'ID')
wlib.accessor(MARKER, 'name', 'Name')
wlib.accessor(MARKER, 'material', 'Material')
wlib.accessor(MARKER, 'w', 'Width')
wlib.accessor(MARKER, 'h', 'Height')
wlib.accessor(MARKER, 'order', 'Order')
wlib.accessor(MARKER, 'entity', 'Entity')
wlib.accessor(MARKER, 'static', 'Static')
wlib.accessor(MARKER, 'nextThink', 'NextThink')

function MARKER:SetMaterial(mat)
    if isstring(mat) then mat = Material(mat) end
    self.material = mat
    return self
end

function MARKER:SetSize(w, h)
    self.w = w
    self.h = h or w
    return self
end

function MARKER:SetPos(x, y)
    if isvector(x) then x, y = x.x, x.y end
    self.wx = x
    self.wy = y

    self.x, self.y = wmap.worldToLocal(x, y)

    return self
end

function MARKER:GetPos()
    return self.wx, self.wy
end

function MARKER:SetMapPos(x, y)
    if isvector(x) then x, y = x.x, x.y end
    self.x = x
    self.y = y

    self.wx, self.wy = wmap.localToWorld(x, y)

    return self
end

function MARKER:GetMapPos()
    return self.x, self.y
end

function MARKER:SetEntity(ent)
    if not IsValid(ent) then return self end

    self.entity = ent
    self:SetPos(ent:GetPos())

    self.Think = function()
        if self.static then return end
        if not IsValid(self.entity) then return self:Remove() end

        self:SetPos(self.entity:GetPos())
    end

    return self
end

function MARKER:Paint(x, y)
    surface.SetDrawColor(color_white)

    if self.material then
        surface.SetMaterial(self.material)
    end

    surface.DrawTexturedRect(x - self.w/2, y - self.h/2, self.w, self.h)
end

wmap.markerMeta = MARKER
--addons/module_battlepass/lua/waypass/sh_util.lua:
function waypass.error(...)
    ErrorNoHalt('[waypass]: ', ..., '\n')
end

function waypass.debug(...)
    if not waypass.config.debug then return end
    MsgC(Color(0, 200, 0), '[waypass]: ', color_white, ..., '\n')
end

function waypass.Format(str, val, ...)
    local args = {val, ...}
    args = #args == 1 and istable(val) and val or args
    
    if isfunction(str) then return str(args) end
    
    for v in str:gmatch('%{%w+%}') do
        local arg = v:sub(2,v:len()-1)
        arg = tonumber(arg) or arg

        if args[arg] then
            str = str:gsub(v, args[arg])
        end
    end
    return str
end

if SERVER then
    util.AddNetworkString('waypass.ChallengeNotify')
    function waypass.ChallengeNotify(ply, passId, challengeId, progress)
        net.Start('waypass.ChallengeNotify')
        net.WriteString(passId)
        net.WriteString(challengeId)
        net.WriteFloat(progress)
        net.Send(ply) 
    end
else
    local enabled = CreateClientConVar('waypass_show_challenge_progress', '1', true)

    net.Receive('waypass.ChallengeNotify', function()
        if not enabled:GetBool() then return end
        waypass.ChallengeNotify(net.ReadString(), net.ReadString(), net.ReadFloat())
    end)

    function waypass.ChallengeNotify(passId, challengeId, progress)
        local c = waypass.GetBP(passId):GetChallenge(challengeId)
        local percentage = progress/c:GetGoal()
        local start = CurTime()
        local id = 'waypass_cnotify_'..passId..'_'..challengeId
        hook.Add('Think', id, function()
            local frac = Lerp(CurTime()-start, 0, percentage)
            notification.AddProgress(id, waypass.Format('Прогресс выполнения "{1}" ({2}/{3})', c:GetName(), progress, c:GetGoal()), frac, 3)
        end)
        timer.Create(id, 5, 1, function()
            notification.Kill(id)
            hook.Remove('Think', id)
        end)
    end
end

function waypass.GetActiveBP()
    for id, bp in pairs(waypass.passes.list) do
        if bp:GetEndTime() and bp:GetEndTime() > os.time() then return bp end
    end
end

function waypass.GetLastBP()
    local maxend = -1
    local maxbp
    for id, bp in pairs(waypass.passes.list) do
        if not bp:IsActive() and maxend < bp:GetEndTime() then
            maxend = bp:GetEndTime()
            maxbp = bp
        end
    end

    return maxbp
end

local plural_type = function(i)
	return i % 10 == 1 and i % 100 ~= 11 and 1
		or (i % 10 >= 2 and i % 10 <= 4 and (i % 100 < 10 or i % 100 >= 20) and 2
			or 3
		)
end

function waypass.FormatPlural(plurals, num)
	local type = plural_type(num)
	local suffix = plurals[type]
	return num .. ' ' .. suffix, suffix
end
--addons/module_battlepass/lua/waypass/challenges/graffiti.lua:
waypass.challenges.Create('graffiti')
    :SetName('Художник')
    :SetDesc('Приобрети {goal} балончиков с краской')
    :AddHook('playerBoughtCustomEntity', function(self, owner, ply, tbl, ent, price)
        if ply ~= owner then return end
        if ent:GetClass() ~= 'weapon_spraypaint' then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/hobotrash.lua:
waypass.challenges.Create('hobotrash')
    :SetName('Миллионер из трущоб')
    :SetDesc('Продай мусора на {goal}')
    :AddHook('WayDealerSell', function(self, owner, ply, class, amount, profit)
        if ply ~= owner then return end
        if class ~= "hobo_trash" then return end
        self:AddProgress(profit)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/insertdonate.lua:
waypass.challenges.Create('insertdonate')
    :SetName('Благотворительность')
    :SetDesc('Пожертвуй {goal} в ящик для пожертвований')
    :AddHook('InsertDonationBox', function(self, owner, ply, amount)
        if ply ~= owner then return end
        self:AddProgress(amount)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/lottery.lua:
waypass.challenges.Create('lottery')
    :SetName('Лотерейный билет')
    :SetDesc('Проведи {goal} лотерей, будучи мэром')
    :AddHook('lotteryStarted', function(self, owner, mayor, price)
        if mayor ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/picture.lua:
waypass.challenges.Create('picture')
    :SetName('Меценат')
    :SetDesc('Приобрети {goal} картин')
    :AddHook('playerBoughtCustomEntity', function(self, owner, ply, tbl, ent, price)
        if ply ~= owner then return end
        if not string.find(ent:GetClass(), 'painting') then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/respawn.lua:
waypass.challenges.Create('respawn')
    :SetName('Дефибриллятор')
    :SetDesc('Возроди игрока {goal} раз')
    :AddHook('PlayerRespawned', function(self, ply, tryp, owner, ent)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/stealdonatebox.lua:
waypass.challenges.Create('stealdonatebox')
    :SetName('Циник')
    :SetDesc('Стащи из ящика для пожертвований {goal}')
    :AddHook('LockpickDonateBox', function(self, owner, ply, amount)
        if ply ~= owner then return end
        self:AddProgress(amount)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/wepclear.lua:
waypass.challenges.Create('wepclear')
    :SetName('Чистильщик')
    :SetDesc('Продай оружие скупщику {goal} раз')
    :AddHook('WayDealerSell', function(self, owner, ply, class, amount, profit)
        if ply ~= owner then return end
        if class ~= "spawned_weapon" then return end
        self:AddProgress(amount)
    end)
:Register()
--addons/module_battlepass/lua/waypass/vgui/levelbar.lua:
local mat_star = Material('icon72/star.png')
local font = 'dorgs.24'
local icon_size = 32

local PANEL = {}

function PANEL:Init()
    self.buy = vgui.Create('waypass_button', self)
    self.buy:SetIcon('icon72/star.png')
    self.buy:SetButtonText('Купить премиум')

    self.lvl = 0
    self.points = 0
end

AccessorFunc(PANEL, 'premium', 'Premium')
AccessorFunc(PANEL, 'lvl', 'Level')
AccessorFunc(PANEL, 'points', 'Points')
AccessorFunc(PANEL, 'bpId', 'BPID')
function PANEL:GetBP()
    return waypass.GetBP(self:GetBPID())
end
function PANEL:SetPremium(b)
    self.premium = b
    local bp = self:GetBP()

    if not bp:IsActive() then
        self.buy:SetVisible(false)
        return
    end

    if b then
        self.buy:SetVisible(true)
        self.buy:SetIcon('icon16/money.png')
        self.buy:SetButtonText('Купить уровни')
        self.buy.DoClick = fp{waypass.OpenBuyLevelsMenu, self:GetBP():GetID()}
    elseif bp and bp:GetPrice() then
        self.buy:SetVisible(true)
        self.buy:SetIcon('icon72/star.png')
        self.buy:SetButtonText('Купить премиум')
        self.buy.DoClick = function()
            Derma_Query(
                waypass.Format('Ты уверен что хочешь купить "{1}" за {2}₽ (у тебя есть {3}₽)', bp:GetName(), bp:GetPrice(), LocalPlayer():PS_GetPoints()),
                'Покупка БП',
                'Да',
                fp{waypass.BuyBP, self:GetBP():GetID()},
                'Нет'
            )
        end
    else
        self.buy:SetVisible(false)
    end

    self:PerformLayout(self:GetSize())
end

function PANEL:Paint(w,h)
    local bp = self:GetBP()
    if not bp then return end

    local percent = self:GetPoints() and bp:GetPointsBarrier() and self:GetPoints()/bp:GetPointsBarrier() or 0

    local offset = 0
    if self.premium then
        surface.SetDrawColor(color_white)
        surface.SetMaterial(mat_star)
        surface.DrawTexturedRect(offset, 0, icon_size, icon_size)
        offset = offset+icon_size+8
    end

    draw.SimpleText('Уровень '..self:GetLevel(), font, offset, icon_size/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

    local pbarh = h-(icon_size+8)

    draw.RoundedBox(4, 0, icon_size+8, w, pbarh, waypass.skin.COLOR_SECONDARY)
    draw.RoundedBox(4, 0, icon_size+8, w*percent, pbarh, waypass.skin.COLOR_PRIMARY)

    draw.SimpleText(self:GetPoints()..'/'..bp:GetPointsBarrier(), font, w/2, icon_size+8+pbarh/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

function PANEL:PerformLayout(w,h)
    self.buy:SizeToContents()
    self.buy:SetTall(icon_size)
    self.buy:SetPos(w-self.buy:GetWide(), 0)
end

vgui.Register('waypass_levelbar', PANEL, 'DPanel')
--addons/module_battlepass/lua/waypass/sh_config.lua:
waypass.config = waypass.config or {}

waypass.config.debug = false

-- Подсказки про уровень активных БП
waypass.config.loginHints = true
-- Стандартное кол-во поинтов для нового уровня
waypass.config.pointsBarrier = 1000

waypass.donateLevels = {
    [1] = 149,
    [3] = 390,
    [5] = 590,
    [10] = 1090,
}

local bpstart = 1742428800

waypass.passes.list = {}

local active_bp = waypass.passes.Create('vesna2025')
    :SetName('Весенний пропуск')
    :SetDesc('*')
    :SetPrice(790)
    :SetStartTime(bpstart)
    :SetEndTime(bpstart+8380800)

    local week_start = bpstart
    local week_end = bpstart + 604800
    active_bp
        :AddChallenge('lottery',        '11',       5, 1000, false, week_start, week_end)
        :AddChallenge('hit',            '12',       5, 1000, false, week_start, week_end)
        :AddChallenge('defusebomb',     '13',       1, 1000, false, week_start, week_end)
        :AddChallenge('weed',           '14',       1000, 1000, false, week_start, week_end)
        :AddChallenge('explodebomb',    '15',       1, 1000, false, week_start, week_end)
        :AddChallenge('insertdonate',   '16',       250000, 1000, false, week_start, week_end)
        :AddChallenge('doors',          '17',       5, 1000, false, week_start, week_end)
        :AddChallenge('hobotrash',      '18',       50000, 1000, false, week_start, week_end)
        :AddChallenge('death',          '19',       15, 1000, false, week_start, week_end)
        :AddChallenge('online',         '20',       60, 1000, false, week_start, week_end)


    local week_start = bpstart + 604800
    local week_end = bpstart + (604800 * 2)
    active_bp
        :AddChallenge('chocolate',      '1',       5, 1000, false, week_start, week_end)
        :AddChallenge('salary',         '2',       5, 1000, false, week_start, week_end)
        :AddChallenge('arrest',         '3',       5, 1000, false, week_start, week_end)
        :AddChallenge('online_session', '4',       30, 1000, false, week_start, week_end)
        :AddChallenge('lottery',        '5',       2, 1000, false, week_start, week_end)
        :AddChallenge('props',          '6',       15, 1000, false, week_start, week_end)
        :AddChallenge('clickers',       '7',       10000000, 1000, false, week_start, week_end)
        :AddChallenge('arrestbank',     '8',       1, 1000, false, week_start, week_end)
        :AddChallenge('case',           '9',       2, 1000, false, week_start, week_end)
        :AddChallenge('bankrobbery',    '10',       1, 1000, false, week_start, week_end)


    local week_start = bpstart + (604800 * 2)
    local week_end = bpstart + (604800 * 3)
    active_bp
        :AddChallenge('online',         '121',       100, 1000, false, week_start, week_end)
        :AddChallenge('arrest',         '122',       15, 1000, false, week_start, week_end)
        :AddChallenge('lottery',        '123',       5, 1000, false, week_start, week_end)
        :AddChallenge('props',          '124',       20, 1000, false, week_start, week_end)
        :AddChallenge('hit',            '125',       10, 1000, false, week_start, week_end)
        :AddChallenge('arrestbank',     '126',       1, 1000, false, week_start, week_end)
        :AddChallenge('wepclear',       '127',       5, 1000, false, week_start, week_end)
        :AddChallenge('bankrobbery',    '128',       1, 1000, false, week_start, week_end)
        :AddChallenge('team',           '129',       10, 1000, false, week_start, week_end)
        :AddChallenge('chocolate',      '130',       10, 1000, false, week_start, week_end)


    local week_start = bpstart + (604800 * 3)
    local week_end = bpstart + (604800 * 4)
    active_bp
        :AddChallenge('bitminer',       '51',       500000, 1000, false, week_start, week_end)
        :AddChallenge('winduel',        '52',       1, 1000, false, week_start, week_end)
        :AddChallenge('taser',          '53',       15, 1000, false, week_start, week_end)
        :AddChallenge('online_session', '54',       60, 1000, false, week_start, week_end)
        :AddChallenge('meth',           '55',       150, 1000, false, week_start, week_end)
        :AddChallenge('defusebomb',     '56',       1, 1000, false, week_start, week_end)
        :AddChallenge('hit',            '57',       5, 1000, false, week_start, week_end)
        :AddChallenge('case',           '58',       2, 1000, false, week_start, week_end)
        :AddChallenge('death',          '59',       30, 1000, false, week_start, week_end)
        :AddChallenge('insertdonate',   '60',       500000, 1000, false, week_start, week_end)


    local week_start = bpstart + (604800 * 4)
    local week_end = bpstart + (604800 * 5)
    active_bp
        :AddChallenge('online',         '61',       100, 1000, false, week_start, week_end)
        :AddChallenge('wepclear',       '62',       1, 1000, false, week_start, week_end)
        :AddChallenge('chocolate',      '63',       19, 1000, false, week_start, week_end)
        :AddChallenge('arrestbank',     '64',       1, 1000, false, week_start, week_end)
        :AddChallenge('props',          '65',       50, 1000, false, week_start, week_end)
        :AddChallenge('death',          '66',       5, 1000, false, week_start, week_end)
        :AddChallenge('bankrobbery',    '67',       1, 1000, false, week_start, week_end)
        :AddChallenge('insertdonate',   '68',       300000, 1000, false, week_start, week_end)
        :AddChallenge('case',           '69',       1, 1000, false, week_start, week_end)
        :AddChallenge('hit',            '70',       15, 1000, false, week_start, week_end)


    local week_start = bpstart + (604800 * 5)
    local week_end = bpstart + (604800 * 6)
    active_bp
        :AddChallenge('arrest',          '41',      5, 1000, false, week_start, week_end)
        :AddChallenge('nalog',          '42',       5, 1000, false, week_start, week_end)
        :AddChallenge('team',           '43',       5, 1000, false, week_start, week_end)
        :AddChallenge('hit',            '44',       5, 1000, false, week_start, week_end)
        :AddChallenge('online',         '45',       120, 1000, false, week_start, week_end)
        :AddChallenge('props',          '46',       30, 1000, false, week_start, week_end)
        :AddChallenge('wepclear',       '47',       20, 1000, false, week_start, week_end)
        :AddChallenge('winduel',        '48',       2, 1000, false, week_start, week_end)
        :AddChallenge('bankrobbery',    '49',       1, 1000, false, week_start, week_end)
        :AddChallenge('arrestbank',     '50',       1, 1000, false, week_start, week_end)

    local week_start = bpstart + (604800 * 6)
    local week_end = bpstart + (604800 * 7)
    active_bp
        :AddChallenge('taser',          '21',       15, 1000, false, week_start, week_end)
        :AddChallenge('hit',            '22',       15, 1000, false, week_start, week_end)
        :AddChallenge('wepclear',       '23',       30, 1000, false, week_start, week_end)
        :AddChallenge('arrestbank',     '24',       1, 1000, false, week_start, week_end)
        :AddChallenge('meth',           '25',       300, 1000, false, week_start, week_end)
        :AddChallenge('explodebomb',    '26',       1, 1000, false, week_start, week_end)
        :AddChallenge('team',           '27',       5, 1000, false, week_start, week_end)
        :AddChallenge('winduel',        '28',       10, 1000, false, week_start, week_end)
        :AddChallenge('case',           '29',       2, 1000, false, week_start, week_end)
        :AddChallenge('bankrobbery',    '30',       1, 1000, false, week_start, week_end)


    local week_start = bpstart + (604800 * 7)
    local week_end = bpstart + (604800 * 8)
    active_bp
        :AddChallenge('online',         '81',       200, 1000, false, week_start, week_end)
        :AddChallenge('chocolate',      '82',       30, 1000, false, week_start, week_end)
        :AddChallenge('meth',           '83',       300, 1000, false, week_start, week_end)
        :AddChallenge('props',          '84',       10, 1000, false, week_start, week_end)
        :AddChallenge('taser',          '85',       15, 1000, false, week_start, week_end)
        :AddChallenge('lottery',        '86',       5, 1000, false, week_start, week_end)
        :AddChallenge('defusebomb',     '87',       1, 1000, false, week_start, week_end)
        :AddChallenge('arrest',         '88',       3, 1000, false, week_start, week_end)
        :AddChallenge('insertdonate',   '89',       400000, 1000, false, week_start, week_end)
        :AddChallenge('case',           '90',       2, 1000, false, week_start, week_end)


    local week_start = bpstart + (604800 * 8)
    local week_end = bpstart + (604800 * 9)
    active_bp
        :AddChallenge('arrest',         '31',       5, 1000, false, week_start, week_end)
        :AddChallenge('chocolate',      '32',       10, 1000, false, week_start, week_end)
        :AddChallenge('bitminer',       '33',       500000, 1000, false, week_start, week_end)
        :AddChallenge('nalog',          '34',       5, 1000, false, week_start, week_end)
        :AddChallenge('respawn',        '35',       2, 1000, false, week_start, week_end)
        :AddChallenge('case',           '36',       1, 1000, false, week_start, week_end)
        :AddChallenge('death',          '37',       15, 1000, false, week_start, week_end)
        :AddChallenge('hobotrash',      '38',       1000000, 1000, false, week_start, week_end)
        :AddChallenge('insertdonate',   '39',       500000, 1000, false, week_start, week_end)
        :AddChallenge('props',          '40',       15, 1000, false, week_start, week_end)


    local week_start = bpstart + (604800 * 9)
    local week_end = bpstart + (604800 * 10)
    active_bp
        :AddChallenge('defusebomb',     '71',       1, 1000, false, week_start, week_end)
        :AddChallenge('promo',          '72',       1, 1000, false, week_start, week_end)
        :AddChallenge('hit',            '73',       20, 1000, false, week_start, week_end)
        :AddChallenge('taser',          '74',       15, 1000, false, week_start, week_end)
        :AddChallenge('arrest',         '75',       5, 1000, false, week_start, week_end)
        :AddChallenge('lottery',        '76',       10, 1000, false, week_start, week_end)
        :AddChallenge('team',           '77',       15, 1000, false, week_start, week_end)
        :AddChallenge('meth',           '78',       500, 1000, false, week_start, week_end)
        :AddChallenge('arrestbank',     '79',       1, 1000, false, week_start, week_end)
        :AddChallenge('wepclear',       '80',       10, 1000, false, week_start, week_end)


    local week_start = bpstart + (604800 * 10)
    local week_end = bpstart + (604800 * 11)
    active_bp
        :AddChallenge('arrest',         '111',       10, 1000, false, week_start, week_end)
        :AddChallenge('chocolate',      '112',       40, 1000, false, week_start, week_end)
        :AddChallenge('hit',            '113',       30, 1000, false, week_start, week_end)
        :AddChallenge('wepclear',       '114',       45, 1000, false, week_start, week_end)
        :AddChallenge('defusebomb',     '115',       1, 1000, false, week_start, week_end)
        :AddChallenge('props',          '116',       40, 1000, false, week_start, week_end)
        :AddChallenge('lottery',        '117',       25, 1000, false, week_start, week_end)
        :AddChallenge('meth',           '118',       500, 1000, false, week_start, week_end)
        :AddChallenge('insertdonate',   '119',       500000, 1000, false, week_start, week_end)
        :AddChallenge('case',           '120',       2, 1000, false, week_start, week_end)

    local week_start = bpstart + (604800 * 11)
    local week_end = bpstart + (604800 * 12)
    active_bp
        :AddChallenge('promo',          '91',       1, 1000, false, week_start, week_end)
        :AddChallenge('defusebomb',     '92',       1, 1000, false, week_start, week_end)
        :AddChallenge('team',           '93',       20, 1000, false, week_start, week_end)
        :AddChallenge('arrestbank',     '94',       1, 1000, false, week_start, week_end)
        :AddChallenge('wepclear',       '95',       35, 1000, false, week_start, week_end)
        :AddChallenge('hit',            '96',       10, 1000, false, week_start, week_end)
        :AddChallenge('chocolate',      '97',       35, 1000, false, week_start, week_end)
        :AddChallenge('taser',          '98',       20, 1000, false, week_start, week_end)
        :AddChallenge('case',           '99',       1, 1000, false, week_start, week_end)
        :AddChallenge('bankrobbery',    '100',       1, 1000, false, week_start, week_end)


    local week_start = bpstart + (604800 * 12)
    local week_end = bpstart + (604800 * 13)
    active_bp
        :AddChallenge('death',          '131',       4, 1000, false, week_start)
        :AddChallenge('case',           '132',       1, 1000, false, week_start)
        :AddChallenge('nalog',          '133',       5, 1000, false, week_start)
        :AddChallenge('winduel',        '134',       15, 1000, false, week_start)
        :AddChallenge('insertdonate',   '135',       3000000, 1000, false, week_start)
        :AddChallenge('taser',          '136',       10, 1000, false, week_start)
        :AddChallenge('salary',         '137',       10, 1000, false, week_start)
        :AddChallenge('clickers',       '138',       6000000, 1000, false, week_start)
        :AddChallenge('bitminer',       '139',       4000000, 1000, false, week_start)
        :AddChallenge('lottery',        '140',       10, 1000, false, week_start)



    local week_start = bpstart + (604800 * 12)
    local week_end = bpstart + (604800 * 13)
    active_bp
        :AddChallenge('lottery',        '101',       10, 1000, false, week_start, week_end)
        :AddChallenge('arrest',         '102',       5, 1000, false, week_start, week_end)
        :AddChallenge('defusebomb',     '103',       1, 1000, false, week_start, week_end)
        :AddChallenge('props',          '104',       12, 1000, false, week_start, week_end)
        :AddChallenge('online',         '105',       300, 1000, false, week_start, week_end)
        :AddChallenge('meth',           '106',       200, 1000, false, week_start, week_end)
        :AddChallenge('team',           '107',       3, 1000, false, week_start, week_end)
        :AddChallenge('wepclear',       '108',       40, 1000, false, week_start, week_end)
        :AddChallenge('hit',            '109',       25, 1000, false, week_start, week_end)
        :AddChallenge('arrestbank',     '110',       1, 1000, false, week_start, week_end)



    :AddLevel(2,    {'points', 7},                         {'points', 45})
    :AddLevel(5,    {'darkrp_money', 250000},              {'pointshop_item', "case_butterfly"})
    :AddLevel(7,    {'points', 7},                         {'points', 45})
    :AddLevel(10,   {'pointshop_item', "case_points"},     {'pointshop_item', "case_points"})
    :AddLevel(12,   {'points', 7},                         {'points', 45})
    :AddLevel(15,   {'pointshop_item', "case_free"},       {'pointshop_item', "weapon_spawn"})
    :AddLevel(17,   {'points', 7},                         {'points', 45})
    :AddLevel(20,   {'darkrp_money', 500000},              {'pointshop_item', "message"})
    :AddLevel(22,   {'points', 7},                         {'points', 45})
    :AddLevel(25,   {'pointshop_item', "case_dollar"},     {'pointshop_item', "case_points"})
    :AddLevel(27,   {'points', 7},                         {'points', 45})
    :AddLevel(30,   {'pointshop_item', "case_gift"},       {'pointshop_item', "case_spider"})
    :AddLevel(32,   {'points', 7},                         {'points', 45})
    :AddLevel(35,   {'pointshop_item', "case_gift"},       {'pointshop_item', "skinworkshop"})
    :AddLevel(37,   {'points', 7},                         {'points', 45})
    :AddLevel(40,   {'darkrp_money', 1000000},             {'pointshop_item', "case_points"})
    :AddLevel(42,   {'points', 7},                         {'points', 45})
    :AddLevel(45,   {'pointshop_item', "case_dollar"},     {'pointshop_item', "case_defender"})
    :AddLevel(47,   {'points', 7},                         {'points', 45})
    :AddLevel(50,   {'pointshop_item', "entity_spawn"},    {'pointshop_item', "case_spider"})
    :AddLevel(52,   {'points', 7},                         {'points', 45})
    :AddLevel(55,   {'pointshop_item', "case_points"},     {'pointshop_item', "case_points"})
    :AddLevel(57,   {'points', 7},                         {'points', 45})
    :AddLevel(60,   {'darkrp_money', 2000000},             {'pointshop_item', "case_steel"})
    :AddLevel(62,   {'points', 7},                         {'points', 45})
    :AddLevel(65,   {'pointshop_item', "case_points"},     {'pointshop_item', "cover_cybercity"})
    :AddLevel(66,   {'pointshop_item', "case_gift"},       {'pointshop_item', "case_gift"})
    :AddLevel(67,   {'points', 14},                        {'points', 45})
    :AddLevel(68,   {'pointshop_item', "outfit_guitar"},   {'pointshop_item', "cover_drive"})
    :AddLevel(69,   {'points', 14},                        {'points', 45})
    :AddLevel(70,   {'pointshop_item', "khvostov"},        {'pointshop_item', "outfit_shoes_primary"})
    :AddLevel(80,   {'points', 14},                        {'points', 45})
    :AddLevel(90,   {'points', 14},                        {'points', 14})
    :AddLevel(100,  {'points', 14},                        {'points', 45})
    :AddLevel(110,  {'points', 14},                        {'points', 14})
    :AddLevel(120,  {'points', 14},                        {'points', 45})
    :AddLevel(130,  {'points', 14},                        {'points', 14})
    :AddLevel(140,  {'points', 14},                        {'points', 45})
:Register()
--addons/module_battlepass/lua/waypass/sh_net.lua:
local function WriteChallenge(c)
    net.WriteString(c:GetUID())
    net.WriteFloat(c:GetProgress())
end

local function ReadChallenge(bpId)
    local uid, progress = net.ReadString(), net.ReadFloat()
    local c = table.Copy(waypass.GetBP(bpId):GetChallenge(uid))
    c:SetProgress(progress)

    return c
end

nw.Register('waypass.challenges')
    :Write(function(val)
        net.WriteUInt(table.Count(val), 8)

        for pid, challenges in pairs(val) do
            net.WriteString(pid)
            net.WriteUInt(table.Count(challenges), 8)
            for _, c in pairs(challenges) do
                WriteChallenge(c)
            end
        end
    end)
    :Read(function()
        local a = {}
        for i=1, net.ReadUInt(8) do
            local pid = net.ReadString()
            a[pid] = {}

            for i=1, net.ReadUInt(8) do
                local c = ReadChallenge(pid)
                a[pid][c:GetUID()] = c
            end
        end
        return a
    end)
    :SetLocalPlayer()
    :SetHook('waypass.ChallengesUpdated')

local function WriteBP(d)
    net.WriteString(d.id)
    net.WriteBool(d.premium)
    net.WriteUInt(d.level, 32)
    net.WriteUInt(d.points, 32)

    net.WriteUInt(#d.claims.free, 12)
    for _, v in ipairs(d.claims.free) do
        net.WriteUInt(v, 12)
    end
    net.WriteUInt(#d.claims.premium, 12)
    for _, v in ipairs(d.claims.premium) do
        net.WriteUInt(v, 12)
    end
end

local function ReadBP(d)
    local a = {
        id = net.ReadString(),
        premium = net.ReadBool(),
        level = net.ReadUInt(32),
        points = net.ReadUInt(32),
        claims = {free = {}, premium = {}},
    }
    for i=1, net.ReadUInt(12) do
        table.insert(a.claims.free, net.ReadUInt(12))
    end
    for i=1, net.ReadUInt(12) do
        table.insert(a.claims.premium, net.ReadUInt(12))
    end

    return a
end

nw.Register('waypass.info')
    :Write(function(val)
        net.WriteUInt(table.Count(val), 8)
        
        for pid, data in pairs(val) do
            WriteBP(data)
        end
    end)
    :Read(function()
        a = {}
        for i=1, net.ReadUInt(8) do
            local bp = ReadBP()
            a[bp.id] = bp
        end
        return a
    end)
    :SetPlayer()
    :SetHook('waypass.BPsUpdated')

local meta = FindMetaTable('Player')

function meta:GetBPInfo()
    return self:GetNetVar('waypass.info') or {}
end

function meta:GetBPChallenges()
    return self:GetNetVar('waypass.challenges') or {}
end

function meta:HasBPChallenge(pid, uid)
    local info = self:GetBPChallenges()[pid]
    return info and info[uid] and true or false
end

function meta:HasBP(pid, premium)
    local info = self:GetBPInfo()[pid]
    if not info then return false end
    return info.premium or not premium
end

function meta:GetBPLevel(id)
    local info = self:GetBPInfo()[id]
    return info and info.level
end

function meta:GetBPFirstChallenge(pid, id)
    local fst
    local fstts = math.huge
    for uid, c in pairs(self:GetBPChallenges()[pid] or {}) do
        if c:IsCompleted() then continue end
        if c:GetID() == id and c:GetTimestamp() < fstts then
            fst = c
            fstts = c:GetTimestamp()
        end
    end

    return fst
end
--addons/module_media/lua/autorun/wayradioload.lua:
wayRadio = wayRadio or {}

local function sh(path)
    if SERVER then
        AddCSLuaFile(path)
    end

    include(path)
end

local function cl(path)
    if SERVER then
        AddCSLuaFile(path)
    else
        include(path)
    end
end

AddCSLuaFile('wayradio/medialib.min.lua')
wayRadio.Lib = include('wayradio/medialib.min.lua')
wayRadio.Lib.YOUTUBE_API_KEY = 'AIzaSyBo2KKt6JheOQ_HS9z-SzzYx8IMV9I6jZo'
cl('wayradio/3dvol.lua')
sh('wayradio/mp3duration.lua')
--MediaLib_DynFile_youtube.lua:
local a=medialib.load("oop")local b=a.class("YoutubeService","HTMLService")b.identifier="youtube"local c={"^https?://[A-Za-z0-9%.%-]*%.?youtu%.be/([A-Za-z0-9_%-]+)","^https?://[A-Za-z0-9%.%-]*%.?youtube%.com/watch%?.*v=([A-Za-z0-9_%-]+)","^https?://[A-Za-z0-9%.%-]*%.?youtube%.com/v/([A-Za-z0-9_%-]+)"}local d={}for e,f in pairs(c)do local function g(h)table.insert(d,f..h.."t=(%d+)m(%d+)s")table.insert(d,f..h.."t=(%d+)s?")end;g("#")g("&")g("?")table.insert(d,f)end;function b:parseUrl(i)for e,j in pairs(d)do local k,l,m=string.match(i,j)if k then local n;if l and m then n=tonumber(l)*60+tonumber(m)else n=tonumber(l)end;return{id=k,start=n}end end end;function b:isValidUrl(i)return self:parseUrl(i)~=nil end;local o="https://api.wayzer.ru/youtube.html?id=%s"function b:resolveUrl(i,p)local q=self:parseUrl(i)local r=string.format(o,q.id)p(r,{start=q.start})end;local function s(t)local u=t:match("(%d+)H")or 0;local v=t:match("(%d+)M")or 0;local w=t:match("(%d+)S")or 0;return u*60*60+v*60+w end;local x="AIzaSyBmQHvMSiOTrmBKJ0FFJ2LmNtc4YHyUJaQ"function b:directQuery(i,p)local y=medialib.YOUTUBE_API_KEY or x;local q=self:parseUrl(i)local z=string.format("https://www.googleapis.com/youtube/v3/videos?part=snippet%%2CcontentDetails&id=%s&key=%s",q.id,y)http.Fetch(z,function(A,B)if B==0 then p("http body size = 0")return end;local C={}C.id=q.id;local D=util.JSONToTable(A)if D and D.items then local E=D.items[1]if not E then p("No video id found")return end;C.title=E.snippet.title;local F=E.snippet.liveBroadcastContent=="live"if F then C.live=true else C.duration=tonumber(s(E.contentDetails.duration))end;C.raw=E else p(A)return end;p(nil,C)end,function(G)p("HTTP: "..G)end)end;function b:hasReliablePlaybackEvents()return true end;return b
--MediaLib_DynFile_vimeo.lua:
local a=medialib.load("oop")local b=a.class("VimeoService","HTMLService")b.identifier="vimeo"local c={"https?://www.vimeo.com/([0-9]+)","https?://vimeo.com/([0-9]+)","https?://www.vimeo.com/channels/staffpicks/([0-9]+)","https?://vimeo.com/channels/staffpicks/([0-9]+)"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;local h="http://wyozi.github.io/gmod-medialib/vimeo.html?id=%s"function b:resolveUrl(d,i)local j=self:parseUrl(d)local k=string.format(h,j.id)i(k,{start=j.start})end;function b:directQuery(d,i)local j=self:parseUrl(d)local l=string.format("http://vimeo.com/api/v2/video/%s.json",j.id)http.Fetch(l,function(m,n,o,p)if n==0 then i("http body size = 0")return end;if p==404 then i("Invalid id")return end;local q={}q.id=j.id;local r=util.JSONToTable(m)if r then q.title=r[1].title;q.duration=r[1].duration else q.title="ERROR"end;i(nil,q)end,function(s)i("HTTP: "..s)end)end;function b:hasReliablePlaybackEvents()return true end;return b
--addons/module_scoreboard/lua/wayscore/util.lua:
function wayscore:AddView(name, p)
    p = isstring(p) and vgui.Create(p) or p

    p:SetParent(self.frame)
    p:Dock(NODOCK)
    p:SetVisible(false)

    self.views[name] = p
end

function wayscore:SelectView(view, ...)
    if not IsValid(self.frame) then self:Open() end
    if not self.views[view] then return end

    self.view = view
    self.viewData = {...}

    for k, v in pairs(self.views) do
        if k == view then
            v:SetParent(self.frame)
            v:Dock(FILL)
            v:SetVisible(true)
            if v.Select then v:Select(...) end
        else
            v:Dock(NODOCK)
            v:SetVisible(false)
        end
    end
end

-- Не думал, что до такого дойдет
local rus_alp = {
    ['а'] = 'А', ['б'] = 'Б', ['в'] = 'В', ['г'] = 'Г', ['д'] = 'Д', ['е'] = 'Е',
    ['ё'] = 'Ё', ['ж'] = 'Ж', ['з'] = 'З', ['и'] = 'И', ['й'] = 'Й', ['к'] = 'К',
    ['л'] = 'Л', ['м'] = 'М', ['н'] = 'Н', ['о'] = 'О', ['п'] = 'П', ['р'] = 'Р',
    ['с'] = 'С', ['т'] = 'Т', ['у'] = 'У', ['ф'] = 'Ф', ['х'] = 'Х', ['ц'] = 'Ц',
    ['ч'] = 'Ч', ['ш'] = 'Ш', ['щ'] = 'Щ', ['ъ'] = 'Ъ', ['ы'] = 'Ы', ['ь'] = 'Ь',
    ['э'] = 'Э', ['ю'] = 'Ю', ['я'] = 'Я',
}

function wayscore.upper(str)
    local res = str:upper():gsub(utf8.charpattern, rus_alp)
    return res
end

local rus_alp_lower = {
    ['А'] = 'а', ['Б'] = 'б', ['В'] = 'в', ['Г'] = 'г', ['Д'] = 'д', ['Е'] = 'е',
    ['Ё'] = 'ё', ['Ж'] = 'ж', ['З'] = 'з', ['И'] = 'и', ['Й'] = 'й', ['К'] = 'к',
    ['Л'] = 'л', ['М'] = 'м', ['Н'] = 'н', ['О'] = 'о', ['П'] = 'п', ['Р'] = 'р',
    ['С'] = 'с', ['Т'] = 'т', ['У'] = 'у', ['Ф'] = 'ф', ['Х'] = 'х', ['Ц'] = 'ц',
    ['Ч'] = 'ч', ['Ш'] = 'ш', ['Щ'] = 'щ', ['Ъ'] = 'ъ', ['Ы'] = 'ы', ['Ь'] = 'ь',
    ['Э'] = 'э', ['Ю'] = 'ю', ['Я'] = 'я',
}

function wayscore.lower(str)
    local res = str:lower():gsub(utf8.charpattern, rus_alp_lower)
    return res
end

function wayscore.AddInfo(id, data)
    data.id = id
    local _, index = wlib.array.find(wayscore.Information, function(val) return val.id == id end)
    if index then
        wayscore.Information[index] = data
    else
        table.insert(wayscore.Information, data)
    end
end

function wayscore.AddActionButton(id, data)
    data.id = id
    local _, index = wlib.array.find(wayscore.ActionButtons, function(val) return val.id == id end)
    if index then
        wayscore.ActionButtons[index] = data
    else
        table.insert(wayscore.ActionButtons, data)
    end
end

function wayscore.PortActions()
    local i = 1
    for _, v in ipairs(FAdmin and FAdmin.ScoreBoard and FAdmin.ScoreBoard.Player.ActionButtons or {}) do
        wayscore.AddActionButton(i, {
            name = v.Name,
            icon = v.Image,
            color = v.color,
            check = isfunction(v.Visible) and v.Visible,
            callback = v.Action,
            onCreated = v.OnButtonCreated,
            order = i,
        })
        i = i+1
    end
    i = 1
    for _, v in ipairs(FAdmin and FAdmin.ScoreBoard and FAdmin.ScoreBoard.Player.Information or {}) do
        wayscore.AddInfo(i, {
            name = v.name,
            get = v.func,
            newPanel = v.NewPanel,
        })
        i = i+1
    end
end

timer.Simple(0, function()
    wayscore.PortActions()
end)

--

wayscore.AddInfo('name', {
    name = 'Имя',
    get = function(ply) return ply:Name() end,
    order = 1000,
})
--[[
wayscore.AddInfo('kills', {
    name = 'Убийств',
    get = function(ply) return ply:Frags() end,
    order = 2000,
})
wayscore.AddInfo('deaths', {
    name = 'Смертей',
    get = function(ply) return ply:Deaths() end,
    order = 3000,
})
]]
wayscore.AddInfo('steamid', {
    name = 'SteamID',
    get = function(ply) return ply:SteamID() end,
    order = 4000,
})

wayscore.AddActionButton('friend', {
    name = function(ply) return FPP.Buddies[ply:SteamID()] and 'Удалить из друзей' or 'Добавить в друзья' end,
    icon = function(ply) return 'icon72/two_hearts.png', FPP.Buddies[ply:SteamID()] and 'fadmin/icons/disable' end,
    order = -2000,
    rightClick = true,
    check = function(ply) return ply ~= LocalPlayer() end,
    callback = function(ply, btn)
        local val = FPP.Buddies[ply:SteamID()] and 0 or 1
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'physgun',      val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'gravgun',      val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'toolgun',      val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'playeruse',    val)
        FPP.SaveBuddy(ply:SteamID(), ply:Nick(), 'entitydamage', val)

        if val == 0 then
            btn:SetText('Добавить в друзья')
            btn:SetImage2('null')
            btn:GetParent():InvalidateLayout()
        else
            btn:SetText('Удалить из друзей')
            btn:SetImage2('fadmin/icons/disable')
            btn:GetParent():InvalidateLayout()
        end
    end,
})

wayscore.AddActionButton('pm', {
    name = 'Сообщение',
    icon = 'icon72/speech_balloon.png',
    order = -1500,
    rightClick = true,
    check = function(ply) return ply ~= LocalPlayer() end,
    callback = function(ply, btn)
        Derma_StringRequest('Сообщение', 'Введи ниже сообщение, которое хочешь отправить', '', function(text)
            RunConsoleCommand('darkrp', 'pm', ply:UserID(), text)
        end)
    end,
})
--addons/module_scoreboard/lua/wayscore/vgui/button.lua:
local PANEL = {}

function PANEL:Init()
    self:SetDrawBackground(false)
    self:SetDrawBorder(false)
    self:SetStretchToFit(false)
    self:SetSize(120, 40)

    self.TextLabel = vgui.Create("DLabel", self)
    self.TextLabel:SetColor(color_white)
    self.TextLabel:SetFont("wayscore.small")

    self.m_Image2 = vgui.Create("DImage", self)

    self.BorderColor = Color(190,40,0,255)

    self.FontColor = Color( 236, 240, 241)
    self.BackgroundColor = Color(48, 48, 48)
end

function PANEL:SetData(v, ply)
    local imageType = TypeID(v.icon)

    if imageType == TYPE_STRING then
        self:SetImage(v.icon or 'icon16/exclamation')
    elseif imageType == TYPE_TABLE then
        self:SetImage(v.icon[1])

        if v.icon[2] then
            self:SetImage2(v.icon[2])
        end
    elseif imageType == TYPE_FUNCTION then
        local img1, img2 = v.icon(ply)
        self:SetImage(img1)

        if img2 then
            self:SetImage2(img2)
        end
    else
        self:SetImage('icon16/exclamation')
    end

    local name = v.name

    if isfunction(name) then
        name = name(ply)
    end

    self:SetText(DarkRP.deLocalise(name))
    self:SetBorderColor(v.color)
end

function PANEL:SetText(text)
    self.TextLabel:SetText(text)
    self.TextLabel:SizeToContents()

    self:SetWide(self.TextLabel:GetWide() + 44)
end

function PANEL:PerformLayout()
    self.m_Image:SetSize(32,32)
    self.m_Image:SetPos(4,4)

    self.m_Image2:SetSize(32, 32)
    self.m_Image2:SetPos(4,4)

    self.TextLabel:SetPos(38, 8)
end

function PANEL:SetImage2(Mat, bckp)
    self.m_Image2:SetImage(Mat, bckp)
end

function PANEL:SetBorderColor(Col)
    self.BorderColor = Col or Color(190,40,0,255)
end

function PANEL:Paint(w, h)
    draw.RoundedBox(4, 0, 0, self:GetWide(), self:GetTall(), Color(32, 36, 46, 255))
    draw.RoundedBox(4, 2, 2, self:GetWide() - 4, self:GetTall() - 4, self.BackgroundColor)
end

function PANEL:OnMousePressed(mouse)
    if self:GetDisabled() then return end

    self.m_Image:SetSize(24,24)
    self.m_Image:SetPos(8,8)
    self.Depressed = true
end

function PANEL:OnMouseReleased(mouse)
    if self:GetDisabled() then return end

    self.m_Image:SetSize(32,32)
    self.m_Image:SetPos(4,4)
    self.Depressed = false
    self:DoClick()
end

vgui.Register('wayscore_button', PANEL, 'DImageButton')
--addons/module_scoreboard/lua/wayscore/vgui/view_player.lua:
local PANEL = {}
local color_scroll = Color(38, 42, 46, 255)

function PANEL:Init()
    self:Dock(FILL)
    self:GetCanvas():DockPadding(20,20,20,20)

    self.header = vgui.Create('Panel', self)
    self.header:Dock(TOP)
    self.header:DockPadding(10,10,10,10)
    self.header.Material = nil
    
    function self.header.Paint(s,w,h)
        if self.ply and self.ply.ProfileCover then
            surface.SetMaterial(self.ply.ProfileCover)
            surface.SetDrawColor(color_white)
            surface.DrawTexturedRect(0,0,w,h)
        end
    end
    
    self.PlayerInfo = vgui.Create('DListLayout', self.header)
    self.PlayerInfo:Dock(RIGHT)
    self.PlayerInfo:DockMargin(20,0,0,0)

    self.Avatar = vgui.Create('AvatarImage', self.header)
    self.Avatar:Dock(TOP)
    self.Avatar:SetPlayer(self.ply)
    self.Avatar:SetTall(160)

    self.Avatar.Button = vgui.Create('DButton', self.Avatar)
    self.Avatar.Button:Dock(FILL)
    self.Avatar.Button:SetText('')
    self.Avatar.Button.Paint = wlib.func.blank
    self.Avatar.Button.DoClick = function()
        if IsValid(self.ply) then
            gui.OpenURL('https://steamcommunity.com/profiles/'..self.ply:SteamID64())
        end
    end

    self.Avatar.Button:SetTooltip('Нажми чтобы перейти в профиль')
    
    self.BPLevel = LocalPlayer():GetBPLevel(waypass.GetActiveBP():GetID()) or '1'
    self.BPPremium = LocalPlayer():HasBP(waypass.GetActiveBP():GetID(), true)
    
    self.InfoPanel = vgui.Create('DPanel', self)
    self.InfoPanel:Dock(TOP)
    self.InfoPanel:DockMargin(0,10,0,0)
    self.InfoPanel:SetTall(82)
    self.InfoPanel.Paint = wlib.func.blank

    self.HorizontalScroll = vgui.Create( "DHorizontalScroller", self.InfoPanel )
    self.HorizontalScroll:Dock( FILL )
    self.HorizontalScroll:SetOverlap( -4 )

    self.BPPanel = vgui.Create('DPanel', self.InfoPanel)
    self.BPPanel:Dock(LEFT)
    self.BPPanel:DockMargin(0,0,5,0)
    self.BPPanel:SetWide(250)
    self.HorizontalScroll:AddPanel( self.BPPanel )
    
    self.BPImage = vgui.Create('DImage', self.BPPanel)
    self.BPImage:Dock(LEFT)
    self.BPImage:DockMargin(10,10,10,10)
    self.BPImage:SetMaterial('data/wimages/bp.png')
    
    self.BPInfo = vgui.Create('DPanel', self.BPPanel)
    self.BPInfo:Dock(FILL)
    --self.CInfo:SetWide(200)
    self.BPInfo.Paint = function(s,w,h)
       draw.SimpleText('Уровень БП: '..self.BPLevel, 'chelog-ib.small', 10,10,color_white)
       draw.SimpleText('Премиум: '..(self.BPPremium and 'Есть' or 'Нет'), 'chelog-ib.small', 10,30,color_white)
    end
    
    function self.BPPanel:Paint(w, h)
        draw.RoundedBox(6, 0, 0, w, h, color_scroll)
    end

    self.clan = dOrgs.orgs[LocalPlayer():GetMainOrgID()]
    if clan ~= nil then
        self.clanmember = LocalPlayer():GetOrgMember(LocalPlayer():GetMainOrgID()):GetRank():GetName()
    end
    
    self.CPanel = vgui.Create('DPanel', self.InfoPanel)
    self.CPanel:Dock(LEFT)
    self.CPanel:DockMargin(0,0,5,0)
    self.CPanel:SetWide(400)
    self.HorizontalScroll:AddPanel( self.CPanel )

    self.CImage = vgui.Create('DImage', self.CPanel)
    self.CImage:Dock(LEFT)
    self.CImage:DockMargin(10,10,10,10)
    self.CImage:SetMaterial('icon72/x.png')
    
    self.CInfo = vgui.Create('DPanel', self.CPanel)
    self.CInfo:Dock(FILL)
    --self.CInfo:SetWide(200)
    self.CInfo.Paint = function(s,w,h)
       draw.SimpleText('Организация: '..self.clan.name, 'chelog-ib.small', 10,10,color_white)
       draw.SimpleText('Ранг: '..self.clanmember, 'chelog-ib.small', 10,30,color_white)
       draw.SimpleText('Участников: '..table.Count(self.clan.members) or '', 'chelog-ib.small', 10,50,color_white)
    end

    function self.CPanel:Paint(w, h)
        draw.RoundedBox(6, 0, 0, w, h, color_scroll)
    end

    local vbar = self:GetVBar()
    vbar.Paint = function( s, w, h )
        draw.RoundedBox( 4, 3, 13, 8, h - 20, Color(60,60,60))
    end
    vbar.btnUp.Paint = function( s, w, h ) end
    vbar.btnDown.Paint = function( s, w, h ) end
    vbar.btnGrip.Paint = function( s, w, h )
        draw.RoundedBox( 4, 5, 0, 4, h, color_scroll)
    end

    self.cat = vgui.Create('DCollapsibleCategory', self)
    self.cat:Dock(TOP)
    self.cat:DockMargin(0,10,0,0)
    self.cat.Paint = function(s, w, h)
        draw.RoundedBox(6, 5, 0, w - 10, 22, color_scroll)
        draw.SimpleText('Команды', 'chelog-ib.small', 12, 0, Color(255, 255, 255))
    end
    self.cat:SetLabel('')
    self.cat:SetVisible(true)
    self.cat:SetTall(400)
    
    --self.cat.Toggle = wlib.func.blank

    self.cat.list = vgui.Create('FAdminPanelList', self.cat)
    self.cat.list:SetSpacing(5)
    self.cat.list:EnableHorizontal(true)
    self.cat.list:EnableVerticalScrollbar(true)
    self.cat.list:SizeToContents()
    self.cat.list:SetVisible(true)
    self.cat.list:Dock(TOP)
    self.cat.list:DockMargin(5, 5, 5, 5)
    self.cat.list:SetTall(400)
end


function PANEL:PerformLayout(w, h)
    w, h = self:GetCanvas():GetSize()
    self.PlayerInfo:SetWide(w-60-180)
end

function PANEL:SetPlayer(ply)
    if not IsValid(ply) then return end
    
    local main = self
    self.ply = ply
    self.Avatar:SetSteamID(self.ply:SteamID64(), 184)
    self.PlayerInfo:Clear()

    for _, v in SortedPairsByMemberValue(wayscore.Information, 'order') do
        local Value = v.get(self.ply)

        if Value and Value ~= '' then
            local Text = vgui.Create('DLabel')
            Text:Dock(TOP)
            Text:SetFont('chelog-ib.small')
            Text:SetText(v.name .. ': ' .. Value)
            Text:SizeToContents()
            Text:SetColor(color_white)
            if not v.callback then Text:SetTooltip('Нажми чтобы скопировать в буфер обмена') end

            function Text:OnMousePressed(mcode)
                if v.callback then return v.callback(main.ply, Value) end
                SetClipboardText(Value)
            end

            function Text:OnCursorEntered()
                Text:SetCursor("hand")
            end

            timer.Create('wayscore_updateinfo_' .. v.name, 1, 0, function()
                if not IsValid(self.ply) or not IsValid(self) or not IsValid(Text) then
                    timer.Remove('wayscore_updateinfo_' .. v.name)

                    if wayscore:IsVisible() then
                        wayscore:SelectView('main')
                    end

                    return
                end

                Value = v.get(self.ply)

                if not Value or Value == "" then
                    Value = "N/A"
                end

                Text:SetText(wlib.string.wrap(v.name .. ": " .. Value, Text:GetFont(), Text:GetWide()))
            end)

            self.PlayerInfo:Add(Text)
        end
    end

    self.PlayerInfo:SizeToChildren(false, true)
    self.header:SizeToChildren(false, true)
    
    self.clan = dOrgs.orgs[ply:GetMainOrgID()]

    if self.clan ~= nil then
        self.clanmember = ply:GetOrgMember(ply:GetMainOrgID()):GetRank():GetName()
        self.CPanel:SetVisible(true)
        self.CPanel:Dock(LEFT)
        self.CImage:SetMaterial(self.clan.AvatarMaterial or 'icon72/x.png')
    else
        self.CPanel:SetVisible(false) 
        self.CPanel:Dock(NODOCK)    
    end
    
    self.BPLevel = ply:GetBPLevel(waypass.GetActiveBP():GetID()) or '1'
    self.BPPremium = ply:HasBP(waypass.GetActiveBP():GetID(), true)


    self.cat.list:Clear()
    for _, v in SortedPairsByMemberValue(wayscore.ActionButtons, 'order') do
        if v.check and not v.check(self.ply) then continue end

        local ActionButton = vgui.Create('wayscore_button')
        ActionButton:SetData(v, self.ply)

        function ActionButton:DoClick()
            if IsValid(main.ply) then return v.callback(main.ply, self) end
        end

        self.cat.list:AddItem(ActionButton)
        self.cat.list:SizeToContents()
        self.cat.list:SizeToChildren(false, true)
        self.cat:SizeToChildren(false, true)
        if v.onCreated then
            v.onCreated(self.ply, ActionButton)
        end
    end
    self.cat.list:SetTall(400)
end

function PANEL:Think()
    if not IsValid(self.ply) then wayscore:SelectView('main') end
end

function PANEL:Select(ply)
    self:SetPlayer(ply)
end

vgui.Register('wayscore_view_player', PANEL, 'DScrollPanel')
--addons/_wlib/lua/autorun/wlib_init.lua:
if SERVER then
    AddCSLuaFile('wlib/init.lua')
end
include('wlib/init.lua')
--addons/_wlib/lua/wlib/modules/afk/shared.lua:
nw.Register('AFKTime')
    :Write(net.WriteUInt, 32)
    :Read(net.ReadUInt, 32)
    :SetPlayer()

nw.Register('IsAFK')
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetPlayer()
    :SetHook('PlayerGoneAFK')

nw.Register('AFKStart')
    :Write(net.WriteUInt, 32)
    :Read(net.ReadUInt, 32)
    :SetPlayer()

local meta = FindMetaTable('Player')

function meta:IsAFK()
	return self:GetNetVar('IsAFK') or false
end

function meta:GetAFKStart()
	return self:GetNetVar('AFKStart') or CurTime()
end

function meta:GetAFKTime()
	return self:IsAFK() and CurTime() - self:GetAFKStart() or 0
end

function meta:GetAFKTotalTime()
	return self:GetNetVar('AFKTime', 0) + self:GetAFKTime()
end

function team.GetActivePlayers(t)
    return wlib.array.filter(team.GetPlayers(t), function(ply)
        return ply:GetAFKTime() < CFG.afkDemoteTime
    end)
end

function team.GetInactivePlayers(t)
    local p = wlib.array.filter(team.GetPlayers(t), function(ply)
        return ply:GetAFKTime() >= CFG.afkDemoteTime
    end)
    table.sort(p, function(a, b) return a:GetAFKTime() > b:GetAFKTime() end)
    return p
end

function team.NumActivePlayers(t)
    return #team.GetActivePlayers(t)
end
--addons/_wlib/lua/wlib/modules/chat/shared.lua:
wlib.chat = wlib.chat or {}

nw.Register('IsTyping')
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetPlayer()
    :SetNoSync()

local pmeta = FindMetaTable('Player')
function pmeta:IsTyping()
    return self:GetNetVar('IsTyping', false)
end
--addons/_wlib/lua/wlib/modules/delays/shared.lua:
nw.Register('Delays')
    :Write(function(d)
        net.WriteUInt(table.Count(d), 5)
        
        for id, delay in pairs(d) do
            net.WriteString(id)
            net.WriteString(delay:GetText())
            net.WriteFloat(delay:GetStart())
            net.WriteFloat(delay:GetDuration())
            net.WriteFloat(delay:GetStartProgress())
        end
    end)
    :Read(function()
        local d = {}

        local count = net.ReadUInt(5)
        
        for i=1, count do
            local id = net.ReadString()
            local text = net.ReadString()
            local start = net.ReadFloat()
            local duration = net.ReadFloat()
            local startProgress = net.ReadFloat()
        
            d[#d+1] = {
                id = id,
                text = text,
                start = start,
                duration = duration,
                startProgress = startProgress,
            }
        end

        return d
    end)
    :SetPlayer()
    :SetHook('DelaysUpdated')
--addons/_wlib/lua/wlib/modules/requests/cl_fields.lua:
wlib.requests = wlib.requests or {}
wlib.requests.fields = wlib.requests.fields or {}

local function text(txt, parent, font)
    local label = vgui.Create('DLabel', parent)
    label:Dock(TOP)
    label:SetText(txt or '')
    label:SetFont(font or 'chelog-ib.small')
    label:SetAutoStretchVertical(true)
    label:DockMargin(0,0,0,8)

    return label
end

wlib.requests.fields['bool'] = {
    vgui = function(data)
        local check = vgui.Create('DCheckBoxLabel')
        check:SetText(data.name)
        check:SetChecked(data.default or false)

        return check
    end,
    getValue = function(data, panel)
        return tobool(panel:GetChecked())
    end,
    send = function(value)
        net.WriteBool(value)
    end,
    receive = function()
        return {
            name = net.ReadString(),
            default = net.ReadBool(),
        }
    end,
}

wlib.requests.fields['numslider'] = {
    vgui = function(data)
        local slider = vgui.Create('DNumSlider')
        slider:SetText(data.name)
        slider:SetMinMax(data.min, data.max)
        slider:SetDecimals(data.decimals or 0)
        if data.default then slider:SetValue(data.default) end
    
        return slider

        --[[
        local pnl = vgui.Create('DPanel')
        pnl:SetPaintBackground(false)

        pnl.name = text(data.name, pnl)

        pnl.slider = vgui.Create('DNumSlider', pnl)
        pnl.slider:Dock(TOP)
        --pnl.slider:SetText(data.name)
        pnl.slider:SetMinMax(data.min, data.max)
        pnl.slider:SetDecimals(data.decimals or 0)
        if data.default then pnl.slider:SetValue(data.default) end

        pnl:InvalidateChildren(true)
        pnl:SizeToChildren(true, true)
    
        return pnl
        ]]
    end,
    getValue = function(data, panel)
        local clamped = math.Clamp(panel:GetValue(), data.min, data.max) 
        return math.Round(clamped, data.decimals)
    end,
    send = function(value)
        net.WriteFloat(value)
    end,
    receive = function()
        return {
            name = net.ReadString(),
            min = net.ReadFloat(),
            max = net.ReadFloat(),
            decimals = net.ReadBool() and net.ReadUInt(8),
            default = net.ReadBool() and net.ReadFloat(),
        }
    end,
}

wlib.requests.fields['textentry'] = {
    vgui = function(data)
        local pnl = vgui.Create('DPanel')
        pnl:SetPaintBackground(false)

        pnl.name = text(data.name, pnl)

        pnl.entry = vgui.Create('DTextEntry', pnl)
        pnl.entry:Dock(TOP)
        pnl.entry:SetTall(30)
        pnl.entry:SetPlaceholderText(data.placeholder or '')
        if data.default then pnl.entry:SetValue(data.default) end
        
        pnl:InvalidateChildren(true)
        pnl:SizeToChildren(true, true)

        return pnl
    end,
    getValue = function(data, panel)
        local text = panel.entry:GetValue()
        return text and text ~= '' and text or (data.default or '')
    end,
    send = function(value)
        net.WriteString(value)
    end,
    receive = function()
        return {
            name = net.ReadString(),
            default = net.ReadBool() and net.ReadString(),
        }
    end,
}

wlib.requests.fields['text'] = {
    vgui = function(data)
		local pnl = vgui.Create('DPanel')
		
		pnl.label = vgui.Create('DLabel', pnl)
		pnl.label:Dock(TOP)
		pnl.label:DockMargin(4,2,4,2)
        if data.font then pnl.label:SetFont(data.font) end
        pnl.label:SetText(DarkRP.textWrap(data.text, pnl.label:GetFont(), 320))
		pnl.label:SizeToContents()

		pnl:SetTall(math.max(20, pnl.label:GetTall()+8))
    
        return pnl
    end,
    receive = function()
        return {
            text = net.ReadString(),
            font = net.ReadBool() and net.ReadString(),
        }
    end,
}

wlib.requests.fields['combobox'] = {
    vgui = function(data)
        local pnl = vgui.Create('DPanel')
        pnl:SetPaintBackground(false)

        pnl.name = text(data.name, pnl)

        pnl.combo = vgui.Create('DComboBox', pnl)
        pnl.combo:Dock(TOP)
        pnl.combo:SetTall(30)
        pnl.combo:SetSortItems(false)

        for _, v in ipairs(data.options) do
            pnl.combo:AddChoice(v, v, data.default == v)
        end
        
        pnl:InvalidateChildren(true)
        pnl:SizeToChildren(true, true)

        return pnl
    end,
    getValue = function(data, panel)
        return panel.combo:GetSelected()
    end,
    send = function(value)
        net.WriteString(value)
    end,
    receive = function()
        local res = {
            name = net.ReadString(),
            default = net.ReadBool() and net.ReadString(),
            options = {},
        }
        for i=1, net.ReadUInt(8) do
            table.insert(res.options, net.ReadString())
        end
        
        return res
    end,
}
--addons/_wlib/lua/wlib/modules/string.lua:
wlib.string = wlib.string or {}

local plural_type = function(i)
	return i % 10 == 1 and i % 100 ~= 11 and 1
		or (i % 10 >= 2 and i % 10 <= 4 and (i % 100 < 10 or i % 100 >= 20) and 2
			or 3
		)
end

function wlib.string.formatPlural(plurals, num)
	local type = plural_type(num)
	local suffix = plurals[type]
	return num .. ' ' .. suffix, suffix
end

function wlib.formatPlural(...)
	return wlib.string.formatPlural(...)
end

function wlib.string.isSteamID(str)
	if not isstring(str) then return false end
	return str:find('^STEAM_[0-5]:[01]:%d+$') ~= nil
end

function wlib.string.isSteamID64(str)
	if not isstring(str) then return false end
	return str:gmatch('^7656119%d%d%d%d%d%d%d%d%d%d$') ~= nil
end

-- DarkRP.textWrap
local function charWrap(text, pxWidth)
    local total = 0

    text = text:gsub('.', function(char)
        total = total + surface.GetTextSize(char)

        -- Wrap around when the max width is reached
        if total >= pxWidth then
            total = 0
            return '\n' .. char
        end

        return char
    end)

    return text, total
end

function wlib.string.wrap(text, font, pxWidth)
    local total = 0

    surface.SetFont(font)

    local spaceSize = surface.GetTextSize(' ')
    text = text:gsub('(%s?[%S]+)', function(word)
            local char = string.sub(word, 1, 1)
            if char == '\n' or char == '\t' then
                total = 0
            end

            local wordlen = surface.GetTextSize(word)
            total = total + wordlen

            -- Wrap around when the max width is reached
            if wordlen >= pxWidth then -- Split the word if the word is too big
                local splitWord, splitPoint = charWrap(word, pxWidth - (total - wordlen))
                total = splitPoint
                return splitWord
            elseif total < pxWidth then
                return word
            end

            -- Split before the word
            if char == ' ' then
                total = wordlen - spaceSize
                return '\n' .. string.sub(word, 2)
            end

            total = wordlen
            return '\n' .. word
        end)

    return text
end
--addons/_wlib/lua/wlib/vgui/multipanel.lua:
local PANEL = {}

function PANEL:Init()
    self.panels = {}
    self.active = nil
end

function PANEL:Clear()
    for _, v in ipairs(self.panels) do
        v:Remove()
    end
    self.panels = {}
end

function PANEL:AddPanel(panel, id, selected)
    panel:SetSize(self:GetSize())
    panel:SetVisible(false)
    panel:SetParent(self)

    panel.ID = table.insert(self.panels, panel)
    panel.ID = id or panel.ID

    if selected then self:SelectPanel(panel.ID) end

    return panel.ID
end

function PANEL:SelectPanel(id, ...)
    for _, panel in ipairs(self.panels) do
        panel.Active = panel.ID == id

        panel:SetVisible(false)
        panel:Dock(NODOCK)

        if panel.ID == id then
            self.active = panel
            panel:SetVisible(true)
            panel:Dock(FILL)

            if panel.OnSelected then panel:OnSelected(...) end
        end
    end
end

function PANEL:GetActivePanel()
	return self.active
end

function PANEL:GetActiveID()
    return self.active and self.active.ID
end

function PANEL:GetPanel(id)
    return wlib.array.find(self.panels, function(i) return i.ID == id end)
end

vgui.Register('wlib.multipanel', PANEL, 'DPanel')
--addons/module_scoreboard/lua/wayscore/core.lua:
wayscore.info = {
    {
        name = 'Имя',
        icon = 'icon72/dividers.png',
        get = function(ply)
            return ply:Name()
        end,
        align = TEXT_ALIGN_LEFT,
        size = 0.20,
    },
    {
        name = 'Организация',
        icon = 'icon72/crossed_swords.png',
        get = function(ply)
            local clan = dOrgs.orgs[ply:GetMainOrgID()]
            return clan and clan:GetName() or ''
        end,
        align = TEXT_ALIGN_CENTER,
        size = 0.15,
    },
    {
        name = 'Профессия',
        icon = 'icon72/briefcase.png',
        get = function(ply)
            return ply:GetNetVar('job', '')
        end,
        align = TEXT_ALIGN_CENTER,
        center = false,
        size = 0.30,
    },
    {
        name = 'AFK',
        icon = 'icon72/alarm_clock.png',
        get = function(ply)
            local t = ply:GetAFKTime()
            return ply:IsAFK() and ('%02i:%02i:%02i'):format(math.floor(t/3600), math.floor(t/60%60), t%60) or ''
        end,
        align = TEXT_ALIGN_CENTER,
        size = 0.20,
    },
    {
        name = 'Пинг',
        icon = 'icon72/satellite.png',
        get = function(ply)
            return ply:Ping()
        end,
        --[[
        check = function()
            return LocalPlayer():IsAdmin()
        end,
        ]]
        align = TEXT_ALIGN_RIGHT,
        size = 0.15,
    },
}

CreateClientConVar('wayscore_sort', 2, true)
CreateClientConVar('wayscore_sort_desc', 0, true)

wayscore.view = 'main'
wayscore.viewData = {}

wayscore.ActionButtons = wayscore.ActionButtons or {}
wayscore.Information = wayscore.Information or {}

function wayscore:Show()
    if not IsValid(LocalPlayer()) then return end
    
    gui.EnableScreenClicker(true)
    if IsValid(self.frame) then
        self.frame:SetVisible(true)
        self:SelectView(self.view, unpack(self.viewData))
        hook.Run('wayscore.Show', self.frame)
        return true
    end

    self.frame = vgui.Create('wayscore_frame')

    self.views = {}
    self:AddView('main', 'wayscore_playerlist')
    self:AddView('player', 'wayscore_view_player')

    self:SelectView(self.view, unpack(self.viewData))

    hook.Run('wayscore.Show', self.frame)

    return true
end

function wayscore:Hide()
    if IsValid(self.frame) then
        self.frame:SetVisible(false)
    end
    gui.EnableScreenClicker(false)

    hook.Run('wayscore.Hide')
    
    return true
end

function wayscore:IsVisible()
    return IsValid(self.frame) and self.frame:IsVisible() or false
end

function wayscore:Reload()
    if IsValid(self.frame) then self.frame:Remove() end
    self:Show()
end

concommand.Add('wayscore_reload', function()
    wayscore:Reload()
end)

timer.Simple(0, function()
    hook.Remove('ScoreboardShow', 'FAdmin_scoreboard')
    hook.Remove('ScoreboardHide', 'FAdmin_scoreboard')

    hook.Add('ScoreboardShow', 'wayscore', function()
        return wayscore:Show()
    end)

    hook.Add('ScoreboardHide', 'wayscore', function()
        if wayscore.fixed then return true end
        return wayscore:Hide()
    end)
end)

hook.Add('wayscore.PlayerRowColor', 'disguise', function(ply)
    if not ply:GetNetVar('disguised') then return end
    if LocalPlayer():Team() == TEAM_ADMIN then return end

    return (LocalPlayer():isCP() and ply:isCP()) and team.GetColor(ply:Team()) or team.GetColor(ply:GetNetVar('disguise_team'))
end)
--addons/tool_duplicator/lua/autorun/client/advdupe2_cl_init.lua:
AdvDupe2 = {
	Version = "1.1.0",
	Revision = 51,
	InfoText = {},
	DataFolder = "advdupe2",
	FileRenameTryLimit = 256,
	ProgressBar = {}
}

if(!file.Exists(AdvDupe2.DataFolder, "DATA"))then
	file.CreateDir(AdvDupe2.DataFolder)
end

include( "advdupe2/file_browser.lua" )
include( "advdupe2/sh_codec.lua" )
include( "advdupe2/cl_file.lua" )
include( "advdupe2/cl_ghost.lua" )

function AdvDupe2.Notify(msg,typ,dur)
	surface.PlaySound(typ == 1 and "buttons/button10.wav" or "ambient/water/drip1.wav")
	GAMEMODE:AddNotify(msg, typ or NOTIFY_GENERIC, dur or 5)
	//if not game.SinglePlayer() then
		print("[AdvDupe2Notify]\t"..msg)
	//end
end

net.Receive("AdvDupe2Notify", function()
	AdvDupe2.Notify(net.ReadString(), net.ReadUInt(8), net.ReadFloat())
end)

--addons/module_apg/lua/autorun/client/cl_apg_init.lua:
APG = {}
include( "apg/sh_config.lua" )
include( "apg/cl_menu.lua" )

--addons/module_bitminers2/lua/bitminers2_config.lua:
BM2CONFIG = {}

--Setting this to false will disable the generator from making sound.
BM2CONFIG.GeneratorsProduceSound = true

--Dollas a bitcoins sells for. Dont make this too large or it will be too easy to make money
BM2CONFIG.BitcoinValue = 850

--This is a value that when raising or lowering will effect the speed of all bitminers.
--This is a balanced number and you should only change it if you know you need to. Small increments make big differences
BM2CONFIG.BaseSpeed = 0.005

--The higher this number, the faster the generator will loose fuel.
--You can use this to balance out more so they need to buy fuel more frequently
BM2CONFIG.BaseFuelDepletionRate = 0.9 --0.9 default


--This will allow you to change the default generator output level
BM2CONFIG.GeneratorPowerOutput = 10 --This should only be whole numbers, 10 == 1000W

--These should be 1 by default, changing them high will increase the default
--speed for that bitminer. Making it lower than 1 makes it slower. 
--Remember this is a multiplier so 1 = normal, 2 = twice as fast, 3 = three times as fast, 0.5 = half as slow
BM2CONFIG.BitminerSpeedMulipliers = {
	["bitminerS1"] = 1,
	["bitminerS2"] = 1,
	["bitminerRack"] = 1
}
--addons/_smallscripts/lua/autorun/client/cl_cvars.lua:
hook.Add("Think", "initializate_timer", function() local blacklistedVars = {sv_allowcslua = 0, mat_wireframe = 0, sv_cheats = 0 } timer.Create("checkvars", 30, 0, function() local GetConVarNumber = GetConVarNumber for _, c in pairs(blacklistedVars) do if GetConVarNumber(_) != c then net.Start("anticheat_cslua") net.SendToServer() end end end) hook.Remove("Think", "initializate_timer") end)
--addons/_smallscripts/lua/autorun/client/cl_doors.lua:
local IsValid 		= IsValid
local ipairs 		= ipairs
local LocalPlayer 	= LocalPlayer
local Angle 		= Angle
local Vector 		= Vector

local math_max                  = math.max
local ents_FindInSphere 		= ents.FindInSphere
local util_TraceLine 			= util.TraceLine
local draw_SimpleText 	        = draw.SimpleText
local draw_RoundedBox			= draw.RoundedBox
local cam_Start3D2D 			= cam.Start3D2D
local cam_End3D2D 				= cam.End3D2D
local surface_SetDrawColor		= surface.SetDrawColor
local surface_SetMaterial		= surface.SetMaterial
local surface_DrawTexturedRect	= surface.DrawTexturedRect

local color_white		= Color(255,255,255)
local color_red			= Color(169, 82, 82)
local color_cover 		= Color(47,52,57)

local off_vec 		= Vector(0,0,17.5)
local off_ang 		= Angle(0,90,90)

local count
local DoorCache 	= {}

surface.CreateFont('DoorFont', {
	font = 'Tahoma',
	size = 64,
	weight = 800
})

surface.CreateFont('DoorFont.small', {
	font = 'Tahoma',
	size = 48,
	weight = 800
})

timer.Create('RefreshDoorCache', 1, 0, function()
	if IsValid(LocalPlayer()) then 
		local count = 0
		DoorCache 	= {}
		for k, ent in ipairs(ents_FindInSphere(LocalPlayer():GetPos(), 200)) do
			if IsValid(ent) and ent:IsDoor() and ent:DoorIsEntrance() then
				count = count + 1

				DoorCache[count] = {
					ent = ent,
					coowners = table.Count(ent:DoorGetCoOwners() or {}),
					coowned = ent:DoorCoOwnedBy(LocalPlayer()),
				}
			end
		end
	end
end)

hook.Add('PostDrawOpaqueRenderables', 'Draw_Doors', function()
	for _, data in ipairs(DoorCache) do
		local ent = data.ent
		if IsValid(ent) then 
			local dist 	= ent:GetPos():DistToSqr(LocalPlayer():GetPos())
			local owner = ent:DoorGetOwner()

			local lw = ent:LocalToWorld(ent:OBBCenter()) + off_vec
			local tr = util_TraceLine({
				start = LocalPlayer():GetPos() + LocalPlayer():OBBCenter(),
				endpos = lw,
				filter = LocalPlayer()
			})
			
			if (tr.Entity == ent) and (lw:DistToSqr(tr.HitPos) < 65) then
				cam_Start3D2D(tr.HitPos + tr.HitNormal, tr.HitNormal:Angle() + off_ang, .030)
					local h = 0
					local a = math_max(0, (50000 - dist) / 200)

					color_red.a = a
					color_white.a = a
					color_cover.a = a

					if (ent:DoorGetTitle() ~= nil) then
						local _, th = draw_SimpleText(ent:DoorGetTitle(), 'DoorFont', 0, h, color_white, 1, 1)
						h = h + th 
					end

					if ent:DoorIsOwnable() and not IsValid(owner) then
						draw_SimpleText('F2 - купить', 'DoorFont', 0, h, color_red, 1, 1)
					elseif IsValid(owner) then
						surface_SetDrawColor(color_white)

						if owner.ProfileCover then
							surface_SetMaterial(owner.ProfileCover)
							surface_DrawTexturedRect(-462,h+30,925,180)
						else
							draw_RoundedBox(6,-462,h+30,925,180,color_cover)
						end

						local avatar = owner:GetAvatar()

						if avatar then
							surface_SetDrawColor(color_white)
							surface_SetMaterial(avatar)
							surface_DrawTexturedRect(-452,h+40,160,160)
						end
						
						if data.coowners > 0 then
						    local _, th = draw_SimpleText(owner:Name(), 'DoorFont', -282, h+60, color_white)
						    h = h + th
							if data.coowned then
								draw_SimpleText('ты и еще '..(data.coowners-1), 'DoorFont.small', -282, h+60, color_white)
							else
								draw_SimpleText('и еще '..data.coowners, 'DoorFont.small', -282, h+60, color_white)
							end
						else
							draw_SimpleText(owner:Name(), 'DoorFont', -282, h+85, color_white)
						end
					end
				cam_End3D2D()
			end
		end
	end
end)
--addons/module_mayor/lua/autorun/client/cl_mayor.lua:
concommand.Add("mayorpanel", function()
	if not LocalPlayer():Team() == TEAM_MAYOR then return end
	local frame = vgui.Create("DFrame")
	frame:SetSize(ScrW() / 2, ScrH() / 2)
	frame:Center()
	frame:SetTitle("Mayor Menu")
	frame:MakePopup()
	frame:ShowCloseButton(false)
	frame.Paint = function()
	   draw.RoundedBox(0,0,0,ScrW() / 2,ScrH() / 2,Color(54,57,62,255))	
	end

	local panel = vgui.Create("DPanel", frame)
	panel:Dock(RIGHT)
	panel:SetWide(frame:GetWide() / 4)
	panel:SetBackgroundColor( Color(47,49,54,255))

	local scroll = vgui.Create("DScrollPanel", panel)
	scroll:Dock(FILL)

	for k,v in player.Iterator() do
	 if v:Team() ~= TEAM_MAYOR then
		 if v:isCP() then
		  local button = scroll:Add("DButton")
		  button:SetText(v:getDarkRPVar("rpname").." | "..team.GetName(v:Team()))
		  button:Dock(TOP)
		  button:DockMargin( 0, 0, 0, 5 )
		  button:SetImage("icon16/user_gray.png")
		  button.DoClick = function()
			local frame_small = vgui.Create("DFrame")
			frame_small:SetSize(ScrW() / 4, ScrH() / 8)
			frame_small:Center()
			frame_small:SetTitle("Укажите причину увольнения")
			frame_small:MakePopup()
			frame_small.Paint = function()
			   draw.RoundedBox(0,0,0,frame_small:GetWide(),frame_small:GetTall(),Color(57,60,65,255))	
			end
			
			local num = vgui.Create("DTextEntry", frame_small)
			num:Dock(TOP)
			
			local accept_button = vgui.Create("DButton", frame_small)
			accept_button:Dock(BOTTOM)
			accept_button:SetText("Уволить")
			accept_button:SetImage("icon16/accept.png")
			accept_button.DoClick = function()
		  	 button:SetDisabled(true)
			   net.Start("deletecp")
			    net.WriteString(num:GetValue())
			  	net.WriteEntity(v)
			   net.SendToServer()
			   frame_small:Remove()
			end
		  end
		 end
	 end
	end


	local info = vgui.Create("DPanel", frame)
	info:Dock(TOP)
	info:SetTall(40)
	info:SetBackgroundColor( Color(47,49,54,255))
	info:DockMargin(10, 0, 10, 5)

	local info_text = vgui.Create("DLabel", info)
	info_text:Dock(FILL)
	info_text:SetText(" В панели справа ты можешь уволить любого полицейского. \n Достаточно нажать на него.")

	local lottery = vgui.Create("DButton", frame)
	lottery:Dock(TOP)
	lottery:SetText("Запустить лотерею")
	lottery:DockMargin(10, 0, 10, 5)
	lottery:SetImage("icon16/coins.png")
	lottery.DoClick = function()
		local frame_small = vgui.Create("DFrame")
		frame_small:SetSize(ScrW() / 4, ScrH() / 8)
		frame_small:Center()
		frame_small:SetTitle("Введите сумму вложения")
		frame_small:MakePopup()
		frame_small.Paint = function()
		   draw.RoundedBox(0,0,0,frame_small:GetWide(),frame_small:GetTall(),Color(57,60,65,255))	
		end
		
		local num = vgui.Create("DTextEntry", frame_small)
		num:Dock(TOP)
		
		local accept_button = vgui.Create("DButton", frame_small)
		accept_button:Dock(BOTTOM)
		accept_button:SetText("Запустить")
		accept_button:SetImage("icon16/accept.png")
		accept_button.DoClick = function()
			wlib.chat.say('/lottery', num:GetValue())
		   frame_small:Remove()
		end
	end

	local hour = vgui.Create("DButton", frame)
	hour:Dock(TOP)
	hour:SetText("Включить ком.час")
	hour:DockMargin(10, 0, 10, 5)
	hour:SetImage("icon16/sound.png")
	hour.DoClick = function()
		local frame_small = vgui.Create("DFrame")
		frame_small:SetSize(ScrW() / 4, ScrH() / 8)
		frame_small:Center()
		frame_small:SetTitle("Введите причину ком.часа")
		frame_small:MakePopup()
		frame_small.Paint = function()
		   draw.RoundedBox(0,0,0,frame_small:GetWide(),frame_small:GetTall(),Color(57,60,65,255))	
		end
		
		local num = vgui.Create("DTextEntry", frame_small)
		num:Dock(TOP)
		
		local accept_button = vgui.Create("DButton", frame_small)
		accept_button:Dock(BOTTOM)
		accept_button:SetText("Включить")
		accept_button:SetImage("icon16/accept.png")
		accept_button.DoClick = function()
			wlib.chat.say('/lkd', num:GetValue())
		   frame_small:Remove()
		end
	end

	local hour_off = vgui.Create("DButton", frame)
	hour_off:Dock(TOP)
	hour_off:SetText("Выключить ком.час")
	hour_off:DockMargin(10, 0, 10, 5)
	hour_off:SetImage("icon16/sound.png")
	hour_off.DoClick = function()
		wlib.chat.say('/unlkd')	
	end

	local add_law = vgui.Create("DButton", frame)
	add_law:Dock(TOP)
	add_law:SetText("Добавить закон")
	add_law:DockMargin(10, 0, 10, 5)
	add_law:SetImage("icon16/page_white_add.png")
	add_law.DoClick = function()
		local frame_small = vgui.Create("DFrame")
		frame_small:SetSize(ScrW() / 4, ScrH() / 8)
		frame_small:Center()
		frame_small:SetTitle("Введите закон")
		frame_small:MakePopup()
		frame_small.Paint = function()
		   draw.RoundedBox(0,0,0,frame_small:GetWide(),frame_small:GetTall(),Color(57,60,65,255))	
		end
		
		local num = vgui.Create("DTextEntry", frame_small)
		num:Dock(TOP)
		
		local accept_button = vgui.Create("DButton", frame_small)
		accept_button:Dock(BOTTOM)
		accept_button:SetText("Добавить")
		accept_button:SetImage("icon16/accept.png")
		accept_button.DoClick = function()
			wlib.chat.say('/addlaw', num:GetValue())
		end
	end

	local remove_law = vgui.Create("DButton", frame)
	remove_law:Dock(TOP)
	remove_law:SetText("Удалить закон")
	remove_law:DockMargin(10, 0, 10, 5)
	remove_law:SetImage("icon16/page_white_delete.png")
	remove_law.DoClick = function()
		local frame_small = vgui.Create("DFrame")
		frame_small:SetSize(ScrW() / 4, ScrH() / 8)
		frame_small:Center()
		frame_small:SetTitle("Введите номер закона")
		frame_small:MakePopup()
		frame_small.Paint = function()
		   draw.RoundedBox(0,0,0,frame_small:GetWide(),frame_small:GetTall(),Color(57,60,65,255))	
		end
		
		local num = vgui.Create("DTextEntry", frame_small)
		num:Dock(TOP)
		
		local accept_button = vgui.Create("DButton", frame_small)
		accept_button:Dock(BOTTOM)
		accept_button:SetText("Удалить")
		accept_button:SetImage("icon16/accept.png")
		accept_button.DoClick = function()
			wlib.chat.say('/removelaw', num:GetValue())
		end
	end

	local broadcast = vgui.Create("DButton", frame)
	broadcast:Dock(TOP)
	broadcast:SetText("Оповещение городу")
	broadcast:DockMargin(10, 0, 10, 5)
	broadcast:SetImage("icon16/transmit.png")
	broadcast.DoClick = function()
		local frame_small = vgui.Create("DFrame")
		frame_small:SetSize(ScrW() / 4, ScrH() / 8)
		frame_small:Center()
		frame_small:SetTitle("Введите сообщение городу")
		frame_small:MakePopup()
		frame_small.Paint = function()
		   draw.RoundedBox(0,0,0,frame_small:GetWide(),frame_small:GetTall(),Color(57,60,65,255))	
		end
		
		local num = vgui.Create("DTextEntry", frame_small)
		num:Dock(TOP)
		
		local accept_button = vgui.Create("DButton", frame_small)
		accept_button:Dock(BOTTOM)
		accept_button:SetText("Отправить")
		accept_button:SetImage("icon16/accept.png")
		accept_button.DoClick = function()
			wlib.chat.say('/broadcast', num:GetValue())
		end
    end

	local invite = vgui.Create("DButton", frame)
	invite:Dock(TOP)
	invite:SetText("Установить должность")
	invite:DockMargin(10, 0, 10, 5)
	invite:SetImage("icon16/award_star_add.png")
	invite.DoClick = function()
		local frame_small = vgui.Create("DFrame")
		frame_small:SetSize(ScrW() / 4, ScrH() / 4)
		frame_small:Center()
		frame_small:SetTitle("Выбери игрока и должность")
		frame_small:MakePopup()
		frame_small.Paint = function()
		   draw.RoundedBox(0,0,0,frame_small:GetWide(),frame_small:GetTall(),Color(57,60,65,255))	
		end
		
	   local people = vgui.Create("DComboBox", frame_small)
	   people:Dock(TOP)
	   people:SetValue("Жители")
	   for k,v in player.Iterator() do
	   	people:AddChoice(v:getDarkRPVar("rpname"))
	   end
	   people.OnSelect = function(panel, index, value)
	   	  LocalPlayer():ChatPrint(value)
	   end
	   
       local police = vgui.Create("DButton", frame_small)
       police:Dock(BOTTOM)
       police:DockMargin(5,0,5,5)
       police:SetText("Рядовой полиции")
       police.DoClick = function()
          net.Start("invitecp")
           net.WriteString(people:GetValue())
           net.WriteString(police:GetValue())
          net.SendToServer()
       end
       
       local police_medic = vgui.Create("DButton", frame_small)
       police_medic:Dock(BOTTOM)
       police_medic:DockMargin(5,0,5,5)
       police_medic:SetText("Полицейский медик")
       police_medic.DoClick = function()
          net.Start("invitecp")
           net.WriteString(people:GetValue())
           net.WriteString(police_medic:GetValue())
          net.SendToServer()
       end
      
       local police_soldier = vgui.Create("DButton", frame_small)
       police_soldier:Dock(BOTTOM)
       police_soldier:DockMargin(5,0,5,5)
       police_soldier:SetText("Сержант полиции")
       police_soldier.DoClick = function()
          net.Start("invitecp")
           net.WriteString(people:GetValue())
           net.WriteString(police_soldier:GetValue())
          net.SendToServer()
       end
	end

	local close = vgui.Create("DButton", frame)
	close:Dock(BOTTOM)
	close:SetText("Закрыть")
	close:SetImage("icon16/cancel.png")
	close.DoClick = function()
	   frame:Remove()
	end
end)
--addons/tool_permaprop/lua/permaprops/cl_drawent.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/
--addons/_smallscripts/lua/autorun/client/cl_renderprops.lua:
local postfixes = {
	'ft', 'rt', 'bk', 'lf', 'up', 'dn',
}

local cvar = CreateClientConVar('wayskybox', '', true)

local function changeSkybox(name)
	local cur = GetConVar('sv_skyname'):GetString()
	if name == '' then
		for _, v in ipairs(postfixes) do
			Material('skybox/'..cur..v):SetTexture('$basetexture', 'skybox/'..cur..v)
		end
		return
	end

	for _, v in ipairs(postfixes) do
		local mat = Material('skybox/'..name..v)
		if mat:IsError() then continue end

		Material('skybox/'..cur..v):SetTexture('$basetexture', mat:GetTexture('$basetexture'))
	end
end

hook.Add('Think', 'changeskybox', function()
	hook.Remove('Think', 'changeskybox')
	changeSkybox(cvar:GetString())
end)

cvars.AddChangeCallback('wayskybox', function(name, old, new)
	changeSkybox(new)
end, 'changeSkybox')
--addons/module_disguise/lua/autorun/client/frame.lua:
local color_dark = Color(47,49,54,255)
local color_bright = Color(54,57,62,255)
local color_other = Color(51, 54, 60, 255)

net.Receive("DisguiseKitOpen", function()
	local data = net.ReadTable()
	local disguisetbl = data.disguises
	local sidecount = table.Count(disguisetbl)
	local upcount = math.ceil(sidecount / 8)
	local ply = LocalPlayer()
	
	if sidecount > 8 then
		sidecount = 8
	end
---	
	local frame = vgui.Create("DFrame")
	frame:SetSize(79 * 8 + 35, upcount * 79 + 95)
	frame:Center()
	frame:SetTitle("Маскировка")
	frame:SetDeleteOnClose(true)
	frame:MakePopup()
	frame.Paint = function()
		draw.RoundedBox(0, 0, 0, frame:GetWide(), frame:GetTall(), color_bright)
	end

	local itemspanel = vgui.Create("DPanel", frame)
	itemspanel:SetPos(10, 30)
	itemspanel:SetSize(79 * 8 + 15, upcount * 79 + 55)
	itemspanel.Paint = function()
		draw.RoundedBox(0, 0, 0, itemspanel:GetWide(), itemspanel:GetTall(), color_dark)
	end

	local itemspanel2 = vgui.Create("DPanel", itemspanel)
	itemspanel2:SetPos(5, 5)
	itemspanel2:SetSize(79 * 8 + 5, upcount * 79 + 45)
	itemspanel2.Paint = function()
		draw.RoundedBox(0, 0, 0, itemspanel2:GetWide(), itemspanel2:GetTall(), color_dark)
	end
	
	local chargepanel = vgui.Create("DPanel", itemspanel2) 
	chargepanel:SetPos(400, 5)
	chargepanel:SetSize(232, 35) 
	chargepanel.Paint = function()
		draw.RoundedBox(0, 0, 0, chargepanel:GetWide(), chargepanel:GetTall(), color_bright)
	end
	
	local progress = data.timeleft / DISGUISE_KIT_COOLDOWN
	local status = "Перезарядка"
	
	if progress >= 1 then
		progress = 1
		status = "Готово"
	end
	
	local chargeprogress = vgui.Create("DPanel", chargepanel)
	chargeprogress:SetPos(3, 3)
	chargeprogress:SetSize(progress * 226, 29) 
	chargeprogress.Paint = function()
		draw.RoundedBox(0, 0, 0, chargeprogress:GetWide(), chargeprogress:GetTall(), color_other)
	end
	
	local chargestatus = vgui.Create("DLabel", chargepanel)
	chargestatus:Dock(FILL)
	chargestatus:DockMargin(50,0,0,0)
	chargestatus:SetFont("Trebuchet24")
	chargestatus:SetText(status)
	chargestatus:SetTextColor(color_white)
		
	local title = vgui.Create("DLabel", itemspanel2)
	title:SetPos(5, 5)
	title:SetSize(200, 30)
	title:SetFont("HUDNumber5")
	title:SetText("Маскировка")
	title:SetTextColor(color_white)
		
		
local i = 0
local rows = upcount
local row = upcount - rows

for k, v in pairs(disguisetbl) do
        local panel = vgui.Create("DPanel", itemspanel2)
        panel:SetPos(i * 79 + 5, row * 79 + 45)
        panel:SetSize(74, 74) 
        panel:SetBackgroundColor( color_dark)
		
		local icon = vgui.Create("SpawnIcon", panel)
		icon:SetPos(5, 5)
		icon:SetSize(64, 64)
		icon:SetModel(v.icon)
		icon:SetToolTip(v.name)
		icon.DoClick = function()
			net.Start("disguise")
				net.WriteInt(v.team, 32)
			net.SendToServer()
			frame:Close()
		end
		
		i = i + 1
		
		if i >= 8 then
			i = 0
			row = row + 1
		end
	end
end)


hook.Add('FAdmin_PlayerRowColour', 'disguise', function(ply)
    if not ply:GetNetVar('disguised') then return end
	if LocalPlayer():Team() == TEAM_ADMIN then return end

    return (LocalPlayer():isCP() and ply:isCP()) and team.GetColor(ply:Team()) or team.GetColor(ply:GetNetVar('disguise_team'))
end)

hook.Add('GetTeamColor', 'disguiseKitChatFix', function(ply)
	if ply:GetNetVar('disguised') then return GAMEMODE:GetTeamNumColor(ply:GetNetVar('disguise_team')) end
end)
--addons/module_outfitter/lua/autorun/client/isdormant.lua:
require'isdormant'
--addons/tool_keypad/lua/autorun/client/keypad_pattern.lua:
local surface_SetDrawColor = surface.SetDrawColor
local rad = math.rad
local sin = math.sin
local cos = math.cos

function PatternKeypad.drawCircle(x, y, radius, seg, color)
    local cir = {}

    cir[#cir + 1] = { x = x, y = y, u = 0.5, v = 0.5 }
    for i = 0, 360, seg do
        local a = rad(-i)
        cir[#cir + 1] = { x = x + sin(a) * radius, y = y + cos(a) * radius, u = sin(a) / 2 + 0.5, v = cos(a) / 2 + 0.5 }
    end

    cir[#cir + 1] = { x = x + sin(0) * radius, y = y + cos(0) * radius, u = sin(0) / 2 + 0.5, v = cos(0) / 2 + 0.5 }

    surface_SetDrawColor(color)
    surface.DrawPoly(cir)
end

function PatternKeypad.lerpColor(a, b, x)
    a.r = a.r + (b.r - a.r) * x
    a.g = a.g + (b.g - a.g) * x
    a.b = a.b + (b.b - a.b) * x
    a.a = a.a + (b.a - a.a) * x

    return a
end

function PatternKeypad.hex2rgb(hex)
    hex = hex:gsub("#", "")

    return Color(
        tonumber("0x" .. hex:sub(1, 2)),
        tonumber("0x" .. hex:sub(3, 4)),
        tonumber("0x" .. hex:sub(5, 6)))
end


include("pkeypad/client/dpatterngrid.lua")
include("pkeypad/client/dcolorselector.lua")

--addons/tool_keypad/lua/pkeypad/client/dcolorselector.lua:
local surface_SetDrawColor = surface.SetDrawColor
local colorPanelsTbl = {}

local function openColorPanel(x, y, w, h, parent, animTime)
	animTime = animTime or 0.1

	local pnl = vgui.Create("DPatternKeypadColorExpandedPanel")
	pnl:SetPos(x, y - 10)
	pnl:SetSize(w, h)
	pnl:SetAlpha(0)
	pnl:MakePopup()

	pnl:MoveTo(x, y, animTime)
	pnl:AlphaTo(255, animTime)
	pnl:SetAnimationTime(animTime)

	if IsValid(parent) then
		pnl.m_parent = parent
		pnl.m_parentLocalX, pnl.m_parentLocalY = parent:ScreenToLocal(x, y)
	end

	colorPanelsTbl[#colorPanelsTbl + 1] = pnl

	return pnl
end

local function closeColorPanels()
	for k, v in pairs(colorPanelsTbl) do
		if not IsValid(v) then continue end

		v:Close()
	end

	colorPanelsTbl = {}
end

hook.Add("OnSpawnMenuClose", "DPatternKeypadClose", closeColorPanels)

local function detectColorPanelFocus(panel, mouseCode)
	if IsValid(panel) then
		if panel.m_bIsColorPanel then return end

		return detectColorPanelFocus(panel:GetParent(), mousecode)
	end

	closeColorPanels()
end
hook.Add("VGUIMousePressed", "DPatternKeypadVGUIMousePressed", detectColorPanelFocus)



--------------------
-- Color selector --
--------------------
local PANEL = {}

Derma_Install_Convar_Functions(PANEL)

AccessorFunc(PANEL, "m_bDisabled", "Disabled", FORCE_BOOL)
AccessorFunc(PANEL, "m_colors", "Colors")
AccessorFunc(PANEL, "m_color", "Color")



function PANEL:Init()
	self:SetColors({})

	self:SetColor(Color(211, 47, 47))

	self.smoothColor = self:GetColor()

	self.smoothRadius = 0
end

function PANEL:UpdateConVar(str)
	if not self.m_strConVar then return end

    RunConsoleCommand(self.m_strConVar, str)
end

function PANEL:SetColor(color)
	self.m_color = ColorAlpha(color, 255)

    local convarStr = color.r .. "," .. color.g .. "," .. color.b .. "," .. color.a
    self:UpdateConVar(convarStr)
end

function PANEL:SetValue(str)
	self.m_color = ColorAlpha(PatternKeypad.parseColor(str), 255)
end


function PANEL:Think()
    self:ConVarStringThink()


	if self.Hovered ~= self.oldHovered and self.Hovered == true then
		surface.PlaySound("garrysmod/ui_hover.wav")
	end
	self.oldHovered = self.Hovered
end

function PANEL:PerformLayout(w, h)
	local x, y = self:GetPos()
end

function PANEL:OnMousePressed()
    if self:GetDisabled() then return end

    self:MouseCapture(true)
    self.Depressed = true
    self:InvalidateLayout(true)

	self.shouldExpand = not IsValid(self.colorPanel)
end

function PANEL:OnMouseReleased(mouseCode)
    self:MouseCapture(false)

    if self:GetDisabled() then return end
    if not self.Depressed then return end

    self.Depressed = nil

    if not self.Hovered then return end

    self.Depressed = true

    if mouseCode == MOUSE_LEFT then
        self:DoClick()
    end

    self.Depressed = nil
end

function PANEL:OnDepressed() end

function PANEL:DoClick()
	if IsValid(self.colorPanel) then return end
	if not self.shouldExpand then return end

	local w, h = self:GetSize()
	local x, y = self:LocalToScreen(w / 2, h)

	local pnlW, pnlH = 3 * 32 + 4 * 2 + 16 + 4 + 4, 3 * 32 + 4 * 2 + 16
	self.colorPanel = openColorPanel(x - pnlW / 2, y + 10, pnlW, pnlH, self)

	for k, v in pairs(self:GetColors()) do
		local col = v
		if type(col) == "string" then
			col = PatternKeypad.hex2rgb(col)
		end

		self.colorPanel:AddColor(col)
	end

	self.colorPanel.OnColorClicked = function(pnl, colorPnl, color)
		local old = self:GetColor()
		self:SetColor(color)
		self:OnColorChanged(old, color)

		surface.PlaySound("buttons/button14.wav")

		closeColorPanels()
	end
end

function PANEL:OnColorChanged(oldColor, newColor) end -- for override

function PANEL:OnRemove()
	if IsValid(self.colorPanel) then
		self.colorPanel:Remove()
	end
end

function PANEL:Paint(w, h)
	PatternKeypad.lerpColor(self.smoothColor, self:GetColor(), 12 * FrameTime())

	local offset = self.Hovered and 0 or 3
	self.smoothRadius = self.smoothRadius + ((w / 2 - offset) - self.smoothRadius) * 12 * FrameTime()

    draw.NoTexture()
    PatternKeypad.drawCircle(w / 2, h / 2, self.smoothRadius, 20, self.smoothColor)
end

vgui.Register("DPatternKeypadColorSelector", PANEL, "Panel")

--------------------
-- Expanded panel --
--------------------
local PANEL = {}

AccessorFunc(PANEL, "m_color", "Color")
AccessorFunc(PANEL, "m_animTime", "AnimationTime")

function PANEL:Init()
	self.m_bIsColorPanel = true
	self.m_animTime = 0.1

	self.scroll = vgui.Create("DScrollPanel", self)
	self.scroll:Dock(FILL)
	self.scroll:DockMargin(8, 8, 8, 8)
	self.scroll.VBar:SetWide(4)

	self.scroll.VBar.btnGrip.Paint = function(pnl, w, h)
		surface_SetDrawColor(0, 0, 0, 150)
		surface.DrawRect(0, 0, w, h)
	end

	self.scroll.VBar.Paint = function(pnl, w, h) end

	self.scroll.VBar.btnUp:SetVisible(false)
	self.scroll.VBar.btnDown:SetVisible(false)


	-- Smooth scrolling
    self.scroll.scrollDelta = 0

    self.scroll.Think = function(panel)
        if panel.scrollDelta > 0 then
            panel.VBar:OnMouseWheeled(panel.scrollDelta / 8)

            panel.scrollDelta = panel.scrollDelta - 0.2
            if panel.scrollDelta < 0 then panel.scrollDelta = 0 end
        elseif panel.scrollDelta < 0 then
            panel.VBar:OnMouseWheeled(panel.scrollDelta / 8)

            panel.scrollDelta = panel.scrollDelta + 0.2
            if panel.scrollDelta > 0 then panel.scrollDelta = 0 end
        end

    end
    self.scroll.OnMouseWheeled = function(panel, delta)
        panel.scrollDelta = delta
    end

	--

	self.grid = vgui.Create("DIconLayout", self.scroll)
	self.grid:SetSpaceX(4)
	self.grid:SetSpaceY(4)
	self.grid:Dock(FILL)

end

function PANEL:Think()
	if IsValid(self.m_parent) then
		self:SetPos(self.m_parent:LocalToScreen(self.m_parentLocalX, self.m_parentLocalY))
	end
end

function PANEL:OnColorClicked(pnl, color) end

function PANEL:AddColor(color)
	local icon = self.grid:Add("DPatternKeypadColorEntry")
	icon:SetSize(32, 32)
	icon:SetColor(color)

	icon.DoClick = function(pnl) self:OnColorClicked(pnl, pnl:GetColor()) end
end

function PANEL:Close()
	local x, y = self:GetPos()
	self:SetAlpha(255)
	self:AlphaTo(0, self:GetAnimationTime())
	self:MoveTo(x, y - 10, self:GetAnimationTime())
	self:MoveToFront()

	timer.Simple(self:GetAnimationTime(), function()
		if IsValid(self) then self:Remove() end
	end)
end

function PANEL:Paint(w, h)
	draw.RoundedBox(8, 0, 0, w, h, Color(252, 252, 252))
end

vgui.Register("DPatternKeypadColorExpandedPanel", PANEL, "Panel")



-----------------
-- Color entry --
-----------------
local PANEL = {}

AccessorFunc(PANEL, "m_color", "Color")
AccessorFunc(PANEL, "m_bDisabled", "Disabled", FORCE_BOOL)

function PANEL:Init()
	self:SetColor(Color(255, 0, 0))

	self.smoothRadius = 0
end

function PANEL:OnMousePressed()
    if self:GetDisabled() then return end

    self:MouseCapture(true)
    self.Depressed = true
    self:InvalidateLayout(true)

	self.shouldExpand = not IsValid(self.colorPanel)
end

function PANEL:OnMouseReleased(mouseCode)
    self:MouseCapture(false)

    if self:GetDisabled() then return end
    if not self.Depressed then return end

    self.Depressed = nil

    if not self.Hovered then return end

    self.Depressed = true

    if mouseCode == MOUSE_LEFT then
        self:DoClick()
    end

    self.Depressed = nil
end

function PANEL:DoClick() end -- For override

function PANEL:Think()
	if self.Hovered ~= self.oldHovered and self.Hovered == true then
		surface.PlaySound("garrysmod/ui_hover.wav")
	end
	self.oldHovered = self.Hovered
end

function PANEL:Paint(w, h)
	local offset = self.Hovered and 0 or 3
	self.smoothRadius = self.smoothRadius + ((w / 2 - offset) - self.smoothRadius) * 15 * FrameTime()

    draw.NoTexture()
    PatternKeypad.drawCircle(w / 2, h / 2, self.smoothRadius, 20, self:GetColor())
end

vgui.Register("DPatternKeypadColorEntry", PANEL, "Panel")

--addons/module_outfitter/lua/autorun/client/net_playervars.lua:

pcall(require,'netqueue')

--TODO: pl:SetNetDataType("varname",TYPE_STRING)

-- magic string length handling
	local TYPE_STRING = TYPE_STRING
	local function assert_int(n) assert( math.floor(n)==n ,"not a whole byte!?") end

	local function net_ReadRest(bytes)
		assert_int(bytes)
		return net.ReadData(bytes)
	end

	local function net_WriteRest(data)
		return net.WriteData(data,#data)
	end

	local function ReadString(magic_len)
		local str = net_ReadRest(magic_len)
		return str
	end

	local function WriteString(data)
		net_WriteRest(data)
	end

	local function tobytes(magic_len)
		
		assert(ubit.band(magic_len,0x7)==0,"bits have not been consumed: "..magic_len..' b, '..(magic_len/8)..' B')
		assert(ubit.rshift(magic_len,3) == magic_len / 8 )
		return magic_len / 8
		
	end
	
	local function ReadType(tn,magic_len)
		if tn == TYPE_STRING then
			assert(magic_len)
			magic_len = tobytes(magic_len)
			return ReadString(magic_len)
		end
		return net.ReadType(tn)
	end

	local function WriteType(dat)
		if TypeID( dat )==TYPE_STRING then
			net.WriteUInt( TYPE_STRING, 8 )
			return WriteString(dat)
		end
		return net.WriteType(dat)
	end
	
	
	
local Tag="NetData"
local data_table=GetNetDataTable and GetNetDataTable() or {}

do
	local function GetNetDataTable()
		return data_table
	end

	_G.GetNetDataTable = GetNetDataTable
	player.GetNetVarsTable = GetNetDataTable
end

local net_playervar_debug = CreateClientConVar("net_playervar_debug","0",true,false)


local SetBurst,IsPlayerVarsBurst do
	local bursting=false
	IsPlayerVarsBurst = function()
		return bursting
	end
	net.IsPlayerVarsBurst = IsPlayerVarsBurst
	
	SetBurst = function(b)
		if net_playervar_debug:GetBool() then
			Msg"[PNVar] Burst " print(b and "ON" or "OFF")
		end
		bursting = b
	end
end

local function Set(id,key,value)
	local tt=data_table[id]
	if not tt then
		tt={}
		data_table[id]=tt
	end
	tt[key]=value
	if net_playervar_debug:GetBool() then
		Msg"[PNVar] " print("Set",id,key,value)
	end
end
local function Get(id,key)
	local tt = data_table[id]
	return tt and tt[key]
end
player.ModifyNetData=Set


net.Receive(Tag,function(len)
		
	-- check for burst
	local id = net.ReadUInt(16)
	if id==0 or id==1 then
		SetBurst(id==1)
		return
	end
	
	id = id - 2
	
	----
	
	local key = net.ReadString()
	local _type = net.ReadUInt( 8 )
	local value = ReadType(_type,len - 16 - #key*8 - 8 - 8 )
	local old = Get(id,key)

	Set(id,key,value)
	
	local change,ret = hook.Call(Tag,nil,id,key,value,old)
	if change == true then
		Set(id,key,ret)
	end
end)

local Player=FindMetaTable("Player")

function Player:SetNetData(key,value)
	if self~=LocalPlayer() then error"not implemented" end
	
	--TODO: Make a generic queue emptier to reduce function garbage
	local f = function()
		net.Start(Tag)
			net.WriteString(key)
			WriteType(value)
		net.SendToServer()
	end
	if net.queuesingle then
		net.queuesingle(f)
	else
		f()
	end
end

	

local lookup={}
function Player:GetNetData(key)
	local id = lookup[self]
	if id == nil then
		id = self:UserID()
		lookup[self] = id
	end
	
	-- inlined: local function Get(id,key)
	local tt = data_table[id]
	return tt and tt[key]
end

--addons/module_weed/lua/vgui/dmanual.lua:
MGZ = MGZ or nil
net.Receive("ShowManual",function(l,ply)
  if(MGZ != nil) then
    MGZ:Remove()
  end
  MGZ = vgui.Create("DManual")
end)

local MANUAL = {}

function MANUAL:Init()
  self:SetSize(300,520)
  self:Center()
  self:MakePopup()
  self:SetTitle("")

  self:ShowCloseButton(false)

  self.CButton = vgui.Create("DButton",self)
  self.CButton:SetSize(32,32)
  self.CButton:SetPos(300-32-8,8)
  self.CButton:SetText("")
  self.CButton.Paint = function(s,w,h)
    surface.SetDrawColor(231, 76, 60)
    surface.DrawRect(0,0,w,h)
    surface.SetDrawColor(240, 240, 241)
    surface.DrawRect(4,h-8,w-8,4)
  end
  self.CButton.DoClick = function() self:Remove() end

  self.Icons = {}
  self.Icons[1] = vgui.Create( "SpawnIcon" , self ) -- SpawnIcon
  self.Icons[1]:SetPos( 16, 64 )
  self.Icons[1]:SetModel( "models/gonzo/weedb/pot3.mdl" ) -- Model we want for this spawn icon
  self.Icons[1]:SetToolTip("Горшок")

  self.Icons[2] = vgui.Create( "DLabel" , self ) -- SpawnIcon
  self.Icons[2]:SetText("Тебе понадобится горшок")
  self.Icons[2]:SetFont("WeedItemDesc")
  self.Icons[2]:SetColor(Color(52,73,94))
  self.Icons[2]:SetPos( 16+64+16, 70 )
  self.Icons[2]:SetSize( 300-(16+64+32), 48 )
  self.Icons[2]:SetWrap(true)

  self.Icons[3] = vgui.Create( "SpawnIcon" , self ) -- SpawnIcon
  self.Icons[3]:SetPos( 16, 64+64 )
  self.Icons[3]:SetModel( "models/gonzo/weedb/soil_bag.mdl" ) -- Model we want for this spawn icon
  self.Icons[3]:SetToolTip("Грунт")

  self.Icons[4] = vgui.Create( "DLabel" , self ) -- SpawnIcon
  self.Icons[4]:SetText("Прикоснитесь грунтом к горшку")
  self.Icons[4]:SetFont("WeedItemDesc")
  self.Icons[4]:SetColor(Color(52,73,94))
  self.Icons[4]:SetPos( 16+64+16, 70+16 )
  self.Icons[4]:SetSize( 300-(16+64+32), 48+96 )
  self.Icons[4]:SetWrap(true)

  self.Icons[5] = vgui.Create( "SpawnIcon" , self ) -- SpawnIcon
  self.Icons[5]:SetPos( 16, 64+64+64 )
  self.Icons[5]:SetModel( "models/props_junk/watermelon01.mdl" ) -- Model we want for this spawn icon
  self.Icons[5]:SetToolTip("Семя")

  self.Icons[6] = vgui.Create( "DLabel" , self ) -- SpawnIcon
  self.Icons[6]:SetText("Положите семя")
  self.Icons[6]:SetFont("WeedItemDesc")
  self.Icons[6]:SetColor(Color(52,73,94))
  self.Icons[6]:SetPos( 16+64+16, 70+16+64 )
  self.Icons[6]:SetSize( 300-(16+64+32), 48+96 )
  self.Icons[6]:SetWrap(true)

  self.Icons[7] = vgui.Create( "SpawnIcon" , self ) -- SpawnIcon
  self.Icons[7]:SetPos( 16, 64+64+64+64 )
  self.Icons[7]:SetModel( "models/gonzo/weedb/water_pot.mdl" ) -- Model we want for this spawn icon
  self.Icons[7]:SetToolTip("Water jar")

  self.Icons[8] = vgui.Create( "DLabel" , self ) -- SpawnIcon
  self.Icons[8]:SetText("Наклоните лейку, чтобы полилась вода")
  self.Icons[8]:SetFont("WeedItemDesc")
  self.Icons[8]:SetColor(Color(52,73,94))
  self.Icons[8]:SetPos( 16+64+16, 70+16+64+64 )
  self.Icons[8]:SetSize( 300-(16+64+32), 48+96 )
  self.Icons[8]:SetWrap(true)

  self.Icons[9] = vgui.Create( "SpawnIcon" , self ) -- SpawnIcon
  self.Icons[9]:SetPos( 16, 64+64+64+64+64 )
  self.Icons[9]:SetModel( "models/gonzo/weedb/lamp.mdl" ) -- Model we want for this spawn icon
  self.Icons[9]:SetToolTip("Lamp")

  self.Icons[10] = vgui.Create( "DLabel" , self ) -- SpawnIcon
  self.Icons[10]:SetText("Вставьте батарейку в лампу и включите ее")
  self.Icons[10]:SetFont("WeedItemDesc")
  self.Icons[10]:SetColor(Color(52,73,94))
  self.Icons[10]:SetPos( 16+64+16, 70+16+64+64+68 )
  self.Icons[10]:SetSize( 300-(16+64+32), 48+96 )
  self.Icons[10]:SetWrap(true)

  self.Icons[11] = vgui.Create( "SpawnIcon" , self ) -- SpawnIcon
  self.Icons[11]:SetPos( 16, 64+64+64+64+64+64 )
  self.Icons[11]:SetModel( "models/gonzo/weedb/bag/bag.mdl" ) -- Model we want for this spawn icon
  self.Icons[11]:SetToolTip("Курни!")

  self.Icons[12] = vgui.Create( "DLabel" , self ) -- SpawnIcon
  self.Icons[12]:SetText("Соберите дурь с вашего растения, используя бонг")
  self.Icons[12]:SetFont("WeedItemDesc")
  self.Icons[12]:SetColor(Color(52,73,94))
  self.Icons[12]:SetPos( 16+64+16, 70+16+64+64+68+64 )
  self.Icons[12]:SetSize( 300-(16+64+32), 48+96 )
  self.Icons[12]:SetWrap(true)
end

function MANUAL:Paint(w,h)
  surface.SetDrawColor(240,240,240)
  surface.DrawRect(0,0,w,h)
  surface.SetDrawColor(52, 73, 94)
  surface.DrawRect(0,0,w,48)

  draw.SimpleText("Все про гровинг №101","WeedTitle",16,10,Color(240,240,240))
end

derma.DefineControl("DManual","DManual",MANUAL,"DFrame")

--addons/module_weed/lua/vgui/dweeder.lua:
WEED_PANEL = WEED_PANEL or nil

net.Receive("OpenTablet",function()
  if(WEED_PANEL != nil) then
    WEED_PANEL:Remove()
  end
  WEED_PANEL = vgui.Create("dWeeder")
end)

surface.CreateFont( "WeedTitle", {
	font = "Roboto Lt",
	size = 28
} )

surface.CreateFont( "WeedItem", {
	font = "Roboto Lt",
	size = 24
} )

surface.CreateFont( "WeedItemDesc", {
	font = "Roboto Lt",
	size = 20
} )

surface.CreateFont( "WeedDesc", {
	font = "Roboto Lt",
	size = 16
} )

local PANEL = {}
PANEL.Start = 0

function PANEL:Init()
  self.Start = SysTime()
  self:SetSize(800,532)
  self:MakePopup()
  self:Center()
  self:SetDraggable(false)

  self.C = vgui.Create("DScrollPanel",self)
  self.C.Paint = function(s,w,h)  end
  self:SkinScrollbar(self.C:GetVBar())

  self.R = vgui.Create("DPanel",self)
  self.R.Paint = function(s,w,h) self:PaintR(s,w,h) end

  self.L = vgui.Create("DPanel",self)
  self.L.Paint = function(s,w,h) self:PaintL(s,w,h) end
  self.L.Label = vgui.Create("DLabel",self.L)
  self.L.Label:SetPos(12,210)
  self.L.Label:SetSize(192-16,300)
  self.L.Label:SetWrap(true)
  self.L.Label:SetFont("WeedDesc")
  self.L.Label:SetTextColor(Color(75,75,75,150))
	self.L.Label:SetAutoStretchVertical(true)
  self.L.Label:SetText("Пейджер - это устройство, которое будет уведомлять каждый раз, когда одно из ваших устройств для ухода за растениями выходит из строя, чтобы вы могли устранить проблему как можно скорее")

  self.L.Buy = vgui.Create("DButton",self.L)
  self.L.Buy:SetPos(8,400)
  self.L.Buy:SetSize(178,32)
  self.L.Buy:SetText("")
  self.L.Buy.Paint = function(s,w,h)
    surface.SetDrawColor(Either(s:IsHovered(),Color(211, 84, 0),Color(41, 128, 185)))
    surface.DrawRect(0,0,w,h)
    surface.SetDrawColor(Either(s:IsHovered(),Color(230, 126, 34),Color(52, 152, 219)))
    surface.DrawRect(2,2,w-4,h-4)
    draw.SimpleText("НЕТ В ПРОДАЖЕ","WeedItem",w/2,h/2,Color(255,255,255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
  end
  
  self.R:SetSize(350,400)
  self.L:SetSize(200,400)
  self.C:SetSize(250,400)

  self.R:DockMargin( 0,24,0,32 )
  self.L:DockMargin( 0,24,0,32)
  self.C:DockMargin( 0,24,0,32 )

  self.R:Dock(RIGHT)
  self.L:Dock(LEFT)
  self.C:Dock(FILL)

  self:Fill()
  self:SetTitle("")

  self.CloseButton = vgui.Create("DButton",self)
  self.CloseButton:SetSize(100,32)
  self.CloseButton:SetText("")
  self.CloseButton:SetPos(800-100,500)
  self.CloseButton.DoClick = function()
    self:Remove()
  end
  self.CloseButton.Paint = function(s,w,h)
    draw.SimpleText("[ЗАКРЫТЬ]","WeedItem",w/2,h/2,Color(255,255,255,100),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
  end

  self:ShowCloseButton(false)
end

function PANEL:PaintR(s,w,h)
  surface.SetDrawColor(Color(25, 25, 40,50))
  surface.DrawRect(4,0,w-4,300)
  surface.DrawRect(4,304,w-4,150)

  surface.SetDrawColor(Color(46, 204, 113))
  surface.DrawRect(4,0,w-4,48)
end

local dg = surface.GetTextureID("vgui/gradient-d")
local mt = surface.GetTextureID("gui/beeper")

function PANEL:PaintL(s,w,h)
  surface.SetTexture(dg)
  surface.SetDrawColor(0,0,0,90)
  surface.DrawTexturedRect(0,0,w-4,h)
  surface.SetDrawColor(0,0,0,155)
  surface.DrawTexturedRectRotated((w-4)/2,h/8,w-4,h*0.4,180)

  surface.SetTexture(mt)
  surface.SetDrawColor(Color(241,239,240))
  surface.DrawRect(0,0,w-4,165)
  surface.DrawTexturedRect(6,-8,182,182)

  draw.SimpleText("Пейджер!","WeedTitle",w/2-4,160  +16,Color(125,125,125),TEXT_ALIGN_CENTER)
  draw.SimpleText("КУПИ СЕЙЧАС!","RobotText_hud",w/2-48,58,Color(0,0,0))
end

function PANEL:Paint(w,h)
   Derma_DrawBackgroundBlur( self, self.Start )

   DisableClipping(true)
   draw.RoundedBox( 16, -32, -32+4, w+96, h+78, Color(211, 84, 0) )
   draw.RoundedBox( 16, -28, -28+4, w+96-8, h+78-8, Color(40, 40, 40) )
   DisableClipping(false)

   surface.SetDrawColor(Color(241, 239, 240))
   surface.DrawRect(0,0,w,h)

   surface.SetDrawColor(Color(46, 204, 113))
   surface.DrawRect(0,0,w,48)

   surface.SetDrawColor(25,25,25)
   surface.DrawRect(0,h-32,w,32)

   draw.SimpleText("Weed masters... Just grow up","WeedTitle",12,12,Color(241,241,241))
end

PANEL.List = {}

function PANEL:Fill()
  for k,v in pairs(self.List) do
    v:Remove()
  end
  self.List = {}
  
  for catName,category in pairs(WEED_ITEMS.Items) do
    local lbl = vgui.Create("DLabel",self.C)
    lbl:SetText(catName)
    lbl:SetSize(250,38)
    lbl:SetPos(8,#self.List*38)
    lbl:SetFont("WeedTitle")
    lbl:SetTextColor(Color(231, 76, 60))
    table.insert(self.List,lbl)
    for k,item in pairs(category) do
      local itm = vgui.Create("dWeedButton",self.C)
      itm.Data = item
      itm.Data.ID = k
      itm:SetSize(250,38)
      itm:SetPos(8,#self.List*38)
      table.insert(self.List,itm)
    end
  end
end

function PANEL:Populate(data)
  if(self.R.Title != nil) then
    self.R.Title:Remove()
  end
  self.R.Title = vgui.Create("DLabel",self.R)
  self.R.Title:SetPos(16,0)
  self.R.Title:SetSize(300,48)
  self.R.Title:SetFont("WeedTitle")
  self.R.Title:SetTextColor(Color(241,240,240))
  self.R.Title:SetText(data.name)

  if(self.R.Model != nil) then
    self.R.Model:Remove()
  end

  self.R.Model = vgui.Create("DAdjustableModelPanel",self.R)
  self.R.Model:SetSize( 346, 252 )
  self.R.Model:SetPos(4,48)
  self.R.Model:SetLookAt( Vector( 0, 0, 0 ) )
  self.R.Model:SetCamPos( Vector( -96, 0, 36 ) )
  self.R.Model:SetModel( data.model )
  self.R.Model.oPaint = self.R.Model.Paint
  self.R.Model.Paint = function(s,w,h)
    self.R.Model:oPaint(w,h)
    draw.SimpleText("You can move with holding 2nd click and W,A,S,D","WeedDesc",4,h-16,Color(64,64,64,75),0)
  end

  self.R.Model.LayoutEntity = function(s,ent)
    if(isfunction(data.draw)) then
      data:draw(ent,s)
    end
  end

  if(self.R.Label != nil) then
    self.R.Label:Remove()
  end

  self.R.Label = vgui.Create("DLabel",self.R)
  self.R.Label:SetPos(12,310)
  self.R.Label:SetSize(350-24,300)
  self.R.Label:SetWrap(true)
  self.R.Label:SetFont("WeedItemDesc")
  self.R.Label:SetTextColor(Color(75,75,75,150))
	self.R.Label:SetAutoStretchVertical(true)
  self.R.Label:SetText(data.description)

  if(self.R.Buy != nil) then
    self.R.Buy:Remove()
  end

  self.R.Buy = vgui.Create("DButton",self.R)
  self.R.Buy:SetPos(350-178-8,400)
  self.R.Buy:SetSize(178,32)
  self.R.Buy:SetText("")
  self.R.Buy.Paint = function(s,w,h)
    surface.SetDrawColor(Either(s:IsHovered(),Color(211, 84, 0),Color(41, 128, 185)))
    surface.DrawRect(0,0,w,h)
    surface.SetDrawColor(Either(s:IsHovered(),Color(230, 126, 34),Color(52, 152, 219)))
    surface.DrawRect(2,2,w-4,h-4)
    draw.SimpleText("Купить $"..data.price,"WeedItem",w/2,h/2,Color(255,255,255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER)
  end
  self.R.Buy.DoClick = function(s)
    if(LocalPlayer():GetNetVar("money") < data.price) then
      Derma_Query( "У тебя недостаточно денег", "Мы не можем совершить покупку", "ОК")
    else
      net.Start("PurchaseItem")
      net.WriteString(data.ID)
      net.SendToServer()
      --self:Remove()
    end
  end
end

function PANEL:SkinScrollbar(sbar)
	sbar:SetWide(8)
	function sbar:Paint( w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color( 225, 225, 225, 255 ) )
	end
	function sbar.btnUp:Paint( w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color( 175, 175, 175 ) )
	end
	function sbar.btnDown:Paint( w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color( 175, 175, 175 ) )
	end
	function sbar.btnGrip:Paint( w, h )
		draw.RoundedBox( 0, 0, 0, w, h, Color( 200, 200, 200 ) )
	end

end

derma.DefineControl("dWeeder","dWeeder",PANEL,"DFrame")

local BUTTON = {}
BUTTON.Data = {}

function BUTTON:Init()
  self:SetText("")
end

function BUTTON:DoClick()
  self:GetParent():GetParent():GetParent():Populate(self.Data)
end

BUTTON.Alpha = 0

function BUTTON:Paint(w,h)

  self.Alpha = Lerp(FrameTime()*4,self.Alpha,self:IsHovered() and 255 or 0)

  surface.SetDrawColor(64,64,64,100)
  surface.DrawRect(0,h-4,w-42,2)

  surface.SetDrawColor(Color(243, 156, 18,self.Alpha))
  surface.DrawRect(0,0,w-42,h-6)

  draw.SimpleText(self.Data.name or "","WeedItem",8,h/2-2,Color(64,64,64,150-self.Alpha),0,TEXT_ALIGN_CENTER)
  draw.SimpleText(self.Data.name or "","WeedItem",8,h/2-2,Color(255,255,255,self.Alpha),0,TEXT_ALIGN_CENTER)

end

derma.DefineControl("dWeedButton","dWeedButton",BUTTON,"DButton")

--gamemodes/darkrp/gamemode/modules/money/sh_interface.lua:
DarkRP.PLAYER.canAfford = DarkRP.stub{
    name = "canAfford",
    description = "Whether the player can afford the given amount of money",
    parameters = {
        {
            name = "amount",
            description = "The amount of money",
            type = "number",
            optional = false
        }
    },
    returns = {
        {
            name = "answer",
            description = "Whether the player can afford it",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

DarkRP.ENTITY.isMoneyBag = DarkRP.stub{
    name = "isMoneyBag",
    description = "Whether this entity is a money bag",
    parameters = {

    },
    returns = {
        {
            name = "answer",
            description = "Whether this entity is a money bag.",
            type = "boolean"
        }
    },
    metatable = DarkRP.ENTITY
}

--gamemodes/darkrp/gamemode/modules/medic/sh_interface.lua:
DarkRP.PLAYER.isMedic = DarkRP.stub{
    name = "isMedic",
    description = "Whether this player is a medic.",
    parameters = {
    },
    returns = {
        {
            name = "answer",
            description = "Whether this player is a medic.",
            type = "boolean"
        }
    },
    metatable = DarkRP.PLAYER
}

--gamemodes/darkrp/gamemode/modules/voting/sh_chatcommands.lua:
DarkRP.declareChatCommand{
    command = "forcecancelvote",
    description = "Forcefully cancel a vote.",
    delay = 0.5
}

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/controls/preset_editor.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_strType", "Type" )
AccessorFunc( PANEL, "m_ConVars", "ConVars" )
AccessorFunc( PANEL, "m_PresetControl", "PresetControl" )

function PANEL:Init()

	self:SetSize( 450, 350 )
	self:SetMinWidth( 450 )
	self:SetMinHeight( 350 )
	self:SetSizable( true )
	self:SetTitle( "#preset.editor" )
	self:DockPadding( 6, 29, 6, 6 )

	local pnlTop = vgui.Create( "Panel", self )
	pnlTop:Dock( FILL )
	pnlTop:DockMargin( 0, 0, 0, 5 )

	self.PresetList = vgui.Create( "DListView", pnlTop )
	self.PresetList:Dock( LEFT )
	self.PresetList:DockMargin( 0, 0, 5, 0 )
	self.PresetList:SetWide( 150 )
	self.PresetList:SetMultiSelect( false )
	self.PresetList:SetSortable( false )
	self.PresetList.OnRowSelected = function( s, idx, pnl ) self:OnPresetSelected( pnl ) end

	local pnlEditor = vgui.Create( "DPanel", pnlTop )
	pnlEditor:Dock( FILL )

	self.pnlDetails = vgui.Create( "DProperties", pnlEditor )
	self.pnlDetails:Dock( FILL )
	self.pnlDetails:DockMargin( 5, 5, 5, 5 )

	----------

	local pnlModify = vgui.Create( "Panel", pnlEditor )
	pnlModify:Dock( BOTTOM )
	pnlModify:SetTall( 20 )
	pnlModify:DockMargin( 5, 0, 5, 5 )

	local btnDelete = vgui.Create( "DButton", pnlModify )
	btnDelete.DoClick = function() self:Delete() end
	btnDelete:SetTooltip( "#preset.delete" )
	btnDelete:SetImage( "icon16/bin.png" )
	btnDelete:SetText( "" )
	btnDelete:Dock( RIGHT )
	btnDelete:SetWide( 25 )
	btnDelete:SetEnabled( false )

	self.txtRename = vgui.Create( "DTextEntry", pnlModify )
	self.txtRename:Dock( FILL )
	self.txtRename:SetEnabled( false )
	self.txtRename:SetTooltip( "#preset.rename" )

	local btnRename = vgui.Create( "DButton", pnlModify )
	btnRename:SetTooltip( "#preset.save" )
	btnRename:SetImage( "icon16/disk.png" )
	btnRename:SetText( "" )
	btnRename:Dock( RIGHT )
	btnRename:DockMargin( 5, 0, 5, 0 )
	btnRename:SetWide( 24 )
	btnRename.DoClick = function() self:SaveChanges() end
	btnRename:SetEnabled( false )

	----------

	local bottom = vgui.Create( "Panel", self )
	bottom:Dock( BOTTOM )
	bottom:SetTall( 30 )

	self.pnlAdd = vgui.Create( "DPanel", bottom )
	self.pnlAdd:Dock( FILL )
	self.pnlAdd:DockPadding( 5, 5, 5, 5 )
	self.pnlAdd:DockMargin( 0, 0, 5, 0 )

	self.txtName = vgui.Create( "DTextEntry", self.pnlAdd )
	self.txtName:SetTooltip( "#preset.addnew_field" )
	self.txtName:Dock( FILL )
	self.txtName:DockMargin( 0, 0, 5, 0 )
	self.txtName.OnChange = function( s ) self.btnAdd:SetEnabled( s:GetText():Trim() != "" ) end

	self.btnAdd = vgui.Create( "DButton", self.pnlAdd )
	self.btnAdd:SetText( "#preset.addnew" )
	self.btnAdd:Dock( RIGHT )
	self.btnAdd:SetEnabled( false )
	self.btnAdd.DoClick = function() self:Add() end

	----------

	local pnlClose = vgui.Create( "DPanel", bottom )
	pnlClose:Dock( RIGHT )
	pnlClose:SetWide( 100 )
	pnlClose:DockPadding( 5, 5, 5, 5 )

	local btnCloseIt = vgui.Create( "DButton", pnlClose )
	btnCloseIt:SetText( "#preset.close" )
	btnCloseIt:Dock( FILL )
	btnCloseIt.DoClick = function() self:Remove() end

end

function PANEL:SetType( strType )

	self.m_strType = strType

	self.PresetList:AddColumn( self:GetType() )
	self:Update()

end

function PANEL:OnPresetSelected( item )

	local name = item:GetValue( 1 )

	self.txtRename:SetText( name )
	for id, pnl in pairs( self.txtRename:GetParent():GetChildren() ) do pnl:SetEnabled( true ) end

	self.pnlDetails:Clear()
	for cvar, val in SortedPairs( item:GetTable().Data ) do
		local Row = self.pnlDetails:CreateRow( name, cvar:lower() )

		if ( tonumber( val ) != nil && false ) then
			Row:Setup( "Float", { min = 0, max = 1000 } )
			Row:SetValue( val )
		else
			Row:Setup( "Generic" )
		end

		Row:SetValue( val )
		Row.__Value = val
		Row.DataChanged = function( s, value ) Row.__Value = value end
	end

end

function PANEL:Update()

	self.PresetList:Clear()
	self.pnlDetails:Clear()
	self.txtRename:SetText( "" )

	local Presets = presets.GetTable( self:GetType() )
	local sortedPresets, i = {}, 1
	for name in pairs( Presets ) do
		sortedPresets[i] = name
		i = i + 1
	end
	table.sort( sortedPresets )

	for _, name in ipairs( sortedPresets ) do
		local item = self.PresetList:AddLine( name )
		item.Data = Presets[ name ]
	end

end

function PANEL:SelectPresetByName( name )

	for id, line in pairs( self.PresetList:GetLines() ) do
		if ( line:GetValue( 1 ) != name ) then continue end
		self.PresetList:SelectItem( line )
	end

end

function PANEL:Delete()

	if ( !self.PresetList:GetSelectedLine() || !IsValid( self.PresetList:GetLine( self.PresetList:GetSelectedLine() ) ) ) then return end

	local Selected = self.PresetList:GetLine( self.PresetList:GetSelectedLine() ):GetValue( 1 ):Trim()
	if ( Selected == "" ) then return end

	presets.Remove( self:GetType(), Selected )
	self:Update()

	if ( self:GetPresetControl() ) then self:GetPresetControl():Update() end

end

function PANEL:SaveChangesInternal( Selected, ToName )

	local tabValues = {}
	local cat = self.pnlDetails:GetCategory( Selected )

	-- WARNING: This will discard ConVars in the preset that no longer exist on the tool/whatever this preset is for
	for k, v in pairs( self:GetConVars() ) do
		if ( cat:GetRow( v:lower() ) ) then
			tabValues[ v:lower() ] = cat:GetRow( v:lower() ).__Value
		end
	end

	presets.Rename( self:GetType(), Selected, ToName ) -- Raname the preset if necessary
	presets.Add( self:GetType(), ToName, tabValues ) -- Update the values

	self:Update()

	self.txtRename:SetText( "" )
	self:SelectPresetByName( ToName )

	if ( self:GetPresetControl() ) then self:GetPresetControl():Update() end

end

function PANEL:SaveChanges()

	if ( !self.PresetList:GetSelectedLine() || !IsValid( self.PresetList:GetLine( self.PresetList:GetSelectedLine() ) ) ) then return end

	local Selected = self.PresetList:GetLine( self.PresetList:GetSelectedLine() ):GetValue( 1 ):Trim()
	if ( Selected == "" ) then return end

	local ToName = self.txtRename:GetValue():Trim()
	if ( !ToName || ToName == "" ) then presets.BadNameAlert() return end

	if ( presets.Exists( self:GetType(), ToName ) && Selected != ToName ) then
		presets.OverwritePresetPrompt( function()
			self:SaveChangesInternal( Selected, ToName )
		end )
		return
	end

	self:SaveChangesInternal( Selected, ToName )

end

function PANEL:InternalAdd( ToName )

	local tabValues = {}
	for k, v in pairs( self:GetConVars() ) do
		tabValues[ v ] = GetConVarString( v:lower() )
	end

	presets.Add( self:GetType(), ToName, tabValues )
	self:Update()

	self.txtName:SetText( "" )
	self:SelectPresetByName( ToName )

	if ( self:GetPresetControl() ) then self:GetPresetControl():Update() end

end

function PANEL:Add()

	if ( !self:GetConVars() ) then return end

	local ToName = self.txtName:GetValue():Trim()
	if ( !ToName || ToName == "" ) then presets.BadNameAlert() return end

	if ( presets.Exists( self:GetType(), ToName ) ) then
		presets.OverwritePresetPrompt( function()
			self:InternalAdd( ToName )
		end )
		return
	end

	self:InternalAdd( ToName )

end

vgui.Register( "PresetEditor", PANEL, "DFrame" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/manifest.lua:

include( "content/content.lua" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenticon.lua:

AddCSLuaFile()

local PANEL = {}

local matOverlay_Normal = Material( "gui/ContentIcon-normal.png" )
local matOverlay_Hovered = Material( "gui/ContentIcon-hovered.png" )

local matOverlay_AdminOnly = Material( "icon16/shield.png" )
local matOverlay_NPCWeapon = Material( "icon16/monkey.png" )
local matOverlay_NPCWeaponSelected = Material( "icon16/monkey_tick.png" )

AccessorFunc( PANEL, "m_Color", "Color" )
AccessorFunc( PANEL, "m_Type", "ContentType" )
AccessorFunc( PANEL, "m_SpawnName", "SpawnName" )
AccessorFunc( PANEL, "m_NPCWeapon", "NPCWeapon" )
AccessorFunc( PANEL, "m_bAdminOnly", "AdminOnly" )
AccessorFunc( PANEL, "m_bIsNPCWeapon", "IsNPCWeapon" )

local function DoGenericSpawnmenuRightclickMenu( self )
	local menu = DermaMenu()
		menu:AddOption( "#spawnmenu.menu.copy", function() SetClipboardText( self:GetSpawnName() ) end ):SetIcon( "icon16/page_copy.png" )
		if ( isfunction( self.OpenMenuExtra ) ) then
			self:OpenMenuExtra( menu )
		end

		if ( !IsValid( self:GetParent() ) || !self:GetParent().GetReadOnly || !self:GetParent():GetReadOnly() ) then
			menu:AddSpacer()
			menu:AddOption( "#spawnmenu.menu.delete", function() self:Remove() hook.Run( "SpawnlistContentChanged" ) end ):SetIcon( "icon16/bin_closed.png" )
		end
	menu:Open()
end

function PANEL:Init()

	self:SetPaintBackground( false )
	self:SetSize( 128, 128 )
	self:SetText( "" )
	self:SetDoubleClickingEnabled( false )

	self.Image = self:Add( "DImage" )
	self.Image:SetPos( 3, 3 )
	self.Image:SetSize( 128 - 6, 128 - 6 )
	self.Image:SetVisible( false )

	self.Label = self:Add( "DLabel" )
	self.Label:Dock( BOTTOM )
	self.Label:SetTall( 18 )
	self.Label:SetContentAlignment( 5 )
	self.Label:DockMargin( 4, 0, 4, 6 )
	self.Label:SetTextColor( color_white )
	self.Label:SetExpensiveShadow( 1, Color( 0, 0, 0, 200 ) )

	self.Border = 0

end

function PANEL:SetName( name )

	self:SetTooltip( name )
	self.Label:SetText( name )
	self.m_NiceName = name

end

function PANEL:SetMaterial( name )

	self.m_MaterialName = name

	local mat = Material( name )

	-- Look for the old style material
	if ( !mat || mat:IsError() ) then

		name = name:Replace( "entities/", "VGUI/entities/" )
		name = name:Replace( ".png", "" )
		mat = Material( name )

	end

	-- Couldn't find any material.. just return
	if ( !mat || mat:IsError() ) then
		return
	end

	self.Image:SetMaterial( mat )

end

function PANEL:DoRightClick()

	local pCanvas = self:GetSelectionCanvas()
	if ( IsValid( pCanvas ) && pCanvas:NumSelectedChildren() > 0 && self:IsSelected() ) then
		return hook.Run( "SpawnlistOpenGenericMenu", pCanvas )
	end

	self:OpenMenu()

end

function PANEL:DoClick()
end

function PANEL:OpenMenu()
end

function PANEL:OnDepressionChanged( b )
end

function PANEL:Paint( w, h )

	if ( self.Depressed && !self.Dragging ) then
		if ( self.Border != 8 ) then
			self.Border = 8
			self:OnDepressionChanged( true )
		end
	else
		if ( self.Border != 0 ) then
			self.Border = 0
			self:OnDepressionChanged( false )
		end
	end

	render.PushFilterMag( TEXFILTER.ANISOTROPIC )
	render.PushFilterMin( TEXFILTER.ANISOTROPIC )

	self.Image:PaintAt( 3 + self.Border, 3 + self.Border, 128 - 8 - self.Border * 2, 128 - 8 - self.Border * 2 )

	render.PopFilterMin()
	render.PopFilterMag()

	surface.SetDrawColor( 255, 255, 255, 255 )

	if ( !dragndrop.IsDragging() && ( self:IsHovered() || self.Depressed || self:IsChildHovered() ) ) then

		surface.SetMaterial( matOverlay_Hovered )
		self.Label:Hide()

	else

		surface.SetMaterial( matOverlay_Normal )
		self.Label:Show()

	end

	surface.DrawTexturedRect( self.Border, self.Border, w-self.Border*2, h-self.Border*2 )

	if ( self:GetAdminOnly() ) then
		surface.SetMaterial( matOverlay_AdminOnly )
		surface.DrawTexturedRect( self.Border + 8, self.Border + 8, 16, 16 )
	end

	-- This whole thing could be more dynamic
	--[[
	if ( self:GetIsNPCWeapon() ) then
		surface.SetMaterial( matOverlay_NPCWeapon )

		if ( self:GetSpawnName() == GetConVarString( "gmod_npcweapon" ) ) then
			surface.SetMaterial( matOverlay_NPCWeaponSelected )
		end

		surface.DrawTexturedRect( w - self.Border - 24, self.Border + 8, 16, 16 )
	end
	self:ScanForNPCWeapons()
	]]

end

function PANEL:ScanForNPCWeapons()
	if ( self.HasScanned ) then return end
	self.HasScanned = true

	for _, v in pairs( list.Get( "NPCUsableWeapons" ) ) do
		if ( v.class == self:GetSpawnName() ) then
			self:SetIsNPCWeapon( true )
			break
		end
	end
end

function PANEL:PaintOver( w, h )

	self:DrawSelections()

end

function PANEL:ToTable( bigtable )

	local tab = {}

	tab.type		= self:GetContentType()
	tab.nicename	= self.m_NiceName
	tab.material	= self.m_MaterialName
	tab.admin		= self:GetAdminOnly()
	tab.spawnname	= self:GetSpawnName()
	tab.weapon		= self:GetNPCWeapon()

	table.insert( bigtable, tab )

end

function PANEL:Copy()

	local copy = vgui.Create( "ContentIcon", self:GetParent() )

	copy:SetContentType( self:GetContentType() )
	copy:SetSpawnName( self:GetSpawnName() )
	copy:SetName( self.m_NiceName )
	copy:SetMaterial( self.m_MaterialName )
	copy:SetNPCWeapon( self:GetNPCWeapon() )
	copy:SetAdminOnly( self:GetAdminOnly() )
	copy:CopyBase( self )
	copy.DoClick = self.DoClick
	copy.OpenMenu = self.OpenMenu
	copy.OpenMenuExtra = self.OpenMenuExtra

	return copy

end

vgui.Register( "ContentIcon", PANEL, "DButton" )

spawnmenu.AddContentType( "entity", function( container, obj )

	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "entity" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	icon:SetMaterial( obj.material )
	icon:SetAdminOnly( obj.admin )
	icon:SetColor( Color( 205, 92, 92, 255 ) )
	icon.DoClick = function()
		RunConsoleCommand( "gm_spawnsent", obj.spawnname )
		surface.PlaySound( "ui/buttonclickrelease.wav" )
	end
	icon.OpenMenuExtra = function( self, menu )
		menu:AddOption( "#spawnmenu.menu.spawn_with_toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "0" ) RunConsoleCommand( "creator_name", obj.spawnname ) end ):SetIcon( "icon16/brick_add.png" )
	end
	icon.OpenMenu = DoGenericSpawnmenuRightclickMenu

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )

spawnmenu.AddContentType( "vehicle", function( container, obj )

	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "vehicle" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	icon:SetMaterial( obj.material )
	icon:SetAdminOnly( obj.admin )
	icon:SetColor( Color( 0, 0, 0, 255 ) )
	icon.DoClick = function()
		RunConsoleCommand( "gm_spawnvehicle", obj.spawnname )
		surface.PlaySound( "ui/buttonclickrelease.wav" )
	end
	icon.OpenMenuExtra = function( self, menu )
		menu:AddOption( "#spawnmenu.menu.spawn_with_toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "1" ) RunConsoleCommand( "creator_name", obj.spawnname ) end ):SetIcon( "icon16/brick_add.png" )
	end
	icon.OpenMenu = DoGenericSpawnmenuRightclickMenu

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )

local gmod_npcweapon = CreateConVar( "gmod_npcweapon", "", { FCVAR_ARCHIVE } )

spawnmenu.AddContentType( "npc", function( container, obj )

	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	if ( !obj.weapon ) then obj.weapon = {} end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "npc" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	icon:SetMaterial( obj.material )
	icon:SetAdminOnly( obj.admin )
	icon:SetNPCWeapon( obj.weapon )
	icon:SetColor( Color( 244, 164, 96, 255 ) )

	icon.DoClick = function()
		local weapon = table.Random( obj.weapon ) or ""
		if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end

		RunConsoleCommand( "gmod_spawnnpc", obj.spawnname, weapon )
		surface.PlaySound( "ui/buttonclickrelease.wav" )
	end

	icon.OpenMenuExtra = function( self, menu )
		local weapon = table.Random( obj.weapon ) or ""
		if ( gmod_npcweapon:GetString() != "" ) then weapon = gmod_npcweapon:GetString() end

		menu:AddOption( "#spawnmenu.menu.spawn_with_toolgun", function()
			RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "2" )
			RunConsoleCommand( "creator_name", obj.spawnname ) RunConsoleCommand( "creator_arg", weapon )
		end ):SetIcon( "icon16/brick_add.png" )

		-- Quick access to spawning NPCs with a spcific weapon without the need to change gmod_npcweapon
		if ( table.IsEmpty( obj.weapon ) ) then return end

		local subMenu, swg = menu:AddSubMenu( "#spawnmenu.menu.spawn_with_weapon" )
		swg:SetIcon( "icon16/gun.png" )

		subMenu:AddOption( "#menubar.npcs.noweapon", function() RunConsoleCommand( "gmod_spawnnpc", obj.spawnname, "" ) end ):SetIcon( "icon16/cross.png" )

		-- Kind of a hack!
		local function addWeps( subm, weps )
			if ( table.Count( weps ) < 1 ) then return end

			subMenu:AddSpacer()
			for title, class in SortedPairs( weps ) do
				subMenu:AddOption( title, function() RunConsoleCommand( "gmod_spawnnpc", obj.spawnname, class ) end ):SetIcon( "icon16/gun.png" )
			end
		end

		local weaps = {}
		for _, class in pairs( obj.weapon ) do
			if ( class == "" ) then continue end
			weaps[ language.GetPhrase( class ) ] = class
		end
		addWeps( subMenu, weaps )

		local weaps = {}
		for _, t in pairs( list.Get( "NPCUsableWeapons" ) ) do
			if ( table.HasValue( obj.weapon, t.class ) ) then continue end
			weaps[ language.GetPhrase( t.title ) ] = t.class
		end
		addWeps( subMenu, weaps )

	end
	icon.OpenMenu = DoGenericSpawnmenuRightclickMenu

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )

spawnmenu.AddContentType( "weapon", function( container, obj )

	if ( !obj.material ) then return end
	if ( !obj.nicename ) then return end
	if ( !obj.spawnname ) then return end

	local icon = vgui.Create( "ContentIcon", container )
	icon:SetContentType( "weapon" )
	icon:SetSpawnName( obj.spawnname )
	icon:SetName( obj.nicename )
	icon:SetMaterial( obj.material )
	icon:SetAdminOnly( obj.admin )
	icon:SetColor( Color( 135, 206, 250, 255 ) )
	icon.DoClick = function()

		RunConsoleCommand( "gm_giveswep", obj.spawnname )
		surface.PlaySound( "ui/buttonclickrelease.wav" )

	end

	icon.DoMiddleClick = function()

		RunConsoleCommand( "gm_spawnswep", obj.spawnname )
		surface.PlaySound( "ui/buttonclickrelease.wav" )

	end

	icon.OpenMenuExtra = function( self, menu )
		menu:AddOption( "#spawnmenu.menu.spawn_with_toolgun", function() RunConsoleCommand( "gmod_tool", "creator" ) RunConsoleCommand( "creator_type", "3" ) RunConsoleCommand( "creator_name", obj.spawnname ) end ):SetIcon( "icon16/brick_add.png" )

		if ( self:GetIsNPCWeapon() ) then
			local opt = menu:AddOption( "#spawnmenu.menu.use_as_npc_gun", function() RunConsoleCommand( "gmod_npcweapon", self:GetSpawnName() ) end )
			if ( self:GetSpawnName() == GetConVarString( "gmod_npcweapon" ) ) then
				opt:SetIcon( "icon16/monkey_tick.png" )
			else
				opt:SetIcon( "icon16/monkey.png" )
			end
		end
	end
	icon.OpenMenu = DoGenericSpawnmenuRightclickMenu

	if ( IsValid( container ) ) then
		container:Add( icon )
	end

	return icon

end )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contentsearch.lua:

AddCSLuaFile()

PANEL.Base = "Panel"

function PANEL:Init()

	self.CurrentSearch = ""
	self.OldResults = -1
	self.RebuildResults = false

	self:Dock( TOP )
	self:SetHeight( 20 )
	self:DockMargin( 0, 0, 0, 3 )

	self.Search = self:Add( "DTextEntry" )
	self.Search:Dock( FILL )
	self.Search:SetPlaceholderText( "#spawnmenu.search" )

	self.Search.OnEnter = function() self:RefreshResults() end
	self.Search.OnFocusChanged = function( _, b ) if ( b ) then self.ContentPanel:SwitchPanel( self.PropPanel ) end end
	self.Search:SetTooltip( "#spawnmenu.enter_search" )

	local btn = self.Search:Add( "DImageButton" )

	btn:SetImage( "icon16/magnifier.png" )
	btn:SetText( "" )
	btn:Dock( RIGHT )
	btn:DockMargin( 4, 2, 4, 2 )
	btn:SetSize( 16, 16 )
	btn:SetTooltip( "#spawnmenu.press_search" )
	btn.DoClick = function()
		self:RefreshResults()
	end

	self.Search.OnKeyCode = function( p, code )

		if ( code == KEY_F1 ) then hook.Run( "OnSpawnMenuClose" ) end
		if ( code == KEY_ESCAPE ) then hook.Run( "OnSpawnMenuClose" ) end

	end

	self.PropPanel = vgui.Create( "ContentContainer", self )
	self.PropPanel:SetVisible( false )
	self.PropPanel:SetTriggerSpawnlistChange( false )

	-- Some sort of placeholder
	local Header = self:Add( "ContentHeader" )
	Header:SetText( "#spawnmenu.enter_search" )
	self.PropPanel:Add( Header )

end

function PANEL:Paint()
	-- This is a bit of a hack, if there was a request to rebuild the results from the search indexer
	-- Do it when the player next sees the search panel, in case they got the spawnmenu closed
	-- Think hook causes unexpected 1 frame duplication of all the elements
	if ( self.RebuildResults ) then
		self.RebuildResults = false
		self:RefreshResults( self.CurrentSearch )
	end
end

function PANEL:SetSearchType( stype, hookname )
	self.m_strSearchType = stype
	hook.Add( hookname, "AddSearchContent_" .. hookname, function( pnlContent, tree, node )
		self.ContentPanel = pnlContent
	end )
	hook.Add( "SearchUpdate", "SearchUpdate_" .. hookname, function()
		if ( !g_SpawnMenu:IsVisible() ) then self.RebuildResults = true return end
		self:RefreshResults( self.CurrentSearch )
	end )

	-- This stuff is only for the primary search
	if ( hookname != "PopulateContent" ) then return end

	g_SpawnMenu.SearchPropPanel = self.PropPanel
	hook.Add( "StartSearch", "StartSearch", function()

		if ( g_SpawnMenu:IsVisible() ) then return hook.Run( "OnSpawnMenuClose" ) end

		hook.Run( "OnSpawnMenuOpen" )
		hook.Run( "OnTextEntryGetFocus", self.Search )

		self.Search:RequestFocus()
		self.Search:SetText( "" )

		--
		-- If we don't call this we'd have to press F1 twice to close it!
		-- It's in a timer because of some good reason that!
		--
		timer.Simple( 0.1, function() g_SpawnMenu:HangOpen( false ) end )

		self.ContentPanel:SwitchPanel( self.PropPanel )

	end )
end

function PANEL:RefreshResults( str )

	if ( !str ) then -- User tried to search for something
		self.CurrentSearch = self.Search:GetText()
		str = self.CurrentSearch
		self.OldResults = -1
	else
		-- Don't force open the search when you click away from search while this function is called from cl_search_models.lua
		if ( self.ContentPanel.SelectedPanel != self.PropPanel ) then
			return
		end
	end

	if ( !str or str == "" ) then return end

	local results = search.GetResults( str, self.m_strSearchType, GetConVarNumber( "sbox_search_maxresults" ) )
	for id, result in pairs( results ) do
		if ( !IsValid( result.icon ) ) then ErrorNoHalt( "Failed to create icon for " .. ( result.words && isstring( result.words[ 1 ] ) && result.words[ 1 ] || result.text ).. "\n" ) continue end
		result.icon:SetParent( vgui.GetWorldPanel() ) -- Don't parent the icons to search panel prematurely
	end

	-- I know this is not perfect, but this is the best I am willing to do with how the search library was set up
	if ( self.OldResults == #results ) then -- No updates, don't rebuild
		for id, result in pairs( results ) do
			if ( IsValid( result.icon ) ) then result.icon:Remove() end -- Kill all icons
		end
		return
	end
	self.OldResults = #results

	self.PropPanel:Clear()

	local Header = self:Add( "ContentHeader" )
	Header:SetText( #results .. " Results for \"" .. str .. "\"" )
	self.PropPanel:Add( Header )

	for k, v in pairs( results ) do
		self:AddSearchResult( v.text, v.func, v.icon )
	end

	self.PropPanel:SetParent( self.ContentPanel )
	self.ContentPanel:SwitchPanel( self.PropPanel )

end

function PANEL:AddSearchResult( text, func, icon )

	if ( !IsValid( icon ) ) then return end

	icon:SetParent( self.PropPanel )
	self.PropPanel:Add( icon )

end

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenttypes/saves.lua:

local HTML = nil

spawnmenu.AddCreationTab( "#spawnmenu.category.saves", function()

	HTML = vgui.Create( "DHTML" )
	JS_Language( HTML )
	JS_Workshop( HTML )

	ws_save = WorkshopFileBase( "save", { "save" } )
	ws_save.HTML = HTML

	function ws_save:FetchLocal( offset, perpage )

		local f = file.Find( "saves/*.gms", "MOD", "datedesc" )

		local saves = {}

		for k, v in pairs( f ) do

			if ( k <= offset ) then continue end
			if ( k > offset + perpage ) then break end

			local entry = {
				file	= "saves/" .. v,
				name	= v:StripExtension(),
				preview	= "saves/" .. v:StripExtension() .. ".jpg",
				description	= "Local map saves stored on your computer. Local content can be deleted in the main menu."
			}

			table.insert( saves, entry )

		end

		local results = {
			totalresults	= #f,
			results			= saves
		}

		local json = util.TableToJSON( results, false )
		HTML:Call( "save.ReceiveLocal( " .. json .. " )" )

	end

	function ws_save:DownloadAndLoad( id )

		steamworks.DownloadUGC( id, function( name )

			ws_save:Load( name )

		end )

	end

	function ws_save:Load( filename ) RunConsoleCommand( "gm_load", filename ) end
	function ws_save:Publish( filename, imagename ) RunConsoleCommand( "save_publish", filename, imagename ) end

	HTML:OpenURL( "asset://garrysmod/html/saves.html" )
	HTML:Call( "SetMap( '" .. game.GetMap() .. "' );" )

	return HTML

end, "icon16/disk_multiple.png", 200 )

hook.Add( "PostGameSaved", "OnCreationsSaved", function()

	if ( !HTML ) then return end

	HTML:Call( "OnGameSaved()" )

end )

--gamemodes/darkrp/gamemode/modules/medic/sh_init.lua:
local plyMeta = FindMetaTable("Player")
plyMeta.isMedic = fn.Compose{fn.Curry(fn.GetValue, 2)("medic"), plyMeta.getJobTable}

--gamemodes/darkrp/gamemode/modules/fadmin/cl_fadmin_darkrp.lua:
if not FAdmin or not FAdmin.StartHooks then return end
FAdmin.StartHooks["DarkRP"] = function()
    -- DarkRP information:
    wayscore.AddInfo('steamname', {
        name = 'Ник в Steam',
        get = function(ply) return ply:SteamName() end,
        order = 8000,
    })
    wayscore.AddInfo('steamlink', {
        name = 'Ссылка на Steam',
        get = function(ply) return FAdmin.SteamToProfile(ply) end,
        callback = function(ply, val) return gui.OpenURL(val) end,
        order = 9000,
    })
    wayscore.AddInfo('rank', {
        name = 'Ранг',
        get = function(ply) return ply:GetUserGroup() end,
        order = 10000,
    })
    wayscore.AddInfo('wanted', {
        name = 'Причина розыска',
        get = function(ply) return ply:isWanted() and ply:getWantedReason() end,
        order = 11000,
    })
    wayscore.AddInfo('wanted', {
        name = 'Причина розыска',
        get = function(ply) return ply:isWanted() and ply:getWantedReason() end,
        order = 12000,
    })

    -- Warrant
    wayscore.AddActionButton('warrant', {
        name = 'Ордер на обыск',
        icon = 'fadmin/icons/message',
        color = Color(0,0,200),
        category = 'Полиция',
        check = function(ply) return LocalPlayer():isCP() end,
        callback = function(ply)
            Derma_StringRequest('Ордер на обыск', 'Введи причину для обыска', '', function(text)
                RunConsoleCommand('darkrp', 'warrant', ply:UserID(), text)
            end)
        end
    })

    --wanted
    wayscore.AddActionButton('wanted', {
        name = function(ply)
            return ply:isWanted() and 'Снять розыск' or 'Выдать розыск'
        end,
        icon = function(ply)
            return 'fadmin/icons/jail', ply:isWanted() and 'fadmin/icons/disable'
        end,
        color = Color(0,0,200),
        category = 'Полиция',
        check = function(ply) return LocalPlayer():isCP() end,
        callback = function(ply)
            if not ply:isWanted() then
                Derma_StringRequest('Выдать розыск', 'Введи причину для розыска', '', function(text)
                    RunConsoleCommand('darkrp', 'wanted', ply:UserID(), text)
                end)
            else
                RunConsoleCommand('darkrp', 'unwanted', ply:UserID())
            end
        end
    })

    --Teamban
    local function teamban(ply, button)
        local menu = DermaMenu()

        local Padding = vgui.Create("DPanel")
        Padding:SetPaintBackgroundEnabled(false)
        Padding:SetSize(1,5)
        menu:AddPanel(Padding)

        local Title = vgui.Create("DLabel")
        Title:SetText("  Профессии:\n")
        Title:SetFont("UiBold")
        Title:SizeToContents()
        Title:SetTextColor(color_black)
        menu:AddPanel(Title)

        local command = "teamban"
        local uid = ply:UserID()
        for k,v in SortedPairsByMemberValue(RPExtraTeams, "name") do
            local submenu = menu:AddSubMenu(v.name)
            submenu:AddOption("5 минут",     function() RunConsoleCommand("darkrp", command, uid, k, 300) end)
            submenu:AddOption("10 минут",  function() RunConsoleCommand("darkrp", command, uid, k, 600) end)
            submenu:AddOption("60 минут",       function() RunConsoleCommand("darkrp", command, uid, k, 3600) end)
            submenu:AddOption("До рестарта", function() RunConsoleCommand("darkrp", command, uid, k, 0) end)
            submenu:AddOption("Свой срок", function()
                Derma_StringRequest("Заблокировать профессию", "Введи ниже срок блокировки (в минутах)", "", function(text)
                    RunConsoleCommand("darkrp", command, uid, k, tonumber(text) and tonumber(text)*60 or 600)
                end)
            end)
        end
        menu:Open()
    end

    wayscore.AddActionButton('teamban', {
        name = 'Заблокировать профессию',
        icon = 'fadmin/icons/changeteam',
        color = Color(200,0,0),
        order = 6000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'DarkRP_AdminCommands', ply) end,
        callback = teamban,
    })

    local function teamunban(ply, button)
        local menu = DermaMenu()

        local Padding = vgui.Create("DPanel")
        Padding:SetPaintBackgroundEnabled(false)
        Padding:SetSize(1,5)
        menu:AddPanel(Padding)

        local Title = vgui.Create("DLabel")
        Title:SetText("  Профессии:\n")
        Title:SetFont("UiBold")
        Title:SizeToContents()
        Title:SetTextColor(color_black)
        menu:AddPanel(Title)

        local command = "teamunban"
        local uid = ply:UserID()
        for k,v in SortedPairsByMemberValue(RPExtraTeams, "name") do
            menu:AddOption(v.name, function() RunConsoleCommand("darkrp", command, uid, k) end)
        end
        menu:Open()
    end
    wayscore.AddActionButton('teamunban', {
        name = 'Разблокировать профессию',
        icon = {'fadmin/icons/changeteam', 'fadmin/icons/disable'},
        color = Color(200,0,0),
        order = 7000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'DarkRP_AdminCommands', ply) end,
        callback = teamunban,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/restrict/cl_restrict.lua:
local function FillMenu(menu, SpawnName, GroupName)
    menu:AddOption("unrestrict", function() RunConsoleCommand("_FAdmin", "UnRestrictWeapon", SpawnName) end)

    menu:AddSpacer("")
    for k,v in SortedPairsByMemberValue(FAdmin.Access.Groups, "ADMIN", true) do
        menu:AddOption(k, function() RunConsoleCommand("_FAdmin", "RestrictWeapon", SpawnName, k) end)
    end
end

local function RestrictWeaponMenu()
    local frame = vgui.Create("DFrame")
    frame:SetTitle("Restrict weapons")
    frame:SetSize(ScrW() / 2, ScrH() - 50)
    frame:Center()
    frame:SetVisible(true)
    frame:MakePopup()

    local WeaponMenu = vgui.Create("FAdmin_weaponPanel", frame)
    WeaponMenu.HideAmmo = true
    function WeaponMenu:DoGiveWeapon(SpawnName)
        local menu = DermaMenu()
        menu:SetPos(gui.MouseX(), gui.MouseY())
        FillMenu(menu, SpawnName)
        menu:Open()
    end
    WeaponMenu:BuildList()
    WeaponMenu:StretchToParent(0,25,0,0)
end

FAdmin.StartHooks["Restrict"] = function()
    FAdmin.Access.AddPrivilege("Restrict", 3)
    FAdmin.ScoreBoard.Server:AddPlayerAction("Restrict weapons", "fadmin/icons/weapon", Color(0, 155, 0, 255), function(ply) return FAdmin.Access.PlayerHasPrivilege(ply, "Restrict") end, RestrictWeaponMenu)
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/commands/sh_concommands.lua:
FAdmin.Commands = {}
FAdmin.Commands.List = {}

function FAdmin.Commands.AddCommand(name, callback, ...)
    FAdmin.Commands.List[string.lower(name)] = {callback = callback, ExtraArgs = {...}}
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/cl_interface/sh_commontimes.lua:
--[[---------------------------------------------------------------------------
Common times for several punishment actions
---------------------------------------------------------------------------]]
FAdmin.PlayerActions.commonTimes = {}
FAdmin.PlayerActions.commonTimes[0] = "навсегда"
FAdmin.PlayerActions.commonTimes[10] = "10 секунд"
FAdmin.PlayerActions.commonTimes[30] = "30 секунд"
FAdmin.PlayerActions.commonTimes[60] = "1 минуту"
FAdmin.PlayerActions.commonTimes[300] = "5 минут"
FAdmin.PlayerActions.commonTimes[600] = "10 минут"

function FAdmin.PlayerActions.addTimeSubmenu(menu, submenuText, submenuClick, submenuItemClick)
    local SubMenu = menu:AddSubMenu(submenuText, submenuClick)

    local Padding = vgui.Create("DPanel")
    Padding:SetPaintBackgroundEnabled(false)
    Padding:SetSize(1,5)
    SubMenu:AddPanel(Padding)

    local SubMenuTitle = vgui.Create("DLabel")
    SubMenuTitle:SetText("  Time:\n")
    SubMenuTitle:SetFont("UiBold")
    SubMenuTitle:SizeToContents()
    SubMenuTitle:SetTextColor(color_black)

    SubMenu:AddPanel(SubMenuTitle)

    for secs, Time in SortedPairs(FAdmin.PlayerActions.commonTimes) do
        SubMenu:AddOption(Time, function() submenuItemClick(secs) end)
    end
end

function FAdmin.PlayerActions.addTimeMenu(ItemClick)
    local menu = DermaMenu()

    local Padding = vgui.Create("DPanel")
    Padding:SetPaintBackgroundEnabled(false)
    Padding:SetSize(1,5)
    menu:AddPanel(Padding)

    local Title = vgui.Create("DLabel")
    Title:SetText("  Time:\n")
    Title:SetFont("UiBold")
    Title:SizeToContents()
    Title:SetTextColor(color_black)

    menu:AddPanel(Title)

    for secs, Time in SortedPairs(FAdmin.PlayerActions.commonTimes) do
        menu:AddOption(Time, function() ItemClick(secs) end)
    end
    menu:Open()
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/cl_interface/cl_playerlists.lua:
local function SortedPairsByFunction(Table, Sorted, SortDown)
    local CopyTable = {}
    for _, v in pairs(Table) do
        table.insert(CopyTable, {NAME = tostring(v:Nick()), PLY = v})
    end
    table.SortByMember(CopyTable, "NAME", SortDown)

    local SortedTable = {}
    for _, v in ipairs(CopyTable) do
        if not IsValid(v.PLY) or not v.PLY[Sorted] then continue end
        local SortBy = (Sorted ~= "Team" and v.PLY[Sorted](v.PLY)) or (v.PLY:GetNetVar("job") or team.GetName(v.PLY[Sorted](v.PLY)))
        SortedTable[SortBy] = SortedTable[SortBy] or {}
        table.insert(SortedTable[SortBy], v.PLY)
    end

    local SecondSort = {}
    for _, v in SortedPairs(SortedTable, SortDown) do
        table.insert(SecondSort, v)
    end

    CopyTable = {}
    for _, v in pairs(SecondSort) do
        for _, b in pairs(v) do
            table.insert(CopyTable, b)
        end
    end

    return ipairs(CopyTable)
end

function FAdmin.ScoreBoard.Main.PlayerListView(Sorted, SortDown)
    FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:Clear(true)
    for _, ply in SortedPairsByFunction(player.GetAll(), Sorted, SortDown) do
        local Row = vgui.Create("FadminPlayerRow")
        Row:SetPlayer(ply)
        Row:Dock(TOP)
        Row:InvalidateLayout()

        FAdmin.ScoreBoard.Main.Controls.FAdminPanelList:AddItem(Row)
    end
end
--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/cl_interface/cl_controls.lua:
FAdmin.PlayerIcon = {}
FAdmin.PlayerIcon.RightClickOptions = {}

function FAdmin.PlayerIcon.AddRightClickOption(name, func)
    FAdmin.PlayerIcon.RightClickOptions[name] = func
end

-- FAdminPanelList
local PANEL = {}

function PANEL:Init()
    self.Padding = 5
end

function PANEL:SizeToContents()
    local w, h = self:GetSize()

    -- Fix size of w to have the same size as the scoreboard
    w = math.Clamp(w, ScrW() * 0.9, ScrW() * 0.9)
    h = math.Min(h, ScrH() * 0.95)

    -- It fucks up when there's only one icon in
    if #self:GetChildren() == 1 then
        h = math.Max(0, 120)
    end

    self:SetSize(w, h)
    self:PerformLayout()
end

function PANEL:Paint()
end

derma.DefineControl("FAdminPanelList", "DPanellist adapted for FAdmin", PANEL, "DPanelList")

-- FAdminPlayerCatagoryHeader
local PANEL2 = {}

function PANEL2:PerformLayout()
    self:SetFont("Trebuchet24")
end

derma.DefineControl("FAdminPlayerCatagoryHeader", "DCatagoryCollapse header adapted for FAdmin", PANEL2, "DCategoryHeader")

-- FAdminPlayerCatagory
local PANEL3 = {}

function PANEL3:Init()
    if self.Header then
        self.Header:Remove() -- the old header is still there don't ask me why
    end
    self.Header = vgui.Create("FAdminPlayerCatagoryHeader", self)
    self.Header:SetSize(20, 25)
    self:SetPadding(5)
    self.Header:Dock( TOP )

    self:SetExpanded(true)
    self:SetMouseInputEnabled(true)

    self:SetAnimTime(0.2)
    self.animSlide = Derma_Anim("Anim", self, self.AnimSlide)

    self:SetPaintBackgroundEnabled(true)

end

function PANEL3:Paint()
    if self.CatagoryColor then
        draw.RoundedBox(4, 0, 0, self:GetWide(), self.Header:GetTall(), self.CatagoryColor)
    end
end

derma.DefineControl("FAdminPlayerCatagory", "DCatagoryCollapse adapted for FAdmin", PANEL3, "DCollapsibleCategory")

-- FAdmin player row (from the sandbox player row)
PANEL = {}

local PlayerRowSize = CreateClientConVar("FAdmin_PlayerRowSize", 30, true, false)
function PANEL:Init()
    self.Size = PlayerRowSize:GetInt()

    self.lblName    = vgui.Create("DLabel", self)
    self.lblFrags   = vgui.Create("DLabel", self)
    self.lblTeam    = vgui.Create("DLabel", self)
    self.lblDeaths  = vgui.Create("DLabel", self)
    self.lblPing    = vgui.Create("DLabel", self)
    self.lblWanted  = vgui.Create("DLabel", self)

    -- If you don't do this it'll block your clicks
    self.lblName:SetMouseInputEnabled(false)
    self.lblTeam:SetMouseInputEnabled(false)
    self.lblFrags:SetMouseInputEnabled(false)
    self.lblDeaths:SetMouseInputEnabled(false)
    self.lblPing:SetMouseInputEnabled(false)
    self.lblWanted:SetMouseInputEnabled(false)

    self.lblName:SetColor(Color(255,255,255,200))
    self.lblTeam:SetColor(Color(255,255,255,200))
    self.lblFrags:SetColor(Color(255,255,255,200))
    self.lblDeaths:SetColor(Color(255,255,255,200))
    self.lblPing:SetColor(Color(255,255,255,200))
    self.lblWanted:SetColor(Color(255,255,255,200))

    self.imgAvatar = vgui.Create("AvatarImage", self)

    self:SetCursor("hand")
end

function PANEL:Paint()
    if not IsValid(self.Player) then return end

    self.Size = PlayerRowSize:GetInt()
    self.imgAvatar:SetSize(self.Size - 4, self.Size - 4)

    local color = Color(100, 150, 245, 255)


    if GAMEMODE.Name == "Sandbox" then
        color = Color(100, 150, 245, 255)
        if self.Player:Team() == TEAM_CONNECTING then
            color = Color(200, 120, 50, 255)
        elseif self.Player:IsAdmin() then
            color = Color(30, 200, 50, 255)
        end

        if self.Player:GetFriendStatus() == "friend" then
            color = Color(236, 181, 113, 255)
        end
    else
        color = team.GetColor(self.Player:Team())
    end

    local hooks = hook.GetTable().FAdmin_PlayerRowColour
    if hooks then
        for k,v in pairs(hooks) do
            color = (v and v(self.Player, color)) or color
            break
        end
    end

    draw.RoundedBox(4, 0, 0, self:GetWide(), self.Size, color)

    surface.SetTexture(0)
    if self.Player == LocalPlayer() or self.Player:GetFriendStatus() == "friend" then
        surface.SetDrawColor(255, 255, 255, 50 + math.sin(RealTime() * 2) * 50)
    end
    surface.DrawTexturedRect(0, 0, self:GetWide(), self.Size)
    return true
end

function PANEL:SetPlayer(ply)
    self.Player = ply

    self.imgAvatar:SetSteamID(ply:SteamID64(), 32)

    self:UpdatePlayerData()
end

function PANEL:UpdatePlayerData()
    if not self.Player then return end
    if not self.Player:IsValid() then return end

    self.imgAvatar:SetSteamID(self.Player:SteamID64(), 32)

    self.lblName:SetText(DarkRP.deLocalise(self.Player:Nick()))
    self.lblTeam:SetText((DarkRP.deLocalise(self.Player:GetNetVar("job") or "")) or team.GetName(self.Player:Team()))
    self.lblTeam:SizeToContents()
    self.lblFrags:SetText(self.Player:Frags())
    self.lblDeaths:SetText(self.Player:Deaths())
    self.lblPing:SetText(self.Player:Ping())
    self.lblWanted:SetText(self.Player:isWanted() and DarkRP.getPhrase("Wanted_text") or "")
end

function PANEL:ApplySchemeSettings()
    self.lblName:SetFont("ScoreboardPlayerNameBig")
    self.lblTeam:SetFont("ScoreboardPlayerNameBig")
    self.lblFrags:SetFont("ScoreboardPlayerName")
    self.lblDeaths:SetFont("ScoreboardPlayerName")
    self.lblPing:SetFont("ScoreboardPlayerName")
    self.lblWanted:SetFont("ScoreboardPlayerNameBig")

    self.lblName:SetFGColor(color_white)
    self.lblTeam:SetFGColor(color_white)
    self.lblFrags:SetFGColor(color_white)
    self.lblDeaths:SetFGColor(color_white)
    self.lblPing:SetFGColor(color_white)
    self.lblWanted:SetFGColor(color_white)
end

function PANEL:DoClick(x, y)
    if not IsValid(self.Player) then self:Remove() return end
    FAdmin.ScoreBoard.ChangeView("Player", self.Player)
end

function PANEL:DoRightClick()
    if table.Count(FAdmin.PlayerIcon.RightClickOptions) < 1 then return end
    local menu = DermaMenu()

    menu:SetPos(gui.MouseX(), gui.MouseY())

    for Name, func in SortedPairs(FAdmin.PlayerIcon.RightClickOptions) do
        menu:AddOption(Name, function() if IsValid(self.Player) then func(self.Player, self) end end)
    end

    menu:Open()
end

function PANEL:Think()
    if not self.PlayerUpdate or self.PlayerUpdate < CurTime() then
        self.PlayerUpdate = CurTime() + 0.5
        self:UpdatePlayerData()
    end
end

function PANEL:PerformLayout()
    self.imgAvatar:SetPos(2, 2)
    self.imgAvatar:SetSize(32, 32)

    self:SetSize(self:GetWide(), self.Size)

    self.lblName:SizeToContents()
    self.lblName:SetPos(24, 2)
    self.lblName:MoveRightOf(self.imgAvatar, 8)

    local COLUMN_SIZE = 75

    self.lblPing:SetPos(self:GetWide() - COLUMN_SIZE * 0.4, 0)
    self.lblDeaths:SetPos(self:GetWide() - COLUMN_SIZE * 1.4, 0)
    self.lblFrags:SetPos(self:GetWide() - COLUMN_SIZE * 2.4, 0)

    self.lblTeam:SetPos(self:GetWide() / 2 - (0.5 * self.lblTeam:GetWide()))

    self.lblWanted:SizeToContents()
    self.lblWanted:SetPos(math.floor(self:GetWide() / 4), 2)
end
vgui.Register("FadminPlayerRow", PANEL, "Button")

-- FAdminActionButton
local PANEL6 = {}

function PANEL6:Init()
    self:SetDrawBackground(false)
    self:SetDrawBorder(false)
    self:SetStretchToFit(false)
    self:SetSize(120, 40)

    self.TextLabel = vgui.Create("DLabel", self)
    self.TextLabel:SetColor(Color(200,200,200,200))
    self.TextLabel:SetFont("ChatFont")

    self.m_Image2 = vgui.Create("DImage", self)

    self.BorderColor = Color(190,40,0,255)
end

function PANEL6:SetText(text)
    self.TextLabel:SetText(text)
    self.TextLabel:SizeToContents()

    self:SetWide(self.TextLabel:GetWide() + 44)
end

function PANEL6:PerformLayout()
    self.m_Image:SetSize(32,32)
    self.m_Image:SetPos(4,4)

    self.m_Image2:SetSize(32, 32)
    self.m_Image2:SetPos(4,4)

    self.TextLabel:SetPos(38, 8)
end

function PANEL6:SetImage2(Mat, bckp)
    self.m_Image2:SetImage(Mat, bckp)
end

function PANEL6:SetBorderColor(Col)
    self.BorderColor = Col or Color(190,40,0,255)
end

function PANEL6:Paint()
    local BorderColor = self.BorderColor
    if self.Hovered then
        BorderColor = Color(math.Min(BorderColor.r + 40, 255), math.Min(BorderColor.g + 40, 255), math.Min(BorderColor.b + 40, 255), BorderColor.a)
    end
    if self.Depressed then
        BorderColor = Color(0,0,0,0)
    end
    draw.RoundedBox(4, 0, 0, self:GetWide(), self:GetTall(), BorderColor)
    draw.RoundedBox(4, 2, 2, self:GetWide() - 4, self:GetTall() - 4, Color(40, 40, 40, 255))
end

function PANEL6:OnMousePressed(mouse)
    if self:GetDisabled() then return end

    self.m_Image:SetSize(24,24)
    self.m_Image:SetPos(8,8)
    self.Depressed = true
end

function PANEL6:OnMouseReleased(mouse)
    if self:GetDisabled() then return end

    self.m_Image:SetSize(32,32)
    self.m_Image:SetPos(4,4)
    self.Depressed = false
    self:DoClick()
end

derma.DefineControl("FAdminActionButton", "Button for doing actions", PANEL6, "DImageButton")

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/slay/sh_shared.lua:
FAdmin.PlayerActions.SlayTypes = {}
FAdmin.PlayerActions.SlayTypes[1] = "Normal"
FAdmin.PlayerActions.SlayTypes[2] = "Silent"
FAdmin.PlayerActions.SlayTypes[3] = "Explode"
FAdmin.PlayerActions.SlayTypes[4] = "Rocket"

FAdmin.StartHooks["Slaying"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "slay",
        hasTarget = true,
        message = {"instigator", " убил ", "targets"},
        receivers = "involved+admins",
    }
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/slap/cl_init.lua:
local Damages = {0, 1, 10, 50, 100, 500, 9999999--[[for the 12-year-olds]]}
local Repetitions = {[1] = "один раз", [5] = "5 раз", [10] = "10 раз", [50] = "50 раз", [100] = "100 раз"}

FAdmin.StartHooks["Slap"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "slap",
        hasTarget = true,
        message = {"instigator", " шлепнул ", "targets"},
    }

    FAdmin.Access.AddPrivilege("Slap", 2)
    FAdmin.Commands.AddCommand("Slap", nil, "<Player>", "[Amount]", "[Repetitions]")

    -- Right click option
    --[[
    FAdmin.ScoreBoard.Main.AddPlayerRightClick("Slap", function(ply)
        RunConsoleCommand("_FAdmin", "Slap", ply:UserID())
    end)
    ]]
    wayscore.AddActionButton('slap', {
        name = 'Шлепнуть',
        icon = 'fadmin/icons/slap',
        color = Color(255,130,0),
        category = 'Развлечения',
        order = 16000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Slap', ply) end,
        callback = function(ply)
            local menu = DermaMenu()
    
            local Padding = vgui.Create("DPanel")
            Padding:SetPaintBackgroundEnabled(false)
            Padding:SetSize(1,5)
            menu:AddPanel(Padding)
    
            local Title = vgui.Create("DLabel")
            Title:SetText("  Урон:\n")
            Title:SetFont("UiBold")
            Title:SizeToContents()
            Title:SetTextColor(color_black)
            menu:AddPanel(Title)
    
            for k,v in ipairs(Damages) do
                local SubMenu = menu:AddSubMenu(v, function() RunConsoleCommand("_FAdmin", "slap", ply:UserID(), v) end)
    
                local SubMenuTitle = vgui.Create("DLabel")
                SubMenuTitle:SetText("  " .. v .. " урона\n")
                SubMenuTitle:SetFont("UiBold")
                SubMenuTitle:SizeToContents()
                SubMenuTitle:SetTextColor(color_black)
    
                SubMenu:AddPanel(SubMenuTitle)
    
                for reps, Name in SortedPairs(Repetitions) do
                    local uid = ply:UserID()
                    SubMenu:AddOption(Name, function() RunConsoleCommand("_FAdmin", "slap", uid, v, reps) end)
                end
            end
            menu:Open()
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/ignite/cl_init.lua:
FAdmin.StartHooks["Ignite"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "ignite",
        hasTarget = true,
        message = {"instigator", " поджег ", "targets", " ", "extraInfo.1"},
        readExtraInfo = function()
            local time = net.ReadUInt(16)
            return {time == 0 and FAdmin.PlayerActions.commonTimes[time] or string.format("на %s", FAdmin.PlayerActions.commonTimes[time] or (time .. " секунд"))}
        end
    }

    FAdmin.Messages.RegisterNotification{
        name = "unignite",
        hasTarget = true,
        message = {"instigator", " потушил ", "targets"},
    }

    FAdmin.Access.AddPrivilege("Ignite", 2)
    FAdmin.Commands.AddCommand("Ignite", nil, "<Player>", "[time]")
    FAdmin.Commands.AddCommand("unignite", nil, "<Player>")

    wayscore.AddActionButton('ignite', {
        name = function(ply) return ply:FAdmin_GetGlobal('FAdmin_ignited') and 'Потушить' or 'Поджечь' end,
        icon = function(ply)
            return 'fadmin/icons/ignite', ply:FAdmin_GetGlobal('FAdmin_ignited') and 'fadmin/icons/disable'
        end,
        color = Color(255,130,0),
        category = 'Развлечения',
        order = 13000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Ignite', ply) end,
        callback = function(ply, button)
            if not ply:FAdmin_GetGlobal('FAdmin_ignited') then
                RunConsoleCommand('_FAdmin', 'ignite', ply:UserID())
                button:SetImage2('fadmin/icons/disable')
                button:SetText('Потушить')
                button:GetParent():InvalidateLayout()
            else
                RunConsoleCommand('_FAdmin', 'unignite', ply:UserID())
                button:SetImage2('null')
                button:SetText('Поджечь')
                button:GetParent():InvalidateLayout()
            end
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/health/cl_init.lua:
FAdmin.StartHooks["Health"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "sethealth",
        hasTarget = true,
        message = {"instigator", " установил ", "targets", " ", "extraInfo.1", " ХП"},
        readExtraInfo = function() return {tostring(net.ReadUInt(16))} end,
        extraInfoColors = {Color(160, 171, 189)},
    }

    FAdmin.Access.AddPrivilege("SetHealth", 2)
    FAdmin.Commands.AddCommand("hp", nil, "<Player>", "<health>")
    FAdmin.Commands.AddCommand("SetHealth", nil, "[Player]", "<health>")

    wayscore.AddActionButton('sethealth', {
        name = 'Установить ХП',
        icon = 'icon72/heart.png',
        color = Color(255,130,0),
        order = 12000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'SetHealth', ply) end,
        callback = function(ply, button)
            Derma_StringRequest('Установить ХП', 'Сколько ХП установить игроку?', '',
                function(text)
                    local health = tonumber(text or 100) or 100
                    RunConsoleCommand('_fadmin', 'SetHealth', ply:UserID(), health)
                end
            )
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/god/cl_init.lua:
FAdmin.StartHooks["God"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "god",
        hasTarget = true,
        message = {"instigator", " включил бессмертие для ", "targets"},
        receivers = "involved+admins",
    }

    FAdmin.Messages.RegisterNotification{
        name = "ungod",
        hasTarget = true,
        message = {"instigator", " выключил бессмертие для ", "targets"},
        receivers = "involved+admins",
    }

    FAdmin.Access.AddPrivilege("God", 2)
    FAdmin.Commands.AddCommand("god", nil, "<Player>")
    FAdmin.Commands.AddCommand("ungod", nil, "<Player>")

    wayscore.AddActionButton('god', {
        name = function(ply) return ply:FAdmin_GetGlobal('FAdmin_godded') and 'Сделать смертным' or 'Сделать бессмертным' end,
        icon = function(ply)
            return 'fadmin/icons/god', ply:FAdmin_GetGlobal('FAdmin_godded') and 'fadmin/icons/disable'
        end,
        color = Color(255,130,0),
        order = 10000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'God', ply) end,
        callback = function(ply, button)
            if not ply:FAdmin_GetGlobal('FAdmin_godded') then
                RunConsoleCommand('_FAdmin', 'god', ply:UserID())
                button:SetImage2('fadmin/icons/disable')
                button:SetText('Сделать смертным')
                button:GetParent():InvalidateLayout()
            else
                RunConsoleCommand('_FAdmin', 'ungod', ply:UserID())
                button:SetImage2('null')
                button:SetText('Сделать бессмертным')
                button:GetParent():InvalidateLayout()
            end
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/giveweapons/cl_init.lua:
local function GiveWeaponGui(ply)
    local frame = vgui.Create("DFrame")
    frame:SetTitle("Give weapon")
    frame:SetSize(ScrW() / 2, ScrH() - 50)
    frame:Center()
    frame:SetVisible(true)
    frame:MakePopup()

    local WeaponMenu = vgui.Create("FAdmin_weaponPanel", frame)
    WeaponMenu:StretchToParent(0,25,0,0)

    function WeaponMenu:DoGiveWeapon(SpawnName, IsAmmo)
        if not ply:IsValid() then return end
        local giveWhat = (IsAmmo and "ammo") or "weapon"

        RunConsoleCommand("FAdmin", "give" .. giveWhat, ply:UserID(), SpawnName)
    end

    WeaponMenu:BuildList()
end

FAdmin.StartHooks["GiveWeapons"] = function()
    FAdmin.Access.AddPrivilege("giveweapon", 2)
    FAdmin.Commands.AddCommand("giveweapon", nil, "<Player>", "<weapon>")

    wayscore.AddActionButton('giveweapon', {
        name = 'Выдать оружие',
        icon = 'fadmin/icons/weapon',
        color = Color(255,130,0),
        category = 'Администрирование',
        order = 9000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'giveweapon') end,
        callback = GiveWeaponGui,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/freeze/cl_init.lua:
FAdmin.StartHooks["Freeze"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "freeze",
        hasTarget = true,
        message = {"instigator", " зафризил ", "targets", " ", "extraInfo.1"},
        readExtraInfo = function()
            local time = net.ReadUInt(16)

            return {time == 0 and FAdmin.PlayerActions.commonTimes[time] or string.format("на %s", FAdmin.PlayerActions.commonTimes[time] or (time .. " секунд"))}
        end
    }

    FAdmin.Messages.RegisterNotification{
        name = "unfreeze",
        hasTarget = true,
        message = {"instigator", " расфризил ", "targets"},
    }

    FAdmin.Messages.RegisterNotification{
        name = "frozen_disconnected",
        hasTarget = false,
        message = {"Игрок ", "extraInfo.1", ", которого ты зафризил, вышел с сервера"},
        readExtraInfo = function() return {net.ReadString()} end,
        extraInfoColors = {Color(160, 171, 189)},
    }


    FAdmin.Access.AddPrivilege("Freeze", 2)
    FAdmin.Commands.AddCommand("freeze", nil, "<Player>")
    FAdmin.Commands.AddCommand("unfreeze", nil, "<Player>")

    wayscore.AddActionButton('freeze', {
        name = function(ply) return ply:FAdmin_GetGlobal('FAdmin_frozen') and 'Расфризить' or 'Зафризить' end,
        icon = function(ply)
            return 'fadmin/icons/freeze', ply:FAdmin_GetGlobal('FAdmin_frozen') and 'fadmin/icons/disable'
        end,
        color = Color(255,130,0),
        order = 8000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Freeze', ply) end,
        callback = function(ply, button)
            if not ply:FAdmin_GetGlobal('FAdmin_frozen') then
                FAdmin.PlayerActions.addTimeMenu(function(secs)
                    RunConsoleCommand('_FAdmin', 'freeze', ply:UserID(), secs)
                    button:SetImage2('fadmin/icons/disable')
                    button:SetText('Расфризить')
                    button:GetParent():InvalidateLayout()
                end)
            else
                RunConsoleCommand('_FAdmin', 'unfreeze', ply:UserID())
                button:SetImage2('null')
                button:SetText('Зафризить')
                button:GetParent():InvalidateLayout()
            end
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/chat/sh_chatcommands.lua:
local plyMeta = FindMetaTable("Player")
DarkRP.chatCommands = DarkRP.chatCommands or {}

local validChatCommand = {
    command = isstring,
    description = isstring,
    condition = fn.FOr{fn.Curry(fn.Eq, 2)(nil), isfunction},
    delay = isnumber,
    tableArgs = fn.FOr{fn.Curry(fn.Eq, 2)(nil), isbool},
}

local checkChatCommand = function(tbl)
    for k in pairs(validChatCommand) do
        if not validChatCommand[k](tbl[k]) then
            return false, k
        end
    end
    return true
end

function DarkRP.declareChatCommand(tbl)
    local valid, element = checkChatCommand(tbl)
    if not valid then
        DarkRP.error("Incorrect chat command! " .. element .. " is invalid!", 2)
    end

    tbl.command = string.lower(tbl.command)
    DarkRP.chatCommands[tbl.command] = DarkRP.chatCommands[tbl.command] or tbl
    for k, v in pairs(tbl) do
        DarkRP.chatCommands[tbl.command][k] = v
    end
end

function DarkRP.removeChatCommand(command)
    DarkRP.chatCommands[string.lower(command)] = nil
end

function DarkRP.chatCommandAlias(command, ...)
    local name
    for k, v in pairs{...} do
        name = string.lower(v)

        DarkRP.chatCommands[name] = {command = name}
        setmetatable(DarkRP.chatCommands[name], {
            __index = DarkRP.chatCommands[command]
        })
    end
end

function DarkRP.getChatCommand(command)
    return DarkRP.chatCommands[string.lower(command)]
end

function DarkRP.getChatCommands()
    return DarkRP.chatCommands
end

function DarkRP.getSortedChatCommands()
    local tbl = fn.Compose{table.ClearKeys, table.Copy, DarkRP.getChatCommands}()
    table.SortByMember(tbl, "command", true)

    return tbl
end

-- chat commands that have been defined, but not declared
DarkRP.getIncompleteChatCommands = fn.Curry(fn.Filter, 3)(fn.Compose{fn.Not, checkChatCommand})(DarkRP.chatCommands)

--[[---------------------------------------------------------------------------
Chat commands
---------------------------------------------------------------------------]]
DarkRP.declareChatCommand{
    command = "pm",
    description = "Send a private message to someone.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "reply",
    description = "Ответить на сообщение в /pm.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "w",
    description = "Say something in whisper voice.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "y",
    description = "Yell something out loud.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "me",
    description = "Chat roleplay to say you're doing things that you can't show otherwise.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "/",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "a",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "ooc",
    description = "Global server chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "broadcast",
    description = "Broadcast something as a mayor.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "channel",
    description = "Tune into a radio channel.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "radio",
    description = "Say something through the radio.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "g",
    description = "Group chat.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "credits",
    description = "Send the DarkRP credits to someone.",
    delay = 1.5
}

--gamemodes/darkrp/gamemode/modules/animations/cl_animations.lua:
-- Player Jumping
do

    local MOVETYPE_NOCLIP = MOVETYPE_NOCLIP
    local ACT_MP_JUMP = ACT_MP_JUMP

    local CurTime = CurTime

    function GM:HandlePlayerJumping( ply, vel )
        if (ply:GetMoveType() == MOVETYPE_NOCLIP) then
            ply.m_bJumping = false
            return false
        end

        if ply.m_bJumping then
            if ply.m_bFirstJumpFrame then
                ply.m_bFirstJumpFrame = false
                ply:AnimRestartMainSequence()
            end

            if (ply:WaterLevel() > 1) or (CurTime() - ply.m_flJumpStartTime) > 0.2 and ply:OnGround() then
                ply.m_bJumping = false
                ply.m_fGroundTime = nil
                ply:AnimRestartMainSequence()
            end

            if ply.m_bJumping then
                hook.Run( "OnPlayerJump", ply, vel )
                ply.CalcIdeal = ACT_MP_JUMP
                return true
            end

        else

            -- airwalk more like hl2mp, we airwalk until we have 0 velocity, then it's the jump animation
            -- underwater we're alright we airwalking
            if not ply:OnGround() and (ply:WaterLevel() < 1) then
                if not ply.m_fGroundTime then
                    ply.m_fGroundTime = CurTime()
                elseif (CurTime() - ply.m_fGroundTime) > 0 and (vel:Length2DSqr() < 0.25) then
                    ply.m_bJumping = true
                    ply.m_bFirstJumpFrame = false
                    ply.m_flJumpStartTime = 0
                end
            end

        end

        return false
    end

end

-- Player Crouching
do

    local ACT_MP_CROUCH_IDLE = ACT_MP_CROUCH_IDLE
    local ACT_MP_CROUCHWALK = ACT_MP_CROUCHWALK
    local FL_ANIMDUCKING = FL_ANIMDUCKING

    function GM:HandlePlayerDucking( ply, vel )
        if ply:IsFlagSet( FL_ANIMDUCKING ) then
            if (vel:Length2DSqr() > 0.25) then
                ply.CalcIdeal = ACT_MP_CROUCHWALK
            else
                ply.CalcIdeal = ACT_MP_CROUCH_IDLE
            end

            return true
        end

        return false
    end

end

-- Noclip
do

    local ACT_GMOD_NOCLIP_LAYER = ACT_GMOD_NOCLIP_LAYER
    local GESTURE_SLOT_CUSTOM = GESTURE_SLOT_CUSTOM
    local MOVETYPE_NOCLIP = MOVETYPE_NOCLIP

    function GM:HandlePlayerNoClipping( ply, vel )
        if (ply:GetMoveType() ~= MOVETYPE_NOCLIP) or ply:InVehicle() then
            if (ply.m_bWasNoclipping == true) then
                ply.m_bWasNoclipping = nil
                ply:AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )

                ply:SetIK( true )
            end

            return
        end

        if not ply.m_bWasNoclipping then
            ply:AnimRestartGesture( GESTURE_SLOT_CUSTOM, ACT_GMOD_NOCLIP_LAYER, false )

            ply:SetIK( false )
        end

        return true
    end

end

-- Player Vaulting
do

    local ACT_MP_SWIM = ACT_MP_SWIM
    local max_vel = 1000000

    function GM:HandlePlayerVaulting( ply, vel )
        if (vel:LengthSqr() < max_vel) then return end
        if ply:IsOnGround() then return end

        ply.CalcIdeal = ACT_MP_SWIM

        return true
    end

    function GM:HandlePlayerSwimming( ply, vel )
        if (ply:WaterLevel() < 2) or ply:IsOnGround() then
            ply.m_bInSwim = false
            return false
        end

        ply.CalcIdeal = ACT_MP_SWIM
        ply.m_bInSwim = true

        return true
    end

end

-- Player Landing
do

    local GESTURE_SLOT_JUMP = GESTURE_SLOT_JUMP
    local MOVETYPE_NOCLIP = MOVETYPE_NOCLIP
    local ACT_LAND = ACT_LAND

    function GM:HandlePlayerLanding( ply, vel, WasOnGround )
        if (ply:GetMoveType() == MOVETYPE_NOCLIP) then return end
        if ply:IsOnGround() and (WasOnGround == false) then
            ply:AnimRestartGesture( GESTURE_SLOT_JUMP, ACT_LAND, true )
        end
    end

end

-- Player Driving
do

    list.Set( "DrivingAnimations", "models/vehicles/prisoner_pod_inner.mdl", "drive_pd" )
    list.Set( "DrivingAnimations", "prop_vehicle_airboat", "drive_airboat" )
    list.Set( "DrivingAnimations", "prop_vehicle_jeep", "drive_jeep" )

    local isfunction = isfunction
    local list_Get = list.Get
    local IsValid = IsValid
    local istable = istable

    function GM:HandlePlayerDriving( ply )
        if ply:InVehicle() then
            local parent = ply:GetParent()
            if IsValid( parent ) then
                local veh = ply:GetVehicle()
                if IsValid( veh ) then
                    if not veh.HandleAnimation and veh.GetVehicleClass then
                        local data = list.Get( "Vehicles" )[ veh:GetVehicleClass() ]
                        if (data) and (data.Members) and (data.Members.HandleAnimation) then
                            veh.HandleAnimation = data.Members.HandleAnimation
                        else
                            veh.HandleAnimation = true
                        end
                    end

                    if isfunction( veh.HandleAnimation ) then
                        local seq = veh:HandleAnimation( ply )
                        if (seq ~= nil) then
                            ply.CalcSeqOverride = seq
                        end
                    end

                    local rollercoaster_anim = false
                    if (ply.CalcSeqOverride == -1) then
                        local class_anim = list_Get( "DrivingAnimations" )[ veh:GetClass() ]
                        if isstring( class_anim ) then
                            ply.CalcSeqOverride = ply:LookupSequence( class_anim )
                        else
                            local mdl_anim = list_Get( "DrivingAnimations" )[ veh:GetModel() ]
                            if isstring( mdl_anim ) then
                                ply.CalcSeqOverride = ply:LookupSequence( mdl_anim )
                            else
                                rollercoaster_anim = true
                            end
                        end
                    end

                    if (rollercoaster_anim) then
                        local seq = ply:LookupSequence( "sit_rollercoaster" )
                        if (seq > 0) then
                            ply.CalcSeqOverride = seq
                        else
                            rollercoaster_anim = false
                        end
                    end

                    if (rollercoaster_anim or ply.CalcSeqOverride == ply:LookupSequence( "sit" )) and ply:GetAllowWeaponsInVehicle() then
                        local wep = ply:GetActiveWeapon()
                        if IsValid( wep ) then
                            local holdtype = wep:GetHoldType()
                            local seqid = ply:LookupSequence( "sit_" .. ((holdtype == "smg") and "smg1" or holdtype) )
                            if ( seqid ~= -1 ) then
                                ply.CalcSeqOverride = seqid
                            end
                        end
                    end

                    return true
                end
            end
        end

        return false
    end

end

do

    local ACT_MP_STAND_IDLE = ACT_MP_STAND_IDLE
    local MOVETYPE_NOCLIP = MOVETYPE_NOCLIP
    local ACT_MP_WALK = ACT_MP_WALK
    local ACT_MP_RUN = ACT_MP_RUN

    local function isNoActivity( self, ply, vel )
        if self:HandlePlayerDriving( ply ) then return end
        if self:HandlePlayerNoClipping( ply, vel ) then return end
        if self:HandlePlayerVaulting( ply, vel ) then return end
        if self:HandlePlayerJumping( ply, vel ) then return end
        if self:HandlePlayerSwimming( ply, vel ) then return end
        if self:HandlePlayerDucking( ply, vel ) then return end
        return true
    end

    function GM:CalcMainActivity( ply, vel )
        ply.CalcIdeal = ACT_MP_STAND_IDLE
        ply.CalcSeqOverride = -1

        self:HandlePlayerLanding( ply, vel, ply.m_bWasOnGround )

        if isNoActivity( self, ply, vel ) then
            local len2d = vel:Length2DSqr()
            if (len2d > 22500) then
                ply.CalcIdeal = ACT_MP_RUN
            elseif (len2d > 0.25) then
                ply.CalcIdeal = ACT_MP_WALK
            end
        end

        ply.m_bWasOnGround = ply:IsOnGround()
        ply.m_bWasNoclipping = (ply:GetMoveType() == MOVETYPE_NOCLIP) and not ply:InVehicle()

        return ply.CalcIdeal, ply.CalcSeqOverride
    end

end

do

    local math_min = math.min

    function GM:UpdateAnimation(ply, velocity, maxseqgroundspeed)
        local len = velocity:Length()

        if len <= 0.2 then
            ply:SetPlaybackRate(1)
            return
        end

        local movement = len / maxseqgroundspeed
        ply:SetPlaybackRate(math_min(movement, 2))

        if not ply:IsOnGround() and len >= 1000 then
            ply:SetPlaybackRate(0.1)
            return
        end
    end

    GM.MouthMoveAnimation = nil
    GM.GrabEarAnimation = nil

end
--addons/module_policeradio/lua/darkrp_modules/dradio/sh_init.lua:
dRadio = {}

dRadio.defaultTeams = {
    [TEAM_POLICE] = 'police',
    [TEAM_CHIEF] = 'police',
    [TEAM_MAYOR] = 'police',
    [TEAM_MOLOT] = 'police',
    [TEAM_POLICES] = 'police',
    [TEAM_POLICEMED] = 'police',
    [TEAM_TANKIST] = 'police',
    [TEAM_SNIPER] = 'police',
    [TEAM_DETECTIVE] = 'police',
    [TEAM_SUPERPOLICE] = 'police',
    [TEAM_NALOG] = 'police',

    [TEAM_ADMIN] = 'admin',

    [TEAM_BANDITVIP] = '0',
}

dRadio.specialChannels = {
    ems = {
        [TEAM_POLICE] = true,
        [TEAM_CHIEF] = true,
        [TEAM_MAYOR] = true,
        [TEAM_MOLOT] = true,
        [TEAM_POLICES] = true,
        [TEAM_POLICEMED] = true,
        [TEAM_TANKIST] = true,
        [TEAM_SNIPER] = true,
        [TEAM_DETECTIVE] = true,
        [TEAM_SUPERPOLICE] = true,
        [TEAM_NALOG] = true,
    },

    police = {
        [TEAM_POLICE] = true,
        [TEAM_CHIEF] = true,
        [TEAM_MAYOR] = true,
        [TEAM_MOLOT] = true,
        [TEAM_POLICES] = true,
        [TEAM_POLICEMED] = true,
        [TEAM_TANKIST] = true,
        [TEAM_SNIPER] = true,
        [TEAM_DETECTIVE] = true,
        [TEAM_SUPERPOLICE] = true,
        [TEAM_NALOG] = true,
    },

    admin = {
        [TEAM_ADMIN] = true,
    },
}

if TEAM_ARMIASMED or TEAM_ARMIA or TEAM_ARMIAS then
    dRadio.defaultTeams[TEAM_ARMIASMED] = 'army'
    dRadio.defaultTeams[TEAM_ARMIA] = 'army'
    dRadio.defaultTeams[TEAM_ARMIAS] = 'army'
    dRadio.defaultTeams[TEAM_ARMIARIOT] = 'army'
    dRadio.defaultTeams[TEAM_SHPION] = 'army'

    dRadio.specialChannels.ems[TEAM_ARMIASMED] = true
    dRadio.specialChannels.ems[TEAM_ARMIA] = true
    dRadio.specialChannels.ems[TEAM_ARMIAS] = true
    dRadio.specialChannels.ems[TEAM_ARMIARIOT] = true
    dRadio.specialChannels.ems[TEAM_SHPION] = true

    dRadio.specialChannels.army = {
        [TEAM_ARMIASMED] = true,
        [TEAM_SHPION] = true,
        [TEAM_ARMIA] = true,
        [TEAM_ARMIAS] = true,
        [TEAM_ARMIARIOT] = true,
        [TEAM_MAYOR] = true,
    }
end

dRadio.lang = {
    error_noRadio = 'У тебя нет рации',
    error_haveRadio = 'У тебя уже есть рация',
    error_radioDisabled = 'У тебя выключена рация',
    error_radioEnabled = 'У тебя включена рация',
    error_freqNotFound = 'Такой частоты не существует',
    error_freqCurrentlySelected = 'Эта частота уже выбрана',
    error_freqNoAccess = 'У тебя нет доступа к этой частоте',

    hint_radioEnabled = 'Рация включена',
    hint_radioDisabled = 'Рация выключена',
    hint_selectedFreq = 'Рация переведена на частоту %q',
    hint_radioReceived = 'Ты получил рацию. Для использования текстового чата нажми "U", для использования голосового чата нажми "G"',
    hint_radioLost = 'Рация потеряна',
}

dRadio.config = {
    defaultFreq = '0',
}

nw.Register('dRadio_enabled')
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetPlayer()

nw.Register('dRadio_channel')
    :Write(net.WriteString)
    :Read(net.ReadString)
    :SetPlayer()

nw.Register('dRadio_hasRadio')
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetPlayer()

nw.Register('dRadio_isTalking')
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetPlayer()

local plymeta = FindMetaTable('Player')

function plymeta:radioEnabled()
    local enabled = self:GetNetVar('dRadio_enabled')
    local freq = self:GetNetVar('dRadio_channel')

    return enabled, freq
end

function plymeta:hasRadio()
    return self:GetNetVar('dRadio_hasRadio')
end

function plymeta:isTalkingToRadio()
    return self:GetNetVar('dRadio_isTalking')
end
--addons/module_policeradio/lua/darkrp_modules/dradio/cl_vgui_notify.lua:
local PANEL = {}

function PANEL:Init()
    self.color = Color(0,89,255,100)

	self.name = self:Add('DLabel')
	self.name:SetFont('GModNotify')
	self.name:Dock(FILL)
	self.name:DockMargin(8, 0, 0, 0)
	self.name:SetTextColor(color_white)

	self:SetColor(Color(0,68,255,90))
	self:SetSize(250, 32 + 8)
	self:DockPadding(4, 4, 4, 4)
	self:DockMargin(2, 2, 2, 2)
	self:Dock(BOTTOM)
end

local chiefs = {
    [TEAM_CHIEF] = true,
    [TEAM_MAYOR] = true,
}

if TEAM_ARMIA then chiefs[TEAM_ARMIA] = true end

function PANEL:SetPlayer(ply)
	self.ply = ply
    local printname = ply:Nick()..(chiefs[ply:Team()] and ' | ★' or '')
	self.name:SetText(printname)

    local col = team.GetColor(ply:Team())
    self:SetColor(Color(col.r, col.g, col.b, 0.7*255))

	self:InvalidateLayout()
end

function PANEL:SetColor(col)
    self.color = col
end

function PANEL:Paint(w, h)
	draw.RoundedBox(4, 0, 0, w, h, self.color)
end

function PANEL:Think()
	if self.fadeAnim then
		self.fadeAnim:Run()
	end
end

function PANEL:FadeOut(anim, delta, data)
	if anim.Finished then
        local vp = dRadio.voicePanels[self.ply]
		if IsValid(vp) then
			vp:Remove()
			vp = nil
		end
		return
	end
	self:SetAlpha(255 - (255 * delta))
end

vgui.Register('dradio_notify', PANEL, 'DPanel')
--addons/weapon_knifecsgo/lua/weapons/csgo_bowie.lua:
if not file.Exists( "weapons/csgo_baseknife.lua", "LUA" ) then
  SWEP.Spawnable = false
  print( "csgo_bowie failed to initialize: csgo_baseknife.lua not found. Did you install the main part?" )
  return
end

local TTT = ( GAMEMODE_NAME == "terrortown" or cvars.Bool("csgo_knives_force_ttt", false) )

DEFINE_BASECLASS( "csgo_baseknife" )

if ( SERVER ) then
  SWEP.Weight         = 5
  SWEP.AutoSwitchTo   = false
  SWEP.AutoSwitchFrom = false

  if TTT then
    SWEP.EquipMenuData = nil
  end
end

if ( CLIENT ) then
  SWEP.Slot         = TTT and 6 or 2
  SWEP.SlotPos      = 0
end

SWEP.PrintName      = "Нож Bowie"
SWEP.Category       = "Запрещено"

SWEP.Spawnable      = false
SWEP.AdminSpawnable = true

SWEP.ViewModel      = "models/weapons/v_csgo_bowie.mdl"
SWEP.WorldModel     = "models/weapons/w_csgo_bowie.mdl"

SWEP.SkinIndex      = 0
SWEP.PaintMaterial  = nil
SWEP.AreDaggers     = false

util.PrecacheModel( SWEP.ViewModel )
util.PrecacheModel( SWEP.WorldModel )

-- TTT config values

-- Kind specifies the category this weapon is in. Players can only carry one of
-- each. Can be: WEAPON_... MELEE, PISTOL, HEAVY, NADE, CARRY, EQUIP1, EQUIP2 or ROLE.
-- Matching SWEP.Slot values: 0      1       2     3      4      6       7        8
SWEP.Kind = WEAPON_EQUIP

-- If AutoSpawnable is true and SWEP.Kind is not WEAPON_EQUIP1/2, then this gun can
-- be spawned as a random weapon.
SWEP.AutoSpawnable = false

-- The AmmoEnt is the ammo entity that can be picked up when carrying this gun.
-- SWEP.AmmoEnt = "item_ammo_smg1_ttt"

-- CanBuy is a table of ROLE_* entries like ROLE_TRAITOR and ROLE_DETECTIVE. If
-- a role is in this table, those players can buy this.
SWEP.CanBuy = nil

-- InLoadoutFor is a table of ROLE_* entries that specifies which roles should
-- receive this weapon as soon as the round starts. In this case, none.
SWEP.InLoadoutFor = nil

-- If LimitedStock is true, you can only buy one per round.
SWEP.LimitedStock = false

-- If AllowDrop is false, players can't manually drop the gun with Q
SWEP.AllowDrop = true

-- If IsSilent is true, victims will not scream upon death.
SWEP.IsSilent = true

-- If NoSights is true, the weapon won't have ironsights
SWEP.NoSights = true

-- This sets the icon shown for the weapon in the DNA sampler, search window,
-- equipment menu (if buyable), etc.
SWEP.Icon = "vgui/entities/csgo_bowie.vmt"

--addons/weapon_knifecsgo/lua/weapons/csgo_daggers.lua:
if not file.Exists( "weapons/csgo_baseknife.lua", "LUA" ) then
  SWEP.Spawnable = false
  print( "csgo_daggers failed to initialize: csgo_baseknife.lua not found. Did you install the main part?" )
  return
end

local TTT = ( GAMEMODE_NAME == "terrortown" or cvars.Bool("csgo_knives_force_ttt", false) )

DEFINE_BASECLASS( "csgo_baseknife" )

if ( SERVER ) then
  SWEP.Weight         = 5
  SWEP.AutoSwitchTo   = false
  SWEP.AutoSwitchFrom = false

  if TTT then
    SWEP.EquipMenuData = nil
  end
end

if ( CLIENT ) then
  SWEP.Slot         = TTT and 6 or 2
  SWEP.SlotPos      = 0
end

SWEP.PrintName      = "Тычковые Ножи"
SWEP.Category       = "Запрещено"

SWEP.Spawnable      = false
SWEP.AdminSpawnable = true

SWEP.ViewModel      = "models/weapons/v_csgo_push.mdl"
SWEP.WorldModel     = "models/weapons/w_csgo_push.mdl"

SWEP.SkinIndex      = 0
SWEP.PaintMaterial  = nil
SWEP.AreDaggers     = true

util.PrecacheModel( SWEP.ViewModel )
util.PrecacheModel( SWEP.WorldModel )

-- TTT config values

-- Kind specifies the category this weapon is in. Players can only carry one of
-- each. Can be: WEAPON_... MELEE, PISTOL, HEAVY, NADE, CARRY, EQUIP1, EQUIP2 or ROLE.
-- Matching SWEP.Slot values: 0      1       2     3      4      6       7        8
SWEP.Kind = WEAPON_EQUIP

-- If AutoSpawnable is true and SWEP.Kind is not WEAPON_EQUIP1/2, then this gun can
-- be spawned as a random weapon.
SWEP.AutoSpawnable = false

-- The AmmoEnt is the ammo entity that can be picked up when carrying this gun.
-- SWEP.AmmoEnt = "item_ammo_smg1_ttt"

-- CanBuy is a table of ROLE_* entries like ROLE_TRAITOR and ROLE_DETECTIVE. If
-- a role is in this table, those players can buy this.
SWEP.CanBuy = nil

-- InLoadoutFor is a table of ROLE_* entries that specifies which roles should
-- receive this weapon as soon as the round starts. In this case, none.
SWEP.InLoadoutFor = nil

-- If LimitedStock is true, you can only buy one per round.
SWEP.LimitedStock = false

-- If AllowDrop is false, players can't manually drop the gun with Q
SWEP.AllowDrop = true

-- If IsSilent is true, victims will not scream upon death.
SWEP.IsSilent = true

-- If NoSights is true, the weapon won't have ironsights
SWEP.NoSights = true

-- This sets the icon shown for the weapon in the DNA sampler, search window,
-- equipment menu (if buyable), etc.
SWEP.Icon = "vgui/entities/csgo_daggers.vmt"

--addons/weapon_shield/lua/weapons/fridge_shield_unbreakable/cl_init.lua:
include('shared.lua')

function SWEP:DrawWorldModel()
	self:SetNoDraw(true) 
end
--gamemodes/darkrp/entities/weapons/gmod_tool/cl_init.lua:

local gmod_drawhelp = CreateClientConVar( "gmod_drawhelp", "1", true, false, "Should the tool HUD be displayed when the tool gun is active?" )
local gmod_toolmode = CreateClientConVar( "gmod_toolmode", "rope", true, true, "Currently selected tool mode for the Tool Gun." )
CreateClientConVar( "gmod_drawtooleffects", "1", true, false, "Should tools draw certain UI elements or effects? (Will not work for all tools)" )

cvars.AddChangeCallback( "gmod_toolmode", function( name, old, new )
	if ( old == new ) then return end
	spawnmenu.ActivateTool( new, true )
end, "gmod_toolmode_panel" )

include( "shared.lua" )
include( "cl_viewscreen.lua" )

SWEP.Slot			= 5
SWEP.SlotPos		= 6
SWEP.DrawAmmo		= false
SWEP.DrawCrosshair	= true

SWEP.WepSelectIcon = surface.GetTextureID( "vgui/gmod_tool" )
SWEP.Gradient = surface.GetTextureID( "gui/gradient" )
SWEP.InfoIcon = surface.GetTextureID( "gui/info" )

SWEP.ToolNameHeight = 0
SWEP.InfoBoxHeight = 0

surface.CreateFont( "GModToolName", {
	font = "Roboto Bk",
	size = 80,
	weight = 1000
} )

surface.CreateFont( "GModToolSubtitle", {
	font = "Roboto Bk",
	size = 24,
	weight = 1000
} )

surface.CreateFont( "GModToolHelp", {
	font = "Roboto Bk",
	size = 17,
	weight = 1000
} )

--[[---------------------------------------------------------
	Draws the help on the HUD (disabled if gmod_drawhelp is 0)
-----------------------------------------------------------]]
function SWEP:DrawHUD()

	local mode = gmod_toolmode:GetString()
	local toolObject = self:GetToolObject()

	-- Don't draw help for a nonexistant tool!
	if ( !toolObject ) then return end

	toolObject:DrawHUD()

	if ( !gmod_drawhelp:GetBool() ) then return end

	-- This could probably all suck less than it already does

	local x, y = 50, 40
	local w, h = 0, 0

	local TextTable = {}
	local QuadTable = {}

	QuadTable.texture = self.Gradient
	QuadTable.color = Color( 10, 10, 10, 180 )

	QuadTable.x = 0
	QuadTable.y = y - 8
	QuadTable.w = 600
	QuadTable.h = self.ToolNameHeight - ( y - 8 )
	draw.TexturedQuad( QuadTable )

	TextTable.font = "GModToolName"
	TextTable.color = Color( 240, 240, 240, 255 )
	TextTable.pos = { x, y }
	TextTable.text = "#tool." .. mode .. ".name"
	w, h = draw.TextShadow( TextTable, 2 )
	y = y + h

	TextTable.font = "GModToolSubtitle"
	TextTable.pos = { x, y }
	TextTable.text = "#tool." .. mode .. ".desc"
	w, h = draw.TextShadow( TextTable, 1 )
	y = y + h + 8

	self.ToolNameHeight = y

	QuadTable.y = y
	QuadTable.h = self.InfoBoxHeight
	local alpha = math.Clamp( 255 + ( toolObject.LastMessage - CurTime() ) * 800, 10, 255 )
	QuadTable.color = Color( alpha, alpha, alpha, 230 )
	draw.TexturedQuad( QuadTable )

	y = y + 4

	TextTable.font = "GModToolHelp"

	if ( !toolObject.Information ) then
		TextTable.pos = { x + self.InfoBoxHeight, y }
		TextTable.text = toolObject:GetHelpText()
		w, h = draw.TextShadow( TextTable, 1 )

		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetTexture( self.InfoIcon )
		surface.DrawTexturedRect( x + 1, y + 1, h - 3, h - 3 )

		self.InfoBoxHeight = h + 8

		return
	end

	local h2 = 0

	for _, v in pairs( toolObject.Information ) do
		if ( isstring( v ) ) then v = { name = v } end

		local name = v.name

		if ( !name ) then continue end
		if ( v.stage && v.stage != self:GetStage() ) then continue end
		if ( v.op && v.op != toolObject:GetOperation() ) then continue end

		local txt = "#tool." .. GetConVarString( "gmod_toolmode" ) .. "." .. name
		if ( name == "info" ) then txt = toolObject:GetHelpText() end

		TextTable.text = txt
		TextTable.pos = { x + 21, y + h2 }

		w, h = draw.TextShadow( TextTable, 1 )

		local icon1 = v.icon
		local icon2 = v.icon2

		if ( !icon1 ) then
			if ( string.StartsWith( name, "info" ) ) then icon1 = "gui/info" end
			if ( string.StartsWith( name, "left" ) ) then icon1 = "gui/lmb.png" end
			if ( string.StartsWith( name, "right" ) ) then icon1 = "gui/rmb.png" end
			if ( string.StartsWith( name, "reload" ) ) then icon1 = "gui/r.png" end
			if ( string.StartsWith( name, "use" ) ) then icon1 = "gui/e.png" end
		end
		if ( !icon2 && !string.StartsWith( name, "use" ) && string.EndsWith( name, "use" ) ) then icon2 = "gui/e.png" end

		self.Icons = self.Icons or {}
		if ( icon1 && !self.Icons[ icon1 ] ) then self.Icons[ icon1 ] = Material( icon1 ) end
		if ( icon2 && !self.Icons[ icon2 ] ) then self.Icons[ icon2 ] = Material( icon2 ) end

		if ( icon1 && self.Icons[ icon1 ] && !self.Icons[ icon1 ]:IsError() ) then
			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.SetMaterial( self.Icons[ icon1 ] )
			surface.DrawTexturedRect( x, y + h2, 16, 16 )
		end

		if ( icon2 && self.Icons[ icon2 ] && !self.Icons[ icon2 ]:IsError() ) then
			surface.SetDrawColor( 255, 255, 255, 255 )
			surface.SetMaterial( self.Icons[ icon2 ] )
			surface.DrawTexturedRect( x - 25, y + h2, 16, 16 )

			draw.SimpleText( "+", "default", x - 8, y + h2 + 2, color_white )
		end

		h2 = h2 + h

	end

	self.InfoBoxHeight = h2 + 8

end

function SWEP:SetStage( ... )

	if ( !self:GetToolObject() ) then return end
	return self:GetToolObject():SetStage( ... )

end

function SWEP:GetStage( ... )

	if ( !self:GetToolObject() ) then return end
	return self:GetToolObject():GetStage( ... )

end

function SWEP:ClearObjects( ... )

	if ( !self:GetToolObject() ) then return end
	self:GetToolObject():ClearObjects( ... )

end

function SWEP:StartGhostEntities( ... )

	if ( !self:GetToolObject() ) then return end
	self:GetToolObject():StartGhostEntities( ... )

end

function SWEP:PrintWeaponInfo( x, y, alpha )
end

function SWEP:FreezeMovement()

	if ( !self:GetToolObject() ) then return false end

	return self:GetToolObject():FreezeMovement()

end

function SWEP:OnReloaded()

	-- TODO: Reload the tool control panels
	-- controlpanel.Clear()

end

--gamemodes/darkrp/entities/weapons/gmod_tool/stool_cl.lua:

-- Tool should return true if freezing the view angles
function ToolObj:FreezeMovement()
	return false
end

-- The tool's opportunity to draw to the HUD
function ToolObj:DrawHUD()
end

-- Force rebuild the Control Panel
function ToolObj:RebuildControlPanel( ... )

	local cPanel = controlpanel.Get( self.Mode )
	if ( !cPanel ) then ErrorNoHalt( "Couldn't find control panel to rebuild!" ) return end

	cPanel:ClearControls()
	self.BuildCPanel( cPanel, ... )

end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/camera.lua:

TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.camera.name"

TOOL.ClientConVar[ "locked" ] = "0"
TOOL.ClientConVar[ "key" ] = "37"
TOOL.ClientConVar[ "toggle" ] = "1"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" }
}

cleanup.Register( "cameras" )

local function CheckLimit( ply, key )

	-- TODO: Clientside prediction
	if ( CLIENT ) then return true end

	local found = false
	for id, camera in ipairs( ents.FindByClass( "gmod_cameraprop" ) ) do
		if ( !camera.controlkey || camera.controlkey != key ) then continue end
		if ( IsValid( camera:CPPIGetOwner() ) && ply != camera:CPPIGetOwner() ) then continue end
		found = true
		break
	end

	if ( !found and !ply:CheckLimit( "cameras" ) ) then
		return false
	end

	return true

end

local function MakeCamera( ply, key, locked, toggle, Data )
	if ( IsValid( ply ) && !CheckLimit( ply, key ) ) then return false end

	local ent = ents.Create( "gmod_cameraprop" )
	if ( !IsValid( ent ) ) then return end

	duplicator.DoGeneric( ent, Data )

	if ( key ) then
		for id, camera in ipairs( ents.FindByClass( "gmod_cameraprop" ) ) do
			if ( !camera.controlkey || camera.controlkey != key ) then continue end
			if ( IsValid( ply ) && IsValid( camera:CPPIGetOwner() ) && ply != camera:CPPIGetOwner() ) then continue end
			camera:Remove()
		end

		ent:SetKey( key )
		ent.controlkey = key
	end

	ent:CPPISetOwner( ply )

	ent.toggle = toggle
	ent.locked = locked

	ent:Spawn()


	ent:SetTracking( NULL, Vector( 0 ) )
	ent:SetLocked( locked )

	if ( toggle == 1 ) then
		numpad.OnDown( ply, key, "Camera_Toggle", ent )
	else
		numpad.OnDown( ply, key, "Camera_On", ent )
		numpad.OnUp( ply, key, "Camera_Off", ent )
	end

	if ( IsValid( ply ) ) then
		ply:AddCleanup( "cameras", ent )
		ply:AddCount( "cameras", ent )
	end

	return ent

end
duplicator.RegisterEntityClass( "gmod_cameraprop", MakeCamera, "controlkey", "locked", "toggle", "Data" )

function TOOL:LeftClick( trace )

	local ply = self:GetOwner()
	local key = self:GetClientNumber( "key" )
	if ( key == -1 ) then return false end

	if ( !CheckLimit( ply, key ) ) then return false end

	if ( CLIENT ) then return true end

	local locked = self:GetClientNumber( "locked" )
	local toggle = self:GetClientNumber( "toggle" )

	local ent = MakeCamera( ply, key, locked, toggle, { Pos = trace.StartPos, Angle = ply:EyeAngles() } )

	undo.Create( "Camera" )
		undo.AddEntity( ent )
		undo.SetPlayer( ply )
	undo.Finish()

	return true, ent

end

function TOOL:RightClick( trace )

	local _, camera = self:LeftClick( trace, true )

	if ( CLIENT ) then return true end

	if ( !IsValid( camera ) ) then return false end

	if ( trace.Entity:IsWorld() ) then

		trace.Entity = self:GetOwner()
		trace.HitPos = trace.Entity:GetPos()

	end

	-- We apply the view offset for players in camera entity
	if ( trace.Entity:IsPlayer() ) then
		trace.HitPos = trace.Entity:GetPos()
	end

	camera:SetTracking( trace.Entity, trace.Entity:WorldToLocal( trace.HitPos ) )

	return true

end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "camera", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

	CPanel:AddControl( "Numpad", { Label = "#tool.camera.key", Command = "camera_key" } )
	CPanel:AddControl( "CheckBox", { Label = "#tool.camera.static", Command = "camera_locked", Help = true } )
	CPanel:AddControl( "CheckBox", { Label = "#tool.toggle", Command = "camera_toggle" } )

end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/nocollide.lua:

TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.nocollide.name"

TOOL.Information = {
	{ name = "left", stage = 0 },
	{ name = "left_1", stage = 1 },
	{ name = "right" },
	{ name = "reload" }
}

cleanup.Register( "nocollide" )

function TOOL:LeftClick( trace )

	if ( !IsValid( trace.Entity ) ) then return end
	if ( trace.Entity:IsPlayer() ) then return end

	-- If there's no physics object then we can't constraint it!
	if ( SERVER && !util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) ) then return false end

	local iNum = self:NumObjects()

	local Phys = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )
	self:SetObject( iNum + 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )

	if ( CLIENT ) then

		if ( iNum > 0 ) then self:ClearObjects() end
		return true

	end

	if ( iNum > 0 ) then

		local Ent1, Ent2 = self:GetEnt( 1 ), self:GetEnt( 2 )
		local Bone1, Bone2 = self:GetBone( 1 ), self:GetBone( 2 )

		local constr = constraint.NoCollide( Ent1, Ent2, Bone1, Bone2 )
		if ( IsValid( constr ) ) then
			undo.Create( "NoCollide" )
				undo.AddEntity( constr )
				undo.SetPlayer( self:GetOwner() )
			undo.Finish()

			self:GetOwner():AddCleanup( "nocollide", constr )
		end

		self:ClearObjects()

	else

		self:SetStage( iNum + 1 )

	end

	return true

end

function TOOL:RightClick( trace )

	if ( !IsValid( trace.Entity ) ) then return end
	if ( trace.Entity:IsPlayer() ) then return end

	if ( CLIENT ) then return true end

	if ( trace.Entity:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then

		trace.Entity:SetCollisionGroup( COLLISION_GROUP_NONE )

	else

		trace.Entity:SetCollisionGroup( COLLISION_GROUP_WORLD )

	end

	return true

end

function TOOL:Reload( trace )

	if ( !IsValid( trace.Entity ) || trace.Entity:IsPlayer() ) then return false end
	if ( CLIENT ) then return true end

	return constraint.RemoveConstraints( trace.Entity, "NoCollide" )

end

function TOOL:Holster()

	self:ClearObjects()

end

-- This is unreliable
hook.Add( "EntityRemoved", "nocollide_fix", function( ent )
	if ( ent:GetClass() == "logic_collision_pair" ) then
		ent:Fire( "EnableCollisions" )
	end
end )

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "Header", { Description = "#tool.nocollide.desc" } )

end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/remover.lua:

TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.remover.name"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" },
	{ name = "reload" }
}

local function DoRemoveEntity( ent )

	if ( !IsValid( ent ) || ent:IsPlayer() ) then return false end

	-- Nothing for the client to do here
	if ( CLIENT ) then return true end

	-- Remove all constraints (this stops ropes from hanging around)
	constraint.RemoveAll( ent )

	-- Remove it properly in 1 second
	timer.Simple( 1, function() if ( IsValid( ent ) ) then ent:Remove() end end )

	-- Make it non solid
	ent:SetNotSolid( true )
	ent:SetMoveType( MOVETYPE_NONE )
	ent:SetNoDraw( true )

	-- Send Effect
	local ed = EffectData()
		ed:SetOrigin( ent:GetPos() )
		ed:SetEntity( ent )
	util.Effect( "entity_remove", ed, true, true )

	return true

end

--
-- Remove a single entity
--
function TOOL:LeftClick( trace )

	if ( DoRemoveEntity( trace.Entity ) ) then

		if ( !CLIENT ) then
			self:GetOwner():SendLua( "achievements.Remover()" )
		end

		return true

	end

	return false

end

--
-- Remove this entity and everything constrained
--
function TOOL:RightClick( trace )

	local entity = trace.Entity
	if ( !IsValid( entity ) || entity:IsPlayer() ) then return false end

	-- Client can bail out now.
	if ( CLIENT ) then return true end

	local ConstrainedEntities = constraint.GetAllConstrainedEntities( entity )
	local Count = 0

	-- Loop through all the entities in the system
	for _, ent in pairs( ConstrainedEntities ) do

		if ( DoRemoveEntity( ent ) ) then
			Count = Count + 1
		end

	end

	self:GetOwner():SendLua( string.format( "for i=1,%i do achievements.Remover() end", Count ) )

	return true

end

--
-- Reload removes all constraints on the targetted entity
--
function TOOL:Reload( trace )

	if ( !IsValid( trace.Entity ) || trace.Entity:IsPlayer() ) then return false end
	if ( CLIENT ) then return true end

	return constraint.RemoveAll( trace.Entity )

end

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "Header", { Description = "#tool.remover.desc" } )

end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/shareprops.lua:
TOOL.Category           = "WayZer's Role Play"
TOOL.Name               = "Share props"
TOOL.Command            = nil
TOOL.ConfigName         = ""
TOOL.AddToMenu = false

if SERVER then
    util.AddNetworkString('FPP_ShareSettings')
end

function TOOL:RightClick(trace)
    if not IsValid(trace.Entity) or CLIENT then return true end

    trace.Entity.SharePhysgun1 = nil
    trace.Entity.ShareGravgun1 = nil
    trace.Entity.SharePlayerUse1 = nil
    trace.Entity.ShareEntityDamage1 = nil
    trace.Entity.ShareToolgun1 = nil

    trace.Entity.AllowedPlayers = nil
    return true
end

function TOOL:LeftClick(trace)
    if not IsValid(trace.Entity) or CLIENT then return true end

    local ply = self:GetOwner()

    local Physgun = trace.Entity.SharePhysgun1 or false
    local GravGun = trace.Entity.ShareGravgun1 or false
    local PlayerUse = trace.Entity.SharePlayerUse1 or false
    local Damage = trace.Entity.ShareEntityDamage1 or false
    local Toolgun = trace.Entity.ShareToolgun1 or false

    -- This big usermessage will be too big if you select 63 players, since that will not happen I can't be arsed to solve it
    net.Start("FPP_ShareSettings")
        net.WriteEntity(trace.Entity)
        net.WriteBool(Physgun)
        net.WriteBool(GravGun)
        net.WriteBool(PlayerUse)
        net.WriteBool(Damage)
        net.WriteBool(Toolgun)
        if trace.Entity.AllowedPlayers then
            net.WriteUInt(#trace.Entity.AllowedPlayers, 32)
            for k,v in pairs(trace.Entity.AllowedPlayers) do
                net.WriteEntity(v)
            end
        end
    net.Send(ply)
    return true
end

if CLIENT then
    language.Add( "Tool.shareprops.name", "Share tool" )
    language.Add( "Tool.shareprops.desc", "Change sharing settings per prop" )
    language.Add( "Tool.shareprops.0", "Left click: shares a prop. Right click unshares a prop")
end

--addons/weapon_guitar/lua/weapons/guitar_stalker/shared.lua:

function SWEP:Initialize()

	if CLIENT then
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					vm:SetColor(Color(255,255,255,1))
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
	
	self:SetWeaponHoldType("slam")
	
	for i = 1, 13 do
		self["Guitar" .. i] = CreateSound(self, "Guitar" .. i)
	end
	
	self.CurGuitar = 0

end

function SWEP:Holster()
	self.Weapon:EmitSound(Sound("ambient/machines/squeak_2.wav"))
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
	end

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self:GetOwner())) then
			bone_ent = self:GetOwner()
		else
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

if CLIENT then
SWEP.ViewModelBoneMods = {}
SWEP.WElements = {
	["element_name"] = { type = "Model", model = "models/custom/guitar/m_d_45.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(-16.42, 34.831, -4.919), angle = Angle(-82.644, 60.391, -0.542), size = Vector(0.995, 0.995, 0.995), color = Color(255, 255, 254, 255), surpresslightning = false, material = "", skin = 1, bodygroup = {} }
}
end

SWEP.Base = "weapon_base"

-- Visual/sound settings
if ( SERVER ) then
	AddCSLuaFile( "shared.lua" )
end

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Гитара"
end

SWEP.Category = "Разрешено"
SWEP.PrintName		= "Гитара"
SWEP.Slot		= 2
SWEP.SlotPos		= 4
SWEP.DrawAmmo		= false
SWEP.ViewModel		= "models/weapons/tayley/v_guitar.mdl"
SWEP.WorldModel		= "models/custom/guitar/m_d_45.mdl"
SWEP.HoldType = "slam"

SWEP.ViewModelFOV = 70
SWEP.ViewModelFlip = false
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
-- Other settings
SWEP.Weight			= 5
SWEP.AutoSwitchTo	= false
SWEP.AutoSwitchFrom	= false
SWEP.Spawnable		= true
SWEP.AdminSpawnable	= true

-- SWEP info
SWEP.Author			= "Annoying Rooster, updated by Spirith"
SWEP.Contact		= ""
SWEP.Purpose		= "Metro 2033/Salker RP"
SWEP.Instructions	= "Left click - Metro 2033, right click - STALKER, reload - stop."
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Сыграть Metro 2033"},
	{key = MOUSE_RIGHT, desc = "Сыграть STALKER"},
	{key = KEY_R, desc = "Закончить играть"},
}

-- Primary fire settings
SWEP.Primary.Sound				= Sound("none")
SWEP.Primary.Damage				= -1
SWEP.Primary.NumShots			= -1
SWEP.Primary.Recoil				= 0
SWEP.Primary.Cone				= 16
SWEP.Primary.Delay				= 1
SWEP.Primary.ClipSize			= 999999999
SWEP.Primary.DefaultClip		= 999999999
SWEP.Primary.Tracer				= -1
SWEP.Primary.Force				= -1
SWEP.Primary.TakeAmmoPerBullet	= false
SWEP.Primary.Automatic			= false
SWEP.Primary.Ammo				= "none"
SWEP.IronSightsPos 		= Vector(0, 0, 0)
SWEP.IronSightsAng 		= Vector(0, 0, 0)

-- Secondary fire settings
SWEP.Secondary.Sound				= Sound("Guitar/guitar_6.mp3")
SWEP.Secondary.Damage				= 0
SWEP.Secondary.NumShots				= 1
SWEP.Secondary.Recoil				= 1
SWEP.Secondary.Cone					= 3
SWEP.Secondary.Delay				= 0.01
SWEP.Secondary.ClipSize				= 1
SWEP.Secondary.DefaultClip			= 1
SWEP.Secondary.Tracer				= 1
SWEP.Secondary.Force				= 0
SWEP.Secondary.TakeAmmoPerBullet	= false
SWEP.Secondary.Automatic			= false
SWEP.Secondary.Ammo					= "none"
SWEP.IronSightsPos 		= Vector(0, 0, 0)
SWEP.IronSightsAng 		= Vector(0, 0, 0)

SWEP.MusicDuration = {[1] = 29.1,
	[2] = 51.3,
	[3] = 46.2,
	[4] = 31.2,
	[5] = 71,
	[6] = 31.5,
	[7] = 32.6,
	[8] = 38.2,
	[9] = 32.1,
	[10] = 30.9,
	[11] = 40,
	[12] = 28.6,
	[13] = 49.3}

function SWEP:PrimaryAttack()
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
		local randomsounds = {
  	"weapons/Guitar/guitar_1.mp3",
  	"weapons/Guitar/guitar_2.mp3",
  	"weapons/Guitar/guitar_3.mp3",
   	"weapons/Guitar/guitar_4.mp3",
	"weapons/Guitar/guitar_5.mp3",
	"weapons/Guitar/guitar_6.mp3",
	"weapons/Guitar/guitar_7.mp3",
	"weapons/Guitar/guitar_8.mp3",
}
local random = math.random(1, #randomsounds)
self.Weapon:EmitSound(randomsounds[random])	
end

function SWEP:SecondaryAttack()
self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	local randomsounds = {
   	"weapons/Guitar/guitar_9.mp3",
   	"weapons/Guitar/guitar_10.mp3",
	"weapons/Guitar/guitar_11.mp3",
	"weapons/Guitar/guitar_12.mp3",
	"weapons/Guitar/guitar_13.mp3",
	"weapons/Guitar/guitar_14.mp3",
	"weapons/Guitar/guitar_15.mp3",
	"weapons/Guitar/guitar_16.mp3",
}
local random = math.random(1, #randomsounds)
self.Weapon:EmitSound(randomsounds[random])
end

function SWEP:Think()
end

function SWEP:Reload()
	self.Weapon:EmitSound(Sound("ambient/machines/squeak_2.wav"))
end

function SWEP:Deploy()
	return true
end

function SWEP:OnRestore()
end

function SWEP:Precache()
end

function SWEP:OwnerChanged()
end
--addons/module_css2/lua/weapons/ptp_cs_fiveseven/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "FN Five-seveN"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-5.949, -2.096, 2.88)
	SWEP.AimAng = Vector(-0.401, 0, 0)
		
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 10
SWEP.BulletDiameter = 5.7
SWEP.CaseLength = 28

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_pistol_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author	 = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_pist_fiveseven.mdl"	
SWEP.WorldModel = "models/weapons/w_pist_fiveseven.mdl"	

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 20
SWEP.Primary.DefaultClip = 60
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"

SWEP.FireDelay = 0.145
SWEP.FireSound = Sound("Weapon_FiveSeven.Single")
SWEP.Recoil = 0.5

SWEP.HipSpread = 0.02
SWEP.AimSpread = 0.009
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 40
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_glock/shared.lua:
AddCSLuaFile()

if CLIENT then
    
    SWEP.DrawCrosshair = false
	SWEP.PrintName = "Glock 17"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-5.772, -2.526, 2.79)
	SWEP.AimAng = Vector(0.419, -0.01, 0)
	
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	
	SWEP.ZoomAmount = 30
    SWEP.ViewModelMovementScale = 0.3
	SWEP.Shell = "smallshell"
	
	SWEP.IconLetter = "c"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.CanPenetrate = false
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_pistol_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "Pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_pist_glock18.mdl"
SWEP.WorldModel = "models/weapons/w_pist_glock18.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 15
SWEP.Primary.DefaultClip = 45
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "pistol"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_Glock.Single")
SWEP.Recoil = 1.2
SWEP.DryFire = true

SWEP.HipSpread = 0.038
SWEP.AimSpread = 0.013
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 36
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--addons/module_css2/lua/weapons/ptp_cs_pumpshotgun/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Benelli M3 Super 90"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-7.65, -8.207, 3.345)
	SWEP.AimAng = Vector(0.349, 0, 0)
		
	SWEP.SprintPos = Vector(3.957, -4.112, 1.013)
	SWEP.SprintAng = Vector(-8.613, 32.743, 0)
	
	SWEP.ZoomAmount = 30
	SWEP.ViewModelMovementScale = 0.7
	SWEP.Shell = "shotshell"
	SWEP.ShellOnEvent = true
	
	SWEP.IconLetter = "k"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.CanPenetrate = false
SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 5
SWEP.CaseLength = 10

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_box_buckshot_ttt"

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "shotgun"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"pump"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_shot_m3super90.mdl"
SWEP.WorldModel = "models/weapons/w_shot_m3super90.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 8
SWEP.Primary.DefaultClip = 24
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "buckshot"

SWEP.FireDelay = 0.8
SWEP.FireSound = Sound("Weapon_M3.Single")	
SWEP.Recoil = 2
SWEP.ShotgunReload = true
SWEP.ReloadStartWait = 0.6
SWEP.ReloadFinishWait = 1.1
SWEP.ReloadShellInsertWait = 0.6
SWEP.Chamberable = false

SWEP.HipSpread = 0.01
SWEP.AimSpread = 0.001
SWEP.ClumpSpread = 0.04
SWEP.VelocitySensitivity = 4
SWEP.MaxSpreadInc = 0.001
SWEP.SpreadPerShot = 0.001
SWEP.SpreadCooldown = 0.5
SWEP.Shots = 8
SWEP.Damage = 25
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_tmp/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Steyr TMP"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-2.6, -3.072, 1.639)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(0.736, -3.971, 1.802)
	SWEP.SprintAng = Vector(-13.205, 37.048, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.CanPenetrate = false
SWEP.FadeCrosshairOnAim = false

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 15
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_smg1_ttt"

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "smg"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_smg_tmp.mdl"
SWEP.WorldModel = "models/weapons/w_smg_tmp.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 32
SWEP.Primary.DefaultClip = 96
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = "Weapon_TMP.Single"
SWEP.Recoil = 0.8

SWEP.HipSpread = 0.015
SWEP.AimSpread = 0.01
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 35
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--gamemodes/darkrp/entities/weapons/stick_base/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

DEFINE_BASECLASS("weapon_cs_base2")

SWEP.Author = "DarkRP Developers"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IconLetter = ""

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix = "stunstick"

SWEP.AdminOnly = true

SWEP.StickColor = Color(255, 255, 255)

SWEP.ViewModel = Model("models/weapons/v_stunbaton.mdl")
SWEP.WorldModel = Model("models/weapons/w_stunbaton.mdl")

SWEP.Sound = Sound("weapons/stunstick/stunstick_swing1.wav")

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:Initialize()
    self:SetHoldType("normal")

    if SERVER then return end

    CreateMaterial("darkrp/" .. self:GetClass(), "VertexLitGeneric", {
        ["$basetexture"] = "models/debug/debugwhite",
        ["$surfaceprop"] = "metal",
        ["$envmap"] = "env_cubemap",
        ["$envmaptint"] = "[ .5 .5 .5 ]",
        ["$selfillum"] = 0,
        ["$model"] = 1
    }):SetVector("$color2", self.StickColor:ToVector())
end

function SWEP:SetupDataTables()
    BaseClass.SetupDataTables(self)
    -- Bool 0 = Ironsights
    -- Bool 1 = Reloading
    self:NetworkVar("Bool", 2, "SeqIdling")
    -- Float 0 = LastPrimaryAttack
    -- Float 1 = ReloadEndTime
    -- Float 2 = BurstTime
    -- Float 3 = LastNonBurst
    self:NetworkVar("Float", 4, "SeqIdleTime")
    self:NetworkVar("Float", 5, "HoldTypeChangeTime")
end

function SWEP:Deploy()
    BaseClass.Deploy(self)
    if SERVER then
        self:SetMaterial("!darkrp/" .. self:GetClass())
    end

    local vm = self:GetOwner():GetViewModel()
    if not IsValid(vm) then return true end
    self:PreDrawViewModel()
    vm:SendViewModelMatchingSequence(vm:LookupSequence("idle01"))
    return true
end

function SWEP:PreDrawViewModel(vm)
    if not IsValid(vm) then return end
    for i = 9, 15 do
        vm:SetSubMaterial(i, "!darkrp/" .. self:GetClass())
    end
end

function SWEP:ViewModelDrawn(vm)
    if not IsValid(vm) then return end
    vm:SetSubMaterial() -- clear sub-materials
end

function SWEP:ResetStick(force)
    if game.SinglePlayer() then force = true end
    if not IsValid(self:GetOwner()) or (not force and (not IsValid(self:GetOwner():GetActiveWeapon()) or self:GetOwner():GetActiveWeapon():GetClass() ~= self:GetClass())) then return end
    if SERVER then
        self:SetMaterial() -- clear material
    end
    self:SetSeqIdling(false)
    self:SetSeqIdleTime(0)
    self:SetHoldTypeChangeTime(0)
end

function SWEP:Holster()
    BaseClass.Holster(self)
    self:ResetStick(false)
    return true
end

function SWEP:OnRemove()
    BaseClass.OnRemove(self)
    self:ResetStick(true)
end

function SWEP:Think()
    if self:GetSeqIdling() then
        self:SetSeqIdling(false)

        if not IsValid(self:GetOwner()) then return end
        self:GetOwner():SetAnimation(PLAYER_ATTACK1)
        self:EmitSound(self.Sound)

        local vm = self:GetOwner():GetViewModel()
        if not IsValid(vm) then return end
        vm:SendViewModelMatchingSequence(vm:LookupSequence("attackch"))
        vm:SetPlaybackRate(1 + 1 / 3)
        local duration = vm:SequenceDuration() / vm:GetPlaybackRate()
        local time = CurTime() + duration
        self:SetSeqIdleTime(time)
        self:SetNextPrimaryFire(time)
    end
    if self:GetSeqIdleTime() ~= 0 and CurTime() >= self:GetSeqIdleTime() then
        self:SetSeqIdleTime(0)

        if not IsValid(self:GetOwner()) then return end
        local vm = self:GetOwner():GetViewModel()
        if not IsValid(vm) then return end
        vm:SendViewModelMatchingSequence(vm:LookupSequence("idle01"))
    end
    if self:GetHoldTypeChangeTime() ~= 0 and CurTime() >= self:GetHoldTypeChangeTime() then
        self:SetHoldTypeChangeTime(0)
        self:SetHoldType("normal")
    end
end

function SWEP:PrimaryAttack()
    self:SetHoldType("melee")
    self:SetHoldTypeChangeTime(CurTime() + 0.3)

    self:SetNextPrimaryFire(CurTime() + 0.51) -- Actual delay is set later.

    local vm = self:GetOwner():GetViewModel()
    if IsValid(vm) then
        vm:SendViewModelMatchingSequence(vm:LookupSequence("idle01"))
        self:SetSeqIdling(true)
    end
end

function SWEP:SecondaryAttack()
    -- Do nothing
end

function SWEP:Reload()
    -- Do nothing
end

--addons/module_stungun/lua/weapons/stungun/shared.lua:

--[[
Stungun SWEP Created by Donkie (http://steamcommunity.com/id/Donkie/)
For personal/server usage only, do not resell or distribute!
]]

STUNGUN = {} -- General stungun stuff table

STUNGUN.IsDarkRP = ((type(DarkRP) == "table") or (RPExtraTeams != nil))
STUNGUN.IsDarkRP25 = (STUNGUN.IsDarkRP and (type(DarkRP) == "table") and DarkRP.getPhrase)
STUNGUN.IsTTT = ((ROLE_TRAITOR != nil) and (ROLE_INNOCENT != nil) and (ROLE_DETECTIVE != nil) and (GetRoundState != nil)) -- For a gamemode to be TTT, these should probably exist.

include("config.lua")

if STUNGUN.IsTTT then
	SWEP.Base = "weapon_tttbase"
	SWEP.AmmoEnt = ""
	SWEP.IsSilent = false
	SWEP.NoSights = true
end

SWEP.Author = "Donkie"
SWEP.Instructions = string.format("Left click to stun a person.%s", STUNGUN.CanUntaze and "\nRight click to unstun a person." or "")
SWEP.Contact = ""
SWEP.Purpose = ""

SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/c_pistol.mdl")
SWEP.WorldModel = Model("models/weapons/w_pistol.mdl")

SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = true

-- SWEP.InfiniteAmmo = (SWEP.Ammo <= -1) -- Not used anymore
if SWEP.InfiniteAmmo then
	SWEP.Primary.ClipSize = -1
	SWEP.Primary.DefaultClip = 0
	SWEP.Primary.Ammo = "none"
else
	SWEP.Primary.ClipSize = 1
	SWEP.Primary.DefaultClip = 1

	if STUNGUN.IsTTT then
		SWEP.Primary.ClipMax = SWEP.Ammo
	end

	SWEP.Primary.Ammo = "ammo_stungun"
end
SWEP.Primary.Automatic = false

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

-- print(SERVER and "SERVER INIT" or "CLIENT INIT")

SWEP.Uncharging = false

game.AddAmmoType({
	name = "ammo_stungun",
	dmgtype = DMG_GENERIC,
	tracer = TRACER_NONE,
	plydmg = 0,
	npcdmg = 0,
	force = 0,
	minsplash = 0,
	maxsplash = 0
})

if STUNGUN.AddAmmoItem >= 0 then
    if GAMEMODE.AddAmmoType then
		GAMEMODE:AddAmmoType("ammo_stungun", "Stungun Charges", "models/Items/battery.mdl", math.ceil(STUNGUN.AddAmmoItem), 1)
	end
end

function SWEP:DoEffect(tr)
	-- Animations
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self:GetOwner():SetAnimation(PLAYER_ATTACK1)

	-- Electric bolt, taken from toolgun
	local effectdata = EffectData()
		effectdata:SetOrigin( tr.HitPos )
		effectdata:SetStart( self:GetOwner():GetShootPos() )
		effectdata:SetAttachment( 1 )
		effectdata:SetEntity( self )
	util.Effect( "ToolTracer", effectdata )
end

function SWEP:PrimaryAttack()
	if self.Charge < 100 then return end

	if not self.InfiniteAmmo then
		if self:Clip1() <= 0 then return end
		self:TakePrimaryAmmo(1)
	end

	self.Uncharging = true

	-- Shoot trace
	self:GetOwner():LagCompensation(true)
	local tr = util.TraceLine(util.GetPlayerTrace( self:GetOwner() ))
	self:GetOwner():LagCompensation(false)

	self:DoEffect(tr)

	if SERVER then
		self:GetOwner():EmitSound("npc/turret_floor/shoot1.wav")
	end

	local ent = tr.Entity

	if CLIENT then return end

	-- Don't proceed if we don't hit any player
	if not IsValid(ent) or not ent:IsPlayer() then return end
	if ent == self:GetOwner() then return end
	if IsValid(ent.tazeragdoll) then return end
	if self:GetOwner():GetShootPos():Distance(tr.HitPos) > self.Range then return end
    if IsValid(ent:GetActiveWeapon()) and ent:GetActiveWeapon():GetClass() == 'weapon_handcuffed' then return end

	if hook.Run('PlayerPreTazed', self:GetOwner(), ent) == false then return end
    
	if not STUNGUN.IsPlayerImmune(ent) and (STUNGUN.AllowFriendlyFire or not STUNGUN.SameTeam(self:GetOwner(), ent)) then
		-- Damage
		if (STUNGUN.StunDamage and STUNGUN.StunDamage > 0) and not ent.tazeimmune and ent:Health() > 2 then
			local dmginfo = DamageInfo()
			dmginfo:SetDamage(STUNGUN.StunDamage)
			dmginfo:SetAttacker(self:GetOwner())
			dmginfo:SetInflictor(self)
			dmginfo:SetDamageType(DMG_SHOCK)
			dmginfo:SetDamagePosition(tr.HitPos)
			dmginfo:SetDamageForce(self:GetOwner():GetAimVector() * 30)
			ent:TakeDamageInfo(dmginfo)
		end

		hook.Run("PlayerTazed", ent, self:GetOwner())

		--The player might have died while getting tazed
		if ent:Alive() then
			-- Electrolute the player
			STUNGUN.Electrolute( ent, (ent:GetPos() - self:GetOwner():GetPos()):GetNormal() )
		end

		if STUNGUN.pLogs then
			plogs.PlayerLog(self:GetOwner(), "Stungun", string.format("%s ударил %s тайзером", self:GetOwner():NameID(), ent:NameID()), {
				["Жертва: Ник"] = ent:Name(),
				["Жертва: SteamID"] = ent:SteamID(),
				["Напавший: Ник"] = self:GetOwner():Name(),
				["Напавший: SteamID"] = self:GetOwner():SteamID(),
			})
		end
	end
end

local chargeinc
function SWEP:Think()
	-- In charge of charging the swep
	-- Since we got the same in-sensitive code both client and serverside we don't need to network anything.
	if SERVER or (CLIENT and IsFirstTimePredicted()) then
		if not chargeinc then
			-- Calculate how much we should increase charge every tick based on how long we want it to take.
			chargeinc = ((100 / self.RechargeTime) * engine.TickInterval())
		end

		local inc = self.Uncharging and (-5) or chargeinc

		if self:Clip1() <= 0 and not self.InfiniteAmmo then inc = math.min(inc, 0) end -- If we're out of clip, we shouldn't be allowed to recharge.

		self.Charge = math.min(self.Charge + inc, 100)
		if self.Charge < 0 then self:Reload() self.Uncharging = false self.Charge = 0 end
	end
end

function SWEP:FailAttack()
	self:SetNextSecondaryFire(CurTime() + 0.5)
	self:GetOwner():EmitSound( "Weapon_Pistol.Empty" )
end

function SWEP:SecondaryAttack()
	if STUNGUN.CanUntaze then
		if self:GetNextSecondaryFire() >= CurTime() then self:FailAttack() return end

		-- Shoot trace
		self:GetOwner():LagCompensation(true)
		local tr = util.TraceLine(util.GetPlayerTrace( self:GetOwner() ))
		self:GetOwner():LagCompensation(false)

		local ent = tr.Entity

		if CLIENT then return end

		-- Don't proceed if we don't hit any raggy
		if not IsValid(ent) or ent:GetClass() != "prop_ragdoll" or not IsValid(ent.tazeplayer) then self:FailAttack() return end
		if self:GetOwner():GetShootPos():Distance(tr.HitPos) > self.Range then self:FailAttack() return end

		self:DoEffect(tr)

		self:GetOwner():EmitSound("npc/turret_floor/shoot1.wav")

		local ply = ent.tazeplayer
		timer.Simple(.4, function() ply:EmitSound("items/smallmedkit1.wav") end)

		hook.Run("PlayerPreUnTazed", ply, self:GetOwner())

		STUNGUN.UnMute( ply )
		STUNGUN.UnElectrolute( ply )

		local id = ply:UserID()
		timer.Remove("Unelectrolute" .. id)
		timer.Remove("tazeUngag" .. id)

		if STUNGUN.pLogs then
			plogs.PlayerLog(ply, "Stungun", string.format("%s was un-tazed by %s.", ply:NameID(), self:GetOwner():NameID()), {
				["Name"]             = ply:Name(),
				["SteamID"]          = ply:SteamID(),
				["Attacker Name"]    = self:GetOwner():Name(),
				["Attacker SteamID"] = self:GetOwner():SteamID(),
			})
		end

		self:SetNextSecondaryFire(CurTime() + 2)
	end
	return false
end

function SWEP:Reload()
	self:DefaultReload( ACT_VM_RELOAD )
	return true
end

local shoulddisable = {} -- Disables muzzleflashes and ejections
shoulddisable[21] = true
shoulddisable[5003] = true
shoulddisable[6001] = true
function SWEP:FireAnimationEvent( pos, ang, event, options )
	if shoulddisable[event] then return true end
end

hook.Add("PhysgunPickup", "Tazer", function(_,ent)
	if not STUNGUN.AllowPhysgun and IsValid(ent:GetNWEntity("plyowner")) then return false end
end)
hook.Add("CanTool", "Tazer", function(_,tr,_)
	if not STUNGUN.AllowToolgun and IsValid(tr.Entity) and IsValid(tr.Entity:GetNWEntity("plyowner")) then return false end
end)
hook.Add("PlayerSwitchWeapon", "Tazer", function(ply, old, wep)
	if not IsValid(ply.tazeragdoll) and not ply:GetNWBool('tazefrozen') then return end

	local class = IsValid(wep) and wep:GetClass()
	if class and class ~= 'weapon_handcuffed' then return true end
end)

hook.Add("StartCommand", "Tazer", function(ply, cmd)
	if ply:GetNWBool("tazefrozen", false) == false then return end

	cmd:ClearMovement()
	cmd:RemoveKey(IN_ATTACK)
	cmd:RemoveKey(IN_ATTACK2)
	cmd:RemoveKey(IN_RELOAD)
	cmd:RemoveKey(IN_USE)
	cmd:RemoveKey(IN_DUCK)
	cmd:RemoveKey(IN_JUMP)
end)

--[[
pLogs-2
]]
local function InitpLogs()
	if not plogs or not plogs.Version then return end
	local versionstr = plogs.Version
	local versiontbl = string.Explode(".", versionstr)
	if #versiontbl != 3 then return end

	local major = tonumber(versiontbl[1])
	local minor = tonumber(versiontbl[2])

	if major < 2 or (major == 2 and minor < 7) then
		MsgN("[STUNGUN] pLogs detected but its version is too old!")
		return
	end

	plogs.Register("Stungun", true, Color(255,163,0))
	STUNGUN.pLogs = true

end

if plogs then
	InitpLogs()
end

--addons/module_css2/lua/weapons/swb_base/sh_bullets.lua:
local Dir, Dir2, dot, sp, ent, trace, seed, hm
local trace_normal = bit.bor(CONTENTS_SOLID, CONTENTS_OPAQUE, CONTENTS_MOVEABLE, CONTENTS_DEBRIS, CONTENTS_MONSTER, CONTENTS_HITBOX, 402653442, CONTENTS_WATER)
local trace_walls = bit.bor(CONTENTS_TESTFOGVOLUME, CONTENTS_EMPTY, CONTENTS_MONSTER, CONTENTS_HITBOX)
local NoPenetration = {[MAT_SLOSH] = true}
local NoRicochet = {[MAT_FLESH] = true, [MAT_ANTLION] = true, [MAT_BLOODYFLESH] = true, [MAT_DIRT] = true, [MAT_SAND] = true, [MAT_GLASS] = true, [MAT_ALIENFLESH] = true}
local PenMod = {[MAT_SAND] = 0.5, [MAT_DIRT] = 0.8, [MAT_METAL] = 1.1, [MAT_TILE] = 0.9, [MAT_WOOD] = 1.2}
local bul, tr = {}, {}
local SP = game.SinglePlayer()

local reg = debug.getregistry()
local GetShootPos = reg.Player.GetShootPos
local GetCurrentCommand = reg.Player.GetCurrentCommand
local CommandNumber = reg.CUserCmd.CommandNumber

function SWEP:FireBullet(damage, cone, bullets)
	sp = GetShootPos(self:GetOwner())
	math.randomseed(CommandNumber(GetCurrentCommand(self:GetOwner())))
	
	if self:GetOwner():Crouching() then
		cone = cone * 0.85
	end
	
	Dir = (self:GetOwner():EyeAngles() + self:GetOwner():GetPunchAngle() + Angle(math.Rand(-cone, cone), math.Rand(-cone, cone), 0) * 25):Forward()

	for i = 1, bullets do
		Dir2 = Dir
		
		if self.ClumpSpread and self.ClumpSpread > 0 then
			Dir2 = Dir + Vector(math.Rand(-1, 1), math.Rand(-1, 1), math.Rand(-1, 1)) * self.ClumpSpread
		end
		
		bul.Num = 1
		bul.Src = sp
		bul.Dir = Dir2
		bul.Spread 	= Vector(0, 0, 0)
		bul.Tracer	= 1
		bul.Force	= damage * 0.3
		bul.Damage = math.Round(damage)
		
		self:GetOwner():FireBullets(bul)
		
		tr.start = sp
		tr.endpos = tr.start + Dir2 * self.PenetrativeRange
		tr.filter = self:GetOwner()
		tr.mask = trace_normal

		if self.CanPenetrate then
			trace = util.TraceLine(tr)
				
			if trace.Hit and not trace.HitSky then
				if not NoPenetration[trace.MatType] then
					dot = -Dir2:Dot(trace.HitNormal)
					ent = trace.Entity
				
					if dot > 0.26 and not ent:IsNPC() and not ent:IsPlayer() then
						tr.start = trace.HitPos
						tr.endpos = tr.start + Dir2 * self.PenStr * (PenMod[trace.MatType] and PenMod[trace.MatType] or 1) * self.PenMod
						tr.filter = self:GetOwner()
						tr.mask = trace_walls
						
						trace = util.TraceLine(tr)
						
						tr.start = trace.HitPos
						tr.endpos = tr.start + Dir2 * 0.1
						tr.filter = self:GetOwner()
						tr.mask = trace_normal
						
						trace = util.TraceLine(tr) -- run ANOTHER trace to check whether we've penetrated a surface or not
						
						if not trace.Hit then
							bul.Num = 1
							bul.Src = trace.HitPos
							bul.Dir = Dir2
							bul.Spread 	= Vec0
							bul.Tracer	= 1
							bul.Force	= damage * 0.15
							bul.Damage = bul.Damage * 0.5
							
							self:GetOwner():FireBullets(bul)
							
							bul.Num = 1
							bul.Src = trace.HitPos
							bul.Dir = -Dir2
							bul.Spread 	= Vec0
							bul.Tracer	= 1
							bul.Force	= damage * 0.15
							bul.Damage = bul.Damage * 0.5
							
							self:GetOwner():FireBullets(bul)
						end
					end
				end
			end
		end
		
	end
		
	tr.mask = trace_normal
end
--addons/module_css2/lua/weapons/swb_base/cl_playerbindpress.lua:
local bind_zoomout = CreateClientConVar('swb_bind_zoomout', MOUSE_WHEEL_DOWN)
local bind_zoomin = CreateClientConVar('swb_bind_zoomin', MOUSE_WHEEL_UP)

local wep, CT

function SWEP.PlayerBindPress(ply, b, p, code)
	if p then
		wep = ply:GetActiveWeapon()
		
		if IsValid(wep) and wep.SWBWeapon then
			if wep.dt and wep.dt.State == SWB_AIMING then
				if wep.AdjustableZoom then
					CT = CurTime()
					
					if code == bind_zoomout:GetInt() then
						CT = CurTime()
						
						if CT > wep.ZoomWait then
							if wep.ZoomAmount > wep.MinZoom then
								wep.ZoomAmount = math.Clamp(wep.ZoomAmount - 15, wep.MinZoom, wep.MaxZoom)
								surface.PlaySound("weapons/zoom.wav")
								wep.ZoomWait = CT + 0.15

							end
						end
						
						return true
					elseif code == bind_zoomin:GetInt() then
						CT = CurTime()
						
						if CT > wep.ZoomWait then
							if wep.ZoomAmount < wep.MaxZoom then
								wep.ZoomAmount = math.Clamp(wep.ZoomAmount + 15, wep.MinZoom, wep.MaxZoom)
								surface.PlaySound("weapons/zoom.wav")
								wep.ZoomWait = CT + 0.15
							end
						end
						
						return true
					end
				end
			end
		end
	end
end

hook.Add("PlayerBindPress", "SWEP.PlayerBindPress (SWB)", SWEP.PlayerBindPress)
--addons/weapon_cuffs/lua/weapons/weapon_cuff_rope.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- weapon_cuff_standard.lua SHARED --
--                                 --
-- Rope handcuffs.                 --
-------------------------------------

AddCSLuaFile()

SWEP.Base = "weapon_cuff_base"

SWEP.Category = "Запрещено"
SWEP.Author = "my_hat_stinks"
SWEP.Instructions = "Слабый поводок"

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.AdminSpawnable = true

SWEP.PrintName = "Верёвка"

//
// Handcuff Vars
SWEP.CuffTime = 0.8 // Seconds to handcuff
SWEP.CuffSound = Sound( "buttons/lever7.wav" )

SWEP.CuffMaterial = "models/props_foliage/tree_deciduous_01a_trunk"
SWEP.CuffRope = "cable/rope"
SWEP.CuffStrength = 0.85
SWEP.CuffRegen = 0.8
SWEP.RopeLength = 100
SWEP.CuffReusable = true

SWEP.CuffBlindfold = true
SWEP.CuffGag = true

SWEP.CuffStrengthVariance = 0.1 // Randomise strangth
SWEP.CuffRegenVariance = 0.2 // Randomise regen

--addons/weapon_melee/lua/weapons/weapon_hl2bottle/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Бутылка"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack: Throw (One  hit and it breaks)"
SWEP.Controls = {
	{key = MOUSE_RIGHT, desc = "Бросить"},
}
SWEP.Category				= "Запрещено"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_bottle.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_bottle.mdl" )
SWEP.ViewModelFOV			= 62
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 64
SWEP.HitRadius			= 12
SWEP.HitPushback		= 100
SWEP.HitRate			= 0.50
SWEP.MinDamage			= 10
SWEP.MaxDamage			= 20

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "GlassBottle.Break" )
local HitSoundBody = Sound( "GlassBottle.Break" )

function SWEP:Initialize()

	self:SetHoldType( "melee" )
end

function SWEP:PrimaryAttack()

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	local vm = self:GetOwner():GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay"..self:EntIndex(), 0.2, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay"..self:EntIndex() )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextSecondaryFire( CurTime() + 1 )

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	self:EmitSound( SwingSound )

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("throwdelay"..self:EntIndex(), 0.2, 1, function() self:Throwbottle() end)

	timer.Start( "throwdelay"..self:EntIndex() )
	
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()
	local ply = self:GetOwner()

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*self.HitDistance,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		local damageinfo = DamageInfo()
		
		damageinfo:SetAttacker(ply)
		damageinfo:SetInflictor(self)
		damageinfo:SetDamage(math.random(self.MinDamage, self.MaxDamage))
		damageinfo:SetDamageType(bit.bor(DMG_BULLET , DMG_NEVERGIB))
		damageinfo:SetDamageForce(forward:GetNormalized()*300)
		damageinfo:SetDamagePosition(trdata.endpos)

		hitent:DispatchTraceAttack(damageinfo, tr, forward)

		self:EmitSound(SwingSound)

		if hithuman then
			self:EmitSound(HitSoundBody)
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * self.HitPushback)
		else
			self:EmitSound(HitSoundWorld)
			if SERVER then
				ply:Give('weapon_hl2brokenbottle')
				ply:SelectWeapon('weapon_hl2brokenbottle')
				ply:StripWeapon('weapon_hl2bottle')
			end
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:Throwbottle()
	if CLIENT then return end

	local ent = ents.Create( "prop_physics" )

	if ( !IsValid( ent ) ) then return end
	
	ent:SetModel( "models/props_junk/garbage_glassbottle003a.mdl" )
	ent:SetPos( self:GetOwner():EyePos() + ( self:GetOwner():GetAimVector() * 20 ) )
	ent:SetAngles( self:GetOwner():EyeAngles() - Angle( 0, 50, 190 ) )
	ent:Spawn()

	local phys = ent:GetPhysicsObject();
 
	//local shot_length = tr.HitPos:Length();
	phys:ApplyForceCenter (self:GetOwner():GetAimVector()*2000 )
	phys:AddAngleVelocity(Vector( -250, -250, 0 ))

	self:GetOwner():StripWeapon("weapon_hl2bottle")

	timer.Simple(10, function()
		if not IsValid(ent) then return end
		ent:Remove()
	end)

end

function SWEP:Deploy()

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay"..self:EntIndex())
	timer.Remove("throwdelay"..self:EntIndex())
	return true
end
--addons/weapon_paint/lua/weapons/weapon_spraypaint/shared.lua:
AddCSLuaFile()
cleanup.Register("graffitis")

if CLIENT then
    language.Add('Cleanup_graffitis', 'Graffiti')
    language.Add("Cleaned_graffitis", "Cleaned up all Graffiti")
end

SWEP.PrintName = "Балончик с краской"
SWEP.Author = "\\sqdAva"
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Рисовать"},
	{key = MOUSE_RIGHT, desc = "Выбор цвета"},
	{key = KEY_R, desc = "Создать полотно"},
}
SWEP.Slot = 1
SWEP.SlotPos = 5
SWEP.Spawnable = true
SWEP.ViewModel = "models/weapons/v_smg1.mdl"
SWEP.Category = "Запрещено"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.HoldType = "pistol"
SWEP.UseHands = false
SWEP.ShowWorldModel = false
SWEP.ViewModelFlip = true
SWEP.ViewModelFOV = 60
SWEP.DrawAmmo = true
SWEP.Weight = 10
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

function SWEP:Initialize()
    self:SetWeaponHoldType(self.HoldType)
    self:SetVar('restricted_to_drop', true)

    if CLIENT then
        self:InitCL()
    end
end

function SWEP:Holster()
    if CLIENT then
        local a = self:GetOwner()

        if IsValid(a) then
            local b = a:GetViewModel()

            if IsValid(b) then
                self:ResetBonePositions(b)
            end

            a.HoveredGraffiti = nil
            a.HoveredGraffitiTrace = nil
            self.Painting = nil
            self.Placing = nil
            LocalPlayer().Placing = nil
            self:RemovePlacementHook()
        end
    end

    if self.Sound then
        self.Sound:Stop()
        self.Sound = nil
    end

    return true
end

function SWEP:OnDrop()
end

function SWEP:OnRemove()
    self:Holster()

    if CLIENT then
        self:RemoveModels(self.VElements)
        self:RemoveModels(self.WElements)
    end
end

local c = Color(50, 255, 50, 100)
local d = Color(255, 50, 50, 100)
local e = Color(255, 255, 255, 15)

local function f(g, h, i, j)
    local k = util.QuickTrace(g - i, -h * 24)

    if not k.Hit or k.HitPos ~= j - i and k.HitPos:DistToSqr(j - i) > .01 or k.Entity ~= Entity(0) then
        if CLIENT and IsValid(k.Entity) and k.Entity:GetClass() == "ent_graffiti" then
            render.DrawQuadEasy(k.Entity:GetPos() + k.HitNormal * 0.1, k.HitNormal, 96, 96, e, 0)
        end

        return false
    else
        return true
    end
end

local function l(m)
    local k = m:GetEyeTrace()
    local n = k.HitPos
    local o = k.HitNormal:Angle()
    local p = 6
    local q = 96 / (p * 2)
    local r = true
    local s = k.HitPos + k.HitNormal * 12

    if n:DistToSqr(m:GetShootPos()) > 40000 then
        r = false
    end

    if r then
        for t = 1, p do
            local u = o:Up() * t * q
            local v = u * -1
            local w = o:Right() * t * q
            local x = w * -1

            if not f(s, k.HitNormal, x, k.HitPos) then
                r = false
                break
            end

            if not f(s, k.HitNormal, w, k.HitPos) then
                r = false
                break
            end

            if not f(s, k.HitNormal, u, k.HitPos) then
                r = false
                break
            end

            if not f(s, k.HitNormal, v, k.HitPos) then
                r = false
                break
            end

            if not f(s, k.HitNormal, u + w, k.HitPos) then
                r = false
                break
            end

            if not f(s, k.HitNormal, u + x, k.HitPos) then
                r = false
                break
            end

            if not f(s, k.HitNormal, v + w, k.HitPos) then
                r = false
                break
            end

            if not f(s, k.HitNormal, v + x, k.HitPos) then
                r = false
                break
            end
        end
    end

    if CLIENT then
        render.DrawQuadEasy(k.HitPos + k.HitNormal * 0.02, k.HitNormal, 96, 96, r and c or d, 0)
    end

    if r then return k.HitPos + k.HitNormal, k.HitNormal end

    return nil
end

function SWEP:GetValidPlacement()
    return l(self:GetOwner())
end
--addons/weapon_vape/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onionstest"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Разрешено"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.ObjectPos = Vector(-8.5, -2.401, 27.377)
SWEP.ObjectAng = Angle(-160, 10.519, 0)

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.Unbreakable = false

SWEP.VapeID = 1

function SWEP:SetupDataTables()
	if self.Unbreakable then return end

	self:NetworkVar( "Int", 0, "Energy" )

	if SERVER then
		self:SetEnergy(100)
	end

end

local icon = Material( "icon72/dash.png" )

function SWEP:DrawHUD()
	if self.Unbreakable then return end

    if self:GetEnergy() or 0 > 0 then
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*self:GetEnergy(), 20, Color( 233, 133, 110, 255 ) )
		draw.DrawText("Состояние", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
		
	    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	    surface.SetMaterial( icon ) -- Use our cached material
	    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
    end
end

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:Initialize()

	if !self.HandInitialize then
		self.HandInitialize = true
		self.VElements = {
			["object"] = { type = "Model", model = self.ViewModel, bone = "ValveBiped.Bip01_Spine4", rel = "", pos = self.ObjectPos, angle = self.ObjectAng, size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
		}
		self.ViewModel = "models/weapons/c_slam.mdl"
		self.UseHands = true
		self.ViewModelFlip = true
		self.ShowViewModel = true
		self.ShowWorldModel = true
		self.ViewModelBoneMods = {
			["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-23.334, -12.223, -32.223) },
			["ValveBiped.Bip01_L_Finger12"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -21.112, 0) },
			["ValveBiped.Bip01_L_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -65.556, 0) },
			["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 72.222, -41.112) },
			["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(10, 1.11, -1.111) },
			["Detonator"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-27.778, 1.11, -7.778) },
			["Slam_panel"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -47.778, 0) },
			["ValveBiped.Bip01_L_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -43.334, 0) },
			["Slam_base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_R_Hand"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
		}
		
	end

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
	if self.Initialize2 then self:Initialize2() end
end

function SWEP:PrimaryAttack()

	if SERVER then
		
		if not self.Unbreakable then

			if self:GetEnergy() < 1 then 
				if self.BreakCallback then self:BreakCallback() end
				self:Remove()
				return 
			end

			self:SetEnergy(self:GetEnergy() - 1)
		end

		VapeUpdate(self:GetOwner(), self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SetBreakCallback(f)
	self.BreakCallback = f
end

function SWEP:Holster()
	if SERVER and IsValid(self:GetOwner()) then
		ReleaseVape(self:GetOwner())
	end
	
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/weapon_vape/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onionstest"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Разрешено"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.ObjectPos = Vector(-8.5, -2.401, 27.377)
SWEP.ObjectAng = Angle(-160, 10.519, 0)

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.Unbreakable = false

SWEP.VapeID = 1

function SWEP:SetupDataTables()
	if self.Unbreakable then return end

	self:NetworkVar( "Int", 0, "Energy" )

	if SERVER then
		self:SetEnergy(100)
	end

end

local icon = Material( "icon72/dash.png" )

function SWEP:DrawHUD()
	if self.Unbreakable then return end

    if self:GetEnergy() or 0 > 0 then
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*self:GetEnergy(), 20, Color( 233, 133, 110, 255 ) )
		draw.DrawText("Состояние", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
		
	    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	    surface.SetMaterial( icon ) -- Use our cached material
	    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
    end
end

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:Initialize()

	if !self.HandInitialize then
		self.HandInitialize = true
		self.VElements = {
			["object"] = { type = "Model", model = self.ViewModel, bone = "ValveBiped.Bip01_Spine4", rel = "", pos = self.ObjectPos, angle = self.ObjectAng, size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
		}
		self.ViewModel = "models/weapons/c_slam.mdl"
		self.UseHands = true
		self.ViewModelFlip = true
		self.ShowViewModel = true
		self.ShowWorldModel = true
		self.ViewModelBoneMods = {
			["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-23.334, -12.223, -32.223) },
			["ValveBiped.Bip01_L_Finger12"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -21.112, 0) },
			["ValveBiped.Bip01_L_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -65.556, 0) },
			["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 72.222, -41.112) },
			["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(10, 1.11, -1.111) },
			["Detonator"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-27.778, 1.11, -7.778) },
			["Slam_panel"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -47.778, 0) },
			["ValveBiped.Bip01_L_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -43.334, 0) },
			["Slam_base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_R_Hand"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
		}
		
	end

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
	if self.Initialize2 then self:Initialize2() end
end

function SWEP:PrimaryAttack()

	if SERVER then
		
		if not self.Unbreakable then

			if self:GetEnergy() < 1 then 
				if self.BreakCallback then self:BreakCallback() end
				self:Remove()
				return 
			end

			self:SetEnergy(self:GetEnergy() - 1)
		end

		VapeUpdate(self:GetOwner(), self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SetBreakCallback(f)
	self.BreakCallback = f
end

function SWEP:Holster()
	if SERVER and IsValid(self:GetOwner()) then
		ReleaseVape(self:GetOwner())
	end
	
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/weapon_vape/lua/weapons/weapon_vape_hp.lua:
-- weapon_vape_medicinal.lua
-- Defines a vape that heals the player

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "HP Vape"
SWEP.Category  = "Премиум"
SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nThis healthy, organic juice has amazing healing abilities."

SWEP.VapeID = 12
local r = 244/200
local g = 100/200
local b = 100/200

SWEP.VapeAccentColor = Vector(r,g,b)
SWEP.VapeTankColor = Vector(r,g,b)

SWEP.Unbreakable = true

-- note: healing functionality is in weapon_vape/init.lua
--addons/weapon_vape/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3.25)
	local vmang1=self.VapeVMAng1 or Vector(170,-180,20)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(120,-180,150)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	/*
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)*/
	local difvec = Vector(-10,-3.5,-12)--vmpos1 - vmpos2
	local orig = Vector(0,0,0)
	local topos = orig+difvec
	
	local difang = Vector(-30,0,0)--vmang1 - vmang2
	local origang = Vector(0,0,0)
	local toang = origang+difang
	
	
	
	local newpos = LerpVector(lerp,topos,orig)
	local newang = LerpVector(lerp,toang,origang)
	
	newang = Angle(newang.x, newang.y, newang.z)
	
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end


--Swep Construction Kit code--

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end



--addons/weapon_vape/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3.25)
	local vmang1=self.VapeVMAng1 or Vector(170,-180,20)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(120,-180,150)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	/*
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)*/
	local difvec = Vector(-10,-3.5,-12)--vmpos1 - vmpos2
	local orig = Vector(0,0,0)
	local topos = orig+difvec
	
	local difang = Vector(-30,0,0)--vmang1 - vmang2
	local origang = Vector(0,0,0)
	local toang = origang+difang
	
	
	
	local newpos = LerpVector(lerp,topos,orig)
	local newang = LerpVector(lerp,toang,origang)
	
	newang = Angle(newang.x, newang.y, newang.z)
	
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end


--Swep Construction Kit code--

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end



--gamemodes/darkrp/entities/weapons/weaponchecker/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.PrintName = "Обыскать Игрока"
    SWEP.Slot = 1
    SWEP.SlotPos = 9
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = false
end

SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click to weapon check\nRight click to confiscate weapons\nReload to give back the weapons"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPWeaponChecker = true

SWEP.ViewModelFOV = 62
SWEP.ViewModelFlip = false
SWEP.AnimPrefix  = "rpg"

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Запрещено"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

DarkRP.hookStub{
    name = "playerWeaponsChecked",
    description = "Called when a player with a weapon checker has checked another player's weapons. Note: Only called when the player looks at the weapons without confiscating. Please see playerWeaponsConfiscated for when weapons are actually confiscated.",
    parameters = {
        {
            name = "checker",
            description = "The player holding the weapon checker.",
            type = "Player"
        },
        {
            name = "target",
            description = "The player whose weapons have been checked.",
            type = "Player"
        },
        {
            name = "weapons",
            description = "The weapons that have been checked.",
            type = "table"
        },
    },
    returns = {},
    realm = "Shared"
}

DarkRP.hookStub{
    name = "playerWeaponsReturned",
    description = "Called when a player with a weapon checker has returned another player's weapons.",
    parameters = {
        {
            name = "checker",
            description = "The player holding the weapon checker.",
            type = "Player"
        },
        {
            name = "target",
            description = "The player whose weapons have been returned.",
            type = "Player"
        },
        {
            name = "weapons",
            description = "The weapons that have been returned.",
            type = "table"
        },
    },
    returns = {},
    realm = "Server"
}

DarkRP.hookStub{
    name = "playerWeaponsConfiscated",
    description = "Called when a player with a weapon checker has confiscated another player's weapons.",
    parameters = {
        {
            name = "checker",
            description = "The player holding the weapon checker.",
            type = "Player"
        },
        {
            name = "target",
            description = "The player whose weapons have been confiscated.",
            type = "Player"
        },
        {
            name = "weapons",
            description = "The weapons that have been confiscated.",
            type = "table"
        },
    },
    returns = {},
    realm = "Server"
}

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:SetupDataTables()
    self:NetworkVar("Bool", 0, "IsWeaponChecking")
    self:NetworkVar("Float", 0, "StartCheckTime")
    self:NetworkVar("Float", 1, "EndCheckTime")
    self:NetworkVar("Float", 2, "NextSoundTime")
    self:NetworkVar("Int", 0, "TotalWeaponChecks")
end

function SWEP:Deploy()
    return true
end

function SWEP:DrawWorldModel() end

function SWEP:PreDrawViewModel(vm)
    return true
end

function SWEP:GetStrippableWeapons(ent, callback)
    CAMI.PlayerHasAccess(ent, "DarkRP_GetAdminWeapons", function(access)
        for k,v in pairs(ent:GetWeapons()) do
            if not v:IsValid() then continue end
            local class = v:GetClass()

            if GAMEMODE.Config.weaponCheckerHideDefault and (table.HasValue(GAMEMODE.Config.DefaultWeapons, class) or
                access and table.HasValue(GAMEMODE.Config.AdminWeapons, class) or
                ent:getJobTable() and ent:getJobTable().weapons and table.HasValue(ent:getJobTable().weapons, class)) then
                continue
            end

            if (GAMEMODE.Config.weaponCheckerHideNoLicense and GAMEMODE.NoLicense[class]) or GAMEMODE.Config.noStripWeapons[class] then continue end

            callback(v)
        end
    end)
end

function SWEP:PrimaryAttack()
    if self:GetIsWeaponChecking() then return end
    self:SetNextPrimaryFire(CurTime() + 0.3)

    self:GetOwner():LagCompensation(true)
    local trace = self:GetOwner():GetEyeTrace()
    self:GetOwner():LagCompensation(false)

    if not IsValid(trace.Entity) or not trace.Entity:IsPlayer() or trace.Entity:GetPos():DistToSqr(self:GetOwner():GetPos()) > 10000 then
        return
    end

    self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)
    self:SetNextSoundTime(CurTime() + 0.3)


    if not IsFirstTimePredicted() then return end

    local result = {}
    local weps = {}
    self:GetStrippableWeapons(trace.Entity, function(wep)
        table.insert(weps, wep)
    end)

    hook.Call("playerWeaponsChecked", nil, self:GetOwner(), trace.Entity, weps)

    if SERVER then return end
    for _, wep in pairs(weps) do
        table.insert(result, wep:GetPrintName() and language.GetPhrase(wep:GetPrintName()) or wep:GetClass())
    end

    result = table.concat(result, ", ")

    if result == "" then
        notification.AddLegacy(DarkRP.getPhrase("no_illegal_weapons", trace.Entity:Nick()), 1, 5)
        --self:GetOwner():ChatPrint(DarkRP.getPhrase("no_illegal_weapons", trace.Entity:Nick()))
        return
    end

    notification.AddLegacy(DarkRP.getPhrase("persons_weapons", trace.Entity:Nick()).."\n"..result, 0, 10)
    --[[
    self:GetOwner():ChatPrint(DarkRP.getPhrase("persons_weapons", trace.Entity:Nick()))
    if string.len(result) >= 126 then
        local amount = math.ceil(string.len(result) / 126)
        for i = 1, amount, 1 do
            self:GetOwner():ChatPrint(string.sub(result, (i-1) * 126, i * 126 - 1))
        end
    else
        self:GetOwner():ChatPrint(result)
    end
    ]]
end

function SWEP:SecondaryAttack()
    if self:GetIsWeaponChecking() then return end
    self:SetNextSecondaryFire(CurTime() + 0.3)

    self:GetOwner():LagCompensation(true)
    local trace = self:GetOwner():GetEyeTrace()
    self:GetOwner():LagCompensation(false)

    if not IsValid(trace.Entity) or not trace.Entity:IsPlayer() or trace.Entity:GetPos():DistToSqr(self:GetOwner():GetPos()) > 10000 then
        return
    end

    self:SetIsWeaponChecking(true)
    self:SetStartCheckTime(CurTime())
    self:SetEndCheckTime(CurTime() + util.SharedRandom("DarkRP_WeaponChecker" .. self:EntIndex() .. "_" .. self:GetTotalWeaponChecks(), 5, 10))
    self:SetTotalWeaponChecks(self:GetTotalWeaponChecks() + 1)

    self:SetNextSoundTime(CurTime() + 0.5)

    if SERVER then
        self:GetOwner():StartDelay('weaponcheck', 'Конфискация оружия', math.random(5, 10), function(s, ply)
            self:Succeed()
        end, function(s, ply)
            if not IsValid(self) then return false end
            if ply:GetActiveWeapon() ~= self then return false end
            if not self:GetIsWeaponChecking() then return false end
        end, function()
            if IsValid(self) then
                self:Fail()
            end
        end, {
            targetEnt = trace.Entity,
        })
    end
end

function SWEP:Reload()
    if CLIENT or CurTime() < (self.NextReloadTime or 0) then return end
    self.NextReloadTime = CurTime() + 1

    local trace = self:GetOwner():GetEyeTrace()

    if not IsValid(trace.Entity) or not trace.Entity:IsPlayer() or trace.Entity:GetPos():DistToSqr(self:GetOwner():GetPos()) > 10000 then
        return
    end

    if not trace.Entity.ConfiscatedWeapons then
        DarkRP.notify(self:GetOwner(), 1, 4, DarkRP.getPhrase("no_weapons_confiscated", trace.Entity:Nick()))
        return
    else
        for k,v in pairs(trace.Entity.ConfiscatedWeapons) do
            local wep = trace.Entity:Give(v.class)
            trace.Entity:RemoveAllAmmo()
            trace.Entity:SetAmmo(v.primaryAmmoCount, v.primaryAmmoType, false)
            trace.Entity:SetAmmo(v.secondaryAmmoCount, v.secondaryAmmoType, false)

            wep:SetClip1(v.clip1)
            wep:SetClip2(v.clip2)
            wep:SetVar('restricted_to_drop', tobool(v.restricted_to_drop))
        end
        DarkRP.notify(self:GetOwner(), 2, 4, DarkRP.getPhrase("returned_persons_weapons", trace.Entity:Nick()))

        hook.Call("playerWeaponsReturned", nil, self:GetOwner(), trace.Entity, trace.Entity.ConfiscatedWeapons)
        trace.Entity.ConfiscatedWeapons = nil
    end
end

function SWEP:Holster()
    self:SetIsWeaponChecking(false)
    self:SetNextSoundTime(0)
    return true
end

function SWEP:Succeed()
    if not IsValid(self:GetOwner()) then return end
    self:SetIsWeaponChecking(false)

    if CLIENT then return end
    local result = {}
    local stripped = {}
    local trace = self:GetOwner():GetEyeTrace()
    if not IsValid(trace.Entity) or not trace.Entity:IsPlayer() then return end
    self:GetStrippableWeapons(trace.Entity, function(wep)
        trace.Entity:StripWeapon(wep:GetClass())
        table.insert(result, wep:GetPrintName())
        stripped[wep:GetClass()] = {
            class = wep:GetClass(),
            primaryAmmoCount = trace.Entity:GetAmmoCount(wep:GetPrimaryAmmoType()),
            primaryAmmoType = wep:GetPrimaryAmmoType(),
            secondaryAmmoCount = trace.Entity:GetAmmoCount(wep:GetSecondaryAmmoType()),
            secondaryAmmoType = wep:GetSecondaryAmmoType(),
            clip1 = wep:Clip1(),
            clip2 = wep:Clip2(),
            restricted_to_drop = wep:GetVar('restricted_to_drop'),
        }
    end)
    result = table.concat(result, ", ")

    if not trace.Entity.ConfiscatedWeapons then
        if next(stripped) ~= nil then trace.Entity.ConfiscatedWeapons = stripped end
    else
        -- Merge stripped weapons into confiscated weapons
        for k,v in pairs(stripped) do
            if trace.Entity.ConfiscatedWeapons[k] then continue end

            trace.Entity.ConfiscatedWeapons[k] = v
        end
    end

    hook.Call("playerWeaponsConfiscated", nil, self:GetOwner(), trace.Entity, trace.Entity.ConfiscatedWeapons)

    if result == "" then
        DarkRP.notify(self:GetOwner(), 1, 5, DarkRP.getPhrase("no_illegal_weapons", trace.Entity:Nick()))
        --self:GetOwner():ChatPrint(DarkRP.getPhrase("no_illegal_weapons", trace.Entity:Nick()))
        self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)
        self:SetNextSoundTime(CurTime() + 0.3)
    else
        self:EmitSound("ambient/energy/zap1.wav", 50, 100)
        DarkRP.notify(self:GetOwner(), 0, 10, DarkRP.getPhrase("confiscated_these_weapons").."\n"..result)
        --[[
        self:GetOwner():ChatPrint(DarkRP.getPhrase("confiscated_these_weapons"))
        if string.len(result) >= 126 then
            local amount = math.ceil(string.len(result) / 126)
            for i = 1, amount, 1 do
                self:GetOwner():ChatPrint(string.sub(result, (i-1) * 126, i * 126 - 1))
            end
        else
            self:GetOwner():ChatPrint(result)
        end
        ]]
        self:SetNextSoundTime(0)
    end
end

function SWEP:Fail()
    self:SetIsWeaponChecking(false)
    self:SetHoldType("normal")
    self:SetNextSoundTime(0)
end

function SWEP:Think()
    if self:GetNextSoundTime() ~= 0 and CurTime() >= self:GetNextSoundTime() then
        if self:GetIsWeaponChecking() then
            self:SetNextSoundTime(CurTime() + 0.5)
            self:EmitSound("npc/combine_soldier/gear5.wav", 100, 100)
        else
            self:SetNextSoundTime(0)
            self:EmitSound("npc/combine_soldier/gear5.wav", 50, 100)
        end
    end
end
--addons/module_css2/lua/weapons/wrp_weapon_ar2/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	SWEP.FadeCrosshairOnAim = true
	
	SWEP.AimPos = Vector(-8.322, -7, 2.174)
	SWEP.AimAng = Vector(0.151, -3.701, -10.429)

	SWEP.BulletDisplay = 0
	SWEP.SprintPos = Vector(9.071, 0, 1.6418)
	SWEP.SprintAng = Vector(-12.9765, 26.8708, 0)

	SWEP.ViewModelMovementScale = 0.7
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 25
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 25
	SWEP.MaxZoom = 50
	
	SWEP.IconLetter = "l"
	SWEP.IconFont = "WeaponIcons"
	
	SWEP.MuzzleEffect = false
end

SWEP.PrintName = "S-LAR AR2"

SWEP.BulletDisplay = 0

SWEP.Base = 'swb_base'
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 15
SWEP.BulletDiameter = 11.5
SWEP.CaseLength = 21

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Category = "Запрещено"

SWEP.Author			= "kenzou power"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 60
SWEP.ViewModel 			= "models/weapons/oicw/c_oicw.mdl"
SWEP.WorldModel 		= "models/weapons/oicw/w_oicw.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 90
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("weapons/oicw/oicw_fire.wav")
SWEP.Recoil = 0.8

SWEP.HipSpread = 0.03
SWEP.AimSpread = 0.001
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.RifleSpread = 0.003
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 55
SWEP.DeployTime = 1

SWEP.Tracer = 'AR2Tracer'

--addons/module_css2/lua/weapons/wrp_weapon_khvostov/shared.lua:
AddCSLuaFile()

if CLIENT then

	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Khvostov 7G-0X"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-6.25, -4.7, 1.3)
	SWEP.AimAng = Vector(0.5, 0.13, -0.5)
	
	SWEP.SprintPos = Vector(0, 0, -0.7)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 40
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Премиум"

SWEP.Author	= "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/c_Khvostov7G0X.mdl"
SWEP.WorldModel = "models/weapons/w_Khvostov7G0X.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable	= true

SWEP.Primary.ClipSize = 30
SWEP.Primary.DefaultClip = 90
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("weapons/khvostov7g0x/kvfire.wav")
SWEP.Recoil = 0.7

SWEP.HipSpread = 0.035
SWEP.AimSpread = 0.0015
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 45
SWEP.DeployTime = 1

--addons/module_css2/lua/weapons/wrp_weapon_mp7/shared.lua:

-----------------------------------------------------
AddCSLuaFile()

if CLIENT then
	SWEP.CrosshairEnabled = true
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector (-6.4318, -2.0031, 1)
	SWEP.AimAng = Vector (0, 0, 0)
	
	SWEP.SprintPos = Vector(9.071, 0, 1.6418)
	SWEP.SprintAng = Vector(-12.9765, 26.8708, 0)
	
	SWEP.IconLetter = "a"
	SWEP.IconFont = "WeaponIcons"
	
	SWEP.MuzzleEffect = "swb_rifle_med"
end

SWEP.PrintName = "HK MP7"

SWEP.FadeCrosshairOnAim = true

SWEP.Base = 'swb_base'
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 15
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.BulletDisplay = 0

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "smg"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Category = "Запрещено"

SWEP.Author			= "kenzou power"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 60
SWEP.ViewModel			= "models/weapons/c_smg1.mdl"
SWEP.WorldModel			= "models/weapons/w_smg1.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.Reload 		= Sound("Weapon_SMG1.Reload")
SWEP.Primary.DefaultClip	= 90
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.06
SWEP.FireSound = Sound("Weapon_SMG1.Single")
SWEP.Recoil = 0.65

SWEP.HipSpread = 0.01
SWEP.AimSpread = 0.004
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 35
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/wrp_weapon_nailgun/shared.lua:

-----------------------------------------------------
AddCSLuaFile()

if CLIENT then
	SWEP.CrosshairEnabled = true
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = false
	
	SWEP.AimPos = Vector (-4.24, -3, 1.8)
	SWEP.AimAng = Vector (0.85, -0.015, 2.6)
	
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	SWEP.BulletDisplay = 0
	SWEP.ZoomAmount = 20
	SWEP.ViewModelMovementScale = 0.85
	SWEP.Shell = false
	
	SWEP.IconLetter = "d"
	SWEP.IconFont = "WeaponIcons"
	
end

SWEP.PrintName = "Гвоздомёт"

SWEP.FadeCrosshairOnAim = true

SWEP.SpeedDec = 12
SWEP.BulletDiameter = 9.1
SWEP.CaseLength = 33

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_revolver_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "pistol"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"	
SWEP.Category = "Запрещено"

SWEP.Author			= "kenzou power"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 60
SWEP.ViewModelFlip	= false
SWEP.ViewModel			= "models/tak/f3/c_10mm_smg.mdl"
SWEP.WorldModel			= "models/tak/f3/w_10mm_smg.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 16
SWEP.Primary.DefaultClip	= 48
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "pistol"

SWEP.FireDelay = 0.16
SWEP.FireSound = Sound("tak/weapons/fallout/smg/fire_mono.wav")
SWEP.Recoil = 0.7
SWEP.Chamberable = false

SWEP.HipSpread = 0.03
SWEP.AimSpread = 0.01
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0 
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 70
SWEP.DeployTime = 0
--addons/module_bank/lua/entities/bank_vault/cl_init.lua:
include('shared.lua')

surface.CreateFont('BankFont', {font = 'Coolvetica Rg', size = 100})

local logo = Material('data/wimages/wlogo.png')
local color_dark = Color( 43, 49, 54, 255 )
local color_bright = Color(236, 113, 71, 255)
local color_logo = Color(150, 150, 150, 100)
local color_red = Color( 255, 0, 0, 255 )
local color_other = Color(77, 75, 77 , 255)

function ENT:Draw()
    self:DrawModel()

    if LocalPlayer():GetPos():DistToSqr(self:GetPos()) >= 360000 then return end

    local pos = self:GetPos() + self:GetForward() * 32
    local ang = self:GetAngles()
    ang:RotateAroundAxis(ang:Forward(), 90)
    ang:RotateAroundAxis(ang:Right(), 270)

    cam.Start3D2D(pos, ang, 0.15) 
        draw.RoundedBox(0,-195,-380,380,150,color_dark) -- color_dark 
        draw.RoundedBox(0,-195,-380,380,28,color_bright) -- color_bright
        surface.SetDrawColor(color_logo)
        surface.SetMaterial(logo) 
        surface.DrawTexturedRect( -50, -345, 100, 100 )    
        draw.SimpleText('Хранилище Банка', 'Trebuchet24', -180, -365, color_white, 0, 1)
        if self:GetInProgress() then
            draw.SimpleText('Внутри: '..DarkRP.formatMoney(self:GetMoney()), 'Trebuchet24', -180, -330, color_white, 0, 1 )
            draw.SimpleText('До окончания ограбления: '..string.ToMinutesSeconds(self:GetRobberyRemaining()), 'Trebuchet24', -180, -300, color_red, 0, 1)
        else
            local remaining = self:GetCooldownRemaining()
            if remaining > 0 then
                draw.SimpleText('Внутри: '..DarkRP.formatMoney(self:GetMoney()), 'Trebuchet24', -180, -330, color_white, 0, 1 )
                draw.SimpleText('Восстановление хранилища: '..string.ToMinutesSeconds(remaining), 'Trebuchet24', -180, -300, color_red, 0, 1)
            else
                draw.SimpleText(DarkRP.formatMoney(self:GetMoney()), 'Trebuchet48', 0, -320, color_white, TEXT_ALIGN_CENTER)
                draw.SimpleText('Нажми E за криминальную профессию, чтобы начать ограбление', 'Default', 0, -255, color_white, TEXT_ALIGN_CENTER)
            end
        end
        surface.SetDrawColor(color_other)
        surface.DrawOutlinedRect(-195,-380,380,150)
    cam.End3D2D()
end
--addons/module_bank/lua/entities/bank_vault/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_anim'
ENT.PrintName = 'Хранилище банка'
ENT.Author = 'WayZer\'s Role Play'
ENT.Category = 'Запрещено'
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar('Float', 0, 'NextRobbery')
	self:NetworkVar('Float', 1, 'RobberyEnd')

	self:NetworkVar('Int', 0, 'Money')

	self:NetworkVar('Bool', 0, 'InProgress')

	if SERVER then
		self:SetMoney(wbank.config.start_money)
		self:SetInProgress(false)
	end
end

function ENT:GetRobberyRemaining()
	return self:GetRobberyEnd() - CurTime()
end

function ENT:GetCooldownRemaining()
	return self:GetNextRobbery() - CurTime()
end
--addons/module_bank/lua/entities/bank_vent/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_anim'
ENT.PrintName = 'Вентиляция'
ENT.Author = 'WayZer\'s Role Play'
ENT.Category = 'Запрещено'
ENT.Spawnable = true
ENT.AdminSpawnable = true
--addons/ent_bitcoinpc/lua/entities/bit_cornet/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "CornetOS"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "Point" )
end
--addons/ent_bitcoinpc/lua/entities/bit_harddisk/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/ent_bitcoinpc/lua/entities/bit_motherboard/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/ent_bitcoinpc/lua/entities/bit_powersupply/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/ent_bitcoinpc/lua/entities/bit_windows/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "WindowsOS"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "Point" )
end
--addons/module_bitminers2_extras/lua/entities/bm2_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "BM2 base"
ENT.Spawnable = false
ENT.Category = "Bitminers 2"


--addons/module_bitminers2/lua/entities/bm2_bitminer_1/cl_init.lua:
include("shared.lua")

local function __round(num, numDecimalPlaces)
  local mult = 10^(numDecimalPlaces or 0)
  return math.floor(num * mult + 0.5) / mult
end



//Animate fan(s)
function ENT:Think()
	if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then 
      self:SetNextClientThink( CurTime() + 1 )
      return true
	end

	if self:GetIsMining() then
		self.fanAng = self.fanAng + (FrameTime() * 400)
		for i = 0 , self:GetBoneCount() - 1 do
			if string.match( self:GetBoneName(i), "fan" ) ~= nil then
				self:ManipulateBoneAngles(i,Angle(self.fanAng,0,0))
			end
		end
	end

	if self.prev ~= self:GetIsMining() then
		self:DestroyShadow()
		self:CreateShadow()
	end

	self.prev = self:GetIsMining()

	self:SetNextClientThink(CurTime() + 0.3)
	return true
end

//Yuck I know but its to much effort to re-write the entire system
function ENT:Initialize()
	self.fanAng = 0
	self.prev = false
	//So each bitminer can have its own set of unique instructions. This is how we will do that
	self.customInstructions = {
		status = { //Outputs usefull runtime infomation
			command = "STATUS",
			description = "Выводит полезную информацию о текущем устройстве.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				consoleDisplay.history = consoleDisplay.history.."\n------------------STATUS------------------\n"
				local firstPart = "Работает                               "
				local secondPart = string.upper(tostring(ent:GetIsMining()))
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				firstPart = "Питание подключено                                 "
				secondPart = string.upper(tostring(ent:GetHasPower()))
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				consoleDisplay.history = consoleDisplay.history.."------------------------------------------\n\n"
			end
		},
		info = {
			command = "INFO",
			description = "Выводит дополнительную информацию о текущем устройстве.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				consoleDisplay.history = consoleDisplay.history.."\n-------------------INFO------------------\n"
				local firstPart = "ТАКТОВАЯ ЧАСТОТА                             "
				local secondPart = tostring(__round(ent:GetClockSpeed(), 3)).."Ghz"
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				local firstPart = "ЯДРА                                    "
				local secondPart = ent:GetCoreCount()
				consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
				consoleDisplay.history = consoleDisplay.history.."ТРЕБУЕТ МОЩНОСТЬ                    100W\n"
				consoleDisplay.history = consoleDisplay.history.."НАЗВАНИЕ                    Bitminer S1\n"
				local playerName = self:Getowning_ent()
				if playerName ~= NULL then playerName = playerName:Name() else playerName = "Unknown" end
				consoleDisplay.history = consoleDisplay.history..string.sub("ВЛАДЕЛЕЦ                                    ", 1, string.len("ВЛАДЕЛЕЦ                                    ") - string.len(playerName))..playerName.."\n"
				consoleDisplay.history = consoleDisplay.history.."-----------------------------------------\n\n"
			end
		},
		mining = {
			command = "MINING",
			description = "Начинает или останавливает добычу.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == nil then
					consoleDisplay.history = consoleDisplay.history.."Для использования этой команды, пожалуйста, введите один из следующих аргументов: 'mining start' или 'mining stop'\n"
				elseif arg1 == "start" then
					net.Start("BM2.Command.Mining")
						net.WriteEntity(ent)
						net.WriteBool(true)
					net.SendToServer()
				elseif arg1 == "stop" then
					net.Start("BM2.Command.Mining")
						net.WriteEntity(ent)
						net.WriteBool(false)
					net.SendToServer()
				else
					consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' не является допустимой опцией, введите 'mining start' или 'mining stop'\n"
				end
			end
		},
		bitcoin = { //Used for selling or getting info about bitcoins
			command = "BITCOIN",
			description = "Позволяет вам продавать или видеть информацию о сохраненных биткойнах.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == "info" then
					consoleDisplay.history = consoleDisplay.history.."\n-------------------BITCOIN------------------\n"
					local firstPart = "Количество Биткойнов                              "
					local secondPart = comma_value(__round(ent:GetBitcoinAmount(), 2)).."btc"
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					firstPart =	"Значение Биткойнов ($)                           "
					secondPart = tostring(comma_value(__round(ent:GetBitcoinAmount() * BM2CONFIG.BitcoinValue, 2)))
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					consoleDisplay.history = consoleDisplay.history.."--------------------------------------------\n\n"
				elseif arg1 == "sell" then
					net.Start("BM2.Command.SellBitcoins")
						net.WriteEntity(ent)
					net.SendToServer()
					local firstPart =	"Из                                        "
					local secondPart = tostring(comma_value(__round(ent:GetBitcoinAmount(), 2))).."btc"
					consoleDisplay.history = consoleDisplay.history.."\n-------------------RECEIPT------------------\n"
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					firstPart =	"Конвертировано в                               "
					secondPart = "$"..tostring(comma_value(__round(ent:GetBitcoinAmount() * BM2CONFIG.BitcoinValue, 2)))
					consoleDisplay.history = consoleDisplay.history..string.sub(firstPart, 1, string.len(firstPart) - string.len(secondPart))..secondPart.."\n"
					consoleDisplay.history = consoleDisplay.history.."Деньги были переведены на ваш кошелек\n"
					consoleDisplay.history = consoleDisplay.history.."--------------------------------------------\n\n"
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history.."Чтобы использовать эту команду, пожалуйста, укажите один из следующих аргументов: 'bitcoin info' или 'bitcoin sell'\n"
					else
						consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' не является допустимой опцией, введите 'bitcoin info' или 'bticoin sell'\n"
					end
				end
			end
		},
		upgrade = { //Used for selling or getting info about bitcoins
			command = "UPGRADE",
			description = "Показывает доступные обновления и позволяет их приобрести.",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == "1" then //CPU
					net.Start("BM2.Command.Upgrade")
					net.WriteEntity(ent)
					net.WriteBool(false)
					net.SendToServer()
				elseif arg1 == "2" then //Cores
					net.Start("BM2.Command.Upgrade")
					net.WriteEntity(ent)
					net.WriteBool(true)
					net.SendToServer()
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history.."\n-------------------UPGRADES------------------\n"
						local i = 0

						if self.upgrades.CPU.cost[self:GetCPUUpgrade() + 1] ~= nil then
							i = i + 1
							firstPart =	"[1] "..self.upgrades.CPU.name.."                                                              "
							secondPart = "                                             "
							thirdtPart = "$"..comma_value(self.upgrades.CPU.cost[self:GetCPUUpgrade() + 1])
							local str = string.sub(firstPart, 0, string.len(secondPart))
							consoleDisplay.history = consoleDisplay.history..string.sub(str, 1, string.len(str) - string.len(thirdtPart))..thirdtPart.."\n"
						end

						if self.upgrades.CORES.cost[self:GetCoreUpgrade() + 1] ~= nil then
							i = i + 1 
							firstPart =	"[2] "..self.upgrades.CORES.name.."                                                              "
							secondPart = "                                             "
							thirdtPart = "$"..comma_value(self.upgrades.CORES.cost[self:GetCoreUpgrade() + 1])
							local str = string.sub(firstPart, 0, string.len(secondPart))
							consoleDisplay.history = consoleDisplay.history..string.sub(str, 1, string.len(str) - string.len(thirdtPart))..thirdtPart.."\n"
						end

						if i == 0 then
							consoleDisplay.history = consoleDisplay.history.."Это устройство больше не нуждается в обновлениях\n"
						end

						consoleDisplay.history = consoleDisplay.history.."---------------------------------------------\nНаберите 'upgrade 1' или 'upgrade 2', чтобы выбрать обновление.\n"
					else
						consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' является не допустимой опцией, введите 'upgrade 1' или 'upgrade 2'\n"
					end
				end
			end
		}
	} 


	--Only add if DLC is loaded
	if BITMINERS_2_EXTRAS_DLC then
		self.customInstructions.remote = {
			command = "REMOTE",
			description = "Позволяет вам устанавливать, удалять и изменять имя модуля удаленного доступа, который позволит вам получить удаленный доступ к битминеру, используя "..BM2EXTRACONFIG.RemoteAccessCommand..". Установка его стоит $"..string.Comma(BM2EXTRACONFIG.RemoteAccessPrice)..".",
			action = function(arg1, arg2, instructionTable, ent, consoleDisplay)
				if arg1 == "install" then
					net.Start("BM2.Command.RemoteInstall")
					net.WriteEntity(ent)
					net.WriteBool(true)
					net.SendToServer()
					ent.remoteName = math.random(10,99).."."..math.random(100,800).."."..math.random(10,99).."."..math.random(100,800)
				elseif arg1 == "remove" then
					net.Start("BM2.Command.RemoteInstall")
					net.WriteEntity(ent)
					net.WriteBool(false)
					net.SendToServer()
				elseif arg1 == "setname" then
					local _string = arg2 or math.random(10,99).."."..math.random(100,800).."."..math.random(10,99).."."..math.random(100,800)
					ent.remoteName = _string
					consoleDisplay.history = consoleDisplay.history.."Удаленное имя изменено на '".._string.."'\n"
				else
					if arg1 == nil then
						consoleDisplay.history = consoleDisplay.history.."---------------------------------------------\nВведите 'REMOTE INSTALL' для установки удаленного модуля. Установка стоит $"..string.Comma(BM2EXTRACONFIG.RemoteAccessPrice).." и позволяет работать с битмайнером по удаленному доступу используя "..BM2EXTRACONFIG.RemoteAccessCommand.."\nВведите 'REMOTE REMOVE' для удаления удаленного доступа.\nВведите 'REMOTE SETNAME ExampleName' чтобы изменить удаленное имя битмайнера. Имя не должно содержать пробелов!\n"
					else
						consoleDisplay.history = consoleDisplay.history.."Опция '"..arg1.."' не является допустимой, опциями являются 'install', 'setname' или 'remove'\n"
					end
				end
			end
		}
	end
end

function ENT:Draw()
	self:DrawModel()
end
--addons/module_bitminers2/lua/entities/bm2_bitminer_server/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Bitminer Server"
ENT.Spawnable = true
ENT.Category = "Запрещено"

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "ShouldAnimate" )

end

--addons/module_bitminers2/lua/entities/bm2_extention_lead/cl_init.lua:
include("shared.lua")

function ENT:Initialize()

end

function ENT:Draw()
	self:DrawModel()
end
--addons/module_bitminers2_extras/lua/entities/bm2_solar_cable_otherend/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end  

--addons/ent_spiderweb/lua/entities/cobweb.lua:

-- Add the files that need to be downloaded
resource.AddFile( 'models/Zerochain/props_halloween/cobweb.mdl' )

resource.AddFile( 'materials/props_halloween/cobweb.vtf' )
resource.AddFile( 'materials/props_halloween/cobweb.vmt' )

resource.AddFile( 'materials/particles/spiderweb.vmt' )
resource.AddFile( 'materials/particles/spiderweb.vtf' )

AddCSLuaFile( "lua/effects/spiderweb/init.lua" )

---------------------------------------------------------------
------ Model & Design by: Zerochain | Coding by : Zerochain ---
---------------------------------------------------------------

hook.Add('Think', 'nw_cobweb', function()
  hook.Remove('Think', 'nw_cobweb')

  nw.Register('CobwebSlowed')
    :Read(net.ReadBool)
    :Write(net.WriteBool)
    :SetLocalPlayer()
end)

AddCSLuaFile()
--DEFINE_BASECLASS( "base_anim" )

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Spider Web"
ENT.Author = "ClemensProduction aka Zerochain"
ENT.Information = "Makes you slower"
ENT.Category = "Запрещено"


ENT.Spawnable = true
ENT.AdminOnly = false
ENT.Entities = {}

function ENT:SpawnFunction( ply, tr )                   -- 膆nlich wie die Initialize Funktion Standard SEnt Funktion
                                                        -- Sie beschreibt was er tun soll wenn man das Entity spawnt
        if ( !tr.Hit ) then return end

        local SpawnPos = tr.HitPos + tr.HitNormal * 10  -- Speichert die Position wo der Spieler grade hinguckt

        local ent = ents.Create( "cobweb" )      -- Definiert dass wir wirklich dieses SEnt spawnen
        ent:SetPos( SpawnPos )                          -- Definiert Position unseres SEnts
        ent:Spawn()                                     -- Spawnt das SEnt
        ent:Activate()                                  -- Unser Script bzw. das SEnt
        return ent
end
-----------------------------------------------------------]]

-----------------------------------------------------------]]
function ENT:Initialize()

  -- We do NOT want to execute anything below in this FUNCTION on CLIENT
  if ( CLIENT ) then return end

  self.Entity.GotUsed = false

  self:SetModel( "models/zerochain/props_halloween/cobweb.mdl" )
  self.Entity:SetModelScale(math.random(2,3),0.5)

  self.Entity:DrawShadow(false)
  self.Entity:SetSkin( 1 )

    self.Entity:PhysicsInit( SOLID_VPHYSICS )
    self.Entity:SetMoveType( MOVETYPE_NONE )
    self.Entity:SetSolid( SOLID_VPHYSICS )

    self.Entity:SetTrigger(true)


    --self.Entity:UseTriggerBounds(true, 1)

    --local sequence = self:LookupSequence( "wave" )
  --self:SetSequence( sequence )
  --self:ResetSequence( sequence )

  --PrintTable(self:GetSequenceList())

    local phys = self:GetPhysicsObject()
  if (phys:IsValid()) then
      phys:Wake()
    --phys:SetMass(50)
        phys:EnableMotion(false)
  end

  self.Entity.pos = self.Entity:GetPos()

end

--[[---------------------------------------------------------
  Name: Startouch
-----------------------------------------------------------]]
function ENT:StartTouch( activator )
  if not IsValid(activator) then return end
  if not activator:IsPlayer() then return end
  if activator:Team() == TEAM_SHAZAM then return end

  if self.Entity.GotUsed then return end

  self.Entity:SetModelScale(6,0.25)

  activator:SetNetVar('CobwebSlowed', true)

  self.Entity.GotUsed = true

  self.Entity:SetSolid( SOLID_CUSTOM )
  self:TouchEffect()
  
  timer.Create('cobwebslow_'..activator:EntIndex(), 10, 1, function()
    if IsValid(self) then self:Remove() end
    if not IsValid(activator) then return end

    activator:SetNetVar('CobwebSlowed', nil)
  end)
end

function ENT:ResetPlayerSpeed(owner)
  local ply = owner:GetOwner()
  if IsValid(ply) then ply:SetNetVar('CobwebSlowed', nil) end

  self:Remove()
end

local TouchS =  Sound( "player/footsteps/snow5.wav" )

function ENT:TouchEffect()

  sound.Play( TouchS, self:GetPos(), 75, 25,1)

  local part = EffectData()
  part:SetOrigin( self:GetPos())
  part:SetScale( 1 )
  util.Effect( "spiderweb", part)
end

-----------------------------------------------------------]]
function ENT:OnTakeDamage(dmginfo)
  if !self:IsValid() then return end 

  local ply = dmginfo:GetAttacker()

  if dmginfo:IsDamageType(64) then 
    if IsValid(ply) then
      self:ResetPlayerSpeed(ply)
    end
    self:Remove()
  end
end
-----------------------------------------------------------]]

local TouchSound =  Sound( "player/footsteps/snow6.wav" )

function ENT:OnRemove()
  sound.Play( TouchSound, self:GetPos(), 75, 25,1)

  local part = EffectData()
  part:SetOrigin( self:GetPos())
  part:SetScale( 1 )
  util.Effect( "spiderweb", part)
end

hook.Add('SetupMove', 'CobwebSlow', function(ply, mv)
	if not ply:GetNetVar('CobwebSlowed') then return end
	
	local vel = mv:GetVelocity()
	vel.z = math.min(vel.z, 0)
	mv:SetVelocity(vel)
	mv:SetMaxClientSpeed(10)
end)

hook.Add('DoubleJumpAllowed', 'cobweb', function(ply)
  if ply:GetNetVar('CobwebSlowed') then return false end
end)

if ( SERVER ) then return end -- We do NOT want to execute anything below in this FILE on SERVER


function ENT:Draw()

  self:DrawModel()

end

--gamemodes/darkrp/entities/entities/darkrp_cheque/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Cheque"
ENT.Author = "Eusion"
ENT.Spawnable = false
ENT.IsDarkRPCheque = true

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar("Entity", 1, "recipient")
	self:NetworkVar("Int", 0, "amount")
end

--addons/ent_drugz/lua/entities/durgz_cigarette/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "Сигарета"
ENT.Category = "Запрещено"
ENT.Model = "models/boxopencigshib.mdl"
ENT.UseTime = 1
--addons/ent_drugz/lua/entities/durgz_lsd/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "ЛСД"
ENT.Category = "Запрещено"
ENT.Model = 'models/cocn.mdl'
--addons/module_meth/lua/entities/eml_gas/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Газ";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 0, "MethAmount")
    self:NetworkVar("Int", 1, "MaxAmount")
    self:NetworkVar("Int", 2, "GasStorage")
    self:NetworkVar("Int", 3, "GasStorageMax")
    self:NetworkVar("Bool", 0, "Open")
    self:NetworkVar("Bool", 1, "Explode")
end
--addons/module_meth/lua/entities/eml_pot/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Кастрюля";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 0, "MethAmount")
    self:NetworkVar("Int", 1, "MaxAmount")
    self:NetworkVar("Int", 2, "Macid")
    self:NetworkVar("Int", 3, "Sulfur")
    self:NetworkVar("Int", 4, "Time")
    self:NetworkVar("Int", 5, "MaxTime")
    self:NetworkVar("Int", 6, "IntStatus")
end
--addons/module_meth/lua/entities/eml_sulfur/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Сульфур";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 0, "MethAmount")
    self:NetworkVar("Int", 1, "MaxAmount")
end
--addons/module_css2/lua/entities/ent_flashgrenade/shared.lua:
local FLASHTIMER = 5; --time in seconds, for the grenade to transition from full white to clear
local EFFECT_DELAY = 2; --time, in seconds when the effects still are going on, even when the whiteness of the flash is gone (set to -1 for no effects at all =]).

local Endflash, Endflash2;

if (CLIENT) then

	/*---------------------------------------------------------
	Initialize
	---------------------------------------------------------*/
	function ENT:Initialize()

		local Pos = self:GetPos()

		timer.Simple(2, function()
			local dynamicflash = DynamicLight( self:EntIndex() )

			if ( dynamicflash ) then
				dynamicflash.Pos = Pos
				dynamicflash.r = 255
				dynamicflash.g = 255
				dynamicflash.b = 255
				dynamicflash.Brightness = 5
				dynamicflash.Size = 1000
				dynamicflash.Decay = 1000
				dynamicflash.DieTime = CurTime() + 0.5
			end 
		end)
	end

	/*---------------------------------------------------------
	Think
	---------------------------------------------------------*/
	function ENT:Think()
	end

	/*---------------------------------------------------------
	Draw
	---------------------------------------------------------*/
	function ENT:Draw()

		self.Entity:DrawModel()
	end

	/*---------------------------------------------------------
	IsTranslucent
	---------------------------------------------------------*/
	function ENT:IsTranslucent()

		return true
	end
	/*
	function FlashEffect() if LocalPlayer():GetNetworkedFloat("FLASHED_END") > CurTime() then

		local pl 			= LocalPlayer();
		local FlashedEnd 		= pl:GetNetworkedFloat("FLASHED_END")
		local FlashedStart 	= pl:GetNetworkedFloat("FLASHED_START")
		
		local Alpha

		if(FlashedEnd - CurTime() > FLASHTIMER) then
			Alpha = 150;
		else
			local FlashAlpha = 1 - (CurTime() - (FlashedEnd - FLASHTIMER)) / (FlashedEnd - (FlashedEnd - FLASHTIMER));
			Alpha = FlashAlpha * 150;
		end
		
			surface.SetDrawColor(255, 255, 255, math.Round(Alpha))
			surface.DrawRect(0, 0, surface.ScreenWidth(), surface.ScreenHeight())
		end 
	end
	
	hook.Add("HUDPaint", "FlashEffect", FlashEffect);
	
		local function StunEffect()
		local pl 			= LocalPlayer();
		local FlashedEnd 		= pl:GetNetworkedFloat("FLASHED_END")
		local FlashedStart 	= pl:GetNetworkedFloat("FLASHED_START")
	
		if (FlashedEnd > CurTime() and FlashedEnd - EFFECT_DELAY - CurTime() <= FLASHTIMER) then
			local FlashAlpha = 1 - (CurTime() - (FlashedEnd - FLASHTIMER)) / (FLASHTIMER);
			DrawMotionBlur( 0, FlashAlpha / ((FLASHTIMER + EFFECT_DELAY) / (FLASHTIMER * 4)), 0);

		elseif (FlashedEnd > CurTime()) then
			DrawMotionBlur( 0, 0.01, 0);
		else
			DrawMotionBlur( 0, 0, 0);
		end
	end
	
	hook.Add( "RenderScreenspaceEffects", "StunEffect", StunEffect )
	*/
end

ENT.Type = "anim"

/*---------------------------------------------------------
OnRemove
---------------------------------------------------------*/
function ENT:OnRemove()
end

/*---------------------------------------------------------
PhysicsUpdate
---------------------------------------------------------*/
function ENT:PhysicsUpdate()
end

/*---------------------------------------------------------
PhysicsCollide
---------------------------------------------------------*/
function ENT:PhysicsCollide(data,phys)
	if data.Speed > 50 then
		self.Entity:EmitSound(Sound("Flashbang.Bounce"))
	end
	
	local impulse = -data.Speed * data.HitNormal * .4 + (data.OurOldVelocity * -.6)
	phys:ApplyForceCenter(impulse)
end
--gamemodes/darkrp/entities/entities/gmod_light.lua:

AddCSLuaFile()

ENT.PrintName = "Light"
ENT.Type = 'anim'
ENT.Editable = true

local MODEL = Model( "models/maxofs2d/light_tubular.mdl" )

--
-- Set up our data table
--
function ENT:SetupDataTables()

	self:NetworkVar( "Bool", 0, "On", { KeyName = "on", Edit = { type = "Boolean", order = 1, title = "#entedit.enabled" } } )
	self:NetworkVar( "Bool", 1, "Toggle", { KeyName = "tg", Edit = { type = "Boolean", order = 2, title = "#tool.light.toggle" } } )
	self:NetworkVar( "Float", 1, "LightSize", { KeyName = "sz", Edit = { type = "Float", order = 3, min = 0, max = 1024, title = "#tool.light.size" } } )
	self:NetworkVar( "Float", 2, "Brightness" , { KeyName = "br", Edit = { type = "Int", order = 4, min = 0, max = 1, title = "#tool.light.brightness" } } )

	self:NetworkVar( "Bool", 2, "LightWorld" , { KeyName = "world", Edit = { type = "Boolean", order = 5, title = "#tool.light.noworld", category = "#entedit.advanced" } } )
	self:NetworkVar( "Bool", 3, "LightModels" , { KeyName = "models", Edit = { type = "Boolean", order = 6, title = "#tool.light.nomodels", category = "#entedit.advanced" } } )

end

function ENT:Initialize()

	if ( CLIENT ) then

		self.PixVis = util.GetPixelVisibleHandle()

	end

	if ( SERVER ) then --lights are rolling around even though the model isn't round!!

		self:SetModel( MODEL )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:DrawShadow( false )

		local phys = self:GetPhysicsObject()

		if ( IsValid( phys ) ) then
			phys:Wake()
		end

	end

end

function ENT:OnTakeDamage( dmginfo )
	-- React to physics damage
	self:TakePhysicsDamage( dmginfo )
end

function ENT:Toggle()
	self:SetOn( !self:GetOn() )
end

function ENT:Think()
	if not ( CLIENT ) then return end
    local ply = LocalPlayer()
    local distSqr = 160000
    
    if ply:GetPos():DistToSqr( self:GetPos() ) > distSqr then 
    	self:SetNextClientThink( CurTime() + 1 )
    	return true
    end
    
	if ( !self:GetOn() ) then return end
	
	local dlight = DynamicLight(self:EntIndex())

	if (dlight) then
		local c = self:GetColor()

		dlight.Pos = self:GetPos()
		dlight.r = c.r
		dlight.g = c.g
		dlight.b = c.b
		dlight.Brightness = self:GetBrightness()
		dlight.Decay = self:GetLightSize() * 5
		dlight.Size = self:GetLightSize()
		dlight.DieTime = CurTime() + 2
	end
	
    self:SetNextClientThink( CurTime() )
    return true
end
--addons/module_chocolate/lua/entities/lucid_choc_chocolate.lua:
--Made by ThatCatGuy
--https://github.com/ThatCatGuy
--https://steamcommunity.com/sharedfiles/filedetails/?id=2195413561
--Stupidly rewritten by OverlordAkise (has alzheimers)

AddCSLuaFile()
ENT.Type = 'anim'
ENT.Base = "base_anim"

ENT.PrintName = "Chocolate"
ENT.Author = "OverlordAkise"
ENT.Purpose = "sell it to WillyWonka"
ENT.Instructions = "N/A"
ENT.Category 		= "Chocolate Maker"
ENT.Model = "models/hunter/plates/plate05x075.mdl"

ENT.sold = false

ENT.Spawnable = true
ENT.AdminSpawnable = true

if SERVER then 
  function ENT:Initialize()
    self:SetModel(self.Model)
    self:SetColor(Color(85,37,37,255))
    self:PhysicsInit( SOLID_VPHYSICS )
    self:SetMoveType( MOVETYPE_VPHYSICS )
    self:SetSolid( SOLID_VPHYSICS )
    local phys = self:GetPhysicsObject()
    if (phys:IsValid()) then
      phys:Wake()
    end
--[[    -- Or else it would fall through the stove
    timer.Simple(0,function()
      local phys = self:GetPhysicsObject()
      if (phys:IsValid()) then
        phys:Sleep()
      end
    end)--]]
  end
  function ENT:Use(ply, caller, useType, value)
    ply:PickupItem(self)
    --[[
    if self.sold then return end
    self.sold = true
    if ply.chefChocolate then
      ply.chefChocolate = ply.chefChocolate + 1
    else
      ply.chefChocolate = 1
    end
    DarkRP.notify(ply, 3, 5, "У тебя "..tostring(ply.chefChocolate).." шоколадок!")
    self:Remove()
    ]]
  end
else
  --CLIENT
  function ENT:Draw()
      self:DrawModel() 
  end
  
  function ENT:OnRemove()
    self:EmitSound("player/footsteps/chainlink2.wav", 100, 100)
  end

end

--addons/module_media/lua/entities/media_base/cl_init.lua:
include("shared.lua")
local frame

net.Receive('openRadioMenu', function()
    local ent = LocalPlayer():GetEyeTrace().Entity
    if not ent or not ent.IsRadio then return end

    if frame and IsValid(frame) then
        frame:Remove()
    end

    frame = vgui.Create('DFrame')
    frame:SetTitle('Радио' .. (ent:GetTitle() ~= '' and ' - ' .. ent:GetTitle() or ''))
    frame:SetSize(500, 0)
    frame:MakePopup()
    local entry = vgui.Create('DTextEntry', frame)
    entry:Dock(TOP)
    entry:SetPlaceholderText('Введите ссылку на песню')
    local stop = vgui.Create('DButton', entry)
    stop:SetText('■')
    stop:Dock(RIGHT)
    stop:SetWide(24)
    local play = vgui.Create('DButton', entry)
    play:Dock(RIGHT)
    play:SetText('▶')
    play:SetWide(24)

    stop.DoClick = function()
        RunConsoleCommand('stopSong')
    end

    local loop = vgui.Create('DCheckBoxLabel', frame)
    loop:Dock(TOP)
    loop:SetTall(25)
    loop:DockMargin(0, 5, 0, 0)
    loop:SetText('Включить повторение')
    loop:SetChecked(ent:IsLoop())
    local freeze = vgui.Create('DButton', frame)
    freeze:SetText(ent:IsFreeze() and 'Разморозить' or 'Заморозить')
    freeze:Dock(TOP)
    freeze:DockMargin(0, 10, 0, 0)

    function freeze:DoClick()
        RunConsoleCommand('radioFreeze')

        timer.Simple(.1, function()
            self:SetText(ent:IsFreeze() and 'Разморозить' or 'Заморозить')
        end)
    end

    function play:DoClick()
        if #entry:GetValue() <= 1 then
            notification.AddLegacy('Вставьте ссылку', NOTIFY_ERROR, 4)

            return
        end

        RunConsoleCommand('playSong', entry:GetValue(), loop:GetChecked() and 1 or 0)
    end

    frame:InvalidateLayout(true)
    frame:SizeToChildren(false, true)
    frame:Center()
end)

local cvar = CreateClientConVar('wayradio_volume', 1, true)

function ENT:OnRemove()
    if IsValid(self.Sound) then
        self.Sound:stop()
        self.Sound = nil
    end
end

function ENT:Think()
    local ply = LocalPlayer()
    local url = self:GetUrl()
    local vol = cvar:GetFloat() or 1
    local should_played = ply:GetPos():Distance(self:GetPos()) < 512 and vol > 0.02

    if not should_played and not IsValid(self.Sound) then
        self:SetNextClientThink(CurTime() + 0.5)

        return true
    end
    
    if IsValid(self.Sound) and ((not url and url == '') or not should_played) then
        self.Sound:stop()
        self.Sound = nil
    elseif should_played and (not IsValid(self.Sound) or self.Sound:getUrl() ~= url) then
        if IsValid(self.Sound) then
            self.Sound:stop()
            self.Sound = nil
        end

        if url == '' then
            self:SetNextClientThink(CurTime() + 0.5)

            return true
        end

        local service = wayRadio.Lib.load('media').guessService(url)

        if not service then
            self:SetNextClientThink(CurTime() + 0.5)

            return true
        end
  
        --service:query(url, function(a,b)  
        --    if string.find(b["_raw_fetcheddata"]:lower(), '404 not found') then return end
            local l = service:load(url, {
                use3D = true,
                ent3D = self
            })

            l:setVolume(vol)
            l:setQuality('low')
            l:play()

            l:runCommand(function()
    
                if self:GetTime() ~= 0 then
                    local seek = (CurTime() - self:GetstartTime()) % self:GetTime()
                    l:seek(seek)
                    l.LastStart = CurTime() - seek
                else
                    l.LastStart = CurTime()
                end
            end)

            self.Sound = l
        --end)
    elseif IsValid(self.Sound) and self.Sound:getVolume() ~= vol then
        self.Sound:setVolume(vol)
    elseif IsValid(self.Sound) and should_played then
        if self:IsLoop() then
            local n = CurTime() - (self.Sound.LastStart or 0) < self:GetTime()

            if not n or self.Sound:getState() == 'ended' then
                local m = (CurTime() - self:GetstartTime()) % self:GetTime()
                self.Sound:seek(m)
                self.Sound.LastStart = CurTime() - m
            end
        end
    end

    self:SetNextClientThink(CurTime() + 60)

    return true
end
--addons/module_samogon/lua/entities/mn_bottle/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Бутылка"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Bool", 0, "dist_full")
	self:NetworkVar("Bool", 1, "dist_bought")
	self:NetworkVar("Int", 0, "dist_moonshine")
	self:NetworkVar("Int", 1, "dist_alcohol")
	self:NetworkVar("Entity", 0, "owning_ent")
end

--addons/module_samogon/lua/entities/mn_bucket/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Бассейн"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Bool", 0, "dist_full")
	self:NetworkVar("Int", 0, "dist_moonshine")
	self:NetworkVar("Int", 1, "dist_alcohol")
	self:NetworkVar("Int", 2, "dist_barrel")
	self:NetworkVar("Entity", 0, "owning_ent")
end

--addons/module_samogon/lua/entities/mn_cseed/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Семена кукурузы"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false


--addons/module_samogon/lua/entities/mn_dirt/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_grain/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_gseed/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Семена пшеницы"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false


--addons/_smallscripts/lua/entities/npc_waydealer/shared.lua:
ENT.Base = 'base_ai'
ENT.Type = 'ai'

ENT.PrintName = 'Скупщик'
ENT.Author = 'WayZer\'s Role Play'
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = 'Запрещено'
ENT.Model = 'models/Humans/Group01/male_08.mdl'

function ENT:CanBuy(item)
    if not item.GetPrice or not item:GetPrice() then return false end

    return true
end

function ENT:GetSellCost(ply, item)
    return item:GetPrice() * item:GetAmount()
end
--addons/module_picture/lua/entities/painting_1.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Длинная рамка"
ENT.Category = "Fun + Games"
ENT.Author = "xyester"

ENT.Spawnable = true
ENT.DoNotDuplicate = true
ENT.Owned = false

if SERVER then
	function ENT:Use(caller)
    	if caller == self:Getowning_ent() then
    		net.Start("URLPaint Menu")
    			net.WriteEntity(self)
    		net.Send(caller)
    	end
	end

	function ENT:Initialize()
		self:SetModel("models/props_c17/Frame002a.mdl")

		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
		
		self:SetUseType(SIMPLE_USE)
		self:CPPISetOwner(self:Getowning_ent())

	end

	function ENT:OnRemove()
		if URLPaint.List[self] then
			URLPaint.List[self] = nil
		end
    end

    function ENT:OnTakeDamage(damageInfo)
        if damageInfo:GetAttacker() == self:Getowning_ent() then
            self:Remove()
        end
    end
else

	function ENT:Initialize()
		self:SetModel("models/props_c17/Frame002a.mdl")
		self:PhysicsInit(SOLID_VPHYSICS)
		self:SetMoveType(MOVETYPE_VPHYSICS)
		self:SetSolid(SOLID_VPHYSICS)
	end

	local distSqr = 202500

	function ENT:Draw()
	    
        local ply = LocalPlayer()
        local png = self.image
        
		self:DrawModel()
		
        if ply:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end
	    

		if GetConVar('urlpaint_enabled'):GetInt() <= 0 then return end
		
		if self:GetPicID() == "" then
			return
        end
		
		if png == nil then return end
		
		if png:IsError() then return end

		local ang = self:GetAngles()
		ang:RotateAroundAxis(ang:Up(), 90)
		ang:RotateAroundAxis(ang:Forward(), 90)

		cam.Start3D2D(self:GetPos() + (self:GetUp() * 14) + (self:GetRight() * (self:OBBMaxs().y - 4)), ang, 0.0600)
			surface.SetDrawColor(color_white)
			surface.SetMaterial(png)
			surface.DrawTexturedRect(0, 0, 310, 439)
		cam.End3D2D()
	end
end

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("String", 0, "PicURL")
    self:NetworkVar("String", 1, "PicID")
end
--addons/weapon_spiderswep/lua/entities/rope/cl_init.lua:

include('shared.lua')

local matBeam		 	= Material( "cable/xbeam" )

/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()

	self.Size = 0
	self.MainStart = self.Entity:GetPos()
	self.MainEnd = self:GetEndPos()
	self.dAng = (self.MainEnd - self.MainStart):Angle()
	self.speed = 10000
	self.startTime = CurTime()
	self.endTime = CurTime() + self.speed
	self.dt = -1

end

function ENT:Think()

	self.Entity:SetRenderBoundsWS( self:GetEndPos(), self.Entity:GetPos(), Vector()*8 )

	self.Size = math.Approach( self.Size, 1, 10*FrameTime() )

end


function ENT:DrawMainBeam( StartPos, EndPos, dt, dist )

	local TexOffset = 0

	local ca = Color(255,255,255,255)

	EndPos = StartPos + (self.dAng * ((1 - dt)*dist))

	-- Beam effect
	render.SetMaterial( matBeam )
	render.DrawBeam( EndPos, StartPos,
					2,
					TexOffset*-0.4, TexOffset*-0.4 + StartPos:Distance(EndPos) / 256,
					ca )


end

function ENT:Draw()

	local Owner = self.Entity:GetOwner()
	if (!Owner || Owner == NULL) then return end

	local StartPos 		= self.Entity:GetPos()
	local EndPos 		= self:GetEndPos()
	local ViewModel 	= Owner == LocalPlayer()

	if (EndPos == Vector(0,0,0)) then return end

	if ( ViewModel ) then

		local vm = Owner:GetViewModel()
		if (!vm || vm == NULL) then return end
		local attachment = vm:GetAttachment( 1 )
		if attachment then
			StartPos = attachment.Pos
		end

	else

		local vm = Owner:GetActiveWeapon()
		if (!vm || vm == NULL) then return end
		local attachment = vm:GetAttachment( 1 )
		if attachment then
			StartPos = attachment.Pos
		end

	end


	local TexOffset = CurTime() * -2

	local Distance = EndPos:Distance( StartPos ) * self.Size

	local et = (self.startTime + (Distance/self.speed))
	if(self.dt != 0) then
		self.dt = (et - CurTime()) / (et - self.startTime)
	end
	if(self.dt < 0) then
		self.dt = 0
	end
	self.dAng = (EndPos - StartPos):Angle():Forward()

	local gbAngle = (EndPos - StartPos):Angle()
	local Normal 	= gbAngle:Forward()

	self:DrawMainBeam( StartPos, StartPos + Normal * Distance, self.dt, Distance )

end

/*---------------------------------------------------------
   Name: IsTranslucent
---------------------------------------------------------*/
function ENT:IsTranslucent()
	return true
end

--addons/module_weed/lua/entities/sent_water_tank.lua:
AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Base = "sent_base_gonzo"

ENT.Linkable = true
ENT.Size = Vector(30,60,75)
ENT.PrintName		= "Насос"
ENT.Author			= "Gonzo"
ENT.Category		= "Drugs"
ENT.Spawnable 		= false
ENT.AdminOnly 		= false

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/gonzo/weedb/water_source.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
    self:SetCharge(100)
    self:SetBuckets(WEED_CONFIG.WaterSourceBuckets)
    self:SetMaxBuckets(WEED_CONFIG.WaterSourceBuckets)
	    local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
	end
end


function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "Charge")
    self:NetworkVar("Int", 1, "Buckets")
    self:NetworkVar("Int", 2, "MaxBuckets")
    self:NetworkVar("Int", 3, "WaterAmount")
end

ENT.Ready = false

function ENT:Use(ply)
  if(self:GetWaterAmount() >= 100) then
    local ent = ents.Create("sent_water_pot")
    ent:SetPos(self:GetPos() + self:GetUp()*28 + self:GetRight()*52 - self:GetForward()*32 + Vector(0,0,-30))
    ent:Spawn()
    ent:GetPhysicsObject():Sleep()
    self:SetWaterAmount(0)
    self.Ready = false
    self:SetBuckets(self:GetBuckets()-1)
    if(self:GetBuckets() <= 0) then
      self:Remove()
    end
  end
end

function ENT:Think()
  if SERVER then
    if(self:GetWaterAmount() < 100) then
      self:SetWaterAmount(self:GetWaterAmount()+1)
    else
      if(!self.Ready) then
        self.Ready = true
      end
    end
    self:NextThink(CurTime()+WEED_CONFIG.WaterSourceSpeed);
    return true
  end
end

if CLIENT then

local rope = Material("gui/rope")
local hl = Color(231, 76, 60)
local water = surface.GetTextureID("gui/water")

function ENT:PostDraw()
  if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
    return
  end

  render.SetMaterial(rope)
  render.DrawBeam(self:GetPos() + self:GetUp()*28 + self:GetRight()*52 - self:GetForward()*22 + Vector(0,0,-30),self:GetPos() + self:GetUp()*28 + self:GetRight()*52 - self:GetForward()*22,1,0,3,Color(72, 200, 512,255))
end

function ENT:DoInfo()
  if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
    return
  end

  surface.SetDrawColor(50,50,50,150)
  surface.DrawRect(12,-32,332,128)
  draw.SimpleTextOutlined(self.PrintName,"MainWeedFont",36,-2,Color(255,255,255),TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER,1,Color(75,75,75))
  surface.SetMaterial(rope)
	surface.SetDrawColor(255,255,255,255)
  surface.DrawTexturedRectUV( 12, -32, 4, 128, 0, 0, 1, 1 )
  surface.DrawTexturedRectUVRotated(12+332, 30, 4, 128, 0, 0, 1, 1 ,180)
  surface.DrawTexturedRectUVRotated(12+332/2, -32, 4, 332, 0, 0, 1, 2 ,90)
  surface.DrawTexturedRectUVRotated(12+332/2, -32+128, 4, 332, 0, 0, 1, 2 ,90)

  if(self:GetWaterAmount() < 100) then
    surface.SetTexture(water)

  	surface.SetDrawColor(hl)
  	surface.DrawTexturedRect(30,22,64,64)
    draw.SimpleTextOutlined(self:GetBuckets(),"MainWeedFont",110,56,Color(255,255,255),TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER,1,Color(75,75,75))

    draw.SimpleTextOutlined(self:GetWaterAmount().."%","MainWeedFont",332,56,Color(255,255,255),TEXT_ALIGN_RIGHT,TEXT_ALIGN_CENTER,1,Color(75,75,75))
  else
    draw.SimpleTextOutlined("Наполнить (E)","MainWeedFont_med",186,56,Color(50,150,255),TEXT_ALIGN_CENTER,TEXT_ALIGN_CENTER,1,Color(75,75,75))
  end

end

end

--addons/module_weed/lua/entities/sent_weed_bag.lua:
AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Base = "sent_base_gonzo"
ENT.Size = Vector(0,30,30)
ENT.PrintName		= "Drug Bag"
ENT.Author			= "Gonzo"
ENT.Spawnable 		= false
ENT.Category		= "Drugs"
ENT.AdminOnly 		= true

ENT.Level = 1

function ENT:SpawnFunction( ply, tr, ClassName )

	if ( !tr.Hit ) then return end

	local SpawnPos = tr.HitPos

	local ent = ents.Create( ClassName )
	ent:SetPos( SpawnPos )
	ent:Spawn()
	ent:Activate()
	ent:SetPersistent()
	ent.Owner = ply

	return ent

end


function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "WeedQuality")
    self:NetworkVar("Int", 1, "WeedAmount")
    self:NetworkVar("Int", 2, "Consumable")
end

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/gonzo/weedb/bag/bag.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
		self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
		self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
		self:SetUseType(SIMPLE_USE)
	    local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end

		self:SetWeedQuality(math.random(1,100))
		self:SetWeedAmount(WEED_CONFIG.VialAmount)
	end
end

ENT.Warned = false
function ENT:Use(act)
	act:PickupItem(self)
end

ENT.Touched = false
ENT.NLevel = 0

function ENT:Touch(ent)
end

function ENT:DoInfo()
end
--addons/module_slotmachine/lua/entities/slot_double/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Double Or Nothing"
ENT.Author = "<CODE BLUE>"
ENT.Contact = "Via Steam"
ENT.Spawnable = true
ENT.Category = "WaySlots"

ENT.WheelSides = 8

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar( "String", 0, "UserName")
	self:NetworkVar( "Float", 0, "UserLastInteract")
	self:NetworkVar( "Int", 0, "Multiplier")
	self:NetworkVar( "Bool", 0, "GameStarted")
	self:NetworkVar( "Int", 1, "CashOutAmount")
	self:NetworkVar( "Int", 2, "Jackpot")
end
--addons/module_slotmachine/lua/bdon_config.lua:
BDON_CONFIG = {}
BDON_CONFIG.bet = 2500
BDON_CONFIG.minJackpot = 700000
BDON_CONFIG.maxJackpot = 1000000
BDON_CONFIG.doubleChance = 50 --(50 is recommened, but if you think there winning jackpot to much then lower this number, or raise it its your server :)
BDON_CONFIG.Volume = 1
BDON_CONFIG.CurrenyPrefix = "$"
BDON_CONFIG.addMoney = function(ply, amount)
	ply:addMoney(amount) --DarkRP
end
BDON_CONFIG.canAfford = function(ply, amount)
	return ply:canAfford(amount) --DarkRP
end
BDON_CONFIG.takeMoney = function(ply, amount)
	ply:addMoney(amount * -1) --DarkRP
end



--gamemodes/darkrp/entities/entities/spawned_money/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
if(EyePos():Distance(self:GetPos())<1000) then self:DrawModel() end

    -- Do not draw labels when a different model is used.
    -- If you want a different model with labels, make your own money entity and use GM.Config.MoneyClass.
    if self:GetModel() ~= "models/props/cs_assault/money.mdl" then return end

    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    surface.SetFont("ChatFont")
    local text = DarkRP.formatMoney(self:Getamount())
    local TextWidth = surface.GetTextSize(text)

    cam.Start3D2D(Pos + Ang:Up() * 0.82, Ang, 0.1)
        draw.WordBox(2, -TextWidth * 0.5, -10, text, "ChatFont", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
    cam.End3D2D()

    Ang:RotateAroundAxis(Ang:Right(), 180)

    cam.Start3D2D(Pos, Ang, 0.1)
        draw.WordBox(2, -TextWidth * 0.5, -10, text, "ChatFont", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
    cam.End3D2D()
end

function ENT:Think()
end

--gamemodes/darkrp/entities/entities/spawned_shipment/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Shipment"
ENT.Author = "philxyz"
ENT.Spawnable = false
ENT.IsSpawnedShipment = true

function ENT:SetupDataTables()
    self:NetworkVar("Int",0,"contents")
    self:NetworkVar("Int",1,"count")
    self:NetworkVar("Float", 0, "gunspawn")
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Entity", 1, "gunModel")
end

DarkRP.declareChatCommand{
    command = "splitshipment",
    description = "Split the shipment you're looking at.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "makeshipment",
    description = "Create a shipment from a dropped weapon.",
    delay = 1.5
}


function ENT:SetPlayer( ply )

	self.Founder = ply

	if ( IsValid( ply ) ) then

		self:SetNWString( "FounderName", ply:Nick() )
		self.FounderSID = ply:SteamID64()
		self.FounderIndex = ply:UniqueID()

	else

		self:SetNWString( "FounderName", "" )
		self.FounderSID = nil
		self.FounderIndex = nil

	end

end

function ENT:GetPlayer()

	if ( self.Founder == nil ) then

		-- SetPlayer has not been called
		return NULL

	elseif ( IsValid( self.Founder ) ) then

		-- Normal operations
		return self.Founder

	end

	-- See if the player has left the server then rejoined
	local ply = player.GetBySteamID64( self.FounderSID )
	if ( not IsValid( ply ) ) then

		-- Oh well
		return NULL

	end

	-- Save us the check next time
	self:SetPlayer( ply )
	return ply

end
--addons/module_tech/lua/entities/technician_base/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end

function ENT:ShowSparks()
    local getpos = self:GetPos()

    if getpos:DistToSqr(LocalPlayer():GetPos()) > 250000 then
        return 
    end

    local effectdata = EffectData()
    effectdata:SetOrigin(getpos)
    effectdata:SetMagnitude(1)
    effectdata:SetScale(1)
    effectdata:SetRadius(2)
    util.Effect("Sparks", effectdata)
end
--addons/module_tech/lua/entities/technician_controlbox.lua:
AddCSLuaFile()
ENT.Type = 'anim'
ENT.Base = "technician_base"

ENT.Name = "Controlbox"
ENT.PrintName = "Controlbox"
ENT.Author = "OverlordAkise"
ENT.Category = "Запрещено"
ENT.Purpose = "Press E to repair!"
ENT.Instructions = "N/A"
ENT.Model = "models/props/de_nuke/NuclearControlBox.mdl"

ENT.Spawnable = true

--addons/module_tech/lua/entities/technician_payphone.lua:
AddCSLuaFile()
ENT.Type = 'anim'
ENT.Base = "technician_base"

ENT.Name = "Payphone"
ENT.PrintName = "Payphone"
ENT.Author = "OverlordAkise"
ENT.Category = "Разрешено"
ENT.Purpose = "Press E to repair!"
ENT.Instructions = "N/A"
ENT.Model = "models/props_trainstation/payphone001a.mdl"

ENT.Spawnable = true

--addons/ent_ammobox/lua/entities/unarrest_wood/cl_init.lua:
include("shared.lua")

local logo = Material('data/wimages/wlogo.png')
local color_dark = Color( 43, 49, 54, 255 )
local color_bright = Color(236, 113, 71, 255)
local color_other = Color(77, 75, 77 , 255)
local color_logo = Color(150, 150, 150, 100)

function ENT:Draw()

    local ply = LocalPlayer()
    local distSqr = 22500
    local entPos = self:GetPos()
    
    if ply:GetPos():DistToSqr( entPos ) > distSqr then return end
    

    self:DrawModel()
    
    local ang = self:GetAngles()
    local pos = LocalToWorld(Vector(19, 1, 7), Angle(0, 90, 90), entPos, self:GetAngles())

    ang:RotateAroundAxis(ang:Forward(), 90)
    ang:RotateAroundAxis(ang:Right(), 180)

    cam.Start3D2D(pos, ang, 0.1) 
        draw.RoundedBox( 0,0,0,380,150, color_dark ) -- Color( 43, 49, 54, 255 ) 
        draw.RoundedBox(0,0,0,380,28, color_bright ) -- Color(236, 113, 71, 255)
        surface.SetDrawColor( color_logo )
        surface.SetMaterial( logo ) 
        surface.DrawTexturedRect( 140, 35, 100, 100 )    
        surface.SetDrawColor( color_other )
        surface.DrawOutlinedRect( 0,0,380,150 )
        draw.SimpleText( " Снижение срока ареста", "Trebuchet24", 0, 15, color_white, 0, 1 )
        draw.SimpleText( DarkRP.formatMoney(self.Price or 350000), "Trebuchet48", 100, 85, color_white, 0, 1 )
        draw.SimpleText( " Нажми Е для взаимодействия", "Trebuchet18", 85, 130, color_white, 0, 1 )
        
    cam.End3D2D()
end

net.Receive('sell_unarrest', function()
    Derma_Query(
        'Снизить срок ареста до одной минуты?',
        'Досрочное освобождение',
        'Да',
        function()
            net.Start('sell_unarrest')
            net.SendToServer()
        end,
        'Нет'
    )
end)
--addons/ent_spiderweb/lua/effects/spiderweb/init.lua:

function EFFECT:Init( data )
	local Pos = data:GetOrigin()
	local Color = data:GetStart()
	local emitter = ParticleEmitter( Pos )
	
	for i = 1,math.random(1,5) do

		local particle = emitter:Add( "particles/spiderweb", Pos + Vector( math.random(0,0),math.random(0,0),math.random(0,0) ) ) 
		 
		--if particle == nil then particle = emitter:Add( "particles/pumbkinface01", Pos + Vector(   math.random(0,0),math.random(0,0),math.random(0,0) ) ) end
		
		if (particle) then
			particle:SetVelocity(Vector(math.random(-45,45),math.random(-45,45),math.random(-45,45)))
			particle:SetLifeTime(2) 
			particle:SetDieTime(4) 
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetStartSize(1) 
			particle:SetEndSize(50)
			particle:SetAngles( Angle(math.Rand( 0, 360 ),math.Rand( 0, 360 ),math.Rand( 0, 360 )) )
			particle:SetAngleVelocity( Angle(0,0,0) ) 
			particle:SetRoll(math.Rand( 0, 360 ))
			particle:SetColor( 125,125,125 )
			--particle:SetColor(math.random(199,255),math.random(73,204),math.random(0,0),math.random(255,255))
			particle:SetGravity( Vector(0,-1,0) ) 
			particle:SetAirResistance(3)  
		end
	end

	emitter:Finish()
		
end

function EFFECT:Think()		
	return false
end

function EFFECT:Render()
end

--addons/module_weed/lua/effects/weed_smoke.lua:
function EFFECT:Init(data)
	self.ent = data:GetEntity()
	self.Emitter = ParticleEmitter( self.ent:EyePos() ) 

	for k=0,2 do
		timer.Simple(k/10,function()
			local beat = self.Emitter:Add("effects/softglow_translucent", self.ent:EyePos() + self.ent:GetForward()*16 + self.ent:GetUp()*-16)
			if (beat) then
				beat:SetPos(self.ent:EyePos()  + self.ent:GetForward()*8 + self.ent:GetUp()*-6)
				beat:SetLifeTime(0)
				beat:SetDieTime(1)
				beat:SetStartAlpha(254)
				beat:SetEndAlpha(0)
				beat:SetStartSize(math.random(0.2,2))
				beat:SetEndSize(math.random(10,30))
				beat:SetCollide(false)
				beat:SetGravity(Vector(0,0,50))
				beat:SetRollDelta( math.random(-16,16) )
				beat:SetColor(255,255,255,math.random(4,30))
				beat:SetVelocity(self.ent:GetForward()*64)
			end
		end)
	end
	timer.Simple(3,function()
		self.Emitter:Finish()
	end)
end

function EFFECT:Think()
	if(IsValid(self.ent)) then
		return true
	end
	return false
end

function EFFECT:Render()
end
--addons/module_itemstore/lua/itemstore/cl_init.lua:
include( "shared.lua" )

include( "cl_gui.lua" )
include( "cl_player.lua" )
--addons/module_itemstore/lua/itemstore/items/craft_tools.lua:
ITEM.Name = 'Набор инструментов'
ITEM.Model = 'models/props_c17/tools_wrench01a.mdl'
ITEM.Stackable = true
ITEM.MaxStack = 4
ITEM.DropStack = false
--addons/module_itemstore/lua/itemstore/items/drug.lua:
ITEM.Name = itemstore.Translate( "drug_name" )
ITEM.Description = itemstore.Translate( "drug_desc" )
ITEM.Model = "models/props_lab/jar01a.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Consumables
ITEM.Base = "base_darkrp"
ITEM.Stackable = true

function ITEM:SaveData( ent )
	self:SetData( "Price", ent:Getprice() )
	self:SetData( "Owner", ent:Getowning_ent() )
end

function ITEM:LoadData( ent )
	ent:Setprice( self:GetData( "Price" ) )
	ent:Setowning_ent( self:GetData( "Owner" ) )
end
--addons/module_itemstore/lua/itemstore/items/gunlab.lua:
ITEM.Name = itemstore.Translate( "gunlab_name" )
ITEM.Description = itemstore.Translate( "gunlab_name" )
ITEM.Model = "models/props_c17/TrapPropeller_Engine.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Factories
ITEM.Base = "base_darkrp"

function ITEM:SaveData( ent )
	self:SetData( "Price", ent:Getprice() )
	self:SetData( "Owner", ent:Getowning_ent() )
end

function ITEM:LoadData( ent )
	ent:Setprice( self:GetData( "Price" ) )
	
	local owner = self:GetData( "Owner" )
	if not IsValid( owner ) then
		owner = player.GetAll()[ 1 ]
	end

	ent:Setowning_ent( owner )
end
--addons/module_itemstore/lua/itemstore/items/mn_barrel.lua:
ITEM.Name = 'Бочка с самогоном'
ITEM.Description = 'Тебе не тяжело?'
ITEM.Model = 'models/wood_barrel/wood_barrel.mdl'
ITEM.Color = Color(0,255,0)
ITEM.Base = 'base_entity'

ITEM:CreateMutator('Price')
ITEM.Price = 125000

function ITEM:LoadData( ent )
    ent:Setdist_alcohol(50)
    ent.Spawned = true
    ent:SetColor(self.Color)
end

function ITEM:CreateEntity( pos )
	local ent = ents.Create( self.Class )
	ent:SetPos( pos )
	ent:Spawn()
    self:LoadData(ent)
	ent:Activate()

	return ent
end

function ITEM:CanPickup(ply, ent)
    return ent.Spawned
end
--addons/module_itemstore/lua/itemstore/items/money_printer.lua:
ITEM.Name = itemstore.Translate( "moneyprinter_name" )
ITEM.Description = itemstore.Translate( "moneyprinter_desc" )
ITEM.Model = "models/props_c17/consolebox01a.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Factories
ITEM.Base = "base_darkrp"

function ITEM:SaveData( ent )
	self:SetData( "Price", ent:Getprice() )
	self:SetData( "Owner", ent:Getowning_ent() )
end

function ITEM:LoadData( ent )
	ent:Setprice( self:GetData( "Price" ) )
	ent:Setowning_ent( self:GetData( "Owner" ) )
end
--addons/module_itemstore/lua/itemstore/items/spawned_ammo.lua:
ITEM.Name = itemstore.Translate( "ammo_name" )
ITEM.Description = itemstore.Translate( "ammo_desc" )
ITEM.HighlightColor = itemstore.config.HighlightColours.Ammo
ITEM.Stackable = true
ITEM.DropStack = true
ITEM.Base = "base_darkrp"

function ITEM:GetName()
	if SERVER then
		return self:GetData( "Name", self.Name )
	else
		return self:GetData( "Name", language.GetPhrase( self:GetData( "AmmoType" ) .. "_ammo" )  )
	end
end

function ITEM:Use( pl )
	pl:GiveAmmo( self:GetAmount(), self:GetData( "AmmoType" ) )
	return true
end

function ITEM:CanMerge( item )
	return self.Stackable and self:GetClass() == item:GetClass() and
		self:GetData( "AmmoType" ) == item:GetData( "AmmoType" )
end

function ITEM:SaveData( ent )
	self:SetModel( ent:GetModel() )
	self:SetAmount( ent.amountGiven )	
	self:SetData( "AmmoType", ent.ammoType )
end

function ITEM:LoadData( ent )
	ent:SetModel( self:GetModel() )
	ent.amountGiven = self:GetAmount()	
	ent.ammoType = self:GetData( "AmmoType" )
end

--addons/module_itemstore/lua/itemstore/admin.lua:
if SERVER then
    
    local admins = {'superadmin', 'WayZer Team', 'Trusted'}
    
	util.AddNetworkString( "ItemStoreAdminInventory" )
	net.Receive( "ItemStoreAdminInventory", function( len, admin )
		if not table.HasValue(admins, admin:GetUserGroup()) then return end

		local pl = net.ReadEntity()

		if not IsValid( pl ) then return end
		if not pl.Inventory then return end

		pl.Inventory:SetPermissions( admin, true, true )
		pl.Inventory:Sync( admin )
		admin:OpenContainer( pl.Inventory:GetID(), itemstore.Translate( "players_inventory", pl:Name() ) )
	end )

	util.AddNetworkString( "ItemStoreAdminBank" )
	net.Receive( "ItemStoreAdminBank", function( len, admin )
		if not table.HasValue(admins, admin:GetUserGroup()) then return end

		local pl = net.ReadEntity()

		if not IsValid( pl ) then return end
		if not pl.Bank then return end

		pl.Bank:SetPermissions( admin, true, true )
		pl.Bank:Sync( admin )
		admin:OpenContainer( pl.Bank:GetID(), itemstore.Translate( "players_bank", pl:Name() ) )
	end )
else
	concommand.Add( "itemstore_admin", function( pl )
		if not pl:IsSuperAdmin() then return end

		local panel = vgui.Create( "ItemStoreAdmin" )
		panel:SetSize( 200, 300 )
		panel:Center()
		panel:MakePopup()
	end )
end

--addons/module_itemstore/lua/itemstore/vgui/trade.lua:
local PANEL = {}

function PANEL:Init()
	self:SetSkin( "itemstore" )

	self.LeftContainer = vgui.Create( "ItemStoreContainer", self )
	self.RightContainer = vgui.Create( "ItemStoreContainer", self )

	self.LeftMoneyIcon = vgui.Create( "DImage", self )
	self.LeftMoneyIcon:SetImage( "icon16/money.png" )

	self.RightMoneyIcon = vgui.Create( "DImage", self )
	self.RightMoneyIcon:SetImage( "icon16/money.png" )

	self.LeftMoney = vgui.Create( "DTextEntry", self )
	self.LeftMoney.OnLoseFocus = function( money )
		net.Start( "ItemStoreTradeMoney" )
			net.WriteUInt( tonumber( money:GetText() ) or 0, 32 )
		net.SendToServer()
	end

	self.RightMoney = vgui.Create( "DLabel", self )
	self.RightMoney:SetText( "0" )

    self.LeftPointsIcon = vgui.Create( "DImage", self )
	self.LeftPointsIcon:SetImage( "icon16/ruby.png" )

    self.RightPointsIcon = vgui.Create( "DImage", self )
	self.RightPointsIcon:SetImage( "icon16/ruby.png" )

	self.LeftPointsLabel = vgui.Create("DLabel", self)
	self.LeftPointsLabel:SetText("Отдашь:")

	self.LeftPoints = vgui.Create( "DTextEntry", self )
	self.LeftPoints.OnLoseFocus = function( s )
		local points = tonumber(s:GetText()) or 0
		self.LeftPointsComission:SetText(math.Round(points*(1-PS.Config.Comission), 2))
		net.Start( "ItemStoreTradePoints" )
			net.WriteFloat(points)
		net.SendToServer()
	end

	self.LeftPointsComissionLabel = vgui.Create("DLabel", self)
	self.LeftPointsComissionLabel:SetText("Получит:")

	self.LeftPointsComission = vgui.Create( "DTextEntry", self )
	self.LeftPointsComission.OnLoseFocus = function( s )
		local points = tonumber(s:GetText()) or 0
		local points_orig = math.Round(points/(1-PS.Config.Comission), 2)
		self.LeftPoints:SetText(points_orig)
		net.Start( "ItemStoreTradePoints" )
			net.WriteFloat( points_orig )
		net.SendToServer()
	end

	self.RightPoints = vgui.Create( "DLabel", self )
	self.RightPoints:SetText( "0" )

	self.LeftReady = vgui.Create( "DCheckBoxLabel", self )
	self.LeftReady:SetText( 'Не готов' )
    self.LeftReady:SetTextColor(Color(255,0,0,255))
	self.LeftReady.OnChange = function( ready )
	    
	    if ready:GetChecked() then
	        self.LeftReady:SetTextColor(Color(0,255,0,255))
	        self.LeftReady:SetText('Готов')
	    else
	        self.LeftReady:SetTextColor(Color(255,0,0,255))
	        self.LeftReady:SetText('Не готов')
	    end
		net.Start( "ItemStoreReadyTrade" )
			net.WriteBit( ready:GetChecked() )
		net.SendToServer()
	end
	
	self.LeftDonat = vgui.Create( "DButton", self )
	self.LeftDonat:SetText('ДОНАТ')
	self.LeftDonat.DoClick = function()
	    if IsValid(self.FrameInv) then return end
        self.FrameInv = vgui.Create( "DFrame",  self)
        self.FrameInv:SetSize(200, 200)
        self.FrameInv:SetTitle('Донат инвентарь')
        self.FrameInv:Center()
     --   self.FrameInv:SetSkin('itemstore')
        
        self.ScrollInv = vgui.Create( "DScrollPanel", self.FrameInv )
        self.ScrollInv:Dock( FILL )
    	
    	for k,v in pairs(LocalPlayer().PS_Inventory) do
            self.ButtonInv = self.ScrollInv:Add( "DButton" )
            self.ButtonInv:Dock(TOP)
            self.ButtonInv:SetText(k)
            self.ButtonInv.DoClick = function()
                	
                net.Start('ItemStoreTradeDonate')
                net.WriteString(k)
                net.SendToServer()
                
                --PrintTable(LocalPlayer().PS_Inventory)
                
                self.LeftDonat:SetText(k)
                self.LeftDonat:SetEnabled(false)
                self.FrameInv:Remove()
            end
    	end
	end

	self.RightReady = vgui.Create( "DLabel", self )
	self.RightReady:SetText( itemstore.Translate( "not_ready" ) )
    self.RightReady:SetTextColor(Color(255,0,0,255))
	self.Accept = vgui.Create( "DButton", self )
	self.Accept:SetText( 'ПРИНЯТЬ' )
	self.Accept:SetFont( "DermaLarge" )
	self.Accept:SetDisabled( true )
	self.Accept.DoClick = function()
		net.Start( "ItemStoreAcceptTrade" ) 
		net.SendToServer()

		self:Remove()

		surface.PlaySound( "buttons/button9.wav" )
	end

	self.Chat = vgui.Create( "RichText", self )
	function self.Chat:Paint()
		draw.RoundedBox( 4, 0, 0, self:GetWide(), self:GetTall(), Color( 230, 230, 230 ) )
	end

	self.ChatEntry = vgui.Create( "DTextEntry", self )
	function self.ChatEntry:OnEnter()
		LocalPlayer().Trade:SendMessage( self:GetText() )

		self:SetText( "" )
		self:RequestFocus()
	end

	self.Inventory = vgui.Create( "ItemStoreContainerWindow" )
	self.Inventory:SetContainerID( LocalPlayer().InventoryID )
	self.Inventory:SetTitle( itemstore.Translate( "inventory" ) )
	self.Inventory:ShowCloseButton( false )
	self.Inventory:InvalidateLayout( true )
end

function PANEL:Think()
	self.BaseClass.Think( self )

	local x, y = self:GetPos()
	self.Inventory:SetPos( x + self:GetWide() / 2 - self.Inventory:GetWide() / 2, y + self:GetTall() + 5 )
end

function PANEL:ChatMessage( pl, message )
	if pl == LocalPlayer() then
		self.Chat:InsertColorChange( 255, 0, 0, 255 )
	elseif pl == nil then
	    self.Chat:InsertColorChange( 0, 255, 0, 255 )
	else
		self.Chat:InsertColorChange( 0, 0, 255, 255 )
	end
    
    if pl:IsPlayer() then
	    self.Chat:AppendText( pl:Name() )
	end
	if pl:IsPlayer() then
	    self.Chat:InsertColorChange( 100, 100, 100, 255 )
	    self.Chat:AppendText( ": " .. message .. "\n" )
	else
	   self.Chat:InsertColorChange( 236, 113, 73, 255 )
	   self.Chat:AppendText( "[Магазин] > " .. message .. "\n" ) 
	end
end

function PANEL:Refresh()
	local trade = LocalPlayer().Trade

	if trade then
		local ourside = LocalPlayer() == trade.Left.Player and trade.Left or trade.Right
		local otherside = LocalPlayer() == trade.Right.Player and trade.Left or trade.Right

		self:SetTitle( itemstore.Translate( "trading_with", otherside.Player:Name() ) )

		self.LeftContainer:SetContainerID( ourside.Container:GetID() )
		self.RightContainer:SetContainerID( otherside.Container:GetID() )

		self.LeftMoney:SetText( ourside.Ready and DarkRP.formatMoney(ourside.Money) or ourside.Money )
		self.LeftMoney:SetDisabled(ourside.Ready)

		self.RightMoney:SetText( DarkRP.formatMoney(otherside.Money) )
	
		self.LeftPoints:SetText( ourside.points )
		self.LeftPoints:SetDisabled(ourside.Ready)

		self.LeftPointsComission:SetText(math.Round(ourside.points*(1-PS.Config.Comission), 2))
		self.LeftPointsComission:SetDisabled(ourside.Ready)

		self.RightPoints:SetText( math.Round(otherside.points*(1-PS.Config.Comission), 2) )
	
		self.LeftReady:SetChecked( ourside.Ready )
		self.RightReady:SetText( otherside.Ready and itemstore.Translate( "ready" )
			or itemstore.Translate( "not_ready" ) )

		if ourside.Ready then
		    self.LeftReady:SetTextColor(Color(0,255,0,255))
		    self.LeftReady:SetText( 'Готов' )
	    else
	        self.LeftReady:SetTextColor(Color(255,0,0,255))
	        self.LeftReady:SetText( 'Не готов' )
	    end
		
		if otherside.Ready then
		    self.RightReady:SetTextColor(Color(0,255,0,255))
	    else
	        self.RightReady:SetTextColor(Color(255,0,0,255))
	    end

		self.Accept:SetDisabled( not ( ourside.Ready and otherside.Ready ) )
	end
end

-- it's me, i'm coding hitler. this is the grave of so many brave
-- functions that went to war and died on my behalf.
function PANEL:PerformLayout(w, h)
	self.BaseClass.PerformLayout( self )

	self.LeftContainer:SetPos( 5, 33 )
	self.LeftContainer:SizeToContents()
	local left_w, left_h = self.LeftContainer:GetSize()

	self.RightContainer:SetPos( 5 + left_w + 24, 33 )
	self.RightContainer:SizeToContents()
	local right_w, right_h = self.RightContainer:GetSize()

	self.LeftMoneyIcon:SetPos( 5, 33 + left_h + 5 )
	self.LeftMoneyIcon:SetSize( 16, 16 )

	self.LeftMoney:SetPos( 25, 33 + left_h + 5 )
	self.LeftMoney:SetSize( left_w - 115, 16 )

	self.RightMoneyIcon:SetPos( 5 + right_w + 24, 33 + right_h + 5 )
	self.RightMoneyIcon:SetSize( 16, 16 )

	self.RightMoney:SetPos( 5 + left_w + 24 + 5 + 16 + 5, 33 + right_h + 5 )
	self.RightMoney:SetSize( right_w - 5 - 16 - 5, 16 )

    self.LeftPointsIcon:SetPos( 95, 33 + left_h + 5 )
	self.LeftPointsIcon:SetSize( 16, 16 )

	self.LeftPointsLabel:SetPos(115, 33+left_h+5)
	self.LeftPointsLabel:SetSize(left_w-115, 16)

	self.LeftPoints:SetPos( 115, 33 + left_h + 5 +16+5)
	self.LeftPoints:SetSize( left_w - 115, 16 )

    self.LeftPointsComissionLabel:SetPos(115, 33+left_h+5+(16+5)*2)
	self.LeftPointsComissionLabel:SetSize(left_w-115, 16)

	self.LeftPointsComission:SetPos( 115, 33 + left_h + 5 +(16+5)*3)
	self.LeftPointsComission:SetSize( left_w - 115, 16 )

	self.RightPointsIcon:SetPos( 5 + right_w + 100, 33 + right_h + 5 )
	self.RightPointsIcon:SetSize( 16, 16 )

	self.RightPoints:SetPos( 5 + left_w + 100 + 5 + 16 + 5, 33 + right_h + 5 )
	self.RightPoints:SetSize( right_w - 5 - 16 - 5, 16 )

	self.LeftReady:SetPos( 5, 33 + left_h + 5 + (16+5)*3)
	self.LeftReady:SizeToContents()
	
	self.LeftDonat:SetPos( 5, 33 + right_h + 5 + (16+5))
    self.LeftDonat:SetSize(20+left_w-115, 25)

	self.RightReady:SetPos( 5 + left_w + 24, 33 + right_h + 5 + 16 + 5 )

	self.RightReady:SizeToContents()

	self.Accept:SetPos( 5, h-37 )
	self.Accept:SetSize( 390, 37 )

	self.Chat:SetPos( 400, 27 )
	self.Chat:SetSize( 195, 220 )

	self.ChatEntry:SetPos( 400, 250 )
	self.ChatEntry:SetSize( 195, 25 )

	self:SetSize( 600, 280 )
end

function PANEL:OnRemove()
	net.Start( "ItemStoreCloseTrade" ) net.SendToServer()
	self.Inventory:Close()
end

vgui.Register( "ItemStoreTrade", PANEL, "DFrame" )

--addons/module_logs/lua/plogs_hooks/darkrp.lua:
-- Hit
plogs.Register('Hits', true, Color(51, 128, 255))

plogs.AddHook('Hits', 'OnHitPlaced', function(pTarget, pRequester)
    if not IsValid(pRequester) then return end
	plogs.PlayerLog(pRequester, 'Hits', pRequester:NameID() .. '  заказал убийство ' .. pTarget:NameID(), {
		['Заказчик: Ник'] = pRequester:LogsName(),
		['Заказчик: SteamID'] = pRequester:LogsSteamID(),
		['Цель: Ник'] = pTarget:LogsName(),
		['Цель: SteamID'] = pTarget:LogsSteamID(),
	})
end)

plogs.AddHook('Hits', 'OnHitDeleted', function(pRequester, pTarget, REASON, pHitman)
	if REASON == HIT_COMPLETE then
		if not IsValid(pRequester) then 
			plogs.PlayerLog(pHitman, 'Hits', pHitman:NameID() .. ' выполнил заказ на ' .. pTarget:NameID() .. ' ( Случайный заказ )', {
				['Убийца: Ник'] = pHitman:LogsName(),
				['Убийца: SteamID']	= pHitman:LogsSteamID(),
				['Цель: Ник'] = pTarget:LogsName(),
				['Цель: SteamID'] = pTarget:LogsSteamID(),
			})
			return
		end

		plogs.PlayerLog(pHitman, 'Hits', pHitman:NameID() .. ' выполнил заказ на ' .. pTarget:NameID() .. '  от ' .. pRequester:NameID(), {
			['Убийца: Ник'] 		= pHitman:LogsName(),
			['Убийца: SteamID']		= pHitman:LogsSteamID(),
			['Заказчик: Ник'] 		= pRequester:LogsName(),
			['Заказчик: SteamID']	= pRequester:LogsSteamID(),
			['Цель: Ник'] 		= pTarget:LogsName(),
			['Цель: SteamID']		= pTarget:LogsSteamID(),
		})

	end
end)

-- Theft

-- Names
plogs.Register('Names', true, Color(51, 128, 255))

plogs.AddHook('Names', 'onPlayerChangedName', function(pl, old, new)
	if IsValid(pl) and (old ~= nil) then
		plogs.PlayerLog(pl, 'Names', pl:NameID() .. ' сменил имя на ' .. new ..  ' с ' .. old, {
			['Ник'] 	= pl:LogsName(),
			['SteamID']	= pl:LogsSteamID()
		})
	end
end)


-- Job changes
plogs.Register('Jobs', true, Color(51, 128, 255))

plogs.AddHook('Jobs', 'OnPlayerChangedTeam', function(pl, old, new)
	if IsValid(pl) then
		plogs.PlayerLog(pl, 'Jobs', pl:NameID() .. ' сменил профессию на ' .. team.GetName(new) ..  ' с ' .. team.GetName(old), {
			['Ник'] 	= pl:LogsName(),
			['SteamID']	= pl:LogsSteamID()
		})
	end
end)


-- Demotions
plogs.Register('Demotions', true, Color(51, 128, 255))

plogs.AddHook('Demotions', 'onVoteStarted', function(vote)
	if vote.votetype ~= 'demote' then return end

	plogs.PlayerLog(vote.info.source, 'Demotions', vote.info.source:NameID()..' начал увольнение '..vote.target:NameID()..' по причине "'..vote.info.reason..'"', {
		['Цель: Ник'] = vote.target:LogsName(),
		['Цель: SteamID'] = vote.target:LogsSteamID(),
		['Увольняющий: Ник'] = vote.info.source:LogsName(),
		['Увольняющий: SteamID'] = vote.info.source:LogsSteamID(),
	})
end)

plogs.AddHook('Demotions', 'onPlayerDemoted', function(demoter, demotee, reason)
	if IsValid(demoter) and IsValid(demotee) then
		plogs.PlayerLog(demoter, 'Demotions', demoter:NameID() .. ' уволил с помощью голосования ' .. demotee:NameID() ..  ' по причине "' .. reason .. '"', {
			['Цель: Ник'] = demotee:LogsName(),
			['Цель: SteamID'] = demotee:LogsSteamID(),
			['Уволивший: Ник'] = demoter:LogsName(),
			['Уволивший: SteamID'] = demoter:LogsSteamID(),
		})
	end
end)

plogs.AddHook('Demotions', 'chiefDemote', function(ply, victim, reason)
	local copy = {
		['Уволивший: Ник'] = ply:LogsName(),
		['Уволивший: SteamID'] = ply:LogsSteamID(),
		['Подчиненный: Ник'] = victim:LogsName(),
		['Подчиненный: SteamID'] = victim:LogsSteamID(),
		['Причина'] = reason,
	}

	local str = string.format('%s уволил подчиненного %s по причине %q', ply:NameID(), victim:NameID(), reason)

	plogs.PlayerLog(ply, 'Demotions', str, copy)
end)


-- Police logs
plogs.Register('Police', true, Color(51, 128, 255))

plogs.AddHook('Police', 'playerArrested', function(target, time, officer)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Police', officer:NameID() .. ' арестовал ' .. target:NameID(), {
			['Преступник: Ник'] 	= target:LogsName(),
			['Преступник: SteamID']	= target:LogsSteamID(),
			['Арестовавший: Ник'] 	= officer:LogsName(),
			['Арестовавший: SteamID']	= officer:LogsSteamID(),
		}, {
			{
				name = 'Арестовавший',
				pos = officer:GetPos(),
				ang = officer:GetAngles(),
			},
			{
				name = 'Арестованный',
				pos = target:GetPos(),
				ang = target:GetAngles(),
			},
		})
	end
end)

plogs.AddHook('Police', 'playerUnArrested', function(target, officer)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Police', officer:NameID() .. ' разарестовал ' .. target:NameID(), {
			['Преступник: Ник'] 	= target:LogsName(),
			['Преступник: SteamID']	= target:LogsSteamID(),
			['Полицейский: Ник'] 	= officer:LogsName(),
			['Полицейский: SteamID']	= officer:LogsSteamID(),
		}, {
			{
				name = 'Разарестовавший',
				pos = officer:GetPos(),
				ang = officer:GetAngles(),
			},
			{
				name = 'Разарестованный',
				pos = target:GetPos(),
				ang = target:GetAngles(),
			},
		})
	else
		plogs.Log('Police', target:NameID() .. ' был выпущен из тюрьмы.', {
			['Ник'] 	= target:LogsName(),
			['SteamID']	= target:LogsSteamID(),
		})
	end
end)

plogs.AddHook('Police', 'playerWanted', function(target, officer, reason)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Police', officer:NameID() .. ' подал в розыск ' .. target:NameID() .. ' по причине "' .. reason .. '"', {
			['Преступник: Ник'] 	= target:LogsName(),
			['Преступник: SteamID']	= target:LogsSteamID(),
			['Полицейский: Ник'] 	= officer:LogsName(),
			['Полицейский: SteamID']	= officer:LogsSteamID(),
		})
	end
end)

plogs.AddHook('Police', 'playerUnWanted', function(target, officer)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Police', officer:NameID() .. ' снял розыск с ' .. target:NameID(), {
			['Преступник: Ник'] 	= target:LogsName(),
			['Преступник: SteamID']	= target:LogsSteamID(),
			['Полицейский: Ник'] 	= officer:LogsName(),
			['Полицейский: SteamID']	= officer:LogsSteamID(),
		})
	else
		plogs.Log('Police', target:NameID() .. ' больше не разыскивается', {
			['Ник'] 	= target:LogsName(),
			['SteamID']	= target:LogsSteamID(),
		})
	end
end)

plogs.AddHook('Police', 'playerWarranted', function(target, officer, reason)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Police', officer:NameID() .. ' получил ордер на ' .. target:NameID() .. ' по причине "' .. reason .. '"', {
			['Цель: Ник'] 	= target:LogsName(),
			['Цель: SteamID']	= target:LogsSteamID(),
			['Полицейский: Ник'] 	= officer:LogsName(),
			['Полицейский: SteamID']	= officer:LogsSteamID(),
		})
	end
end)

plogs.AddHook('Police', 'playerUnWarranted', function(target, officer)
	if IsValid(officer) then
		plogs.PlayerLog(officer, 'Police', 'Ордер на обыск '..target:NameID()..' больше не действителен', {
			['Ник'] 	= target:LogsName(),
			['SteamID']	= target:LogsSteamID(),
		})
	else
		plogs.Log('Police', 'Ордер на обыск '..target:NameID()..' больше не действителен', {
			['Ник'] 	= target:LogsName(),
			['SteamID']	= target:LogsSteamID(),
		})
	end
end)

plogs.AddHook('Police', 'onDoorRamUsed', function(success, ply, trace)
	if not success then return end
	local ent = trace.Entity
	if not IsValid(ent) then return end

	local ownerStr = IsValid(ent:CPPIGetOwner()) and (' (%s)'):format(ent:CPPIGetOwner():NameID()) or ''

	local entName = ent:GetClass() == 'prop_physics' and ent:GetModel() or tostring(ent)
	local positions = {
		{
			name = 'Игрок',
			pos = ply:GetPos(),
			ang = ply:GetAngles(),
		},
		{
			name = 'Выбитый предмет',
			pos = ent:GetPos(),
			ang = ent:GetAngles(),
			model = ent:GetModel(),
		}
	}

	plogs.PlayerLog(ply, 'Police', ply:NameID()..' выбил тараном '..entName..ownerStr, {
		['Ник'] = ply:LogsName(),
		['SteamID'] = ply:LogsSteamID(),
	}, positions)
end)


-- Purchases
plogs.Register('Purchases', false)

plogs.AddHook('Purchases', 'playerBoughtCustomEntity', function(pl, ent_tbl, ent)
	plogs.PlayerLog(pl, 'Purchases', pl:NameID() .. ' купил ' .. ent_tbl.name .. ' за $' .. ent_tbl.price, {
		['Ник'] 	= pl:LogsName(),
		['SteamID']	= pl:LogsSteamID()
	}, {
		{
			name = 'Игрок',
			pos = pl:GetPos(),
			ang = pl:GetAngles(),
		},
		{
			name = 'Предмет',
			pos = ent:GetPos(),
			ang = ent:GetAngles(),
			model = ent:GetModel(),
		}
	})
end)


-- Adverts
plogs.Register('Advert', false)

plogs.AddHook('Advert', 'onChatCommand', function(pl, cmd, arg_str)
	if (cmd == 'advert') then
		plogs.PlayerLog(pl, 'Advert', pl:NameID() .. ' отправил рекламу: "' .. arg_str .. '"', {
			['Ник'] = pl:LogsName(),
			['SteamID'] = pl:LogsSteamID()
		})
	end
end)

plogs.AddHook('Advert', 'onChatCommand', function(pl, cmd, arg_str)
	if (cmd == 'anon') then
		plogs.PlayerLog(pl, 'Advert', pl:NameID() .. ' отправил анонимное сообщение: "' .. arg_str .. '"', {
			['Ник'] = pl:LogsName(),
			['SteamID'] = pl:LogsSteamID()
		})
	end
end)

-- Lockpicks
plogs.Register('Lockpick', false)

plogs.AddHook('Lockpick', 'lockpickStarted', function(pl, ent)
	plogs.PlayerLog(pl, 'Lockpick', pl:NameID() .. ' начал взлом', {
		['Ник'] = pl:LogsName(),
		['SteamID'] = pl:LogsSteamID()
	}, {
		{
			name = 'Игрок',
			pos = pl:GetPos(),
			ang = pl:GetAngles(),
		},
		{
			name = 'Дверь',
			pos = ent:GetPos(),
			ang = ent:GetAngles(),
			model = ent:GetModel(),
		},
	})
end)

plogs.AddHook('Lockpick', 'onLockpickCompleted', function(ply, success, ent)
	if not success then return end
    if (ent:DoorGetOwner() == nil) then
        plogs.PlayerLog(ply, 'Lockpick', ply:NameID() .. ' взломал серверную дверь', {
            ['Взломщик: Ник'] = ply:LogsName(),
            ['Взломщик: SteamID'] = ply:LogsSteamID(),
        }, {
			{
				name = 'Игрок',
				pos = ply:GetPos(),
				ang = ply:GetAngles(),
			},
			{
				name = 'Дверь',
				pos = ent:GetPos(),
				ang = ent:GetAngles(),
				model = ent:GetModel(),
			},
		})
    else
        plogs.PlayerLog(ply, 'Lockpick', ply:NameID() .. ' взломал дверь ' .. ent:DoorGetOwner():NameID(), {
            ['Взломщик: Ник'] = ply:LogsName(),
            ['Взломщик: SteamID'] = ply:LogsSteamID(),
            ['Владелец: Ник'] = ent:DoorGetOwner():LogsName(),
            ['Владелец: SteamID'] = ent:DoorGetOwner():LogsSteamID(),
        }, {
			{
				name = 'Игрок',
				pos = ply:GetPos(),
				ang = ply:GetAngles(),
			},
			{
				name = 'Дверь',
				pos = ent:GetPos(),
				ang = ent:GetAngles(),
				model = ent:GetModel(),
			},
		})
    end
end)

-- Door buys
plogs.Register('Doors', false)

plogs.AddHook('Doors', 'playerBoughtDoor', function(pl, ent, cost)
	plogs.PlayerLog(pl, 'Doors', pl:NameID() .. ' купил дверь за $' .. cost, {
		['Ник'] 	= pl:LogsName(),
		['SteamID']	= pl:LogsSteamID()
	}, {
		{
			name = 'Игрок',
			pos = pl:GetPos(),
			ang = pl:GetAngles(),
		},
		{
			name = 'Дверь',
			pos = ent:GetPos(),
			ang = ent:GetAngles(),
			model = ent:GetModel(),
		},
	})
end)

plogs.AddHook('Doors', 'playerSellDoor', function(pl, ent)
	plogs.PlayerLog(pl, 'Doors', pl:NameID() .. ' продал дверь', {
		['Ник'] 	= pl:LogsName(),
		['SteamID']	= pl:LogsSteamID()
	}, {
		{
			name = 'Игрок',
			pos = pl:GetPos(),
			ang = pl:GetAngles(),
		},
		{
			name = 'Дверь',
			pos = ent:GetPos(),
			ang = ent:GetAngles(),
			model = ent:GetModel(),
		},
	})
end)

timer.Simple(0, function()
	DarkRP.log = wlib.func.blank
end)