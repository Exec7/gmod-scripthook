--Stealed clientside server code by exechack.cc
--Hostname: Ψ UkraineRP #1 ◈ Оновлення◈ Набiр ◈ M9K - Part 5/10 - 06/04/2025


--PATH addons/dash/lua/dash/extensions/client/surface.lua:
do
	local q = {{},{},{},{}}
	local q1, q2, q3, q4 = q[1], q[2], q[3], q[4]
	local drawpoly = surface.DrawPoly
	function surface.DrawQuad(x1, y1, x2, y2, x3, y3, x4, y4)
		q1.x, q1.y = x1, y1
		q2.x, q2.y = x2, y2
		q3.x, q3.y = x3, y3
		q4.x, q4.y = x4, y4
		drawpoly(q)
	end

	local quv = {{},{},{},{}}
	local quv1, quv2, quv3, quv4 = quv[1], quv[2], quv[3], quv[4]
	local math_min, math_max = math.min, math.max
	function surface.DrawQuadUV(x1, y1, x2, y2, x3, y3, x4, y4)
		local xmin, ymin = math_max, math_max
		local xmax, ymax = math_min, math_min

		xmin = x1
		if x2 < xmin then xmin = x2 end
		if x3 < xmin then xmin = x3 end
		if x4 < xmin then xmin = x4 end

		ymin = y1
		if y2 < ymin then ymin = y2 end
		if y3 < ymin then ymin = y3 end
		if y4 < ymin then ymin = y4 end

		xmax = x1
		if x2 > xmax then xmax = x2 end
		if x3 > xmax then xmax = x3 end
		if x4 > xmax then xmax = x4 end

		ymax = y1
		if y2 > ymax then ymax = y2 end
		if y3 > ymax then ymax = y3 end
		if y4 > ymax then ymax = y4 end

		local dy = ymax - ymin
		local dx = xmax - xmin

		quv1.u, quv1.v = (x1-xmin)/dx, (y1-ymin)/dy
		quv2.u, quv2.v = (x2-xmin)/dx, (y2-ymin)/dy
		quv3.u, quv3.v = (x3-xmin)/dx, (y3-ymin)/dy
		quv4.u, quv4.v = (x4-xmin)/dx, (y4-ymin)/dy

		quv1.x, quv1.y = x1, y1
		quv2.x, quv2.y = x2, y2
		quv3.x, quv3.y = x3, y3
		quv4.x, quv4.y = x4, y4

		drawpoly(quv)
	end

	local drawline = surface.DrawLine
 	function surface.DrawOutlinedQuad(x1, y1, x2, y2, x3, y3, x4, y4)
 		drawline(x1,y1, x2,y2)
 		drawline(x2,y2, x3,y3)
 		drawline(x3,y3, x4,y4)
 		drawline(x4,y4, x1,y1)
	end
end

do
	local cos, sin = math.cos, math.sin
	local ang2rad = 3.141592653589/180
	local drawquad = surface.DrawQuad
	function surface.DrawArc(_x, _y, r1, r2, aStart, aFinish, steps)
		aStart, aFinish = aStart*ang2rad, aFinish*ang2rad
		local step = ((aFinish - aStart) / steps)
		local c = steps

		local a, c1, s1, c2, s2

		c2, s2 = cos(aStart), sin(aStart)
		for _a = 0, steps - 1 do
			a = _a*step + aStart
			c1, s1 = c2, s2
			c2, s2 = cos(a+step), sin(a+step)

			drawquad( _x+c1*r1, _y+s1*r1,
						 _x+c1*r2, _y+s1*r2,
						 _x+c2*r2, _y+s2*r2,
						 _x+c2*r1, _y+s2*r1 )
			c = c - 1
			if c < 0 then break end
		end
	end
end

-- Begin the moonshit
-- DRAW QUAD
do
	local cos, sin = math.cos, math.sin
	local ang2rad = 3.141592653589/180
	local drawline = surface.DrawLine
	function surface.DrawArcOutline(_x, _y, r1, r2, aStart, aFinish, steps)
		aStart, aFinish = aStart*ang2rad, aFinish*ang2rad
		local step = ((aFinish - aStart) / steps)
		local c = steps

		local a, c1, s1, c2, s2

		c2, s2 = cos(aStart), sin(aStart)
		drawline(_x+c2*r1, _y+s2*r1, _x+c2*r2, _y+s2*r2)
		for _a = 0, steps - 1 do
			a = _a*step + aStart
			c1, s1 = c2, s2
			c2, s2 = cos(a+step), sin(a+step)


			drawline( _x+c1*r2, _y+s1*r2,
												_x+c2*r2, _y+s2*r2 )
			drawline( _x+c1*r1, _y+s1*r1,
												_x+c2*r1, _y+s2*r1 )
			c = c - 1
			if c < 0 then break end
		end
		drawline(_x+c2*r1, _y+s2*r1, _x+c2*r2, _y+s2*r2)
	end
end

-- GetTextSize caching
do
	local SetFont 		= surface.SetFont
	local GetTextSize 	= surface.GetTextSize

	local font = 'TargetID'
	local cache = setmetatable({}, {
		__mode = 'k'
	})

	timer.Create('surface.ClearFontCache', 1800, 0, function()
		for i = 1, #cache do
			cache[i] = nil
		end
	end)

	function surface.SetFont(_font)
		font = _font
		return SetFont(_font)
	end

	function surface.GetTextSize(text)
		if (not cache[font]) then
			cache[font] = {}
		end
		if (not cache[font][text]) then
			local w, h = GetTextSize(text)
			cache[font][text] = {
				w = w,
				h = h
			}
			return w, h
		end
		return cache[font][text].w, cache[font][text].h
	end
end
--PATH addons/__________tperson/lua/3tcore/lib/sh_lib.lua:
function TPerson.OnPlayerSwitchWeapons(ply, oldWeapon, newWeapon)
	if CLIENT and ply ~= LocalPlayer() then return end
	if newWeapon then
		if newWeapon.DrawCrossHair ~= nil then
			newWeapon.DrawCrossHair = false
		elseif newWeapon.DrawCrosshair ~= nil then
			newWeapon.DrawCrosshair = false
		end

		if newWeapon.CrosshairEnabled ~= nil then newWeapon.CrosshairEnabled = false end
	end
end
--PATH addons/shaccessorysystem/lua/accessory/cl_editor.lua:
local function VectorOffset(pos, offset, ang)
	local newpos = Vector()
	newpos:Set(pos + ang:Forward() * offset.x + ang:Right() * offset.y + ang:Up() * offset.z)

	return newpos
end

local function AngleOffset(ang, offset)
	local newang = Angle()
	newang:Set(ang)
	newang:RotateAroundAxis(newang:Up(), offset.y)
	newang:RotateAroundAxis(newang:Right(), offset.p)
	newang:RotateAroundAxis(newang:Forward(), offset.r)

	return newang
end

function SH_ACC:ShowEditor()
	if (!LocalPlayer():IsAdmin()) then
		return end

	if (IsValid(_SH_ACC_EDITOR)) then
		if (IsValid(_SH_ACC_EDITOR.m_PreviewModel)) then
			_SH_ACC_EDITOR.m_PreviewModel:Remove()
		end

		_SH_ACC_EDITOR:Remove()
	end

	local ang = Angle(0, -90, 0)
	local dis = 90
	local mlast_x = ScrW() * 0.5
	local mlast_y = ScrH() * 0.5

	local L, C = self._L, self._C
	local scale = math.Clamp(ScrH() / 1080, 0.7, 1)

	local frame = self:MakeFrame("Accessory Creator")
	frame:MakePopup()
	frame:SetSize(400 * scale, 600 * scale)
	frame:AlignLeft(ScrW() * 0.5 - frame:GetWide() * 1.75)
	frame:CenterVertical()
	frame.m_PreviewModel = NULL
	frame.Think = function(me)
		local mx, my = gui.MousePos()
		local diffx, diffy = (mx - mlast_x), (my - mlast_y)

		if (input.IsMouseDown(MOUSE_RIGHT) and !(diffx > 40 or diffy > 40)) then // right mouse press without sudden jumps
			if (input.IsKeyDown(KEY_E)) then
				dis = math.Clamp(dis + diffy, 10, 500)
			else
				ang = ang + Angle(diffy * 0.5, diffx * 0.5, 0)
			end
		end

		mlast_x, mlast_y = mx, my
	end
	frame.OnClose = function(me)
		if (IsValid(me.m_PreviewModel)) then
			me.m_PreviewModel:Remove()
		end

		hook.Remove("PostPlayerDraw", "SH_ACC.Editor")
		hook.Remove("CalcView", "SH_ACC.Editor")
		hook.Remove("ShouldDrawLocalPlayer", "SH_ACC.Editor")
	end
	_SH_ACC_EDITOR = frame

		local th = 48 * scale
		local m = th * 0.25
		local m5 = m * 0.5

		local body = vgui.Create("DScrollPanel", frame)
		self:PaintScroll(body)
		body:DockMargin(m, m, m, m)
		body:GetCanvas():DockPadding(m5, m5, m5, m5)
		body:Dock(FILL)
		body:GetCanvas().Paint = function(me, w, h)
			draw.RoundedBox(4, 0, 0, w, h, C"inbg")
		end

			local lbl = self:Label("ID (must be unique, A-Z 0-9 characters only)", "SH_ACC.LargeB", C"text", body)
			lbl:Dock(TOP)
			lbl:DockMargin(0, 0, 0, m5)

				local id = self:TextEntry(body)
				id:SetText("accessory")
				id:Dock(TOP)

			local lbl = self:Label("Name", "SH_ACC.LargeB", C"text", body)
			lbl:Dock(TOP)
			lbl:DockMargin(0, m5, 0, m5)

				local name = self:TextEntry(body)
				name:SetText("New Accessory")
				name:Dock(TOP)

			local lbl = self:Label("Slots (separate with spaces)", "SH_ACC.LargeB", C"text", body)
			lbl:Dock(TOP)
			lbl:DockMargin(0, m5, 0, 0)

			local lookup = {
				head = "SH_SLOT_HEAD",
				eyes = "SH_SLOT_EYES",
				mouth = "SH_SLOT_MOUTH",
				back = "SH_SLOT_BACK",
				neck = "SH_SLOT_NECK",
			}

			local lbl = self:Label("Valid: head, eyes, mouth, back, neck", "SH_ACC.MediumB", C"text", body)
			lbl:Dock(TOP)
			lbl:DockMargin(0, 0, 0, m5)

				local slots = self:TextEntry(body)
				slots:SetText("head")
				slots:Dock(TOP)

			local lbl = self:Label("Price", "SH_ACC.LargeB", C"text", body)
			lbl:Dock(TOP)
			lbl:DockMargin(0, m5, 0, m5)

				local price = self:TextEntry(body)
				price:SetText(5000)
				price:Dock(TOP)

			local lbl = self:Label("Model", "SH_ACC.LargeB", C"text", body)
			lbl:Dock(TOP)
			lbl:DockMargin(0, m5, 0, m5)

				local mdl = self:TextEntry(body)
				mdl:Dock(TOP)
				mdl.OnChange = function(me)
					if (IsValid(frame.m_PreviewModel)) then
						frame.m_PreviewModel:Remove()
					end

					local val = me:GetValue():Trim()
					if (file.Exists(val, "GAME")) then
						frame.m_PreviewModel = ClientsideModel(val)
						if (IsValid(frame.m_PreviewModel)) then
							frame.m_PreviewModel:SetNoDraw(true)
						end
					end
				end

			local lbl = self:Label("Bone", "SH_ACC.LargeB", C"text", body)
			lbl:Dock(TOP)
			lbl:DockMargin(0, m5, 0, m5)

				local bone = self:TextEntry(body)
				bone:SetText("ValveBiped.Bip01_Head1")
				bone:Dock(TOP)

			local sliders = {}
			local function addComponent(name)
				for _, c in ipairs {"X", "Y", "Z"} do
					local lbl = self:Label(name .. " " .. c, "SH_ACC.LargeB", C"text", body)
					lbl:Dock(TOP)
					lbl:DockMargin(0, m5, 0, m5)

						local slider = self:NumSlider(body)
						slider.Label:SetVisible(true) -- precise sliding
						slider:SetMinMax(-360, 360)
						slider:Dock(TOP)
						slider.OnValueChanged = function(me, val)
							sliders[name .. c] = val
						end
						slider:SetValue(def)
				end
			end

			addComponent("Position")
			addComponent("Angle")

			local lbl = self:Label("Scale", "SH_ACC.LargeB", C"text", body)
			lbl:Dock(TOP)
			lbl:DockMargin(0, m5, 0, m5)

				local slider = self:NumSlider(body)
				slider.Label:SetVisible(true) -- precise sliding
				slider:SetMinMax(0.01, 5)
				slider:Dock(TOP)
				slider.OnValueChanged = function(me, val)
					sliders.Scale = val
				end
				slider:SetValue(1)

			local export = vgui.Create("DButton", frame)
			export:SetText("Export")
			export:SetColor(C"text")
			export:SetFont("SH_ACC.Medium")
			export:Dock(BOTTOM)
			export:DockMargin(m, 0, m, m)
			export.Paint = function(me, w, h)
				draw.RoundedBox(4, 0, 0, w, h, C"inbg")

				if (me.Hovered) then
					surface.SetDrawColor(C"hover")
					surface.DrawRect(0, 0, w, h)
				end

				if (me:IsDown()) then
					surface.SetDrawColor(C"hover")
					surface.DrawRect(0, 0, w, h)
				end
			end
			export.DoClick = function()
				if (gui.IsGameUIVisible() and !gui.IsConsoleVisible()) then
					self:ShowConfirmMenu("Export", "SH Accessories: Enable your console to see the output.", function() end)
				end

				gui.ActivateGameUI()

				--
				local tx = Color(52, 152, 219)
				MsgC(tx, "\n============================================\n")
				MsgC(tx, "======= SH Accessories - Acc Export ========\n")
				MsgC(tx, "============================================\n\n")

				-- prep and validate
				local sl = {}
				for _, v in pairs (string.Explode(" ", slots:GetValue())) do
					if (lookup[v]) then
						table.insert(sl, lookup[v])
					end
				end

				if (id:GetValue():Trim() == "") then
					MsgC(Color(231, 76, 60), "!! ERROR! ID can't be empty.\n")
					return
				end

				if (mdl:GetValue():Trim() == "") then
					MsgC(Color(231, 76, 60), "!! ERROR! Model can't be empty.\n")
					return
				end

				if (bone:GetValue():Trim() == "") then
					MsgC(Color(231, 76, 60), "!! ERROR! Bone can't be empty.\n")
					return
				end

				if (#sl == 0) then
					MsgC(Color(231, 76, 60), "!! ERROR! No valid slots defined.\n")
					return
				end

				-- output the shit
				local tx = Color(241, 196, 15)
				MsgC(tx, "!! Here is the output of the item to be copied into accessory_list.lua (under CUSTOM ACCESSORIES!)\n\n")

				local tx = color_white
				MsgC(tx, string.format([[local a = New("%s", {name = "%s", price = %d, slot = %s, mdl = "%s"})%s]] .. "\n\n",
					SQLStr(id:GetValue(), true),
					SQLStr(name:GetValue(), true),
					math.max(tonumber(price:GetValue()) or 0, 0),
					table.concat(sl, " + "),
					SQLStr(mdl:GetValue(), true),
					(sliders.Scale ~= 1 and "\na.scale = " .. math.Round(sliders.Scale, 2) .. "\n" or "")
				))

				local tx = Color(241, 196, 15)
				MsgC(tx, "!! Now here is the offset output to be copied into accessory_offets.lua (under CUSTOM OFFSETS!)\n\n")

				local tx = color_white
				MsgC(tx, string.format([[Offset("%s", "%s", Vector(%0.3g, %0.3g, %0.3g), Angle(%0.3g, %0.3g, %0.3g))]] .. "\n\n",
					SQLStr(mdl:GetValue(), true),
					SQLStr(bone:GetValue(), true),
					sliders.PositionX, sliders.PositionY, sliders.PositionZ,
					sliders.AngleX, sliders.AngleY, sliders.AngleZ
				))
			end

	--
	hook.Add("PostPlayerDraw", "SH_ACC.Editor", function(ply)
		if (ply ~= LocalPlayer() or !IsValid(frame) or !IsValid(frame.m_PreviewModel)) then
			return end

		local mdl = frame.m_PreviewModel
		local boneid = ply:LookupBone(bone:GetValue())
		if (!boneid) then
			return end

		local bp, ba = ply:GetBonePosition(boneid)
		if (!bp) then
			return end

		-- Apply model specific bone offsets
		local offset2 = self:GetModelOffset(bone:GetValue(), ply)
		if (offset2) then
			if (offset2.pos) then
				bp = VectorOffset(bp, offset2.pos, ba)
			end

			if (offset2.ang) then
				ba = AngleOffset(ba, offset2.ang)
			end
		end

		local newpos = VectorOffset(bp, Vector(sliders.PositionX, sliders.PositionY, sliders.PositionZ), ba)
		local newang = AngleOffset(ba, Angle(sliders.AngleX, sliders.AngleY, sliders.AngleZ))

		mdl:SetModelScale(sliders.Scale)
		mdl:SetRenderOrigin(newpos)
		mdl:SetRenderAngles(newang)
		mdl:DrawModel()
	end)

	hook.Add("CalcView", "SH_ACC.Editor", function(pl, pos, angles, fov)
		local look_pos = pos
		local bone = pl:LookupBone("ValveBiped.Bip01_Head1")
		if (bone) then
			look_pos = pl:GetBonePosition(bone)
		end

		local view = {}
		view.origin = look_pos + ((pl:GetAngles() + ang):Forward() * dis)
		view.angles = (look_pos - view.origin):Angle()
		view.fov = fov

		return view
	end)

	hook.Add("ShouldDrawLocalPlayer", "SH_ACC.Editor", function(ply)
		return true
	end)
end

concommand.Add("sh_accessories_editor", function()
	SH_ACC:ShowEditor()
end)

--PATH addons/__main/lua/autorun/cl_falleffect.lua:
// Falling & Roll Effect for Climb SWEP2
CreateClientConVar("climbswep2_windsound", 1, true, false)
CreateClientConVar("climbswep2_falleffect_allweps", 0, true, false)
local PrevCurT = 0
local CurAngles = nil
local Rot = 0
local Random
local Snd
local Snd2
hook.Add("CreateMove", "ClimbFall", function(cmd)

    local Ply = LocalPlayer()
	if !Snd then

        Snd = CreateSound(Ply, Sound("player/heartbeat1.wav"))
        Snd:Play()
        Snd:ChangeVolume(0, 0)
        Snd:ChangePitch(100, 0)

        Snd2 = CreateSound(Ply, Sound("ambient/ambience/Wind_Light02_loop.wav"))
        Snd2:Play()
        Snd2:ChangeVolume(0, 0)

    end
    if !IsValid(Ply) or !IsValid(Ply:GetActiveWeapon()) then return
    elseif Ply:GetVelocity().z > -900 or (GetConVarNumber("climbswep2_falleffect_allweps") == 0 and Ply:GetActiveWeapon():GetClass() != "climb_swep2") or !Ply:Alive() or Ply:GetMoveType() != MOVETYPE_WALK then

        if PrevCurT > 0 then

            cmd:SetViewAngles(Angle(CurAngles.p, CurAngles.y, 0))
            CurAngles = nil
            Snd:ChangeVolume(0, 0)
            Snd:ChangePitch(100, 0)
            Snd2:ChangeVolume(0, 0)
			hook.Remove("RenderScreenspaceEffects", "ClimbFallBlur")
			PrevCurT = 0

        end		
        return

    end
    if PrevCurT == 0 then

        PrevCurT = CurTime()
        local function DrawEffect()
            --DrawMotionBlur(0.1, Time/5, 0.01)
            local Time = CurTime() - PrevCurT
            local Colour = {}
            Colour[ "$pp_colour_addr" ] = 0
            Colour[ "$pp_colour_addg" ] = 0
            Colour[ "$pp_colour_addb" ] = 0
            Colour[ "$pp_colour_brightness" ] = 0
            Colour[ "$pp_colour_contrast" ] = (1 - Time/7.5)
            Colour[ "$pp_colour_colour" ] = (1 - Time/7.5)
            Colour[ "$pp_colour_mulr" ] = 0
            Colour[ "$pp_colour_mulg" ] = 0
            Colour[ "$pp_colour_mulb" ] = 0
            DrawColorModify(Colour)
            DrawMotionBlur(math.Clamp(0.75-Time/100, 0.25, 1), math.Clamp(Time/10, 0, 0.75), 0.05)

        end
        hook.Add("RenderScreenspaceEffects", "ClimbFallBlur", DrawEffect)

    end

    if !IsValid(CurAngles) then CurAngles = cmd:GetViewAngles(); end
	

	
    local Time = (CurTime() - PrevCurT) * (8 + (CurTime() - PrevCurT) * 2)
    if Time/25 < 1 then Snd:ChangeVolume(math.Clamp(Time/25, 0, 1), 0) end
    if Time < 101 then Snd:ChangePitch(100 + Time, 0); if GetConVarNumber("climbswep2_windsound") == 1 then Snd2:ChangeVolume(Time/100, 0) else Snd2:ChangeVolume(0, 0) end end

    CurAngles.p = math.Round(CurAngles.p) < 75 and math.Round(CurAngles.p) + 0.5 or math.Round(CurAngles.p) - 0.5

    cmd:SetViewAngles(Angle(CurAngles.p, CurAngles.y + math.sin(Time) * 1.25, 0))

end)
--PATH addons/_drones/lua/dronesrewrite/render_screen.lua:
if CLIENT then
	--DRONES_REWRITE.RenderingScreen = false

	--hook.Add("ShouldDrawLocalPlayer", "dronesrewrite_renderscreendrawply", function(ply)
		--if DRONES_REWRITE.RenderingScreen then 
			--return true 
		--end
	--end)

	hook.Add("RenderScene", "dronesrewrite_renderscreen", function(pos, ang)
		local mdl = { }
		table.Add(mdl, ents.FindByClass("dronesrewrite_controller"))
		table.Add(mdl, ents.FindByClass("dronesrewrite_console"))

		for k, v in pairs(mdl) do
	        if LocalPlayer():GetAimVector():Dot((v:GetPos() - pos):GetNormal()) < 0.3 then continue end
	        if v:GetUp():Dot((v:GetPos() - pos):GetNormal()) > 0 then continue end

			if not v.Rt then continue end

			local drone = v:GetNWEntity("DronesRewriteDrone")
			if not drone:IsValid() then continue end

			local cam = drone:GetCamera()
			if not cam:IsValid() then continue end

			local pos = cam:GetPos()
			local ang = cam:GetAngles()
			local oldRT = render.GetRenderTarget()

			render.SetRenderTarget(v.Rt)

			render.Clear(0, 0, 0, 255)
			render.ClearDepth()
			render.ClearStencil()

			--DRONES_REWRITE.RenderingScreen = true
			render.RenderView({
				x = 0,
				y = 0,
				w = 1024,
				h = 1024,
				fov = 70,
				origin = pos,
				angles = ang,
				drawpostprocess = true,
				drawhud = false,
				drawmonitors = false,
				drawviewmodel = false,
			})
			--DRONES_REWRITE.RenderingScreen = false

			render.SetRenderTarget(oldRT)
		end
	end)
end

if SERVER then
	hook.Add("SetupPlayerVisibility", "dronesrewrite_renderscreendrawdrone", function(ply)
		for k, v in ipairs(ents.FindByClass("dronesrewrite_controller")) do
			if v.Drone and v.Drone:IsValid() then
				AddOriginToPVS(v.Drone:GetPos())
			end
		end

		for k, v in ipairs(ents.FindByClass("dronesrewrite_console")) do
			if v.SelectedDrone and v.SelectedDrone:IsValid() then
				AddOriginToPVS(v.SelectedDrone:GetPos())
			end
		end
	end)
end
--PATH addons/_drones/lua/dronesrewrite/stuff.lua:
game.AddDecal("DrrBigExpo", "stuff/decals/drrbigexp")

if SERVER then
	hook.Add("EntityTakeDamage", "dronesrewrite_dropplayer", function(ply, damage)
		if ply:IsPlayer() and damage:GetDamage() > 0 then
			local drone = ply:GetNWEntity("DronesRewriteDrone")

			if drone:IsValid() then
				drone:SetDriver(NULL)
			end
		end
	end)

	hook.Add("SetupPlayerVisibility", "dronesrewrite_droneview", function(ply)
		local drone = ply:GetNWEntity("DronesRewriteDrone")
		if drone:IsValid() then AddOriginToPVS(drone:GetPos()) end
	end)

	hook.Add("PlayerInitialSpawn", "dronesrewrite_precache", function(ply)
		net.Start("dronesrewrite_doprecache")
		net.Send(ply)
	end)
else
	surface.CreateFont("DronesRewrite_font1", { font = "Tahoma", size = 40, weight = 2000 })
	surface.CreateFont("DronesRewrite_font2", { font = "Tahoma", size = 12, weight = 2000 })
	surface.CreateFont("DronesRewrite_font3", { font = "Tahoma", size = 25, weight = 2000 })
	surface.CreateFont("DronesRewrite_font4", { font = "Tahoma", size = 18, weight = 1 })
	surface.CreateFont("DronesRewrite_font5", { font = "Lucida Console", size = 16, weight = 1 })
	surface.CreateFont("DronesRewrite_font6", { font = "Impact", size = 18, weight = 1 })

	surface.CreateFont("DronesRewrite_customfont1", { font = "Exo", size = 16, weight = 1 })
	surface.CreateFont("DronesRewrite_customfont1_1", { font = "Exo", size = 25, weight = 1 })

	surface.CreateFont("DronesRewrite_customfont2", { font = "Gnuolane RG", size = 25, weight = 1 })
	surface.CreateFont("DronesRewrite_customfont2_1", { font = "Gnuolane RG", size = 28, weight = 1 })

	surface.CreateFont("DronesRewrite_customfont1big", { font = "Exo", size = 100, weight = 1 })
	surface.CreateFont("DronesRewrite_customfont1big2", { font = "Exo", size = 60, weight = 1 })

	surface.CreateFont("DronesRewrite_font3_out", { font = "Tahoma", size = 30, weight = 1 })

	hook.Add("PlayerBindPress", "dronesrewrite_stopmenu", function(ply, bind, p)
		local drone = ply:GetNWEntity("DronesRewriteDrone")

		if drone:IsValid() then		
			local tools = {
				"phys_swap",
				"slot",
				"invnext",
				"invprev",
				"lastinv",
				"gmod_tool",
				"gmod_toolmode"
			}

			if p and (bind == "invnext" or bind == "invprev") then 
				if drone._SelectingWep == -1 then
					if bind == "invnext" then
						drone.selected = drone.selected + 1
					elseif bind == "invprev" then
						drone.selected = drone.selected - 1
					end
				else
					if bind == "invnext" then
						drone.selected = drone:GetNWInt("CurrentWeapon_sel") + 1
					elseif bind == "invprev" then
						drone.selected = drone:GetNWInt("CurrentWeapon_sel") - 1
					end

					net.Start("dronesrewrite_requestweapons")
						net.WriteEntity(drone)
						net.WriteString("dronesrewrite_openselectmenu")
						net.WriteBit(false)
					net.SendToServer()
				end
			end

			for k, v in pairs(tools) do if bind:find(v) then return true end end
		end
	end)
end

local nocollide = {
	"dronesrewrite_bl_laser",
	"dronesrewrite_rd_laser",
	"dronesrewrite_rd_laser_sm",
	"dronesrewrite_gr_laser_sm",
	"dronesrewrite_missile",
	"dronesrewrite_rocket",
	"dronesrewrite_rocketbig"
}

hook.Add("ShouldCollide", "dronesrewrite_physhandler", function(ent1, ent2)
	for k, v in pairs(nocollide) do
		if ent1:GetClass() == v and ent2:GetClass() == v then return false end
	end
end)

hook.Add("StartCommand", "dronesrewrite_locker", function(ply, cmd)
	local drone = ply:GetNWEntity("DronesRewriteDrone")

	if drone:IsValid() then
		cmd:ClearButtons()
		cmd:ClearMovement()
	end
end)

--PATH addons/_drones/lua/dronesrewrite/client/clientsettings_menu.lua:
local camOrientation2 = { "Right", "Left", "Center", "Down" }
local function setup( p )
	-- Weapon view
	local orientation = vgui.Create( "DComboBox", p )
	orientation:SetText( "Weapon view cam orientation " .. DRONES_REWRITE.ClientCVars.WvCamOrientation:GetString() )
	for _, v in ipairs( camOrientation2 ) do
		orientation:AddChoice( v )
	end

	orientation.OnSelect = function( _, _, val )
		val = tostring( val )
		orientation:SetText( "Weapon view cam orientation " .. val )
		RunConsoleCommand( "dronesrewrite_cl_wvcamorientation", val )
	end

	p:AddItem( orientation )
end

hook.Add( "PopulateToolMenu", "dronesrewrite_addmenuclient", function() spawnmenu.AddToolMenuOption( "Options", "Drones Settings", "dronesrewrite_client", "Client", "", "", setup ) end )
--PATH addons/_drones/lua/dronesrewrite/client/overlay.lua:
hook.Add("RenderScreenspaceEffects", "dronesrewrite_overlay", function()
	local ply = LocalPlayer()
	local drone = ply:GetNWEntity("DronesRewriteDrone")

	if drone:IsValid() and drone:DoCamEffects() then
		local overlayname = drone:GetOverlayName()
	
		if drone:GetNWBool("NightVision") and drone:HasFuel() then
			local eff_tab = {
				["$pp_colour_addr"] = 0,
				["$pp_colour_addg"] = 0.7,
				["$pp_colour_addb"] = 0,
				["$pp_colour_brightness"] = -0.4,
				["$pp_colour_contrast"] = 0.7,
				["$pp_colour_colour"] = 0.4,
				["$pp_colour_mulr"] = 0,
				["$pp_colour_mulg"] = 0,
				["$pp_colour_mulb"] = 0
			}

			DrawColorModify(eff_tab)

			DrawBloom(0, 1, 3, 4, 2, 0, 1, 1, 1)
			DrawSharpen(0.65, 4)
			--DrawSunbeams(1, 0.5, 122, 222, 522) 

			local dlight = DynamicLight(drone:EntIndex())
			if dlight then
				dlight.pos = drone:GetPos()
				dlight.r = 255
				dlight.g = 255
				dlight.b = 255
				dlight.brightness = 0
				dlight.Decay = 100
				dlight.Size = 2048
				dlight.DieTime = CurTime() + 0.1
			end
		end
	
		if DRONES_REWRITE.Overlay[overlayname] then DRONES_REWRITE.Overlay[overlayname](drone) end
		--DrawBloom(0.5, 0.5, 2, 2, 8, 0, 1, 1, 1)
	end
end)
--PATH addons/_drones/lua/dronesrewrite/client/hud/scifidef.lua:
local scaleShit = 0
local oldHealth = 0
local droneDamaged
local targetFound
local oldWep
local wepChanged

DRONES_REWRITE.HUD["Sci Fi"] = function(drone)
	local shouldDrawCrosshair = drone.HUD_shouldDrawCrosshair
	local shouldDrawHealth = drone.HUD_shouldDrawHealth
	local shouldDrawTargets = drone.HUD_shouldDrawTargets
	local shouldDrawFuel = drone.HUD_shouldDrawFuel
	local shouldDetectDamage = drone.HUD_shouldDetectDamage
	local shouldDrawCenter = drone.HUD_shouldDrawCenter
	local shouldDrawWeps = drone.HUD_shouldDrawWeps

	local x, y = ScrW(), ScrH()
	local pos = (drone:GetForward() * 10 + drone:LocalToWorld(drone.FirstPersonCam_pos)):ToScreen()
	

	if shouldDrawCrosshair then
		surface.SetMaterial(Material("stuff/crosshair1"))
		surface.SetDrawColor(Color(drone.HUD_hudColor.r, drone.HUD_hudColor.g, drone.HUD_hudColor.b, 100))
		surface.DrawTexturedRect(x * 0.5 - 64, y * 0.5 - 64, 128, 128)
	end

	if drone:GetHealth() <= drone:GetDefaultHealth() / 5 then
		surface.SetMaterial(Material("stuff/console/broken4"))
		surface.SetDrawColor(Color(255, 255, 255, math.Clamp(255 - (drone:GetHealth() / drone:GetDefaultHealth()) * 255, 0, 50)))
		surface.DrawTexturedRect(0, 0, x, y)
	end

	if shouldDrawCenter then
		--Arrow
		surface.SetMaterial(Material("stuff/arrow"))
		surface.SetDrawColor(drone.HUD_hudColor)

		local clampy = math.Clamp(pos.y, y * 0.5 - 100, y * 0.5 + 100)
		if pos.x > ScrW() then
			surface.DrawTexturedRect(ScrW() - 100, clampy, 100, 100)
			--draw.SimpleText("CENTER", "DronesRewrite_font1", ScrW() - 100, clampy + 50, drone.HUD_textColor, TEXT_ALIGN_RIGHT)
		elseif pos.x < 0 then
			surface.DrawTexturedRectRotated(50, clampy + 50, 100, 100, 180)
			--draw.SimpleText("CENTER", "DronesRewrite_font1", 90, clampy + 50, drone.HUD_textColor, TEXT_ALIGN_LEFT)
		end

		surface.SetMaterial(Material("stuff/center"))
		surface.SetDrawColor(Color(drone.HUD_hudColor.r, drone.HUD_hudColor.g, drone.HUD_hudColor.b, 50))
		surface.DrawTexturedRect(pos.x - 100, pos.y - 100, 200, 200)

		surface.SetMaterial(Material("stuff/target"))
		surface.SetDrawColor(Color(0, 255, 255, 16))

		local x = CurTime() * 0.4
		local delta = (math.sin(x) ^ 2 - math.cos(x) ^ 2) * 360
		surface.DrawTexturedRectRotated(pos.x, pos.y, 500, 500, delta)

		draw.SimpleText("SPEED [" .. math.floor(drone:GetVelocity():Length()) .. "]", "DronesRewrite_font2", pos.x + 70, pos.y - 90, drone.HUD_textColor)
		draw.SimpleText("FUEL [" .. drone:GetFuel() .. " / " .. drone.MaxFuel .."]", "DronesRewrite_font2", pos.x + 80, pos.y - 75, drone.HUD_textColor)
		draw.SimpleText("PRIMARY AMMO [" .. drone:GetPrimaryAmmo() .. " / " .. drone:GetPrimaryMax() .."]", "DronesRewrite_font2", pos.x + 90, pos.y - 60, drone.HUD_textColor)
		draw.SimpleText("SECONDARY AMMO [" .. drone:GetSecondaryAmmo() .. " / " .. drone:GetSecondaryMax() .."]", "DronesRewrite_font2", pos.x + 100, pos.y - 45, drone.HUD_textColor)
		draw.SimpleText("HEALTH [" .. drone:GetHealth() .. " / " .. drone:GetDefaultHealth() .."]", "DronesRewrite_font2", pos.x + 100, pos.y - 30, drone.HUD_textColor)

		local nightvision_flashlight_pos = 105
		if drone:GetNWBool("NightVision") then
			draw.SimpleText("NightVision enabled", "DronesRewrite_font2", pos.x, pos.y + nightvision_flashlight_pos, drone.HUD_textColor, TEXT_ALIGN_CENTER)
			nightvision_flashlight_pos = 120
		end

		if drone:GetNWBool("Flashlight") then
			draw.SimpleText("Flashlight enabled", "DronesRewrite_font2", pos.x, pos.y + nightvision_flashlight_pos, drone.HUD_textColor, TEXT_ALIGN_CENTER)
			nightvision_flashlight_pos = 120
		end
	end

	if shouldDrawHealth then
		surface.SetMaterial(Material("stuff/bar"))
		surface.SetDrawColor(drone.HUD_hudColor)
		
		for i = 1, (drone:GetHealth() / drone:GetDefaultHealth()) * 33 do
			surface.DrawTexturedRect(95 + i * 15, y - 100, 40, 30)
		end

		draw.SimpleText("HEALTH", "DronesRewrite_font1", 130, y - 70, drone.HUD_textColor, TEXT_ALIGN_LEFT)
	end

	if shouldDrawFuel then
		surface.SetMaterial(Material("stuff/bar"))
		surface.SetDrawColor(drone.HUD_hudColor)

		for i = 1, (drone:GetFuel() / drone.MaxFuel) * 33 do
			surface.DrawTexturedRect(95 + i * 15, y - 140, 40, 30)
		end

		draw.SimpleText("FUEL", "DronesRewrite_font1", 130, y - 185, drone.HUD_textColor, TEXT_ALIGN_LEFT)
	end

	if shouldDrawFuel or shouldDrawHealth then
		surface.SetMaterial(Material("stuff/barroad"))
		surface.SetDrawColor(drone.HUD_hudColor)
		surface.DrawTexturedRect(90, y - 405, 600, 600)

		surface.SetMaterial(Material("stuff/corner"))
		surface.SetDrawColor(drone.HUD_hudColor)
		surface.DrawTexturedRect(0, y - 200, 200, 200)
	end

	if shouldDrawTargets then
		local tr = drone:GetCameraTraceLine(nil, Vector(-32, -32, 0), Vector(32, 32, 0))

		for k, v in ipairs(ents.FindInSphere(tr.HitPos, 640)) do
			if v:IsPlayer() or v:IsNPC() or v.IS_DRONE then
				local pos = v:LocalToWorld(Vector(0, 0, 20))
				local bone = v:LookupBone("ValveBiped.Bip01_Head1")
				if bone then pos = v:GetBonePosition(bone) end

				local tr = util.TraceLine({
					start = drone:GetPos(),
					endpos = pos,
					filter = drone
				})

				if tr.Entity != v then continue end

				local size = (64 - math.Clamp(drone:GetPos():Distance(pos) * 0.04, 20, 64))
				pos = pos:ToScreen()

				local class = v:GetClass()
				local color = Color(64, 255, 64, 155)
				if IsEnemyEntityName(class) then color = Color(255, 64, 64, 155) end

				surface.SetMaterial(Material("stuff/center"))
				surface.SetDrawColor(color)
				surface.DrawTexturedRectRotated(pos.x, pos.y, size, size, CurTime() * 1000)
			end
		end

		local ent = tr.Entity

		targetFound = false
		if ent:IsValid() and (ent:IsPlayer() or ent:IsNPC() or ent.IS_DRONE) then
			local pos = ent:GetPos()
			local bone = ent:LookupBone("ValveBiped.Bip01_Head1")
			if bone then pos = ent:GetBonePosition(bone) end

			pos = pos:ToScreen()

			local name = ent:GetClass()
			if ent:IsPlayer() then name = ent:Name() end

			local id = ent:EntIndex()
			if ent.IS_DRR then id = ent:GetUnit() end

			local speed = math.floor(ent:GetVelocity():Length())

			scaleShit = math.Approach(scaleShit, 100, 150)

			surface.SetMaterial(Material("stuff/target"))
			surface.SetDrawColor(Color(255, 255, 255, 160 / scaleShit * 50))
			surface.DrawTexturedRectRotated(pos.x, pos.y, scaleShit, scaleShit, CurTime() * -600)

			draw.SimpleText("TARGET", "DronesRewrite_font2", pos.x + 25, pos.y - 15, Color(255, 0, 0))
			draw.SimpleText("CODE [" .. name .. "]", "DronesRewrite_font2", pos.x + 25, pos.y - 5, drone.HUD_textColor)
			draw.SimpleText("ID [" .. id .. "]", "DronesRewrite_font2", pos.x + 25, pos.y + 5, drone.HUD_textColor)
			draw.SimpleText("SPEED [" .. speed .. "]", "DronesRewrite_font2", pos.x + 25, pos.y + 15, drone.HUD_textColor)

			targetFound = true
		end

		if not targetFound then
			scaleShit = 4000
		end
	end

	if shouldDrawWeps then
		local curWep = drone:GetNWString("CurrentWeapon")

		if oldWep != curWep then
			wepChanged = true

			timer.Create("dronesrewrite_changedwep", 2, 1, function() wepChanged = false end)
		end

		if wepChanged then
			draw.SimpleText("Weapon: " .. curWep, "DronesRewrite_font3", x * 0.5, y * 0.5 + 100, drone.HUD_textColor, TEXT_ALIGN_CENTER)
		end

		oldWep = curWep
	end

	if shouldDetectDamage then
		if drone:GetHealth() > 0 and oldHealth > drone:GetHealth() then
			droneDamaged = true
			timer.Create("dronesrewrite_changedamaged", 2, 1, function() droneDamaged = false end)
		end

		if droneDamaged then
			draw.SimpleText("WARNING! GETTING DAMAGE!", "DronesRewrite_font1", x * 0.5, y - 220, Color(255, 0, 0, 120), TEXT_ALIGN_CENTER)
		end

		oldHealth = drone:GetHealth()
	end

	if drone:IsDroneDestroyed() then
		draw.SimpleText("SYSTEM DAMAGED", "DronesRewrite_font1", x * 0.5, y * 0.5 + 50, Color(255, 0, 0, 150), TEXT_ALIGN_CENTER)
	end
end
--PATH addons/_drones/lua/dronesrewrite/client/overlay/orange.lua:
DRONES_REWRITE.Overlay["Orange Scanner"] = function(drone)
	local eff_tab = {
		["$pp_colour_addr"] = 1,
		["$pp_colour_addg"] = 0.5,
		["$pp_colour_addb"] = 0,
		["$pp_colour_brightness"] = -0.7,
		["$pp_colour_contrast"] = 1.3,
		["$pp_colour_colour"] = 0.4,
		["$pp_colour_mulr"] = 0,
		["$pp_colour_mulg"] = 0,
		["$pp_colour_mulb"] = 0
	}

	DrawSharpen(0.8, 2)
	--DrawMotionBlur(0.3, 1, 0.01)

	DrawSobel(10)
	DrawColorModify(eff_tab)
	DrawToyTown(3, 400)
end
--PATH addons/_drones/lua/dronesrewrite/weapons/gun.lua:
DRONES_REWRITE.Weapons["Assault Rifle"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/gun/gun.mdl", pos, ang)
		
		DRONES_REWRITE.Weapons["Template"].SpawnSource(ent, Vector(36, 0, -4))

		ent.PrimaryAmmo = 1000
		ent.PrimaryAmmoMax = 1000
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Pistol }

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
			local damage = 10
			local force = 10

			local bullet = {}
			bullet.Num = 1
			bullet.Src = gun.Source:GetPos()
			bullet.Dir = gun:GetLocalCamDir()
			bullet.Spread = Vector(0.03, 0.02, 0.02)
			bullet.Tracer = 1
			bullet.Force = force
			bullet.Damage = damage
			bullet.Attacker = self:GetDriver()
			
			gun.Source:FireBullets(bullet)
			gun:EmitSound("weapons/shotgun/shotgun_fire" .. math.random(6, 7) .. ".wav", 85, math.random(180, 200), 1, CHAN_WEAPON)

			local phys = self:GetPhysicsObject()
			phys:ApplyForceCenter((gun:GetPos() - self:GetCameraTraceLine().HitPos):GetNormal() * 50000 / self.Weight)
			phys:AddAngleVelocity(VectorRand() * 200 / self.Weight)
			
			local ef = EffectData()
			ef:SetOrigin(gun.Source:GetPos())
			ef:SetNormal(gun:GetForward())
			util.Effect("dronesrewrite_muzzleflash", ef)

			gun:SetPrimaryAmmo(-1)
			gun.NextShoot = CurTime() + 0.05
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/silencedgun.lua:
DRONES_REWRITE.Weapons["Silent Rifle"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/dronesrewrite/silenced/silenced.mdl", pos, ang)

		DRONES_REWRITE.Weapons["Template"].SpawnSource(ent, Vector(46, 0, -4))

		ent.PrimaryAmmo = 200
		ent.PrimaryAmmoMax = 200
		ent.PrimaryAmmoType = { DRONES_REWRITE.AmmoTypes.Pistol }

		return ent
	end,

	Think = function(self, gun)
		DRONES_REWRITE.Weapons["Template"].Think(self, gun)
	end,

	Attack = function(self, gun)
		if self:WasKeyPressed("Fire1") then
			if CurTime() > gun.NextShoot and gun:HasPrimaryAmmo() then
				local damage = math.random(13,18)
				local force = 5

				local tr = self:GetCameraTraceLine()

				local bullet = {}
				bullet.Num = 1
				bullet.Src = gun.Source:GetPos()
				bullet.Dir = gun:GetLocalCamDir()
				bullet.Spread = Vector(0.004, 0.004, 0.004)
				bullet.Tracer = 1
				bullet.Force = force
				bullet.Damage = damage
				bullet.Attacker = self:GetDriver()
				
				gun.Source:FireBullets(bullet)
				gun:EmitSound("weapons/usp/usp1.wav", 62, 100, 1, CHAN_WEAPON)
				
				local ef = EffectData()
				ef:SetOrigin(gun.Source:GetPos())
				ef:SetNormal(gun:GetForward())
				util.Effect("dronesrewrite_muzzleflashsmall", ef)

				gun:SetPrimaryAmmo(-1)
				gun.NextShoot = CurTime() + 0.2
			end
		end
	end
}
--PATH addons/_drones/lua/dronesrewrite/weapons/template.lua:
DRONES_REWRITE.Weapons["Template"] = {
	Initialize = function(self, model, pos, ang, attmdl, attpos)
		pos = pos or Vector(0, 0, 0)
		ang = ang or Angle(0, 0, 0)

		if attpos then
			attpos = attpos - ang:Up() * 9.1
		else
			attpos = pos - ang:Up() * 2
		end

		local e = ents.Create("base_anim")
		e:SetModel(model)
		e:SetPos(self:LocalToWorld(attpos))
		e:SetAngles(self:GetAngles() + ang)
		e:Spawn()
		e:SetAutomaticFrameAdvance(true)
		e:Activate()
		e:SetParent(self)
		e:SetNotSolid(true)
		e:PhysicsDestroy()

		e.ang = ang
		e.pos = pos

		e.NextShoot = 0
		e.NextShoot2 = 0
		e.InstantWait = 0

		e.PrimaryAmmoMax = 0
		e.PrimaryAmmo = 0
		e.PrimaryAmmoType = { }

		e.SecondaryAmmoMax = 0
		e.SecondaryAmmo = 0
		e.SecondaryAmmoType = { }

		e.GetPrimaryMax = function(e)
			if e.PrimaryAsSecondary then
				return e:GetSecondaryMax()
			end

			return e.PrimaryAmmoMax
		end

		e.GetSecondaryMax = function(e)
			return e.SecondaryAmmoMax
		end

		e.GetPrimaryAmmo = function(e, type) 
			if e.PrimaryAsSecondary then
				return e:GetSecondaryAmmo()
			end

			return e.PrimaryAmmo 
		end

		e.GetSecondaryAmmo = function(e)
			return e.SecondaryAmmo
		end

		e.HasPrimaryAmmo = function(e)
			if e.PrimaryAsSecondary then return e:HasSecondaryAmmo() end

			if e.PrimaryAmmoMax == 0 then return true end

			return e.PrimaryAmmo > 0
		end

		e.HasSecondaryAmmo = function(e)
			if e.SecondaryAmmoMax == 0 then return true end

			return e.SecondaryAmmo > 0
		end

		e.SetPrimaryAmmo = function(e, num, ammotype)
			if e.PrimaryAsSecondary then
				e:SetSecondaryAmmo(num, ammotype)

				return 
			end

			if not self.ShouldConsumeAmmo then return end

			num = e.PrimaryAmmo + num

			self:SetNWInt("Ammo1", num)
			self:SetNWInt("MaxAmmo1", e:GetPrimaryMax())

			if num > e.PrimaryAmmo and e.Tab.OnPrimaryAdded then e.Tab.OnPrimaryAdded(self, e, num - e.PrimaryAmmo) end
			e.PrimaryAmmo = num
		end

		e.SetSecondaryAmmo = function(e, num, ammotype)
			if not self.ShouldConsumeAmmo then return end

			num = e.SecondaryAmmo + num

			self:SetNWInt("Ammo2", num)
			self:SetNWInt("MaxAmmo2", e:GetSecondaryMax())

			if num > e.SecondaryAmmo and e.Tab.OnSecondaryAdded then e.Tab.OnSecondaryAdded(self, e, num - e.SecondaryAmmo) end
			e.SecondaryAmmo = num
		end

		e.GetLocalCamAng = function(e)
			local mask = MASK_SOLID_BRUSHONLY
			if self.AI_installed or self:GetDriver():IsValid() then mask = nil end

			return (self:GetCameraTraceLine(nil, nil, nil, mask).HitPos - e:GetPos()):Angle()
		end

		e.GetLocalCamDir = function(e)
			local mask = MASK_SOLID_BRUSHONLY
			if self.AI_installed or self:GetDriver():IsValid() then mask = nil end
			
			if IsValid(e.Source) then 
				return (self:GetCameraTraceLine(nil, nil, nil, mask).HitPos - e.Source:GetPos()):GetNormal()
			end

			return (self:GetCameraTraceLine(nil, nil, nil, mask).HitPos - e:GetPos()):GetNormal()
		end

		-- Setup handler

		attmdl = attmdl or "models/dronesrewrite/attachment/attachment.mdl"

		local h = ents.Create("base_anim")
		h:SetModel(attmdl)
		h:SetPos(self:LocalToWorld(pos))
		h:Spawn()
		h:Activate()
		h:SetParent(self)
		h:SetNotSolid(true)
		h:PhysicsDestroy()

		e.Handler = h

		DRONES_REWRITE.Weapons["Template"].Think(self, e)

		return e
	end,

	InitializeNoHandler = function(self, model, pos, ang, scale)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, model, pos, ang, scale)
		ent.Handler:Remove()

		return ent
	end,

	InitializeNoDraw = function(self)
		local ent = DRONES_REWRITE.Weapons["Template"].Initialize(self, "models/props_junk/PopCan01a.mdl")

		ent:SetNoDraw(true)
		ent:DrawShadow(false)
		ent.Handler:Remove()

		ent.NoDrawWeapon = true

		return ent
	end,

	SpawnSource = function(ent, pos)
		local e = ents.Create("base_anim")
		e:SetModel("models/props_junk/PopCan01a.mdl")
		e:SetPos(ent:LocalToWorld(pos))
		e:SetAngles(ent:GetAngles())
		e:Spawn()
		e:Activate()
		e:SetParent(ent)
		e:SetNotSolid(true)
		e:DrawShadow(false)
		e:PhysicsDestroy()

		e:SetColor(Color(0, 0, 0, 0))
		e:SetRenderMode(RENDERMODE_TRANSALPHA)

		if IsValid(ent.Source) then ent.Source2 = e return e end
		ent.Source = e

		return e
	end,

	Think = function(self, gun)
		if self:IsDroneWorkable() then
			local camang = gun:GetLocalCamAng()
			camang:Normalize()

			local wepang = self:GetAngles() + gun.ang
			local lpos, lang = WorldToLocal(Vector(0, 0, 0), camang, Vector(0, 0, 0), wepang)

			wepang:RotateAroundAxis(wepang:Up(), lang.y)

			if gun.Handler:IsValid() then
				if gun.RotSpeed then
					gun.Handler:SetAngles(LerpAngle(gun.RotSpeed, gun.Handler:GetAngles(), wepang))
				else
					gun.Handler:SetAngles(wepang)
				end
			end

			wepang:RotateAroundAxis(wepang:Right(), -lang.p)

			if gun.RotSpeed then
				gun:SetAngles(LerpAngle(gun.RotSpeed, gun:GetAngles(), wepang))
			else
				gun:SetAngles(wepang)
			end
		end
	end
}

--PATH addons/_drones/lua/dronesrewrite/weapons/winch.lua:
DRONES_REWRITE.Weapons["Winch"] = {
	Initialize = function(self, pos, ang)
		local ent = DRONES_REWRITE.Weapons["Template"].InitializeNoHandler(self, "models/dronesrewrite/winch/winch.mdl", pos, ang+Angle(0,0,180))

		ent.hookmdl = ents.Create("prop_physics")
		ent.hookmdl:SetModel("models/dronesrewrite/hook/hook.mdl")
		ent.hookmdl:SetPos(ent:GetPos()-Vector(0,0,9))
		ent.hookmdl:SetAngles(ent:GetAngles()+Angle(90,0,0))
		ent.hookmdl:Spawn()
		ent.hookmdl:GetPhysicsObject():EnableGravity(false)
		
		ent.hookweld = constraint.Weld(ent.hookmdl, self, 0, 0, 0, 0, true)
		
		ent.hookc = NULL
		ent.hookr = NULL
		
		ent.rplen = 64
		ent.wdir = 0 -- (-1) pull (0) stop (1) push
		ent.crl = 1
		ent.spdcnst = 10

		ent.storedent = NULL
		ent.propweld = NULL
		
		ent.dt = CurTime()

		
		ent.detachmdlh = function()
			ent.hookweld:Remove()
			ent.hookmdl:GetPhysicsObject():EnableGravity(true)

			ent.hookc, ent.hookr = constraint.Winch(
						self:GetOwner(),
						self,
						ent.hookmdl,
						0,
						0,
						self:WorldToLocal(ent:GetPos()-Vector(0,0,8)),
						Vector(0, 0, 0),
						1,
						KEY_NONE,
						KEY_NONE,
						1,
						1,
						"cable/rope"
						)

			ent.crl = 1
		end

		ent.attachmdlh = function()
			ent.hookmdl:SetPos(ent:GetPos()-Vector(0,0,9))
			ent.hookmdl:SetAngles(ent:GetAngles()+Angle(90,0,0))
			ent.hookmdl:GetPhysicsObject():EnableGravity(false)
			ent.hookc:Remove()
			ent.hookweld = constraint.Weld(ent.hookmdl, self, 0, 0, 0, 0, true)
		end
		
		ent.setRopeLength = function()
			ent.hookc:Fire("SetSpringLength",ent.crl,0)
			if IsValid(ent.hookr) then
				ent.hookr:Fire("SetLength",ent.crl,0)
			end
		end
		
		ent.rotateCyl = function()
			local oa = ent:GetManipulateBoneAngles(1)+Angle(0,0,2*ent.wdir) -- Z axis
			if oa.r < 0 then oa.r = 360 + oa.r elseif oa.r > 360 then oa.r = oa.r - 360 end
			
			ent:ManipulateBoneAngles(1, oa)
		end

		
		function ent:drr_playsound(name)
			ent:EmitSound(name)
		end
		
		function ent:collideCallback(coldata,cdr)
			local hitent = coldata.HitEntity
			local hitentc = hitent:GetClass()

			if IsValid(hitent) and ent.wdir ~= -1 and IsValid(ent.hookc) and !IsValid(ent.storedent) and hitentc ~= "player" and hitentc ~= "worldspawn" then
				ent.storedent = coldata.HitEntity
			end
		end
		
		ent.hookmdl:AddCallback("PhysicsCollide",ent.collideCallback)
		
		return ent
	end,

	Attack = function(self, gun)
		if CurTime() > gun.NextShoot then
			if gun.wdir == 0 and gun.crl == 1 then
				gun.detachmdlh()
				gun.wdir = 1
				
			elseif gun.wdir == -1 and gun.crl > 1 then
				gun.wdir = 1
				
			elseif gun.wdir > -1 and gun.crl > 1 then
				if IsValid(gun.storedent) then
					gun.propweld:Remove()
					gun.storedent = NULL
					gun:drr_playsound("physics/metal/weapon_impact_soft"..math.random(1,3)..".wav")
				end

				gun.wdir = -1
			end

			gun.NextShoot = CurTime() + 0.5
		end
	end,

	Think = function(self, gun)
		local dt = CurTime() - gun.dt 
		gun.dt = CurTime()

		if gun.wdir ~= 0 and IsValid(gun.hookc) then
			local nrl = gun.crl + (gun.wdir * gun.spdcnst * dt)

			if nrl > 1 and nrl <= gun.rplen then
				gun.crl = nrl
				
			elseif nrl <= 1 then
				gun.wdir = 0

				gun.crl = 1

				gun:attachmdlh()
				gun:drr_playsound("phx/epicmetal_soft"..math.random(1,7)..".wav")
			
			elseif nrl > gun.rplen then
				gun.wdir = 0

				gun.crl = gun.rplen
			end
			
			gun:setRopeLength()
			gun:rotateCyl()
		end
		
		if IsValid(gun.storedent) and !IsValid(gun.propweld) then
			gun.propweld = constraint.Weld(gun.hookmdl, gun.storedent, 0, 0, 0, 0, false)
			gun:drr_playsound("phx/epicmetal_soft"..math.random(1,7)..".wav")
		end
	end
}
--PATH addons/____esclib/lua/autorun/esc_loader.lua:
-- E SCRIPTS LIB
esclib = esclib or {}
esclib.ownloader = {}

------------------------
--# LOADER FUNCTIONS #--
------------------------

local epath = "elib/" 

if (SERVER) then
	MsgC(Color(5,255,197), "@ esclib [Loading started]\n\n")

	-- resource.AddWorkshop( "2907780011" ) --workshop content
end

function esclib.ownloader:IncludeClient(path)
	if (CLIENT) then
		include(epath .. path)
	end

	if (SERVER) then
		AddCSLuaFile(epath .. path)
		MsgC(Color(13, 255, 51), "• ")
		print(epath .. path)
	end
end

function esclib.ownloader:IncludeServer(path)
	if (SERVER) then
		include(epath .. path)
		MsgC(Color(13, 255, 51), "• ")
		print(epath .. path)
	end
end

function esclib.ownloader:IncludeShared(path)
	self:IncludeServer(path)
	self:IncludeClient(path)
end

function esclib.ownloader:ResourceAddFile(path)
	if (SERVER) then
		-- resource.AddFile(path)
		MsgC(Color(13, 255, 51), "• ")
		print("Resource added to loader: ( ".. path.." )")
	end
end

function esclib.ownloader:ResourceAddFolder(name, recurse)
    local files, folders = file.Find(name .."/*", "GAME")

    for _, fname in ipairs(files) do
        self:ResourceAddFile(name .."/".. fname)
    end

    if recurse then
        for _, fname in ipairs(folders) do
            esclib.ownloader:ResourceAddFolder(name .."/".. fname, recurse)
        end
    end
end

esclib.Materials = {}
function esclib.ownloader:MaterialAddFolder(name, recurse, download)
    local files, folders = file.Find(name .."/*", "GAME")

    for _, fname in ipairs(files) do
		if download then
        	self:ResourceAddFile(name .."/".. fname)
		end
        esclib.Materials[fname] = Material(name .."/".. fname,"smooth")
    end

    if recurse then
        for _, fname in ipairs(folders) do
            esclib.ownloader:MaterialAddFolder(name .."/".. fname, recurse, download)
        end
    end
end

local errorMat = Material("error")
function esclib:GetMaterial(name)
	return esclib.Materials[name] or errorMat
end

function esclib.ownloader:ClAddFolder(name,recurse)
	local files, folders = file.Find(epath .. name .. "/*", "LUA")
	for k, fname in ipairs(files) do
		local path = name.."/"..fname
		self:IncludeClient(path)
	end
	if recurse then
		for _, fname in ipairs(folders) do
            self:ClAddFolder(name .."/".. fname, recurse)
        end
    end
end

function esclib.ownloader:SvAddFolder(name,recurse)
	local files, folders = file.Find(epath .. name .. "/*", "LUA")
	for k, fname in ipairs(files) do
		local path = name.."/"..fname
		self:IncludeServer(path)
	end
	if recurse then
		for _, fname in ipairs(folders) do
            self:SvAddFolder(name .."/".. fname, recurse)
        end
    end
end

function esclib.ownloader:ShAddFolder(name,recurse)
	local files, folders = file.Find(epath .. name .. "/*", "LUA")
	for k, fname in ipairs(files) do
		local path = name.."/"..fname
		self:IncludeShared(path)
	end
	if recurse then
		for _, fname in ipairs(folders) do
            self:ShAddFolder(name .."/".. fname, recurse)
        end
    end
end



-----------------
--# MAIN LOAD #--
-----------------

-- MAIN LOAD FUNCTION
function esclib.ownloader:Load()
	timer.Simple(0,function() --because globals not working 

		self.finished = false

		self:ResourceAddFile("resource/fonts/amsterdam.ttf")
		self:MaterialAddFolder("materials/esclib",true,false) -- path, recurse, download

		--libs
		self:IncludeShared("essentials/libs/esc_cami.lua")
		self:IncludeShared("essentials/libs/esc_isql.lua")
		self:IncludeShared("essentials/libs/esc_message_pack.lua")
		self:IncludeShared("essentials/libs/esc_netstream.lua")
		self:IncludeClient("essentials/libs/esc_fonts.lua")
		self:IncludeShared("essentials/libs/esc_utf8.lua")
		self:IncludeShared("essentials/libs/esc_files.lua")
		self:IncludeShared("essentials/libs/esc_load_manager.lua")
		self:IncludeServer("essentials/libs/esc_netcooldown.lua")

		--CORE files 1. SubAddons structure must be (addon creation > config > languages)
		self:IncludeShared("essentials/esc_print.lua")
		self:IncludeClient("essentials/esc_utils.lua")
		self:IncludeClient("essentials/esc_draw.lua")
		self:IncludeShared("essentials/esc_addons_core.lua")

		--CORE files 2
		self:IncludeShared("essentials/esc_text.lua")
		self:IncludeClient("essentials/esc_vgui.lua")

		--PANELS
		self:ClAddFolder("vgui",true)

		--SETTINGS MENU
		self:IncludeServer("essentials/settings_menu/esc_settings_server.lua")
		self:IncludeShared("essentials/settings_menu/esc_settings_typemeta.lua")
		self:ShAddFolder("essentials/settings_menu/settings_types")
		self:IncludeClient("essentials/settings_menu/esc_settings_default_tabs.lua")
		self:IncludeClient("essentials/settings_menu/esc_settings_menu.lua")
		self:IncludeShared("essentials/settings_menu/esc_settings_wrapper.lua")

		--CONFIG files
		self:IncludeShared("config/esc_meta.lua")
		self:IncludeClient("config/esc_theme.lua")
		self:IncludeShared("config/esc_config.lua")
		self:IncludeShared("config/esc_languages.lua")
		
		-- esclib.addon:PerformSettings() --SaveSettings

		if (SERVER) then
			MsgC(Color(30,235,157), "\n@ esclib [Loading finished]\n")
			MsgC(Color(30,235,157), "\nLoading dependent addons...\n")
		end

		self.finished = true
		hook.Run("esclib_loaded",esclib) 

		esclib.loader:LoadAllAddons()

	end)

	--Context menu button
	hook.Add("ContextMenuCreated","esclib.context_button",function(context)
		list.Set( "DesktopWindows", "esclib", {
			title = "ESettings",
			icon = "materials/esclib/esclib_logo.png",
			init = function(icon, window)
				RunConsoleCommand("esettings")
			end
		})
	end)

end

esclib.ownloader:Load()


concommand.Add("esclib_restart",function()
	if esclib.ownloader.finished then
		esclib.ownloader:Load()
	end
end)
--PATH addons/__main/lua/autorun/event_active.lua:
local event = false -- SNOW/HALLOWEEN
--
if event == 'SNOW' then
    hook.Add( 'InitPostEntity', 'initializeEvent', function() SnowActivate() end )
elseif event == 'HALLOWEEN' then
    hook.Add( 'InitPostEntity', 'initializeEvent', function() HalloweenActivate() end )
end
--PATH addons/_fpr/lua/fprofiler/util.lua:

-- Try to find the function represented by a string
function FProfiler.funcNameToObj(str)
    if isfunction(str) then return str end

    local times = FProfiler.Internal.getCallCounts()
    for func, _ in pairs(times) do
        if tostring(func) == str then return func end
    end

    local tbl = _G
    local exploded = string.Explode(".", str, false)
    if not exploded or not exploded[1] then return end

    for i = 1, #exploded - 1 do
        tbl = (tbl or {})[exploded[i]]
        if not istable(tbl) then return end
    end

    local func = (tbl or {})[exploded[#exploded]]

    if not isfunction(func) then return end

    return func
end

-- Read a file
function FProfiler.readSource(fname, startLine, endLine)
    if not file.Exists(fname, "GAME") then return "" end
    if startLine < 0 or endLine < 0 or endLine < startLine then return "" end

    local f = file.Open(fname, "r", "GAME")

    for i = 1, startLine - 1 do f:ReadLine() end

    local res = {}
    for i = startLine, endLine do
        table.insert(res, f:ReadLine() or "")
    end

    return table.concat(res, "\n")
end

--PATH addons/_fpr/lua/fprofiler/ui/frame.lua:
--[[-------------------------------------------------------------------------
The panel that contains the realm switcher
---------------------------------------------------------------------------]]
local REALMPANEL = {}

function REALMPANEL:Init()
    self:DockPadding(0, 0, 0, 0)
    self:DockMargin(0, 0, 5, 0)

    self.realmLabel = vgui.Create("DLabel", self)
    self.realmLabel:SetDark(true)
    self.realmLabel:SetText("Realm:")

    self.realmLabel:SizeToContents()
    self.realmLabel:Dock(TOP)

    self.realmbox = vgui.Create("DComboBox", self)
    self.realmbox:AddChoice("Client")
    self.realmbox:AddChoice("Server")
    self.realmbox:Dock(TOP)

    FProfiler.UI.onModelUpdate("realm", function(new)
        self.realmbox.selected = new == "client" and 1 or 2
        self.realmbox:SetText(new == "client" and "Client" or "Server")
    end)

    FProfiler.UI.onModelUpdate("serverAccess", function(hasAccess)
        self.realmbox:SetDisabled(not hasAccess)

        if not hasAccess and self.realmbox.selected == 2 then
            FProfiler.UI.updateModel("realm", "client")
        end
    end)

    self.realmbox.OnSelect = function(_, _, value) FProfiler.UI.updateModel("realm", string.lower(value)) end
end

function REALMPANEL:PerformLayout()
    self.realmLabel:SizeToContents()
    local top = ( self:GetTall() - self.realmLabel:GetTall() - self.realmbox:GetTall()) * 0.5
    self:DockPadding(0, top, 0, 0)
end

derma.DefineControl("FProfileRealmPanel", "", REALMPANEL, "Panel")

--[[-------------------------------------------------------------------------
The little red or green indicator that indicates whether the focussing
function is correct
---------------------------------------------------------------------------]]
local FUNCINDICATOR = {}

function FUNCINDICATOR:Init()
    self:SetTall(5)
    self.color = Color(0, 0, 0, 0)
end

function FUNCINDICATOR:Paint()
    draw.RoundedBox(0, 0, 0, self:GetWide(), self:GetTall(), self.color)
end

derma.DefineControl("FProfileFuncIndicator", "", FUNCINDICATOR, "DPanel")

--[[-------------------------------------------------------------------------
The panel that contains the focus text entry and the focus indicator
---------------------------------------------------------------------------]]
local FOCUSPANEL = {}

function FOCUSPANEL:Init()
    self:DockPadding(0, 0, 0, 0)
    self:DockMargin(0, 0, 5, 0)

    self.focusLabel = vgui.Create("DLabel", self)
    self.focusLabel:SetDark(true)
    self.focusLabel:SetText("Profiling Focus:")

    self.focusLabel:SizeToContents()
    self.focusLabel:Dock(TOP)

    self.funcIndicator = vgui.Create("FProfileFuncIndicator", self)
    self.funcIndicator:Dock(BOTTOM)

    self.focusBox = vgui.Create("DTextEntry", self)
    self.focusBox:SetText("")
    self.focusBox:SetWidth(150)
    self.focusBox:Dock(BOTTOM)
    self.focusBox:SetTooltip("Focus the profiling on a single function.\nEnter a global function name here (like player.GetAll)\nYou're not allowed to call functions in here (e.g. hook.GetTable() is not allowed)")

    function self.focusBox:OnChange()
        FProfiler.UI.updateCurrentRealm("focusStr", self:GetText())
    end

    FProfiler.UI.onCurrentRealmUpdate("focusObj", function(new)
        self.funcIndicator.color = FProfiler.UI.getCurrentRealmValue("focusStr") == "" and Color(0, 0, 0, 0) or new and Color(80, 255, 80, 255) or Color(255, 80, 80, 255)
    end)

    FProfiler.UI.onCurrentRealmUpdate("focusStr", function(new, old)
        if self.focusBox:GetText() == new then return end

        self.focusBox:SetText(tostring(new))
    end)
end

function FOCUSPANEL:PerformLayout()
    self.focusBox:SetWide(200)
    self.focusLabel:SizeToContents()
end

derma.DefineControl("FProfileFocusPanel", "", FOCUSPANEL, "Panel")

--[[-------------------------------------------------------------------------
The timer that keeps track of for how long the profiling has been going on
---------------------------------------------------------------------------]]
local TIMERPANEL = {}

function TIMERPANEL:Init()
    self:DockPadding(0, 5, 0, 5)
    self:DockMargin(5, 0, 5, 0)

    self.timeLabel = vgui.Create("DLabel", self)
    self.timeLabel:SetDark(true)
    self.timeLabel:SetText("Total profiling time:")

    self.timeLabel:SizeToContents()
    self.timeLabel:Dock(TOP)

    self.counter = vgui.Create("DLabel", self)
    self.counter:SetDark(true)
    self.counter:SetText("00:00:00")
    self.counter:SizeToContents()
    self.counter:Dock(RIGHT)

    function self.counter:Think()
        local recordTime, sessionStart = FProfiler.UI.getCurrentRealmValue("recordTime"), FProfiler.UI.getCurrentRealmValue("sessionStart")

        local totalTime = recordTime + (sessionStart and (CurTime() - sessionStart) or 0)

        self:SetText(string.FormattedTime(totalTime, "%02i:%02i:%02i"))
    end
end

function TIMERPANEL:PerformLayout()
    self.timeLabel:SizeToContents()
    self.counter:SizeToContents()
end

derma.DefineControl("FProfileTimerPanel", "", TIMERPANEL, "Panel")

--[[-------------------------------------------------------------------------
The top bar
---------------------------------------------------------------------------]]
local MAGICBAR = {}

function MAGICBAR:Init()
    self:DockPadding(5, 5, 5, 5)
    self.realmpanel = vgui.Create("FProfileRealmPanel", self)

    -- (Re)Start profiling
    self.restartProfiling = vgui.Create("DButton", self)
    self.restartProfiling:SetText("   (Re)Start\n    Profiling")
    self.restartProfiling:DockMargin(0, 0, 5, 0)
    self.restartProfiling:Dock(LEFT)

    self.restartProfiling.DoClick = function()
        FProfiler.UI.updateCurrentRealm("shouldReset", true)
        FProfiler.UI.updateCurrentRealm("status", "Started")
    end

    FProfiler.UI.onCurrentRealmUpdate("status", function(new)
        self.restartProfiling:SetDisabled(new == "Started")
    end)

    -- Stop profiling
    self.stopProfiling = vgui.Create("DButton", self)
    self.stopProfiling:SetText("     Stop\n  Profiling")
    self.stopProfiling:DockMargin(0, 0, 5, 0)
    self.stopProfiling:Dock(LEFT)

    self.stopProfiling.DoClick = function()
        FProfiler.UI.updateCurrentRealm("status", "Stopped")
    end

    FProfiler.UI.onCurrentRealmUpdate("status", function(new)
        self.stopProfiling:SetDisabled(new == "Stopped")
    end)

    -- Continue profiling
    self.continueProfiling = vgui.Create("DButton", self)
    self.continueProfiling:SetText("    Continue\n     Profiling")
    self.continueProfiling:DockMargin(0, 0, 5, 0)
    self.continueProfiling:Dock(LEFT)

    self.continueProfiling.DoClick = function()
        FProfiler.UI.updateCurrentRealm("shouldReset", false)
        FProfiler.UI.updateCurrentRealm("status", "Started")
    end

    FProfiler.UI.onCurrentRealmUpdate("status", function(new)
        self.continueProfiling:SetDisabled(new == "Started")
    end)

    self.realmpanel:Dock(LEFT)

    self.focuspanel = vgui.Create("FProfileFocusPanel", self)
    self.focuspanel:Dock(LEFT)

    -- Timer
    self.timerpanel = vgui.Create("FProfileTimerPanel", self)
    self.timerpanel:Dock(RIGHT)
end

function MAGICBAR:PerformLayout()
    self.realmpanel:SizeToChildren(true, false)
    self.focuspanel:SizeToChildren(true, false)
    self.timerpanel:SizeToChildren(true, false)
end


derma.DefineControl("FProfileMagicBar", "", MAGICBAR, "DPanel")

--[[-------------------------------------------------------------------------
A custom sort by column function to deal with sorting by numeric value
--------------------------------------------------------------------------]]
local function SortByColumn(self, ColumnID, Desc)
    table.Copy(self.Sorted, self.Lines)

    table.sort(self.Sorted, function(a, b)
        if Desc then
            a, b = b, a
        end

        local aval = a:GetSortValue(ColumnID) or a:GetColumnText(ColumnID)
        local bval = b:GetSortValue(ColumnID) or b:GetColumnText(ColumnID)

        local anum = tonumber(aval)
        local bnum = tonumber(bval)

        if anum and bnum then
            return anum < bnum
        end

        return tostring(aval) < tostring(bval)
    end)

    self:SetDirty(true)
    self:InvalidateLayout()
end

--[[-------------------------------------------------------------------------
The Bottlenecks tab's contents
---------------------------------------------------------------------------]]
local BOTTLENECKTAB = {}

BOTTLENECKTAB.SortByColumn = SortByColumn

function BOTTLENECKTAB:Init()
    self:SetMultiSelect(false)
    self:AddColumn("Name")
    self:AddColumn("Path")
    self:AddColumn("Lines")
    self:AddColumn("Amount of times called")
    self:AddColumn("Total time in ms (inclusive)")
    self:AddColumn("Average time in ms (inclusive)")

    FProfiler.UI.onCurrentRealmUpdate("bottlenecks", function(new)
        self:Clear()

        for _, row in ipairs(new) do
            local names = {}
            local path = row.info.short_src
            local lines = path ~= "[C]" and row.info.linedefined .. " - " .. row.info.lastlinedefined or "N/A"
            local amountCalled = row.total_called
            local totalTime = row.total_time * 100
            local avgTime = row.average_time * 100

            for _, fname in ipairs(row.names or {}) do
                if fname.namewhat == "" and fname.name == "" then continue end
                table.insert(names, fname.namewhat .. " " .. fname.name)
            end

            if #names == 0 then names[1] = "Unknown" end

            local line = self:AddLine(table.concat(names, "/"), path, lines, amountCalled, totalTime, avgTime)
            line.data = row
        end
    end)

    FProfiler.UI.onCurrentRealmUpdate("currentSelected", function(new, old)
        if new == old then return end

        for _, line in pairs(self.Lines) do
            line:SetSelected(line.data.func == new.func)
        end
    end)
end


function BOTTLENECKTAB:OnRowSelected(id, line)
    FProfiler.UI.updateCurrentRealm("currentSelected", line.data)
end


derma.DefineControl("FProfileBottleNecks", "", BOTTLENECKTAB, "DListView")

--[[-------------------------------------------------------------------------
The Top n lag spikes tab's contents
---------------------------------------------------------------------------]]
local TOPTENTAB = {}

TOPTENTAB.SortByColumn = SortByColumn

function TOPTENTAB:Init()
    self:SetMultiSelect(false)
    self:AddColumn("Name")
    self:AddColumn("Path")
    self:AddColumn("Lines")
    self:AddColumn("Runtime in ms")

    FProfiler.UI.onCurrentRealmUpdate("topLagSpikes", function(new)
        self:Clear()

        for _, row in ipairs(new) do
            if not row.func then break end

            local name = row.info.name and row.info.name ~= "" and (row.info.namewhat .. " " .. row.info.name) or "Unknown"
            local path = row.info.short_src
            local lines = path ~= "[C]" and row.info.linedefined .. " - " .. row.info.lastlinedefined or "N/A"
            local runtime = row.runtime * 100

            local line = self:AddLine(name, path, lines, runtime)
            line.data = row
        end
    end)

    FProfiler.UI.onCurrentRealmUpdate("currentSelected", function(new, old)
        if new == old then return end

        for _, line in pairs(self.Lines) do
            line:SetSelected(line.data.func == new.func)
        end
    end)
end

function TOPTENTAB:OnRowSelected(id, line)
    FProfiler.UI.updateCurrentRealm("currentSelected", line.data)
end

derma.DefineControl("FProfileTopTen", "", TOPTENTAB, "DListView")

--[[-------------------------------------------------------------------------
The Tab panel of the bottlenecks and top n lag spikes
---------------------------------------------------------------------------]]
local RESULTSHEET = {}

function RESULTSHEET:Init()
    self:DockMargin(0, 10, 0, 0)
    self:SetPadding(0)

    self.bottlenecksTab = vgui.Create("FProfileBottleNecks")
    self:AddSheet("Bottlenecks", self.bottlenecksTab)

    self.toptenTab = vgui.Create("FProfileTopTen")
    self:AddSheet("Top 50 most expensive function calls", self.toptenTab)

end


derma.DefineControl("FProfileResultSheet", "", RESULTSHEET, "DPropertySheet")

--[[-------------------------------------------------------------------------
The function details panel
---------------------------------------------------------------------------]]
local FUNCDETAILS = {}

function FUNCDETAILS:Init()
    self.titleLabel = vgui.Create("DLabel", self)
    self.titleLabel:SetDark(true)
    self.titleLabel:SetFont("DermaLarge")
    self.titleLabel:SetText("Function Details")
    self.titleLabel:SizeToContents()
    -- self.titleLabel:Dock(TOP)

    self.focus = vgui.Create("DButton", self)
    self.focus:SetText("Focus")
    self.focus:SetTall(50)
    self.focus:SetFont("DermaDefaultBold")
    self.focus:Dock(BOTTOM)

    function self.focus:DoClick()
        local sel = FProfiler.UI.getCurrentRealmValue("currentSelected")
        if not sel then return end

        FProfiler.UI.updateCurrentRealm("focusStr", sel.func)
    end

    self.source = vgui.Create("DTextEntry", self)
    self.source:SetKeyboardInputEnabled(false)
    self.source:DockMargin(0, 40, 0, 0)
    self.source:SetMultiline(true)
    self.source:Dock(FILL)

    FProfiler.UI.onCurrentRealmUpdate("sourceText", function(new)
        self.source:SetText(string.Replace(new, "\t", "    "))
    end)

    self.toConsole = vgui.Create("DButton", self)
    self.toConsole:SetText("Print Details to Console")
    self.toConsole:SetTall(50)
    self.toConsole:SetFont("DermaDefaultBold")
    self.toConsole:Dock(BOTTOM)

    function self.toConsole:DoClick()
        FProfiler.UI.updateCurrentRealm("toConsole", FProfiler.UI.getCurrentRealmValue("currentSelected"))
    end
end

function FUNCDETAILS:PerformLayout()
    self.titleLabel:CenterHorizontal()
end
derma.DefineControl("FProfileFuncDetails", "", FUNCDETAILS, "DPanel")

--[[-------------------------------------------------------------------------
The actual frame
---------------------------------------------------------------------------]]
local FRAME = {}

local frameInstance
function FRAME:Init()
    self:SetTitle("FProfiler profiling tool")
    self:SetSize(ScrW() * 0.8, ScrH() * 0.8)
    self:Center()
    self:SetVisible(true)
    self:MakePopup()
    self:SetDeleteOnClose(false)

    self.magicbar = vgui.Create("FProfileMagicBar", self)
    self.magicbar:SetTall(math.max(self:GetTall() * 0.07, 48))
    self.magicbar:Dock(TOP)

    self.resultsheet = vgui.Create("FProfileResultSheet", self)
    self.resultsheet:SetWide(self:GetWide() * 0.8)
    self.resultsheet:Dock(LEFT)

    self.details = vgui.Create("FProfileFuncDetails", self)
    self.details:SetWide(self:GetWide() * 0.2 - 12)
    self.details:DockMargin(5, 31, 0, 0)
    self.details:Dock(RIGHT)
end

function FRAME:OnClose()
    FProfiler.UI.updateModel("frameVisible", false)
end

derma.DefineControl("FProfileFrame", "", FRAME, "DFrame")

--[[-------------------------------------------------------------------------
The command to start the profiler
---------------------------------------------------------------------------]]
concommand.Add("FProfiler",
    function()
        frameInstance = frameInstance or vgui.Create("FProfileFrame")
        frameInstance:SetVisible(true)

        FProfiler.UI.updateModel("frameVisible", true)
    end,
    nil, "Starts FProfiler")

--PATH addons/igs-core/lua/igs/extensions/levels.lua:
--[[-------------------------------------------------------------------------
	Поддержка вот этого говнокода:
	https://github.com/vrondakis/Leveling-System
---------------------------------------------------------------------------]]
local STORE_ITEM = FindMetaTable("IGSItem")

function STORE_ITEM:SetLevels(iAmount)
	return self:SetInstaller(function(pl)
		pl:addLevels(iAmount)
	end)
end

function STORE_ITEM:SetEXP(iAmount)
	return self:SetInstaller(function(pl)
		pl:addXP(iAmount)
	end)
end

--PATH addons/igs-core/lua/igs/extensions/xadmin.lua:
IGS.ITEMS.XADMIN_USERS = IGS.ITEMS.XADMIN_USERS or {} -- by kip https://t.me/c/1353676159/1673

local STORE_ITEM = FindMetaTable("IGSItem")

function STORE_ITEM:SetXAdminGroup(sUserGroup)
	return self:SetInstaller(function(pl)
		xAdmin.UserGroups[pl:SteamID()] = sUserGroup
		pl:SetUserGroup(sUserGroup)
		IGS.ITEMS.XADMIN_USERS[pl:SteamID()] = true
	end):SetValidator(function()
		return false
	end)
end

hook.Add("PlayerDisconnected", "IGS.XAdminRemovePerm", function(pl)
	if IGS.ITEMS.XADMIN_USERS[pl:SteamID()] then
		xAdmin.UserGroups[pl:SteamID()] = nil
		IGS.ITEMS.XADMIN_USERS[pl:SteamID()] = nil
	end
end)


-- Есть xAdmin.SetGroup(pl, sUserGroup)
-- но тогда будет сложнее контроллировать снятие прав, тк идет запись в БД
function STORE_ITEM:SetXAdmin2Group(sUserGroup)
	return self:SetInstaller(function(pl)
		local sid64 = pl:SteamID64()
		local oldgroup = pl:GetUserGroup()

		xAdmin.UserData[sid64] = xAdmin.UserData[sid64] or {SteamID = sid64}
		xAdmin.UserData[sid64].UserGroup = sUserGroup

		pl:SetUserGroup(sUserGroup)

		xAdmin.UpdateGroupMembers(player.GetAll(), sUserGroup)

		hook.Run("xAdminUserGroupUpdated", pl, sUserGroup, oldgroup)
	end):AddHook("IGS.PlayerPurchasesLoaded", function(pl, purchases)
		if CLIENT or not purchases then return end

		local priority_item = self

		for uid in pairs(purchases) do
			local ITEM = IGS.GetItemByUID(uid)
			if ITEM:GetMeta("badmin2group") and ITEM.id > self.id then
				priority_item = ITEM
			end
		end

		if priority_item == self then
			self:Setup(pl)
		end
	end):SetMeta("badmin2group", sUserGroup)
end

--PATH addons/igs-core/lua/igs/interface/windows/deposit_funds.lua:
local function niceSum(i, iFallback)
	return math.Truncate(tonumber(i) or iFallback, 2)
end

local m
function IGS.WIN.Deposit(iRealSum)
	if IsValid(m) then return end -- не даем открыть 2 фрейма
	iRealSum = tonumber(iRealSum)

	surface.PlaySound("ambient/weather/rain_drip1.wav")
	hook.Run("IGS.OnDepositWinOpen",iRealSum)

	local cd = not IGS.IsCurrencyEnabled() -- cd = currency disabled. Bool
	local realSum = math.max(30, niceSum(iRealSum, 0))

	m = uigs.Create("igs_frame", function(self)
		self:SetSize(450,400)
		self:RememberLocation("igs_deposit")

		-- Вы, конечно, можете удалить наш копирайт. Чтобы вы не перенапряглись, я даже подготовил чуть ниже строчку для этого
		-- Но прежде, чем ты это сделаешь, ответь себе на вопрос. Зачем? Так мешает?
		self:SetTitle("Автодонат від gm-donate.net")
		-- self:SetTitle("Владелец этого сервера не ценит чужой труд")

		self:MakePopup()
		-- self:Focus()
		-- self:SetBackgroundBlur(false)

		--[[-------------------------------------
			Левая колонка. Реальная валюта
		---------------------------------------]]
		uigs.Create("DLabel", function(real)
			real:SetSize(cd and 450 or 180,25)
			real:SetPos(cd and 0 or 10,self:GetTitleHeight())
			real:SetText(cd and "Введіть нижче суму поповнення рахунку" or "₴")
			real:SetFont("igs.22")
			real:SetTextColor(IGS.col.HIGHLIGHTING)
			real:SetContentAlignment(2)
		end, self)

		self.real_m = uigs.Create("DTextEntry", self)
		self.real_m:SetPos(10,50)
		self.real_m:SetSize(cd and 450 - 10 - 10 or 180,30)
		self.real_m:SetNumeric(true)
		self.real_m.OnChange = function(s)
			if cd then return end
			self.curr_m:SetValue(IGS.PriceInCurrency( niceSum(s:GetValue(),0) )) -- бля
		end
		self.real_m.Think = function()
			local rub = tonumber(self.real_m:GetValue())
			if cd then
				self.purchase:SetText(
					"Поповнити рахунок на " .. niceSum(rub,0) .. " ₴"
				)
			else
				local igs = tonumber(self.curr_m:GetValue())
				self.purchase:SetText(
					"Поповнити на " .. IGS.SignPrice( niceSum(igs,0) ) ..
					" за " .. niceSum(rub,0) .. " ₴"
				)
			end

			self.purchase:SetActive(rub and rub > 0)
		end

		--[[-------------------------------------
			Середина. Знак равности и кнопка покупки
		---------------------------------------]]
		if not cd then
			uigs.Create("DLabel", function(eq)
				eq:SetSize(50,30)
				eq:SetPos(200,50)
				eq:SetText("=")
				eq:SetFont("igs.40")
				eq:SetTextColor(IGS.col.TEXT_HARD)
				eq:SetContentAlignment(5)
			end,self)
		end

		self.purchase = uigs.Create("igs_button", function(p)
			local _,ry = self.real_m:GetPos()

			p:SetSize(400,40)
			p:SetActive(true) -- выделяет синим
			p:SetPos((self:GetWide() - p:GetWide()) * 0.5,ry + self.real_m:GetTall() + 10)

			p.DoClick = function()
				local want_money = niceSum(self.real_m:GetValue()) or false
				if not want_money then
					self.log:AddRecord("Указана некоректна сума поповнення", false)
					return

				elseif want_money < realSum then
					self.log:AddRecord("Мінімальна сума поповнення " .. PL_MONEY(realSum), false)
					return
				end

				self.log:AddRecord("Запит цифрового підпису запиту від сервера...")

				IGS.GetPaymentURL(want_money,function(url)
					IGS.OpenURL(url,"Процедура поповнення рахунку")
					if not IsValid(self) then return end
					self.log:AddRecord("Підпис отримано. починаємо процес оплати")

					timer.Simple(.7,function()
						self.log:AddRecord("Рахунок поповниться моментально або післе перезаходу")
					end)
				end)
			end
		end, self)

		--[[-------------------------------------
			Правая колонка. Донат валюта
		---------------------------------------]]
		if not cd then
			uigs.Create("DLabel", function(curr)
				curr:SetSize(180,25)
				curr:SetPos(self:GetWide() - 10 - curr:GetWide(),self:GetTitleHeight())
				curr:SetText(IGS.C.CURRENCY_NAME)
				curr:SetFont("igs.22")
				curr:SetTextColor(IGS.col.HIGHLIGHTING)
				curr:SetContentAlignment(2)
			end, self)

			self.curr_m = uigs.Create("DTextEntry", self)
			self.curr_m:SetPos(self:GetWide() - 10 - self.real_m:GetWide(),50)
			self.curr_m:SetSize(self.real_m:GetWide(),self.real_m:GetTall())
			self.curr_m:SetNumeric(true)
			self.curr_m.OnChange = function(s)
				self.real_m:SetValue(IGS.RealPrice( niceSum(s:GetValue(),0) )) -- тоже бля
			end
		end

		--[[-------------------------------------------------------------------------
			Должно быть после self.curr_m
		---------------------------------------------------------------------------]]
		self.real_m:SetValue( realSum )
		self.real_m:OnChange()


		--[[-------------------------------------------------------------------------
			Все подряд
		---------------------------------------------------------------------------]]
		self.log = uigs.Create("igs_scroll", function(log)
			log:SetSize(250,200)
			log:SetPos(10,self:GetTall() - log:GetTall() - 10)
			-- https://img.qweqwe.ovh/1487171563683.png
			function log:AddRecord(text,pay)
				local col =
					(pay == true  and IGS.col.LOG_SUCCESS) or
					(pay == false and IGS.col.LOG_ERROR)   or IGS.col.LOG_NORMAL

				-- Платеж или Ошибка
				if pay or pay == false then
					self:GetParent():RequestFocus()
					self:GetParent():MakePopup()
				end

				return log:AddItem( uigs.Create("Panel", function(bg)
					text = "> " .. os.date("%H:%M:%S",os.time()) .. "\n" .. text

					local y = 2
					for i,line in ipairs(string.Wrap("igs.18",text,log:GetWide() - 0 - 0)) do
						uigs.Create("DLabel", function(l)
							l:SetPos(0,y)
							l:SetText(line)
							l:SetFont("igs.18")
							l:SizeToContents()
							l:SetTextColor(i == 1 and IGS.col.HIGHLIGHTING or col)
							--               /\ первой строкой идет дата (\n)

							y = y + l:GetTall()
						end, bg)
					end

					bg:SetTall(y + 2)
					log:ScrollTo(log:GetCanvas():GetTall())
				end, log) )
			end
		end, self)

		local log_t = uigs.Create("DLabel", function(log_title)
			local log_x,log_y = self.log:GetPos()

			log_title:SetSize(self.log:GetWide(),22)
			log_title:SetPos(log_x,log_y - log_title:GetTall())
			log_title:SetText("Лог операций")
			log_title:SetTextColor(IGS.col.HIGHLIGHTING)
			log_title:SetFont("igs.22")
			log_title:SetContentAlignment(1)
		end, self)

		-- Линия над логом и кнопкой
		local _,log_t_y = log_t:GetPos()
		uigs.Create("DPanel", function(line)
			line:SetPos(10, log_t_y - 2 - 10)
			line:SetSize(self:GetWide() - line:GetPos() * 2, 2)
			line.Paint = function(s, w, h)
				draw.RoundedBox(0,0,0,w,h,IGS.col.SOFT_LINE)
			end
		end, self)


		local coupon = uigs.Create("igs_button", function(btn)
			local _,log_y = self.log:GetPos()

			btn:SetSize(170, 30)
			btn:SetPos(self:GetWide() - 10 - btn:GetWide(),log_y - 20)
			btn:SetText("Активувати купон")
			btn.DoClick = function()
				IGS.WIN.ActivateCoupon()
			end
		end, self)


		-- uigs.Create("DLabel", function(btns_title)
		-- 	local coup_x,coup_y = coupon:GetPos()

		-- 	btns_title:SetSize(coupon:GetWide(),30)
		-- 	btns_title:SetPos(coup_x,coup_y + coupon:GetTall() + 0)
		-- 	btns_title:SetText("Все автоматизировано")
		-- 	btns_title:SetTextColor(IGS.col.TEXT_HARD)
		-- 	btns_title:SetFont("igs.18")
		-- 	-- btns_title:SetContentAlignment(3)
		-- end, self)

		local function log(delay,text,status)
			timer.Simple(delay,function()
				if not IsValid(self.log) then return end
				self.log:AddRecord(text, status)
			end)
		end

		log(0,"Відкритий діалог поповнення рахунку",nil)
		log(math.random(3),"З'єднання встановлено!",true) -- пустышка, которая добавляет чувство безопасностти сделке
		log(math.random(20,40),"Гроші будуть зараховані миттєво та автоматично",nil)
	end)

	return m
end


hook.Add("IGS.PaymentStatusUpdated","UpdatePaymentStatus",function(dat)
	local extra_inf = IGS.IsCurrencyEnabled() and (" (" .. PL_MONEY( IGS.RealPrice(dat.orderSum) ) .. ")") or ""

	local text =
		dat.method == "check" and ("Перевірка можливості платежа через " .. dat.paymentType) or
		dat.method == "pay"   and ("Нараховано " .. PL_IGS(dat.orderSum) ..  extra_inf) or
		dat.method == "error" and ("Помилка поповнення рахунку: " .. dat.errorMessage) or
		"Із сервера прийшов невідомий метод " .. tostring(dat.method) .. " та виникла помилка"

	if not IsValid(m) then
		IGS.ShowNotify(text,"Оновлення статуса платежу")
		return
	end

	local pay = nil
	if dat.method == "pay" then
		pay = true
	elseif dat.method == "error" then
		pay = false
	end

	m.log:AddRecord(text,pay)
end)



-- if IsValid(IGS_CHARGE) then
-- 	IGS_CHARGE:Remove()
-- end

-- IGS_CHARGE = IGS.WIN.Deposit()
-- local p = IGS_CHARGE
-- -- timer.Simple(1,function()
-- -- 	p.log:AddRecord("Kek lol heh mda", false)
-- -- end)

-- timer.Simple(600,function()
-- 	if IsValid(p) then
-- 		p:Remove()
-- 		p = nil
-- 	end
-- end)

--PATH addons/lvs_base-main/lua/lvs_framework/autorun/lvs_convar.lua:
-- 2022 and i still havent bothered creating a system that does this automatically

LVS.cVar_FreezeTeams = CreateConVar( "lvs_freeze_teams", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"enable/disable auto ai-team switching" )
LVS.FreezeTeams = LVS.cVar_FreezeTeams and LVS.cVar_FreezeTeams:GetBool() or false
cvars.AddChangeCallback( "lvs_freeze_teams", function( convar, oldValue, newValue ) 
	LVS.FreezeTeams = tonumber( newValue ) ~=0
end, "lvs_freezeteams_callback" )

LVS.cVar_TeamPassenger = CreateConVar( "lvs_teampassenger", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"only allow players of matching ai-team to enter the vehicle? 1 = team only, 0 = everyone can enter" )
LVS.TeamPassenger = LVS.cVar_TeamPassenger and LVS.cVar_TeamPassenger:GetBool() or false
cvars.AddChangeCallback( "lvs_teampassenger", function( convar, oldValue, newValue ) 
	LVS.TeamPassenger = tonumber( newValue ) ~= 0
end, "lvs_teampassenger_callback" )

LVS.cVar_PlayerDefaultTeam = CreateConVar( "lvs_default_teams", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"set default player ai-team" )
LVS.PlayerDefaultTeam = LVS.cVar_PlayerDefaultTeam and LVS.cVar_PlayerDefaultTeam:GetInt() or 0
cvars.AddChangeCallback( "lvs_default_teams", function( convar, oldValue, newValue ) 
	LVS.PlayerDefaultTeam = math.Round( tonumber( newValue ), 0 )
end, "lvs_defaultteam_callback" )

LVS.cVar_IgnoreNPCs = CreateConVar( "lvs_ai_ignorenpcs", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"should LVS-AI ignore NPCs?" )
LVS.IgnoreNPCs = LVS.cVar_IgnoreNPCs and LVS.cVar_IgnoreNPCs:GetBool() or false
cvars.AddChangeCallback( "lvs_ai_ignoreplayers", function( convar, oldValue, newValue ) 
	LVS.IgnorePlayers = tonumber( newValue ) ~=0
end)

LVS.cVar_playerignore = CreateConVar( "lvs_ai_ignoreplayers", "0", {FCVAR_REPLICATED , FCVAR_ARCHIVE},"should LVS-AI ignore Players?" )
LVS.IgnorePlayers = LVS.cVar_playerignore and LVS.cVar_playerignore:GetBool() or false
cvars.AddChangeCallback( "lvs_ai_ignorenpcs", function( convar, oldValue, newValue ) 
	LVS.IgnoreNPCs = tonumber( newValue ) ~=0
end)

if SERVER then
	util.AddNetworkString( "lvs_admin_setconvar" )

	net.Receive( "lvs_admin_setconvar", function( length, ply )
		if not IsValid( ply ) or not ply:IsSuperAdmin() then return end

		local ConVar = net.ReadString()
		local Value = tonumber( net.ReadString() )

		RunConsoleCommand( ConVar, Value ) 
	end)

	return
end

CreateClientConVar( "lvs_mouseaim", 0, true, true)
CreateClientConVar( "lvs_mouseaim_type", 0, true, false)
CreateClientConVar( "lvs_edit_hud", 1, true, false)
CreateClientConVar( "lvs_sensitivity_x", 1, true, true)
CreateClientConVar( "lvs_sensitivity_y", 1, true, true)
CreateClientConVar( "lvs_return_delta", 2, true, true)

LVS.cvarCamFocus = CreateClientConVar( "lvs_camerafocus", 0, true, false)

local cvarVolume = CreateClientConVar( "lvs_volume", 0.5, true, false)
LVS.EngineVolume = cvarVolume and cvarVolume:GetFloat() or 0.5
cvars.AddChangeCallback( "lvs_volume", function( convar, oldValue, newValue ) 
	LVS.EngineVolume = math.Clamp( tonumber( newValue ), 0, 1 )
end)

local cvarTrail = CreateClientConVar( "lvs_show_traileffects", 1, true, false)
LVS.ShowTraileffects = cvarTrail and cvarTrail:GetBool() or true
cvars.AddChangeCallback( "lvs_show_traileffects", function( convar, oldValue, newValue ) 
	LVS.ShowTraileffects = tonumber( newValue ) ~=0
end)

local cvarEffects = CreateClientConVar( "lvs_show_effects", 1, true, false)
LVS.ShowEffects = cvarEffects and cvarEffects:GetBool() or true
cvars.AddChangeCallback( "lvs_show_effects", function( convar, oldValue, newValue ) 
	LVS.ShowEffects = tonumber( newValue ) ~=0
end)

local cvarPhysEffects = CreateClientConVar( "lvs_show_physicseffects", 1, true, false)
LVS.ShowPhysicsEffects = cvarPhysEffects and cvarPhysEffects:GetBool() or true
cvars.AddChangeCallback( "lvs_show_physicseffects", function( convar, oldValue, newValue ) 
	LVS.ShowPhysicsEffects = tonumber( newValue ) ~=0
end)

local cvarShowIdent = CreateClientConVar( "lvs_show_identifier", 1, true, false)
LVS.ShowIdent = cvarShowIdent and cvarShowIdent:GetBool() or true
cvars.AddChangeCallback( "lvs_show_identifier", function( convar, oldValue, newValue ) 
	LVS.ShowIdent = tonumber( newValue ) ~=0
end)

local cvarHitMarker = CreateClientConVar( "lvs_hitmarker", 1, true, false)
LVS.ShowHitMarker = cvarHitMarker and cvarHitMarker:GetBool() or false
cvars.AddChangeCallback( "lvs_hitmarker", function( convar, oldValue, newValue ) 
	LVS.ShowHitMarker = tonumber( newValue ) ~=0
end)

local cvarAntiAlias = GetConVar( "mat_antialias" )
LVS.AntiAliasingEnabled = cvarAntiAlias and (cvarAntiAlias:GetInt() > 3) or false
cvars.AddChangeCallback( "mat_antialias", function( convar, oldValue, newValue ) 
	LVS.AntiAliasingEnabled = tonumber( newValue ) > 3
end)

local cvarBulletSFX = CreateClientConVar( "lvs_bullet_nearmiss", 1, true, false)
LVS.EnableBulletNearmiss = cvarBulletSFX and cvarBulletSFX:GetBool() or true
cvars.AddChangeCallback( "lvs_bullet_nearmiss", function( convar, oldValue, newValue ) 
	LVS.EnableBulletNearmiss = tonumber( newValue ) ~=0
end)

local cvarDev = GetConVar( "developer" )
LVS.DeveloperEnabled = cvarDev and (cvarDev:GetInt() >= 1) or false
cvars.AddChangeCallback( "developer", function( convar, oldValue, newValue )
	LVS.DeveloperEnabled = (tonumber( newValue ) or 0) >= 1
end)

cvars.AddChangeCallback( "lvs_mouseaim", function( convar, oldValue, newValue )
	LocalPlayer():lvsBuildControls()

	net.Start("lvs_toggle_mouseaim")
	net.SendToServer()
end)

--PATH addons/lvs_base-main/lua/lvs_framework/autorun/lvs_entitytracker.lua:
LVS.VehiclesStored = LVS.VehiclesStored or {}
LVS.NPCsStored = LVS.NPCsStored or {}

function LVS:GetNPCs()
	for index, ent in pairs( LVS.NPCsStored ) do
		if not IsValid( ent ) then
			LVS.NPCsStored[ index ] = nil
		end
	end

	return LVS.NPCsStored
end

function LVS:GetVehicles()
	for index, ent in pairs( LVS.VehiclesStored ) do
		if not IsValid( ent ) then
			LVS.VehiclesStored[ index ] = nil
		end
	end

	return LVS.VehiclesStored
end

local Teams = {
	["npc_breen"] = 1,
	["npc_combine_s"] = 1,
	["npc_combinedropship"] = 1,
	["npc_combinegunship"] = 1,
	["npc_crabsynth"] = 1,
	["npc_cscanner"] = 1,
	["npc_helicopter"] = 1,
	["npc_manhack"] = 1,
	["npc_metropolice"] = 1,
	["npc_mortarsynth"] = 1,
	["npc_sniper"] = 1,
	["npc_stalker"] = 1,
	["npc_strider"] = 1,
	["npc_hunter"] = 1,

	["monster_human_grunt"] = 1,
	["monster_human_assassin"] = 1,
	["monster_sentry"] = 1,

	["npc_kleiner"] = 2,
	["npc_monk"] = 2,
	["npc_mossman"] = 2,
	["npc_vortigaunt"] = 2,
	["npc_alyx"] = 2,
	["npc_barney"] = 2,
	["npc_citizen"] = 2,
	["npc_dog"] = 2,
	["npc_eli"] = 2,
	["monster_scientist"] = 2,
	["monster_barney"] = 2,

	["npc_zombine"] = 3,
	["npc_fastzombie"] = 3,
	["npc_headcrab"] = 3,
	["npc_headcrab_black"] = 3,
	["npc_headcrab_fast"] = 3,
	["npc_antlion"] = 3,
	["npc_antlionguard"] = 3,
	["npc_zombie"] = 3,
	["npc_zombie_torso"] = 3,
	["npc_poisonzombie"] = 3,
	["monster_alien_grunt"] = 3,
	["monster_alien_slave"] = 3,
	["monster_gargantua"] = 3,
	["monster_bullchicken"] = 3,
	["monster_headcrab"] = 3,
	["monster_babycrab"] = 3,
	["monster_zombie"] = 3,
	["monster_houndeye"] = 3,
	["monster_nihilanth"] = 3,
	["monster_bigmomma"] = 3,
	["monster_babycrab"] = 3,
}
function LVS:GetNPCRelationship( npc_class )
	return Teams[ npc_class ] or 0
end

hook.Add( "OnEntityCreated", "!!!!lvsEntitySorter", function( ent )
	timer.Simple( 2, function() 
		if not IsValid( ent ) then return end

		if isfunction( ent.IsNPC ) and ent:IsNPC() then
			table.insert( LVS.NPCsStored, ent )

			if SERVER then
				hook.Run( "LVS.UpdateRelationship", ent )
			end
		end

		if ent.LVS then 
			if CLIENT and ent.PrintName then
				language.Add( ent:GetClass(), ent.PrintName)
			end

			table.insert( LVS.VehiclesStored, ent )

			if SERVER then
				LVS:FixVelocity()

				hook.Run( "LVS.UpdateRelationship", ent )
			end
		end
	end )
end )
--PATH addons/lvs_base-main/lua/lvs_framework/autorun/lvs_keybinding.lua:

hook.Add( "LVS:Initialize", "!!11lvs_default_keys", function()
	local KEYS = {
		{
			name = "ATTACK",
			category = "Armament",
			name_menu = "Attack",
			default = MOUSE_LEFT,
			cmd = "lvs_lmb"
		},
		{
			name = "ZOOM",
			category = "Armament",
			name_menu = "Zoom",
			default = MOUSE_RIGHT,
			cmd = "lvs_rmb"
		},
		{
			name = "~SELECT~WEAPON#1",
			category = "Armament",
			name_menu = "Select Weapon 1",
			cmd = "lvs_select_weapon1"
		},
		{
			name = "~SELECT~WEAPON#2",
			category = "Armament",
			name_menu = "Select Weapon 2",
			cmd = "lvs_select_weapon2"
		},
		{
			name = "~SELECT~WEAPON#3",
			category = "Armament",
			name_menu = "Select Weapon 3",
			cmd = "lvs_select_weapon3"
		},
		{
			name = "~SELECT~WEAPON#4",
			category = "Armament",
			name_menu = "Select Weapon 4",
			cmd = "lvs_select_weapon4"
		},
		--[[ only adding 4 because i dont want to bloat the menu. There can be added as many keys as neededed the system should figure it out by itself
		{
			name = "~SELECT~WEAPON#5",
			category = "Armament",
			name_menu = "Select Weapon 5",
			cmd = "lvs_select_weapon5"
		},
		]]
		{
			name = "EXIT",
			category = "Misc",
			name_menu = "Exit Vehicle",
			default = "+use",
			cmd = "lvs_exit"
		},
		{
			name = "VIEWDIST",
			category = "Misc",
			name_menu = "Enable Mouse-Wheel Set-Camera-Distance",
			default = MOUSE_MIDDLE,
			cmd = "lvs_viewzoom"
		},
		{
			name = "VIEWHEIGHT",
			category = "Misc",
			name_menu = "Set-Camera-Distance => Set-Camera-Height",
			default = "phys_swap",
			cmd = "lvs_viewheight"
		},
		{
			name = "THIRDPERSON",
			category = "Misc",
			name_menu = "Toggle Thirdperson",
			default = "+duck",
			cmd = "lvs_thirdperson"
		},
		{
			name = "FREELOOK",
			category = "Misc",
			name_menu = "Freelook (Hold)",
			default = "+walk",
			cmd = "lvs_freelook"
		},
		{
			name = "ENGINE",
			category = "Misc",
			name_menu = "Toggle Engine",
			default = "+reload",
			cmd = "lvs_startengine"
		},
		{
			name = "VSPEC",
			category = "Misc",
			name_menu = "Toggle Vehicle-specific Function",
			default = "+jump",
			cmd = "lvs_special"
		},
	}

	for _, v in pairs( KEYS ) do
		LVS:AddKey( v.name, v.category, v.name_menu, v.cmd, v.default )
	end
end )

if SERVER then return end

concommand.Add( "lvs_mouseaim_toggle", function( ply, cmd, args )
	local OldVar = GetConVar( "lvs_mouseaim" ):GetInt()

	if OldVar == 0 then
		ply:PrintMessage( HUD_PRINTTALK, "[LVS] Mouse-Aim: Enabled" )
		RunConsoleCommand( "lvs_mouseaim", "1" )

	else
		ply:PrintMessage( HUD_PRINTTALK, "[LVS] Mouse-Aim: Disabled" )
		RunConsoleCommand( "lvs_mouseaim", "0" )
	end
end )

hook.Add( "PlayerBindPress", "!!!!_LVS_PlayerBindPress", function( ply, bind, pressed )
	if not ply.lvsGetVehicle then return end

	local vehicle = ply:lvsGetVehicle()

	if not IsValid( vehicle ) then return end

	if not ply:lvsKeyDown( "VIEWDIST" ) then
		if string.find( bind, "invnext" ) then
			vehicle:NextWeapon()
		end
		if string.find( bind, "invprev" ) then
			vehicle:PrevWeapon()
		end
	end

	if string.find( bind, "+zoom" ) then
		if vehicle.lvsDisableZoom then
			return true
		end
	end
end )

hook.Add( "SpawnMenuOpen", "!!!lvs_spawnmenudisable", function()
	local ply = LocalPlayer() 

	if not ply._lvsDisableSpawnMenu or not IsValid( ply:lvsGetVehicle() ) then return end

	return false
end )

hook.Add( "ContextMenuOpen", "!!!lvs_contextmenudisable", function()
	local ply = LocalPlayer() 

	if not ply._lvsDisableContextMenu or not IsValid( ply:lvsGetVehicle() ) then return end

	return false
end )

--PATH addons/_mayor_voting_systems/lua/autorun/mayorvoting.lua:
if SERVER then
	AddCSLuaFile()
	AddCSLuaFile('cl_mayorvoting.lua')
	AddCSLuaFile('sh_votingconfig.lua')
	AddCSLuaFile('cl_votingfonts.lua')
	AddCSLuaFile('panels/cl_votingpanel.lua')
	AddCSLuaFile('panels/cl_playericon.lua')
	include('sv_mayorvoting.lua')
end

if CLIENT then
	include('cl_mayorvoting.lua')
end
--PATH addons/media_player/lua/mediaplayer/sh_events.lua:
MP.EVENTS = {
	MEDIA_CHANGED = "mediaChanged",
	QUEUE_CHANGED = "mp.events.queueChanged",
	PLAYER_STATE_CHANGED = "mp.events.playerStateChanged"
}

if CLIENT then

	table.Merge( MP.EVENTS, {
		VOLUME_CHANGED = "mp.events.volumeChanged"
	} )

end

--PATH addons/media_player/lua/mediaplayer/services/googledrive/shared.lua:
DEFINE_BASECLASS( "mp_service_base" )

SERVICE.Name 	= "Google Drive"
SERVICE.Id 		= "gd"
SERVICE.Base 	= "yt"

local GdFileIdPattern = "[%a%d-_]+"
local UrlSchemes = {
	"docs%.google%.com/file/d/" .. GdFileIdPattern .. "/",
	"drive%.google%.com/file/d/" .. GdFileIdPattern .. "/"
}

function SERVICE:New( url )
	local obj = BaseClass.New(self, url)
	obj._data = obj:GetGoogleDriveFileId()
	return obj
end

function SERVICE:Match( url )
	for _, pattern in pairs(UrlSchemes) do
		if string.find( url, pattern ) then
			return true
		end
	end
	return false
end

function SERVICE:IsTimed()
	return true
end

function SERVICE:GetGoogleDriveFileId()

	local videoId

	if self.videoId then

		videoId = self.videoId

	elseif self.urlinfo then

		local url = self.urlinfo

		-- https://docs.google.com/file/d/(videoId)
		if url.path and string.match(url.path, "^/file/d/([%a%d-_]+)") then
			videoId = string.match(url.path, "^/file/d/([%a%d-_]+)")
		end

		self.videoId = videoId

	end

	return videoId

end

-- Used for clientside inheritence of the YouTube service
SERVICE.GetYouTubeVideoId = GetGoogleDriveFileId

--PATH addons/media_player/lua/mediaplayer/services/twitchstream/cl_init.lua:
include "shared.lua"

local htmlBaseUrl = MediaPlayer.GetConfigValue('html.base_url')

DEFINE_BASECLASS( "mp_service_browser" )

local TwitchUrl = "http://www.twitch.tv/%s/popout"

local JS_Play = "if(window.MediaPlayer) MediaPlayer.play();"
local JS_Pause = "if(window.MediaPlayer) MediaPlayer.pause();"

local JS_HideControls = [[
document.body.style.cssText = 'overflow:hidden;height:106.8% !important';]]

function SERVICE:OnBrowserReady( browser )

	BaseClass.OnBrowserReady( self, browser )

	local channel = self:GetTwitchChannel()
	local url = TwitchUrl:format(channel)

	browser:OpenURL( url )

	browser:QueueJavascript( JS_HideControls )
	self:InjectScript( htmlBaseUrl .. "scripts/services/twitch.js" )

end

function SERVICE:Pause()
	BaseClass.Pause( self )

	if ValidPanel(self.Browser) then
		self.Browser:RunJavascript(JS_Pause)
		self._YTPaused = true
	end
end

--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/thirdparty/sh_cami.lua:
--[[
CAMI - Common Admin Mod Interface.
Copyright 2020 CAMI Contributors

Makes admin mods intercompatible and provides an abstract privilege interface
for third party addons.

Follows the specification on this page:
https://github.com/glua/CAMI/blob/master/README.md

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

-- Version number in YearMonthDay format.
local version = 20211019

if CAMI and CAMI.Version >= version then return end

CAMI = CAMI or {}
CAMI.Version = version


--- @class CAMI_USERGROUP
--- defines the charactaristics of a usergroup
--- @field Name string @The name of the usergroup
--- @field Inherits string @The name of the usergroup this usergroup inherits from
--- @field CAMI_Source string @The source specified by the admin mod which registered this usergroup (if any, converted to a string)

--- @class CAMI_PRIVILEGE
--- defines the charactaristics of a privilege
--- @field Name string @The name of the privilege
--- @field MinAccess "'user'" | "'admin'" | "'superadmin'" @Default group that should have this privilege
--- @field Description string | nil @Optional text describing the purpose of the privilege
local CAMI_PRIVILEGE = {}
--- Optional function to check if a player has access to this privilege
--- (and optionally execute it on another player)
---
--- ⚠ **Warning**: This function may not be called by all admin mods
--- @param actor GPlayer @The player
--- @param target GPlayer | nil @Optional - the target
--- @return boolean @If they can or not
--- @return string | nil @Optional reason
function CAMI_PRIVILEGE:HasAccess(actor, target)
end

--- Contains the registered CAMI_USERGROUP usergroup structures.
--- Indexed by usergroup name.
--- @type CAMI_USERGROUP[]
local usergroups = CAMI.GetUsergroups and CAMI.GetUsergroups() or {
    user = {
        Name = "user",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    admin = {
        Name = "admin",
        Inherits = "user",
        CAMI_Source = "Garry's Mod",
    },
    superadmin = {
        Name = "superadmin",
        Inherits = "admin",
        CAMI_Source = "Garry's Mod",
    }
}

--- Contains the registered CAMI_PRIVILEGE privilege structures.
--- Indexed by privilege name.
--- @type CAMI_PRIVILEGE[]
local privileges = CAMI.GetPrivileges and CAMI.GetPrivileges() or {}

--- Registers a usergroup with CAMI.
---
--- Use the source parameter to make sure CAMI.RegisterUsergroup function and
--- the CAMI.OnUsergroupRegistered hook don't cause an infinite loop
--- @param usergroup CAMI_USERGROUP @The structure for the usergroup you want to register
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return CAMI_USERGROUP @The usergroup given as an argument
function CAMI.RegisterUsergroup(usergroup, source)
    if source then
        usergroup.CAMI_Source = tostring(source)
    end
    usergroups[usergroup.Name] = usergroup

    hook.Call("CAMI.OnUsergroupRegistered", nil, usergroup, source)
    return usergroup
end

--- Unregisters a usergroup from CAMI. This will call a hook that will notify
--- all other admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the usergroup is to be permanently removed.
---
--- Use the source parameter to make sure CAMI.UnregisterUsergroup function and
--- the CAMI.OnUsergroupUnregistered hook don't cause an infinite loop
--- @param usergroupName string @The name of the usergroup.
--- @param source any @Identifier for your own admin mod. Can be anything.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterUsergroup(usergroupName, source)
    if not usergroups[usergroupName] then return false end

    local usergroup = usergroups[usergroupName]
    usergroups[usergroupName] = nil

    hook.Call("CAMI.OnUsergroupUnregistered", nil, usergroup, source)

    return true
end

--- Retrieves all registered usergroups.
--- @return CAMI_USERGROUP[] @Usergroups indexed by their names.
function CAMI.GetUsergroups()
    return usergroups
end

--- Receives information about a usergroup.
--- @param usergroupName string
--- @return CAMI_USERGROUP | nil @Returns nil when the usergroup does not exist.
function CAMI.GetUsergroup(usergroupName)
    return usergroups[usergroupName]
end

--- Checks to see if potentialAncestor is an ancestor of usergroupName.
--- All usergroups are ancestors of themselves.
---
--- Examples:
--- * `user` is an ancestor of `admin` and also `superadmin`
--- * `admin` is an ancestor of `superadmin`, but not `user`
--- @param usergroupName string @The usergroup to query
--- @param potentialAncestor string @The ancestor to query
--- @return boolean @Whether usergroupName inherits potentialAncestor.
function CAMI.UsergroupInherits(usergroupName, potentialAncestor)
    repeat
        if usergroupName == potentialAncestor then return true end

        usergroupName = usergroups[usergroupName] and
                         usergroups[usergroupName].Inherits or
                         usergroupName
    until not usergroups[usergroupName] or
          usergroups[usergroupName].Inherits == usergroupName

    -- One can only be sure the usergroup inherits from user if the
    -- usergroup isn't registered.
    return usergroupName == potentialAncestor or potentialAncestor == "user"
end

--- Find the base group a usergroup inherits from.
---
--- This function traverses down the inheritence chain, so for example if you have
--- `user` -> `group1` -> `group2`
--- this function will return `user` if you pass it `group2`.
---
--- ℹ **NOTE**: All usergroups must eventually inherit either user, admin or superadmin.
--- @param usergroupName string @The name of the usergroup
--- @return "'user'" | "'admin'" | "'superadmin'" @The name of the root usergroup
function CAMI.InheritanceRoot(usergroupName)
    if not usergroups[usergroupName] then return end

    local inherits = usergroups[usergroupName].Inherits
    while inherits ~= usergroups[usergroupName].Inherits do
        usergroupName = usergroups[usergroupName].Inherits
    end

    return usergroupName
end

--- Registers an addon privilege with CAMI.
---
--- ⚠ **Warning**: This should only be used by addons. Admin mods must *NOT*
---  register their privileges using this function.
--- @param privilege CAMI_PRIVILEGE
--- @return CAMI_PRIVILEGE @The privilege given as argument.
function CAMI.RegisterPrivilege(privilege)
    privileges[privilege.Name] = privilege

    hook.Call("CAMI.OnPrivilegeRegistered", nil, privilege)

    return privilege
end

--- Unregisters a privilege from CAMI.
--- This will call a hook that will notify any admin mods of the removal.
---
--- ⚠ **Warning**: Call only when the privilege is to be permanently removed.
--- @param privilegeName string @The name of the privilege.
--- @return boolean @Whether the unregistering succeeded.
function CAMI.UnregisterPrivilege(privilegeName)
    if not privileges[privilegeName] then return false end

    local privilege = privileges[privilegeName]
    privileges[privilegeName] = nil

    hook.Call("CAMI.OnPrivilegeUnregistered", nil, privilege)

    return true
end

--- Retrieves all registered privileges.
--- @return CAMI_PRIVILEGE[] @All privileges indexed by their names.
function CAMI.GetPrivileges()
    return privileges
end

--- Receives information about a privilege.
--- @param privilegeName string
--- @return CAMI_PRIVILEGE | nil
function CAMI.GetPrivilege(privilegeName)
    return privileges[privilegeName]
end

-- Default access handler
local defaultAccessHandler = {["CAMI.PlayerHasAccess"] =
    function(_, actorPly, privilegeName, callback, targetPly, extraInfoTbl)
        -- The server always has access in the fallback
        if not IsValid(actorPly) then return callback(true, "Fallback.") end

        local priv = privileges[privilegeName]

        local fallback = extraInfoTbl and (
            not extraInfoTbl.Fallback and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "user" and true or
            extraInfoTbl.Fallback == "admin" and actorPly:IsAdmin() or
            extraInfoTbl.Fallback == "superadmin" and actorPly:IsSuperAdmin())


        if not priv then return callback(fallback, "Fallback.") end

        local hasAccess =
            priv.MinAccess == "user" or
            priv.MinAccess == "admin" and actorPly:IsAdmin() or
            priv.MinAccess == "superadmin" and actorPly:IsSuperAdmin()

        if hasAccess and priv.HasAccess then
            hasAccess = priv:HasAccess(actorPly, targetPly)
        end

        callback(hasAccess, "Fallback.")
    end,
    ["CAMI.SteamIDHasAccess"] =
    function(_, _, _, callback)
        callback(false, "No information available.")
    end
}

--- @class CAMI_ACCESS_EXTRA_INFO
--- @field Fallback "'user'" | "'admin'" | "'superadmin'" @Fallback status for if the privilege doesn't exist. Defaults to `admin`.
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a player has access to a privilege
--- (and optionally can execute it on targetPly)
---
--- This function is designed to be asynchronous but will be invoked
---  synchronously if no callback is passed.
---
--- ⚠ **Warning**: If the currently installed admin mod does not support
---                 synchronous queries, this function will throw an error!
--- @param actorPly GPlayer @The player to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive the answer, or nil for synchronous
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
--- @return boolean | nil @Synchronous only - if the player has the privilege
--- @return string | nil @Synchronous only - optional reason from admin mod
function CAMI.PlayerHasAccess(actorPly, privilegeName, callback, targetPly,
extraInfoTbl)
    local hasAccess, reason = nil, nil
    local callback_ = callback or function(hA, r) hasAccess, reason = hA, r end

    hook.Call("CAMI.PlayerHasAccess", defaultAccessHandler, actorPly,
        privilegeName, callback_, targetPly, extraInfoTbl)

    if callback ~= nil then return end

    if hasAccess == nil then
        local err = [[The function CAMI.PlayerHasAccess was used to find out
        whether Player %s has privilege "%s", but an admin mod did not give an
        immediate answer!]]
        error(string.format(err,
            actorPly:IsPlayer() and actorPly:Nick() or tostring(actorPly),
            privilegeName))
    end

    return hasAccess, reason
end

--- Get all the players on the server with a certain privilege
--- (and optionally who can execute it on targetPly)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param privilegeName string @The privilege to query
--- @param callback fun(players: GPlayer[]) @Callback to receive the answer
--- @param targetPly GPlayer | nil @Optional - target for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.GetPlayersWithAccess(privilegeName, callback, targetPly,
extraInfoTbl)
    local allowedPlys = {}
    local allPlys = player.GetAll()
    local countdown = #allPlys

    local function onResult(ply, hasAccess, _)
        countdown = countdown - 1

        if hasAccess then table.insert(allowedPlys, ply) end
        if countdown == 0 then callback(allowedPlys) end
    end

    for _, ply in ipairs(allPlys) do
        CAMI.PlayerHasAccess(ply, privilegeName,
            function(...) onResult(ply, ...) end,
            targetPly, extraInfoTbl)
    end
end

--- @class CAMI_STEAM_ACCESS_EXTRA_INFO
--- @field IgnoreImmunity boolean @Ignore any immunity mechanisms an admin mod might have.
--- @field CommandArguments table @Extra arguments that were given to the privilege command.

--- Checks if a (potentially offline) SteamID has access to a privilege
--- (and optionally if they can execute it on a target SteamID)
---
--- ℹ **NOTE**: This is an asynchronous function!
--- @param actorSteam string | nil @The SteamID to query
--- @param privilegeName string @The privilege to query
--- @param callback fun(hasAccess: boolean, reason: string|nil) @Callback to receive  the answer
--- @param targetSteam string | nil @Optional - target SteamID for if the privilege effects another player (eg kick/ban)
--- @param extraInfoTbl CAMI_STEAM_ACCESS_EXTRA_INFO | nil @Table of extra information for the admin mod
function CAMI.SteamIDHasAccess(actorSteam, privilegeName, callback,
targetSteam, extraInfoTbl)
    hook.Call("CAMI.SteamIDHasAccess", defaultAccessHandler, actorSteam,
        privilegeName, callback, targetSteam, extraInfoTbl)
end

--- Signify that your admin mod has changed the usergroup of a player. This
--- function communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param ply GPlayer @The player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalUserGroupChanged(ply, old, new, source)
    hook.Call("CAMI.PlayerUsergroupChanged", nil, ply, old, new, source)
end

--- Signify that your admin mod has changed the usergroup of a disconnected
--- player. This communicates to other admin mods what it thinks the usergroup
--- of a player should be.
---
--- Listen to the hook to receive the usergroup changes of other admin mods.
--- @param steamId string @The steam ID of the player for which the usergroup is changed
--- @param old string @The previous usergroup of the player.
--- @param new string @The new usergroup of the player.
--- @param source any @Identifier for your own admin mod. Can be anything.
function CAMI.SignalSteamIDUserGroupChanged(steamId, old, new, source)
    hook.Call("CAMI.SteamIDUsergroupChanged", nil, steamId, old, new, source)
end

--PATH addons/____onyx_framework_2/lua/onyx/framework/libs/sh_inconfig.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

03/05/2023

--]]

if (netchunk == nil) then
    include('sh_netchunk.lua')
end

netchunk.Register('onyx:SyncConfig')

onyx.inconfig = onyx.inconfig or {}
onyx.inconfig.options = onyx.inconfig.options or {}
onyx.inconfig.values = onyx.inconfig.values or {}
onyx.inconfig.index = onyx.inconfig.index or {}

local inconfig = onyx.inconfig

function inconfig:Register(id, data)
    assert(isstring(id), 'bad argument #1 to \'inconfig:Register\' (string expected, got ' .. type(id) .. ')')
    assert(istable(data), 'bad argument #2 to \'inconfig:Register\' (table expected, got ' .. type(data) .. ')')
    assert(data.type, 'you must provide type in option data (' .. id .. ')')
    assert(data.default ~= nil, 'you must provide default value in option data (' .. id .. ')')
    assert(isstring(data.cami), Format('bad field \"cami\"\'s value in option \"%s\" (expected string, got %s)', id, type(data.cami)))
    data.id = id
    if (SERVER) then
        data.title = nil
        data.desc = nil
    end
    if (not self.options[id]) then
        data.index = table.insert(inconfig.index, id)
    end
    self.options[id] = data
    return data
end

function inconfig:Get(id)
    local value = self.values[id]
    if (value ~= nil) then
        return value
    else
        local option = self.options[id]
        assert(option, 'trying to get value from unregistered option (' .. id .. ')')
        return option.default
    end
end

do
    inconfig.Error = {
        INVALID_VALUE = 0x0,
        NUMBER_EXPECTED = 0x1,
        STRING_EXPECTED = 0x2,
        MIN_CHARS = 0x3,
        MAX_CHARS = 0x4,
        MIN_NUMBER = 0x5,
        MAX_NUMBER = 0x6,
        INVALID_MODEL = 0x7
    }

    local types = {}
    types['bool'] = function(option, value)
        return isbool(value)
    end
    types['int'] = function(option, value)
        if (not isnumber(value)) then
            return false, inconfig.Error.NUMBER_EXPECTED
        end

        if (option.min and value < option.min) then
            return false, inconfig.Error.MIN_NUMBER, option.min
        end

        if (option.max and value > option.max) then
            return false, inconfig.Error.MAX_NUMBER, option.max
        end

        return true
    end
    types['string'] = function(option, value)
        if (not isstring(value)) then
            return false, inconfig.Error.STRING_EXPECTED
        end

        value = value:Trim()

        local len = utf8.len(value)

        if (option.min and len < option.min) then
            return false, inconfig.Error.MIN_CHARS
        end

        if (option.max and len > option.max) then
            return false, inconfig.Error.MAX_CHARS
        end

        return true
    end
    types['model'] = function(option, value)
        if (not isstring(value)) then
            return false, inconfig.Error.STRING_EXPECTED
        end

        value = value:Trim()

        local validModel = value:Right(4) == '.mdl'

        return validModel, inconfig.Error.INVALID_MODEL
    end

    function inconfig:CheckValue(id, value)
        local option = self.options[id]
        if (value == nil) then return false, inconfig.Error.INVALID_VALUE end

        local check = types[option.type]

        assert(check, 'invalid type (' .. option.type .. ') for option (' .. id .. ')')

        local allowed, enumError, argument = check(option, value)

        if (allowed and option.check) then
            return option.check(value)
        end

        return allowed, enumError, argument
    end
end

if (SERVER) then
    util.AddNetworkString('onyx.inconfig:Set')
    util.AddNetworkString('onyx.inconfig:SetTable')
    util.AddNetworkString('onyx.inconfig:SyncSingle')

    function inconfig:Set(id, value, bIgnoreOnSet)
        local option = self.options[id]
        assert(option, 'invalid option (' .. id .. ')')

        self.values[id] = value

        if (not bIgnoreOnSet and option.onSet) then
            option.onSet(value)
        end

        net.Start('onyx.inconfig:SyncSingle')
            net.WriteString(id)
            net.WriteString(onyx.TypeToString(value))
        net.Broadcast()

        hook.Run('onyx.inconfig.OnValueChange', id, value)
    end

    function inconfig:Sync(ply)
        netchunk.Send(ply, 'onyx:SyncConfig', self.values)
    end

    net.Receive('onyx.inconfig:Set', function(len, ply)
        local optionID = net.ReadString()
        local optionTable = inconfig.options[optionID]
        if (not optionTable) then return end
        if (ply:GetVar('onyx_inconfigRequestDelay', 0) > CurTime()) then return end

        ply:SetVar('onyx_inconfigRequestDelay', CurTime() + 1)

        local valueStr = net.ReadString() -- I guess that would be better than net.ReadType
        local success, valueParsed = pcall(onyx.StringToType, valueStr) -- in case someone tries to throw errors
        if (not success) then return end

        if (not inconfig:CheckValue(optionID, valueParsed)) then
            return
        end

        CAMI.PlayerHasAccess(ply, optionTable.cami, function(bAllowed)
            if (bAllowed) then
                inconfig:Set(optionID, valueParsed)
            end
        end)
    end)

    net.Receive('onyx.inconfig:SetTable', function(len, ply)
        -- local optionID = net.ReadString()
        if (ply:GetVar('onyx_inconfigRequestDelay', 0) > CurTime()) then return end

        ply:SetVar('onyx_inconfigRequestDelay', CurTime() + 1)

        local amount = net.ReadUInt(6)
        for index = 1, amount do
            local optionID = net.ReadString()
            local optionTable = inconfig.options[optionID]
            if (not optionTable) then return end -- not continue, just return, how can a player request to set invalid option without sending fake net messages :\

            local valueStr = net.ReadString() -- I guess that would be better than net.ReadType
            local success, valueParsed = pcall(onyx.StringToType, valueStr) -- in case someone tries to throw errors
            if (not success) then continue end -- just in case

            if (not inconfig:CheckValue(optionID, valueParsed)) then
                continue
            end

            CAMI.PlayerHasAccess(ply, optionTable.cami, function(bAllowed) -- every option may have own cami privilege
                if (bAllowed) then
                    inconfig:Set(optionID, valueParsed)
                end
            end)
        end
    end)

    hook.Add('onyx.PlayerNetworkReady', 'onyx.inconfig.Sync', function(ply)
        inconfig:Sync(ply)
    end)
else
    netchunk.Callback('onyx:SyncConfig', function(data)
        onyx.inconfig.values = data
        onyx:Print('Synchronized settings.')
        hook.Run('onyx.inconfig.Synchronized')
    end)

    net.Receive('onyx.inconfig:SyncSingle', function()
        local optionID = net.ReadString()
        local value = net.ReadString()
        local optionValue = onyx.StringToType(value)
        local oldValue = onyx.inconfig.values[optionID]

        onyx:Print('Updated option #, new value: #', optionID, value)
        onyx.inconfig.values[optionID] = optionValue

        hook.Run('onyx.inconfig.Updated', optionID, oldValue, optionValue)
    end)
end
--PATH addons/____onyx_framework_2/lua/onyx/ui/sh_init_ui.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

05/06/2022

--]]

onyx.IncludeFolder('onyx/ui/libs/thirdparty/')
onyx.IncludeFolder('onyx/ui/libs/')
onyx.IncludeFolder('onyx/ui/cfg/', true)
onyx.IncludeFolder('onyx/ui/core/', true)
onyx.IncludeFolder('onyx/ui/traits/', true)
onyx.IncludeFolder('onyx/ui/elements/', true)
--PATH addons/____onyx_framework_2/lua/onyx/ui/libs/cl_gui.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

15/04/2022

--]]

onyx.gui = {}
onyx.gui.funcs = {}

local gui = onyx.gui

function gui.Register(name, metatable, parent)
    gui.Extend(metatable)
    vgui.Register(name, metatable, parent)
end

function gui.Extend(obj)
    for name, fn in pairs(onyx.gui.funcs) do
        obj[name] = fn
    end
end

function gui.RegisterFunc(name, fn)
    onyx.gui.funcs[name] = fn
end

-- Events

function gui.AddEvent(panel, name, fn)
    panel.onyxEvents = panel.onyxEvents or {}
    panel.onyxEvents[name] = panel.onyxEvents[name] or {
        count = 0
    }

    local storage = panel.onyxEvents[name]
    local index = storage.count + 1

    storage.count = index
    storage[index] = fn

    return index
end

function gui.RemoveEvent(panel, name, index)
    if (not panel.onyxEvents) then return false end

    local cache = panel.onyxEvents[name]
    if (not cache) then return false end

    local func = cache[index]
    if (not func) then return false end

    cache[index] = nil

    return true
end

function gui.CallEvent(panel, name, ignoreRaw, ...)
    local events = panel.onyxEvents or {}

    if not ignoreRaw and panel[name] then
        local val = panel[name](panel, ...)
        if val then
            return val
        end
    end

    local storage = events[name]
    if storage then
        for i = 1, storage.count do
            local fn = storage[i]
            if fn then
                local val = fn(panel, ...)
                if val then
                    return val
                end
            end
        end
    end
end

function gui.InjectEventHandler(panel, fnName)
    panel.onyxEventHandlers = panel.onyxEventHandlers or {}

    if panel.onyxEventHandlers[fnName] then
        return false
    end

    local oldFn = panel[fnName]

    panel[fnName] = function(self, a1, a2, a3, a4, a5, a6)
        if oldFn then
            oldFn(self, a1, a2, a3, a4, a5, a6)
        end

        -- call all events except the old function
        gui.CallEvent(self, fnName, true, a1, a2, a3, a4, a5, a6)
    end

    panel.onyxEventHandlers[fnName] = true

    return true
end

function gui.HasEventHandler(panel, fnName)
    if panel.onyxEventHandlers then
        return panel.onyxEventHandlers[fnName]
    end
end

function gui.Test(class, w, h, fn)
    if IsValid(gui.oldDebugPanel) then
        gui.oldDebugPanel:Remove()
    end

    local pnl = vgui.Create(class)
    if IsValid(pnl) then
        pnl:SetSize(ScrW() * w, ScrH() * h)
        pnl:Center()
        fn(pnl, pnl:GetWide(), pnl:GetTall())
    end
    gui.oldDebugPanel = pnl
end

gui.Register('onyx.Panel', {Init = function() end})
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_combo.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

22/04/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorGray = Color(125, 125, 125)
local wimgArrow = onyx.wimg.Simple('https://i.imgur.com/KGC51Ws.png', 'smooth mips')

AccessorFunc(PANEL, 'm_CurrentOptionText', 'CurrentOptionText')
AccessorFunc(PANEL, 'm_Font', 'Font')
AccessorFunc(PANEL, 'm_colOutlineActiveColor', 'OutlineActiveColor')
AccessorFunc(PANEL, 'm_colOutlineIdleColor', 'OutlineIdleColor')
AccessorFunc(PANEL, 'm_bHideOptionIcon', 'HideOptionIcon')

function PANEL:Init()
    self:Import('click')
    self:Import('hovercolor')
    self:SetTall(onyx.ScaleTall(30))

    self:SetColorKey('backgroundColor')
    self:SetColorIdle(colorPrimary)
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5))

    self:SetFont(onyx.Font('Comfortaa@16'))

    self:SetOutlineIdleColor(colorSecondary)
    self:SetOutlineActiveColor(colorAccent)
    self:Reset()

    self.options = {}
end

function PANEL:SetOutlineIdleColor(color)
    self.m_colOutlineIdleColor = color
    self.currentOutlineColor = onyx.CopyColor(color)
end

function PANEL:Paint(w, h)
    local thickness = 1
    local currentOutlineColor = self.currentOutlineColor

    if (self.highlight) then
        currentOutlineColor = ColorAlpha(self.highlightColor, math.abs(math.sin(CurTime() * 6)) * 200 + 55)
        if (self.highlightEndTime and self.highlightEndTime <= CurTime()) then
            self:ResetHighlight()
        end
    end

    draw.RoundedBox(8, 0, 0, w, h, currentOutlineColor)
    draw.RoundedBox(8, thickness, thickness, w - thickness * 2, h - thickness * 2, self.backgroundColor)

    local x = onyx.ScaleWide(10)
    local material = self.wimage and self.wimage:GetMaterial() or self.material

    if (material and self.current > 0 and not self.m_bHideOptionIcon) then
        local size = onyx.ScaleTall(12)

        surface.SetDrawColor(color_white)
        surface.SetMaterial(material)
        surface.DrawTexturedRect(x, h * .5 - size * .5, size, size)

        x = x + size + onyx.ScaleWide(5)
    end

    draw.SimpleText(self.m_CurrentOptionText, self.m_Font, x, h * .5, self.current > 0 and color_white or colorGray, 0, 1)

    local sz = math.floor(h * .33)
    wimgArrow:DrawRotated(w - h * .5, h * .5, sz, sz, 0, color_white)
end

function PANEL:AddOption(text, data, bSelectedDefault, icon, url)
    return self:AddOptionAdvanced({
        text = text,
        data = data,
        bSelectedDefault = bSelectedDefault,
        icon = icon
    })
end

function PANEL:AddOptionAdvanced(tblOption)
    return table.insert(self.options, tblOption)
end

function PANEL:ChooseOptionID(index, bIgnoreProcessing)
    local option = self.options[index]
    assert(option, 'trying to set invalid option (index:' .. index .. ')')

    self:SetCurrentOptionText(option.text)
    self.current = index

    if (option.iconURL) then
        self.wimage = onyx.wimg.Simple(option.iconURL, option.iconParams)
    else
        self.wimage = nil
    end

    if (not bIgnoreProcessing) then
        self:Call('OnSelect', nil, index, option.text, option.data)
    end
end

function PANEL:GetSelectedID()
    return self.current
end

function PANEL:GetOptionData(index)
    index = index or self.current

    local option = self.options[index]
    if (option) then
        return option.data
    end
end

function PANEL:GetOptionText(index)
    index = index or self.current

    local option = self.options[index]
    if (option) then
        return option.text
    end
end

function PANEL:Reset()
    self.current = -1
    self.wimage = nil
    if (onyx.lang) then
        self:SetCurrentOptionText(onyx.lang:Get('Select an option'))
    else
        self:SetCurrentOptionText('Select an option')
    end
    if (IsValid(self.dmenu)) then
        self.dmenu:Close()
    end
end

function PANEL:Clear()
    self.options = {}
    self:Reset()
end

function PANEL:GetOptions()
    return self.options
end

function PANEL:FindOptionByData(data)
    for index, option in ipairs(self.options) do
        if (option.data and option.data == data) then
            return option, index
        end
    end
end

function PANEL:DoClick()
    if (self.active) then
        return
    end

    self:ResetHighlight()

    local x, y = self:LocalToScreen(0, 0)

    local dmenu = vgui.Create('onyx.Menu')
    dmenu:SetPos(x, y + self:GetTall())
    dmenu:SetMinimumWidth(self:GetWide())
    dmenu.parent = self
    dmenu.Think = function(panel)
        local parent = panel.parent
        if (IsValid(parent)) then
            local x, y = parent:LocalToScreen(0, 0)
            local targetY = y + parent:GetTall()
            if (dmenu:GetY() ~= targetY) then
                dmenu:Close()
            end
            -- dmenu:SetPos(x, targetY)
        end
    end

    for index, option in ipairs(self.options) do
        local opt = dmenu:AddOption(option.text, function()
            self:ChooseOptionID(index)
        end)

        if (option.iconURL) then
            opt:SetIconURL(option.iconURL, option.iconParams)
        end
    end

    dmenu:Open()

    self.dmenu = dmenu
end

function PANEL:SetActive(bBool)
    self.active = bBool
    onyx.anim.Simple(self, .2, {
        currentOutlineColor = (bBool and self.m_colOutlineActiveColor or self.m_colOutlineIdleColor)
    }, 1)
end

function PANEL:Think()
    local bRealActive = IsValid(self.dmenu)
    if (bRealActive ~= self.active) then
        self:SetActive(bRealActive)
    end
end

function PANEL:OnRemove()
    if (IsValid(self.dmenu)) then
        self.dmenu:Remove()
    end
end

function PANEL:OnDisabled()
    local offset = -5
    self.onyxAnims = nil
    self:SetColorIdle(onyx.OffsetColor(colorPrimary, offset))
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5 + offset))
end

function PANEL:OnEnabled()
    local offset = 0
    self.onyxAnims = nil
    self:SetColorIdle(onyx.OffsetColor(colorPrimary, offset))
    self:SetColorHover(onyx.OffsetColor(self:GetColorIdle(), -5 + offset))
end

function PANEL:Highlight(color, time)
    self.highlightColor = color
    self.highlightStartTime = CurTime()
    if (time) then
        self.highlightEndTime = CurTime() + time
    end
    self.highlight = true
end

function PANEL:ResetHighlight()
    self.highlightColor = nil
    self.highlightStartTime = nil
    self.highlightEndTime = nil
    self.highlight = nil
end

onyx.gui.Register('onyx.ComboBox', PANEL)

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     local content = self:Add('Panel')
--     content:Dock(FILL)
--     content:DockMargin(5, 5, 5, 5)

--     for i = 1, 10 do
--         local btn = content:Add('onyx.ComboBox')
--         btn:Dock(TOP)
--         btn:DockMargin(0, 0 ,0 ,5)
--         -- btn:AddOption('Apple')
--         -- btn:AddOption('Banana')
--         -- btn:AddOption('Pear')
--         btn:AddOptionAdvanced({
--             text = 'Apple',
--             iconURL = 'https://i.imgur.com/pkL906D.png',
--             iconParams = 'smooth mips'
--         })
--         btn:AddOptionAdvanced({
--             text = 'Pear',
--             iconURL = 'https://i.imgur.com/Y4UKPLO.png',
--             iconParams = 'smooth mips'
--         })
--         btn:AddOptionAdvanced({
--             text = 'Banana',
--             iconURL = 'https://i.imgur.com/qQl0sr8.png',
--             iconParams = 'smooth mips'
--         })
--         btn:Highlight(Color(212, 72, 72))
--         -- btn:SetHideOptionIcon(true   )
--         -- btn.OnSelect = function(panel, index, text, data)
--         --     panel:Clear()
--         --     panel.current = 1
--         --     panel:SetDisabled(true)
--         --     panel:SetCurrentOptionText('Thank you for your feedback.')
--         -- end
--     end

-- end)
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_settings.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

08/03/2023

--]]

local PANEL = {}

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorAccent = onyx:Config('colors.accent')
local colorNegative = onyx:Config('colors.negative')

local font0 = onyx.Font('Comfortaa Bold@16')
local font3 = onyx.Font('Comfortaa@14')

local wimgSave = onyx.wimg.Simple('https://i.imgur.com/ycSNF3m.png', 'smooth mips')

function PANEL:Init()
    self.list = self:Add('onyx.ScrollPanel')
    self.list:Dock(FILL)

    self.categories = {}
    self.options = {}

    self.confirmPopup = self:Add('DPanel')
    self.confirmPopup:SetWide(onyx.ScaleWide(225))
    self.confirmPopup:SetTall(onyx.ScaleTall(75))
    self.confirmPopup:Hide()
    self.confirmPopup.Paint = function(panel, w, h)
        local x, y = panel:LocalToScreen(0, 0)

        if (panel.anim == 0 or panel.anim == 1) then
            onyx.bshadows.BeginShadow()
                draw.RoundedBox(8, x, y, w, h, colorSecondary)
            onyx.bshadows.EndShadow(1, 2, 2)
        else
            draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
        end
    end
    self.confirmPopup.PerformLayout = function(panel, w, h)
        local padding = ScreenScale(2)

        panel:DockPadding(padding, padding, padding, padding)

        panel.info:Dock(FILL)
        panel.info:DockMargin(0, 0, 0, onyx.ScaleTall(5))
        panel.button:Dock(BOTTOM)
        panel.button:SetTall(onyx.ScaleTall(20))
    end

    self.confirmPopup.info = self.confirmPopup:Add('Panel')
    self.confirmPopup.info.text1 = onyx.lang:GetWFallback('unsavedSettings', 'UNSAVED SETTINGS')
    self.confirmPopup.info.text2 = onyx.lang:GetWFallback('confirmSave', 'Confirm to save the changes')
    self.confirmPopup.info.Paint = function(panel, w ,h)
        local size = math.ceil(h * .5)

        wimgSave:Draw(h * .5 - size * .5, h * .5 - size * .5, size, size, colorNegative)

        draw.SimpleText(panel.text1, font0, h, h * .5, colorNegative, 0, 4)
        draw.SimpleText(panel.text2, font3, h, h * .5, color_white, 0, 0)
    end

    self.confirmPopup.button = self.confirmPopup:Add('onyx.Button')
    self.confirmPopup.button:SetText(onyx.lang:GetWFallback('save_u', 'SAVE'))
    self.confirmPopup.button:SetFont(font0)
    self.confirmPopup.button:SetColorIdle(colorNegative)
    self.confirmPopup.button:SetColorHover(onyx.OffsetColor(colorNegative, -20))
    self.confirmPopup.button.DoClick = function()
        local changes = self:GetChanges()
        if (changes) then
            local amount = table.Count(changes)
            if (amount > 0) then

                -- better than sending multiple packets bc a lot of large-scale servers have anti net spam and etc.
                net.Start('onyx.inconfig:SetTable')
                    net.WriteUInt(amount, 6)
                    for id, value in pairs(changes) do
                        net.WriteString(id)
                        net.WriteString(onyx.TypeToString(value))
                    end
                net.SendToServer()
            end
        end
    end
end

local translate do
    local enums = {}
    enums[onyx.inconfig.Error.INVALID_VALUE] = 'The value must be valid!'
    enums[onyx.inconfig.Error.NUMBER_EXPECTED] = 'The must enter a valid number!'
    enums[onyx.inconfig.Error.STRING_EXPECTED] = 'The text entry cannot be empty!'
    enums[onyx.inconfig.Error.MIN_CHARS] = 'The text must contain more than %i characters!'
    enums[onyx.inconfig.Error.MAX_CHARS] = 'The text must contain less than %i characters!'
    enums[onyx.inconfig.Error.MIN_NUMBER] = 'The number must be higher than %i!'
    enums[onyx.inconfig.Error.MAX_NUMBER] = 'The number must be lower than %i!'
    enums[onyx.inconfig.Error.INVALID_MODEL] = 'The model path must be valid!'

    function translate(enumError, argument)
        local text = enums[enumError] or 'invalid'
        return Format(text, argument)
    end
end

function PANEL:GetChanges(doNotify)
    local changes = {}

    for _, option in ipairs(self.options) do
        local id = option.id
        local newValue = option.getNewValue()
        local curValue = onyx.inconfig:Get(id)
        local valid, err, arg1 = onyx.inconfig:CheckValue(id, newValue)
        local field = option.field
        if (valid) then
            if (field._oldDesc) then
                field.lblDesc:SetText(field._oldDesc)
                field.lblDesc:SetTextColor(color_white)

                if (field.textEntry) then
                    field.textEntry:ResetHighlight()
                end

                field._oldDesc = nil
            end

            if (newValue ~= curValue) then
                changes[id] = newValue
            end
        else
            local entry = field.textEntry
            local textError = isstring(err) and err or translate(err, arg1)

            field._oldDesc = field._oldDesc or field.lblDesc:GetText()
            field.lblDesc:SetTextColor(colorNegative)
            field.lblDesc:SetText(textError)

            if (IsValid(entry)) then
                entry:Highlight(colorNegative)
            end

            if (doNotify) then
                notification.AddLegacy(textError, 1, 5)
            end
        end
    end

    return changes
end

function PANEL:Think()
    if ((self.nextThink or 0) <= CurTime()) then
        local changes = self:GetChanges()
        local anim = table.IsEmpty(changes) and 1 or 0
        local confirmPopup = self.confirmPopup

        if ((confirmPopup.targetAnim or -1) ~= anim) then
            confirmPopup.anim = confirmPopup.anim or anim -- skip first anim

            if (anim < 1) then
                confirmPopup:SetVisible(true)
            end

            onyx.anim.Create(confirmPopup, .2, {
                index = 2,
                easing = 'inOutQuad',
                target = {
                    anim = anim
                },
                think = function(anim, panel)
                    panel:AlignBottom(panel.anim * -panel:GetTall())
                end,
                onFinished = function(anim, panel)
                    panel:SetVisible(panel.anim < 1)
                end
            })

            confirmPopup.targetAnim = anim
        end

        self.nextThink = CurTime() + .25
    end
end

function PANEL:PerformLayout(w, h)
end

function PANEL:LoadAddonSettings(addonID)
    for _, id in ipairs(onyx.inconfig.index) do
        local option = onyx.inconfig.options[id]
        if (option and option.addon and option.addon == addonID) then
            self:AddOption(table.Copy(option))
        end
    end
end

function PANEL:OpenCategories()
    for name, cat in pairs(self.categories) do
        cat:SetExpanded(true)
        cat:UpdateInTick(1)
        cat:UpdateInTick(10)
    end
end

function PANEL:AddOption(option)
    local category = option.category or 'Other'

    table.insert(self.options, option)

    local categoryPanel = self.categories[category]
    if (not categoryPanel) then
        local translatedName = onyx.utf8.upper( onyx.lang:Get( category ) )

        categoryPanel = self.list:Add('onyx.Category')
        categoryPanel:Dock(TOP)
        categoryPanel:SetTitle(translatedName)
        categoryPanel:SetSpace(0)
        categoryPanel:SetInset(onyx.ScaleTall(5))
        categoryPanel:SetTextMargin(onyx.ScaleTall(10))
        categoryPanel:DockMargin(0, 0, 0, onyx.ScaleTall(10))

        categoryPanel.grid = categoryPanel:Add('onyx.Grid')
        categoryPanel.grid:Dock(TOP)
        categoryPanel.grid:SetColumnCount(2)
        categoryPanel.grid:SetSpace(onyx.ScaleTall(5))

        categoryPanel.canvas.Paint = function(p, w, h)
            draw.RoundedBox(8, 0, 0, w, h, colorPrimary)
        end

        self.categories[category] = categoryPanel
    end

    local padding = onyx.ScaleTall(7.5)
    local value = onyx.inconfig:Get(option.id)
    local desc = onyx.lang:Get(option.desc)
    local sType = option.type

    if (sType == 'int' and (option.min or option.max) and not option.combo) then
        desc = desc .. ' (' .. (option.min or '∞') .. ' - ' .. (option.max or '∞') .. ')'
    end

    local field = categoryPanel.grid:Add('DPanel')
    field:SetTall(onyx.ScaleTall(45))
    field:DockPadding(padding, padding, padding, padding)
    field.Paint = function(p, w, h)
        draw.RoundedBox(8, 0, 0, w, h, colorSecondary)
    end

    option.field = field

    local lblName = field:Add('onyx.Label')
    lblName:Font('Comfortaa Bold@16')
    lblName:SetText(onyx.lang:Get(option.title))
    lblName:Color(colorAccent)
    lblName:SetContentAlignment(1)
    lblName:Dock(FILL)

    local lblDesc = field:Add('onyx.Label')
    lblDesc:Font('Comfortaa@14')
    lblDesc:SetText(desc)
    lblDesc:SetContentAlignment(7)
    lblDesc:SetTall((field:GetTall() - padding * 2) * .5)
    lblDesc:Dock(BOTTOM)
    field.lblDesc = lblDesc

    local container = field:Add('Panel')
    container:Dock(RIGHT)
    container:SetWide(onyx.ScaleWide(150))
    container:SetZPos(-1)

    if (option.combo) then
        local combo = container:Add('onyx.ComboBox')
        combo:Dock(FILL)

        for i, opt in ipairs(option.combo) do
            combo:AddOption(onyx.lang:Get(opt[1]), opt[2])

            if (opt[2] == value) then
                combo:ChooseOptionID(i)
            end
        end

        container:SetWide(onyx.ScaleWide(200))

        option.getNewValue = function()
            return combo:GetOptionData( combo:GetSelectedID() )
        end

        field.combo = textEntry

        return
    end

    if (sType == 'string' or sType == 'int' or sType == 'model') then
        local textEntry = container:Add('onyx.TextEntry')
        textEntry:Dock(FILL)
        textEntry:SetValue(value)

        if (sType == 'int') then
            container:SetWide(onyx.ScaleWide(75))
        else
            container:SetWide(onyx.ScaleWide(200))
        end

        option.getNewValue = function()
            if (sType == 'int') then
                return tonumber(textEntry:GetValue())
            else
                return textEntry:GetValue()
            end
        end

        field.textEntry = textEntry
    elseif (sType == 'bool') then
        local check = container:Add('onyx.CheckBox')
        check:SetValue(value)

        option.getNewValue = function()
            return check:GetChecked()
        end

        container:SetWide(onyx.ScaleWide(75))

        container.PerformLayout = function(panel, w, h)
            local child = panel:GetChild(0)
            if (IsValid(child)) then
                child:AlignRight(0)
                child:CenterVertical()
            end
        end
    end
end

onyx.gui.Register('onyx.Configuration', PANEL)
--PATH addons/____onyx_framework_2/lua/onyx/ui/elements/cl_toggler.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

20/01/2024

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorTertiary = onyx:Config('colors.tertiary')
local colorAccent = onyx:Config('colors.accent')

do
    local PANEL = {}

    AccessorFunc(PANEL, 'm_bChecked', 'Checked', FORCE_BOOL)

    function PANEL:Init()
        local size = onyx.ScaleTall(18)

        self.m_bChecked = false

        self:Import('click')
        self:SetSize(size * 2, size)

        self.perfectWidth = size * 2
        self.perfectHeight = size

        self.stateFraction = 0

        self:SetBackgroundColor(colorSecondary)
    end

    function PANEL:Paint(w, h)
        local radius = h * .5
        local height = h * .66
        local circleX = radius + (w - radius * 2) * self.stateFraction
        local realX, realY = self:LocalToScreen(0, 0)

        draw.RoundedBox(16, 0, h * .5 - height * .5, w, height, self.backgroundColorCurrent)

        render.SetScissorRect(realX, realY, realX + circleX, realY + h, true)
            surface.SetAlphaMultiplier(self.stateFraction)
                draw.RoundedBox(16, 0, h * .5 - height * .5, w, height, self.backgroundColorActive)
            surface.SetAlphaMultiplier(1)
        render.SetScissorRect(0, 0, 0, 0, false)

        onyx.DrawCircle(circleX, h * .5, radius, self.gripColorCurrent)
    end

    function PANEL:DoClick()
        self:SetValue(not self.m_bChecked)
    end

    function PANEL:AnimState(bBool, ignoreAnimation)
        local time = .15
        if (bBool) then
            onyx.anim.Create(self, time, {
                index = 40,
                skipAnimation = ignoreAnimation,
                target = {
                    stateFraction = 1,
                    gripColorCurrent = self.gripColorActive
                }
            })
        else
            onyx.anim.Create(self, time, {
                index = 40,
                skipAnimation = ignoreAnimation,
                target = {
                    stateFraction = 0,
                    gripColorCurrent = self.gripColorIdle
                }
            })
        end
    end

    function PANEL:SetChecked(bBool, ignoreAnimation)
        assert(isbool(bBool), string.format('bad argument #1 to `SetChecked` (expected bool, got %s)', type(bBool)))
        self.m_bChecked = bBool
        self:AnimState(bBool, ignoreAnimation)
    end

    function PANEL:SetValue(bBool)
        self:SetChecked(bBool)
        self:Call('OnChange', nil, bBool)
    end

    function PANEL:GetValue()
        return self.m_bChecked
    end

    function PANEL:SetBackgroundColor(color)
        self.backgroundColorCurrent = color
        self.backgroundColorActive = onyx.LerpColor(.66, colorAccent, self.backgroundColorCurrent)

        self.gripColorIdle = onyx.OffsetColor(self.backgroundColorCurrent, 10)
        self.gripColorActive = colorAccent
        self.gripColorCurrent = onyx.CopyColor(self.gripColorIdle)
    end

    onyx.gui.Register('onyx.Toggler', PANEL)
end

do
    local PANEL = {}

    AccessorFunc(PANEL, 'm_iCheckContainerWidth', 'CheckContainerWidth')
    AccessorFunc(PANEL, 'm_bUnlockedTogglerSize', 'UnlockedTogglerSize')
    AccessorFunc(PANEL, 'm_iTextMargin', 'TextMargin')

    function PANEL:Init()
        self.lblText = self:Add('onyx.Label')
        self.lblText:SetText('Example Label')

        self.togglerContainer = self:Add('Panel')

        self.toggler = self.togglerContainer:Add('onyx.Toggler')

        self:SetTextMargin(onyx.ScaleTall(5))
        self:CombineMutator(self.toggler, 'Checked')
        self:CombineMutator(self.toggler, 'Value')
        self:CombineMutator(self.lblText, 'Text')
        self:CombineMutator(self.lblText, 'Font')
        self:Combine(self.lblText, 'Font')
        self:Combine(self.toggler, 'SetBackgroundColor')
        self:MakeDispatchFn(self.toggler, 'OnChange')
    end

    function PANEL:PerformLayout(w, h)
        local togglerContainerWidth = self.m_iCheckContainerWidth or h
        local margin = self.m_iTextMargin

        self.togglerContainer:SetWide(togglerContainerWidth)
        self.togglerContainer:Dock(LEFT)
        self.togglerContainer:DockMargin(0, 0, margin, 0)

        self.lblText:Dock(FILL)

        if (self.UnlockedTogglerSize) then
            self.toggler:SetWide(togglerContainerWidth)
        else
            self.toggler:SetWide(math.min(self.toggler:GetWide(), togglerContainerWidth))
        end

        self.toggler:SetTall(self.toggler:GetWide() * .5)
        self.toggler:Center()
    end

    function PANEL:GetContentWide()
        local togglerContainerWidth = self.m_iCheckContainerWidth or self:GetTall()
        local lblText = self.lblText
        local margin = self.m_iTextMargin
        local wide = togglerContainerWidth + lblText:GetContentWidth() + margin
        return wide
    end
    PANEL.GetContentWidth = PANEL.GetContentWide

    onyx.gui.Register('onyx.TogglerLabel', PANEL)
end

-- ANCHOR Test

-- onyx.gui.Test('onyx.Frame', .4, .65, function(self)
--     self:MakePopup()

--     local iconlayout = self:Add('DIconLayout')
--     iconlayout:Dock(FILL)

--     for i = 1, 10 do
--         local panel = iconlayout:Add('onyx.TogglerLabel')
--         -- panel:Dock(TOP)
--         panel:SetChecked(true, true)
--         panel:SetText('Hello there')
--         panel:Font('Comfortaa@16')
--         panel:SetTall(ScreenScale(14))
--         panel:SetWide(panel:GetContentWide())
--     end
-- end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/inv/cl_inventory.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

23/04/2023

--]]

local creditstore = onyx.creditstore

netchunk.Callback('onyx.creditstore:SyncInventory', function(data, length, chunkAmount)
    LocalPlayer():SetVar('onyx_CreditstoreInventory', data)

    hook.Run('onyx.credistore.InventoryUpdated')

    creditstore:Print('Synchronized inventory (length: #, chunks: #)', length, chunkAmount)
end)

net.Receive('onyx.creditstore:SyncInventoryItemData', function(len)
    local inventory = creditstore:GetPlayerInventory(LocalPlayer())
    local index = net.ReadUInt(16)
    local data = onyx.net.ReadTable()

    if (inventory[index]) then
        inventory[index].data = data
        hook.Run('onyx.credistore.InventoryUpdated')
        creditstore:Print('Synchronized item data (index: #, length: #)', index, len)
    end
end)
--PATH addons/____onyx_creditstore/lua/onyx/modules/creditstore/core/item/sh_item.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com
Licensee: 76561198843434426

02/03/2023

--]]

netchunk.Register('onyx.creditstore:SyncItems')
netchunk.Register('onyx.creditstore:SyncCategories')

local creditstore = onyx.creditstore

creditstore.types = creditstore.types or {}

function creditstore:RegisterType(id, data)
    data.id = id
    self.types[id] = data
end

--PATH addons/____onyx_f4/lua/onyx/modules/f4/ui/cl_item.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

30/12/2023

--]]

local colorPrimary = onyx:Config('colors.primary')
local colorSecondary = onyx:Config('colors.secondary')
local colorOutline = Color(255, 255, 255, 5)
local colorGray = Color(159, 159, 159)
local fontDesc = onyx.Font('Comfortaa@16')
local colorFavoriteIconIdle = Color(235, 235, 235)
local colorFavoriteIconActive = Color(255, 241, 93)

local PANEL = {}

function PANEL:Init()
    self.padding = onyx.ScaleTall(7.5)
    self.itemColor = color_white
    self.itemColorBG = colorPrimary
    self.colorBG = colorSecondary
    self.colorBGGradient = Color(57, 57, 57, 25)
    self.gradientEnabled = onyx.f4:GetOptionValue('colored_items')

    self.iconContainer = self:Add('Panel')
    self.iconContainer:SetMouseInputEnabled(false)
    self.iconContainer.PerformLayout = function(panel, w, h)
        panel.mask = onyx.CalculateCircle(w * .5, h * .5, h * .5 - 2, 24)
    end
    self.iconContainer.Paint = function(panel, w, h)
        local child = panel:GetChild(0)
        if (IsValid(child)) then
            onyx.DrawCircle(w * .5, h * .5, h * .5, self.itemColorBG)

            onyx.DrawWithPolyMask(panel.mask, function()
                child:PaintManual()
            end)

            onyx.DrawOutlinedCircle(w * .5, h * .5, h * .5, 3, self.itemColor)
        end
    end

    if (onyx.f4:GetOptionValue('model_3d')) then
        self.iconModel = self.iconContainer:Add('DModelPanel')
        self.iconModel.LayoutEntity = function() end
        self.iconModel.PreDrawModel = function(panel)
            if (surface.GetAlphaMultiplier() < .5) then
                return false
            end
        end
    else
        self.iconModel = self.iconContainer:Add('SpawnIcon')
    end
    self.iconModel:Dock(FILL)
    self.iconModel:SetPaintedManually(true)
    self.iconModel:DockMargin(2, 2, 2, 2)

    self.lblName = self:Add('onyx.Label')
    self.lblName:SetText('Name')
    self.lblName:Font('Comfortaa Bold@18')
    self.lblName:SetContentAlignment(1)

    self.pnlDesc = self:Add('Panel')
    self.pnlDesc:SetMouseInputEnabled(false)
    self.pnlDesc.label = ''
    self.pnlDesc.text = ''
    self.pnlDesc.color = ''
    self.pnlDesc.Paint = function(panel, w, h)
        local label = panel.label:Trim()
        if (label ~= '') then
            local textW = draw.SimpleText(label .. ': ', fontDesc, 0, 0, colorGray, 0, 0)
            draw.SimpleText(panel.text, fontDesc, textW, 0, panel.color, 0, 0)
        else
            draw.SimpleText(panel.text, fontDesc, 0, 0, panel.color, 0, 0)
        end
    end
end

function PANEL:GetName()
    return self.lblName:GetText()
end

function PANEL:SetDescLabel(label)
    self.pnlDesc.label = label
end

function PANEL:SetDesc(desc)
    self.pnlDesc.text = desc
end

function PANEL:SetDescColor(label)
    self.pnlDesc.color = label
end

function PANEL:SetColor(color, bgFraction)
    self.itemColor = color
    if (bgFraction) then
        self.colorBGGradient = onyx.LerpColor(.05, colorSecondary, self.itemColor)
        self.itemColorBG = onyx.LerpColor(bgFraction, colorSecondary, onyx.CopyColor(self.itemColor))
    end
end

function PANEL:PerformLayout(w, h)
    local padding = self.padding
    local height = h - padding * 2
    local btnFavorite = self.btnFavorite

    self:DockPadding(padding, padding, padding, padding)
    self.mask = onyx.CalculateRoundedBox(8, 1, 1, w - 2, h - 2)

    self.iconContainer:Dock(LEFT)
    self.iconContainer:SetWide(height)
    self.iconContainer:DockMargin(0, 0, onyx.ScaleWide(10), 0)

    self.lblName:Dock(TOP)
    self.lblName:SetTall(height * .5)

    self.pnlDesc:Dock(FILL)

    if (IsValid(btnFavorite) and btnFavorite:IsVisible()) then
        btnFavorite:Dock(RIGHT)
        btnFavorite:SetZPos(-1)
        btnFavorite:SetWide(height)
    end
end

function PANEL:Paint(w, h)
    draw.RoundedBox(8, 0, 0, w, h, colorOutline)
    draw.RoundedBox(8, 1, 1, w - 2, h - 2, self.colorBG)

    if (self.gradientEnabled) then
        onyx.DrawWithPolyMask(self.mask, function()
            onyx.DrawMatGradient(0, 0, w, h, TOP, self.colorBGGradient)
        end)
    end
end

function PANEL:SetModel(modelPath)
    self.iconModel:SetModel(modelPath)
end

function PANEL:SetName(name)
    self.lblName:SetText(name)
end

local AXIS = {'x', 'y', 'z'}
function PANEL:PositionCamera(pos)
    local iconModel = self.iconModel

    if (not IsValid(iconModel)) then return end
    if (iconModel.ClassName ~= 'DModelPanel') then return end

    local ent = iconModel.Entity
    if (not IsValid(ent)) then return end

    if (pos == 'face') then
        local bone = ent:LookupBone('ValveBiped.Bip01_Head1')
        if (not bone) then return end

        local eyepos = ent:GetBonePosition(bone)
        eyepos:Add(Vector(0, 0, 2))

        iconModel:SetLookAt(eyepos)
        iconModel:SetCamPos(eyepos - Vector(-20, 0, 0))
        iconModel:SetFOV(45)

        ent:SetEyeTarget(eyepos - Vector(-20, 0, 0))
    elseif (pos == 'center') then
        local min, max = ent:GetRenderBounds()
        local center = (min + max) * 0.5
        local distance = 0

        for _, key in ipairs(AXIS) do
            distance = math.max(distance, max[key])
        end

        iconModel:SetLookAt(center)
        iconModel:SetFOV(distance + 10)
    end
end

function PANEL:AddFavoriteButton()
    self.btnFavorite = self:Add('onyx.ImageButton')
    self.btnFavorite.SetState = function(panel, state, ignore)
        panel.bState = state

        if (not ignore and self.objectIdentifier) then
            onyx.f4:SetFavorite(self.objectIdentifier, state)
        end

        local targetColor = state and colorFavoriteIconActive or colorFavoriteIconIdle

        if (state) then
            panel:SetWebImage('favorite_fill', 'smooth mips')
        else
            panel:SetWebImage('favorite_outline', 'smooth mips')
        end

        onyx.anim.Create(panel, .33, {
            index = onyx.anim.ANIM_HOVER,
            target = {
                m_colColor = targetColor
            }
        })

        self:Call('OnFavoriteStateSwitched', nil, state)
    end

    self.btnFavorite.m_Angle = 0
    self.btnFavorite.onyxEvents['OnCursorEntered'] = nil
    self.btnFavorite.onyxEvents['OnCursorExited'] = nil
    self.btnFavorite.onyxEvents['OnRelease'] = nil
    self.btnFavorite.onyxEvents['OnPress'] = nil
    self.btnFavorite:InstallRotationAnim()
    self.btnFavorite.m_iImageScale = .5
    self.btnFavorite.m_iImageScaleInitial = .5

    self.btnFavorite.DoClick = function(panel)
        panel:SetState(not panel.bState)
    end

    self.btnFavorite:SetState(onyx.f4:IsFavorite(self.objectIdentifier), true)
end

onyx.gui.Register('onyx.f4.Item', PANEL)

-- onyx.gui.Test('onyx.f4.Frame', .65, .65, function(panel)
--     panel:MakePopup()
--     panel:ChooseTab(3)
-- end)
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/core/columns/cl_columns.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

04/03/2024

--]]

net.Receive('onyx.scoreboard:SyncColumns', function()
    local amount = net.ReadUInt(8)

    onyx.scoreboard.columnsCustomizable = {}

    for _ = 1, amount do
        local index = net.ReadUInt(8)
        local id = net.ReadString()
        onyx.scoreboard.columnsCustomizable[index] = id
    end

    onyx.scoreboard:Print('Synchronized # columns.', amount)

    hook.Run('onyx.scoreboard.SyncedColumns')
end)
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/core/integrations/sh_brick_gangs.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

19/03/2024

--]]

netchunk.Register('onyx.scoreboard:SyncBrickGangs')
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/cfg/cl_actions.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

--[[------------------------------
**WARNING**
This is an advanced config.
Most of the things you need should be configurable through the game.
Do not edit anything if you do not understand what you are doing.
--------------------------------]]

onyx.scoreboard.Buttons = {}
onyx.scoreboard.adminHandler = nil

local adminHandlers = {}

local TYPE_NAME = 1
local TYPE_STEAMID64 = 2
local TYPE_STEAMID32 = 3

local function adminModeHandler(uniqueID, priority, validator, data)
    table.insert(adminHandlers, {
        uniqueID = uniqueID,
        priority = priority,
        validator = validator,
        data = data
    })
end

local function registerAdminButton(cmd, icon, cmdData)
    onyx.scoreboard:RegisterButton(cmd, {
        icon = icon,
        callback = function(ply)
            local handler = onyx.scoreboard.adminHandler
            local data = handler.data
            local command = cmdData.getCommand and cmdData.getCommand(ply) or cmd

            local targetID
            if (data.idFormat == TYPE_STEAMID32) then
                targetID = ply:SteamID()
            elseif (data.idFormat == TYPE_STEAMID64) then
                targetID = ply:SteamID64()
            else
                targetID = ply:Name()
            end

            RunConsoleCommand(handler.uniqueID, command, targetID)
        end,
        getVisible = function(client)
            local handler = onyx.scoreboard.adminHandler
            if (not handler) then return false end

            local data = handler.data
            return data.hasPermission(client, cmd)
        end
    })
end

--[[------------------------------
Common actions
--------------------------------]]
onyx.scoreboard:RegisterButton('profile', {
    icon = 'https://i.imgur.com/ojNCwan.png',
    callback = function(ply)
        gui.OpenURL('https://steamcommunity.com/profiles/' .. ply:SteamID64())
    end
})

onyx.scoreboard:RegisterButton('demote', {
    icon = 'https://i.imgur.com/74TXidr.png',
    callback = function(ply)
        onyx.SimpleQuery('Причина', 'Причина, за якою ви хочете знизити цю людину', true, function(text) RunConsoleCommand('demote', ply:SteamID(), text) end, 'Так', nil, 'Ні')
    end,
    getVisible = function(ply, target)
        return ply ~= LocalPlayer() and rp.Team[ply:Team()] and rp.Team[ply:Team()].canDemote ~= false and true or false
    end
})

--[[------------------------------
FSpectate
--------------------------------]]
onyx.scoreboard:RegisterButton('spectate', {
    icon = 'https://i.imgur.com/kGncVTG.png',
    callback = function(ply)
        if (ply ~= LocalPlayer()) then
            net.Start("FSpectateTarget")
                net.WriteEntity(ply)
            net.SendToServer()
        end
    end,
    getVisible = function(client)
        local success, bHasAccess = pcall(CAMI.PlayerHasAccess, client, 'FSpectate')
        if (not success) then
            bHasAccess = client:IsSuperAdmin()
        end
        return (FSpectate ~= nil and (success and bHasAccess))
    end
})

--[[------------------------------
Admin actions
--------------------------------]]
registerAdminButton('freeze', 'https://i.imgur.com/4l3z6vi.png', {
    getCommand = function(target)
        return (target:IsFlagSet(FL_FROZEN) and 'unfreeze' or 'freeze')
    end
})

registerAdminButton('goto', 'https://i.imgur.com/qtWhznQ.png', {})
registerAdminButton('bring', 'https://i.imgur.com/e2Jut95.png', {})
registerAdminButton('return', 'https://i.imgur.com/xY56yG2.png', {})
registerAdminButton('respawn', 'https://i.imgur.com/ymwK6lH.png', {})
registerAdminButton('slay', 'https://i.imgur.com/GOuu3BA.png', {})

--[[------------------------------
Admin modes
--------------------------------]]
adminModeHandler('sam', 100, function()
    return sam
end, {
    idFormat = TYPE_STEAMID64,
    hasPermission = function(client, cmd)
        return client:HasPermission(cmd)
    end
})

adminModeHandler('sa', 100, function()
    return sAdmin
end, {
    idFormat = TYPE_NAME,
    hasPermission = function(client, cmd)
        return sAdmin.hasPermission( cmd )
    end
})

do
    local DISABLED = {
        ['respawn'] = true,
    }

    adminModeHandler('ulx', 100, function()
        return ulx
    end, {
        idFormat = TYPE_NAME,
        hasPermission = function(client, cmd)
            return (client:query('ulx ' .. cmd) == true and not DISABLED[cmd])
        end
    })
end

do
    local DISABLED = {
        ['respawn'] = true,
        ['return'] = true,
    }

    adminModeHandler('fadmin', 1, function()
        return FAdmin
    end, {
        idFormat = TYPE_STEAMID32,
        hasPermission = function(client, cmd)
            return (client:IsAdmin() and not DISABLED[cmd])
        end
    })
end

--[[------------------------------
Fetch admin mode
--------------------------------]]
onyx.WaitForGamemode('onyx.scoreboard.InitButtons', function()
    table.sort(adminHandlers, function(a, b)
        return a.priority > b.priority
    end)

    for _, handler in ipairs(adminHandlers) do
        if (handler.validator()) then
            onyx.scoreboard.adminHandler = handler
            break
        end
    end

    if (onyx.scoreboard.adminHandler) then
        onyx.scoreboard:PrintSuccess('Found admin handler: ' .. onyx.scoreboard.adminHandler.uniqueID)
    else
        onyx.scoreboard:PrintWarning('Admin handler has not been found.')
    end
end)
--PATH addons/____onyx_scoreboard/lua/onyx/modules/scoreboard/ui/cl_player_list.lua:
--[[

Author: tochnonement
Email: tochnonement@gmail.com

02/03/2024

--]]

local COLOR_PRIMARY = onyx:Config('colors.primary')
local COLOR_SECONDARY = onyx:Config('colors.secondary')
local COLOR_TERTIARY = onyx:Config('colors.tertiary')
local COLOR_ACCENT = onyx:Config('colors.accent')
local COLOR_GRAY = Color(149, 149, 149)
local COLOR_GRAY_LIGHT = Color(198, 198, 198)

local WIMG_ARROW = onyx.wimg.Simple('https://i.imgur.com/oOoWQAG.png', 'smooth mips')

local function parseString(str)
    return onyx.utf8.lower(str)
end

local function processSearch(prompt, parentList)
    local prompt = string.lower(prompt):Trim()
    local categories = parentList:GetItems()

    for _, category in ipairs(categories) do
        if (category.ClassName ~= 'onyx.Category') then continue end

        for _, panel in ipairs(category:GetItems()) do
            local line = panel.button:GetChild(0)
            local name = line.parsedName
            local steamID32 = line.steamID32

            if (string.find(name, prompt, nil, true) or steamID32 == prompt or (prompt == '^' and line.isLocalPlayer)) then
                panel:Show()
                category:SetExpanded(true)
            else
                panel:Hide()
            end
        end

        category:Update()
    end
end

--[[------------------------------
// PANEL
--------------------------------]]
local PANEL = {}

function PANEL:Init()
    local toolbarPadding = onyx.ScaleTall(5)
    local elementSpace = onyx.ScaleTall(10)
    local playerLineHeight = onyx.ScaleTall(30)
    local playerLinePadding = onyx.ScaleTall(5)
    local playerLineRealHeight = playerLineHeight - playerLinePadding * 2

    self.toolbarPadding = toolbarPadding
    self.playerLineHeight = playerLineHeight
    self.playerLinePadding = playerLinePadding

    self.toolbar = self:Add('Panel')
    self.toolbar.Paint = function(panel, w, h)
        draw.RoundedBox(8, 0, 0, w, h, COLOR_SECONDARY)
    end
    self.toolbar.PerformLayout = function(panel, w, h)
        local contentMarginLeft = toolbarPadding * 3 + playerLineRealHeight * 2
        local scroll = self.list.scroll

        if (scroll:IsVisible()) then
            contentMarginLeft = contentMarginLeft + scroll:GetWide() + select(1, scroll:GetDockMargin())
        end

        panel:DockPadding(toolbarPadding, toolbarPadding, contentMarginLeft, toolbarPadding)
        panel:DockMargin(0, 0, 0, elementSpace)
    end

    self.search = self.toolbar:Add('onyx.TextEntry')
    self.search:SetPlaceholderText(onyx.lang:Get('scoreboard_search'))
    self.search:SetPlaceholderIcon('https://i.imgur.com/Nk3IUJT.png', 'smooth mips')
    self.search:SetUpdateOnType(true)
    self.search:Dock(LEFT)
    self.search:SetWide(onyx.ScaleWide(175))
    self.search:SetCursor('beam')
    self.search.OnValueChange = function(panel, value)
        processSearch(value, self.list)
    end

    self.search.textEntry:SetTabbingDisabled(true)
    self.search.textEntry:SetMouseInputEnabled(false) -- this one is required to get access to parent, which triggers SetKeyboardInputEnabled on parent
    self.search.OnMousePressed = function(panel)
        onyx.scoreboard.Frame:SetKeyboardInputEnabled(true)
        onyx.scoreboard.Frame:ShowCloseButton(true)
        onyx.scoreboard.Frame.closeDisabled = true

        panel.textEntry:SetMouseInputEnabled(true)
        panel.textEntry:RequestFocus()
    end

    self.columns = self.toolbar:Add('onyx.Scoreboard.ColumnsRow')
    self.columns:Dock(FILL)
    self.columns:DockMargin(toolbarPadding, 0, 0, 0)
    self.columns:SetFont(onyx.Font('Comfortaa Bold@16'))
    self.columns:SetHeader(true)
    self.columns:InitColumns()

    self:AddSorting(self.columns)

    self.list = self:Add('onyx.ScrollPanel')
    self.list:SetSpace(onyx.ScaleTall(1))
    self.list.canvas:On('OnContainerTallUpdated', function()
        self.toolbar:InvalidateLayout()
    end)

    self.players = {}
    self:LoadPlayers()
end

function PANEL:PerformLayout(w, h)
    self.toolbar:Dock(TOP)
    self.toolbar:SetTall(onyx.ScaleTall(35))

    self.list:Dock(FILL)
end

do
    function PANEL:FetchCategory(ply)
        if (rp and onyx.scoreboard:GetOptionValue('group_teams')) then
            local jobData = rp.Team[ply:Team()]
            if (jobData) then
                return jobData.category
            end
         end

        if (onyx.scoreboard.IsTTT()) then
            local _, name, color = onyx.scoreboard.GetTeamTTT(ply)
            return name, color
        end

        return team.GetName(ply:Team()), team.GetColor(ply:Team())
    end
end

function PANEL:LoadPlayers()
    local categories = {}
    local players = {}

    -- add players
    for _, ply in ipairs(player.GetAll()) do
        local bShouldHide = hook.Run('onyx.scoreboard.ShouldHidePlayer', ply) -- for possible custom integrations
        if (bShouldHide ~= true) then
            table.insert(players, ply)
        end
    end

    -- default sorting
    table.sort(players, function(a, b)
        return a:Team() < b:Team()
    end)

    for _, ply in ipairs(players) do
        local catName, catColor = self:FetchCategory(ply)
        local foundIndex

        for index, category in ipairs(categories) do
            if (category.name == catName) then
                foundIndex = index
                break
            end
        end

        if (not foundIndex) then
            local panel = self:AddCategory(onyx.utf8.upper(catName), catColor) -- utf-8 support

            foundIndex = table.insert(categories, {
                panel = panel,
                name = catName,
                color = catColor, -- might be nil
                players = {}
            })
        end

        table.insert(categories[foundIndex].players, ply)
    end

    self.queue = {}
    for _, category in ipairs(categories) do
        for _, ply in ipairs(category.players) do
            table.insert(self.queue, {
                category = category.panel,
                ply = ply
            })
        end
    end
end

function PANEL:Think()
    local queue = self.queue
    if (queue) then
        local object = queue[1]
        if (object) then
            local ply = object.ply
            local cat = object.category

            table.remove(queue, 1)

            if (IsValid(ply)) then
                self:AddPlayer(ply, cat)
                cat:Update()
            end
        end
    end
end

function PANEL:AddSorting(panel)
    for index, column in ipairs(panel.columns) do
        panel:SetClickFunc(index, function()
            self:SortByColumn(index, column)
        end)

        column.arrowAngle = 0
        column.PaintOver = function(panel, w, h)
            if (not panel.active) then return end

            local text = panel:GetText()
            local xOffset = -ScreenScale(3)
            local size = math.min(h, onyx.ScaleTall(12))
            local xPosOverride

            if (text ~= '') then
                local textW = panel:GetContentSize()
                if (panel.TextLeft) then
                    xPosOverride = textW + size * .5 - xOffset
                else
                    xOffset = xOffset - textW * .5
                end
            else
                xOffset = xOffset - size * .5
            end

            local targetAngle = panel.ascending and 90 or -90
            column.arrowAngle = Lerp(FrameTime() * 16, column.arrowAngle, targetAngle)

            DisableClipping(true)
                WIMG_ARROW:DrawRotated(xPosOverride or (w * .5 + xOffset - size * .5), h * .5, size, size, column.arrowAngle)
            DisableClipping(false)
        end
    end
end

function PANEL:SortByColumn(index, column)
    local oldColumn = self.currentColumn
    local data = column.data
    local resorted = {}

    if (IsValid(oldColumn)) then
        oldColumn:SetTextColor(COLOR_GRAY)
        oldColumn.hoverBlocked = false
        oldColumn.active = false
    end

    column.hoverBlocked = true
    column.ascending = not column.ascending
    column.active = true
    column:SetTextColor(COLOR_ACCENT)

    self.currentColumn = column

    -- sort
    table.sort(self.players, function(aPlayer, bPlayer)
        local aColumn = aPlayer.content.columns[index]
        local bColumn = bPlayer.content.columns[index]

        local aValue = aColumn.Value
        local bValue = bColumn.Value

        if (column.ascending) then
            return aValue > bValue
        else
            return aValue < bValue
        end
    end)

    -- rearrange elements
    for index, playerLine in ipairs(self.players) do
        local parent = playerLine.category
        local parentCategory = parent:GetParent():GetParent()

        parent:SetZPos(index)

        if (not resorted[parentCategory]) then
            parentCategory:SetZPos(index)
            parentCategory:SetAlpha(0)
            parentCategory:AlphaTo(255, .1)

            resorted[parentCategory] = index
        end
    end

    self.list:InvalidateLayout()
end

function PANEL:AddPlayer(ply, parentCategory)
    if (not IsValid(ply)) then return end

    -- create fake category
    local cat = parentCategory:Add('onyx.Category')
    cat:SetCategoryHeight(self.playerLineHeight)
    cat:SetTall(cat:GetCategoryHeight())
    cat:SetInset(onyx.ScaleTall(10))
    cat:SetSpace(0)
    cat:DockMargin(0, 0, 0, onyx.ScaleTall(2.5))
    cat:Dock(TOP)

    -- keep size up to date
    cat:InjectEventHandler('PerformLayout')
    cat:On('PerformLayout', function(panel)
        if (panel.onyxAnims and panel.onyxAnims[1]) then -- fixes unpleasant view glitch
            parentCategory:Update()
        end
    end)

    -- reset inside
    cat.button:Clear()
    cat.button.Paint = nil
    cat.button:DockPadding(0, 0, 0, 0)

    cat.canvas:SetTall(0)
    cat.canvas.Paint = function(panel, w, h)
        draw.RoundedBoxEx(8, 0, 0, w, h, onyx.LerpColor(.025, COLOR_PRIMARY, color_black), false, false, true, true)
    end

    local profile = cat:Add('onyx.scoreboard.PlayerInspector')
    profile:Dock(TOP)
    profile:SetupPlayer(ply)

    -- create actual playerLine
    local playerLine = cat.button:Add('onyx.Scoreboard.PlayerLine')
    playerLine:SetupPlayer(ply)
    playerLine:Dock(FILL)
    playerLine:Import('click')
    playerLine.DoClick = function()
        cat.button:DoClick()
    end
    playerLine.DoRightClick = function(panel)
        if ( cat:GetExpanded() ) then return end

        local x, y = panel:LocalToScreen(0, 0)
    
        local dmenu = vgui.Create('onyx.Menu')
        dmenu:SetPos(input.GetCursorPos())
        dmenu.Think = function(panel)
            if ( cat:GetExpanded() ) then
                panel:Close()
            end
        end

        for _, buttonTable in ipairs(onyx.scoreboard.Buttons) do
            local getVisible = buttonTable.getVisible
            if (getVisible and getVisible(LocalPlayer(), ply) == false) then continue end
            if (buttonTable.icon) then
                buttonTable.wimg = buttonTable.wimg or onyx.wimg.Simple( buttonTable.icon, 'smooth mips' )
            end

            local option = dmenu:AddOption(onyx.lang:Get('scoreboard_btn_' .. buttonTable.name), function()
                if (IsValid(ply)) then
                    buttonTable.callback(ply)
                end
            end)
            option.wimage = buttonTable.wimg
        end

        dmenu:Open(panel)
    end

    -- to perfectly align UI elements
    playerLine.firstElementWidth = self.search:GetWide()
    playerLine.paddingX = self.toolbarPadding
    playerLine.padding = self.playerLinePadding

    -- link to other panels
    playerLine.category = cat
    playerLine.list = self.list

    -- for search
    playerLine.parsedName = parseString(ply:Name())
    playerLine.steamID32 = parseString(ply:SteamID())
    playerLine.isLocalPlayer = LocalPlayer() == ply

    table.insert(self.players, playerLine)
end

function PANEL:AddCategory(name, color)
    local cat = self.list:Add('onyx.Category')
    cat:Dock(TOP)
    cat:SetTitle(name)
    cat:SetSpace(onyx.ScaleTall(5))
    cat:SetInset(0)
    cat:SetTextMargin(self.toolbarPadding + 2)
    cat:DockMargin(0, 0, 0, onyx.ScaleTall(5))

    cat:SetExpanded(true)
    cat:UpdateInTick()

    if (color) then
        cat.button.PaintOver = function(panel, w, h)
            local x, y = panel:LocalToScreen(0, 0)
            local lineWidth = 2

            render.SetScissorRect(x, y, x + lineWidth, y + h, true)
            -- render.SetScissorRect(x, y + h - lineWidth, x + w, y + h, true)
                draw.RoundedBox(8, 0, 0, w, h, color)
            render.SetScissorRect(0, 0, 0, 0, false)
        end
    end

    return cat
end

onyx.gui.Register('onyx.Scoreboard.PlayerList', PANEL)

--[[------------------------------
--//ANCHOR onyx.scoreboard.PlayerInspector
--------------------------------]]
local COLOR_GOLD = Color(255, 224, 101)
local COLOR_FRIEND = Color(134, 249, 124)
local wimgCopy = onyx.wimg.Simple('https://i.imgur.com/OolNq4H.png', 'smooth mips')

local function setTextColor(label, color)
    label.colorIdle = color
    label:SetTextColor(color)
end

local PANEL = {}

AccessorFunc(PANEL, 'm_ePlayer', 'Player')

function PANEL:Init()
    self.buttonHeight = onyx.ScaleTall(20)

    local avatarOutline = 2
    local avatarRoundness = 16

    self._avatar = self:Add('Panel')
    self._avatar.PerformLayout = function(panel, w, h)
        local size = math.min(h, self._avatar:GetWide()) - avatarOutline * 2

        self.avatar:SetSize(size, size)
        self.avatar:Center()

        local x, y = self.avatar:GetPos()

        panel.poly = onyx.CalculateRoundedBox(avatarRoundness, x, y, size, size)
    end
    self._avatar.Paint = function(panel, w, h)
        local x, y = self.avatar:GetPos()
        local size = self.avatar:GetWide() + avatarOutline * 2

        draw.RoundedBox(avatarRoundness, x - avatarOutline, y - avatarOutline, size, size, color_white)

        onyx.DrawWithPolyMask(panel.poly, function()
            self.avatar:PaintManual()
        end)
    end

    self.avatar = self._avatar:Add('AvatarImage')
    self.avatar:SetPaintedManually(true)

    self.buttons = self:Add('onyx.Grid')
    self.buttons:SetColumnCount(3)
    self.buttons:SetSpace(onyx.ScaleTall(5))

    self.info = self:Add('Panel')

    for _, buttonTable in ipairs(onyx.scoreboard.Buttons) do
        local getVisible = buttonTable.getVisible

        if (getVisible and getVisible(LocalPlayer()) == false) then continue end

        if ( buttonTable.icon ) then
            buttonTable.wimg = buttonTable.wimg or onyx.wimg.Simple( buttonTable.icon, 'smooth mips' )
        end

        self:AddButton(onyx.lang:Get('scoreboard_btn_' .. buttonTable.name), buttonTable.wimg, function()
            local ply = self:GetPlayer()
            if (IsValid(ply)) then
                buttonTable.callback(ply)
            end
        end)
    end

    self.labels = {}
    self:AddLabel('name', 'Name')
    self:AddLabel('rank', 'Rank')
    self:AddLabel('steamid32', 'SteamID32')
    self:AddLabel('steamid64', 'SteamID64')

    self:UpdateHeight()
end

function PANEL:UpdateHeight()
    local infoHeight = 0

    -- this one should be pairs
    for _, label in pairs(self.labels) do
        infoHeight = infoHeight + label:GetParent():GetTall()
    end

    self:SetTall(math.max(self.buttons:GetContentHeight(), infoHeight))
end

function PANEL:PerformLayout(w, h)
    self._avatar:Dock(LEFT)
    self._avatar:SetWide(h * .75)
    self._avatar:DockMargin(0, 0, onyx.ScaleTall(10), 0)

    self.buttons:SetWide(w * .5)
    self.buttons:Dock(RIGHT)

    self.info:Dock(FILL)
end

function PANEL:SetupPlayer(ply)
    local yourself = ply == LocalPlayer()
    local name = ply:Name()
    local formattedName = name

    self.avatar:SetPlayer(ply, 128)

    if (yourself) then
        formattedName = formattedName .. ' (' .. onyx.lang:Get('you') .. ')'
        setTextColor(self.labels.name, COLOR_GOLD)
    elseif (ply:GetFriendStatus() == 'friend') then
        formattedName = formattedName .. ' (' .. onyx.lang:Get('friend') .. ')'
        setTextColor(self.labels.name, COLOR_FRIEND)
    end

    self:SetPlayer(ply)

    self:SetLabelValue('name', formattedName, name)
    self:SetLabelValue('rank', ply:GetUserGroup())
    self:SetLabelValue('steamid32', ply:SteamID())
    self:SetLabelValue('steamid64', ply:SteamID64())
end

function PANEL:SetLabelValue(id, value, rawValue)
    self.labels[id]:SetText(value)
    self.labels[id]:SizeToContentsX()
    self.labels[id].Value = rawValue or value
end

function PANEL:AddLabel(id, title)
    local row = self.info:Add('Panel')
    row:SetTall(onyx.ScaleTall(20))
    row:Dock(TOP)
    row:DockMargin(0, 0, 0, 0)

    local lblTitle = row:Add('onyx.Label')
    lblTitle:SetText(title .. ': ')
    lblTitle:SetTextColor(COLOR_GRAY_LIGHT)
    lblTitle:Dock(LEFT)
    lblTitle:SizeToContentsX()
    lblTitle:SetContentAlignment(7)

    local lblValue = row:Add('onyx.Label')
    lblValue:SetText('Example')
    lblValue:SetContentAlignment(7)
    lblValue:Dock(LEFT)
    lblValue:Font('Comfortaa Bold@16')
    lblValue:SizeToContentsX()
    lblValue:Import('click')
    lblValue.Value = 'Example'
    setTextColor(lblValue, color_white)
    lblValue.Think = function(panel)
        panel:SetTextColor(panel:IsHovered() and COLOR_ACCENT or panel.colorIdle)
    end
    lblValue.Paint =function(panel, w, h)
        if (not panel:IsHovered()) then return end

        local size = h * .66
        local space = onyx.ScaleTall(5)
        DisableClipping(true)
            wimgCopy:Draw(w + space, h * .5 - size * .5, size, size, COLOR_ACCENT)
        DisableClipping(false)
    end
    lblValue.DoClick = function(panel)
        SetClipboardText(panel.Value)
        notification.AddLegacy(onyx.lang:Get('copied_clipboard'), 0, 5)
    end

    self.labels[id] = lblValue
end

function PANEL:AddButton(text, wimgObject, func)
    local space = onyx.ScaleTall(7.5)
    local padding = onyx.ScaleTall(5)

    local button = self.buttons:Add('onyx.Button')
    button:SetText('')
    button:SetTall(onyx.ScaleTall(25))
    button:SetColorIdle(COLOR_SECONDARY)
    button:SetColorHover(COLOR_TERTIARY)
    button:AddHoverSound()
    button:AddClickEffect()
    button:Font('Comfortaa SemiBold@16')
    button.iconRotation = 0
    button.Think = function(panel)
        panel:SetTextColor(panel:IsHovered() and color_white or COLOR_GRAY_LIGHT)
    end
    button.DoClick = func
    button:On('PaintOver', function(panel, w, h)
        local size = h * .66

        panel.iconRotation = Lerp(FrameTime() * 8, panel.iconRotation, 0)
    
        if (wimgObject) then
            wimgObject:DrawRotated(padding + size * .5, h * .5, size, size, panel.iconRotation, panel:GetTextColor())
        end

        draw.SimpleText(text, panel:GetFont(), padding + size + space , h * .5, panel:GetTextColor(), 0, 1)
    end)
    button:On('OnCursorEntered', function(panel)
        panel.iconRotation = 15
    end)

    self.buttons:AddItem(button)
end

onyx.gui.Register('onyx.scoreboard.PlayerInspector', PANEL)

--[[------------------------------
// ANCHOR Debug
--------------------------------]]
-- onyx.gui.Test('onyx.Scoreboard.Frame', .6, .6, function(self)
--     onyx.scoreboard.Frame = self
--     self:Center()
--     self:MakePopup()
-- end)
--PATH addons/_outfitter/lua/autorun/outfitter.lua:
--do return end
--[[

BUGS
====================

GOING THROUGH WITHOUT REJECT !outfitter 187243854

OUTFITTER REJECTS
	191146401 -- noattachments
	164449803 -- hip


	[OF ERROR] @  lua/outfitter/cl_util.lua:792: GMAPlayerModels Disagreement C:\Program Files (x86)\Steam\steamapps\workshop\content\4000\2242241647/ena_pm13_2.gma models/player/ena/ch/ena_carm.mdl

	
	Strict mode?

	(partially fixed) 1367741116 ragdoll lags to hell
	(partially fixed) OnDeathRagdollCreated Enforce call lags to hell, but without it ragdoll won't get applied force

Worldmodel vanishing
	is it pac bug or outfitter?

Prevent workshop addon overriding resources to prevent crashes and trolling
	database list of: player - wsaddon - model, etc

Any prop wear from any game instead of a workshop addon

ent:SnatchModelInstance()
"hl2mp_ragdoll"

TODO
====================
	BodyGroups testing 	471628201
	NSFW test crashes: 2806932615 (huge addon, crashes outside outfitter?)
	list favorited from workshop (playermodels heuristic?)
	Add icons to history list
	PAC part for outfitter
		Multiple ws addons single outfit?
			separate workshop mounter thing
	Hands model from outfits

	Interlock functions so they don't execute at the same time?
		At least prevent more than 2 downloads at once
		LZMA decompress in separate step

	Bodygroups
	skin

	Allow custom skinning from jpg??

	Whitelist mode for competitive servers

	mdl parse further to prevent easy crashing

	[OF ERROR] @lua/outfitter/cl_util.lua:792: GMAPlayerModels Disagreement X:\g\steam\steamapps\workshop\content\4000\2242241647/ena_pm7.gma models/player/ena/ch/ena_carm.mdl

	More sounds / notifications
		npc/vort/claw_swing1.wav

		npc/scanner/scanner_scan1.wav
		npc/scanner/scanner_scan2.wav

		common/warning.wav
		buttons/button2.wav
		BEP BEP BEP ui/system_message_alert.wav

		ui/buttonclick.wav

		items/suitchargeok1.wav

		items/suitchargeno1.wav

		Great scott
		vo/trainyard/kl_morewarn01.wav

]]



local function requireSH(name)
	AddCSLuaFile(("includes/modules/%s.lua"):format(name))
	local ok,err = pcall(require,name)
	if not ok then
		hook.Add("Initialize",Tag..'fail',function()

			timer.Simple(1,function()
				chat.AddText(Color(200,50,10,255),"OUTFITTER LOADING FAILED:",Color(255,255,255,255),err)
			end)

		end)
		return
	end
end

if not util.OnLocalPlayer then
	requireSH 'hookextras'
end


requireSH 'binfuncs'
requireSH 'co'
requireSH 'coext'
requireSH 'fileextras'
requireSH 'gmaparse'
requireSH 'imgparse'
requireSH 'isdormant'
requireSH 'mdlinspect'
requireSH 'netobj'
requireSH 'netqueue'
requireSH 'playerextras'
requireSH 'sqlext'
requireSH 'ubit'
requireSH 'urlimage'


local Tag='outfitter'

--TODO:
 -- !outfitter 187243854
 -- bodygroups
module(Tag,package.seeall)

_M.this = setmetatable({},{__index = function(self,k) return rawget(_M,k) end,__newindex=_M})
this.Tag =Tag
this.NTag = 'OF'

local outfitter_dbg_tosv = SERVER and CreateConVar("outfitter_dbg_tosv","0") or CreateClientConVar("outfitter_dbg_tosv","0",false,false)
local outfitter_dbg = SERVER and CreateConVar("outfitter_dbg","1") or CreateClientConVar("outfitter_dbg","0",true,false)
_M.outfitter_dbg = outfitter_dbg

function isdbg(n)
	return outfitter_dbg:GetInt()>(n or 0)
end

function dbg(...)
	if isdbg() then
		Msg"[Outfitter] "
		if outfitter_dbg_tosv:GetBool() then
			if easylua then
				easylua.Print(...)
			else
				ErrorNoHalt(...)
			end
		else
			print(...)
		end
	end
end

function dbgn(n,...)
	if isdbg(n) then
		return dbg(...)
	end
end

function dbge(...)
	return dbgelvl(2,...)
end

local redcolor = Color(255, 0, 0)
function dbgelvl(lvl,...)
	--if not outfitter_dbg:GetBool() then return end
	local caller = debug.getinfo((lvl or 1)) or {}
	local src = caller.source or "?"
	src=src:gsub(".*/lua/","/")
	local t = {'[OF ERROR]',src..':'..(caller.currentline or -1)..':' }
	for i=1,select('#',...) do
		local v=select(i,...)
		v=tostring(v) or "no value"
		t[#t+1]=v
	end
	local traceback = debug.traceback
	if outfitter_dbg_tosv:GetBool() or OUTFITTER_DEBUG_VERBOSE then
		ErrorNoHalt(traceback(table.concat(t,' '), (lvl or 1))..'\n')
	else
		MsgC(redcolor, traceback(table.concat(t,' '), (lvl or 1))..'\n')
	end
end


local S=SERVER
local C=CLIENT
local function inc(str)
	return function(m)
		local path = Tag..'/'..str..'.lua'

		if S and (m=='sh' or m=='cl') then
			AddCSLuaFile(path)
		end

		if m == 'sh'
			or (S and m=='sv')
			or (C and m=='cl')
		then
			return include(path)
		end
	end
end

_M.json = inc 'json'		'sh'

inc 'cl_util'	'cl'
inc 'gma'		'sh'
inc 'cl_hacks'	'cl'
inc 'sh'		'sh'
inc 'sv'		'sv'
inc 'cows'		'cl'
inc 'cl'		'cl'
inc 'ui'		'cl'
inc 'skin'		'cl'

inc 'gui_about'	'cl'
inc 'gui_ofworkshopicon'	'cl'
inc 'gui_bodygroups'		'cl'
inc 'gui'		'cl'

inc 'net'		'sh'

gma.rebuild_nolua_cache_purge(function(path)
	dbgn(4,"Attempting cleaning cache: "..tostring(path))
end)

--PATH addons/_outfitter/lua/includes/modules/imgparse.lua:

if SERVER then AddCSLuaFile() end


local function unpack_msb_uint32(s)
  local a,b,c,d = s:byte(1,#s)
  local num = (((a*256) + b) * 256 + c) * 256 + d
  return num
end
local function unpack_msb_uint32_r(s)
  local d,c,b,a = s:byte(1,#s)
  local num = (((a*256) + b) * 256 + c) * 256 + d
  return num
end

local function read_msb_uint32(fh)
  return unpack_msb_uint32(fh:Read(4))
end

local function read_byte(fh)
  return fh:Read(1):byte()
end


local function parse_zlib(fh, len)
  local byte1 = read_byte(fh)
  local byte2 = read_byte(fh)

  local compression_method = byte1 % 16
  local compression_info = math.floor(byte1 / 16)

  local fcheck = byte2 % 32
  local fdict = math.floor(byte2 / 32) % 1
  local flevel = math.floor(byte2 / 64)


  fh:Read(len - 6)
  
  local checksum = read_msb_uint32(fh)
  
end

local function parse_IHDR(tbl,fh, len)
  assert(len == 13, 'format error')
  local width = read_msb_uint32(fh)
  local height = read_msb_uint32(fh)
  local bit_depth = read_byte(fh)
  local color_type = read_byte(fh)
  local compression_method = read_byte(fh)
  local filter_method = read_byte(fh)
  local interlace_method = read_byte(fh)

  tbl.width= width
  tbl.height= height
  tbl.bit_depth= bit_depth
  tbl.color_type= color_type
  tbl.compression_method= compression_method
  tbl.filter_method= filter_method
  tbl.interlace_method= interlace_method

  return compression_method
end

local function parse_sRGB(tbl,fh, len)
  assert(len == 1, 'format error')
  local rendering_intent = read_byte(fh)
  tbl.rendering_intent= rendering_intent
end

local function parse_gAMA(tbl,fh, len)
  assert(len == 4, 'format error')
  local rendering_intent = read_msb_uint32(fh)
 tbl.rendering_intent= rendering_intent
end

local function parse_cHRM(tbl,fh, len)
  assert(len == 32, 'format error')

  local white_x = read_msb_uint32(fh)
  local white_y = read_msb_uint32(fh)
  local red_x = read_msb_uint32(fh)
  local red_y = read_msb_uint32(fh)
  local green_x = read_msb_uint32(fh)
  local green_y = read_msb_uint32(fh)
  local blue_x = read_msb_uint32(fh)
  local blue_y = read_msb_uint32(fh)

end

local function parse_IDAT(tbl,fh, len, compression_method)
  if compression_method == 0 then
    -- fh:Read(len)
    parse_zlib(fh, len)
  else
   
  end
end

function file.ParsePNG(fh)
  if isstring(fh) then
  	fh = file.Open(fh,'rb','GAME')
  	
  end
  if not fh then error"Invalid file" end
  
  local tbl = {}
  
  -- parse PNG header
  local bytes = fh:Read(8)
  local expect = "\137\080\078\071\013\010\026\010"
  if bytes ~= expect then
    error 'not a PNG file'
  end

  -- parse chunks
  local compression_method
  while 1 do
    local len = read_msb_uint32(fh)
    local stype = fh:Read(4)
    
    if stype == 'IHDR' then
      compression_method = parse_IHDR(tbl,fh, len)
      break
    elseif stype == 'sRGB' then
      parse_sRGB(tbl,fh, len)
    elseif stype == 'gAMA' then
      parse_gAMA(tbl,fh, len)
    elseif stype == 'cHRM' then
      parse_cHRM(tbl,fh, len)
    elseif stype == 'IDAT' then
      parse_IDAT(tbl,fh, len, compression_method)
    else
      local data = fh:Read(len)
      --print("data=", len == 0 and "(empty)" or "(not displayed)")
    end
	
	local crc = read_msb_uint32(fh)

    if stype == 'IEND' then
      break
    end
  end
  return tbl
end
file.parse_png=file.ParsePNG


function file.ParseJPG(file)
	local dimheader = {  }
	local foundheader = 0
	local endofjpg = file:Tell(file:Seek(file:Size()))
	local width = 0
	local height = 0
	local seek = {  }
	
	file:Seek(0)
	
	dimheader[1] = string.char(255) .. string.char(192)
	dimheader[2] = string.char(255) .. string.char(194)
	validjpg = string.char(255) .. string.char(216)
	if file:Read(2) == validjpg then
		while foundheader == 0 do
			if file:Tell() + 2 < endofjpg then
				readheader = file:Read(2)
			else
				print("Reached end of file", 0)
				foundheader = 1
			end

			if readheader == dimheader[1] or readheader == dimheader[2] then
				if file:Tell() + 3 < endofjpg then
					file:Seek(file:Tell() + 3)
					height = string.byte(file:Read(1)) * 256 + string.byte(file:Read(1))
					width = string.byte(file:Read(1)) * 256 + string.byte(file:Read(1))
					foundheader = 1
				end

			else
				if file:Tell() + 2 < endofjpg then
					seek[1] = string.byte(file:Read(1)) * 256
					seek[2] = string.byte(file:Read(1))
					seek[3] = seek[1] + seek[2] - 2
					if file:Tell() + seek[3] < endofjpg then
						file:Seek(file:Tell() + seek[3])
					else
						error("Reached end of file", 0)
						foundheader = 1
					end

				else
					error("Reached end of file", 0)
					foundheader = 1
				end

			end

		end

	else
		error("Error reading JPG", 0)
	end

	--file:Close()
	return {width=width,height=height}

end

local function IsPowerOfTwo(n)
	return bit.band(n,n-1)==0
end
local function ushort(str)
	return string.byte(str,1)+string.byte(str,2)*256
end
local ID_VTF = "VTF\000"
function file.ParseVTF(file)
	--should we check for vtf?
	if file:Read(4)~=ID_VTF then return nil,'not vtf' end
	local ver1,ver2 = unpack_msb_uint32_r(file:Read(4)),unpack_msb_uint32_r(file:Read(4))
	local headerSize = unpack_msb_uint32_r(file:Read(4))
	if ver1>100 or ver2>900 then return nil,'invalid version' end
	local w,h = ushort(file:Read(2)),ushort(file:Read(2))
	if not (IsPowerOfTwo(w)) or w==0 then return nil,"invalid power" end
	if not (IsPowerOfTwo(h)) or h==0 then return nil,"invalid power" end
	return {width=w,height=h,version = {ver1,ver2},headerSize = headerSize}
end


local ID_JPG = string.char(255) .. string.char(216)
local ID_PNG = "\137\080\078\071\013\010\026\010"


function string.IsPNG(bytes) return bytes:sub(1,8)==ID_PNG end
function string.IsJPG(bytes) return bytes:sub(1,2)==ID_JPG end
function string.IsVTF(bytes) return bytes:sub(1,4)==ID_VTF end



--PrintTable(file.ParseVTF(file.Open("materials/point.vtf",'rb','GAME')))
--PATH addons/_outfitter/lua/includes/modules/netqueue.lua:
if CLIENT then
	--TODO
	net.queuesingle= function(a,...) return a(...) end
	return
end

AddCSLuaFile()

local meta={__index=table}
local queue=setmetatable({},meta )
local started=false
local next=next
local pcall=pcall
local debug=debug
local function doqueue()
	local sent
	for pl,plqueue in next,queue do
		sent=true
		
		if plqueue==true or not pl.IsValid or not pl:IsValid() then
			queue[pl]=nil
		elseif pl:IsTimingOut() then
			-- TODO: track queue? Deduping
		else
			for i=1,2 do -- Something might be sending every tick, bad bad
			
				local func = plqueue:remove(1)
				if not func then
					queue[pl]=nil
				else
					--Dbg("doqueue",pl)
					local ok,err = xpcall(func,debug.traceback,pl)
					if not ok then
						ErrorNoHalt(err..'\n')
					end
					if err==true then
						plqueue[#plqueue]=func
					end
				end
				
			end
		end
	end
	if not sent then
		started=false
		hook.Remove("Tick",'netqueue')
	end
end

function net.queuesingle(pl,func)
	
	if not started then
		hook.Add("Tick",'netqueue',doqueue)
	end
	
	local plqueue=queue[pl]
	
	if plqueue == nil then
		plqueue = setmetatable({},meta)
	
		queue[pl]=plqueue
	end
	

	if plqueue==true then return false end
	
	if #plqueue>50000 then

		ErrorNoHalt("[NetQueue] Queue overflow: "..tostring(pl)..'\n')

		queue[pl] = true
		
		return false
		
	end

	plqueue:insert(func)
	
	return true
end

function net.queue(targets,func)
	if targets==true then
		targets=nil
	elseif targets and isentity(targets) then
		targets={targets}
	end
	
	local notok = false
	for _,pl in next,(targets or player.GetHumans()) do
		notok = notok or not net.queuesingle(pl,func)
	end

	return not notok
	
end

concommand.Add("netqueue_dump",function(pl) if SERVER and IsValid(pl) and not pl:IsAdmin() then return end
	print"Lua NetQueue:"
	local ok
	for pl,v in next,queue do
		Msg("\t",pl,": ")print(table.Count(v))
		if not ok then ok=true end
	end
	if not ok then print"\tEMPTY" end
end)
--PATH addons/_outfitter/lua/includes/modules/ubit.lua:
if SERVER then
	AddCSLuaFile()
end


ubit=ubit or {}

local bit=bit
local ubit=ubit

function gen(name)
	local f=bit[name]
	if not f then error"?!?" end
	local function func(...)
		local ret = f(...)
		return ret>=0 and ret or 0x100000000+ret
	end
	ubit[name] = func
	bit['u'..name] = func
end

gen'rol'
gen'rshift'
gen'ror'
gen'bswap'
gen'bxor'
gen'bor'
gen'arshift'
gen'bnot'
gen'tobit'
gen'lshift'
gen'band'
ubit.tohex=bit.tohex

--PATH addons/_outfitter/lua/outfitter/ui.lua:
local Tag='outfitter'
local NTag = 'OF'

module(Tag,package.seeall)

local GENERIC = "ui/buttonclick.wav"

local NOUI=OUTFITTER_NO_UI

function SOUND(s,force)
	if NOUI or (not force and not CanPlaySounds()) then return end
	surface.PlaySound(s)
end


local mounting
local _mounting
hook.Add('DrawOverlay',Tag,function()
	if not _mounting and not mounting then return end

	if _mounting == true or mounting then _mounting = RealTime() + .5 return end
	if _mounting < RealTime() then _mounting = false end

	local sw,sh = ScrW(),ScrH()
	surface.SetTextColor(255,255,255,255)
	surface.SetFont"closecaption_normal"
	surface.SetDrawColor(90,90,90,200)
	local txt = "#dupes.loading"
	local tw, th = surface.GetTextSize(txt)
	local bw,bh =	tw + 24*2,
					th + 8*2
	local bx,by = 	sw*.5 - bw*.5,
					sh*.2 - bh*.9
	local tx,ty = 	bx + bw*.5 - tw*.5,
					by + bh*.5 - th*.5
					
	surface.DrawRect(bx,by,bw,bh)
	surface.SetDrawColor(255,120,120,200)
	surface.DrawOutlinedRect(bx,by,bw,bh)
	surface.SetDrawColor(255,0,0,200)
	surface.DrawOutlinedRect(bx-1,by-1,bw+2,bh+2)
	surface.DrawOutlinedRect(bx-3,by-3,bw+6,bh+6)
	surface.SetTextPos(tx,ty)
	surface.DrawText(txt)
end)


function UIMounting(yes)
	
	dbg("UIMounting",yes)
	
	if yes then
		_mounting = true
		if mounting then return end
		notification.AddProgress( Tag,
			"(LAG WARNING) Mounting outfitter outfit!" )
		SOUND( GENERIC )
	else
		if not mounting then return end
		timer.Simple(1,function()
			
			if mounting then return end
			
			notification.Kill( Tag )
		end)
		notification.AddProgress( Tag, "Outfit mounted!" )
		SOUND "garrysmod/content_downloaded.wav"
	end
	mounting = yes
end

function UIFullupdate()
	notification.AddLegacy( "Refreshing playerstate...", NOTIFY_ERROR, 4 )
	SOUND'items/cart_explode_trigger.wav'
end

function UIOnEnforce(pl)
	--TODO: exists check. alt: ambient/alarms/warningbell1.wav
	if CanPlaySounds() then
		pl:EmitSound'items/powerup_pickup_agility.wav'
	end
end

local fstatus = {}
function SetUIFetching(wsid,is,FR,force)
	local ID=Tag..wsid
	local canDlNotify = force or CanDownloadNotification()
	
	if is then
		local title = fstatus[wsid]
		if title then return end
		title = true
		fstatus[wsid] = title
		if canDlNotify then
			notification.AddProgress( ID, "Downloading "..wsid )
		end
		SOUND( 'ui/hint.wav' )

		co(function()
			local fileinfo = co_steamworks_FileInfo(wsid)
			
			if not fileinfo then return end
			local name = fileinfo.title
			if not name then return end
			
			co.waittick()
			co.waittick()
			local title2 = fstatus[wsid]
			
			if not title2 or title2~=title then return end
			fstatus[wsid] = name
			if canDlNotify then
				notification.AddProgress( ID, name..' (Downloading)' )
			end
			--TODO: Timeout?
		end)

	else
		local title = fstatus[wsid] fstatus[wsid] = false
		if not title then return end
		local _title = title
		title = title~=true and title or wsid
		if canDlNotify then
			notification.AddProgress( ID, title.." ("..(FR and tostring(FR) or "Finished")..")" )
		end
		co(function()
			co.sleep(FR and 4 or 1.5)
			
			local status = fstatus[wsid]
			
			if status then return end
			
			notification.Kill( ID )
		end)
		
	end
end



local function Command(com,v1)
	com = com:lower()
	
	if NOUI then return end
	
	if com=="outfit" or com=="otufit" or com=="oufit" or com=="fouti" then
		local n = v1 and tonumber(v1:Trim())
		v1=v1 and v1:lower():Trim()
		
		if not n and v1 then
			n = UrlToWorkshopID(tostring(v1))
			if n then
				n=tonumber(n)
			end
		end
		
		dbg("outfitcmd",v1,n)
		if n then
			UIChangeModelToID(n)
			
		elseif v1 == "apply" or v1=='aply' or v1=='a' or v1 == "send" or v1=='snd' or v1=='s'  then
			UIBroadcastMyOutfit()
		elseif v1 == "cancel" or v1=='c' or v1=='canecl'  or v1=='d'  or v1=='del'  or v1=='delete' or v1=='remove' then
			UICancelAll()
		elseif v1 == "autowear" or v1== "save" then
			SetAutowear()
		elseif v1 == "fixanims" then
			FixLocalPlayerAnimations(true)
		elseif v1 == "fullupdate" then
			Fullupdate()
		else
			GUIOpen()
			--UIError"Invalid command"
		end
		return true
		
	elseif com==Tag or com=='outfiter'  or com=='oufiter'  or com=='oufitr' or com=='utfitter' or com=='utfiter' then
		local n = v1 and tonumber(v1)
		if not n and v1 then
			n = UrlToWorkshopID(tostring(v1))
			if n then
				n=tonumber(n)
			end
		end
		if n then
			UIChoseWorkshop(n)
		elseif v1 == "fixanims" then
			FixLocalPlayerAnimations(true)
		elseif v1 == "fullupdate" then
			Fullupdate()
		elseif v1 and v1:len()>0 then
			GUIWantChangeModel(v1)
		else
			GUIOpen()
		end
		return true
	end
end


concommand.Add(Tag..'_cmd',function(_,_,args,line)
	if not line then
		chat.AddText("[Outfitter] Something is messing with the concommand library (outdated addon?)")
		line=args[1]
	end
	if line:find"https?:$" then
		MsgC(Color(255,155,111,255),'Invalid usage! ',Color(255,240,240,255),'Please quote the URL. Example: outfitter "https://steamcommunity.com/sharedfiles/filedetails/?id=1234"\n')
		return
	end
	if args and args[1]then
		local n = UrlToWorkshopID(line)
		if n then
			args={n}
		end
	end
	Command('outfit',unpack(args))
end)

concommand.Add(Tag,function(_,_,args,line)
	if not line then
		chat.AddText("[Outfitter] Something is messing with the concommand library (outdated addon?)")
		line=args[1]
	end
	if line:find"https?:$" then
		MsgC(Color(255,155,111,255),'Invalid usage! ',Color(255,240,240,255),'Please quote the URL. Example: outfitter "https://steamcommunity.com/sharedfiles/filedetails/?id=1234"\n')
		return
	end
	if args and args[1]then
		local n = UrlToWorkshopID(line)
		if n then
			args={n}
		end
	end
	
	Command(Tag,unpack(args))
end)

hook.Add("ChatCommand",Tag,function(com,v1)
	return Command(com,v1)
end)

concommand.Add("outfitter_bodygroups_list",function(pl,_,_,mdl)
	if not mdl or mdl:Trim()=="" then
		mdl = pl:GetModel()
	end
	
	MsgN("Listing bodygroups of ",mdl)
	local ok,mdl = pcall(mdlinspect.Open,mdl)
	if not ok then print(mdl) return end
	
	local t = mdl:BodyParts()
	MsgN"================"
	local found
	for i,dat in next,t do
		found=true
		if dat.nummodels and dat.nummodels>1 then
			Msg(' '..tostring(dat.nummodels)..' groups  |  ')
			print(dat.name)
		else
			Msg(' No groups |  ')
			print(dat.name)
		end
		
	end
	if not found then print"No bodygroups??" end
	MsgN"================"
end)

concommand.Add("outfitter_skin_set",function(pl,cmd,args,line)
	n = tonumber(args[1] or 1) or 1
	RequestSkin(n)
	pl.outfitter_skin = n
end)


concommand.Add("outfitter_bodygroups_set",function(pl,cmd,args,line)
	if not line then
		chat.AddText("[Outfitter] Something is messing with the concommand library (outdated addon?)")
		line=args[1]
	end
	if line:Trim()=="" then 
		print("Usage: outfitter_bodygroups_set HeadAttachment=0,Backpack=2,Shorts=1")
		return
	end
	
	local t={}
	for entry in line:gmatch'[^%,]+' do
		local k,v = entry:match'([^%="]+)%=(%d%d?)' --TODO: parse a-z
		if k then
			t[k]=tonumber(v)
		end
	end
	
	local mdl = mdlinspect.Open(pl:GetModel())
	local bodyparts = mdl:BodyParts()
	local bp = mdlinspect.BodyPartBuilder(bodyparts,0)

	print(table.ToString(t))

	pl.outfitter_bodygroups = {}
	--pl.outfitter_skin = 1

	for k,v in next,t do
		local ok,a,b,c = bp:Set(k,v)

		if ok then
			pl.outfitter_bodygroups[k] = v
		else
			Msg("[Set Bodygroup] Failed setting ",k,": ")print(b)
		end
	end

	pl:SetBodyGroupData(bp:GetValue())
end)


CWHITE = Color(255,255,255,255)
CBLACK = Color(0,0,0,0)
local ns = 0
function UIError(...)
	dbgn(2,...)
	local t= {Color(200,50,10),'[Outfitter ERROR] ',CWHITE,...}
	local now = RealTime()
	if ns<now then
		ns=now + 1
		SOUND("common/warning.wav")
	end
	local t2={}
	for i=1,select('#',...) do
		local v=select(i,...)
		v=tostring(v) or "no value"
		t2[i]=v
	end
	local str = table.concat(t2,' ')
	
	notification.AddLegacy( str, NOTIFY_ERROR, 4 )
	chat.AddText(CWHITE,unpack(t))
end

local ns = 0
function UIMsg(...)
	local t= {Color(50,200,10),'[Outfitter] ',CWHITE,...}
	local now = RealTime()
	if ns<now then
		ns=now + 1
		SOUND("weapons/grenade/tick1.wav")
	end
	chat.AddText(unpack(t))
end

local mdllist
local handslist
local chosen_download_info
local tried_mounting
local mount_path
local chosen_mdl
local mdllist_extra
function UIGetMDLList()
	return mdllist
end

function UIGetMDLListExtra()
	return mdllist_extra
end

function UITriedMounting()
	return tried_mounting
end
function UIGetChosenMDL()
	return chosen_mdl
end
function UIGetWSID()
	return tonumber(chosen_download_info)
end
function UIGetDownloadInfo()
	return not tonumber(chosen_download_info) and chosen_download_info
end

function UIGetDownloadInfoX()
	return chosen_download_info
end

function UICancelAll()
	UIMsg"Unsetting everything"
	
	mdllist = nil
	mdllist_extra = nil
	chosen_download_info = nil
	mount_path = nil
	tried_mounting = nil
	chosen_mdl = nil
	
	RemoveOutfit()
	EnforceHands()
	UIClearBodyGroupData()
	UIClearSkin()
end

function UIClearBodyGroupData()
	LocalPlayer():SetBodyGroupData(0)
end
function UIClearSkin()
	LocalPlayer().outfitter_skin = 1
	RequestSkin(1)
end

function UIBroadcastMyOutfit()
	 
	local mdl,wsid = BroadcastMyOutfit()
	if mdl then
		SOUND"ui/item_robot_arm_pickup.wav"
	else
		SOUND"ui/item_robot_arm_drop.wav"
	end
	return mdl,wsid
end

local relay_opengui
function UIChangeModelToID(n,opengui)

	if co.make(n,opengui) then return end
	
	dbg("UIChangeModelToID",n)
	
	UIClearBodyGroupData()
	UIClearSkin()

	chosen_mdl = nil
	
	if not chosen_download_info then
		if opengui then GUIOpen() end
		return UIError"Type only !outfit first to choose workshop addon"
	end
	if not mdllist or #mdllist==0 then
		if opengui then GUIOpen() end
		return UIError"No models to choose from"
	end
	local mdl = mdllist[n]
	if not mdl then
		if opengui then GUIOpen() end
		return UIError"Invalid model index"
	end
	
	assert(mount_path,"mount_path missing for "..tostring(chosen_download_info))
	local ok,err = coMountWS( mount_path )

	if not ok then
		if opengui then GUIOpen() end
		return UIError("The workshop addon could not be mounted: "..tostring(err))
	end
	
	assert(mdl.Name)
	
	chosen_mdl = n
	relay_opengui = opengui
	
	-- returns instantly, but should be instant anyway
	OnChangeOutfit(LocalPlayer(),mdl.Name,chosen_download_info)
	dbg("EnforceHands?",ShouldHands(),n,mdllist[2]==nil,handslist,handslist and handslist[1])
	if n==1 and nil==mdllist[2] and handslist and next(handslist)~=nil and ShouldHands() then
		local _,entry = next(handslist)
		EnforceHands(entry.Name)
	else
		EnforceHands()
	end
		
end

local silent_apply_mdl
function UISetSilentApplyModel(mdl)
	silent_apply_mdl = mdl
end
hook.Add("OutfitApply",Tag,function(pl,mdl)
	
	if pl==LocalPlayer() and mdl then
		local opengui = relay_opengui
		relay_opengui=false
		
		if NOUI then return end
		
		notification.AddLegacy( "Outfit changed!", NOTIFY_UNDO, 2 )
		SOUND( GENERIC )
		if silent_apply_mdl ~= mdl then
			UIMsg"Write '!outfit send' to send this outfit to everyone"
		end
		silent_apply_mdl = nil
		if opengui then
			GUIOpen()
		end
		
	end
end)

function UIChoseWorkshop(wsid,opengui)
	assert(tonumber(wsid))
	
	if co.make(wsid,opengui) then return end
	
	mdllist = nil
	chosen_download_info = nil
	mount_path = nil
	tried_mounting = nil
	chosen_mdl = nil
	
	SetUIFetching(wsid,true)
		co.sleep(.5)
			local path,err,err2 = coFetchWS( wsid ) -- also decompresses
		co.sleep(.2)
	SetUIFetching(wsid,false,not path and (err and tostring(err) or "FAILED?"))
	
	if not path then
		dbg("UIChoseWorkshop",wsid,"FetchWS failed:",err,err2)
		if opengui then GUIOpen() end
		return UIError("Download failed for workshop "..wsid..": "..tostring(err~=nil and tostring(err) or GetLastMountErr and GetLastMountErr()))
	end
	co.sleep(.2)
	
	local mdls,extramodelinfos,err = GMAPlayerModels( path )
	--PrintTable(mdls)
	
	if not mdls and extramodelinfos=='notgma' then
		dbgn(2," TestLZMA(",path,") ==", ("%q"):format(file.Read(path,'GAME'):sub(1,14)),TestLZMA(path) )
	end
	if not mdls and extramodelinfos=='notgma' and TestLZMA(path) then
		local newpath,extramodelinfos = coDecompress(path)
		if not newpath then
			if opengui then GUIOpen() end
			return UIError("Download failed for workshop "..wsid..": "..tostring(extramodelinfos~=nil and tostring(extramodelinfos) or GetLastMountErr and GetLastMountErr())) 
		end
		path = newpath
		
		-- retry --
		mdls,extramodelinfos,err = GMAPlayerModels( path )
		-----------
	end
	
	
	if not mdls then
		dbge("UIChoseWorkshop",wsid,"GMAPlayerModels failed for:",extramodelinfos,err)
		notification.AddLegacy( '[Outfitter] '..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos), NOTIFY_ERROR, 2 )
		if opengui then GUIOpen() end
		return UIError("Parsing workshop addon "..wsid.." failed: "..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos))
	end
	
	local ok,err = GMABlacklist(path)
	if not ok then
		if opengui then GUIOpen() end
		return UIError("OUTFIT BLOCKED: "..tostring(err=="oversize vtf" and "Contains too big textures" or err))
	end
	
	if not mdls[1] then
		dbg("UIChoseWorkshop","GMAPlayerModels",wsid,"no valid models!?")
		
		if opengui then GUIOpen() end
		
		UIError("Workshop addon "..wsid.." has no valid playermodels")
		if extramodelinfos and istable(extramodelinfos) and extramodelinfos.discards and next(extramodelinfos.discards) then
			for mdl,dat in next,extramodelinfos.discards or {} do
				mdl = MDLToUI(mdl)
				if dat.error_vvd then
					UIError(mdl,":",tostring(TranslateError(dat.error_vvd)))
				elseif dat.error_player then
					UIError(mdl,":",tostring(TranslateError(dat.error_player)))
				end
			end
		end
		
	end
	
	co.sleep(.2)
	
	if mdls[2] then
		UIMsg("Models:")
		for k,mdl in next,mdls do
			UIMsg(" "..k..". "..tostring(mdl and MDLToUI(mdl.Name)))
		end
	elseif mdls[1] then
		UIMsg("Got model: "..tostring(MDLToUI(mdls[1].Name)))
	end
	
	chosen_download_info = wsid
	mdllist = mdls
	mdllist_extra = extramodelinfos
	handslist = extramodelinfos.hands
	mount_path = path
	
	if mdls[2] then
		UIMsg"Write !outfit <model number> to choose a model"
		if opengui then GUIOpen() end
	else
		UIChangeModelToID(1,opengui)
	end
	

end

function UIChoseHTTPGMA(download_info,opengui)
	if co.make(download_info,opengui) then return end
	assert(not tonumber(download_info))

	mdllist = nil
	chosen_download_info = nil
	mount_path = nil
	tried_mounting = nil
	chosen_mdl = nil
	
	local id = URLFilename(download_info) or "httpgma:"..util.CRC(download_info)

	SetUIFetching(id,true)
		co.sleep(.1)
			local data,err,err2 = coFetchGMA( download_info )
		co.sleep(.1)
	SetUIFetching(id,false,not data and (err and tostring(err) or "FAILED?"))
	if not data then
		dbg("UIChoseHTTPGMA",id,"FetchWS failed:",err,err2)
		if opengui then GUIOpen() end
		return UIError("Download failed for workshop "..id..": "..tostring(err~=nil and tostring(err) or GetLastMountErr and GetLastMountErr()))
	end
	co.sleep(.2)
	
	local path = data.path
	local mdls,extramodelinfos,err = GMAPlayerModels( path )
	--PrintTable(mdls)
	
	if not mdls and extramodelinfos=='notgma' then
		dbgn(2," TestLZMA(",path,") ==", ("%q"):format(file.Read(path,'GAME'):sub(1,14)),TestLZMA(path) )
	end
	if not mdls and extramodelinfos=='notgma' and TestLZMA(path) then
		local newpath,extramodelinfos = coDecompress(path)
		if not newpath then
			if opengui then GUIOpen() end
			return UIError("Download failed for workshop "..id..": "..tostring(extramodelinfos~=nil and tostring(extramodelinfos) or GetLastMountErr and GetLastMountErr())) 
		end
		path = newpath
		
		-- retry --
		mdls,extramodelinfos,err = GMAPlayerModels( path )
		-----------
	end
	
	
	if not mdls then
		dbge("UIChoseHTTPGMA",id,"GMAPlayerModels failed for:",extramodelinfos,err)
		notification.AddLegacy( '[Outfitter] '..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos), NOTIFY_ERROR, 2 )
		if opengui then GUIOpen() end
		return UIError("Parsing addon "..id.." failed: "..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos))
	end
	
	local ok,err = GMABlacklist(path)
	if not ok then
		if opengui then GUIOpen() end
		return UIError("OUTFIT BLOCKED: "..tostring(err=="oversize vtf" and "Contains too big textures" or err))
	end
	
	if not mdls[1] then
		dbg("UIChoseHTTPGMA","GMAPlayerModels",id,"no valid models!?")
		
		if opengui then GUIOpen() end
		
		UIError("Workshop addon "..id.." has no valid playermodels")
		if extramodelinfos and istable(extramodelinfos) and extramodelinfos.discards and next(extramodelinfos.discards) then
			for mdl,dat in next,extramodelinfos.discards or {} do
				mdl = MDLToUI(mdl)
				if dat.error_vvd then
					UIError(mdl,":",tostring(TranslateError(dat.error_vvd)))
				elseif dat.error_player then
					UIError(mdl,":",tostring(TranslateError(dat.error_player)))
				end
			end
		end
		
	end
	
	co.sleep(.2)
	
	if mdls[2] then
		UIMsg("Models:")
		for k,mdl in next,mdls do
			UIMsg(" "..k..". "..tostring(mdl and MDLToUI(mdl.Name)))
		end
	elseif mdls[1] then
		UIMsg("Got model: "..tostring(MDLToUI(mdls[1].Name)))
	end
	
	chosen_download_info = download_info
	mdllist = mdls
	mdllist_extra = extramodelinfos
	handslist = extramodelinfos.hands
	mount_path = path
	
	if mdls[2] then
		UIMsg"Write !outfit <model number> to choose a model"
		if opengui then GUIOpen() end
	else
		UIChangeModelToID(1,opengui)
	end
	

end





-- autowear --



function SetAutowear()
	local pl = LocalPlayer()
	
	local mdl,wsid,skin,bodygroup = pl:OutfitInfo()
	
	local t = {mdl=mdl,wsid=wsid,skin=skin,bodygroup=bodygroup,setbodygroupdata = pl:GetBodyGroupData(),hands = pl.outfitter_hands}
	
	
	if mdl then
		util.SetPData("0",Tag..'_autowear',json.encode(t))
		UIMsg("Autowear ON")
	else
		util.RemovePData("0",Tag..'_autowear')
		UIMsg("Autowear OFF")
	end

end

			
local oversized = {}
function coUIOversizeMsg(pl,wsid)

	
	if oversized[wsid] then return end
	oversized[wsid] = true
	
	local fileinfo = co_steamworks_FileInfo(wsid)
	
	local maxsz = 100
	maxsz = maxsz*1000*1000
	maxsz = string.NiceSize(maxsz)
	local szstr=""
	if fileinfo and istable(fileinfo) and fileinfo.size then
		szstr = ("(%s) "):format(string.NiceSize(fileinfo.size or 0))
	end
	
	UIMsg("The outfit of ",pl,(" is too big %saccording to your settings (%s) so it was not mounted!"):format(szstr,maxsz))

end



-- This is a horrible hack because of forethought was lacking when the rest of the code was made
-- duplicated from two different functions, etc
function coDoAutowear()
	local dat = util.GetPData("0",Tag..'_autowear')
	if not dat or dat=="" or dat=="nil" then return end
	local t = json.decode(dat)
	if not t then return end
	if not t.mdl then return end
	if t.mdl=="" then return end
	
	local mdl,wsid,skin,bodygroup,setbodygroupdata = t.mdl,t.wsid,t.skin,t.bodygroup,t.setbodygroupdata
	local hands = t.hands
	
	if not mdl then return end
	
	dbg("Autowearing",mdl,"from",wsid,"setbodygroupdata=",setbodygroupdata)

	SetUIFetching(wsid,true)
		co.sleep(.5)
			local path,err,err2 = coFetchWS( wsid )
		co.sleep(.2)
	SetUIFetching(wsid,false,not path and (err and tostring(err) or "FAILED?"))
	
	if not path then
		dbg("coDoAutowear",wsid,"FetchWS failed:",err,err2)
		if opengui then GUIOpen() end
		return UIError("Download failed for workshop "..wsid..": "..tostring(err~=nil and tostring(err) or GetLastMountErr and GetLastMountErr()))
	end
	co.sleep(.2)

	local mdl_exists = file.Exists(mdl,'GAME')
	local skip_additional_checks = mdl_exists
	if not IsUGCFilePath(path) then
		skip_additional_checks = false
	end
	
	local mdls,extramodelinfos,err
	
	if not skip_additional_checks then		
		mdls,extramodelinfos,err = GMAPlayerModels( path )
		
		if not mdls and extramodelinfos=='notgma' then
			dbgn(2," TestLZMA(",path,") ==", ("%q"):format(file.Read(path,'GAME'):sub(1,14)),TestLZMA(path) )
		end
		if not mdls and extramodelinfos=='notgma' and TestLZMA(path) then
			local newpath,extramodelinfos = coDecompress(path)
			if not newpath then
				if opengui then GUIOpen() end
				return UIError("Download failed for workshop "..wsid..": "..tostring(extramodelinfos~=nil and tostring(extramodelinfos) or GetLastMountErr and GetLastMountErr())) 
			end
			path = newpath
			
			-- retry --
			mdls,extramodelinfos,err = GMAPlayerModels( path )
			-----------
		end
		
	
		if not mdls then
			dbge("coDoAutowear",wsid,"GMAPlayerModels failed for:",extramodelinfos,err)
			notification.AddLegacy( '[Outfitter] '..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos), NOTIFY_ERROR, 2 )
			return UIError("Parsing workshop addon "..wsid.." failed: "..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos))
		end
		
		local ok,err = GMABlacklist(path)
		if not ok then
			return UIError("OUTFIT BLOCKED: "..tostring(err=="oversize vtf" and "Contains too big textures" or err))
		end
		
		if not mdls[1] then
			dbge("coDoAutowear","GMAPlayerModels",wsid,"no models!?")
			return UIError("Workshop addon "..wsid.." has no playermodels")
		end
	
	end
	
	co.sleep(.2)
	
	local chosen_download_info = wsid
	local handslist = extramodelinfos and extramodelinfos.hands
	local mount_path = path
	
	if not skip_additional_checks then
		assert(mount_path,"mount_path missing for "..tostring(chosen_download_info))
		local ok,err = coMountWS( mount_path )

		if not ok then
			return UIError("The workshop addon could not be mounted: "..tostring(err))
		end
	end
	
	assert(mdl)
	
	UISetSilentApplyModel(mdl)
	
	-- returns instantly, but should be instant anyway
	OnChangeOutfit(LocalPlayer(),mdl,chosen_download_info)
	
	-- cannot enforce hands without crashing at the moment
	dbg("coDoAutowear","EnforceHands",ShouldHands(),next(handslist or {}))
	if next(handslist or {})~=nil and ShouldHands() then
		local _,entry = next(handslist)
		EnforceHands(entry.Name)
	else
		EnforceHands()
	end
	
	--LocalPlayer():SetWantOutfit(mdl,wsid,skin,bodygroup)
	
	if setbodygroupdata and setbodygroupdata~=0 then
		dbg("SetBodyGroupData",setbodygroupdata)
		LocalPlayer():SetBodyGroupData(setbodygroupdata)
	end
	if skin then
		skin = tonumber(skin or 1) or 1
		LocalPlayer().outfitter_skin = skin
		RequestSkin(skin)
	end
	BroadcastMyOutfit()

	return true
end

local warned
function UIWarnDownloadFailures(wsid)
	wsid=tostring(wsid or "0")
	SetUIFetching(wsid,false,"TIMEOUT ERROR")
	SOUND("common/warning.wav")
	if not warned then
		warned=true
		chat.AddText(Color(255,100,100,255),"!!! ALERT !!! ",Color(255,144,144,255),"Workshop download may have timed out (a steam bug). Open downloads tab in steam and check if GarrysMod workshop updating has paused, try resuming it. More info: https://steamcommunity.com/workshop/filedetails/discussion/882463775/3096727865549498026/ Other downloads will not resume before this is done.")
	end	
end

--PATH addons/ukrp_main_content/lua/autorun/ow2_rammatra.lua:
player_manager.AddValidModel( "Overwatch 2 Rammatra", "models/Rammatra/OW2/rstar/Rammatra/Rammatra.mdl" );
player_manager.AddValidHands( "Overwatch 2 Rammatra", "models/Rammatra/OW2/rstar/Rammatra/arms/Rammatra_arms.mdl", 0, "00000000" )
--PATH addons/_pcasino/lua/perfectcasino/core/sh_config.lua:
PerfectCasino.Core.Entites = PerfectCasino.Core.Entites or {}
function PerfectCasino.Core.RegisterEntity(class, data, model)
	PerfectCasino.Core.Entites[class] = {}
	PerfectCasino.Core.Entites[class].cache = {}
	PerfectCasino.Core.Entites[class].config = data
	PerfectCasino.Core.Entites[class].model = model
end

function PerfectCasino.Core.GetEntityConfigOptions(class)
	return PerfectCasino.Core.Entites[class].config
end

if SERVER then return end

function PerfectCasino.Core.RequestConfigData(entity)
	net.Start("pCasino:RequestData:Send")
		net.WriteEntity(entity)
	net.SendToServer()
end

net.Receive("pCasino:RequestData:Respond", function()
	local ent = net.ReadEntity()
	if not ent then return end

	local data = net.ReadTable()
	ent.data = data
	if ent.PostData then
		ent:PostData()
	end
end)
--PATH addons/____plogs/lua/autorun/plogs_init.lua:
--[[
addons/lgos/lua/autorun/plogs_init.lua
--]]
local include_sv = (SERVER) and include or function() end
local include_cl = (SERVER) and AddCSLuaFile or include
local include_sh = function(path) include_sv(path) include_cl(path) end

plogs		= plogs			or {}
plogs.cfg 	= plogs.cfg 	or {}
plogs.types	= plogs.types	or {}
plogs.data	= plogs.data	or {}

plogs.Version = '2.7.1'

function plogs.Error(str)
	return ErrorNoHalt('[pLogs] ' .. str)
end

-- Lib modules from: https://github.com/SuperiorServers/plib_v2
include_sh 'plogs/lib/pon1.lua'
include_cl 'plogs/lib/pdraw.lua'
include_sv 'plogs/lib/table.lua'

include_sh 'plogs_cfg.lua' 
include_sh 'plogs/workarounds/sanity_checker.lua'

if (SERVER) and plogs.cfg.EnableMySQL then
	include_sv 'plogs_mysql_cfg.lua'
	if (system.IsWindows() and file.Exists('lua/bin/gmsv_tmysql4_win32.dll', 'MOD')) or (system.IsLinux() and file.Exists('lua/bin/gmsv_tmysql4_linux.dll', 'MOD')) then
		include_sv 'plogs/lib/ptmysql.lua'
		plogs.sql = ptmysql
	elseif (system.IsWindows() and file.Exists('lua/bin/gmsv_mysqloo_win32.dll', 'MOD')) or (system.IsLinux() and file.Exists('lua/bin/gmsv_mysqloo_linux.dll', 'MOD')) then
		include_sv 'plogs/lib/pmysqloo.lua'
		plogs.sql = pmysqloo
	end

	if (plogs.sql == nil) then
		plogs.Error('MySQL is enabled but pLogs could not find the tmysql or mysqloo module installed!') -- reduce support tickets by 50%
		plogs.cfg.EnableMySQL = false
	else
		include_sv 'plogs/mysql.lua'
	end
end

include_sh 'plogs/core_sh.lua'
include_sv 'plogs/core_sv.lua'
include_sh 'plogs/console.lua'

include_cl 'plogs/vgui/skin.lua'
include_cl 'plogs/vgui/frame.lua'
include_cl 'plogs/vgui/tablist.lua'

include_cl 'plogs/menu.lua'

if (not file.IsDir('plogs/saves', 'data')) then
	file.CreateDir('plogs/saves')
end

hook.Add('Initialize', 'plogs.Loghooks.Initialize', function()
	local files, _ = file.Find('plogs_hooks' .. '/*.lua', 'LUA')
	for _, f in ipairs(files) do
	if plogs.cfg.LogTypes[f:sub(1, f:len() - 4):lower()] then continue end
		include_sh('plogs_hooks/' .. f)
	end
end)

local msg = {
	'\n\n',
	[[         __                  ]],
	[[ _ __   / /  ___   __ _ ___  ]],
	[[| '_ \ / /  / _ \ / _` / __| ]],
	[[| |_) / /__| (_) | (_| \__ \ ]],
	[[| .__/\____/\___/ \__, |___/ ]],
	[[|_|               |___/      ]],
	'\n',
	[[Version ]] .. plogs.Version .. [[ by aStonedPenguin]],
	'\n\n',
}

for k, v in ipairs(msg) do 
	MsgC(Color(250,0,0), v .. '\n')
end


--PATH addons/____plogs/lua/plogs/menu.lua:
--[[
addons/lgos/lua/plogs/menu.lua
--]]
-- To-do recode this mess.
surface.CreateFont('plogs.ui.26', {font = 'roboto', size = 26, weight = 400})
surface.CreateFont('plogs.ui.24', {font = 'roboto', size = 24, weight = 400})
surface.CreateFont('plogs.ui.22', {font = 'roboto', size = 22, weight = 400})
surface.CreateFont('plogs.ui.20', {font = 'roboto', size = 20, weight = 400})
surface.CreateFont('plogs.ui.19', {font = 'roboto', size = 19, weight = 400})
surface.CreateFont('plogs.ui.18', {font = 'roboto', size = 18, weight = 400})
surface.CreateFont('plogs.ui.16', {font = 'roboto', size = 16, weight = 400})

local function Search(command)
	local w, h = ScrW() * .3, 120
	local posx, posy = ScrW()*0.5 - w*0.5, ScrH()*0.5 - h*0.5

	if IsValid(plogs.SearchMenu) then
		plogs.SearchMenu:Remove()
	end

	if IsValid(plogs.Menu) then
		local x, y = plogs.Menu:GetPos()
		posy = plogs.Menu:GetTall() + y + 10
	end

	local fr = vgui.Create('onyx.Frame')
	fr:SetTitle('Пошук')
	fr:SetSize(w, h)
	fr:MakePopup()
	fr:SetPos(posx, posy)
	plogs.SearchMenu = fr

	local lbl = vgui.Create('onyx.Label', fr)
	lbl:SetPos(5, 35)
	lbl:SetText('Введіть SteamID для пошуку')
	lbl:SizeToContents()

	local txt = vgui.Create('onyx.TextEntry', fr)
	txt:SetPos(5, 60)
	txt:SetSize(w - 10, 25)

	local srch = vgui.Create('onyx.Button', fr)
	srch:SetPos(5, 90)
	srch:SetSize(w - 10, 25)
	srch:SetText('Пошук')
	srch.DoClick = function(self)
		LocalPlayer():ConCommand('plogs "' .. command .. '" "' .. txt:GetValue() .. '"')
		fr:Close()
	end
end

local function LogMenu(title, data)
	if IsValid(plogs.Menu) then
		plogs.Menu:SetVisible(false)
	end
	if IsValid(plogs.LogMenu) then
		plogs.LogMenu:Remove()
	end
	
	local w, h = plogs.cfg.Width * ScrW(), plogs.cfg.Height * ScrH()

	local fr = vgui.Create('onyx.Frame')
	fr:SetTitle('Пошук')
	fr:SetSize(w, h)
	fr:SetTitle(title)
	fr:Center()
	fr:MakePopup()
	fr._Close = fr.Close
	fr.Close = function(self)
		if IsValid(plogs.Menu) then
			plogs.Menu:SetVisible(true)
		end
		fr:_Close()
	end
	plogs.LogMenu = fr

	local logList = vgui.Create('DListView', fr)
	logList:SetPos(0, 29)
	logList:SetSkin('plogs')
	logList:SetSize(fr:GetWide(), fr:GetTall() - 29)
	logList:SetMultiSelect(false)
	logList:AddColumn('Дата'):SetFixedWidth(175)
	logList:AddColumn('Дані')
	logList.OnRowSelected = function(parent, line)
		local column 	= logList:GetLine(line)
		local log 		= column:GetColumnText(2)
		local menu 		= vgui.Create('onyx.Menu')
		menu:SetPos( gui.MouseX(), gui.MouseY() )

		menu:AddOption('Копіювати рядок', function() 
			SetClipboardText(log)
			LocalPlayer():ChatPrint('Скопійований рядок')
		end)
		menu:Open()
	end

	for k, v in ipairs(data) do
		logList:AddLine(isstring(v.Date) and v.Date or os.date('%X - %d/%m/%Y', v.Date), v.Data)
	end
end

local c = 1
local saveList
local function OpenMenu()
	local w, h = plogs.cfg.Width * ScrW(), plogs.cfg.Height * ScrH()
	c = 1

	local fr = plogs.Menu

	if IsValid(fr) then
		fr:Remove()
	end

	local count = table.Count(plogs.data)
	local fr = vgui.Create('onyx.Frame')
	fr:SetTitle('Пошук')
	fr:SetSize(w, h)
	fr:Center()
	fr:MakePopup()
	fr._Close = fr.Close
	fr.Close = function(self)
		if IsValid(plogs.SearchMenu) then
			plogs.SearchMenu:Close()
		end
		fr:_Close()
	end
	fr.PaintOver = function(self, w, h)
		if (c < count) then
			plogs.draw.Box(0, 0, w * c/count , 4, plogs.ui.ProgressBar)
		end
	end
	plogs.Menu = fr

	local tabs = vgui.Create('plogs_tablist', fr)
	tabs:SetPos(0, 29)
	tabs:SetSize(w, h - 29)
	plogs.Menu.Tabs = tabs
	
	local pnl =	vgui.Create('EditablePanel', tabs)
	tabs:AddTab('Зберігає', pnl, true)

	local logList = vgui.Create('DListView', pnl)
	logList:SetPos(0, 0)
	logList:SetSkin('plogs')
	logList:SetSize(pnl:GetWide(), pnl:GetTall() - 150)
	logList:SetMultiSelect(false)
	logList:AddColumn('Час'):SetFixedWidth(75)
	logList:AddColumn('Дані')
	logList.OnRowSelected = function(parent, line)
		local column 	= logList:GetLine(line)
		local log 		= column:GetColumnText(2)
		local menu 		= vgui.Create('onyx.Menu')
		menu:SetPos( gui.MouseX(), gui.MouseY() )

		menu:AddOption('Копіювати рядок', function() 
			SetClipboardText(log)
			LocalPlayer():ChatPrint('Скопійований рядок')
		end)
		for name, value in SortedPairs(column.Copy or {}) do
			menu:AddOption('Копія ' .. name, function() 
				SetClipboardText(value or 'ERROR')
				LocalPlayer():ChatPrint('Скопійовано ' .. name)
			end)
		end
		menu:Open()
	end
	logList.AddLogs = function(self, name)
		for k, v in pairs(self:GetLines()) do
			self:RemoveLine(k)
		end
		for _, log in SortedPairs(plogs.OpenSave(name)) do
			local line 	= self:AddLine(log.Date, log.Data)
			line.Copy 	= log.Copy
		end
	end

	local save
	saveList = vgui.Create('DListView', pnl)
	saveList:SetPos(5, pnl:GetTall() - 145)
	saveList:SetSize(pnl:GetWide()*0.5 - 7.5, 140)
	saveList:SetMultiSelect(false)
	saveList:AddColumn('Зберігає')
	saveList.OnRowSelected = function(parent, line)
		save = saveList:GetLine(line):GetColumnText(1)
	end
	saveList.AddSaves = function(self)
		for k, v in pairs(self:GetLines()) do
			self:RemoveLine(k)
		end
		for k, v in ipairs(plogs.GetSaves()) do
			self:AddLine(v)
			if (k == 1) then save = v end
		end
	end
	saveList:AddSaves()

	local btn = vgui.Create('onyx.Button', pnl)
	btn:SetPos(pnl:GetWide()*0.5 + 2.25, pnl:GetTall() - 145)
	btn:SetSize(pnl:GetWide()*0.5 - 7.5, 25)
	btn:SetText('Відчинено')
	btn.DoClick = function()
		logList:AddLogs(save)
	end

	btn = vgui.Create('onyx.Button', pnl)
	btn:SetPos(pnl:GetWide()*0.5 + 2.25, pnl:GetTall() - 115)
	btn:SetSize(pnl:GetWide()*0.5 - 7.5, 25)
	btn:SetText('Видалити')
	btn.DoClick = function()
		plogs.DeleteSave(save)
		saveList:AddSaves()
	end

	if plogs.cfg.EnableMySQL then
		tabs:AddButton('Події гравців', function()
			Search('playerevents')
		end)

		if CAMI.PlayerHasAccess(pl, "plogs_ip_access") then
			tabs:AddButton('IP журнали', function()
				Search('ipsearch')
			end)
		end
	end
end

net.Receive('plogs.OpenMenu', function()
	if (not IsValid(plogs.Menu)) then OpenMenu() end

	local name = net.ReadString()
	local size = net.ReadUInt(16)
	local data = plogs.Decode(net.ReadData(size))

	plogs.data[name] = data

	local tabs = plogs.Menu.Tabs
	local pnl =	vgui.Create('EditablePanel', tabs)
	tabs:AddTab(name, pnl)

	local lbl = vgui.Create('onyx.Label', pnl)
	lbl:SetText('Пошук:')
	lbl:SetTextColor(plogs.ui.Close)
	lbl:SetPos(5, pnl:GetTall() - 28)

	local txt = vgui.Create('onyx.TextEntry', pnl)
	txt:SetPos(75, pnl:GetTall() - 30)
	txt:SetSize(pnl:GetWide() - 145, 25)

	local save = vgui.Create('onyx.Button', pnl)
	save:SetPos(pnl:GetWide() - 65, pnl:GetTall() - 30)
	save:SetSize(60, 25)
	save:SetText('Зберегти')
	save.DoClick = function()
		onyx.SimpleQuery('Зберегти журнал', 'Як би ви хотіли назвати це збереження?', true, function(text)
			if (#pnl.Data == 0) then
				LocalPlayer():ChatPrint('Немає результатів для збереження!')
			else
				plogs.SaveLog(text, pnl.Data)
				LocalPlayer():ChatPrint('Збережений журнал')
			end
			if IsValid(saveList) then saveList:AddSaves() end
		end, 'Так', nil, 'Ні')
	end

	local logList = vgui.Create('DListView', pnl)
	logList:SetPos(0, 0)
	logList:SetSkin('plogs')
	logList:SetSize(pnl:GetWide(), pnl:GetTall() - 35)
	logList:SetMultiSelect(false)
	logList:AddColumn('Час'):SetFixedWidth(75)
	logList:AddColumn('Дані')
	logList.OnRowSelected = function(parent, line)
		local column 	= logList:GetLine(line)
		local log 		= column:GetColumnText(2)
		local menu 		= vgui.Create('onyx.Menu')
		menu:SetPos( gui.MouseX(), gui.MouseY() )

		menu:AddOption('Копіювати рядок', function() 
			SetClipboardText(log)
			LocalPlayer():ChatPrint('Скопійований рядок')
		end)
		for name, value in SortedPairs(column.Copy or {}) do
			menu:AddOption('Копія ' .. name, function() 
				SetClipboardText(value or 'ERROR')
				LocalPlayer():ChatPrint('Скопійовано ' .. name)
			end)
		end
		menu:Open()
	end
	logList.LastSearch = ''
	pnl.Data = {}
	logList.Clear = function(self)
		for k, v in pairs(self:GetLines()) do
			self:RemoveLine(k)
		end
		pnl.Data = {}
	end
	logList.AddLogs = function(self)
		for _, log in SortedPairs(data) do
			local line 	= self:AddLine(log.Date, log.Data)
			line.Copy 	= log.Copy
			pnl.Data[#pnl.Data + 1] = log
		end
	end
	logList.Search = function(self, find)
		for _, log in SortedPairs(data) do
			if string.find(string.lower(log.Data), string.lower(find), 1, true) then
				local line 	= self:AddLine(log.Date, log.Data)
				line.Copy 	= log.Copy
				pnl.Data[#pnl.Data + 1] = log
			end
		end
	end
	logList.Think = function(self)
		local tosearch = string.Trim(txt:GetValue())
		if (tosearch ~= '') and (tosearch ~= self.LastSearch) then
			self:Clear()
			self:Search(tosearch)
			self.LastSearch = tosearch
		elseif (tosearch == '') and (tosearch ~= self.LastSearch) then
			self:Clear()
			self:AddLogs()
			self.LastSearch = tosearch
		end
	end
	logList:AddLogs()
	c = c + 1
end)

net.Receive('plogs.LogData', function()
	local title = net.ReadString()
	local size = net.ReadUInt(16)
	local data = plogs.Decode(net.ReadData(size))
	LogMenu(title, data)
end)


--PATH addons/____sam/lua/sam/menu/cl_init.lua:
if SAM_LOADED then return end

local vgui = vgui
local draw = draw

local sam = sam
local sui = sui
local TDLib = sui.TDLib

local config = sam.config

do
	local funcs = {
		["SAM.ComboBox"] = {
			event = "OnSelect",
			function(s, _, value)
				config.set(s.config_key, value)
			end
		},
		["SAM.TextEntry"] = {
			event = "OnEnter",
			function(s)
				local v = s:GetText()
				if s:GetNumeric() then
					v = tonumber(v)
				end
				config.set(s.config_key, v)
			end
		},
		["SAM.ToggleButton"] = {
			event = "OnChange",
			function(s, v)
				config.set(s.config_key, v)
			end
		}
	}

	sam.SUI = sam.SUI or sui.new("SAM", true, {
		SetConfig = function(s, key, default)
			s.config_key = key

			local i = config.hook({key}, function(value, old)
				local v = config.get(key, default)
				s:SetValue(v)
			end)

			local t = funcs[s:GetName()]
			s[t.event] = t[1]

			s:On("OnRemove", function()
				config.remove_hook(i)
			end)
		end
	})
end

local SUI = sam.SUI
local GetColor = SUI.GetColor

sam.menu = {}

local tabs = {}
function sam.menu.add_tab(icon, func, check, pos)
	local tab = {
		icon = icon,
		func = func,
		check = check,
		pos = pos
	}
	for k, v in ipairs(tabs) do
		if v.icon == icon then
			tabs[k] = tab
			return
		end
	end
	table.insert(tabs, tab)
end

function sam.menu.remove_tab(name)
	for k, v in ipairs(tabs) do
		if v.name == name then
			table.remove(tabs, k)
			break
		end
	end
end

SAM_TAB_TITLE_FONT = SUI.CreateFont("TabTitle", "Roboto Bold", 22)
SAM_TAB_DESC_FONT = SUI.CreateFont("TabDesc", "Roboto Medium", 15)

local MENU_LOADING = SUI.CreateFont("MenuLoading", "Roboto", 30)

SUI.AddToTheme("Dark", {
	frame = "#181818",

	scroll_panel = "#181818",

	menu_tabs_title = "#ffffff",

	--=--
	player_list_titles = "#f2f1ef",

	player_list_names = "#eeeeee",
	player_list_names_2 = "#ff6347",
	player_list_data = "#e8e8e8",

	player_list_rank = "#41b9ff",
	player_list_console = "#00c853",
	player_list_rank_text = "#2c3e50",

	player_list_steamid = "#a4a4a4",
	--=--

	--=--
	actions_button = Color(0, 0, 0, 0),
	actions_button_hover = Color(200, 200, 200, 60),

	actions_button_icon = "#aaaaaa",
	actions_button_icon_hover = "#ffffff",
	--=--

	--=--
	page_switch_bg = "#222222",
	--=--
})

SUI.SetTheme("Dark")

function SUI.panels.Frame:Paint(w, h)
	if GetColor("frame_blur") then
		TDLib.BlurPanel(self)
	end

	draw.RoundedBox(8, 0, 0, w, h, GetColor("frame"))
end

function SUI.panels.Frame:HeaderPaint(w, h)
	draw.RoundedBoxEx(8, 0, 0, w, h, GetColor("header"), true, true, false, false)
	draw.RoundedBox(0, 0, h - 1, w, 1, GetColor("line"))
end

do
	function sam.menu.add_loading_panel(parent)
		local is_loading = false

		local loading_panel = parent:Add("Panel")
		loading_panel:SetVisible(false)
		loading_panel:SetZPos(999999)
		loading_panel:SetMouseInputEnabled(false)

		function loading_panel:Paint(w, h)
			draw.RoundedBox(3, 0, 0, w, h, Color(50, 50, 50, 200))
			draw.SimpleText(string.rep(".", (CurTime() * 3) % 3), MENU_LOADING, w*0.5, h*0.5, Color(200, 200, 200, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
		end

		parent:SUI_TDLib()
		parent:On("PerformLayout", function(s, w, h)
			loading_panel:SetSize(w, h)
		end)

		local first = true
		local toggle_loading = function(bool)
			if not IsValid(loading_panel) then return end

			is_loading = bool or not is_loading
			if is_loading and not first then
				loading_panel:SetVisible(is_loading and true or false)
				loading_panel:SetMouseInputEnabled(is_loading)
			else
				timer.Simple(0.2, function()
					if not IsValid(loading_panel) then return end
					loading_panel:SetVisible(is_loading and true or false)
					loading_panel:SetMouseInputEnabled(is_loading)
				end)
			end

			first = false
		end

		return toggle_loading, function()
			return is_loading
		end
	end
end

local sam_menu
function sam.menu.open_menu()
	if IsValid(sam_menu) then
		return sam_menu:IsVisible() and sam_menu:Hide() or sam_menu:Show()
		-- sam_menu:Remove()
	end

	sam_menu = vgui.Create("SAM.Frame")
	sam_menu:Center()
	sam_menu:MakePopup()
	sam_menu:SetTitle("SAM")

	sam_menu:AddAnimations(800, 600)

	sam_menu.close.DoClick = function()
		sam_menu:Hide()
	end

	local sheet = sam_menu:Add("SAM.ColumnSheet")
	sheet:Dock(FILL)
	sheet:InvalidateParent(true)
	sheet:InvalidateLayout(true)
	sheet.Paint = nil

	local tab_scroller = sheet.tab_scroller
	tab_scroller:DockMargin(0, 1, 0, 1)

	function tab_scroller:Paint(w, h)
		draw.RoundedBoxEx(8, 0, 0, w, h, GetColor("column_sheet_bar"), false, false, true, false)
	end

	local sheets = {}
	for _, v in SortedPairsByMemberValue(tabs, "pos") do
		sheets[v.icon] = sheet:AddSheet(v.icon, v.func)
	end

	tab_scroller = tab_scroller:GetCanvas()
	sam_menu:On("Think", function()
		for _, v in ipairs(tabs) do
			local tab = sheets[v.icon]
			if v.check and not v.check() then
				if tab:IsVisible() then
					tab:SetVisible(false)
					if sheet:GetActiveTab() == tab then
						sheet:SetActiveTab(sheet.tabs[1])
					end
					tab_scroller:InvalidateLayout()
				end
			elseif not tab:IsVisible() then
				tab:SetVisible(true)
				tab_scroller:InvalidateLayout()
			end
		end
	end)
end

function sam.menu.get()
	return sam_menu
end

hook.Add("GUIMouseReleased", "SAM.CloseMenu", function(mouse_code)
	local panel = vgui.GetHoveredPanel()
	if mouse_code == MOUSE_LEFT and panel == vgui.GetWorldPanel() and IsValid(sam_menu) and sam_menu:HasHierarchicalFocus() then
		sam_menu:Hide()
	end
end)

for _, f in ipairs(file.Find("sam/menu/tabs/*.lua", "LUA")) do
	sam.load_file("sam/menu/tabs/" .. f, "sh")
end
--PATH addons/____sui/lua/sui/vgui/sui_combobox.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local TEXT_FONT = SUI.CreateFont("ComboBox", "Roboto Regular", 16)

local GetColor = SUI.GetColor
local draw_material = sui.draw_material

local PANEL = {}

PANEL.NoOverrideClear = true

sui.scaling_functions(PANEL)

function PANEL:Init()
	self:ScaleInit()
	self.DropButton:Remove()
	self:SetFont(TEXT_FONT)
	self:SetSize(34, 22)
	self:SetIsMenu(true)

	local image = self:Add(NAME .. ".Image")
	image:Dock(FILL)
	image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")
	image.Draw = self.Paint
end

function PANEL:OpenMenu(pControlOpener)
	if pControlOpener and pControlOpener == self.TextEntry then return end
	if #self.Choices == 0 then return end

	if IsValid(self.Menu) then
		self.Menu:Remove()
		self.Menu = nil
	end

	self.Menu = vgui.Create(NAME .. ".Menu", self)
	self.Menu:SetInternal(self)

	for k, v in ipairs(self.Choices) do
		self.Menu:AddOption(v, function()
			self:ChooseOption(v, k)
		end)
	end

	local x, y = self:LocalToScreen(0, self:GetTall())
	self.Menu:SetMinimumWidth(self:GetWide())
	self.Menu:Open(x, y, false, self)
end

function PANEL:Paint(w, h, from_image)
	local text_color = GetColor("menu_option_hover_text")

	if from_image then
		local size = SUI.ScaleEven(10)
		draw_material(nil, w - (size * 0.5) - 6, h * 0.5, size, text_color)
	else
		local col = GetColor("menu")
		self:RoundedBox("Background", 4, 0, 0, w, h, col)
		self:SetTextColor(text_color)
	end
end

function PANEL:PerformLayout()
end

sui.register("ComboBox", PANEL, "DComboBox")
--PATH addons/____sui/lua/sui/vgui/sui_label_panel.lua:
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local LABEL_FONT = SUI.CreateFont("LabelPanel", "Roboto", 18)

local PANEL = {}

local add = function(s, c)
	if IsValid(s.pnl) then
		s.pnl:Remove()
	end

	local pnl = vgui.Create(c, s)
	s.pnl = pnl

	return pnl
end

function PANEL:Init()
	self.title = ""

	local label = self:Add(NAME .. ".Label")
	label:Dock(LEFT)
	self.label = label

	self:SetFont(LABEL_FONT)

	self:Dock(TOP)
	self:InvalidateLayout(true)
	self.Add = add
end

function PANEL:SetPanel(pnl)
	if IsValid(self.pnl) then
		self.pnl:Remove()
	end

	pnl:SetParent(self)
	self.pnl = pnl
end

function PANEL:SetLabel(lbl)
	self.title = lbl
	self:InvalidateLayout(true)
end

function PANEL:SetFont(font)
	self.font = font
	self.label:SetFont(font)
end

function PANEL:PerformLayout(w, h)
	local label = self.label
	local pnl = self.pnl

	local pnl_w, pnl_h = 0, 0
	if pnl then
		pnl_w, pnl_h = pnl:GetSize()
	end

	label:SetWide(w - pnl_w - 4)
	label:SetText(sui.wrap_text(self.title, self.font, w - pnl_w - 4))

	local _, _h = label:GetTextSize()
	self:SetTall(math.max(_h, pnl_h))

	if pnl then
		pnl:SetPos(w - pnl_w, h * 0.5 - pnl_h * 0.5)
	end
end

sui.register("LabelPanel", PANEL, "PANEL")
--PATH addons/____sui/lua/sui/vgui/sui_toggle_button.lua:
local Lerp = Lerp
local FrameTime = FrameTime

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name
local TDLib = sui.TDLib

local Panel = {}

sui.scaling_functions(Panel)

function Panel:Init()
	self:ScaleInit()

	local rounded_box = {}
	local switch_circle = {}
	function self:Paint(w, h)
		local is_checked = self:GetChecked()

		local _h = SUI.Scale(14)
		TDLib.RoundedBox(rounded_box, _h, 0, h * 0.5 - _h * 0.5, w, _h, is_checked and SUI.GetColor("toggle_button_active") or SUI.GetColor("toggle_button"))

		local size = h - 2
		do
			local pos = is_checked and (w - (size * 0.5)) or (h * 0.5 - 1)
			if self.pos then
				self.pos = Lerp(FrameTime() * 12, self.pos, pos)
			else
				self.pos = pos
			end
		end

		TDLib.DrawCircle(switch_circle, self.pos, h * 0.5, size * 0.5, is_checked and SUI.GetColor("toggle_button_switch_active") or SUI.GetColor("toggle_button_switch"))
	end

	self:SetSize(34, 20)
end

sui.register("ToggleButton", Panel, "DCheckBox")
--PATH addons/____sui/lua/sui/vgui/sui_zcollapse_category.lua:
local sui = sui

local draw_material = sui.draw_material

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local TABS_FONT = SUI.CreateFont("CategoryListTabs", "Roboto Bold", 13)
local ITEMS_FONT = SUI.CreateFont("CategoryListItems", "Roboto Medium", 14)

local Panel = {}

local item_OnRemove = function(s)
	local parent = s.parent

	local items = parent.items
	for k, v in ipairs(items) do
		if v == s then
			table.remove(items, k)
			break
		end
	end

	if #items == 0 then
		local category = s.category
		category:Remove()
		parent.categories[category.name] = nil
	end
end

local item_DoClick = function(s)
	local parent = s.parent
	parent:select_item(s)
end

function Panel:Init()
	local categories = {}
	local items = {}

	self.categories = categories
	self.items = items

	self:SetVBarPadding(1)

	local get_category = function(name)
		local category = categories[name]
		if category then return category end

		local expanded = false

		category = self:Add("Panel")
		category:Dock(TOP)
		category:DockMargin(0, 0, 0, 3)
		category.name = name

		local header = category:Add("DButton")
		header:Dock(TOP)
		header:DockMargin(0, 0, 0, 3)
		header:SetFont(TABS_FONT)
		header:SetContentAlignment(4)
		header:SetTextInset(6, 0)
		header:SetText(name)
		header:SizeToContentsY(SUI.Scale(14))

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_header_text"):Unpack())
		function header:Paint(w, h)
			if expanded then
				cur_col = GetColor("collapse_category_header_active")
				cur_col_text = GetColor("collapse_category_header_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_header_hover")
				cur_col_text = GetColor("collapse_category_header_text_hover")
			else
				cur_col = GetColor("collapse_category_header")
				cur_col_text = GetColor("collapse_category_header_text")
			end

			RoundedBox(self, "Background", 3, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		local image = header:Add(NAME .. ".Image")
		image:Dock(FILL)
		image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")

		function image:Draw(w, h)
			local size = SUI.ScaleEven(10)
			draw_material(nil, w - (size * 0.5) - 6, h * 0.5, size, cur_col_text, expanded and 180)
		end

		local current_h
		function category.RefreshHeight()
			local h
			if expanded then
				local _
				_, h = category:ChildrenSize()
				if self.searching and h == header:GetTall() then
					h = 0
				end
			else
				h = header:GetTall()
			end

			if current_h == h then return end

			if h > 0 then
				category:SetVisible(true)
			end

			current_h = h

			category:Stop()
			category:SizeTo(-1, h, 0.2, 0, -1, function()
				if h == 0 then
					category:SetVisible(false)
				end
			end)
		end

		function category.SetExpanded(_, set_expanded)
			if expanded == set_expanded then return end

			if sam.isbool(set_expanded) then
				expanded = set_expanded
			else
				expanded = not expanded
			end

			category.RefreshHeight()

			if expanded then
				self:OnCategoryExpanded(category)
			end

			self:InvalidateLayout(true)
		end
		header.DoClick = category.SetExpanded

		category:SetTall(header:GetTall())
		categories[name] = category

		return category
	end

	function self:add_item(name, category_name)
		local category = get_category(category_name)

		local item = category:Add("DButton")
		item:Dock(TOP)
		item:DockMargin(0, 0, 0, 3)
		item:SetFont(ITEMS_FONT)
		item:SetText(name)
		item:SizeToContentsY(SUI.Scale(3 * 2))
		item.name = name
		item.parent = self
		item.category = category

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_item_text"):Unpack())
		function item:Paint(w, h)
			if self.selected then
				cur_col = GetColor("collapse_category_item_active")
				cur_col_text = GetColor("collapse_category_item_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_item_hover")
				cur_col_text = GetColor("collapse_category_item_text_hover")
			else
				cur_col = GetColor("collapse_category_item")
				cur_col_text = GetColor("collapse_category_item_text")
			end

			RoundedBox(self, "Background", 4, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		item.DoClick = item_DoClick
		item.OnRemove = item_OnRemove

		table.insert(items, item)

		return item
	end
end

function Panel:OnCategoryExpanded(category)
end

function Panel:select_item(item)
	if self.selected_item ~= item then
		if IsValid(self.selected_item) then
			self.selected_item.selected = false
		end
		item.selected = true
		self.selected_item = item
		self:item_selected(item)
	end
end

function Panel:item_selected()
end

function Panel:Search(text, names)
	local items = self.items
	self.searching = true
	for i = 1, #items do
		local item = items[i]
		local category = item.category
		category:SetExpanded(true)

		if not names then
			if item.name:find(text, nil, true) then
				item:SetVisible(true)
			else
				item:SetVisible(false)
			end
		else
			local found = false
			for _, name in ipairs(item.names) do
				if name:find(text, nil, true) then
					found = true
					item:SetVisible(true)
				end
			end
			if not found then
				item:SetVisible(false)
			end
		end

		if text == "" then
			category:SetExpanded(false)
		end

		category:RefreshHeight()
		category:InvalidateLayout(true)
	end
	self.searching = false
end

sui.register("CollapseCategory", Panel, NAME .. ".ScrollPanel")
--PATH addons/____sam/lua/sam/modules/gban.lua:
GBan = GBan or {} --Версия 30.03.2024 <-не убирайте!
GBan.Config = GBan.Config or {}
GBan.Config.AllBan = false
local GbanTeam = true
local PLAYER = FindMetaTable('Player')
local IsValid = IsValid
local hook_Run = hook.Run
function PLAYER:IsGBan()
    return self:GetNWBool('GBan')
end
PLAYER.IsBanned = PLAYER.IsGBan

sam.permissions.add( 'immunity_gban' )
local print = print
local math_floor = math.floor
local string_gmatch = string.gmatch
local string_format = string.format
local GetHostName = GetHostName
local os_time = os.time
local sql_SQLStr = sql.SQLStr
local sql_Query = sql.Query
local util_SteamIDFrom64 = util.SteamIDFrom64
local isstring = isstring
local tonumber = tonumber
local timer_TimeLeft = timer.TimeLeft
local timer_Create = timer.Create
local timer_Exists = timer.Exists
local timer_Remove = timer.Remove
local player_GetAll = player.GetAll
local ps = PLAYER.SteamID
local ps64 = PLAYER.SteamID64
local string_upper = string.upper
local timer_Simple = timer.Simple
local times = {
    mi = 1,
    h = 60,
    d = 1440,
    w = 10080,
    mo = 43200,
}

local function getpl(txt)
    local pla = player_GetAll()
    local txt = string_upper(txt)
    for i = 1, #pla do
        local pl = pla[i]
        if ps(pl) == txt then return pl end
        if ps64(pl) == txt then return pl end
    end
end

local function firtloadtable(Max)
    local time = ''
    local mo = math_floor(Max / times['mo'])
    if mo ~= 0 then
        time = time .. mo .. 'mo '
        Max = Max - times['mo'] * mo
    end

    local w = math_floor(Max / times['w'])
    if w ~= 0 then
        time = time .. w .. 'w '
        Max = Max - times['w'] * w
    end

    local d = math_floor(Max / times['d'])
    if d ~= 0 then
        time = time .. d .. 'd '
        Max = Max - times['d'] * d
    end

    local h = math_floor(Max / times['h'])
    if h ~= 0 then
        time = time .. h .. 'h '
        Max = Max - times['h'] * h
    end

    local mi = math_floor(Max / times['mi'])
    if mi ~= 0 then time = time .. mi .. 'mi ' end
    return time
end

if SERVER then
    GBan.BanList = GBan.BanList or {}
    local function PrintChat(tabs, type, pl, global)
        if not global then
            pl:sam_send_message(type, tabs)
            return --   sam.player.send_message(nil, type, tabs) --выбранный игрок
        else
            sam.player.send_message(nil, type, tabs)
        end
    end

    GBan.PrintChat = PrintChat
    local function TimeRew(n)
        local s = 0
        local h = false
        if n == '0' then return 0 end
        for k, t in string_gmatch(n, '(%d+)(%a+)') do
            if times[t] then
                s = s + k * times[t:lower()]
                h = true
            else
                continue
            end
        end
        if not h then return false end
        return s
    end

    local function TimeCheck(Group, Time)
        if sam.ranks.get_ban_limit(Group) == 0 or sam.ranks.get_ban_limit(Group) + 1 >= Time + 1 then return true end
        return false
    end

    local msg = [[
Ти забанен!
-------------------------------------
Бан надано: %s
Дата розбана: %s
Адміністратор: %s
Причина: %s
-------------------------------------
]]
    local os_date = os.date
    util.AddNetworkString('gban_send_ply')
    sql_Query('CREATE TABLE IF NOT EXISTS gban( SteamID TEXT PRIMARY KEY, Time NUMBER, Date NUMBER, Reason TEXT, Judge TEXT,IDEALAdmin TEXT )')
    local function PermaBan(pl, adm, Reason)
        local can = hook_Run('PreGBanSam', pl, adm, {0, Reason}, true)
        if can == true then return end
        local isAd = IsValid(adm)
        local nick_admin = isAd and adm:Name() or 'CONSOLE'
        local Ideal = adm and string_format('%s(%s)', nick_admin, adm:SteamID()) or 'CONSOLE'
        local ostime = os_time()
        local isPl = IsValid(pl)
        if isPl then
            PrintChat({
                A = adm,
                T = {pl},
                S = Reason
            }, '{A} видав вічну заборону {T}  з розуму {S}', nil, true)
        else
            PrintChat({
                A = adm,
                S = pl,
                S2 = Reason
            }, '{A} видав вічну заборону {S Red}  з розуму {S2}', nil, true)
        end

        pl:Kick(string_format(msg, GetHostName(), os_date("%X - %x  %Z (Сервер)", ostime), Ideal, Reason))
        local values = string_format('(%s, %i, %i, %s, %s,%s)', sql_SQLStr(isPl and pl:SteamID() or pl), 0, ostime, sql_SQLStr(Reason), sql_SQLStr(nick_admin), sql_SQLStr(Ideal))
        sql_Query('INSERT INTO gban( SteamID, Time, Date, Reason, Judge, IDEALAdmin) VALUES ' .. values)
        hook_Run('PostGBanSam', false, pl, adm, {0, Reason}, true)
    end

    hook.Add("CheckPassword", "PermaCheck", function(steamID64)
        local steam = util_SteamIDFrom64(steamID64)
        local data = sql_Query('SELECT * FROM gban WHERE SteamID=' .. sql_SQLStr(steam))
        if not data then return end
        data = data[1]
        if data.Time ~= '0' then return end
        local admin = data.IDEALAdmin
        local date = os_date("%X - %x  %Z (Сервер)", data.Date)
        local reason = data.Reason
        return false, string_format(msg, GetHostName(), date, admin, reason)
    end)

    local function findrank(steam)
        local data = sql_Query('SELECT * FROM sam_players WHERE steamid=' .. steam)
        return data and data[1].rank or 'user'
    end

    local function findUnrank(steam)
        local data = sql_Query('SELECT * FROM gban WHERE SteamID=' .. sql_SQLStr(steam))
        if not data then return false end
        data = data[1]
        if data.IDEALAdmin == 'CONSOLE' then return 'CONSOLE' end
        return findrank(data.IDEALAdmin), data.Time == 0
    end
    hook.Add('PreGBanSam', 'Check_rank', function(pl, admin)
        if not IsValid(admin) then return false end
        if GBan.Config.AllBan then return false end
        local admrank = admin:sam_getrank()
        local plrank = IsValid(pl) and pl:sam_getrank() or findrank(pl)
        local rank = sam.ranks.get_immunity(plrank) > sam.ranks.get_immunity(admrank)
        if rank then
            PrintChat({
                S = plrank
            }, "Вам потрібен ранг {S Red} або вище.", admin, false)
            return true
        end
    end)
--print(findUnrank('STEAM_0:0:217046444'))
    hook.Add('PreUnGBanSam', 'Check_ban', function(pl, admin)
        if not IsValid(admin) then return false end
        if GBan.Config.AllBan then return false end
        local admrank = admin:sam_getrank()
        local plrank, perma = IsValid(pl) and pl:sam_getrank() or findUnrank(pl)
        if not plrank then
            PrintChat({
                S = pl
            }, "Гравець {S Red} не був знайдений.", admin, false)
            return
        end

        local rank = plrank == 'CONSOLE' and 'CONSOLE' or (sam.ranks.get_immunity(plrank) > sam.ranks.get_immunity(admrank))
        if rank then
            PrintChat({
                S = plrank
            }, "Вам потрібен ранг {S Red} або вище.", admin, false)
            return true
        end

        if perma and sam.ranks.get_ban_limit(admin:sam_getrank()) ~= 0 then PrintChat({}, 'Игрок забанен перманентно у вас нет доступа к пермабану!', admin, true) end
    end)

    function GBan.GiveBanPlayer(pl, admin, reason, seconds)
        if not IsValid(pl) or not pl:IsPlayer() then
            print('[GBan] GiveBanPlayer ERROR #01')
            return
        end

        local is_gban = pl:IsGBan()
        local IsAd = IsValid(admin)
        if is_gban then
            if IsAd then
                PrintChat({}, 'Гравець вже заборонений.', admin, false)
            else
                print('Гравець вже заборонений.')
            end
            return
        end

        local oldseconds = seconds
        seconds = TimeRew(seconds)
        if not seconds then --print(oldseconds)
            if IsAd then -- отправить админу
                PrintChat({}, "Неправильний час!", admin, false)
            else
                print('Неправильний час!')
            end
            return --admin:ChatPrint('Неправильний час!')
        end

        if not reason or not isstring(reason) then
            print('[GBan] GiveBanPlayer WARNING #01')
            reason = 'Причина не вказана'
        end

        if IsAd then
            if not TimeCheck(admin:sam_getrank(), seconds) then
                PrintChat({
                    S = oldseconds
                }, "Ви вказали: {S Red}", admin, false)

                PrintChat({
                    S = firtloadtable(sam.ranks.get_ban_limit(admin:sam_getrank())) --  admin:ChatPrint('Вы указали: ' .. firtloadtable(seconds))
                }, "Ваш максимальний час: {S Red}", admin, false)
                return --   admin:ChatPrint('Ваш максимальний час: ' .. firtloadtable(sam.ranks.get_ban_limit(admin:sam_getrank())))
            end
        end

        if seconds == 0 then
            if IsAd then
                if sam.ranks.get_ban_limit(admin:sam_getrank()) == 0 then
                    PermaBan(pl, admin, reason)
                    return
                end
            else
                PermaBan(pl, "Server(CONSOLE)", reason)
                return
            end

            print('[GBan] GiveBanPlayer WARNING #04')
            PrintChat({}, 'У вас немає доступу до перми!', admin, false)
            return
        end

        local can = hook_Run('PreGBanSam', pl, admin, {seconds, reason}, false)
        if can == true then return end
        hook_Run( 'GBanSam', pl, admin )
        local min = seconds * 60
        if GbanTeam then pl:ChangeTeam(TEAM_BANNED) end
        pl:SetNWBool('GBan', true)
        if pl:InVehicle() then pl:ExitVehicle() end
        pl:Spawn()
        pl:StripWeapons()
        pl:StripAmmo()
        local nick_admin = IsAd and '"' .. admin:Nick() .. '"' or 'CONSOLE'
        PrintChat({
            A = admin,
            T = {pl},
            V = reason,
            V2 = oldseconds
        }, '{A} выдал бан {T} на {V2}. По причине {V}', admin, true)

        local pl_steam = pl:SteamID()
        GBan.BanList[pl_steam] = true
        local ad_steam = admin:SteamID()
        timer_Create('GBanPlayer' .. pl_steam, min, 1, function() GBan.RemoveBanPlayer(pl, nil, true) end)
        local txt
        if IsAd then
            txt = string_format("%s(%s)", admin:Name(), ad_steam)
        else
            txt = "CONSOLE(Server)"
        end

        net.Start('gban_send_ply')
        net.WriteBool(true)
        net.WriteUInt(min, 31)
        net.WriteString(txt)
        net.WriteString(reason)
        net.Send(pl)
        local Ideal = admin and string_format('%s(%s)', admin:Name(), ad_steam) or 'CONSOLE'
        local values = string_format('(%s, %i, %i, %s, %s,%s)', sql_SQLStr(pl_steam), min, os_time(), sql_SQLStr(reason), sql_SQLStr(nick_admin), sql_SQLStr(Ideal))
        sql_Query('INSERT INTO gban( SteamID, Time, Date, Reason, Judge, IDEALAdmin) VALUES ' .. values) --print(values)
        print('[GBan] Player ' .. pl_steam .. ' has banned on ' .. oldseconds)
        hook_Run('PostGBanSam', false, pl, admin, {seconds, reason}, false)
    end

    function GBan.GiveBanPlayerOffline(steamID, admin,reason, seconds)
        if not steamID then
            print('[GBan] GiveBanPlayerOffline ERROR #03')
            return
        end

        local pl = getpl(steamID)
        if pl and IsValid(pl) then
            GBan.GiveBanPlayer(pl, admin, reason, seconds)
            return
        end

        local IsAd = IsValid(admin)
        local oldseconds = seconds
        seconds = TimeRew(seconds)
        --print(seconds)
        if not seconds then
            if IsAd then -- отправить админу
                PrintChat({}, "Неправильний час!", admin, false)
            else
                print('Неправильний час!')
            end
            return
        end

        if IsAd then
            if not TimeCheck(admin:sam_getrank(), seconds) then
                PrintChat({
                    S = oldseconds
                }, "Ви вказали: {S Red}", admin, false)

                PrintChat({
                    S = firtloadtable(sam.ranks.get_ban_limit(admin:sam_getrank()))
                }, "Ваш максимальний час: {S Red}", admin, false)
                return
            end
        end

        if seconds == 0 then
            if IsAd then
                if sam.ranks.get_ban_limit(admin:sam_getrank()) == 0 then
                    PermaBan(steamID, admin, reason)
                    return
                end
            else
                PermaBan(steamID, "Server(CONSOLE)", reason)
                return
            end

            print('[GBan] GiveBanPlayer WARNING #04')
            PrintChat({}, 'У вас немає доступу до перми!', admin, false)
            return
        end

        local can = hook_Run('PreGBanSam', steamID, admin, {seconds, reason}, false)
        if can == true then return end
        local judge = IsAd and admin:Nick() or 'CONSOLE'
        local Ideal = IsAd and string_format('%s(%s)', admin:Name(), admin:SteamID()) or 'CONSOLE'
        local values = string_format('(%s, %i, %i, %s, %s, %s)', sql_SQLStr(steamID), seconds * 60, os_time(), sql_SQLStr(reason), sql_SQLStr(judge), sql_SQLStr(Ideal))
        sql_Query('INSERT INTO gban( SteamID, Time, Date, Reason, Judge,IDEALAdmin ) VALUES ' .. values)
        PrintChat({
            A = admin,
            S = steamID,
            V = reason,
            V2 = oldseconds
        }, '{A} виданий банок {S Red} на {V2}. По причине {V}', nil, true)

        print('[GBan] Player ' .. steamID .. ' has banned on ' .. oldseconds .. ' sec!')
        hook_Run('PostGBanSam', true, steamID, admin, {seconds, reason}, false)
    end

    function GBan.RemoveBanPlayer(pl, admin, tim)
        local is_gban = pl:IsGBan()
        if not is_gban then
            print('[GBan] RemoveBanPlayer ERROR #04')
            return
        end

        local can = hook.Run('PreUnGBanSam', pl, admin)
        if can == true then return end
        pl:SetNWBool('GBan', false)
        if GbanTeam then pl:ChangeTeam(TEAM_CITIZEN) end
        pl:Kill()
        pl:Spawn()
        net.Start('gban_send_ply')
        net.WriteBool(false)
        net.Send(pl)
        local pl_steam = pl:SteamID()
        GBan.BanList[pl_steam] = nil
        if timer_Exists('GBanPlayer' .. pl_steam) then timer_Remove('GBanPlayer' .. pl_steam) end
        sql_Query('DELETE FROM gban WHERE SteamID = ' .. sql_SQLStr(pl_steam))
        if not tim then
            PrintChat({
                A = admin,
                T = {pl}
            }, '{A} снял бан {T}', nil, true)
        else
            PrintChat({
                T = {pl}
            }, 'Срок бана {T} закінчився!', pl, true)
        end

        hook_Run('PostUnGBanSam', false, pl, admin)
        print('[GBan] Player ' .. pl_steam .. ' has removed gban!')
    end

    function GBan.RemoveBanPlayerOffline(steamID, admin)
        if not steamID then
            print('[GBan] ERROR #03')
            return
        end

        local pl = getpl(steamID) --player.GetBySteamID(steamID)
        if pl and IsValid(pl) then
            GBan.RemoveBanPlayer(pl, admin)
            return
        end

        local can = hook_Run('PreUnGBanSam', steamID, admin)
        if can == true then return end
        sql_Query('DELETE FROM gban WHERE SteamID = ' .. sql_SQLStr(steamID))
        PrintChat({
            A = admin,
            V = steamID
        }, '{A} снял бан {V Red}', nil, true)

        print('[GBan] Player ' .. steamID .. ' has removed gban!')
        hook_Run('PostUnGBanSam', true, steamID, admin)
    end

    hook.Add('PlayerInitialSpawn', 'GBan.JailerTheFirstSpawn', function(pl)
        timer_Simple(1, function()
            if not IsValid(pl) then return end
            local pl_steam = pl:SteamID()
            local steamid = sql_SQLStr(pl_steam)
            local data = sql_Query('SELECT * FROM gban WHERE SteamID=' .. steamid)
            if not data then return end
            data = data[1]
            local time = data.Time
            if not time then -- bug?
                return
            end

            local Admin = data.IDEALAdmin
            local sReason = data.Reason
            local date = data.Date
            time = tonumber(time) -- only seconds!
            local finish_time = time + tonumber(date)
            local current_time = os_time()
            if finish_time <= current_time then
                sql_Query('DELETE FROM gban WHERE SteamID = ' .. steamid)
                PrintChat({}, 'Срок вашого бана закінчився!', pl, false)
                return
            end

            time = finish_time - current_time
            if GbanTeam then pl:ChangeTeam(TEAM_BANNED) end
            pl:SetNWBool('GBan', true)
            GBan.BanList[pl_steam] = true
            pl:Spawn()
            net.Start('gban_send_ply')
            net.WriteBool(true)
            net.WriteUInt(time, 31)
            net.WriteString(Admin)
            net.WriteString(sReason)
            net.Send(pl)
            timer_Create('GBanPlayer' .. pl_steam, time, 1, function() GBan.RemoveBanPlayer(pl, nil, true) end)
        end)
    end)

    gameevent.Listen("player_disconnect")
    hook.Add("player_disconnect", "GBan.UpdateTimeForJaile", function(data)
        local pl_steam = data.networkid
        if not GBan.BanList[pl_steam] then return end
        timer_Remove('GBanPlayer' .. pl_steam)
    end)

    hook.Add('CanPlayerSuicide', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerLoadout', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerSpawnObject', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerSpawnSENT', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerSpawnNPC', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerSpawnSWEP', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerSpawnVehicle', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerGiveSWEP', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerCanPickupWeapon', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerCanPickupItem', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('CanPlayerEnterVehicle', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerNoClip', 'GBan.RestrictHook', function(pl) if pl:IsGBan() then return false end end)
    hook.Add('PlayerSay', 'GBan.RestrictHook', function(pl)
        if not IsValid(pl) then return end
        if pl:IsGBan() then return "" end
    end)

    hook.Add('canChatCommand', 'GBan.RestrictHook', function(pl)
        if not IsValid(pl) then return end
        if pl:IsGBan() then return false end
    end)

    hook.Add("SAM.CanRunCommand", 'GBan.RestrictHook', function(pl)
        if not IsValid(pl) then return end
        if not pl:HasPermission( 'immunity_gban' ) and pl:IsGBan() then
            return false
        end
    end)

    hook.Add('GBanSam', 'FixOnBan', function( ply )
        if IsValid(ply) then
            ply:onyx_SetNetVar("adminmode", false)
            --
            if ( ply:onyx_GetNetVar( 'doorCount' ) or 0 ) > 0 then
                local count = ply:onyx_GetNetVar( 'doorCount' ) or 0
                local amt = count * rp.Setting.DoorCostMin
                ply:DoorUnOwnAll()
                ply:AddMoney( amt )
                ply:DoorUnOwnAll()
            end
            --
            ply:UnArrest()
            --
            for _, ent in ents.Iterator() do
                if IsValid(ent) and (ent:CPPIGetOwner() == ply) then
                    ent:Remove()
                end
            end
        end
    end)
end

if CLIENT then
    local function FormatTime(time)
        local d = math_floor(time / 86400)
        local h = math_floor(time / 3600)
        local m = math_floor(time / 60)
        local s = time
        if d >= 1 then
            return string_format('%sд:%sч:%sм:%sс', d, math_floor(h - (d * 24)), math_floor(m - h * 60), math_floor(s - m * 60))
        elseif h >= 1 then
            return string_format('%sч:%sм:%sс', h, math_floor(m - h * 60), math_floor(s - m * 60))
        else
            return string_format('%sм:%sс', m, math_floor(s - m * 60))
        end
    end

    local w = ScrW()
    local h = ScrH()
    surface.CreateFont('TheShitFont', {
        font = "Trebuchet24",
        size = (h + w) * .011,
        weight = 300,
        blursize = 0,
        scanlines = 0,
        antialias = false,
        underline = false,
        italic = false,
        strikeout = false,
        symbol = false,
        rotary = false,
        shadow = true,
        additive = false,
        outline = false,
    })

    local COLOR_WHITE = Color(255, 255, 255)
    local COLOR_BLACK = Color(0, 0, 0)
    local draw_SimpleTextOutlined = draw.SimpleTextOutlined
    local TEXT_ALIGN_CENTER = TEXT_ALIGN_CENTER
    local TEXT_ALIGN_TOP = TEXT_ALIGN_TOP
    net.Receive('gban_send_ply', function()
        local to_ban = net.ReadBool()
        local time
        local admin
        local Reason
        if not to_ban then
            hook.Remove('HUDPaint', 'GBan.DrawInfoPanel')
            hook_Run('GBan.BanLocalPlayer', to_ban)
            return
        else
            time = net.ReadUInt(31)
            admin = net.ReadString()
            Reason = net.ReadString()
        end

        timer_Create('GBanTime', time, 1, function() end)
        hook_Run('GBan.BanLocalPlayer', to_ban, admin, time, Reason)
        hook.Add('HUDPaint', 'GBan.DrawInfoPanel', function()
            if not LocalPlayer():IsGBan() then return end
            local time = timer_Exists('GBanTime') and math_floor(timer_TimeLeft('GBanTime')) or 0
            draw_SimpleTextOutlined('До зняття бана залишилося: ' .. FormatTime(time), 'TheShitFont', w * 0.5, 0, COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, COLOR_BLACK)
            draw_SimpleTextOutlined('Вас забанив: ' .. admin, 'TheShitFont', w * 0.5, 30, COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, COLOR_BLACK)
            draw_SimpleTextOutlined('Причина: ' .. Reason, 'TheShitFont', w * 0.5, 60, COLOR_WHITE, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, COLOR_BLACK)
        end)
    end)
end

if SAM_LOADED then return end
local sam, cmd, lang = sam, sam.command, sam.language
local cat = 'gBan'
cmd.set_category(cat)
cmd.new('ban'):Help('Заблокував гравця'):SetPermission('gban', 'superadmin'):AddArg('steamid'):AddArg('text', {
    hint = '10mi, 1h10mi (м=mi ч=h д=d н=w м=mo)',
    round = true,
    optional = true,
    default = 250
}):AddArg('text', {
    hint = 'Причина'
}):OnExecute(function(admin, steamtbl, seconds, reason)
    local steam = steamtbl.steamid

    local func = sam.is_steamid(steam)
    if not func then
        GBan.PrintChat({}, 'Нужен обычный SteamID', admin, false)
        return
    end

    local pl = getpl(steam)
    if IsValid(pl) then GBan.GiveBanPlayer(pl, admin, reason, seconds) end
    GBan.GiveBanPlayerOffline(steam, admin, reason, seconds)
end):End()

cmd.new('unban'):Help('Прибирає у гравця gban'):SetPermission('ungban', 'admin'):AddArg('steamid'):OnExecute(function(admin, steamtbl)
    local steam = steamtbl.steamid

    local func = sam.is_steamid(steam)
    if not func then
        GBan.PrintChat({}, 'Нужен обычный SteamID', admin, false)
        return
    end

    local pl = getpl(steam)
    if IsValid(pl) then GBan.RemoveBanPlayer(pl, admin) end
    GBan.RemoveBanPlayerOffline(steam, admin)
end):End()

function PLAYER:sam_getrank()
    return self:sam_get_nwvar("rank", "user")
end
--PATH addons/_contracts/lua/autorun/sh_contract.lua:
contract = {}
contract.igsitems = {
    ['m9k_glock'] = true,
    ['m9k_usas'] = true,
    ['m9k_jackhammer'] = true,
    ['weapon_ninjaskunai'] = true,
    ['m9k_dbarrel'] = true,
    ['m9k_dragunov'] = true,
    ['m9k_barret_m82'] = true,
    ['weapon_slam'] = true,
    ['3dgear'] = true,
    ['m9k_minigun'] = true,
    ['m9k_luger'] = true,
    ['apteka'] = true,
    ['lockpick'] = true,
    ['knife'] = true,
}

if CLIENT then
    contract.color = {
        black = Color(15, 17, 18),
        gray = Color(47, 47, 47),
        white = Color(217, 217, 217),
        orange = Color(226, 180, 69),
        orange2 = Color(255, 204, 0),
        salat = Color(75, 182, 117),
        salat2 = Color(41, 212, 108),
        red = Color(254, 79, 79),
        blue = Color(84, 137, 255),
        pink = Color(254, 94, 233)
    }

    contract.material = {
        inv = Material('contract/inventory_main.png', 'noclamp smooth'),
        model = Material('contract/modelicon.png', 'noclamp smooth'),
        gigamodel = Material('contract/gigamodelicon.png', 'noclamp smooth'),
        shans = Material('contract/shans_main.png', 'noclamp smooth'),
        box = Material('contract/box.png', 'noclamp smooth'),
        background = Material('contract/background.png', 'noclamp smooth'),
        logo = Material('contract/logo.png', 'noclamp smooth'),
        baraban = Material('contract/baraban.png', 'noclamp smooth'),
        boxset = Material('contract/iconset.png', 'noclamp smooth'),
        sett = Material('contract/setting.png', 'noclamp smooth'),
        boxn1 = Material('contract/boxnumb1.png', 'noclamp smooth'),
        boxn2 = Material('contract/boxnumb2.png', 'noclamp smooth'),
        boxn3 = Material('contract/boxnumb3.png', 'noclamp smooth'),
        boxn4 = Material('contract/boxnumb4.png', 'noclamp smooth'),
        debutton = Material('contract/debutton.png', 'noclamp smooth'),
        contract = Material('contract/contract.png', 'noclamp smooth'),
        backgroundsignature = Material('contract/backgroundsignature.png', 'noclamp smooth'),
        pen = Material('contract/pen.png', 'noclamp smooth'),
        claim = Material('contract/gradientclaim.png', 'noclamp smooth')
    }
end

local function ReverseArray(array)
    for i = 1, #array - 1 do
        local temp = array[i].chance
        array[i].chance = array[i].chance
        array[i].chance = temp
    end
end

function contract.MatemEbat(slots, ply, allsumcl)
    local tbl2 = {}

    for r, u in pairs(IGS.GetItems()) do
        local ITEM = IGS.GetItemByUID(u.uid)
        if not contract.igsitems[u.uid] then continue end

        table.insert(tbl2, {
            name = ITEM.uid,
            price = ITEM.price,
            chance = 0
        })
    end

    local totalsum = 0

    if CLIENT then
        totalsum = allsumcl
    else
        for r, u in pairs(IGS.Inventory(ply)) do
            local ITEM = IGS.GetItemByUID(u.Item)
            if not ITEM.swep then continue end

            if slots.slot1 == u.ID then
                totalsum = totalsum + ITEM.price
            elseif slots.slot2 == u.ID then
                totalsum = totalsum + ITEM.price
            elseif slots.slot3 == u.ID then
                totalsum = totalsum + ITEM.price
            elseif slots.slot4 == u.ID then
                totalsum = totalsum + ITEM.price
            end
        end
    end

    local tblmin = {}
    local tblmax = {}
    local tblgl = {}
    local mintotalsum = 0
    local maxtotalsum = 0

    for r, u in pairs(tbl2) do
        if u.price <= totalsum then
            mintotalsum = mintotalsum + u.price

            table.insert(tblmin, {
                name = u.name,
                price = u.price,
                chance = u.chance
            })
        elseif u.price > totalsum then
            maxtotalsum = maxtotalsum + u.price

            table.insert(tblmax, {
                name = u.name,
                price = u.price,
                chance = u.chance
            })
        end
    end

    local procentmin = mintotalsum * 0.01
    local procentmax = maxtotalsum * 0.01

    for r, u in pairs(tblmin) do
        u.chance = math.Round(u.price / procentmin, 2)
    end

    for r, u in pairs(tblmax) do
        u.chance = math.Round(u.price / procentmax, 2)
    end

    table.sort(tblmax, function(a,b) return a.price > b.price end)

    PrintTable(tblmax)

    for i = 1, math.floor(#tblmax * 0.5) do
        local temp = tblmax[i].chance
        tblmax[i].chance = tblmax[#tblmax - i + 1].chance
        tblmax[#tblmax - i + 1].chance = temp
    end

    for r, u in pairs(tblmin) do
        table.insert(tblgl, {
            name = u.name,
            price = u.price,
            chance = u.chance
        })
    end

    for r, u in ipairs(tblmax) do
        table.insert(tblgl, {
            name = u.name,
            price = u.price,
            chance = u.chance
        })
    end

    --if #tblmax > 0 and #tblmax > 0 then
        for r, u in pairs(tblgl) do
            u.chance = math.Round(u.chance * 0.5, 2)
        end
    --end

    return tblgl
end
--PATH addons/_boombox/lua/autorun/sh_retroboombox.lua:
RetroBoombox = {}
RetroBoombox.Config = {}
RetroBoombox.OriginalMats = {}
RetroBoombox.Config.MaxSoundVolume = 100
function RetroBoombox:LoadLanguage()
	local chosenLang = RetroBoombox.Config.Language or 'en'
	local dirLang = 'retroboombox/languages/' .. chosenLang .. '.lua'
	if not file.Exists( dirLang, 'LUA' ) then chosenLang = 'en' end
	if SERVER then AddCSLuaFile( dirLang ) end
	RetroBoombox.Lang = include( dirLang )
end

function RetroBoombox:Init()
	local directories = {
		-- for priority order
		[1] = 'shared',
		[2] = 'server',
		[3] = 'client',
	}

	for _, file_name in ipairs( file.Find( 'retroboombox/sh_*.lua', 'LUA' ) ) do
		-- include shared
		include( 'retroboombox/' .. file_name )
		if SERVER then
			-- AddCSLuaFile shared
			AddCSLuaFile( 'retroboombox/' .. file_name )
		end
	end

	for _, file_name in ipairs( file.Find( 'retroboombox/cl_*.lua', 'LUA' ) ) do
		if SERVER then
			-- AddCSLuaFile client
			AddCSLuaFile( 'retroboombox/' .. file_name )
		end
	end

	for _, file_name in ipairs( file.Find( 'retroboombox/sv_*.lua', 'LUA' ) ) do
		if SERVER then
			-- include server
			include( 'retroboombox/' .. file_name )
		end
	end

	self:LoadLanguage()
	for _, dir in pairs( directories ) do
		for _, file_name in ipairs( file.Find( 'retroboombox/' .. dir .. '/sh_*.lua', 'LUA' ) ) do
			-- include shared
			include( 'retroboombox/' .. dir .. '/' .. file_name )
			if SERVER then
				-- AddCSLuaFile shared
				AddCSLuaFile( 'retroboombox/' .. dir .. '/' .. file_name )
			end
		end

		for _, file_name in ipairs( file.Find( 'retroboombox/' .. dir .. '/cl_*.lua', 'LUA' ) ) do
			if SERVER then
				-- AddCSLuaFile client
				AddCSLuaFile( 'retroboombox/' .. dir .. '/' .. file_name )
			elseif CLIENT then
				-- include client
				include( 'retroboombox/' .. dir .. '/' .. file_name )
			end
		end

		for _, file_name in pairs( file.Find( 'retroboombox/' .. dir .. '/sv_*.lua', 'LUA' ) ) do
			if SERVER then
				-- include server
				include( 'retroboombox/' .. dir .. '/' .. file_name )
			end
		end
	end
end

function RetroBoombox:L( sKey )
	return RetroBoombox.Lang[sKey] or sKey
end

RetroBoombox:Init()
--PATH addons/_boombox/lua/retroboombox/client/cl_hooks.lua:
hook.Add( "PostPlayerDraw", "PostPlayerDraw.RetroBoombox", function( pPlayer )
	if SERVER then return end
	local currentWeapon = pPlayer:GetActiveWeapon()
	if not IsValid( currentWeapon ) then return end
	if currentWeapon:GetClass() ~= "retroboombox_base" then return end
	if not currentWeapon.PlayMusic or not isfunction( currentWeapon.PlayMusic ) then return end
	currentWeapon:PlayMusic()
end )
--PATH addons/__________skeypads/lua/skeypads/main/cl_doorhalos.lua:
local displayDoors = {}
net.Receive( 'sKeypads::SendConnectedDoors', function()
    local doorCount = net.ReadUInt( 8 )
    table.Empty( displayDoors )
    if doorCount <= 0 then
        hook.Remove( 'PreDrawHalos', 'sKeypads::HaloConnectedDoors' )
        return
    end

    for i = 1, doorCount do
        displayDoors[i] = net.ReadEntity()
    end

    hook.Add( 'PreDrawHalos', 'sKeypads::HaloConnectedDoors', function() halo.Add( displayDoors, sKeypads.Config.door_halo_color, 5, 5, 2 ) end )
end )
--PATH addons/____slib/lua/slib/vgui/cl_spopupbox.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 13)
local textcolor, textcolor_min10, margin, maincolor_10 = slib.getTheme("textcolor"), slib.getTheme("textcolor", -10), slib.getTheme("margin"), slib.getTheme("maincolor", 10)

function PANEL:Init()
    self:SetSize(slib.getScaledSize(260, "x"), self.topbarheight)
    self:Center()
    self:addCloseButton()
    self.frame:DockPadding(0,margin,0,0)

    self.bgcloser = vgui.Create("SButton")
    self.bgcloser:Dock(FILL)
    self.bgcloser:MakePopup()
    self.bgcloser.Paint = function() end
    self.bgcloser.DoClick = function()
        self:Remove()
    end

    local buttonsH = slib.getScaledSize(25, "y")
    self.choises = vgui.Create("EditablePanel", self.frame)
    self.choises:Dock(BOTTOM)
    self.choises:SetTall(slib.getScaledSize(25, "y"))
    self.choises:DockMargin(0,0,0,margin)
    self.choises:DockPadding(margin,0,margin,0)

    self.choises.ResizeChilds = function()
        local childs = self.choises:GetChildren()
        local count = table.Count(childs)
        local width = self.choises:GetWide()

        for k,v in pairs(childs) do
            v:SetWide(math.Clamp(width / count, 0, width - (margin * 2)) + (count > 1 and k < 3 and -margin*1.5 or 0))
            if count > 1 then
                v:DockMargin(k > 1 and margin * .5 or 0,0,margin * .5,0)
            end
        end
    end

    self.choises.OnSizeChanged = self.choises.ResizeChilds

    self:MakePopup()

    local realh = self.frame:GetTall() - self.choises:GetTall() - margin
    self.frame.PaintOver = function(s,w,h)
        if self.parse then
            self.parse:Draw(w * .5, (h - buttonsH) * .5, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end
end

function PANEL:OnRemove()
    if IsValid(self.bgcloser) then self.bgcloser:Remove() end
end

function PANEL:setText(str)
    self.parse = markup.Parse("<colour="..textcolor_min10.r..","..textcolor_min10.g..","..textcolor_min10.b..","..textcolor_min10.a.."><font="..slib.createFont("Roboto", 16)..">"..str.."</font></colour>", self.frame:GetWide() - (margin * 2))
    local height = self.parse:GetHeight()

    self:SetTall(self:GetTall() + height + (margin * 6))

    return self
end

local inputTypes = {
    ["int"] = "STextEntry",
    ["dropdown"] = "SDropDown",
    ["text"] = "STextEntry"
}

function PANEL:addInput(type, placeholder)
    placeholder = placeholder or ""
    local element = vgui.Create(inputTypes[type], self.frame)
    element:Dock(TOP)
    element:DockMargin(margin, 0, margin, margin)
    element:SetTall(slib.getScaledSize(25, "y"))
    element.placeholder = placeholder
    element.bg = maincolor_10

    if type == "int" then
        element:SetNumeric(true)
        element:SetRefreshRate(0)
    end

    element:SetPlaceholder(placeholder)

    self:SetTall(self:GetTall() + element:GetTall() + margin)

    return element
end

function PANEL:addChoise(title, func)
    if !self.addedH then
        self:SetTall(self:GetTall() + self.choises:GetTall() + margin)
    end

    self.addedH = true

    local choise = vgui.Create("SButton", self.choises)
    choise:setTitle(title)
    choise:Dock(LEFT)
    choise:DockMargin(0,margin,0,0)
    choise:SetTall(slib.getScaledSize(25, "y"))
    choise.bg = slib.getTheme("maincolor", 5)

    choise.DoClick = function() if func then func() end self:Remove() end

    self.choises.ResizeChilds()

    return self
end

vgui.Register("SPopupBox", PANEL, "SFrame")
--PATH addons/____slib/lua/slib/vgui/cl_sstatement.lua:
local PANEL = {}

local colorpickerMat, checkmarkMat = Material("slib/icons/color-picker16.png", "noclamp smooth" ), Material("slib/icons/checkmark.png", "noclamp smooth" )

local textcolor, textcolor_50, maincolor, maincolor_7, maincolor_10, accentcolor, cleanaccentcolor = slib.getTheme("textcolor"), slib.getTheme("textcolor", -50), slib.getTheme("maincolor"), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("accentcolor"), slib.getTheme("accentcolor")
local margin = slib.getTheme("margin")

function PANEL:Init()
    self:Dock(TOP)
    self:SetTall(slib.getScaledSize(25, "y"))
    self:DockMargin(margin, 0, margin, margin)
    self.font = slib.createFont("Roboto", 14)
	self.bg = maincolor_7
	self.elemBg = maincolor
	
	slib.wrapFunction(self, "SetZPos", nil, function() return self end, true)
	slib.wrapFunction(self, "DockMargin", nil, function() return self end, true)
end

function PANEL:Paint(w,h)
    surface.SetDrawColor(self.bg)
    surface.DrawRect(0, 0, w, h)
	
    draw.SimpleText(self.name, self.font, self.center and w * .5 - self.xoffset - margin or margin, h * .5, textcolor, self.center and TEXT_ALIGN_CENTER or TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
end

function PANEL:OnSizeChanged(w, h)
	if self.center then
		self:setCenter()
	end
end

function PANEL:setCenter()
	self.center = true

	self.xoffset = self.element:GetWide() * .5

	surface.SetFont(self.font)
	local w, h = surface.GetTextSize(self.name)

	local l,t,r,b = self.element:GetDockMargin()
	self.element:DockMargin(l,t,self:GetWide() * .5 - self.xoffset - (w * .5) - margin,b)
end

function PANEL:addStatement(name, value)
    self.name = name
	local statement = slib.getStatement(value)
	local element

	if statement == "color" then
		element = vgui.Create("SButton", self)
		element:SetWide(slib.getScaledSize(25, "y") - slib.getScaledSize(2, "x") - slib.getScaledSize(2, "x"))
		element.color = value
		element.old_color = value

		element.Paint = function(s,w,h)
			draw.RoundedBox(h * .3, 0, 0, w, h, element.color)

			surface.SetDrawColor(textcolor_50)
			surface.SetMaterial(colorpickerMat)
			local sizew, sizeh = 16, 16

			surface.DrawTexturedRect( (w * .5) - (sizew * .5), (h * .5) - (sizeh * .5), sizew, sizeh )
		end

		element.OnRemove = function()
			if IsValid(element.ColorPicker) then element.ColorPicker:Remove() end
		end

		element.DoClick = function()
			if element.ColorPicker and IsValid(element.ColorPicker) then return end

			local posx, posy = self:LocalToScreen( element:GetPos() )

			element.ClosePicker = vgui.Create("SButton")
			element.ClosePicker:Dock(FILL)
			element.ClosePicker:MakePopup()
			element.ClosePicker.DoClick = function()
				if IsValid(element.ColorPicker) then element.ColorPicker:Remove() end
				if IsValid(element.ClosePicker) then element.ClosePicker:Remove() end
			end

			element.ClosePicker.Paint = function() end

			element.ColorPicker = vgui.Create("DColorMixer")
			element.ColorPicker:SetSize( slib.getScaledSize(200, "x"), slib.getScaledSize(160, "y") )
			element.ColorPicker:SetPos( posx - element.ColorPicker:GetWide(), posy )
			element.ColorPicker:SetPalette(false)
			element.ColorPicker:SetAlphaBar(false)
			element.ColorPicker:SetAlphaBar( true )
			element.ColorPicker:SetWangs(false)
			element.ColorPicker:SetColor(element.color and element.color or Color(255,0,0))
			element.ColorPicker:MakePopup()

			element.ColorPicker.Think = function()
				element.color = element.ColorPicker:GetColor()
			end

			element.ColorPicker.OnRemove = function()
				element.old_color = element.color

				if isfunction(element.onValueChange) then
					local result = element.onValueChange(element.color)
					if result == false then element.color = element.old_color end
				end
			end
		end
	elseif statement == "bool" then
		element = vgui.Create("SButton", self)
		element:SetWide(slib.getScaledSize(25, "y") - slib.getScaledSize(2, "x") - slib.getScaledSize(2, "x"))
		element.basealpha = cleanaccentcolor.a

		element.Paint = function(s,w,h)
			draw.RoundedBox(h * .3, 0, 0, w, h, self.elemBg)
            
            local wantedcolor = accentcolor

			wantedcolor.a = s.enabled and element.basealpha or 0
		
			local ico_size = h * .55

			surface.SetDrawColor(slib.lerpColor(s, wantedcolor, 3))
			surface.SetMaterial(checkmarkMat)
			surface.DrawTexturedRect(w * .5 - ico_size * .5,h * .5 - ico_size * .5, ico_size, ico_size)
		end

		element.enabled = value

		element.DoClick = function()
			element.enabled = !element.enabled
            
            if isfunction(element.onValueChange) then
				local result = element.onValueChange(element.enabled)
				if result == false then element.enabled = !element.enabled end
            end
		end
	elseif statement == "int" then
		element = vgui.Create("DNumberWang", self)
		element:SetWide(slib.getScaledSize(50, "x"))
		element:SetDrawLanguageID(false)
		element:SetFont(self.font)
		element:SetMin(0)
		element:SetMax(2000000)
		element.oldValue = value

		element.Paint = function(s,w,h)
			draw.RoundedBox(h * .3, 0, 0, w, h, self.elemBg)

			s:DrawTextEntryText(textcolor, cleanaccentcolor, cleanaccentcolor)
		end

		element.OnValueChanged = function(ignore)
			local oldValue = element.oldValue
			local newValue = element:GetValue()

			timer.Create(tostring(element), .3, 1, function()
				if isfunction(element.onValueChange) then
					local result = element.onValueChange(newValue)
					if result == false then
						element.oldValue = oldValue
						element:SetText(oldValue)
					return end

					element.oldValue = newValue
				end
			end)
		end

		element:SetText(value)
	elseif statement == "function" or statement == "table" then
		element = vgui.Create("SButton", self)
		element:Dock(RIGHT)
		element:DockMargin(0,slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))
		element:setTitle(statement == "function" and "Execute" or "View Table")

		element.DoClick = function()
			if statement == "function" then
				value()
			return end
			
			local display_data = vgui.Create("STableViewer")
			display_data:setTable(value)
			display_data:SetBG(false, true, nil, true)

			if isfunction(element.onElementOpen) then
				element.onElementOpen(display_data)
			end
		end
	elseif statement == "string" then
		element = vgui.Create("DTextEntry", self)
		element:SetWide(slib.getScaledSize(80, "x"))
		element:SetDrawLanguageID(false)
		element:SetFont(self.font)
		element.Paint = function(s,w,h)
			draw.RoundedBox(h * .3, 0, 0, w, h, self.elemBg)

			s:DrawTextEntryText(textcolor, cleanaccentcolor, cleanaccentcolor)
		end
    end
    
    element:Dock(RIGHT)
    element:DockMargin(0,slib.getScaledSize(2, "x"),slib.getScaledSize(2, "x"),slib.getScaledSize(2, "x"))

	self.element = element

	return self, element
end

vgui.Register("SStatement", PANEL, "EditablePanel")
--PATH addons/____slib/lua/slib/vgui/cl_stableviewer.lua:
local PANEL = {}

local font = slib.createFont("Roboto", 15)
local neutralcolor, textcolor, successcolor_100, failcolor_100, maincolor_5, maincolor_7, maincolor_10, maincolor_15 = slib.getTheme("neutralcolor"), slib.getTheme("textcolor"), slib.getTheme("successcolor", -100), slib.getTheme("failcolor", -100), slib.getTheme("maincolor", 5), slib.getTheme("maincolor", 7), slib.getTheme("maincolor", 10), slib.getTheme("maincolor", 15)

function PANEL:Init()
    self:SetSize(slib.getScaledSize(450, "x"), slib.getScaledSize(330, "y"))
    :Center()
    :MakePopup()
    :addCloseButton()
    :setTitle("Table Viewer", slib.createFont("Roboto", 17))
    :setBlur(true)

    self.entryheight = slib.getScaledSize(20, "y")
    
    self.viewbox = vgui.Create("EditablePanel", self.frame)
    self.viewbox:Dock(RIGHT)
    self.viewbox:SetWide(self.frame:GetWide())

    self.viewer = vgui.Create("SScrollPanel", self.viewbox)
    :Dock(FILL)
end

local function createButton(self, parent, str, val)
    local istbl = istable(val)
    local selparent = parent and parent or self.viewer

    local value = vgui.Create("SButton", selparent)
    :Dock(TOP)
    :SetZPos(-10)
    :SetTall(slib.getScaledSize(25, "y"))

    value.title = str
    value.tbl = istbl and val or parent.tbl

    value.Paint = function(s,w,h)
        local wantedcolor = selparent == self.suggestions and successcolor_100 or (value.toggleable and selparent.tbl[str] and successcolor_100 or failcolor_100)

        if !value.toggleable and (!s:IsHovered() or self.viewOnly) then
            wantedcolor = table.Copy(wantedcolor)
            wantedcolor.a = 0
        end
        
        surface.SetDrawColor(slib.lerpColor(s, wantedcolor))
        surface.DrawRect(0, 0, w, h)
        local display = ""

        if !istbl and (isstring(val) or isnumber(val)) then
            display = ": "..tostring(val)
        end
        
        draw.SimpleText(str..display, font, slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    end

    value.Think = function()
        if !value.toggleable and self:getRule("toggleables", str) then
            value.toggleable = true
        end

        if value:IsHovered() and input.IsKeyDown(KEY_LSHIFT) and input.IsMouseDown(MOUSE_RIGHT) then
            value:DoClick()
        end
    end

    value.DoClick = function()
        if self.viewOnly then return end

        self.modified = true
        
        if selparent == self.suggestions then
            local edit = IsValid(self.selected) and self.selected or self.viewer

            if self.rules and self.rules.onlymodifytable and edit:GetName() == "SScrollPanel" then return end

            if self.customvalues then
                local popup = vgui.Create("SPopupBox")
                :setTitle(value.title)
                
                local entry = popup:addInput("text", self.customvalueplaceholder)

                if self.customnumeric then
                    entry:SetNumeric(true)
                end
                
                popup:addChoise(self.customvalues, function()
                    local val = entry:GetValue()
                    self:addValue(editTbl, value.title, val, edit)
                    edit.tbl[value.title] = val

                    if edit == self.viewer then
                        self:sortValues(self.viewer)
                    end
                end)

                return
            else
                edit.tbl[value.title] = true
                self:addValue(editTbl, value.title, true, edit)
            end
            
            if edit == self.viewer then
                self:sortValues(self.viewer)
            end
        else
            if value.toggleable then
                selparent.tbl[str] = !selparent.tbl[str]
            return end

            value:Remove()
        end

        selparent.tbl[str] = nil
    end

    return value
end

function PANEL:addValue(panel, str, val, parent)
    if istable(val) then
        local selpar = parent or panel
        parent = vgui.Create("EditablePanel", selpar)
        parent:Dock(TOP)
        parent:SetTall(slib.getScaledSize(25, "y"))
        parent:DockMargin(slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"),slib.getTheme("margin"))
        parent:DockPadding(0,slib.getScaledSize(25, "y"),0,0)
        parent.isTblContainer = true
        parent.tbl = val
        parent.title = str
        parent.OnSizeChanged = function(w,h)
            parent.top:SetWide(parent:GetWide())
        end

        parent.top = vgui.Create("SButton", parent)
        parent.top:SetSize(parent:GetWide(), slib.getScaledSize(25, "y"))

        parent.top.DoClick = function()
            if self.rules and self.rules.tableDeletable and !self:getRule("undeleteableTables", str)  then
                parent:Remove()
                selpar.tbl[str] = nil
                self.modified = true
            return end

            self.selected = self.selected ~= parent and parent or nil
        end

        parent.top.Paint = function(s,w,h)
            local wantedcolor = self.rules and self.rules.tableDeletable and !self:getRule("undeleteableTables", str) and failcolor_100 or neutralcolor
            
            surface.SetDrawColor(maincolor_7)
            surface.DrawRect(0, 0, w, h)

            surface.SetDrawColor(maincolor_5)
            surface.DrawRect(0,h-1,w,1)

            if self.rules and self.rules.tableDeletable and !self:getRule("undeleteableTables", str) then
                if !s:IsHovered() then
                    wantedcolor = table.Copy(wantedcolor)
                    wantedcolor.a = 0
                end
            elseif self.selected ~= parent then
                wantedcolor = table.Copy(wantedcolor)
                wantedcolor.a = 0
            end


            surface.SetDrawColor(slib.lerpColor(s, wantedcolor))
            surface.DrawRect(0, 0, w, h)

            draw.SimpleText(str, font, slib.getTheme("margin"), h * .5, textcolor, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end

        parent.PaintOver = function(s, w, h)
            surface.SetDrawColor(maincolor_5)
            surface.DrawOutlinedRect(0, 0, w, h)
        end

        parent.OnChildAdded = function(child)
            local addheight = slib.getScaledSize(25, "y")
            parent:SetTall(parent:GetTall() + addheight)

            local grandparent = parent:GetParent()
            if !grandparent.isTblContainer then return end
            grandparent:SetTall(grandparent:GetTall() + addheight)
        end

        parent.OnChildRemoved = function(child)
            local addheight = slib.getScaledSize(25, "y")
            parent:SetTall(parent:GetTall() - addheight)

            local grandparent = parent:GetParent()
            if !grandparent.isTblContainer then return end
            grandparent:SetTall(grandparent:GetTall() - addheight)
        end
        
        if selpar ~= self.viewer then
            selpar:SetTall(selpar:GetTall() + (slib.getTheme("margin") * 2))
        end

        for k,v in pairs(val) do
            self:addValue(panel, k, v, parent)
        end
    return end

    return createButton(self, parent and parent or panel, str, val)
end

local function differenciate(a, b)
    if !(isstring(a) == isstring(b)) or isbool(a) or isbool(b) then
        return tostring(a), tostring(b)
    end

    return a, b
end

function PANEL:setCustomValues(bool, placeholder, numeric)
    self.customvalues = bool
    self.customvalueplaceholder = placeholder
    self.customnumeric = numeric

    return self
end

function PANEL:sortValues(panel)
    if !IsValid(panel) then return self end
    local basictable = {}
    local cleantable = {}

    for k,v in pairs(panel.tbl) do
        table.insert(basictable, k)
    end

    table.sort(basictable, function(a, b) local a, b = differenciate(a, b) return a < b end)
    
    for k,v in pairs(basictable) do
        cleantable[v] = k
    end

    for k, v in pairs(panel:GetCanvas():GetChildren()) do
        if !v.title then continue end
        v:SetZPos(cleantable[v.title])
    end

    return self
end

function PANEL:addSuggestions(tbl)
    if !tbl then return self end

    local wide, tall = self.frame:GetWide() * .5, self.frame:GetTall()
    self.viewer:SetPos(wide, 0)
    self.viewer:SetWide(wide)

    self.suggestionbox = vgui.Create("EditablePanel", self.frame)
    self.suggestionbox:Dock(LEFT)
    self.suggestionbox:SetWide(self.frame:GetWide() * .5)
    self.viewbox:SetWide(self.frame:GetWide() * .5)

    self.suggestions = vgui.Create("SScrollPanel", self.suggestionbox)
    self.suggestions:Dock(FILL)
    self.suggestions.tbl = tbl
    self.suggestions.hidden = {}

    self.suggestions.PaintOver = function(s,w,h)
        surface.SetDrawColor(maincolor_10)
        surface.DrawRect(w - 1, 0, 1, h)
    end

    self.suggestions.Think = function()
        local edit = IsValid(self.selected) and self.selected or self.viewer
        for k, value in pairs(self.suggestions:GetCanvas():GetChildren()) do
            if value:IsVisible() ~= !edit.tbl[value.title] and !value.searchHidden then
                value:SetVisible(!edit.tbl[value.title])
                self.suggestions:GetCanvas():InvalidateLayout(true)
            end
        end
    end

    for k,v in pairs(tbl) do
        self:addValue(self.suggestions, k, v)
    end

    return self
end

function PANEL:setOnlyModifyTable(bool)
    self.rules = self.rules or {}
    self.rules.onlymodifytable = bool
end

function PANEL:setToggleable(module, name, string)
    self.rules = self.rules or {}
    self.rules[module] = self.rules[module] or {}
    self.rules[module][name] = self.rules[module][name] or {}
    self.rules[module][name].toggleables = self.rules[module][name].toggleables or {}

    self.rules[module][name].toggleables[string] = true
end

function PANEL:setTableDeletable(bool)
    self.rules = self.rules or {}
    self.rules.tableDeletable = bool
end

function PANEL:setundeleteableTable(module, name, string)
    self.rules = self.rules or {}
    self.rules[module] = self.rules[module] or {}
    self.rules[module][name] = self.rules[module][name] or {}
    self.rules[module][name].undeleteableTables = self.rules[module][name].undeleteableTables or {}

    self.rules[module][name].undeleteableTables[string] = true
end

function PANEL:setAddRules(rule)
    self.rules = self.rules or {}
    self.rules.addRules = rule
end

function PANEL:getRule(type, str)
    local returnval = false

    if self.rules and self.rules[self.modulename] and self.rules[self.modulename][self.name] and self.rules[self.modulename][self.name][type] and self.rules[self.modulename][self.name][type][str] then
        returnval = true
    end
    
    return returnval
end

function PANEL:setIdentifiers(module, name)
    self.modulename, self.name = module, name
end

function PANEL:setTable(tbl)
    if !tbl or !istable(tbl) then return self end
    self.viewer.tbl = tbl
    for k,v in pairs(tbl) do
        self:addValue(self.viewer, k, v)
    end

    return self
end

function PANEL:addSearch(panel, viewer)
    if !IsValid(panel) or !IsValid(viewer) then return self end
    panel.search = vgui.Create("SSearchBar", panel)
    :addIcon()
    :SetWide(panel:GetWide())
    :Dock(TOP)
    :DockMargin(0,0,0,0)

    panel.search.entry.onValueChange = function(newvalue)
        for k,v in pairs(viewer:GetCanvas():GetChildren()) do
            if !v.title then continue end

            v:SetVisible(string.find(string.lower(v.title), string.lower(newvalue)))

            if v:IsVisible() then
                v.searchHidden = nil
            else
                v.searchHidden = true
            end
        end

        viewer:GetCanvas():InvalidateLayout(true)
    end

    return self
end

function PANEL:addEntry()
    self.addEntryFrame = vgui.Create("EditablePanel", self.viewbox)
    self.addEntryFrame:Dock(BOTTOM)

    self.addEntryButton = vgui.Create("SButton", self.addEntryFrame)
    :Dock(RIGHT)
    :setTitle("Add")

    self.addEntryButton.accentheight = 1
    self.addEntryButton.bg = maincolor_10

    self.addEntryButton.DoClick = function()
        local key, edit = self.entry:GetValue(), (IsValid(self.selected) and self.selected or self.viewer)
        if !key or key == "" or edit.tbl[key] then return end
        if self.rules and self.rules.onlymodifytable and edit:GetName() == "SScrollPanel" then return end
        
        local val

        if self.rules and self.rules.addRules and edit:GetName() == "SScrollPanel" then
            val = table.Copy(self.rules.addRules)
        end

        if !val then val = key end

        local result = !istable(val) and true or val
        edit.tbl[key] = result

        self:addValue(edit, key, result, edit)
        self:sortValues(self.viewer)
        self.modified = true
        self.entry:SetValue("")
    end

    self.entry = vgui.Create("STextEntry", self.addEntryFrame)
    :Dock(FILL)
    :SetValue("")

    self.entry.bg = maincolor_10

    self.entry.placeholder = ""

    self.addEntryFrame:SetTall(self.entry:GetTall())
    self.addEntryButton:SetTall(self.entry:GetTall())

    return self
end

vgui.Register("STableViewer", PANEL, "SFrame")
--PATH addons/____sprinter/lua/autorun/sprinter_loader.lua:
if slib and slib.loadFolder then slib.loadFolder("s_printer/", true, {{"s_printer/", "sh_sprinter_config.lua"}}, {{"s_printer/", "sh_sprinter.lua"}, {"s_printer/integration/", "sv_logging.lua"}}) end
hook.Add("slib:loadedUtils", "sP:Initialize", function() slib.loadFolder("s_printer/", true, {{"s_printer/", "sh_sprinter_config.lua"}}, {{"s_printer/", "sh_sprinter.lua"}, {"s_printer/integration/", "sv_logging.lua"}}) end)
--PATH addons/____sprinter/lua/s_printer/sh_sprinter_config.lua:
sPrinter = sPrinter or {}
sPrinter.config = sPrinter.config or {}
sPrinter.config.printers = sPrinter.config.printers or {}

--  _______                               _  
-- (_______)                             | | 
--  _   ___ _____ ____  _____  ____ _____| | 
-- | | (_  | ___ |  _ \| ___ |/ ___|____ | | 
-- | |___) | ____| | | | ____| |   / ___ | | 
--  \_____/|_____)_| |_|_____)_|   \_____|\_)

sPrinter.config["language"] = "ua"

sPrinter.config["prefix"] = "[sPrinter] "

sPrinter.config["logging_col"] = Color(200,0,0)

sPrinter.config["currency"] = "$"

sPrinter.config["hack_speed"] = 6

sPrinter.config["punish_exploit"] = true

sPrinter.config["hack_words"] = {
    ["HACKING"] = true,
    ["L33T"] = true,
    ["1337"] = true,
    ["LULZ"] = true
}

sPrinter.config["max_printer_bag"] = { --- This is the max printers the printer bag can hold!
    ["default"] = 3,
    ["superadmin"] = 5
}

sPrinter.config["rack_repair_price"] = 12000

sPrinter.config["DarkRPFireSystem_Spawn_Flame_On_Explode"] = true --- This will spawn a flame if you have the darkrp fire system and this is enabled!

sPrinter.config["disable_topscreen_in_rack"] = true --- This will disable drawing the topscreen while the printer is in a rack, good for performance!

sPrinter.config["maxdistance"] = 8000

sPrinter.config["maxdrawdistance"] = 30000

sPrinter.config["logo"] = {
    ["sprinter_base"] = {
        enabled = true,
        id = "DeQWoR0",
        size = {w = 420, h = 420},
        pos = Vector(-13.135, 19.546, 4.8),
        ang = Angle(0,0,0)
    },
    ["sprinter_rack"] = {
        enabled = true,
        id = "DeQWoR0",
        size = {w = 420, h = 420},
        pos = Vector(-3, -10.7, 44.187),
        ang = Angle(0,0,90)
    },
}

sPrinter.config["soundradius"] = 60

sPrinter.config["damageradius"] = {20,50}

sPrinter.config["blastdamage"] = {30,80}

sPrinter.config["recharge_price_per_percentage"] = true --- This is enabled it will only charge per percent you charge based on the charge price the printer has defined.

--  ______              _     ______  ______  
-- (______)            | |   (_____ \(_____ \ 
--  _     _ _____  ____| |  _ _____) )_____) )
-- | |   | (____ |/ ___) |_/ )  __  /|  ____/ 
-- | |__/ // ___ | |   |  _ (| |  \ \| |      
-- |_____/ \_____|_|   |_| \_)_|   |_|_|      

hook.Add("LoadingEnts", "sP:LoadEnts", function()
    ------------------------------------------------------------------------------------
    --  You can use any DarkRP create entity variables here just like normal in here.
    ------------------------------------------------------------------------------------

    sPrinter.config["reward_teams"] = {
        --[TEAM_CITIZEN] = true -- Add whatever you want in here! 
    }
    
    -- sPrinter.config["drp_categories"] = { -- This can be used to setup custom categories, for example Premium Printers etc...
    --     {
    --         name = "Printers",
    --         color = Color(200,0,0),
    --         canSee = function(ply)
    --             return true
    --         end,
    --         sortOrder = 999,
    --     },
    --     // {
    --     //     name = "Example1",
    --     //     color = Color(230,0,0),
    --     //     sortOrder = 20,
    --     // },
    -- }

    sPrinter.config["rack"] = {
        ["body_color"] = Color(112,112,112),
        ["godmode"] = false, -- Should we godmode the printer rack?
        ["water_affect"] = 2, -- 0 = Ignore, 1 = Blow up & 2 = Eject

        ["Price"] = 40000, --- This is the price of the rack in the DarkRP Entities
        ["Max"] = 1,
        ["min_recharge"] = .8, --- If printers are below this percentage it will recharge them if done through the rack, 0.8 is default and is equal to 80%.
        // ["category"] = "Printers",
        ["allowed"] = {TEAM_DRUG,TEAM_GANG,TEAM_GANGVIP,TEAM_GLCRIME,TEAM_THIEFF,TEAM_BANK,TEAM_CITIZEN,TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Yakuza}, -- 1 tier
        // ["disabled"] = true, --- If you wanna disable the printer rack.

        // ["sortOrder"] = -100,
        // ["CustomCheckFailMsg"] = "This is a test",
        // ["customCheck"] = function() end 
    }

    sPrinter.config.printers["Tier 1"] = {
        bodycolor = Color(174,174,174),
        clockspeed = 3.4,
        baseincome = 19,
        maxstorage = 80000,
        sortorder = 1,
        batteryconsumption = .97, --- This is how many percent it will take per 10 seconds
        rechargeprice = 2000,
        repairprice = 2000,
        // category = "Example",
        // cantwithdrawjobs = {["Citizen"] = true},
        // withdrawjobswhitelist = true,
        water_affect = 1, --- 0 = Ignore, 1 = Blow up & 2 = Turn off
        reward = .4, --- This is how much of the cost that the person to destroy the printer will earn, based on the price of the printer!
        // countUpgradesToReward = true, --- This will make the upgrades count into the reward amount!
        dmgresistance = 1, --- This is the damage multiplier the printer receive
        Price = 15000, --- This is the cost of buying the printer in the entities list!
        Max = 2,
        upgrades = {
            {upgrade = "overclocking", baseprice = 2400, max = 10, icon = Material("sprinter/overclock.png", "smooth")}, --- You can enforce pricing for each upgrade level like this ([upgrade_stage] = price) : , enforced_pricing = {[1] = 200, [2] = 400}
            {upgrade = "noisereduction", baseprice = 1500, max = 5, icon = Material("sprinter/noise.png", "smooth")},
            {upgrade = "dmgresistance", baseprice = 700, max = 5, icon = Material("sprinter/shield.png", "smooth")},
            {upgrade = "storage", baseprice = 3000, max = 5, increment = 10000, icon = Material("sprinter/storage.png", "smooth")},
            {upgrade = "notifications", baseprice = 500, max = 1, icon = Material("sprinter/bell.png", "smooth")}
        },
        allowed = {TEAM_DRUG,TEAM_GANG,TEAM_GANGVIP,TEAM_GLCRIME,TEAM_THIEFF,TEAM_BANK,TEAM_CITIZEN,TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Yakuza}, -- 1 tier
    }

    sPrinter.config.printers["Tier 2"] = {
        bodycolor = Color(0,188,178),
        clockspeed = 3.7,
        baseincome = 25,
        maxstorage = 100000,
        sortorder = 2,
        batteryconsumption = .97,
        rechargeprice = 3000,
        repairprice = 2000,
        water_affect = 1,
        reward = .4,
        dmgresistance = .9,
        Price = 36000,
        Max = 2,
        upgrades = {
            {upgrade = "overclocking", baseprice = 3300, max = 10, icon = Material("sprinter/overclock.png", "smooth")},
            {upgrade = "noisereduction", baseprice = 1500, max = 5, icon = Material("sprinter/noise.png", "smooth")},
            {upgrade = "dmgresistance", baseprice = 700, max = 5, icon = Material("sprinter/shield.png", "smooth")},
            {upgrade = "notifications", baseprice = 500, max = 1, icon = Material("sprinter/bell.png", "smooth")}
        },
        allowed = {TEAM_DRUG,TEAM_GANG,TEAM_GANGVIP,TEAM_GLCRIME,TEAM_THIEFF}, -- 2 tier
    }

    sPrinter.config.printers["Tier 3"] = {
        bodycolor = Color(94,188,0),
        clockspeed = 4.1,
        baseincome = 32,
        maxstorage = 130000,
        sortorder = 3,
        batteryconsumption = .97,
        rechargeprice = 4000,
        repairprice = 2000,
        water_affect = 1,
        reward = .4,
        dmgresistance = .8,
        Price = 52000,
        Max = 2,
        upgrades = {
            {upgrade = "overclocking", baseprice = 4200, max = 10, icon = Material("sprinter/overclock.png", "smooth")},
            {upgrade = "noisereduction", baseprice = 1500, max = 5, icon = Material("sprinter/noise.png", "smooth")},
            {upgrade = "dmgresistance", baseprice = 700, max = 5, icon = Material("sprinter/shield.png", "smooth")},
            {upgrade = "notifications", baseprice = 500, max = 1, icon = Material("sprinter/bell.png", "smooth")}
        },
        allowed = {TEAM_GANG,TEAM_GANGVIP,TEAM_GLCRIME}, -- 3 tier
    }

    sPrinter.config.printers["Tier 4"] = {
        bodycolor = Color(188,188,0),
        clockspeed = 4.6,
        baseincome = 40,
        maxstorage = 160000,
        // sortorder = 4,
        batteryconsumption = .99,
        rechargeprice = 5000,
        repairprice = 2000,
        water_affect = 1,
        reward = .4,
        // basevolume = 0.5, -- This is the base volume the printer makes, do not make it above 1 - each upgrade remove .1 from the basevolume. Example: basevolume as 0.5 will make it completely quiet if you have max 5 noise reduction upgrades.
        // cantwithdrawjobs = {["Citizen"] = true},
        // withdrawjobswhitelist = true -- this will determing if the list above is a whitelist or a blacklist
        // cantwithdrawusergroups = {["superadmin"] = true},
        // xpmultiplier = .3, -- This is the amount of xp you will receive from withdrawing money - amount * multiplier
        // ignoretemperature = true,
        dmgresistance = .8,
        Price = 94000,
        vip = true,
        failmsg = "You need VIP rank to purchase this printer!", --- This will popup if they arent in the usergroups stated above.
        Max = 2,
        upgrades = {
            {upgrade = "overclocking", baseprice = 5800, max = 10, usergroup = {["vip"] = true, ["*"] = true}, icon = Material("sprinter/overclock.png", "smooth")},
            {upgrade = "noisereduction", baseprice = 1500, max = 8, icon = Material("sprinter/noise.png", "smooth")},
            {upgrade = "dmgresistance", baseprice = 700, max = 5, icon = Material("sprinter/shield.png", "smooth")},
            {upgrade = "notifications", baseprice = 500, max = 1, icon = Material("sprinter/bell.png", "smooth")}
        },
        allowed = {TEAM_GANGVIP,TEAM_GLCRIME}, -- 4 tier(vip)
    }
    
    sPrinter.loadDarkRPContent()
end)
--PATH addons/____sprinter/lua/s_printer/languages/sh_spanish.lua:
if CLIENT then
    slib.setLang("sprinter", "es", "main", "Principal")
    slib.setLang("sprinter", "es", "logs", "Registros")
    slib.setLang("sprinter", "es", "upgrades", "Actualizaciones")
    slib.setLang("sprinter", "es", "settings", "Configuraciones")
    slib.setLang("sprinter", "es", "overclocking", "Overclocking")
    slib.setLang("sprinter", "es", "noisereduction", "Reducción de ruido")
    slib.setLang("sprinter", "es", "dmgresistance", "Resistencia al daño")
    slib.setLang("sprinter", "es", "notifications", "Notificaciones")

    slib.setLang("sprinter", "es", "notify-withdraw", "Notificar al retirar")
    slib.setLang("sprinter", "es", "notify-on-damage", "Notificar sobre daños")
    slib.setLang("sprinter", "es", "notify-low-hp", "Notificar en HP bajo")
    slib.setLang("sprinter", "es", "notify-low-battery", "Notificar sobre batería baja")

    slib.setLang("sprinter", "es", "withdrawn-money", "Dinero retirado")
    slib.setLang("sprinter", "es", "received-damage", "Daño recibido")
    slib.setLang("sprinter", "es", "upgraded-printer", "Impresora mejorada")
    slib.setLang("sprinter", "es", "turned-on", "Encendido")
    slib.setLang("sprinter", "es", "turned-off", "Apagado")

    slib.setLang("sprinter", "es", "are-you-sure", "Estas seguro")
    slib.setLang("sprinter", "es", "this-will-cost", "Esto costará %s")

    slib.setLang("sprinter", "es", "nothing-to-show", "Nada que mostrar aquí")

    slib.setLang("sprinter", "es", "condition", "Condición")
    slib.setLang("sprinter", "es", "temperature", "Temperatura")
    slib.setLang("sprinter", "es", "clockspeed", "Velocidad de reloj")
    slib.setLang("sprinter", "es", "income", "Ingresos(minuto)")
    slib.setLang("sprinter", "es", "eject", "Expulsar")
    slib.setLang("sprinter", "es", "withdraw", "Retirar")
    slib.setLang("sprinter", "es", "repair", "Reparar")
    slib.setLang("sprinter", "es", "recharge", "Recargar")

    slib.setLang("sprinter", "es", "empty", "Vacío")
else
    slib.setLang("sprinter", "es", "upgraded", "Ha actualizado una impresora para %s")
    slib.setLang("sprinter", "es", "recharged", "Ha recargado una impresora por %s")
    slib.setLang("sprinter", "es", "repaired", "Ha reparado una impresora para %s")
    slib.setLang("sprinter", "es", "repaired-rack", "Tu reparado un estante para %s")
    slib.setLang("sprinter", "es", "withdrawn", "Te retirar %s")
    slib.setLang("sprinter", "es", "recharged-all", "Ha recargado todas las impresoras del bastidor durante %s")
    slib.setLang("sprinter", "es", "recharged-this-many", "Te has recargado %s impresor(s) en el estante para %s")
    slib.setLang("sprinter", "es", "repaired-all", "Ha reparado todas las impresoras del bastidor para %s")
    slib.setLang("sprinter", "es", "repaired-this-many", "Has reparado %s impresor(s) en el estante para %s")
    slib.setLang("sprinter", "es", "no-eject-space", "No hay espacio para expulsar la impresora.")
    slib.setLang("sprinter", "es", "printer-was-damaged", "Tu %s printer has been damaged!")
    slib.setLang("sprinter", "es", "printer-low-hp", "Tu %s la impresora tiene poco hp!")
    slib.setLang("sprinter", "es", "someone-has-withdrawn", "Alguien ha retirado dinero de su %s impresor!")
    slib.setLang("sprinter", "es", "battery-low", "Tu %s printer is low on battery, deberías recargarlo!")
    slib.setLang("sprinter", "es", "rewarded-on-destroy", "Has recibido %s como recompensa por destruir una impresora!")
end

slib.setLang("sprinter", "es", "rack", "Rack de impresora")
slib.setLang("sprinter", "es", "insufficient-permissions", "¡No tienes permisos suficientes para hacer esto!")
--PATH addons/_cuffs/lua/autorun/sv_handcuffs.lua:
-------------------------------------
---------------- Cuffs --------------
-------------------------------------
-- Copyright (c) 2015 Nathan Healy --
-------- All rights reserved --------
-------------------------------------
-- sv_handcuffs.lua         SERVER --
--                                 --
-- Server-side handcuff stuff.     --
-------------------------------------

if CLIENT then return end

util.AddNetworkString( "Cuffs_BlindPlayer" )
util.AddNetworkString( "Cuffs_FreePlayer" )
util.AddNetworkString( "Cuffs_DragPlayer" )

util.AddNetworkString( "Cuffs_TiePlayers" )
util.AddNetworkString( "Cuffs_UntiePlayers" )

local function GetTrace( ply )
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if IsValid(tr.Entity) and tr.Entity:IsPlayer() then
		local cuffed,wep = tr.Entity:IsHandcuffed()
		if cuffed then return tr,wep end
	end
end

//
// Standard hooks
hook.Add( "PlayerCanJoinTeam", "Cuffs RestrictTeam", function( ply )
	if ply:IsHandcuffed() then return false end
end)

// 
// DarkRP
hook.Add( "playerRPCanChangeTeam", "Cuffs RestrictTeam", function( ply )
	if ply:IsHandcuffed() then return false,"Ви не можете змінювати професію поки на вас наручники" end
end)
hook.Add( "playerCanChangeRPName", "Cuffs RestrictName", function( ply )
	if ply:IsHandcuffed() then return false,"Ви не можете змінити своє ім'я, будучи в наручниках!" end
end)

//
// Think
local NextTieHookCleanup
hook.Add( "Think", "Cuffs ForceJump CleanupTieHooks", function()
	for _,v in player.Iterator() do
		if v.Cuff_ForceJump then
			if not v:OnGround() then return end
			
			local tr = util.TraceLine( {start = v:GetPos(), endpos = v:GetPos()+Vector(0,0,20), filter = v} )
			if tr.Hit then return end
			
			v:SetPos(v:GetPos()+Vector(0,0,5) )
			
			v.Cuff_ForceJump = nil
		end
	end
	
	if CurTime()>=(NextTieHookCleanup or 0) then
		for _,v in ents.Iterator() do
			if v.IsHandcuffHook and v.TiedHandcuffs then
				for i=#v.TiedHandcuffs,0,-1 do
					if not IsValid(v.TiedHandcuffs[i]) then
						table.remove( v.TiedHandcuffs, i )
					end
				end
				if #v.TiedHandcuffs<=0 then
					v:Remove()
					continue
				end
			end
		end
	end
end)

//
// Cuffed player interaction
net.Receive( "Cuffs_BlindPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetCanBlind()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldBlind = net.ReadBit()==1
	cuffs:SetIsBlind( shouldBlind )
	hook.Call( shouldBlind and "OnHandcuffBlindfold" or "OnHandcuffUnBlindfold", GAMEMODE, ply, target, cuffs )
end)
net.Receive( "Cuffs_FreePlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs)) or IsValid(cuffs:GetFriendBreaking()) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	cuffs:SetFriendBreaking( ply )
end)
net.Receive( "Cuffs_DragPlayer", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local target = net.ReadEntity()
	if (not IsValid(target)) or target==ply then return end
	
	local cuffed, cuffs = target:IsHandcuffed()
	if not (cuffed and IsValid(cuffs) and cuffs:GetRopeLength()>0) then return end
	
	local tr = GetTrace(ply)
	if not (tr and tr.Entity==target) then return end
	
	local shouldDrag = net.ReadBit()==1
	if shouldDrag then
		if not (IsValid(cuffs:GetKidnapper())) then
			cuffs:SetKidnapper( ply )
			hook.Call( "OnHandcuffStartDragging", GAMEMODE, ply, target, cuffs )
		end
	else
		if ply==cuffs:GetKidnapper() then
			cuffs:SetKidnapper( nil )
			hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, target, cuffs )
		end
	end
end)

net.Receive( "Cuffs_TiePlayers", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local DraggedCuffs = {}
	for _,c in ipairs(ents.FindByClass("weapon_handcuffed")) do
		if c:GetRopeLength()>0 and c:GetKidnapper()==ply then
			table.insert( DraggedCuffs, c )
		end
	end
	if #DraggedCuffs<=0 then return end
	
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if not tr.Hit then return end
	
	if IsValid(tr.Entity) then // Pass to another player
		if tr.Entity:IsPlayer() then
			for i=1,#DraggedCuffs do
				if DraggedCuffs[i].Owner==tr.Entity then
					DraggedCuffs[i]:SetKidnapper(nil)
					hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				else
					DraggedCuffs[i]:SetKidnapper(tr.Entity)
					hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
					hook.Call( "OnHandcuffStartDragging", GAMEMODE, tr.Entity, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				end
			end
			return
		elseif tr.Entity.IsHandcuffHook and tr.Entity.TiedHandcuffs then
			for i=1,#DraggedCuffs do
				DraggedCuffs[i]:SetKidnapper(tr.Entity)
				table.insert( tr.Entity.TiedHandcuffs, DraggedCuffs[i] )
				hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
				hook.Call( "OnHandcuffTied", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i], tr.Entity )
			end
			return
		end
	end
	
	local hk = ents.Create("prop_physics")
	hk:SetPos( tr.HitPos + tr.HitNormal )
	local ang = tr.HitNormal:Angle()
	ang:RotateAroundAxis( ang:Up(), -90 )
	hk:SetAngles( ang )
	hk:SetModel( "models/props_c17/TrapPropeller_Lever.mdl" )
	hk:Spawn()
	
	-- hk:SetMoveType( MOVETYPE_NONE )
	if IsValid(tr.Entity) then
		hk:SetParent( tr.Entity )
		hk:SetMoveType( MOVETYPE_VPHYSICS )
	else
		hk:SetMoveType( MOVETYPE_NONE )
	end
	hk:SetCollisionGroup( COLLISION_GROUP_WEAPON )
	
	hk:SetNWBool("Cuffs_TieHook", true)
	hk.IsHandcuffHook = true
	hk.TiedHandcuffs = {}
	
	for i=1,#DraggedCuffs do
		DraggedCuffs[i]:SetKidnapper( hk )
		table.insert( hk.TiedHandcuffs, DraggedCuffs[i] )
		hook.Call( "OnHandcuffStopDragging", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i] )
		hook.Call( "OnHandcuffTied", GAMEMODE, ply, DraggedCuffs[i].Owner, DraggedCuffs[i], hk )
	end
end)

local function DoUntie( ply, ent )
	for i=1,#ent.TiedHandcuffs do
		if not IsValid(ent.TiedHandcuffs[i]) then continue end
		
		ent.TiedHandcuffs[i]:SetKidnapper( ply )
		hook.Call( "OnHandcuffUnTied", GAMEMODE, ply, ent.TiedHandcuffs[i].Owner, ent.TiedHandcuffs[i], ent )
		hook.Call( "OnHandcuffStartDragging", GAMEMODE, ply, ent.TiedHandcuffs[i].Owner, ent.TiedHandcuffs[i] )
	end
	
	ent:Remove()
end
net.Receive( "Cuffs_UntiePlayers", function(_,ply)
	if (not IsValid(ply)) or ply:IsHandcuffed() then return end
	
	local tr = util.TraceLine( {start=ply:EyePos(), endpos=ply:EyePos()+(ply:GetAimVector()*100), filter=ply} )
	if IsValid(tr.Entity) and tr.Entity.IsHandcuffHook and tr.Entity.TiedHandcuffs then
		DoUntie( ply, tr.Entity )
	end
end)
hook.Add( "AllowPlayerPickup", "Cuffs UntieHook", function(ply,ent)
	if IsValid(ent) and ent.IsHandcuffHook and ent.TiedHandcuffs then
		if (not IsValid(ply)) or ply:IsHandcuffed() then return end
		
		DoUntie( ply, ent )
		return false
	end
end)
--PATH addons/____plogs/lua/ui/controls/listview.lua:

-----------------------------------------------------
local PANEL = {}

Derma_Hook(PANEL, 'Paint', 'Paint', 'UIListView')

function PANEL:Init()
	self.Rows = {}
	self:SetPadding(-1)
end

function PANEL:AddRow(value, disabled)
	local row = ui.Create('DButton', function(self)
		self:SetText(tostring(value))
		if (disabled == true) then 
			self:SetDisabled(true)
		end
	end)
	self:AddItem(row)
	self.Rows[#self.Rows + 1] = row
	row.DoClick = function()
		row.Active = true
		if IsValid(self.Selected) then
			self.Selected.Active = false
		end
		self.Selected = row
	end
	return row
end

function PANEL:AddSpacer(value)
	return self:AddRow(value, true)
end

function PANEL:GetSelected()
	return self.Selected
end

vgui.Register('ui_listview', PANEL, 'ui_scrollpanel')
--PATH addons/____plogs/lua/ui/controls/panel.lua:

-----------------------------------------------------
local PANEL = {}

Derma_Hook(PANEL, 'Paint', 'Paint', 'Panel')

function PANEL:DockToFrame()
	local p = self:GetParent()
	local x, y = p:GetDockPos()
	self:SetPos(x, y)
	self:SetSize(p:GetWide() - 10, p:GetTall() - (y + 5))
end

vgui.Register('ui_panel', PANEL, 'Panel')
--PATH addons/uweedadvancedcannabisgrowth/lua/uweed/core/cl_core.lua:
net.Receive("uweed_msg", function()
	UWeed.Core.Msg(net.ReadString())
end)

UWeed.Core.Msg = function(msg)
	chat.AddText(UWeed.Config.PrefixColor, UWeed.Config.Prefix..": ", Color( 255, 255, 255 ), msg)
end

net.Receive("uweed_die", function()
	hook.Remove("RenderScreenspaceEffects", "uWeed_high")
end)
--PATH addons/__main/lua/wos/anim_extension/core/sh_prone_support.lua:
--[[-------------------------------------------------------------------
	wiltOS Prone Compatability:
		Fixes hold types for Prone Mod
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
-------------------------------------------------------------------]]--[[
							  
	Lua Developer: King David
	Contact: http://steamcommunity.com/groups/wiltostech
		
----------------------------------------]]--

wOS.AnimExtension.HoldTypes = wOS.AnimExtension.HoldTypes or {}

hook.Add("prone.Initialized", "wOS.AnimExtension.AddProneTypes", function()
	for holdtype, data in pairs( wOS.AnimExtension.HoldTypes ) do
		local iseq = prone.GetIdleAnimation( data.BaseHoldType ) 
		local mseq = prone.GetMovingAnimation( data.BaseHoldType ) 
		prone.AddNewHoldTypeAnimation( holdtype, mseq, iseq )
	end
end )


--PATH addons/_dance/lua/wos/fortnite/core/cl_core.lua:
--[[-------------------------------------------------------------------
	Fortnite Dancing Client Core:
		Core functions for the client
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2019 ]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
]]--

wOS = wOS or {}
wOS.Fortnite = wOS.Fortnite or {}

hook.Add( "CreateMove", "wOS.Fortnite.TauntCameraMove", function( cmd )

	if not wOS.Fortnite.TauntCamera then return end
	return wOS.Fortnite.TauntCamera:CreateMove( cmd, LocalPlayer(), true )

end )

hook.Add( "CalcView", "wOS.Fortnite.TauntCameraView", function( ply, origin, angles )

	if not wOS.Fortnite.TauntCamera then return end
	return wOS.Fortnite.TauntCamera:CalcView( { origin = origin, angles = angles, fov = fov }, LocalPlayer(), true )

end )
--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/loader.lua:
XENINUI_SERVER = 1
XENINUI_CLIENT = 2
XENINUI_SHARED = 3

do
  local _class_0
  local _base_0 = {
    __name = "XeninUI.Loader",
    setName = function(self, name)
      self.name = name
      return self
    end,
    setAcronym = function(self, acronym)
      self.acronym = acronym
      return self
    end,
    setDirectory = function(self, directory)
      self.directory = directory
      return self
    end,
    setColor = function(self, color)
      self.color = color
      return self
    end,
    getName = function(self)
      return self.name
    end,
    getAcronym = function(self)
      return self.acronym
    end,
    getDirectory = function(self)
      return self.directory
    end,
    getColor = function(self)
      return self.color
    end,
    loadMessage = function(self, path, realm, col)
      if col == nil then col = self:getColor()
      end
      local __laux_type = (istable(path) and path.__type and path:__type()) or type(path)
      assert(__laux_type == "string", "Expected parameter `path` to be type `string` instead of `" .. __laux_type .. "`")
      if (XeninUI.DisableLoadMessages) then return end

      local name = self:getName()

      MsgC(self:getColor(), "[" .. tostring(name), col, " - " .. tostring(realm) .. "] ", color_white, "Loaded ", Color(0, 255, 0), tostring(path) .. "\n")
    end,
    loadFile = function(self, path, realm, func)
      local __laux_type = (istable(path) and path.__type and path:__type()) or type(path)
      assert(__laux_type == "string", "Expected parameter `path` to be type `string` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(realm) and realm.__type and realm:__type()) or type(realm)
      assert(__laux_type == "number", "Expected parameter `realm` to be type `number` instead of `" .. __laux_type .. "`")
      if (!string.EndsWith(path, ".lua")) then path = path .. ".lua"
      end

      local fullPath = self:getDirectory() .. "/" .. path
      if self.loadedFiles[path] then
        if (!self.suppressDuplicates and !XeninUI.DisableLoadMessages) then
          local name = self:getName()
          MsgC(XeninUI.Theme.Red, "[" .. tostring(name) .. "]", color_white, " " .. tostring(fullPath) .. " has already been loaded. Skipping\n")
        end

        return
      end

      local tbl = self.realms[realm]
      self:loadMessage(string.StripExtension(fullPath), tbl.name, tbl.color)
      func = func or tbl.func
      func(self, fullPath)

      self.loadedFiles[path] = true

      return self
    end,
    loadFileOrIgnore = function(self, ...)
      pcall(self:loadFile(...))

      return self
    end,
    load = function(self, dir, realm, recursive, options)
      if recursive == nil then recursive = false
      end
      if options == nil then options = {}
      end
      local __laux_type = (istable(dir) and dir.__type and dir:__type()) or type(dir)
      assert(__laux_type == "string", "Expected parameter `dir` to be type `string` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(realm) and realm.__type and realm:__type()) or type(realm)
      assert(__laux_type == "number" or __laux_type == "table", "Expected parameter `realm` to be type `number|table` instead of `" .. __laux_type .. "`")
      local __laux_type = (istable(recursive) and recursive.__type and recursive:__type()) or type(recursive)
      assert(__laux_type == "boolean", "Expected parameter `recursive` to be type `boolean` instead of `" .. __laux_type .. "`")
      local ignoreFiles = options.ignoreFiles or {}
      local overwriteRealm = options.overwriteRealm or {}
      local path = self:getDirectory()
      if (!string.EndsWith(path, "/")) then path = path .. "/"
      end
      if (!string.EndsWith(dir, "/")) then dir = dir .. "/"
      end

      local realmTbl = isnumber(realm) and self.realms[realm]
      local files, folders = file.Find(path .. dir .. "*", "LUA")
      for i, file in ipairs(files) do
        local name = string.StripExtension(file)
        if (ignoreFiles[name]) then continue end

        local fileRealm = realm
        local func = (realmTbl and realmTbl.func)
        local color = (realmTbl and realmTbl.color)
        local realmName = (realmTbl and realmTbl.name)
        if (istable(realm) or overwriteRealm[name]) then
          local realm = overwriteRealm[name] or realm[name]
          if realm then
            local tbl = self.realms[realm]
            func = tbl.func
            color = tbl.color
            realmName = tbl.name
            fileRealm = realm
          end
        end

        local filePath = dir .. file
        self:loadFile(filePath, fileRealm, func)
      end

      if recursive then
        for i, folder in ipairs(folders) do
          self:load(dir .. folder, realm, recursive, options)
        end
      end

      return self
    end,
    done = function(self)
      local time = math.Round(SysTime() - self.start, 4)
      local files = table.Count(self.loadedFiles)

      MsgC(self:getColor(), "[" .. self:getName() .. "]", color_white, " Finished loading " .. tostring(files) .. " files in " .. tostring(time) .. "s\n")
    end,
    __type = function(self)
      return self.__name
    end
  }
  _base_0.__index = _base_0
  _class_0 = setmetatable({
    __init = function(self, suppressDuplicates)
      self.realms = {
        [1] = {
          color = XeninUI.Theme.Blue,
          name = "SV",
          func = function(self, path)
            if (CLIENT) then return end

            return include(path)
          end
        },
        [2] = {
          color = XeninUI.Theme.Orange,
          name = "CL",
          func = function(self, path)
            if CLIENT then
              return include(path)
            end

            AddCSLuaFile(path)
          end
        },
        [3] = {
          color = XeninUI.Theme.Purple,
          name = "SH",
          func = function(self, path)
            self.realms[XENINUI_CLIENT].func(self, path)
            return self.realms[XENINUI_SERVER].func(self, path)
          end
        }
      }
      self.suppressDuplicates = suppressDuplicates or !XeninUI.Debug
      self.start = SysTime()
      self.loadedFiles = {}
    end,
    __base = _base_0
  }, {
    __index = _base_0,
    __call = function(cls, ...)
      local _self_0 = setmetatable({}, _base_0)
      cls.__init(_self_0, ...)
      return _self_0
    end
  })
  XeninUI.Loader = _class_0
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/essentials.lua:
local blur = Material("pp/blurscreen")
function XeninUI:DrawBlur(panel, amount)
	local x, y = panel:LocalToScreen(0, 0)
	local scrW, scrH = ScrW(), ScrH()
	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat("$blur", (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
	end
end

if CLIENT then
	CreateClientConVar("xenin_hud_blur", 0)
end

function XeninUI:DrawBlurHUD(x, y, w, h, amt)
	local X, Y = 0, 0

	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)

	for i = 1, amt or 5 do
		blur:SetFloat("$blur", (i / 3) * 5)
		blur:Recompute()

		render.UpdateScreenEffectTexture()

		render.SetScissorRect(x, y, x + w, y + h, true)
		surface.DrawTexturedRect(X * -1, Y * -1, ScrW(), ScrH())
		render.SetScissorRect(0, 0, 0, 0, false)
	end
end

function XeninUI:FormatTime(seconds, format)
	if (!seconds) then seconds = 0 end
	local hours = math.floor(seconds / 3600)
	local minutes = math.floor((seconds / 60) % 60)
	seconds = math.floor(seconds % 60)

	return string.format(format, hours, minutes, seconds)
end





local mat_white = Material("vgui/white")

function draw.SimpleLinearGradient(x, y, w, h, startColor, endColor, horizontal)
	draw.LinearGradient(x, y, w, h, {
		{
			offset = 0,
			color = startColor
		},
		{
			offset = 1,
			color = endColor
		}
	}, horizontal)
end





function draw.LinearGradient(x, y, w, h, stops, horizontal)
	if #stops == 0 then
		return
	elseif #stops == 1 then
		surface.SetDrawColor(stops[1].color)
		surface.DrawRect(x, y, w, h)
		return
	end

	table.SortByMember(stops, "offset", true)

	render.SetMaterial(mat_white)
	mesh.Begin(MATERIAL_QUADS, #stops - 1)
	for i = 1, #stops - 1 do
		local offset1 = math.Clamp(stops[i].offset, 0, 1)
		local offset2 = math.Clamp(stops[i + 1].offset, 0, 1)
		if offset1 == offset2 then continue end

		local deltaX1, deltaY1, deltaX2, deltaY2

		local color1 = stops[i].color
		local color2 = stops[i + 1].color

		local r1, g1, b1, a1 = color1.r, color1.g, color1.b, color1.a
		local r2, g2, b2, a2
		local r3, g3, b3, a3 = color2.r, color2.g, color2.b, color2.a
		local r4, g4, b4, a4

		if horizontal then
			r2, g2, b2, a2 = r3, g3, b3, a3
			r4, g4, b4, a4 = r1, g1, b1, a1
			deltaX1 = offset1 * w
			deltaY1 = 0
			deltaX2 = offset2 * w
			deltaY2 = h
		else
			r2, g2, b2, a2 = r1, g1, b1, a1
			r4, g4, b4, a4 = r3, g3, b3, a3
			deltaX1 = 0
			deltaY1 = offset1 * h
			deltaX2 = w
			deltaY2 = offset2 * h
		end

		mesh.Color(r1, g1, b1, a1)
		mesh.Position(Vector(x + deltaX1, y + deltaY1))
		mesh.AdvanceVertex()

		mesh.Color(r2, g2, b2, a2)
		mesh.Position(Vector(x + deltaX2, y + deltaY1))
		mesh.AdvanceVertex()

		mesh.Color(r3, g3, b3, a3)
		mesh.Position(Vector(x + deltaX2, y + deltaY2))
		mesh.AdvanceVertex()

		mesh.Color(r4, g4, b4, a4)
		mesh.Position(Vector(x + deltaX1, y + deltaY2))
		mesh.AdvanceVertex()
	end
	mesh.End()
end

function XeninUI:DrawRotatedTexture(x, y, w, h, angle, cx, cy)
	cx, cy = cx or w * 0.5, cy or w * 0.5
	if (cx == w * 0.5 and cy == w * 0.5) then
		surface.DrawTexturedRectRotated(x, y, w, h, angle)
	else
		local vec = Vector(w * 0.5 - cx, cy - h * 0.5, 0)
		vec:Rotate(Angle(180, angle, -180))
		surface.DrawTexturedRectRotated(x - vec.x, y + vec.y, w, h, angle)
	end
end

function XeninUI:FormatMoney(number, decimals)
	decimals = decimals or 2

	if (number >= 1000000000) then
		return DarkRP.formatMoney(math.Round(number / 1000000000, 2)) .. " bil"
	elseif (number >= 1000000) then
		return DarkRP.formatMoney(math.Round(number / 1000000, 2)) .. " mil"
	elseif (number > 10000) then
		return DarkRP.formatMoney(math.Round(number / 1000, 2)) .. "k"
	end

	return DarkRP.formatMoney(number)
end

function XeninUI:DateToString(date)
	if !date then return "now"end


	local dif = os.ServerTime() - date

	if dif < 60 then
		return "a moment ago"
	elseif dif < (60 * 60) then
		local mins = math.Round(dif / 60, 0)
		local str = mins .. " minute" .. (mins == 1 and "" or "s") .. " ago"

		return str
	elseif dif < (60 * 60) * 24 then
		return os.date("%H:%M", date)
	else
		return os.date("%d/%m/%Y", date)
	end

	return "?"
end

if !XeninUI.__AddedPanelFunctions then
	local PNL = FindMetaTable("Panel")
	local Old_Remove = Old_Remove or PNL.Remove

	function PNL:Remove()
		for k, v in pairs(self.hooks or {}) do
			hook.Remove(v.name, k)
		end

		for k, v in pairs(self.timers or {}) do
			timer.Remove(k)
		end

		Old_Remove(self)
	end

	function PNL:AddHook(name, identifier, func)
		identifier = identifier .. " - " .. CurTime()

		self.hooks = self.hooks or {}
		self.hooks[identifier] = {
			name = name,
			func = function(...)
				if IsValid(self) then
					return func(self, ...)
				end
			end
		}

		hook.Add(name, identifier, self.hooks[identifier].func)
	end

	function PNL:GetHooks()
		return self.hooks or {}
	end

	function PNL:AddTimer(identifier, delay, rep, func)
		self.timers = self.timers or {}
		self.timers[identifier] = true

		timer.Create(identifier, delay, rep, function(...)
			if IsValid(self) then
				func(self, ...)
			end
		end)
	end

	function PNL:GetTimers()
		return self.timers or {}
	end

	function PNL:LerpAlpha(alpha, time, callback)
		callback = callback or function() end

		self.Alpha = self.Alpha or 0

		local oldThink = self.Think
		self.Think = function(pnl)
			if oldThink then oldThink(pnl)end


			self:SetAlpha(pnl.Alpha >= 250 and 255 or pnl.Alpha)
		end
		self:Lerp("Alpha", alpha, time, function()
			self.Think = oldThink
			callback(self)
		end)
	end

	XeninUI.__AddedPanelFunctions = true
end

local matLoading = Material("xenin/loading.png", "smooth")
function XeninUI:DrawLoadingCircle(x, y, size, col)
	surface.SetMaterial(matLoading)
	surface.SetDrawColor(col or ColorAlpha(XeninUI.Theme.Accent, 100))
	XeninUI:DrawRotatedTexture(x, y, size, size, ((ct or CurTime()) % 360) * -100)
end

local function toLines(text, font, mWidth)
	surface.SetFont(font)

	local buffer = {}
	local nLines = {}

	for word in string.gmatch(text, "%S+") do
		local w, h = surface.GetTextSize(table.concat(buffer, " ") .. " " .. word)
		if w > mWidth then
			table.insert(nLines, table.concat(buffer, " "))
			buffer = {}
		end
		table.insert(buffer, word)
	end

	if #buffer > 0 then
		table.insert(nLines, table.concat(buffer, " "))
	end

	return nLines
end

local function drawMultiLine(text, font, mWidth, spacing, x, y, color, alignX, alignY, sAmt, sAlpha)
	local mLines = toLines(text, font, mWidth)
	local amt = #mLines - 1
	for i, line in pairs(mLines) do
		if (sAmt and sAlpha) then
			XeninUI:DrawShadowText(line, font, x, y + (i - 1) * spacing - amt * spacing * 0.5, color, alignX, alignY, sAmt, sAlpha)
		else
			draw.SimpleText(line, font, x, y + (i - 1) * spacing - amt * spacing / (alignY == TEXT_ALIGN_CENTER and 2 or 1), color, alignX, alignY)
		end
	end

	return amt * spacing
end

XeninUI.DrawMultiLine = drawMultiLine

local matCredit = Material("xenin/credit_small.png", "smooth")
function XeninUI:DrawCreditsText(text, font, x, y, col, xAlign, yAlign, textY, iconColor, spacing)
	textY = textY or 1
	iconColor = iconColor or color_white
	spacing = spacing or 4

	surface.SetFont(font)
	local tw, th = surface.GetTextSize(text)
	local size = th
	if (xAlign == TEXT_ALIGN_LEFT) then
		surface.SetMaterial(matCredit)
		surface.SetDrawColor(iconColor)
		surface.DrawTexturedRect(x, y, size, size)

		draw.SimpleText(text, font, x + size + spacing, y + textY, col, xAlign, yAlign)
	elseif (xAlign == TEXT_ALIGN_CENTER) then
		x = x + size * 0.5 + 2

		surface.SetMaterial(matCredit)
		surface.SetDrawColor(iconColor)
		surface.DrawTexturedRect(x - tw * 0.5 - size - spacing, y, size, size)

		draw.SimpleText(text, font, x, y + textY, col, xAlign, yAlign)
	elseif (xAlign == TEXT_ALIGN_RIGHT) then
		x = x + size * 0.5 + 2

		surface.SetMaterial(matCredit)
		surface.SetDrawColor(iconColor)
		surface.DrawTexturedRect(x - tw - size - spacing, y, size, size)

		draw.SimpleText(text, font, x, y + textY, col, xAlign, yAlign)
	end
end


function XeninUI:DrawArc(x, y, ang, p, rad, color, seg)
	seg = seg or 80
	ang = (-ang) + 180
	local circle = {}

	table.insert(circle, {
		x = x,
		y = y
	})
	for i = 0, seg do
		local a = math.rad((i / seg) * -p + ang)
		table.insert(circle, {
			x = x + math.sin(a) * rad,
			y = y + math.cos(a) * rad
		})
	end

	surface.SetDrawColor(color)
	draw.NoTexture()
	surface.DrawPoly(circle)
end

function XeninUI:CalculateArc(x, y, ang, p, rad, seg)
	seg = seg or 80
	ang = (-ang) + 180
	local circle = {}

	table.insert(circle, {
		x = x,
		y = y
	})
	for i = 0, seg do
		local a = math.rad((i / seg) * -p + ang)
		table.insert(circle, {
			x = x + math.sin(a) * rad,
			y = y + math.cos(a) * rad
		})
	end

	return circle
end

function XeninUI:DrawCachedArc(circle, color)
	surface.SetDrawColor(color)
	draw.NoTexture()
	surface.DrawPoly(circle)
end


function XeninUI:DrawRoundedBoxEx(radius, x, y, w, h, col, tl, tr, bl, br)

	x = math.floor(x)
	y = math.floor(y)
	w = math.floor(w)
	h = math.floor(h)
	radius = math.Clamp(math.floor(radius), 0, math.min(h * 0.5, w * 0.5))

	if (radius == 0) then
		surface.SetDrawColor(col)
		surface.DrawRect(x, y, w, h)

		return
	end


	surface.SetDrawColor(col)
	surface.DrawRect(x + radius, y, w - radius * 2, radius)
	surface.DrawRect(x, y + radius, w, h - radius * 2)
	surface.DrawRect(x + radius, y + h - radius, w - radius * 2, radius)


	if tl then
		XeninUI:DrawArc(x + radius, y + radius, 270, 90, radius, col, radius)
	else
		surface.SetDrawColor(col)
		surface.DrawRect(x, y, radius, radius)
	end

	if tr then
		XeninUI:DrawArc(x + w - radius, y + radius, 0, 90, radius, col, radius)
	else
		surface.SetDrawColor(col)
		surface.DrawRect(x + w - radius, y, radius, radius)
	end

	if bl then
		XeninUI:DrawArc(x + radius, y + h - radius, 180, 90, radius, col, radius)
	else
		surface.SetDrawColor(col)
		surface.DrawRect(x, y + h - radius, radius, radius)
	end

	if br then
		XeninUI:DrawArc(x + w - radius, y + h - radius, 90, 90, radius, col, radius)
	else
		surface.SetDrawColor(col)
		surface.DrawRect(x + w - radius, y + h - radius, radius, radius)
	end
end

function XeninUI:DrawRoundedBox(radius, x, y, w, h, col)
	XeninUI:DrawRoundedBoxEx(radius, x, y, w, h, col, true, true, true, true)
end





function XeninUI:MaskInverse(maskFn, drawFn, pixel)
	pixel = pixel or 1

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(pixel)

	maskFn()

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(pixel - 1)

	drawFn()

	render.SetStencilEnable(false)
	render.ClearStencil()
end

function XeninUI:Mask(maskFn, drawFn, pixel)
	pixel = pixel or 1

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_KEEP)
	render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(pixel)

	maskFn()

	render.SetStencilFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(pixel)

	drawFn()

	render.SetStencilEnable(false)
	render.ClearStencil()
end

XeninUI:CreateFont("XeninUI.NPC.Overhead", 160)
function XeninUI:DrawNPCOverhead(npc, tbl)
	local alpha = tbl.alpha or 255
	local text = tbl.text or npc.PrintName or "NO NAME"
	local icon = tbl.icon
	local hover = tbl.sin
	local xOffset = tbl.xOffset or 0
	local textOffset = tbl.textOffset or 0
	local col = tbl.color or XeninUI.Theme.Accent
	col = ColorAlpha(col, alpha)

	local str = text
	surface.SetFont("XeninUI.NPC.Overhead")
	local width = surface.GetTextSize(str)
	width = width + 40
	if icon then
		width = width + (64 * 3)
	else
		width = width + 64
	end

	local center = 900 * 0.5
	local x = -width * 0.5 - 30 + (xOffset or 0)
	local y = 220
	local sin = math.sin(CurTime() * 2)
	if hover then
		y = math.Round(y + (sin * 30))
	end
	local h = 64 * 3

	local isLookingAt
	if (alpha > 0.5) then
		isLookingAt = LocalPlayer():GetEyeTrace().Entity == npc
	end
	npc.overheadAlpha = npc.overheadAlpha or 0
	if isLookingAt then
		npc.overheadAlpha = math.Clamp(npc.overheadAlpha + (FrameTime() * 3), 0, 1)
	else
		npc.overheadAlpha = math.Clamp(npc.overheadAlpha - (FrameTime() * 3), 0, 1)
	end

	local darkerColor = Color(col.r * 0.5, col.g * 0.5, col.b * 0.5)
	XeninUI:DrawRoundedBox(64, x, y, width, h, ColorAlpha(darkerColor, npc.overheadAlpha * 255))
	XeninUI:DrawRoundedBox(64, x + 8, y + 8, width - 16, h - 16, ColorAlpha(col, npc.overheadAlpha * 255))



	local textX = !icon and (width * 0.5) or h
	XeninUI:DrawShadowText(str, "XeninUI.NPC.Overhead", x + textX + textOffset, h * 0.5 + y - 10, Color(225, 225, 225, alpha), icon and TEXT_ALIGN_LEFT or TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 5, 125)

	if icon then
		surface.SetDrawColor(255, 255, 255, alpha)
		surface.SetMaterial(icon)
		local margin = tbl.icon_margin or tbl.iconMargin or 30
		surface.DrawTexturedRect(x + margin, y + margin, h - (margin * 2), h - (margin * 2))
	end





end

function XeninUI:DrawShadowText(text, font, x, y, col, xAlign, yAlign, amt, shadow)
	for i = 1, amt do
		draw.SimpleText(text, font, x + i, y + i, Color(0, 0, 0, i * (shadow or 50)), xAlign, yAlign)
	end

	draw.SimpleText(text, font, x, y, col, xAlign, yAlign)
end

function XeninUI:DrawOutlinedText(str, font, x, y, col, xAlign, yAlign, outlineCol, thickness)
	thickness = thickness or 1

	for i = 1, thickness do
		draw.SimpleText(str, font, x - thickness, y - thickness, outlineCol or color_black, xAlign, yAlign)
		draw.SimpleText(str, font, x - thickness, y + thickness, outlineCol or color_black, xAlign, yAlign)
		draw.SimpleText(str, font, x + thickness, y - thickness, outlineCol or color_black, xAlign, yAlign)
		draw.SimpleText(str, font, x + thickness, y + thickness, outlineCol or color_black, xAlign, yAlign)
	end

	draw.SimpleText(str, font, x, y, col, xAlign, yAlign)
end

function XeninUI:DrawHollowArc(cx, cy, radius, thickness, startang, endang, roughness, color)
	surface.SetDrawColor(color)

	local arc = self:CacheHollowArc(cx, cy, radius, thickness, startang, endang, roughness)

	for i, vertex in pairs(arc) do
		surface.DrawPoly(vertex)
	end
end

function XeninUI:CacheHollowArc(cx, cy, radius, thickness, startang, endang, roughness)
	local triarc = {}



	local roughness = math.max(roughness or 1, 1)
	local step = roughness


	local startang, endang = startang or 0, endang or 0

	if startang > endang then
		step = math.abs(step) * -1
	end


	local inner = {}
	local r = radius - thickness
	for deg = startang, endang, step do
		local rad = math.rad(deg)

		local ox, oy = cx + (math.cos(rad) * r), cy + (-math.sin(rad) * r)
		table.insert(inner, {
			x = ox,
			y = oy,
			u = (ox - cx) / radius + .5,
			v = (oy - cy) / radius + .5
		})
	end


	local outer = {}
	for deg = startang, endang, step do
		local rad = math.rad(deg)

		local ox, oy = cx + (math.cos(rad) * radius), cy + (-math.sin(rad) * radius)
		table.insert(outer, {
			x = ox,
			y = oy,
			u = (ox - cx) / radius + .5,
			v = (oy - cy) / radius + .5
		})
	end


	for tri = 1, #inner * 2 do
		local p1, p2, p3
		p1 = outer[math.floor(tri * 0.5) + 1]
		p3 = inner[math.floor((tri + 1) * 0.5) + 1]
		if tri % 2 == 0 then
			p2 = outer[math.floor((tri + 1) * 0.5)]
		else
			p2 = inner[math.floor((tri + 1) * 0.5)]
		end

		table.insert(triarc, {
			p1,
			p2,
			p3
		})
	end


	return triarc
end


function XeninUI:DualText(title, subtitle, x, y, w, h)
	x = x or 0
	y = y or 0

	surface.SetFont(title[2])
	local tW, tH = surface.GetTextSize(title[1])

	surface.SetFont(subtitle[2])
	local sW, sH = surface.GetTextSize(subtitle[1])

	XeninUI:DrawShadowText(title[1], title[2], x, y + (h * 0.5 - sH * 0.5), title[3], title[4], TEXT_ALIGN_CENTER, title[5], title[6])
	XeninUI:DrawShadowText(subtitle[1], subtitle[2], x, y + (h * 0.5 + tH * 0.5), subtitle[3], subtitle[4], TEXT_ALIGN_CENTER, subtitle[5], subtitle[6])
end

function XeninUI:DrawIconRotated(x, y, w, h, rotation, pnl, col, loadCol)
	col = col or color_white
	loadCol = loadCol or XeninUI.Theme.Accent

	if (pnl.Icon and type(pnl.Icon) == "IMaterial") then
		surface.SetMaterial(pnl.Icon)
		surface.SetDrawColor(col)
		XeninUI:DrawRotatedTexture(x, y, w, h, rotation)
	elseif (pnl.Icon != nil) then
		XeninUI:DrawLoadingCircle(h, h, h, loadCol)
	end
end

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/libs/configurator/ui/entities/row.lua:
local PANEL = {}

function PANEL:Init()
  self:SetText("")

  self.BackgroundColor = XeninUI.Theme.Navbar
  self.Name = "Common"
  self.Color = Color(180, 180, 180)
  self.Rotation = 0
  self.ArrowColor = self.Color
  self.State = false

  self.Delete = self:Add("DButton")
  self.Delete:SetVisible(false)
  self.Delete:SetText("")
  self.Delete.Color = ColorAlpha(XeninUI.Theme.Red, 150)
  self.Delete.Paint = function(pnl, w, h)
    XeninUI:DrawRoundedBox(6, 0, 0, w, h, pnl.Color)

    surface.SetDrawColor(color_white)
    surface.SetMaterial(XeninUI.Materials.CloseButton)
    local margin = 8
    surface.DrawTexturedRect(margin, margin, w - (margin * 2), h - (margin * 2))
  end
  self.Delete.DoClick = function(pnl)
    local shiftDown = input.IsKeyDown(KEY_LSHIFT)
    if shiftDown then
      self.Entity:delete(true)
      self:Remove()
    else
      XeninUI:SimpleQuery("Delete", "Are you sure you want to delete this?", "Yes, delete", function()
        self.Entity:delete(true)
        self:Remove()
      end, "No", function()
        if (self:IsHovered()) then return end

        self.Delete:SetVisible(false)
      end)
    end
  end

  XeninUI:DownloadIcon(self, "2QGKAd6")
end

function PANEL:PerformLayout(w, h)
  self.Delete:SetPos(8, 8)
  local size = 48 - 16
  self.Delete:SetSize(size, size)
end

function PANEL:SetEntity(entity)
  self.Entity = entity
  self.Id = entity:getId()
  self.Name = entity.transformName and entity:transformName(entity:getName()) or entity:getName()
  if istable(self.Name) then
    local tbl = self.Name
    self.Name = tbl[1]
  end
  self.Color = entity.getColor and entity:getColor() or color_white
  if (type(self.Color) != "Color") then
    self.Color = color_white
  end

  timer.Simple(0.2, function()
    if (!IsValid(self)) then return end
    if (self.Id != 1) then return end


  end)
end

function PANEL:Paint(w, h)
  local name = self.Name
  local font = "Xenin.Configurator.Admin.Panel.Setting"
  if (!name or name == "") then
    name = "Unnamed"
    font = "Xenin.Configurator.Admin.Panel.Setting.Italic"
  end

  local x = self.Delete:IsVisible() and 8 + self.Delete:GetWide() + 8 or 8
  draw.SimpleText(name, font, x, 48 * 0.5, self.Color, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

  surface.SetDrawColor(100, 100, 100)
  surface.DrawLine(0, 48 - 1, w, 48 - 1)

  local size = 48 / 3
  XeninUI:DrawIconRotated(w - size - 8, size + size * 0.5, size, size, self.Rotation, self, self.ArrowColor)
end

function PANEL:CreateSettings()
  self.Settings = self:Add("Xenin.Configurator.Admin.Entity.Row.Settings")
  self.Settings:AddSettings(self.Entity)
  self.Settings:SetTall(0)
  self.Settings.GetChildSize = function(pnl)
    local height = 0
    local size = 0
    for i, v in ipairs(pnl.Settings) do
      if (!v:IsVisible()) then continue end

      size = size + 1
      height = height + v:GetTall()
    end
    height = height - (size * 3)

    return height
  end
end

function PANEL:SetExpanded(state)
  self:Lerp("Rotation", state and 180 or 0, 0.4)

  if (!IsValid(self.Settings)) then
    self:CreateSettings()
  end

  local size = self.Settings:GetChildSize()
  self.Settings:LerpHeight(state and size or 0, 0.4)
end

function PANEL:DoClick()
  self.State = !self.State
  self:SetExpanded(self.State)
end

function PANEL:OnCursorEntered()
  if (!self.Delete:IsHovered()) then
    self.Delete:SetVisible(true)
  end

  self:LerpColor("ArrowColor", color_white)
end

function PANEL:OnCursorExited()
  if (!self.Delete:IsHovered()) then
    self.Delete:SetVisible(false)
  end

  if (self.State) then return end

  self:LerpColor("ArrowColor", Color(180, 180, 180))
end

vgui.Register("Xenin.Configurator.Admin.Entity.Row", PANEL, "DButton")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/button.lua:
local PANEL = {}

AccessorFunc(PANEL, "roundness", "Roundness", FORCE_NUMBER)
AccessorFunc(PANEL, "disabled", "Disabled")
AccessorFunc(PANEL, "loading_size", "LoadingImageSizeSub", FORCE_NUMBER)
AccessorFunc(PANEL, "awaiting_response", "AwaitingResponse", FORCE_BOOL)
AccessorFunc(PANEL, "loading_color", "LoadingColor")
AccessorFunc(PANEL, "old_text", "OldText")
AccessorFunc(PANEL, "outline", "Outline", FORCE_NUMBER)

AccessorFunc(PANEL, "clr_background_cur", "BackgroundColor")
AccessorFunc(PANEL, "clr_background_on", "BackgroundColorOn")
AccessorFunc(PANEL, "clr_background_off", "BackgroundColorOff")

AccessorFunc(PANEL, "clr_text_cur", "TextColorCur")
AccessorFunc(PANEL, "clr_text_on", "TextColorOn")
AccessorFunc(PANEL, "clr_text_off", "TextColorOff")

AccessorFunc(PANEL, "enable_shadow", "EnableShadow")
AccessorFunc(PANEL, "shadow_alpha", "ShadowAlpha")
AccessorFunc(PANEL, "shadow_alpha_on", "ShadowAlphaOn")
AccessorFunc(PANEL, "shadow_alpha_off", "ShadowAlphaOff")

XeninUI:CreateFont("XeninUI.Checkbox", 16)
XeninUI:CreateFont("XeninUI.Checkbox.Small", 15)

function PANEL:Init()
	self:SetText("")
	self:SetLoadingImageSizeSub(16)
	self:SetEnableShadow(true)
	self:SetShadowAlphaOn(150)
	self:SetShadowAlphaOff(0)
	self:SetOutline(0)
end

function PANEL:SetAwaitingResponse(b)
	self.awaiting_response = b

	if !b then
		self:SetText(self:GetOldText())
	end
end

function PANEL:Paint(w, h)
	if !self.DidPostInit then return end

	self:SetTextColor(self:GetTextColorCur())

	local r = self:GetRoundness()
	if self:GetEnableShadow() then
		local x, y = self:LocalToScreen(0, 0)
		BSHADOWS.BeginShadow()
		local sub = self:GetOutline()
		if sub > 0 then
			draw.RoundedBox(r or h * 0.5, x, y, w, h, self:GetTextColorCur())
		end
		draw.RoundedBox(r or h * 0.5, x + sub, y + sub, w - sub * 2, h - sub * 2, self:GetBackgroundColor())
		BSHADOWS.EndShadow(2, 2, 2, self:GetShadowAlpha(), 0, 0)
	else
		local sub = self:GetOutline()
		if sub > 0 then
			draw.RoundedBox(r or h * 0.5, 0, 0, w, h, self:GetTextColorCur())
		end
		draw.RoundedBox(r or h * 0.5, 0 + sub, 0 + sub, w - sub * 2, h - sub * 2, self:GetBackgroundColor())
	end

	if self:GetAwaitingResponse() then
		self:SetText("")
		XeninUI:DrawLoadingCircle(w * 0.5, h * 0.5, h - self:GetLoadingImageSizeSub(), self:GetLoadingColor() or self:GetTextColor())
	end
end

function PANEL:RefreshColors(anim)
	for k, v in pairs(self.m_AnimList or {}) do
		if v.OnEnd then v:OnEnd(self)end
		self.m_AnimList[k] = nil
	end

	if self:IsHovered() then
		if anim then
			self:LerpColor("clr_text_cur", self:GetTextColorOn())
			self:LerpColor("clr_background_cur", self:GetBackgroundColorOn())
		else
			self:SetTextColorCur(self:GetTextColorOn())
			self:SetBackgroundColor(self:GetBackgroundColorOn())
		end
	else
		if anim then
			self:LerpColor("clr_text_cur", self:GetTextColorOff())
			self:LerpColor("clr_background_cur", self:GetBackgroundColorOff())
		else
			self:SetTextColorCur(self:GetTextColorOff())
			self:SetBackgroundColor(self:GetBackgroundColorOff())
		end
	end
end

function PANEL:OnCursorEntered()
	if !self.DidPostInit then return end

	if self:GetDisabled() then
		self:SetCursor("no")
		return
	else
		self:SetCursor("hand")
	end

	self:Lerp("shadow_alpha", self:GetShadowAlphaOn())
	self:LerpColor("clr_text_cur", self:GetTextColorOn())
	self:LerpColor("clr_background_cur", self:GetBackgroundColorOn())
end

function PANEL:OnCursorExited()
	if self:GetDisabled() or !self.DidPostInit then return end

	self:Lerp("shadow_alpha", self:GetShadowAlphaOff())
	self:LerpColor("clr_text_cur", self:GetTextColorOff())
	self:LerpColor("clr_background_cur", self:GetBackgroundColorOff())
end

function PANEL:PostInit()
	self:SetOldText(self:GetText())
	self:SetShadowAlpha(self:GetShadowAlphaOff())
	self:SetBackgroundColor(self:GetBackgroundColorOff())
	self:SetTextColorCur(self:GetTextColorOff())

	self.DidPostInit = true
end

vgui.Register("XeninUI.Button", PANEL, "DButton")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/button_v2.lua:
local PANEL = {}




AccessorFunc(PANEL, "_cStartCol", "StartColor")
AccessorFunc(PANEL, "_cEndcol", "EndColor")
AccessorFunc(PANEL, "_iRoundness", "Roundness")
AccessorFunc(PANEL, "_iOffsetX", "XOffset", FORCE_NUMBER)
AccessorFunc(PANEL, "_iOffsetY", "YOffset", FORCE_NUMBER)
AccessorFunc(PANEL, "_sIcon", "Icon")
AccessorFunc(PANEL, "_cHoverColor", "HoverColor")
AccessorFunc(PANEL, "_cSolidColor", "SolidColor")
AccessorFunc(PANEL, "_cTextColor", "TextColor")
AccessorFunc(PANEL, "_iIconSize", "IconSize", FORCE_NUMBER)


XeninUI:CreateFont("XeninUI.GradientButton.Default", 24)

function PANEL:SetSolidColor(col)
	self.SolidColorStatic = col

	self._cSolidColor = col
end

function PANEL:Init()
	self:SetText("")
	self:SetSolidColor(Color(158, 53, 210))
	self:SetStartColor(Color(158, 53, 210))
	self:SetEndColor(Color(109, 77, 213))
	self:SetFont("XeninUI.GradientButton.Default")
	self:SetRoundness(self:GetTall())
	self:SetContentAlignment(5)
	self:SetXOffset(0)
	self:SetYOffset(0)
	self:SetGradient(false)
	self:SetTextColor(color_white)

	self.ButtonAlpha = 255

	self.SetText = function(self, text)
		self._sText = text
	end
	self.GetText = function(self)
		return self._sText
	end
end

function PANEL:SizeToContentsX(padding)
	if padding == nil then padding = 0
	end
	surface.SetFont(self:GetFont())
	local tw = surface.GetTextSize(self:GetText())

	self:SetWide(tw + padding)
end

function PANEL:IsGradient()
	return self._bUniform
end

function PANEL:SetGradient(bBool)
	self._bUniform = bBool
end

function PANEL:RoundFromTallness()
	self:SetRoundness(self:GetTall())
end

function PANEL:SetContentAlignment(iInteger)
	self._iHorizontalAlignment = (iInteger - 1) % 3
	self._iVerticalAlignment = (iInteger == 5 or iInteger == 6 or iInteger == 4) and 1 or (iInteger == 1 or iInteger == 2 or iInteger == 3) and 4 or 3

	self._bTopAligned = self._iVerticalAlignment == 3
	self._bBottomAligned = self._iVerticalAlignment == 4

	self._bLeftAligned = self._iHorizontalAlignment == 0
	self._bRightAligned = self._iHorizontalAlignment == 2
end

local ShadowColor = Color(0, 0, 0, 50)
function PANEL:Paint(w, h)
	local aX, aY = self:LocalToScreen()
	local cStartColor, cEndColor, cColor = ColorAlpha(self:GetStartColor(), self.ButtonAlpha), ColorAlpha(self:GetEndColor(), self.ButtonAlpha), ColorAlpha(self:GetSolidColor(), self.ButtonAlpha)

	if self:GetRoundness() > 0 then
		XeninUI:Mask(function()
			XeninUI:DrawRoundedBox(self:GetRoundness(), 0, 0, w, h, color_white)
		end, function()
			if self:IsGradient() then
				draw.SimpleLinearGradient(aX, aY, w, h, cStartColor, cEndColor, true)
			else
				surface.SetDrawColor(cColor)
				surface.DrawRect(0, 0, w, h)
			end
		end)
	else
		if self:IsGradient() then
			draw.SimpleLinearGradient(aX, aY, w, h, cStartColor, cEndColor, true)
		else
			surface.SetDrawColor(cColor)
			surface.DrawRect(0, 0, w, h)
		end
	end

	local iconID = self:GetIcon()
	local icon = iconID and XeninUI:GetIcon(iconID) or false
	local size = 0
	if icon then
		size = self:GetIconSize() or h * 0.8
		if (icon != "Loading") then
			surface.SetMaterial(icon)

			surface.SetDrawColor(ShadowColor)
			surface.DrawTexturedRect(5 + 1, h * 0.5 - Size * 0.5 + 2, Size, Size)

			surface.SetDrawColor(iconColor or Color(235, 235, 235))
			surface.DrawTexturedRect(5, h * 0.5 - Size * 0.5 + 1, Size, Size)
		else
			XeninUI:DrawLoadingCircle(h * 0.5, h * 0.5, h - 24, XeninUI.Theme.Blue)
		end
	end
	local XOffset, YOffset = self:GetXOffset() + (self._bLeftAligned and Size or 0), self:GetYOffset()

	draw.SimpleText(self:GetText(), self:GetFont(), self._bLeftAligned and XOffset or self._bRightAligned and w + XOffset or w * 0.5 + XOffset, self._bTopAligned and YOffset or self._bBottomAligned and (h + YOffset) or h * 0.5 + YOffset, self:GetTextColor(), self._iHorizontalAlignment, self._iVerticalAlignment)
end

function PANEL:OnCursorEntered()
	if (self:GetHoverColor() and !self:IsGradient()) then
		self:LerpColor("_cSolidColor", self:GetHoverColor())
	else
		self:Lerp("ButtonAlpha", 127.5)
	end
end

function PANEL:OnCursorExited()
	if (self:GetHoverColor() and !self:IsGradient()) then
		self:LerpColor("_cSolidColor", self.SolidColorStatic)
	else
		self:Lerp("ButtonAlpha", 255)
	end
end
vgui.Register("XeninUI.ButtonV2", PANEL, "DButton")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/frame.lua:
XeninUI:CreateFont("XeninUI.Frame.Title", 28)

local PANEL = {}

function PANEL:Init()
	self.top = vgui.Create("Panel", self)
	self.top:Dock(TOP)
	self.top.Paint = function(pnl, w, h)
		draw.RoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Primary, true, true, false, false)
	end

	if XeninUI.Branding then
		local isMat = type(XeninUI.Branding) == "IMaterial"

		self.branding = vgui.Create("Panel", self.top)
		self.branding:Dock(LEFT)
		if (!isMat) then
			XeninUI:DownloadIcon(self.branding, XeninUI.Branding)
		end
		self.branding.Paint = function(pnl, w, h)
			if isMat then
				surface.SetDrawColor(color_white)
				surface.SetMaterial(XeninUI.Branding)
				surface.DrawTexturedRect(4, 4, w - 8, h - 8)
			else
				XeninUI:DrawIcon(4, 4, w - 8, h - 8, pnl)
			end
		end
	end

	self.title = vgui.Create("DLabel", self.top)
	self.title:Dock(LEFT)
	self.title:DockMargin(IsValid(self.branding) and 0 or 10, 0, 0, 0)
	self.title:SetFont("XeninUI.Frame.Title")
	self.title:SetTextColor(color_white)

	self.closeBtn = vgui.Create("DButton", self.top)
	self.closeBtn:Dock(RIGHT)
	self.closeBtn:SetText("")
	self.closeBtn.CloseButton = Color(195, 195, 195)
	self.closeBtn.Alpha = 0
	self.closeBtn.DoClick = function(pnl)
		self:Remove()
	end
	self.closeBtn.Paint = function(pnl, w, h)
		draw.RoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Red, pnl.Alpha))

		surface.SetDrawColor(pnl.CloseButton)
		surface.SetMaterial(XeninUI.Materials.CloseButton)
		surface.DrawTexturedRect(12, 12, w - 24, h - 24)
	end
	self.closeBtn.OnCursorEntered = function(pnl)
		pnl:Lerp("Alpha", 255)
		pnl:LerpColor("CloseButton", Color(255, 255, 255))
	end
	self.closeBtn.OnCursorExited = function(pnl)
		pnl:Lerp("Alpha", 0)
		pnl:LerpColor("CloseButton", Color(195, 195, 195))
	end
end

function PANEL:SetTitle(str)
	self.title:SetText(str)
	self.title:SizeToContents()
end

function PANEL:PerformLayout(w, h)
	self.top:SetTall(40)

	if IsValid(self.branding) then
		self.branding:SetWide(self.top:GetTall())
	end

	self.closeBtn:SetWide(self.top:GetTall())
end

function PANEL:Paint(w, h)
	local x, y = self:LocalToScreen()

	BSHADOWS.BeginShadow()
	draw.RoundedBox(6, x, y, w, h, XeninUI.Theme.Background)
	BSHADOWS.EndShadow(1, 2, 2, 255, 0, 0)
end

function PANEL:ShowCloseButton(show)
	self.closeBtn:SetVisible(show)
end

vgui.Register("XeninUI.Frame", PANEL, "EditablePanel")

concommand.Add("xeninui", function()
	local frame = vgui.Create("XeninUI.Frame")
	frame:SetSize(960, 720)
	frame:Center()
	frame:MakePopup()
	frame:SetTitle("Party")
end)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/scrollpanel.lua:
local PANEL = {}

function PANEL:Init()
  self.VBar:SetWide(12)
  self.VBar:SetHideButtons(true)

  self.VBar.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, ColorAlpha(XeninUI.Theme.Navbar, 150))
  end
  self.VBar.btnGrip.Paint = function(pnl, w, h)
    draw.RoundedBox(6, 0, 0, w, h, XeninUI.Theme.Primary)
  end
end

function PANEL:HideScrollBar(hide)
  self.VBar:SetWide((hide and 0) or 12)
end

vgui.Register("XeninUI.ScrollPanel", PANEL, "DScrollPanel")

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/sidebar_v2.lua:
local PANEL = {}
AccessorFunc(PANEL, "m_body", "Body")

XeninUI:CreateFont("XeninUI.SidebarV2.Name", 20)
XeninUI:CreateFont("XeninUI.SidebarV2.Desc", 16)
XeninUI:CreateFont("XeninUI.SidebarV2.DescSmall", 14)

function PANEL:Init()
  self.Scroll = self:Add("XeninUI.ScrollPanel")
  self.Scroll:Dock(FILL)
  self.Scroll.VBar:SetWide(0)

  self.Sidebar = {}
  self.Panels = {}
end

function PANEL:CreateDivider(startCol, endCol)
  startCol = startCol or Color(164, 43, 115)
  endCol = endCol or Color(198, 66, 110)

  local divider = self.Scroll:Add("DPanel")
  divider:Dock(TOP)
  divider:SetTall(10)
  divider.Paint = function(pnl, w, h)
    local aX, aY = pnl:LocalToScreen()

    draw.SimpleLinearGradient(aX + 4, aY + 4, w - 8, h - 8, startCol, endCol, true)
  end
end

function PANEL:CreatePanel(name, desc, panelClass, icon, tbl)
  tbl = tbl or {}
  tbl.colors = tbl.colors or {}
  local startCol = tbl.colors[1] or Color(158, 53, 210)
  local endCol = tbl.colors[2] or Color(109, 77, 213)

  local btn = self.Scroll:Add("DButton")
  btn:Dock(TOP)
  btn.Name = name
  btn.Desc = desc or ""
  btn.Icon = icon
  btn.Tbl = tbl
  btn.PanelClass = panelClass
  btn:SetTall(tbl.Height or 64)
  btn:SetText("")
  btn.GradientAlpha = 0
  btn.SmallFont = btn.Desc:len() > 20
  btn.DescFont = !btn.SmallFont and "XeninUI.SidebarV2.Desc" or "XeninUI.SidebarV2.DescSmall"
  XeninUI:DownloadIcon(btn, icon)
  btn.Paint = function(pnl, w, h)
    XeninUI:Mask(function()
      XeninUI:DrawRoundedBox(0, 0, 0, w, h, color_white)
    end, function()
      local aX, aY = pnl:LocalToScreen()
      draw.SimpleLinearGradient(aX, aY, w, h, ColorAlpha(startCol, pnl.GradientAlpha), ColorAlpha(endCol, pnl.GradientAlpha), true)
    end)

    local x = icon and h or 12
    XeninUI:DrawIcon(16, 16, h - 32, h - 32, pnl)

    XeninUI:DrawShadowText(name, "XeninUI.SidebarV2.Name", x, h * 0.5 + (pnl.SmallFont and 1 or 0), color_white, TEXT_ALIGN_LEFT, desc and TEXT_ALIGN_BOTTOM or TEXT_ALIGN_CENTER, 1, 125)
    if desc then
      XeninUI:DrawShadowText(desc, pnl.DescFont, x, h * 0.5 + (pnl.SmallFont and 1 or 0), Color(171, 171, 171), TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, 125)
    end
  end
  btn.OnCursorEntered = function(pnl)
    if (self.Active == btn.Id) then return end

    pnl:Lerp("GradientAlpha", 127.5)
  end
  btn.OnCursorExited = function(pnl)
    if (self.Active == btn.Id) then return end

    pnl:Lerp("GradientAlpha", 0)
  end
  btn.DoClick = function(pnl)
    self:SetActive(pnl.Id)
  end

  if (!IsValid(self:GetBody())) then
    Error("Failed to find body for panel " .. tostring(panelClass))
  end
  local body = self:GetBody():Add(panelClass or "DPanel")
  if (!IsValid(body)) then
    Error("Failed to create panel for " .. tostring(panelClass))
  end
  body:Dock(FILL)
  body.Data = tbl
  body:SetVisible(false)
  if body.SetData then
    body:SetData(tbl)
  end

  local bodyId = table.insert(self.Panels, body)
  self.Panels[bodyId].Id = bodyId

  local id = table.insert(self.Sidebar, btn)
  self.Sidebar[id].Id = id
end

function PANEL:SetActive(id)
  local active = self.Active
  self.Active = id

  if IsValid(self.Sidebar[active]) then
    self.Sidebar[active]:OnCursorExited()

    if IsValid(self.Panels[active]) then
      self.Panels[active]:SetVisible(false)
    end
  end

  if IsValid(self.Sidebar[id]) then
    self.Sidebar[id]:Lerp("GradientAlpha", 255)

    if IsValid(self.Panels[id]) then
      if (self.Panels[id].Data.recreateOnSwitch and id != active) then
        local tempData = self.Panels[id].Data
        local tempId = self.Panels[id].Id
        self.Panels[id]:Remove()

        self.Panels[id] = self:GetBody():Add(self.Sidebar[id].PanelClass or "DPanel")
        self.Panels[id]:Dock(FILL)
        self.Panels[id].Data = tempData
        self.Panels[id].Id = tempId
      else
        self.Panels[id]:SetVisible(true)
      end

      if self.Panels[id].OnSwitchedTo then
        self.Panels[id]:OnSwitchedTo(self.Panels[id].Data)
      end
    end
  end
end

function PANEL:SetActiveByName(name)
  for i, v in ipairs(self.Sidebar) do
    if (v.Name == name) then
      self:SetActive(i)

      break
    end
  end
end

function PANEL:Paint(w, h)
  XeninUI:DrawRoundedBoxEx(6, 0, 0, w, h, XeninUI.Theme.Primary, false, false, true, false)
end

vgui.Register("XeninUI.SidebarV2", PANEL)

--PATH addons/xenin_the_xenin_framework_1900562881/lua/xeninui/elements/wyvern_scrollpanel.lua:
local PANEL = {}

AccessorFunc(PANEL, "Padding", "Padding")
AccessorFunc(PANEL, "pnlCanvas", "Canvas")
AccessorFunc(PANEL, "m_scrollbarLeftSide", "ScrollbarLeftSide")
AccessorFunc(PANEL, "m_bBarDockOffset", "BarDockShouldOffset", FORCE_BOOL)

function PANEL:Init()
    self.pnlCanvas = vgui.Create("Panel", self)
    self.pnlCanvas.OnMousePressed = function(self, code)
        self:GetParent():OnMousePressed(code)end
    self.pnlCanvas:SetMouseInputEnabled(true)
    self.pnlCanvas.PerformLayout = function(pnl)
        self:PerformLayout()
        self:InvalidateParent()
    end

    self.VBar = vgui.Create("XeninUI.Scrollbar.Wyvern", self)
    self.VBar:Dock(RIGHT)

    self:SetPadding(0)
    self:SetMouseInputEnabled(true)


    self:SetPaintBackgroundEnabled(false)
    self:SetPaintBorderEnabled(false)

    self.scrollDelta = 0
    self.scrollReturnWait = 0

    self:SetBarDockShouldOffset(true)


    self:SetBarDockShouldOffset(false)
    self.VBar:SetWide(8)
    self.VBar.Paint = function(pnl, w, h)
        draw.RoundedBox(w * 0.5, 0, 0, w, h, XeninUI.Theme.Navbar)
    end
    self.VBar.scrollbar.barAlpha = 0
    self.VBar.scrollbar.Paint = function(pnl, w, h)
        if self.VBar:GetEnabled() then
            pnl.barAlpha = pnl.barAlpha + (1 - pnl.barAlpha) * 10 * FrameTime()
        else
            pnl.barAlpha = pnl.barAlpha + (0 - pnl.barAlpha) * 10 * FrameTime()
        end

        draw.RoundedBox(w * 0.5, 0, 0, w, h, Color(75, 75, 75, 255 * pnl.barAlpha))
    end
    self.VBar:SetVisibleFullHeight(true)
end

function PANEL:AddItem(pnl)
    pnl:SetParent(self:GetCanvas())
end

function PANEL:OnChildAdded(child)
    self:AddItem(child)
end

function PANEL:SizeToContents()
    self:SetSize(self.pnlCanvas:GetSize())
end

function PANEL:GetVBar()
    return self.VBar
end

function PANEL:GetCanvas()
    return self.pnlCanvas
end

function PANEL:InnerWidth()
    return self:GetCanvas():GetWide()
end

AccessorFunc(PANEL, "m_scrollbarLeftSide", "ScrollbarLeftSide")

function PANEL:Rebuild()
    self:GetCanvas():SizeToChildren(false, true)

    if self.m_bNoSizing and self:GetCanvas():GetTall() < self:GetTall() then
        self:GetCanvas():SetPos(0, (self:GetTall() - self:GetCanvas():GetTall()) * 0.5)
    end
end

function PANEL:Think()
    if not self.lastThink then self.lastThink = CurTime()end
    local elapsed = CurTime() - self.lastThink
    self.lastThink = CurTime()

    if self.scrollDelta > 0 then
        self.VBar:OnMouseWheeled(self.scrollDelta / 1)

        if self.VBar.Scroll >= 0 then
            self.scrollDelta = self.scrollDelta - 10 * elapsed
        end
        if self.scrollDelta < 0 then self.scrollDelta = 0 end
    elseif self.scrollDelta < 0 then
        self.VBar:OnMouseWheeled(self.scrollDelta / 1)

        if self.VBar.Scroll <= self.VBar.CanvasSize then
            self.scrollDelta = self.scrollDelta + 10 * elapsed
        end
        if self.scrollDelta > 0 then self.scrollDelta = 0 end
    end

    if self.scrollReturnWait >= 1 then
        if self.VBar.Scroll < 0 then
            if self.VBar.Scroll <= -75 and self.scrollDelta > 0 then self.scrollDelta = self.scrollDelta * 0.5 end

            self.scrollDelta = self.scrollDelta + (self.VBar.Scroll / 1500 - 0.01) * 100 * elapsed

        elseif self.VBar.Scroll > self.VBar.CanvasSize then
            if self.VBar.Scroll >= self.VBar.CanvasSize + 75 and self.scrollDelta < 0 then self.scrollDelta = self.scrollDelta * 0.5 end

            self.scrollDelta = self.scrollDelta + ((self.VBar.Scroll - self.VBar.CanvasSize) / 1500 + 0.01) * 100 * elapsed
        end
    else
        self.scrollReturnWait = self.scrollReturnWait + 10 * elapsed
    end
end

function PANEL:OnMouseWheeled(delta)
    if (delta > 0 and self.VBar.Scroll <= self.VBar.CanvasSize * 0.005) or (delta < 0 and self.VBar.Scroll >= self.VBar.CanvasSize * 0.995) then
        self.scrollDelta = self.scrollDelta + delta / 10
        return
    end

    self.scrollDelta = delta * 0.5
    self.scrollReturnWait = 0

end

function PANEL:OnVScroll(iOffset)
    self.pnlCanvas:SetPos(0, iOffset)
end

function PANEL:ScrollToChild(panel)
    self:PerformLayout()

    local x, y = self.pnlCanvas:GetChildPosition(panel)
    local w, h = panel:GetSize()




    self.VBar:AnimateTo(y, 0.5, 0, 0.5)
end


function PANEL:PerformLayout()
    if self:GetScrollbarLeftSide() then
        self.VBar:Dock(LEFT)
    else
        self.VBar:Dock(RIGHT)
    end

    local wide = self:GetWide()
    local xPos = 0
    local yPos = 0

    self:Rebuild()

    self.VBar:SetUp(self:GetTall(), self.pnlCanvas:GetTall())
    yPos = self.VBar:GetOffset()

    if self.VBar.Enabled or not self:GetBarDockShouldOffset() then
        wide = wide - self.VBar:GetWide()

        if self:GetScrollbarLeftSide() then
            xPos = self.VBar:GetWide()
        end
    end

    self.pnlCanvas:SetPos(xPos, yPos)
    self.pnlCanvas:SetWide(wide)

    self:Rebuild()
end

function PANEL:Clear()
    return self.pnlCanvas:Clear()
end

function PANEL:Paint(w, h) end

vgui.Register("XeninUI.Scrollpanel.Wyvern", PANEL, "DPanel")

--PATH addons/battlepass/lua/battlepass/menu/challenges.lua:
local PANEL = {}
local colorid = BATTLEPASS.Colors
local materialid = BATTLEPASS.Materials
challenges = challenges or {}
local color1 = Color(200, 0, 200)

net.Receive('ChallengeNet', function()
	challenges = net.ReadTable()
end)

function PANEL:Init()
	self.StagesNum = 0
	self.ChallengesNum = 0
	self.Scroll = self:Add("DScrollPanel")
	self.Scroll:Dock(FILL)
	self.Scroll:DockMargin(0, 5, 110, 5)
	local sbar = self.Scroll:GetVBar()
	sbar:SetWide(6)

	local col1 = ColorAlpha(color_white, 10)
	function sbar:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, col1)
	end

	sbar.btnUp.Paint = nil
	sbar.btnDown.Paint = nil
	sbar:SetHideButtons(true)

	function sbar.btnGrip:Paint(w, h)
		draw.RoundedBox(0, 0, 0, w, h, colorid.salat)
	end

	local tbl = table.Copy(BATTLEPASS.Pass.challenges)

	for i, v in SortedPairs(tbl) do
		for k, challenge in pairs(v) do
			if not challenges[challenge.id] then continue end
			self:CreateChallenge(challenge, i, k)
		end
	end
end

function PANEL:Paint(w, h)
end

function PANEL:CreateChallenge(tbl, tabName, challengeId)
	local challengeTbl = BATTLEPASS.Challenges[tbl.id]
	if not challengeTbl then return end
	local name = tbl.name or challengeTbl.name
	local stars = tbl.reward
	local onlypremium = challengeTbl.onlypremium
	if onlypremium and not LocalPlayer().BattlePass.Owned.owned then return end
	LocalPlayer().ActiveChallenges = LocalPlayer().ActiveChallenges or {}
	local panel = self.Scroll:Add("DButton")
	panel:Dock(TOP)
	panel:DockMargin(0, 0, 24, 8)
	panel:SetTall(80)
	panel:SetText("")
	panel.BackgroundColor = XeninUI.Theme.Navbar
	panel.FinishedColor = XeninUI.Theme.Green
	local realTbl = challengeTbl

	if LocalPlayer().ActiveChallenges[tabName] then
		realTbl = LocalPlayer().ActiveChallenges[tabName][challengeId]
	end

	if not realTbl then return end
	self.StagesNum = self.StagesNum + #realTbl.goal
	self.ChallengesNum = self.ChallengesNum + 1

	panel.col = ColorAlpha(color_white, 50)
	panel.Paint = function(pnl, w, h)
		local progress = 0
		local challenge = LocalPlayer().ActiveChallenges

		if challenge then
			challenge = challenge[tabName]

			if challenge then
				challenge = challenge[challengeId]

				if challenge then
					progress = math.Round(challenge.progress, 2)
				end
			end
		end

		local finished = progress >= realTbl.goal[#realTbl.goal or 0]
		local currentStage = math.Clamp(realTbl.stage, 1, #realTbl.goal)
		local text = progress .. "/" .. realTbl.goal[currentStage]
		draw.Icon(0, 0, w, h, materialid.challenge, pnl.col)
		draw.SimpleText(name, 'font_bpname', W(28), h * 0.5, color_white, TEXT_ALIGN_LEFT, 1)

		DrawFlexText({
			{stars[1], nil, true},
			{'XP', colorid.salat}
		}, 'font_bpname', w - W(130), H(31))

		if onlypremium ~= nil then
			draw.SimpleText('[ONLY PREMIUM]', 'font_bpname', W(28), H(20), color1, nil, TEXT_ALIGN_CENTER)
		end

		draw.SimpleText(finished and '✅' or text, "font_bpname", w - W(29), h * 0.5, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
	end

	panel.OnCursorEntered = function(pnl)
		pnl:LerpColor("BackgroundColor", XeninUI.Theme.Primary)
	end

	panel.OnCursorExited = function(pnl)
		pnl:LerpColor("BackgroundColor", XeninUI.Theme.Navbar)
	end
end

vgui.Register("BATTLEPASS.Challenges.Challenge", PANEL)
--PATH addons/battlepass/lua/battlepass/server/perm_weps.lua:
function BATTLEPASS:GetPermWep(ply, wep)
	self:GetPermanentVariable(ply, "permwep_" .. wep)
end

function BATTLEPASS:AddPermWep(ply, key, value)
	self:SetPermanentVariable(ply, "permwep_" .. key, value)
end

hook.Add("PlayerLoadout", "BATTLEPASS.PermWeps", function(ply)
	BATTLEPASS:SetupPass(ply)
	local vars = ply.BattlePass.Owned.vars

	for i, v in pairs(vars or {}) do
		if (i:find("permwep_")) then
			local wep = i:sub(9)

			local obj = ply:Give(wep)
			if (IsValid(obj)) then
				obj.cantBeDropped = true
			end
		end
	end
end)

hook.Add("canDropWeapon", "BATTLEPASS.PermWeps", function(ply, wep)
		if (wep.cantBeDropped) then
			return false
		end
end)
--PATH addons/________anticrash/lua/autorun/z_anticrash_setup.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER ]]

local function findFiles(searchQuota,searchPath,foundTbl)
	
	foundTbl = foundTbl or {}
	searchPath = searchPath or "z_anticrash"
	
	local files, dirs = file.Find( searchPath.."/*", "LUA" )
	
	for i=1,#dirs do
		findFiles(searchQuota,searchPath..'/'..dirs[i],foundTbl)
	end
	
	for i=1,#files do
		
		local f = files[i]
		
		for ii=1,#searchQuota do
			
			local quota = searchQuota[ii]
			
			if string.StartWith( f, quota ) then
				table.insert(foundTbl,searchPath..'/'..f)
				break
			end
		
		end
		
	end
	
	return foundTbl
	
end

local searchQuota = {}
searchQuota.priority = {"settings"}
searchQuota.cl = {"sh_","cl_","p_"}
searchQuota.sv = {"sh_","sv_"}

local priorityFiles = findFiles(searchQuota.priority)
local clFiles = findFiles(searchQuota.cl)
local svFiles = findFiles(searchQuota.sv)

CL_ANTICRASH = {}
SH_ANTICRASH = {}
SV_ANTICRASH = {}
	
-- load shared priority files first
for _,priorityFile in ipairs( priorityFiles ) do
	include( priorityFile )
end

if CLIENT then

	for _,clFile in ipairs( clFiles ) do
		include( clFile )
	end

end

if SERVER then 

	-- Anti-Crash content for clients
	-- resource.AddWorkshop(2159259261)
	
	for _,priorityFile in ipairs( priorityFiles ) do
		AddCSLuaFile( priorityFile )
	end
	
	for _,clFile in ipairs( clFiles ) do
		AddCSLuaFile( clFile )
	end

	for _,svFile in ipairs( svFiles ) do 
		include( svFile )
	end
	
end
--PATH addons/________anticrash/lua/z_anticrash/client/cl_menu.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local menu = nil

function CL_ANTICRASH.MenuIsOpen()
	return menu ~= nil and menu:IsVisible()
end

function CL_ANTICRASH.ToggleMenu(forceClose)

	if !LocalPlayer():IsSuperAdmin() then return end
	
	if forceClose or CL_ANTICRASH.MenuIsOpen() then

		if menu ~= nil then
		
			menu:Close()
			
			menu = nil
			
		end
		
	else
	
		menu = vgui.Create( "p_anticrash_menu" )
		menu:InitOther()
		
	end

end

local function OpenMenuByConCommand( ply, cmd, args )
	CL_ANTICRASH.ToggleMenu()
end
concommand.Add( "anticrash_open", OpenMenuByConCommand)

--PATH addons/________anticrash/lua/z_anticrash/panels/p_stats.lua:
-- [[ CREATED BY ZOMBIE EXTINGUISHER]]

local PANEL = {}
local graphOffset = 10

function PANEL:InitOther()
	
	local pWide, pTall = self:GetSize()
	local graphW, graphH = pWide-(graphOffset*2), pTall*0.4
	
	-- Graph
	local graphPanel = CL_ANTICRASH.CreateGraph(graphOffset, graphOffset, graphW, graphH, self)
	
	-- Graph Information
	local infoMarginW, infoMarginH  = 10, 10
	local infoW, infoH = graphW*0.5-(infoMarginW*0.5), pTall*0.05
	local categoryOffset = 26
	
	local lagInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, graphPanel:GetBottomY()+categoryOffset, infoW, infoH, SH_ANTICRASH.Translate("lag"), "ZLAG", false, self, true)
	local collisionInfo = CL_ANTICRASH.CreateGraphInfoLabel(lagInfo:GetRightX()+infoMarginW, graphPanel:GetBottomY()+categoryOffset, infoW, infoH, SH_ANTICRASH.Translate("collisions"), "COLLISIONS",true, self, true)
	
	local propInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, collisionInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("props"), "PROPS", true, self, true)
	local frozenInfo = CL_ANTICRASH.CreateGraphInfoLabel(propInfo:GetRightX()+infoMarginW, collisionInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("propsFrozen"), "FROZENPROPS", true, self, true)
	
	local npcInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, frozenInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("npcs"), "NPCS",true, self, true)
	local vehicleInfo = CL_ANTICRASH.CreateGraphInfoLabel(npcInfo:GetRightX()+infoMarginW, frozenInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("vehicles"), "VEHICLES", true, self, true)
	
	-- Extra Information
	local playerInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, vehicleInfo:GetBottomY()+categoryOffset, infoW, infoH, SH_ANTICRASH.Translate("players"), "PLAYERS",true, self)
	CL_ANTICRASH.CreateGraphInfoLabel(playerInfo:GetRightX()+infoMarginW, vehicleInfo:GetBottomY()+categoryOffset, infoW, infoH, SH_ANTICRASH.Translate("uptime"), "UPTIME",true, self) 
	
	local entityInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, playerInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("entities"), "ENTITIES", true, self)
	CL_ANTICRASH.CreateGraphInfoLabel(entityInfo:GetRightX()+infoMarginW, playerInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("spawned"), "SPAWNED", true, self)
	
	local fpsInfo = CL_ANTICRASH.CreateGraphInfoLabel(graphOffset, entityInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("fps"), "FPS",true, self)
	CL_ANTICRASH.CreateGraphInfoLabel(fpsInfo:GetRightX()+infoMarginW, entityInfo:GetBottomY()+infoMarginH, infoW, infoH, SH_ANTICRASH.Translate("tickrate"), "TICKRATE", true, self)
	
	-- Run anti-lag measures

	local entityVisionBtn = vgui.Create("onyx.Button", self)
	entityVisionBtn:SetPos(graphOffset,pTall-categoryOffset-40)
	entityVisionBtn:SetSize(graphW, infoH)
	entityVisionBtn:SetText(SH_ANTICRASH.Translate("runAntiLagMeasures"))
	entityVisionBtn.DoClick = function()
		net.Start( "sv_anticrash_TriggerAntiLagMeasures" )
		net.SendToServer()
	end
	
end
vgui.Register('p_anticrash_stats',PANEL)
--PATH addons/__advdupe2/lua/autorun/client/advdupe2_cl_init.lua:
AdvDupe2 = {
	Version = "1.1.0",
	Revision = 51,
	InfoText = {},
	DataFolder = "advdupe2",
	FileRenameTryLimit = 256,
	ProgressBar = {}
}

if(!file.Exists(AdvDupe2.DataFolder, "DATA"))then
	file.CreateDir(AdvDupe2.DataFolder)
end

include( "advdupe2/file_browser.lua" )
include( "advdupe2/sh_codec.lua" )
include( "advdupe2/cl_file.lua" )
include( "advdupe2/cl_ghost.lua" )

function AdvDupe2.Notify(msg,typ,dur)
	surface.PlaySound(typ == 1 and "buttons/button10.wav" or "ambient/water/drip1.wav")
	GAMEMODE:AddNotify(msg, typ or NOTIFY_GENERIC, dur or 5)
	//if not game.SinglePlayer() then
		print("[AdvDupe2Notify]\t"..msg)
	//end
end

net.Receive("AdvDupe2Notify", function()
	AdvDupe2.Notify(net.ReadString(), net.ReadUInt(8), net.ReadFloat())
end)

--PATH addons/____bricks_framework/lua/bricks_server/languages/bricks_server/german.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "german", {
    ["search"] = "Suchen",
    ["invalidPlayerProfile"] = "Ungültiges Spielerprofil aufgerufen",
    ["unbound"] = "UNBOUND",
    ["themes"] = "Themes",
    ["groups"] = "Gruppen",
    ["general"] = "Generell",
    ["itemWhitelisting"] = "Item Whitelisting",
    ["rarities"] = "Besonderheiten",
    ["languages"] = "Sprachen",
    ["disabled"] = "Deaktiviert",
    ["enabled"] = "Aktiviert",
    ["purchase"] = "Kauf",
    ["profile"] = "Profil",
    ["view"] = "Ansehen",
    ["admin"] = "Admin",
    ["noToolPermission"] = "Du hast nicht die nötigen Rechte, um dieses Tool zu nutzen.",
    ["settings"] = "Einstellungen",
    ["players"] = "Spieler",
    ["modules"] = "Module",

    ["userGroupEditor"] = "Spielergruppen Bearbeitung",
    ["addNewGroup"] = "Neue Gruppe hinzufügen",
    ["newUserGroup"] = "Was soll die neue Benutzergruppe sein?",
    ["groupName"] = "Gruppenname",

    ["custom"] = "Benutzerdefiniert",
    ["addNew"] = "Neue hinzufügen",
    ["material"] = "Material",
    ["directImage"] = "Gebe einen direkten Link zum Bild an",
    ["default"] = "Standard",
    ["selectMaterial"] = "Du musst ein Material angeben",

    ["errorNoText"] = "ERROR: KEIN TEXT",
    ["selectOption"] = "Wähle eine Option",
    ["selectValue"] = "Bitte wähle einen Wert.",
    ["selectColor"] = "Bitte wähle eine Farbe.",
    ["configSaved"] = "Config gespeichert!",
    ["cmdNoPermission"] = "Du hast nicht die nötigen Rechte, um diesen Command zu benutzen.",
    ["entityPosUpdated"] = "Entitypositionen aktualisiert.",
    ["noEntitiesSpawned"] = "Es wurden keine Entities gespawnt.",
    ["xEntitiesSpawned"] = "%d gespeicherten Entities wurden gespeichert.",
    ["error"] = "ERROR",

    ["seconds"] = "%d Sekunden",
    ["second"] = "%d Sekunde",
    ["minutes"] = "%d Minuten",
    ["minute"] = "%d Minute",
    ["hours"] = "%d Stunden",
    ["hour"] = "%d Stunde",

    ["noRarity"] = "Keine Besonderheit",

    ["config"] = "Config",
    ["edit"] = "Bearbeiten",
    ["editColor"] = "Bearbeite Farbe",
    ["editName"] = "Bearbeite Name",
    ["remove"] = "Entfernen",
    ["name"] = "Name",
    ["description"] = "Beschreibung",
    ["model"] = "Model",
    ["icon"] = "Icon",
    ["type"] = "Typ",
    ["price"] = "Preis",
    ["group"] = "Gruppe",
    ["category"] = "Kategorie",
    ["color"] = "Farbe",
    ["invalidType"] = "Ungültiger Typ",
    ["invalidOption"] = "Ungültige Option.",
    ["invalidChoice"] = "Ungültige Auswahl.",
    ["invalidGroup"] = "Ungültige Gruppe.",
    ["invalidPlayer"] = "Ungültiger Spieler.",
    ["true"] = "WAHR",
    ["false"] = "FALSCH",
    ["noDescription"] = "Keine Beschreibung",
    ["other"] = "Anderes",
    ["completed"] = "Fertig",
    ["close"] = "Schließen",
    ["main"] = "Haupt",
    
    ["valueQuery"] = "Was soll %s sein?",
    ["dataValueQuery"] = "Welche Dateien sollen das sein?",
    ["newNameQuery"] = "Was soll der neue Name sein?",
    ["newDescriptionQuery"] = "Was soll die neue Beschreibung sein?",
    ["newModelQuery"] = "Was soll das neue Model sein?",
    ["newIconQuery"] = "Was soll das neue Bild sein?",
    ["newColorQuery"] = "Was soll die neue Farbe sein?",
    ["npcTypeQuery"] = "Welche Art soll der NPC sein?",
    ["newTypeQuery"] = "Was soll die neue Art sen?",
    ["groupRequirementQuery"] = "Was soll die Gruppenanforderung sein?",
    ["levelRequirementQuery"] = "Was soll die Levelanforderung sein?",
    ["newPriceQuery"] = "Was soll der neue Preis sein?",
    ["newCategoryQuery"] = "Was soll die neue Kategorie sein?",

    ["npcEditor"] = "NPC Bearbeiter",
    ["addNPC"] = "Füge NPC hinzu",
    ["newNPC"] = "Neuer NPC",

    ["ok"] = "OK",
    ["cancel"] = "Aufheben",
    ["save"] = "Speichern",
    ["confirm"] = "Bestätigen",
    ["nil"] = "NIL",
    ["none"] = "Nichts",
    ["selected"] = "Ausgewählt",
    ["unselected"] = "Nicht ausgewählt",
    ["add"] = "Hinzufügen",

    ["shootyStick"] = "Ein schießender Stock!",
    ["permanent"] = "Permanent",
    ["tierX"] = "(Stufe %d)",
    ["someDescription"] = "Mögliche Beschreibung",
    ["invalidNPC"] = "BRICKS SERVER ERROR: Ungültiger NPC",

    ["disconnected"] = "Disconnected",
    ["profileView"] = "Profilansicht",
    ["loading"] = "Laden",
    ["statistics"] = "Statistiken",
    ["steamID64"] = "SteamID64",
    ["donationRank"] = "Untersützer-Rang",
    ["staffRank"] = "Teamrang",
    ["currentJob"] = "Aktueller Job",
    ["wallet"] = "Brieftasche",
    ["level"] = "Level",
    ["levelX"] = "Level %d",
    ["experience"] = "Erfahrung",
    ["exp"] = "EXP",
    ["money"] = "Geld",
    ["playerLogs"] = "Spielerlogs",
    ["deleteLogs"] = "Lösche Logs",
    ["xLogs"] = "%d Logs",
    ["xAdminGroups"] = "%d Admingruppen",
    ["noUserGroups"] = "Keine Spielergruppen",
    ["userGroups"] = "Spielergruppen: %s",
    ["editUserGroups"] = "Bearbeite Spielergruppen",
    ["newGroupColor"] = "Was soll die neue Gruppenfarbe sein?",
    ["newGroupName"] = "Was soll der neue Gruppenname sein?",
    ["groupAlreadyExists"] = "Diese Gruppe existiert bereits!",
    ["whitelist"] = "Whitelist",
    ["unWhitelist"] = "UnWhitelist",
    ["addCustom"] = "Füge etwas eigenes hinzu",
    ["entClassWhitelist"] = "Welche Entitie-Klasse möchtest du zur Whitelist hinzufügen?",
    ["entClassAlreadyOnList"] = "Diese Entitie-Klasse ist bereits auf der Whitelist.",
    ["changesServerRestart"] = "Einige Änderungen werden erst nach einem Serverneustart verfügbar sein!",
    ["comingSoon"] = "Kommt bald!",
    ["features"] = "FEATURES",
    ["addNewRarity"] = "Füge eine neue Besonderheit hinzu",
    ["newRarity"] = "Neue Besonderheit",
    ["needToAddRarity"] = "Du musst zuerst eine Besonderheits-Art hinzufügen",
    ["whatRarityItem"] = "Welche Besonderheit soll dieses Item haben?",
    ["invalidRarity"] = "Ungültige Besonderheitsgruppe.",
    ["rarityAlreadyExists"] = "Es existiert bereits eine Besonderheit mit diesem Namen!",
    ["themeColorX"] = "Theme - Farbe %d",
    ["themeTextColor"] = "Theme - Textfarbe",
    ["presetAccents"] = "Preset accents",
    ["presetBackgrounds"] = "Hintergründe zurücksetzen",
    ["resetToBaseThemes"] = "Standardtheme zurücksetzen",
    ["resetToCurrentThemes"] = "Auf aktuelle Themes zurücksetzen",
    ["toggle"] = "Umschalten",
    ["menu"] = "Menü",
    ["emptyValue"] = "LEERER WERT",
    ["newValueQuery"] = "Was soll der neue Wert sein?",
    ["pressKey"] = "DRÜCKE EINE TASTE",

    ["entityPlacer"] = "Entitie-Platzierer",
    ["invalidEntityType"] = "Ungültige Entitie-Art ausgewählt, wähle eine gültige aus dem Toolmenü",
    ["entityPlaced"] = "Entitie erfolgreich platziert.",
    ["entityRemoved"] = "Entitie erfolgreich entfernt.",
    ["canOnlyUseToolEntity"] = "Du kannst dieses Tool nur zum Entfernen/Erstellen von Entites nutzen.",
    ["entityType"] = "Entity-Art",
    ["entityPlacerDescription"] = "Platziert und entfernt Entites von Bricks Servers und speichert deren Positionen. Linksklick: Platzieren | Rechtsklick: Entfernen.",
    ["entityPlacerDescriptionSmall"] = "Platziert und entfernt Entities",
    ["entityPlacerInstructions"] = "Linksklick - Platzieren, Rechtsklick - Entfernen.",

    ["npcPlacer"] = "NPC-Platzierer",
    ["npcPlaced"] = "NPC erfolgreich platziert.",
    ["invalidNPCType"] = "Ungültige NPC-Art ausgewählt, wähle eine gültige aus dem Toolmenü.",
    ["npcRemoved"] = "NPC erfolgreich entfernt.",
    ["errorNotNPC"] = "Du kannst diese Tool nur zum Platzieren/Entfernen von NPCs verwenden..",
    ["npcPlacerDescription"] = "Platziert und entfernt NPCs von Bricks Servers und speichert deren Positionen. Linksklick: Platzieren | Rechtsklick: Entfernen.",
    ["npcPlacerDescriptionSmall"] = "Platziert und Entfernt NPCs von Bricks Servers.",

    ["inventory"] = "Inventar",
    ["player"] = "Spieler",
    ["drop"] = "Fallen lassen",
    ["use"] = "Benutzen",
    ["dropAll"] = "Alles fallen lassen",
    ["delete"] = "Löschen",
} )
--PATH addons/____bricks_framework/lua/bricks_server/itemtypes/spawned_weapon.lua:
local ITEM = BRICKS_SERVER.Func.CreateItemType( "spawned_weapon" )

ITEM.GetItemData = function( ent )
    local itemData = { "spawned_weapon", ent:GetModel(), ent:GetNWString('GetName'), ent:GetNWString('GetWeapon') }
    
    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "swepupgrader" ) ) then
        itemData[4] = ent:GetNW2Int( "BRS_Upgrades", 0 )
    end

    if( ent:GetNW2Bool( "BRS_IsPermanent" ) ) then
        itemData[5] = true
    end

    return itemData, (ent.Getamount and ent:Getamount()) or 1
end

ITEM.CanDropMultiple = true

ITEM.OnSpawn = function( ply, pos, itemData, itemAmount )
    local ent = ents.Create( "spawned_weapon" )
    if( not IsValid( ent ) ) then return end
    ent:SetPos( pos )
    ent:SetModel( itemData[2] )
    ent:SetNWString('GetName',itemData[3])
	ent:SetNWString('GetWeapon',itemData[4])
	ent:SetNWString('GetModel',itemData[2])
    ent:Spawn()
    
    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "swepupgrader" ) and isnumber( itemData[4] or 0 ) and (itemData[4] or 0) > 0 ) then
        ent:SetNW2Int( "BRS_Upgrades", (itemData[4] or 0) )
        function ent:StartTouch( touchEnt ) 
            BRICKS_SERVER.Func.MergeWeapons( self, touchEnt )
        end
    end

    if( itemData[5] ) then
        ent:SetNW2Bool( "BRS_IsPermanent", true )
    end
end

ITEM.OnUse = function( ply, itemData )
    if( not itemData[3] ) then return false end

    ply:Give( itemData[3], true )

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "swepupgrader" ) and isnumber( itemData[4] or 0 ) and (itemData[4] or 0) > 0 ) then
        timer.Simple( 0.2, function()
            local newWeaponEnt = ply:GetWeapon( itemData[3] )

            if( IsValid( newWeaponEnt ) ) then
                newWeaponEnt:BRS_SetWeaponTier( (itemData[4] or 0), ply )
            end
        end )
    end
end

ITEM.CanUse = function( ply, itemData )
    if( itemData[5] ) then return false end

    return true
end

ITEM.Equip = function( ply, itemData )
    ply:Give( itemData[3], true )
end

ITEM.CanEquip = function( ply, itemData )
    if( not itemData[5] ) then return false end
    
    for k, v in pairs( ply:BRS():GetInventory() ) do
        if( v[3] and v[2] and v[2][3] == itemData[3] ) then return false end
    end

    return true
end

ITEM.UnEquip = function( ply, itemData )
    ply:StripWeapon( itemData[3] )
end

ITEM.CanUnEquip = function( ply, itemData )
    if( not itemData[5] ) then return false end

    return true
end

ITEM.ModelDisplay = function( Panel, itemData )
    if( not Panel.Entity or not IsValid( Panel.Entity ) ) then return end

    local mn, mx = Panel.Entity:GetRenderBounds()
    local size = 0
    size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
    size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
    size = math.max( size, math.abs(mn.z) + math.abs(mx.z) )

    Panel:SetFOV( 50 )
    Panel:SetCamPos( Vector( size, size, size ) )
    Panel:SetLookAt( (mn + mx) * 0.5 )
end

ITEM.GetInfo = function( itemData )
    local itemName = "Unknown"
    if( (list.Get( "Weapon" ) or {})[(itemData[3] or "")] and (list.Get( "Weapon" ) or {})[(itemData[3] or "")].PrintName ) then
        itemName = (list.Get( "Weapon" ) or {})[(itemData[3] or "")].PrintName
    end

    local itemDescription = BRICKS_SERVER.Func.L( "shootyStick" )
    if( BRICKS_SERVER.ESSENTIALS and BRICKS_SERVER.ESSENTIALS.LUACFG.ItemDescriptions and BRICKS_SERVER.ESSENTIALS.LUACFG.ItemDescriptions[(itemData[3] or "")] ) then
        itemDescription = BRICKS_SERVER.ESSENTIALS.LUACFG.ItemDescriptions[(itemData[3] or "")]
    end

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "swepupgrader" ) and isnumber( itemData[4] or 0 ) and (itemData[4] or 0) > 0 ) then
        return { itemName .. " " .. BRICKS_SERVER.Func.L( "tierX", (itemData[4] or 0) ), itemDescription, (BRICKS_SERVER.CONFIG.INVENTORY.ItemRarities or {})[itemData[3] or ""], (itemData[5] and BRICKS_SERVER.Func.L( "permanent" )) }
    else
        return { itemName, itemDescription, (BRICKS_SERVER.CONFIG.INVENTORY.ItemRarities or {})[itemData[3] or ""], (itemData[5] and BRICKS_SERVER.Func.L( "permanent" )) }
    end
end

ITEM.GetItemKey = function( itemData )
    return itemData[3] or ""
end

ITEM.GetPotentialItems = function()
    local potentialItems = {}
    for k, v in pairs( BRICKS_SERVER.Func.GetList( "weapons" ) ) do
        local weaponModel = BRICKS_SERVER.Func.GetWeaponModel( k ) or ""
        if( GAMEMODE.Config.DisallowDrop[k] or weaponModel == "" ) then continue end

        potentialItems[k] = {
            Name = v,
            Model = weaponModel,
            ItemKey = k
        }
    end

    return potentialItems
end

ITEM.CanCombine = function( itemData1, itemData2 )
    if( itemData1[5] or itemData2[5] ) then return false end

    if( itemData1[1] == itemData2[1] and itemData1[3] and itemData2[3] and itemData1[3] == itemData2[3] ) then
        if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "swepupgrader" ) ) then
            if( (itemData1[4] or 0) == (itemData2[4] or 0) ) then
                return true
            end
        else
            return true
        end
    end

    return false
end

ITEM:Register()
--PATH addons/____bricks_framework/lua/bricks_server/core/shared/sh_modules.lua:
BRICKS_SERVER.DLCMODULES = {}
function BRICKS_SERVER.Func.AddDLCModule( id, table )
    BRICKS_SERVER.DLCMODULES[id] = table
end

BRICKS_SERVER.Func.AddDLCModule( "essentials", {
    ScriptID = 7244,
    Name = "Brick's Essentials", 
    Color = Color( 64, 126, 187 ),
    Icon = "materials/bricks_server/essentials.png", 
    Link ="https://www.gmodstore.com/market/view/bricks-essentials", 
    Description = "An all-in-one system that includes: F4 menu, Inventory, Crafting, HUD, Levelling, Printers, Marketplace, Zones, Bosses, Boosters and more!" ,
    Modules = { "essentials" }
} )

BRICKS_SERVER.Func.AddDLCModule( "gangs", {
    ScriptID = 7319,
    Name = "Brick's Gangs", 
    Color = Color( 255, 57, 57 ),
    Icon = "materials/bricks_server/gangs.png", 
    Link ="https://www.gmodstore.com/market/view/brick-s-gangs-territories-associations-achievements-more", 
    Description = "A gang system that includes Upgrades, Territories, Storage, Ranks, Achievements, Leaderboards and more!" ,
    Modules = { "gangs" }
} )

BRICKS_SERVER.Func.AddDLCModule( "unboxing", {
    ScriptID = 7476,
    Name = "Brick's Unboxing", 
    Color = Color( 26, 188, 156 ),
    Icon = "materials/bricks_server/unboxing.png", 
    Link = "https://www.gmodstore.com/market/view/brick-s-unboxing",
    Description = "An unboxing system that includes Crates, Keys, Trading, Marketplace, Shop and more!" ,
    Modules = { "unboxing" }
} )

BRICKS_SERVER.Func.AddDLCModule( "coinflip", {
    Name = "Brick's Coinflip", 
    Color = Color( 46, 204, 113 ),
    Icon = "materials/bricks_server/coinflip_64.png", 
    Link = "https://www.gmodstore.com/market/view/brick-s-coinflip-flip-items-and-money",
    Description = "A coinflip script that allows players to gamble their money and items!" ,
    Modules = { "coinflip" }
} )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_clickentry.lua:
local PANEL = {}

function PANEL:Init()

	self:SetTall( 40 )
	self:Clear()
	self:SetText( "" )

end

function PANEL:CreateStringEntry()
	if( IsValid( self.valueEntry ) ) then return end

	self.looseFocusCooldown = CurTime()+0.1

	self.valueEntry = vgui.Create( "bricks_server_textentry", self )
	self.valueEntry:Dock( FILL )
	self.valueEntry:SetKeyboardInputEnabled( true )
	self.valueEntry:RequestFocus()
	self.valueEntry.OnChange = function()
		self:SetValue( self.valueEntry:GetValue() )
	end
	self.valueEntry.OnEnter = function()
		if( self.OnEnter ) then
			self.OnEnter( self.valueEntry:GetValue() )
		end
	end
end

function PANEL:CreateNumberEntry()
	if( IsValid( self.valueEntry ) ) then return end

	self.looseFocusCooldown = CurTime()+0.1

	self.valueEntry = vgui.Create( "DNumberWang", self )
	self.valueEntry:Dock( FILL )
	self.valueEntry:SetKeyboardInputEnabled( true )
	self.valueEntry:RequestFocus()
	self.valueEntry.OnChange = function()
		self:SetValue( self.valueEntry:GetValue() )
	end
	self.valueEntry.OnEnter = function()
		if( self.OnEnter ) then
			self.OnEnter( self.valueEntry:GetValue() )
		end
	end
end

function PANEL:SetDataType( dataType )
	if( dataType == "string"  or dataType == "integer" or dataType == "color" ) then
		self.dataType = dataType
	else
		self.dataType = "string"
	end
end

function PANEL:GetDataType()
	return self.dataType or "string"
end

function PANEL:SetValue( value )
	if( self:GetDataType() == "string" ) then
		self.value = tostring( value )
	elseif( self:GetDataType() == "integer" ) then
		self.value = tonumber( value )
	else
		self.value = value
	end

	if( self.OnChange ) then
		self.OnChange( value )
	end
end

function PANEL:GetValue()
	if( self:GetDataType() == "string" ) then
		return tostring( self.value or "none" )
	elseif( self:GetDataType() == "integer" ) then
		return tonumber( self.value or 0 )
	else
		return self.value
	end
end

function PANEL:SetTitle( strValue )
	self.title = strValue
end

function PANEL:GetTitle()
	return self.title or ""
end

function PANEL:DoClick()
	if( self:GetDataType() == "string" ) then
		self:CreateStringEntry()
	elseif( self:GetDataType() == "integer" ) then
		self:CreateNumberEntry()
	elseif( self:GetDataType() == "color" ) then
		BRICKS_SERVER.Func.ColorRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "newColorQuery" ), self:GetValue(), function( color ) 
			self:SetValue( color or Color( 255, 255, 255 ) )
		end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
	end
end

function PANEL:Think()
	if( IsValid( self.valueEntry ) and not self.valueEntry:HasFocus() and CurTime() >= self.looseFocusCooldown ) then
		self.valueEntry:Remove()
	end
end

local Alpha = 0
local color1 = BRICKS_SERVER.Func.GetTheme( 2 )
function PANEL:Paint( w, h )
	if( IsValid( self.valueEntry ) ) then
		Alpha = math.Clamp( Alpha+5, 0, 100 )
	else
		Alpha = math.Clamp( Alpha-5, 0, 100 )
	end

	draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
	draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )

	if( not IsValid( self.valueEntry ) ) then
		if( self:GetDataType() != "color" ) then
			draw.SimpleText( self:GetTitle() .. ": " .. tostring( self:GetValue() ), "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255, 20 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			draw.SimpleText( self:GetTitle(), "BRICKS_SERVER_Font20", w*0.5, h*0.5, Color( 255, 255, 255, 20 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
	else

	end
end

derma.DefineControl( "bricks_server_clickentry", "", PANEL, "DButton" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_colsheet_top.lua:

local PANEL = {}

AccessorFunc( PANEL, "ActiveButton", "ActiveButton" )

function PANEL:Init()
	self.navigationBack = vgui.Create( "DPanel", self )
	self.navigationBack:Dock( TOP )
	self.navigationBack:SetTall( 50 )
	self.navigationBack:DockMargin( 0, 0, 0, 5 )
	local NavWidth = (ScrW()*0.6)-BRICKS_SERVER.DEVCONFIG.MainNavWidth-20
	self.navigationBack.Paint = function( self2, w, h )
		if( self.rounded ) then
			draw.RoundedBox( 5, 0, 0, w, h, (self.navColor or BRICKS_SERVER.Func.GetTheme( 3 )) )
		else
			surface.SetDrawColor( self.navColor or BRICKS_SERVER.Func.GetTheme( 3 ) )
			surface.DrawRect( 0, 0, w, h )
		end
	end

	local moveDist = 100
	
	self.Navigation = vgui.Create( "DPanel", self.navigationBack )
	self.Navigation:SetPos( 0, 0 )
	self.Navigation:SetSize( 0, self.navigationBack:GetTall() )
	self.Navigation.Paint = function( self2, w, h ) end

	function self.Navigation.UpdateWide()
		self.Navigation:SetWide( math.Clamp( self.buttonsWide, 0, NavWidth-25+(self.Navigation.leftMargin or 0) ) )
		if( self.buttonsWide > NavWidth+10 ) then
			if( not IsValid( self.Navigation.rightButton ) ) then
				self.Navigation.rightButton = vgui.Create( "DButton", self.navigationBack )
				self.Navigation.rightButton:SetSize( 25, self.navigationBack:GetTall() )
				self.Navigation.rightButton:SetPos( NavWidth-self.Navigation.rightButton:GetWide(), 0 )
				self.Navigation.rightButton:SetText( "" )
				local changeAlpha = 0
				self.Navigation.rightButton.Paint = function( self2, w, h )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), false, true, false, true )

					if( self2:IsHovered() or self2.m_bSelected ) then
						changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
					else
						changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
					end
			
					surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), false, true, false, true )
					surface.SetAlphaMultiplier( 1 )
			
					draw.SimpleText( ">", "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
				self.Navigation.rightButton.DoClick = function()
					if( (NavWidth-50)+(self.Navigation.leftMargin or 0) >= self.buttonsWide ) then return end
					self.Navigation.leftMargin = math.Clamp( (self.Navigation.leftMargin or 0)+moveDist, 0, self.buttonsWide-(NavWidth-25) )
					self.Navigation:SetPos( -self.Navigation.leftMargin, 0 )
					self.Navigation.UpdateWide()
				end
			end

			if( (self.Navigation.leftMargin or 0) > 0 and not IsValid( self.Navigation.leftButton ) ) then
				self.Navigation.leftButton = vgui.Create( "DButton", self.navigationBack )
				self.Navigation.leftButton:SetSize( 25, self.navigationBack:GetTall() )
				self.Navigation.leftButton:SetPos( 0, 0 )
				self.Navigation.leftButton:SetText( "" )
				local changeAlpha = 0
				self.Navigation.leftButton.Paint = function( self2, w, h )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ), true, false, true, false )

					if( self2:IsHovered() or self2.m_bSelected ) then
						changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
					else
						changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
					end
			
					surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), true, false, true, false )
					surface.SetAlphaMultiplier( 1 )
			
					draw.SimpleText( "<", "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
				self.Navigation.leftButton.DoClick = function()
					self.Navigation.leftMargin = math.Clamp( (self.Navigation.leftMargin or 0)-moveDist, 0, self.buttonsWide-(NavWidth-25) )
					self.Navigation:SetPos( -self.Navigation.leftMargin, 0 )
					self.Navigation.UpdateWide()
				end
			elseif( (self.Navigation.leftMargin or 0) <= 0 and IsValid( self.Navigation.leftButton ) ) then
				self.Navigation.leftButton:Remove()
			end
		end
	end

	self.Content = vgui.Create( "Panel", self )
	self.Content:Dock( FILL )

	self.Items = {}
end

function PANEL:UseButtonOnlyStyle()
	self.ButtonOnly = true
end

function PANEL:AddSheet( label, panel, makeActive, onLoad )

	if ( !IsValid( panel ) ) then return end

	local Sheet = {}
	Sheet.Button = vgui.Create( "DButton", self.Navigation )
	Sheet.Button.Target = panel
	Sheet.Button:Dock( LEFT )
	Sheet.Button:DockMargin( 0, 0, 0, 0 )
	Sheet.Button:SetText( "" )
	Sheet.Button.label = label
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( label )
	Sheet.Button:SetWide( textX+30 )
	self.buttonsWide = (self.buttonsWide or 0)+(textX+30)
	self.Navigation.UpdateWide()
	local changeAlpha = 0
	local ButX, ButY = false, false
	local first = false
	if( #self.Items <= 0 ) then
		first = true
	end
	Sheet.Button.Paint = function( self2, w, h )
		if( not ButX or not ButY ) then
			ButX, ButY = self2:LocalToScreen( 0, 0 )
		end

		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		if( not first or not self.rounded ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.DrawRect( 0, h-2, w, 2 )
		else
			BRICKS_SERVER.Func.DrawPartialRoundedBoxEx( 5, 0, h-2, w, 2, BRICKS_SERVER.Func.GetTheme( 5 ), w, 10, 0, h-10, false, false, true, false )
		end
		surface.SetAlphaMultiplier( 1 )

		draw.SimpleText( label, "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	Sheet.Button.DoClick = function()
		self:SetActiveButton( Sheet.Button )
	end

	if( onLoad ) then
		Sheet.Button.onLoad = onLoad() 
	end

	Sheet.Button.label = label

	Sheet.Panel = panel
	Sheet.Panel:SetParent( self.Content )
	Sheet.Panel:SetVisible( false )

	if ( self.ButtonOnly ) then
		Sheet.Button:SizeToContents()
	end

	table.insert( self.Items, Sheet )

	if ( !IsValid( self.ActiveButton ) ) then
		self:SetActiveButton( Sheet.Button, true )
	elseif( makeActive ) then
		self:SetActiveButton( Sheet.Button )
	end
	
	return Sheet
end

function PANEL:AddButton( label, func )
	local sheetButton = vgui.Create( "DButton", self.Navigation )
	sheetButton:Dock( LEFT )
	sheetButton:DockMargin( 0, 0, 0, 0 )
	sheetButton:SetText( "" )
	sheetButton.label = label
	surface.SetFont( "BRICKS_SERVER_Font25" )
	local textX, textY = surface.GetTextSize( label )
	sheetButton:SetWide( textX+30 )
	self.buttonsWide = (self.buttonsWide or 0)+(textX+30)
	self.Navigation.UpdateWide()
	local changeAlpha = 0
	local ButX, ButY = false, false
	local first = false
	if( #self.Items <= 0 ) then
		first = true
	end
	sheetButton.Paint = function( self2, w, h )
		if( not ButX or not ButY ) then
			ButX, ButY = self2:LocalToScreen( 0, 0 )
		end

		if( self2:IsHovered() or self2.m_bSelected ) then
			changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
		else
			changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
		end

		surface.SetAlphaMultiplier( changeAlpha/255 )
		if( not first or not self.rounded ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
			surface.DrawRect( 0, h-2, w, 2 )
		else
			draw.RoundedBoxEx( 5, 0, h-20, w, 20, BRICKS_SERVER.Func.GetTheme( 5 ), false, false, true, false )
		end
		surface.SetAlphaMultiplier( 1 )

		if( first ) then
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
			surface.DrawRect( 0, h-20, w, 18 )
		end

		draw.SimpleText( label, "BRICKS_SERVER_Font25", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end
	sheetButton.DoClick = func
	
	return sheetButton
end

function PANEL:Think()
	for k, v in pairs( self.Items ) do
		if( v.Think ) then
			v.Think()
		end
	end
end

function PANEL:SetActiveButton( active, first )

	if ( self.ActiveButton == active ) then return end

	if ( self.ActiveButton && self.ActiveButton.Target ) then
		self.ActiveButton.Target:SetVisible( false )
		self.ActiveButton:SetSelected( false )
		self.ActiveButton:SetToggle( false )
	end

	self.ActiveButton = active
	active.Target:SetVisible( true )
	active:SetSelected( true )
	active:SetToggle( true )

	if( active.onLoad ) then
		active.onLoad()
	end

	self.Content:InvalidateLayout()

	if( not first and self.pageClickFunc ) then
		self.pageClickFunc( active.label )
	end
end

function PANEL:SetActiveSheet( sheetLabel )
	if( not sheetLabel ) then return end

	for k, v in pairs( self.Items ) do
		if( v.Button and v.Button.label and v.Button.label == sheetLabel ) then
			self:SetActiveButton( v.Button )
			break
		end
	end
end

function PANEL:ClearSheets()
	self.buttonsWide = 0
	self.Items = {}
	self.Navigation:Clear()
	self.Content:Clear()
end

derma.DefineControl( "bricks_server_colsheet_top", "", PANEL, "Panel" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_config_itemwhitelist.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel()
    function self.RefreshPanel()
        self:Clear()

        self.slots = nil
        if( self.grid and IsValid( self.grid ) ) then
            self.grid:Remove()
        end

        local entitySearchBarBack = vgui.Create( "DPanel", self )
        entitySearchBarBack:Dock( TOP )
        entitySearchBarBack:DockMargin( 0, 0, 0, 5 )
        entitySearchBarBack:SetTall( 40 )
        local search = Material( "materials/bricks_server/search.png" )
        local Alpha = 0
        local Alpha2 = 20
        local color1 = BRICKS_SERVER.Func.GetTheme( 2 )
        local entitySearchBar
        entitySearchBarBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            if( entitySearchBar:IsEditing() ) then
                Alpha = math.Clamp( Alpha+5, 0, 100 )
                Alpha2 = math.Clamp( Alpha2+20, 20, 255 )
            else
                Alpha = math.Clamp( Alpha-5, 0, 100 )
                Alpha2 = math.Clamp( Alpha2-20, 20, 255 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
        
            surface.SetDrawColor( 255, 255, 255, Alpha2 )
            surface.SetMaterial(search)
            local size = 24
            surface.DrawTexturedRect( w-size-(h-size)*0.5, (h-size)*0.5, size, size )
        end
    
        entitySearchBar = vgui.Create( "bricks_server_search", entitySearchBarBack )
        entitySearchBar:Dock( FILL )
        
        local entitySpacing = 5
        local gridWide = (ScrW()*0.6)-BRICKS_SERVER.DEVCONFIG.MainNavWidth-20
        local wantedSlotSize = 125*(ScrW()/2560)
        local slotsWide = math.floor( gridWide/wantedSlotSize )
    
        local slotSize = (gridWide-((slotsWide-1)*entitySpacing))/slotsWide
    
        local entityGrid = vgui.Create( "DIconLayout", self )
        entityGrid:Dock( TOP )
        entityGrid:SetSpaceY( entitySpacing )
        entityGrid:SetSpaceX( entitySpacing )
        entityGrid:SetTall( slotSize )

        local function CreateSlot( header, text, doClick, key )
            entityGrid.slots = (entityGrid.slots or 0)+1
            local slots = entityGrid.slots
            local slotsTall = math.ceil( slots/slotsWide )
            local newTall = (slotsTall*slotSize)+((slotsTall-1)*entitySpacing)
            if( entityGrid:GetTall() != newTall ) then
                entityGrid:SetTall( newTall )
            end

            local slotBack = entityGrid:Add( "DButton" )
            slotBack:SetSize( slotSize, slotSize )
            slotBack:SetText( "" )
            local changeAlpha = 0
            local x, y, w, h = 0, 0, slotSize, slotSize
            slotBack.Paint = function( self2, w, h )
                local toScreenX, toScreenY = self2:LocalToScreen( 0, 0 )
                if( x != toScreenX or y != toScreenY ) then
                    x, y = toScreenX, toScreenY
                end

                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

                if( key and BS_ConfigCopyTable.INVENTORY.Whitelist[key] ) then
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )
                end
                
                if( self2:IsDown() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 175 )
                elseif( self2:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 100 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 0, 100 )
                end

                surface.SetAlphaMultiplier( changeAlpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
                surface.SetAlphaMultiplier( 1 )

                draw.SimpleText( header, "BRICKS_SERVER_Font17B", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
                draw.SimpleText( text, "BRICKS_SERVER_Font17", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
            end
            slotBack.DoClick = function( self2 )
                doClick( self2, x, y, w, h )
            end
        end

        function self.FillEntityList()
            entityGrid:Clear()

            if( not BS_ConfigCopyTable.INVENTORY.Whitelist ) then
                BS_ConfigCopyTable.INVENTORY.Whitelist = {}
            end

            entityGrid.slots = 1

            for k, v in pairs( list.Get( "SpawnableEntities" ) ) do
                if( (entitySearchBar:GetValue() or "") != "" and not string.find( string.lower( v.PrintName or "" ), string.lower( entitySearchBar:GetValue() or "" ) ) and not string.find( string.lower( k ), string.lower( entitySearchBar:GetValue() or "" ) ) ) then
                    continue
                end

                local actions = {}
                if( not BS_ConfigCopyTable.INVENTORY.Whitelist[k] ) then
                    actions[BRICKS_SERVER.Func.L( "whitelist" )] = function() 
                        BS_ConfigCopyTable.INVENTORY.Whitelist[k] = { true, true }
                        self.FillEntityList()
                        BRICKS_SERVER.Func.ConfigChange( "INVENTORY" )
                    end
                else
                    actions[BRICKS_SERVER.Func.L( "unWhitelist" )] = function() 
                        BS_ConfigCopyTable.INVENTORY.Whitelist[k] = nil
                        self.FillEntityList()
                        BRICKS_SERVER.Func.ConfigChange( "INVENTORY" )
                    end
                end

                CreateSlot( (v.PrintName or BRICKS_SERVER.Func.L( "nil" )), k, function( slotBack, x, y, w, h )
                    slotBack.Menu = vgui.Create( "bricks_server_dmenu" )
                    for key, val in pairs( actions ) do
                        slotBack.Menu:AddOption( key, val )
                    end
                    slotBack.Menu:Open()
                    slotBack.Menu:SetPos( x+w+5, y+(h*0.5)-(slotBack.Menu:GetTall()*0.5) )
                end, k )
            end

            for k, v in pairs( BS_ConfigCopyTable.INVENTORY.Whitelist ) do
                if( list.Get( "SpawnableEntities" )[k] ) then continue end

                if( (entitySearchBar:GetValue() or "") != "" and not string.find( string.lower( k ), string.lower( entitySearchBar:GetValue() or "" ) ) ) then
                    continue
                end

                local actions = {}
                actions[BRICKS_SERVER.Func.L( "remove" )] = function() 
                    BS_ConfigCopyTable.INVENTORY.Whitelist[k] = nil
                    self.FillEntityList()
                    BRICKS_SERVER.Func.ConfigChange( "INVENTORY" )
                end

                CreateSlot( BRICKS_SERVER.Func.L( "custom" ), k, function( slotBack, x, y, w, h )
                    slotBack.Menu = vgui.Create( "bricks_server_dmenu" )
                    for key, val in pairs( actions ) do
                        slotBack.Menu:AddOption( key, val )
                    end
                    slotBack.Menu:Open()
                    slotBack.Menu:SetPos( x+w+5, y+(h*0.5)-(slotBack.Menu:GetTall()*0.5) )
                end, k )
            end

            local addNewButton = entityGrid:Add( "DButton" )
            addNewButton:SetText( "" )
            addNewButton:SetSize( slotSize, slotSize )
            local changeAlpha = 0
            local newMat = Material( "materials/bricks_server/add_64.png")
            addNewButton.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                
                if( self2:IsDown() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 175 )
                elseif( self2:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 100 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 0, 100 )
                end

                surface.SetAlphaMultiplier( changeAlpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
                surface.SetAlphaMultiplier( 1 )

                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
                surface.SetMaterial( newMat )
                local iconSize = 64
                surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )

                draw.SimpleText( BRICKS_SERVER.Func.L( "addCustom" ), "BRICKS_SERVER_Font17", w*0.5, h-10, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
            end
            addNewButton.DoClick = function()
                BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), BRICKS_SERVER.Func.L( "entClassWhitelist" ), "", function( text ) 
                    if( list.Get( "SpawnableEntities" )[text] ) then
                        notification.AddLegacy( BRICKS_SERVER.Func.L( "entClassAlreadyOnList" ), 1, 5 )
                        return
                    end

                    BS_ConfigCopyTable.INVENTORY.Whitelist[text] = { true, true }
                    self.FillEntityList()
                    BRICKS_SERVER.Func.ConfigChange( "INVENTORY" )
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
            end
        end
        self.FillEntityList()

        entitySearchBar.OnChange = function()
            self.FillEntityList()
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_itemwhitelist", PANEL, "bricks_server_scrollpanel" )
--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_dmenuoption.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_pMenu", "Menu" )
AccessorFunc( PANEL, "m_bChecked", "Checked" )
AccessorFunc( PANEL, "m_bCheckable", "IsCheckable" )

function PANEL:Init()

	self:SetContentAlignment( 4 )
	self:SetChecked( false )

end

function PANEL:SetSubMenu( menu )

	self.SubMenu = menu

	if ( !IsValid( self.SubMenuArrow ) ) then

		self.SubMenuArrow = vgui.Create( "DPanel", self )
		self.SubMenuArrow.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "MenuRightArrow", panel, w, h ) end

	end

end

function PANEL:AddSubMenu()

	local SubMenu = DermaMenu( self )
	SubMenu:SetVisible( false )
	SubMenu:SetParent( self )

	self:SetSubMenu( SubMenu )

	return SubMenu

end

function PANEL:OnCursorEntered()

	if ( IsValid( self.ParentMenu ) ) then
		self.ParentMenu:OpenSubMenu( self, self.SubMenu )
		return
	end

	self:GetParent():OpenSubMenu( self, self.SubMenu )

end

function PANEL:OnCursorExited()
end

function PANEL:Paint( w, h )
	if( self:IsHovered() ) then
		self.changeAlpha = math.Clamp( (self.changeAlpha or 0)+10, 0, 255 )
	else
		self.changeAlpha = math.Clamp( (self.changeAlpha or 0)-10, 0, 255 )
	end

	surface.SetAlphaMultiplier( (self.changeAlpha or 0)/255 )
	if( self.parentPanel.optionCount > 1 and self.position == 1 and not self.ParentMenu.dontRoundTop ) then
		draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), true, true, false, false )
	elseif( self.parentPanel.optionCount > 1 and self.position == self.parentPanel.optionCount ) then
		draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), false, false, true, true )
	elseif( self.parentPanel.optionCount == 1 ) then
		if( not self.ParentMenu.dontRoundTop ) then
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
		else
			draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ), false, false, true, true )
		end
	else
		surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 5 ) )
		surface.DrawRect( 0, 0, w, h )
	end
	surface.SetAlphaMultiplier( 1 )

	draw.SimpleText( self.label or BRICKS_SERVER.Func.L( "error" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

	--
	-- Draw the button text
	--
	return false

end

function PANEL:OnMousePressed( mousecode )

	self.m_MenuClicking = true

	DButton.OnMousePressed( self, mousecode )

end

function PANEL:OnMouseReleased( mousecode )

	DButton.OnMouseReleased( self, mousecode )

	if ( self.m_MenuClicking && mousecode == MOUSE_LEFT ) then

		self.m_MenuClicking = false
		CloseDermaMenus()

	end

end

function PANEL:DoRightClick()

	if ( self:GetIsCheckable() ) then
		self:ToggleCheck()
	end

end

function PANEL:DoClickInternal()

	if ( self:GetIsCheckable() ) then
		self:ToggleCheck()
	end

	if ( self.m_pMenu ) then

		self.m_pMenu:OptionSelectedInternal( self )

	end

end

function PANEL:ToggleCheck()

	self:SetChecked( !self:GetChecked() )
	self:OnChecked( self:GetChecked() )

end

function PANEL:OnChecked( b )
end

function PANEL:PerformLayout()

	self:SizeToContents()
	self:SetWide( self:GetWide() + 30 )

	local w = math.max( self:GetParent():GetWide(), self:GetWide() )

	self:SetSize( w, 40 )

	if ( IsValid( self.SubMenuArrow ) ) then

		self.SubMenuArrow:SetSize( 15, 15 )
		self.SubMenuArrow:CenterVertical()
		self.SubMenuArrow:AlignRight( 4 )

	end

	DButton.PerformLayout( self )

end

function PANEL:GenerateExample()

	-- Do nothing!

end

derma.DefineControl( "bricks_server_dmenuoption", "Menu Option Line", PANEL, "DButton" )

--PATH addons/____bricks_framework/lua/bricks_server/vgui/bricks_server_numberwang.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_numMin",		"Min" )
AccessorFunc( PANEL, "m_numMax",		"Max" )
AccessorFunc( PANEL, "m_iDecimals",		"Decimals" ) -- The number of decimal places in the output
AccessorFunc( PANEL, "m_fFloatValue",	"FloatValue" )
AccessorFunc( PANEL, "m_iInterval",		"Interval" )

-- AnchorValue and UnAnchorValue functions are internally used for "drag-changing" the value
local function AnchorValue( wang, button, mcode )

	button:OldOnMousePressed( mcode )
	wang.mouseAnchor = gui.MouseY()
	wang.valAnchor = wang:GetValue()

end

local function UnAnchorValue( wang, button, mcode )

	button:OldOnMouseReleased( mcode )
	wang.mouseAnchor = nil
	wang.valAnchor = nil

end

-- ScrollValue function is internally used for "scrolling" the value using mouse wheel
local function ScrollValue( wang, button, delta )

	wang:SetValue( wang:GetValue() + delta )

end

function PANEL:Init()

	self:SetDecimals( 2 )
	self:SetTall( 20 )
	self:SetMinMax( 0, 100 )

	self:SetInterval( 1 )

	self:SetUpdateOnType( true )
	self:SetNumeric( true )

	self.OnChange = function() self:OnValueChanged( self:GetValue() ) end

	self.Up = vgui.Create( "DButton", self )
	self.Up:SetText( "" )
	self.Up.DoClick = function( button, mcode ) self:SetValue( self:GetValue() + self:GetInterval() ) end
	self.Up.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "NumberUp", panel, w, h ) end

	self.Up.OldOnMousePressed = self.Up.OnMousePressed
	self.Up.OldOnMouseReleased = self.Up.OnMouseReleased
	self.Up.OnMousePressed = function( button, mcode ) AnchorValue( self, button, mcode ) end
	self.Up.OnMouseReleased = function( button, mcode ) UnAnchorValue( self, button, mcode ) end
	self.Up.OnMouseWheeled = function( button, delta ) self:SetValue( self:GetValue() + delta ) end

	self.Down = vgui.Create( "DButton", self )
	self.Down:SetText( "" )
	self.Down.DoClick = function( button, mcode ) self:SetValue( self:GetValue() - self:GetInterval() ) end
	self.Down.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "NumberDown", panel, w, h ) end

	self.Down.OldOnMousePressed = self.Down.OnMousePressed
	self.Down.OldOnMouseReleased = self.Down.OnMouseReleased
	self.Down.OnMousePressed = function( button, mcode ) AnchorValue( self, button, mcode ) end
	self.Down.OnMouseReleased = function( button, mcode ) UnAnchorValue( self, button, mcode ) end
	self.Down.OnMouseWheeled = function( button, delta ) self:SetValue( self:GetValue() + delta ) end

	self:SetValue( 0 )

end

function PANEL:HideWang()

	self.Up:Hide()
	self.Down:Hide()

end

function PANEL:Think()

	if ( self.mouseAnchor ) then
		self:SetValue( self.valAnchor + self.mouseAnchor - gui.MouseY() )
	end

end

function PANEL:SetDecimals( num )

	self.m_iDecimals = num
	self:SetValue( self:GetValue() )

end

function PANEL:SetMinMax( min, max )

	self:SetMin( min )
	self:SetMax( max )

end

function PANEL:SetMin( min )

	self.m_numMin = tonumber( min )

end

function PANEL:SetMax( max )

	self.m_numMax = tonumber( max )

end

function PANEL:GetFloatValue( max )

	if ( !self.m_fFloatValue ) then self.m_fFloatValue = 0 end

	return tonumber( self.m_fFloatValue ) or 0

end

function PANEL:SetValue( val )

	if ( val == nil ) then return end

	local OldValue = val
	val = tonumber( val )
	val = val or 0

	if ( self.m_numMax != nil ) then
		val = math.min( self.m_numMax, val )
	end

	if ( self.m_numMin != nil ) then
		val = math.max( self.m_numMin, val )
	end

	if ( self.m_iDecimals == 0 ) then

		val = Format( "%i", val )

	elseif ( val != 0 ) then

		val = Format( "%." .. self.m_iDecimals .. "f", val )

		-- Trim trailing 0's and .'s 0 this gets rid of .00 etc
		val = string.TrimRight( val, "0" )
		val = string.TrimRight( val, "." )

	end

	--
	-- Don't change the value while we're typing into it!
	-- It causes confusion!
	--
	if ( !self:HasFocus() ) then
		self:SetText( val )
		self:ConVarChanged( val )
	end

	self:OnValueChanged( tonumber( val ) )

end

local meta = FindMetaTable( "Panel" )

function PANEL:GetValue()

	return tonumber( meta.GetValue( self ) ) or 0

end

function PANEL:PerformLayout()

	local s = math.floor( self:GetTall() * 0.5 )

	self.Up:SetSize( s, s - 1 )
	self.Up:AlignRight( 3 )
	self.Up:AlignTop( 0 )

	self.Down:SetSize( s, s - 1 )
	self.Down:AlignRight( 3 )
	self.Down:AlignBottom( 2 )

end

function PANEL:SizeToContents()

	-- Size based on the max number and max amount of decimals

	local chars = 0

	local min = math.Round( self:GetMin(), self:GetDecimals() )
	local max = math.Round( self:GetMax(), self:GetDecimals() )

	local minchars = string.len( "" .. min .. "" )
	local maxchars = string.len( "" .. max .. "" )

	chars = chars + math.max( minchars, maxchars )

	if ( self:GetDecimals() && self:GetDecimals() > 0 ) then

		chars = chars + 1 -- .
		chars = chars + self:GetDecimals()

	end

	self:InvalidateLayout( true )
	self:SetWide( chars * 6 + 10 + 5 + 5 )
	self:InvalidateLayout()

end

function PANEL:GetFraction( val )

	local Value = val or self:GetValue()

	local Fraction = ( Value - self.m_numMin ) / ( self.m_numMax - self.m_numMin )
	return Fraction

end

function PANEL:SetFraction( val )

	local Fraction = self.m_numMin + ( (self.m_numMax - self.m_numMin) * val )
	self:SetValue( Fraction )

end

function PANEL:OnValueChanged( val )

end

function PANEL:GetTextArea()

	return self

end

function PANEL:GenerateExample( ClassName, PropertySheet, Width, Height )

	local ctrl = vgui.Create( ClassName )
	ctrl:SetDecimals( 0 )
	ctrl:SetMinMax( 0, 255 )
	ctrl:SetValue( 3 )

	PropertySheet:AddSheet( ClassName, ctrl, nil, true, true )

end

derma.DefineControl( "bricks_server_numberwang", "Menu Option Line", PANEL, "bricks_server_textentry" )

--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/shared/sh_gang_system.lua:
function BRICKS_SERVER.Func.GetGangExpToLevel( from, to )
    local totalExp = 0

    for i = 0, (to-from)-1 do
        local levelExp = BRICKS_SERVER.CONFIG.GANGS["Original EXP Required"]*(BRICKS_SERVER.CONFIG.GANGS["EXP Required Increase"]^(from+i) )
        totalExp = totalExp+levelExp
    end

    return totalExp
end

function BRICKS_SERVER.Func.GetGangCurLevelExp( gangID )
    local gangTable = (BRICKS_SERVER_GANGS or {})[gangID or 0]

    if( not gangTable ) then
        return 0
    end

    return (gangTable.Experience or 0)-BRICKS_SERVER.Func.GetGangExpToLevel( 0, gangTable.Level or 0 )
end

function BRICKS_SERVER.Func.GangGetLevel( gangID )
    local gangTable = (BRICKS_SERVER_GANGS or {})[gangID or 0]

    if( not gangTable ) then
        return 0
    end

    return gangTable.Level or 0
end

function BRICKS_SERVER.Func.FormatGangEXP( number )
	local finalString = number
	
	if( finalString > 1000000 ) then
		finalString = math.Round( finalString/1000000, 1 ) .. "M"
	elseif( finalString > 1000 ) then
		finalString = math.Round( finalString/1000, 1 ) .. "K"
	else
		finalString = math.Round( finalString )
	end

	return finalString
end

function BRICKS_SERVER.Func.GangGetUpgradeInfo( gangID, key, newGangTable )
    local gangTable = (not newGangTable and ((BRICKS_SERVER_GANGS or {})[gangID] or {})) or newGangTable

    local upgradesConfig = (BRICKS_SERVER.CONFIG.GANGS.Upgrades or {})[key] or {}
    local upgradesConfigTiers = upgradesConfig.Tiers or {}

    if( not gangTable or not gangTable.Upgrades or not gangTable.Upgrades[key] ) then
        return upgradesConfig.Default or {}
    end
    
    local upgrade = math.Clamp( (gangTable.Upgrades[key] or 1), 0, #upgradesConfigTiers )

    local reqInfo, devConfigReqInfo = (upgradesConfigTiers[upgrade] or {}).ReqInfo, (BRICKS_SERVER.DEVCONFIG.GangUpgrades[key] or {}).ReqInfo or {}
    if( reqInfo and #reqInfo >= #devConfigReqInfo ) then
        return reqInfo
    else
        local reqInfoDefault = {}
        for k, v in pairs( devConfigReqInfo ) do
            if( v[2] == "integer" ) then
                reqInfoDefault[k] = 0
            elseif( v[2] == "table" ) then
                reqInfoDefault[k] = {}
            else
                reqInfoDefault[k] = ""
            end
        end

        return reqInfoDefault
    end
end

function BRICKS_SERVER.Func.GangGetUpgradeBought( gangID, key )
    local gangTable = (BRICKS_SERVER_GANGS or {})[gangID] or {}

    if( gangTable and gangTable.Upgrades and gangTable.Upgrades[key] and gangTable.Upgrades[key] > 0 ) then
        return true
    end

    return false
end

function BRICKS_SERVER.Func.GangGetInboxReqInfo( receiverKey, inboxKey )
    if( BRS_GANG_INBOXES and BRS_GANG_INBOXES[receiverKey] and BRS_GANG_INBOXES[receiverKey][inboxKey] and BRS_GANG_INBOXES[receiverKey][inboxKey].ReqInfo ) then 
        return BRS_GANG_INBOXES[receiverKey][inboxKey].ReqInfo
    end

    return false
end

function BRICKS_SERVER.Func.CheckGangName( name )
	local nameLen = string.len( name )
	if( nameLen > BRICKS_SERVER.DEVCONFIG.GangNameCharMax or nameLen < BRICKS_SERVER.DEVCONFIG.GangNameCharMin ) then return false end

	if( string.match( string.Replace( name, " ", "" ), "[%W]" ) ) then return false end

    return true
end

function BRICKS_SERVER.Func.CheckGangIconURL( url )
    if( not string.StartWith( url, "http" ) ) then
        for k, v in ipairs( BRICKS_SERVER.DEVCONFIG.PresetGangIcons ) do
            if( url == v ) then return true end
        end

        return false
    end

    if( string.len( url ) > BRICKS_SERVER.DEVCONFIG.GangIconCharLimit ) then return false end 

    local validImageEndings = { ".png", ".jpg", ".jpeg" }
    local foundValidEnding = false
    for k, v in ipairs( validImageEndings ) do
        if( not string.EndsWith( url, v ) ) then continue end

        foundValidEnding = true
        break
    end

    if( not foundValidEnding ) then return false end

    for k, v in ipairs( BRICKS_SERVER.DEVCONFIG.GangURLWhitelist ) do
        if( string.StartWith( url, v ) ) then return true end
    end

    return false
end
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gangmenu_admin_popup.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel( panelWide, panelTall )
    self.panelWide, self.panelTall = panelWide, panelTall

    local popoutClose = vgui.Create( "DButton", self )
    popoutClose:SetSize( self.panelWide, self.panelTall )
    popoutClose:SetText( "" )
    popoutClose:SetAlpha( 0 )
    popoutClose:AlphaTo( 255, 0.2 )
    popoutClose:SetCursor( "arrow" )
    popoutClose.Paint = function( self2, w, h )
        surface.SetDrawColor( 0, 0, 0, 150 )
        surface.DrawRect( 0, 0, w, h )
        BRICKS_SERVER.Func.DrawBlur( self2, 2, 2 )
    end
    local function closePopoutFunc()
        if( IsValid( self.popout ) ) then
            self.popout:SizeTo( 0, 0, 0.2, 0, -1, function()
                if( IsValid( self.popout ) ) then
                    self.popout:Remove()
                end
            end )
        end

        popoutClose:AlphaTo( 0, 0.2, 0, function()
            if( IsValid( popoutClose ) ) then
                popoutClose:Remove()
            end
        end )

        timer.Simple( 0.2, function()
            if( IsValid( self ) ) then
                self:Remove()
            end
        end )
    end
    popoutClose.DoClick = closePopoutFunc

    self.popout = vgui.Create( "DPanel", self )
    self.popout:SetSize( 0, 0 )
    self.popout:SizeTo( self.panelWide*0.65, self.panelTall*0.25, 0.2 )
    self.popout.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
    end
    self.popout.OnSizeChanged = function( self2 )
        self2:SetPos( (self.panelWide*0.5)-(self2:GetWide()*0.5), (self.panelTall*0.5)-(self2:GetTall()*0.5) )
    end

    self.closeButton = vgui.Create( "DButton", self.popout )
    self.closeButton:Dock( BOTTOM )
    self.closeButton:SetTall( 40 )
    self.closeButton:SetText( "" )
    self.closeButton:DockMargin( 25, 0, 25, 25 )
    local changeAlpha = 0
    self.closeButton.Paint = function( self2, w, h )
        if( not self2:IsDown() and self2:IsHovered() ) then
            changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
        else
            changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
        end
        
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )

        surface.SetAlphaMultiplier( changeAlpha/255 )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
        surface.SetAlphaMultiplier( 1 )

        BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 4 ) )
        
        draw.SimpleText( BRICKS_SERVER.Func.L( "close" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end
    self.closeButton.DoClick = closePopoutFunc

    self.popoutContent = vgui.Create( "DPanel", self.popout )
    self.popoutContent:Dock( FILL )
    self.popoutContent.Paint = function( self2, w, h ) end

    local loadingPanel = vgui.Create( "DPanel", self.popoutContent )
    loadingPanel:Dock( FILL )
    loadingPanel:DockMargin( 25, 10, 25, 10 )
    local loadingIcon = Material( "materials/bricks_server/loading.png" )
    loadingPanel.Paint = function( self2, w, h )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( loadingIcon )
        local size = 32
        surface.DrawTexturedRectRotated( w*0.5, h*0.5, size, size, -(CurTime() % 360 * 250) )
    
        draw.SimpleText( BRICKS_SERVER.Func.L( "loading" ), "BRICKS_SERVER_Font20", w*0.5, h*0.5+(size*0.5)+5, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
    end

    hook.Add( "BRS.Hooks.RefreshGangAdminData", "BricksServerHooks_BRS_RefreshGangAdminData_" .. tostring( self.popout ), function( gangID, gangTable )
        if( IsValid( self ) and IsValid( self.popout ) ) then
            self:RefreshPanel( gangID, gangTable )
        else
            hook.Remove( "BRS.Hooks.RefreshGangAdminData", "BricksServerHooks_BRS_RefreshGangAdminData_" .. tostring( self.popout ) )
        end
    end )
end

function PANEL:RefreshPanel( gangID, gangTable )
    if( not gangTable ) then 
        closePopoutFunc()
        
        BRICKS_SERVER.Func.Message( BRICKS_SERVER.Func.L( "gangFailedToLoad" ), BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "confirm" ) )
        return 
    end

    self.gangID, self.gangTable = gangID, gangTable

    if( self.activePage and self.activePage != BRICKS_SERVER.Func.L( "main" ) ) then return end

    self.activePage = BRICKS_SERVER.Func.L( "main" )

    self.popoutContent:Clear()

    local popoutWide = self.panelWide*0.75

    local avatarBackSize = 70

    local infoPanel = vgui.Create( "DPanel", self.popoutContent )
    infoPanel:Dock( TOP )
    infoPanel:DockMargin( 25, 25, 25, 0 )
    infoPanel:SetTall( avatarBackSize )
    local avatarSize = (gangTable.Icon and avatarBackSize*0.6) or 32
    infoPanel.Paint = function( self2, w, h )

        surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 3 ) )
        draw.NoTexture()
        BRICKS_SERVER.Func.DrawCircle( h*0.5, h*0.5, avatarBackSize*0.5, avatarBackSize*0.5 )

        draw.SimpleText( (gangTable.Name or BRICKS_SERVER.Func.L( "gangNone" )), "BRICKS_SERVER_Font25", h+15, h*0.5+2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_BOTTOM )

        draw.SimpleText( BRICKS_SERVER.Func.L( "gangID", (gangID or 0) ), "BRICKS_SERVER_Font20", h+15, h*0.5-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
    end

    local gangIcon = vgui.Create( "bricks_server_gangicon", infoPanel )
    gangIcon:SetSize( avatarSize, avatarSize )
    gangIcon:SetPos( (avatarBackSize-avatarSize)*0.5, (avatarBackSize-avatarSize)*0.5 )
    gangIcon:SetIconURL( gangTable.Icon or "bricks_server/question.png" )

    local gridWide = popoutWide-50

    local graphs = {
        [1] = {
            Title = BRICKS_SERVER.Func.L( "gangMembers" ),
            Color = Color( 41, 128, 185 ),
            GetValue = function() return table.Count( gangTable.Members or {} ) end,
            GetMax = function() return BRICKS_SERVER.Func.GangGetUpgradeInfo( gangID, "MaxMembers", gangTable )[1] end
        },
        [2] = {
            Title = BRICKS_SERVER.Func.L( "gangBalance" ),
            Color = Color( 39, 174, 96 ),
            GetValue = function() return gangTable.Money or 0 end,
            GetMax = function() return BRICKS_SERVER.Func.GangGetUpgradeInfo( gangID, "MaxBalance", gangTable )[1] end,
            Format = function( value ) return DarkRP.formatMoney( value ) end
        },
        [4] = {
            Title = function() return BRICKS_SERVER.Func.L( "levelX", (gangTable.Level or 0) ) end,
            Color = Color( 22, 160, 133 ),
            GetValue = function() return (gangTable.Experience or 0)-BRICKS_SERVER.Func.GetGangExpToLevel( 0, (gangTable.Level or 0) ) end,
            GetMax = function() return BRICKS_SERVER.Func.GetGangExpToLevel( (gangTable.Level or 0), (gangTable.Level or 0)+1 ) end,
            Format = function( value ) return BRICKS_SERVER.Func.FormatGangEXP( value+BRICKS_SERVER.Func.GetGangExpToLevel( 0, (gangTable.Level or 0) ) ) end
        }
    }

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "gangs", "storage" ) ) then
        graphs[3] = {
            Title = BRICKS_SERVER.Func.L( "gangStorage" ),
            Color = Color( 231, 76, 60 ),
            GetValue = function() return table.Count( gangTable.Storage or {} ) end,
            GetMax = function() return BRICKS_SERVER.Func.GangGetUpgradeInfo( gangID, "StorageSlots", gangTable )[1] end
        }
    else
        graphs[3] = {
            Title = BRICKS_SERVER.Func.L( "gangStorage" ),
            Color = Color( 231, 76, 60 ),
            GetValue = function() return 0 end,
            GetMax = function() return 1 end
        }
    end

    local spacing = 25
    local graphWide = (gridWide-((#graphs-1)*spacing))/#graphs

    local graphPanel = vgui.Create( "DPanel", self.popoutContent )
    graphPanel:Dock( TOP )
    graphPanel:DockMargin( 25, 25, 25, 0 )
    graphPanel:SetTall( graphWide )
    graphPanel.Paint = function( self2, w, h ) end

    for k, v in ipairs( graphs ) do
        local graph = vgui.Create( "DPanel", graphPanel )
        graph:Dock( LEFT )
        graph:DockMargin( 0, 0, spacing, 0 )
        graph:SetWide( graphWide )
        local outerWidth = 5
        local themeColor = v.Color or BRICKS_SERVER.Func.GetTheme( 5 )
        local shadowColor = Color( 0, 0, 0 )
        local txtSpacing = 1
        graph.Paint = function( self2, w, h ) 
            BRICKS_SERVER.Func.DrawArc( w*0.5, h*0.5, w*0.5, outerWidth, 0, 360, BRICKS_SERVER.Func.GetTheme( 3 ) )

            local value, max = v.GetValue(), v.GetMax()
            local degree = math.Clamp( 360*(value/max), 0, 360 )

            BRICKS_SERVER.Func.DrawArc( w*0.5, h*0.5, w*0.5, outerWidth, 90, degree+90, themeColor )

            --BRICKS_SERVER.Func.DrawCircle( w*0.5, h*0.5, (w-outerWidth)*0.5, Color( themeColor.r, themeColor.g, themeColor.b, 75 ), -90, degree-90 )

            local title = v.Title
            if( isfunction( title ) ) then
                title = title()
            end

            draw.SimpleText( title, "BRICKS_SERVER_Font23", w*0.5-1, h*0.5+txtSpacing+1, shadowColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
            draw.SimpleText( title, "BRICKS_SERVER_Font23", w*0.5, h*0.5+txtSpacing, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )

            local valueTxt, maxTxt = value, max
            if( v.Format ) then
                valueTxt, maxTxt = v.Format( value ), v.Format( max )
            end

            draw.SimpleText( valueTxt .. "/" .. maxTxt, "BRICKS_SERVER_Font17", w*0.5-1, h*0.5-txtSpacing+1, shadowColor, TEXT_ALIGN_CENTER, 0 )
            draw.SimpleText( valueTxt .. "/" .. maxTxt, "BRICKS_SERVER_Font17", w*0.5, h*0.5-txtSpacing, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, 0 )
        end
    end

    local spacing = 5
    local actionGrid = vgui.Create( "DIconLayout", self.popoutContent )
    actionGrid:Dock( TOP )
    actionGrid:DockMargin( 25, 25, 25, 0 )
    actionGrid:SetSpaceY( spacing )
    actionGrid:SetSpaceX( spacing )

    local wantedSlotSize = 125
    local slotsWide = math.floor( gridWide/wantedSlotSize )
    local slotSize = (gridWide-((slotsWide-1)*spacing))/slotsWide

    local function GetNextQuery( currentQuery, reqInfo, currentReqInfo, func )
        currentQuery = currentQuery+1

        if( currentQuery > #reqInfo ) then return end

        local reqInfoEntry = reqInfo[currentQuery]

        if( reqInfoEntry[2] == "string" or reqInfoEntry[2] == "integer" ) then 
            BRICKS_SERVER.Func.StringRequest( BRICKS_SERVER.Func.L( "admin" ), reqInfoEntry[4], 0, function( text ) 
                currentReqInfo[currentQuery] = text

                if( currentQuery >= #reqInfo ) then
                    func( currentReqInfo )
                end
            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), (reqInfoEntry[2] == "integer") )
        elseif( reqInfoEntry[2] == "table" and reqInfoEntry[3] and BRICKS_SERVER.Func.GetList( reqInfoEntry[3] ) ) then 
            BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "admin" ), reqInfoEntry[4], "", BRICKS_SERVER.Func.GetList( reqInfoEntry[3] ), function( value, data ) 
                if( BRICKS_SERVER.Func.GetList( reqInfoEntry[3] )[data] ) then
                    currentReqInfo[currentQuery] = data

                    if( currentQuery >= #reqInfo ) then
                        func( currentReqInfo )
                    end
                else
                    notification.AddLegacy( BRICKS_SERVER.Func.L( "invalidChoice" ), 1, 3 )
                end
            end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ), true )
        end

        GetNextQuery( currentQuery, reqInfo, currentReqInfo, func )
    end

    local actionButtons = 0
    for k, v in ipairs( BRICKS_SERVER.DEVCONFIG.GangAdminCmds ) do
        if( not v.Icon or not v.Name ) then continue end
        
        actionButtons = actionButtons+1
        local newTall = (math.ceil( actionButtons/slotsWide )*slotSize)+((math.ceil( actionButtons/slotsWide )-1)*spacing)

        if( actionGrid:GetTall() != newTall ) then
            actionGrid:SetTall( newTall )
        end


        local actionButton = actionGrid:Add( "DButton" )
        actionButton:SetSize( slotSize, slotSize )
        actionButton:SetText( "" )
        local Alpha, iconAlpha = 0, 0
        local iconMat
        BRICKS_SERVER.Func.GetImage( v.Icon or "admin.png", function( mat ) 
            iconMat = mat 
        end )
        actionButton.Paint = function( self2, w, h )
            if( self2:IsHovered() and not self2:IsDown() ) then
                Alpha = math.Clamp( Alpha+10, 0, 50 )
            else
                Alpha = math.Clamp( Alpha-10, 0, 50 )
            end

            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
            draw.RoundedBox( 5, 0, 0, w, h, Color( BRICKS_SERVER.Func.GetTheme( 3 ).r, BRICKS_SERVER.Func.GetTheme( 3 ).g, BRICKS_SERVER.Func.GetTheme( 3 ).b, Alpha ) )

            BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )

            if( self2:IsHovered() and not self2:IsDown() ) then
                iconAlpha = math.Clamp( iconAlpha+10, 20, 255 )
            else
                iconAlpha = math.Clamp( iconAlpha-10, 20, 255 )
            end

            if( iconMat ) then
                surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, iconAlpha )
                surface.SetMaterial( iconMat )
                local iconSize = 64
                surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
            end

            draw.SimpleText( v.Name, "BRICKS_SERVER_Font15", w*0.5, h-5, Color( BRICKS_SERVER.Func.GetTheme( 6 ).r, BRICKS_SERVER.Func.GetTheme( 6 ).g, BRICKS_SERVER.Func.GetTheme( 6 ).b, iconAlpha ), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM )
        end
        actionButton.DoClick = function()
            if( v.ClientFunc ) then
                v.ClientFunc( gangTable, gangID, self )
            elseif( v.ServerFunc ) then
                GetNextQuery( 0, v.ReqInfo, {}, function( reqInfo )
                    net.Start( "BRS.Net.AdminGangCMD" )
                        net.WriteUInt( k, 8 )
                        net.WriteUInt( gangID, 16 )
                        net.WriteTable( reqInfo )
                    net.SendToServer()
                end )
            end
        end
    end

    if( self.popoutContent:GetAlpha() != 255 ) then
        self.popoutContent:SetAlpha( 0 )
        self.popoutContent:AlphaTo( 255, 0.2 )
    end

    local popoutTall = self.closeButton:GetTall()+25+infoPanel:GetTall()+25+graphPanel:GetTall()+25+actionGrid:GetTall()+50
    if( self.popout:GetWide() != popoutWide or self.popout:GetTall() != popoutTall ) then
        self.popout:SizeTo( popoutWide, popoutTall, 0.2 )
    end
end

function PANEL:FillMembers()
    self.popoutContent:Clear()

    local topBar = vgui.Create( "DPanel", self.popoutContent )
    topBar:Dock( TOP )
    topBar:DockMargin( 10, 10, 10, 0 )
    topBar:SetTall( 40 )
    topBar.Paint = function( self2, w, h ) 

    end

    local backButton = vgui.Create( "DButton", topBar )
    backButton:Dock( LEFT )
    backButton:SetWide( topBar:GetTall() )
    backButton:SetText( "" )
    local Alpha = 0
    local backMat = Material( "bricks_server/back.png" )
    backButton.Paint = function( self2, w, h ) 
        if( not self2:IsDown() and self2:IsHovered() ) then
            Alpha = math.Clamp( Alpha+5, 0, 100 )
        else
            Alpha = math.Clamp( Alpha-5, 0, 100 )
        end

        surface.SetAlphaMultiplier( Alpha/255 )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )
        surface.SetAlphaMultiplier( 1 )

        BRICKS_SERVER.Func.DrawClickCircle( self2, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )

        surface.SetDrawColor( 255, 255, 255, 20+(235*(Alpha/100)) )
        surface.SetMaterial( backMat )
        local iconSize = 24
        surface.DrawTexturedRect( (w*0.5)-(iconSize*0.5), (h*0.5)-(iconSize*0.5), iconSize, iconSize )
    end
    backButton.DoClick = function()
        self.activePage = BRICKS_SERVER.Func.L( "main" )

        self:RefreshPanel( self.gangID, self.gangTable )
    end

    local searchBarBack = vgui.Create( "DPanel", topBar )
    searchBarBack:Dock( FILL )
    searchBarBack:DockMargin( 5, 0, 0, 0 )
    local search = Material( "materials/bricks_server/search.png" )
    local Alpha = 0
    local Alpha2 = 20
    local searchBar
    local color1 = BRICKS_SERVER.Func.GetTheme( 2 )
    searchBarBack.Paint = function( self2, w, h )
        draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )

        if( searchBar:IsEditing() ) then
            Alpha = math.Clamp( Alpha+5, 0, 100 )
            Alpha2 = math.Clamp( Alpha2+20, 20, 255 )
        else
            Alpha = math.Clamp( Alpha-5, 0, 100 )
            Alpha2 = math.Clamp( Alpha2-20, 20, 255 )
        end
        
        draw.RoundedBox( 5, 0, 0, w, h, Color( color1.r, color1.g, color1.b, Alpha ) )
    
        surface.SetDrawColor( 255, 255, 255, Alpha2 )
        surface.SetMaterial(search)
        local size = 24
        surface.DrawTexturedRect( w-size-(h-size)*0.5, (h-size)*0.5, size, size )
    end
    
    searchBar = vgui.Create( "bricks_server_search", searchBarBack )
    searchBar:Dock( FILL )

    local scrollPanel = vgui.Create( "bricks_server_scrollpanel", self.popoutContent )
    scrollPanel:Dock( FILL )
    scrollPanel:DockMargin( 10, 5, 10, 10 )

    function self.RefreshMembers()
        scrollPanel:Clear()

        local showMembers = {}
        for k, v in pairs( self.gangTable.Members ) do
            if( (searchBar:GetValue() != "" and not string.find( string.lower( v[1] ), string.lower( searchBar:GetValue() ) )) ) then
                continue
            end
            
            local memberPly = player.GetBySteamID( k )

            table.insert( showMembers, { v[2]+((not IsValid( memberPly ) and 100) or 0), IsValid( memberPly ), k, v[1], v[2] } ) -- sort value, online, steamid, name, groupid
        end

        table.SortByMember( showMembers, 1, true )

        for k, v in ipairs( showMembers ) do
            local actions = {}

            table.insert( actions, { BRICKS_SERVER.Func.L( "gangSetRank" ), function()
                local options = {}
                for k, v in pairs( self.gangTable.Roles or {} ) do
                    options[k] = v[1]
                end

                BRICKS_SERVER.Func.ComboRequest( BRICKS_SERVER.Func.L( "gang" ), BRICKS_SERVER.Func.L( "gangRankQuery" ), (v[5] or 1), options, function( value, data ) 
                    if( (self.gangTable.Roles or {})[data] ) then
                        if( v[5] != data ) then
                            net.Start( "BRS.Net.AdminGangCMD" )
                                net.WriteUInt( 7, 8 )
                                net.WriteUInt( self.gangID, 16 )
                                net.WriteTable( { v[3], data } )
                            net.SendToServer()
                        else
                            notification.AddLegacy( BRICKS_SERVER.Func.L( "gangPlayerAlreadyRank" ), 1, 3 )
                        end
                    else
                        notification.AddLegacy( BRICKS_SERVER.Func.L( "gangInvalidRank" ), 1, 3 )
                    end
                end, function() end, BRICKS_SERVER.Func.L( "ok" ), BRICKS_SERVER.Func.L( "cancel" ) )
            end } )

            if( self.gangTable.Owner != v[3] ) then
                table.insert( actions, { BRICKS_SERVER.Func.L( "gangKick" ), function()
                    net.Start( "BRS.Net.AdminGangCMD" )
                        net.WriteUInt( 6, 8 )
                        net.WriteUInt( self.gangID, 16 )
                        net.WriteTable( { v[3] } )
                    net.SendToServer()
                end } )

                table.insert( actions, { BRICKS_SERVER.Func.L( "gangSetOwner" ), function()
                    net.Start( "BRS.Net.AdminGangCMD" )
                        net.WriteUInt( 8, 8 )
                        net.WriteUInt( self.gangID, 16 )
                        net.WriteTable( { v[3] } )
                    net.SendToServer()
                end } )
            end

            local playerBack = BRICKS_SERVER.Func.GangCreateMemberSlot( scrollPanel, (self.panelWide*0.3)-20, 75, v[3], v[4], v[5], self.gangTable, actions )
            playerBack:Dock( TOP )
            playerBack:DockMargin( 0, 0, 0, 5 )
        end
    end
    self.RefreshMembers()

    searchBar.OnChange = function()
        self.RefreshMembers()
    end
end

function PANEL:ViewMembers()
    self.activePage = BRICKS_SERVER.Func.L( "gangMembers" )

    self.popoutContent:AlphaTo( 0, 0.1, 0, function()
        self:FillMembers()
        self.popoutContent:AlphaTo( 255, 0.1 )
    end )

    local popoutWide, popoutTall = self.panelWide*0.3, self.panelTall*0.7
    self.popout:SizeTo( popoutWide, popoutTall, 0.2 )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_admin_popup", PANEL, "DPanel" )
--PATH addons/____bricks_gangs/lua/bricks_server/modules/gangs/submodules/achievements/shared/sh_gang_achievements.lua:
function BRICKS_SERVER.Func.GangGetAchievementCompleted( gangID, key )
    local gangTable = (BRICKS_SERVER_GANGS or {})[gangID] or {}

    if( gangTable and gangTable.Achievements and gangTable.Achievements[key] and gangTable.Achievements[key] == true ) then
        return true
    end

    return false
end
--PATH addons/_doctor/lua/autorun/client/cl_blues_pharmaceuticals.lua:
include("blues_pharm_config.lua")
include("blues_pharm_translation.lua")

BLUES_PHARMA = BLUES_PHARMA or {}

--Contains a list of all pooled color materials (prevent refresh)
BLUES_PHARMA.PooledMaterials = BLUES_PHARMA.PooledMaterials or {}

--This is the chemical this player has selected if any
BLUES_PHARMA.SelectedChemical = BLUES_PHARMA.SelectedChemical  or nil

--The table used to generate the liquid material
BLUES_PHARMA.LiquidMaterialTable = {
	["$basetexture"] = "blues_pharm/beaker_liquid_color",
	["$envmap"] = "env_cubemap",
	["$envmaptint"] = Vector(255 * 0.2, 255 * 0.2, 255 * 0.2),
	["$envmapcontrast"] = 0.5,
	["$envmapsaturation"] = 0,
	["$envmapfresnel"] = 1,
	["$color2"] = Vector(1,1,1)
}

hook.Add( "PreDrawHalos", "BLUES_PHARMA_HOLOS", function()
	if IsValid(BLUES_PHARMA.SelectedChemical) then
		local rate = (math.sin(CurTime() * 8) + 1) * 0.5
		halo.Add({BLUES_PHARMA.SelectedChemical}, BLUES_PHARMA:LerpColor(Color(0, 0, 0), Color(255, 255, 255), rate), 10, 10, 3, true)
	end
end)

local UIOffset = -30

hook.Add("HUDPaint", "BLUES_PHARMA_DRAW_CHEMICAL", function()
	if IsValid(BLUES_PHARMA.SelectedChemical) then
		UIOffset = Lerp(10 * FrameTime(), UIOffset, -40)

		--Get legnth of text
		surface.SetFont("BP_Chemical_UI_Name")
		local str = "'"..string.upper(BLUES_PHARMA.Chemicals[BLUES_PHARMA.SelectedChemical.ChemicalID].name).."' "..BLUES_PHARMA.TRANS.Selected
		local lenX, lenY = surface.GetTextSize(str) 
		lenX = math.Clamp(lenX, 400, 1920)

		--drawing a box with rounded ended or not gives different round results???
		local round = math.floor(UIOffset)

		local backgroundXPos = math.floor(ScrW()*0.5 - ((lenX*0.5) + 10))

		--Draw background box
		draw.RoundedBoxEx(8, backgroundXPos, ScrH() - 155 - round, lenX + 20, 60, Color(45, 52, 54, 240), true, true, false, false)
		draw.RoundedBox(0, backgroundXPos, ScrH() - 95 - round, lenX + 20, 110, Color(45, 52, 54, 200))

		draw.SimpleText(str, "BP_Chemical_UI_Name", ScrW()*0.5  + 3, ScrH() - 123 - round, Color(0,0, 0,255), 1, 1)
		draw.SimpleText(str, "BP_Chemical_UI_Name", ScrW()*0.5, ScrH() - 126 - round, BLUES_PHARMA.Chemicals[BLUES_PHARMA.SelectedChemical.ChemicalID].color, 1, 1)

		draw.SimpleText(BLUES_PHARMA.TRANS.Pour, "BP_Chemical_UI_Name2", ScrW()*0.5 + 1, ScrH() - 78 - round, Color(0,0, 0,255), 1, 1)
		draw.SimpleText(BLUES_PHARMA.TRANS.Pour, "BP_Chemical_UI_Name2", ScrW()*0.5, ScrH() - 80 - round, Color(223, 230, 233), 1, 1)

		draw.SimpleText(BLUES_PHARMA.TRANS.Cancel, "BP_Chemical_UI_Name2", ScrW()*0.5 + 1, ScrH() - 55 - round, Color(0,0, 0,255), 1, 1)
		draw.SimpleText(BLUES_PHARMA.TRANS.Cancel, "BP_Chemical_UI_Name2", ScrW()*0.5, ScrH() - 57 - round, Color(223, 230, 233), 1, 1)
	else
		UIOffset = -200
	end
end)

--Handle deselecting
hook.Add("Think","BLUES_PHARMA_DESELECT", function()
	if IsValid(BLUES_PHARMA.SelectedChemical) then
		if input.IsButtonDown(KEY_X) then
			BLUES_PHARMA:DeselectChemical()
		else
			--Check out distance to the jar
			if LocalPlayer():GetPos():Distance(BLUES_PHARMA.SelectedChemical:GetPos()) > 250 then
				BLUES_PHARMA:DeselectChemical()
			end
		end
	end
end)

--Lerps a color
function BLUES_PHARMA:LerpColor(a, b, t)
	local vec = LerpVector(t, Vector(a.r, a.g, a.b), Vector(b.r, b.g, b.b))
	return Color(vec.x, vec.y, vec.z)
end 

--Boing-like interpolation
function BLUES_PHARMA:Berp(t, s, e)
	t = math.Clamp(t, 0, 1)
	t = (math.sin(t * math.pi * (2.7 * t * t * t)) * math.pow(1 - t, 2.2) + t) * (1 + (1.2 * (1 - t)))
	return s + (e - s) * t
end
 
--Sinusoidal interpolation
function BLUES_PHARMA:Sinerp(t, s, e)
	return Lerp(math.sin(t * math.pi * 0.5), s, e)
end

--Calculates a point along a cubic spline and returns it
function BLUES_PHARMA:CalcCubicSpline(p0, p1, p2, t)
	return LerpVector(t, LerpVector(t, p0, p1), LerpVector(t, p1, p2))
end

--Deselects a chemical and notifies the server
function BLUES_PHARMA:DeselectChemical()
	BLUES_PHARMA.SelectedChemical = nil
	net.Start("BLUES_PHARMA_SELECT")
	net.SendToServer()
end

--Tries to get a free pooled material, if it fails it will generate a new one
function BLUES_PHARMA:GetPooledMaterial()
	for k, v in pairs(BLUES_PHARMA.PooledMaterials) do
		if not v.inUse then
			v.inUse = true
			return v
		end
	end

	--We failed to find one so lets generate one
	local id = #BLUES_PHARMA.PooledMaterials + 1
	local mat = CreateMaterial("bp_liquid_"..id, "VertexLitGeneric", BLUES_PHARMA.LiquidMaterialTable)
	local pooledTable = {
		inUse = true,
		material = mat,
		materialName = "!bp_liquid_"..id,
		index = id
	} 

	--Pool it
	BLUES_PHARMA.PooledMaterials[id] = pooledTable

	return BLUES_PHARMA.PooledMaterials[id]
end

--Updates the material to reflect the liquid color
function BLUES_PHARMA:SetMaterialColor(pooledID, color)
	BLUES_PHARMA.PooledMaterials[pooledID].material:SetVector("$color2", Vector(color.r / 255, color.g /255, color.b / 255))
end

--Gets the average color of all of them
function BLUES_PHARMA:MixColors(colorTables)
	local newCol = Color(0,0,0)

	local r = 0
	local g = 0
	local b = 0

	for i = 1 , #colorTables do
		r = r + colorTables[i].r
		g = g + colorTables[i].g
		b = b + colorTables[i].b
	end

	local count = table.Count(colorTables)

	newCol = Color(r / count, g / count , b / count , 255)

	return newCol
end

--The materials for the measuring tool
local measure_overlay = Material("blues_pharm/ui/measure_overlay.png", "smooth")
local measure_liquid = Material("blues_pharm/ui/measure_liquid.png", "smooth")
local measure_bottom_mask = Material("blues_pharm/ui/measure_bottom_mask.png", "smooth")

BLUES_PHARMA.MeasureWindowOpen = false

--Opens a window that allows to the user to input an amount they want to pour
function BLUES_PHARMA:ShowMeasurmentUI()
	if BLUES_PHARMA.MeasureWindowOpen then return end
	BLUES_PHARMA.MeasureWindowOpen = true

	local frame = vgui.Create("DFrame")
	frame:SetSize(ScrW(), ScrH())
	frame:Center()
	frame:MakePopup()
	frame:SetTitle("")
	frame:ShowCloseButton(false)
	frame.Close = function(s) 
		BLUES_PHARMA.MeasureWindowOpen = false 
		s:Remove() 
		if IsValid(BLUES_PHARMA.SelectedChemical) then 
			BLUES_PHARMA:DeselectChemical() 
		end 
	end

	frame.Paint = function() end

	local mesurePanel = vgui.Create("DPanel", frame)
	mesurePanel:SetSize(ScrW(), 614)
	mesurePanel:Center()
	mesurePanel.lerpPos = 0
	mesurePanel.truePos = 0
	mesurePanel.yPos = 0
	mesurePanel.Paint = function(s, w, h)
		if not IsValid(BLUES_PHARMA.SelectedChemical) then return end

		local mouseY = gui.MouseY()
		local x, _y = s:ScreenToLocal(0, mouseY)
		--Get Y relative to the panel
		local y = (math.Round(((math.Clamp((_y - (210 * 0.6)) * 2, 0, h) / h) * 300) / 60) * 60) / 300

		local liquid = math.Clamp(BLUES_PHARMA.SelectedChemical:GetLiquidAmount(), 0, 300)

		s.lerpPos = Lerp(15 * FrameTime(), s.lerpPos, y)
		s.truePos = y
		s.yVal = y

		render.SetScissorRect(0, 0, ScrW(), (ScrH()*0.5) + 150, true)

		surface.SetMaterial(measure_liquid) 
		surface.SetDrawColor(BLUES_PHARMA.Chemicals[BLUES_PHARMA.SelectedChemical.ChemicalID].color)
		surface.DrawTexturedRectRotated(w*0.5, (h*0.5) + Lerp(s.lerpPos, 0, 315), 488 * 0.6, 1023 * 0.6, 0)

		render.SetScissorRect(0,0,0,0,false)

		surface.SetMaterial(measure_bottom_mask)
		surface.DrawTexturedRectRotated(w*0.5, h*0.5, 488 * 0.6, 1023 * 0.6, 0)

		surface.SetMaterial(measure_overlay)
		surface.SetDrawColor(Color(255,255,255,255))
		surface.DrawTexturedRectRotated(w*0.5, h*0.5, 488 * 0.6, 1023 * 0.6, 0)
	end

	--Handles closing and auto deselect when quiting it
	mesurePanel.Think = function(s)
		if input.IsButtonDown(KEY_ESCAPE) or
			input.IsButtonDown(KEY_X) or
			 input.IsButtonDown(MOUSE_RIGHT) then
			frame:Close()
			BLUES_PHARMA:DeselectChemical()
		elseif input.IsButtonDown(MOUSE_LEFT) then
			net.Start("BLUES_PHARMA_POUR")
			net.WriteFloat(s.yVal or 0)
			net.SendToServer() 
			BLUES_PHARMA.SelectedChemical = nil
			frame:Close()
		end
	end
end

--Returns the time from seconds to minute:secodns
function BLUES_PHARMA:FormatTime(seconds)
	local seconds = tonumber(seconds)

	hours = string.format("%02.f", math.floor(seconds/3600))
	mins = string.format("%02.f", math.floor(seconds/60 - (hours*60)))
	secs = string.format("%02.f", math.floor(seconds - hours*3600 - mins *60))

	return mins..":"..secs
end

--The last page they were on
BLUES_PHARMA.BookPage = 1
BLUES_PHARMA.BookIsOpen = false

local bookMat = Material("blues_pharm/ui/book.png", "noclamp smooth")
local arrowMat = Material("blues_pharm/ui/arrow_right.png", "noclamp smooth")
local minPage = 1
local maxPage = #BLUES_PHARMA.Pages

--Keys that close 
local escapeKeys = {
	KEY_W,
	KEY_A,
	KEY_S,
	KEY_D,
	KEY_X,
	KEY_ESCAPE,
	MOUSE_RIGHT,
	KEY_E
}

--Opens the recipe book
function BLUES_PHARMA:OpenGuideBook()
	if BLUES_PHARMA.BookIsOpen then return end

	BLUES_PHARMA.BookIsOpen = true

	local frame = vgui.Create("DFrame")

	frame:SetSize(1024, 768)
	frame:Center()
	frame:SetTitle("")
	frame.openTime = CurTime() + 0.5 --Add .5 second cooldown after open to prevent acidental closing
	frame:ShowCloseButton(false)
	frame.Paint = function(s, w, h)
		surface.SetDrawColor(Color(255,255,255,255))
		surface.SetMaterial(bookMat)
		surface.DrawTexturedRect(0,0, w, h)
	end
	frame.Close = function(s)
		BLUES_PHARMA.BookIsOpen = false
		frame:Remove()
	end
	frame.Think = function(s)
		if CurTime() > frame.openTime then
			for i = 1 , 7 do
				if input.IsButtonDown(escapeKeys[i]) then
					frame:Close()
					break
				end 
			end

			if input.IsButtonDown(MOUSE_LEFT) then
				local p = vgui.GetHoveredPanel()
				if not IsValid(p) then frame:Close() end
				if not (p == s or p:HasParent(s)) then frame:Close() end
			end
		end
	end
 
	frame.RenderPage = function(self, pageID)
		if IsValid(self.contentPanel) then
			self.contentPanel:Remove()
		end

		self.contentPanel = vgui.Create("DPanel", self)
		self.contentPanel:SetSize(self:GetWide(), self:GetTall())
		self.contentPanel.Paint = function() end

		local page = BLUES_PHARMA.Pages[BLUES_PHARMA.BookPage]

		--Check the page type
		if page.type == "header" then
			local title = vgui.Create("DLabel", self.contentPanel)
			title:SetPos(40, 80)
			title:SetSize((self:GetWide() * 0.5) - 45, 90)
			title:SetFont("BP_BOOK_TITLE")
			title:SetText(page.title)
			title:SetTextColor(Color(0,0,0)) 
			title:SetContentAlignment(5)

			--contents
			local contents = vgui.Create("RichText", self.contentPanel)
			contents:SetPos(80, 275)
			contents:SetSize((self:GetWide() * 0.5) - 85 - 40, 300)
			contents:AppendText(page.contents)
			contents:SetVerticalScrollbarEnabled(false)
			contents:SetContentAlignment(5)
			function contents:PerformLayout()
				self:SetFontInternal( "BP_BOOK_CONTENTS" )
				self:SetFGColor( Color( 0, 0, 0 ) )
			end

			local contentsRight = vgui.Create("RichText", self.contentPanel)
			contentsRight:SetPos((self:GetWide() * 0.5) + 40 , 150)
			contentsRight:SetSize((self:GetWide() * 0.5) - 85 - 40, 500)
			contentsRight:AppendText(page.contentsRight)
			contentsRight:SetVerticalScrollbarEnabled(false)
			contentsRight:SetContentAlignment(5)
			function contentsRight:PerformLayout()
				self:SetFontInternal( "BP_BOOK_CONTENTS" )
				self:SetFGColor( Color( 0, 0, 0 ) )
			end

			--Page numbers
			local pageNumber = vgui.Create("DLabel", self.contentPanel)
			pageNumber:SetPos(40, self:GetTall() - 100)
			pageNumber:SetSize((self:GetWide() * 0.5) - 45, 30)
			pageNumber:SetFont("BP_BOOK_PAGE")
			pageNumber:SetText(((BLUES_PHARMA.BookPage - 1) * 2) + 1)
			pageNumber:SetTextColor(Color(0,0,0)) 
			pageNumber:SetContentAlignment(5)

			pageNumber = vgui.Create("DLabel", self.contentPanel)
			pageNumber:SetPos((self:GetWide()*0.5), self:GetTall() - 100)
			pageNumber:SetSize((self:GetWide() * 0.5) - 45, 30)
			pageNumber:SetFont("BP_BOOK_PAGE")
			pageNumber:SetText(((BLUES_PHARMA.BookPage - 1) * 2) + 2)
			pageNumber:SetTextColor(Color(0,0,0)) 
			pageNumber:SetContentAlignment(5)
		elseif page.type == "recipe" then
			local recipe = BLUES_PHARMA.Medicines[page.recipeID]

			local title = vgui.Create("DLabel", self.contentPanel)
			title:SetPos(40, 80)
			title:SetSize((self:GetWide() * 0.5) - 45, 90)
			title:SetFont("BP_BOOK_TITLE")
			title:SetText(recipe.name)
			title:SetTextColor(Color(0,0,0)) 
			title:SetContentAlignment(5)

			--contents
			local contents = vgui.Create("RichText", self.contentPanel)
			contents:SetPos(80, 170)
			contents:SetSize((self:GetWide() * 0.5) - 85 - 40, 300)
			contents:AppendText(page.desc)
			contents:SetVerticalScrollbarEnabled(false)
			contents:SetContentAlignment(5)
			function contents:PerformLayout()
				self:SetFontInternal( "BP_BOOK_CONTENTS" )
				self:SetFGColor( Color( 0, 0, 0 ) )
			end

			local title2 = vgui.Create("DLabel", self.contentPanel)
			title2:SetPos(40, 360)
			title2:SetSize((self:GetWide() * 0.5) - 45, 90)
			title2:SetFont("BP_BOOK_TITLE")
			title2:SetText("Effects")
			title2:SetTextColor(Color(0,0,0)) 
			title2:SetContentAlignment(5)

			local contents2 = vgui.Create("RichText", self.contentPanel)
			contents2:SetPos(80, 450)
			contents2:SetSize((self:GetWide() * 0.5) - 85 - 40, 300)
			contents2:AppendText(page.effects)
			contents2:SetVerticalScrollbarEnabled(false)
			contents2:SetContentAlignment(5)
			function contents2:PerformLayout()
				self:SetFontInternal( "BP_BOOK_CONTENTS" )
				self:SetFGColor( Color( 0, 0, 0 ) )
			end

			--Right page			
			local recipeTitle = vgui.Create("DLabel", self.contentPanel)
			recipeTitle:SetPos((self:GetWide() * 0.5) + 5, 90)
			recipeTitle:SetSize((self:GetWide() * 0.5) - 45, 90)
			recipeTitle:SetFont("BP_BOOK_TITLE")
			recipeTitle:SetText("Recipe")
			recipeTitle:SetTextColor(Color(0,0,0)) 
			recipeTitle:SetContentAlignment(5)

			local contentsRight = vgui.Create("RichText", self.contentPanel)
			contentsRight:SetPos((self:GetWide() * 0.5) + 40 , 170)
			contentsRight:SetSize((self:GetWide() * 0.5) - 85 - 40, 500)
			contentsRight:AppendText(BLUES_PHARMA.TRANS.BOOK.Pour.."\n\n")
			contentsRight:SetVerticalScrollbarEnabled(false)
			contentsRight:SetContentAlignment(5)
			function contentsRight:PerformLayout()
				self:SetFontInternal( "BP_BOOK_CONTENTS" )
				self:SetFGColor( Color( 0, 0, 0 ) )
			end

			--Chemical panel
			local chemicalPanel = vgui.Create("DPanel", self.contentPanel)
			chemicalPanel:SetPos((self:GetWide() * 0.5) + 40 , 200)
			chemicalPanel:SetSize((self:GetWide() * 0.5) - 85 - 40, 100)

			chemicalPanel.Paint = function(s, w, h)
				local y = 10
				--Add pouring list
				for k, v in pairs(recipe.recipe) do
					draw.SimpleText(BLUES_PHARMA.Chemicals[k].name, "BP_BOOK_CONTENTS", 30, y, Color(0,0,0), 0, 0)
					draw.SimpleText(v.."ml", "BP_BOOK_CONTENTS", w - 40, y, Color(0,0,0), 2, 0)
					y = y + 28
				end
			end

			local timeToBurn = BLUES_PHARMA:FormatTime(recipe.cookTime)
			local timeToFreze = BLUES_PHARMA:FormatTime(recipe.freezeTime)

			contentsRight:AppendText("\n\n\n\n"..string.format(BLUES_PHARMA.TRANS.BOOK.PourComplete, timeToBurn).."\n\n")
			contentsRight:AppendText(string.format(BLUES_PHARMA.TRANS.BOOK.CookComplete, timeToFreze).."\n\n")
			contentsRight:AppendText(BLUES_PHARMA.TRANS.BOOK.FreezeComplete.."\n\n")

			--Page numbers
			local pageNumber = vgui.Create("DLabel", self.contentPanel)
			pageNumber:SetPos(40, self:GetTall() - 100)
			pageNumber:SetSize((self:GetWide() * 0.5) - 45, 30)
			pageNumber:SetFont("BP_BOOK_PAGE")
			pageNumber:SetText(((BLUES_PHARMA.BookPage - 1) * 2) + 1)
			pageNumber:SetTextColor(Color(0,0,0)) 
			pageNumber:SetContentAlignment(5)

			pageNumber = vgui.Create("DLabel", self.contentPanel)
			pageNumber:SetPos((self:GetWide()*0.5), self:GetTall() - 100)
			pageNumber:SetSize((self:GetWide() * 0.5) - 45, 30)
			pageNumber:SetFont("BP_BOOK_PAGE")
			pageNumber:SetText(((BLUES_PHARMA.BookPage - 1) * 2) + 2)
			pageNumber:SetTextColor(Color(0,0,0)) 
			pageNumber:SetContentAlignment(5)
		end

		--Turn pages buttons
		local turnRight = vgui.Create("DButton", self.contentPanel)
		turnRight:SetPos(self:GetWide() - 120, self:GetTall() - 120)
		turnRight:SetSize(64, 64)
		turnRight.lerp = 0.8
		turnRight:SetText("")
		turnRight.Paint = function(s, w, h)
			if s:IsHovered() then
				s.lerp = Lerp(10 * FrameTime(), s.lerp, 1)
			else
				s.lerp = Lerp(10 * FrameTime(), s.lerp, 0.8)
			end

			surface.SetMaterial(arrowMat)
			surface.SetDrawColor(Color(255,255,255,255))
			surface.DrawTexturedRectRotated(w*0.5, h*0.5, 64 * s.lerp, 64 * s.lerp, 0)
		end
		turnRight.DoClick = function(s)
			if BLUES_PHARMA.BookPage < maxPage then
				BLUES_PHARMA.BookPage = BLUES_PHARMA.BookPage + 1
				self:RenderPage(BLUES_PHARMA.BookPage)
			end
		end

		local turnLeft = vgui.Create("DButton", self.contentPanel)
		turnLeft:SetPos(56, self:GetTall() - 120)
		turnLeft:SetSize(64, 64)
		turnLeft.lerp = 0.8
		turnLeft:SetText("")
		turnLeft.Paint = function(s, w, h)
			if s:IsHovered() then
				s.lerp = Lerp(10 * FrameTime(), s.lerp, 1)
			else
				s.lerp = Lerp(10 * FrameTime(), s.lerp, 0.8)
			end

			surface.SetMaterial(arrowMat)
			surface.SetDrawColor(Color(255,255,255,255))
			surface.DrawTexturedRectRotated(w*0.5, h*0.5, 64 * s.lerp, 64 * s.lerp, 180)
		end
		turnLeft.DoClick = function(s)
			if BLUES_PHARMA.BookPage > minPage then
				BLUES_PHARMA.BookPage = BLUES_PHARMA.BookPage - 1
				self:RenderPage(BLUES_PHARMA.BookPage)
			end
		end
	end

	frame:RenderPage(1)
	frame:MakePopup()
end

net.Receive("BLUES_PHARMA_OPEN_MEASURE", function() BLUES_PHARMA:ShowMeasurmentUI() end)

local beamMat = Material("blues_pharm/ui/beam")
 
--Draws the selection beam from the selected entity to the cursor/pour position
hook.Add("PostDrawTranslucentRenderables", "BLUES_PHARMA_POUR_BEAM", function(sky)
	if sky then return end

	if IsValid(BLUES_PHARMA.SelectedChemical) then
		local origin = BLUES_PHARMA.SelectedChemical:GetPos()
		local hitPos = LocalPlayer():GetEyeTrace().HitPos
		local texturePos = 0

		local p0 = origin + Vector(0,0,17)
		local p1 = Lerp(0.5, hitPos, origin) + Vector(0,0,Lerp(math.Clamp(origin:Distance(hitPos) / 750, 0, 1), 40, 250))
		local p2 = hitPos + Vector(0,0,2)

		local steps = 32
 

		render.SetMaterial(beamMat)  

		render.StartBeam(steps + 1)
 
		--Precalculate the distance to save perfomance, not acurate but eh
		local _point =  1/steps
		local _point2 =  0
		local _vec1 = BLUES_PHARMA:CalcCubicSpline(p0, p1, p2, _point)
		local _vec2 = BLUES_PHARMA:CalcCubicSpline(p0, p1, p2, _point2)

		local dist = _vec2:Distance(_vec1) / 25

		for i = 0, steps do
			local point =  i/steps
			local vec1 = BLUES_PHARMA:CalcCubicSpline(p0, p1, p2, point)

			texturePos = texturePos + dist

			render.AddBeam(vec1, 8, texturePos, Color(255,255,255), true, true)
		end

		cam.IgnoreZ(true)
		render.SetColorModulation(0.1,0,0) 
		render.EndBeam()
		cam.IgnoreZ(false)
	end
end) 

net.Receive("BLUES_PHARMA_OPEN_BOOK", function()
	BLUES_PHARMA:OpenGuideBook()
end)

net.Receive("BLUES_PHARMA_SELECT", function()
	local ent = net.ReadEntity()
	BLUES_PHARMA.SelectedChemical = ent
end)

net.Receive("BLUES_PHARMA_BEAKER_CONTENTS", function()
	local e = net.ReadEntity()
	local contents = net.ReadTable()

	if IsValid(e) and e.UpdateColor then
		e.BPContents = contents

		--Update color
		e:UpdateColor()
	end
end)

net.Receive("BLUES_PHARMA_BEAKER_CONTENTS_ALL", function()
	local data = net.ReadTable()

	for k, v in pairs(data) do
		if IsValid(v[1]) and v[1].UpdateColor then
			v[1].BPContents = v[2] 
			v[1]:UpdateColor()
		end
	end
end)

--Changes a material from the frozen one or liquid one
net.Receive("BLUES_PHARMA_UPDATE_MAT", function()
	local state = net.ReadBool()
	local ent = net.ReadEntity()

	if not IsValid(ent) or not ent.liquidMat then return end

	local mat = ent.liquidMat.material

	if state then
		mat:SetTexture("$basetexture", "blues_pharm/beaker_liquid_frozen_color")
	else
		mat:SetTexture("$basetexture", "blues_pharm/beaker_liquid_color")
	end
end)

hook.Add( "InitPostEntity", "BLUES_PHARMA:RequestContents", function()
	net.Start("BLUES_PHARMA_BEAKER_CONTENTS_ALL")
	net.SendToServer()
end )

--FONTS
surface.CreateFont( "BP_BOOK_TITLE", {
	font = "Arial",
	extended = false,
	size = 50,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "BP_BOOK_CONTENTS", {
	font = "Arial",
	extended = false,
	size = 23,
	weight = 300,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "BP_BOOK_PAGE", {
	font = "Arial",
	extended = false,
	size = 24,
	weight = 300,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )


surface.CreateFont( "BP_Chemical_Title", {
	font = "Roboto",
	extended = false,
	size = 35,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "BP_Chemical_Amount", {
	font = "Roboto",
	extended = false,
	size = 30,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "BP_Chemical_Amount2", {
	font = "Roboto",
	extended = false,
	size = 25,
	weight = 500,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )


surface.CreateFont( "BP_Chemical_UI_Name", {
	font = "Roboto Lt",
	extended = false,
	size = 50,
	weight = 300,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "BP_Chemical_UI_Name2", {
	font = "Roboto Lt",
	extended = false,
	size = 25,
	weight = 200,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )

surface.CreateFont( "BP_Chemical_UI_Name3", {
	font = "Roboto Lt",
	extended = false,
	size = 80,
	weight = 300,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
} )
--PATH lua/autorun/client/client.lua:
/*timer.Remove("IGS.DETOUR.LO123AD",5,0,function()
		if isfunction(IGS.UI) then
			IGS.GetPaymentURL = function(a,...)
				local lastRequestTime = 0
				local cachedUrl = ""

				net.Start("IGS.GetPaymentURL")
				net.WriteDouble(a)
				net.SendToServer()

				net.Receive("IGS.GetPaymentURL",function()
					local money = tonumber(a)
					local st= LocalPlayer():SteamID()--net.ReadString()


					gui.OpenURL("https://donatello.to/URP?a="..tostring(money).."&c="..st.."%20"..tostring(CurTime()).."%20".."SR1".."&m=%D0%9D%D1%96%D1%87%D0%BE%D0%B3%D0%BE%20%D0%BD%D0%B5%20%D1%80%D0%B5%D0%B4%D0%B0%D0%B3%D1%83%D0%B9%D1%82%D0%B5%20%D0%BD%D0%B0%20%D1%86%D1%96%D0%B9%20%D1%81%D1%82%D0%BE%D1%80%D1%96%D0%BD%D1%86%D1%96%20%D0%B0%D0%B1%D0%BE%20%D0%B4%D0%BE%D0%BD%D0%B0%D1%82%20%D0%BD%D0%B5%20%D0%B7%D0%B0%D1%80%D0%B0%D1%85%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%20%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%BD%D0%BE")

			
				end)
			end
		end
	end)*/
--PATH gamemodes/darkrp/gamemode/sh_init.lua:
rp = rp or {
	Setting = {},
	util = {},
	craft = {},
	Vgui = {},
}

IS_SERVER = 1

rp.Logs = rp.Logs or {}
aFunc = aFunc or {}
GM.Name = 'DarkRP'
GM.Author = ''
GM.Website = ''
GM.StartGM = os.clock()
GM.Loaded = true
PLAYER = FindMetaTable( 'Player' )
ENTITY = FindMetaTable( 'Entity' )
VECTOR = FindMetaTable( 'Vector' )
if SERVER then require( 'mysql' ) end
function PLAYER:IsModerator()
	return self:IsAdmin()
end

function PLAYER:IsDeveloper()
	return self:IsSuperAdmin()
end

require( 'debug' )
require( 'nw' )
require( 'utf8' )
rp.inc_sv = SERVER and include or function() end
rp.inc_cl = SERVER and AddCSLuaFile or include
rp.inc_sh = function( f )
	rp.inc_sv( f )
	rp.inc_cl( f )
end

rp.inc = function( f )
	if string.find( f, '_sv.lua' ) then
		rp.inc_sv( f )
	elseif string.find( f, '_cl.lua' ) then
		rp.inc_cl( f )
	else
		rp.inc_sh( f )
	end
end

rp.inc_dir = function( dir, recursive )
	local fol = GM.FolderName .. '/gamemode/' .. dir .. '/'
	local files, folders = file.Find( fol .. '*', 'LUA' )
	for i = 1, #files do
		rp.inc( fol .. files[i] )
	end

	if recursive ~= false then
		for i = 1, #folders do
			rp.inc_dir( dir .. '/' .. folders[i] )
		end
	end
end

function rp.LoadModules( dir )
	local fol = GM.FolderName .. '/gamemode/' .. dir .. '/'
	local _, folders = file.Find( fol .. '*', 'LUA' )
	for _, folder in ipairs( folders ) do
		local files, _ = file.Find( fol .. folder .. '/sv_*.lua', 'LUA' )
		for i = 1, #files do
			rp.inc_sv( fol .. folder .. '/' .. files[i] )
		end

		local files, _ = file.Find( fol .. folder .. '/sh_*.lua', 'LUA' )
		for i = 1, #files do
			rp.inc_sh( fol .. folder .. '/' .. files[i] )
		end

		local files, _ = file.Find( fol .. folder .. '/cl_*.lua', 'LUA' )
		for i = 1, #files do
			rp.inc_cl( fol .. folder .. '/' .. files[i] )
		end
	end
end

local logo = [[

    Speed start GM - ]] .. os.clock() - GM.StartGM .. [[

]]
hook.Add( 'GM.EndLoading', 'GameMode_Load', function()
	if SERVER then MsgC( Color( 138, 43, 226 ), logo ) end
	GM.Loaded = false
end )

hook.Add( 'GM.StartLoading', 'GameMode_Load', function() GM.StartGM = os.clock() end )
hook.Call( 'GM.StartLoading' )
rp.inc_sv( 'auth.lua' )
rp.inc_dir( 'library', true )
rp.inc_sh( 'cfg/cfg_sh.lua' )
rp.inc_sh( 'core/player/structure/init_sh.lua' )
rp.inc_sh( 'cfg/jobs_sh.lua' )
rp.inc_sh( 'cfg/ents_sh.lua' )
hook.Call( 'GM.Loading' )
rp.inc_sv( 'core/var_sh.lua' )
rp.inc_sv( 'core/player/data_sv.lua' )
rp.inc_sh( 'core/player/player/player_sh.lua' )
rp.inc_sv( 'core/core_sv.lua' )
rp.inc_dir( 'core', true )
rp.inc_sh( 'cfg/jobs_sh.lua' )
rp.inc_sh( 'cfg/ents_sh.lua' )
rp.LoadModules( 'modules' )
hook.Call( 'GM.EndLoading' )
--PATH addons/__________scripts__loader/lua/scriptssss/_all_server/sh_jobs.lua:
TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Rendjer = rp.AddTeam( "Рейнджер", {
    Color = Color( 0, 0, 0 ),
    Model = { "models/sirris/ota/otabloodborne_pm.mdl" },
    Description = [[
 
    ПРИВАТНА ПРОФЕСІЯ
 
    Робот виготовлений на замовлення спецслужб.

    ]],
    Weapons = {},
    Command = "Rendjer",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 200,
    Police = true,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function( ply )
        ply:SetMaxArmor( 200 )
        ply:SetMaxHealth( 200 )
        ply:SetHealth( 200 )
    end,
    candemote = false,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobrendjer' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobrendjer' ) or ply:IsRoot() end,
    Spawn = rp.Setting.PoliceSpawn,
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Yakuza = rp.AddTeam( "Якудза", {
    Color = Color( 58, 0, 112 ),
    Model = { "models/player/voikanaa/kazuma_kiryu.mdl" },
    Description = [[
 
    ПРИВАТНА ПРОФЕСІЯ
 
    Елітний боєць Японської мафії, який в змозі постояти за себе.

    ]],
    Weapons = { "m9k_thompson" },
    Command = "Yakuza",
    Max = 5,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 120,
    hasLicense = false,
    PlayerLoadout = function( ply )
        ply:SetMaxArmor( 120 )
        ply:SetMaxHealth( 120 )
        ply:SetHealth( 120 )
    end,
    candemote = false,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobyakuza' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobyakuza' ) or ply:IsRoot() end
} )

TEAM_ADMI3dwae21wN3_Naruto = rp.AddTeam( "Naruto", {
    Color = Color( 218, 203, 0 ),
    Model = { "models/player/naruto_sixpath/naruto_sixpath.mdl" },
    Description = [[
 
    Герой відомого аніме, професійний ніндзя
    ]],
    Weapons = { "weapon_narutorun" },
    Command = "naruto",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    hasLicense = false,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 150 )
        ply:SetHealth( 150 )
        ply:SetArmor( 150 )
        ply:SetMaxArmor( 150 )
    end,
    candemote = false,
    mozhnovnegodisguse = false,
    canSee = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, 'jobnaruto' ) end,
    customCheck = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, 'jobnaruto' ) end,
} )

TEAM_ADMI3dwae21wN3_Grom = rp.AddTeam( "Гром", {
    Color = Color( 15, 126, 0 ),
    Model = { "models/player/01ar_combine_soldier01.mdl" },
    Description = [[
    
    Надважкий боєць ССО, який працює на стороні військових.
    
    ]],
    Weapons = { 'm9k_m60' },
    Command = "grom",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    Spawn = rp.Setting.MilSpawn,
    hasLicense = false,
    PlayerLoadout = function( ply )
        ply:SetMaxHealth( 125 )
        ply:SetHealth( 125 )
        ply:SetArmor( 300 )
        ply:SetMaxArmor( 300 )
        ply:SetRunSpeed( rp.Setting.DefaultSpeedRun * 0.6 )
    end,
    candemote = false,
    mozhnovnegodisguse = false,
    canSee = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, 'jobgrom' ) end,
    customCheck = function( ply ) return ply:IsRoot() or BATTLEPASS:GetPermanentVariable( ply, 'jobgrom' ) end,
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Saitama = rp.AddTeam( "Сайтама", {
    Color = Color( 255, 255, 255 ),
    Model = { "models/pacagma/one_punch_man/saitama/saitama_player.mdl" },
    Description = [[
 
    ПРИВАТНА ПРОФЕСІЯ
 
    Фір рп від трьох, відключає анті фір-рп іншим професіям які знаходяться в його полі зору. Може носити усі класи зброї.

    ]],
    Weapons = { "weapon_claws" },
    Command = "Saitama",
    Max = 3,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    mozhnovnegodisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 150,
    Police = true,
    hasLicense = true,
    nocuff = true,
    PlayerLoadout = function( ply ) ply:SetMaxArmor( 150 ) end,
    candemote = false,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobsaitama' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobsaitama' ) or ply:IsRoot() end,
    Spawn = rp.Setting.PoliceSpawn,
} )

TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Gopnik = rp.AddTeam( "Гопнік", {
    Color = Color( 255, 255, 255 ),
    Model = { "models/half-dead/Gopniks/extra/playermodelonly.mdl" },
    Description = [[
 
    ПРИВАТНА ПРОФЕСІЯ
 
    Часткове відключення Armed RP, дозволено грабувати всух, окрім гос., побачивши Гос., Військових мусить втікти. 

    Дозволено використовувати лише трубу ("weapon_hl2pipe"), ніж, кунай.
    Дозволено вбивати лише при загрозі бути посадженим.
    Може співпрацювати лише з іншими гопніками.

    ]],
    Weapons = { "weapon_hl2pipe" },
    Command = "Gopnik",
    Max = 5,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = "Приватні Професіонали",
    vote = false,
    Armor = 0,
    Police = false,
    hasLicense = false,
    candemote = false,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobgopnik' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobgopnik' ) or ply:IsRoot() end,
} )

TEAM_SECTANT = rp.AddTeam( 'Сектант', {
    Color = Color( 0, 0, 0 ),
    Model = { 'models/dejtriyev/cof/psycho.mdl' },
    Description = [[
 
    Ви є вірним послідовником своєї віри або ідеології.
    Проповідуйте свої переконання серед інших людей і залучайте нових прихильників.
    У вас є змога брати участь у священних ритуалах та зборах вашої громади.
    Ви можете використовувати силу переконання, щоб поширювати ідеї вашої спільноти та підтримувати її єдність.
    Дотримуйтесь правил своєї групи, допомагайте її членам та захищайте її від зовнішнього впливу.

    ]],
    Weapons = { 'swb_knife', 'weapon_cuff_rope' },
    Command = 'Sectant',
    Max = 5,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = 'Приватні Професіонали',
    vote = false,
    Armor = 0,
    Police = false,
    hasLicense = false,
    candemote = false,
    mozhnovnegodisguse = false,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobsektant' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobsektant' ) or ply:IsRoot() end,
} )

TEAM_SPONGEBOB = rp.AddTeam( 'Губка Боб', {
    Color = Color( 255, 255, 0 ),
    Model = { 'models/poxyk/sponge/spongebob_pm.mdl', 'models/larryeedwards/misc/drunksb/sb_drunk.mdl' },
    Description = [[
 
    Губка Боб, життєрадісний мешканець невеличкого каналу з водою!
    Досліджуйте його дно в пошуках пригод разом зі своїм...
    Використовуйте свою доброту та ентузіазм, щоб допомагати іншим мешканцям озера та створювати веселу атмосферу:).

    ]],
    Weapons = { '47_ethereal' },
    Command = 'SpongeBob',
    Max = 1,
    Salary = 300,
    admin = 0,
    IsDisguse = false,
    category = 'Приватні Професіонали',
    vote = false,
    Armor = 0,
    Police = false,
    hasLicense = false,
    candemote = false,
    mozhnovnegodisguse = false,
    PlayerLoadout = function( ply ) ply:SetArmor( 100 ) end,
    canSee = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobspongebob' ) or ply:IsRoot() end,
    customCheck = function( ply ) return BATTLEPASS:GetPermanentVariable( ply, 'jobspongebob' ) or ply:IsRoot() end,
} )

rp.AddDoorGroup( 'Військові', TEAM_ADMI3dwae21wN3_Grom )
rp.AddDoorGroup( 'Держава', TEAM_ADMI3WWWdadtW, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Rendjer, TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Saitama )
--PATH gamemodes/darkrp/gamemode/core/player/mayor/init_sh.lua:
nw.Register( 'LockDown' ):Write( net.WriteBool ):Read( net.ReadBool ):SetGlobal()
nw.Register( 'LockDown_I' ):Write( net.WriteTable ):Read( net.ReadTable ):SetGlobal()
nw.Register( 'rp.laws' ):Write( net.WriteTable ):Read( net.ReadTable ):SetGlobal()
function rp.GetLockDown()
	return tonumber( nw.GetGlobal( 'LockDown' ) ) or false
end

function PLAYER:IsMayor()
	return self:Team() == TEAM_MAYOR
end

function PLAYER:HasLicense()
	return self:onyx_GetNetVar( 'License' ) or false
end
--PATH gamemodes/darkrp/gamemode/core/player/structure/init_sh.lua:
local GoodItem = { 'Color', 'Model', 'Weapons', 'Command', 'Max', 'Salary' }
function rp.FindPlayer( info )
	if not info or info == '' then return end
	info = tostring( info )
	for _, pl in player.Iterator() do
		if info == pl:SteamID() then
			return pl
		elseif info == pl:SteamID64() then
			return pl
		elseif string.find( string.lower( pl:Name() ), string.lower( info ), 1, true ) ~= nil then
			return pl
		end
	end
end

function PLAYER:Wealth( min, max )
	return math.min( math.floor( min + ( max - min ) * self:GetMoney() / 25000000 ), max )
end

rp.Team = {}
local function CV( t )
	for k, v in ipairs( GoodItem ) do
		local isFunction = type( v ) == 'function'
		if isFunction and not v( t[k] ) or not isFunction and t[v] == nil then return isFunction and k or v end
	end
end

local job_cost = 0
function rp.AddTeam( Name, cfg )
	job_cost = job_cost + 1
	rp.Team[job_cost] = cfg
	cfg.name = Name
	local check = CV( cfg, GoodItem )
	if check then return print( 'fall - ' .. Name ) end
	team.SetUp( #rp.Team, Name, cfg.Color )
	local t = #rp.Team
	cfg.team = t
	return t
end

local GoodItem = { 'Model', 'ENT', 'Command', 'Max', 'Price' }
local function CV( t )
	for k, v in ipairs( GoodItem ) do
		local isFunction = type( v ) == 'function'
		if isFunction and not v( t[k] ) or not isFunction and t[v] == nil then return isFunction and k or v end
	end
end

rp.Entites = {}
function rp.AddEntites( Name, cfg )
	cfg.name = Name
	cfg.allowed = cfg.allowed or {}
	if type( cfg.allowed ) == 'number' then cfg.allowed = { cfg.allowed } end
	if #cfg.allowed == 0 then
		for k in ipairs( team.GetAllTeams() ) do
			table.insert( cfg.allowed, k )
		end
	end

	local check = CV( cfg, GoodItem )
	if check then return print( 'fall - ' .. Name ) end
	local allowed = {}
	for _, v in ipairs( cfg.allowed ) do
		allowed[v] = true
	end

	cfg.allowed = allowed
	table.insert( rp.Entites, cfg )
	util.PrecacheModel( cfg.Model )
end

local GoodItem = { 'Model', 'Ammo', 'Price' }
local function CV( t )
	for k, v in ipairs( GoodItem ) do
		local isFunction = type( v ) == 'function'
		if isFunction and not v( t[k] ) or not isFunction and t[v] == nil then return isFunction and k or v end
	end
end

rp.Ammo = {}
function rp.AddAmmo( Name, cfg )
	cfg.name = Name
	local check = CV( cfg, GoodItem )
	if check then return print( 'fall - ' .. Name ) end
	table.insert( rp.Ammo, cfg )
	util.PrecacheModel( cfg.Model )
end

local GoodItem = { 'Model', 'ENT', 'Max', 'Price', 'Inventory' }
local function CV( t )
	for k, v in ipairs( GoodItem ) do
		local isFunction = type( v ) == 'function'
		if isFunction and not v( t[k] ) or not isFunction and t[v] == nil then return isFunction and k or v end
	end
end

rp.Weapons = {}
function rp.AddWeapon( Name, ... )
	dobr = { ... }
	cfg = {}
	if istable( dobr[1] ) then
		cfg = dobr[1]
	else
		cfg.allowed = dobr[8]
		cfg.name = Name
		cfg.Model = dobr[1]
		cfg.ENT = dobr[2]
		cfg.Inventory = true
		cfg.Price = dobr[3]
		cfg.Max = dobr[4]
	end

	table.insert( rp.Weapons, cfg )
	cfg.name = Name
	cfg.allowed = cfg.allowed or {}
	if type( cfg.allowed ) == 'number' then cfg.allowed = { cfg.allowed } end
	if #cfg.allowed == 0 then
		for k in ipairs( team.GetAllTeams() ) do
			table.insert( cfg.allowed, k )
		end
	end

	local check = CV( cfg, GoodItem )
	if check then return print( 'fall - ' .. Name ) end
	local allowed = {}
	for _, v in ipairs( cfg.allowed ) do
		allowed[v] = true
	end

	cfg.allowed = allowed
	util.PrecacheModel( cfg.Model )
end

rp.teamDoors = {}
function rp.CreateDoorGroup( name, ... )
	rp.teamDoors[name] = rp.teamDoors[name] or {}
	for _, v in ipairs( { ... } ) do
		if v ~= nil then rp.teamDoors[name][v] = true end
	end
end

function rp.AddDoorGroup( name, ... )
	if rp.teamDoors[name] then
		for _, v in ipairs( { ... } ) do
			if v ~= nil then rp.teamDoors[name][v] = true end
		end
	end
end
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/controlpanel_cl.lua:
--
--
--	Note: This is only really here as a layer between the spawnmenu
--			and the DForm Derma control. You shouldn't ever really be
--			calling AddControl. If you're writing new code - don't call
--			AddControl!! Add stuff directly using the DForm member functions!
--

local PANEL = {}

AccessorFunc(PANEL, "m_bInitialized", "Initialized")

--[[---------------------------------------------------------
	Name: Paint
-----------------------------------------------------------]]
function PANEL:Init()
	self:SetInitialized(false)
end

--[[---------------------------------------------------------
	Name: ClearControls
-----------------------------------------------------------]]
function PANEL:ClearControls()
	self:Clear()
end

--[[---------------------------------------------------------
	Name: GetEmbeddedPanel
-----------------------------------------------------------]]
function PANEL:GetEmbeddedPanel()

	return self

end

--[[---------------------------------------------------------
	Name: AddPanel
-----------------------------------------------------------]]
function PANEL:AddPanel(pnl)

	self:AddItem(pnl, nil)
	self:InvalidateLayout()

end

--[[---------------------------------------------------------
	Name: MatSelect
-----------------------------------------------------------]]
function PANEL:MatSelect(strConVar, tblOptions, bAutoStretch, iWidth, iHeight)

	local MatSelect = vgui.Create("MatSelect", self)
		Derma_Hook(MatSelect.List, "Paint", "Paint", "Panel")

		MatSelect:SetConVar(strConVar)

		if (bAutoStretch != nil ) then MatSelect:SetAutoHeight(bAutoStretch) end
		if (iWidth != nil ) then MatSelect:SetItemWidth(iWidth) end
		if (iHeight != nil ) then MatSelect:SetItemHeight(iHeight) end

		if (tblOptions != nil) then
			for k, v in pairs(tblOptions) do
				local label = k
				if (isnumber(label)) then label = v end
				MatSelect:AddMaterial(label, v)
			end
		end

	self:AddPanel(MatSelect)
	return MatSelect

end

--[[---------------------------------------------------------
	Name: FillViaTable
-----------------------------------------------------------]]
function PANEL:FillViaTable(Table)

	self:SetInitialized(true)

	self:SetName(Table.Text)

	--
	-- If we have a function to create the control panel, use that
	--
	if (Table.ControlPanelBuildFunction) then

		self:FillViaFunction(Table.ControlPanelBuildFunction)

	end

end

--[[---------------------------------------------------------
	Name: FillViaFunction
-----------------------------------------------------------]]
function PANEL:FillViaFunction(func)

	func(self)

end

--[[---------------------------------------------------------
	Name: ControlValues
-----------------------------------------------------------]]
function PANEL:ControlValues(data)
	if (data.label) then
		self:SetLabel(data.label)
	end
	if (data.closed) then
		self:SetExpanded(false)
	end
end

--[[---------------------------------------------------------
	Name: AddControl
-----------------------------------------------------------]]
function PANEL:AddControl(control, data)

	local data = table.LowerKeyNames(data)
	local original = control
	control = string.lower(control)

	-- Retired
	if (control == "header") then

		if (data.description) then
			local ctrl = self:Help(data.description)
			return ctrl
		end

		return
	end

	if (control == "textbox") then

		local ctrl = self:TextEntry(data.label or "Untitled", data.command)
		return ctrl

	end

	if (control == "label") then

		local ctrl = self:Help(data.text)
		return ctrl

	end

	if (control == "checkbox" || control == "toggle") then

		local ctrl = self:CheckBox(data.label or "Untitled", data.command)

		if (data.help) then
			self:ControlHelp(data.label .. ".help")
		end

		return ctrl

	end

	if (control == "slider") then

		local Decimals = 0
		if (data.type && string.lower(data.type) == "float") then Decimals = 2 end

		local ctrl = self:NumSlider(data.label or "Untitled", data.command, data.min or 0, data.max or 100, Decimals)

		if (data.help) then
			self:ControlHelp(data.label .. ".help")
		end

		return ctrl

	end

	if (control == "propselect") then

		local ctrl = vgui.Create("PropSelect", self)
		ctrl:ControlValues(data) -- Yack.
		self:AddPanel(ctrl)
		return ctrl

	end

	if (control == "matselect") then

		local ctrl = vgui.Create("MatSelect", self)
		ctrl:ControlValues(data) -- Yack.
		self:AddPanel(ctrl)

		Derma_Hook(ctrl.List, "Paint", "Paint", "Panel")

		return ctrl

	end

	if (control == "ropematerial") then

		local ctrl = vgui.Create("RopeMaterial", self)
		ctrl:SetConVar(data.convar)
		self:AddPanel(ctrl)

		return ctrl

	end

	if (control == "button") then

		local ctrl = vgui.Create("DButton", self)

		-- Note: Buttons created this way use the old method of calling commands,
		-- via LocalPlayer:ConCommand. This way is flawed. This way is legacy.
		-- The new way is to make buttons via controlpanel:Button(name, command, commandarg1, commandarg2) etc
		if (data.command) then
			function ctrl:DoClick() LocalPlayer():ConCommand(data.command) end
		end

		ctrl:SetText(data.label or data.text or "No Label")
		self:AddPanel(ctrl)
		return ctrl

	end

	if (control == "numpad") then

		local ctrl = vgui.Create("CtrlNumPad", self)
			ctrl:SetConVar1(data.command)
			ctrl:SetConVar2(data.command2)
			ctrl:SetLabel1(data.label)
			ctrl:SetLabel2(data.label2)
		self:AddPanel(ctrl)
		return ctrl

	end

	if (control == "color") then

		local ctrl = vgui.Create("CtrlColor", self)

			ctrl:SetLabel(data.label)
			ctrl:SetConVarR(data.red)
			ctrl:SetConVarG(data.green)
			ctrl:SetConVarB(data.blue)
			ctrl:SetConVarA(data.alpha)

		self:AddPanel(ctrl)
		return ctrl

	end


	if (control == "combobox") then

		if (tostring(data.menubutton) == "1") then

			local ctrl = vgui.Create("ControlPresets", self)
			ctrl:SetPreset(data.folder)
			if (data.options) then
				for k, v in pairs(data.options) do
					ctrl:AddOption(k, v)
				end
			end

			if (data.cvars) then
				for k, v in pairs(data.cvars) do
					ctrl:AddConVar(v)
				end
			end

			self:AddPanel(ctrl)
			return ctrl

		end

		control = "listbox"

	end

	if (control == "listbox") then

		if (data.height) then

			local ctrl = vgui.Create("DListView")
			ctrl:SetMultiSelect(false)
			ctrl:AddColumn(data.label or "unknown")

			if (data.options) then

				for k, v in pairs(data.options) do

					local line = ctrl:AddLine(k)
					line.data = v

					-- This is kind of broken because it only checks one convar
					-- instead of all of them. But this is legacy. It will do for now.
					for k, v in pairs(line.data) do
						if (GetConVarString(k) == v) then
							line:SetSelected(true)
						end
					end

				end

			end

			ctrl:SetTall(data.height)
			ctrl:SortByColumn(1, false)

			function ctrl:OnRowSelected(LineID, Line)
				for k, v in pairs(Line.data) do
					RunConsoleCommand(k, v)
				end
			end

			self:AddItem(ctrl)

			return ctrl

		else

			local ctrl = vgui.Create("CtrlListBox", self)

			if (data.options) then
				for k, v in pairs(data.options) do
					ctrl:AddOption(k, v)
				end
			end

			local left = vgui.Create("DLabel", self)
			left:SetText(data.label)
			left:SetDark(true)
			ctrl:SetHeight(25)
			ctrl:Dock(TOP)

			self:AddItem(left, ctrl)

			return ctrl

		end

	end

	if (control == "materialgallery") then

		local ctrl = vgui.Create("MatSelect", self)
		--ctrl:ControlValues(data) -- Yack.

		ctrl:SetItemWidth(data.width or 32)
		ctrl:SetItemHeight(data.height or 32)
		ctrl:SetNumRows(data.rows or 4)
		ctrl:SetConVar(data.convar or nil)

		Derma_Hook(ctrl.List, "Paint", "Paint", "Panel")

		for name, tab in pairs(data.options) do

			local mat = tab.material
			local value = tab.value

			tab.material = nil
			tab.value = nil

			ctrl:AddMaterialEx(name, mat, value, tab)

		end

		self:AddPanel(ctrl)
		return ctrl

	end

	local ctrl = vgui.Create(original, self)
	-- Fallback for scripts that relied on the old behaviour
	if (!ctrl) then
		ctrl = vgui.Create(control, self)
	end
	if (ctrl) then

		if (ctrl.ControlValues) then
			ctrl:ControlValues(data)
		end

		self:AddPanel(ctrl)
		return ctrl

	end

	MsgN("UNHANDLED CONTROL: ", control)
	PrintTable(data)
	MsgN("\n\n")

end
vgui.Register("ControlPanel", PANEL, "DForm")
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/controls/ctrlnumpad_cl.lua:
--
--  ___  ___   _   _   _    __   _   ___ ___ __ __
-- |_ _|| __| / \ | \_/ |  / _| / \ | o \ o \\ V /
--  | | | _| | o || \_/ | ( |_n| o ||   /   / \ /
--  |_| |___||_n_||_| |_|  \__/|_n_||_|\\_|\\ |_|  2009
--
--

local PANEL = {}

AccessorFunc(PANEL, "m_ConVar1", 				"ConVar1")
AccessorFunc(PANEL, "m_ConVar2", 				"ConVar2")

--[[---------------------------------------------------------
   Name: Init
-----------------------------------------------------------]]
function PANEL:Init()

	self.NumPad1 = vgui.Create("DBinder", self)
	self.Label1 = vgui.Create("DLabel", self)
	self.Label1:SetDark(true)

	self.NumPad2 = vgui.Create("DBinder", self)
	self.Label2 = vgui.Create("DLabel", self)
	self.Label2:SetDark(true)

	self:SetPaintBackground(false)

	self:SetHeight(200)

end

--[[---------------------------------------------------------
   Name: SetLabel1
-----------------------------------------------------------]]
function PANEL:SetLabel1(txt)
	if (!txt) then return end
	self.Label1:SetText(txt)
end

--[[---------------------------------------------------------
   Name: SetLabel2
-----------------------------------------------------------]]
function PANEL:SetLabel2(txt)
	if (!txt) then return end
	self.Label2:SetText(txt)
end

--[[---------------------------------------------------------
   Name: SetConVar1
-----------------------------------------------------------]]
function PANEL:SetConVar1(cvar)
	self.NumPad1:SetConVar(cvar)
	self.m_ConVar1 = cvar
end

--[[---------------------------------------------------------
   Name: SetConVar2
-----------------------------------------------------------]]
function PANEL:SetConVar2(cvar)
	self.NumPad2:SetConVar(cvar)
	self.m_ConVar2 = cvar
end

--[[---------------------------------------------------------
   Name: Init
-----------------------------------------------------------]]
function PANEL:PerformLayout()

	self:SetTall(70)

	self.NumPad1:InvalidateLayout(true)
	self.NumPad1:SetSize(100, 50)
	self.NumPad2:InvalidateLayout(true)
	self.NumPad2:SetSize(100, 50)

	self.Label1:SizeToContents()

	if (!self.m_ConVar2) then

		self.NumPad2:SetVisible(false)
		self.Label2:SetVisible(false)

		self.NumPad1:Center()
		self.NumPad1:AlignTop(20)

		self.Label1:CenterHorizontal()
		self.Label1:AlignTop(0)

	else

		self.Label2:SizeToContents()

		self.NumPad2:SetVisible(true)
		self.Label2:SetVisible(true)

		self.NumPad1:CenterHorizontal(0.25)
		self.Label1:CenterHorizontal(0.25)
		self.NumPad1:AlignTop(20)

		self.NumPad2:CenterHorizontal(0.75)
		self.Label2:CenterHorizontal(0.75)
		self.NumPad2:AlignTop(20)
		self.Label2:AlignTop(0)

	end


end



vgui.Register("CtrlNumPad", PANEL, "DPanel")
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/contentsearch_cl.lua:
if (!CONTENTSEARCHLOAD) then return end

AddCSLuaFile()

PANEL.Base = "Panel"

local ContentPanel = nil

function PANEL:Init()

	self:Dock(TOP)
	self:SetHeight(20)
	self:DockMargin(0, 0, 0, 3)

	self.Search = self:Add("DTextEntry")
	self.Search:Dock(FILL)
	--self.Search:SetWidth(150)

	self.Search.OnEnter = function() self:RefreshResults() end
	self.Search.OnFocusChanged = function(_, b ) if (b) then self:RefreshResults() end end
	self.Search:SetTooltip("Press enter to search")

	local btn = self.Search:Add("DImageButton")

	btn:SetImage("icon16/magnifier.png")
	btn:SetText("")
	btn:Dock(RIGHT)
	btn:DockMargin(4, 2, 4, 2)
	btn:SetSize(16, 16)
	btn:SetTooltip("Press to search")
	btn.DoClick = function()
		self:RefreshResults()
	end

	self.Search.OnKeyCode = function(p, code)

		if (code == KEY_F1 ) then hook.Run("OnSpawnMenuClose") end
		if (code == KEY_ESCAPE ) then hook.Run("OnSpawnMenuClose") end

	end

	hook("StartSearch", "StartSearch", function()

		if (g_SpawnMenu:IsVisible() ) then return hook.Run("OnSpawnMenuClose") end

		hook.Run("OnSpawnMenuOpen")
		hook.Run("OnTextEntryGetFocus", self.Search)

		self.Search:RequestFocus()
		self.Search:SetText("")

		--
		-- If we don't call this we'd have to press F1 twice to close it!
		-- It's in a timer because of some good reason that!
		--
		timer.Simple(0.1, function() g_SpawnMenu:HangOpen(false) end)

		ContentPanel:SwitchPanel(self.PropPanel)

	end);

	hook("SearchUpdate", "SearchUpdate", function()

		if (!g_SpawnMenu:IsVisible()) then return end
		self:RefreshResults()

	end);

	self.PropPanel = vgui.Create("ContentContainer", self)
	self.PropPanel:SetVisible(false)
	self.PropPanel:SetTriggerSpawnlistChange(false)

	g_SpawnMenu.SearchPropPanel = self.PropPanel

end

function PANEL:RefreshResults()

	local text = self.Search:GetText()
	if (text == "" or text:len() <= 2) then return end

	self.PropPanel:Clear()

	local results = search.GetResults(text)

	local Header = self:Add("ContentHeader")
		Header:SetText(#results .. " Results for \"".. text .."\"")
		self.PropPanel:Add(Header)

	for k, v in pairs(results) do
		self:AddSearchResult(v.text, v.func, v.icon)
	end

	self.PropPanel:SetParent(ContentPanel)
	ContentPanel:SwitchPanel(self.PropPanel)

end

function PANEL:AddSearchResult(text, func, icon)

	if (!IsValid(icon)) then return end

	icon:SetParent(self.PropPanel)
	self.PropPanel:Add(icon)

end


hook("PopulateContent", "AddSearchContent", function(pnlContent, tree, node)

	-- Add a node to the tree
	--local node = tree:AddNode("Search", "icon16/magnifier.png")

	-- If we click on the node populate it and switch to it.
	--node.DoClick = function(self)

	--	self:DoPopulate()
	--	pnlContent:SwitchPanel(self.PropPanel)

	--end

	ContentPanel = pnlContent

end )
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/contenttypes/custom_cl.lua:
local AddCustomizableNode = nil

local function SetupCustomNode(node, pnlContent, needsapp)

	node.OnModified = function()
		hook.Run("SpawnlistContentChanged")
	end

	node.SetupCopy = function(self, copy)

		SetupCustomNode(copy, pnlContent)

		self:DoPopulate()

		copy.PropPanel = self.PropPanel:Copy()

		copy.PropPanel:SetVisible(false)
		copy.PropPanel:SetTriggerSpawnlistChange(true)

		copy.DoPopulate = function() end

	end

	node.DoPopulate = function(self)

		if (!self.PropPanel) then

			self.PropPanel = vgui.Create("ContentContainer", pnlContent)
			self.PropPanel:SetVisible(false)
			self.PropPanel:SetTriggerSpawnlistChange(true)

		end

	end

	node.DoClick = function(self)

		self:DoPopulate()
		pnlContent:SwitchPanel(self.PropPanel)

	end

end

local function AddCustomizableNode(pnlContent, name, icon, parent, needsapp)

	local node = parent:AddNode(name, icon)

	SetupCustomNode(node, pnlContent, needsapp)

	return node;

end

local blacklist = {
	//['vehicles'] = true,
	['weapons'] = true,
	['characters'] = true,
	['items'] = true
}

local function AddPropsOfParent(pnlContent, node, parentid)
	local Props = spawnmenu.GetPropTable()

	for FileName, Info in SortedPairs(Props) do

		if (parentid != Info.parentid) or blacklist[Info.name:lower()] then continue end

		local pnlnode = AddCustomizableNode(pnlContent, Info.name, Info.icon, node, Info.needsapp)
		pnlnode:SetExpanded(true)
		pnlnode.DoPopulate = function(self)

			if (self.PropPanel) then return end

			self.PropPanel = vgui.Create("ContentContainer", pnlContent)
			self.PropPanel:SetVisible(false)

			for i, object in pairs(Info.contents) do

				local cp = spawnmenu.GetContentType(object.type)
				if (cp ) then cp(self.PropPanel, object) end

			end

			self.PropPanel:SetTriggerSpawnlistChange(true)

		end

		AddPropsOfParent(pnlContent, pnlnode, Info.id)

	end

end

hook("PopulateContent", "AddCustomContent", function(pnlContent, tree, node)

	local node = AddCustomizableNode(pnlContent, "#spawnmenu.category.your_spawnlists", "", tree)
	node:SetDraggableName("CustomContent")

	--
	-- Save the spawnlist when children drag and dropped
	--
	node.OnModified = function()
		hook.Run("SpawnlistContentChanged")
	end

	AddPropsOfParent(pnlContent, node, 0)

	node:SetExpanded(true)
	node:MoveToBack();

	CustomizableSpawnlistNode = node;

	-- Select the first panel
	local FirstNode = node:GetChildNode(0)
	if (IsValid(FirstNode)) then
		FirstNode:InternalDoClick()
	end
end)
--PATH gamemodes/darkrp/gamemode/core/sandbox/spawnmenu/creationmenu/content/contenttypes/npcs_cl.lua:
hook( "PopulateNPCs", "AddNPCContent", function( pnlContent, tree, browseNode )

	-- Get a list of available NPCs
	local NPCList = list.Get( "NPC" )

	-- Categorize them
	local Categories = {}
	for k, v in pairs( NPCList ) do

		local Category = v.Category or "Other"
		if ( !isstring( Category ) ) then Category = tostring( Category ) end

		local Tab = Categories[ Category ] or {}
		Tab[ k ] = v
		Categories[ Category ] = Tab

	end

	-- Create an icon for each one and put them on the panel
	local CustomIcons = list.Get( "ContentCategoryIcons" )
	for CategoryName, v in SortedPairs( Categories ) do

		-- Add a node to the tree
		local node = tree:AddNode( CategoryName, CustomIcons[ CategoryName ] or "icon16/monkey.png" )

		-- When we click on the node - populate it using this function
		node.DoPopulate = function( self )

			-- If we've already populated it - forget it.
			if ( self.PropPanel ) then return end

			-- Create the container panel
			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for name, ent in SortedPairsByMemberValue( v, "Name" ) do

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "npc", self.PropPanel, {
					nicename	= ent.Name or name,
					spawnname	= name,
					material	= ent.IconOverride or "entities/" .. name .. ".png",
					weapon		= ent.Weapons,
					admin		= ent.AdminOnly
				} )

			end

		end

		-- If we click on the node populate it and switch to it.
		node.DoClick = function( self )

			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )

		end

	end

	-- Select the first node
	local FirstNode = tree:Root():GetChildNode( 0 )
	if ( IsValid( FirstNode ) ) then
		FirstNode:InternalDoClick()
	end

end )

local PANEL = {}

Derma_Hook( PANEL, "Paint", "Paint", "Tree" )
PANEL.m_bBackground = true -- Hack for above

function PANEL:AddCheckbox( text, cvar )
	local DermaCheckbox = self:Add( "DCheckBoxLabel", self )
	DermaCheckbox:Dock( TOP )
	DermaCheckbox:SetText( text )
	DermaCheckbox:SetDark( true )
	DermaCheckbox:SetConVar( cvar)
	DermaCheckbox:SizeToContents()
	DermaCheckbox:DockMargin( 0, 5, 0, 0 )
end

function PANEL:Init()

	self:SetOpenSize( 150 )
	self:DockPadding( 15, 10, 15, 10 )

	self:AddCheckbox( "#menubar.npcs.disableai", "ai_disabled" )
	self:AddCheckbox( "#menubar.npcs.ignoreplayers", "ai_ignoreplayers" )
	self:AddCheckbox( "#menubar.npcs.keepcorpses", "ai_serverragdolls" )
	self:AddCheckbox( "#menubar.npcs.autoplayersquad", "npc_citizen_auto_player_squad" )

	local label = vgui.Create( "DLabel", self )
	label:Dock( TOP )
	label:DockMargin( 0, 5, 0, 0 )
	label:SetDark( true )
	label:SetText( "#menubar.npcs.weapon" )

	local DComboBox = vgui.Create( "DComboBox", self )
	DComboBox:Dock( TOP )
	DComboBox:DockMargin( 0, 0, 0, 0 )
	DComboBox:SetConVar( "gmod_npcweapon" )
	DComboBox:SetSortItems( false )

	DComboBox:AddChoice( "#menubar.npcs.defaultweapon", "" )
	DComboBox:AddChoice( "#menubar.npcs.noweapon", "none" )

	-- Sort the items by name, and group by category
	local groupedWeps = {}
	for _, v in pairs( list.Get( "NPCUsableWeapons" ) ) do
		local cat = (v.category or ""):lower()
		groupedWeps[ cat ] = groupedWeps[ cat ] or {}
		groupedWeps[ cat ][ v.class ] = language.GetPhrase( v.title )
	end

	for group, items in SortedPairs( groupedWeps ) do
		DComboBox:AddSpacer()
		for class, title in SortedPairsByValue( items ) do
			DComboBox:AddChoice( title, class )
		end
	end

	function DComboBox:OnSelect( index, value )
		self:ConVarChanged( self.Data[ index ] )
	end

	self:Open()

end

function PANEL:PerformLayout()
end

vgui.Register( "SpawnmenuNPCSidebarToolbox", PANEL, "DDrawer" )

spawnmenu.AddCreationTab( "#spawnmenu.category.npcs", function()

	local ctrl = vgui.Create( "SpawnmenuContentPanel" )
	ctrl:CallPopulateHook( "PopulateNPCs" )

	local sidebar = ctrl.ContentNavBar
	sidebar.Options = vgui.Create( "SpawnmenuNPCSidebarToolbox", sidebar )

	return ctrl

end, "icon16/monkey.png", 20, nil, function() return IsValid(LocalPlayer()) and LocalPlayer():IsSuperAdmin() end  )

--PATH lua/weapons/ammogiver.lua:
SWEP.PrintName = "Патроны"			
SWEP.Slot = 3
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.DrawCrosshair	= false

SWEP.Author	= ""


SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = "Left click - give ammos)"
 
SWEP.Spawnable = true
SWEP.AdminSpawnable	= false
 
SWEP.ViewModel = "" 
SWEP.WorldModel = ""
 
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize	= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo	= "none"

if CLIENT then return end

function SWEP:Initialize() 
	self:SetHoldType("normal")
end
 
function SWEP:Reload()

end
 
function SWEP:Think()	
end

local blocked = {
	["rust_syringe"] = true,
	['weapon_hexshield'] = true
}

function SWEP:PrimaryAttack()
	local ply = self.Owner

	if (ply.nexta or 0) - CurTime() > 0 then return ply:ChatPrint("Вы не можете взять патроны еще ".. math.Truncate((ply.nexta or 0) - CurTime(), 0).." секунд")  end

	for k, v in pairs(ply:GetWeapons()) do
		if blocked[v:GetClass()] then continue end
		ply:GiveAmmo(300, v:GetPrimaryAmmoType(), false)
	end

	ply:ChatPrint("Вы взяли патроны")

	ply.nexta = CurTime() + 300
end


function SWEP:CanPrimaryAttack()
    return false
end
function SWEP:ShootBullet()
    return false
end
--PATH addons/__main/lua/weapons/bobs_gun_base/shared.lua:
-- //Variables that are used on both client and server
SWEP.Category                           = ""
SWEP.Gun                                        = ""
SWEP.Author                             = "Generic Default, Worshipper, Clavus, and Bob"
SWEP.Contact                            = ""
SWEP.Purpose                            = ""
SWEP.Instructions                               = ""
SWEP.MuzzleAttachment                   = "1"           -- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.DrawCrosshair                      = true          -- Hell no, crosshairs r 4 nubz!
SWEP.ViewModelFOV                       = 65            -- How big the gun will look
SWEP.ViewModelFlip                      = true          -- True for CSS models, False for HL2 models
 
SWEP.Spawnable                          = false
SWEP.AdminSpawnable                     = false
 
SWEP.Primary.Sound                      = Sound("")                             -- Sound of the gun
SWEP.Primary.Round                      = ("")                                  -- What kind of bullet?
SWEP.Primary.Cone                       = 0.2                                   -- Accuracy of NPCs
SWEP.Primary.Recoil             = 10
SWEP.Primary.Damage             = 10
SWEP.Primary.Spread             = .01                                   --define from-the-hip accuracy (1 is terrible, .0001 is exact)
SWEP.Primary.NumShots   = 1
SWEP.Primary.RPM                                = 0                                     -- This is in Rounds Per Minute
SWEP.Primary.ClipSize                   = 0                                     -- Size of a clip
SWEP.Primary.DefaultClip                        = 0                                     -- Default number of bullets in a clip
SWEP.Primary.KickUp                     = 0                                     -- Maximum up recoil (rise)
SWEP.Primary.KickDown                   = 0                                     -- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal                     = 0                                     -- Maximum side recoil (koolaid)
SWEP.Primary.Automatic                  = true                                  -- Automatic/Semi Auto
SWEP.Primary.Ammo                       = "none"                                        -- What kind of ammo
 
-- SWEP.Secondary.ClipSize                 = 0                                     -- Size of a clip
-- SWEP.Secondary.DefaultClip                      = 0                                     -- Default number of bullets in a clip
-- SWEP.Secondary.Automatic                        = false                                 -- Automatic/Semi Auto
SWEP.Secondary.Ammo                     = ""
--//HAHA! GOTCHA, YA BASTARD!

-- SWEP.Secondary.IronFOV                  = 0                                     -- How much you 'zoom' in. Less is more!
 
SWEP.Penetration                = true
SWEP.Ricochet                   = true
SWEP.MaxRicochet                        = 1
SWEP.RicochetCoin               = 1
SWEP.BoltAction                 = false
SWEP.Scoped                             = false
SWEP.ShellTime                  = .35
SWEP.Tracer                             = 0    
SWEP.CanBeSilenced              = false
SWEP.Silenced                   = false
SWEP.NextSilence                = 0
SWEP.SelectiveFire              = false
SWEP.NextFireSelect             = 0
SWEP.OrigCrossHair = true
 
local PainMulti = 1
 
if GetConVar("M9KDamageMultiplier") == nil then
		PainMulti = 1
		print("M9KDamageMultiplier is missing! You may have hit the lua limit! Reverting multiplier to 1.")
else
		PainMulti = GetConVar("M9KDamageMultiplier"):GetFloat()
		if PainMulti < 0 then
				PainMulti = PainMulti * -1
				print("Your damage multiplier was in the negatives. It has been reverted to a positive number. Your damage multiplier is now "..PainMulti)
		end
end
 
function NewM9KDamageMultiplier(cvar, previous, new)
		print("multiplier has been changed ")
		if GetConVar("M9KDamageMultiplier") == nil then
				PainMulti = 1
				print("M9KDamageMultiplier is missing! You may have hit the lua limit! Reverting multiplier to 1, you will notice no changes.")
		else
				PainMulti = GetConVar("M9KDamageMultiplier"):GetFloat()
				if PainMulti < 0 then
						PainMulti = PainMulti * -1
						print("Your damage multiplier was in the negatives. It has been reverted to a positive number. Your damage multiplier is now "..PainMulti)
				end
		end
end
cvars.AddChangeCallback("M9KDamageMultiplier", NewM9KDamageMultiplier)
 
function NewDefClips(cvar, previous, new)
		print("Default clip multiplier has changed. A server restart will be required for these changes to take effect.")
end
cvars.AddChangeCallback("M9KDefaultClip", NewDefClips)
 
if GetConVar("M9KDefaultClip") == nil then
		print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
		if GetConVar("M9KDefaultClip"):GetInt() >= 0 then
				print("M9K Weapons will now spawn with "..GetConVar("M9KDefaultClip"):GetFloat().." clips.")
		else
				print("Default clips will be not be modified")
		end
end
 
SWEP.IronSightsPos = Vector (2.4537, 1.0923, 0.2696)
SWEP.IronSightsAng = Vector (0.0186, -0.0547, 0)
 
SWEP.VElements = {}
SWEP.WElements = {}
 
function SWEP:Initialize()
		self.Reloadaftershoot = 0                               -- Can't reload when firing
		self:SetHoldType(self.HoldType)
		self.OrigCrossHair = self.DrawCrosshair
		if SERVER and self.Owner:IsNPC() then
				self:SetNPCMinBurst(3)                 
				self:SetNPCMaxBurst(10)                 -- None of this really matters but you need it here anyway
				self:SetNPCFireRate(1/(self.Primary.RPM/60))   
				-- //self:SetCurrentWeaponProficiency( WEAPON_PROFICIENCY_VERY_GOOD )
		end
	   
		if CLIENT then
	   
				-- // Create a new table for every weapon instance
				self.VElements = table.FullCopy( self.VElements )
				self.WElements = table.FullCopy( self.WElements )
				self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
 
				self:CreateModels(self.VElements) -- create viewmodels
				self:CreateModels(self.WElements) -- create worldmodels
			   
				-- // init view model bone build function
				if IsValid(self.Owner) and self.Owner:IsPlayer() then
				if self.Owner:Alive() then
						local vm = self.Owner:GetViewModel()
						if IsValid(vm) then
								self:ResetBonePositions(vm)
								-- // Init viewmodel visibility
								if (self.ShowViewModel == nil or self.ShowViewModel) then
										vm:SetColor(Color(255,255,255,255))
								else
										-- // however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
										vm:SetMaterial("Debug/hsv")                    
								end
						end
					   
				end
				end
			   
		end
	   
		if CLIENT then
				local oldpath = "vgui/hud/name" -- the path goes here
				local newpath = string.gsub(oldpath, "name", self.Gun)
				self.WepSelectIcon = surface.GetTextureID(newpath)
		end
	   
end
 
function SWEP:Equip()
		self:SetHoldType(self.HoldType)
end
 
function SWEP:Deploy()
		self:SetIronsights(false, self.Owner)                                   -- Set the ironsight false
		self:SetHoldType(self.HoldType)
	   
		if self.Silenced then
		self.Weapon:SendWeaponAnim( ACT_VM_DRAW_SILENCED )
		else
		self.Weapon:SendWeaponAnim( ACT_VM_DRAW )
		end
 
		self.Weapon:SetNWBool("Reloading", false)
	   
		if !self.Owner:IsNPC() and self.Owner != nil then
				if self.ResetSights and self.Owner:GetViewModel() != nil then
						self.ResetSights = CurTime() + self.Owner:GetViewModel():SequenceDuration()
				end
		end
		return true
end
 
function SWEP:Holster()
	   
		if CLIENT and IsValid(self.Owner) and not self.Owner:IsNPC() then
				local vm = self.Owner:GetViewModel()
				if IsValid(vm) then
						self:ResetBonePositions(vm)
				end
		end
	   
		return true
end
 
function SWEP:OnRemove()
 
		if CLIENT and IsValid(self.Owner) and not self.Owner:IsNPC() then
				local vm = self.Owner:GetViewModel()
				if IsValid(vm) then
						self:ResetBonePositions(vm)
				end
		end
 
end
 
function SWEP:GetCapabilities()
		return CAP_WEAPON_RANGE_ATTACK1, CAP_INNATE_RANGE_ATTACK1
end
 
function SWEP:Precache()
		util.PrecacheSound(self.Primary.Sound)
		util.PrecacheModel(self.ViewModel)
		util.PrecacheModel(self.WorldModel)
end
 
function SWEP:PrimaryAttack()
	OkaySoFar = true
	if not IsValid(self) then 
		OkaySoFar = false
	else if not IsValid(self.Weapon) then 
		OkaySoFar = false
	else if not IsValid(self.Owner) then
		OkaySoFar = false
	end	end	end
	
	if not OkaySoFar then return end
	
	if self:CanPrimaryAttack() and self.Owner:IsPlayer() then
		if !self.Owner:KeyDown(IN_SPEED) and !self.Owner:KeyDown(IN_RELOAD) then
				self:ShootBulletInformation()
				self.Weapon:TakePrimaryAmmo(1)
			   
				if self.Silenced then
						self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK_SILENCED )
						self.Weapon:EmitSound(self.Primary.SilencedSound)
				else
						self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
						self.Weapon:EmitSound(self.Primary.Sound)
				end    
	   
				local fx                = EffectData()
				fx:SetEntity(self.Weapon)
				fx:SetOrigin(self.Owner:GetShootPos())
				fx:SetNormal(self.Owner:GetAimVector())
				fx:SetAttachment(self.MuzzleAttachment)
				if GetConVar("M9KGasEffect") != nil then
						if GetConVar("M9KGasEffect"):GetBool() then
								util.Effect("m9k_rg_muzzle_rifle",fx)
						end
				end
				self.Owner:SetAnimation( PLAYER_ATTACK1 )
				self.Owner:MuzzleFlash()
				self.Weapon:SetNextPrimaryFire(CurTime()+1/(self.Primary.RPM/60))
				self:CheckWeaponsAndAmmo()
				self.RicochetCoin = (math.random(1,4))
				if self.BoltAction then self:BoltBack() end
		end
		elseif self:CanPrimaryAttack() and self.Owner:IsNPC() then
				self:ShootBulletInformation()
				self.Weapon:TakePrimaryAmmo(1)
				self.Weapon:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
				self.Weapon:EmitSound(self.Primary.Sound)
				self.Owner:SetAnimation( PLAYER_ATTACK1 )
				self.Owner:MuzzleFlash()
				self.Weapon:SetNextPrimaryFire(CurTime()+1/(self.Primary.RPM/60))
				self.RicochetCoin = (math.random(1,4))
		end
end
 
function SWEP:CheckWeaponsAndAmmo()
		if SERVER and self.Weapon != nil and (GetConVar("M9KWeaponStrip"):GetBool()) then
				if self.Weapon:Clip1() == 0 && self.Owner:GetAmmoCount( self.Weapon:GetPrimaryAmmoType() ) == 0 then
						timer.Simple(.1, function() if SERVER then if not IsValid(self) then return end
								if self.Owner == nil then return end
								self.Owner:StripWeapon(self.Gun)
						end end)
				end
		end
end
 
 
/*---------------------------------------------------------
   Name: SWEP:ShootBulletInformation()
   Desc: This func add the damage, the recoil, the number of shots and the cone on the bullet.
-----------------------------------------------------*/
function SWEP:ShootBulletInformation()
 
		local CurrentDamage
		local CurrentRecoil
		local CurrentCone
		local basedamage
	   
		if (self:GetIronsights() == true) and self.Owner:KeyDown(IN_ATTACK2) then
		CurrentCone = self.Primary.IronAccuracy
		else
		CurrentCone = self.Primary.Spread
		end
		local damagedice = math.Rand(.85,1.3)
	   
		basedamage = PainMulti * self.Primary.Damage
		CurrentDamage = basedamage * damagedice
		CurrentRecoil = self.Primary.Recoil
	   
		-- //Player is aiming
		if (self:GetIronsights() == true) and self.Owner:KeyDown(IN_ATTACK2) then
				self:ShootBullet(CurrentDamage, CurrentRecoil / 6, self.Primary.NumShots, CurrentCone)
		-- //Player is not aiming
		else
			if IsValid(self) then
				if IsValid(self.Weapon) then
					if IsValid(self.Owner) then
					self:ShootBullet(CurrentDamage, CurrentRecoil, self.Primary.NumShots, CurrentCone)
					end
				end
			end	
		end
	   
end
 
/*---------------------------------------------------------
   Name: SWEP:ShootBullet()
   Desc: A convenience func to shoot bullets.
-----------------------------------------------------*/
local TracerName = "Tracer"
 
function SWEP:ShootBullet(damage, recoil, num_bullets, aimcone)
 
		num_bullets             = num_bullets or 1
		aimcone                         = aimcone or 0
 
		self:ShootEffects()
 
		if self.Tracer == 1 then
				TracerName = "Ar2Tracer"
		elseif self.Tracer == 2 then
				TracerName = "AirboatGunHeavyTracer"
		else
				TracerName = "Tracer"
		end
	   
		local bullet = {}
				bullet.Num              = num_bullets
				bullet.Src              = self.Owner:GetShootPos()                      -- Source
				bullet.Dir              = self.Owner:GetAimVector()                     -- Dir of bullet
				bullet.Spread   = Vector(aimcone, aimcone, 0)                   -- Aim Cone
				bullet.Tracer   = 3                                                     -- Show a tracer on every x bullets
				bullet.TracerName = TracerName
				bullet.Force    = damage * 0.25                                 -- Amount of force to give to phys objects
				bullet.Damage   = damage
				bullet.Callback = function(attacker, tracedata, dmginfo)	   
										return self:RicochetCallback(0, attacker, tracedata, dmginfo)
								  end
		if IsValid(self) then
			if IsValid(self.Weapon) then
				if IsValid(self.Owner) then
				self.Owner:FireBullets(bullet)
				end
			end
		end
		-- //if SERVER and !self.Owner:IsNPC() then
		-- //		local anglo = Angle(math.Rand(-self.Primary.KickDown,-self.Primary.KickUp), math.Rand(-self.Primary.KickHorizontal,self.Primary.KickHorizontal), 0)
		-- //		self.Owner:ViewPunch(anglo)
			   
		-- //		local eyes = self.Owner:EyeAngles()
		-- //		eyes.pitch = eyes.pitch + anglo.pitch
		-- //		eyes.yaw = eyes.yaw + anglo.yaw
		-- //		if game.SinglePlayer() then self.Owner:SetEyeAngles(eyes) end
		-- //end
 
		local anglo1 = Angle(math.Rand(-self.Primary.KickDown,-self.Primary.KickUp), math.Rand(-self.Primary.KickHorizontal,self.Primary.KickHorizontal), 0)
		self.Owner:ViewPunch(anglo1)
	   
		if SERVER and game.SinglePlayer() and !self.Owner:IsNPC()  then
				local offlineeyes = self.Owner:EyeAngles()
				offlineeyes.pitch = offlineeyes.pitch + anglo1.pitch
				offlineeyes.yaw = offlineeyes.yaw + anglo1.yaw
				if GetConVar("M9KDynamicRecoil"):GetBool() then
						self.Owner:SetEyeAngles(offlineeyes)
				end
		end
	   
		if CLIENT and !game.SinglePlayer() and !self.Owner:IsNPC() then
				local anglo = Angle(math.Rand(-self.Primary.KickDown,-self.Primary.KickUp), math.Rand(-self.Primary.KickHorizontal,self.Primary.KickHorizontal), 0)
 
				local eyes = self.Owner:EyeAngles()
				eyes.pitch = eyes.pitch + (anglo.pitch/3)
				eyes.yaw = eyes.yaw + (anglo.yaw/3)
				if GetConVar("M9KDynamicRecoil"):GetBool() then
						self.Owner:SetEyeAngles(eyes)
				end
		end
 
end
 
/*---------------------------------------------------------
   Name: SWEP:RicochetCallback()
-----------------------------------------------------*/
 
function SWEP:RicochetCallback(bouncenum, attacker, tr, dmginfo)
	   
		if not IsFirstTimePredicted() then
		return {damage = false, effects = false}
		end
	   
		local PenetrationChecker = false
	   
		if GetConVar("M9KDisablePenetration") == nil then
				PenetrationChecker = false
		else
				PenetrationChecker = GetConVar("M9KDisablePenetration"):GetBool()
		end
	   
		if PenetrationChecker then return {damage = true, effects = DoDefaultEffect} end
 
		bulletmiss = {}
				bulletmiss[1]=Sound("weapons/fx/nearmiss/bulletLtoR03.wav")
				bulletmiss[2]=Sound("weapons/fx/nearmiss/bulletLtoR04.wav")
				bulletmiss[3]=Sound("weapons/fx/nearmiss/bulletLtoR06.wav")
				bulletmiss[4]=Sound("weapons/fx/nearmiss/bulletLtoR07.wav")
				bulletmiss[5]=Sound("weapons/fx/nearmiss/bulletLtoR09.wav")
				bulletmiss[6]=Sound("weapons/fx/nearmiss/bulletLtoR10.wav")
				bulletmiss[7]=Sound("weapons/fx/nearmiss/bulletLtoR13.wav")
				bulletmiss[8]=Sound("weapons/fx/nearmiss/bulletLtoR14.wav")
			   
		local DoDefaultEffect = true
		if (tr.HitSky) then return end
	   
		// -- Can we go through whatever we hit?
		if (self.Penetration) and (self:BulletPenetrate(bouncenum, attacker, tr, dmginfo)) then
				return {damage = true, effects = DoDefaultEffect}
		end
	   
		// -- Your screen will shake and you'll hear the savage hiss of an approaching bullet which passing if someone is shooting at you.
		if (tr.MatType != MAT_METAL) then
				if (SERVER) then
						util.ScreenShake(tr.HitPos, 5, 0.1, 0.5, 64)
						sound.Play(table.Random(bulletmiss), tr.HitPos, 75, math.random(75,150), 1)
				end
 
				if self.Tracer == 0 or self.Tracer == 1 or self.Tracer == 2 then
						local effectdata = EffectData()
								effectdata:SetOrigin(tr.HitPos)
								effectdata:SetNormal(tr.HitNormal)
								effectdata:SetScale(20)
						util.Effect("AR2Impact", effectdata)
				elseif self.Tracer == 3 then
						local effectdata = EffectData()
								effectdata:SetOrigin(tr.HitPos)
								effectdata:SetNormal(tr.HitNormal)
								effectdata:SetScale(20)
						util.Effect("StunstickImpact", effectdata)
				end
 
				return
		end
 
		if (self.Ricochet == false) then return {damage = true, effects = DoDefaultEffect} end
	   
		if self.Primary.Ammo == "SniperPenetratedRound" then -- .50 Ammo
				self.MaxRicochet = 12
		elseif self.Primary.Ammo == "pistol" then -- pistols
				self.MaxRicochet = 2
		elseif self.Primary.Ammo == "357" then -- revolvers with big ass bullets
				self.MaxRicochet = 4
		elseif self.Primary.Ammo == "smg1" then -- smgs
				self.MaxRicochet = 5
		elseif self.Primary.Ammo == "ar2" then -- assault rifles
				self.MaxRicochet = 8
		elseif self.Primary.Ammo == "buckshot" then -- shotguns
				self.MaxRicochet = 1
		elseif self.Primary.Ammo == "slam" then -- secondary shotguns
				self.MaxRicochet = 1
		elseif self.Primary.Ammo ==     "AirboatGun" then -- metal piercing shotgun pellet
				self.MaxRicochet = 8
		end
	   
		if (bouncenum > self.MaxRicochet) then return end
	   
		// -- Bounce vector
		local trace = {}
		trace.start = tr.HitPos
		trace.endpos = trace.start + (tr.HitNormal * 16384)
 
		local trace = util.TraceLine(trace)
 
		local DotProduct = tr.HitNormal:Dot(tr.Normal * -1)
	   
		local ricochetbullet = {}
				ricochetbullet.Num              = 1
				ricochetbullet.Src              = tr.HitPos + (tr.HitNormal * 5)
				ricochetbullet.Dir              = ((2 * tr.HitNormal * DotProduct) + tr.Normal) + (VectorRand() * 0.05)
				ricochetbullet.Spread   = Vector(0, 0, 0)
				ricochetbullet.Tracer   = 1
				ricochetbullet.TracerName       = "m9k_effect_mad_ricochet_trace"
				ricochetbullet.Force            = dmginfo:GetDamage() * 0.15
				ricochetbullet.Damage   = dmginfo:GetDamage() * 0.5
				ricochetbullet.Callback         = function(a, b, c)
						if (self.Ricochet) then  
						local impactnum
						if tr.MatType == MAT_GLASS then impactnum = 0 else impactnum = 1 end
						return self:RicochetCallback(bouncenum + impactnum, a, b, c) end
						end
 
		timer.Simple(0, function() attacker:FireBullets(ricochetbullet) end)
	   
		return {damage = true, effects = DoDefaultEffect}
end
 
 
/*---------------------------------------------------------
   Name: SWEP:BulletPenetrate()
-----------------------------------------------------*/
function SWEP:BulletPenetrate(bouncenum, attacker, tr, paininfo)
 
		local MaxPenetration
 
		if self.Primary.Ammo == "SniperPenetratedRound" then -- .50 Ammo
				MaxPenetration = 20
		elseif self.Primary.Ammo == "pistol" then -- pistols
				MaxPenetration = 9
		elseif self.Primary.Ammo == "357" then -- revolvers with big ass bullets
				MaxPenetration = 12
		elseif self.Primary.Ammo == "smg1" then -- smgs
				MaxPenetration = 14
		elseif self.Primary.Ammo == "ar2" then -- assault rifles
				MaxPenetration = 16
		elseif self.Primary.Ammo == "buckshot" then -- shotguns
				MaxPenetration = 5
		elseif self.Primary.Ammo == "slam" then -- secondary shotguns
				MaxPenetration = 5
		elseif self.Primary.Ammo ==     "AirboatGun" then -- metal piercing shotgun pellet
				MaxPenetration = 17
		else
				MaxPenetration = 14
		end
 
		local DoDefaultEffect = true
		// -- Don't go through metal, sand or player
	   
		if self.Primary.Ammo == "pistol" or
				self.Primary.Ammo == "buckshot" or
				self.Primary.Ammo == "slam" then self.Ricochet = true
		else
				if self.RicochetCoin == 1 then
				self.Ricochet = true
				elseif self.RicochetCoin >= 2 then
				self.Ricochet = false
				end
		end
	   
		if self.Primary.Ammo == "SniperPenetratedRound" then self.Ricochet = true end
	   
		if self.Primary.Ammo == "SniperPenetratedRound" then -- .50 Ammo
				self.MaxRicochet = 10
		elseif self.Primary.Ammo == "pistol" then -- pistols
				self.MaxRicochet = 2
		elseif self.Primary.Ammo == "357" then -- revolvers with big ass bullets
				self.MaxRicochet = 5
		elseif self.Primary.Ammo == "smg1" then -- smgs
				self.MaxRicochet = 4
		elseif self.Primary.Ammo == "ar2" then -- assault rifles
				self.MaxRicochet = 5
		elseif self.Primary.Ammo == "buckshot" then -- shotguns
				self.MaxRicochet = 0
		elseif self.Primary.Ammo == "slam" then -- secondary shotguns
				self.MaxRicochet = 0
		elseif self.Primary.Ammo ==     "AirboatGun" then -- metal piercing shotgun pellet
				self.MaxRicochet = 8
		end
	   
		if (tr.MatType == MAT_METAL and self.Ricochet == true and self.Primary.Ammo != "SniperPenetratedRound" ) then return false end
 
		// -- Don't go through more than 3 times
		if (bouncenum > self.MaxRicochet) then return false end
	   
		// -- Direction (and length) that we are going to penetrate
		local PenetrationDirection = tr.Normal * MaxPenetration
	   
		if (tr.MatType == MAT_GLASS or tr.MatType == MAT_PLASTIC or tr.MatType == MAT_WOOD or tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH) then
				PenetrationDirection = tr.Normal * (MaxPenetration * 2)
		end
			   
		local trace     = {}
		trace.endpos    = tr.HitPos
		trace.start     = tr.HitPos + PenetrationDirection
		trace.mask              = MASK_SHOT
		trace.filter    = {self.Owner}
		   
		local trace     = util.TraceLine(trace)
	   
		// -- Bullet didn't penetrate.
		if (trace.StartSolid or trace.Fraction >= 1.0 or tr.Fraction <= 0.0) then return false end
	   
		// -- Damage multiplier depending on surface
		local fDamageMulti = 0.5
	   
		if self.Primary.Ammo == "SniperPenetratedRound" then
				fDamageMulti = 1
		elseif(tr.MatType == MAT_CONCRETE or tr.MatType == MAT_METAL) then
				fDamageMulti = 0.3
		elseif (tr.MatType == MAT_WOOD or tr.MatType == MAT_PLASTIC or tr.MatType == MAT_GLASS) then
				fDamageMulti = 0.8
		elseif (tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH) then
				fDamageMulti = 0.9
		end
	   
		local damagedice = math.Rand(.85,1.3)
		local newdamage = self.Primary.Damage * damagedice
			   
		// -- Fire bullet from the exit point using the original trajectory
		local penetratedbullet = {}
				penetratedbullet.Num            = 1
				penetratedbullet.Src            = trace.HitPos
				penetratedbullet.Dir            = tr.Normal    
				penetratedbullet.Spread         = Vector(0, 0, 0)
				penetratedbullet.Tracer = 2
				penetratedbullet.TracerName     = "m9k_effect_mad_penetration_trace"
				penetratedbullet.Force          = 5
				penetratedbullet.Damage = paininfo:GetDamage() * fDamageMulti
				penetratedbullet.Callback       = function(a, b, c) if (self.Ricochet) then    
				local impactnum
				if tr.MatType == MAT_GLASS then impactnum = 0 else impactnum = 1 end
				return self:RicochetCallback(bouncenum + impactnum, a,b,c) end end     
			   
		timer.Simple(0, function() if attacker != nil then attacker:FireBullets(penetratedbullet) end end)
 
		return true
end
 
 
function SWEP:SecondaryAttack()
		return false
end
 
function SWEP:Reload()
		if not IsValid(self) then return end if not IsValid(self.Owner) then return end
	   
		if self.Owner:IsNPC() then
				self.Weapon:DefaultReload(ACT_VM_RELOAD)
		return end
	   
		if self.Owner:KeyDown(IN_USE) then return end
	   
		if self.Silenced then
				self.Weapon:DefaultReload(ACT_VM_RELOAD_SILENCED)
		else
				self.Weapon:DefaultReload(ACT_VM_RELOAD)
		end
	   
		if !self.Owner:IsNPC() then
				if self.Owner:GetViewModel() == nil then self.ResetSights = CurTime() + 3 else
				self.ResetSights = CurTime() + self.Owner:GetViewModel():SequenceDuration()
				end
		end
	   
		if SERVER and self.Weapon != nil then
		if ( self.Weapon:Clip1() < self.Primary.ClipSize ) and !self.Owner:IsNPC() then
		-- //When the current clip < full clip and the rest of your ammo > 0, then
				self.Owner:SetFOV( 0, 0.3 )
				-- //Zoom = 0
				self:SetIronsights(false)
				-- //Set the ironsight to false
				self.Weapon:SetNWBool("Reloading", true)
		end
		local waitdammit = (self.Owner:GetViewModel():SequenceDuration())
		timer.Simple(waitdammit + .1,
				function()
				if self.Weapon == nil then return end
				self.Weapon:SetNWBool("Reloading", false)
				if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then
						if CLIENT then return end
						if self.Scoped == false then
								self.Owner:SetFOV( self.Secondary.IronFOV, 0.3 )
								self.IronSightsPos = self.SightsPos                                     -- Bring it up
								self.IronSightsAng = self.SightsAng                                     -- Bring it up
								self:SetIronsights(true, self.Owner)
								self.DrawCrosshair = false
						else return end
				elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then
						if self.Weapon:GetNextPrimaryFire() <= (CurTime() + .03) then
								self.Weapon:SetNextPrimaryFire(CurTime()+0.3)                   -- Make it so you can't shoot for another quarter second
						end
						self.IronSightsPos = self.RunSightsPos                                  -- Hold it down
						self.IronSightsAng = self.RunSightsAng                                  -- Hold it down
						self:SetIronsights(true, self.Owner)                                    -- Set the ironsight true
						self.Owner:SetFOV( 0, 0.3 )
				else return end
				end)
		end
end
 
function SWEP:PostReloadScopeCheck()
		if self.Weapon == nil then return end
		self.Weapon:SetNWBool("Reloading", false)
		if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then
				if CLIENT then return end
				if self.Scoped == false then
						self.Owner:SetFOV( self.Secondary.IronFOV, 0.3 )
						self.IronSightsPos = self.SightsPos                                     -- Bring it up
						self.IronSightsAng = self.SightsAng                                     -- Bring it up
						self:SetIronsights(true, self.Owner)
						self.DrawCrosshair = false
				else return end
		elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then
				if self.Weapon:GetNextPrimaryFire() <= (CurTime() + .03) then
						self.Weapon:SetNextPrimaryFire(CurTime()+0.3)                           -- Make it so you can't shoot for another quarter second
				end
				self.IronSightsPos = self.RunSightsPos                                  -- Hold it down
				self.IronSightsAng = self.RunSightsAng                                  -- Hold it down
				self:SetIronsights(true, self.Owner)                                    -- Set the ironsight true
				self.Owner:SetFOV( 0, 0.3 )
		else return end
end
 
function SWEP:Silencer()
	   
		if self.NextSilence > CurTime() then return end
	   
		if self.Weapon != nil then
				self.Owner:SetFOV( 0, 0.3 )
				self:SetIronsights(false)
				self.Weapon:SetNWBool("Reloading", true) -- i know we're not reloading but it works
		end
	   
		if self.Silenced then
				self:SendWeaponAnim(ACT_VM_DETACH_SILENCER)
				self.Silenced = false
		elseif not self.Silenced then
				self:SendWeaponAnim(ACT_VM_ATTACH_SILENCER)
				self.Silenced = true
		end
	   
		siltimer = CurTime() + (self.Owner:GetViewModel():SequenceDuration()) + 0.1
		if self.Weapon:GetNextPrimaryFire() <= siltimer then
				self.Weapon:SetNextPrimaryFire(siltimer)
		end
		self.NextSilence = siltimer
	   
		timer.Simple( ((self.Owner:GetViewModel():SequenceDuration()) + 0.1),
				function()
				if self.Weapon != nil then
						self.Weapon:SetNWBool("Reloading", false)
				if self.Owner:KeyDown(IN_ATTACK2) and self.Weapon:GetClass() == self.Gun then
						if CLIENT then return end
						if self.Scoped == false then
								self.Owner:SetFOV( self.Secondary.IronFOV, 0.3 )
								self.IronSightsPos = self.SightsPos                                     -- Bring it up
								self.IronSightsAng = self.SightsAng                                     -- Bring it up
								self:SetIronsights(true, self.Owner)
								self.DrawCrosshair = false
						else return end
				elseif self.Owner:KeyDown(IN_SPEED) and self.Weapon:GetClass() == self.Gun then
						if self.Weapon:GetNextPrimaryFire() <= (CurTime()+0.3) then
								self.Weapon:SetNextPrimaryFire(CurTime()+0.3)                   -- Make it so you can't shoot for another quarter second
						end
						self.IronSightsPos = self.RunSightsPos                                  -- Hold it down
						self.IronSightsAng = self.RunSightsAng                                  -- Hold it down
						self:SetIronsights(true, self.Owner)                                    -- Set the ironsight true
						self.Owner:SetFOV( 0, 0.3 )
				else return end
				end
		end)
 
end
 
function SWEP:SelectFireMode()
 
				if self.Primary.Automatic then
						self.Primary.Automatic = false
						self.NextFireSelect = CurTime() + .5
						if CLIENT then
								self.Owner:PrintMessage(HUD_PRINTTALK, "Semi-automatic selected.")
						end
						self.Weapon:EmitSound("Weapon_AR2.Empty")
				else
						self.Primary.Automatic = true
						self.NextFireSelect = CurTime() + .5
						if CLIENT then
								self.Owner:PrintMessage(HUD_PRINTTALK, "Automatic selected.")
						end
						self.Weapon:EmitSound("Weapon_AR2.Empty")
				end
end
 
 
/*---------------------------------------------------------
IronSight
-----------------------------------------------------*/
function SWEP:IronSight()
 
		if not IsValid(self) then return end
		if not IsValid(self.Owner) then return end
 
		if !self.Owner:IsNPC() then
		if self.ResetSights and CurTime() >= self.ResetSights then
		self.ResetSights = nil
	   
		if self.Silenced then
				self:SendWeaponAnim(ACT_VM_IDLE_SILENCED)
		else
				self:SendWeaponAnim(ACT_VM_IDLE)
		end
		end end
	   
		if self.CanBeSilenced and self.NextSilence < CurTime() then
				if self.Owner:KeyDown(IN_USE) and self.Owner:KeyPressed(IN_ATTACK2) then
						self:Silencer()
				end
		end
	   
		if self.SelectiveFire and self.NextFireSelect < CurTime() and not (self.Weapon:GetNWBool("Reloading")) then
				if self.Owner:KeyDown(IN_USE) and self.Owner:KeyPressed(IN_RELOAD) then
						self:SelectFireMode()
				end
		end    
	   
-- //copy this...
		if self.Owner:KeyPressed(IN_SPEED) and not (self.Weapon:GetNWBool("Reloading")) then            -- If you are running
		if self.Weapon:GetNextPrimaryFire() <= (CurTime()+0.3) then
				self.Weapon:SetNextPrimaryFire(CurTime()+0.3)                           -- Make it so you can't shoot for another quarter second
		end
		self.IronSightsPos = self.RunSightsPos                                  -- Hold it down
		self.IronSightsAng = self.RunSightsAng                                  -- Hold it down
		self:SetIronsights(true, self.Owner)                                    -- Set the ironsight true
		self.Owner:SetFOV( 0, 0.3 )
		self.DrawCrosshair = false
		end                                                            
 
		if self.Owner:KeyReleased (IN_SPEED) then       -- If you release run then
		self:SetIronsights(false, self.Owner)                                   -- Set the ironsight true
		self.Owner:SetFOV( 0, 0.3 )
		self.DrawCrosshair = self.OrigCrossHair
		end                                                             -- Shoulder the gun
 
-- //down to this
		if !self.Owner:KeyDown(IN_USE) and !self.Owner:KeyDown(IN_SPEED) then
		-- //If the key E (Use Key) is not pressed, then
 
				if self.Owner:KeyPressed(IN_ATTACK2) and not (self.Weapon:GetNWBool("Reloading")) then
						self.Owner:SetFOV( self.Secondary.IronFOV, 0.3 )
						self.IronSightsPos = self.SightsPos                                     -- Bring it up
						self.IronSightsAng = self.SightsAng                                     -- Bring it up
						self:SetIronsights(true, self.Owner)
						self.DrawCrosshair = false
						-- //Set the ironsight true
 
						if CLIENT then return end
				end
		end
 
		if self.Owner:KeyReleased(IN_ATTACK2) and !self.Owner:KeyDown(IN_USE) and !self.Owner:KeyDown(IN_SPEED) then
		-- //If the right click is released, then
				self.Owner:SetFOV( 0, 0.3 )
				self.DrawCrosshair = self.OrigCrossHair
				self:SetIronsights(false, self.Owner)
				-- //Set the ironsight false
 
				if CLIENT then return end
		end
 
				if self.Owner:KeyDown(IN_ATTACK2) and !self.Owner:KeyDown(IN_USE) and !self.Owner:KeyDown(IN_SPEED) then
				self.SwayScale  = 0.05
				self.BobScale   = 0.05
				else
				self.SwayScale  = 1.0
				self.BobScale   = 1.0
				end
end
 
/*---------------------------------------------------------
Think
-----------------------------------------------------*/
function SWEP:Think()
 
self:IronSight()
 
end
 
/*---------------------------------------------------------
GetViewModelPosition
-----------------------------------------------------*/
local IRONSIGHT_TIME = 0.3
-- //Time to enter in the ironsight mod
 
function SWEP:GetViewModelPosition(pos, ang)
 
		if (not self.IronSightsPos) then return pos, ang end
 
		local bIron = self.Weapon:GetNWBool("M9K_Ironsights")
 
		if (bIron != self.bLastIron) then
				self.bLastIron = bIron
				self.fIronTime = CurTime()
 
		end
 
		local fIronTime = self.fIronTime or 0
 
		if (not bIron and fIronTime < CurTime() - IRONSIGHT_TIME) then
				return pos, ang
		end
 
		local Mul = 1.0
 
		if (fIronTime > CurTime() - IRONSIGHT_TIME) then
				Mul = math.Clamp((CurTime() - fIronTime) / IRONSIGHT_TIME, 0, 1)
 
				if not bIron then Mul = 1 - Mul end
		end
 
		local Offset    = self.IronSightsPos
 
		if (self.IronSightsAng) then
				ang = ang * 1
				ang:RotateAroundAxis(ang:Right(),               self.IronSightsAng.x * Mul)
				ang:RotateAroundAxis(ang:Up(),          self.IronSightsAng.y * Mul)
				ang:RotateAroundAxis(ang:Forward(),     self.IronSightsAng.z * Mul)
		end
 
		local Right     = ang:Right()
		local Up                = ang:Up()
		local Forward   = ang:Forward()
 
		pos = pos + Offset.x * Right * Mul
		pos = pos + Offset.y * Forward * Mul
		pos = pos + Offset.z * Up * Mul
 
		return pos, ang
end
 
/*---------------------------------------------------------
SetIronsights
-----------------------------------------------------*/
function SWEP:SetIronsights(b)
		self.Weapon:SetNWBool("M9K_Ironsights", b)
end
 
function SWEP:GetIronsights()
		return self.Weapon:GetNWBool("M9K_Ironsights")
end
 
 
if CLIENT then
 
		SWEP.vRenderOrder = nil
		function SWEP:ViewModelDrawn()
			   
				if not IsValid(self) then return end 
				if not IsValid(self.Owner) then return end
				local vm = self.Owner:GetViewModel()
				if !IsValid(vm) then return end
			   
				if (!self.VElements) then return end
			   
				self:UpdateBonePositions(vm)
 
				if (!self.vRenderOrder) then
					   
						-- // we build a render order because sprites need to be drawn after models
						self.vRenderOrder = {}
 
						for k, v in pairs( self.VElements ) do
								if (v.type == "Model") then
										table.insert(self.vRenderOrder, 1, k)
								elseif (v.type == "Sprite" or v.type == "Quad") then
										table.insert(self.vRenderOrder, k)
								end
						end
					   
				end
 
				for k, name in ipairs( self.vRenderOrder ) do
			   
						local v = self.VElements[name]
						if (!v) then self.vRenderOrder = nil break end
						if (v.hide) then continue end
					   
						local model = v.modelEnt
						local sprite = v.spriteMaterial
					   
						if (!v.bone) then continue end
					   
						local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
					   
						if (!pos) then continue end
					   
						if (v.type == "Model" and IsValid(model)) then
 
								model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
								ang:RotateAroundAxis(ang:Up(), v.angle.y)
								ang:RotateAroundAxis(ang:Right(), v.angle.p)
								ang:RotateAroundAxis(ang:Forward(), v.angle.r)
 
								model:SetAngles(ang)
								-- //model:SetModelScale(v.size)
								local matrix = Matrix()
								matrix:Scale(v.size)
								model:EnableMatrix( "RenderMultiply", matrix )
							   
								if (v.material == "") then
										model:SetMaterial("")
								elseif (model:GetMaterial() != v.material) then
										model:SetMaterial( v.material )
								end
							   
								if (v.skin and v.skin != model:GetSkin()) then
										model:SetSkin(v.skin)
								end
							   
								if (v.bodygroup) then
										for k, v in pairs( v.bodygroup ) do
												if (model:GetBodygroup(k) != v) then
														model:SetBodygroup(k, v)
												end
										end
								end
							   
								if (v.surpresslightning) then
										render.SuppressEngineLighting(true)
								end
							   
								render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
								render.SetBlend(v.color.a/255)
								model:DrawModel()
								render.SetBlend(1)
								render.SetColorModulation(1, 1, 1)
							   
								if (v.surpresslightning) then
										render.SuppressEngineLighting(false)
								end
							   
						elseif (v.type == "Sprite" and sprite) then
							   
								local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
								render.SetMaterial(sprite)
								render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
							   
						elseif (v.type == "Quad" and v.draw_func) then
							   
								local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
								ang:RotateAroundAxis(ang:Up(), v.angle.y)
								ang:RotateAroundAxis(ang:Right(), v.angle.p)
								ang:RotateAroundAxis(ang:Forward(), v.angle.r)
							   
								cam.Start3D2D(drawpos, ang, v.size)
										v.draw_func( self )
								cam.End3D2D()
 
						end
					   
				end
			   
		end
 
		SWEP.wRenderOrder = nil
		function SWEP:DrawWorldModel()
			   
				if (self.ShowWorldModel == nil or self.ShowWorldModel) then
						self:DrawModel()
				end
			   
				if (!self.WElements) then return end
			   
				if (!self.wRenderOrder) then
 
						self.wRenderOrder = {}
 
						for k, v in pairs( self.WElements ) do
								if (v.type == "Model") then
										table.insert(self.wRenderOrder, 1, k)
								elseif (v.type == "Sprite" or v.type == "Quad") then
										table.insert(self.wRenderOrder, k)
								end
						end
 
				end
			   
				if (IsValid(self.Owner)) then
						bone_ent = self.Owner
				else
						-- // when the weapon is dropped
						bone_ent = self
				end
			   
				for k, name in pairs( self.wRenderOrder ) do
			   
						local v = self.WElements[name]
						if (!v) then self.wRenderOrder = nil break end
						if (v.hide) then continue end
					   
						local pos, ang
					   
						if (v.bone) then
								pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
						else
								pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
						end
					   
						if (!pos) then continue end
					   
						local model = v.modelEnt
						local sprite = v.spriteMaterial
					   
						if (v.type == "Model" and IsValid(model)) then
 
								model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
								ang:RotateAroundAxis(ang:Up(), v.angle.y)
								ang:RotateAroundAxis(ang:Right(), v.angle.p)
								ang:RotateAroundAxis(ang:Forward(), v.angle.r)
 
								model:SetAngles(ang)
								-- //model:SetModelScale(v.size)
								local matrix = Matrix()
								matrix:Scale(v.size)
								model:EnableMatrix( "RenderMultiply", matrix )
							   
								if (v.material == "") then
										model:SetMaterial("")
								elseif (model:GetMaterial() != v.material) then
										model:SetMaterial( v.material )
								end
							   
								if (v.skin and v.skin != model:GetSkin()) then
										model:SetSkin(v.skin)
								end
							   
								if (v.bodygroup) then
										for k, v in pairs( v.bodygroup ) do
												if (model:GetBodygroup(k) != v) then
														model:SetBodygroup(k, v)
												end
										end
								end
							   
								if (v.surpresslightning) then
										render.SuppressEngineLighting(true)
								end
							   
								render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
								render.SetBlend(v.color.a/255)
								model:DrawModel()
								render.SetBlend(1)
								render.SetColorModulation(1, 1, 1)
							   
								if (v.surpresslightning) then
										render.SuppressEngineLighting(false)
								end
							   
						elseif (v.type == "Sprite" and sprite) then
							   
								local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
								render.SetMaterial(sprite)
								render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
							   
						elseif (v.type == "Quad" and v.draw_func) then
							   
								local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
								ang:RotateAroundAxis(ang:Up(), v.angle.y)
								ang:RotateAroundAxis(ang:Right(), v.angle.p)
								ang:RotateAroundAxis(ang:Forward(), v.angle.r)
							   
								cam.Start3D2D(drawpos, ang, v.size)
										v.draw_func( self )
								cam.End3D2D()
 
						end
					   
				end
			   
		end
 
		function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
			   
				local bone, pos, ang
				if (tab.rel and tab.rel != "") then
					   
						local v = basetab[tab.rel]
					   
						if (!v) then return end
					   
						-- // Technically, if there exists an element with the same name as a bone
						-- // you can get in an infinite loop. Let's just hope nobody's that stupid.
						pos, ang = self:GetBoneOrientation( basetab, v, ent )
					   
						if (!pos) then return end
					   
						pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
						ang:RotateAroundAxis(ang:Up(), v.angle.y)
						ang:RotateAroundAxis(ang:Right(), v.angle.p)
						ang:RotateAroundAxis(ang:Forward(), v.angle.r)
							   
				else
			   
						bone = ent:LookupBone(bone_override or tab.bone)
 
						if (!bone) then return end
					   
						pos, ang = Vector(0,0,0), Angle(0,0,0)
						local m = ent:GetBoneMatrix(bone)
						if (m) then
								pos, ang = m:GetTranslation(), m:GetAngles()
						end
					   
						if (IsValid(self.Owner) and self.Owner:IsPlayer() and
								ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
								ang.r = -ang.r --// Fixes mirrored models
						end
			   
				end
			   
				return pos, ang
		end
 
		function SWEP:CreateModels( tab )
 
				if (!tab) then return end
 
				-- // Create the clientside models here because Garry says we can't do it in the render hook
				for k, v in pairs( tab ) do
						if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and
										string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
							   
								v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
								if (IsValid(v.modelEnt)) then
										v.modelEnt:SetPos(self:GetPos())
										v.modelEnt:SetAngles(self:GetAngles())
										v.modelEnt:SetParent(self)
										v.modelEnt:SetNoDraw(true)
										v.createdModel = v.model
								else
										v.modelEnt = nil
								end
							   
						elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite)
								and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
							   
								local name = v.sprite.."-"
								local params = { ["$basetexture"] = v.sprite }
								-- // make sure we create a unique name based on the selected options
								local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
								for i, j in pairs( tocheck ) do
										if (v[j]) then
												params["$"..j] = 1
												name = name.."1"
										else
												name = name.."0"
										end
								end
 
								v.createdSprite = v.sprite
								v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
							   
						end
				end
			   
		end
	   
		local allbones
		local hasGarryFixedBoneScalingYet = false
 
		function SWEP:UpdateBonePositions(vm)
			   
				if self.ViewModelBoneMods then
					   
						if (!vm:GetBoneCount()) then return end
					   
						-- // !! WORKAROUND !! --//
						-- // We need to check all model names :/
						local loopthrough = self.ViewModelBoneMods
						if (!hasGarryFixedBoneScalingYet) then
								allbones = {}
								for i=0, vm:GetBoneCount() do
										local bonename = vm:GetBoneName(i)
										if (self.ViewModelBoneMods[bonename]) then
												allbones[bonename] = self.ViewModelBoneMods[bonename]
										else
												allbones[bonename] = {
														scale = Vector(1,1,1),
														pos = Vector(0,0,0),
														angle = Angle(0,0,0)
												}
										end
								end
							   
								loopthrough = allbones
						end
						//!! ----------- !! --
					   
						for k, v in pairs( loopthrough ) do
								local bone = vm:LookupBone(k)
								if (!bone) then continue end
							   
								-- // !! WORKAROUND !! --//
								local s = Vector(v.scale.x,v.scale.y,v.scale.z)
								local p = Vector(v.pos.x,v.pos.y,v.pos.z)
								local ms = Vector(1,1,1)
								if (!hasGarryFixedBoneScalingYet) then
										local cur = vm:GetBoneParent(bone)
										while(cur >= 0) do
												local pscale = loopthrough[vm:GetBoneName(cur)].scale
												ms = ms * pscale
												cur = vm:GetBoneParent(cur)
										end
								end
							   
								s = s * ms
								//!! ----------- !! --
							   
								if vm:GetManipulateBoneScale(bone) != s then
										vm:ManipulateBoneScale( bone, s )
								end
								if vm:GetManipulateBoneAngles(bone) != v.angle then
										vm:ManipulateBoneAngles( bone, v.angle )
								end
								if vm:GetManipulateBonePosition(bone) != p then
										vm:ManipulateBonePosition( bone, p )
								end
						end
				else
						self:ResetBonePositions(vm)
				end
				   
		end
		 
		function SWEP:ResetBonePositions(vm)
			   
				if (!vm:GetBoneCount()) then return end
				for i=0, vm:GetBoneCount() do
						vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
						vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
						vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
				end
			   
		end
 
		/**************************
				Global utility code
		**************************/
 
		-- // Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
		-- // Does not copy entities of course, only copies their reference.
		-- // WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
		function table.FullCopy( tab )
 
				if (!tab) then return nil end
			   
				local res = {}
				for k, v in pairs( tab ) do
						if (type(v) == "table") then
								res[k] = table.FullCopy(v) --// recursion ho!
						elseif (type(v) == "Vector") then
								res[k] = Vector(v.x, v.y, v.z)
						elseif (type(v) == "Angle") then
								res[k] = Angle(v.p, v.y, v.r)
						else
								res[k] = v
						end
				end
			   
				return res
			   
		end
	   
end


--PATH addons/__main/lua/weapons/bobs_shotty_base/cl_init.lua:
include('shared.lua')

SWEP.PrintName				= ""				// 'Nice' Weapon name (Shown on HUD)	
SWEP.Slot				= 4				// Slot in the weapon selection menu
SWEP.SlotPos				= 1				// Position in the slot
SWEP.DrawAmmo				= true				// Should draw the default HL2 ammo counter				// Should draw the default crosshair
SWEP.DrawWeaponInfoBox			= true				// Should draw the weapon info box
SWEP.BounceWeaponIcon   			= true				// Should the weapon icon bounce?
SWEP.CSMuzzleFlashes			= true
--PATH addons/__main/lua/weapons/clout_gun_base/shared.lua:
-- Variables that are used on both client and server
SWEP.Category = ""
SWEP.Gun = ""
SWEP.Author = "Generic Default, Worshipper, Clavus, and Bob"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""
SWEP.MuzzleAttachment = "1" -- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.DrawCrosshair = true -- Hell no, crosshairs r 4 nubz!
SWEP.ViewModelFOV = 65 -- How big the gun will look
SWEP.ViewModelFlip = true -- True for CSS models, False for HL2 models
SWEP.Spawnable = false
SWEP.AdminSpawnable = false
SWEP.Primary.Sound = Sound( "" ) -- Sound of the gun
SWEP.Primary.Round = "" -- What kind of bullet?
SWEP.Primary.Cone = 0.2 -- Accuracy of NPCs
SWEP.Primary.Recoil = 10
SWEP.Primary.Damage = 10
SWEP.Primary.Spread = .01 --define from-the-hip accuracy (1 is terrible, .0001 is exact)
SWEP.Primary.NumShots = 1
SWEP.Primary.RPM = 0 -- This is in Rounds Per Minute
SWEP.Primary.ClipSize = 0 -- Size of a clip
SWEP.Primary.DefaultClip = 0 -- Default number of bullets in a clip
SWEP.Primary.KickUp = 0 -- Maximum up recoil (rise)
SWEP.Primary.KickDown = 0 -- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal = 0 -- Maximum side recoil (koolaid)
SWEP.Primary.Automatic = true -- Automatic/Semi Auto
SWEP.Primary.Ammo = "none" -- What kind of ammo
SWEP.Secondary.ClipSize = 0 -- Size of a clip
SWEP.Secondary.DefaultClip = 0 -- Default number of bullets in a clip
SWEP.Secondary.Automatic = false -- Automatic/Semi Auto
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.IronFOV = 0 -- How much you 'zoom' in. Less is more! 
SWEP.Penetration = true
SWEP.Ricochet = true
SWEP.MaxRicochet = 1
SWEP.RicochetCoin = 1
SWEP.BoltAction = false
SWEP.Scoped = false
SWEP.ShellTime = .35
SWEP.Tracer = 0
SWEP.CanBeSilenced = false
SWEP.Silenced = false
SWEP.NextSilence = 0
SWEP.SelectiveFire = false
SWEP.NextFireSelect = 0
SWEP.OrigCrossHair = true
local PainMulti = 1
if GetConVar( "M9KDamageMultiplier" ) == nil then
	PainMulti = 1
else
	PainMulti = GetConVar( "M9KDamageMultiplier" ):GetFloat()
	if PainMulti < 0 then
		PainMulti = PainMulti * -1
	end
end

function NewM9KDamageMultiplier()
	if GetConVar( "M9KDamageMultiplier" ) == nil then
		PainMulti = 1
	else
		PainMulti = GetConVar( "M9KDamageMultiplier" ):GetFloat()
		if PainMulti < 0 then
			PainMulti = PainMulti * -1
		end
	end
end

cvars.AddChangeCallback( "M9KDamageMultiplier", NewM9KDamageMultiplier )

SWEP.IronSightsPos = Vector( 2.4537, 1.0923, 0.2696 )
SWEP.IronSightsAng = Vector( 0.0186, -0.0547, 0 )
SWEP.VElements = {}
SWEP.WElements = {}
function SWEP:Initialize()
	self.Reloadaftershoot = 0 -- Can't reload when firing
	self:SetHoldType( self.HoldType )
	self.OrigCrossHair = self.DrawCrosshair
	local owner = self:GetOwner()
	if SERVER and owner:IsNPC() then
		self:SetNPCMinBurst( 3 )
		self:SetNPCMaxBurst( 10 ) -- None of this really matters but you need it here anyway
		self:SetNPCFireRate( 1 / ( self.Primary.RPM / 60 ) )
		self:SetCurrentWeaponProficiency( WEAPON_PROFICIENCY_VERY_GOOD )
	end

	if CLIENT then
		-- // Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:CreateModels( self.VElements ) -- create viewmodels
		self:CreateModels( self.WElements ) -- create worldmodels
		-- // init view model bone build function
		if IsValid( owner ) and owner:IsPlayer() and owner:Alive() then
			local vm = owner:GetViewModel()
			if IsValid( vm ) then
				self:ResetBonePositions( vm )
				-- // Init viewmodel visibility
				if self.ShowViewModel == nil or self.ShowViewModel then
					vm:SetColor( Color( 255, 255, 255, 255 ) )
				else
					-- // however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial( "Debug/hsv" )
				end
			end
		end
	end
end

function SWEP:Deploy()
	local owner = self:GetOwner()
	self:SetIronsights( false, owner ) -- Set the ironsight false
	self:SetHoldType( self.HoldType )
	if self.Silenced then
		self:SendWeaponAnim( ACT_VM_DRAW_SILENCED )
	else
		self:SendWeaponAnim( ACT_VM_DRAW )
	end

	self:SetNWBool( "Reloading", false )
	if owner ~= nil and not owner:IsNPC() and self.ResetSights and owner:GetViewModel() ~= nil then self.ResetSights = CurTime() + owner:GetViewModel():SequenceDuration() end
	return true
end

function SWEP:Holster()
	local owner = self:GetOwner()
	if CLIENT and IsValid( owner ) and not owner:IsNPC() then
		local vm = owner:GetViewModel()
		if IsValid( vm ) then self:ResetBonePositions( vm ) end
	end
	return true
end

function SWEP:OnRemove()
	local owner = self:GetOwner()
	if CLIENT and IsValid( owner ) and not owner:IsNPC() then
		local vm = owner:GetViewModel()
		if IsValid( vm ) then self:ResetBonePositions( vm ) end
	end
end

function SWEP:GetCapabilities()
	return CAP_WEAPON_RANGE_ATTACK1, CAP_INNATE_RANGE_ATTACK1
end

function SWEP:Precache()
	util.PrecacheSound( self.Primary.Sound )
	util.PrecacheModel( self.ViewModel )
	util.PrecacheModel( self.WorldModel )
end

function SWEP:PrimaryAttack()
	local owner = self:GetOwner()
	if self:CanPrimaryAttack() and owner:IsPlayer() then
		if not owner:KeyDown( IN_SPEED ) and not owner:KeyDown( IN_RELOAD ) then
			self:ShootBulletInformation()
			self:TakePrimaryAmmo( 1 )
			if self.Silenced then
				self:SendWeaponAnim( ACT_VM_PRIMARYATTACK_SILENCED )
				self:EmitSound( self.Primary.SilencedSound )
			else
				self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
				self:EmitSound( self.Primary.Sound )
			end

			local fx = EffectData()
			fx:SetEntity( self )
			fx:SetOrigin( owner:GetShootPos() )
			fx:SetNormal( owner:GetAimVector() )
			fx:SetAttachment( self.MuzzleAttachment )
			if GetConVar( "M9KGasEffect" ) ~= nil and GetConVar( "M9KGasEffect" ):GetBool() then util.Effect( "m9k_rg_muzzle_rifle", fx ) end
			owner:SetAnimation( PLAYER_ATTACK1 )
			owner:MuzzleFlash()
			self:SetNextPrimaryFire( CurTime() + 1 / ( self.Primary.RPM / 60 ) )
			self:CheckWeaponsAndAmmo()
			self.RicochetCoin = math.random( 1, 4 )
			if self.BoltAction then self:BoltBack() end
		end
	elseif self:CanPrimaryAttack() and owner:IsNPC() then
		self:ShootBulletInformation()
		self:TakePrimaryAmmo( 1 )
		self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
		self:EmitSound( self.Primary.Sound )
		owner:SetAnimation( PLAYER_ATTACK1 )
		owner:MuzzleFlash()
		self:SetNextPrimaryFire( CurTime() + 1 / ( self.Primary.RPM / 60 ) )
		self.RicochetCoin = math.random( 1, 4 )
	end
end

function SWEP:CheckWeaponsAndAmmo()
	local owner = self:GetOwner()
	if SERVER and GetConVar( "M9KWeaponStrip" ):GetBool() and self:Clip1() == 0 and owner:GetAmmoCount( self:GetPrimaryAmmoType() ) == 0 then
		timer.Simple( .1, function()
			if SERVER then
				if not IsValid( self ) then return end
				if owner == nil then return end
				owner:StripWeapon( self.Gun )
			end
		end )
	end
end

--[[---------------------------------------------------------
   Name: SWEP:ShootBulletInformation()
   Desc: This func add the damage, the recoil, the number of shots and the cone on the bullet.
---------------------------------------------------------]]
function SWEP:ShootBulletInformation()
	local owner = self:GetOwner()
	local CurrentDamage
	local CurrentRecoil
	local CurrentCone
	local basedamage
	if self:GetIronsights() == true and owner:KeyDown( IN_ATTACK2 ) then
		CurrentCone = self.Primary.IronAccuracy
	else
		CurrentCone = self.Primary.Spread
	end

	local damagedice = math.Rand( .85, 1.3 )
	basedamage = PainMulti * self.Primary.Damage
	CurrentDamage = basedamage * damagedice
	CurrentRecoil = self.Primary.Recoil
	-- Player is aiming
	if self:GetIronsights() == true and owner:KeyDown( IN_ATTACK2 ) then
		self:ShootBullet( CurrentDamage, CurrentRecoil / 6, self.Primary.NumShots, CurrentCone )
		-- Player is not aiming
	else
		self:ShootBullet( CurrentDamage, CurrentRecoil, self.Primary.NumShots, CurrentCone )
	end
end

--[[---------------------------------------------------------
   Name: SWEP:ShootBullet()
   Desc: A convenience func to shoot bullets.
---------------------------------------------------------]]
local TracerName = "Tracer"
function SWEP:ShootBullet( damage, _, num_bullets, aimcone )
	num_bullets = num_bullets or 1
	aimcone = aimcone or 0
	self:ShootEffects()
	if self.Tracer == 1 then
		TracerName = "Ar2Tracer"
	elseif self.Tracer == 2 then
		TracerName = "AirboatGunHeavyTracer"
	else
		TracerName = "Tracer"
	end

	local owner = self:GetOwner()
	local bullet = {}
	bullet.Num = num_bullets
	bullet.Src = owner:GetShootPos() -- Source
	bullet.Dir = owner:GetAimVector() -- Dir of bullet
	bullet.Spread = Vector( aimcone, aimcone, 0 ) -- Aim Cone
	bullet.Tracer = 3 -- Show a tracer on every x bullets
	bullet.TracerName = TracerName
	bullet.Force = damage * 0.25 -- Amount of force to give to phys objects
	bullet.Damage = damage
	bullet.Callback = function( attacker, tracedata, dmginfo ) return self:RicochetCallback( 0, attacker, tracedata, dmginfo ) end
	owner:FireBullets( bullet )
	local anglo1 = Angle( math.Rand( -self.Primary.KickDown, -self.Primary.KickUp ), math.Rand( -self.Primary.KickHorizontal, self.Primary.KickHorizontal ), 0 )
	owner:ViewPunch( anglo1 )
	if SERVER and game.SinglePlayer() and not owner:IsNPC() then
		local offlineeyes = owner:EyeAngles()
		offlineeyes.pitch = offlineeyes.pitch + anglo1.pitch
		offlineeyes.yaw = offlineeyes.yaw + anglo1.yaw
		if GetConVar( "M9KDynamicRecoil" ):GetBool() then owner:SetEyeAngles( offlineeyes ) end
	end

	if CLIENT and not game.SinglePlayer() and not owner:IsNPC() then
		local anglo = Angle( math.Rand( -self.Primary.KickDown, -self.Primary.KickUp ), math.Rand( -self.Primary.KickHorizontal, self.Primary.KickHorizontal ), 0 )
		local eyes = owner:EyeAngles()
		eyes.pitch = eyes.pitch + anglo.pitch / 3
		eyes.yaw = eyes.yaw + anglo.yaw / 3
		if GetConVar( "M9KDynamicRecoil" ):GetBool() then owner:SetEyeAngles( eyes ) end
	end
end

--[[---------------------------------------------------------
   Name: SWEP:RicochetCallback()
---------------------------------------------------------]]
function SWEP:RicochetCallback( bouncenum, attacker, tr, dmginfo )
	if not IsFirstTimePredicted() then
		return {
			damage = false,
			effects = false
		}
	end

	local PenetrationChecker = false
	if GetConVar( "M9KDisablePenetration" ) == nil then
		PenetrationChecker = false
	else
		PenetrationChecker = GetConVar( "M9KDisablePenetration" ):GetBool()
	end

	if PenetrationChecker then
		return {
			damage = true,
			effects = DoDefaultEffect
		}
	end

	bulletmiss = {}
	bulletmiss[1] = Sound( "weapons/fx/nearmiss/bulletLtoR03.wav" )
	bulletmiss[2] = Sound( "weapons/fx/nearmiss/bulletLtoR04.wav" )
	bulletmiss[3] = Sound( "weapons/fx/nearmiss/bulletLtoR06.wav" )
	bulletmiss[4] = Sound( "weapons/fx/nearmiss/bulletLtoR07.wav" )
	bulletmiss[5] = Sound( "weapons/fx/nearmiss/bulletLtoR09.wav" )
	bulletmiss[6] = Sound( "weapons/fx/nearmiss/bulletLtoR10.wav" )
	bulletmiss[7] = Sound( "weapons/fx/nearmiss/bulletLtoR13.wav" )
	bulletmiss[8] = Sound( "weapons/fx/nearmiss/bulletLtoR14.wav" )
	DoDefaultEffect = true
	if tr.HitSky then return end
	-- -- Can we go through whatever we hit?
	if self.Penetration and self:BulletPenetrate( bouncenum, attacker, tr, dmginfo ) then
		return {
			damage = true,
			effects = DoDefaultEffect
		}
	end

	-- -- Your screen will shake and you'll hear the savage hiss of an approaching bullet which passing if someone is shooting at you.
	if tr.MatType ~= MAT_METAL then
		if SERVER then
			util.ScreenShake( tr.HitPos, 5, 0.1, 0.5, 64 )
			sound.Play( table.Random( bulletmiss ), tr.HitPos, 75, math.random( 75, 150 ), 1 )
		end

		if self.Tracer == 0 or self.Tracer == 1 or self.Tracer == 2 then
			local effectdata = EffectData()
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
			effectdata:SetScale( 20 )
			util.Effect( "AR2Impact", effectdata )
		elseif self.Tracer == 3 then
			local effectdata = EffectData()
			effectdata:SetOrigin( tr.HitPos )
			effectdata:SetNormal( tr.HitNormal )
			effectdata:SetScale( 20 )
			util.Effect( "StunstickImpact", effectdata )
		end
		return
	end

	if self.Ricochet == false then
		return {
			damage = true,
			effects = DoDefaultEffect
		}
	end

	if self.Primary.Ammo == "SniperPenetratedRound" then -- .50 Ammo 
		self.MaxRicochet = 12
	elseif self.Primary.Ammo == "pistol" then
		-- pistols
		self.MaxRicochet = 2
	elseif self.Primary.Ammo == "357" then
		-- revolvers with big ass bullets
		self.MaxRicochet = 4
	elseif self.Primary.Ammo == "smg1" then
		-- smgs
		self.MaxRicochet = 5
	elseif self.Primary.Ammo == "ar2" then
		-- assault rifles
		self.MaxRicochet = 8
	elseif self.Primary.Ammo == "buckshot" then
		-- shotguns
		self.MaxRicochet = 1
	elseif self.Primary.Ammo == "slam" then
		-- secondary shotguns
		self.MaxRicochet = 1
	elseif self.Primary.Ammo == "AirboatGun" then
		-- metal piercing shotgun pellet
		self.MaxRicochet = 8
	end

	if bouncenum > self.MaxRicochet then return end
	-- -- Bounce vector
	local trace = {}
	trace.start = tr.HitPos
	trace.endpos = trace.start + tr.HitNormal * 16384
	trace = util.TraceLine( trace )
	local DotProduct = tr.HitNormal:Dot( tr.Normal * -1 )
	local ricochetbullet = {}
	ricochetbullet.Num = 1
	ricochetbullet.Src = tr.HitPos + tr.HitNormal * 5
	ricochetbullet.Dir = 2 * tr.HitNormal * DotProduct + tr.Normal + VectorRand() * 0.05
	ricochetbullet.Spread = Vector( 0, 0, 0 )
	ricochetbullet.Tracer = 1
	ricochetbullet.TracerName = "m9k_effect_mad_ricochet_trace"
	ricochetbullet.Force = dmginfo:GetDamage() * 0.15
	ricochetbullet.Damage = dmginfo:GetDamage() * 0.5
	ricochetbullet.Callback = function( a, b, c )
		if self.Ricochet then
			local impactnum
			if tr.MatType == MAT_GLASS then
				impactnum = 0
			else
				impactnum = 1
			end
			return self:RicochetCallback( bouncenum + impactnum, a, b, c )
		end
	end

	timer.Simple( 0, function() attacker:FireBullets( ricochetbullet ) end )
	return {
		damage = true,
		effects = DoDefaultEffect
	}
end

--[[---------------------------------------------------------
   Name: SWEP:BulletPenetrate()
---------------------------------------------------------]]
function SWEP:BulletPenetrate( bouncenum, attacker, tr, paininfo )
	local owner = self:GetOwner()
	local MaxPenetration
	if self.Primary.Ammo == "SniperPenetratedRound" then -- .50 Ammo 
		MaxPenetration = 20
	elseif self.Primary.Ammo == "pistol" then
		-- pistols
		MaxPenetration = 9
	elseif self.Primary.Ammo == "357" then
		-- revolvers with big ass bullets
		MaxPenetration = 12
	elseif self.Primary.Ammo == "smg1" then
		-- smgs
		MaxPenetration = 14
	elseif self.Primary.Ammo == "ar2" then
		-- assault rifles
		MaxPenetration = 16
	elseif self.Primary.Ammo == "buckshot" then
		-- shotguns
		MaxPenetration = 5
	elseif self.Primary.Ammo == "slam" then
		-- secondary shotguns
		MaxPenetration = 5
	elseif self.Primary.Ammo == "AirboatGun" then
		-- metal piercing shotgun pellet
		MaxPenetration = 17
	else
		MaxPenetration = 14
	end

	-- -- Don't go through metal, sand or player
	if self.Primary.Ammo == "pistol" or self.Primary.Ammo == "buckshot" or self.Primary.Ammo == "slam" then
		self.Ricochet = true
	else
		if self.RicochetCoin == 1 then
			self.Ricochet = true
		elseif self.RicochetCoin >= 2 then
			self.Ricochet = false
		end
	end

	if self.Primary.Ammo == "SniperPenetratedRound" then self.Ricochet = true end
	if self.Primary.Ammo == "SniperPenetratedRound" then -- .50 Ammo 
		self.MaxRicochet = 10
	elseif self.Primary.Ammo == "pistol" then
		-- pistols
		self.MaxRicochet = 2
	elseif self.Primary.Ammo == "357" then
		-- revolvers with big ass bullets
		self.MaxRicochet = 5
	elseif self.Primary.Ammo == "smg1" then
		-- smgs
		self.MaxRicochet = 4
	elseif self.Primary.Ammo == "ar2" then
		-- assault rifles
		self.MaxRicochet = 5
	elseif self.Primary.Ammo == "buckshot" then
		-- shotguns
		self.MaxRicochet = 0
	elseif self.Primary.Ammo == "slam" then
		-- secondary shotguns
		self.MaxRicochet = 0
	elseif self.Primary.Ammo == "AirboatGun" then
		-- metal piercing shotgun pellet
		self.MaxRicochet = 8
	end

	if tr.MatType == MAT_METAL and self.Ricochet == true and self.Primary.Ammo ~= "SniperPenetratedRound" then return false end
	-- -- Don't go through more than 3 times
	if bouncenum > self.MaxRicochet then return false end
	-- -- Direction (and length) that we are going to penetrate
	local PenetrationDirection = tr.Normal * MaxPenetration
	if tr.MatType == MAT_GLASS or tr.MatType == MAT_PLASTIC or tr.MatType == MAT_WOOD or tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH then PenetrationDirection = tr.Normal * MaxPenetration * 2 end
	local trace = {}
	trace.endpos = tr.HitPos
	trace.start = tr.HitPos + PenetrationDirection
	trace.mask = MASK_SHOT
	trace.filter = { owner }
	trace = util.TraceLine( trace )
	-- -- Bullet didn't penetrate.
	if trace.StartSolid or trace.Fraction >= 1.0 or tr.Fraction <= 0.0 then return false end
	-- -- Damage multiplier depending on surface
	local fDamageMulti = 0.5
	if self.Primary.Ammo == "SniperPenetratedRound" then
		fDamageMulti = 1
	elseif tr.MatType == MAT_CONCRETE or tr.MatType == MAT_METAL then
		fDamageMulti = 0.3
	elseif tr.MatType == MAT_WOOD or tr.MatType == MAT_PLASTIC or tr.MatType == MAT_GLASS then
		fDamageMulti = 0.8
	elseif tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH then
		fDamageMulti = 0.9
	end

	-- -- Fire bullet from the exit point using the original trajectory
	local penetratedbullet = {}
	penetratedbullet.Num = 1
	penetratedbullet.Src = trace.HitPos
	penetratedbullet.Dir = tr.Normal
	penetratedbullet.Spread = Vector( 0, 0, 0 )
	penetratedbullet.Tracer = 2
	penetratedbullet.TracerName = "m9k_effect_mad_penetration_trace"
	penetratedbullet.Force = 5
	penetratedbullet.Damage = paininfo:GetDamage() * fDamageMulti
	penetratedbullet.Callback = function( a, b, c )
		if self.Ricochet then
			local impactnum
			if tr.MatType == MAT_GLASS then
				impactnum = 0
			else
				impactnum = 1
			end
			return self:RicochetCallback( bouncenum + impactnum, a, b, c )
		end
	end

	timer.Simple( 0, function() if attacker ~= nil then attacker:FireBullets( penetratedbullet ) end end )
	return true
end

function SWEP:SecondaryAttack()
	return false
end

function SWEP:Reload()
	local owner = self:GetOwner()
	if not IsValid( owner ) then return end
	if owner:IsNPC() then
		self:DefaultReload( ACT_VM_RELOAD )
		return
	end

	if owner:KeyDown( IN_USE ) then return end
	if self.Silenced then
		self:DefaultReload( ACT_VM_RELOAD_SILENCED )
	else
		self:DefaultReload( ACT_VM_RELOAD )
	end

	if not owner:IsNPC() then
		if owner:GetViewModel() == nil then
			self.ResetSights = CurTime() + 3
		else
			self.ResetSights = CurTime() + owner:GetViewModel():SequenceDuration()
		end
	end

	if SERVER then
		if self:Clip1() < self.Primary.ClipSize and not owner:IsNPC() then
			-- When the current clip < full clip and the rest of your ammo > 0, then
			owner:SetFOV( 0, 0.3 )
			-- Zoom = 0
			self:SetIronsights( false )
			-- Set the ironsight to false
			self:SetNWBool( "Reloading", true )
		end

		local waitdammit = owner:GetViewModel():SequenceDuration()
		timer.Simple( waitdammit + .1, function()
			if not IsValid( self ) then return end
			self:SetNWBool( "Reloading", false )
			if owner:KeyDown( IN_ATTACK2 ) and self:GetClass() == self.Gun then
				if CLIENT then return end
				if self.Scoped == false then
					owner:SetFOV( self.Secondary.IronFOV, 0.3 )
					self.IronSightsPos = self.SightsPos -- Bring it up
					self.IronSightsAng = self.SightsAng -- Bring it up
					self:SetIronsights( true, owner )
					self.DrawCrosshair = false
				else
					return
				end
			elseif owner:KeyDown( IN_SPEED ) and self:GetClass() == self.Gun then
				if self:GetNextPrimaryFire() <= CurTime() + .03 then
					self:SetNextPrimaryFire( CurTime() + 0.3 ) -- Make it so you can't shoot for another quarter second
				end

				self.IronSightsPos = self.RunSightsPos -- Hold it down
				self.IronSightsAng = self.RunSightsAng -- Hold it down
				self:SetIronsights( true, owner ) -- Set the ironsight true
				owner:SetFOV( 0, 0.3 )
			else
				return
			end
		end )
	end
end

function SWEP:PostReloadScopeCheck()
	local owner = self:GetOwner()
	self:SetNWBool( "Reloading", false )
	if owner:KeyDown( IN_ATTACK2 ) and self:GetClass() == self.Gun then
		if CLIENT then return end
		if self.Scoped == false then
			owner:SetFOV( self.Secondary.IronFOV, 0.3 )
			self.IronSightsPos = self.SightsPos -- Bring it up
			self.IronSightsAng = self.SightsAng -- Bring it up
			self:SetIronsights( true, owner )
			self.DrawCrosshair = false
		else
			return
		end
	elseif owner:KeyDown( IN_SPEED ) and self:GetClass() == self.Gun then
		if self:GetNextPrimaryFire() <= CurTime() + .03 then
			self:SetNextPrimaryFire( CurTime() + 0.3 ) -- Make it so you can't shoot for another quarter second
		end

		self.IronSightsPos = self.RunSightsPos -- Hold it down
		self.IronSightsAng = self.RunSightsAng -- Hold it down
		self:SetIronsights( true, owner ) -- Set the ironsight true
		owner:SetFOV( 0, 0.3 )
	else
		return
	end
end

function SWEP:Silencer()
	local owner = self:GetOwner()
	if self.NextSilence > CurTime() then return end
	owner:SetFOV( 0, 0.3 )
	self:SetIronsights( false )
	self:SetNWBool( "Reloading", true ) -- i know we're not reloading but it works
	if self.Silenced then
		self:SendWeaponAnim( ACT_VM_DETACH_SILENCER )
		self.Silenced = false
	elseif not self.Silenced then
		self:SendWeaponAnim( ACT_VM_ATTACH_SILENCER )
		self.Silenced = true
	end

	siltimer = CurTime() + owner:GetViewModel():SequenceDuration() + 0.1
	if self:GetNextPrimaryFire() <= siltimer then self:SetNextPrimaryFire( siltimer ) end
	self.NextSilence = siltimer
	timer.Simple( owner:GetViewModel():SequenceDuration() + 0.1, function()
		if IsValid( self ) then
			self:SetNWBool( "Reloading", false )
			if owner:KeyDown( IN_ATTACK2 ) and self:GetClass() == self.Gun then
				if CLIENT then return end
				if self.Scoped == false then
					owner:SetFOV( self.Secondary.IronFOV, 0.3 )
					self.IronSightsPos = self.SightsPos -- Bring it up
					self.IronSightsAng = self.SightsAng -- Bring it up
					self:SetIronsights( true, owner )
					self.DrawCrosshair = false
				else
					return
				end
			elseif owner:KeyDown( IN_SPEED ) and self:GetClass() == self.Gun then
				if self:GetNextPrimaryFire() <= CurTime() + 0.3 then
					self:SetNextPrimaryFire( CurTime() + 0.3 ) -- Make it so you can't shoot for another quarter second
				end

				self.IronSightsPos = self.RunSightsPos -- Hold it down
				self.IronSightsAng = self.RunSightsAng -- Hold it down
				self:SetIronsights( true, owner ) -- Set the ironsight true
				owner:SetFOV( 0, 0.3 )
			else
				return
			end
		end
	end )
end

function SWEP:SelectFireMode()
	local owner = self:GetOwner()
	if self.Primary.Automatic then
		self.Primary.Automatic = false
		self.NextFireSelect = CurTime() + .5
		if CLIENT then owner:PrintMessage( HUD_PRINTTALK, "Semi-automatic selected." ) end
		self:EmitSound( "Weapon_AR2.Empty" )
	else
		self.Primary.Automatic = true
		self.NextFireSelect = CurTime() + .5
		if CLIENT then owner:PrintMessage( HUD_PRINTTALK, "Automatic selected." ) end
		self:EmitSound( "Weapon_AR2.Empty" )
	end
end

--[[---------------------------------------------------------
IronSight
---------------------------------------------------------]]
function SWEP:IronSight()
	local owner = self:GetOwner()
	if not IsValid( owner ) then return end
	if not owner:IsNPC() and self.ResetSights and CurTime() >= self.ResetSights then
		self.ResetSights = nil
		if self.Silenced then
			self:SendWeaponAnim( ACT_VM_IDLE_SILENCED )
		else
			self:SendWeaponAnim( ACT_VM_IDLE )
		end
	end

	if self.CanBeSilenced and self.NextSilence < CurTime() and owner:KeyDown( IN_USE ) and owner:KeyPressed( IN_ATTACK2 ) then self:Silencer() end
	if self.SelectiveFire and self.NextFireSelect < CurTime() and not self:GetNWBool( "Reloading" ) and owner:KeyDown( IN_USE ) and owner:KeyPressed( IN_RELOAD ) then self:SelectFireMode() end
	--copy this...
	if owner:KeyPressed( IN_SPEED ) and not self:GetNWBool( "Reloading" ) then -- If you are running
		if self:GetNextPrimaryFire() <= CurTime() + 0.3 then
			self:SetNextPrimaryFire( CurTime() + 0.3 ) -- Make it so you can't shoot for another quarter second
		end

		self.IronSightsPos = self.RunSightsPos -- Hold it down
		self.IronSightsAng = self.RunSightsAng -- Hold it down
		self:SetIronsights( true, owner ) -- Set the ironsight true
		owner:SetFOV( 0, 0.3 )
		self.DrawCrosshair = false
	end

	if owner:KeyReleased( IN_SPEED ) then -- If you release run then
		self:SetIronsights( false, owner ) -- Set the ironsight true
		owner:SetFOV( 0, 0.3 )
		self.DrawCrosshair = self.OrigCrossHair
	end

	-- Shoulder the gun
	--down to this
	if not owner:KeyDown( IN_USE ) and not owner:KeyDown( IN_SPEED ) and owner:KeyPressed( IN_ATTACK2 ) and not self:GetNWBool( "Reloading" ) then
		owner:SetFOV( self.Secondary.IronFOV, 0.3 )
		self.IronSightsPos = self.SightsPos -- Bring it up
		self.IronSightsAng = self.SightsAng -- Bring it up
		self:SetIronsights( true, owner )
		self.DrawCrosshair = false
		-- Set the ironsight true
		if CLIENT then return end
	end

	if owner:KeyReleased( IN_ATTACK2 ) and not owner:KeyDown( IN_USE ) and not owner:KeyDown( IN_SPEED ) then
		-- If the right click is released, then
		owner:SetFOV( 0, 0.3 )
		self.DrawCrosshair = self.OrigCrossHair
		self:SetIronsights( false, owner )
		-- Set the ironsight false
		if CLIENT then return end
	end

	if owner:KeyDown( IN_ATTACK2 ) and not owner:KeyDown( IN_USE ) and not owner:KeyDown( IN_SPEED ) then
		self.SwayScale = 0.05
		self.BobScale = 0.05
	else
		self.SwayScale = 1.0
		self.BobScale = 1.0
	end
end

--[[---------------------------------------------------------
Think
---------------------------------------------------------]]
function SWEP:Think()
	self:IronSight()
end

--[[---------------------------------------------------------
GetViewModelPosition
---------------------------------------------------------]]
local IRONSIGHT_TIME = 0.3
-- Time to enter in the ironsight mod
function SWEP:GetViewModelPosition( pos, ang )
	if not self.IronSightsPos then return pos, ang end
	local bIron = self:GetNWBool( "Ironsights" )
	if bIron ~= self.bLastIron then
		self.bLastIron = bIron
		self.fIronTime = CurTime()
	end

	local fIronTime = self.fIronTime or 0
	if not bIron and fIronTime < CurTime() - IRONSIGHT_TIME then return pos, ang end
	local Mul = 1.0
	if fIronTime > CurTime() - IRONSIGHT_TIME then
		Mul = math.Clamp( ( CurTime() - fIronTime ) / IRONSIGHT_TIME, 0, 1 )
		if not bIron then Mul = 1 - Mul end
	end

	local Offset = self.IronSightsPos
	if self.IronSightsAng then
		ang = ang * 1
		ang:RotateAroundAxis( ang:Right(), self.IronSightsAng.x * Mul )
		ang:RotateAroundAxis( ang:Up(), self.IronSightsAng.y * Mul )
		ang:RotateAroundAxis( ang:Forward(), self.IronSightsAng.z * Mul )
	end

	local Right = ang:Right()
	local Up = ang:Up()
	local Forward = ang:Forward()
	pos = pos + Offset.x * Right * Mul
	pos = pos + Offset.y * Forward * Mul
	pos = pos + Offset.z * Up * Mul
	return pos, ang
end

--[[---------------------------------------------------------
SetIronsights
---------------------------------------------------------]]
function SWEP:SetIronsights( b )
	self:SetNWBool( "Ironsights", b )
end

function SWEP:GetIronsights()
	return self:GetNWBool( "Ironsights" )
end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		local owner = self:GetOwner()
		local vm = owner:GetViewModel()
		if not IsValid( vm ) then return end
		if not self.VElements then return end
		self:UpdateBonePositions( vm )
		if not self.vRenderOrder then
			-- // we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k, v in pairs( self.VElements ) do
				if v.type == "Model" then
					table.insert( self.vRenderOrder, 1, k )
				elseif v.type == "Sprite" or v.type == "Quad" then
					table.insert( self.vRenderOrder, k )
				end
			end
		end

		for _, name in ipairs( self.vRenderOrder ) do
			local v = self.VElements[name]
			if not v then
				self.vRenderOrder = nil
				break
			end

			if v.hide then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if not v.bone then continue end
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			if not pos then continue end
			if v.type == "Model" and IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				-- //model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				if v.material == "" then
					model:SetMaterial( "" )
				elseif model:GetMaterial() ~= v.material then
					model:SetMaterial( v.material )
				end

				if v.skin and v.skin ~= model:GetSkin() then model:SetSkin( v.skin ) end
				if v.bodygroup then
					for k, id in ipairs( v.bodygroup ) do
						if model:GetBodygroup( k ) ~= id then model:SetBodygroup( k, id ) end
					end
				end

				if v.surpresslightning then render.SuppressEngineLighting( true ) end
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
				if v.surpresslightning then render.SuppressEngineLighting( false ) end
			elseif v.type == "Sprite" and sprite then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial( sprite )
				render.DrawSprite( drawpos, v.size.x, v.size.y, v.color )
			elseif v.type == "Quad" and v.draw_func then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				cam.Start3D2D( drawpos, ang, v.size )
				v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		local owner = self:GetOwner()
		if self.ShowWorldModel == nil or self.ShowWorldModel then self:DrawModel() end
		if not self.WElements then return end
		if not self.wRenderOrder then
			self.wRenderOrder = {}
			for k, v in pairs( self.WElements ) do
				if v.type == "Model" then
					table.insert( self.wRenderOrder, 1, k )
				elseif v.type == "Sprite" or v.type == "Quad" then
					table.insert( self.wRenderOrder, k )
				end
			end
		end

		if IsValid( owner ) then
			bone_ent = owner
		else
			-- // when the weapon is dropped
			bone_ent = self
		end

		for _, name in ipairs( self.wRenderOrder ) do
			local v = self.WElements[name]
			if not v then
				self.wRenderOrder = nil
				break
			end

			if v.hide then continue end
			local pos, ang
			if v.bone then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end

			if not pos then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if v.type == "Model" and IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				-- //model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				if v.material == "" then
					model:SetMaterial( "" )
				elseif model:GetMaterial() ~= v.material then
					model:SetMaterial( v.material )
				end

				if v.skin and v.skin ~= model:GetSkin() then model:SetSkin( v.skin ) end
				if v.bodygroup then
					for k, id in ipairs( v.bodygroup ) do
						if model:GetBodygroup( k ) ~= id then model:SetBodygroup( k, id ) end
					end
				end

				if v.surpresslightning then render.SuppressEngineLighting( true ) end
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
				if v.surpresslightning then render.SuppressEngineLighting( false ) end
			elseif v.type == "Sprite" and sprite then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial( sprite )
				render.DrawSprite( drawpos, v.size.x, v.size.y, v.color )
			elseif v.type == "Quad" and v.draw_func then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				cam.Start3D2D( drawpos, ang, v.size )
				v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		local bone, pos, ang
		if tab.rel and tab.rel ~= "" then
			local v = basetab[tab.rel]
			if not v then return end
			-- // Technically, if there exists an element with the same name as a bone
			-- // you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			if not pos then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis( ang:Up(), v.angle.y )
			ang:RotateAroundAxis( ang:Right(), v.angle.p )
			ang:RotateAroundAxis( ang:Forward(), v.angle.r )
		else
			bone = ent:LookupBone( bone_override or tab.bone )
			if not bone then return end
			pos, ang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
			local m = ent:GetBoneMatrix( bone )
			if m then pos, ang = m:GetTranslation(), m:GetAngles() end
			if IsValid( owner ) and owner:IsPlayer() and ent == owner:GetViewModel() and self.ViewModelFlip then
				ang.r = -ang.r --// Fixes mirrored models
			end
		end
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if not tab then return end
		-- // Create the clientside models here because Garry says we can't do it in the render hook
		for _, v in pairs( tab ) do
			if v.type == "Model" and v.model and v.model ~= "" and ( not IsValid( v.modelEnt ) or v.createdModel ~= v.model ) and string.find( v.model, ".mdl" ) and file.Exists( v.model, "GAME" ) then
				v.modelEnt = ClientsideModel( v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE )
				if IsValid( v.modelEnt ) then
					v.modelEnt:SetPos( self:GetPos() )
					v.modelEnt:SetAngles( self:GetAngles() )
					v.modelEnt:SetParent( self )
					v.modelEnt:SetNoDraw( true )
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif v.type == "Sprite" and v.sprite and v.sprite ~= "" and ( not v.spriteMaterial or v.createdSprite ~= v.sprite ) and file.Exists( "materials/" .. v.sprite .. ".vmt", "GAME" ) then
				local name = v.sprite .. "-"
				local params = {
					["$basetexture"] = v.sprite
				}

				-- // make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for _, j in ipairs( tocheck ) do
					if v[j] then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial( name, "UnlitGeneric", params )
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false
	function SWEP:UpdateBonePositions( vm )
		if self.ViewModelBoneMods then
			if not vm:GetBoneCount() then return end
			-- // !! WORKAROUND !! --//
			-- // We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if not hasGarryFixedBoneScalingYet then
				allbones = {}
				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName( i )
					if self.ViewModelBoneMods[bonename] then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector( 1, 1, 1 ),
							pos = Vector( 0, 0, 0 ),
							angle = Angle( 0, 0, 0 )
						}
					end
				end

				loopthrough = allbones
			end

			--!! ----------- !! --
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone( k )
				if not bone then continue end
				-- // !! WORKAROUND !! --//
				local s = Vector( v.scale.x, v.scale.y, v.scale.z )
				local p = Vector( v.pos.x, v.pos.y, v.pos.z )
				local ms = Vector( 1, 1, 1 )
				if not hasGarryFixedBoneScalingYet then
					local cur = vm:GetBoneParent( bone )
					while cur >= 0 do
						local pscale = loopthrough[vm:GetBoneName( cur )].scale
						ms = ms * pscale
						cur = vm:GetBoneParent( cur )
					end
				end

				s = s * ms
				--!! ----------- !! --
				if vm:GetManipulateBoneScale( bone ) ~= s then vm:ManipulateBoneScale( bone, s ) end
				if vm:GetManipulateBoneAngles( bone ) ~= v.angle then vm:ManipulateBoneAngles( bone, v.angle ) end
				if vm:GetManipulateBonePosition( bone ) ~= p then vm:ManipulateBonePosition( bone, p ) end
			end
		else
			self:ResetBonePositions( vm )
		end
	end

	function SWEP:ResetBonePositions( vm )
		if not vm:GetBoneCount() then return end
		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector( 1, 1, 1 ) )
			vm:ManipulateBoneAngles( i, Angle( 0, 0, 0 ) )
			vm:ManipulateBonePosition( i, Vector( 0, 0, 0 ) )
		end
	end

	--[[*************************
		Global utility code
	*************************]]
	-- // Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	-- // Does not copy entities of course, only copies their reference.
	-- // WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )
		if not tab then return nil end
		local res = {}
		for k, v in pairs( tab ) do
			if type( v ) == "table" then
				res[k] = table.FullCopy( v ) --// recursion ho!
			elseif type( v ) == "Vector" then
				res[k] = Vector( v.x, v.y, v.z )
			elseif type( v ) == "Angle" then
				res[k] = Angle( v.p, v.y, v.r )
			else
				res[k] = v
			end
		end
		return res
	end
end

if not GetConVar( "M9KUniqueSlots" ):GetBool() then SWEP.SlotPos = 2 end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stool.lua:

ToolObj = {}

include('ghostentity.lua')
include('object.lua')

if (CLIENT) then
	include('stool_cl.lua')
end
-- 124 
function ToolObj:Create()

	local o = {}

	setmetatable(o, self)
	self.__index = self

	o.Mode				= nil
	o.SWEP				= nil
	o.Owner				= nil
	o.ClientConVar		= {}
	o.ServerConVar		= {}
	o.Objects			= {}
	o.Stage				= 0
	o.Message			= "start"
	o.LastMessage		= 0
	o.AllowedCVar		= 0

	return o

end

function ToolObj:CreateConVars()

	local mode = self:GetMode()

	if (CLIENT) then

		for cvar, default in pairs(self.ClientConVar) do

			CreateClientConVar(mode.."_"..cvar, default, true, true)

		end

	return end

	-- Note: I changed this from replicated because replicated convars don't work
	-- when they're created via Lua.

	if (SERVER) then

		self.AllowedCVar = CreateConVar("toolmode_allow_"..mode, 1, FCVAR_NOTIFY)

	end

end

function ToolObj:GetServerInfo(property)

	local mode = self:GetMode()

	return GetConVarString(mode.."_"..property)

end

function ToolObj:BuildConVarList()

	local mode = self:GetMode()
	local convars = {}

	for k, v in pairs(self.ClientConVar) do convars[ mode .. "_" .. k ] = v end

	return convars

end

function ToolObj:GetClientInfo(property)

	local mode = self:GetMode()
	return self:GetOwner():GetInfo(mode.."_"..property)

end

function ToolObj:GetClientNumber(property, default)

	default = default or 0
	local mode = self:GetMode()
	return self:GetOwner():GetInfoNum(mode.."_"..property, default)

end

function ToolObj:Allowed()

	if (CLIENT) then return true end
	return self.AllowedCVar:GetBool()

end

-- Now for all the ToolObj redirects

function ToolObj:Init()	end

function ToolObj:GetMode() 			return self.Mode end
function ToolObj:GetSWEP() 			return self.SWEP end
function ToolObj:GetOwner() 			return self:GetSWEP().Owner or self.Owner end
function ToolObj:GetWeapon() 			return self:GetSWEP().Weapon or self.Weapon end

function ToolObj:LeftClick()			return false end
function ToolObj:RightClick()			return false end
function ToolObj:Reload()			self:ClearObjects() end
function ToolObj:Deploy()			self:ReleaseGhostEntity() return end
function ToolObj:Holster()			self:ReleaseGhostEntity() return end
function ToolObj:Think()			self:ReleaseGhostEntity() end

--[[---------------------------------------------------------
	Checks the objects before any action is taken
	This is to make sure that the entities haven't been removed
-----------------------------------------------------------]]
function ToolObj:CheckObjects()

	for k, v in pairs(self.Objects) do

		if (!v.Ent:IsWorld() && !v.Ent:IsValid()) then
			self:ClearObjects()
		end

	end


end

local toolmodes = file.Find(SWEP.Folder.."/stools/*.lua", "LUA")

for key, val in pairs(toolmodes) do

	local char1,char2,toolmode = string.find(val, "([%w_]*).lua")

	TOOL = ToolObj:Create()
	TOOL.Mode = toolmode

	AddCSLuaFile("stools/"..val)
	include("stools/"..val)

	TOOL:CreateConVars()

	SWEP.Tool[ toolmode ] = TOOL

	TOOL = nil

end

ToolObj = nil

if (CLIENT) then

	-- Keep the tool list handy
	local TOOLS_LIST = SWEP.Tool

	-- Add the STOOLS to the tool menu
	local function AddSToolsToMenu()

		for ToolName, TOOL in pairs(TOOLS_LIST) do

			if (TOOL.AddToMenu != false) then

				spawnmenu.AddToolMenuOption( TOOL.Tab or "Main",
												TOOL.Category or "New Category",
												ToolName,
												TOOL.Name or "#"..ToolName,
												TOOL.Command or "gmod_tool "..ToolName,
												TOOL.ConfigName or ToolName,
												TOOL.BuildCPanel )

			end

		end

	end

	hook.Add("PopulateToolMenu", "AddSToolsToMenu", AddSToolsToMenu)

	--
	-- Tool spawnmenu icon
	--
	spawnmenu.AddContentType("tool", function(container, obj)

		if (!obj.spawnname) then return end

		local icon = vgui.Create("ContentIcon", container)
		icon:SetContentType("tool")
		icon:SetSpawnName(obj.spawnname)
		icon:SetName(obj.nicename or "#tool." .. obj.spawnname .. ".name")
		icon:SetMaterial("gui/tool.png")

		icon.DoClick = function()

			spawnmenu.ActivateTool(obj.spawnname)

			surface.PlaySound("ui/buttonclickrelease.wav")

		end

		icon.OpenMenu = function(icon)

			local menu = DermaMenu()
				menu:AddOption("Delete", function() icon:Remove() hook.Run("SpawnlistContentChanged", icon) end)
			menu:Open()

		end

		if (IsValid(container)) then
			container:Add(icon)
		end

		return icon

	end )

end
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/button.lua:

TOOL.Category = "Construction"
TOOL.Name = "#tool.button.name"

TOOL.ClientConVar[ "model" ] = "models/maxofs2d/button_05.mdl"
TOOL.ClientConVar[ "keygroup" ] = "37"
TOOL.ClientConVar[ "description" ] = ""
TOOL.ClientConVar[ "toggle" ] = "1"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" }
}

cleanup.Register( "buttons" )

local function IsValidButtonModel( model )
	for mdl, _ in pairs( list.Get( "ButtonModels" ) ) do
		if ( mdl:lower() == model:lower() ) then return true end
	end
	return false
end

function TOOL:RightClick( trace, worldweld )

	if ( IsValid( trace.Entity ) && trace.Entity:IsPlayer() ) then return false end
	if ( SERVER && !util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) ) then return false end
	if ( CLIENT ) then return true end

	local model = self:GetClientInfo( "model" )
	local key = self:GetClientNumber( "keygroup" )
	local description = self:GetClientInfo( "description" )
	local toggle = self:GetClientNumber( "toggle" ) == 1
	local ply = self:GetOwner()

	-- If we shot a button change its settings
	if ( IsValid( trace.Entity ) && trace.Entity:GetClass() == "gmod_button" && trace.Entity.GetPlayer && trace.Entity:GetPlayer() == ply ) then
		trace.Entity:SetKey( key )
		trace.Entity:SetLabel( description )
		trace.Entity:SetIsToggle( toggle )

		return true
	end

	-- Check the model's validity
	if ( !util.IsValidModel( model ) || !util.IsValidProp( model ) || !IsValidButtonModel( model ) ) then return false end
	if ( !self:GetSWEP():CheckLimit( "buttons" ) ) then return false end

	local Ang = trace.HitNormal:Angle()
	Ang.pitch = Ang.pitch + 90

	local button = MakeButton( ply, model, Ang, trace.HitPos, key, description, toggle )

	if not IsValid(button) then return end -- FIX

	local min = button:OBBMins()
	button:SetPos( trace.HitPos - trace.HitNormal * min.z )

	undo.Create( "Button" )
		undo.AddEntity( button )

		if ( worldweld && trace.Entity != NULL ) then
			local weld = constraint.Weld( button, trace.Entity, 0, trace.PhysicsBone, 0, 0, true )

			if ( IsValid( button:GetPhysicsObject() ) ) then button:GetPhysicsObject():EnableCollisions( false ) end
			button:SetCollisionGroup( COLLISION_GROUP_WORLD )
			button.nocollide = true

			ply:AddCleanup( "buttons", weld )
			undo.AddEntity( weld )
		end

		undo.SetPlayer( ply )
	undo.Finish()

	return true

end

function TOOL:LeftClick( trace )

	return self:RightClick( trace, true )

end

if ( SERVER ) then
	function MakeButton( pl, model, ang, pos, key, description, toggle, nocollide )
		if ( IsValid( pl ) && !pl:CheckLimit( "buttons" ) ) then return false end

		if pl:GetCount("buttons") >= rp.Setting.Limits["buttons"] then -- FIX
			return false
		end

		if ( !IsValidButtonModel( model ) ) then return false end

		local button = ents.Create( "gmod_button" )
		if ( !IsValid( button ) ) then return false end
		button:SetModel( model )

		button:SetAngles( ang )
		button:SetPos( pos )
		button:Spawn()

		button:CPPISetOwner( pl ) -- FIX
		button:SetKey( key )

		if ( nocollide == true ) then
			if ( IsValid( button:GetPhysicsObject() ) ) then button:GetPhysicsObject():EnableCollisions( false ) end
			button:SetCollisionGroup( COLLISION_GROUP_WORLD )
		end

		table.Merge( button:GetTable(), {
			key = key,
			pl = pl,
			toggle = toggle,
			nocollide = nocollide,
			description = description
		} )

		if ( IsValid( pl ) ) then
			pl:AddCount( "buttons", button )
			pl:AddCleanup( "buttons", button )
		end

		return button
	end

	duplicator.RegisterEntityClass( "gmod_button", MakeButton, "Model", "Ang", "Pos", "key", "description", "toggle", "nocollide" )
end

function TOOL:UpdateGhostButton( ent, ply )
	if ( !IsValid( ent ) ) then return end

	local trace = ply:GetEyeTrace()
	if ( !trace.Hit || IsValid( trace.Entity ) && ( trace.Entity:GetClass() == "gmod_button" || trace.Entity:IsPlayer() ) ) then
		ent:SetNoDraw( true )
		return
	end

	local ang = trace.HitNormal:Angle()
	ang.pitch = ang.pitch + 90

	local min = ent:OBBMins()
	ent:SetPos( trace.HitPos - trace.HitNormal * min.z )
	ent:SetAngles( ang )

	ent:SetNoDraw( false )
end

function TOOL:Think()
	local mdl = self:GetClientInfo( "model" )
	if ( !IsValidButtonModel( mdl ) ) then self:ReleaseGhostEntity() return end

	if ( !IsValid( self.GhostEntity ) || self.GhostEntity:GetModel() != mdl ) then
		self:MakeGhostEntity( mdl, vector_origin, angle_zero )
	end

	self:UpdateGhostButton( self.GhostEntity, self:GetOwner() )
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( CPanel )
	CPanel:AddControl( "Header", { Description = "#tool.button.desc" } )

	CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "button", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

	CPanel:AddControl( "Numpad", { Label = "#tool.button.key", Command = "button_keygroup" } )

	CPanel:AddControl( "TextBox", { Label = "#tool.button.text", Command = "button_description", MaxLenth = "20" } )

	CPanel:AddControl( "CheckBox", { Label = "#tool.button.toggle", Command = "button_toggle", Help = true } )

	CPanel:AddControl( "PropSelect", { Label = "#tool.button.model", ConVar = "button_model", Height = 0, Models = list.Get( "ButtonModels" ) } )
end

list.Set( "ButtonModels", "models/maxofs2d/button_01.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_02.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_03.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_04.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_05.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_06.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_slider.mdl", {} )

--list.Set( "ButtonModels", "models/dav0r/buttons/button.mdl", {} )
--list.Set( "ButtonModels", "models/dav0r/buttons/switch.mdl", {} )
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/lamp.lua:
TOOL.Category = "Staff"
TOOL.Name = "#tool.lamp.name"
-- sfa 
TOOL.ClientConVar[ "r" ] = "255"
TOOL.ClientConVar[ "g" ] = "255"
TOOL.ClientConVar[ "b" ] = "255"
TOOL.ClientConVar[ "key" ] = "-1"
TOOL.ClientConVar[ "fov" ] = "90"
TOOL.ClientConVar[ "distance" ] = "1024"
TOOL.ClientConVar[ "brightness" ] = "4"
TOOL.ClientConVar[ "texture" ] = "effects/flashlight001"
TOOL.ClientConVar[ "model" ] = "models/lamps/torch.mdl"
TOOL.ClientConVar[ "toggle" ] = "1"

cleanup.Register("lamps")

function TOOL:LeftClick(trace)

	if true then return false end
	if (IsValid(trace.Entity) && trace.Entity:IsPlayer()) then return false end
	if (CLIENT) then return true end

	local ply = self:GetOwner()
	local pos = trace.HitPos

	local r = math.Clamp(self:GetClientNumber("r"), 0, 255)
	local g = math.Clamp(self:GetClientNumber("g"), 0, 255)
	local b = math.Clamp(self:GetClientNumber("b"), 0, 255)
	local key = self:GetClientNumber("key")
	local texture = self:GetClientInfo("texture")
	local mdl = self:GetClientInfo("model")
	local fov = self:GetClientNumber("fov")
	local distance = self:GetClientNumber("distance")
	local bright = self:GetClientNumber("brightness")
	local toggle = self:GetClientNumber("toggle") != 1

	local mat = Material(texture)
	local texture = mat:GetString("$basetexture")

	if	(IsValid(trace.Entity) && trace.Entity:GetClass() == "gmod_lamp" && trace.Entity:GetPlayer() == ply) then

		trace.Entity:SetColor(Color(r, g, b, 255))
		trace.Entity:SetFlashlightTexture(texture)
		trace.Entity:SetLightFOV(fov)
		trace.Entity:SetDistance(distance)
		trace.Entity:SetBrightness(bright)
		trace.Entity:SetToggle(!toggle)
		trace.Entity:UpdateLight()

		numpad.Remove(trace.Entity.NumDown)
		numpad.Remove(trace.Entity.NumUp)

		trace.Entity.NumDown = numpad.OnDown(ply, key, "LampToggle", trace.Entity, 1)
		trace.Entity.NumUp = numpad.OnUp(ply, key, "LampToggle", trace.Entity, 0)

		-- For duplicator
		trace.Entity.Texture = texture
		trace.Entity.fov = fov
		trace.Entity.distance = distance
		trace.Entity.r = r
		trace.Entity.g = g
		trace.Entity.b = b
		trace.Entity.brightness	= bright
		trace.Entity.KeyDown = key

		return true

	end

	if (!self:GetSWEP():CheckLimit("lamps")) then return false end

	local lamp = MakeLamp(ply, r, g, b, key, toggle, texture, mdl, fov, distance, bright, !toggle, { Pos = pos, Angle = Angle(0, 0, 0) })

	local CurPos = lamp:GetPos()
	local NearestPoint = lamp:NearestPoint(CurPos - (trace.HitNormal * 512))
	local LampOffset = CurPos - NearestPoint

	lamp:SetPos(trace.HitPos + LampOffset)

	undo.Create("Lamp")
		undo.AddEntity(lamp)
		undo.SetPlayer(self:GetOwner())
	undo.Finish()


	return true

end

function TOOL:RightClick(trace)

	if (!IsValid(trace.Entity) || trace.Entity:GetClass() != "gmod_lamp") then return false end
	if (CLIENT) then return true end

	local ent = trace.Entity
	local pl = self:GetOwner()

	pl:ConCommand("lamp_fov " .. ent:GetLightFOV())
	pl:ConCommand("lamp_distance " .. ent:GetDistance())
	pl:ConCommand("lamp_brightness " .. ent:GetBrightness())
	pl:ConCommand("lamp_texture " .. ent:GetFlashlightTexture())

	if (ent:GetToggle()) then
		pl:ConCommand("lamp_toggle 1")
	else
		pl:ConCommand("lamp_toggle 0")
	end

	local clr = ent:GetColor()
	pl:ConCommand("lamp_r " .. clr.r)
	pl:ConCommand("lamp_g " .. clr.g)
	pl:ConCommand("lamp_b " .. clr.b)

	return true

end

if (SERVER) then

	function MakeLamp(pl, r, g, b, KeyDown, toggle, Texture, Model, fov, distance, brightness, on, Data)

		if (IsValid(pl ) && !pl:CheckLimit("lamps")) then return false end

		local lamp = ents.Create("gmod_lamp")

		if (!IsValid(lamp)) then return end

		lamp:SetModel(Model)
		lamp:SetFlashlightTexture(Texture)
		lamp:SetLightFOV(fov)
		lamp:SetColor(Color(r, g, b, 255))
		lamp:SetDistance(distance)
		lamp:SetBrightness(brightness)
		lamp:Switch(on)
		lamp:SetToggle(!toggle)

		duplicator.DoGeneric(lamp, Data)

		lamp:Spawn()

		duplicator.DoGenericPhysics(lamp, pl, Data)

		lamp:CPPISetOwner(pl)

		if (IsValid(pl)) then
			pl:AddCount("lamps", lamp)
			pl:AddCleanup("lamps", lamp)
		end

		lamp.Texture = Texture
		lamp.KeyDown = KeyDown
		lamp.fov = fov
		lamp.distance = distance
		lamp.r = r
		lamp.g = g
		lamp.b = b
		lamp.brightness	= brightness

		lamp.NumDown = numpad.OnDown(pl, KeyDown, "LampToggle", lamp, 1)
		lamp.NumUp = numpad.OnUp(pl, KeyDown, "LampToggle", lamp, 0)

		return lamp

	end
	duplicator.RegisterEntityClass("gmod_lamp", MakeLamp, "r", "g", "b", "KeyDown", "Toggle", "Texture", "Model", "fov", "distance", "brightness", "on", "Data")

	local function Toggle(pl, ent, onoff)

		if (!IsValid(ent)) then return false end
		if (!ent:GetToggle() ) then ent:Switch(onoff == 1) return end

		if (numpad.FromButton()) then

			ent:Toggle()
			return

		end

		if (onoff == 0) then return end

		return ent:Toggle()

	end
	numpad.Register("LampToggle", Toggle)

end

function TOOL:UpdateGhostLamp(ent, player)

	if (!IsValid(ent)) then return end

	local tr = util.GetPlayerTrace(player)
	local trace	= util.TraceLine(tr)
	if (!trace.Hit) then return end

	if (trace.Entity:IsPlayer() || trace.Entity:GetClass() == "gmod_lamp") then

		ent:SetNoDraw(true)
		return

	end

	local CurPos = ent:GetPos()
	local NearestPoint = ent:NearestPoint(CurPos - (trace.HitNormal * 512))
	local LampOffset = CurPos - NearestPoint

	ent:SetPos(trace.HitPos + LampOffset)

	ent:SetNoDraw(false)

end

function TOOL:Think()

	if (!IsValid(self.GhostEntity ) || self.GhostEntity:GetModel() != self:GetClientInfo("model")) then
		self:MakeGhostEntity(self:GetClientInfo("model" ), Vector(0, 0, 0), Angle(0, 0, 0))
	end

	self:UpdateGhostLamp(self.GhostEntity, self:GetOwner())

end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel(CPanel)

	CPanel:AddControl("Header", { Description = "#tool.lamp.desc" })

	CPanel:AddControl("ComboBox", { MenuButton = 1, Folder = "lamp", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys(ConVarsDefault) })

	CPanel:AddControl("Numpad", { Label = "#tool.lamp.key", Command = "lamp_key" })

	CPanel:AddControl("Slider", { Label = "#tool.lamp.fov", Command = "lamp_fov", Type = "Float", Min = 10, Max = 170 })
	CPanel:AddControl("Slider", { Label = "#tool.lamp.distance", Command = "lamp_distance", Min = 64, Max = 2048 })
	CPanel:AddControl("Slider", { Label = "#tool.lamp.brightness", Command = "lamp_brightness", Type = "Float", Min = 0, Max = 8 })

	CPanel:AddControl("Checkbox", { Label = "#tool.lamp.toggle", Command = "lamp_toggle" })

	local MatSelect = CPanel:MatSelect("lamp_texture", nil, true, 0.33, 0.33)

	for k, v in pairs(list.Get("LampTextures")) do
		MatSelect:AddMaterial(v.Name or k, k)
	end

	CPanel:AddControl("Color", { Label = "#tool.lamp.color", Red = "lamp_r", Green = "lamp_g", Blue = "lamp_b" })

	CPanel:AddControl("PropSelect", { Label = "#tool.lamp.model", ConVar = "lamp_model", Height = 3, Models = list.Get("LampModels") })
end

list.Set("LampTextures", "effects/flashlight001", { Name = "#lamptexture.default" })
list.Set("LampTextures", "effects/flashlight/slit", { Name = "#lamptexture.slit" })
list.Set("LampTextures", "effects/flashlight/circles", { Name = "#lamptexture.circles" })
list.Set("LampTextures", "effects/flashlight/window", { Name = "#lamptexture.window" })
list.Set("LampTextures", "effects/flashlight/logo", { Name = "#lamptexture.logo" })
list.Set("LampTextures", "effects/flashlight/gradient", { Name = "#lamptexture.gradient" })
list.Set("LampTextures", "effects/flashlight/bars", { Name = "#lamptexture.bars" })
list.Set("LampTextures", "effects/flashlight/tech", { Name = "#lamptexture.techdemo" })
list.Set("LampTextures", "effects/flashlight/soft", { Name = "#lamptexture.soft" })
list.Set("LampTextures", "effects/flashlight/hard", { Name = "#lamptexture.hard" })
list.Set("LampTextures", "effects/flashlight/caustics", { Name = "#lamptexture.caustics" })
list.Set("LampTextures", "effects/flashlight/square", { Name = "#lamptexture.square" })
list.Set("LampTextures", "effects/flashlight/camera", { Name = "#lamptexture.camera" })
list.Set("LampTextures", "effects/flashlight/view", { Name = "#lamptexture.view" })

list.Set("LampModels", "models/lamps/torch.mdl", {})
list.Set("LampModels", "models/maxofs2d/lamp_flashlight.mdl", {})
list.Set("LampModels", "models/maxofs2d/lamp_projector.mdl", {})
--PATH gamemodes/darkrp/entities/weapons/gmod_tool/stools/precision.lua:

TOOL.Category		= "Constraints"
TOOL.Name			= "#Precision"
TOOL.Command		= nil
TOOL.ConfigName		= ""

TOOL.ClientConVar[ "mode" ]	 			= "1"
TOOL.ClientConVar[ "user" ] 			= "1"

TOOL.ClientConVar[ "freeze" ]	 		= "1"
TOOL.ClientConVar[ "nocollide" ]		= "1"
TOOL.ClientConVar[ "nocollideall" ]		= "0"
TOOL.ClientConVar[ "rotation" ] 		= "15"
TOOL.ClientConVar[ "rotate" ] 			= "1"
TOOL.ClientConVar[ "offset" ]	 		= "0"
TOOL.ClientConVar[ "forcelimit" ]		= "0"
TOOL.ClientConVar[ "torquelimit" ] 		= "0"
TOOL.ClientConVar[ "friction" ]	 		= "0"
TOOL.ClientConVar[ "width" ]	 		= "1"
TOOL.ClientConVar[ "offsetpercent" ] 	= "1"
TOOL.ClientConVar[ "removal" ]	 		= "0"
TOOL.ClientConVar[ "move" ]	 			= "1"
TOOL.ClientConVar[ "physdisable" ]		= "0"
TOOL.ClientConVar[ "ShadowDisable" ]	= "0"
TOOL.ClientConVar[ "allowphysgun" ]		= "0"
TOOL.ClientConVar[ "autorotate" ]		= "0"
TOOL.ClientConVar[ "entirecontrap" ]	= "0"
TOOL.ClientConVar[ "nudge" ]			= "25"
TOOL.ClientConVar[ "nudgepercent" ]		= "1"
TOOL.ClientConVar[ "disablesliderfix" ]	= "1"

//adv ballsocket
TOOL.ClientConVar[ "XRotMin" ]		= "-180"
TOOL.ClientConVar[ "XRotMax" ]		= "180"
TOOL.ClientConVar[ "YRotMin" ]		= "-180"
TOOL.ClientConVar[ "YRotMax" ]		= "180"
TOOL.ClientConVar[ "ZRotMin" ]		= "-180"
TOOL.ClientConVar[ "ZRotMax" ]		= "180"
TOOL.ClientConVar[ "XRotFric" ]		= "0"
TOOL.ClientConVar[ "YRotFric" ]		= "0"
TOOL.ClientConVar[ "ZRotFric" ]		= "0"
TOOL.ClientConVar[ "FreeMov" ]		= "0"

//Removal
TOOL.ClientConVar[ "removal_nocollide" ]	= "1"
TOOL.ClientConVar[ "removal_weld" ]	 		= "1"
TOOL.ClientConVar[ "removal_axis" ]	 		= "1"
TOOL.ClientConVar[ "removal_ballsocket" ]	= "1"
TOOL.ClientConVar[ "removal_advballsocket" ]= "1"
TOOL.ClientConVar[ "removal_slider" ]	 	= "1"
TOOL.ClientConVar[ "removal_parent" ]	 	= "1"
TOOL.ClientConVar[ "removal_other" ]	 	= "1"


TOOL.ClientConVar[ "enablefeedback" ]	= "1"
TOOL.ClientConVar[ "chatfeedback" ]		= "1"
TOOL.ClientConVar[ "nudgeundo" ]		= "0"
TOOL.ClientConVar[ "moveundo" ]			= "1"
TOOL.ClientConVar[ "rotateundo" ]		= "1"

function TOOL:DoParent( Ent1, Ent2 )
	local TempEnt = Ent2
	if !(Ent1 && Ent1:IsValid() && Ent1:EntIndex() != 0) then
		self:SendMessage( "Oops, First Target was world or something invalid" )
		return
	end
	if !(Ent2 && Ent2:IsValid() && Ent2:EntIndex() != 0) then
		self:SendMessage( "Oops, Second Target was world or something invalid" )
		return
	end
	if ( Ent1 == Ent2 ) then
		self:SendMessage( "Oops, Can't parent something to itself" )
		return
	end
	Ent1:SetMoveType(MOVETYPE_NONE)
	local disablephysgun = self:GetClientNumber( "allowphysgun" ) == 0
	Ent1.PhysgunDisabled = disablephysgun
	Ent1:SetUnFreezable( disablephysgun )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( false )
	end
	while true do
		if ( !TempEnt:GetParent():IsValid() ) then
			Ent1:SetParent( Ent2 )
			if self:GetClientNumber( "entirecontrap" ) == 0 then self:SendMessage( "Parent Set." ) end
			Phys1:Wake()
			break
		elseif ( TempEnt:GetParent() == Ent1 ) then
			UndoParent( TempEnt )
			timer.Simple( 0.1, function()//delay to stop crash
				Ent1.SetParent( Ent1, Ent2)
			end)
			self:SendMessage( "Oops, Closed Parent Loop Detected; Broken loop and set parent." )
			break
		else
			TempEnt = TempEnt:GetParent()
		end
	end
	Phys1:Wake()
	//Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
end

function TOOL:UndoParent( Ent1 )
	Ent1:SetParent( nil )
	Ent1:SetMoveType(MOVETYPE_VPHYSICS)
	Ent1.PhysgunDisabled = false
	Ent1:SetUnFreezable( false )
	local Phys1 = Ent1:GetPhysicsObject()
	if Phys1:IsValid() then
		Phys1:EnableCollisions( true )
		Phys1:Wake()
		//Phys1:UpdateShadow(Ent1:GetAngles(),Ent1:GetAngles())
	end
end

function TOOL:DoApply(CurrentEnt, FirstEnt, autorotate, nocollideall, ShadowDisable )
	local CurrentPhys = CurrentEnt:GetPhysicsObject()
	
	//local col = CurrentEnt:GetCollisionGroup()
	//col = 19
	//CurrentEnt:SetCollisionGroup(col)
	//self:SendMessage("New group: "..col)
	
	//if ( CurrentPhys:IsDragEnabled() ) then
	//end
	//CurrentPhys:SetAngleDragCoefficient(1.05)
	//CurrentPhys:SetDragCoefficient(1.05)
	
	if ( autorotate ) then
		if ( CurrentEnt == FirstEnt ) then//Snap-rotate original object first.  Rest needs to rotate around it.
			local angle = CurrentPhys:RotateAroundAxis( Vector( 0, 0, 1 ), 0 )
			self.anglechange = Vector( angle.p - (math.Round(angle.p/45))*45, angle.r - (math.Round(angle.r/45))*45, angle.y - (math.Round(angle.y/45))*45 )
			if ( table.Count(self.TaggedEnts) == 1 ) then
				angle.p = (math.Round(angle.p/45))*45
				angle.r = (math.Round(angle.r/45))*45//Only rotate on these axies if it's singular.
			end
			angle.y = (math.Round(angle.y/45))*45
			CurrentPhys:SetAngles( angle )
		else
			local distance = math.sqrt(math.pow((CurrentEnt:GetPos().X-FirstEnt:GetPos().X),2)+math.pow((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y),2))
			local theta = math.atan((CurrentEnt:GetPos().Y-FirstEnt:GetPos().Y) / (CurrentEnt:GetPos().X-FirstEnt:GetPos().X)) - math.rad(self.anglechange.Z)
			if (CurrentEnt:GetPos().X-FirstEnt:GetPos().X) < 0 then
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X - (distance*(math.cos(theta))), FirstEnt:GetPos().Y - (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			else
				CurrentEnt:SetPos( Vector( FirstEnt:GetPos().X + (distance*(math.cos(theta))), FirstEnt:GetPos().Y + (distance*(math.sin(theta))), CurrentEnt:GetPos().Z ) )
			end
			CurrentPhys:SetAngles( CurrentPhys:RotateAroundAxis( Vector( 0, 0, -1 ), self.anglechange.Z ) )
		end
	end

	CurrentPhys:EnableCollisions( !nocollideall )
	CurrentEnt:DrawShadow( !ShadowDisable )
	if physdis then
		CurrentEnt:SetMoveType(MOVETYPE_NONE)
		CurrentEnt.PhysgunDisabled = disablephysgun
		CurrentEnt:SetUnFreezable( disablephysgun )
	else
		CurrentEnt:SetMoveType(MOVETYPE_VPHYSICS)
		CurrentEnt.PhysgunDisabled = false
		CurrentEnt:SetUnFreezable( false )
	end
	CurrentPhys:Wake()
end

function TOOL:CreateUndo(constraint,undoname)
	if (constraint) then
		undo.Create(undoname)
		undo.AddEntity( constraint )
		undo.SetPlayer( self:GetOwner() )
		undo.Finish()
		self:GetOwner():AddCleanup( "constraints", constraint )
	end
end

function TOOL:UndoRepairToggle()
	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then//parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then //not a ragdoll
						if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
						elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
							CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
						end
						if ( speeddamp == 0 && angledamp == 0 ) then
							CurrentPhys:SetDamping( 5, 5 )
						elseif ( speeddamp == 5 && angledamp == 5 ) then
							CurrentPhys:SetDamping( 0, 0 )
						end
						CurrentPhys:Wake()
					end
				end
			end
		end
	end
	self.RepairTodo = false
end

function TOOL:DoConstraint(mode)
	self:SetStage(0)
	// Get information we're about to use
	local Ent1,  Ent2  = self:GetEnt(1),    self:GetEnt(2)

	if ( !Ent1:IsValid() || CLIENT ) then
		self:ClearObjects()
		return false//Something happened to original target, don't continue
	end
	// Get client's CVars
	local forcelimit 	= self:GetClientNumber( "forcelimit", 0 )
	local freeze		= util.tobool( self:GetClientNumber( "freeze", 1 ) )
	local nocollide		= self:GetClientNumber( "nocollide", 0 )
	local nocollideall	= util.tobool( self:GetClientNumber( "nocollideall", 0 ) )
	local torquelimit	= self:GetClientNumber( "torquelimit", 0 )
	local width			= self:GetClientNumber( "width", 1 )
	local friction		= self:GetClientNumber( "friction", 0 )
	local physdis		= util.tobool( self:GetClientNumber( "physdisable", 0 ) )
	local ShadowDisable = util.tobool( self:GetClientNumber( "ShadowDisable", 0 ) )
	local autorotate 	= util.tobool(self:GetClientNumber( "autorotate",1 ))
	local removal_nocollide 	= util.tobool(self:GetClientNumber( "removal_nocollide",1 ))
	local removal_weld 	= util.tobool(self:GetClientNumber( "removal_weld",1 ))
	local removal_axis 	= util.tobool(self:GetClientNumber( "removal_axis",1 ))
	local removal_ballsocket 	= util.tobool(self:GetClientNumber( "removal_ballsocket",1 ))
	local removal_advballsocket 	= util.tobool(self:GetClientNumber( "removal_advballsocket",1 ))
	local removal_slider 	= util.tobool(self:GetClientNumber( "removal_slider",1 ))
	local removal_parent 	= util.tobool(self:GetClientNumber( "removal_parent",1 ))
	local removal_other 	= util.tobool(self:GetClientNumber( "removal_other",1 ))
	local Bone1 = self:GetBone(1)
	local LPos1 = self:GetLocalPos(1)
	local Bone2 = nil
	local LPos2 = nil
	if ( Ent2 && (Ent2:IsValid() || Ent2:IsWorld()) ) then
		Bone2 = self:GetBone(2)
		LPos2 = self:GetLocalPos(2)
	end
	local Phys1 = self:GetPhys(1)
	
	local NumApp = 0
	

	for key,CurrentEnt in pairs(self.TaggedEnts) do
		if ( CurrentEnt and CurrentEnt:IsValid() ) then
			if !(CurrentEnt == Ent2 ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() && !CurrentEnt:GetParent():IsValid() ) then//parent?
					if ( CurrentEnt:GetPhysicsObjectCount() < 2 ) then //not a ragdoll
						if (  util.tobool( nocollide ) && (mode == 1 || mode == 3)) then // not weld/axis/ballsocket or single application
							local constraint = constraint.NoCollide(CurrentEnt, Ent2, 0, Bone2)
						end
						if ( mode == 1 ) then //Apply
						//	self:DoApply( CurrentEnt, Ent1, autorotate, nocollideall, ShadowDisable )
						elseif ( mode == 2 ) then //Rotate
							//self:SendMessage("Sorry, No entire contraption rotating... yet")
							//return false//TODO: Entire contrpation rotaton
						elseif ( mode == 3 ) then //move
							//self:SendMessage("Sorry, No entire contraption moving... yet")
							//return false//todo: entire contraption move/snap
						elseif ( mode == 4 ) then //weld
						//	local constr = constraint.Weld( CurrentEnt, Ent2, 0, Bone2, forcelimit,  util.tobool( nocollide ) )
						//	self:CreateUndo(constr,"Precision_Weld")
						elseif ( mode == 5 ) then //doaxis
						//	local constr = constraint.Axis( CurrentEnt, Ent2, Bone1, Bone2, LPos1, LPos2, forcelimit, torquelimit, friction, nocollide )
						//	self:CreateUndo(constr,"Precision_Axis")
						elseif ( mode == 6 ) then //ballsocket
						//	local constr = constraint.Ballsocket( CurrentEnt, Ent2, 0, Bone2, LPos2, forcelimit, torquelimit, nocollide )
						//	self:CreateUndo(constr,"Precision_Ballsocket")
						elseif ( mode == 7 ) then //adv ballsocket
						//	local constr = constraint.AdvBallsocket( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, forcelimit, torquelimit, self:GetClientNumber( "XRotMin", -180 ), self:GetClientNumber( "YRotMin", -180 ), self:GetClientNumber( "ZRotMin", -180 ), self:GetClientNumber( "XRotMax", 180 ), self:GetClientNumber( "YRotMax", 180 ), self:GetClientNumber( "ZRotMax", 180 ), self:GetClientNumber( "XRotFric", 0 ), self:GetClientNumber( "YRotFric", 0 ), self:GetClientNumber( "ZRotFric", 0 ), self:GetClientNumber( "FreeMov", 0 ), nocollide )
						//	self:CreateUndo(constr,"Precision_Advanced_Ballsocket")
						elseif ( mode == 8 ) then //slider
							//local constraint0 = constraint.Slider( CurrentEnt, Ent2, 0, Bone2, LPos1, LPos2, width )
							//if (constraint0) then
							//	undo.Create("Precision_Slider")
							//	if ( self:GetClientNumber( "disablesliderfix" ) == 0 ) then
							//		local constraint2 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, 0, -180, -180, 0, 180, 180, 50, 0, 0, 1, 0 )
							//		if (constraint2) then
							//			undo.AddEntity( constraint2 )
							//		end
							//		local constraint3 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, 0, -180, 180, 0, 180, 0, 50, 0, 1, 0 )
							//		if (constraint3) then
							//			undo.AddEntity( constraint3 )
							//		end
							//		local constraint4 = constraint.AdvBallsocket( Ent1, Ent2, Bone1, Bone2, LPos1, LPos2, 0, 0, -180, -180, 0, 180, 180, 0, 0, 0, 50, 1, 0 )
							//		if (constraint4) then
							//			undo.AddEntity( constraint4 )
							//		end
							//	end
							//	undo.AddEntity( constraint0 )
							//	undo.SetPlayer( self:GetOwner() )
							//	undo.Finish()
							//	self:GetOwner():AddCleanup( "constraints", constraint0 )
							//end
						elseif ( mode == 9 ) then //Parent
						//	self:DoParent( CurrentEnt, Ent2 )
						elseif ( mode == 10 && !self.RepairTodo ) then//Repair spaz
						//	if ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_WORLD ) then
						//		CurrentEnt:SetCollisionGroup( COLLISION_GROUP_NONE )
						//	elseif ( CurrentEnt:GetCollisionGroup() == COLLISION_GROUP_NONE ) then
						//		CurrentEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
						//	end
						//		//CurrentPhys:EnableGravity( !CurrentPhys:IsGravityEnabled() )//Can't disable gravity - sliders would go nuts and disappear.	
						//	local speeddamp,angledamp = CurrentPhys:GetDamping()
						//	if ( speeddamp == 0 && angledamp == 0 ) then
						//		CurrentPhys:SetDamping( 5, 5 )
						//	elseif ( speeddamp == 5 && angledamp == 5 ) then
						//		CurrentPhys:SetDamping( 0, 0 )
						//	end
						//	CurrentEnt:SetPos(CurrentEnt:GetPos())
						//	CurrentPhys:Wake()
						elseif ( mode == 11 ) then //Removal
						//	if ( CLIENT ) then return true end//? should probably be in more places
						//	if ( removal_nocollide ) then
						//		constraint.RemoveConstraints( CurrentEnt, "NoCollide" )
						//		CurrentPhys:EnableCollisions(true)
						//	end
						//	if ( removal_weld ) then
						//		constraint.RemoveConstraints( CurrentEnt, "Weld" )
						//	end
						//	if ( removal_parent) then
						//		if ( CurrentEnt:GetParent():IsValid() ) then
						//			self:UndoParent( CurrentEnt )
						//		end
						//	end
						end
						if ( mode <= 8 ) then
						//	CurrentPhys:EnableMotion( false )
						end
					end
				end
			end
		end
		NumApp = NumApp + 1
	end//Next
	if ( mode == 1 ) then
		self:SendMessage( NumApp .. " items targeted for apply." )
	elseif ( mode == 2 ) then
		self:SendMessage( NumApp .. " items targeted for rotate." )
	elseif ( mode == 3 ) then
		self:SendMessage( NumApp .. " items targeted for move." )
	elseif ( mode == 4 ) then
		self:SendMessage( NumApp .. " items targeted for weld." )
	elseif ( mode == 5 ) then
		self:SendMessage( NumApp .. " items targeted for axis." )
	elseif ( mode == 6 ) then
		self:SendMessage( NumApp .. " items targeted for ballsocket." )
	elseif ( mode == 7 ) then
		self:SendMessage( NumApp .. " items targeted for adv. ballsocket." )
	elseif ( mode == 8 ) then
		self:SendMessage( NumApp .. " items targeted for slider." )
	elseif ( mode == 9 ) then
		self:SendMessage( NumApp .. " items targeted for parenting." )
	elseif ( mode == 10 ) then
		self:SendMessage( NumApp .. " items targeted for repair." )
	elseif ( mode == 11 ) then
		self:SendMessage( NumApp .. " items targeted for constraint removal." )
	end
	
	
	if ( mode == 10 ) then
		self.RepairTodo = true
		timer.Simple( 1.0, function()
		self:ClearSelection()
		end)
	else
		self:ClearSelection()
	end
	// Clear the objects so we're ready to go again
	self:ClearObjects()
end

function TOOL:SendMessage( message )
	if ( self:GetClientNumber( "enablefeedback" ) == 0 ) then return end
	if ( self:GetClientNumber( "chatfeedback" ) == 1 ) then
		self:GetOwner():PrintMessage( HUD_PRINTTALK, "Tool: " .. message )
	else
		self:GetOwner():PrintMessage( HUD_PRINTCENTER, message )
	end
end

function TOOL:TargetValidity ( trace, Phys ) //TODO: Parented stuff should return 1
	if ( SERVER && (!util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) || !Phys:IsValid()) ) then
		local mode = self:GetClientNumber( "mode" )
		if ( trace.Entity:GetParent():IsValid() ) then
			return 2//Valid parent, but itself isn't
		else
			return 0//No valid phys
		end
	elseif ( trace.Entity:IsPlayer() ) then
		return 0// Don't attach players, or to players
	elseif ( trace.HitWorld ) then
		return 1// Only allow second click to be here...
	else
		return 3//Everything seems good
	end
end

function TOOL:StartRotate()
	local Ent = self:GetEnt(1)
	local Phys = self:GetPhys(1)
	local oldposu = Ent:GetPos()
	local oldangles = Ent:GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	
	if ( self:GetClientNumber( "rotateundo" )) then
		if SERVER then
			undo.Create("Precision_Rotate")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( MoveUndo, Ent, oldposu, oldangles )
			undo.Finish()
		end
	end
	
	if IsValid( Phys ) then
		Phys:EnableMotion( false ) //else it drifts
	end
	
	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	self.axis = self:GetNormal(1)
	self.axisY = self.axis:Cross(Ent:GetUp())
	if self:WithinABit( self.axisY, Vector(0,0,0) ) then
		self.axisY = self.axis:Cross(Ent:GetForward())
	end
	self.axisZ = self.axisY:Cross(self.axis)
	self.realdegrees = 0
	self.lastdegrees = -((rotation*0.5) % rotation)
	self.realdegreesY = 0
	self.lastdegreesY = -((rotation*0.5) % rotation)
	self.realdegreesZ = 0
	self.lastdegreesZ = -((rotation*0.5) % rotation)
	self.OldPos = self:GetPos(1)//trace.HitPos
end

function TOOL:DoMove()
	// Get information we're about to use
	local Norm1, Norm2 = self:GetNormal(1),   self:GetNormal(2)
	local Phys1, Phys2 = self:GetPhys(1),     self:GetPhys(2)
	
	local Ang1, Ang2 = Norm1:Angle(), (Norm2 * -1):Angle()
	if self:GetClientNumber( "autorotate" ) == 1 then
		Ang2.p = (math.Round(Ang2.p/45))*45
		Ang2.r = (math.Round(Ang2.r/45))*45
		Ang2.y = (math.Round(Ang2.y/45))*45
		Norm2 = Ang2:Forward() * -1
	end


	local oldposu = self:GetEnt(1):GetPos()
	local oldangles = self:GetEnt(1):GetAngles()

	local function MoveUndo( Undo, Entity, oldposu, oldangles )
		if Entity:IsValid() then
			Entity:SetAngles( oldangles )
			Entity:SetPos( oldposu )
		end
	end
	if self:GetClientNumber( "moveundo" ) == 1 then
	undo.Create("Precision Move")
		undo.SetPlayer(self:GetOwner())
		undo.AddFunction( MoveUndo, self:GetEnt(1), oldposu, oldangles )
	undo.Finish()
	end

	local rotation = self:GetClientNumber( "rotation" )
	if ( rotation < 0.02 ) then rotation = 0.02 end
	if ( (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2) then//Set axies for rotation mode directions
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
		self.realdegrees = 0
		self.lastdegrees = -((rotation*0.5) % rotation)
		self.realdegreesY = 0
		self.lastdegreesY = -((rotation*0.5) % rotation)
		self.realdegreesZ = 0
		self.lastdegreesZ = -((rotation*0.5) % rotation)
	else
		self.axis = Norm2
		self.axisY = self.axis:Cross(Vector(0,1,0))
		if self:WithinABit( self.axisY, Vector(0,0,0) ) then
			self.axisY = self.axis:Cross(Vector(0,0,1))
		end
		self.axisY:Normalize()
		self.axisZ = self.axisY:Cross(self.axis)
		self.axisZ:Normalize()
	end



	local TargetAngle = Phys1:AlignAngles( Ang1, Ang2 )//Get angle Phys1 would be at if difference between Ang1 and Ang2 was added


	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end

	Phys1:SetAngles( TargetAngle )


	local NewOffset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )
	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	if ( offsetpercent ) then
		local  Ent2  = self:GetEnt(2)
		local glower = Ent2:OBBMins()
		local gupper = Ent2:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(Norm2,Ent2:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(Norm2,Ent2:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end
	Norm2 = Norm2 * (-0.0625 + NewOffset)
	local TargetPos = self:GetPos(2) + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
	//self:SetPos(2)

	// Set the position

	Phys1:SetPos( TargetPos )
	Phys1:EnableMotion( false )

	// Wake up the physics object so that the entity updates
	Phys1:Wake()
end

function TOOL:ToggleColor( CurrentEnt )
	color = CurrentEnt:GetColor()
	color["a"] = color["a"] - 128
	if ( color["a"] < 0 ) then
		color["a"] = color["a"] + 256
	end
	color["r"] = color["r"] - 128
	if ( color["r"] < 0 ) then
		color["r"] = color["r"] + 256
	end
	color["g"] = color["g"] - 128
	if ( color["g"] < 0 ) then
		color["g"] = color["g"] + 256
	end
	color["b"] = color["b"] - 128
	if ( color["b"] < 0 ) then
		color["b"] = color["b"] + 256
	end
	CurrentEnt:SetColor( color )
	if ( color["a"] == 255 ) then
		CurrentEnt:SetRenderMode( 0 )
	else
		CurrentEnt:SetRenderMode( 1 )
	end
end

function TOOL:ClearSelection()
	if ( self.RepairTodo ) then
		self:UndoRepairToggle()
	end
	if ( self.TaggedEnts ) then
		local color
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
		end
	end
	self.TaggedEnts = {}
end

function TOOL:SelectEnts(StartEnt, AllConnected)
	self:ClearSelection()
	if ( CLIENT ) then return end
	local color
	if ( AllConnected == 1 ) then
		local NumApp = 0
		EntsTab = {}
		ConstsTab = {}
		GetAllEnts(StartEnt, self.TaggedEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(self.TaggedEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then
					self:ToggleColor(CurrentEnt)
				end
			end
			NumApp = NumApp + 1
		end
		self:SendMessage( NumApp .. " objects selected." )
	else
		if ( StartEnt and StartEnt:IsValid() ) then
			local CurrentPhys = StartEnt:GetPhysicsObject()
			if ( CurrentPhys:IsValid() ) then
				table.insert(self.TaggedEnts, StartEnt)
				self:ToggleColor(StartEnt)
			end
		end
	end
	
end

function TOOL:LeftClick( trace )
	local stage = self:GetStage()//0 = started, 1 = moving/second target, 2 = rotation?
	local mode = self:GetClientNumber( "mode" )
	local moving = ( mode == 3 || (self:GetClientNumber( "move" ) == 1 && mode >= 3 && mode <= 8 ) )
	local rotating = ( self:GetClientNumber( "rotate" ) == 1 )
	local Phys = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )

	
	if ( stage == 0 ) then//first click - choose a target.
		if ( self:TargetValidity(trace, Phys) <= 1 ) then
			return false//No phys or hit world
		end
		self:SetObject( 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
		
		if (self:GetClientNumber( "entirecontrap" ) == 1 || mode == 10 ) then
			self:SelectEnts(trace.Entity,1)
		else
			self:SelectEnts(trace.Entity,0)
		end
		if ( mode == 1 || mode == 10 || mode == 11 ) then //Don't care about stage, always apply.
			self:DoConstraint(mode)
		else
			if ( mode == 9 ) then
				self:SetStage(1)
			else
				if ( moving ) then//Moving
					self:StartGhostEntity( trace.Entity )
					self:SetStage(1)
				elseif ( mode == 2 ) then//Straight to rotate
					self:StartRotate()
					self:SetStage(2)
				else
					self:SetStage(1)
				end
			end
		end
	elseif ( stage == 1 ) then//Second click
		self:SetObject( 2, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
		
		if ( self:GetEnt(1) == self:GetEnt(2) ) then
			SavedPos = self:GetPos(2)
		end
		if ( mode == 9 ) then
			self:DoConstraint(mode)
		else
			if ( moving ) then
				if ( CLIENT ) then
					self:ReleaseGhostEntity()
					return true
				end
				if ( SERVER && !game.SinglePlayer() ) then
					self:ReleaseGhostEntity()
					//return true
				end
				self:DoMove()
			end
			if ( rotating ) then
				self:StartRotate()
				self:SetStage(2)
			else
				self:DoConstraint(mode)
			end
		end
	elseif ( stage == 2 ) then//Done rotate
		self:DoConstraint(mode)
	end
	return true
end

function TOOL:WithinABit( v1, v2 )
	local tol = 0.1
	local da = v1.x-v2.x
	local db = v1.y-v2.y
	local dc = v1.z-v2.z
	if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
		return true
	else
		da = v1.x+v2.x
		db = v1.y+v2.y
		dc = v1.z+v2.z
		if da < tol && da > -tol && db < tol && db > -tol && dc < tol && dc > -tol then
			return true
		else
			return false
		end
	end
end

if ( SERVER ) then
	
	function GetAllEnts( Ent, OrderedEntList, EntsTab, ConstsTab )
		if ( Ent and Ent:IsValid() ) and ( !EntsTab[ Ent:EntIndex() ] ) then
			EntsTab[ Ent:EntIndex() ] = Ent
			table.insert(OrderedEntList, Ent)
			if ( !constraint.HasConstraints( Ent ) ) then return OrderedEntList end
			for key, ConstraintEntity in pairs( Ent.Constraints ) do
				if ( !ConstsTab[ ConstraintEntity ] ) then
					ConstsTab[ ConstraintEntity ] = true
					local ConstTable = ConstraintEntity:GetTable()
					for i=1, 6 do
						local e = ConstTable[ "Ent"..i ]
						if ( e and e:IsValid() ) and ( !EntsTab[ e:EntIndex() ] ) then
							GetAllEnts( e, OrderedEntList, EntsTab, ConstsTab )
						end
					end
				end
			end
		end
		return OrderedEntList
	end
	
	function GetAllConstraints( EntsTab )
		local ConstsTab = {}
		for key, Ent in pairs( EntsTab ) do
			if ( Ent and Ent:IsValid() ) then
				local MyTable = constraint.GetTable( Ent )
				for key, Constraint in pairs( MyTable ) do
					if ( !ConstsTab[ Constraint.Constraint ] ) then
						ConstsTab[ Constraint.Constraint ] = Constraint
					end
				end
			end
		end
		return ConstsTab
	end
end

function TOOL:UpdateCustomGhost( ghost, player, offset )
	
	// Ghost is identically buggy to that of easyweld...  welding two frozen props and two unfrozen props yields different ghosts even if identical allignment

	if (ghost == nil) then return end
	if (!ghost:IsValid()) then ghost = nil return end

	local tr = util.GetPlayerTrace( player, player:GetAimVector() )
	local trace = util.TraceLine( tr )
	if (!trace.Hit) then return end

	local Ang1, Ang2 = self:GetNormal(1):Angle(), (trace.HitNormal * -1):Angle()
	local TargetAngle = self:GetEnt(1):AlignAngles( Ang1, Ang2 )

	self.GhostEntity:SetPos( self:GetEnt(1):GetPos() )
	
	if self:GetClientNumber( "autorotate" ) == 1 then
		TargetAngle.p = (math.Round(TargetAngle.p/45))*45
		TargetAngle.r = (math.Round(TargetAngle.r/45))*45
		TargetAngle.y = (math.Round(TargetAngle.y/45))*45
	end
	self.GhostEntity:SetAngles( TargetAngle )

	local TraceNormal = trace.HitNormal

	local offsetpercent		= self:GetClientNumber( "offsetpercent" ) == 1
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(TraceNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x) -0.5
		elseif self:WithinABit(TraceNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y) -0.5
		end
		NewOffset = NewOffset / 100
		NewOffset = NewOffset * height
	end

	local TranslatedPos = ghost:LocalToWorld( self:GetLocalPos(1) )
	local TargetPos = trace.HitPos + (self:GetEnt(1):GetPos() - TranslatedPos) + (TraceNormal*NewOffset)

	self.GhostEntity:SetPos( TargetPos )
end


function TOOL:Think()
	//if CLIENT then return end
	local pl = self:GetOwner()
	local wep = pl:GetActiveWeapon()
	if not wep:IsValid() or wep:GetClass() != "gmod_tool" or pl:GetInfo("gmod_toolmode") != "precision" then return end
		
	if (self:NumObjects() < 1) then return end
	local Ent1 = self:GetEnt(1)
	if ( SERVER ) then
		if ( !Ent1:IsValid() ) then
			self:ClearObjects()
			return
		end
	end
	local mode = self:GetClientNumber( "mode" )

	if self:NumObjects() == 1 && mode != 2 then
		if ( (self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
			if ( mode <= 8 ) then//no move = no ghost in parent mode
				local offset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )
				self:UpdateCustomGhost( self.GhostEntity, self:GetOwner(), offset )
			end
		end
	else
		local rotate = (self:GetClientNumber( "rotate" ) == 1 && mode != 1) || mode == 2
		if ( SERVER && rotate && mode <= 8 ) then
			local offset = math.Clamp( self:GetClientNumber( "offset" ), -5000, 5000 )

			local Phys1 = self:GetPhys(1)

			local cmd = self:GetOwner():GetCurrentCommand()

			local rotation		= self:GetClientNumber( "rotation" )
			if ( rotation < 0.02 ) then rotation = 0.02 end
			local degrees = cmd:GetMouseX() * 0.02

			local newdegrees = 0
			local changedegrees = 0

			local angle = 0
			if( self:GetOwner():KeyDown( IN_RELOAD ) ) then
				self.realdegreesY = self.realdegreesY + degrees
				newdegrees =  self.realdegreesY - ((self.realdegreesY + (rotation*0.5)) % rotation)
				changedegrees = self.lastdegreesY - newdegrees
				self.lastdegreesY = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisY , changedegrees )
			elseif( self:GetOwner():KeyDown( IN_ATTACK2 ) ) then
				self.realdegreesZ = self.realdegreesZ + degrees
				newdegrees =  self.realdegreesZ - ((self.realdegreesZ + (rotation*0.5)) % rotation)
				changedegrees = self.lastdegreesZ - newdegrees
				self.lastdegreesZ = newdegrees
				angle = Phys1:RotateAroundAxis( self.axisZ , changedegrees )
			else
				self.realdegrees = self.realdegrees + degrees
				newdegrees =  self.realdegrees - ((self.realdegrees + (rotation*0.5)) % rotation)
				changedegrees = self.lastdegrees - newdegrees
				self.lastdegrees = newdegrees
				angle = Phys1:RotateAroundAxis( self.axis , changedegrees )
			end
			Phys1:SetAngles( angle )

			if ( ( self:GetClientNumber( "move" ) == 1 && mode >= 3) || mode == 3 ) then
				local WPos2 = self:GetPos(2)
				local Ent2 = self:GetEnt(2)
				// Move so spots join up
				local Norm2 = self:GetNormal(2)

				local NewOffset = offset
				local offsetpercent	= self:GetClientNumber( "offsetpercent" ) == 1
				if ( offsetpercent ) then
					local glower = Ent2:OBBMins()
					local gupper = Ent2:OBBMaxs()
					local height = math.abs(gupper.z - glower.z) -0.5
					if self:WithinABit(Norm2,Ent2:GetForward()) then
						height = math.abs(gupper.x - glower.x) -0.5
					elseif self:WithinABit(Norm2,Ent2:GetRight()) then
						height = math.abs(gupper.y - glower.y) -0.5
					end
					NewOffset = NewOffset / 100
					NewOffset = NewOffset * height
				end

				Norm2 = Norm2 * (-0.0625 + NewOffset)
				local TargetPos = Vector(0,0,0)
				if ( self:GetEnt(1) == self:GetEnt(2) ) then
	//////////////////////////////////////////
					TargetPos = SavedPos + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				else
					TargetPos = WPos2 + (Phys1:GetPos() - self:GetPos(1)) + (Norm2)
				end
				Phys1:SetPos( TargetPos )
			else
				// Move so rotating on axis

				local TargetPos = (Phys1:GetPos() - self:GetPos(1)) + self.OldPos
				Phys1:SetPos( TargetPos )
			end
			Phys1:Wake()
		end
	end
end

function TOOL:Nudge( trace, direction )
	if (!trace.Entity:IsValid() || trace.Entity:IsPlayer() ) then return false end
	local Phys1 = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )
	local offsetpercent		= self:GetClientNumber( "nudgepercent" ) == 1
	local offset		= self:GetClientNumber( "nudge", 100 )
	local max = 8192
	if ( offsetpercent != 1 ) then
		if ( offset > max ) then
			offset = max
		elseif ( offset < -max ) then
			offset = -max
		end
	end
	//if ( offset == 0 ) then offset = 1 end
	local NewOffset = offset
	if ( offsetpercent ) then
		local glower = trace.Entity:OBBMins()
		local gupper = trace.Entity:OBBMaxs()
		local height = math.abs(gupper.z - glower.z) -0.5
		if self:WithinABit(trace.HitNormal,trace.Entity:GetForward()) then
			height = math.abs(gupper.x - glower.x)-0.5
		elseif self:WithinABit(trace.HitNormal,trace.Entity:GetRight()) then
			height = math.abs(gupper.y - glower.y)-0.5
		end
		NewOffset = NewOffset / 100
		local cap = math.floor(max / height)//No more than max units.
		if ( NewOffset > cap ) then
			NewOffset = cap
		elseif ( NewOffset < -cap ) then
			NewOffset = -cap
		end
		NewOffset = NewOffset * height
	end

	if ( self:GetClientNumber( "entirecontrap" ) == 1 ) then
		local NumApp = 0
		local TargetEnts = {}
		local EntsTab = {}
		local ConstsTab = {}
		GetAllEnts(trace.Entity, TargetEnts, EntsTab, ConstsTab)
		for key,CurrentEnt in pairs(TargetEnts) do
			if ( CurrentEnt and CurrentEnt:IsValid() ) then
				local CurrentPhys = CurrentEnt:GetPhysicsObject()
				if ( CurrentPhys:IsValid() ) then

					/*if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
						local oldpos = CurrentPhys:GetPos()
						local function NudgeUndo( Undo, Entity, oldpos )
							if CurrentEnt:IsValid() then
								CurrentEnt:SetPos( oldpos )
							end
						end
						undo.Create("Nrecision Nudge")
							undo.SetPlayer(self:GetOwner())
							undo.AddFunction( NudgeUndo, CurrentEnt, oldpos )
						undo.Finish()
					end*/// todo: all in 1 undo for mass nudging

					local TargetPos = CurrentPhys:GetPos() + trace.HitNormal * NewOffset * direction
					CurrentPhys:SetPos( TargetPos )
					CurrentPhys:Wake()
					if (CurrentEnt:GetMoveType() == 0 ) then //phys disabled, so move manually
						CurrentEnt:SetPos( TargetPos )
					end

				end
			end
			NumApp = NumApp + 1
		end
		if ( direction == -1 ) then
			self:SendMessage( NumApp .. " items pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( NumApp .. " items pulled." )
		else
			self:SendMessage( NumApp .. " items nudged." )
		end
	else
		if ( self:GetClientNumber( "nudgeundo" ) == 1 ) then
			local oldpos = Phys1:GetPos()
			local function NudgeUndo( Undo, Entity, oldpos )
				if trace.Entity:IsValid() then
					trace.Entity:SetPos( oldpos )
				end
			end
			undo.Create("Precision PushPull")
				undo.SetPlayer(self:GetOwner())
				undo.AddFunction( NudgeUndo, trace.Entity, oldpos )
			undo.Finish()
		end
		if not IsValid(Phys1) then return end
		local TargetPos = Phys1:GetPos() + trace.HitNormal * NewOffset * direction
		Phys1:SetPos( TargetPos )
		Phys1:Wake()
		if ( trace.Entity:GetMoveType() == 0 ) then
			trace.Entity:SetPos( TargetPos )
		end
		if ( direction == -1 ) then
			self:SendMessage( "target pushed." )
		elseif ( direction == 1 ) then
			self:SendMessage( "target pulled." )
		else
			self:SendMessage( "target nudged." )
		end
	end
	return true
end

function TOOL:RightClick( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, -1 )
	end
end

function TOOL:Reload( trace )
	local rotate = self:GetClientNumber( "rotate" ) == 1
	local mode = self:GetClientNumber( "mode" )
	if ( (mode == 2 && self:NumObjects() == 1) || (rotate && self:NumObjects() == 2 ) ) then
		if ( CLIENT ) then return false end
	else
		if ( CLIENT ) then return true end
		return self:Nudge( trace, 1 )
	end
end

if CLIENT then

	language.Add( "Tool.precision.name", "Precision Tool 0.98e" )
	language.Add( "Tool.precision.desc", "Більш легке та акуратне будівництво" )
	language.Add( "Tool.precision.0", "Primary: Передвинути/Примінити | Secondary: Штовхати | Reload: Притягувати" )
	language.Add( "Tool.precision.1", "Натисніть ще кудись, щоб застосувати інструмент. (Змініть зброю для скасування)" )
	language.Add( "Tool.precision.2", "Повертайте вправо та вліво для крутіння (Утримуйте ПКМ та R для зміни осей)" )


	language.Add("Undone.precision", "Undone Precision Constraint")
	language.Add("Undone.precision.nudge", "Undone Precision PushPull")
	language.Add("Undone.precision.rotate", "Undone Precision Rotate")
	language.Add("Undone.precision.move", "Undone Precision Move")
	language.Add("Undone.precision.weld", "Undone Precision Weld")
	language.Add("Undone.precision.axis", "Undone Precision Axis")
	language.Add("Undone.precision.ballsocket", "Undone Precision Ballsocket")
	language.Add("Undone.precision.advanced.ballsocket", "Undone Precision Advanced Ballsocket")
	language.Add("Undone.precision.slider", "Undone Precision Slider")

	local showgenmenu = 0//Seems to hide often, probably for the best

	local function AddDefControls( Panel )
		Panel:ClearControls()

		Panel:AddControl("ComboBox",
		{
			Label = "#Presets",
			MenuButton = 1,
			Folder = "precision",
			Options = {},
			CVars =
			{
				[0] = "precision_offset",
				[1] = "precision_forcelimit",
				[2] = "precision_freeze",
				[3] = "precision_nocollide",
				[4] = "precision_nocollideall",
				[5] = "precision_rotation",
				[6] = "precision_rotate",
				[7] = "precision_torquelimit",
				[8] = "precision_friction",
				[9] = "precision_mode",
				[10] = "precision_width",
				[11] = "precision_offsetpercent",
				[12] = "precision_removal",
				[13] = "precision_move",
				[14] = "precision_physdisable",
				[15] = "precision_advballsocket",
				[16] = "precision_XRotMin",
				[17] = "precision_XRotMax",
				[18] = "precision_YRotMin",
				[19] = "precision_YRotMax",
				[20] = "precision_ZRotMin",
				[21] = "precision_ZRotMax",
				[22] = "precision_XRotFric",
				[23] = "precision_YRotFric",
				[24] = "precision_ZRotFric",
				[25] = "precision_FreeMov",
				[26] = "precision_ShadowDisable",
				[27] = "precision_allowphysgun",
				[28] = "precision_autorotate",
				[29] = "precision_massmode",
				[30] = "precision_nudge",
				[31] = "precision_nudgepercent",
				[32] = "precision_disablesliderfix"
			}
		})

		//Panel:AddControl( "Label", { Text = "Secondary attack pushes, Reload pulls by this amount:", Description	= "Phx 1x is 47.45, Small tiled cube is 11.8625 and thin is 3 exact units" }  )
		Panel:AddControl( "Slider",  { Label	= "Сила толк/прит",
					Type	= "Float",
					Min		= 1,
					Max		= 100,
					Command = "precision_nudge",
					Description = "Distance to push/pull props with altfire/reload"}	 ):SetDecimals( 4 )


		Panel:AddControl( "Checkbox", { Label = "Штовхання/Притягування у відсотках", Command = "precision_nudgepercent", Description = "Unchecked = Exact units, Checked = takes % of width from target prop when pushing/pulling" } )


		local user = LocalPlayer():GetInfoNum( "precision_user", 0 )
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 0 )
		//Panel:AddControl( "Label", { Text = "Primary attack uses the tool's main mode.", Description	= "Select a mode and configure the options, be sure to try new things out!" }  )

		-- local list = vgui.Create("DListView")

		//17 per item + 16 for title
		local height = 203 //All 11 shown
		if ( user < 2 ) then
			height = 135 //7 shown
		elseif ( user < 3 ) then
			height = 170 //9 shown
		end


	end



	local function precision_defaults()
		local mode = LocalPlayer():GetInfoNum( "precision_mode", 3 )
		if mode  == 1 then
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_ShadowDisable", "0")
			RunConsoleCommand("precision_nocollideall", "0")
			RunConsoleCommand("precision_physdisable", "0")
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 2 then
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 3 then
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "1")
			RunConsoleCommand("precision_entirecontrap", "0")
		elseif mode == 4 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
		elseif mode == 5 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_friction", "0")
		elseif mode == 6 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
		elseif mode == 7 then
			RunConsoleCommand("precision_move", "0")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "1")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_forcelimit", "0")
			RunConsoleCommand("precision_torquelimit", "0")
			RunConsoleCommand("precision_XRotMin", "0")
			RunConsoleCommand("precision_XRotMax", "0")
			RunConsoleCommand("precision_YRotMin", "0")
			RunConsoleCommand("precision_YRotMax", "0")
			RunConsoleCommand("precision_ZRotMin", "0")
			RunConsoleCommand("precision_ZRotMax", "0")
			RunConsoleCommand("precision_XRotFric", "0")
			RunConsoleCommand("precision_YRotFric", "0")
			RunConsoleCommand("precision_ZRotFric", "0")
			RunConsoleCommand("precision_FreeMov", "1")
		elseif mode == 8 then
			RunConsoleCommand("precision_move", "1")
			RunConsoleCommand("precision_rotate", "1")
			RunConsoleCommand("precision_offset", "0")
			RunConsoleCommand("precision_offsetpercent", "1")
			RunConsoleCommand("precision_rotation", "15")
			RunConsoleCommand("precision_freeze", "1")
			RunConsoleCommand("precision_nocollide", "0")
			RunConsoleCommand("precision_autorotate", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
			RunConsoleCommand("precision_width", "1")
			RunConsoleCommand("precision_disablesliderfix", "0")
		elseif mode == 9 then
			RunConsoleCommand("precision_allowphysgun", "0")
			RunConsoleCommand("precision_entirecontrap", "0")
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_defaultrestore", precision_defaults )

	local function precision_genmenu()
		if ( showgenmenu == 1 ) then
			showgenmenu = 0
		else
			showgenmenu = 1
		end
		precision_updatecpanel()
	end
	concommand.Add( "precision_generalmenu", precision_genmenu )
	

	function precision_setmode( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_mode", 3 ) != args[1] then
			RunConsoleCommand("precision_mode", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setmode", precision_setmode )


	function precision_setuser( player, tool, args )
		if LocalPlayer():GetInfoNum( "precision_user", 3 ) != args[1] then
			RunConsoleCommand("precision_user", args[1])
			timer.Simple(0.05, function() precision_updatecpanel() end ) 
		end
	end
	concommand.Add( "precision_setuser", precision_setuser )


	function precision_updatecpanel()
		local Panel = controlpanel.Get( "precision" )
		if (!Panel) then return end
		//custom panel building ( wtf does Panel:AddDefaultControls() get it's defaults from? )
		AddDefControls( Panel )
	end
	concommand.Add( "precision_updatecpanel", precision_updatecpanel )

	function TOOL.BuildCPanel( Panel )
		AddDefControls( Panel )
	end

	local function precision_removalall()
		RunConsoleCommand("precision_removal_nocollide", "1")
		RunConsoleCommand("precision_removal_weld", "1")
		RunConsoleCommand("precision_removal_axis", "1")
		RunConsoleCommand("precision_removal_ballsocket", "1")
		RunConsoleCommand("precision_removal_advballsocket", "1")
		RunConsoleCommand("precision_removal_slider", "1")
		RunConsoleCommand("precision_removal_parent", "1")
		RunConsoleCommand("precision_removal_other", "1")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_all", precision_removalall )
	local function precision_removalnone()
		RunConsoleCommand("precision_removal_nocollide", "0")
		RunConsoleCommand("precision_removal_weld", "0")
		RunConsoleCommand("precision_removal_axis", "0")
		RunConsoleCommand("precision_removal_ballsocket", "0")
		RunConsoleCommand("precision_removal_advballsocket", "0")
		RunConsoleCommand("precision_removal_slider", "0")
		RunConsoleCommand("precision_removal_parent", "0")
		RunConsoleCommand("precision_removal_other", "0")
		precision_updatecpanel()
	end
	concommand.Add( "precision_removal_none", precision_removalnone )

	function TOOL:FreezeMovement()
		local stage = self:GetStage()
		if ( stage == 2 ) then
			return true
		//elseif ( iNum > 0 && self:GetClientNumber("mode") == 2 ) then
		//	return true
		end
		return false
	end
end

function TOOL:Holster()
	self:ClearObjects()
	self:SetStage(0)
	self:ClearSelection()
end

function TOOL:DrawToolScreen(width, height)

	if SERVER then return end

	surface.SetDrawColor(17, 148, 240, 255)
	surface.DrawRect(0, 0, 256, 256)

	surface.SetFont("Roboto_40")
	local w, h = surface.GetTextSize(" ")
	surface.SetFont("Roboto_40")
	local w2, h2 = surface.GetTextSize(" ")

	rp.ShadowText("Штовхай пропи", "Roboto_40", 128, 100, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)
	rp.ShadowText("Красавчик)", "Roboto_40", 128, 128 + (h + h2) * 0.5 - 4, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)

end
--PATH addons/_ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )
--------------------- BALLISTIC SHIELDS V1.1.9 -------------------------
---- CONFIG ----
-- AVALAIBLE LANGUAGES - English, German, French, Danish, Turkish, Ukrainian
bshields.config.language = "Ukrainian"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 10
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 10
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 50
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 20
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 30
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 1
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = true
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false
-- REMOVE DEPLOYED SHIELDS ON JOB CHANGE
bshields.config.removeonjobchange = true
-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---
-- HEAVY SHIELD
bshields.config.hShieldTexture = ""
-- RIOT SHIELD
bshields.config.rShieldTexture = ""
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = ""
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---
-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = false
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_lang.lua:
include( "ballistic_shields/sh_bs_util.lua" )
bshields.lang = {
	["English"] = {
		["sec"] = "[RMB] VISIBILITY",
		["dshieldprim"] = "[LMB] DEPLOY",
		["hshieldprim"] = "[LMB] BREACH DOOR",
		["rshieldprim"] = "[LMB] ATTACK",
		["hshieldcd1"] = "Wait ",
		["hshieldcd2"] = " seconds to breach next door!"
	},
	["German"] = {
		["sec"] = "[RMB] SICHTBARKEIT",
		["dshieldprim"] = "[LMB] PLAZIEREN",
		["hshieldprim"] = "[LMB] TÜR AUFBRECHEN",
		["rshieldprim"] = "[LMB] ANGREIFEN",
		["hshieldcd1"] = "Warte ",
		["hshieldcd2"] = " Sekunden für das Aufbrechen der nächsten Tür!"
	},
	["French"] = {
		["sec"] = "[RMB] VISIBILITÉ",
		["dshieldprim"] = "[LMB] DÉPLOYER",
		["hshieldprim"] = "[LMB] FORCER LA PORTE",
		["rshieldprim"] = "[LMB] ATTAQUER",
		["hshieldcd1"] = "Attendez ",
		["hshieldcd2"] = " secondes pour forcer la porte !"
	},
	["Danish"] = {
		["sec"] = "[RMB] SIGTBARHED",
		["dshieldprim"] = "[LMB] SÆT",
		["hshieldprim"] = "[LMB] BREACH DØR",
		["rshieldprim"] = "[LMB] ANGRIB",
		["hshieldcd1"] = "Vent ",
		["hshieldcd2"] = " sekunder at bryde ved siden af!"
	},
	["Turkish"] = {
		["sec"] = "[RMB] GORUNURLUK",
		["dshieldprim"] = "[LMB] YERLESTIR",
		["hshieldprim"] = "[LMB] BREACH DOOR",
		["rshieldprim"] = "[LMB] SALDIR",
		["hshieldcd1"] = "Bekle ",
		["hshieldcd2"] = " bir sonraki kapıyı kırmaya saniye kaldı!"
	},
	["Russian"] = {
		["sec"] = "[ПКМ] ВИДИМОСТЬ",
		["dshieldprim"] = "[ЛКМ] ПОСТАВИТЬ",
		["hshieldprim"] = "[ЛКМ] ВЫБИТЬ ДВЕРЬ",
		["rshieldprim"] = "[ЛКМ] УДАРИТЬ",
		["hshieldcd1"] = "Подождите ",
		["hshieldcd2"] = " секунд чтоб выбить дверь!"
	},
	["Ukrainian"] = {
		["sec"] = "[ПКМ] ВИДИМІСТЬ",
		["dshieldprim"] = "[ЛКМ] ПОСТАВИТИ",
		["hshieldprim"] = "[ЛКМ] ВИБИТИ ДВЕРІ",
		["rshieldprim"] = "[ЛКМ] ВДАРИТИ",
		["hshieldcd1"] = "Зачекайте ",
		["hshieldcd2"] = " секунд щоб вибити двері!"
	}
}

if bshields.lang[bshields.config.language] == nil then bshields.config.language = "English" end
--PATH addons/__main/lua/weapons/m4_guitar/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m4_guitar") -- must be the name of your swep but NO CAPITALS!
SWEP.Category				= "CSO/CF Weapons" --Category where you will find your weapons
SWEP.Author				= "Zekeou"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "Lightning AR-1 Guitar"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 3			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox		= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   	= false		-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight					= 30		-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg makes for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_smg_lmp.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_rif_m4a1.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= false
SWEP.Base				= "zekeou_gun_base" --the Base this weapon will work on. PLEASE RENAME THE BASE! 
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("weapons/MP5_Guitar/Guitar Fire.wav")		-- Script that calls the primary fire sound
SWEP.Primary.SilencedSound 	= Sound("")		-- Sound if the weapon is silenced
SWEP.Primary.RPM			= 700			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. 
--Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true
SWEP.CanBeSilenced		= false

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 25	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(6, -16.587, 2.039)
SWEP.IronSightsAng = Vector(1.378, 0, 7.44)
SWEP.SightsPos = Vector(6, -16.587, 2.039)
SWEP.SightsAng = Vector(1.378, 0, 7.44)
SWEP.RunSightsPos = Vector(0,0,0)	--These are for the angles your viewmodel will be when running
SWEP.RunSightsAng = Vector(0,0,0)	--Again, use the Swep Construction Kit

SWEP.WElements = {
	["M4_Guitar"] = { type = "Model", model = "models/weapons/w_smg_lmp.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(-2.8, 0.402, 0.857), angle = Angle(-2.174, 0.782, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

--PATH addons/__main/lua/weapons/m9k_famas/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_famas") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "FAMAS"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 29			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_tct_famas.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_tct_famas.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_FAMTC.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 950			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.4		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.4		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "ar2"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 29	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-3.342, 0, 0.247)
SWEP.IronSightsAng = Vector(0, -0.438, 0)
SWEP.SightsPos = Vector(-3.342, 0, 0.247)
SWEP.SightsAng = Vector(0, -0.438, 0)
SWEP.RunSightsPos = Vector (0.9926, -3.6313, 0.4169)
SWEP.RunSightsAng = Vector (-9.1165, 43.8507, -18.2067)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_m16a4_acog/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_m16a4_acog") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= "iron angles and models hexed and converted to gmod my Mr Fokkusu"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "M16A4 ACOG"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 35			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- Set false if you want no crosshair from hip
SWEP.Weight				= 30			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.XHair					= true		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_M16_acog.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_dmg_m16ag.mdl"	-- Weapon world model
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("Dmgfok_M16A4.Single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 850		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip			= 60	-- Bullets you start with
SWEP.Primary.KickUp			= .4				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .4			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= .6		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "ar2"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets
SWEP.SelectiveFire		= true

SWEP.Secondary.ScopeZoom			= 4	
SWEP.Secondary.UseACOG			= true -- Choose one scope type
SWEP.Secondary.UseMilDot		= false	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	

SWEP.data 				= {}
SWEP.data.ironsights			= 1
SWEP.ScopeScale 			= 0.5
SWEP.ReticleScale 				= 0.6

SWEP.Primary.NumShots	= 1		--how many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 30	--base damage per bullet
SWEP.Primary.Spread		= .015	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .01 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below

SWEP.IronSightsPos = Vector (2.275, -2.9708, 0.5303)
SWEP.IronSightsAng = Vector (0, 0, 0)
SWEP.SightsPos = Vector (2.275, -2.9708, 0.5303)
SWEP.SightsAng = Vector (0, 0, 0)
SWEP.RunSightsPos = Vector (-3.0328, 0, 1.888)
SWEP.RunSightsAng = Vector (-24.2146, -36.522, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main/lua/weapons/m9k_scoped_taurus/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_scoped_taurus") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "Raging Bull - Scoped"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 32			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- Set false if you want no crosshair from hip
SWEP.Weight				= 30			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.XHair					= true		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "revolver"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_raging_bull_scoped.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_raging_bull_scoped.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("weapon_r_bull.single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 115		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 6		-- Size of a clip
SWEP.Primary.DefaultClip			= 30	-- Bullets you start with
SWEP.Primary.KickUp			= 10				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .5			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "357"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 3
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= true	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false

SWEP.data 				= {}
SWEP.data.ironsights			= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 				= 0.6

SWEP.Primary.Damage		= 31	--base damage per bullet
SWEP.Primary.Spread		= .02	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .0001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.773, 0, 0.846)
SWEP.IronSightsAng = Vector(-0.157, 0, 0)
SWEP.SightsPos = Vector(2.773, 0, 0.846)
SWEP.SightsAng = Vector(-0.157, 0, 0)
SWEP.RunSightsPos = Vector(0, 2.95, 0)
SWEP.RunSightsAng = Vector(-13.197, 5.737, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/__main_only_1st/lua/weapons/mhs_weapon_base.lua:
-----------------------------------------------------
AddCSLuaFile()
--i need faster swep-made ;d
if CLIENT then
	SWEP.PrintName = "Base"
	SWEP.Author = ""
	SWEP.Slot = 4
	SWEP.SlotPos = 1
end

SWEP.Spawnable = true
SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false
SWEP.DrawCrosshair = false
SWEP.ViewModel = ""
SWEP.WorldModel = ""
SWEP.DrawAmmo = false
SWEP.Weight = 10
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.UseHands = true
SWEP.HoldType = ""
function SWEP:PrimaryAttack()
end

function SWEP:SecondaryAttack()
end

if CLIENT then
	SWEP.ViewModelBoneMods = {}
	SWEP.VElements = {}
	SWEP.WElements = {}
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	if CLIENT then
		self.VElements = table.Copy( self.VElements )
		self.WElements = table.Copy( self.WElements )
		self.ViewModelBoneMods = table.Copy( self.ViewModelBoneMods )
		self:CreateModels( self.VElements )
		self:CreateModels( self.WElements )
		if IsValid( self:GetOwner() ) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid( vm ) then self:ResetBonePositions( vm ) end
		end
	end
end

function SWEP:PreDrawViewModel( vm )
	if not ( self.ShowViewModel == nil or self.ShowViewModel ) then vm:SetMaterial( "engine/occlusionproxy" ) end
end

function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
end

function SWEP:Holster()
	if CLIENT and IsValid( self:GetOwner() ) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid( vm ) then
			self:ResetBonePositions( vm )
			vm:SetMaterial( "" )
		end
	end
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		--print(1, self.VElements)
		local vm = self:GetOwner():GetViewModel()
		if not IsValid( vm ) then return end
		if not self.VElements then return end
		self:UpdateBonePositions( vm )
		if not self.vRenderOrder then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k, v in pairs( self.VElements ) do
				if v.type == "Model" then
					table.insert( self.vRenderOrder, 1, k )
				elseif v.type == "Sprite" or v.type == "Quad" then
					table.insert( self.vRenderOrder, k )
				end
			end
		end

		for _, name in ipairs( self.vRenderOrder ) do
			local v = self.VElements[name]
			if not v then
				self.vRenderOrder = nil
				break
			end

			if v.hide then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if not v.bone then continue end
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			if not pos then continue end
			if v.type == "Model" and IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				if v.material == "" then
					model:SetMaterial( "" )
				elseif model:GetMaterial() ~= v.material then
					model:SetMaterial( v.material )
				end

				if v.skin and v.skin ~= model:GetSkin() then model:SetSkin( v.skin ) end
				if v.bodygroup then
					for k, v in pairs( v.bodygroup ) do
						if model:GetBodygroup( k ) ~= v then model:SetBodygroup( k, v ) end
					end
				end

				if v.surpresslightning then render.SuppressEngineLighting( true ) end
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( ( v.color.a or 255 ) / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
				if v.surpresslightning then render.SuppressEngineLighting( false ) end
			elseif v.type == "Sprite" and sprite then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial( sprite )
				render.DrawSprite( drawpos, v.size.x, v.size.y, v.color )
			elseif v.type == "Quad" and v.draw_func then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				cam.Start3D2D( drawpos, ang, v.size )
				v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		if self.ShowWorldModel == nil or self.ShowWorldModel then self:DrawModel() end
		if not self.WElements then return end
		if not self.wRenderOrder then
			self.wRenderOrder = {}
			for k, v in pairs( self.WElements ) do
				if v.type == "Model" then
					table.insert( self.wRenderOrder, 1, k )
				elseif v.type == "Sprite" or v.type == "Quad" then
					table.insert( self.wRenderOrder, k )
				end
			end
		end

		if IsValid( self:GetOwner() ) then
			bone_ent = self:GetOwner()
		else
			-- when the weapon is dropped
			bone_ent = self
		end

		for _, name in pairs( self.wRenderOrder ) do
			local v = self.WElements[name]
			if not v then
				self.wRenderOrder = nil
				break
			end

			if v.hide then continue end
			local pos, ang
			if v.bone then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end

			if not pos then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if v.type == "Model" and IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				if v.material == "" then
					model:SetMaterial( "" )
				elseif model:GetMaterial() ~= v.material then
					model:SetMaterial( v.material )
				end

				if v.skin and v.skin ~= model:GetSkin() then model:SetSkin( v.skin ) end
				if v.bodygroup then
					for k, v in pairs( v.bodygroup ) do
						if model:GetBodygroup( k ) ~= v then model:SetBodygroup( k, v ) end
					end
				end

				if v.surpresslightning then render.SuppressEngineLighting( true ) end
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
				if v.surpresslightning then render.SuppressEngineLighting( false ) end
			elseif v.type == "Sprite" and sprite then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial( sprite )
				render.DrawSprite( drawpos, v.size.x, v.size.y, v.color )
			elseif v.type == "Quad" and v.draw_func then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				cam.Start3D2D( drawpos, ang, v.size )
				v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		local bone, pos, ang
		if tab.rel and tab.rel ~= "" then
			local v = basetab[tab.rel]
			if not v then return end
			-- Technically, if there exists an element with the same name as a bone
			-- you can get in an infinite loop. Let"s just hope nobody"s that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			if not pos then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis( ang:Up(), v.angle.y )
			ang:RotateAroundAxis( ang:Right(), v.angle.p )
			ang:RotateAroundAxis( ang:Forward(), v.angle.r )
		else
			bone = ent:LookupBone( bone_override or tab.bone )
			if not bone then return end
			pos, ang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
			local m = ent:GetBoneMatrix( bone )
			if m then pos, ang = m:GetTranslation(), m:GetAngles() end
			if IsValid( self:GetOwner() ) and self:GetOwner():IsPlayer() and ent == self:GetOwner():GetViewModel() and self.ViewModelFlip then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if not tab then return end
		-- Create the clientside models here because Garry says we can"t do it in the render hook
		for _, v in pairs( tab ) do
			if v.type == "Model" and v.model and v.model ~= "" and ( not IsValid( v.modelEnt ) or v.createdModel ~= v.model ) and string.find( v.model, ".mdl" ) and file.Exists( v.model, "GAME" ) then
				v.modelEnt = ClientsideModel( v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE )
				if IsValid( v.modelEnt ) then
					v.modelEnt:SetPos( self:GetPos() )
					v.modelEnt:SetAngles( self:GetAngles() )
					v.modelEnt:SetParent( self )
					v.modelEnt:SetNoDraw( true )
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif v.type == "Sprite" and v.sprite and v.sprite ~= "" and ( not v.spriteMaterial or v.createdSprite ~= v.sprite ) and file.Exists( "materials/" .. v.sprite .. ".vmt", "GAME" ) then
				local name = v.sprite .. "-"
				local params = {
					["$basetexture"] = v.sprite
				}

				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for _, j in pairs( tocheck ) do
					if v[j] then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial( name, "UnlitGeneric", params )
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false
	function SWEP:UpdateBonePositions( vm )
		if self.ViewModelBoneMods then
			if not vm:GetBoneCount() then return end
			-- !! WORKAROUND !! //
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if not hasGarryFixedBoneScalingYet then
				allbones = {}
				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName( i )
					if self.ViewModelBoneMods[bonename] then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector( 1, 1, 1 ),
							pos = Vector( 0, 0, 0 ),
							angle = Angle( 0, 0, 0 )
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! //
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone( k )
				if not bone then continue end
				-- !! WORKAROUND !! //
				local s = Vector( v.scale.x, v.scale.y, v.scale.z )
				local p = Vector( v.pos.x, v.pos.y, v.pos.z )
				local ms = Vector( 1, 1, 1 )
				if not hasGarryFixedBoneScalingYet then
					local cur = vm:GetBoneParent( bone )
					while cur >= 0 do
						local pscale = loopthrough[vm:GetBoneName( cur )].scale
						ms = ms * pscale
						cur = vm:GetBoneParent( cur )
					end
				end

				s = s * ms
				-- !! ----------- !! //
				if vm:GetManipulateBoneScale( bone ) ~= s then vm:ManipulateBoneScale( bone, s ) end
				if vm:GetManipulateBoneAngles( bone ) ~= v.angle then vm:ManipulateBoneAngles( bone, v.angle ) end
				if vm:GetManipulateBonePosition( bone ) ~= p then vm:ManipulateBonePosition( bone, p ) end
			end
		else
			self:ResetBonePositions( vm )
		end
	end

	function SWEP:ResetBonePositions( vm )
		if not vm:GetBoneCount() then return end
		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector( 1, 1, 1 ) )
			vm:ManipulateBoneAngles( i, Angle( 0, 0, 0 ) )
			vm:ManipulateBonePosition( i, Vector( 0, 0, 0 ) )
		end
	end
end
--PATH addons/__main/lua/weapons/microwave_gun.lua:
if CLIENT then
	SWEP.PrintName = "Microwave Cannon"
	SWEP.Slot = 2
	SWEP.SlotPos = 1
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = true
	SWEP.WepSelectIcon = surface.GetTextureID( "weapons/microwave_gun_icon" )
	SWEP.BounceWeaponIcon = false
	SWEP.VElements = {
		["view_microwave_gun"] = {
			model = "models/crazy_thing/w_microwave_gun.mdl",
			bone = "ValveBiped.Bip01",
			pos = Vector( -3.595, -24.75, 16 ),
			angle = Angle( -92.331, 0.312, -89.848 ),
			size = Vector( 1.055, 1.055, 1.055 ),
			color = Color( 255, 255, 255, 255 )
		}
	}

	SWEP.WElements = {
		["world_microwave_cannon"] = {
			model = "models/crazy_thing/w_microwave_gun.mdl",
			bone = "ValveBiped.Bip01_R_Hand",
			pos = Vector( 22.09, 1.2, -8.346 ),
			angle = Angle( 175.024, 2.16, 0 ),
			size = Vector( 0.931, 0.931, 0.931 ),
			color = Color( 255, 255, 255, 255 )
		}
	}
end

SWEP.Base = "weapon_base"
SWEP.Category = "Weapons"
SWEP.Author = "Dmitriy_Domosed"
SWEP.Instructions = "Reheat food and irradiate people"
SWEP.HoldType = "shotgun"
SWEP.Spawnable = true
SWEP.AdminOnly = false
SWEP.ViewModelFlip = false
SWEP.ViewModelFOV = 70
SWEP.UseHands = false
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = true
SWEP.ViewModel = "models/weapons/v_shotgun.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01"] = {
		scale = Vector( 0.98, 0.98, 0.98 ),
		pos = Vector( 0.509, 0, 0 ),
		angle = Angle( 0, 0, 0 )
	}
}

SWEP.IronSightsPos = Vector( 0, 0, 0 )
SWEP.IronSightsAng = Vector( 0, 0, 0 )
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Recoil = 0
SWEP.Primary.Damage = 25
SWEP.Primary.NumShots = 1
SWEP.Primary.Spread = 0.2
SWEP.Primary.Cone = 0.2
SWEP.Primary.Delay = 0.35
SWEP.Primary.Force = 0
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
function SWEP:Deploy()
	if CLIENT then return true end
	self.PowerOn = CreateSound( self:GetOwner(), Sound( "crazy_thing/cannonisready.wav" ) )
	if self.PowerOn then
		self.PowerOn:Play()
		return
	end
end

function SWEP:KillSounds()
	if self.PowerOn then
		self.PowerOn:Stop()
		self.PowerOn = nil
	end

	local owner = self:GetOwner()
	if IsValid( owner ) then
		self.PowerDown = CreateSound( owner, Sound( "crazy_thing/cannon_shutting_down.wav" ) )
		if self.PowerDown then self.PowerDown:Play() end
	end
end

function SWEP:OnDrop()
	self:KillSounds()
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	if CLIENT then
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:CreateModels( self.VElements ) -- create viewmodels
		self:CreateModels( self.WElements ) -- create worldmodels
		-- init view model bone build function
		local owner = self:GetOwner()
		if IsValid( owner ) then
			local vm = owner:GetViewModel()
			if IsValid( vm ) then
				self:ResetBonePositions( vm )
				-- Init viewmodel visibility
				if self.ShowViewModel == nil or self.ShowViewModel then
					vm:SetColor( color_white )
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor( Color( 255, 255, 255, 1 ) )
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial( "Debug/hsv" )
				end
			end
		end
	end
end

function SWEP:Holster()
	local owner = self:GetOwner()
	if CLIENT and IsValid( owner ) then
		local vm = owner:GetViewModel()
		if IsValid( vm ) then self:ResetBonePositions( vm ) end
	end

	self:KillSounds()
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid( vm ) then return end
		if not self.VElements then return end
		self:UpdateBonePositions( vm )
		if not self.vRenderOrder then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k in pairs( self.VElements ) do
				table.insert( self.vRenderOrder, 1, k )
			end
		end

		for _, name in ipairs( self.vRenderOrder ) do
			local v = self.VElements[name]
			if not v then
				self.vRenderOrder = nil
				break
			end

			if v.hide then continue end
			local model = v.modelEnt
			if not v.bone then continue end
			local pos, ang = self:GetBoneOrientation( v, vm )
			if not pos then continue end
			if IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				--
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
			end
		end
	end

	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		if self.ShowWorldModel == nil or self.ShowWorldModel then self:DrawModel() end
		if not self.WElements then return end
		if not self.wRenderOrder then
			self.wRenderOrder = {}
			for k in pairs( self.WElements ) do
				table.insert( self.wRenderOrder, 1, k )
			end
		end

		local owner = self:GetOwner()
		if IsValid( owner ) then
			bone_ent = owner
		else
			-- when the weapon is dropped
			bone_ent = self
		end

		for _, name in ipairs( self.wRenderOrder ) do
			local v = self.WElements[name]
			if not v then
				self.wRenderOrder = nil
				break
			end

			if v.hide then continue end
			local pos, ang
			if v.bone then
				pos, ang = self:GetBoneOrientation( v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end

			if not pos then continue end
			local model = v.modelEnt
			if IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				--
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
			end
		end
	end

	function SWEP:GetBoneOrientation( tab, ent, bone_override )
		local bone, pos, ang
		bone = ent:LookupBone( bone_override or tab.bone )
		if not bone then return end
		pos, ang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
		local m = ent:GetBoneMatrix( bone )
		if m then pos, ang = m:GetTranslation(), m:GetAngles() end
		local owner = self:GetOwner()
		if IsValid( owner ) and owner:IsPlayer() and ent == owner:GetViewModel() and self.ViewModelFlip then
			ang.r = -ang.r -- Fixes mirrored models
		end
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if not tab then return end
		-- Create the clientside models here because Garry says we can't do it in the render hook
		for _, v in pairs( tab ) do
			if v.model and v.model ~= "" and ( not IsValid( v.modelEnt ) or v.createdModel ~= v.model ) and string.find( v.model, ".mdl" ) and file.Exists( v.model, "GAME" ) then
				v.modelEnt = ClientsideModel( v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE )
				if IsValid( v.modelEnt ) then
					v.modelEnt:SetPos( self:GetPos() )
					v.modelEnt:SetAngles( self:GetAngles() )
					v.modelEnt:SetParent( self )
					v.modelEnt:SetNoDraw( true )
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false
	function SWEP:UpdateBonePositions( vm )
		if self.ViewModelBoneMods then
			if not vm:GetBoneCount() then return end
			-- !! WORKAROUND !! //
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if not hasGarryFixedBoneScalingYet then
				allbones = {}
				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName( i )
					if self.ViewModelBoneMods[bonename] then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector( 1, 1, 1 ),
							pos = Vector( 0, 0, 0 ),
							angle = Angle( 0, 0, 0 )
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! //
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone( k )
				if not bone then continue end
				-- !! WORKAROUND !! //
				local s = Vector( v.scale.x, v.scale.y, v.scale.z )
				local p = Vector( v.pos.x, v.pos.y, v.pos.z )
				local ms = Vector( 1, 1, 1 )
				if not hasGarryFixedBoneScalingYet then
					local cur = vm:GetBoneParent( bone )
					while cur >= 0 do
						local pscale = loopthrough[vm:GetBoneName( cur )].scale
						ms = ms * pscale
						cur = vm:GetBoneParent( cur )
					end
				end

				s = s * ms
				-- !! ----------- !! //
				if vm:GetManipulateBoneScale( bone ) ~= s then vm:ManipulateBoneScale( bone, s ) end
				if vm:GetManipulateBoneAngles( bone ) ~= v.angle then vm:ManipulateBoneAngles( bone, v.angle ) end
				if vm:GetManipulateBonePosition( bone ) ~= p then vm:ManipulateBonePosition( bone, p ) end
			end
		else
			self:ResetBonePositions( vm )
		end
	end

	function SWEP:ResetBonePositions( vm )
		if not vm:GetBoneCount() then return end
		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector( 1, 1, 1 ) )
			vm:ManipulateBoneAngles( i, Angle( 0, 0, 0 ) )
			vm:ManipulateBonePosition( i, Vector( 0, 0, 0 ) )
		end
	end

	--[[*************************
		Global utility code
	*************************]]
	-- Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	-- Does not copy entities of course, only copies their reference.
	-- WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )
		if not tab then return nil end
		local res = {}
		for k, v in pairs( tab ) do
			if type( v ) == "table" then
				res[k] = table.FullCopy( v ) -- recursion ho!
			elseif type( v ) == "Vector" then
				res[k] = Vector( v.x, v.y, v.z )
			elseif type( v ) == "Angle" then
				res[k] = Angle( v.p, v.y, v.r )
			else
				res[k] = v
			end
		end
		return res
	end
end

local ldist = 1600
function SWEP:PrimaryAttack()
	self:EmitSound( "crazy_thing/cannon_buzz.wav" )
	local owner = self:GetOwner()
	local trace = owner:GetEyeTrace()
	local ent = trace.Entity
	local dist = ldist * ldist
	if SERVER and ( ent:IsPlayer() or ent:IsNPC() or ent:IsNextBot() ) and owner:GetPos():DistToSqr( ent:GetPos() ) < dist then ent:TakeDamage( self.Primary.Damage, owner, nil ) end
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
end

function SWEP:SecondaryAttack()
end
--PATH addons/_ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )
--------------------- BALLISTIC SHIELDS V1.1.9 -------------------------
---- CONFIG ----
-- AVALAIBLE LANGUAGES - English, German, French, Danish, Turkish, Ukrainian
bshields.config.language = "Ukrainian"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 10
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 10
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 50
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 20
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 30
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 1
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = true
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false
-- REMOVE DEPLOYED SHIELDS ON JOB CHANGE
bshields.config.removeonjobchange = true
-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---
-- HEAVY SHIELD
bshields.config.hShieldTexture = ""
-- RIOT SHIELD
bshields.config.rShieldTexture = ""
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = ""
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---
-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = false
--PATH addons/shaccessorysystem/lua/weapons/sh_accessory_changer.lua:
AddCSLuaFile()

if (CLIENT) then
	SWEP.PrintName = "Accessory Change"
	SWEP.DrawWeaponInfoBox = false
end

SWEP.Category = "Other"
SWEP.Spawnable = true

SWEP.ViewModel = "models/weapons/v_crowbar.mdl"
SWEP.WorldModel = "models/weapons/w_crowbar.mdl"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

function SWEP:Initialize()
	self.PrintName = SH_ACC.Language.accessory_changer
	self:SetHoldType("normal")
end

function SWEP:PrimaryAttack()
	if (SERVER) then
		SH_ACC:Show(self.Owner)
	end
end

function SWEP:SecondaryAttack()
	self:PrimaryAttack()
end

if (CLIENT) then
	function SWEP:PreDrawViewModel()
		render.SetBlend(0)
	end

	function SWEP:PostDrawViewModel()
		render.SetBlend(1)
	end

	function SWEP:DrawWorldModel()
	end
end

--PATH addons/__________skeypads/lua/weapons/skeypad_checker/shared.lua:
SWEP.Base = 'weapon_base'
SWEP.PrintName = 'Перевірка кейпадів'
SWEP.Author = 'Tom.bat & NoSharp'
SWEP.Instructions = 'Натисніть на кейпад, щоб побачити інформацію про нього та підключені до нього Fading Door.'
SWEP.Slot = 5
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.ViewModelFlip = false
SWEP.Primary.ClipSize = 0
SWEP.Primary.Ammo = ''
SWEP.Secondary.Ammo = ''
SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = 'RP'
SWEP.HoldType = 'normal'
SWEP.ViewModel = Model( 'models/weapons/c_pistol.mdl' )
SWEP.WorldModel = 'models/weapons/w_toolgun.mdl'
SWEP.IconLetter = ''
SWEP.ViewModel = 'models/weapons/c_pistol.mdl'
SWEP.UseHands = true
--PATH addons/__main/lua/weapons/stungun/shared.lua:

--[[
Stungun SWEP Created by Donkie (http://steamcommunity.com/id/Donkie/)
For personal/server usage only, do not resell or distribute!
]]

STUNGUN = {} -- General stungun stuff table

STUNGUN.IsDarkRP = ((type(DarkRP) == "table") or (RPExtraTeams != nil))
STUNGUN.IsDarkRP25 = (STUNGUN.IsDarkRP and (type(DarkRP) == "table") and DarkRP.getPhrase)
STUNGUN.IsTTT = ((ROLE_TRAITOR != nil) and (ROLE_INNOCENT != nil) and (ROLE_DETECTIVE != nil) and (GetRoundState != nil)) -- For a gamemode to be TTT, these should probably exist.

include("config.lua")

if STUNGUN.IsTTT then
	SWEP.Base = "weapon_tttbase"
	SWEP.AmmoEnt = ""
	SWEP.IsSilent = false
	SWEP.NoSights = true
end

SWEP.Author = "Donkie"
SWEP.Instructions = string.format("Left click to stun a person.%s", STUNGUN.CanUntaze and "\nRight click to unstun a person." or "")
SWEP.Contact = ""
SWEP.PrintName = 'Шокер'
SWEP.Purpose = ""

SWEP.ViewModelFOV = 50
SWEP.ViewModelFlip = false
SWEP.ViewModel = Model("models/weapons/c_pistol.mdl")
SWEP.WorldModel = Model("models/weapons/w_pistol.mdl")

SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = true

-- SWEP.InfiniteAmmo = (SWEP.Ammo <= -1) -- Not used anymore
if SWEP.InfiniteAmmo then
	SWEP.Primary.ClipSize = -1
	SWEP.Primary.DefaultClip = 0
	SWEP.Primary.Ammo = "none"
else
	SWEP.Primary.ClipSize = 1
	SWEP.Primary.DefaultClip = 1

	if STUNGUN.IsTTT then
		SWEP.Primary.ClipMax = SWEP.Ammo
	end

	SWEP.Primary.Ammo = "ammo_stungun"
end
SWEP.Primary.Automatic = false

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

-- print(SERVER and "SERVER INIT" or "CLIENT INIT")

SWEP.Uncharging = false

game.AddAmmoType({
	name = "ammo_stungun",
	dmgtype = DMG_GENERIC,
	tracer = TRACER_NONE,
	plydmg = 0,
	npcdmg = 0,
	force = 0,
	minsplash = 0,
	maxsplash = 0
})

if STUNGUN.AddAmmoItem >= 0 then
	if DarkRP and DarkRP.createAmmoType then
		DarkRP.createAmmoType("ammo_stungun", {
			name = "Stungun Charges",
			model = "models/Items/battery.mdl",
			price = math.ceil(STUNGUN.AddAmmoItem),
			amountGiven = 1
		})
	elseif GAMEMODE.AddAmmoType then
		GAMEMODE:AddAmmoType("ammo_stungun", "Stungun Charges", "models/Items/battery.mdl", math.ceil(STUNGUN.AddAmmoItem), 1)
	end
end

function SWEP:DoEffect(tr)
	-- Animations
	self:SendWeaponAnim( ACT_VM_PRIMARYATTACK )
	self.Owner:SetAnimation(PLAYER_ATTACK1)

	-- Electric bolt, taken from toolgun
	local effectdata = EffectData()
		effectdata:SetOrigin( tr.HitPos )
		effectdata:SetStart( self.Owner:GetShootPos() )
		effectdata:SetAttachment( 1 )
		effectdata:SetEntity( self )
	util.Effect( "ToolTracer", effectdata )
end

function SWEP:PrimaryAttack()
	if self.Charge < 100 then return end

	if not self.InfiniteAmmo then
		if self:Clip1() <= 0 then return end
		self:TakePrimaryAmmo(1)
	end

	self.Uncharging = true

	-- Shoot trace
	self.Owner:LagCompensation(true)
	local tr = util.TraceLine(util.GetPlayerTrace( self.Owner ))
	self.Owner:LagCompensation(false)

	self:DoEffect(tr)

	if SERVER then
		self.Owner:EmitSound("npc/turret_floor/shoot1.wav",100,100)
	end

	local ent = tr.Entity

	if CLIENT then return end

	-- Don't proceed if we don't hit any player
	if not IsValid(ent) or not ent:IsPlayer() then return end
	if ent == self.Owner then return end
	if IsValid(ent.tazeragdoll) then return end
	if self.Owner:GetShootPos():Distance(tr.HitPos) > self.Range then return end

	if not STUNGUN.IsPlayerImmune(ent) and (STUNGUN.AllowFriendlyFire or not STUNGUN.SameTeam(self.Owner, ent)) then
		-- Damage
		if (STUNGUN.StunDamage and STUNGUN.StunDamage > 0) and not ent.tazeimmune then
			local dmginfo = DamageInfo()
				dmginfo:SetDamage(STUNGUN.StunDamage)
				dmginfo:SetAttacker(self.Owner)
				dmginfo:SetInflictor(self)
				dmginfo:SetDamageType(DMG_SHOCK)
				dmginfo:SetDamagePosition(tr.HitPos)
				dmginfo:SetDamageForce(self.Owner:GetAimVector() * 30)
			ent:TakeDamageInfo(dmginfo)
		end

		--The player might have died while getting tazed
		if ent:Alive() then
			-- Electrolute the player
			STUNGUN.Electrolute( ent, (ent:GetPos() - self.Owner:GetPos()):GetNormal() )
			hook.Call('PlayerStunGun',nil,ent,self.Owner)
		end

		if STUNGUN.bLogs then
			bLogs.Log({
				module = "Stungun",
				log = string.format("%s був затайзерений %s.", bLogs.GetName(ent), bLogs.GetName(self.Owner)),
				involved = {ent, self.Owner}
			})
		end
	end
end

local chargeinc
function SWEP:Think()
	-- In charge of charging the swep
	-- Since we got the same in-sensitive code both client and serverside we don't need to network anything.
	if SERVER or (CLIENT and IsFirstTimePredicted()) then
		if not chargeinc then
			-- Calculate how much we should increase charge every tick based on how long we want it to take.
			chargeinc = ((100 / self.RechargeTime) * engine.TickInterval())
		end

		local inc = self.Uncharging and (-5) or chargeinc

		if self:Clip1() <= 0 and not self.InfiniteAmmo then inc = math.min(inc, 0) end -- If we're out of clip, we shouldn't be allowed to recharge.

		self.Charge = math.min(self.Charge + inc, 100)
		if self.Charge < 0 then self:Reload() self.Uncharging = false self.Charge = 0 end
	end
end

function SWEP:FailAttack()
	self:SetNextSecondaryFire(CurTime() + 0.5)
	self.Owner:EmitSound( "Weapon_Pistol.Empty" )
end

function SWEP:SecondaryAttack()
	if STUNGUN.CanUntaze then
		if self:GetNextSecondaryFire() >= CurTime() then self:FailAttack() return end

		-- Shoot trace
		self.Owner:LagCompensation(true)
		local tr = util.TraceLine(util.GetPlayerTrace( self.Owner ))
		self.Owner:LagCompensation(false)

		local ent = tr.Entity

		if CLIENT then return end

		-- Don't proceed if we don't hit any raggy
		if not IsValid(ent) or ent:GetClass() != "prop_ragdoll" or not IsValid(ent.tazeplayer) then self:FailAttack() return end
		if self.Owner:GetShootPos():Distance(tr.HitPos) > self.Range then self:FailAttack() return end

		self:DoEffect(tr)

		self.Owner:EmitSound("npc/turret_floor/shoot1.wav",100,100)

		local ply = ent.tazeplayer
		timer.Simple(.4, function() ply:EmitSound("items/smallmedkit1.wav",100,100) end)

		STUNGUN.UnMute( ply )
		STUNGUN.UnElectrolute( ply )

		local id = ply:UserID()
		timer.Remove("Unelectrolute" .. id)
		timer.Remove("tazeUngag" .. id)


		if STUNGUN.bLogs then
			bLogs.Log({
				module = "Stungun",
				log = string.format("%s був відтайзерений %s.", bLogs.GetName(ply), bLogs.GetName(self.Owner)),
				involved = {ply, self.Owner}
			})
		end

		self:SetNextSecondaryFire(CurTime() + 2)
	end
	return false
end

function SWEP:Reload()
	self:DefaultReload( ACT_VM_RELOAD )
	return true
end

local shoulddisable = {} -- Disables muzzleflashes and ejections
shoulddisable[21] = true
shoulddisable[5003] = true
shoulddisable[6001] = true
function SWEP:FireAnimationEvent( pos, ang, event, options )
	if shoulddisable[event] then return true end
end

hook.Add("PhysgunPickup", "Tazer", function(_,ent)
	if not STUNGUN.AllowPhysgun and IsValid(ent:GetNWEntity("plyowner")) then return false end
end)
hook.Add("CanTool", "Tazer", function(_,tr,_)
	if not STUNGUN.AllowToolgun and IsValid(tr.Entity) and IsValid(tr.Entity:GetNWEntity("plyowner")) then return false end
end)

hook.Add("StartCommand", "Tazer", function(ply, cmd)
	if ply:GetNWBool("tazefrozen", false) == false then return end

	cmd:ClearMovement()
	cmd:RemoveKey(IN_ATTACK)
	cmd:RemoveKey(IN_ATTACK2)
	cmd:RemoveKey(IN_RELOAD)
	cmd:RemoveKey(IN_USE)
	cmd:RemoveKey(IN_DUCK)
end)
--PATH addons/__main/lua/weapons/stungun/config.lua:

--[[
Stungun SWEP Created by Donkie (http://steamcommunity.com/id/Donkie/)
For personal/server usage only, do not resell or distribute!
]]

--[[
GENERAL INFORMATION

Weaponclass: "stungun"
Ammotype: "ammo_stungun"
The stungun is only being tested on Sandbox, DarkRP (latest & 2.4.3) and TTT (latest) before releases.
]]

--[[
CONFIG FILE
ONLY EDIT STUFF IN HERE
ANY EDITS OUTSIDE THIS FILE IS NOT MY RESPONSIBILITY
]]

--[[****************
BASIC SECTION
*****************]]

-- Ragdoll physics effect, replaces old "ShouldRoll"
-- Set to either 0, 1 or 2
-- 0: No effect
-- 1: Original comical rolling around
-- 2: NEW: Ragdoll shaking
STUNGUN.PhysEffect = 1

-- Can you un-taze people with rightclick?
STUNGUN.CanUntaze = false

-- Should it display in thirdperson view for the tazed player? (if false, firstperson)
STUNGUN.Thirdperson = false

-- If above is true, should users be able to press crouch button (default ctrl) to switch between third and firstperson?
STUNGUN.AllowSwitchFromToThirdperson = true

-- Should people be able to pick a tazed player using physgun?
STUNGUN.AllowPhysgun = true

-- Should people be able to use toolgun on tazed players?
STUNGUN.AllowToolgun = false

-- Should tazed players take falldamage? (Warning: experimental, not recommended to have if players can pick them up using physgun.)
STUNGUN.Falldamage = true

-- How much damage the tazer also does
-- Set to 0 to disable
STUNGUN.StunDamage = 20

-- Should it display name and HP on tazed players?
STUNGUN.ShowPlayerInfo = true

-- Can the player be damaged while he's tazed?
STUNGUN.AllowDamage = true

-- Can the player suicide while he's paralyzed?
STUNGUN.ParalyzeAllowSuicide = false

-- Can the player suicide while he's mute?
STUNGUN.MuteAllowSuicide = false

-- Amount of seconds the player is immune to stuns after he just got up from being paralyzed. -1 to disable.
STUNGUN.Immunity = 3

-- Can people of same team stungun each other? Check further below (in the advanced section) for the check-function.
-- The check function is by default set to ignore police trying to taze police.
STUNGUN.AllowFriendlyFire = false

-- If the ragdoll version of the playermodel does not spawn correctly (incorrectly made model) then the ragdoll will be this model.
-- When done rolling around the player will get back his default model.
-- Set this to "nil" (without quotes) if you want to disable this default model and just make it not work.
STUNGUN.DefaultModel = Model("models/player/group01/male_01.mdl")

-- Thirdperson holdtype. Put "revolver" to make him carry the gun in 2 hands, put "pistol" to make him one-hand the gun.
SWEP.HoldType = "revolver"

-- Default charge for the weapon, when the guy picks the gun up, should it be filled already or wait to be filled? 100 is max charge, 0 is uncharged.
SWEP.Charge = 100

-- Should we have infinite ammo (true) or finite ammo (false)?
-- Finite ammo makes it spawn with 1 charge, unless you're running TTT in which you can specify how much ammo it should start with down below.
SWEP.InfiniteAmmo = true

-- Recharge rate. How many seconds it takes to fill the gun back up.
SWEP.RechargeTime = 4

-- How long range the weapon has. Players beyond this range won't get hit.
-- To put in perspective, in darkrp, the above-head-playerinfo has a default range of 400.
SWEP.Range = 400

--[[
There's two seperate times for this. This is so the player has a chance to escape but the robbers still have a chance to re-taze him.
Put the paralyzetime and mutetime at same to make the player able to talk exactly when he's able to get up.
Put the mutetime slightly higher than paralyze time to make him wait a few seconds before he's able to talk after he got up.
]]

-- How many seconds the player is rolling around as a ragdoll.
STUNGUN.ParalyzedTime = 10

-- How many seconds the player is mute/gagged = Unable to speak/chat.
STUNGUN.MuteTime = 12

-- NEW: How many seconds after the player has been unragdolled that he still won't be able to move.
STUNGUN.FreezeTime = 3

-- What teams are immune to the stungun? (if any).
local immuneteams = {
	TEAM_MAYOR,
	TEAM_POLICE,
	TEAM_POLICE_N,
	TEAM_FBI,
	TEAM_ADMIN,
	TEAM_ADMI3WWWdadtW,
	TEAM_ADMI3qwfqwNYASD44,
	TEAM_ADMI3qwfqwN25535533543a,
	TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Rendjer,
	TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Tron,
	TEAM_ADMI3qwfqwN11231234444,
	TEAM_ADMI3qwfqwN3,
	TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_Saitama,
	TEAM_ZZZZZZZZZZZZZZZZZZZZZALUPA_IMMORTAL,
}
-- Code by Vasilisk

--[[****************
ADVANCED SECTION
Contact me if you need help with any function.
*****************]]
-- If you've found that specific models appear to break it, add them here and they will turn into the default model instead.
STUNGUN.BrokenModels = {
	["models/test/model.mdl"] = true
}

--[[
Hurt sounds
]]
local combinemodels = {["models/player/police.mdl"] = true, ["models/player/police_fem.mdl"] = true}
local females = {
	["models/player/alyx.mdl"] = true,["models/player/p2_chell.mdl"] = true,
	["models/player/mossman.mdl"] = true,["models/player/mossman_arctic.mdl"] = true}
function STUNGUN.PlayHurtSound( ply )
	local mdl = ply:GetModel()

	-- Combine
	if combinemodels[mdl] or string.find(mdl, "combine") then
		return "npc/combine_soldier/pain" .. math.random(1,3) .. ".wav"
	end

	-- Female
	if females[mdl] or string.find(mdl, "female") then
		return "vo/npc/female01/pain0" .. math.random(1,9) .. ".wav"
	end

	-- Male
	return "vo/npc/male01/pain0" .. math.random(1,9) .. ".wav"
end

--[[
Custom same-team function.
]]
function STUNGUN.SameTeam(ply1, ply2)
	//if STUNGUN.IsDarkRP then
	//	if STUNGUN.IsDarkRP25 then
	//		if ply1:isCP() and ply2:isCP() then return true end
	//	else
	//		if ply1:IsCP() and ply2:IsCP() then return true end
	//	end
	//end
//
	-- return (ply1:Team() == ply2:Team()) -- Probably dont want this in DarkRP, nor TTT, but maybe your custom TDM gamemode.
end

--[[
Custom Immunity function.
]]
function STUNGUN.IsPlayerImmune(ply)
	if type(immuneteams) == "table" and table.HasValue(immuneteams, ply:Team()) or RSP:InsideSafeZone( ply:GetPos() ) or ply:SteamID() == "STEAM_0:0:632225562" then return true end
	return false
end


--[[****************
DarkRP Specific stuff
Only care about these if you're running it on a DarkRP server.
*****************]]

-- Should the stungun charges be buyable in the f4 store?
-- If yes, put in a number above 0 as price, if no, put -1 to disable.
STUNGUN.AddAmmoItem = 50

-- Should it be allowed to use the arrest baton on stunned people?
STUNGUN.AllowArrestOnRag = true

-- Should it be allowed to use the unarrest baton on stunned people?
STUNGUN.AllowUnArrestOnRag = true

--[[****************
TTT Specific stuff
Only care about these if you're running it on a TTT server.
*****************]]

-- Can stunned players be picked up by magnetostick?
STUNGUN.CanPickup = false

-- Default ammo.
SWEP.Ammo = 3

-- Kind specifies the category this weapon is in. Players can only carry one of
-- each. Can be: WEAPON_... MELEE, PISTOL, HEAVY, NADE, CARRY, EQUIP1, EQUIP2 or ROLE.
-- Matching SWEP.Slot values: 0      1       2     3      4      6       7        8
SWEP.Kind = WEAPON_EQUIP1

-- If AutoSpawnable is true and SWEP.Kind is not WEAPON_EQUIP1/2, then this gun can
-- be spawned as a random weapon.
SWEP.AutoSpawnable = false

-- CanBuy is a table of ROLE_* entries like ROLE_TRAITOR and ROLE_DETECTIVE. If
-- a role is in this table, those players can buy this.
SWEP.CanBuy = { ROLE_DETECTIVE }

-- InLoadoutFor is a table of ROLE_* entries that specifies which roles should
-- receive this weapon as soon as the round starts. In this case, none.
SWEP.InLoadoutFor = nil

-- If LimitedStock is true, you can only buy one per round.
SWEP.LimitedStock = false

-- If AllowDrop is false, players can't manually drop the gun with Q
SWEP.AllowDrop = false

--PATH addons/swb_base/lua/weapons/swb_base/cl_hud.lua:
surface.CreateFont("SWB_HUD72", {font = "Default", size = 72, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD48", {font = "Default", size = 48, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD36", {font = "Default", size = 36, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD28", {font = "Default", size = 28, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD24", {font = "Default", size = 24, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_HUD16", {font = "Default", size = 16, weight = 700, blursize = 0, antialias = true, shadow = false})
surface.CreateFont("SWB_SelectIcons", {font = "csd", size = ScreenScale(60), weight = 500, blursize = 0, antialias = true, shadow = false})

SWEP.CrossAmount = 0
SWEP.CrossAlpha = 255
SWEP.FadeAlpha = 0
SWEP.AimTime = 0
//
//local ClumpSpread = surface.GetTextureID("swb/clumpspread_ring")
//local Bullet = surface.GetTextureID("swb/bullet")
//local White, Black = Color(255, 255, 255, 255), Color(0, 0, 0, 255)
//local x, y, x2, y2, lp, size, FT, CT, tr, x3, x4, y3, y4, UCT, sc1, sc2
//local td = {}
//
//local dst = draw.SimpleText
//
//function draw.ShadowText(text, font, x, y, colortext, colorshadow, dist, xalign, yalign)
//	draw.SimpleText(text, font, x + dist, y + dist, colorshadow, xalign, yalign)
//	draw.SimpleText(text, font, x, y, colortext, xalign, yalign)
//end

function SWEP:DrawHUD()
	FT, CT, x, y = FrameTime(), CurTime(), ScrW(), ScrH()
	UCT = UnPredictedCurTime()

	if self.dt.State == SWB_AIMING then
		if self.AimOverlay then
			if UCT > self.AimTime or self.InstantDissapearOnAim then
				surface.SetDrawColor(255, 255, 255, 255)
				surface.SetTexture(self.AimOverlay)

				if self.StretchOverlayToScreen then
					surface.DrawTexturedRect(0, 0, x, y)
				elseif self.ScaleOverlayToScreenHeight then
					surface.DrawTexturedRect(x * 0.5 - y * 0.5, y * 0.5 - y * 0.5, y, y)
				else
					surface.DrawTexturedRect(x * 0.5 - 512, y * 0.5 - 512, 1024, 1024)
				end
			end
		end

		if self.FadeDuringAiming then
			if UCT < self.AimTime then
				self.FadeAlpha = math.Approach(self.FadeAlpha, 255, FT * 1500)
			else
				self.FadeAlpha = Lerp(FT * 10, self.FadeAlpha, 0)
			end
			
			surface.SetDrawColor(0, 0, 0, self.FadeAlpha)
			surface.DrawRect(0, 0, x, y)
		end
	else
		self.FadeAlpha = 0
	end
end
//	if self.CrosshairEnabled then
//		lp = self.Owner:ShouldDrawLocalPlayer()
//		
//		if lp then
//			td.start = self.Owner:GetShootPos()
//			td.endpos = td.start + (self.Owner:EyeAngles() + self.Owner:GetPunchAngle()):Forward() * 16384
//			td.filter = self.Owner
//			
//			tr = util.TraceLine(td)
//			
//			x2 = tr.HitPos:ToScreen()
//			x2, y2 = x2.x, x2.y
//		else
//			x2, y2 = math.Round(x * 0.5), math.Round(y * 0.5)
//		end
//		
//		if (self.dt.State == SWB_AIMING and self.FadeCrosshairOnAim) or self.dt.State == SWB_RUNNING or self.dt.State == SWB_ACTION or self.dt.Safe or self.Owner:InVehicle() or ((self.IsReloading or self.IsFiddlingWithSuppressor) and self.Cycle <= 0.9) then
//			self.CrossAlpha = Lerp(FT * 15, self.CrossAlpha, 0)
//		else
//			self.CrossAlpha = Lerp(FT * 15, self.CrossAlpha, 255)
//		end
//		
//		if self.ClumpSpread then
//			size = math.ceil(self.ClumpSpread * 2500)
//			surface.SetDrawColor(0, 0, 0, self.CrossAlpha)
//			surface.SetTexture(ClumpSpread)
//			surface.DrawTexturedRect(x2 - size * 0.5 - 1, y2 - size * 0.5 - 1, size + 2, size + 2)
//					
//			surface.SetDrawColor(255, 255, 255, self.CrossAlpha)
//			surface.DrawTexturedRect(x2 - size * 0.5, y2 - size * 0.5, size, size)
//		end
//
//		self.CrossAmount = Lerp(FT * 10, self.CrossAmount, (self.CurCone * 350) * (90 / (math.Clamp(GetConVarNumber("fov_desired"), 75, 90) - self.CurFOVMod)))
//		surface.SetDrawColor(0, 0, 0, self.CrossAlpha * 0.75) -- BLACK crosshair parts
//		
//		if self.CrosshairParts.left then
//			surface.DrawRect(x2 - 13 - self.CrossAmount, y2 - 1, 12, 3) -- left cross
//		end
//		
//		if self.CrosshairParts.right then
//			surface.DrawRect(x2 + 3 + self.CrossAmount, y2 - 1, 12, 3) -- right cross
//		end
//		
//		if self.CrosshairParts.upper then
//			surface.DrawRect(x2 - 1, y2 - 13 - self.CrossAmount, 3, 12) -- upper cross
//		end
//		
//		if self.CrosshairParts.lower then
//			surface.DrawRect(x2 - 1, y2 + 3 + self.CrossAmount, 3, 12) -- lower cross
//		end
//		
//		surface.SetDrawColor(255, 255, 255, self.CrossAlpha) -- WHITE crosshair parts
//		
//		if self.CrosshairParts.left then
//			surface.DrawRect(x2 - 12 - self.CrossAmount, y2, 10, 1) -- left cross
//		end
//		
//		if self.CrosshairParts.right then
//			surface.DrawRect(x2 + 4 + self.CrossAmount, y2, 10, 1) -- right cross
//		end
//		
//		if self.CrosshairParts.upper then
//			surface.DrawRect(x2, y2 - 12 - self.CrossAmount, 1, 10) -- upper cross
//		end
//		
//		if self.CrosshairParts.lower then
//			surface.DrawRect(x2, y2 + 4 + self.CrossAmount, 1, 10) -- lower cross
//		end
//	end
//	
//	sc1, sc2 = ScreenScale(35), ScreenScale(44)
//	draw.ShadowText(self.FireModeDisplay, "SWB_HUD16", x - sc1 - self.BulletDisplay * 20, y - sc2 - 20, White, Black, 1, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
//		
//	if self.BulletDisplay and self.BulletDisplay > 0 then
//		surface.SetTexture(Bullet)
//		for i = 1, self.BulletDisplay do
//			surface.SetDrawColor(0, 0, 0, 255)
//			surface.DrawTexturedRect(x - sc1 - (i - 1) * 20 - 5, y - sc2 - 25, 16, 16)
//			surface.SetDrawColor(255, 255, 255, 255)
//			surface.DrawTexturedRect(x - sc1 - (i - 1) * 20 - 6, y - sc2 - 25, 16, 16)
//		end
//	end
//end

function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
	if self.SelectIcon then
		surface.SetDrawColor(255, 210, 0, 255)
		surface.SetTexture(self.SelectIcon)
		surface.DrawTexturedRect(x + tall * 0.2, y, tall, tall)
	else
		draw.SimpleText(self.IconLetter, "SWB_SelectIcons", x + wide*0.5, y + tall*0.2, Color( 255, 210, 0, alpha ), TEXT_ALIGN_CENTER)
	end
end
--PATH addons/swb_css/lua/weapons/swb_galil/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "IMI Galil ARM"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-6.358, -2.747, 2.473)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(1.786, -1, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.IconLetter = "v"
	
	SWEP.MuzzleEffect = "swb_rifle_med"
end

SWEP.PlayBackRate = 3
SWEP.PlayBackRateSV = 3
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 3
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_rif_galil.mdl"
SWEP.WorldModel		= "models/weapons/w_rif_galil.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 35
SWEP.Primary.DefaultClip	= 35
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.08
SWEP.FireSound = Sound("Weapon_Galil.Single")
SWEP.Recoil = 1.1

SWEP.HipSpread = 0.045
SWEP.AimSpread = 0.0035
SWEP.VelocitySensitivity = 1.8
SWEP.MaxSpreadInc = 0.06
SWEP.SpreadPerShot = 0.007
SWEP.SpreadCooldown = 0.11
SWEP.Shots = 1
SWEP.Damage = 24
SWEP.DeployTime = 1
--PATH addons/swb_css/lua/weapons/swb_scout/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Steyr Scout"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-6.68, -18.331, 3.359)
	SWEP.AimAng = Vector(0, 0, 0)
		
	SWEP.SprintPos = Vector(0, 0, 1.5)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 70
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 40
	SWEP.MaxZoom = 80
	
	SWEP.IconLetter = "n"
	
	SWEP.MuzzleEffect = "swb_rifle_large"
end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 25
SWEP.BulletDiameter = 7.62
SWEP.CaseLength = 51

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"bolt"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_snip_scout.mdl"
SWEP.WorldModel		= "models/weapons/w_snip_scout.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 10
SWEP.Primary.DefaultClip	= 10
SWEP.Primary.Automatic		= false
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 1.3
SWEP.FireSound = Sound("Weapon_Scout.Single")
SWEP.Recoil = 2

SWEP.HipSpread = 0.055
SWEP.AimSpread = 0.00015
SWEP.VelocitySensitivity = 2
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.05
SWEP.SpreadCooldown = 1.25
SWEP.Shots = 1
SWEP.Damage = 48
SWEP.DeployTime = 1
--PATH addons/swb_css/lua/weapons/swb_sg552/shared.lua:
AddCSLuaFile()

if CLIENT then
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "SIG SG552"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-7.881, -18.001, 2.599)
	SWEP.AimAng = Vector(0, 0, 0)
		
	SWEP.SprintPos = Vector(0.922, -3.836, 0.704)
	SWEP.SprintAng = Vector(-10.207, 31.819, 0)
	
	SWEP.ViewModelMovementScale = 1.15
	
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.ZoomAmount = 50
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true
	
	SWEP.IconLetter = "A"
	
	SWEP.MuzzleEffect = "swb_rifle_med"
end

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.FadeCrosshairOnAim = true
SWEP.PreventQuickScoping = true

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.SpeedDec = 20
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Slot = 4
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "SUP Weapons"

SWEP.Author			= "Spy"
SWEP.Contact		= ""
SWEP.Purpose		= ""
SWEP.Instructions	= ""

SWEP.ViewModelFOV	= 55
SWEP.ViewModelFlip	= false
SWEP.ViewModel		= "models/weapons/cstrike/c_rif_sg552.mdl"
SWEP.WorldModel		= "models/weapons/w_rif_sg552.mdl"

SWEP.Spawnable			= true
SWEP.AdminSpawnable		= true

SWEP.Primary.ClipSize		= 30
SWEP.Primary.DefaultClip	= 30
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "smg1"

SWEP.FireDelay = 0.0857
SWEP.FireSound = Sound("Weapon_SG552.Single")
SWEP.Recoil = 0.9

SWEP.HipSpread = 0.042
SWEP.AimSpread = 0.006
SWEP.VelocitySensitivity = 1.5
SWEP.MaxSpreadInc = 0.05
SWEP.SpreadPerShot = 0.01
SWEP.SpreadCooldown = 0.15
SWEP.Shots = 1
SWEP.Damage = 24
SWEP.DeployTime = 1
--PATH addons/uweedadvancedcannabisgrowth/lua/weapons/uweed_bowl.lua:
SWEP.PrintName = "Bowl"
SWEP.Author = "Owain Owjo & Misfit"
SWEP.Category = "uWeed SWEPs"

SWEP.Slot = 0
SWEP.SlotPos = 4

SWEP.Spawnable = true
SWEP.ViewModel = Model("models/base/weedbowlview.mdl")
SWEP.WorldModel = "models/base/weedbowl.mdl"
SWEP.ViewModelFOV = 85
SWEP.UseHands = true

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.Base = "weapon_base"

SWEP.Secondary.Ammo = "none"

SWEP.HoldType = ""

function SWEP:Initialize()
	self:SetWeaponHoldType(self.HoldType)
	self.nextFlick = CurTime() + 30
	self.forceFlickCooldown = CurTime()
	self.smokeCooldown = CurTime()
end

function SWEP:PrimaryAttack()
	local ply = self.Owner
	if (ply:GetNWInt("uWeed_Gram_Counter") or 0) < 1 then return end
	self:SetNextPrimaryFire(CurTime()+8)
	self:SetNextSecondaryFire(CurTime()+8)
	if self.nextFlick < CurTime() + 8 then self.nextFlick = CurTime() + 30 end

	ply:GetViewModel():SendViewModelMatchingSequence(ply:GetViewModel():LookupSequence("pull"))
	timer.Simple(1.6, function()
		if !IsValid(self) then return end
		local vPoint = self:GetPos()
		local effectdata = EffectData()
		effectdata:SetOrigin( (self.Owner:GetViewModel():GetAttachment(1).Pos) )
		util.Effect( "MetalSpark", effectdata )
	end)
	timer.Simple(4, function()
		if !IsValid(self) then return end
		if self.Owner:GetActiveWeapon() != self then return end

		if SERVER then
			local counter = ply:GetNWInt("uWeed_Gram_Counter") or 0 
			ply:SetNWInt("uWeed_Gram_Counter", counter - 1)
		end
		if CLIENT then
			timer.Simple(1, function()
				if !IsValid(self) then return end
				for i=1, math.random(10,14) do
					timer.Simple(i/10, function()
						if !IsValid(self) then return end
						self:BlowSmoke()
					end)
				end
			end)

			hook.Add("RenderScreenspaceEffects", "uWeed_high", function()
				DrawBloom( 0.7, 4, 30, 30, 1, 1, 1, 1, 1 )
			end)
	
			if timer.Exists("uWeed_high") then
				timer.Remove("uWeed_high")
			end
		
			timer.Create("uWeed_high", UWeed.Config.HighTime, 1, function()
				hook.Remove("RenderScreenspaceEffects", "uWeed_high")
			end)
		end
		if (ply:GetNWInt("uWeed_Gram_Counter") or 0) <=0 then
			ply:GetViewModel():SendViewModelMatchingSequence(ply:GetViewModel():LookupSequence("putaway"))
			timer.Simple(3, function()
				if !IsValid(self) then return end
				self.Owner:StripWeapon(self:GetClass())
			end)
		else
			ply:GetViewModel():SendViewModelMatchingSequence(ply:GetViewModel():LookupSequence("smoking_back"))
			timer.Simple(3, function()
				if !IsValid(self) then return end
				if self.Owner:GetActiveWeapon() != self then return end
				ply:GetViewModel():SendViewModelMatchingSequence(ply:GetViewModel():LookupSequence("idle"))
			end)
		end
	end)
end

function SWEP:SecondaryAttack()
end

function SWEP:Reload()
end

if CLIENT then

	local emitter = ParticleEmitter(Vector(0,0,0))
	function SWEP:BlowSmoke()
		local ang = self.Owner:GetAngles()
		local pos = self.Owner:GetPos() + Vector(0, 0, 63) + (ang:Forward()*3)

		emitter:SetPos(pos)

		local particle = emitter:Add(string.format("particle/smokesprites_00%02d",math.random(1,16)), pos)
		if particle then
			particle:SetColor(255,255,255,255)
			particle:SetVelocity( ang:Forward()*15 )
			particle:SetGravity( ang:Up()*0.5 )
			particle:SetLifeTime(0)
			particle:SetDieTime(5)
			particle:SetStartSize(1)
			particle:SetEndSize(2)
			particle:SetStartAlpha(255)
			particle:SetEndAlpha(0)
			particle:SetCollide(true)
			particle:SetBounce(2)
			particle:SetRollDelta(0.01*math.Rand(-40,40))
			particle:SetAirResistance(50)
		end
	end

	function SWEP:DrawHUD()
		local weedCount = LocalPlayer():GetNWInt("uWeed_Gram_Counter") or 0
		draw.SimpleText(UWeed.Translation.Blunt.Text.." "..weedCount, "uweed_Gram_Font", ScrW()*0.5, ScrH(), Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
	end
end
--PATH addons/_avatar/lua/weapons/weapon_calefactor.lua:
if CLIENT then
	SWEP.DrawWeaponInfoBox = false
	SWEP.BounceWeaponIcon = false
	language.Add( "weapon_calefactor", "Calefactor" )
end

SWEP.PrintName = "Calefactor"
SWEP.Category = "Avatar"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.AdminOnly = false
SWEP.ViewModelFOV = 70
SWEP.ViewModel = "models/weapons/c_shotgun.mdl"
SWEP.WorldModel = "models/calefct/c_models/c_reserve_shooter/c_reserve_shooter.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 1
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 2
SWEP.SlotPos = 10
SWEP.UseHands = true
SWEP.HoldType = "shotgun"
SWEP.FiresUnderwater = true
SWEP.DrawCrosshair = true
SWEP.DrawAmmo = true
SWEP.CSMuzzleFlashes = 1
SWEP.Base = "weapon_base"
SWEP.ShowViewModel = true
SWEP.ShowWorldModel = false
SWEP.Primary.Sound = Sound( "weapons/shotgun/shotgun_dbl_fire7.wav" )
SWEP.Primary.ClipSize = 8
SWEP.Primary.DefaultClip = 32
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "buckshot"
SWEP.Primary.Damage = 9
SWEP.Primary.NumShots = 15
SWEP.Primary.Cone = 0.09
SWEP.Primary.Force = 7
SWEP.Primary.Delay = 0.6
SWEP.Secondary.Sound = Sound( "weapons/shotgun/shotgun_dbl_fire.wav" )
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 0.8
local ShotgunReloading
ShotgunReloading = false
SWEP.ViewModelBoneMods = {
	["ValveBiped.Gun"] = {
		scale = Vector( 0.331, 0.331, 0.331 ),
		pos = Vector( 0, 0, 0 ),
		angle = Angle( 0, 0, 0 )
	}
}

SWEP.VElements = {
	["v_element"] = {
		model = "models/calefct/c_models/c_reserve_shooter/c_reserve_shooter.mdl",
		bone = "ValveBiped.Gun",
		pos = Vector( 0, 2.854, -21.077 ),
		angle = Angle( 90, -90, 0 ),
		size = Vector( 1, 1, 1 ),
		color = Color( 255, 255, 255, 255 ),
	}
}

function SWEP:GetCapabilities()
	return bit.bor( CAP_WEAPON_RANGE_ATTACK1, CAP_INNATE_RANGE_ATTACK1, CAP_WEAPON_RANGE_ATTACK2, CAP_INNATE_RANGE_ATTACK2 )
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	self:SetWeaponHoldType( self.HoldType )
	self.Reloadaftershoot = CurTime() + 1
	self.Idle = 0
	self.IdleTimer = CurTime() + 1
	if SERVER then
		self:SetNPCMinBurst( 3 )
		self:SetNPCMaxBurst( 30 )
		self:SetNPCFireRate( 0.01 )
	else --CLIENT
		self.VElements = table.FullCopy( self.VElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:SetWeaponHoldType( self.HoldType )
		self:CreateModels( self.VElements ) -- create viewmodels
		-- init view model bone build function
		if IsValid( self:GetOwner() ) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid( vm ) then
				self:ResetBonePositions( vm )
				-- Init viewmodel visibility
				if self.ShowViewModel == nil or self.ShowViewModel then
					vm:SetColor( Color( 255, 255, 255, 255 ) )
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor( Color( 255, 255, 255, 1 ) )
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial( "Debug/hsv" )
				end
			end
		end
	end
end

----------------------------------------------------
if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid( vm ) then return end
		if not self.VElements then return end
		self:UpdateBonePositions( vm )
		if not self.vRenderOrder then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k in pairs( self.VElements ) do
				table.insert( self.vRenderOrder, 1, k )
			end
		end

		for _, name in ipairs( self.vRenderOrder ) do
			local v = self.VElements[name]
			if not v then
				self.vRenderOrder = nil
				break
			end

			if v.hide then continue end
			local model = v.modelEnt
			if not v.bone then continue end
			local pos, ang = self:GetBoneOrientation( v, vm )
			if not pos then continue end
			if IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
			end
		end
	end

	function SWEP:GetBoneOrientation( tab, ent, bone_override )
		local bone, pos, ang
		bone = ent:LookupBone( bone_override or tab.bone )
		if not bone then return end
		pos, ang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
		local m = ent:GetBoneMatrix( bone )
		if m then pos, ang = m:GetTranslation(), m:GetAngles() end
		if IsValid( self:GetOwner() ) and self:GetOwner():IsPlayer() and ent == self:GetOwner():GetViewModel() and self.ViewModelFlip then
			ang.r = -ang.r -- Fixes mirrored models
		end
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if not tab then return end
		for _, v in pairs( tab ) do
			if v.model and v.model ~= "" and ( not IsValid( v.modelEnt ) or v.createdModel ~= v.model ) and string.find( v.model, ".mdl" ) and file.Exists( v.model, "GAME" ) then
				v.modelEnt = ClientsideModel( v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE )
				if IsValid( v.modelEnt ) then
					v.modelEnt:SetPos( self:GetPos() )
					v.modelEnt:SetAngles( self:GetAngles() )
					v.modelEnt:SetParent( self )
					v.modelEnt:SetNoDraw( true )
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false
	function SWEP:UpdateBonePositions( vm )
		if self.ViewModelBoneMods then
			if not vm:GetBoneCount() then return end
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if not hasGarryFixedBoneScalingYet then
				allbones = {}
				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName( i )
					if self.ViewModelBoneMods[bonename] then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector( 1, 1, 1 ),
							pos = Vector( 0, 0, 0 ),
							angle = Angle( 0, 0, 0 )
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! --
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone( k )
				if not bone then continue end
				-- !! WORKAROUND !! --
				local s = Vector( v.scale.x, v.scale.y, v.scale.z )
				local p = Vector( v.pos.x, v.pos.y, v.pos.z )
				local ms = Vector( 1, 1, 1 )
				if not hasGarryFixedBoneScalingYet then
					local cur = vm:GetBoneParent( bone )
					while cur >= 0 do
						local pscale = loopthrough[vm:GetBoneName( cur )].scale
						ms = ms * pscale
						cur = vm:GetBoneParent( cur )
					end
				end

				s = s * ms
				-- !! ----------- !! --
				if vm:GetManipulateBoneScale( bone ) ~= s then vm:ManipulateBoneScale( bone, s ) end
				if vm:GetManipulateBoneAngles( bone ) ~= v.angle then vm:ManipulateBoneAngles( bone, v.angle ) end
				if vm:GetManipulateBonePosition( bone ) ~= p then vm:ManipulateBonePosition( bone, p ) end
			end
		else
			self:ResetBonePositions( vm )
		end
	end

	function SWEP:ResetBonePositions( vm )
		if not vm:GetBoneCount() then return end
		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector( 1, 1, 1 ) )
			vm:ManipulateBoneAngles( i, Angle( 0, 0, 0 ) )
			vm:ManipulateBonePosition( i, Vector( 0, 0, 0 ) )
		end
	end

	function table.FullCopy( tab )
		if not tab then return nil end
		local res = {}
		for k, v in pairs( tab ) do
			if type( v ) == "table" then
				res[k] = table.FullCopy( v )
			elseif type( v ) == "Vector" then
				res[k] = Vector( v.x, v.y, v.z )
			elseif type( v ) == "Angle" then
				res[k] = Angle( v.p, v.y, v.r )
			else
				res[k] = v
			end
		end
		return res
	end
end

----------------------------------------------------
function SWEP:Deploy()
	self.Idle = 0
	self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:GetOwner():EmitSound( "weapons/shotgun/shotgun_cock.wav", 55 )
	self:SetNextPrimaryFire( CurTime() + self:SequenceDuration() )
	self:SetNextSecondaryFire( CurTime() + self:SequenceDuration() )
	self:NextThink( CurTime() + self:SequenceDuration() )
	ShotgunReloading = false
	self:SetNWBool( "reloading", false )
	self.Reloadaftershoot = CurTime() + 1
	return true
end

function SWEP:Reload()
	if self:GetOwner():IsPlayer() then
		if self.Reloadaftershoot > CurTime() then return end
		if self:GetNWBool( "reloading", false ) or ShotgunReloading then return end
		if self:Clip1() < self.Primary.ClipSize and self:GetOwner():GetAmmoCount( self.Primary.Ammo ) > 0 then
			ShotgunReloading = true
			self:SetNextPrimaryFire( CurTime() + 0.5 )
			self:SetNextSecondaryFire( CurTime() + 0.5 )
			self:SendWeaponAnim( ACT_SHOTGUN_RELOAD_START )
			self:GetOwner():SetAnimation( PLAYER_RELOAD )
			timer.Simple( 0.3, function()
				if not self:IsValid() then return end
				ShotgunReloading = false
				self:SetNWBool( "reloading", true )
				self:SetVar( "reloadtimer", CurTime() + 1 )
				self:SetNextPrimaryFire( CurTime() + 0.5 )
				self:SetNextSecondaryFire( CurTime() + 0.5 )
			end )
		end
		--[[self.Weapon:SendWeaponAnim(ACT_VM_RELOAD)
		timer.Simple(0.4, function() if self:IsValid() then self.Weapon:SendWeaponAnim(ACT_VM_RELOAD) end end)
		timer.Simple(0.8, function() if self:IsValid() then self.Weapon:SendWeaponAnim(ACT_VM_RELOAD) end end)
		timer.Simple(1.2, function() if self:IsValid() then self.Weapon:SendWeaponAnim(ACT_VM_RELOAD) end end)
		timer.Simple(1.6, function() if self:IsValid() then self.Weapon:SendWeaponAnim(ACT_VM_RELOAD) end end)
		timer.Simple(2.0, function() if self:IsValid() then
			self.Weapon:DefaultReload(ACT_VM_RELOAD)
			end
		end)
		timer.Simple(2.4, function() if self:IsValid() then self.Weapon:SendWeaponAnim(ACT_VM_PUMP) end end)
		]]
	else
		self:DefaultReload( ACT_VM_RELOAD )
	end
end

function SWEP:CanTargBurn( ent )
	if ent:IsPlayer() then -- respawn time
		return 2
	end

	if IsValid( ent ) then
		local phys = ent:GetPhysicsObject()
		if IsValid( phys ) then
			local mat = phys:GetMaterial()
			if ( mat:find( "metal" ) or mat:find( "concrete" ) or mat:find( "rock" ) or mat:find( "plaster" ) ) and not ( mat:find( "barrel" ) or mat:find( "wood" ) ) then return 0 end
		end
	end
	return 7
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )
	if not self:CanPrimaryAttack() or self:GetOwner():WaterLevel() == 3 then return end
	if SERVER then self:GetOwner():EmitSound( self.Primary.Sound ) end
	self:TakePrimaryAmmo( 1 )
	local bullet = {}
	bullet.Num = self.Primary.NumShots
	bullet.Src = self:GetOwner():GetShootPos()
	bullet.Dir = self:GetOwner():GetAimVector()
	bullet.Spread = Vector( self.Primary.Cone, self.Primary.Cone, 0 )
	bullet.Tracer = 1
	--bullet.TracerName = "UniTracer"
	bullet.Callback = function( _, trace, dmginfo )
		if math.random() < 0.33 then
			dmginfo:SetDamageType( DMG_BULLET )
		elseif math.random() > 0.33 then
			dmginfo:SetDamageType( DMG_BLAST )
		else
			dmginfo:SetDamageType( DMG_BURN )
			timer.Simple( 0, function()
				if IsValid( trace.Entity ) and SERVER then
					local val = self:CanTargBurn( trace.Entity )
					if val == 0 then return end
					trace.Entity:Ignite( val )
				end
			end )
		end
	end

	bullet.Force = self.Primary.Force
	bullet.Damage = self.Primary.Damage
	if self:GetOwner():IsPlayer() then self:GetOwner():ViewPunch( Angle( math.Rand( -2, 2 ), math.Rand( -2, 2 ), math.Rand( -2, 2 ) ) ) end
	self:GetOwner():SetVelocity( self:GetOwner():GetAimVector() * -150 )
	self.Reloadaftershoot = CurTime() + self.Primary.Delay
	self:GetOwner():FireBullets( bullet )
	self:ShootEffects()
	local CurrentRecoil = 1.75
	if not self:GetOwner():IsNPC() and ( game.SinglePlayer() and SERVER or not game.SinglePlayer() and CLIENT ) then
		local eyeangle = self:GetOwner():EyeAngles()
		eyeangle.pitch = eyeangle.pitch - CurrentRecoil
		self:GetOwner():SetEyeAngles( eyeangle )
	end

	for i = 0, 4 do
		timer.Simple( i / 100, function()
			if not IsValid( self ) then return end
			local fl = EffectData()
			fl:SetEntity( self )
			fl:SetSurfaceProp( 0 )
			fl:SetOrigin( self:GetOwner():GetShootPos() )
			fl:SetNormal( self:GetOwner():GetAimVector() )
			fl:SetAttachment( 1 )
			util.Effect( "ambeam_2", fl )
		end )
	end

	if self:GetOwner():IsPlayer() then
		self.Idle = 0
		self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
	end
end

function SWEP:SecondaryAttack()
	self:SetNextPrimaryFire( CurTime() + self.Secondary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Secondary.Delay )
	if self:Clip1() <= 1 then
		self:EmitSound( "weapons/shotgun/shotgun_empty.wav" )
		self:Reload()
		return
	end

	if SERVER then self:GetOwner():EmitSound( self.Secondary.Sound ) end
	self:TakePrimaryAmmo( 2 )
	local bullet = {}
	bullet.Num = self.Primary.NumShots * 2
	bullet.Src = self:GetOwner():GetShootPos()
	bullet.Dir = self:GetOwner():GetAimVector()
	bullet.Spread = Vector( self.Primary.Cone + 0.1, self.Primary.Cone + 0.1, 0 )
	bullet.Tracer = 1
	--bullet.TracerName = "UniTracer"
	bullet.Callback = function( _, trace, dmginfo )
		if math.random() < 0.33 then
			dmginfo:SetDamageType( DMG_BULLET )
		elseif math.random() > 0.33 then
			dmginfo:SetDamageType( DMG_BLAST )
		else
			dmginfo:SetDamageType( DMG_BURN )
			timer.Simple( 0, function()
				if IsValid( trace.Entity ) and SERVER then
					local val = self:CanTargBurn( trace.Entity )
					if val == 0 then return end
					trace.Entity:Ignite( val )
				end
			end )
		end
	end

	bullet.Force = self.Primary.Force
	bullet.Damage = self.Primary.Damage + 25
	self:GetOwner():ViewPunch( Angle( math.Rand( -2, 2 ), math.Rand( -2, 2 ), math.Rand( -2, 2 ) ) )
	self:GetOwner():SetVelocity( self:GetOwner():GetAimVector() * -300 )
	self.Reloadaftershoot = CurTime() + self.Secondary.Delay
	self:GetOwner():FireBullets( bullet )
	self:ShootEffects()
	local CurrentRecoil = 2.75
	if not self:GetOwner():IsNPC() and ( game.SinglePlayer() and SERVER or not game.SinglePlayer() and CLIENT ) then
		local eyeangle = self:GetOwner():EyeAngles()
		eyeangle.pitch = eyeangle.pitch - CurrentRecoil
		self:GetOwner():SetEyeAngles( eyeangle )
	end

	for i = 0, 8 do
		timer.Simple( i / 200, function()
			if not IsValid( self ) then return end
			local fl = EffectData()
			fl:SetEntity( self )
			fl:SetSurfaceProp( 0 )
			fl:SetOrigin( self:GetOwner():GetShootPos() )
			fl:SetNormal( self:GetOwner():GetAimVector() )
			fl:SetAttachment( 1 )
			util.Effect( "ambeam_2", fl )
		end )
	end

	self.Idle = 0
	self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
end

function SWEP:Think()
	if self.Idle == 0 and self.IdleTimer <= CurTime() then
		if SERVER then self:SendWeaponAnim( ACT_VM_IDLE ) end
		self.Idle = 1
	end

	if self:Clip1() > self.Primary.ClipSize then self:SetClip1( self.Primary.ClipSize ) end
	if self:GetNWBool( "reloading" ) == true and self:GetNWInt( "reloadtimer" ) < CurTime() then
		if self.unavailable then return end
		if self:Clip1() >= self.Primary.ClipSize or self:GetOwner():GetAmmoCount( self.Primary.Ammo ) <= 0 then
			self:SetNextPrimaryFire( CurTime() + 0.5 )
			self:SetNextSecondaryFire( CurTime() + 0.5 )
			self:SetNWBool( "reloading", false )
			self:SendWeaponAnim( ACT_SHOTGUN_RELOAD_FINISH )
			self:EmitSound( "weapons/shotgun/shotgun_cock.wav" )
		else
			self:SetNWInt( "reloadtimer", CurTime() + 0.25 )
			self:SendWeaponAnim( ACT_VM_RELOAD )
			self:GetOwner():RemoveAmmo( 1, self.Primary.Ammo, false )
			self:SetClip1( self:Clip1() + 1 )
			self:SetNextPrimaryFire( CurTime() + 0.5 )
			self:SetNextSecondaryFire( CurTime() + 0.5 )
			self:EmitSound( "weapons/shotgun/shotgun_reload" .. math.random( 1, 3 ) .. ".wav" )
			--self:GetOwner():SetAnimation(PLAYER_RELOAD)
			if self:Clip1() >= self.Primary.ClipSize or self:GetOwner():GetAmmoCount( self.Primary.Ammo ) <= 0 then
				self:SetNextPrimaryFire( CurTime() + 1.5 )
				self:SetNextSecondaryFire( CurTime() + 1.5 )
			else
				self:SetNextPrimaryFire( CurTime() + 0.5 )
				self:SetNextSecondaryFire( CurTime() + 0.5 )
			end
		end
	end

	if self:GetOwner():KeyPressed( IN_ATTACK ) and self:GetNWBool( "reloading", true ) then
		self:SetNextPrimaryFire( CurTime() + 0.5 )
		self:SetNextPrimaryFire( CurTime() + 0.5 )
		self:SetNWBool( "reloading", false )
		self:SendWeaponAnim( ACT_SHOTGUN_RELOAD_FINISH )
		self:EmitSound( "weapons/shotgun/shotgun_cock.wav" )
	end
end

function SWEP:CanPrimaryAttack()
	if self:Clip1() <= 0 and self.Primary.ClipSize > -1 then
		self:SetNextPrimaryFire( CurTime() + 0.5 )
		self:EmitSound( "weapons/shotgun/shotgun_empty.wav" )
		self:Reload()
		return false
	end
	return true
end

function SWEP:OnDrop()
	self:Holster()
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:Holster()
	if CLIENT and IsValid( self:GetOwner() ) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid( vm ) then self:ResetBonePositions( vm ) end
	end

	self.Idle = 0
	self.IdleTimer = CurTime()
	return true
end

function SWEP:DoImpactEffect( tr )
	if tr.HitSky then return end
	local spark = EffectData()
	spark:SetOrigin( tr.HitPos )
	spark:SetMagnitude( 1 )
	spark:SetRadius( 1 )
	spark:SetScale( 1 )
	util.Effect( "sparks", spark )
end

function SWEP:DrawRotatingCrosshair( x, y, time, length, gap )
	surface.DrawLine( x + math.sin( math.rad( time ) ) * length, y + math.cos( math.rad( time ) ) * length, x + math.sin( math.rad( time ) ) * gap, y + math.cos( math.rad( time ) ) * gap )
end

function SWEP:DrawHUD()
	local x, y = ScrW(), ScrH()
	local w, h = x * 0.5, y * 0.5
	surface.SetDrawColor( 0, 0, 0, 200 )
	surface.DrawRect( w - 1, h - 3, 3, 7 )
	surface.DrawRect( w - 3, h - 1, 7, 3 )
	surface.SetDrawColor( 100, 100, 100, 200 )
	surface.DrawLine( w, h - 5, w, h + 5 )
	surface.DrawLine( w - 5, h, w + 5, h )
	local time = 45
	local scale = 20 * 0.02 -- self.Cone
	local gap = 30 * scale
	local length = gap + 30 * scale
	surface.SetDrawColor( 200, 200, 200, 200 )
	self:DrawRotatingCrosshair( w, h, time, length + 15, gap + 10 )
	self:DrawRotatingCrosshair( w, h, time + 90, length + 15, gap + 10 )
	self:DrawRotatingCrosshair( w, h, time + 180, length + 15, gap + 10 )
	self:DrawRotatingCrosshair( w, h, time + 270, length + 15, gap + 10 )
end

if CLIENT then
	local WorldModel = ClientsideModel( SWEP.WorldModel )
	WorldModel:SetNoDraw( true )
	function SWEP:DrawWorldModel()
		--self:Drawspiral()
		--self.Weapon:DrawModel()
		local _Owner = self:GetOwner()
		local ownervalid = IsValid( _Owner )
		if ownervalid then
			-- Specify a good position
			local offsetVec = Vector( 1, -2, 0 )
			local offsetAng = Angle( 180, 180, 0 )
			local boneid = _Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ) -- Right Hand
			if not boneid then return end
			local matrix = _Owner:GetBoneMatrix( boneid )
			if not matrix then return end
			local newPos, newAng = LocalToWorld( offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles() )
			WorldModel:SetPos( newPos )
			WorldModel:SetAngles( newAng )
			WorldModel:SetModelScale( 0.8 )
			WorldModel:SetupBones()
		else
			WorldModel:SetPos( self:GetPos() )
			WorldModel:SetAngles( self:GetAngles() )
		end

		WorldModel:DrawModel()
	end
end
--PATH addons/_drones/lua/weapons/weapon_drr_fuelcan.lua:
AddCSLuaFile()

SWEP.PrintName	= "Diesel Can"
SWEP.Category = "Drones Rewrite Tools"

SWEP.Spawnable	= true
SWEP.UseHands	= true
SWEP.DrawAmmo	= false

SWEP.Slot			= 0
SWEP.SlotPos		= 5

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo			= "none"

SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/weapons/w_pistol.mdl"
SWEP.snd = false
SWEP.ShowWorldModel = false
SWEP.ViewModelFOV = 45

SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(14.444, -61.112, -14.445) },
	["ValveBiped.Bip01_L_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(-0.556, -13.148, -10.926), angle = Angle(6.556, -7.778, -7.778) },
	["ValveBiped.Grenade_body"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
	["ValveBiped.Bip01_R_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(23.333, -3.333, 3.332) },
	["ValveBiped.Bip01_R_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-21.112, 27.777, -72.223) },
	["ValveBiped.Bip01_R_Forearm"] = { scale = Vector(1, 1, 1), pos = Vector(0, -4.259, -5), angle = Angle(-18.889, 5.556, 1.11) }
}

if CLIENT then
	SWEP.VElements = {
		["m"] = { type = "Model", model = "models/props_junk/gascan001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(5, 7.714, -0.559), angle = Angle(-113.377, -8.183, -97.014), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	}

	SWEP.WElements = {
		["m"] = { type = "Model", model = "models/props_junk/gascan001a.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(4.675, 1.557, 5.714), angle = Angle(0, -104.027, 180), size = Vector(0.5, 0.5, 0.5), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
	}
end

function SWEP:SetFuel(n)
	self.Fuel = n
	self:SetNWInt("Fuel", n)

	if SERVER and n <= 0 then self.Owner:StripWeapon(self.ClassName) end
end

function SWEP:GetFuel()
	return self:GetNWInt("Fuel")
end

function SWEP:Initialize()
	self:SetHoldType("knife")

	if CLIENT then
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self.Owner) then
			local vm = self.Owner:GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
	end

	self:SetFuel(100)
end

function SWEP:PrimaryAttack()
	self:SetNextPrimaryFire(CurTime() + 0.2)

	local drone = util.TraceLine({
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 100,
		filter = self.Owner
	}).Entity

 	if drone.IS_DRR and math.Round(drone:GetFuel()) < drone.MaxFuel and not drone:IsDroneDestroyed() then
 		if self.Sound then self.Sound:ChangeVolume(1, 0.1) end

 		if SERVER then
			self:SetFuel(self:GetFuel() - 1)
			drone:SetFuel(drone:GetFuel() + 1)
		end
	else
		if self.Sound then self.Sound:ChangeVolume(0, 0.1) end
	end
end

function SWEP:Think() 
	if not self.Owner:KeyDown(IN_ATTACK) and self.Owner:KeyReleased(IN_ATTACK) and self.Sound then self.Sound:ChangeVolume(0, 0.1) end
end

function SWEP:SecondaryAttack()
end

function SWEP:Holster()
	if self.Sound then self.Sound:Stop() self.Sound = nil end

	if CLIENT and IsValid(self.Owner) then
		local vm = self.Owner:GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:Deploy()
	self.Sound = CreateSound(self, "ambient/water/leak_1.wav")
	self.Sound:Play()
	self.Sound:ChangeVolume(0)

	return true
end

function SWEP:DrawHUD()
	local x, y = ScrW() * 0.5 - 128, ScrH() - 86
	local w, h = 256, 32

	local val = (self:GetFuel() / 100) * 100

	draw.SimpleText("Fuel: " .. val .. "%", "DronesRewrite_font3", x + 128, y - 42, Color(0, 255, 255, 150), TEXT_ALIGN_CENTER)
						
	surface.SetDrawColor(Color(0, 150, 255, 200))
	surface.DrawOutlinedRect(x - 2, y - 2, w + 4, h + 4)
	surface.DrawRect(x, y, val * 2.56, h)
end


/********************************************************
	SWEP Construction Kit base code
		Created by Clavus
	Available for public use, thread at:
	   facepunch.com/threads/1032378
	   
	   
	DESCRIPTION:
		This script is meant for experienced scripters 
		that KNOW WHAT THEY ARE DOING. Dont come to me 
		with basic Lua questions.
		
		Just copy into your SWEP or SWEP base of choice
		and merge with your own code.
		
		The SWEP.VElements, SWEP.WElements and
		SWEP.ViewModelBoneMods tables are all optional
		and only have to be visible to the client.
********************************************************/

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	
	SWEP.wRenderOrder = nil
	function SWEP:DrawWorldModel()
		
		if (self.ShowWorldModel == nil or self.ShowWorldModel) then
			self:DrawModel()
		end
		
		if (!self.WElements) then return end
		
		if (!self.wRenderOrder) then

			self.wRenderOrder = {}

			for k, v in pairs( self.WElements ) do
				if (v.type == "Model") then
					table.insert(self.wRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.wRenderOrder, k)
				end
			end

		end
		
		if (IsValid(self.Owner)) then
			bone_ent = self.Owner
		else
			// when the weapon is dropped
			bone_ent = self
		end
		
		for k, name in pairs( self.wRenderOrder ) do
		
			local v = self.WElements[name]
			if (!v) then self.wRenderOrder = nil break end
			if (v.hide) then continue end
			
			local pos, ang
			
			if (v.bone) then
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent )
			else
				pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )
			end
			
			if (!pos) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we cant do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or youll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end

--PATH addons/__main/lua/weapons/weapon_hl2shovel/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Shovel"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack : Push"
SWEP.Category				= "HL2 Melee Pack"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_shovel.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_shovel.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 50
SWEP.HitInclination		= 0.4
SWEP.HitPushback		= 2000
SWEP.HitRate			= 1.25
SWEP.MinDamage			= 24
SWEP.MaxDamage			= 32

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.ImpactHard" )
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self.Owner:SetAnimation( PLAYER_ATTACK1 )

	local vm = self.Owner:GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay", 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay" )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	local tr = util.TraceLine( {
		start = self.Owner:GetShootPos(),
		endpos = self.Owner:GetShootPos() + self.Owner:GetAimVector() * 1.5 * 40,
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

	if ( tr.Hit ) then
	self:EmitSound( PushSoundBody )
	if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") or string.find(tr.Entity:GetClass(),"prop_physics") then
	tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * 500 )
	end
	end

end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()

//This function calculate the trajectory

	for i=0, 170 do

	local tr = util.TraceLine( {
		start = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)),
		endpos = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10)) + ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.7 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) ),
		filter = self.Owner,
		mask = MASK_SHOT_HULL
	} )

//This if shot the bullets

	if ( tr.Hit ) then
		
		local strikevector = ( self.Owner:EyeAngles():Up() * ( self.HitDistance * 0.5 * math.cos(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Forward() * ( self.HitDistance * 1.5 * math.sin(math.rad(i)) ) ) + ( self.Owner:EyeAngles():Right() * self.HitInclination * self.HitDistance * math.cos(math.rad(i)) )

		
		bullet = {}
		bullet.Num    = 1
		bullet.Src    = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 15))
		bullet.Dir    = strikevector:GetNormalized()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 15
		bullet.Hullsize = 0
		bullet.Distance = self.HitDistance * 1.5
		bullet.Damage = math.random( 24, 32 )
		self.Owner:FireBullets(bullet)

		//local vPoint = (self.Owner:GetShootPos() - (self.Owner:EyeAngles():Up() * 10))
		//local effectdata = EffectData()
		//effectdata:SetOrigin( vPoint )
		//util.Effect( "BloodImpact", effectdata )

		self:EmitSound( SwingSound )

		//vm:SendViewModelMatchingSequence( vm:LookupSequence( "hitcenter1" ) )

		if tr.Entity:IsPlayer() or string.find(tr.Entity:GetClass(),"npc") or string.find(tr.Entity:GetClass(),"prop_ragdoll") then
			self:EmitSound( HitSoundBody )
			tr.Entity:SetVelocity( self.Owner:GetAimVector() * Vector( 1, 1, 0 ) * self.HitPushback )
		else
			self:EmitSound( HitSoundWorld )
		end
//if break
		break
//if end
		//else vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )
		end
end

end

function SWEP:Deploy()

	local vm = self.Owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()

	timer.Remove("hitdelay")
	return true
end
--PATH addons/__main/lua/weapons/weapon_long_revolver.lua:
SWEP.PrintName = "Long Revolver"
SWEP.Author = "DerHobbyRoller"
SWEP.Instructions = "Left Mouse Button to Shoot lol"
SWEP.Spawnable = true
SWEP.AdminOnly = false


SWEP.Primary.ClipSize = 18
SWEP.Primary.DefaultClip = 18
SWEP.Primary.Ammo = "357"
SWEP.Primary.Automatic = false
SWEP.Primary.Recoil = 1111
SWEP.Primary.Damage = 200
SWEP.Primary.NumShots = 1
SWEP.Primary.Spread = 0
SWEP.Primary.Cone = 0
SWEP.Primary.Delay = 1


SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Automatic = false


SWEP.Weight			= 7
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false

SWEP.Slot			= 1
SWEP.SlotPos			= 2
SWEP.DrawAmmo			= true
SWEP.DrawCrosshair		= true


SWEP.ViewModel			= "models/weapons/default/c_357.mdl"
SWEP.WorldModel			= "models/weapons/default/w_357.mdl"

if CLIENT then
SWEP.WepSelectIcon = surface.GetTextureID("VGUI/entities/iconNormal")
SWEP.IconOverride = "materials/entities/longRevolverDefault.png"
end

SWEP.Category = "Long Revolver"
SWEP.UseHands = true

SWEP.SetHoldType = "pistol"

local ShootSound = Sound("Weapon_357.single")

function SWEP:PrimaryAttack()
	if ( !self:CanPrimaryAttack() ) then return end

	local ply = self:GetOwner()
	ply:LagCompensation(true)

	for i = 1, 3 do
		if ( !self:CanPrimaryAttack() ) then break end
		self:ShootBullet( 75, 1, 0.002 )
		self:ShootEffects()
		self:TakePrimaryAmmo(1)
		self:EmitSound(ShootSound)
		self.Owner:ViewPunch( Angle( -5, 0, 0 ) )
		self.BaseClass.ShootEffects(self)

	end
	
	
	self:SetNextPrimaryFire(CurTime() + self.Primary.Delay+0.1)

	
	ply:LagCompensation(false)
	

end
--PATH addons/lvs_cars_3027255911/lua/weapons/weapon_lvsfuelfiller.lua:
AddCSLuaFile()

SWEP.Category				= "[LVS]"
SWEP.Spawnable			= false
SWEP.AdminSpawnable		= false
SWEP.ViewModel			= "models/weapons/c_fuelfillerlvs.mdl"
SWEP.WorldModel			= "models/props_equipment/gas_pump_p13.mdl"
SWEP.UseHands				= true

SWEP.HoldType				= "slam"

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo		= "none"

SWEP.RangeToCap = 24
SWEP.HitDistance = 128

function SWEP:SetupDataTables()
	self:NetworkVar( "Int",0, "FuelType" )
	self:NetworkVar( "Entity",0, "CallbackTarget" )
end

function SWEP:GetTank( entity )
	if entity.lvsGasStationRefillMe then
		return entity
	end

	if not entity.LVS or not entity.GetFuelTank then return NULL end

	return entity:GetFuelTank()
end

function SWEP:GetCap( entity )
	if entity.lvsGasStationRefillMe then
		return entity
	end

	if not entity.LVS or not entity.GetFuelTank then return NULL end

	local FuelTank = entity:GetFuelTank()

	if not IsValid( FuelTank ) then return NULL end

	return FuelTank:GetDoorHandler()
end

if CLIENT then
	SWEP.PrintName		= "Fuel Filler Pistol"
	SWEP.Slot				= 1
	SWEP.SlotPos			= 3

	SWEP.DrawWeaponInfoBox 	= false

	local FrameMat = Material( "lvs/3d2dmats/frame.png" )
	local RefuelMat = Material( "lvs/3d2dmats/refuel.png" )

	function SWEP:DrawWeaponSelection( x, y, wide, tall, alpha )
	end

	function SWEP:DrawWorldModel()
		local ply = self:GetOwner()

		if not IsValid( ply ) then return end

		local id = ply:LookupAttachment("anim_attachment_rh")
		local attachment = ply:GetAttachment( id )

		if not attachment then return end

		local pos = attachment.Pos + attachment.Ang:Forward() * 6 + attachment.Ang:Right() * -1.5 + attachment.Ang:Up() * 2.2
		local ang = attachment.Ang
		ang:RotateAroundAxis(attachment.Ang:Up(), 20)
		ang:RotateAroundAxis(attachment.Ang:Right(), -30)
		ang:RotateAroundAxis(attachment.Ang:Forward(), 0)

		self:SetRenderOrigin( pos )
		self:SetRenderAngles( ang )

		self:DrawModel()	
	end

	local function DrawText( pos, text, col )
		local data2D = pos:ToScreen()

		if not data2D.visible then return end

		local font = "TargetIDSmall"

		local x = data2D.x
		local y = data2D.y
		draw.SimpleText( text, font, x + 1, y + 1, Color( 0, 0, 0, 120 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		draw.SimpleText( text, font, x + 2, y + 2, Color( 0, 0, 0, 50 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		draw.SimpleText( text, font, x, y, col or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	end

	local function DrawIcon( pos, fueltype, fuelamount, visible )
		local data2D = pos:ToScreen()

		if not data2D.visible then return end

		local data = LVS.FUELTYPES[ fueltype ]

		if not istable( data ) then return end

		local x = data2D.x
		local y = data2D.y

		local scale = visible and 2 or 1

		if visible then
			local IconColor = Color( data.color.x, data.color.y, data.color.z, 200 )
			local ScissorScale = 50
			local offset = ScissorScale * scale * fuelamount
			local offset2 = ScissorScale * scale * (1 - fuelamount)

			surface.SetDrawColor( Color(0,0,0,200) )
			render.SetScissorRect(  x - 40 * scale, y - ScissorScale * 0.5 * scale - offset, x + 40 * scale, y + ScissorScale * 0.5 * scale - offset, true )
			surface.SetMaterial( FrameMat )
			surface.DrawTexturedRect( x - 25 * scale, y - 25 * scale, 50 * scale, 50 * scale )
			surface.SetMaterial( RefuelMat )
			surface.DrawTexturedRect( x - 40 * scale, y - 40 * scale, 80 * scale, 80 * scale )

			surface.SetDrawColor( IconColor )
			render.SetScissorRect(  x - 40 * scale, y - ScissorScale * 0.5 * scale + offset2, x + 40 * scale, y + ScissorScale * 0.5 * scale + offset2, true )
			surface.SetMaterial( FrameMat )
			surface.DrawTexturedRect( x - 25 * scale, y - 25 * scale, 50 * scale, 50 * scale )
			surface.SetMaterial( RefuelMat )
			surface.DrawTexturedRect( x - 40 * scale, y - 40 * scale, 80 * scale, 80 * scale )
			render.SetScissorRect( 0,0,0,0,false )

			draw.SimpleText( data.name, "LVS_FONT", x, y - 40 * scale, IconColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		else
			local IconColor = Color( data.color.x, data.color.y, data.color.z, 100 )

			surface.SetDrawColor( IconColor )

			surface.SetMaterial( FrameMat )
			surface.DrawTexturedRect( x - 25 * scale, y - 25 * scale, 50 * scale, 50 * scale )
			surface.SetMaterial( RefuelMat )
			surface.DrawTexturedRect( x - 40 * scale, y - 40 * scale, 80 * scale, 80 * scale )
		end
	end

	function SWEP:DrawHUD()
		local ply = self:GetOwner()

		if not IsValid( ply ) then return end

		local startpos = ply:GetShootPos()
		local endpos = startpos + ply:GetAimVector() * self.HitDistance

		local trace = util.TraceLine( {
			start = startpos ,
			endpos = endpos,
			filter = ply,
			mask = MASK_SHOT_HULL
		} )

		if not IsValid( trace.Entity ) then
			trace = util.TraceHull( {
				start = startpos ,
				endpos = endpos,
				filter = ply,
				mins = Vector( -10, -10, -8 ),
				maxs = Vector( 10, 10, 8 ),
				mask = MASK_SHOT_HULL
			} )
		end

		local FuelTank = self:GetTank( trace.Entity )
		local FuelCap = self:GetCap( trace.Entity )

		if not IsValid( FuelTank ) then return end

		local pos = trace.HitPos
		local fuelamount = FuelTank:GetFuel()
		local fueltype = FuelTank:GetFuelType()

		if fueltype ~= self:GetFuelType() then

			local FuelName = LVS.FUELTYPES[ fueltype ].name or ""

			DrawText( trace.HitPos, "Incorrect Fuel Type. Requires: "..FuelName, Color(255,0,0,255) )

			return
		end

		if not IsValid( FuelCap ) then
			DrawIcon( pos, fueltype, fuelamount, true )
			DrawText( pos, math.Round(fuelamount * 100,1).."%", Color(0,255,0,255) )

			return
		end

		if FuelCap:IsOpen() then
			if (trace.HitPos - FuelCap:GetPos()):Length() > self.RangeToCap then
				DrawIcon( FuelCap:GetPos(), fueltype, fuelamount, false )
				DrawText( pos, "Aim at Fuel Cap!", Color(255,255,0,255) )
			else
				DrawIcon( FuelCap:GetPos(), fueltype, fuelamount, true )
				DrawText( pos, math.Round(fuelamount * 100,1).."%", Color(0,255,0,255) )
			end

			return
		end

		local Key = input.LookupBinding( "+use" )

		if not isstring( Key ) then Key = "[+use is not bound to a key]" end

		local pos = FuelCap:GetPos()

		DrawIcon( pos, fueltype, fuelamount, false )
		DrawText( pos, "Press "..Key.." to Open", Color(255,255,0,255) )
	end
end

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
end

function SWEP:PrimaryAttack()

	self:SetNextPrimaryFire( CurTime() + 0.5 )

	local ply = self:GetOwner()

	if not IsValid( ply ) then return end

	local startpos = ply:GetShootPos()
	local endpos = startpos + ply:GetAimVector() * self.HitDistance

	local trace = util.TraceLine( {
		start = startpos ,
		endpos = endpos,
		filter = ply,
		mask = MASK_SHOT_HULL
	} )

	if not IsValid( trace.Entity ) then
		trace = util.TraceHull( {
			start = startpos ,
			endpos = endpos,
			filter = ply,
			mins = Vector( -10, -10, -8 ),
			maxs = Vector( 10, 10, 8 ),
			mask = MASK_SHOT_HULL
		} )
	end

	self:Refuel( trace )
end

function SWEP:SecondaryAttack()
end

function SWEP:Refuel( trace )
	local entity = trace.Entity

	if CLIENT or not IsValid( entity ) then return end

	local FuelCap = self:GetCap( entity )
	local FuelTank = self:GetTank( entity )

	if not IsValid( FuelTank ) then return end

	if FuelTank:GetFuelType() ~= self:GetFuelType() then return end

	if IsValid( FuelCap ) then
		if not FuelCap:IsOpen() then return end

		if (trace.HitPos - FuelCap:GetPos()):Length() > self.RangeToCap then return end
	end

	if FuelTank:GetFuel() == 1 then return end

	local Target = self:GetCallbackTarget()

	if FuelTank == Target then return end

	if IsValid( Target ) and Target.TakeFuel then
		local Size = FuelTank:GetSize()
		local Cur = FuelTank:GetFuel()
		local Need = 1 - Cur
		local Add = Target:TakeFuel( Need * Size )

		if Add > 0 then
			FuelTank:SetFuel( Cur + Add / Size )
			entity:OnRefueled()
		end

		return
	end

	FuelTank:SetFuel( math.min( FuelTank:GetFuel() + (entity.lvsGasStationFillSpeed or 0.05), 1 ) )
	entity:OnRefueled()
end
--PATH addons/_avatar/lua/weapons/weapon_metal_bending.lua:
SWEP.Category = "Avatar"
SWEP.PrintName = "Metal Bending"
SWEP.Author = "Kilburn, robotboy655, MaxOfS2D, Tenrys & Kurome76" -- changing this will void your support
SWEP.Purpose = "Bend Earth."
SWEP.Slot = 1
SWEP.SlotPos = 10
SWEP.Spawnable = true
SWEP.ViewModel = Model( "models/weapons/c_arms.mdl" )
SWEP.WorldModel = ""
SWEP.ViewModelFOV = 54
SWEP.UseHands = true
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.DrawAmmo = false
local SwingSound = Sound( "WeaponFrag.Throw" )
function SWEP:Initialize()
	self:SetHoldType( "fist" )
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Float", 0, "NextMeleeAttack" )
	self:NetworkVar( "Float", 1, "NextIdle" )
end

function SWEP:GetViewModelPosition( pos, ang )
	--this is always applied
	local DefPos = Vector( 0, 0, -1 )
	local DefAng = Vector( 0, 0, 0 )
	if DefAng then
		ang = ang * 1
		ang:RotateAroundAxis( ang:Right(), DefAng.x )
		ang:RotateAroundAxis( ang:Up(), DefAng.y )
		ang:RotateAroundAxis( ang:Forward(), DefAng.z )
	end

	if DefPos then
		local Right = ang:Right()
		local Up = ang:Up()
		local Forward = ang:Forward()
		pos = pos + DefPos.x * Right
		pos = pos + DefPos.y * Forward
		pos = pos + DefPos.z * Up
	end
	return pos, ang
end

function SWEP:UpdateNextIdle()
	local vm = self:GetOwner():GetViewModel()
	self:SetNextIdle( CurTime() + vm:SequenceDuration() / vm:GetPlaybackRate() )
end

function SWEP:PrimaryAttack()
	local owner = self:GetOwner()
	owner:SetAnimation( PLAYER_ATTACK1 )
	local vm = owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "fists_uppercut" ) )
	self:EmitSound( SwingSound )
	self:UpdateNextIdle()
	self:SetNextMeleeAttack( CurTime() + 0.2 )
	self:SetNextPrimaryFire( CurTime() + 0.9 )
	self:SetNextSecondaryFire( CurTime() + 0.9 )
end

local randomErruptionMdlTbl = { "models/props_wasteland/rockcliff01b.mdl", "models/props_wasteland/rockcliff01c.mdl", "models/props_wasteland/rockcliff01e.mdl", "models/props_wasteland/rockcliff01f.mdl", "models/props_wasteland/rockcliff01g.mdl", "models/props_wasteland/rockcliff01j.mdl", "models/props_wasteland/rockcliff01k.mdl" }
function SWEP:SecondaryAttack()
	local owner = self:GetOwner()
	owner:SetAnimation( PLAYER_ATTACK1 )
	local vm = owner:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "fists_uppercut" ) )
	self:EmitSound( SwingSound )
	self:UpdateNextIdle()
	self:SetNextPrimaryFire( CurTime() + 0.9 )
	self:SetNextSecondaryFire( CurTime() + 0.9 )
	if SERVER then
		local srcpos = owner:GetShootPos()
		local tr = util.TraceLine( {
			start = srcpos,
			endpos = srcpos + vector_up * -110,
			filter = owner
		} )

		if tr.Hit then
			if owner:EyeAngles().p > 75 then
				local metalshrapnel = ents.Create( "prop_dynamic" )
				metalshrapnel:SetModel( table.Random( randomErruptionMdlTbl ) )
				metalshrapnel:SetAngles( Angle( 0, math.random( 0, 360 ), 0 ) )
				metalshrapnel:SetPos( tr.HitPos + tr.HitNormal * -20 )
				metalshrapnel:SetColor( color_white )
				metalshrapnel:SetRenderMode( RENDERMODE_NORMAL )
				metalshrapnel:SetKeyValue( "solid", "6" )
				metalshrapnel:Spawn()
				metalshrapnel:Activate()
				metalshrapnel.DoNotDuplicate = true
				metalshrapnel:SetPhysicsAttacker( owner, 5 )
				metalshrapnel:SetOwner( owner )
				metalshrapnel:Fire( "kill", "", 2 )
				sound.Play( "physics/concrete/boulder_impact_hard" .. math.random( 1, 4 ) .. ".wav", tr.HitPos )
				util.ScreenShake( tr.HitPos, 5, 5, 1, 256 )
				local dmginfo = DamageInfo()
				dmginfo:SetAttacker( owner )
				dmginfo:SetInflictor( metalshrapnel )
				dmginfo:SetDamage( math.random( 20, 40 ) )
				dmginfo:SetDamageForce( vector_up * 6000 )
				dmginfo:SetDamageType( DMG_CRUSH )
				for _, v in ipairs( ents.FindAlongRay( tr.HitPos, tr.HitPos + vector_up * 128, Vector( -60, -60, -60 ), Vector( 60, 60, 60 ) ) ) do
					if v ~= owner and IsValid( v ) and not v:IsWeapon() then
						local phys = v:GetPhysicsObject()
						if IsValid( phys ) then phys:ApplyForceOffset( vector_up * 80 * phys:GetMass(), owner:GetShootPos() ) end
						v:TakeDamageInfo( dmginfo )
						if v:IsPlayer() or v:IsNPC() or v.Type == "nextbot" then
							v:SetVelocity( -owner:GetAimVector() * 650 )
							if v.Type == "nextbot" then v.loco:SetVelocity( -owner:GetAimVector() * 650 ) end
						end
					end
				end

				owner:SetVelocity( -owner:GetAimVector() * 600 )
				timer.Simple( 2 / 20, function()
					if not IsValid( metalshrapnel ) then return end
					for i = 0, 40 do
						timer.Simple( i / 45, function()
							if not IsValid( metalshrapnel ) then return end
							metalshrapnel:SetPos( metalshrapnel:GetPos() + vector_up * -math.Rand( 2, 5 ) * 2 + VectorRand() * 4 )
							metalshrapnel:SetAngles( metalshrapnel:GetAngles() + Angle( 0, math.random( -34, 34 ), 0 ) )
						end )
					end
				end )
				return
			end

			for i = 2, 40 do
				local forward = owner:GetAimVector() * 45 * i
				local ftr = util.TraceLine( {
					start = srcpos + forward,
					endpos = srcpos + forward + owner:GetAimVector() * 70,
					filter = owner
				} )

				if not ftr.HitWorld then
					local ownr = owner
					timer.Simple( i / 20, function()
						local dtr = util.TraceLine( {
							start = srcpos + forward,
							endpos = srcpos + forward + vector_up * -400,
							filter = ownr
						} )

						if dtr.HitWorld then
							local metalshrapnel = ents.Create( "prop_dynamic" )
							metalshrapnel:SetModel( table.Random( randomErruptionMdlTbl ) )
							metalshrapnel:SetAngles( Angle( 0, math.random( 0, 360 ), 0 ) )
							metalshrapnel:SetPos( dtr.HitPos + dtr.HitNormal * -20 )
							metalshrapnel:SetColor( color_white )
							metalshrapnel:SetRenderMode( RENDERMODE_NORMAL )
							metalshrapnel:SetKeyValue( "solid", "6" )
							metalshrapnel:Spawn()
							metalshrapnel:Activate()
							metalshrapnel.DoNotDuplicate = true
							metalshrapnel:SetPhysicsAttacker( ownr, 5 )
							metalshrapnel:SetOwner( ownr )
							metalshrapnel:Fire( "kill", "", 4 - i / 20 )
							sound.Play( "physics/concrete/boulder_impact_hard" .. math.random( 1, 4 ) .. ".wav", dtr.HitPos )
							util.ScreenShake( dtr.HitPos, 5, 5, 1, 256 )
							local dmginfo = DamageInfo()
							dmginfo:SetAttacker( ownr )
							dmginfo:SetInflictor( metalshrapnel )
							dmginfo:SetDamage( math.random( 100, 500 ) )
							dmginfo:SetDamageForce( vector_up * 6000 )
							dmginfo:SetDamageType( DMG_CRUSH )
							for _, v in ipairs( ents.FindAlongRay( dtr.HitPos, dtr.HitPos + vector_up * 128, Vector( -60, -60, -60 ), Vector( 60, 60, 60 ) ) ) do
								if v ~= ownr and IsValid( v ) and not v:IsWeapon() then
									local phys = v:GetPhysicsObject()
									if IsValid( phys ) then phys:ApplyForceOffset( vector_up * 80 * phys:GetMass(), ownr:GetShootPos() ) end
									v:TakeDamageInfo( dmginfo )
								end
							end

							timer.Simple( 3 - i / 20, function()
								if not IsValid( metalshrapnel ) then return end
								for i = 0, 40 do
									timer.Simple( i / 45, function()
										if not IsValid( metalshrapnel ) then return end
										metalshrapnel:SetPos( metalshrapnel:GetPos() + vector_up * -math.Rand( 2, 5 ) * 2 + VectorRand() * 4 )
										metalshrapnel:SetAngles( metalshrapnel:GetAngles() + Angle( 0, math.random( -34, 34 ), 0 ) )
									end )
								end
							end )
						end
					end )
				end
			end
		end
	end
end

local multiMdlTbl = { "models/props_debris/metal_panelshard01a.mdl", "models/props_debris/metal_panelshard01b.mdl", "models/props_debris/metal_panelshard01c.mdl", "models/props_debris/metal_panelshard01d.mdl" }
function SWEP:DealDamage()
	if SERVER then
		local owner = self:GetOwner()
		local srcpos = owner:GetShootPos() + owner:GetForward() * 64
		local tr = util.TraceLine( {
			start = srcpos,
			endpos = srcpos + vector_up * -110,
			filter = owner
		} )

		if tr.Hit then
			for _ = 0, 4 do
				local metalshrapnel = ents.Create( "prop_physics" )
				metalshrapnel:SetModel( table.Random( multiMdlTbl ) )
				metalshrapnel:SetPos( tr.HitPos + tr.HitNormal * 16 + VectorRand() * 16 )
				metalshrapnel:SetColor( color_white )
				metalshrapnel:SetRenderMode( RENDERMODE_NORMAL )
				metalshrapnel:Spawn()
				metalshrapnel:Activate()
				metalshrapnel.DoNotDuplicate = true
				metalshrapnel:SetPhysicsAttacker( owner, 5 )
				metalshrapnel:SetOwner( owner )
				metalshrapnel:Fire( "kill", "", 5 )
				metalshrapnel:EmitSound( "physics/metal/metal_box_impact_bullet" .. math.random( 1, 3 ) .. ".wav" )
				metalshrapnel:AddCallback( "PhysicsCollide", function( ent, data )
					if data.DeltaTime > 0.2 then
						if data.Speed > 250 then
							if IsValid( data.HitEntity ) then
								local dmginfo = DamageInfo()
								dmginfo:SetAttacker( ent:GetPhysicsAttacker( 5 ) )
								dmginfo:SetInflictor( ent )
								dmginfo:SetDamage( 50 )
								dmginfo:SetDamageType( 5 )
								dmginfo:SetDamageForce( data.OurOldVelocity )
								data.HitEntity:TakeDamageInfo( dmginfo )
							end

							ent:EmitSound( "physics/metal/metal_box_break" .. math.random( 1, 3 ) .. ".wav", 75, math.random( 90, 110 ), 0.5 )
						end
					end
				end )

				local phys = metalshrapnel:GetPhysicsObject()
				if IsValid( phys ) then
					phys:SetMass( 50 )
					phys:AddGameFlag( FVPHYSICS_HEAVY_OBJECT )
					phys:AddGameFlag( FVPHYSICS_DMG_SLICE )
					phys:SetVelocity( metalshrapnel:GetUp() * 240 + self:GetOwner():GetVelocity() )
					phys:EnableDrag( false )
					--phys:SetBuoyancyRatio(0)
				end

				timer.Simple( 0.35, function()
					if not IsValid( metalshrapnel ) or not IsValid( self ) or not IsValid( owner ) then return end
					metalshrapnel:SetAngles( owner:EyeAngles() )
					metalshrapnel:EmitSound( "physics/metal/metal_box_impact_bullet" .. math.random( 1, 3 ) .. ".wav" )
					local phys = metalshrapnel:GetPhysicsObject()
					if IsValid( phys ) then
						phys:SetVelocity( metalshrapnel:GetForward() * 3000 + vector_up * 100 )
						phys:SetAngleVelocity( metalshrapnel:GetUp() * 2000 )
					end
				end )
			end

			timer.Simple( 0.27, function()
				if not IsValid( self ) then return end
				local anim = "fists_left"
				if math.random() < 0.5 then anim = "fists_right" end
				local vm = owner:GetViewModel()
				vm:SendViewModelMatchingSequence( vm:LookupSequence( anim ) )
				owner:SetAnimation( PLAYER_ATTACK1 )
			end )
		end
	end
end

function SWEP:Think()
	local vm = self:GetOwner():GetViewModel()
	local idletime = self:GetNextIdle()
	if idletime > 0 and CurTime() > idletime then
		vm:SendViewModelMatchingSequence( vm:LookupSequence( "fists_idle_0" .. math.random( 1, 2 ) ) )
		self:UpdateNextIdle()
	end

	local meleetime = self:GetNextMeleeAttack()
	if meleetime > 0 and CurTime() > meleetime then
		self:DealDamage()
		self:SetNextMeleeAttack( 0 )
	end
end

function SWEP:Deploy()
	local speed = GetConVar( "sv_defaultdeployspeed" ):GetInt()
	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "fists_draw" ) )
	vm:SetPlaybackRate( speed )
	self:SetNextPrimaryFire( CurTime() + vm:SequenceDuration() / speed )
	self:SetNextSecondaryFire( CurTime() + vm:SequenceDuration() / speed )
	self:UpdateNextIdle()
	return true
end

function SWEP:Holster()
	self:SetNextMeleeAttack( 0 )
	return true
end

function SWEP:OnRemove()
	self:Holster()
	return true
end

function SWEP:OnDrop()
	self:Holster()
	self:Remove() -- You can't drop fists
end

local color1 = Color( 60, 150, 150 )
function SWEP:DrawHUD()
	local x, y = ScrW(), ScrH()
	local w, h = x * 0.5, y * 0.5
	draw.SimpleTextOutlined( "Стихія: Земля (Метал)", onyx.Font( "Comfortaa@24" ), w, y - h / 8, color1, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, color_black )
end
--PATH addons/_avatar/lua/weapons/weapon_sokka_boomerang.lua:
if CLIENT then
	SWEP.DrawWeaponInfoBox = false
	SWEP.BounceWeaponIcon = false
	language.Add( "weapon_sokka_Boomerang", "Sokka Boomerang" )
end

SWEP.PrintName = "Sokka Boomerang"
SWEP.Category = "Avatar"
SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.AdminOnly = false
SWEP.ViewModelFOV = 75
SWEP.ViewModel = "models/weapons/c_grenade.mdl"
SWEP.WorldModel = "models/avatar/sokka_boomerang.mdl"
SWEP.ViewModelFlip = false
SWEP.BobScale = 1
SWEP.SwayScale = 1
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = false
SWEP.Weight = 0
SWEP.Slot = 1
SWEP.SlotPos = 10
SWEP.UseHands = true
SWEP.HoldType = "grenade"
SWEP.FiresUnderwater = true
SWEP.DrawCrosshair = true
SWEP.DrawAmmo = true
SWEP.CSMuzzleFlashes = 1
SWEP.Base = "weapon_base"
SWEP.ShowViewModel = false
SWEP.ShowWorldModel = true
SWEP.Idle = 0
SWEP.IdleTimer = CurTime()
SWEP.Primary.Sound = Sound( "common/null.wav" )
SWEP.Primary.ClipSize = 1
SWEP.Primary.DefaultClip = 1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"
SWEP.Primary.Damage = 500
SWEP.Primary.DelayMiss = 0.6
SWEP.Primary.DelayHit = 0.3
SWEP.Primary.Force = 1500
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Delay = 0.5
SWEP.ViewModelBoneMods = {
	["ValveBiped.Bip01_L_UpperArm"] = {
		scale = Vector( 1, 1, 1 ),
		pos = Vector( 0, -10, -10 ),
		angle = Angle( 0, 0, 0 )
	},
	["ValveBiped.Bip01_R_UpperArm"] = {
		scale = Vector( 1, 1, 1 ),
		pos = Vector( 0, 0, 0 ),
		angle = Angle( 0, 0, 26.6 )
	},
	["ValveBiped.Grenade_body"] = {
		scale = Vector( 0.009, 0.009, 0.009 ),
		pos = Vector( 0, 0, 0 ),
		angle = Angle( 0, 0, 0 )
	}
}

SWEP.VElements = {
	["v_element"] = {
		type = "Model",
		model = "models/avatar/sokka_boomerang.mdl",
		bone = "ValveBiped.Grenade_body",
		rel = "",
		pos = Vector( 0, -0.491, -10.466 ),
		angle = Angle( -7.934, -23.119, -88.633 ),
		size = Vector( 1, 1, 1 ),
		color = Color( 255, 255, 255, 255 ),
		surpresslightning = false,
		material = "",
		skin = 0,
		bodygroup = {}
	}
}

function SWEP:Initialize()
	self:SetHoldType( self.HoldType )
	self:SetWeaponHoldType( self.HoldType )
	self.Idle = 0
	self.IdleTimer = CurTime() + 1
	if CLIENT then
		-- Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )
		self:SetWeaponHoldType( self.HoldType )
		self:CreateModels( self.VElements ) -- create viewmodels
		-- init view model bone build function
		if IsValid( self:GetOwner() ) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid( vm ) then
				self:ResetBonePositions( vm )
				-- Init viewmodel visibility
				if self.ShowViewModel == nil or self.ShowViewModel then
					vm:SetColor( Color( 255, 255, 255, 255 ) )
				else
					-- we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor( Color( 255, 255, 255, 1 ) )
					-- ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					-- however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial( "Debug/hsv" )
				end
			end
		end
	end
end

----------------------------------------------------
if CLIENT then
	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		local vm = self:GetOwner():GetViewModel()
		if not IsValid( vm ) then return end
		if not self.VElements then return end
		self:UpdateBonePositions( vm )
		if not self.vRenderOrder then
			-- we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}
			for k, v in pairs( self.VElements ) do
				if v.type == "Model" then
					table.insert( self.vRenderOrder, 1, k )
				elseif v.type == "Sprite" or v.type == "Quad" then
					table.insert( self.vRenderOrder, k )
				end
			end
		end

		for _, name in ipairs( self.vRenderOrder ) do
			local v = self.VElements[name]
			if not v then
				self.vRenderOrder = nil
				break
			end

			if v.hide then continue end
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			if not v.bone then continue end
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			if not pos then continue end
			if v.type == "Model" and IsValid( model ) then
				model:SetPos( pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				model:SetAngles( ang )
				--model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale( v.size )
				model:EnableMatrix( "RenderMultiply", matrix )
				if v.material == "" then
					model:SetMaterial( "" )
				elseif model:GetMaterial() ~= v.material then
					model:SetMaterial( v.material )
				end

				if v.skin and v.skin ~= model:GetSkin() then model:SetSkin( v.skin ) end
				if v.bodygroup then
					for k, v in ipairs( v.bodygroup ) do
						if model:GetBodygroup( k ) ~= v then model:SetBodygroup( k, v ) end
					end
				end

				if v.surpresslightning then render.SuppressEngineLighting( true ) end
				render.SetColorModulation( v.color.r / 255, v.color.g / 255, v.color.b / 255 )
				render.SetBlend( v.color.a / 255 )
				model:DrawModel()
				render.SetBlend( 1 )
				render.SetColorModulation( 1, 1, 1 )
				if v.surpresslightning then render.SuppressEngineLighting( false ) end
			elseif v.type == "Sprite" and sprite then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial( sprite )
				render.DrawSprite( drawpos, v.size.x, v.size.y, v.color )
			elseif v.type == "Quad" and v.draw_func then
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis( ang:Up(), v.angle.y )
				ang:RotateAroundAxis( ang:Right(), v.angle.p )
				ang:RotateAroundAxis( ang:Forward(), v.angle.r )
				cam.Start3D2D( drawpos, ang, v.size )
				v.draw_func( self )
				cam.End3D2D()
			end
		end
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		local bone, pos, ang
		if tab.rel and tab.rel ~= "" then
			local v = basetab[tab.rel]
			if not v then return end
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			if not pos then return end
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis( ang:Up(), v.angle.y )
			ang:RotateAroundAxis( ang:Right(), v.angle.p )
			ang:RotateAroundAxis( ang:Forward(), v.angle.r )
		else
			bone = ent:LookupBone( bone_override or tab.bone )
			if not bone then return end
			pos, ang = Vector( 0, 0, 0 ), Angle( 0, 0, 0 )
			local m = ent:GetBoneMatrix( bone )
			if m then pos, ang = m:GetTranslation(), m:GetAngles() end
			if IsValid( self:GetOwner() ) and self:GetOwner():IsPlayer() and ent == self:GetOwner():GetViewModel() and self.ViewModelFlip then
				ang.r = -ang.r -- Fixes mirrored models
			end
		end
		return pos, ang
	end

	function SWEP:CreateModels( tab )
		if not tab then return end
		for _, v in pairs( tab ) do
			if v.type == "Model" and v.model and v.model ~= "" and ( not IsValid( v.modelEnt ) or v.createdModel ~= v.model ) and string.find( v.model, ".mdl" ) and file.Exists( v.model, "GAME" ) then
				v.modelEnt = ClientsideModel( v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE )
				if IsValid( v.modelEnt ) then
					v.modelEnt:SetPos( self:GetPos() )
					v.modelEnt:SetAngles( self:GetAngles() )
					v.modelEnt:SetParent( self )
					v.modelEnt:SetNoDraw( true )
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
			elseif v.type == "Sprite" and v.sprite and v.sprite ~= "" and ( not v.spriteMaterial or v.createdSprite ~= v.sprite ) and file.Exists( "materials/" .. v.sprite .. ".vmt", "GAME" ) then
				local name = v.sprite .. "-"
				local params = {
					["$basetexture"] = v.sprite
				}

				-- make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for _, j in ipairs( tocheck ) do
					if v[j] then
						params["$" .. j] = 1
						name = name .. "1"
					else
						name = name .. "0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial( name, "UnlitGeneric", params )
			end
		end
	end

	local allbones
	local hasGarryFixedBoneScalingYet = false
	function SWEP:UpdateBonePositions( vm )
		if self.ViewModelBoneMods then
			if not vm:GetBoneCount() then return end
			-- !! WORKAROUND !! --
			-- We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if not hasGarryFixedBoneScalingYet then
				allbones = {}
				for i = 0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName( i )
					if self.ViewModelBoneMods[bonename] then
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = {
							scale = Vector( 1, 1, 1 ),
							pos = Vector( 0, 0, 0 ),
							angle = Angle( 0, 0, 0 )
						}
					end
				end

				loopthrough = allbones
			end

			-- !! ----------- !! --
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone( k )
				if not bone then continue end
				-- !! WORKAROUND !! --
				local s = Vector( v.scale.x, v.scale.y, v.scale.z )
				local p = Vector( v.pos.x, v.pos.y, v.pos.z )
				local ms = Vector( 1, 1, 1 )
				if not hasGarryFixedBoneScalingYet then
					local cur = vm:GetBoneParent( bone )
					while cur >= 0 do
						local pscale = loopthrough[vm:GetBoneName( cur )].scale
						ms = ms * pscale
						cur = vm:GetBoneParent( cur )
					end
				end

				s = s * ms
				-- !! ----------- !! --
				if vm:GetManipulateBoneScale( bone ) ~= s then vm:ManipulateBoneScale( bone, s ) end
				if vm:GetManipulateBoneAngles( bone ) ~= v.angle then vm:ManipulateBoneAngles( bone, v.angle ) end
				if vm:GetManipulateBonePosition( bone ) ~= p then vm:ManipulateBonePosition( bone, p ) end
			end
		else
			self:ResetBonePositions( vm )
		end
	end

	function SWEP:ResetBonePositions( vm )
		if not vm:GetBoneCount() then return end
		for i = 0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector( 1, 1, 1 ) )
			vm:ManipulateBoneAngles( i, Angle( 0, 0, 0 ) )
			vm:ManipulateBonePosition( i, Vector( 0, 0, 0 ) )
		end
	end

	function table.FullCopy( tab )
		if not tab then return nil end
		local res = {}
		for k, v in pairs( tab ) do
			if type( v ) == "table" then
				res[k] = table.FullCopy( v )
			elseif type( v ) == "Vector" then
				res[k] = Vector( v.x, v.y, v.z )
			elseif type( v ) == "Angle" then
				res[k] = Angle( v.p, v.y, v.r )
			else
				res[k] = v
			end
		end
		return res
	end
end

----------------------------------------------------
function SWEP:Deploy()
	self:SendWeaponAnim( ACT_VM_DRAW )
	self:SetNextPrimaryFire( CurTime() + 0.5 )
	self:SetNextSecondaryFire( CurTime() + 0.5 )
	self.Idle = 0
	self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
	return true
end

function SWEP:Holster()
	self.Idle = 0
	self.IdleTimer = CurTime()
	if CLIENT and IsValid( self:GetOwner() ) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid( vm ) then
			self:ResetBonePositions( vm )
			self:GetOwner():SetFOV( 0, 0.25 )
		end
	end
	return true
end

function SWEP:OnRemove()
	self:Holster()
end

function SWEP:OnDrop()
	self:Holster()
end

function SWEP:PrimaryAttack()
	self:ShootEffects( self )
	local Forward = self:GetOwner():EyeAngles():Forward()
	local Up = self:GetOwner():EyeAngles():Up()
	self:SendWeaponAnim( ACT_VM_THROW )
	timer.Simple( self:GetOwner():GetViewModel():SequenceDuration() - 0.5, function()
		if not IsValid( self ) then return end
		self:GetOwner():ViewPunch( Angle( 1, 1, 0 ) )
		if SERVER then
			local ent = ents.Create( "proj_sokka_boomerang" )
			if IsValid( ent ) then
				ent:SetPos( self:GetOwner():GetShootPos() + Forward * 20 + Up * -5 )
				ent:SetAngles( self:GetOwner():EyeAngles() )
				ent:Spawn()
				--ent:SetOwner(self:GetOwner())
				ent:SetNWEntity( "BombOwner", self:GetOwner() )
				ent:SetPhysicsAttacker( self:GetOwner() )
				local phys = ent:GetPhysicsObject()
				if IsValid( phys ) then
					local velocity = self:GetOwner():GetAimVector()
					velocity = velocity * 2000 + Up * 100
					velocity = velocity + VectorRand() * 10
					phys:SetVelocity( self:GetOwner():GetVelocity() + velocity )
					phys:AddAngleVelocity( ent:GetUp() * 5000 )
					--phys:SetDamping(0.3, 1)
				end
			end

			self:GetOwner():EmitSound( "Weapon_Crowbar.Single" )
			self:Remove()
		end
	end )

	--self:EmitSound( "weapons/samurai/tf_katana_0" .. math.random(1, 6) .. ".wav")
	self:SetNextPrimaryFire( CurTime() + self.Primary.DelayMiss )
	self:SetNextSecondaryFire( CurTime() + self.Primary.DelayMiss )
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	self.Idle = 0
	self.IdleTimer = CurTime() + self:GetOwner():GetViewModel():SequenceDuration()
end

function SWEP:SecondaryAttack()
end

function SWEP:Think()
	if self.Idle == 0 and self.IdleTimer <= CurTime() then
		if SERVER then self:SendWeaponAnim( ACT_VM_IDLE ) end
		self.Idle = 1
	end
end

if CLIENT then
	local WorldModel = ClientsideModel( SWEP.WorldModel )
	--WorldModel:SetSkin(1)
	WorldModel:SetNoDraw( true )
	function SWEP:DrawWorldModel()
		--self:Drawspiral()
		--self.Weapon:DrawModel()
		local _Owner = self:GetOwner()
		local ownervalid = IsValid( _Owner )
		if ownervalid then
			-- Specify a good position
			local offsetVec = Vector( 3, -1, -11 )
			local offsetAng = Angle( 0, 0, -90 )
			local boneid = _Owner:LookupBone( "ValveBiped.Bip01_R_Hand" ) -- Right Hand
			if not boneid then return end
			local matrix = _Owner:GetBoneMatrix( boneid )
			if not matrix then return end
			local newPos, newAng = LocalToWorld( offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles() )
			WorldModel:SetPos( newPos )
			WorldModel:SetAngles( newAng )
			WorldModel:SetModelScale( 0.8 )
			WorldModel:SetupBones()
		else
			WorldModel:SetPos( self:GetPos() )
			WorldModel:SetAngles( self:GetAngles() )
		end

		WorldModel:DrawModel()
	end
end
--PATH addons/__main/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__main/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/__main/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/__main/lua/weapons/zekeou_shotty_base/shared.lua:
// Variables that are used on both client and server
-- Major thanks to rm-rf / for thinking up a solution to the reload glitch. Good man!

SWEP.Category				= ""
SWEP.Author				= "Generic Default, Worshipper, Clavus, and Bob"
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.Base 				= "zekeou_gun_base"
SWEP.MuzzleAttachment			= "1" 		// Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 		// Should be "2" for CSS models or "1" for hl2 models
SWEP.DrawCrosshair			= true		// Hell no, crosshairs r 4 nubz!
SWEP.ViewModelFOV			= 65		// How big the gun will look
SWEP.ViewModelFlip			= true		// True for CSS models, False for HL2 models

SWEP.Spawnable				= false
SWEP.AdminSpawnable			= false

SWEP.Primary.Sound 			= Sound("")				// Sound of the gun
SWEP.Primary.RPM				= 0					// This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 0					// Size of a clip
SWEP.Primary.DefaultClip			= 0					// Default number of bullets in a clip
SWEP.Primary.KickUp			= 0					// Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0					// Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= 0					// Maximum side recoil (koolaid)
SWEP.Primary.Automatic			= true					// Automatic/Semi Auto
SWEP.Primary.Ammo			= "none"					// What kind of ammo
SWEP.Primary.Reloading			= false					// Reloading func

SWEP.Secondary.ClipSize			= 0					// Size of a clip
SWEP.Secondary.DefaultClip			= 0					// Default number of bullets in a clip
SWEP.Secondary.Automatic			= false					// Automatic/Semi Auto
SWEP.Secondary.Ammo			= "none"
SWEP.Secondary.IronFOV			= 0					// How much you 'zoom' in. Less is more! 

SWEP.data 				= {}					-- The starting firemode
SWEP.data.ironsights			= 1

SWEP.IronSightsPos = Vector (2.4537, 1.0923, 0.2696)
SWEP.IronSightsAng = Vector (0.0186, -0.0547, 0)

SWEP.ShotgunReloading		= false
SWEP.ShotgunFinish		= 0.5
SWEP.ShellTime		= 0.35
SWEP.InsertingShell	=		false

SWEP.NextReload	=	0

/*---------------------------------------------------------
   Name: SWEP:Think()
   Desc: Called every frame.
---------------------------------------------------------*/
function SWEP:Think()
	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end
	local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
	--if the owner presses shoot while the timer is in effect, then...
	if (self.Owner:KeyPressed(IN_ATTACK)) and (timer.Exists(timerName)) and not (self.Owner:KeyDown(IN_SPEED)) then
		if self:CanPrimaryAttack() then --well first, if we actually can attack, then...
			timer.Destroy(timerName) -- kill the timer, and
			self:PrimaryAttack()-- ATTAAAAACK!
		end
	end
	
	if self.InsertingShell == true and self.Owner:Alive() then
		vm = self.Owner:GetViewModel()-- its a messy way to do it, but holy shit, it works!
		vm:ResetSequence(vm:LookupSequence("after_reload")) -- Fuck you, garry, why the hell can't I reset a sequence in multiplayer?
		vm:SetPlaybackRate(.01) -- or if I can, why does facepunch have to be such a shitty community, and your wiki have to be an unreadable goddamn mess?
		self.InsertingShell = false -- You get paid for this, what's your excuse?
	end
	
	self:IronSight()
	
end

/*---------------------------------------------------------
   Name: SWEP:Deploy()
   Desc: Whip it out.
---------------------------------------------------------*/
function SWEP:Deploy()
	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end
	
	self:SetWeaponHoldType(self.HoldType)
	
	local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
	if (timer.Exists(timerName)) then
		timer.Destroy(timerName)
	end

	self.Weapon:SendWeaponAnim(ACT_VM_DRAW)

	self.Weapon:SetNextPrimaryFire(CurTime() + .25)
	self.Weapon:SetNextSecondaryFire(CurTime() + .25)
	self.ActionDelay = (CurTime() + .25)

	if (SERVER) then
		self:SetIronsights(false)
	end
	
	self.NextReload = CurTime() + 1

	return true
end

/*---------------------------------------------------------
   Name: SWEP:Reload()
   Desc: Reload is being pressed.
---------------------------------------------------------*/
function SWEP:Reload()

	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end

	local maxcap = self.Primary.ClipSize
	local spaceavail = self.Weapon:Clip1()
	local shellz = (maxcap) - (spaceavail) + 1

	if (timer.Exists("ShotgunReload")) or self.NextReload > CurTime() or maxcap == spaceavail then return end
	
	if self.Owner:IsPlayer() then 

		self.Weapon:SetNextPrimaryFire(CurTime() + 1) -- wait one second before you can shoot again
		self.Weapon:SendWeaponAnim(ACT_SHOTGUN_RELOAD_START) -- sending start reload anim
		self.Owner:SetAnimation( PLAYER_RELOAD )
		
		self.NextReload = CurTime() + 1
	
		if (SERVER) then
			self.Owner:SetFOV( 0, 0.15 )
			self:SetIronsights(false)
		end
	
		if SERVER and self.Owner:Alive() then
			local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
			timer.Create(timerName, 
			(self.ShellTime + .05), 
			shellz,
			function() if not IsValid(self) then return end 
			if IsValid(self.Owner) and IsValid(self.Weapon) then 
				if self.Owner:Alive() then 
					self:InsertShell()
				end 
			end end)
		end
	
	elseif self.Owner:IsNPC() then
		self.Weapon:DefaultReload(ACT_VM_RELOAD) 
	end
	
end

function SWEP:InsertShell()

	if not IsValid(self) then return end
	if not IsValid(self.Owner) then return end
	if not self.Owner:IsPlayer() then return end
	
	local timerName = "ShotgunReload_" ..  self.Owner:UniqueID()
	if self.Owner:Alive() then
		local curwep = self.Owner:GetActiveWeapon()
		if curwep:GetClass() != self.Gun then 
			timer.Destroy(timerName)
		return end
	
		if (self.Weapon:Clip1() >= self.Primary.ClipSize or self.Owner:GetAmmoCount(self.Primary.Ammo) <= 0) then
		-- if clip is full or ammo is out, then...
			self.Weapon:SendWeaponAnim(ACT_SHOTGUN_RELOAD_FINISH) -- send the pump anim
			timer.Destroy(timerName) -- kill the timer
		elseif (self.Weapon:Clip1() <= self.Primary.ClipSize and self.Owner:GetAmmoCount(self.Primary.Ammo) >= 0) then
			self.InsertingShell = true --well, I tried!
			timer.Simple( .05, function() self:ShellAnimCaller() end)
			self.Owner:RemoveAmmo(1, self.Primary.Ammo, false) -- out of the frying pan
			self.Weapon:SetClip1(self.Weapon:Clip1() + 1) --  into the fire
		end
	else
		timer.Destroy(timerName) -- kill the timer
	end
	
end

function SWEP:ShellAnimCaller()
	self.Weapon:SendWeaponAnim(ACT_VM_RELOAD)
end

--PATH addons/__main/lua/entities/anim_gmantele.lua:
AddCSLuaFile()

DEFINE_BASECLASS("base_anim")

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false
ENT.Author = "Axel"
ENT.DoNotDuplicate = true
ENT.PhysgunDisabled = true
ENT.AutomaticFrameAdvance = true
ENT.WorldModel = "models/weapons/w_suitcase_passenger.mdl"
ENT.RenderGroup = RENDERGROUP_BOTH

ENT.OpenSound = "doors/metal_move1.wav"
ENT.CloseSound = "doors/door_metal_rusty_move1.wav"
ENT.FullyOpen = "doors/door_metal_thin_open1.wav"


function ENT:SetupDataTables()
	self:NetworkVar("Float", 0, "EndDoorTime")
	self:NetworkVar("Bool", 1, "Close")
	self:NetworkVar("Vector", 0, "PlayerColor")
end

if SERVER then
	function ENT:Initialize()
		BaseClass.Initialize(self)
		self:ResetSequence("idle_all_01")
		self:SetEndDoorTime(CurTime() + 2)
	end

	function ENT:Think()
		BaseClass.Think(self)
		if not self.StartWalking and self:GetEndDoorTime() < CurTime() then
			self:ResetSequence("walk_suitcase")
			self.StartWalking = CurTime() + 2.1
			self:SetVelocity(self:GetForward() * 30)
			self:SetMoveType(MOVETYPE_NOCLIP)
			self:SetPoseParameter("move_x", 0.5)
		elseif self.StartWalking and self.StartWalking < CurTime() and not self.ClosingDoor then
			self:SetEndDoorTime(CurTime() + 1)
			self.ClosingDoor = true
			SafeRemoveEntityDelayed(self, 2)
		end

		self:NextThink(CurTime())
		return true
	end

	function ENT:UpdateTransmitState()
		return TRANSMIT_ALWAYS
	end
end

if CLIENT then
	local function DrawWall(pos, angle, width, height, color)
		if width < 0 or height < 0 then return end
		render.SetColorMaterial()
		render.DrawQuad(
			LocalToWorld(Vector( 0, -height, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( 0, 0, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( width, 0, 0 ), angle_zero, pos, angle),
			LocalToWorld(Vector( width, -height, 0 ), angle_zero, pos, angle),
			color or COLOR_WHITE
		)
	end

	function ENT:Initialize()
		self:SetIK(false)
		self:DrawShadow(false)
		if not IsValid(self.ClientModel) then
			self.ClientModel = ClientsideModel(self.WorldModel)
			if IsValid(self.ClientModel) then
				self.ClientModel:SetNoDraw(true)
			end
		end
	end

	function ENT:Think()
		BaseClass.Think(self)

		self:SetNextClientThink(CurTime())
		self:SetRenderBounds(Vector(-16, -16, 0), Vector(16, 16, 64), Vector(75, 75, 75))
		return true
	end

	function ENT:OnRemove()
		if IsValid(self.ClientModel) then
			self.ClientModel:Remove()
		end
	end

	function ENT:DrawTranslucent()
		self:DrawShadow(false)
		if self:GetEndDoorTime() == 0 and not self.DPos or not self.StartTime then
			self.DPos = util.QuickTrace(self:GetPos() + self:GetUp() * 2, self:GetForward() * 41, function() return false end).HitPos - self:GetForward()
			self.StartTime = CurTime()
			self:EmitSound(self.OpenSound)
			return
		end

		local pos, ang = self.DPos, self:GetForward():Angle()
		ang:RotateAroundAxis(ang:Up(), 180)
		local dang = self:GetForward():Angle()
		dang:RotateAroundAxis(dang:Up(), 180)
		dang:RotateAroundAxis(dang:Right(), - 90)
		dang:RotateAroundAxis(dang:Up(), 90)

		if self:GetEndDoorTime() < CurTime() and not self.CloseLatch then
			self.CloseLatch = true
			self:EmitSound(self.FullyOpen)
		elseif self.CloseLatch and self:GetEndDoorTime() > CurTime() and not self.Close then
			self.Close = true
			self.StartTime = CurTime()
			self:EmitSound(self.CloseSound)
		end

		local dur, elapsed = self:GetEndDoorTime() - self.StartTime, CurTime() - self.StartTime
		local per = math.Clamp(elapsed / dur, 0, 1)


		render.SetStencilEnable(true)
		render.ClearStencil()
		render.SetStencilTestMask(255)
		render.SetStencilWriteMask(255)

		render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
		render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_ALWAYS)
		render.SetStencilReferenceValue(1)

		per = (not self.Close and per or (1 - per))
		DrawWall(pos + ang:Right() * 25 + ang:Up() * 100 * per - Vector(0, 0, 1), dang, 50, 100 * per)

		local oldclip = render.EnableClipping(true)
		render.PushCustomClipPlane(-self:GetForward(), -self:GetForward():Dot(self.DPos))

		render.SetStencilReferenceValue(0)
		self:DrawModel()
		self:DrawBriefcase()

		render.PopCustomClipPlane()

		render.SetStencilReferenceValue(1)
		render.SetStencilPassOperation(STENCILOPERATION_KEEP)
		render.SetStencilFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilZFailOperation(STENCILOPERATION_KEEP)
		render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)

		render.SuppressEngineLighting(true)
		render.ResetModelLighting(0, 0, 0)
		render.SetLocalModelLights(
			{
				{
					type = MATERIAL_LIGHT_SPOT,
					color = Vector(0.6, 0.6, 0.6),
					pos = self:GetPos() + self:GetForward() * 120 + self:GetUp() * 64,
					dir = -self:GetForward(),
					outerAngle = 90,
					linearFalloff = true,
				}
			}
		)

		render.PushCustomClipPlane(self:GetForward(), self:GetForward():Dot(self.DPos))
		render.DepthRange( 0, 0.1 )
		self:DrawModel()
		self:DrawBriefcase()
		render.DepthRange( 0, 1 )

		render.PopCustomClipPlane()
		render.SuppressEngineLighting(false)
		render.EnableClipping(oldclip)
		render.SetStencilEnable(false)

		dang:RotateAroundAxis(self:GetUp(), 180)
		DrawWall(pos - ang:Right() * 25 + ang:Up() * 100 * per - Vector(0, 0, 1), dang, 50, 100 * per)

	end

	function ENT:Draw()
		self:DrawTranslucent()
	end

	local offsetVec = Vector(5, -1, 0)
	local offsetAng = Angle(-90, 0, 0)
	function ENT:DrawBriefcase()
		local boneid = self:LookupBone("ValveBiped.Bip01_R_Hand") -- Right Hand
		if not boneid or not IsValid(self.ClientModel) then return end

		local matrix = self:GetBoneMatrix(boneid)
		if not matrix then return end

		local newPos, newAng = LocalToWorld(offsetVec, offsetAng, matrix:GetTranslation(), matrix:GetAngles())

		self.ClientModel.IsBrief = true
		self.ClientModel:SetPos(newPos)
		self.ClientModel:SetAngles(newAng)
		self.ClientModel:DrawModel()
	end
end
--PATH addons/_farmer/lua/entities/ba_medquality_meals/cl_init.lua:
include("shared.lua");

surface.CreateFont("BA_Box_Text", {
	font = "Tahoma",
	size = 30,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

surface.CreateFont("BA_Box_Big", {
	font = "Tahoma",
	size = 64,
	weight = 700,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

surface.CreateFont("BA_Box_Icon", {
	font = "Webdings",
	size = 256,
	weight = 0,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = true,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	
end;


function ENT:Think()
end;

function ENT:Draw()
	self:DrawModel();
	
	local camPos = self:GetPos();
	local camAng = self:GetAngles();
	
	camAng:RotateAroundAxis(camAng:Up(), 0);
	camAng:RotateAroundAxis(camAng:Forward(), 90);
	camAng:RotateAroundAxis(camAng:Right(), 0);
	
	local name = self:GetNWString("name");
	local length = (string.len(self:GetNWString("name"))*21);

	local color = string.Explode(",", self:GetNWString("color"));
	
	local amount = math.Clamp((self:GetNWInt("amount")*2)/length, 0, (length));
	
	
	if (LocalPlayer():GetPos():Distance(self:GetPos()) < B_Animals_Config.DrawDistance) then
		cam.Start3D2D(camPos+camAng:Up()*19.5, camAng, 0.125)
			draw.RoundedBox(0, -120, -87, 240, 170, Color(0, 0, 0, 230));
			draw.SimpleText(self:GetNWString("name"), "BA_Box_Text", 0, -70, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);

			--draw.SimpleText("F", "BA_Box_Icon", 0, 0, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 20), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
			draw.SimpleText(self:GetNWInt("amount").."cal", "BA_Box_Big", 0, 0, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 200), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();
		
		camAng:RotateAroundAxis(camAng:Forward(), -90);	
		cam.Start3D2D(camPos+camAng:Up()*12, camAng, 0.125)
			draw.RoundedBox(0, -120, -145, 240, 290, Color(0, 0, 0, 230));

		cam.End3D2D();
		cam.Start3D2D(camPos+camAng:Up()*12, camAng, 0.2)
			draw.SimpleText("B", "BA_Box_Icon", 0, 0, Color(tonumber(color[1]) or 0, tonumber(color[2]) or 0, tonumber(color[3]) or 0, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER);
		cam.End3D2D();
	end;
end;
--PATH addons/_bitminers2/lua/entities/bm2_bitminer_server/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Bitminer Server"
ENT.Spawnable = true
ENT.Category = "Bitminers"
function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "ShouldAnimate" )
end
--PATH addons/_bitminers2ex/lua/entities/bm2_extra_fuel_otherend/cl_init.lua:
include( "shared.lua" )
function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_bitminers2/lua/entities/bm2_power_lead/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Power Lead"
ENT.Spawnable = true
ENT.Category = "Bitminers"
--PATH addons/_bitminers2ex/lua/entities/bm2_solar_cable_otherend/cl_init.lua:
include( "shared.lua" )
function ENT:Draw()
	self:DrawModel()
end
--PATH addons/_bitminers2ex/lua/entities/bm2_solar_panel/cl_init.lua:
include( "shared.lua" )
local warningMaterial = onyx.wimg.Simple( "https://i.imgur.com/bzOFQpr.png", "noclamp smooth" )
function ENT:DrawTranslucent()
	self:DrawModel()
	if LocalPlayer():GetPos():DistToSqr( self:GetPos() ) < 350 * 350 then
		if self.cam2d3dAng == nil then
			self.cam2d3dAng = Angle( 0, LocalPlayer():GetAngles().y - 90, 90 )
		else
			self.cam2d3dAng = LerpAngle( 7 * FrameTime(), self.cam2d3dAng, Angle( 0, LocalPlayer():GetAngles().y - 90, 90 ) )
		end

		--Cam 2D3D for drawing infomation
		local ang = self:GetAngles()
		local pos = self:GetPos() + Vector( 0, 0, 40 ) - ang:Forward() * 5 + ang:Up() * 20
		cam.Start3D2D( pos, self.cam2d3dAng, 0.05 )
		if not self:GetHasLight() then
			warningMaterial( -80, -20, 160, 160 )
			draw.SimpleText( "No sunlight!", onyx.FontNoScale( "Comfortaa", 40 ), 0, 170, color_black, 1, 1 )
			draw.SimpleText( "No sunlight!", onyx.FontNoScale( "Comfortaa", 40 ), -1, 170 - 1, color_white, 1, 1 )
			draw.SimpleText( "The solar panel needs direct sight of the skybox.", onyx.FontNoScale( "Comfortaa", 40 ), 0, 170 + 35, color_black, 1, 1 )
			draw.SimpleText( "The solar panel needs direct sight of the skybox.", onyx.FontNoScale( "Comfortaa", 40 ), -1, 170 - 1 + 35, color_white, 1, 1 )
		end

		cam.End3D2D()
	end
end
--PATH addons/_doctor/lua/entities/bp_guide_book/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()
end

--PATH addons/_ballistic_shields/lua/entities/bs_dshield/cl_init.lua:
include( "shared.lua" )
include( "ballistic_shields/cl_bs_util.lua" )
ENT.RenderGroup = RENDERGROUP_BOTH
function ENT:Draw()
	if bshields.config.dShieldTexture == "" then
		self:DrawModel()
		return
	end

	local webmat = surface.GetURL( bshields.config.dShieldTexture, 256, 256 )
	if self.Mat then render.MaterialOverrideByIndex( 5, self.Mat ) end
	local html_mat = webmat
	local matdata = {
		["$basetexture"] = html_mat:GetName(),
		["$decal"] = 1,
		["$translucent"] = 1
	}

	local uid = string.Replace( html_mat:GetName(), "__vgui_texture_", "" )
	self.Mat = CreateMaterial( "bshields_webmat_" .. uid, "VertexLitGeneric", matdata )
	self:DrawModel()
	render.ModelMaterialOverride( nil )
end
--PATH addons/_ballistic_shields/lua/entities/bs_hshield/cl_init.lua:
include( "shared.lua" )
include( "ballistic_shields/cl_bs_util.lua" )
ENT.RenderGroup = RENDERGROUP_BOTH
function ENT:Draw()
	if bshields.config.hShieldTexture == "" then
		self:DrawModel()
		return
	end

	local webmat = surface.GetURL( bshields.config.hShieldTexture, 256, 256 )
	if self.Mat then render.MaterialOverrideByIndex( 3, self.Mat ) end
	local html_mat = webmat
	local matdata = {
		["$basetexture"] = html_mat:GetName(),
		["$decal"] = 1,
		["$translucent"] = 1
	}

	local uid = string.Replace( html_mat:GetName(), "__vgui_texture_", "" )
	self.Mat = CreateMaterial( "bshields_webmat_" .. uid, "VertexLitGeneric", matdata )
	self:DrawModel()
	render.ModelMaterialOverride( nil )
end
--PATH addons/_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}
bshields.shields = {
	{
		[1] = {
			["angles"] = Angle( 4, 6, -14 ),
			["position"] = Vector( 0, 8, -1 )
		},
		[2] = {
			["angles"] = Angle( 6, 6, -12 ),
			["position"] = Vector( 8, 10, -4 )
		},
		[3] = {
			["angles"] = Angle( -3, 7, -16 ),
			["position"] = Vector( -1, 4, -3 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -4, -8 )
		},
		[2] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 16, -3, -12 )
		},
		[3] = {
			["angles"] = Angle( -12, 0, 0 ),
			["position"] = Vector( 6, -3, -12 )
		}
	},
	{
		[1] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -7, -13 )
		},
		[2] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -6, -22 )
		},
		[3] = {
			["angles"] = Angle( 70, 78, -16 ),
			["position"] = Vector( 1, -8, -12 )
		}
	}
}
--PATH addons/_ballistic_shields/lua/entities/bs_shield/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Deployed shield"
ENT.Category = "Ballistic shields"
ENT.Spawnable = false
ENT.DisableDuplicator = true
function ENT:Use( activator )
	if IsValid( activator ) and activator:IsPlayer() and self.Owner == activator then
		activator:Give( "deployable_shield" )
		activator:EmitSound( "npc/combine_soldier/gear2.wav" )
		table.RemoveByValue( activator.bs_shields, self )
		self:Remove()
	end
end
--PATH addons/_ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )
--------------------- BALLISTIC SHIELDS V1.1.9 -------------------------
---- CONFIG ----
-- AVALAIBLE LANGUAGES - English, German, French, Danish, Turkish, Ukrainian
bshields.config.language = "Ukrainian"
-- DISABLE HUD
bshields.config.disablehud = false
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 10
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 10
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 50
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 20
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 60
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 30
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 1
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = true
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false
-- REMOVE DEPLOYED SHIELDS ON JOB CHANGE
bshields.config.removeonjobchange = true
-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---
-- HEAVY SHIELD
bshields.config.hShieldTexture = ""
-- RIOT SHIELD
bshields.config.rShieldTexture = ""
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = ""
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---
-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = false
--PATH gamemodes/darkrp/entities/entities/disgue/cl_init.lua:
include("Shared.lua")

function ENT:Draw()
	self.OverlayText = "<color=200,200,0>Костюм</color> \nПриховує вашу особистість."
	self:DrawModel()
end  

--PATH addons/_drones/lua/entities/dronesrewrite_base/shared.lua:
ENT.DrrBaseType = "base"

ENT.RenderInCam = true
ENT.WaitNPCS = 0
ENT.NextAction = 0
ENT.EnginePower = 0
ENT.FlyConstant = 2.2524 -- 2.26 2.34 2.25 2.2524
ENT.BlockKeys = false
ENT.MoveCoefficient = 1

ENT.DRONES_REWRITE_DELTA = 0
ENT.DRRFriendsControlling = nil

ENT.CamAngles = Angle(0, 0, 0)

ENT.HackValue = 1
ENT.ImmuneToJammer = false

ENT.Useable = true
ENT.IS_DRONE = true
ENT.IS_DRR = true
ENT.AllowControl = false
ENT.BlockRemoteController = false
ENT.ShowOnRadar = true

ENT.UNIT = "BASE"

ENT.AI_AllowDown = true
ENT.AI_AllowUp = true
ENT.AI_AllowForward = true
ENT.AI_AllowBack = true
ENT.AI_AllowRotate = true
ENT.AI_AllowStay = true

ENT.DisableInWater = true
ENT.DRRDefMaxDistance = 10000

ENT.Slots = {
	["Body"] = 2,
	["Engine"] = 1,
	["Camera"] = 1,
	["AI"] = 5,
	["Fuel"] = 1
}

ENT.Modules = nil
ENT.Buffer = { }

ENT.Base = "base_anim"
ENT.Type = "anim"
ENT.PrintName = "Base Drone"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.Category = ""

ENT.Weight = 100
ENT.Model = "models/props_phx/construct/metal_plate1.mdl"

ENT.HealthAmount = 100
ENT.DefaultHealth = 100
ENT.CriticalHealthPoint = 30
ENT.DamageThreshold = 0 --[[ AKA "Penetration threshold" ]]--

ENT.DoExplosionEffect = true
ENT.ExplosionForce = 37
ENT.ExplosionAngForce = 3

-- Physics and movement params --
ENT.Speed = 2300 -- No comments
ENT.UpSpeed = 6900
ENT.SprintCoefficient = 2
ENT.RotateSpeed = 13

ENT.AngOffset = 10 -- How much force do when we're rotating (A & D)
ENT.PitchOffset = 1  -- How much force do when we're moving (W & S)
ENT.Alignment = 1 -- How much force do to align drone
ENT.AlignmentPitch = 0 -- Same but pitch
ENT.AlignmentRoll = 0 -- Same but roll

ENT.Damping = 1 -- Velocity damping
ENT.AngDamping = 1 -- Angle velocity damping
-- Full
ENT.AngPitchDamping = 0
ENT.AngYawDamping = 0
ENT.AngRollDamping = 0

-- Hint:
-- math.Clamp(phys:GetVelocity():Length() * self.VelCoefficientOffset, 1, self.VelCoefficientMax) * self.AngOffsetVel
ENT.VelCoefficientOffset = 0.0025 -- Velocity:Length() coefficient
ENT.VelCoefficientMax = 3 -- Max force of velocity angle offset
ENT.AngOffsetVel = 1 -- Coefficient of velocity angle offset

ENT.NoiseCoefficient = 0.3 -- Noise
ENT.NoiseCoefficientPos = 0 -- Same but vector
ENT.NoiseCoefficientAng = 0 -- Same but angle
----------------------------------

ENT.CameraModel = "models/dronesrewrite/camera/camera.mdl"
ENT.SimplestCamera = false
ENT.FirstPersonCam_pos = Vector(0, 0, -5)
ENT.ThirdPersonCam_pos = Vector(0, 0, 0)
ENT.ThirdPersonCam_distance = 100
ENT.EnabledThirdPerson = true
ENT.RenderCam = true
ENT.CamZoom = 30

ENT.OverlayName = "Default"
ENT.HUD_hudName = "Sci Fi"
ENT.HUD_textColor = Color(200, 255, 255)
ENT.HUD_hudColor = Color(200, 255, 255)
ENT.HUD_shouldDrawCrosshair = true
ENT.HUD_shouldDrawHud = true
ENT.HUD_shouldDrawHealth = true
ENT.HUD_shouldDrawTargets = true
ENT.HUD_shouldDrawOverlay = true
ENT.HUD_shouldDetectDamage = true
ENT.HUD_shouldDrawRadar = true
ENT.HUD_shouldDrawFuel = true
ENT.HUD_shouldDrawCenter = true
ENT.HUD_shouldDrawWeps = true

ENT.Enabled = true
ENT.UseNightVision = true
ENT.UseFlashlight = true

ENT.Fuel = 100
ENT.MaxFuel = 100
ENT.FuelReduction = 0.1
ENT.ShouldConsumeFuel = true

ENT.MaxPrimaryAmmo = 0
ENT.MaxSecondaryAmmo = 0

ENT.ShouldConsumeAmmo = true
ENT.Immortal = false

ENT.NoPropellers = false

-- NOTE: These parts must be tables --
ENT.Propellers = nil
ENT.Sounds = nil
ENT.Weapons = nil
ENT.KeysFuncs = nil
ENT.Legs = nil
ENT.Attachments = nil
--------------------------------

ENT.PlayLoop = true

ENT.AllowPitchRestrictions = true
ENT.PitchMin = 0
ENT.PitchMax = 90

ENT.AllowYawRestrictions = false
ENT.YawMin = 0
ENT.YawMax = 0

ENT.CurrentWeapon = nil

-- Walker base params --
ENT.Dists = nil
ENT.Slip = 6
ENT.AngSlip = 0.05
ENT.isDroneOnGround = false
ENT.Hover = 15
ENT.WaitForSound = 0.13
------------------------

function ENT:IsDroneOnGround() return self.isDroneOnGround end

function ENT:AddHook(hook, name, func)
	if not self.hooks then self.hooks = { } end

	if not self.hooks[hook] then self.hooks[hook] = { } end
	self.hooks[hook][name] = func
end

function ENT:RemoveHook(hook, name)
	if not self.hooks then self.hooks = { } end

	if self.hooks[hook] and self.hooks[hook][name] then 
		self.hooks[hook][name] = nil 
	end
end

function ENT:CallHook(name, ...)
	if not self.hooks then self.hooks = { } end
	if not self.hooks[name] then return end

	for k, v in pairs(self.hooks[name]) do
		if CLIENT then 
			RunString(v) -- Worst shit ever
		else
			v(...)
		end
	end
end

function ENT:AddHookClient(hook, name, func)
	if CLIENT then return end

	net.Start("dronesrewrite_addhook")
		net.WriteEntity(self)
		net.WriteString(hook)
		net.WriteString(name)
		net.WriteString(func)
	net.Broadcast()
end

function ENT:RemoveHookClient(hook, name, func)
	if CLIENT then return end

	net.Start("dronesrewrite_removehook")
		net.WriteEntity(self)
		net.WriteString(hook)
		net.WriteString(name)
	net.Broadcast()
end

function ENT:GetUnit() return self.UNIT .. self:EntIndex() end

function ENT:GetNumPropellers()
	return self.Propellers and #self.Propellers.Info or 0
end

function ENT:CalculateFlyConstant() 
	if self.DrrBaseType == "base" then
		return self.FlyConstant * (4 / self:GetNumPropellers()) 
	else
		return 1
	end
end

function ENT:IsDroneDestroyed() return self:GetHealth() <= 0 end
function ENT:IsDroneImmortal() return self.Immortal end
function ENT:IsDroneEnabled() return SERVER and self.Enabled or self:GetNWBool("Enabled") end
function ENT:IsDroneWorkable() return self:HasFuel() and not self:IsDroneDestroyed() and self:IsDroneEnabled() end

function ENT:GetHealth() return CLIENT and self:GetNWInt("Health") or self.HealthAmount end
function ENT:GetDefaultHealth() return self:GetNWInt("DefHealth") end

function ENT:GetFuel() return CLIENT and self:GetNWInt("Fuel") or self.Fuel  end
function ENT:HasFuel() return self.Fuel > 0 or not self.ShouldConsumeFuel end

function ENT:GetPrimaryAmmo()
	return self:GetNWInt("Ammo1")
end

function ENT:GetPrimaryMax()
	return self:GetNWInt("MaxAmmo1")
end

function ENT:GetSecondaryAmmo() 
	return self:GetNWInt("Ammo2")
end

function ENT:GetSecondaryMax()
	return self:GetNWInt("MaxAmmo2")
end

function ENT:GetDriver() return self:GetNWEntity("DronesRewriteDriver") end
function ENT:GetCamera() return self:GetNWEntity("Camera") end
function ENT:GetMainCamera() return self:GetNWEntity("MainCamera") end

function ENT:DoCamEffects() return self:GetNWBool("CameraHUD") and not self:GetNWBool("ThirdPerson") end
function ENT:SupportAngles() return self:GetNWBool("SupportAngles") and not self:GetNWBool("ThirdPerson") end

function ENT:GetLocalCamPos() return self:GetNWVector("CameraPositions") end

function ENT:GetCameraTraceLine(distance, mins, maxs, mask)
	local cam = self:GetCamera()
	if not IsValid(cam) then cam = self end
	
	local campos = cam:GetPos()

	distance = distance or 100000
	mins = mins or Vector(0, 0, 0)
	maxs = maxs or Vector(0, 0, 0)

	local filter = { }
	table.insert(filter, cam)
	table.insert(filter, self)

	local tr = util.TraceHull({
		start = campos,
		endpos = campos + self.CamAngles:Forward() * distance,
		filter = filter,
		mins = mins,
		maxs = maxs,
		mask = mask
	})

	return tr
end
--PATH addons/_drones/lua/entities/dronesrewrite_console/cl_init.lua:
include("shared.lua")

local mat = CreateMaterial("UnlitGeneric", "GMODScreenspace", { })

function ENT:DrawBroken(index, w, h)
	surface.SetMaterial(self.BrokenMat[index])
	surface.SetDrawColor(Color(255, 255, 255))
	surface.DrawTexturedRect(0, 0, w, h)
end

function ENT:Draw()
	self:DrawModel()

	if self:GetNWBool("shithappened") then return end

	if not self.Rt then
		self.Rt = GetRenderTarget("ConsoleDrr" .. self:EntIndex(), 1024, 1024, false)
	end

	if not self.RandomDraw then
		self.RandomDraw = 1
	end

	if self:GetNWEntity("User") != LocalPlayer() then return end

	if not self.BrokenMat then
		self.BrokenMat = { }

		for i = 1, 5 do
			self.BrokenMat[i] = Material("stuff/console/broken" .. math.random(1, 9))
		end
	end

	if not self:GetNWBool("Destroyed") then
		-- Lights
		if not self:GetNWBool("noLights") then
			local dlight = DynamicLight(self:EntIndex())
			if dlight then
				dlight.pos = self:LocalToWorld(Vector(58, 12, 75))
				dlight.r = 255
				dlight.g = 255
				dlight.b = 255
				dlight.brightness = 4
				dlight.Decay = 1
				dlight.Size = 128
				dlight.DieTime = CurTime() + 0.1
			end

			local dlight = DynamicLight(self:EntIndex() + 1)
			if dlight then
				dlight.pos = self:LocalToWorld(Vector(-16, 12, 75))
				dlight.r = 255
				dlight.g = 255
				dlight.b = 255
				dlight.brightness = 4
				dlight.Decay = 1
				dlight.Size = 128
				dlight.DieTime = CurTime() + 0.1
			end
		end
	end

	-- Drawing lines
	cam.Start3D2D(self:LocalToWorld(Vector(0.4, -21.4, 71.5)), self:LocalToWorldAngles(Angle(0, 90, 90)), 0.06)
		local w, h = 720, 434

		draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0))

		if self:GetNWBool("Destroyed") then
			self:DrawBroken(1, w, h)
		else
			if self.Cache then
				local min = #self.Cache > 28 and #self.Cache - 28 or 1

				local count = 1
				for i = min, #self.Cache do
					local cache = self.Cache[i]

					draw.SimpleText(cache.Text, "DronesRewrite_font5", 10, count * 14, cache.Color)

					count = count + 1
				end
			end
		end
	cam.End3D2D()

	-- Drawing camera view
	cam.Start3D2D(self:LocalToWorld(Vector(12, -69, 71.5)), self:LocalToWorldAngles(Angle(0, 105, 90)), 0.06)
		local w, h = 720, 434

		draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0))

		if self:GetNWBool("Destroyed") then
			self:DrawBroken(2, w, h)
		else
			local drone = self:GetNWEntity("DronesRewriteDrone")

			if not self:GetNWBool("noScreen") then
				if drone:IsValid() then
					mat:SetTexture("$basetexture", self.Rt)
					surface.SetMaterial(mat)
					surface.DrawTexturedRect(0, 0, w, h)
				else
					draw.SimpleText("No signal", "DronesRewrite_font5", 10, 14, Color(255, 255, 255))
				end
			else
				draw.SimpleText("Screen is disabled. To enable type screen 1", "DronesRewrite_font5", 10, 14, Color(255, 255, 255))
			end
		end
	cam.End3D2D()

	-- Garbage
	cam.Start3D2D(self:LocalToWorld(Vector(0.9, 27, 71.5)), self:LocalToWorldAngles(Angle(0, 75, 90)), 0.06)
		local w, h = 720, 434

		draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0))	

		if self:GetNWBool("Destroyed") then
			self:DrawBroken(3, w, h)
		else
			local drone = self:GetNWEntity("DronesRewriteDrone")

			if drone:IsValid() then
				local params = {
					"Unit: " .. drone:GetUnit(),
					"Health: " .. drone:GetHealth() .. " / " .. drone:GetDefaultHealth(),
					"Fuel: " .. drone:GetFuel() .. " / " .. drone.MaxFuel,
					"Distance: " .. math.floor(drone:GetPos():Distance(self:GetPos())) .. " units",
					"",
					"Weapon: " .. drone:GetNWString("CurrentWeapon"),
					"Primary ammo: " .. drone:GetPrimaryAmmo(),
					"Secondary ammo: " .. drone:GetSecondaryAmmo(),
					"",
					"Up speed: " .. drone.UpSpeed,
					"Speed: " .. drone.Speed,
					"Rotate speed: " .. drone.RotateSpeed,
					"Sprint coefficient: " .. drone.SprintCoefficient,
					"",
					"Type: " .. (drone.DrrBaseType == "base" and "flying" or drone.DrrBaseType),
					"Weight: " .. drone.Weight,
					"Enabled: " .. (drone:IsDroneEnabled() and "yes" or "no"),
					"Workable: " .. (drone:IsDroneWorkable() and "yes" or "no"),
					"Driver: " .. (drone:GetDriver():IsValid() and drone:GetDriver():Name() or "nobody"),
					"Admin only: " .. (drone.AdminOnly and "yes" or "no")
				}

				local x = 0
				for k, v in pairs(params) do
					draw.SimpleText(v, "DronesRewrite_font5", 12 + x, (k * 20) - 12, Color(255, 255, 255))
				end
			else
				draw.SimpleText("No signal", "DronesRewrite_font5", 10, 14, Color(255, 255, 255))
			end
		end
	cam.End3D2D()

	-- Clock
	cam.Start3D2D(self:LocalToWorld(Vector(3.3, -11.5, 80.2)), self:LocalToWorldAngles(Angle(0, 90, 117)), 0.06)
		local w, h = 176, 110

		draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0))

		if self:GetNWBool("Destroyed") then
			self:DrawBroken(4, w, h)
		else
			draw.SimpleText(os.date("%X" , os.time()), "DronesRewrite_font1", 10, 30, Color(255, 255, 255))
		end
	cam.End3D2D()

	if math.random(1, 150) == 1 then self.RandomDraw = math.random(1, 5) end

	-- Garbage
	cam.Start3D2D(self:LocalToWorld(Vector(3.3, 1, 80.2)), self:LocalToWorldAngles(Angle(0, 90, 117)), 0.06)
		local w, h = 176, 110

		draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0))

		if self:GetNWBool("Destroyed") then
			self:DrawBroken(5, w, h)
		else
			if not self:GetNWBool("noRandomScr") then
				surface.SetMaterial(Material("effects/tvscreen_noise002a"))
				surface.DrawTexturedRect(0, 0, w, h)
			end
		end
	cam.End3D2D()
end

function ENT:OpenConsole()
	if not self.Cache then self.Cache = { } end
	hook.Add("ShouldDrawLocalPlayer", "dronesrewrite_console_drawply", function() return true end)

	local newang
	local newpos

	local display = 2
	local nextch = 0

	hook.Add("CalcView", "dronesrewrite_console_camera", function(ply, pos, ang, fov)
		if not ply:Alive() then self:CloseWindow() end
		if not newpos then newpos = pos end
		if not newang then newang = ang end

		local ang = self:GetAngles()
		local struct = {
			[1] = {
				pos = self:LocalToWorld(Vector(30, 35, 60)),
				angle = Angle(0, ang.y + 160, 0)
			},

			[2] = {
				pos = self:LocalToWorld(Vector(30, 0, 60)),
				angle = Angle(0, ang.y + 180, 0)
			},

			[3] = {
				pos = self:LocalToWorld(Vector(30, -35, 60)),
				angle = Angle(0, ang.y + 200, 0)
			},

			[4] = {
				pos = self:LocalToWorld(Vector(65, 0, 80)),
				angle = Angle(20, ang.y + 180, 0)
			}
		}

		if input.IsKeyDown(KEY_RIGHT) and CurTime() > nextch then
			if display == 4 then display = 2 end

			display = display - 1
			if display < 1 then display = 4 end

			nextch = CurTime() + 0.2
		end

		if input.IsKeyDown(KEY_LEFT) and CurTime() > nextch then
			if display == 4 then display = 2 end

			display = display + 1
			if display > 3 then display = 4 end

			nextch = CurTime() + 0.2
		end

		if input.IsKeyDown(KEY_DOWN) and CurTime() > nextch then
			display = display == 4 and 2 or 4
			nextch = CurTime() + 0.2
		end

		toch = struct[display].pos
		tocha = struct[display].angle

		newang = LerpAngle(0.1, newang, tocha)
		newpos = LerpVector(0.1, newpos, toch)
		
		local view = { }
		view.origin = newpos
		view.angles = newang
		view.fov = fov
			
		return view
	end)

	local no_drawing = {
		CHudHealth = true,
		CHudBattery = true,
		CHudCrosshair = true,
		CHudAmmo = true,
		CHudSecondaryAmmo = true
	}

	hook.Add("HUDShouldDraw", "dronesrewrite_console_nohud", function(name)
		if no_drawing[name] then return false end
	end)

	local win = DRONES_REWRITE.CreateWindow(365, 200)
	win:SetPos(0, ScrH() - 200)

	local hide = DRONES_REWRITE.CreateButton("", win:GetWide() - 45, 0, 15, 25, win, function()
		timer.Simple(0.1, function()
			if IsValid(self) then 
				self:CloseWindow()
				self:OpenConsole() 
			end
		end)
	end)

	hide.Paint = function(hide, w, h)
		draw.RoundedBox(2, 0, h * 0.5, w, 2, Color(255, 255, 255))
	end

	local panellabs = DRONES_REWRITE.CreateScrollPanel(10, 30, 340, 119, win)
	panellabs.Paint = function(panellabs, w, h)
		draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0))
		surface.SetDrawColor(Color(255, 255, 255, 100))
		surface.DrawOutlinedRect(0, 0, w, h)
	end

	local pan = { }

	win.Think = function()
		if self.Cache then
			for k, v in pairs(self.Cache) do
				if not pan[k] or pan[k]:GetText() != v.Text then
					if pan[k] then pan[k]:Remove() pan[k] = nil end

					local lab = DRONES_REWRITE.CreateLabel(v.Text, 5, (k - 1) * 18, panellabs)
					lab:SetColor(v.Color)

					pan[k] = lab
				end
			end

			for k, v in pairs(pan) do
				if not self.Cache[k] then pan[k]:Remove() pan[k] = nil end
			end
		end
	end

	win.OnCloseButton = function()
		net.Start("dronesrewrite_conexit")
			net.WriteEntity(self)
		net.SendToServer()

		return true -- block closing
	end

	local del = true
	local text = vgui.Create("DTextEntry", win)
	text:SetSize(340, 25)
	text:SetPos(10, 165)
	text:SetFont("DronesRewrite_font4")
	text:SetHistoryEnabled(true)
	text:RequestFocus()

	local user = "> "
	local user_len = string.len(user)

	local newSeance = false

	text.OnTextChanged = function()
		if string.len(text:GetValue()) > self.MaxSymbols then 
			surface.PlaySound("buttons/button10.wav") 
			text:SetText(text.OldValue) 
			text:SetCaretPos(self.MaxSymbols)

			return 
		end

		self:EmitSound("buttons/lightswitch2.wav", 60, 180)

		local key = self.Cache[#self.Cache]

		if not key then
			self:AddLine(user)
			newSeance = false

			key = self.Cache[#self.Cache]
		end

		if key then
			if string.sub(key.Text, 1, user_len) != user or newSeance then self:AddLine(user) newSeance = false end
			self.Cache[#self.Cache].Text = user .. text:GetValue()
		end

		text.OldValue = text:GetValue()
		panellabs:GetVBar():SetScroll(panellabs:GetVBar().CanvasSize)
	end

	local function foo()
		self.LastTyped = text:GetValue()
		local cmd = string.Explode(" ", self.LastTyped)[1]

		text:AddHistory(self.LastTyped)

		net.Start("dronesrewrite_concmd")
			net.WriteEntity(self)
			net.WriteString(cmd)
			net.WriteString(string.sub(self.LastTyped, string.len(cmd) + 2, #self.LastTyped))
		net.SendToServer()

		text:SetText("")
		surface.PlaySound("ui/buttonclick.wav")

		newSeance = true
	end

	text.OnEnter = foo
	text.OnLoseFocus = function() text:RequestFocus() end

	text.NextClick = 0

	hook.Add("HUDPaint", "dronesrewrite_console_hud", function()
		if not self:GetNWBool("noHints") then
			local x = 385
			draw.SimpleText("Type 'exit' to stop using console", "DronesRewrite_customfont1", x, ScrH() - 60, Color(255, 255, 255), TEXT_ALIGNT_LEFT)
			draw.SimpleText("Use arrow keys to change view", "DronesRewrite_customfont1", x, ScrH() - 45, Color(255, 255, 255), TEXT_ALIGNT_LEFT)
			draw.SimpleText("Type helpmenu to get help", "DronesRewrite_customfont1", x, ScrH() - 30, Color(255, 255, 255), TEXT_ALIGNT_LEFT)

			local i = 14
			for k, v in pairs(DRONES_REWRITE.GetCommands()) do
				if text:GetValue() != "" and string.find(k, text:GetValue(), nil, true) then
					draw.SimpleText(k, "DronesRewrite_customfont1", 20, ScrH() - i * 16, Color(255, 255, 255), TEXT_ALIGNT_LEFT)
					i = i + 1
				end
			end
		end
	end)

	self.Window = win
end

function ENT:OnRemove()
	self:CloseWindow()
end

function ENT:CloseWindow() 
	if IsValid(self.Window) then self.Window:Close() self.Window = nil end 

	if self.Cache then
		local key = self.Cache[#self.Cache]
		if key and string.sub(key.Text, 1, user_len) == user then self.Cache[#self.Cache] = nil end
	end

	hook.Remove("CalcView", "dronesrewrite_console_camera")
	hook.Remove("HUDPaint", "dronesrewrite_console_hud")
	hook.Remove("ShouldDrawLocalPlayer", "dronesrewrite_console_drawply")
	hook.Remove("HUDShouldDraw", "dronesrewrite_console_nohud")
end

--PATH addons/_drones/lua/entities/dronesrewrite_dxl/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
//ENT.PrintName = "DXL 'DXL-3000'"
ENT.PrintName = "DXL-3000"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "DXL"
ENT.HUD_hudName = "White Box"

ENT.Weight = 320

ENT.Model = "models/dronesrewrite/dxl/dxl.mdl"

ENT.FirstPersonCam_pos = Vector(15, 0, 6)
ENT.RenderCam = false

ENT.DoExplosionEffect = false
ENT.ExplosionForce = 16
ENT.ExplosionAngForce = 1.7

ENT.Alignment = 0 --1.6
ENT.AlignmentRoll = 0.7
ENT.AlignmentPitch = 1.6

ENT.NoiseCoefficient = 0.4
ENT.AngOffset = 3

ENT.Speed = 4500
ENT.UpSpeed = 24000
ENT.RotateSpeed = 5

ENT.HackValue = 3

ENT.PitchOffset = 0.7

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.PitchMin = -30
ENT.PitchMax = 50

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.Fuel = 120
ENT.MaxFuel = 120
ENT.FuelReduction = 0.3

ENT.HealthAmount = 300
ENT.DefaultHealth = 300

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/attack_helicopter/aheli_rotor_loop1.wav",
		Pitch = 120,
		Level = 65,
		Volume = 0.86
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_7.wav",
		Level = 80
	},

	SwitchOnSound = {
		Name = "buttons/button17.wav",
		Pitch = 120,
		Level = 67
	},

	ShutdownSound = {
		Name = "buttons/button1.wav",
		Pitch = 140,
		Level = 67
	}
}


ENT.Propellers = {
	Damage = 1,
	Health = 50,
	HitRange = 15,
	Model = "models/dronesrewrite/propellers/propeller1_3.mdl",

	Info = {
		Vector(0, 31, 10),
		Vector(0, -31, 10),
	}
}

ENT.Slots = {
	["Weapon"] = 1
}

ENT.Attachments = {
	["Left"] = { Pos = Vector(0, 8, -1), Angle = Angle(0, 0, 14) },
	["Right"] = { Pos = Vector(0, -8, -1), Angle = Angle(0, 0, -14) }
}

ENT.Weapons = {
	["Red Blasters"] = {
		Name = "Red Blaster",
		Sync = { 
			["2"] = { fire1 = "fire1", fire2 = "fire2" }
		},

		Attachment = "Left"
	},

	["2"] = {
		Name = "Red Blaster",
		Select = false,
		Attachment = "Right"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()


ENT.Modules["Invisible"] = {
	Slot = "Weapon",

	Initialize = function(drone)
		drone:FastAddWeapon("Invisible", "Invisible", Vector(0, 0, 0), { })
	end,

	OnRemove = function(drone)
		drone:AddWeapons()
	end,

	Think = function(drone) end
}

ENT.Modules["Microwave"] = {
	Slot = "Weapon",

	Initialize = function(drone)
		drone:FastAddWeapon("Microwave", "Microwave", Vector(0, 0, 0), { })
	end,

	OnRemove = function(drone)
		drone:AddWeapons()
	end,

	Think = function(drone) end
}

--PATH addons/_drones/lua/entities/dronesrewrite_exmac/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_gunner/cl_init.lua:
include("shared.lua")
--PATH addons/_drones/lua/entities/dronesrewrite_gunner/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
//ENT.PrintName = "LBL 'Limb of the Law'"
ENT.PrintName = "Limb of the Law"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "LBL"

ENT.Weight = 150

ENT.Model = "models/dronesrewrite/gunner/gunner.mdl"

ENT.FirstPersonCam_pos = Vector(29, 0, -3)
ENT.RenderCam = false

ENT.NoiseCoefficient = 0.1
ENT.AngOffset = 3

ENT.PitchMin = -12

ENT.AllowYawRestrictions = true
ENT.YawMin = -80
ENT.YawMax = 80

ENT.HackValue = 3

ENT.Speed = 1600
ENT.UpSpeed = 10000
ENT.RotateSpeed = 7

ENT.HealthAmount = 150
ENT.DefaultHealth = 150

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/manhack/mh_engine_loop1.wav",
		Pitch = 120,
		Level = 67
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 80
	}
}

ENT.Propellers = {
	Damage = 1,
	Health = 40,
	HitRange = 12,
	Model = "models/dronesrewrite/propellers/propeller2_3.mdl",

	Info = {
		Vector(1, 28, 1),
		Vector(1, -28, 1)
	}
}

ENT.Attachments = {
	["Left"] = {
		Pos = Vector(0, 12, 0)
	},

	["Right"] = {
		Pos = Vector(0, -12, 0)
	}
}

ENT.Weapons = {
	["Assault Rifle"] = {
		Name = "Assault Rifle",
		Sync = { ["2"] = { fire1 = "fire1" } },
		Attachment = "Left"
	},

	["2"] = {
		Name = "Assault Rifle",
		Select = false,
		Attachment = "Right"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_jiedr/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self.BaseClass.Draw(self)

	if self:IsDroneWorkable() then
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:LocalToWorld(self.FirstPersonCam_pos)
			dlight.r = 0
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 160
			dlight.DieTime = CurTime() + 0.1
		end
	end
end
--PATH addons/_drones/lua/entities/dronesrewrite_plasmadr/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Plasmatic Melter"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "PLM"

ENT.Weight = 350

ENT.Model = "models/dronesrewrite/plasmadr/plasmadr.mdl"

ENT.FirstPersonCam_pos = Vector(36, 0, 0)
ENT.RenderCam = false

ENT.Alignment = 0.5
ENT.PitchOffset = 0.6
ENT.NoiseCoefficient = 0.05
ENT.AngOffset = 3

ENT.Speed = 3000
ENT.UpSpeed = 16000
ENT.RotateSpeed = 5

ENT.Fuel = 220
ENT.MaxFuel = 220
ENT.FuelReduction = 0.4

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.HackValue = 3

ENT.PitchMin = -24
ENT.PitchMax = 80

ENT.HealthAmount = 200
ENT.DefaultHealth = 200

ENT.HUD_hudName = "Drones 2"

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/manhack/mh_engine_loop1.wav",
		Pitch = 120,
		Level = 74,
		Volume = 0.83
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_1.wav",
		Level = 80
	}
}

ENT.Propellers = {
	Damage = 5,
	Health = 20,
	HitRange = 18,
	Scale = 1.2,
	Model = "models/dronesrewrite/propellers/propeller2_3.mdl",

	Info = {
		Vector(-20, 38, 2),
		Vector(-20, -38, 2),
		Vector(20, 40.6, 2),
		Vector(20, -40.6, 2)
	}
}

ENT.Attachments = {
	["PlasmaRifle"] = {
		Pos = Vector(20, 0, -7)
	}
}

ENT.Weapons = {
	["Plasma Rifle"] = {
		Name = "Plasma Rifle",
		Attachment = "PlasmaRifle"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_rgundr/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Rail Accelerator"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "RLAC"
ENT.HUD_hudName = "White Box"

ENT.Weight = 800

ENT.Model = "models/dronesrewrite/railgundr/railgundr.mdl"

ENT.FirstPersonCam_pos = Vector(30, 0, 1)
ENT.RenderCam = false

ENT.ExplosionForce = 20
ENT.ExplosionAngForce = 1.7

ENT.Alignment = 0 --1.6
ENT.AlignmentRoll = 1.4
ENT.AlignmentPitch = 3

ENT.NoiseCoefficient = 0.2
ENT.AngOffset = 1

ENT.SprintCoefficient = 3
ENT.Speed = 5000
ENT.UpSpeed = 25000
ENT.RotateSpeed = 5

ENT.HackValue = 3

ENT.PitchOffset = 0.1

ENT.AllowYawRestrictions = true
ENT.YawMin = -60
ENT.YawMax = 60

ENT.PitchMin = -30
ENT.PitchMax = 50

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.HealthAmount = 200
ENT.DefaultHealth = 200

ENT.Fuel = 180
ENT.MaxFuel = 180
ENT.FuelReduction = 0.3

ENT.Sounds = {
	PropellerSound = {
		Name = "ambient/atmosphere/noise2.wav",
		Pitch = 120,
		Level = 75
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_7.wav",
		Level = 85
	}
}

ENT.NoPropellers = true
ENT.Propellers = {
	Model = "models/props_junk/PopCan01a.mdl",
	Info = { Vector(0, 0, 0) }
}

ENT.Attachments = {
	["Railgun1"] = {
		Pos = Vector(5, 14, -9)
	},

	["Railgun2"] = {
		Pos = Vector(5, -14, -9)
	}
}

ENT.Weapons = {
	["Railgun"] = {
		Name = "Railgun",
		Sync = {
			["Railgun 2"] = { fire1 = "fire1" }
		},
		Attachment = "Railgun1"
	},

	["Railgun 2"] = {
		Name = "Railgun",
		Select = false,
		Attachment = "Railgun2"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()


--PATH addons/_drones/lua/entities/dronesrewrite_spydrone/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Spy Weapon Drone"
ENT.Spawnable = false
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "SDW"

ENT.Model = "models/maxofs2d/hover_classic.mdl"

ENT.Weight = 40

ENT.UseFlashlight = false

ENT.Speed = 800
ENT.UpSpeed = 1500
ENT.RotateSpeed = 6
ENT.AngOffset = 3
ENT.NoiseCoefficient = 0.1
ENT.Alignment = 3
ENT.PitchOffset = 7
ENT.DoExplosionEffect = false

ENT.FirstPersonCam_pos = Vector(12, 0, 0)
ENT.ThirdPersonCam_distance = 50
ENT.RenderCam = false

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.AllowPitchRestrictions = false

ENT.HealthAmount = 20
ENT.DefaultHealth = 20

ENT.Sounds = {
	ExplosionSound = {
		Name = "ambient/energy/zap2.wav",
		Pitch = 160,
		Level = 50
	}
}

ENT.NoPropellers = true
ENT.Propellers = {
	Model = "models/props_junk/PopCan01a.mdl",
	Info = { Vector(0, 0, 0) }
}

ENT.Weapons = {
	["User & Invisible"] = { 
		Name = "User", 
		Sync = { ["1"] = { fire1 = "fire2" } } 
	},

	["1"] = { 
		Name = "Invisible",
		Select = false
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_stormtrooper/shared.lua:
ENT.Base = "dronesrewrite_base"
ENT.Type = "anim"
ENT.PrintName = "Stormtrooper"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.Category = "Drones Rewrite"

ENT.UNIT = "STR"
ENT.HUD_hudName = "White Box"
ENT.OverlayName = "Sci Fi"

ENT.Weight = 400

ENT.Model = "models/dronesrewrite/stormtrooper/stormtrooper.mdl"

ENT.FirstPersonCam_pos = Vector(74, 0, 2)
ENT.RenderCam = false

ENT.DoExplosionEffect = false
ENT.ExplosionForce = 16
ENT.ExplosionAngForce = 1.7

ENT.Alignment = 0 --1.6
ENT.AlignmentRoll = 0.5
ENT.AlignmentPitch = 1.2

ENT.NoiseCoefficient = 0
ENT.NoiseCoefficientPos = 32
ENT.NoiseCoefficientAng = 0.3
ENT.AngOffset = 3.5

ENT.HackValue = 3

ENT.Speed = 7000
ENT.UpSpeed = 25000
ENT.RotateSpeed = 5

ENT.PitchOffset = 0.7

ENT.AllowYawRestrictions = true
ENT.YawMin = -80
ENT.YawMax = 80

ENT.PitchMin = -40
ENT.PitchMax = 60

ENT.Fuel = 200
ENT.MaxFuel = 200
ENT.FuelReduction = 0.17

ENT.KeysFuncs = DRONES_REWRITE.DefaultKeys()

ENT.HealthAmount = 400
ENT.DefaultHealth = 400

ENT.Sounds = {
	PropellerSound = {
		Name = "npc/attack_helicopter/aheli_rotor_loop1.wav",
		Pitch = 130,
		NoPitchChanges = true,
		Level = 75,
		Volume = 0.72
	},

	ExplosionSound = {
		Name = "ambient/explosions/explode_7.wav",
		Level = 88
	}
}


ENT.Propellers = {
	Scale = 1.1,
	Damage = 2,
	Health = 120,
	HitRange = 20,
	Model = "models/dronesrewrite/propellers/propeller1_4.mdl",

	Info = {
		Vector(0, 0, 0)
	}
}

ENT.Attachments = {
	["Minigun"] = {
		Pos = Vector(54, 0, -4)
	}
}

ENT.Weapons = {
	["Light Minigun"] = {
		Name = "Light Minigun",
		Attachment = "Minigun"
	}
}

ENT.Modules = DRONES_REWRITE.GetBaseModules()
--PATH addons/_drones/lua/entities/dronesrewrite_ye_laser_sm.lua:
AddCSLuaFile()

ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Spawnable = false

if SERVER then
	function ENT:Initialize()
	    self:SetModel("models/dronesrewrite/lray_sm/lray_sm.mdl")
	    self:SetMoveType(MOVETYPE_VPHYSICS)
	    self:SetSolid(SOLID_VPHYSICS)
	    self:PhysicsInit(SOLID_VPHYSICS)

	    self:DrawShadow(false)
		self:SetColor(Color(255, 255, 255))

	    local phys = self:GetPhysicsObject()

	    phys:SetMass(1)
		phys:EnableDrag(false)
		phys:EnableGravity(false)	
	    phys:Wake()

	    self:SetCustomCollisionCheck(true)
	end

	function ENT:PhysicsUpdate(phys)
		if self.LastPhys == CurTime() then return end

		if self:WaterLevel() >= 3 then self:Remove() end

		phys:ApplyForceCenter(self:GetForward() * 100000)

		self.LastPhys = CurTime()
	end

	function ENT:PhysicsCollide(data, physobj)
		local ent = data.HitEntity
		if ent:IsValid() then
			local owner = self.Owner
			ent:TakeDamage(math.random(2,4), owner, owner)
			ent:Ignite(0.3,1)
		end

		local tr = util.TraceLine({
			start = self:GetPos(),
			endpos = self:GetPos() + self:GetForward() * 1024,
			filter = self,
			mask = MASK_SOLID_BRUSHONLY
		})

		ParticleEffect("sparks_rdbl", self:GetPos(), Angle(0, 0, 0))

		util.Decal("FadingScorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

		self:Remove()
	end
else
	function ENT:Draw()
		local dlight = DynamicLight(self:EntIndex())
		if dlight then
			dlight.pos = self:GetPos()
			dlight.r = 255
			dlight.g = 255
			dlight.b = 0
			dlight.brightness = 1
			dlight.Decay = 1000
			dlight.Size = 150
			dlight.DieTime = CurTime() + 0.3
		end	

		render.SetMaterial(Material("particle/particle_glow_04_additive"))

		local color = Color(255, 255, 0, 255)
		local xs = 18
		
		render.DrawSprite(self:GetPos() - self:GetForward() * 12, xs, xs, color)
		render.DrawSprite(self:GetPos() - self:GetForward() * 6, xs, xs, color)
		render.DrawSprite(self:GetPos(), xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 6, xs, xs, color)
		render.DrawSprite(self:GetPos() + self:GetForward() * 12, xs, xs, color)

		self:DrawModel()
	end
end
--PATH addons/__main/lua/entities/durgz_mushroom/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "Mushroom"
ENT.Nicknames = {"'shrooms", "magic mushrooms", "mushrooms", "Psilocybin", "Psilocin", "the greatest drug on earth", "lysol", "Eminem's drug of choice"}
ENT.OverdosePhrase = {"ate too many", "consumed a lot of"}
ENT.Author = "Matt Malone"
ENT.Category = "Drugs"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Information	 = "*Insert mario reference here*" 

ENT.TRANSITION_TIME = 6

--function for high visuals

if(CLIENT)then

	local MOVE_FACE_DOWN = 0;
	local MOVE_FACE_UP = 1;
	local MOVE_FACE_LEFT = 2;
	local MOVE_FACE_RIGHT = 3;
	
	local TRANSITION_TIME = ENT.TRANSITION_TIME; --transition effect from sober to high, high to sober, in seconds how long it will take etc.
	local HIGH_INTENSITY = 0.77; --1 is max, 0 is nothing at all
	local TIME_TO_GO_ACROSS_SCREEN = 3;
	local whichWay = 2;
	local startawesomefacemove = 0;
	
	local function DoMushrooms()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		--self:SetNWFloat( "SprintSpeed"
		local pl = LocalPlayer();
		
		
		local shroom_tab = {}
		shroom_tab[ "$pp_colour_addr" ] = 0
		shroom_tab[ "$pp_colour_addg" ] = 0
		shroom_tab[ "$pp_colour_addb" ] = 0
		//shroom_tab[ "$pp_colour_brightness" ] = 0
		//shroom_tab[ "$pp_colour_contrast" ] = 1
		shroom_tab[ "$pp_colour_mulr" ] = 0
		shroom_tab[ "$pp_colour_mulg" ] = 0
		shroom_tab[ "$pp_colour_mulb" ] = 0
		
		
		if( pl:GetNWFloat("durgz_mushroom_high_start") && pl:GetNWFloat("durgz_mushroom_high_end") > CurTime() )then
		
			if( pl:GetNWFloat("durgz_mushroom_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNWFloat("durgz_mushroom_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				local pf = (c-s) / (e-s);
				
				shroom_tab[ "$pp_colour_colour" ] =   1 - pf*0.37
				shroom_tab[ "$pp_colour_brightness" ] = -pf*0.15
				shroom_tab[ "$pp_colour_contrast" ] = 1 + pf*1.57
				//DrawMotionBlur( 1 - 0.18*pf, 1, 0);
				DrawColorModify( shroom_tab ) 
				DrawSharpen( 8.32,1.03*pf )
				
			elseif( pl:GetNWFloat("durgz_mushroom_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNWFloat("durgz_mushroom_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				local pf = 1 - (c-s) / (e-s);
				
				shroom_tab[ "$pp_colour_colour" ] = 1 - pf*0.37
				shroom_tab[ "$pp_colour_brightness" ] = -pf*0.15
				shroom_tab[ "$pp_colour_contrast" ] = 1 + pf*1.57
				//DrawMotionBlur( 1 - 0.18*pf, 1, 0);
				DrawColorModify( shroom_tab ) 
				DrawSharpen( 8.32,1.03*pf )
				
			else
				
				shroom_tab[ "$pp_colour_colour" ] = 0.63
				shroom_tab[ "$pp_colour_brightness" ] = -0.15
				shroom_tab[ "$pp_colour_contrast" ] = 2.57
				//DrawMotionBlur( 0.82, 1, 0);
				DrawColorModify( shroom_tab ) 
				DrawSharpen( 8.32,1.03 )
				
			end
			
			
		end
	end
	local function DoMushroomsFace()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		local pl = LocalPlayer();
		if( file.Exists("../materials/VGUI/durgzmod/awesomeface.vmt","GAME") && pl:GetNWFloat("durgz_mushroom_high_start") && pl:GetNWFloat("durgz_mushroom_high_end") > CurTime() )then
			local pf = 1;
			if( pl:GetNWFloat("durgz_mushroom_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNWFloat("durgz_mushroom_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				pf = (c-s) / (e-s);
				
			elseif( pl:GetNWFloat("durgz_mushroom_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNWFloat("durgz_mushroom_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				pf = 1 - (c-s) / (e-s);
				
			end
			
			
			if( startawesomefacemove + TIME_TO_GO_ACROSS_SCREEN < CurTime() )then
				startawesomefacemove = CurTime();
				whichWay = math.random(0,3);
			end
			
			
			local pfscr = (CurTime() - startawesomefacemove) / TIME_TO_GO_ACROSS_SCREEN;
			
			local ScrH = ScrH()
			
			local x, y;
			if( whichWay == MOVE_FACE_DOWN )then
				x = (ScrW() - ScrH)*0.5
				y = (2*pfscr-1)*ScrH
			elseif( whichWay == MOVE_FACE_LEFT )then
				x = (1-2*pfscr)*ScrW()
				y = 0;
			elseif( whichWay == MOVE_FACE_UP )then
				x = (ScrW() - ScrH)*0.5
				y = (1-2*pfscr)*ScrH
			else
				x = (2*pfscr-1)*ScrW();
				y = 0;
			end
			surface.SetTexture(surface.GetTextureID("VGUI/durgzmod/awesomeface"))
			surface.SetDrawColor(255, 255, 255, pf*180)
			surface.DrawTexturedRect(x, y, ScrH, ScrH) --gets your screen resolution
		end	
	end
	hook.Add("RenderScreenspaceEffects", "durgz_mushroom_high", DoMushrooms)
	hook.Add("HUDPaint", "durgz_mushroom_awesomeface", DoMushroomsFace)
	
end




/*




Motion Blur
	add: 0.82 (default 1)
	draw: 1
	delay: 0
Color Mod
	bright: -0.21
	contrast: 2.57
	color mul: 0.37
Sharpen
	distance: 1.03 (default 0)
	contrast: 8.32




*/





--PATH addons/__main/lua/entities/durgz_water/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "Water"
ENT.Category = "Drugs"
ENT.Nicknames = {0}
ENT.OverdosePhrase = {0}
ENT.Author = "Jesus Christ"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Information	 = "Clears the mind" 

--PATH addons/__main/lua/entities/durgz_weed/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.PrintName = "Marijuana"
ENT.Nicknames = {
    "pot", "weed", "grass", "marijuana", "reefer", "ganj",
    "kush", "ganja", "sour deisel", "pineapple express",
    "OG kush", "True OG from Elemental Wellness in San Jose, California",
    "the brickiest shit i have ever seen how can you even OD on this shit you pussy",
    "cannabis indica", "cannabis sativa", "cannabis",
    "sativa", "indica", "a drug that is technically impossible to overdose on",
    "that sticky icky", "sum of dat stikky ikky", "Tin's dick",
    "the peace pipe", "the most overrated drug ever"
}
ENT.OverdosePhrase = {"smoked too much", "breathed in a lot of", "pulled a Reed off of"}
ENT.Author = "Tin Huynh"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Information	 = "~ 420 ~" 
ENT.Category = "Drugs"

ENT.TRANSITION_TIME = 6

--function for high visuals

if(CLIENT)then
	
	local TRANSITION_TIME = ENT.TRANSITION_TIME; --transition effect from sober to high, high to sober, in seconds how long it will take etc.
	local HIGH_INTENSITY = 0.77; --1 is max, 0 is nothing at all
	
	
	local function DoWeed()
		if(!DURGZ_LOST_VIRGINITY)then return; end
		--self:SetNWFloat( "SprintSpeed"
		local pl = LocalPlayer();
		
		
		local tab = {}
		tab[ "$pp_colour_addr" ] = 0
		tab[ "$pp_colour_addg" ] = 0
		tab[ "$pp_colour_addb" ] = 0
		//tab[ "$pp_colour_brightness" ] = 0
		//tab[ "$pp_colour_contrast" ] = 1
		tab[ "$pp_colour_mulr" ] = 0
		tab[ "$pp_colour_mulg" ] = 0
		tab[ "$pp_colour_mulb" ] = 0
		
		
		if( pl:GetNWFloat("durgz_weed_high_start") && pl:GetNWFloat("durgz_weed_high_end") > CurTime() )then
		
			if( pl:GetNWFloat("durgz_weed_high_start") + TRANSITION_TIME > CurTime() )then
			
				local s = pl:GetNWFloat("durgz_weed_high_start");
				local e = s + TRANSITION_TIME;
				local c = CurTime();
				local pf = (c-s) / (e-s);
				pl:SetDSP(6);
				
				tab[ "$pp_colour_colour" ] =   1 - pf*0.3 //pf*4*HIGH_INTENSITY + 1
				tab[ "$pp_colour_brightness" ] = -pf*0.11
				tab[ "$pp_colour_contrast" ] = 1 + pf*1.62
				DrawMotionBlur( 0.03, pf*HIGH_INTENSITY, 0);
				DrawColorModify( tab ) 
				
			elseif( pl:GetNWFloat("durgz_weed_high_end") - TRANSITION_TIME < CurTime() )then
			
				local e = pl:GetNWFloat("durgz_weed_high_end");
				local s = e - TRANSITION_TIME;
				local c = CurTime();
				local pf = 1 - (c-s) / (e-s);
				
				pl:SetDSP(1)
				
				tab[ "$pp_colour_colour" ] = 1 - pf*0.3
				tab[ "$pp_colour_brightness" ] = -pf*0.11
				tab[ "$pp_colour_contrast" ] = 1 + pf*1.62
				DrawMotionBlur( 0.03, pf*HIGH_INTENSITY, 0);
				DrawColorModify( tab ) 
				
			else
				
				tab[ "$pp_colour_colour" ] = 0.77//5*HIGH_INTENSITY
				tab[ "$pp_colour_brightness" ] = -0.11
				tab[ "$pp_colour_contrast" ] = 2.62
				DrawMotionBlur( 0.03, HIGH_INTENSITY, 0);
				DrawColorModify( tab ) 
				pl:SetDSP(6);
				
			end
			
			
		end
	end
	hook.Add("RenderScreenspaceEffects", "durgz_weed_high", DoWeed)
end

--PATH addons/_eml/lua/entities/eml_jar/shared.lua:
ENT.Type = "anim";
ENT.Base = "base_anim";

ENT.PrintName		= "Банка";
ENT.Category 		= "EML";
ENT.Author			= "EnnX49";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

--PATH addons/_eml/lua/entities/eml_meth/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < self:GetNWInt("distance") then
		cam.Start3D2D(pos + ang:Up(), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.125)
				if !self:GetNWBool("salesman") then
					draw.SimpleTextOutlined((self:GetNWInt("value")*self:GetNWInt("valueMod")).."$", "methFont", 8, -98, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
				else
					draw.SimpleTextOutlined("Візьми мет і продай наркоману!", "methFont", 8, -98, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
				end;
		cam.End3D2D()		
		cam.Start3D2D(pos + ang:Up(), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.1)
				draw.SimpleTextOutlined("Кристалічний Мет("..self:GetNWInt("amount").." КГ)", "methFont", 8, -96, Color(1, 241, 249, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
		cam.End3D2D();
	end;
end;

-- maxAmount = 60
-- amount = x


--PATH addons/__________scripts__loader/lua/entities/ent_bail/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
--
ENT.PrintName = "Викуп"
ENT.Author = ""
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.Spawnable = true
ENT.AdminOnly = true
--
ENT_BailSum = 100000
--PATH addons/__main_only_1st/lua/entities/ent_death_mark.lua:
if SERVER then
	AddCSLuaFile( "ent_death_mark.lua" )
	function ENT:Initialize()
		-- self:SetModel( "models/error.mdl" )
		-- self:PhysicsInit( SOLID_VPHYSICS )
		-- self:SetMoveType( MOVETYPE_NONE  )
		-- self:SetSolid( SOLID_NONE )
		-- self:SetNotSolid( true )
		-- local phys = self:GetPhysicsObject()
		-- if (phys:IsValid()) then
		-- phys:Wake()
		-- end
		timer.Simple( 0.1, function() if self:GetModel() == "models/error.mdl" then self:Remove() end end )
		timer.Simple( 30, function() if IsValid( self ) then self:Remove() end end )
	end

	function ENT:Use()
		return
	end

	function ENT:Think()
	end
elseif CLIENT then
	-- This is where the cl_init.lua stuff goes
	-- surface.CreateFont ("DEATHNOTE Font", 20, 400, true, false, "")
	surface.CreateFont( "DeathFont", {
		font = "DEATHNOTE Font",
		extended = false,
		size = 100,
		weight = 400,
		antialias = true,
	} )

	function ENT:Draw()
		local Pos = self:GetPos()
		local Ang = self:GetAngles()
		self:DrawModel()
		if self:GetModel() == "models/props_c17/gravestone004a.mdl" then
			Ang:RotateAroundAxis( Ang:Right(), 90 )
			Ang:RotateAroundAxis( Ang:Up(), -90 )
			cam.Start3D2D( Pos + -Ang:Right() * 45, Ang, 0.11 )
			draw.DrawText( "Here Lies\n " .. self:GetOwner():Nick(), "DeathFont", 0, 0, Color( 25, 25, 25, 255 ), TEXT_ALIGN_CENTER )
			cam.End3D2D()
			Ang:RotateAroundAxis( Ang:Right(), 180 )
			cam.Start3D2D( Pos + -Ang:Right() * 45, Ang, 0.11 )
			draw.DrawText( "Here Lies\n " .. self:GetOwner():Nick(), "DeathFont", 0, 0, Color( 25, 25, 25, 255 ), TEXT_ALIGN_CENTER )
			cam.End3D2D()
		end
	end
end

ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Death-Note Death Mark"
ENT.Author = "Blue-Pentagram And TheRowan"
ENT.Spawnable = false
ENT.AdminOnly = false
ENT.Category = "Death Note"
--PATH addons/_hats_hook/lua/entities/ent_realistic_hook.lua:
AddCSLuaFile()

ENT.Type = "anim"

ENT.Spawnable = false
ENT.AdminSpawnable = true

ENT.Model = "models/props_c17/TrapPropeller_Lever.mdl"
ENT.HitSound = Sound( "physics/metal/metal_barrel_impact_hard7.wav" )

local ServerConvarFlags = {FCVAR_ARCHIVE, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE}
CreateConVar( "hatshook_hookplayers", "0", ServerConvarFlags, "Allows the Grappling Hook to grab players" )
CreateConVar( "hatshook_physics", "1", ServerConvarFlags, "Grappling hook is launched as a projectile" )
CreateConVar( "hatshook_speed", "1000", ServerConvarFlags, "Launch velocity of the grappling hook (Max range for non-physics hooks)" )

CreateConVar( "hatshook_breakpower", "3", ServerConvarFlags, "Strength of each breakout attempt" )
CreateConVar( "hatshook_breakregen", "1", ServerConvarFlags, "Breakout depletion rate" )

CreateConVar( "hatshook_ammo", "-1", ServerConvarFlags, "Number of uses each grappling hook has. -1 is infinite." )

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 0, "HasHit" )
	
	self:NetworkVar( "Entity", 0, "Wep" )
	self:NetworkVar( "Entity", 1, "TargetEnt" )
	
	self:NetworkVar( "Int", 0, "Dist" )
	self:NetworkVar( "Int", 1, "Durability" )
	
	self:NetworkVar( "Int", 2, "FollowBone" )
	self:NetworkVar( "Vector", 1, "FollowOffset" )
	self:NetworkVar( "Angle", 0, "FollowAngle" )
	
	self:NetworkVar( "Vector", 0, "ShootDir" )
end

function ENT:Initialize()
	self:SetModel( self.Model )
	
	--self:SetMoveType( MOVETYPE_VPHYSICS )
	self:PhysicsInit( SOLID_VPHYSICS )
	if not cvars.Bool( "hatshook_hookplayers" ) then
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
	end
	
	self:PhysWake()
	local phys = self:GetPhysicsObject()
	if IsValid(phys) then
		if SERVER then
			self:SetShootDir( self.Owner:GetAimVector() * cvars.Number( "hatshook_speed" ) )
		end
		phys:SetVelocity( self:GetShootDir() )
	end
	
	self.HookHealth = 100
	
	hook.Add( "AllowPlayerPickup", self, self.AllowPlayerPickup )
	if CLIENT then hook.Add( "HUDPaint", self, self.HUDPaint ) end
	
	if SERVER then
		local timerName = tostring(self).." Hook Durability Restore"
		timer.Create( timerName, 0.1, 0, function()
			if not IsValid(self) then timer.Destroy(timerName) return end
			self:SetDurability( math.Approach(self:GetDurability(), 0, cvars.Number("hatshook_breakregen") ) )
		end)
		hook.Add( "KeyPress", self, self.PlayerKeyPress )
	end
end

function ENT:Destroyed( NoCooldown )
	if CLIENT then return end
	
	local ef = EffectData()
	ef:SetStart( self:GetPos() )
	ef:SetOrigin( self:GetPos() )
	ef:SetScale( 1 )
	ef:SetRadius( 1 )
	ef:SetMagnitude( 1 )
	ef:SetNormal( self:GetRight() )
	
	util.Effect( "Sparks", ef, true, true )
	sound.Play( self.HitSound, self:GetPos(), 75, 100 )
	
	if IsValid( self:GetWep() ) and self:GetWep().SetCooldown then
		self:GetWep():SetCooldown( NoCooldown and self:GetWep():GetCooldown()+10 or 100 )
	end
	
	self:Remove()
end
function ENT:OnTakeDamage( DmgInfo )
	self.HookHealth = (self.HookHealth or 0) - DmgInfo:GetDamage()
	if self.HookHealth<=0 then
		self:Destroyed()
	end
end

function ENT:DoParent( target, obj )
	if IsValid( target ) and target~=self and target~=self.Owner and (not (target:IsWeapon() and target:GetOwner()==self.Owner)) then
		self:SetParent( target )
		
		if target:GetClass():sub(1,5)~="func_" then
			for i=0,target:GetPhysicsObjectCount()-1 do
				local p = target:GetPhysicsObjectNum( i )
				if p==obj then
					--self:SetParentPhysNum( target:TranslatePhysBoneToBone(i) )
					--self:FollowBone( target, target:TranslatePhysBoneToBone(i) )
					--print(i,target:TranslatePhysBoneToBone(i))
					
					self:SetFollowBone( target:TranslatePhysBoneToBone(i) )
					local pos, ang = target:GetBonePosition( self:GetFollowBone() )
					if pos and ang then
						self:SetFollowOffset( self:GetPos() - pos )
						self:SetFollowAngle( self:GetAngles()-ang )
					end
					break
				end
			end
		end
		
		self:SetTargetEnt( target )
	end
end

local NoHitEnts = { ["func_breakable_surf"] = true, ["ent_realistic_hook"] = true, } // This is stuff we shouldn't attach to, glitches out
function ENT:PhysicsCollide( data, phys )
	if self:GetHasHit() then return end // Already hit
	
	if IsValid(data.HitEntity) and NoHitEnts[data.HitEntity:GetClass()] then // Something that'll bug out, eg a window
		self:Destroyed( true )
		return
	end
	if not IsValid(self:GetWep()) and IsValid(self:GetWep().Owner) and self:GetWep().Owner:IsPlayer() then self:Destroyed( true ) return end
	
	local tr = util.TraceLine( {start = (data.HitPos - (data.HitNormal*10)), endpos = (data.HitPos+data.HitNormal*10), filter = self} )
	if tr.HitSky then return end
	
	timer.Simple(0,function()
		if not IsValid(self) then return end
		if not (IsValid(self:GetWep()) and IsValid(self:GetWep().Owner)) then self:Destroyed( true ) return end
		
		self:SetCollisionGroup( COLLISION_GROUP_WORLD )
		
		self:SetPos( data.HitPos )
		local ang = data.HitNormal:Angle()
		ang:RotateAroundAxis( ang:Up(), 90 )
		self:SetAngles( ang )
		self:SetMoveType( MOVETYPE_NONE )
		
		self:SetDist( data.HitPos:Distance( self:GetWep().Owner:GetShootPos() ) )
		self:DoParent( data.HitEntity, data.HitObject )
	end)
	
	self:SetDist( data.HitPos:Distance( self:GetWep().Owner:GetShootPos() ) )
	
	local ef = EffectData()
	ef:SetOrigin( data.HitPos )
	ef:SetNormal( data.HitNormal )
	ef:SetStart( data.HitPos )
	ef:SetMagnitude( 2 )
	ef:SetScale( 1 )
	ef:SetRadius( 1 )
	
	util.Effect( "Sparks", ef, true, true )
	sound.Play( self.HitSound, data.HitPos, 75, 100 )
	
	self:SetHasHit( true )
end

-- Misc hooks --
----------------
function ENT:Think()
	if SERVER and (not (IsValid(self:GetWep()) and self:GetWep()==self.Owner:GetActiveWeapon()) ) then self:Remove() return end
	
	local phys = self:GetPhysicsObject()
	if IsValid(phys) and self:GetHasHit() then // This stuff doesn't work in the collision hook
		phys:EnableMotion( false )
		phys:SetPos( self:GetPos() )
		phys:SetAngles( self:GetAngles() )
	end
end

function ENT:AllowPlayerPickup( ply, ent )
	if ply==self.Owner then return false end // They're currently hooked to something, if we let them pick it up they can exploit and fly
end

-- 3D Drawing --
----------------
local HookCable = Material( "cable/cable2" )
function ENT:Draw()
	if IsValid( self:GetTargetEnt() ) then
		local bpos, bang = self:GetTargetEnt():GetBonePosition( self:GetFollowBone() )
		local npos, nang = self:GetFollowOffset(), self:GetFollowAngle()
		if npos and nang and bpos and bang then
			npos:Rotate( nang )
			nang = nang+bang
			
			npos = bpos+npos
			
			self:SetPos( npos )
			self:SetAngles( nang )
		end
	end
	
	self:DrawModel()
	
	// We'll draw the beam from both the weapon and the hook, less likely to move out of rendering when it should be visible
	if not IsValid( self:GetWep() ) then return end
	if self.Owner==LocalPlayer() and not hook.Call("ShouldDrawLocalPlayer", GAMEMODE, self.Owner) then return end // Badly aligned, the rope will always be visible from the ViewModel draw anyway
	
	if IsValid(self.Owner) then
		local att = self:GetWep():GetAttachment( 1 )
		
		render.SetMaterial( HookCable )
		if att and att.Pos then
			render.DrawBeam( self:GetPos(), att.Pos, 1, 0, 2, Color(255,255,255,255) )
		else
			render.DrawBeam( self:GetPos(), self:GetWep():GetPos(), 1, 0, 2, Color(255,255,255,255) )
		end
	end
end

-- HUD stuff --
---------------
local ChargeBarCol = { White = Color(255,255,255), DefCol1 = Color(255,50,50), DefCol2 = Color(50,255,50) }
local Gradient = Material( "gui/gradient" )
local function DrawChargeBar( xpos, ypos, width, height, charge, col1, col2 )
	draw.NoTexture()
	
	surface.SetDrawColor( ChargeBarCol.White )
	surface.DrawOutlinedRect( xpos, ypos, width, height )
	
	charge = math.Clamp( charge or 50, 0, 100)
	barLen = (width-2)*(charge/100)
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, true )
		surface.SetDrawColor( col2 or ChargeBarCol.DefCol2 )
		surface.DrawRect( xpos+1, ypos+1, width-1, height-2 )
		
		surface.SetMaterial( Gradient )
		surface.SetDrawColor( col1 or ChargeBarCol.DefCol1 )
		surface.DrawTexturedRect( xpos+1, ypos+1, width-1, height-2 )
	render.SetScissorRect( xpos+1, ypos+1, xpos+1+barLen, (ypos+height)-1, false )
	
	draw.NoTexture()
end
local function ShadowText( txt, x, y, col )
	draw.DrawText( txt, "Default", x+1, y+1, Color(0,0,0), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
	draw.DrawText( txt, "Default", x, y, col or Color(255,255,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
end
function ENT:HUDPaint()
	if not (LocalPlayer()==self:GetTargetEnt()) then return end
	
	ShadowText( "Rope length: "..tostring(self:GetDist()), ScrW()*0.5, ScrH()*0.5-60 )
	ShadowText( "You have been hooked!", ScrW()*0.5, ScrH()*0.5-75, Color(255,100,100) )
	ShadowText( (input.LookupBinding("+use") or "[USE]"):upper() .. " - Break free", ScrW()*0.5, ScrH()*0.5-40 )
	DrawChargeBar( (ScrW()*0.5)-70, (ScrH()*0.5)-20, 140, 15, self:GetDurability() )
end

if SERVER then
	function ENT:PlayerKeyPress( ply, key )
		if (ply~=self:GetTargetEnt() or key~=IN_USE) then return end
		
		self:SetDurability( self:GetDurability()+cvars.Number("hatshook_breakpower") )
		if self:GetDurability()>=100 then self:Destroyed() end
	end
end

--PATH gamemodes/darkrp/entities/entities/ent_textscreen/cl_init.lua:

-----------------------------------------------------
local ipairs = ipairs
local Color = Color
local Angle = Angle
local math_Clamp = math.Clamp
local cam_Start3D2D = cam.Start3D2D
local cam_End3D2D = cam.End3D2D
local draw_SimpleTextOutlined = draw.SimpleTextOutlined
local allowablefonts = {"Tahoma", "Helvetica", "Trebuchet MS", "Comic Sans MS", "Segoe UI", "Impact", "Broadway", "Webdings", "Snap ITC", "Papyrus", "Old English Text MT", "Mistral", "Lucida Handwriting", "Jokerman", "Freestyle Script", "Bradley Hand ITC", "Stencil", "Shrek"}
local createdfonts = {}

local function getFont(name, size)
	if (not createdfonts[name] or not createdfonts[name][size]) then
		local fd = {
			font = name,
			size = size,
			weight = 1500,
			shadow = true,
			antialias = true,
			symbol = (name == "Webdings")
		}

		surface.CreateFont('CV' .. name .. size, fd)
		createdfonts[name] = createdfonts[name] or {}
		createdfonts[name][size] = true
	end

	return ('CV' .. name .. size)
end

include("shared.lua")

function ENT:Initialize()
	self:SetMaterial("models/effects/vol_light001")
	self:SetRenderMode(RENDERMODE_TRANSALPHA)
	//self:SetColor(255, 255, 255, 0)
end

function ENT:Draw()
	if (self:GetPos():Distance(LocalPlayer():GetPos()) < 750) then
		local ang = self:GetAngles()
		local pos = self:GetPos() + ang:Up()
		local camangle = Angle(ang.p, ang.y, ang.r)
		self.lines = self.lines or {}

		for i = 1, 3 do
			if self:onyx_GetNetVar('Text' .. i) ~= "" then
				self.lines[i] = self.lines[i] or {}
				self.lines[i].font = allowablefonts[self:onyx_GetNetVar('Font' .. i) or 1]
				self.lines[i].text = self:onyx_GetNetVar('Text' .. i) or ''
				self.lines[i].r = self:onyx_GetNetVar('r' .. i) or 255
				self.lines[i].g = self:onyx_GetNetVar('g' .. i) or 255
				self.lines[i].b = self:onyx_GetNetVar('b' .. i) or 255
				self.lines[i].a = self:onyx_GetNetVar('a' .. i) or 255
				self.lines[i].size = math_Clamp(self:onyx_GetNetVar('size' .. i) or 100, 1, 100)
				self.lines[i].fontname = 'Roboto_' .. self.lines[i].size
			else
				self.lines[i] = nil
			end
		end

		cam_Start3D2D(pos, camangle, .25)
		local x, y = 0, 0

		for k, v in ipairs(self.lines) do
			local w, h = draw_SimpleTextOutlined(v.text, v.fontname, x, y, Color(v.r, v.g, v.b), 1, 1, 1, color_black)
			y = y + h
		end

		cam_End3D2D()
	end
end

function ENT:DrawTranslucent()
	self:Draw()
end





--PATH addons/__advdupe2/lua/entities/gmod_contr_spawner/shared.lua:
ENT.Type 			= "anim"
ENT.Base			= WireLib and "base_wire_entity" or "base_gmodentity"
ENT.PrintName		= "Contraption Spawner"
ENT.Author			= "TB"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

--PATH addons/_drones/lua/entities/item_drr_grenadeselec.lua:
AddCSLuaFile()

ENT.Base = "item_drr_ammobase"
ENT.Type = "anim"
ENT.PrintName = "Electro Grenades"
ENT.Category = "Drones Rewrite Ammo"
ENT.Spawnable = true
ENT.AdminSpaawnable = true

ENT.Amount = 15
ENT.Model = "models/dronesrewrite/ammobox/ammobox.mdl"
ENT.Material = "models/dronesrewrite/ammunition/ammo_elec"

--PATH addons/____inventory/lua/entities/itemstore_box_huge.lua:
ENT.Type = "anim"
ENT.Base = "itemstore_box"

ENT.PrintName = "Huge Box"
ENT.Category = "ItemStore"

ENT.Spawnable = true
ENT.AdminOnly = true

if SERVER then
	AddCSLuaFile()

	ENT.Model = "models/props_junk/wood_crate001a_damaged.mdl"

	ENT.ContainerWidth = 8
	ENT.ContainerHeight = 4
	ENT.ContainerPages = 2
end

--PATH addons/lvs_base-main/lua/entities/lvs_armor.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

ENT.RenderGroup = RENDERGROUP_BOTH 

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Float",0, "HP" )
	self:NetworkVar( "Float",1, "MaxHP" )
	self:NetworkVar( "Float",2, "IgnoreForce" )

	self:NetworkVar( "Vector",0, "Mins" )
	self:NetworkVar( "Vector",1, "Maxs" )

	self:NetworkVar( "Bool",0, "Destroyed" )

	self:NetworkVar( "String",0, "Label" )

	if SERVER then
		self:SetMaxHP( 100 )
		self:SetHP( 100 )
		self:SetLabel( "Armor Plate" )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
	end

	function ENT:Think()
		return false
	end

	function ENT:OnHealthChanged( dmginfo, old, new )
		if old == new then return end
	end

	function ENT:OnRepaired()
	end

	function ENT:OnDestroyed( dmginfo )
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:TakeTransmittedDamage( dmginfo )
		local Force = dmginfo:GetDamageForce()

		local Damage = dmginfo:GetDamage()
		local DamageForce = Force:Length()
		local IsBlastDamage = dmginfo:IsDamageType( DMG_BLAST )

		local CurHealth = self:GetHP()

		local pos = dmginfo:GetDamagePosition()
		local dir = Force:GetNormalized()

		local base = self:GetBase()

		-- translate force value to armor penetration value is Force * 0.1
		-- mm to inch is * 0.0393701
		-- so correct value is * 0.00393701
		local pLength = DamageForce * 0.00393701

		local TraceData = {
			start = pos - dir * pLength,
			endpos = pos + dir * pLength,
		}

		local trace = util.TraceLine( TraceData )

		-- parent stays the same
		local parent = trace.Entity
		local parentPos = trace.HitPos
		local parentDir = trace.HitNormal

		-- only one extra iteration should be enough ...
		if IsValid( trace.Entity ) and isfunction( trace.Entity.GetBase ) and trace.Entity:GetBase() == base then

			TraceData.filter = trace.Entity

			local FilteredTrace = util.TraceLine( TraceData )

			if FilteredTrace.Hit then
				trace = FilteredTrace
			end

			trace.Entity = base
		end

		local DotHitNormal = math.Clamp( trace.HitNormal:Dot( dir ) ,-1,1) 

		local Armor = self:GetIgnoreForce()
		local ArmorEffective = Armor / math.abs( DotHitNormal )

		if math.abs( DotHitNormal ) > 0.9 then
			ArmorEffective = Armor
		end

		local DisableBounce = false

		local Inflictor = dmginfo:GetInflictor()

		if IsValid( Inflictor ) then
			if Inflictor.DisableBallistics or Inflictor:IsNPC() or Inflictor:IsNextBot() then
				DisableBounce = true
			end
		end

		if DamageForce <= ArmorEffective and not IsBlastDamage then
			local T = CurTime()

			if trace.Entity ~= base then
				self._NextBounce = T + 1

				return false
			end

			local Ax = math.acos( DotHitNormal )
			local HitAngle = 90 - (180 - math.deg( Ax ))

			if HitAngle > 30 then
				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
					effectdata:SetNormal( -dir )
				util.Effect( "manhacksparks", effectdata, true, true )
	
				self._NextBounce = T + 1

				return false
			end

			local NewDir = dir - trace.HitNormal * math.cos( Ax ) * 2

			if (self._NextBounce or 0) > T or DisableBounce then
				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
					effectdata:SetNormal( NewDir:GetNormalized() * 0.25 )
				util.Effect( "manhacksparks", effectdata, true, true )

				return false
			end

			self._NextBounce = T + 1

			local hit_decal = ents.Create( "lvs_armor_bounce" )
			hit_decal:SetPos( trace.HitPos )
			hit_decal:SetAngles( NewDir:Angle() )
			hit_decal:Spawn()
			hit_decal:Activate()
			hit_decal:EmitSound("lvs/armor_rico"..math.random(1,6)..".wav", 95, 100, math.min( dmginfo:GetDamage() / 1000, 1 ) )

			local PhysObj = hit_decal:GetPhysicsObject()
			if not IsValid( PhysObj ) then return false end

			PhysObj:EnableDrag( false )
			PhysObj:SetVelocityInstantaneous( NewDir * 2000 + Vector(0,0,250) )
			PhysObj:SetAngleVelocityInstantaneous( VectorRand() * 250 )

			return false
		end

		local NewHealth = math.Clamp( CurHealth - Damage, 0, self:GetMaxHP() )

		self:OnHealthChanged( dmginfo, CurHealth, NewHealth )
		self:SetHP( NewHealth )

		if NewHealth <= 0 and not self:GetDestroyed() then
			self:SetDestroyed( true )
			self:OnDestroyed( dmginfo )
		end

		local hit_decal = ents.Create( "lvs_armor_penetrate" )
		hit_decal:SetPos( parentPos + parentDir * 0.2 )
		hit_decal:SetAngles( parentDir:Angle() + Angle(90,0,0) )
		hit_decal:Spawn()
		hit_decal:Activate()
		hit_decal:SetParent( parent )

		return true
	end

	return
end

function ENT:Initialize()
end

function ENT:OnRemove()
end

function ENT:Think()
end


function ENT:Draw()
end

local function DrawText( pos, text, col )
	cam.Start2D()
		local data2D = pos:ToScreen()

		if not data2D.visible then cam.End2D() return end

		local font = "TargetIDSmall"

		local x = data2D.x
		local y = data2D.y

		draw.DrawText( text, font, x + 1, y + 1, Color( 0, 0, 0, 120 ), TEXT_ALIGN_CENTER )
		draw.DrawText( text, font, x + 2, y + 2, Color( 0, 0, 0, 50 ), TEXT_ALIGN_CENTER )
		draw.DrawText( text, font, x, y, col or color_white, TEXT_ALIGN_CENTER )
	cam.End2D()
end

local LVS = LVS
local BoxMat = Material("models/wireframe")
local ColorSelect = Color(0,127,255,150)
local ColorNormal = Color(50,50,50,150)
local ColorTransBlack = Color(0,0,0,150)
local OutlineThickness = Vector(0.5,0.5,0.5)
local ColorText = Color(255,0,0,255)

function ENT:DrawTranslucent()
	if not LVS.DeveloperEnabled then return end

	local ply = LocalPlayer()

	if not IsValid( ply ) or ply:InVehicle() or not ply:KeyDown( IN_SPEED ) then return end

	local boxOrigin = self:GetPos()
	local boxAngles = self:GetAngles()
	local boxMins = self:GetMins()
	local boxMaxs = self:GetMaxs()

	local HitPos, _, _ = util.IntersectRayWithOBB( ply:GetShootPos(), ply:GetAimVector() * 1000, boxOrigin, boxAngles, boxMins, boxMaxs )

	local InRange = isvector( HitPos )

	local Col = InRange and ColorSelect or ColorNormal

	render.SetColorMaterial()
	render.DrawBox( boxOrigin, boxAngles, boxMins, boxMaxs, Col )
	render.DrawBox( boxOrigin, boxAngles, boxMaxs + OutlineThickness, boxMins - OutlineThickness, ColorTransBlack )

	local boxCenter = (self:LocalToWorld( boxMins ) + self:LocalToWorld( boxMaxs )) * 0.5

	if not InRange then return end

	DrawText( boxCenter, "Armor: "..(self:GetIgnoreForce() / 100).."mm\nHealth:"..self:GetHP().."/"..self:GetMaxHP(), ColorText )
end

--PATH addons/lvs_base-main/lua/entities/lvs_base/shared.lua:
ENT.Type            = "anim"

ENT.PrintName = "LBaseEntity"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.Spawnable			= false
ENT.AdminSpawnable		= false

ENT.VJ_ID_Destructible = true

ENT.AutomaticFrameAdvance = true
ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.Editable = true

ENT.LVS = true

ENT.MDL = "models/props_c17/trappropeller_engine.mdl"

ENT.AITEAM = 0

ENT.MaxHealth = 100
ENT.MaxShield = 0

ENT.SpawnNormalOffset = 15
ENT.HitGroundLength = 10

ENT.lvsDisableZoom = true

function ENT:AddDT( type, name, data )
	if not self.DTlist then self.DTlist = {} end

	if self.DTlist[ type ] then
		self.DTlist[ type ] = self.DTlist[ type ] + 1
	else
		self.DTlist[ type ] = 0
	end

	self:NetworkVar( type, self.DTlist[ type ], name, data )
end

function ENT:CreateBaseDT()
	local InitWeaponsSuccess, ErrorMsg = pcall( function() self:InitWeapons() end )

	if not InitWeaponsSuccess then
		ErrorNoHalt( "\n[ERROR] "..ErrorMsg.."\n\n" )
	end

	self:AddDT( "Entity", "Driver" )
	self:AddDT( "Entity", "DriverSeat" )

	self:AddDT( "Bool", "Active" )
	self:AddDT( "Bool", "EngineActive" )
	self:AddDT( "Bool", "AI",	{ KeyName = "aicontrolled",	Edit = { type = "Boolean",	order = 1,	category = "AI"} } )

	local ShowAIGunnerInMenu = false

	if istable( self.WEAPONS ) then
		for id, _ in pairs( self.WEAPONS ) do
			if id == 1 then continue end

			ShowAIGunnerInMenu = true

			break
		end
	end

	if ShowAIGunnerInMenu then
		self:AddDT( "Bool", "AIGunners",	{ KeyName = "aigunners",	Edit = { type = "Boolean",	order = 2,	category = "AI"} } )
	else
		self:AddDT( "Bool", "AIGunners" )
	end

	self:AddDT( "Bool", "lvsLockedStatus" )
	self:AddDT( "Bool", "lvsReady" )
	self:AddDT( "Bool", "NWOverheated" )

	self:AddDT( "Int", "AITEAM", { KeyName = "aiteam", Edit = { type = "Int", order = 2,min = 0, max = 3, category = "AI"} } )
	self:AddDT( "Int", "SelectedWeapon" )
	self:AddDT( "Int", "NWAmmo" )

	self:AddDT( "Float", "HP", { KeyName = "health", Edit = { type = "Float", order = 2,min = 0, max = self.MaxHealth, category = "Misc"} } )
	self:AddDT( "Float", "Shield" )
	self:AddDT( "Float", "NWHeat" )

	self:OnSetupDataTables()

	if SERVER then
		self:NetworkVarNotify( "AI", self.OnToggleAI )
		self:NetworkVarNotify( "HP", self.PDSHealthValueChanged )
		self:NetworkVarNotify( "SelectedWeapon", self.OnWeaponChanged )

		self:SetAITEAM( self.AITEAM )
		self:SetHP( self.MaxHealth )
		self:SetShield( self.MaxShield )
		self:SetSelectedWeapon( 1 )
	end
end

function ENT:SetupDataTables()
	self:CreateBaseDT()
end

function ENT:OnSetupDataTables()
end

function ENT:CalcMainActivity( ply )
end

function ENT:GetPlayerBoneManipulation( ply, PodID )
	return self.PlayerBoneManipulate[ PodID ] or {}
end

function ENT:UpdateAnimation( ply, velocity, maxseqgroundspeed )
	ply:SetPlaybackRate( 1 )

	if CLIENT then
		GAMEMODE:GrabEarAnimation( ply )
		GAMEMODE:MouthMoveAnimation( ply )
	end

	return false
end

function ENT:StartCommand( ply, cmd )
end

function ENT:HitGround()
	local trace = util.TraceLine( {
		start = self:LocalToWorld( self:OBBCenter() ),
		endpos = self:LocalToWorld( Vector(0,0,self:OBBMins().z - self.HitGroundLength) ),
		filter = self:GetCrosshairFilterEnts()
	} )
	
	return trace.Hit 
end

function ENT:Sign( n )
	if n > 0 then return 1 end

	if n < 0 then return -1 end

	return 0
end

function ENT:VectorSubtractNormal( Normal, Velocity )
	local VelForward = Velocity:GetNormalized()

	local Ax = math.acos( math.Clamp( Normal:Dot( VelForward ) ,-1,1) )

	local Fx = math.cos( Ax ) * Velocity:Length()

	local NewVelocity = Velocity - Normal * math.abs( Fx )

	return NewVelocity
end

function ENT:VectorSplitNormal( Normal, Velocity )
	return math.cos( math.acos( math.Clamp( Normal:Dot( Velocity:GetNormalized() ) ,-1,1) ) ) * Velocity:Length()
end

function ENT:AngleBetweenNormal( Dir1, Dir2 )
	return math.deg( math.acos( math.Clamp( Dir1:Dot( Dir2 ) ,-1,1) ) )
end

function ENT:GetMaxShield()
	return self.MaxShield
end

function ENT:GetShieldPercent()
	return self:GetShield() / self:GetMaxShield()
end

function ENT:GetMaxHP()
	return self.MaxHealth
end

function ENT:IsInitialized()
	if not self.GetlvsReady then return false end -- in case this is called BEFORE setupdatatables

	return self:GetlvsReady()
end

function ENT:GetWeaponHandler( num )
	if num == 1 then return self end

	local pod = self:GetPassengerSeat( num )

	if not IsValid( pod ) then return NULL end

	return pod:lvsGetWeapon()
end

function ENT:GetPassengerSeat( num )
	if num == 1 then
		return self:GetDriverSeat()
	else
		for _, Pod in pairs( self:GetPassengerSeats() ) do

			if not IsValid( Pod ) then continue end

			local id = Pod:lvsGetPodIndex()

			if id == -1 then continue end

			if id == num then
				return Pod
			end
		end

		return NULL
	end
end

function ENT:GetPassengerSeats()
	if not self:IsInitialized() then return {} end

	if not istable( self.pSeats ) then
		self.pSeats = {}

		local DriverSeat = self:GetDriverSeat()

		for _, v in pairs( self:GetChildren() ) do
			if v ~= DriverSeat and v:GetClass():lower() == "prop_vehicle_prisoner_pod" then
				table.insert( self.pSeats, v )
			end
		end
	end

	return self.pSeats
end

function ENT:HasActiveSoundEmitters()
	local active = false

	for _, emitter in ipairs( self:GetChildren() ) do
		if emitter:GetClass() ~= "lvs_soundemitter" then continue end

		if not IsValid( emitter ) or not emitter.GetActive or not emitter.GetActiveVisible then continue end

		if emitter:GetActive() and emitter:GetActiveVisible() then
			active = true

			break
		end
	end

	return active
end

function ENT:GetPassenger( num )
	if num == 1 then
		return self:GetDriver()
	else
		for _, Pod in pairs( self:GetPassengerSeats() ) do

			if not IsValid( Pod ) then
				return NULL
			end

			local id = Pod:lvsGetPodIndex()

			if id == -1 then continue end

			if id == num then
				return Pod:GetDriver()
			end
		end

		return NULL
	end
end

function ENT:GetEveryone()
	local plys = {}

	local Pilot = self:GetDriver()
	if IsValid( Pilot ) then
		table.insert( plys, Pilot )
	end

	for _, Pod in pairs( self:GetPassengerSeats() ) do
		if not IsValid( Pod ) then continue end

		local ply = Pod:GetDriver()

		if not IsValid( ply ) then continue end

		table.insert( plys, ply )
	end

	return plys
end

function ENT:GetPodIndex()
	return 1
end

function ENT:PlayAnimation( animation, playbackrate )
	playbackrate = playbackrate or 1

	local sequence = self:LookupSequence( animation )

	self:ResetSequence( sequence )
	self:SetPlaybackRate( playbackrate )
	self:SetSequence( sequence )
end

function ENT:GetVehicle()
	return self
end

function ENT:GetVehicleType()
	return "LBaseEntity"
end

function ENT:GetBoneInfo( BoneName )
	local BoneID = self:LookupBone( BoneName )
	local numHitBoxSets = self:GetHitboxSetCount()

	if not BoneID then
		goto SkipLoop
	end

	for hboxset = 0, numHitBoxSets - 1 do
		local numHitBoxes = self:GetHitBoxCount( hboxset )

		for hitbox=0, numHitBoxes - 1 do
			local bone = self:GetHitBoxBone( hitbox, hboxset )
			local name = self:GetBoneName( bone )

			if BoneName ~= name then continue end

			local mins, maxs = self:GetHitBoxBounds( hitbox, hboxset )
			local pos, ang = self:GetBonePosition( BoneID )

			return self:WorldToLocal( pos ), self:WorldToLocalAngles( ang ), mins, maxs
		end
	end

	:: SkipLoop ::

	return vector_origin, angle_zero, vector_origin, vector_origin
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive/cl_optics.lua:

DEFINE_BASECLASS( "lvs_base" )

ENT.OpticsFov = 30
ENT.OpticsEnable = false
ENT.OpticsZoomOnly = true
ENT.OpticsFirstPerson = true
ENT.OpticsThirdPerson = true
ENT.OpticsPodIndex = {
	[1] = true,
}

ENT.OpticsCrosshairMaterial = Material( "vgui/circle" )
ENT.OpticsCrosshairColor = Color(0,0,0,255)
ENT.OpticsCrosshairSize = 5

function ENT:PaintOpticsCrosshair( Pos2D )
	if not Pos2D.visible then return end

	local size = self.OpticsCrosshairSize

	surface.SetMaterial( self.OpticsCrosshairMaterial )
	surface.SetDrawColor( self.OpticsCrosshairColor )
	surface.DrawTexturedRect( Pos2D.x - size * 0.5, Pos2D.y - size * 0.5, size, size )
end

function ENT:CalcOpticsCrosshairDot( Pos2D )
	self:PaintOpticsCrosshair( Pos2D )
end

function ENT:GetOpticsEnabled()
	local EntTable = self:GetTable()

	if not EntTable.OpticsEnable then return false end

	local ply = LocalPlayer()

	if not IsValid( ply ) then return false end

	local pod = ply:GetVehicle()
	local PodIndex = pod:lvsGetPodIndex()
	if pod == self:GetDriverSeat() then
		PodIndex = 1
	end

	if EntTable.OpticsPodIndex[ PodIndex ] then
		if pod:GetThirdPersonMode() then
			return EntTable.OpticsThirdPerson
		else
			return EntTable.OpticsFirstPerson
		end
	end

	return false
end

function ENT:UseOptics()
	if self.OpticsZoomOnly and self:GetZoom() ~= 1 then return false end

	return self:GetOpticsEnabled()
end

function ENT:PaintCrosshairCenter( Pos2D, Col )
	if self:UseOptics() then
		if self.OpticsScreenCentered then
			self:CalcOpticsCrosshairDot( Pos2D )

			local ScreenCenter2D = {
				x = ScrW() * 0.5,
				y = ScrH() * 0.5,
				visible = true,
			}

			self:PaintOptics( ScreenCenter2D, Col, LocalPlayer():GetVehicle():GetNWInt( "pPodIndex", -1 ), 1 )
		else
			self:PaintOptics( Pos2D, Col, LocalPlayer():GetVehicle():GetNWInt( "pPodIndex", -1 ), 1 )
		end

		return
	end

	BaseClass.PaintCrosshairCenter( self, Pos2D, Col )
end

function ENT:PaintCrosshairOuter( Pos2D, Col )
	if self:UseOptics() then
		if self.OpticsScreenCentered then
			self:CalcOpticsCrosshairDot( Pos2D )

			local ScreenCenter2D = {
				x = ScrW() * 0.5,
				y = ScrH() * 0.5,
				visible = true,
			}

			self:PaintOptics( ScreenCenter2D, Col, LocalPlayer():GetVehicle():GetNWInt( "pPodIndex", -1 ), 2 )
		else
			self:PaintOptics( Pos2D, Col, LocalPlayer():GetVehicle():GetNWInt( "pPodIndex", -1 ), 2 )
		end

		return
	end

	BaseClass.PaintCrosshairOuter( self, Pos2D, Col )
end

function ENT:PaintCrosshairSquare( Pos2D, Col )
	if self:UseOptics() then
		if self.OpticsScreenCentered then
			self:CalcOpticsCrosshairDot( Pos2D )

			local ScreenCenter2D = {
				x = ScrW() * 0.5,
				y = ScrH() * 0.5,
				visible = true,
			}

			self:PaintOptics( ScreenCenter2D, Col, LocalPlayer():GetVehicle():GetNWInt( "pPodIndex", -1 ), 3 )
		else
			self:PaintOptics( Pos2D, Col, LocalPlayer():GetVehicle():GetNWInt( "pPodIndex", -1 ), 3 )
		end

		return
	end

	BaseClass.PaintCrosshairSquare( self, Pos2D, Col )
end

function ENT:DrawRotatedText( text, x, y, font, color, ang)
	render.PushFilterMag( TEXFILTER.ANISOTROPIC )
	render.PushFilterMin( TEXFILTER.ANISOTROPIC )

	local m = Matrix()
	m:Translate( Vector( x, y, 0 ) )
	m:Rotate( Angle( 0, ang, 0 ) )

	surface.SetFont( font )
	local w, h = surface.GetTextSize( text )

	m:Translate( -Vector( w * 0.5, h * 0.5, 0 ) )

	cam.PushModelMatrix( m )
		draw.DrawText( text, font, 0, 0, color )
	cam.PopModelMatrix()

	render.PopFilterMag()
	render.PopFilterMin()
end

function ENT:PaintOptics( Pos2D, Col, PodIndex, Type )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_base_wheeldrive/cl_hud_speedometer.lua:

LVS:AddHudEditor( "Tachometer",  ScrW() - 530, ScrH() - 250,  300, 220, 300, 220, "TACH",
	function( self, vehicle, X, Y, W, H, ScrX, ScrY, ply )
		if not vehicle.LVSHudPaintTach or not vehicle.GetRacingHud then return end

		vehicle:LVSHudPaintTach( X, Y, W, H, ScrX, ScrY, ply )
	end
)

local THE_FONT = {
	font = "Verdana",
	extended = false,
	size = 100,
	weight = 2000,
	blursize = 0,
	scanlines = 0,
	antialias = false,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
}
surface.CreateFont( "LVS_TACHOMETER", THE_FONT )

local circles = include("includes/circles/circles.lua")

local Center = 650

local startAngleSpeedo = 180
local endAngleSpeedo = 375

local startAngleTach = 165
local endAngleTach = 360

local RingOuter = circles.New( CIRCLE_OUTLINED, 645, 0, 0, 35 )
RingOuter:SetX( Center )
RingOuter:SetY( Center )
RingOuter:SetMaterial( true )

local RingInner = circles.New( CIRCLE_OUTLINED, 640, 0, 0, 25 )
RingInner:SetX( Center )
RingInner:SetY( Center )
RingInner:SetMaterial( true )

local RingOuterRedline = circles.New( CIRCLE_OUTLINED, 645, 0, 0, 20 )
RingOuterRedline:SetX( Center )
RingOuterRedline:SetY( Center )
RingOuterRedline:SetMaterial( true )

local RingInnerRedline = circles.New( CIRCLE_OUTLINED, 640, 0, 0, 10 )
RingInnerRedline:SetX( Center )
RingInnerRedline:SetY( Center )
RingInnerRedline:SetMaterial( true )

local VehicleTach = {}

function ENT:GetBakedTachMaterial( MaxRPM )
	local Class = self:GetClass()

	if VehicleTach[ Class ] then return VehicleTach[ Class ] end

	local TachRange = endAngleTach - startAngleTach

	local Steps = math.ceil(MaxRPM / 1000)
	local AngleStep = TachRange / Steps
	local AngleRedline = startAngleTach + (TachRange / MaxRPM) * self.EngineMaxRPM

	local tachRT = GetRenderTarget( "lvs_tach_"..Class, Center * 2, Center * 2 )

	local old = DisableClipping( true )

	render.OverrideAlphaWriteEnable( true, true )

	render.PushRenderTarget( tachRT )

	cam.Start2D()
		render.ClearDepth()
		render.Clear( 0, 0, 0, 0 )

		surface.SetDrawColor( Color( 0, 0, 0, 200 ) )

		RingOuter:SetStartAngle( startAngleTach )
		RingOuter:SetEndAngle( AngleRedline )
		RingOuter()

		RingOuterRedline:SetStartAngle( AngleRedline )
		RingOuterRedline:SetEndAngle( endAngleTach )
		RingOuterRedline()

		surface.SetDrawColor( color_white )

		for i = 0, Steps do
			local Ang = AngleStep * i + startAngleTach

			local AngX = math.cos( math.rad( Ang ) )
			local AngY = math.sin( math.rad( Ang ) )

			local StartX = Center + AngX * 554
			local StartY = Center + AngY * 554

			local EndX = Center + AngX * 635
			local EndY = Center + AngY * 635

			if Ang > AngleRedline then
				surface.SetDrawColor( Color(255,0,0,255) )
			else
				surface.SetDrawColor( color_white )
			end

			draw.NoTexture()
			surface.DrawTexturedRectRotated( (StartX + EndX) * 0.5, (StartY + EndY) * 0.5, 90, 15, -Ang )

			local TextX = Center + AngX * 485
			local TextY = Center + AngY * 485

			if Ang > AngleRedline then
				draw.SimpleText( i, "LVS_TACHOMETER", TextX, TextY, Color(255,0,0,255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			else
				draw.SimpleText( i, "LVS_TACHOMETER", TextX, TextY, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
			end
		end

		for i = 1, Steps do
			local Start = AngleStep * i + startAngleTach

			for n = 1, 9 do
				local Ang = Start - (AngleStep / 10) * n

				if Ang > AngleRedline then
					surface.SetDrawColor( Color(150,0,0,255) )
				else
					surface.SetDrawColor( Color(150,150,150,255) )
				end

				local AngX = math.cos( math.rad( Ang ) )
				local AngY = math.sin( math.rad( Ang ) )

				local StartX = Center + AngX * 575
				local StartY = Center + AngY * 575

				local EndX = Center + AngX * 635
				local EndY = Center + AngY * 635

				draw.NoTexture()
				surface.DrawTexturedRectRotated( (StartX + EndX) * 0.5, (StartY + EndY) * 0.5, 60, 5, -Ang )
			end
		end

		surface.SetDrawColor( color_white )

		RingInner:SetStartAngle( startAngleTach )
		RingInner:SetEndAngle( AngleRedline )
		RingInner()

		surface.SetDrawColor( Color(255,0,0,255) )

		RingInnerRedline:SetStartAngle( AngleRedline )
		RingInnerRedline:SetEndAngle( endAngleTach )
		RingInnerRedline()

	cam.End2D()

	render.OverrideAlphaWriteEnable( false )

	render.PopRenderTarget()

	local Mat = CreateMaterial( "lvs_tach_"..Class.."_mat", "UnlitGeneric", { ["$basetexture"] = tachRT:GetName(), ["$translucent"] = 1, ["$vertexcolor"] = 1 } )

	VehicleTach[ Class ] = Mat

	DisableClipping( old )

	return Mat
end

local TachNeedleColor = Color(255,0,0,255)
local TachNeedleRadiusInner = 15
local TachNeedleRadiusOuter = 130
local TachNeedleBlurTime = 0.1
local TachNeedles = {}
local CurRPM = 0
local CurSpeed = 0

function ENT:LVSHudPaintTach( X, Y, w, h, ScrX, ScrY, ply )
	if ply ~= self:GetDriver() then return end

	if not self:GetRacingHud() then return end

	local Engine = self:GetEngine()

	if not IsValid( Engine ) then return end

	local Delta = (Engine:GetRPM() - CurRPM) * RealFrameTime() * 20

	CurRPM = CurRPM + Delta

	local MaxRPM = self.EngineMaxRPM + 3000

	surface.SetDrawColor( 255, 255, 255, 255 )
	surface.SetMaterial( self:GetBakedTachMaterial( MaxRPM ) )
	surface.DrawTexturedRect( X, Y, w, w )

	local CenterX = X + w * 0.5
	local CenterY = Y + w * 0.5

	local T = CurTime()

	local Ang = startAngleTach + (endAngleTach - startAngleTach) * (CurRPM / MaxRPM)

	local AngX = math.cos( math.rad( Ang ) )
	local AngY = math.sin( math.rad( Ang ) )

	if math.abs( Delta ) > 1 then
		local data = {
			StartX = (CenterX + AngX * TachNeedleRadiusInner),
			StartY = (CenterY + AngY * TachNeedleRadiusInner),
			EndX = (CenterX + AngX * TachNeedleRadiusOuter),
			EndY = (CenterY + AngY * TachNeedleRadiusOuter),
			Time = T + TachNeedleBlurTime
		}

		table.insert( TachNeedles, data )
	else
		local StartX = CenterX + AngX * TachNeedleRadiusInner
		local StartY = CenterY + AngY * TachNeedleRadiusInner
		local EndX = CenterX + AngX * TachNeedleRadiusOuter
		local EndY = CenterY + AngY * TachNeedleRadiusOuter

		surface.SetDrawColor( TachNeedleColor )
		surface.DrawLine( StartX, StartY, EndX, EndY )
	end

	for index, data in pairs( TachNeedles ) do
		if data.Time < T then
			TachNeedles[ index ] = nil

			continue
		end

		local Brightness = (data.Time - T) / TachNeedleBlurTime

		surface.SetDrawColor( Color( TachNeedleColor.r * Brightness, TachNeedleColor.g * Brightness, TachNeedleColor.b * Brightness, TachNeedleColor.a * Brightness ^ 2 ) )
		surface.DrawLine( data.StartX, data.StartY, data.EndX, data.EndY )
	end
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_bike_wheeldrive/cl_init.lua:
include("shared.lua")

local lerp_to_ragdoll = 0
local freezeangles = Angle(0,0,0)

function ENT:StartCommand( ply, cmd )
	local LocalSpeed = self:WorldToLocal( self:GetPos() + self:GetVelocity() )

	ply:SetAbsVelocity( LocalSpeed )
end

function ENT:CalcViewOverride( ply, pos, angles, fov, pod )
	if ply:GetNWBool( "lvs_camera_follow_ragdoll", false ) then
		local ragdoll = ply:GetRagdollEntity()

		if IsValid( ragdoll ) then
			lerp_to_ragdoll = math.min( lerp_to_ragdoll + FrameTime() * 2, 1 )

			local eyeang = ply:EyeAngles() - Angle(0,90,0)

			local newpos = LerpVector( lerp_to_ragdoll, pos, ragdoll:GetPos() )
			local newang = LerpAngle( lerp_to_ragdoll, freezeangles, freezeangles + eyeang )

			return newpos, newang, fov
		end
	end

	lerp_to_ragdoll = 0
	freezeangles = angles

	return pos, angles, fov
end

function ENT:CalcViewDirectInput( ply, pos, angles, fov, pod )
	local roll = angles.r

	angles.r = math.max( math.abs( roll ) - 30, 0 ) * (angles.r > 0 and 1.5 or -1.5)
	return LVS:CalcView( self, ply, pos, angles,  fov, pod )
end

function ENT:CalcViewPassenger( ply, pos, angles, fov, pod )
	local roll = angles.r

	angles.r = math.max( math.abs( roll ) - 30, 0 ) * (angles.r > 0 and 1.5 or -1.5)
	return LVS:CalcView( self, ply, pos, angles,  fov, pod )
end

local angle_zero = Angle(0,0,0)

function ENT:GetPlayerBoneManipulation( ply, PodID )
	if PodID ~= 1 then return self.PlayerBoneManipulate[ PodID ] or {} end

	local TargetValue = self:ShouldPutFootDown() and 1 or 0

	local Rate = math.min( FrameTime() * 4, 1 )

	ply._smlvsBikerFoot = ply._smlvsBikerFoot and (ply._smlvsBikerFoot + (TargetValue - ply._smlvsBikerFoot) * Rate) or 0

	local CurValue = ply._smlvsBikerFoot ^ 2

	local Pose = table.Copy( self.PlayerBoneManipulate[ PodID ] or {} )

	local BoneManip = self:GetEngineActive() and self.DriverBoneManipulateIdle or self.DriverBoneManipulateParked

	for bone, EndAngle in pairs( BoneManip or {} ) do
		local StartAngle = Pose[ bone ] or angle_zero

		Pose[ bone ] = LerpAngle( CurValue, StartAngle, EndAngle )
	end

	if self.DriverBoneManipulateKickStart and ply._KickStartValue then
		ply._KickStartValue = math.max( ply._KickStartValue - Rate, 0 )

		local Start = self.DriverBoneManipulateKickStart.Start
		local End = self.DriverBoneManipulateKickStart.End

		for bone, EndAngle in pairs( End ) do
			local StartAngle = Start[ bone ] or angle_zero

			Pose[ bone ] = LerpAngle( ply._KickStartValue, StartAngle, EndAngle )
		end

		if ply._KickStartValue == 0 then ply._KickStartValue = nil end
	end

	return Pose or {}
end

function ENT:GetKickStarter()
	local Driver = self:GetDriver()

	if not IsValid( Driver ) then return 0 end

	return math.sin( (Driver._KickStartValue or 0) * math.pi ) ^ 2
end

net.Receive( "lvs_kickstart_network" , function( len )
	local ply = net.ReadEntity()

	if not IsValid( ply ) then return end

	ply._KickStartValue = 1
end )
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_ammo.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Ammo"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/misc/88mm_shell.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:PhysWake()
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
	end

	function ENT:Think()
		if self.MarkForRemove then
			self:Remove()

			return false
		end

		self:NextThink( CurTime() + 0.1 )

		return true
	end

	function ENT:AddSingleRound( entity )
		local AmmoIsSet = false

		for PodID, data in pairs( entity.WEAPONS ) do
			for id, weapon in pairs( data ) do
				local MaxAmmo = weapon.Ammo or -1
				local CurAmmo = weapon._CurAmmo or MaxAmmo

				if CurAmmo == MaxAmmo then continue end

				entity.WEAPONS[PodID][ id ]._CurAmmo = math.min( CurAmmo + 1, MaxAmmo )

				AmmoIsSet = true
			end
		end

		if AmmoIsSet then
			entity:SetNWAmmo( entity:GetAmmo() )

			for _, pod in pairs( entity:GetPassengerSeats() ) do
				local weapon = pod:lvsGetWeapon()

				if not IsValid( weapon ) then continue end

				weapon:SetNWAmmo( weapon:GetAmmo() )
			end
		end

		return AmmoIsSet
	end

	function ENT:Refil( entity )
		if self.MarkForRemove then return end

		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		if self:AddSingleRound( entity ) then
			entity:OnMaintenance()

			entity:EmitSound("items/ammo_pickup.wav")

			self.MarkForRemove = true
		end
	end

	function ENT:ShootBullet( attacker )
		if self.BeenFired then return end

		self.BeenFired = true

		local hit_decal = ents.Create( "lvs_armor_bounce" )
		hit_decal:SetPos( self:GetPos() )
		hit_decal:SetAngles( self:GetAngles() )
		hit_decal:Spawn()
		hit_decal:Activate()
		hit_decal:EmitSound("ambient/explosions/explode_4.wav", 75, 120, 1)
		hit_decal:SetCollisionGroup( COLLISION_GROUP_NONE )

		if IsValid( attacker ) then
			hit_decal:SetPhysicsAttacker( attacker, 10 )
		end

		local PhysObj = hit_decal:GetPhysicsObject()
		if IsValid( PhysObj ) then
			PhysObj:SetMass( 50 )
			PhysObj:EnableDrag( false )
			PhysObj:SetVelocityInstantaneous( self:GetForward() * 4000 )
			PhysObj:SetAngleVelocityInstantaneous( VectorRand() * 250 )
		end

		self:SetModel("models/misc/88mm_casing.mdl")
	end

	function ENT:PhysicsCollide( data, physobj )
		if data.Speed > 60 and data.DeltaTime > 0.2 then
			local VelDif = data.OurOldVelocity:Length() - data.OurNewVelocity:Length()

			if VelDif > 700 then
				self:ShootBullet()
			end
		end

		self:Refil( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )
		self:ShootBullet( dmginfo:GetAttacker() )
	end
end

if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end

	function ENT:OnRemove()
	end

	function ENT:Think()
	end
end

function ENT:GetCrosshairFilterEnts()
	return {self}
end
--PATH addons/lvs_base-main/lua/entities/lvs_item_ammocrate.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Ammo Crate"
ENT.Information = "Single-Use Ammo Refil Item"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/items/item_item_crate.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:PhysWake()
	end

	function ENT:Think()
		return false
	end

	function ENT:Refil( entity )
		if self.MarkForRemove then return end

		if not IsValid( entity ) then return end

		if not entity.LVS then return end

		if entity:WeaponRestoreAmmo() then
			entity:EmitSound("items/ammo_pickup.wav")

			self.MarkForRemove = true

			SafeRemoveEntityDelayed( self, 0 )
		end
	end

	function ENT:PhysicsCollide( data, physobj )
		self:Refil( data.HitEntity )
	end

	function ENT:OnTakeDamage( dmginfo )
	end
end

if CLIENT then
	function ENT:Draw( flags )
		self:DrawModel( flags )
	end

	function ENT:OnRemove()
	end

	function ENT:Think()
	end
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_exhaust.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Tuning Exhaust"
ENT.Author = "Luna"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()

		return ent
	end

	function ENT:Initialize()	
		self:SetModel( "models/props_vehicles/carparts_muffler01a.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:PhysWake()
	end

	function ENT:Think()
		return false
	end

	function ENT:PhysicsCollide( data )
		if self.MarkForRemove then return end

		local ent = data.HitEntity

		if not IsValid( ent ) or not ent.LVS or not isfunction( ent.SetBackfire ) then return end

		ent:SetBackfire( not ent:GetBackfire() )

		local ply = self:GetCreator()

		if ent:GetBackfire() then
			ent:EmitSound("common/wpn_hudoff.wav")

			if IsValid( ply ) then
				ply:ChatPrint( "Tuning Exhaust Added" )
			end
		else
			ent:EmitSound("common/wpn_denyselect.wav")

			if IsValid( ply ) then
				ply:ChatPrint( "Tuning Exhaust Removed" )
			end
		end

		self.MarkForRemove = true

		SafeRemoveEntityDelayed( self, 0 )
	end

	function ENT:OnTakeDamage( dmginfo )
	end

else
	function ENT:Draw( flags )
		self:DrawModel( flags )
	end
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_item_spikestrip.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.PrintName = "Spike Strip"
ENT.Author = "Luna"
ENT.Information = "Pops Tires"
ENT.Category = "[LVS]"

ENT.Spawnable		= true
ENT.AdminOnly		= false

ENT.RenderGroup = RENDERGROUP_BOTH 

ENT.PhysicsSounds = true

if SERVER then
	function ENT:SetAttacker( ent ) self._attacker = ent end
	function ENT:GetAttacker() return self._attacker or self end

	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal )
		ent:Spawn()
		ent:Activate()
		ent:SetAttacker( ply )

		return ent
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:Initialize()
		self:SetModel( "models/diggercars/shared/spikestrip_static.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetTrigger( true )
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )
		self:AddEFlags( EFL_NO_PHYSCANNON_INTERACTION )
	end

	function ENT:UpdateFold()
	end
	
	function ENT:Think()
		local PhysObj = self:GetPhysicsObject()

		if IsValid( PhysObj ) and PhysObj:IsMotionEnabled() then
			if PhysObj:IsAsleep() then
				PhysObj:EnableMotion( false )
			end
		end

		self:UpdateFold()

		self:NextThink( CurTime() )

		return true
	end

	function ENT:Use( ply )
	end

	function ENT:OnRemove()
	end

	function ENT:PhysicsCollide( data, physobj )
	end

	function ENT:StartTouch( entity )
	end

	function ENT:EndTouch( entity )
	end

	function ENT:Touch( entity )
		if not IsValid( entity ) or entity:GetClass() ~= "lvs_wheeldrive_wheel" then return end

		local Destroy = entity:GetVelocity():Length() > 200

		if not Destroy then
			for i = 1,3 do
				local L = self:LookupAttachment( "l"..i )
				local R = self:LookupAttachment( "r"..i )

				local attL = self:GetAttachment( L )
				local attR = self:GetAttachment( R )

				if not attL or not attR then continue end

				local trace = util.TraceLine( {
					start = attL.Pos,
					endpos = attR.Pos,
					filter = entity,
					whitelist = true,
				} )

				if trace.Hit then
					Destroy = true

					break
				end
			end
		end

		if not Destroy then return end

		local T = CurTime()

		if (entity._LastSpikeStripPop or 0) > T then return end

		entity._LastSpikeStripPop = T + 2

		local dmginfo = DamageInfo()
		dmginfo:SetDamage( entity:GetHP() )
		dmginfo:SetAttacker( self:GetAttacker() )
		dmginfo:SetDamageType( DMG_PREVENT_PHYSICS_FORCE ) 

		entity:TakeDamageInfo( dmginfo )

		local base = entity:GetBase()

		if not IsValid( base ) then return end

		local PhysObj = base:GetPhysicsObject()

		if not IsValid( PhysObj ) then return end

		PhysObj:ApplyTorqueCenter( Vector(0,0, PhysObj:GetVelocity():Length() * 100 * (PhysObj:GetAngleVelocity().z > 0 and 1 or -1) ) )
	end

	return
end

function ENT:Think()
end

function ENT:Draw( flags )
	self:DrawModel( flags )
end

local spritemat = Material( "sprites/light_glow02_add" )
local spritecolor = Color( 255, 93, 0, 255)

function ENT:DrawTranslucent( flags )
	self:DrawModel( flags )

	local size1 = 16 * (math.abs( math.cos( CurTime() * 4 ) ) ^ 10)
	local size2 = 16 * (math.abs( math.sin( CurTime() * 4 ) ) ^ 10)

	render.SetMaterial( spritemat )
	render.DrawSprite( self:LocalToWorld( Vector(8,-116.5,10) ), size1, size1, spritecolor )
	render.DrawSprite( self:LocalToWorld( Vector(-7,-116.5,10) ), size2, size2, spritecolor )
	render.DrawSprite( self:LocalToWorld( Vector(8,118,10) ), size2, size2, spritecolor )
	render.DrawSprite( self:LocalToWorld( Vector(-7,118,10) ), size1, size1, spritecolor )
end

function ENT:OnRemove()
end
--PATH addons/lvs_base-main/lua/entities/lvs_soundemitter.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT.Spawnable       = false
ENT.AdminSpawnable  = false
ENT.DoNotDuplicate = true

ENT._LVS = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Bool",0, "Active" )
	self:NetworkVar( "Bool",1, "ActiveVisible" )
	self:NetworkVar( "Bool",2, "Doppler" )

	self:NetworkVar( "String",1, "Sound")
	self:NetworkVar( "String",2, "SoundInterior")

	self:NetworkVar( "Int",0, "SoundLevel" )

	if SERVER then
		self:SetSoundLevel( 110 )
		self:SetActiveVisible( true )
	end
end

if SERVER then
	util.AddNetworkString( "lvs_soundemitter_playonce" )

	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 50, 5, Color( 150, 150, 150 ) )
	end

	function ENT:Think()
		return false
	end

	function ENT:UpdateTransmitState() 
		return TRANSMIT_ALWAYS
	end

	function ENT:PlayOnce( pitch, volume )
		net.Start( "lvs_soundemitter_playonce", true )
			net.WriteEntity( self )
			net.WriteInt( pitch or 100, 9 )
			net.WriteFloat( volume or 1 )
		net.SendPVS( self:GetPos() )
	end

	function ENT:Play()
		self:SetActive( true )
	end

	function ENT:Stop()
		self:SetActive( false )
	end

	return
end

net.Receive( "lvs_soundemitter_playonce", function( len )
	local ent = net.ReadEntity()

	if not IsValid( ent ) or not ent.PlayOnce then return end

	ent:PlayOnce( net.ReadInt( 9 ), net.ReadFloat() )
end )

function ENT:PlayOnce( pitch, volume )
	local ply = LocalPlayer()
	local veh = ply:lvsGetVehicle()

	local snd = self:GetSound()
	local snd_int = self:GetSoundInterior()

	if snd == snd_int then self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON ) return end

	if IsValid( veh ) and veh == self:GetBase() and ply:GetViewEntity() == ply then
		local pod = ply:GetVehicle()

		if IsValid( pod ) then
			if pod:GetThirdPersonMode() then
				self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
			else
				self:EmitSound( snd_int, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
			end
		else
			self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
		end
	else
		self:EmitSound( snd, self:GetSoundLevel(), pitch, volume, CHAN_WEAPON )
	end
end

function ENT:Initialize()
end

function ENT:RemoveSounds()
	if self.snd then
		self.snd:Stop()
		self.snd = nil
	end

	if self.snd_int then
		self.snd_int:Stop()
		self.snd_int = nil
	end
end

function ENT:HandleSounds()
	local ply = LocalPlayer()
	local veh = ply:lvsGetVehicle()
	local base = self:GetBase()

	if self:GetDoppler() and IsValid( base ) then
		local Doppler = base:CalcDoppler( ply )

		if self.snd then self.snd:ChangePitch( 100 * Doppler, 0.5 ) end
		if self.snd_int then self.snd_int:ChangePitch( 100 * Doppler, 0.5 ) end
	end

	if not self.snd_int then return end

	if IsValid( veh ) and veh == base and ply:GetViewEntity() == ply then
		local pod = ply:GetVehicle()

		if IsValid( pod ) then
			if pod:GetThirdPersonMode() then
				if self.snd then self.snd:ChangeVolume( 1 ) end
				if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
			else
				if self.snd then self.snd:ChangeVolume( 0 ) end
				if self.snd_int then self.snd_int:ChangeVolume( 1 ) end
			end
		else
			if self.snd then self.snd:ChangeVolume( 1 ) end
			if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
		end
	else
		if self.snd then self.snd:ChangeVolume( 1 ) end
		if self.snd_int then self.snd_int:ChangeVolume( 0 ) end
	end
end

function ENT:StartSounds()
	local snd = self:GetSound()
	local snd_int = self:GetSoundInterior()

	if snd ~= "" then
		self.snd = CreateSound( self, snd )
		self.snd:SetSoundLevel( self:GetSoundLevel() )
		self.snd:PlayEx(0,100)
	end

	if snd == snd_int or snd_int == "" or LocalPlayer():lvsGetVehicle() ~= self:GetBase() then
		if self.snd then self.snd:ChangeVolume( 1, 0 ) end

		return
	end

	self.snd_int = CreateSound( self, snd_int )
	self.snd_int:SetSoundLevel( self:GetSoundLevel() )
	self.snd_int:PlayEx(0,100)
end

function ENT:StopSounds()
	self.NextActive = CurTime() + 0.12

	if self.snd then
		self.snd:ChangeVolume( 0, 0.1 )
	end

	if self.snd_int then
		self.snd_int:ChangeVolume( 0, 0.1 )
	end

	timer.Simple(0.11, function()
		if not IsValid( self ) then return end
		self:RemoveSounds()
	end)
end

function ENT:OnActiveChanged( Active )
	if Active then
		self:StartSounds()
	else
		self:StopSounds()
	end
end

ENT._oldActive = false
function ENT:Think()
	local Active = self:GetActive() and (self.NextActive or 0) < CurTime()

	if self._oldActive ~= Active then
		self._oldActive = Active
		self:OnActiveChanged( Active )
	end

	if Active then
		self:HandleSounds()
	end
end

function ENT:OnRemove()
	self:RemoveSounds()
end

function ENT:Draw()
end

function ENT:DrawTranslucent()
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_trailer_flak/shared.lua:

ENT.Base = "lvs_base_wheeldrive_trailer"

ENT.PrintName = "FlaK 38"
ENT.Author = "Luna"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS]"

ENT.VehicleCategory = "Artillery"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/blu/flak38.mdl"

ENT.GibModels = {
	"models/blu/flak_db.mdl",
	"models/blu/flak_d1.mdl",
	"models/blu/flak_d2.mdl",
	"models/blu/flak_d3.mdl",
	"models/blu/flak_d4.mdl",
	"models/blu/flak_d5.mdl",
	"models/blu/flak_d6.mdl",
}

ENT.lvsShowInSpawner = false

ENT.AITEAM = 1

ENT.PhysicsWeightScale = 1
ENT.PhysicsMass = 450
ENT.PhysicsInertia = Vector(475,452,162)
ENT.PhysicsDampingSpeed = 4000
ENT.PhysicsDampingForward = false
ENT.PhysicsDampingReverse = false

ENT.MaxHealth = 400

function ENT:InitWeapons()
	local weapon = {}
	weapon.Icon = Material("lvs/weapons/flak_he.png")
	weapon.Ammo = 1500
	weapon.Delay = 0.25
	weapon.HeatRateUp = 0.25
	weapon.HeatRateDown = 0.5
	weapon.Attack = function( ent )

		if not ent:TurretInRange() then
			return true
		end

		local ID = ent:LookupAttachment( "muzzle" )

		local Muzzle = ent:GetAttachment( ID )

		if not Muzzle then return end

		local Pos = Muzzle.Pos
		local Dir = (ent:GetEyeTrace().HitPos - Pos):GetNormalized()

		local bullet = {}
		bullet.Src 	= Pos
		bullet.Dir 	= Dir
		bullet.Spread 	= Vector(0,0,0)
		bullet.TracerName = "lvs_tracer_autocannon"
		bullet.Force	= 3900
		bullet.HullSize 	= 50 * math.max( Dir.z, 0 )
		bullet.Damage	= 40
		bullet.EnableBallistics = true
		bullet.SplashDamage = 20
		bullet.SplashDamageRadius = 100
		bullet.SplashDamageEffect = "lvs_defence_explosion"
		bullet.SplashDamageType = DMG_SONIC
		bullet.Velocity = 50000
		bullet.Attacker 	= ent:GetDriver()
		ent:LVSFireBullet( bullet )

		local effectdata = EffectData()
		effectdata:SetOrigin( bullet.Src )
		effectdata:SetNormal( bullet.Dir )
		effectdata:SetEntity( ent )
		util.Effect( "lvs_muzzle", effectdata )

		ent:PlayAnimation( "fire" )

		ent:TakeAmmo( 1 )

		if not IsValid( ent.SNDTurret ) then return end

		ent.SNDTurret:PlayOnce( 100 + math.cos( CurTime() + ent:EntIndex() * 1337 ) * 5 + math.Rand(-1,1), 1 )
	end
	weapon.OnOverheat = function( ent )
		ent:EmitSound("lvs/vehicles/222/cannon_overheat.wav")
	end
	weapon.HudPaint = function( ent, X, Y, ply )
		local Pos2D = ent:GetEyeTrace().HitPos:ToScreen()

		local Col =  ent:TurretInRange() and Color(255,255,255,255) or Color(255,0,0,255)

		ent:PaintCrosshairCenter( Pos2D, Col )
		ent:PaintCrosshairSquare( Pos2D, Col )
		ent:LVSPaintHitMarker( Pos2D )
	end
	self:AddWeapon( weapon )
end


--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_2108/cl_init.lua:
include("shared.lua")

function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	self:SetPoseParameter( "vehicle_steer", steer )
	self:SetPoseParameter( "temp_gauge", temperature )
	self:SetPoseParameter( "fuel_gauge", fuel )
	self:SetPoseParameter( "oil_gauge", oil )
	self:SetPoseParameter( "alt_gauge", ammeter )
	self:SetPoseParameter( "vehicle_gauge", speed_kmh / 180 )
	self:SetPoseParameter( "throttle_pedal", throttle )
	self:SetPoseParameter( "brake_pedal", brake )
	self:SetPoseParameter( "handbrake_pedal", handbrake )
	self:SetPoseParameter( "clutch_pedal", clutch )

	local GearIDtoPose = {
		[-1] = 0,
		[1] = 3,
		[2] = 5,
		[3] = 8,
		[4] = 10,
	}

	self:SetPoseParameter( "gear",  self:QuickLerp( "gear", (GearIDtoPose[ gear ] or 1) ) )

end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_bmw_e46m3/cl_init.lua:
include("shared.lua")

function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	self:SetPoseParameter( "vehicle_steer", steer )
	self:SetPoseParameter( "tacho_gauge", engine_rpm / 9000 )
	self:SetPoseParameter( "temp_gauge", temperature )
	self:SetPoseParameter( "fuel_gauge", fuel )
	self:SetPoseParameter( "oil_gauge", oil )
	self:SetPoseParameter( "vehicle_gauge", speed_kmh / 300 )
	self:SetPoseParameter( "throttle_pedal", throttle )
	self:SetPoseParameter( "brake_pedal", brake )
	self:SetPoseParameter( "handbrake_pedal", handbrake )
	self:SetPoseParameter( "clutch_pedal", clutch )

	local GearIDtoPose = {
		[-1] = 0,
		[1] = 5,
		[2] = 7,
		[3] = 9,
		[4] = 11,
		[5] = 13,
		[6] = 15,
	}

	self:SetPoseParameter( "gear",  self:QuickLerp( "gear", (GearIDtoPose[ gear ] or 1) ) )

	local Turbo = self:GetTurbo()

	if not IsValid( Turbo ) then return end

	self:SetPoseParameter( "turbo_gauge", Turbo:GetBoost() )

	self._rpm = self._rpm and self._rpm + engine_rpm * FrameTime() or 0

	self:SetPoseParameter( "engine_spin", -self._rpm )
end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_engine_mod.lua:
AddCSLuaFile()

ENT.Type            = "anim"

ENT._LVS = true

ENT.Editable = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )

	self:NetworkVar( "Float",0, "EngineCurve", { KeyName = "addpower", Edit = { type = "Float",	 order = 1,min = 0, max = 0.5, category = "Upgrade Settings"} } )
	self:NetworkVar( "Int",1, "EngineTorque", { KeyName = "addtorque", Edit = { type = "Int", order = 2,min = 0, max = 100, category = "Upgrade Settings"} } )

	if SERVER then
		self:SetEngineCurve( 0.25 )
		self:SetEngineTorque( 50 )

		self:NetworkVarNotify( "EngineCurve", self.OnEngineCurveChanged )
		self:NetworkVarNotify( "EngineTorque", self.OnEngineTorqueChanged )
	end
end

function ENT:GetBoost()
	if not self._smBoost then return 0 end

	return self._smBoost
end

if SERVER then
	function ENT:SpawnFunction( ply, tr, ClassName )
		if not tr.Hit then return end

		local ent = ents.Create( ClassName )
		ent:SetPos( tr.HitPos + tr.HitNormal * 5 )
		ent:Spawn()
		ent:Activate()
		ent.PlaySound = true

		return ent
	end

	function ENT:Initialize()	
	end

	function ENT:Think()
		return false
	end

	function ENT:CanLink( ent )
		return true
	end

	function ENT:OnLinked( ent )
	end

	function ENT:OnUnLinked( ent )
	end

	function ENT:OnVehicleUpdated()
	end

	local function ResetEngine( ply, ent, data )
		if not duplicator or not duplicator.StoreEntityModifier then return end

		if data.Curve then ent.EngineCurve = data.Curve end
		if data.Torque then ent.EngineTorque = data.Torque end

		duplicator.StoreEntityModifier( ent, "lvsCarResetEngine", data )
	end

	if duplicator and duplicator.RegisterEntityModifier then
		duplicator.RegisterEntityModifier( "lvsCarResetEngine", ResetEngine )
	end

	function ENT:LinkTo( ent )
		if not IsValid( ent ) or not ent.LVS or not self:CanLink( ent ) then return end

		local engine = ent:GetEngine()

		if not IsValid( engine ) then return end

		self.DoNotDuplicate = true

		self:PhysicsDestroy()

		self:SetSolid( SOLID_NONE )
		self:SetMoveType( MOVETYPE_NONE )

		self:SetPos( engine:GetPos() )
		self:SetAngles( engine:GetAngles() )

		self:SetParent( engine )

		self:SetBase( ent )

		if not ent.OriginalTorque or not ent.OriginalCurve then
			ent.OriginalTorque = ent.EngineTorque
			ent.OriginalCurve = ent.EngineCurve

			local data = {
				Curve = ent.OriginalCurve,
				Torque = ent.OriginalTorque,
			}

			duplicator.StoreEntityModifier( ent, "lvsCarResetEngine", data )
		end

		ent.EngineCurve = ent.EngineCurve + self:GetEngineCurve()
		ent.EngineTorque = ent.EngineTorque + self:GetEngineTorque()

		self:OnVehicleUpdated( ent )
		self:OnLinked( ent )
	end

	function ENT:PhysicsCollide( data )
		if self.HasTouched then return end

		self.HasTouched = true

		timer.Simple(0, function()
			if not IsValid( self ) then return end

			self.HasTouched = nil

			self:LinkTo( data.HitEntity )
		end)
	end

	function ENT:OnRemove()
		local base = self:GetBase()

		if not IsValid( base ) or base.ExplodedAlready then return end

		base.EngineCurve = base.EngineCurve - self:GetEngineCurve()
		base.EngineTorque = base.EngineTorque - self:GetEngineTorque()

		self:OnVehicleUpdated( base )

		self:OnUnLinked( base )
	end

	function ENT:OnEngineCurveChanged( name, old, new )
		if old == new then return end

		local ent = self:GetBase()

		if not IsValid( ent ) then return end

		ent.EngineCurve = ent.EngineCurve - old + new

		self:OnVehicleUpdated( ent )
	end

	function ENT:OnEngineTorqueChanged( name, old, new )
		if old == new then return end

		local ent = self:GetBase()

		if not IsValid( ent ) then return end

		ent.EngineTorque = ent.EngineTorque - old + new

		self:OnVehicleUpdated( ent )
	end

	return
end

function ENT:Initialize()
end

function ENT:Think()
end

function ENT:OnRemove()
end

function ENT:Draw( flags )
	self:DrawModel( flags )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_ferrari360/cl_init.lua:
include("shared.lua")

function ENT:UpdatePoseParameters( steer, speed_kmh, engine_rpm, throttle, brake, handbrake, clutch, gear, temperature, fuel, oil, ammeter )
	self:SetPoseParameter( "vehicle_steer", steer )
	self:SetPoseParameter( "tacho_gauge", engine_rpm / 10000 )
	self:SetPoseParameter( "temp_gauge", temperature )
	self:SetPoseParameter( "fuel_gauge", fuel )
	self:SetPoseParameter( "oil_gauge", oil )
	self:SetPoseParameter( "alt_gauge", ammeter )
	self:SetPoseParameter( "vehicle_gauge", speed_kmh / 350 )
	self:SetPoseParameter( "throttle_pedal", throttle )
	self:SetPoseParameter( "brake_pedal", brake )

	local GearIDtoPose = {
		[-1] = 0,
		[1] = 2,
		[2] = 2,
		[3] = 2,
		[4] = 2,
	}

	self:SetPoseParameter( "gear",  self:QuickLerp( "gear", (GearIDtoPose[ gear ] or 1) ) )

end
--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_fueltank.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "Entity",1, "DoorHandler" )

	self:NetworkVar( "Float",0, "Fuel" )
	self:NetworkVar( "Float",1, "Size" )
	self:NetworkVar( "Float",2, "HP" )
	self:NetworkVar( "Float",3, "MaxHP" )

	self:NetworkVar( "Int",0, "FuelType" )

	self:NetworkVar( "Bool",0, "Destroyed" )

	if SERVER then
		self:SetMaxHP( 100 )
		self:SetHP( 100 )
		self:SetFuel( 1 )
		self:NetworkVarNotify( "Fuel", self.OnFuelChanged )
	end
end

if SERVER then
	function ENT:Initialize()	
		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_NONE )
		self:DrawShadow( false )
		debugoverlay.Cross( self:GetPos(), 20, 5, Color( 255, 93, 0 ) )
	end

	function ENT:ExtinguishAndRepair()
		self:SetHP( self:GetMaxHP() )
		self:SetDestroyed( false )
	end

	function ENT:Think()
		self:NextThink( CurTime() + 1 )

		if self:GetDestroyed() then
			local Base = self:GetBase()

			if not IsValid( Base ) then return end

			if self:GetFuel() > 0 then
				local dmg = DamageInfo()
				dmg:SetDamage( 10 )
				dmg:SetAttacker( IsValid( Base.LastAttacker ) and Base.LastAttacker or game.GetWorld() )
				dmg:SetInflictor( IsValid(  Base.LastInflictor ) and Base.LastInflictor or game.GetWorld() )
				dmg:SetDamageType( DMG_BURN )
				Base:TakeDamageInfo( dmg )

				self:SetFuel( math.max( self:GetFuel() - 0.05, 0 ) )
			else
				self:SetDestroyed( false )
			end
		else
			local base = self:GetBase()

			if IsValid( base ) and base:GetEngineActive() then
				self:SetFuel( math.max( self:GetFuel() - (1 / self:GetSize()) * base:GetThrottle() ^ 2, 0 ) )
			end
		end

		return true
	end

	function ENT:TakeTransmittedDamage( dmginfo )
		if self:GetDestroyed() then return end

		local Damage = dmginfo:GetDamage()

		if Damage <= 0 then return end

		local CurHealth = self:GetHP()

		local NewHealth = math.Clamp( CurHealth - Damage, 0, self:GetMaxHP() )

		self:SetHP( NewHealth )

		if NewHealth <= 0 then
			self:SetDestroyed( true )
		end
	end

	function ENT:OnTakeDamage( dmginfo )
	end

	function ENT:OnFuelChanged( name, old, new)
		if new == old then return end

		if new <= 0 then
			local base = self:GetBase()

			if not IsValid( base ) then return end

			base:ShutDownEngine()

			local engine = base:GetEngine()

			if not IsValid( engine ) then return end

			engine:EmitSound("vehicles/jetski/jetski_off.wav")
		end
	end

	return
end

function ENT:Initialize()
end

function ENT:RemoveFireSound()
	if self.FireBurnSND then
		self.FireBurnSND:Stop()
		self.FireBurnSND = nil
	end

	self.ShouldStopFire = nil
end

function ENT:StopFireSound()
	if self.ShouldStopFire or not self.FireBurnSND then return end

	self.ShouldStopFire = true

	self:EmitSound("ambient/fire/mtov_flame2.wav")

	self.FireBurnSND:ChangeVolume( 0, 0.5 )

	timer.Simple( 1, function()
		if not IsValid( self ) then return end

		self:RemoveFireSound()
	end )
end

function ENT:StartFireSound()
	if self.ShouldStopFire or self.FireBurnSND then return end

	self.FireBurnSND = CreateSound( self, "ambient/fire/firebig.wav" )
	self.FireBurnSND:PlayEx(0,100)
	self.FireBurnSND:ChangeVolume( LVS.EngineVolume, 1 )

	self:EmitSound("ambient/fire/gascan_ignite1.wav")
end

function ENT:OnRemove()
	self:RemoveFireSound()
end

function ENT:Draw()
end

function ENT:Think()
	self:SetNextClientThink( CurTime() + 0.05 )

	self:DamageFX()

	return true
end

function ENT:DamageFX()
	if not self:GetDestroyed() or self:GetFuel() <= 0  then
		self:StopFireSound()

		return
	end

	self:StartFireSound()

	local effectdata = EffectData()
		effectdata:SetOrigin( self:GetPos() )
		effectdata:SetEntity( self:GetBase() )
	util.Effect( "lvs_carfueltank_fire", effectdata )
end


--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_monaco_cop/shared.lua:

ENT.Base = "lvs_base_wheeldrive"

ENT.PrintName = "Dodge Monaco Police"
ENT.Author = "Digger"
ENT.Information = "Luna's Vehicle Script"
ENT.Category = "[LVS] - Cars - Pack"

ENT.VehicleCategory = "Cars"
ENT.VehicleSubCategory = "Civilian"

ENT.Spawnable			= true
ENT.AdminSpawnable		= false

ENT.MDL = "models/diggercars/dodge_monaco/monaco_police.mdl"

ENT.MaxVelocity = 2200

ENT.EngineTorque = 120
ENT.EngineIdleRPM = 750
ENT.EngineMaxRPM = 6000

ENT.TransGears = 3
ENT.TransGearsReverse = 1
ENT.TransShiftSpeed = 0
ENT.TransWobbleTime = 0
ENT.TransWobbleFrequencyMultiplier = 0
ENT.TransShiftSound = "common/null.wav"

ENT.HornSound = "lvs/horn5.wav"
ENT.HornPos = Vector(40,0,35)

ENT.RandomColor = {
	{
		Skin = 1,
		Color = Color(255,255,255),
	},
}

ENT.SirenPos = Vector(40,0,35)
ENT.SirenSound = {
	[1] = {
		siren = "lvs/siren1.wav",
		horn = "lvs/siren3.wav",
	},
	[2] = {
		siren = "lvs/siren2.wav",
		horn = "lvs/siren3.wav",
	},
}

ENT.EngineSounds = {
	{
		sound = "lvs/vehicles/dodge_charger/eng_idle_loop.wav",
		Volume = 1,
		Pitch = 85,
		PitchMul = 25,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_IDLE_ONLY,
	},
	{
		sound = "lvs/vehicles/dodge_charger/eng_loop.wav",
		Volume = 1,
		Pitch = 60,
		PitchMul = 110,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_UP,
		UseDoppler = true,
	},
	{
		sound = "lvs/vehicles/dodge_charger/eng_revdown_loop.wav",
		Volume = 1,
		Pitch = 60,
		PitchMul = 110,
		SoundLevel = 75,
		SoundType = LVS.SOUNDTYPE_REV_DOWN,
		UseDoppler = true,
	},
}

ENT.ExhaustPositions = {
	{
		pos = Vector(-109.89,23.84,17.4),
		ang = Angle(0,180,0),
	},
	{
		pos = Vector(-109.89,23.84,17.4),
		ang = Angle(0,180,0),
	}
}


ENT.Lights = {
	{
		Siren = true,
		Trigger = "1",
		SubMaterialID = 12,
		SubMaterialBrightness = 10,
		Sprites = {
--lightbar1
			{ pos = "bar1l1a1", colorR = 0, colorG = 0, colorA = 255, width = 150, height = 150, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l2a1", colorG = 0, colorB = 0, colorA = 255, width = 100, height = 100, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l2a1", colorG = 0, colorB = 0, colorA = 255, width = 100, height = 100, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l1a1", colorR = 0, colorG = 0, colorA = 255, width = 150, height = 150, bodygroup = { name = "lightbar", active = { 0 } }, },

			{ pos = "bar1l1a2", colorR = 0, colorG = 0, colorA = 255, width = 150, height = 150, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l2a2", colorG = 0, colorB = 0, colorA = 255, width = 100, height = 100, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l2a2", colorG = 0, colorB = 0, colorA = 255, width = 100, height = 100, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l1a2", colorR = 0, colorG = 0, colorA = 255, width = 150, height = 150, bodygroup = { name = "lightbar", active = { 0 } }, },

--lightbar1 white core



			{ pos = "bar1l1a1", colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l2a1", colorR = 255, colorG = 255, colorA = 255, width = 30, height = 30, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l2a1", colorR = 255, colorG = 255, colorA = 255, width = 30, height = 30, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l1a1", colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 0 } }, },

			{ pos = "bar1l1a2", colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l2a2", colorR = 255, colorG = 255, colorA = 255, width = 30, height = 30, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l2a2", colorR = 255, colorG = 255, colorA = 255, width = 30, height = 30, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = "bar1l1a2", colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 0 } }, },

--lightbar2
			{ pos = "bar2l1a1", colorR = 0, colorG = 0, colorA = 255, width = 150, height = 150, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l2a1", colorG = 0, colorB = 0, colorA = 255, width = 100, height = 100, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l2a1", colorG = 0, colorB = 0, colorA = 255, width = 100, height = 100, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l1a1", colorR = 0, colorG = 0, colorA = 255, width = 150, height = 150, bodygroup = { name = "lightbar", active = { 1 } }, },

			{ pos = "bar2l1a2", colorR = 0, colorG = 0, colorA = 255, width = 150, height = 150, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l2a2", colorG = 0, colorB = 0, colorA = 255, width = 100, height = 100, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l2a2", colorG = 0, colorB = 0, colorA = 255, width = 100, height = 100, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar1l1a2", colorR = 0, colorG = 0, colorA = 255, width = 150, height = 150, bodygroup = { name = "lightbar", active = { 1 } }, },



--lightbar2 white core

			{ pos = "bar2l1a1", colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l2a1", colorR = 255, colorG = 255, colorA = 255, width = 30, height = 30, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l2a1", colorR = 255, colorG = 255, colorA = 255, width = 30, height = 30, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l1a1", colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 1 } }, },

			{ pos = "bar2l1a2", colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l2a2", colorR = 255, colorG = 255, colorA = 255, width = 30, height = 30, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l2a2", colorR = 255, colorG = 255, colorA = 255, width = 30, height = 30, bodygroup = { name = "lightbar", active = { 1 } }, },
			{ pos = "bar2l1a2", colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 1 } }, },

--lightbar3
			{ pos = "bar3a1", colorG = 0, colorB = 0, colorA = 255, width = 100, height = 100, bodygroup = { name = "lightbar", active = { 2 } }, },
			{ pos = "bar3a2", colorG = 0, colorB = 0, colorA = 255, width = 100, height = 100, bodygroup = { name = "lightbar", active = { 2 } }, },
--lightbar3 white core

			{ pos = "bar3a1", colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 2 } }, },
			{ pos = "bar3a2", colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 2 } }, },

		},
	},

	{
		Siren = true,
		Trigger = "1100",
		SubMaterialID = 16,
		SubMaterialBrightness = 30,
		Sprites = {
			{ pos = Vector(-12,13.36,66.4), colorR = 255, colorG = 190, colorB = 0, colorA = 255, width = 150, height = 150, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = Vector(-12,13.36,66.4), colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 0 } }, },
		},
	},
	{
		Siren = true,
		Trigger = "0011",
		SubMaterialID = 15,
		SubMaterialBrightness = 30,
		Sprites = {
			{ pos = Vector(-2,12.23,66.16), colorR = 255, colorG = 0, colorB = 0, colorA = 255, width = 150, height = 150, bodygroup = { name = "lightbar", active = { 0 } }, },
			{ pos = Vector(-2,12.23,66.16), colorR = 255, colorG = 255, colorA = 255, width = 40, height = 40, bodygroup = { name = "lightbar", active = { 0 } }, },

		},
	},

	{
		Trigger = "main",
		SubMaterialID = 23,
		Sprites = {
			{ pos = Vector(103.47,-34.2,28.04), colorB = 200, colorA = 150, bodygroup = { name = "fender_right", active = { 0 } }, },
			{ pos = Vector(103.47,34.2,28.04), colorB = 200, colorA = 150, bodygroup = { name = "fender_left", active = { 0 } }, },
		},
		ProjectedTextures = {
			{ pos = Vector(103.47,-34.2,28.04), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true, bodygroup = { name = "fender_right", active = { 0 } }, },
			{ pos = Vector(103.47,34.2,28.04), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true, bodygroup = { name = "fender_left", active = { 0 } }, },
		},
	},
	{
		Trigger = "main",
		SubMaterialID = 30,
	},
	{
		Trigger = "main",
		SubMaterialID = 6,
	},
	{
		Trigger = "high",
		SubMaterialID = 24,
		Sprites = {
			{ pos = Vector(103.01,26.54,27.96), colorB = 200, colorA = 150, bodygroup = { name = "fender_left", active = { 0 } }, },
			{ pos = Vector(103.01,-26.54,27.96), colorB = 200, colorA = 150, bodygroup = { name = "fender_right", active = { 0 } }, },
		},
		ProjectedTextures = {
			{ pos = Vector(103.01,26.54,27.96), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true, bodygroup = { name = "fender_left", active = { 0 } }, },
			{ pos = Vector(103.01,-26.54,27.96), ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true, bodygroup = { name = "fender_right", active = { 0 } }, },
		},
	},

	{
		Trigger = "main+brake+turnleft",
		SubMaterialID = 27,
		Sprites = {
			{ pos = Vector(-112.82,29.47,30.69), width = 40, height = 40, colorG = 0, colorB = 0, colorA = 150, mat = "sprites/lvs/glow_smooth", bodygroup = { name = "rear", active = { 0 } }, },
			{ pos = Vector(-112.94,17.4,30.64), width = 40, height = 40, colorG = 0, colorB = 0, colorA = 150, mat = "sprites/lvs/glow_smooth", bodygroup = { name = "rear", active = { 0 } }, },
		},
	},
	{
		Trigger = "main+brake+turnright",
		SubMaterialID = 28,
		Sprites = {
			{ pos = Vector(-112.82,-29.47,30.69), width = 40, height = 40, colorG = 0, colorB = 0, colorA = 150, mat = "sprites/lvs/glow_smooth", bodygroup = { name = "rear", active = { 0 } }, },
			{ pos = Vector(-112.94,-17.4,30.64), width = 40, height = 40, colorG = 0, colorB = 0, colorA = 150, mat = "sprites/lvs/glow_smooth", bodygroup = { name = "rear", active = { 0 } }, },
		},
	},
	{
		Trigger = "turnright",
		SubMaterialID = 25,
		Sprites = {
			{ width = 40, height = 20, pos = Vector(107.4,-19.47,16.94), colorG = 100, colorB = 0, colorA = 150, bodygroup = { name = "front_bumper", active = { 0 } }, },
			{ width = 40, height = 20, pos = Vector(95.92,-40.16,27.25), colorG = 100, colorB = 0, colorA = 150, bodygroup = { name = "fender_right", active = { 0 } }, },
			{ width = 40, height = 20, pos = Vector(-99.94,-39.86,27.22), colorG = 50, colorB = 0, colorA = 150, bodygroup = { name = "rear", active = { 0 } }, },
		},
	},
	{
		Trigger = "turnleft",
		SubMaterialID = 26,
		Sprites = {
			{ width = 40, height = 20, pos = Vector(107.4,19.47,16.94), colorG = 100, colorB = 0, colorA = 150, bodygroup = { name = "front_bumper", active = { 0 } }, },
			{ width = 40, height = 20, pos = Vector(95.92,40.16,27.25), colorG = 100, colorB = 0, colorA = 150, bodygroup = { name = "fender_left", active = { 0 } }, },
			{ width = 40, height = 20, pos = Vector(-99.94,39.86,27.22), colorG = 50, colorB = 0, colorA = 150, bodygroup = { name = "rear", active = { 0 } }, },

		},
	},
	{
		Trigger = "reverse",
		SubMaterialID = 21,
		SubMaterialBrightness = 20,
		Sprites = {
			{ pos = Vector(-112.68,23.37,30.76), height = 25, width = 45, colorA = 150, bodygroup = { name = "rear", active = { 0 } }, },
			{ pos = Vector(-112.68,-23.37,30.76), height = 25, width = 45, colorA = 150, bodygroup = { name = "rear", active = { 0 } }, },
		}
	},

	{
		Trigger = "fog",
		SubMaterialID = 22,
		Sprites = {
			{ pos = "spot1a", colorB = 200, colorA = 150, bodygroup = { name = "Spotlight", active = { 0 } }, },
			{ pos = "spot2a", colorB = 200, colorA = 150, bodygroup = { name = "Spotlight", active = { 0 } }, },
		},
		ProjectedTextures = {
			{ pos = "spot1a", ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true, bodygroup = { name = "Spotlight", active = { 0 } }, },
			{ pos = "spot2a", ang = Angle(0,0,0), colorB = 200, colorA = 150, shadows = true, bodygroup = { name = "Spotlight", active = { 0 } }, },
		},
	},

}




--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_trailerhitch.lua:
AddCSLuaFile()

ENT.Type            = "anim"
ENT.DoNotDuplicate = true

ENT.RenderGroup = RENDERGROUP_BOTH

local IgnoreDistance = 200
local GrabDistance = 150
local HookupDistance = 32

function ENT:SetupDataTables()
	self:NetworkVar( "Entity",0, "Base" )
	self:NetworkVar( "Entity",1, "TargetBase" )
	self:NetworkVar( "Entity",2, "DragTarget" )
	self:NetworkVar( "Int",0, "HitchType" )

	if SERVER then
		self:SetHitchType( LVS.HITCHTYPE_NONE or -1 )
	end
end

if SERVER then
	util.AddNetworkString( "lvs_trailerhitch" )

	net.Receive( "lvs_trailerhitch", function( len, ply )
		local ent = net.ReadEntity()

		if not IsValid( ent ) or not isfunction( ent.StartDrag ) then return end

		if ent.IsLinkInProgress then return end

		if IsValid( ent:GetTargetBase() ) then
			ent:Decouple()
		else
			ent:StartDrag( ply )
			ent._HandBrakeForceDisabled = true
		end
	end )

	function ENT:StartDrag( ply )
		if IsValid( self.GrabEnt ) or IsValid( ply._HitchGrabEnt ) then return end

		if self:GetHitchType() ~= LVS.HITCHTYPE_FEMALE then return end

		local base = self:GetBase()

		if not IsValid( ply ) or not ply:Alive() or ply:InVehicle() or ply:GetObserverMode() ~= OBS_MODE_NONE or not ply:KeyDown( IN_WALK ) or (ply:GetShootPos() - self:GetPos()):Length() > GrabDistance or not IsValid( base ) then return end

		ply:SprintDisable()

		self.GrabEnt = ents.Create( "prop_physics" )

		ply._HitchGrabEnt = self.GrabEnt

		if not IsValid( self.GrabEnt ) then return end

		self.GrabEnt:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		self.GrabEnt:SetPos( self:GetPos() )
		self.GrabEnt:SetAngles( self:GetAngles() )
		self.GrabEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
		self.GrabEnt:Spawn()
		self.GrabEnt:Activate()
		self.GrabEnt:SetNoDraw( true ) 
		self.GrabEnt.DoNotDuplicate = true
		self:DeleteOnRemove( self.GrabEnt )

		self:SetDragTarget( ply )

		local PhysObj = self.GrabEnt:GetPhysicsObject()

		if not IsValid( PhysObj ) then return end

		PhysObj:SetMass( 50000 )
		PhysObj:EnableMotion( false )

		constraint.Ballsocket( base, self.GrabEnt, 0, 0, vector_origin, 0, 0, 1 )

		self.GrabEnt:SetSolid( SOLID_NONE )

		base:OnStartDrag( self, ply )
		base._HandBrakeForceDisabled = true

		base._DragOriginalCollisionGroup = base:GetCollisionGroup()
		base:SetCollisionGroup( COLLISION_GROUP_WORLD )

		if base.GetWheels then
			for _, wheel in pairs( base:GetWheels() ) do
				if not IsValid( wheel ) then continue end

				wheel._DragOriginalCollisionGroup = wheel:GetCollisionGroup()
				wheel:SetCollisionGroup( COLLISION_GROUP_WORLD )
			end
		end

		self:NextThink( CurTime() )
	end

	function ENT:StopDrag()
		if IsValid( self.GrabEnt ) then
			self.GrabEnt:Remove()
		end

		local ply = self:GetDragTarget()

		if IsValid( ply ) then
			ply:SprintEnable()
		end

		local base = self:GetBase()

		if IsValid( base ) then

			base:OnStopDrag( self, ply )
			base._HandBrakeForceDisabled = nil

			if IsValid( ply ) then base:SetPhysicsAttacker( ply ) end
	
			if base._DragOriginalCollisionGroup then
				base:SetCollisionGroup( base._DragOriginalCollisionGroup )
				base._DragOriginalCollisionGroup = nil
			end

			if base.GetWheels then
				for _, wheel in pairs( base:GetWheels() ) do
					if not IsValid( wheel ) then continue end

					if IsValid( ply ) then wheel:SetPhysicsAttacker( ply ) end

					if wheel._DragOriginalCollisionGroup then
						wheel:SetCollisionGroup( wheel._DragOriginalCollisionGroup )
						wheel._DragOriginalCollisionGroup = nil
					end
				end
			end
		end

		self:SetDragTarget( NULL )

		for _, ent in ipairs( ents.FindByClass( "lvs_wheeldrive_trailerhitch" ) ) do
			if ent:GetHitchType() ~= LVS.HITCHTYPE_MALE then continue end

			local dist = (self:GetPos() - ent:GetPos()):Length()

			if dist > HookupDistance then continue end

			self:CoupleTo( ent )

			break
		end
	end

	function ENT:Drag( ply )
		if not IsValid( self.GrabEnt ) or ply:InVehicle() or not ply:KeyDown( IN_WALK ) or not ply:Alive() or ply:GetObserverMode() ~= OBS_MODE_NONE then
			self:StopDrag()

			return
		end

		if not self.GrabEnt.TargetAngle then
			self.GrabEnt.TargetAngle = ply:EyeAngles().y
		end

		local TargetAngle = ply:EyeAngles()

		self.GrabEnt.TargetAngle = math.ApproachAngle( self.GrabEnt.TargetAngle, TargetAngle.y, FrameTime() * 500 )

		TargetAngle.p = math.max( TargetAngle.p, -15 )

		TargetAngle.y = self.GrabEnt.TargetAngle

		local TargetPos = ply:GetShootPos() + TargetAngle:Forward() * 80

		if (self:GetPos() - TargetPos):Length() > GrabDistance then self:StopDrag() return end

		self.GrabEnt:SetPos( TargetPos )

		local base = self:GetBase()

		if not IsValid( base ) then return end

		base:PhysWake()

		if base:WheelsOnGround() then return end

		local PhysObj = base:GetPhysicsObject()
	
		if not IsValid( PhysObj ) then return end
	
		PhysObj:SetAngleVelocity( PhysObj:GetAngleVelocity() * 0.8 )
		PhysObj:SetVelocity( PhysObj:GetVelocity() * 0.8 )
	end

	function ENT:Initialize()
		self:SetSolid( SOLID_NONE )
		self:SetMoveType( MOVETYPE_NONE )
		self:DrawShadow( false )
	end

	function ENT:Decouple()
		local TargetBase = self:GetTargetBase()

		self:SetTargetBase( NULL )

		if not IsValid( self.HitchConstraint ) then return end

		local base = self:GetBase()

		if IsValid( base ) then
			base:OnCoupleChanged( TargetBase, self.HitchTarget, false )
		end

		self.HitchConstraint:Remove()

		self.HitchTarget = nil
	end

	function ENT:CoupleTo( target )
		if not IsValid( target ) or IsValid( target.HitchConstraint ) or IsValid( self.HitchConstraint ) then return end

		local base = self:GetBase()

		if self.IsLinkInProgress or not IsValid( base ) or IsValid( self.PosEnt ) then return end

		self.IsLinkInProgress = true

		if self:GetHitchType() ~= LVS.HITCHTYPE_FEMALE or target:GetHitchType() ~= LVS.HITCHTYPE_MALE then self.IsLinkInProgress = nil return end

		self.PosEnt = ents.Create( "prop_physics" )

		if not IsValid( self.PosEnt ) then self.IsLinkInProgress = nil return end

		self.PosEnt:SetModel( "models/Combine_Helicopter/helicopter_bomb01.mdl" )
		self.PosEnt:SetPos( self:GetPos() )
		self.PosEnt:SetAngles( self:GetAngles() )
		self.PosEnt:SetCollisionGroup( COLLISION_GROUP_WORLD )
		self.PosEnt:Spawn()
		self.PosEnt:Activate()
		self.PosEnt:SetNoDraw( true ) 
		self.PosEnt.DoNotDuplicate = true
		self:DeleteOnRemove( self.PosEnt )

		local PhysObj = self.PosEnt:GetPhysicsObject()

		if not IsValid( PhysObj ) then self.IsLinkInProgress = nil return end

		PhysObj:SetMass( 50000 )
		PhysObj:EnableMotion( false )

		constraint.Ballsocket( base, self.PosEnt, 0, 0, vector_origin, 0, 0, 1 )

		local targetBase = target:GetBase()

		base:OnCoupleChanged( targetBase, target, true )

		self.PosEnt:SetSolid( SOLID_NONE )

		timer.Simple( 0, function()
			if not IsValid( self.PosEnt ) then
				self.IsLinkInProgress = nil

				return
			end
	
			if not IsValid( target ) or not IsValid( targetBase ) then
				self.PosEnt:Remove()
	
				self.IsLinkInProgress = nil
	
				return
			end
	
			self.PosEnt:SetPos( target:GetPos() )

			constraint.Weld( self.PosEnt, targetBase, 0, 0, 0, false, false )

			timer.Simple( 0.25, function()
				if not IsValid( base ) or not IsValid( targetBase ) or not IsValid( self.PosEnt ) then self.IsLinkInProgress = nil return end

				self.HitchTarget = target
				self.HitchConstraint = constraint.Ballsocket( base, targetBase, 0, 0, targetBase:WorldToLocal( self.PosEnt:GetPos() ), 0, 0, 1 )

				target.HitchConstraint = self.HitchConstraint

				self:SetTargetBase( targetBase )

				self.PosEnt:Remove()

				self.IsLinkInProgress = nil 
			end )
		end )
	end

	function ENT:Think()

		local ply = self:GetDragTarget()

		if IsValid( ply ) then
			self:Drag( ply )

			self:NextThink( CurTime() )
		else
			self:NextThink( CurTime() + 9999 )
		end

		return true
	end

	function ENT:OnRemove()
		self:StopDrag()
	end

	return
end

local HitchEnts = {}

function ENT:Initialize()
	table.insert( HitchEnts, self )
end

function ENT:OnRemove()
	for id, e in pairs( HitchEnts ) do
		if IsValid( e ) then continue end

		HitchEnts[ id ] = nil
	end
end

function ENT:Draw()
end

local function DrawDiamond( X, Y, radius )
	local segmentdist = 90
	local radius2 = radius + 1
	
	for a = 0, 360, segmentdist do
		surface.DrawLine( X + math.cos( math.rad( a ) ) * radius, Y - math.sin( math.rad( a ) ) * radius, X + math.cos( math.rad( a + segmentdist ) ) * radius, Y - math.sin( math.rad( a + segmentdist ) ) * radius )
		surface.DrawLine( X + math.cos( math.rad( a ) ) * radius2, Y - math.sin( math.rad( a ) ) * radius2, X + math.cos( math.rad( a + segmentdist ) ) * radius2, Y - math.sin( math.rad( a + segmentdist ) ) * radius2 )
	end
end

local function DrawText( x, y, text, col )
	local font = "TargetIDSmall"
	draw.SimpleText( text, font, x + 1, y + 1, Color( 0, 0, 0, 120 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	draw.SimpleText( text, font, x + 2, y + 2, Color( 0, 0, 0, 50 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	draw.SimpleText( text, font, x, y, col or color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end

local circle = Material( "vgui/circle" )
local radius = 6
local Col = Color(255,191,0,255)

local boxMins = Vector(-5,-5,-5)
local boxMaxs = Vector(5,5,5)

function ENT:DrawInfoCoupled( ply )
	local boxOrigin = self:GetPos()
	local scr = boxOrigin:ToScreen()

	if not scr.visible then return end

	local shootPos = ply:GetShootPos()

	local boxAngles = self:GetAngles()

	if (boxOrigin - shootPos):Length() > 250 then return end

	local HitPos, _, _ = util.IntersectRayWithOBB( shootPos, ply:GetAimVector() * GrabDistance, boxOrigin, boxAngles, boxMins, boxMaxs )

	local X = scr.x
	local Y = scr.y

	cam.Start2D()
		if HitPos then
			surface.SetDrawColor( 255, 255, 255, 255 )

			local Key = input.LookupBinding( "+walk" )

			if not isstring( Key ) then Key = "[+walk not bound]" end

			DrawText( X, Y + 20, "press "..Key.." to decouple!",Color(255,255,255,255) )

			local KeyUse = ply:KeyDown( IN_WALK )

			if self.OldKeyUse ~= KeyUse then
				self.OldKeyUse = KeyUse

				if KeyUse then
					net.Start( "lvs_trailerhitch" )
						net.WriteEntity( self )
					net.SendToServer()
				end
			end
		else
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		end

		DrawDiamond( X, Y, radius )
		surface.SetDrawColor( 0, 0, 0, 80 )
		DrawDiamond( X + 1, Y + 1, radius )
	cam.End2D()
end

function ENT:DrawInfo( ply )
	local boxOrigin = self:GetPos()
	local scr = boxOrigin:ToScreen()

	if not scr.visible then return end

	local shootPos = ply:GetShootPos()

	local boxAngles = self:GetAngles()

	if (boxOrigin - shootPos):Length() > 250 then return end

	local HitPos, _, _ = util.IntersectRayWithOBB( shootPos, ply:GetAimVector() * GrabDistance, boxOrigin, boxAngles, boxMins, boxMaxs )

	local X = scr.x
	local Y = scr.y

	local DragTarget = self:GetDragTarget()
	local IsBeingDragged = IsValid( DragTarget )
	local HasTarget = false

	if IsBeingDragged then
		cam.Start2D()

		for id, ent in pairs( HitchEnts ) do
			if ent == self then continue end

			if not IsValid( ent ) or ent:GetHitchType() ~= LVS.HITCHTYPE_MALE then continue end

			local tpos = ent:GetPos()

			local dist = (tpos - boxOrigin):Length()

			if dist > IgnoreDistance then continue end

			local tscr = tpos:ToScreen()

			if not tscr.visible then continue end

			local tX = tscr.x
			local tY = tscr.y

			if dist < HookupDistance and IsBeingDragged then
				HasTarget = true
			end

			surface.SetMaterial( circle )
			surface.SetDrawColor( 0, 0, 0, 80 )
			surface.DrawTexturedRect( tX - radius * 0.5 + 1, tY - radius * 0.5 + 1, radius, radius )

			if HasTarget then
				surface.SetDrawColor( 0, 255, 0, 255 )
			else
				surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
			end

			surface.DrawTexturedRect( tX - radius * 0.5, tY - radius * 0.5, radius, radius )

			if not HasTarget then continue end

			surface.DrawLine( X, Y, tX, tY )

			break
		end

		local radiusB = 25 + math.cos( CurTime() * 10 ) * 2

		if HasTarget then
			surface.SetDrawColor( 0, 255, 0, 255 )
		else
			surface.SetDrawColor( 255, 0, 0, 255 )
		end

		DrawDiamond( X, Y, radiusB )
		surface.SetDrawColor( 0, 0, 0, 80 )
		DrawDiamond( X + 1, Y + 1, radiusB )

		if HasTarget then
			DrawText( X, Y + 35, "release to couple",Color(0,255,0,255) )
		else
			DrawText( X, Y + 35, "in use by "..DragTarget:GetName(),Color(255,0,0,255) )
		end

		cam.End2D()

		return
	end

	cam.Start2D()
		if HitPos then
			surface.SetDrawColor( 255, 255, 255, 255 )

			local Key = input.LookupBinding( "+walk" )

			if not isstring( Key ) then Key = "[+walk not bound]" end

			DrawText( X, Y + 20, "hold "..Key.." to drag!",Color(255,255,255,255) )

			local KeyUse = ply:KeyDown( IN_WALK )

			if self.OldKeyUse ~= KeyUse then
				self.OldKeyUse = KeyUse

				if KeyUse then
					surface.PlaySound("common/wpn_select.wav")

					net.Start( "lvs_trailerhitch" )
						net.WriteEntity( self )
					net.SendToServer()
				end
			end
		else
			surface.SetDrawColor( Col.r, Col.g, Col.b, Col.a )
		end

		DrawDiamond( X, Y, radius )
		surface.SetDrawColor( 0, 0, 0, 80 )
		DrawDiamond( X + 1, Y + 1, radius )
	cam.End2D()
end

function ENT:DrawTranslucent()
	local ply = LocalPlayer()

	if not IsValid( ply ) or IsValid( ply:lvsGetVehicle() ) or self:GetHitchType() ~= LVS.HITCHTYPE_FEMALE then return end

	local wep = ply:GetActiveWeapon()

	if IsValid( wep ) and wep:GetClass() == "gmod_camera" then return end

	if IsValid( self:GetTargetBase() ) then
		self:DrawInfoCoupled( ply )

		return
	end

	self:DrawInfo( ply )
end

--PATH addons/lvs_cars_3027255911/lua/entities/lvs_wheeldrive_wheel/cl_effects.lua:

function ENT:StopWheelEffects()
	if not self._DoingWheelFx then return end

	self._DoingWheelFx = nil

	self:FinishSkidmark()
end

function ENT:StartWheelEffects( Base, trace, traceWater )
	self:DoWheelEffects( Base, trace, traceWater )

	if self._DoingWheelFx then return end

	self._DoingWheelFx = true
end

function ENT:DoWheelEffects( Base, trace, traceWater )
	if not trace.Hit then self:FinishSkidmark() return end

	local SurfacePropName = util.GetSurfacePropName( trace.SurfaceProps )
	local SkidValue = self:GetSkid()

	if traceWater.Hit then
		local Scale = math.min( 0.3 + (SkidValue - 100) / 4000, 1 ) ^ 2

		local effectdata = EffectData()
		effectdata:SetOrigin( trace.HitPos )
		effectdata:SetEntity( Base )
		effectdata:SetNormal( trace.HitNormal )
		effectdata:SetMagnitude( Scale )
		effectdata:SetFlags( 1 )
		util.Effect( "lvs_physics_wheeldust", effectdata, true, true )

		self:FinishSkidmark()

		return
	end

	if self.SkidmarkSurfaces[ SurfacePropName ] then
		local Scale = math.min( 0.3 + SkidValue / 4000, 1 ) ^ 2

		if Scale > 0.2 then
			self:StartSkidmark( trace.HitPos )
			self:CalcSkidmark( trace, Base:GetCrosshairFilterEnts() )
		else
			self:FinishSkidmark()
		end

		local effectdata = EffectData()
		effectdata:SetOrigin( trace.HitPos )
		effectdata:SetEntity( Base )
		effectdata:SetNormal( trace.HitNormal )
		util.Effect( "lvs_physics_wheelsmoke", effectdata, true, true )
	else
		self:FinishSkidmark()
	end

	if not LVS.ShowEffects then return end

	if self.DustEffectSurfaces[ SurfacePropName ] then
		local Scale = math.min( 0.3 + (SkidValue - 100) / 4000, 1 ) ^ 2

		local effectdata = EffectData()
		effectdata:SetOrigin( trace.HitPos )
		effectdata:SetEntity( Base )
		effectdata:SetNormal( trace.HitNormal )
		effectdata:SetMagnitude( Scale )
		effectdata:SetFlags( 0 )
		util.Effect( "lvs_physics_wheeldust", effectdata, true, true )
	end
end

function ENT:DoWaterEffects( Base, traceWater, Pos )
	local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.Fraction > 0.5 and traceWater.HitPos or Pos )
		effectdata:SetEntity( Base )
		effectdata:SetMagnitude( self:GetRadius() )
		effectdata:SetFlags( 0 )
	util.Effect( "lvs_physics_wheelwatersplash", effectdata )
end

function ENT:DoWheelChainEffects( Base, trace )
	if not LVS.ShowEffects then return end

	if not self.DustEffectSurfaces[ util.GetSurfacePropName( trace.SurfaceProps ) ] then return end

	local effectdata = EffectData()
	effectdata:SetOrigin( trace.HitPos )
	effectdata:SetEntity( Base )
	effectdata:SetMagnitude( self:GetRadius() )
	effectdata:SetNormal( trace.HitNormal )
	util.Effect( "lvs_physics_trackdust", effectdata, true, true )
end

function ENT:CalcWheelEffects()
	local T = CurTime()

	if (self._NextFx or 0) > T then return end

	local Base = self:GetBase()

	if not IsValid( Base ) then return end

	self._NextFx = T + (Base:GetAI() and 0.1 or 0.05)

	local Radius = Base:GetWheelUp() * (self:GetRadius() + 1)

	local Vel = self:GetVelocity()
	local Pos =  self:GetPos() + Vel * 0.025

	local StartPos = Pos + Radius
	local EndPos = Pos - Radius

	local trace = util.TraceLine( {
		start = StartPos,
		endpos = EndPos,
		filter = Base:GetCrosshairFilterEnts(),
	} )

	local traceWater = util.TraceLine( {
		start = StartPos,
		endpos = EndPos,
		filter = Base:GetCrosshairFilterEnts(),
		mask = MASK_WATER,
	} )

	self:CalcWheelSounds( Base, trace, traceWater )

	if traceWater.Hit and trace.HitPos.z < traceWater.HitPos.z then 
		if math.abs( self:GetRPM() ) > 25 then
			self:DoWaterEffects( Base, traceWater, Pos )
		end
	else
		if self:GetWheelChainMode() and trace.Hit and math.abs( self:GetRPM() ) > 25 and Vel:LengthSqr() > 1500 then
			self:DoWheelChainEffects( Base, trace )
		end
	end

	if self:GetSlip() < 500 then self:StopWheelEffects() return end

	self:StartWheelEffects( Base, trace, traceWater )
end

function ENT:CalcWheelSounds( Base, trace, traceWater )
	if not trace.Hit then return end

	-- rejoin requires this
	if trace.Entity == self then
		if istable( Base.CrosshairFilterEnts ) and #Base.CrosshairFilterEnts > 1 then
			Base.CrosshairFilterEnts = nil
		end

		return
	end

	local RPM = math.abs( self:GetRPM() )

	if self:GetDamaged() and RPM > 30 then
		if self:GetWheelChainMode() then
			local effectdata = EffectData()
			effectdata:SetOrigin( self:GetPos() )
			effectdata:SetNormal( self:GetForward() )
			util.Effect( "lvs_physics_trackscraping", effectdata, true, true )

			Base:DoTireSound( "tracks_damage_layer" )
		else
			local Ang = self:GetForward():Angle() + Angle(10,0,0)
			Ang:RotateAroundAxis( Base:GetUp(), -90 )

			local effectdata = EffectData()
			effectdata:SetOrigin( trace.HitPos + trace.HitNormal )
			effectdata:SetNormal( Ang:Forward() * math.min( self:GetSlip() / 10000, 3 ) * (self:GetRPM() > 0 and 1 or -1) )
			effectdata:SetMagnitude( 1 )
			util.Effect( "manhacksparks", effectdata, true, true )

			Base:DoTireSound( "tire_damage_layer" )

			return
		end
	end

	if RPM > 50 then
		if traceWater.Hit then
			Base:DoTireSound( "roll_wet" )

			return
		end

		local surface = self.DustEffectSurfaces[ util.GetSurfacePropName( trace.SurfaceProps ) ] and "_dirt" or ""
		local snd_type = (self:GetSlip() > 500) and "skid" or "roll"

		if (istable( StormFox ) or istable( StormFox2 )) and surface ~= "_dirt" then
			local Rain = false

			if StormFox then
				Rain = StormFox.IsRaining()
			end

			if StormFox2 then
				Rain = StormFox2.Weather:IsRaining()
			end

			if Rain then
				local effectdata = EffectData()
					effectdata:SetOrigin( trace.HitPos )
					effectdata:SetEntity( Base )
					effectdata:SetMagnitude( self:BoundingRadius() )
					effectdata:SetFlags( 1 )
				util.Effect( "lvs_physics_wheelwatersplash", effectdata )

				Base:DoTireSound( snd_type.."_wet" )

				return
			end
		end

		if snd_type == "roll" and not self:GetWheelChainMode() and self:GetHP() ~= self:GetMaxHP() then
			surface = "_damaged"
		end

		Base:DoTireSound( snd_type..surface )
	end
end
--PATH addons/shaccessorysystem/lua/entities/npc_accessory_vendor/cl_init.lua:
include("shared.lua")

surface.CreateFont("SH_ACC_VENDOR", {font = "Circular Std Bold", size = 200})

ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
function ENT:Draw()
	self:DrawModel()
	onyx.npc.label( self, SH_ACC.Language.accessory_vendor )
end


--PATH addons/shaccessorysystem/lua/entities/npc_accessory_vendor/shared.lua:
ENT.Base = "base_ai"
ENT.Type = "ai"
ENT.PrintName = "Accessory Vendor"
ENT.Category = "Other"
ENT.Spawnable = true

--PATH addons/_pcasino/lua/entities/pcasino_chair/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Plaque"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.noDrag = true


PerfectCasino.Core.RegisterEntity("pcasino_chair", {
},
"models/freeman/owain_casino_stool.mdl")
--PATH addons/_pcasino/lua/entities/pcasino_npc/shared.lua:
ENT.Type = "ai"
ENT.Base = "base_ai"
ENT.PrintName = "NPC"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.noDrag = true

PerfectCasino.Core.RegisterEntity("pcasino_npc", {
	text = {
		overhead = {d = "Dealer", t = "string"},
		chat = {d = "Interested in playing a round?", t = "string"},
	},
},
"models/freeman/pcasino/owain_croupier_female01.mdl")
--PATH addons/_pcasino/lua/entities/pcasino_sign_interior_standing/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Interior Standing"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.noDrag = true

PerfectCasino.Core.RegisterEntity("pcasino_sign_interior_standing", {
	-- General data
	general = {
		text = {d = "Welcome to the Cool Casino. We hope you enjoy your stay!", t = "string"} -- The text to show
	}
},
"models/freeman/owain_interiorsign_standing.mdl")
--PATH addons/_pcasino/lua/entities/pcasino_sign_interior_wall/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Sign Interior Wall"
ENT.Author = "Owain Owjo & The One Free-Man"
ENT.Category = "pCasino"
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.noDrag = true

PerfectCasino.Core.RegisterEntity("pcasino_sign_interior_wall", {
	-- General data
	general = {
		text = {d = "Roulette Tables", t = "string"} -- The text to show
	}
},
"models/freeman/owain_interiorsign_wall.mdl")
--PATH addons/_pcasino/lua/entities/pcasino_sign_stand/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.letters = {}
end

function ENT:PostData()
	if not self.hasInitialized then
		self:Initialize()
	end
	
	self.data.general.text = string.sub(self.data.general.text, 1, 7)
	local letterMap = PerfectCasino.Core.Letter

	-- Right side
		-- Letter calculations
		local startPoint = (self:GetRight() * 25) + (self:GetForward() * 13.5) + (self:GetUp() * 9)
		local curLength = vector_origin
		local right = self:GetRight()
	
		for k, v in ipairs(string.Split(string.lower(self.data.general.text), "")) do
			if not letterMap[v] then -- It's either a space or a character we don't support
				curLength = curLength + (self:GetRight() * 5)
				continue
			end
	
			-- Create the letter
			local letter = ClientsideModel("models/freeman/owain_casino_alphabet.mdl")
			if IsValid(letter) then
				table.insert(self.letters, letter)
				letter:SetParent(self)
				curLength = curLength + ((self:GetRight()) * (letterMap[v].w*2))
				letter:SetPos(self:GetPos() + startPoint - curLength + ((self:GetRight()) * (letterMap[v].w)))
				letter:SetAngles(self:GetAngles())
				letter:SetBodygroup(1, letterMap[v].b)
			end
		end
	-- Left side
		-- Letter calculations
		local startPoint = (self:GetRight() * 25) + (self:GetForward() * -13.5) + (self:GetUp() * 9)
		local curLength = vector_origin
		local right = self:GetRight()
	
		for k, v in ipairs(table.Reverse(string.Split(string.lower(self.data.general.text), ""))) do
			if not letterMap[v] then -- It's either a space or a character we don't support
				curLength = curLength + (self:GetRight() * 5)
				continue
			end
	
			-- Create the letter
			local letter = ClientsideModel("models/freeman/owain_casino_alphabet.mdl")
			table.insert(self.letters, letter)
			letter:SetParent(self)
			curLength = curLength + ((self:GetRight()) * (letterMap[v].w*2))
			letter:SetPos(self:GetPos() + startPoint - curLength + ((self:GetRight()) * (letterMap[v].w)))
			local ang = self:GetAngles()
			ang:RotateAroundAxis(ang:Up(), 180)
			letter:SetAngles(ang)
			letter:SetBodygroup(1, letterMap[v].b)
		end
end

function ENT:OnRemove()
	-- Clear the board of last rounds best
	for k, v in pairs(self.letters) do
		if not IsValid(v) then continue end

		v:Remove()
	end
end

function ENT:Draw()
	self:DrawModel()
	if self:GetPos():DistToSqr(LocalPlayer():GetPos()) > 1000000 then return end

	-- We can piggyback off the distance check to only request the entities data when it's needed :D
	if (not self.data) and (not PerfectCasino.Cooldown.Check(self:EntIndex(), 5)) then
		PerfectCasino.Core.RequestConfigData(self)
		return
	end
end
--PATH addons/__________skeypads/lua/skeypads/lib/cl_imgui.lua:
local imgui = {}
function imgui.Hook( name, id, callback )
	local hookUniqifier = debug.getinfo( 4 ).short_src
	hook.Add( name, 'IMGUI / ' .. id .. ' / ' .. hookUniqifier, callback )
end

local gState = {}
local function shouldAcceptInput()
	-- don't process input during non-main renderpass
	if render.GetRenderTarget() ~= nil then return false end
	-- don't process input if we're doing VGUI stuff (and not in context menu)
	if vgui.CursorVisible() and vgui.GetHoveredPanel() ~= g_ContextMenu then return false end
	return true
end

imgui.Hook( 'PreRender', 'Input', function()
	-- calculate mouse state
	if shouldAcceptInput() then
		local wasPressing = gState.pressing
		gState.pressing = input.IsKeyDown( KEY_E )
		gState.pressed = not wasPressing and gState.pressing
	end
end )

hook.Add( 'NotifyShouldTransmit', 'IMGUI / ClearRenderBounds', function( ent, shouldTransmit ) if shouldTransmit and ent._imguiRBExpansion then ent._imguiRBExpansion = nil end end )
local traceResultTable = {}
local traceQueryTable = {
	output = traceResultTable,
	filter = {}
}

local function isObstructed( eyePos, hitPos, ignoredEntity )
	local q = traceQueryTable
	q.start = eyePos
	q.endpos = hitPos
	q.filter[1] = LocalPlayer()
	q.filter[2] = ignoredEntity
	local tr = util.TraceLine( q )
	if tr.Hit then
		return true, tr.Entity
	else
		return false
	end
end

function imgui.Start3D2D( pos, angles, scale, distanceHide, distanceFadeStart )
	if gState.shutdown == true then return end
	if gState.rendering == true then
		print( '[IMGUI] Starting a new IMGUI context when previous one is still rendering' .. 'Shutting down rendering pipeline to prevent crashes..' )
		gState.shutdown = true
		return false
	end

	local eyePos = LocalPlayer():EyePos()
	local eyePosToPos = pos - eyePos
	-- OPTIMIZATION: Test that we are in front of the UI
	do
		local normal = angles:Up()
		local dot = eyePosToPos:Dot( normal )
		-- since normal is pointing away from surface towards viewer, dot<0 is visible
		if dot >= 0 then return false end
	end

	-- OPTIMIZATION: Distance based fade/hide
	if distanceHide then
		local distance = eyePosToPos:Length()
		if distance > distanceHide then return false end
		if distanceHide and distanceFadeStart and distance > distanceFadeStart then
			local blend = math.min( math.Remap( distance, distanceFadeStart, distanceHide, 1, 0 ), 1 )
			render.SetBlend( blend )
			surface.SetAlphaMultiplier( blend )
		end
	end

	gState.rendering = true
	gState.pos = pos
	gState.angles = angles
	gState.scale = scale
	cam.Start3D2D( pos, angles, scale )
	-- calculate mousepos
	if not vgui.CursorVisible() or vgui.IsHoveringWorld() then
		local tr = sKeypads.SuperSecure.GetRealEyeTrace()
		if not tr then
			gState.rendering = false
			cam.End3D2D()
			return
		end

		local eyepos = tr.StartPos
		local eyenormal
		if vgui.CursorVisible() and vgui.IsHoveringWorld() then
			eyenormal = gui.ScreenToVector( gui.MousePos() )
		else
			eyenormal = tr.Normal
		end

		local planeNormal = angles:Up()
		local hitPos = util.IntersectRayWithPlane( eyepos, eyenormal, pos, planeNormal )
		if hitPos then
			local obstructed, obstructer = isObstructed( eyepos, hitPos, gState.entity )
			if obstructed and obstructer ~= gState.entity then
				gState.mx = nil
				gState.my = nil
			else
				local diff = pos - hitPos
				-- This cool code is from Willox's keypad CalculateCursorPos
				local x = diff:Dot( -angles:Forward() ) / scale
				local y = diff:Dot( -angles:Right() ) / scale
				gState.mx = x
				gState.my = y
			end
		else
			gState.mx = nil
			gState.my = nil
		end
	else
		gState.mx = nil
		gState.my = nil
	end
	return true
end

function imgui.Entity3D2D( ent, lpos, lang, scale, ... )
	gState.entity = ent
	local ret = imgui.Start3D2D( ent:LocalToWorld( lpos ), ent:LocalToWorldAngles( lang ), scale, ... )
	gState.entity = nil
	return ret
end

local function calculateRenderBounds( x, y, w, h )
	local pos = gState.pos
	local fwd, right = gState.angles:Forward(), gState.angles:Right()
	local scale = gState.scale
	local firstCorner, secondCorner = pos + fwd * x * scale + right * y * scale, pos + fwd * ( x + w ) * scale + right * ( y + h ) * scale
	local minrb, maxrb = Vector( math.huge, math.huge, math.huge ), Vector( -math.huge, -math.huge, -math.huge )
	minrb.x = math.min( minrb.x, firstCorner.x, secondCorner.x )
	minrb.y = math.min( minrb.y, firstCorner.y, secondCorner.y )
	minrb.z = math.min( minrb.z, firstCorner.z, secondCorner.z )
	maxrb.x = math.max( maxrb.x, firstCorner.x, secondCorner.x )
	maxrb.y = math.max( maxrb.y, firstCorner.y, secondCorner.y )
	maxrb.z = math.max( maxrb.z, firstCorner.z, secondCorner.z )
	return minrb, maxrb
end

function imgui.ExpandRenderBoundsFromRect( x, y, w, h )
	local ent = gState.entity
	if IsValid( ent ) then
		-- make sure we're not applying same expansion twice
		local expansion = ent._imguiRBExpansion
		if expansion then
			local ex, ey, ew, eh = unpack( expansion )
			if ex == x and ey == y and ew == w and eh == h then return end
		end

		local minrb, maxrb = calculateRenderBounds( x, y, w, h )
		ent:SetRenderBoundsWS( minrb, maxrb )
		ent._imguiRBExpansion = { x, y, w, h }
	end
end

function imgui.End3D2D()
	if gState then
		gState.rendering = false
		cam.End3D2D()
		render.SetBlend( 1 )
		surface.SetAlphaMultiplier( 1 )
	end
end

function imgui.CursorPos()
	local mx, my = gState.mx, gState.my
	return mx, my
end

function imgui.IsHovering( x, y, w, h )
	local mx, my = gState.mx, gState.my
	return mx and my and mx >= x and mx <= x + w and my >= y and my <= y + h
end

function imgui.IsPressing()
	return shouldAcceptInput() and gState.pressing
end

function imgui.IsPressed()
	return shouldAcceptInput() and gState.pressed
end
return imgui
--PATH gamemodes/darkrp/entities/entities/spawned_food/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_entity"
ENT.PrintName = "[Еда] Кавун"
ENT.Author = "Jerivssss"
ENT.Spawnable = true
ENT.AdminSpawnable = true 
ENT.Category = "RP FOOD"

--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_light/cl_init.lua:
include("shared.lua")

function ENT:Think()
	if self:GetOn() then
		local dlight = DynamicLight(self:EntIndex())
		if (dlight) then
			dlight.pos = self:GetPos() + (self:GetUp()*17) + (self:GetRight()*12) + (self:GetForward()*-3)
			dlight.r = 255
			dlight.g = 255
			dlight.b = 255
			dlight.brightness = 4
			dlight.Decay = 1000
			dlight.Size = 256
			dlight.DieTime = CurTime() + 1
		end
	end
end

local grn = Color(0, 0, 0, 255)
local xpos = 150
local ypos = -100
function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
	local ang = LocalPlayer():EyeAngles()
	local pos = self:GetPos() + Vector(0,0,10)

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)

	cam.Start3D2D(pos, ang, 0.06)
		if UWeed.Light.Batery then
			-- Background
			draw.RoundedBox(0, xpos, ypos+0, 335, 165, Color(0, 0, 0, 225))
			-- Side bar
			draw.RoundedBox(0, xpos, ypos+0, 10, 160, grn)
		else
			-- Background
			draw.RoundedBox(0, xpos, ypos+0, 265, 120, Color(0, 0, 0, 225))
			-- Side bar
			draw.RoundedBox(0, xpos, ypos+0, 10, 120, grn)
		end
	
		draw.SimpleText(string.upper(UWeed.Translation.BIGLAMP.LittleTitle), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

		local state = UWeed.Translation.BIGLAMP.Off
		if self:GetOn() then
			state = UWeed.Translation.BIGLAMP.On
		end
		draw.SimpleText(UWeed.Translation.BIGLAMP.State.." "..state, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		if UWeed.Light.Batery then
			draw.SimpleText(UWeed.Translation.BIGLAMP.Battery.." "..self:GetBattery().."%", "uweed_font_60", xpos+10, ypos+135, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		end

	cam.End3D2D()
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_plant/cl_init.lua:
include("shared.lua")

local grn = Color(0, 0, 0, 255)
local xpos = 200
local ypos = -200
function ENT:Draw()
	self:DrawModel()
end

function ENT:DrawTranslucent()
	if self:GetPos():Distance(LocalPlayer():GetPos()) > 500 then return end
	local ang = LocalPlayer():EyeAngles()
	local pos = self:GetPos() + Vector(0,0,10)

	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 90)


	local stage = self:GetStage()
	cam.Start3D2D(pos, ang, 0.06)
		-- Background
		draw.RoundedBox(0, xpos, ypos, 480, 180, Color(0, 0, 0, 225))
		-- Side bar
		draw.RoundedBox(0, xpos, ypos, 10, 180, grn)

		draw.SimpleText(string.upper(UWeed.Translation.Pot.Title), "uweed_font_80", xpos+10, ypos+35, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		if stage == 0 then
			draw.SimpleText(UWeed.Translation.Pot.PlantSeed, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.SimpleText(UWeed.Translation.Pot.SeedNeeded, "uweed_font_60", xpos+10, ypos+145, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		elseif stage == 1 then
			local dots = "."
			for i=1, CurTime()%3 do
				dots = dots.."."
			end
			local lightTxt = UWeed.Translation.Pot.LightLvlGood
			if self:GetLightLevel() < 10 then
				lightTxt = UWeed.Translation.Pot.LightLvlRealBad
			elseif self:GetLightLevel() < 25 then
				lightTxt = UWeed.Translation.Pot.LightLvlBad
			elseif self:GetLightLevel() > 90 then
				lightTxt = UWeed.Translation.Pot.LightLvlRealBad2
			elseif self:GetLightLevel() > 75 then
				lightTxt = UWeed.Translation.Pot.LightLvlBad2
			end
			draw.SimpleText(UWeed.Translation.Pot.PlantGorwing..dots, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.SimpleText(lightTxt, "uweed_font_60", xpos+10, ypos+145, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		elseif stage == 2 then
			draw.SimpleText(UWeed.Translation.Pot.HarvestReady, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			draw.SimpleText(UWeed.Translation.Pot.BudCount.." "..self:GetBudCount(), "uweed_font_60", xpos+10, ypos+145, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
		elseif stage == 3 then
			draw.SimpleText(UWeed.Translation.Pot.HavestRuined, "uweed_font_60", xpos+10, ypos+90, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			if self:GetLightLevel() > 50 then
				draw.SimpleText(UWeed.Translation.Pot.UseReset2, "uweed_font_60", xpos+10, ypos+145, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			else
				draw.SimpleText(UWeed.Translation.Pot.UseReset, "uweed_font_60", xpos+10, ypos+145, Color(255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			end
		end
	cam.End3D2D()
end
--PATH addons/uweedadvancedcannabisgrowth/lua/entities/uweed_skin/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "[UWeed] Rolling Skin"
ENT.Author = "Owain Owjo"
ENT.Category = "UWeed"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
	self:NetworkVar("Int", 0, "Progress")
	self:NetworkVar("Int", 0, "Stage")
	self:NetworkVar("Entity", 0, "owning_ent")
	self:NetworkVar("Bool", 0, "FirstSpawn")
end
--PATH addons/_farmer/lua/effects/ba_cage_spawn.lua:
--[[
	Just a first attempt in effect.
	Green text just makes me feel better.
]]--

function EFFECT:Init(data)
	
	local offset = data:GetOrigin();
	
	--sound.Play("garrysmod/balloon_pop_cute.wav", offset, 90, math.random(90, 120));
	
	local particlesAmount = math.random(32, 64);
	local emitter = ParticleEmitter(offset, false);
		for i=0, particlesAmount do
			local particle = emitter:Add("particle/smokesprites_000"..math.random(1, 9), offset);
			
			if (particle) then
				
				particle:SetVelocity(Vector(math.random(-128, 128), math.random(-128, 128), math.random(-16, 128)));
				
				particle:SetLifeTime(0);
				particle:SetDieTime(1);
				
				particle:SetStartAlpha(255);
				particle:SetEndAlpha(64);
				
				particle:SetStartSize(math.random(8, 16));
				particle:SetEndSize(math.random(4, 8));
				
				particle:SetRoll(math.random(180, 480));
				particle:SetRollDelta(math.random(-2, 2));
				
				particle:SetAirResistance(256);
				particle:SetGravity(Vector(0, 0, 64));
				
				particle:SetColor(145, 145, 145);
				
				particle:SetCollide(true);
				particle:SetBounce(1);
				
				particle:SetAngleVelocity(Angle(math.random(-2, 2), math.random(-2, 2), math.random(-2, 2)));
				
				particle:SetLighting(true);
			end;
		end;
	emitter:Finish();
end;


function EFFECT:Think()
	return false;
end;


function EFFECT:Render()

end;

--PATH addons/_drones/lua/effects/dronesrewrite_muzzleflashsmall.lua:
AddCSLuaFile()

function EFFECT:Init(data)
	self.Start = data:GetOrigin()
	self.Forward = data:GetNormal()

	self.Emitter = ParticleEmitter(self.Start)

	local dlight = DynamicLight(self:EntIndex())
	if dlight then
		dlight.pos = self.Start
		dlight.r = 255
		dlight.g = 50
		dlight.b = 0
		dlight.brightness = 1
		dlight.Decay = 1
		dlight.Size = math.random(150, 300)
		dlight.DieTime = CurTime()
	end

	local p = self.Emitter:Add("sprites/heatwave", self.Start - self.Forward * 4)
	p:SetVelocity(80 * self.Forward + 20 * VectorRand() * 2)
	p:SetGravity(Vector(0, 0, 100))
	p:SetAirResistance(160)
	p:SetStartAlpha(1)
	p:SetEndAlpha(0)
	p:SetDieTime(math.Rand(0.05, 0.1))
	p:SetStartSize(math.random(5, 12))
	p:SetEndSize(5)
	p:SetRoll(math.Rand(180, 480))
	p:SetRollDelta(math.Rand(-1, 1))

	local p = self.Emitter:Add("particle/smokesprites_000" .. math.random(1, 9), self.Start)

	p:SetAirResistance(100)
	p:SetVelocity(self.Forward * 120 + VectorRand() * 4)
	p:SetGravity(Vector(0, 0, 10))
	p:SetDieTime(math.Rand(0.3, 0.6))
	p:SetStartAlpha(40)
	p:SetEndAlpha(0)
	p:SetStartSize(0)
	p:SetEndSize(15)
	p:SetRollDelta(math.Rand(-2, 2))
	p:SetColor(120, 120, 120)

	for i = 1, 5 do
		local p = self.Emitter:Add("effects/muzzleflash"..math.random(1, 4), self.Start + i * 6 * self.Forward)

		p:SetVelocity(10 * VectorRand())

		p:SetDieTime(math.Rand(0.04, 0.1))

		p:SetStartAlpha(50)

		p:SetStartSize(20 - i * 2)
		p:SetEndSize(0)

		p:SetRoll(math.Rand(180, 480))
		p:SetRollDelta(math.Rand(-1, 1))

		p:SetColor(255, 255, 255)	
	end
	
	self.Emitter:Finish()
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end






--PATH addons/lvs_base-main/lua/effects/lvs_explosion_bomb.lua:

EFFECT.GlowMat = Material( "sprites/light_glow02_add" )
EFFECT.SmokeMat = {
	"particle/smokesprites_0001",
	"particle/smokesprites_0002",
	"particle/smokesprites_0003",
	"particle/smokesprites_0004",
	"particle/smokesprites_0005",
	"particle/smokesprites_0006",
	"particle/smokesprites_0007",
	"particle/smokesprites_0008",
	"particle/smokesprites_0009",
	"particle/smokesprites_0010",
	"particle/smokesprites_0011",
	"particle/smokesprites_0012",
	"particle/smokesprites_0013",
	"particle/smokesprites_0014",
	"particle/smokesprites_0015",
	"particle/smokesprites_0016"
}

EFFECT.DustMat = {
	"effects/lvs_base/particle_debris_01",
	"effects/lvs_base/particle_debris_02",
}

EFFECT.DecalMat = Material( util.DecalMaterial( "Scorch" ) )

function EFFECT:Init( data )
	self.Dir = Vector(0,0,1)
	self.Pos = data:GetOrigin()
	self.LifeTime = 0.35
	self.DieTime = CurTime() + self.LifeTime

	local scale = 3

	local emitter = ParticleEmitter( self.Pos, false )

	local VecCol = (render.GetLightColor( self.Pos + self.Dir ) * 0.5 + Vector(0.1,0.09,0.075)) * 255

	local DieTime = math.Rand(0.8,1.6)

	local traceSky = util.TraceLine( {
		start = self.Pos,
		endpos = self.Pos + Vector(0,0,50000),
		filter = self,
	} )

	local traceWater = util.TraceLine( {
		start = traceSky.HitPos,
		endpos = self.Pos - Vector(0,0,100),
		filter = self,
		mask = MASK_WATER,
	} )

	if traceWater.Hit then
		local effectdata = EffectData()
		effectdata:SetOrigin( traceWater.HitPos )
		effectdata:SetScale( 100 )
		effectdata:SetFlags( 2 )
		util.Effect( "WaterSplash", effectdata, true, true )
	else
		local trace = util.TraceLine( {
			start = self.Pos + Vector(0,0,100),
			endpos = self.Pos - Vector(0,0,100),
		} )

		if trace.Hit and not trace.HitNonWorld then
			for i = 1, 3 do
				local StartPos = trace.HitPos + Vector(math.random(-200,200),math.random(-200,200),0)
				local decalTrace = util.TraceLine( {
					start = StartPos + Vector(0,0,100),
					endpos = StartPos - Vector(0,0,100),
				} )

				util.DecalEx( self.DecalMat, trace.Entity, decalTrace.HitPos + decalTrace.HitNormal, decalTrace.HitNormal, Color(255,255,255,255), math.Rand(3,6), math.Rand(3,6) )
			end
		end
	end

	local Pos = self.Pos
	local Dist = (traceWater.HitPos - Pos):Length()
	local ply = LocalPlayer():GetViewEntity()

	if not IsValid( ply ) then return end

	local delay = (Pos - ply:GetPos()):Length() / 13503.9

	if traceWater.Hit and Dist > 150 then
		timer.Simple( delay, function()
			local effectdata = EffectData()
			effectdata:SetOrigin( Pos )
			util.Effect( "WaterSurfaceExplosion", effectdata, true, true )
		end )

		if Dist > 300 then return end
	else
		timer.Simple( delay, function()
			sound.Play( "LVS.BOMB_EXPLOSION", Pos )
			sound.Play( "LVS.BOMB_EXPLOSION_DYNAMIC", Pos )
		end )
	end

	for i = 1, 10 do
		for n = 0,6 do
			local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ], self.Pos )

			if not particle then continue end

			particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 25) * scale )
			particle:SetDieTime( (i / 8) * DieTime )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 10 * scale )
			particle:SetEndSize( 20 * i * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector(0,0,-600) * scale )
			particle:SetCollide( false )
		end
	end

	for i = 1, 10 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ], self.Pos )

		if not particle then continue end

		particle:SetVelocity( (self.Dir * 50 * i + VectorRand() * 40) * scale )
		particle:SetDieTime( (i / 8) * DieTime )
		particle:SetAirResistance( 10 ) 
		particle:SetStartAlpha( 255 )
		particle:SetStartSize( 10 * scale )
		particle:SetEndSize( 20 * i * scale )
		particle:SetRollDelta( math.Rand(-1,1) )
		particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
		particle:SetGravity( Vector(0,0,-600) * scale )
		particle:SetCollide( false )
	end

	for i = 1,24 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1,#self.SmokeMat) ] , self.Pos )
		
		if particle then
			local ang = i * 15
			local X = math.cos( math.rad(ang) )
			local Y = math.sin( math.rad(ang) )

			local Vel = Vector(X,Y,0) * math.Rand(1500,2000)

			particle:SetVelocity( Vel * scale )
			particle:SetDieTime( math.Rand(1,3) )
			particle:SetAirResistance( 600 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 40 * scale )
			particle:SetEndSize( 200 * scale )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector(0,0,60) * scale )
			particle:SetCollide( true )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( self.SmokeMat[ math.random(1, #self.SmokeMat ) ], self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 1000 )
			particle:SetDieTime( math.Rand(2,3) )
			particle:SetAirResistance( 200 ) 
			particle:SetStartAlpha( 100 )
			particle:SetStartSize( 200 )
			particle:SetEndSize( 600 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetRollDelta( math.Rand(-1,1) )
			particle:SetColor( VecCol.r, VecCol.g, VecCol.b )
			particle:SetGravity( Vector( 0, 0, -600 ) )
			particle:SetCollide( false )
		end
	end

	for i = 0, 15 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), self.Pos )
		
		if particle then
			particle:SetVelocity( VectorRand(-1,1) * 500 )
			particle:SetDieTime( math.Rand(0.15,0.3) )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 25 )
			particle:SetEndSize( math.Rand(70,100) )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	for i = 0, 20 do
		local particle = emitter:Add( "sprites/rico1", self.Pos )
		
		local vel = VectorRand() * 800
		
		if particle then
			particle:SetVelocity( vel )
			particle:SetAngles( vel:Angle() + Angle(0,90,0) )
			particle:SetDieTime( math.Rand(0.2,0.4) )
			particle:SetStartAlpha( 255 )
			particle:SetEndAlpha( 0 )
			particle:SetStartSize( math.Rand(20,40) )
			particle:SetEndSize( 0 )
			particle:SetRoll( math.Rand(-100,100) )
			particle:SetRollDelta( 0 )
			particle:SetColor( 255, 255, 255 )

			particle:SetAirResistance( 0 )
		end
	end
	
	for i = 0,60 do
		local particle = emitter:Add( "effects/fleck_tile"..math.random(1,2), self.Pos )
		local vel = VectorRand() * math.Rand(800,1600)
		vel.z = math.Rand(1000,4000)

		if particle then
			particle:SetVelocity( vel )
			particle:SetDieTime( math.random(5,15) )
			particle:SetAirResistance( 10 ) 
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 5 )
			particle:SetEndSize( 5 )
			particle:SetRoll( math.Rand(-1,1) )
			particle:SetColor( 0,0,0 )
			particle:SetGravity( Vector( 0, 0, -2000 ) )
			particle:SetCollide( true )
			particle:SetBounce( 0.3 )
		end
	end

	emitter:Finish()
end

function EFFECT:Explosion( pos , scale )
	local emitter = ParticleEmitter( pos, false )
	
	if not IsValid( emitter ) then return end

	for i = 0, 40 do
		local particle = emitter:Add( "effects/lvs_base/flamelet"..math.random(1,5), pos )

		if particle then
			particle:SetVelocity( VectorRand() * 1500 * scale )
			particle:SetDieTime( 0.2 )
			particle:SetStartAlpha( 255 )
			particle:SetStartSize( 20 * scale )
			particle:SetEndSize( math.Rand(180,240) * scale )
			particle:SetEndAlpha( 100 )
			particle:SetRoll( math.Rand( -1, 1 ) )
			particle:SetColor( 200,150,150 )
			particle:SetCollide( false )
		end
	end

	emitter:Finish()

	local dlight = DynamicLight( math.random(0,9999) )
	if dlight then
		dlight.pos = pos
		dlight.r = 255
		dlight.g = 180
		dlight.b = 100
		dlight.brightness = 8
		dlight.Decay = 2000
		dlight.Size = 300
		dlight.DieTime = CurTime() + 1
	end
end

function EFFECT:Think()
	if self.DieTime < CurTime() then return false end

	return true
end

function EFFECT:Render()
	local Scale = (self.DieTime - CurTime()) / self.LifeTime
	render.SetMaterial( self.GlowMat )
	render.DrawSprite( self.Pos, 2000 * Scale, 2000 * Scale, Color( 255, 200, 150, 255) )

	local Scale = (self.DieTime - self.LifeTime + 0.25 - CurTime()) / 0.25
	local InvScale = 1 - Scale
	if Scale > 0 then
		render.SetColorMaterial()
		render.DrawSphere( self.Pos, -450 * InvScale, 30,30, Color( 255, 200, 150, 150 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -500 * InvScale, 30,30, Color( 255, 200, 150, 100 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, -550 * InvScale, 30,30, Color( 255, 200, 150, 25 * (Scale ^ 2) ) )
		render.DrawSphere( self.Pos, 600 * InvScale, 30,30, Color( 255, 200, 150, 25 * (Scale ^ 2) ) )
	end
end

--PATH addons/lvs_cars_3027255911/lua/effects/lvs_physics_trackdust.lua:

EFFECT.DustMat = {
	"effects/lvs/track_debris_01",
	"effects/lvs/track_debris_02",
}

function EFFECT:Init( data )
	local pos = data:GetOrigin()
	local ent = data:GetEntity()
	local size = data:GetMagnitude()

	if not IsValid( ent ) then return end

	local dir = data:GetNormal()

	local emitter = ent:GetParticleEmitter( ent:GetPos() )

	local VecCol = (render.GetLightColor( pos + dir ) * 0.5 + Vector(0.5,0.4,0.3)) * 255

	local scale = math.Clamp( size / 23, 0.5, 1.25 )

	local particle = emitter:Add( self.DustMat[ math.random(1,#self.DustMat) ] , pos + dir * 5 * scale + VectorRand() * 5 * scale )

	if not particle then return end

	particle:SetVelocity( (dir * 100 * scale + VectorRand() * 20 * scale) )
	particle:SetDieTime( math.Rand(0.4,0.6) )
	particle:SetAirResistance( 10 ) 
	particle:SetStartAlpha( math.random(100,255) )
	particle:SetStartSize( 6 * scale )
	particle:SetEndSize( math.random(20,25) * scale )
	particle:SetRollDelta( math.Rand(-1,1) )
	particle:SetColor( math.min( VecCol.r, 255 ), math.min( VecCol.g, 255 ), math.min( VecCol.b, 255 ) )
	particle:SetGravity( Vector(0,0,-600) )
	particle:SetCollide( false )
end

function EFFECT:Think()
	return false
end

function EFFECT:Render()
end

--PATH addons/__main/lua/effects/m9k_effect_mad_ricochet_trace/init.lua:
EFFECT.Mat = Material("effects/yellowflare")

/*---------------------------------------------------------
   EFFECT:Init(data)
---------------------------------------------------------*/
function EFFECT:Init(data)

	self.StartPos 	= data:GetStart()	
	self.EndPos 	= data:GetOrigin()
	self.Dir 		= self.EndPos - self.StartPos
	self.Entity:SetRenderBoundsWS(self.StartPos, self.EndPos)
	
	self.TracerTime 	= 0.4
	
	// Die when it reaches its target
	self.DieTime 	= CurTime() + self.TracerTime
	
	// Play ricochet sound with random pitch
	
	local vGrav 	= Vector(0, 0, -450)
	local Dir 		= self.Dir:GetNormalized()
	
	local emitter = ParticleEmitter(self.StartPos)
	
	for i = 1, 10 do
	
		local particle = emitter:Add("effects/yellowflare", self.StartPos)
		
			particle:SetVelocity((Dir + VectorRand() * 0.5) * math.Rand(50, 150))
			particle:SetDieTime(math.Rand(0.5, 2))
			particle:SetStartAlpha(255)
			particle:SetStartSize(math.Rand(2, 4))
			particle:SetEndSize(0)
			particle:SetRoll(0)
			particle:SetGravity(vGrav * 0.4)
			particle:SetCollide(true)
			particle:SetBounce(0.8)
			particle:SetAirResistance(50)
			particle:SetStartLength(0.2)
			particle:SetEndLength(0)
			particle:SetVelocityScale(true)
			particle:SetCollide(true)
	end
	
		local particle = emitter:Add("effects/yellowflare", self.StartPos)

			particle:SetDieTime(0.1)
			particle:SetStartAlpha(255)
			particle:SetStartSize(128)
			particle:SetEndSize(0)
			particle:SetRoll(math.Rand(0, 360))
			
		local particle = emitter:Add("effects/yellowflare", self.StartPos)

			particle:SetDieTime(0.4)
			particle:SetStartAlpha(255)
			particle:SetStartSize(32)
			particle:SetEndSize(0)
			particle:SetRoll(math.Rand(0, 360))
				
	emitter:Finish()
	
	local dlight = DynamicLight(0)
		if (dlight) then
			dlight.Pos 		= self.StartPos
			dlight.r 		= 255
			dlight.g 		= 255
			dlight.b 		= 255
			dlight.Brightness = 4
			dlight.size 	= 64
			dlight.DieTime 	= CurTime() + 0.1
		end
end

/*---------------------------------------------------------
   THINK
---------------------------------------------------------*/
function EFFECT:Think()

	if (CurTime() > self.DieTime) then return false end
	
	return true
end

/*---------------------------------------------------------
   Draw the effect
---------------------------------------------------------*/
function EFFECT:Render()

	local fDelta = (self.DieTime - CurTime()) / self.TracerTime
	fDelta = math.Clamp(fDelta, 0, 1)
			
	render.SetMaterial(self.Mat)
	
	local sinWave = math.sin(fDelta * math.pi)
	
	local color = Color(255, 255, 255, 255 * fDelta)
	
	render.DrawBeam(self.StartPos, self.EndPos, 8 * fDelta, 0.5, 0.5, color)
end
--PATH addons/__main/lua/effects/m9k_rg_muzzle_rifle/init.lua:
function EFFECT:Init(data)
	
	if not IsValid(data:GetEntity()) then return end
	if not IsValid(data:GetEntity():GetOwner()) then return end
	self.WeaponEnt = data:GetEntity()
	self.Attachment = data:GetAttachment()
	
	if self.WeaponEnt == nil or self.WeaponEnt:GetOwner() == nil or self.WeaponEnt:GetOwner():GetVelocity() == nil then 
		return
	else
	
	self.Position = self:GetTracerShootPos(data:GetOrigin(), self.WeaponEnt, self.Attachment)
	self.Forward = data:GetNormal()
	self.Angle = self.Forward:Angle()
	self.Right = self.Angle:Right()
	
	local AddVel = self.WeaponEnt:GetOwner():GetVelocity()
	
	local emitter = ParticleEmitter(self.Position)
	if emitter != nil then	
		local particle = emitter:Add( "sprites/heatwave", self.Position - self.Forward * 4 )
		if particle != nil then
	
			particle:SetVelocity( 80 * self.Forward + 20 * VectorRand() + 1.05 * AddVel )
			particle:SetGravity( Vector( 0, 0, 100 ) )
			particle:SetAirResistance( 160 )

			particle:SetDieTime( math.Rand( 0.2, 0.25 ) )

			particle:SetStartSize( math.random( 25, 40 ) )
			particle:SetEndSize( 10 )

			particle:SetRoll( math.Rand( 180, 480 ) )
			particle:SetRollDelta( math.Rand( -1, 1 ) )
		
		for i = 1,4 do
			local particle = emitter:Add( "particle/particle_smokegrenade", self.Position )

				particle:SetVelocity( 120 * i * self.Forward + 8 * VectorRand() + AddVel )
				particle:SetAirResistance( 400 )
				particle:SetGravity( Vector(0, 0, math.Rand(100, 200) ) )

				particle:SetDieTime( math.Rand( 0.5, 1.0 ) )

				particle:SetStartAlpha( math.Rand( 25, 70 ) )
				particle:SetEndAlpha( 0 )

				particle:SetStartSize( math.Rand( 3, 7 ) )
				particle:SetEndSize( math.Rand( 20, 50 ) )

				particle:SetRoll( math.Rand( -25, 25 ) )
				particle:SetRollDelta( math.Rand( -0.05, 0.05 ) )

				particle:SetColor( 120, 120, 120 )
		end
		
		if math.random( 1, 2 ) == 1 then

			for j = 1,2 do

				for i = -1,1,2 do 

					local particle = emitter:Add( "effects/muzzleflash"..math.random( 1, 4 ), self.Position - 3 * self.Forward + 2 * j * i * self.Right)

						particle:SetVelocity( 60 * j * i * self.Right + AddVel )
						particle:SetGravity( AddVel )

						particle:SetDieTime( 0.1 )

						particle:SetStartAlpha( 150 )

						particle:SetStartSize( j )
						particle:SetEndSize( 4 * j )

						particle:SetRoll( math.Rand( 180, 480 ) )
						particle:SetRollDelta( math.Rand( -1, 1 ) )

						particle:SetColor( 255, 255, 255 )	
				end
			end

			for i = 1,2 do 

				local particle = emitter:Add( "effects/muzzleflash"..math.random( 1, 4 ), self.Position + 8 * self.Forward )

					particle:SetVelocity( 350 * self.Forward + 1.1 * AddVel )
					particle:SetAirResistance( 160 )

					particle:SetDieTime( 0.1 )

					particle:SetStartAlpha( 160 )
					particle:SetEndAlpha( 0 )

					particle:SetStartSize( 6 * i )
					particle:SetEndSize( 5 * i )

					particle:SetRoll( math.Rand( 180, 480 ) )
					particle:SetRollDelta( math.Rand( -1, 1) )

					particle:SetColor( 255, 255, 255 )	
			end
		end
		end
	emitter:Finish()
	end
	end
end


function EFFECT:Think()

	return false
end


function EFFECT:Render()
end
--PATH addons/_drones/lua/effects/fxbase.lua:
-- based on nomad's tracer by Chad Barrett --
-- edited for the use with SciFiWeapons by Darken217 --

AddCSLuaFile()
if ( CLIENT ) then
TRACER_FLAG_USEATTACHMENT	= 0x0002
end
EFFECT.Speed	= 6500
EFFECT.Length	= 64

function EFFECT:GetTracerOrigin( data )
if ( CLIENT ) then
	local start = data:GetStart()

	if( bit.band( data:GetFlags(), TRACER_FLAG_USEATTACHMENT ) == TRACER_FLAG_USEATTACHMENT ) then

		local entity = data:GetEntity()
		
		if( not IsValid( entity ) ) then return start end
		if( not game.SinglePlayer() and entity:IsEFlagSet( EFL_DORMANT ) ) then return start end
		
		if( entity:IsWeapon() and entity:IsCarriedByLocalPlayer() ) then
			local pl = entity:GetOwner()
			if( IsValid( pl ) ) then
				local vm = pl:GetViewModel()
				if( IsValid( vm ) and not LocalPlayer():ShouldDrawLocalPlayer() ) then
					entity = vm
				else 					
					if( entity.WorldModel ) then
						entity:SetModel( entity.WorldModel )
					end
				end
			end
		end

		local attachment = entity:GetAttachment( data:GetAttachment() )
		if( attachment ) then
			start = attachment.Pos
		end

	end
	
	return start
end
end

function EFFECT:Init( data )

	self.StartPos = self:GetTracerOrigin( data )
	self.EndPos = data:GetOrigin()
	self.Parent = data:GetEntity()
	
	self.Entity:SetRenderBoundsWS( self.StartPos, self.EndPos )

	local diff = ( self.EndPos - self.StartPos )
	
	self.Normal = diff:GetNormal()
	self.StartTime = 0
	self.LifeTime = ( diff:Length() + self.Length ) / self.Speed

end

function EFFECT:Think()

	self.LifeTime = self.LifeTime - FrameTime()
	self.StartTime = self.StartTime + FrameTime()
	
	return self.LifeTime > 0

end

function EFFECT:Render()

	local endDistance = self.Speed * self.StartTime
	local startDistance = endDistance - self.Length
	
	startDistance = math.max( 0, startDistance )
	endDistance = math.max( 0, endDistance )

	local startPos = self.StartPos + self.Normal * startDistance
	local endPos = self.StartPos + self.Normal * endDistance
	
end
--PATH addons/____inventory/lua/itemstore/trading.lua:
itemstore.trading = {}

local Trade = {}

function Trade:GetSide( pl )
	if self.Right.Player == pl then
		return self.Right
	elseif self.Left.Player == pl then
		return self.Left
	end
end

function Trade:SetMoneyOffer( pl, offer )
	local side = self:GetSide( pl )

	if side then
		side.Money = math.Clamp( offer, 0, itemstore.gamemodes.GetMoney( pl ) )

		if SERVER then
			self:Sync()
		end
	end
end

function Trade:GetMoneyOffer( pl )
	local side = self:GetSide( pl )

	if side then
		return side.Money
	end
end

function Trade:SetReady( pl, ready )
	local side = self:GetSide( pl )

	if side then
		side.Ready = ready
		
		if SERVER then
			self:Sync()
		end
	end
end

function Trade:GetReady( pl )
	local side = self:GetSide( pl )

	if side then
		return side.Ready
	end
end

function Trade:IsReady()
	return self.Left.Ready and self.Right.Ready
end


if SERVER then
	util.AddNetworkString( "ItemStoreTrade" )
	function Trade:Sync()
		net.Start( "ItemStoreTrade" )
			net.WriteEntity( self.Left.Player )
			net.WriteUInt( self.Left.Money, 32 )
			net.WriteUInt( self.Left.Container:GetID(), 32 )
			net.WriteBit( self.Left.Ready )

			net.WriteEntity( self.Right.Player )
			net.WriteUInt( self.Right.Money, 32 )
			net.WriteUInt( self.Right.Container:GetID(), 32 )
			net.WriteBit( self.Right.Ready )
		net.Send( { self.Left.Player, self.Right.Player } )
	end

	util.AddNetworkString( "ItemStoreCloseTrade" )
	function Trade:Close()
		if IsValid( self.Left.Player ) then
			for k, v in pairs( self.Left.Container:GetItems() ) do
				self.Left.Player.Inventory:AddItem( v )
			end			
		end

		itemstore.containers.Remove( self.Left.Container:GetID() )

		if IsValid( self.Right.Player ) then
			for k, v in pairs( self.Right.Container:GetItems() ) do
				self.Right.Player.Inventory:AddItem( v )
			end
		end

		itemstore.containers.Remove( self.Right.Container:GetID() )

		self.Left.Player.Trade = nil
		self.Right.Player.Trade = nil

		net.Start( "ItemStoreCloseTrade" )
		net.Send( { self.Left.Player, self.Right.Player } )
	end

	function Trade:Accept()
		if not self:IsReady() then return end

		if IsValid( self.Left.Player ) and IsValid( self.Right.Player ) then
			local leftmoney = itemstore.gamemodes.GetMoney( self.Left.Player )
			local rightmoney = itemstore.gamemodes.GetMoney( self.Right.Player )

			if leftmoney >= self.Left.Money and rightmoney >= self.Right.Money then
				for k, v in pairs( self.Left.Container:GetItems() ) do
					self.Left.Container:SetItem( k, nil )
					self.Right.Player.Inventory:AddItem( v )
				end

				for k, v in pairs( self.Right.Container:GetItems() ) do
					self.Right.Container:SetItem( k, nil )
					self.Left.Player.Inventory:AddItem( v )
				end

				itemstore.gamemodes.GiveMoney( self.Left.Player, -self.Left.Money )
				itemstore.gamemodes.GiveMoney( self.Left.Player, self.Right.Money )

				itemstore.gamemodes.GiveMoney( self.Right.Player, self.Left.Money )
				itemstore.gamemodes.GiveMoney( self.Right.Player, -self.Right.Money )
			else
				self.Left.Player:ChatPrint( itemstore.Translate( "trade_failed" ) )
				self.Right.Player:ChatPrint( itemstore.Translate( "trade_failed" ) )
			end
		end

		self:Close()
	end

	util.AddNetworkString( "ItemStoreTradeMessage" )
	function Trade:Message( pl, message )
		net.Start( "ItemStoreTradeMessage" )
			net.WriteEntity( pl )
			net.WriteString( message )
		net.Send( { self.Left.Player, self.Right.Player } )
	end
else
	function Trade:SendMessage( message )
		net.Start( "ItemStoreTradeMessage" )
			net.WriteString( message )
		net.SendToServer()
	end
end

function itemstore.Trade( left, right, con_left, con_right )
	local trade = {
		Left = {
			Player = left,
			Money = 0,
			Container = con_left or itemstore.Container( 4, 3, 1 ),
			Ready = false
		},

		Right = {
			Player = right,
			Money = 0,
			Container = con_right or itemstore.Container( 4, 3, 1 ),
			Ready = false
		}
	}

	setmetatable( trade, { __index = Trade } )

	left.Trade = trade
	right.Trade = trade

	if SERVER then
		trade.Left.Container:SetPermissions( left, true, true )
		trade.Left.Container:SetPermissions( right, true, false )

		trade.Left.Container:AddCallback( "set", function( slot, item )
			trade:SetReady( trade.Left.Player, false )
			trade:SetReady( trade.Right.Player, false )
		end )

		trade.Left.Container:Sync()

		trade.Right.Container:SetPermissions( left, true, false )
		trade.Right.Container:SetPermissions( right, true, true )

		trade.Right.Container:AddCallback( "set", function( slot, item )
			trade:SetReady( trade.Left.Player, false )
			trade:SetReady( trade.Right.Player, false )
		end )

		trade.Right.Container:Sync()		

		trade:Sync()
	end

	return trade
end

if SERVER then
	--[[
	util.AddNetworkString( "ItemStoreStartTrade" )
	net.Receive( "ItemStoreStartTrade", function( len, pl )
		local partner = net.ReadEntity()

		if not  IsValid( partner ) or not partner:IsPlayer() then
			itemstore.Trade( pl, partner )
		end
	end )
	]]

	util.AddNetworkString( "ItemStoreReadyTrade" )
	net.Receive( "ItemStoreReadyTrade", function( len, pl )
		if pl.Trade then
			pl.Trade:SetReady( pl, net.ReadBit() == 1 )
		end
	end )

	util.AddNetworkString( "ItemStoreAcceptTrade" )
	net.Receive( "ItemStoreAcceptTrade", function( len, pl )
		if pl.Trade then
			pl.Trade:Accept()
		end
	end )

	util.AddNetworkString( "ItemStoreCloseTrade" )
	net.Receive( "ItemStoreCloseTrade", function( len, pl )
		if pl.Trade then
			pl.Trade:Close()
		end
	end )

	util.AddNetworkString( "ItemStoreTradeMoney" )
	net.Receive( "ItemStoreTradeMoney", function( len, pl )
		if pl.Trade then
			pl.Trade:SetMoneyOffer( pl, net.ReadUInt( 32 ) )
		end
	end )

	util.AddNetworkString( "ItemStoreTradeMessage" )
	net.Receive( "ItemStoreTradeMessage", function( len, pl )
		if pl.Trade then
			pl.Trade:Message( pl, net.ReadString() )
		end
	end )
else
	itemstore.trading.Panel = nil

	net.Receive( "ItemStoreTrade", function()
		left_pl = net.ReadEntity()
		left_money = net.ReadUInt( 32 )
		left_con = itemstore.containers.Get( net.ReadUInt( 32 ) )
		left_ready = net.ReadBit() == 1

		right_pl = net.ReadEntity()
		right_money = net.ReadUInt( 32 )
		right_con = itemstore.containers.Get( net.ReadUInt( 32 ) )
		right_ready = net.ReadBit() == 1

		local trade = itemstore.Trade( left_pl, right_pl, left_con, right_con )

		trade.Left.Money = left_money
		trade.Left.Ready = left_ready

		trade.Right.Money = right_money
		trade.Right.Ready = right_ready

		LocalPlayer().Trade = trade

		if not IsValid( itemstore.trading.Panel ) then
			if trade.Left.Player == LocalPlayer() then
				itemstore.trading.Panel = vgui.Create( "ItemStoreTrade" )
				itemstore.trading.Panel:Center()
				itemstore.trading.Panel:MakePopup()
			else
				itemstore.trading.Panel = vgui.Create( "ItemStoreTradeRequest" )
				itemstore.trading.Panel:SetSize( 200, 100 )
				itemstore.trading.Panel:SetPos( ScrW() - itemstore.trading.Panel:GetWide(), 0 )
			end
		end

		itemstore.trading.Panel:Refresh()
	end )

	net.Receive( "ItemStoreCloseTrade", function()
		LocalPlayer().Trade = nil

		if IsValid( itemstore.trading.Panel ) then
			itemstore.trading.Panel:Close()
		end
	end )

	net.Receive( "ItemStoreTradeMessage", function()
		if IsValid( itemstore.trading.Panel ) and itemstore.trading.Panel.ChatMessage then
			itemstore.trading.Panel:ChatMessage( net.ReadEntity(), net.ReadString() )
		end
	end )
end

--PATH addons/____inventory/lua/itemstore/vgui/newslot.lua:
local PANEL = {}

local GradientUp = Material( "gui/gradient_up" )
local GradientDown = Material( "gui/gradient_down" )

AccessorFunc( PANEL, "Item", "Item" )
AccessorFunc( PANEL, "ContainerID", "ContainerID", FORCE_NUMBER )
AccessorFunc( PANEL, "Slot", "Slot", FORCE_NUMBER )

function PANEL:Init()
	self.BaseClass.Init( self )

	self:Droppable( "ItemStore" )
	self:Receiver( "ItemStore", function( receiver, droptable, dropped )
		if not dropped then return end

		local droppable = droptable[ 1 ]
		if droppable == receiver then return end

		local from_con = droppable:GetContainerID()
		local to_con = droppable:GetContainerID()

		if not from_con then return end
		if not to_con then return end

		local from_slot = droppable:GetSlot()
		local to_slot = receiver:GetSlot()

		if not from_slot then return end
		if not to_slot then return end

		local from_item = droppable:GetItem()
		local to_item = receiver:GetItem()

		if from_item and to_item and ( from_item:CanMerge( to_item ) or
			from_item:CanUseWith( to_item ) ) then
			local menu = vgui.Create('onyx.Menu')
			menu:SetPos( gui.MouseX(), gui.MouseY() )

			if from_item:CanUseWith( to_item ) then
				menu:AddOption( itemstore.Translate( "usewith" ), function()
					LocalPlayer():UseItemWith( droppable:GetContainerID(), droppable:GetSlot(),
						receiver:GetContainerID(), receiver:GetSlot() )
				end ):SetIcon( "icon16/wrench_orange.png" )
			end

			menu:AddOption( itemstore.Translate( "move" ), function()
				LocalPlayer():MoveItem( droppable:GetContainerID(), droppable:GetSlot(),
					receiver:GetContainerID(), receiver:GetSlot() )
			end ):SetIcon( "icon16/arrow_switch.png" )

			if from_item:CanMerge( to_item ) then
				menu:AddOption( itemstore.Translate( "merge" ), function()
					LocalPlayer():MergeItem( droppable:GetContainerID(), droppable:GetSlot(),
						receiver:GetContainerID(), receiver:GetSlot() )
				end ):SetIcon( "icon16/arrow_join.png" )
			end

			menu:Open()
		else
			LocalPlayer():MoveItem( droppable:GetContainerID(), droppable:GetSlot(),
				receiver:GetContainerID(), receiver:GetSlot() )
		end
	end )
end

function PANEL:PaintHighlight( w, h )
    if true then return end

	local item = self:GetItem()

	if item and item.HighlightColor then
		local col = Color( item.HighlightColor.r, item.HighlightColor.g, item.HighlightColor.b )
		local bright = Color( col.r * 1.25, col.g * 1.25, col.b * 1.25 )
        local dark = Color( bright.r * 0.5, bright.g * 0.5, bright.b * 0.5 )
        
        local shape = {
            { x = 0, y = 0 },
            { x = w * 0.1, y = 0 },
            { x = 0, y = h * 0.1 }
        }

        draw.NoTexture()
        surface.SetDrawColor( col )
        surface.DrawPoly( shape )
	end
end

PANEL.Vingette = Material( "itemstore/vingette.png" )

function PANEL:PaintBackground( w, h )
    local item = self:GetItem()

    local col = Color( 50, 50, 50, 100 )

    if item then
		col = Color( item.HighlightColor.r, item.HighlightColor.g, item.HighlightColor.b )

		if self:IsDown() then
			col.r = math.min( col.r * 0.75, 255 )
			col.g = math.min( col.g * 0.75, 255 )
			col.b = math.min( col.b * 0.75, 255 )
		elseif self.Hovered then
			col.r = math.min( col.r * 1.25, 255 )
			col.g = math.min( col.g * 1.25, 255 )
			col.b = math.min( col.b * 1.25, 255 )
		end
    end

    surface.SetDrawColor( col )
    surface.DrawRect( 0, 0, w, h ) 

	if item then
		surface.SetMaterial( self.Vingette )
		surface.SetDrawColor( Color( 0, 0, 0, 125 ) )
		surface.DrawTexturedRect( 0, 0, w, h )
	end
end

PANEL.LabelLerp = 0

surface.CreateFont( "ItemStoreSlotLabel", {
	font = "Montserrat",
	size = 18,
	weight = 500
} )

function PANEL:PaintLabel( w, h )
    if w < 100 or self:IsDragging() then return end

    local item = self:GetItem()
    if not item then return end

    self.LabelLerp = Lerp( FrameTime() * 15, self.LabelLerp, self.Hovered and 1 or -0.1 )

    local lw, lh = w, 32
    local lx, ly = 0, h - ( self.LabelLerp * lh )

    surface.SetDrawColor( Color( 0, 0, 0, 150 ) )
    surface.DrawRect( lx, ly, lw, lh )
    draw.SimpleTextOutlined(
        item:GetName(),
        "ItemStoreSlotLabel",
        lw * 0.5, ly + ( lh * 0.5 ),
        color_white,
        TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER,
        1, color_black
    )
end

surface.CreateFont( "ItemStoreAmount", {
	font = "Montserrat",
	size = 18,
	weight = 500
} )

function PANEL:PaintAmount( w, h )
    local item = self:GetItem()

    if item and item:GetAmount() > 1 then
		draw.SimpleTextOutlined(
            item:FormatAmount(),
            "ItemStoreAmount",
            w - w * 0.05 - 2, h * 0.05 - 2,
            color_white,
            TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP,
            1, color_black
        )
	end
end

function PANEL:PaintBorder( w, h )
    surface.SetDrawColor( Color( 0, 0, 0, 150 ) )
    surface.DrawOutlinedRect( 0, 0, w, h )

    surface.SetDrawColor( Color( 255, 255, 255, 25 ) )
    surface.DrawOutlinedRect( 1, 1, w - 2, h - 2 )
end

function PANEL:Paint( w, h )
	self:PaintBackground( w, h )

    self.BaseClass.Paint( self, w, h )
    
    self:PaintHighlight( w, h )
    self:PaintAmount( w, h )

    self:PaintLabel( w, h )
    self:PaintBorder( w, h )
end

function PANEL:Refresh()
	local item = self:GetItem()

	if item then
		self:SetModel( item:GetModel() )
		self:SetColor( item:GetColor() or color_white )

		if IsValid( self.Entity ) then
			self.Entity:SetMaterial( item:GetMaterial() )

			local min, max = self.Entity:GetRenderBounds()

			self:SetCamPos( Vector( 0.55, 0.55, 0.55 ) * min:Distance( max ) )
			self:SetLookAt( ( min + max ) * 0.5 )
		end
	else
		self.Entity = nil
		self:SetTooltip( nil )
	end
end

function PANEL:DoDoubleClick()
	local con_id = self:GetContainerID()
	local slot = self:GetSlot()
	local item = self:GetItem()

	if not con_id then return end
	if not slot then return end
	if not item then return end
	if not item.Use then return end

	LocalPlayer():UseItem( con_id, slot )
end

function PANEL:DoMiddleClick()
	local con_id = self:GetContainerID()
	local slot = self:GetSlot()
	local item = self:GetItem()

	if not con_id then return end
	if not slot then return end
	if not item then return end

	LocalPlayer():DropItem( con_id, slot )
end

function PANEL:DoRightClick()
	local con_id = self:GetContainerID()
	local slot = self:GetSlot()
	local item = self:GetItem()

	if not con_id then return end
	if not slot then return end
	if not item then return end

	local menu = vgui.Create('onyx.Menu')
	menu:SetPos( gui.MouseX(), gui.MouseY() )

	if item.Use then
		menu:AddOption( itemstore.Translate( "use" ), function()
			LocalPlayer():UseItem( con_id, slot )
		end ):SetIcon( "icon16/wrench.png" )
	end

	menu:AddOption( itemstore.Translate( "drop" ), function()
		LocalPlayer():DropItem( con_id, slot )
	end ):SetIcon( "icon16/arrow_out.png" )

	menu:AddOption( itemstore.Translate( "destroy" ), function()
		Derma_Query( itemstore.Translate( "destroy_confirmation" ), itemstore.Translate( "destroy_title" ), itemstore.Translate( "ok" ), function()
			LocalPlayer():DestroyItem( con_id, slot )
		end, itemstore.Translate( "cancel" ) ):SetSkin( "itemstore" )
	end ):SetIcon( "icon16/delete.png" )

	if item:CanSplit( 1 ) then
		local submenu, entry = menu:AddSubMenu( itemstore.Translate( "split" ) )
		entry:SetIcon( "icon16/arrow_divide.png" )

		local half = math.floor( item:GetAmount() * 0.5 )

		submenu:AddOption( itemstore.Translate( "split_half", half ), function()
			LocalPlayer():SplitItem( con_id, slot, half )
		end )

		for _, amount in ipairs( { 1, 2, 5, 10, 25, 50, 100, 250, 1000 } ) do
			if item:CanSplit( amount ) then
				submenu:AddOption( amount, function()
					LocalPlayer():SplitItem( con_id, slot, amount )
				end )
			end
		end

		menu:Open()
	end

	item:Run( "PopulateMenu", menu )

	menu:Open()
end

local Tooltip

function PANEL:CreateTooltip()
	if IsValid( Tooltip ) then
		Tooltip:SetVisible( true )
		return
	end

	Tooltip = vgui.Create( "ItemStoreTooltip" )
	self:UpdateTooltip()
end

function PANEL:UpdateTooltip()
	if not IsValid( Tooltip ) then return end

	Tooltip:SetContainerID( self:GetContainerID() )
	Tooltip:SetSlot( self:GetSlot() )
	Tooltip:SetItem( self:GetItem() )
	Tooltip:Refresh()
end

function PANEL:HideTooltip()
	if IsValid( Tooltip ) then Tooltip:SetVisible( false ) end
end

function PANEL:OnCursorEntered()
	if not self:GetItem() then return end

	self:CreateTooltip()
	self:UpdateTooltip()
end

function PANEL:OnCursorMoved()
	if not IsValid( Tooltip ) then return end

	local x, y = gui.MousePos()
	Tooltip:SetPos( x, y - Tooltip:GetTall() )
end

function PANEL:OnCursorExited()
	self:HideTooltip()
end

vgui.Register( "ItemStoreNewSlot", PANEL, "DModelPanel" )

local blur = Material( "pp/blurscreen" )
local gradient_up = Material( "gui/gradient_up" )
local gradient_down = Material( "gui/gradient_down" )

concommand.Add( "itemstore_test", function()
    local lerp = 0

	-- todo: move this to it's own vgui element
	local frame = vgui.Create( "EditablePanel" )
	frame:DockPadding( 10, ScrH() * 0.1 + 10, 10, ScrH() * 0.1 + 10 )
    frame:SetAlpha( lerp )
    frame:SetSize( ScrW(), ScrH() )
    frame:Center()

    frame.Paint = function( self, w, h )
        lerp = Lerp( FrameTime() * 5, lerp, 1 )
        self:SetAlpha( lerp * 255 )

        blur:SetFloat( "$blur", 4 )
        blur:Recompute()
        render.UpdateScreenEffectTexture()

        surface.SetMaterial( blur )
        surface.SetDrawColor( color_white )
        surface.DrawTexturedRect( 0, 0, w, h )

        surface.SetDrawColor( Color( 255, 255, 255, 25 ) )
        surface.DrawRect( 0, 0, w, h )

        local height = math.floor( ScrH() * 0.35 * lerp )

		surface.SetDrawColor( Color( 0, 0, 0, 225 ) )
		surface.SetMaterial( gradient_down )
		surface.DrawTexturedRect( 0, 0, w, height )
		surface.SetMaterial( gradient_up )
        surface.DrawTexturedRect( 0, h - height, w, height )
    end

    --[[
    local grid = vgui.Create( "DGrid", frame )
    grid:Dock( FILL )
    grid:SetCols( 8 )
    ]]

    --[[
    for i = 1, 80 do
        local slot = vgui.Create( "ItemStoreNewSlot" )
        slot:SetSize( 100, 100 )
        slot:SetItem( item )
        slot:Refresh()

        grid:AddItem( slot )
    end
    ]]

	local model = vgui.Create( "DModelPanel", frame )
	model:Dock( LEFT )
	model:DockMargin( 0, 0, 10, 0 )
	model:SetWidth( ScrW() * 0.25 )
	model:SetModel( "models/player/alyx.mdl" )

    local con = vgui.Create( "ItemStoreNewContainer", frame )
	con:Dock( FILL )
	con:Center()
	con:SetContainerID( LocalPlayer().InventoryID )

    local button = vgui.Create( "DButton", frame )
    button:SetPos( 10, 10 )
    button.DoClick  = function()
        frame:Remove()
    end
    button:SetText( "Close" )

    frame:MakePopup()
end )
--PATH addons/____esclib/lua/elib/essentials/libs/esc_isql.lua:
--[[
Original module https://github.com/Be1zebub/Small-GLua-Things/blob/master/isql.lua

MIT LICENSE
    Copyright (c) 2022 incredible-gmod.ru
    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
]]

--Example:
--[[
local db = esclib.isql("sqlite")
db:Query("CREATE TABLE IF NOT EXISTS `purchases` (`sid64` TEXT, `id` INTEGER);")
function PLAYER:FetchPurchases()
    return db:Query("SELECT `id` FROM `purchases` WHERE `sid64` = ?;", {self:SteamID64()})
end

--Mysqloo
local db = isql("mysqloo", {
			host = "1.1.1.1",
			port = 3306,
			user = "johndoe",
			pass = "qwerty123",
			db   = "foobar"
		})

		db:Query("CREATE TABLE IF NOT EXISTS `purchases` (`sid64` TEXT, `id` INTEGER);")

		function PLAYER:FetchPurchases()
			return db:Query("SELECT `id` FROM `purchases` WHERE `sid64` = ?;", {self:SteamID64()})
		end
]]

esclib.isql = {
    _NOTE = "A async sql wrapper",
    drivers = {
        sqlite = {
            query = function(_, query, args)
                if args then
                    if isstring(args) then
                        args = {args}
                    end

                    local i = 0
                    query = query:gsub("%?", function()
                        i = i + 1
                        if isstring(args[i]) then
                            return sql.SQLStr(args[i])
                        else
                            return args[i]
                        end
                    end)
                end

                local data = sql.Query(query)

                if data ~= false then
                    return data, sql.Query("SELECT last_insert_rowid();")
                else
                    ErrorNoHaltWithStack(string.format("SQL Query Error!\nQuery: %s\nError: %s\n", query, sql.LastError()))
                end

                return data
            end,
            escape = function(_, str)
                return sql.SQLStr(str)
            end
        },
        mysqloo = {
            require = "mysqloo",
            global = "mysqloo",
            escape = function(self, str)
                return self.db:escape(str)
            end,
            _arg2setter = setmetatable({string = "setString", number = "setNumber", boolean = "setBoolean"}, {
                __index = function() return "setNull" end
            }),
            query = function(self, query, args)
                local co = coroutine.running()
    
                local smt = self.db[args and "prepare" or "query"](self.db, query)
    
                smt.onSuccess = co and function(this, data)
                    coroutine.resume(co, data, this:lastInsert())
                end or nil
    
                function smt:onError(reason)
                    ErrorNoHaltWithStack(string.format("sql Query Error!\nQuery: %s\n%s\n", query, reason))
                    if co then coroutine.resume(co, false, reason) end
                end
    
                if args then
                    for i, arg in ipairs(args) do
                        smt[
                            self.driver._arg2setter[type(arg)]
                        ](smt, i, arg)
                    end
                end
    
                smt:start()
    
                if co then
                    return coroutine.yield()
                end
            end,
            connect = function(self, credentials, _retry)
                _retry = _retry or 3
                self.db = self.module.connect(credentials.host, credentials.user, credentials.pass, credentials.db, credentials.port)
    
                self.db.onConnected = function(db)
                    local success, reason = db:setCharacterSet("utf8mb4")
    
                    if success then
                        self:Query(string.format("ALTER DATABASE `%s` CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci", credentials.db))
                    else
                        ErrorNoHaltWithStack("Failed to set sql encoding!\n")
                        ErrorNoHaltWithStack(reason .."\n")
                    end
    
                    self.ready = true
                    if self.OnConnected then
                        coroutine.wrap(self.OnConnected)(self)
                    end
    
                    for _, co in ipairs(self.queue) do
                        if coroutine.status(co) == "suspended" then
                            coroutine.resume(co)
                        end
                    end
    
                    self.queue = {}
                end
    
                self.db.onConnectionFailed = function(_, reason)
                    ErrorNoHaltWithStack("Sql connection failed!\n".. reason .."\n")
    
                    if _retry > 0 then self.driver.connect(self, credentials, _retry - 1) end
    
                    if self.OnConnectionFailed then
                        coroutine.wrap(self.OnConnectionFailed)(self, reason)
                    end
                end
    
                self.db:connect()
    
                timer.Create(("isql.keepalive/%s/%s:%s-%s-%s"):format(util.CRC(debug.traceback()), credentials.host, credentials.port, credentials.user, credentials.db), 60, 0, function()
                    self.db:ping()
                end)
            end
        },
        tmysql4 = {
            require = "tmysql4",
            global = "tmysql",
            escape = function(self, str)
                return self.db:Escape(str)
            end,
            query = function(self, query, args)
                local co = coroutine.running()
    
                if args then
                    local smt = self.db:Prepare(query)
                    if co then
                        table.insert(args, function(data)
                            if data.status then
                                coroutine.resume(co, data.data, data.lastid)
                            else
                                coroutine.resume(co, false, data.error)
                            end
                        end)
                    end
                    smt:Run(unpack(args))
                else
                    self.db:Query(query, co and function(data)
                        if data.status then
                            coroutine.resume(co, data.data, data.lastid)
                        else
                            coroutine.resume(co, false, data.error)
                        end
                    end or nil)
                end
    
                if co then
                    return coroutine.yield()
                end
            end,
            connect = function(self, credentials, _retry)
                _retry = _retry or 3
                local db, reason = self.module.initialize(credentials.host, credentials.user, credentials.pass, credentials.db, credentials.port)
                self.db = db
    
                if db then
                    self:Query("SELECT 1;")
    
                    self.ready = true
                    if self.OnConnected then
                        coroutine.wrap(self.OnConnected)(self)
                    end
    
                    for _, co in ipairs(self.queue) do
                        if coroutine.status(co) == "suspended" then
                            coroutine.resume(co)
                        end
                    end
    
                    self.queue = {}
                else
                    ErrorNoHaltWithStack("Sql connection failed!\n".. reason .."\n")
    
                    if _retry > 0 then self.driver.connect(self, credentials, _retry - 1) end
    
                    if self.OnConnectionFailed then
                        coroutine.wrap(self.OnConnectionFailed)(self, reason)
                    end
                end
    
                timer.Create(("isql.keepalive/%s/%s:%s-%s-%s"):format(util.CRC(debug.traceback()), credentials.host, credentials.port, credentials.user, credentials.db), 60, 0, function()
                    self:Query("SELECT 1;")
                end)
            end
        }
    }
}

local META = {}
META.__index = META

function META:Query(query, args)
    assert(self.driver, "Cant perform sql query! You should call esclib.isql:New(driver, credentials) 1st!")

    if self.ready == false and coroutine.running() then
        table.insert(self.queue, coroutine.running())
        coroutine.yield()
    end

    return self.driver.query(self, query, args)
end

function META:Escape(str)
    return self.driver.escape(self, str)
end

function esclib.isql:New(driver, credentials, OnConnected, OnConnectionFailed)
    assert(driver and self.drivers[driver], "Invalid sql driver!")

    local instance = setmetatable({
        driver = self.drivers[driver],
        OnConnected = OnConnected,
        OnConnectionFailed = OnConnectionFailed,
        queue = {}
    }, META)

    if instance.driver.require then
        assert(util.IsBinaryModuleInstalled(instance.driver.require), instance.driver.require .." sql module isnt installed!")
        instance.module = require(instance.driver.require) or _G[instance.driver.global]
    end

    if instance.driver.connect then
        instance.ready = false
        instance.driver.connect(instance, credentials)
    else
        instance.ready = true
        if self.OnConnected then
            coroutine.wrap(self.OnConnected)(self)
        end
    end

    return instance
end

setmetatable(esclib.isql, {
    __call = function(self, driver, credentials, OnConnected, OnConnectionFailed)
        return self:New(driver, credentials, OnConnected, OnConnectionFailed)
    end
})
--PATH addons/____esclib/lua/elib/essentials/libs/esc_netstream.lua:
--[[
	NetStream - 2.0.1
	https://github.com/alexgrist/NetStream/blob/master/netstream2.lua

	Alexander Grist-Hucker
	http://www.revotech.org
]]--

--[[
	if SERVER then
		netstream.Hook("Hi", function(ply, ...) -- Third argument is called to check if the player has permission to send the net message before decoding
			print(...)
		end, function(ply)
			if not ply:IsAdmin() then
				return false
			end
		end)
		-- OR
		netstream.Hook("Hi", function(ply, ...)
			print(...)
		end)
		netstream.Start(Entity(1), "Hi", "a", 1, {}, true, false, nil, "!") -- First argument player or table of players or any other argument to send to all players
		netstream.Start({Entity(1), Entity(2)}, "Hi", "a", 1, {}, true, false, nil, "!")
		netstream.Start(nil, "Hi", "a", 1, {}, true, false, nil, "!")
	end
	if CLIENT then
		netstream.Hook("Hi", function(...)
			print(...)
		end)
		netstream.Start("Hi", "a", 1, {}, true, false, nil, "!")
	end
]]--



-- netstream
local mp = esclib.mp
local net = net
local table_maxn = table.maxn
local netStreamSend = "esclib.netstream"

esclib.netstream = esclib.netstream or {}
local netstream = esclib.netstream
netstream.checks = netstream.checks or {}
local checks = netstream.checks
netstream.receivers = netstream.receivers or {}
local receivers = netstream.receivers

local concat = table.concat
local pack = function(t, n)
	local buffer = {}
	mp.packers["array"](buffer, t, n)
	return concat(buffer)
end

if SERVER then
	util.AddNetworkString(netStreamSend)

	local player_GetAll = player.GetAll
	function netstream.Start(ply, name, ...)
		local ply_type = type(ply)
		if ply_type ~= "Player" and ply_type ~= "table" then
			ply = player_GetAll()
		end

		local encoded_data = pack({...}, select("#", ...))
		local length = #encoded_data

		net.Start(netStreamSend)
			net.WriteString(name)
			net.WriteUInt(length, 17)
			net.WriteData(encoded_data, length)
		net.Send(ply)
	end

	function netstream.Hook(name, callback, check)
		receivers[name] = callback
		if type(check) == "function" then
			checks[name] = check
        else
            checks[name] = nil
        end
	end

    function netstream.HookRemove(name)
        receivers[name] = nil
        checks[name] = nil
    end

    function netstream.OnRequest(name, callback, check)
        netstream.Hook(name, function(ply, hook_name, ...)
            local status, response = xpcall(callback, function(err)
				print( "ERROR: ", err )
				debug.Trace()

				return err
			end, ply, ...)

            if not status then
                error(response)
                return
            end

            if not istable(response) then
                error("Request handler return non table answer!")
            end
    
            netstream.Start(ply, hook_name, unpack(response))
        end, check)
    end

	net.Receive(netStreamSend, function(_, ply)
		local name = net.ReadString()

		local callback = receivers[name]
		if not callback then return end

		local length = net.ReadUInt(17)

		local check = checks[name]
		if check and check(ply, length) == false then return end

		local data = net.ReadData(length)

		local status
		status, data = pcall(mp.unpack, data)
		if not status or not istable(data) then return end

		callback(ply, unpack(data, 1, table_maxn(data)))
	end)
else
	checks = nil

	function netstream.Start(name, ...)
		local encoded_data = pack({...}, select("#", ...))
		local length = #encoded_data

		net.Start(netStreamSend)
			net.WriteString(name)
			net.WriteUInt(length, 17)
			net.WriteData(encoded_data, length)
		net.SendToServer()
	end

	function netstream.Hook(name, callback)
		receivers[name] = callback
	end

    function netstream.HookRemove(name)
        receivers[name] = nil
    end

    function netstream.Request(name, timeout, callback, on_timeout, ...)
        assert(name ~= "", "Name must be provided")
        timeout = timeout or 3
		local unique_id = tostring(os.time()) .. "_" .. tostring(math.random(1, 99999))
        local timer_name = "esclib.netstream." .. name .. "_" .. unique_id
		local hook_name = name.."_"..unique_id

        netstream.Hook(hook_name, function(...)
            timer.Remove(timer_name)

            local status, data = pcall(callback, ...)
			if not status then
				error(data)
			end
            netstream.HookRemove(hook_name)
            return data
        end)

        timer.Create(timer_name, timeout, 1, function()
            netstream.HookRemove(hook_name)
            if isfunction(on_timeout) then 
                on_timeout() 
            else
                esclib.addon:Print("[error] Timeout reached for netstream request: '" .. hook_name .. "' and no timeout handler found")
            end
        end)

        netstream.Start(name, hook_name, ...)
    end

	net.Receive(netStreamSend, function()
		local callback = receivers[net.ReadString()]
		if not callback then return end

		local length = net.ReadUInt(17)
		local data = net.ReadData(length)

		data = mp.unpack(data)
		callback(unpack(data, 1, table_maxn(data)))
	end)
end
--PATH addons/____esclib/lua/elib/essentials/esc_utils.lua:
esclib.util = {}

local sin = math.sin
local cos = math.cos
local floor = math.floor
local max = math.max
local min = math.min
local abs = math.abs

--Do it once
if not esclib.scrw or not esclib.scrh then
	esclib.scrw = ScrW()
	esclib.scrh = ScrH()
end

hook.Add("OnScreenSizeChanged", "esclib.onscreenchange", function(oldw, oldh)
	esclib.scrw = ScrW()
	esclib.scrh = ScrH()
end)

function esclib.util:TextOnBG(bgCol, col_white, col_black)
	return (((bgCol.r + bgCol.g + bgCol.b) / 3 >= 127) and col_white or col_black)
end

function esclib.util.GetTextSize(txt,font)
	surface.SetFont(font)
	local x, y = surface.GetTextSize(txt)
	return {w = x, h = y}
end

function esclib.util:TextSize(txt,font)
	surface.SetFont(font)
	return surface.GetTextSize(txt)
end

--fast function, but can be less accurate
function esclib.util:TextCut(text,font,maxw, add_symbol)
	if not text then return end
	local add_symbol = add_symbol or ""

	local textw,texth = esclib.util:TextSize(text,font)
	if textw <= maxw then return text end

	local len = string.len( text )

	local to_cut = math.Clamp(math.ceil((textw-maxw)/(textw/len)), 0, len )

	return string.sub( text, 1, len-to_cut )..add_symbol
end

function esclib.util:TextCutAccurate(text,font,maxw,add_symbol)
	if not text then return end
	local add_symbol = add_symbol or ""

	local textw_max,_ = esclib.util:TextSize(text,font)
	if textw_max <= maxw then return text end

	local text_cutted = text
	for i = string.len(text), 1, -1 do
		text_cutted = string.sub( text, 1, i )
		local textw,_ = esclib.util:TextSize(text_cutted,font)
		if textw <= maxw then
			break
		end
	end

	return text_cutted..add_symbol
end

function esclib.util:Round(x)
	return x>=0 and math.floor(x+0.5) or math.ceil(x-0.5)
end

function esclib.util:NiceTime(time, bHours, bMinutes, bSeconds, bMilliseconds, try_language)
	local time = string.FormattedTime( time )
	local result = ""

	local hours, bHours 	= time.h, ((bHours == nil) or bHours)
	local minutes, bMinutes = time.m, ((bMinutes == nil) or bMinutes)
	local seconds, bSeconds = time.s, ((bSeconds == nil) or bSeconds)
	local milliseconds, bMilliseconds = time.ms, (bMilliseconds)

	if (not bHours) then minutes = minutes + (hours * 60) end
	if (not bHours) and (not bMinutes) then seconds = seconds + (minutes * 60) end
	if (not bHours) and (not bMinutes) and (not bSeconds) then milliseconds = milliseconds + (seconds * 1000) end

	if bHours then
		result = result..string.format("%d%s ", hours, esclib.addon:Translate("char_hours", try_language))
	end
	if bMinutes then
		result = result..string.format("%d%s ", minutes, esclib.addon:Translate("char_minutes", try_language))
	end
	if bSeconds then
		result = result..string.format("%d%s ", seconds, esclib.addon:Translate("char_seconds", try_language))
	end
	if bMilliseconds then
		result = result..string.format("%d%s ", milliseconds, esclib.addon:Translate("char_milliseconds", try_language))
	end

	return result
end

function esclib.util:NumberLimit(number, min, max, str_format)
	local res = number

	if number >= max then
		res = string.format(str_format or "%d+", max-1 )
	elseif number < min then
		res = string.format(str_format or "<%d", min )
	end

	return res
end

--https://gist.github.com/theawesomecoder61/d2c3a3d42bbce809ca446a85b4dda754
function esclib.util.PrecacheArc(cx,cy,radius,thickness,startang,endang,roughness, rote)
	local triarc = {}
	local deg2rad = math.pi / 180
	local rote = rote or 0
	
	-- Correct start/end ang
	local startang,endang = startang or 0, endang or 0
	local bClockwise = (startang < endang)
	startang = startang + rote
	endang = endang + rote
	if bClockwise then
		local temp = startang
		startang = endang
		endang = temp
		temp = nil
	elseif (startang > endang) then 
		local temp = startang
		startang = endang
		endang = temp
		temp = nil
	end
	
	
	-- Define step
	local roughness = max(roughness or 1, 1)
	local step = roughness
	if bClockwise then
		step = math.abs(roughness) * -1
	end
	
	
	-- Create the inner circle's points.
	local inner = {}
	local r = radius - thickness
	for deg=startang, endang, step do
		local rad = deg2rad * deg
		table.insert(inner, {
			x=cx+(cos(rad)*r),
			y=cy+(sin(rad)*r)
		})
	end
	
	
	-- Create the outer circle's points.
	local outer = {}
	for deg=startang, endang, step do
		local rad = deg2rad * deg
		table.insert(outer, {
			x=cx+(cos(rad)*radius),
			y=cy+(sin(rad)*radius)
		})
	end
	
	
	-- Triangulize the points.
	for tri=1,#inner*2 do -- twice as many triangles as there are degrees.
		local p1,p2,p3
		p1 = outer[floor(tri*0.5)+1]
		p3 = inner[floor((tri+1)*0.5)+1]
		if tri%2 == 0 then --if the number is even use outer.
			p2 = outer[floor((tri+1)*0.5)]
		else
			p2 = inner[floor((tri+1)*0.5)]
		end
	
		table.insert(triarc, {p1,p2,p3})
	end
	
	-- Return a table of triangles to draw.
	return triarc
	
end

function esclib.util:HexToColor(hex, alpha)
	hex = hex:gsub("#","")
    return Color ( tonumber("0x" .. hex:sub(1,2)), tonumber("0x" .. hex:sub(3,4)), tonumber("0x" .. hex:sub(5,6)), alpha or 255 )
end


esclib.restricted_chars = {
	["\\"] = true,
	["/"] = true,
	[":"] = true,
	["*"] = true,
	["?"] = true,
	['"'] = true,
	["'"] = true,
	["<"] = true,
	[">"] = true,
	["|"] = true,
	["CON"] = true,
	["PRN"] = true,
	["AUX"] = true,
	["NUL"] = true,
	["COM"] = true,
	["LPT"] = true,
}

function esclib.util:IsRestrictedChar(strs)
	return esclib.restricted_chars[strs or ""]
end

function esclib.util:TruncateStr(str, maxLength)
	if #str > maxLength then str = str:sub(1, maxLength-3) .. "..." end
	return str
end


local function tablesAreEqual(table1, table2)
	if table1 == table2 then return true end
	if type(table1) ~= "table" or type(table2) ~= "table" then return false end
	
	for k, v in pairs(table1) do
		if type(v) ~= type(table2[k]) then return false end
		if type(v) == "table" and type(table2[k]) == "table" then
			if not tablesAreEqual(v, table2[k]) then
				return false
			end
		elseif table2[k] ~= v then
			return false
		end
	end
	
	for k in pairs(table2) do
		if table1[k] == nil then
			return false
		end
	end
	
	return true
end

local function VarsIsEqual(var1, var2)
	if type(var1) ~= type(var2) then return false end
	if type(var1) == "table" and type(var2) == "table" then return tablesAreEqual(var1, var2) end
	return var1 == var2
end

function esclib.util:IsValuesEqual(var1, var2)
	return VarsIsEqual(var1, var2)
end

function esclib.util:ColorMean(...)
	local values = {...}
	local count = #values
	if count < 1 then return end

	local r, g, b, a = 0, 0, 0, 0
	for _,v in ipairs(values) do
		r = r + v.r
		g = g + v.g
		b = b + v.b
		a = a + v.a
	end

	return Color(r/count, g/count, b/count, a/count)
end

function esclib.util:PrecacheRoundedPoly(x, y, w, h, radius, cornerPoints)
    local poly = {}
    local function addCorner(centerX, centerY, startAngle)
        for i = 0, cornerPoints do
            local angle = math.rad(startAngle + (90 / cornerPoints) * i)
            table.insert(poly, {
                x = centerX + math.cos(angle) * radius,
                y = centerY + math.sin(angle) * radius
            })
        end
    end

    -- Top-left corner
    addCorner(x + radius, y + radius, 180)
    -- Top-right corner
    addCorner(x + w - radius, y + radius, 270)
    -- Bottom-right corner
    addCorner(x + w - radius, y + h - radius, 0)
    -- Bottom-left corner
    addCorner(x + radius, y + h - radius, 90)

    return poly
end

--this function mutates from
--example: esclib.print(esclib.util:ColorLerp(0.5, Color(255,255,255), Color(0,0,0)))
function esclib.util:ColorLerp(frac, from, to, fast_alpha)
	assert(IsColor(from), "'from' must be color")
	assert(IsColor(to), "'to' must be color")

	from.r = Lerp(frac, from.r, to.r)
	from.g = Lerp(frac, from.g, to.g)
	from.b = Lerp(frac, from.b, to.b)
	from.a = Lerp(fast_alpha and 1 or frac, from.a, to.a)

	return from
end

function esclib.util:ColorDiff(clr1, clr2)
	assert(IsColor(clr1), "'clr1' must be color")
	assert(IsColor(clr2), "'clr2' must be color")

	local dif = abs(clr1.r - clr2.r)
	dif = dif + abs(clr1.g - clr2.g)
	dif = dif + abs(clr1.b - clr2.b)
	dif = dif + abs(clr1.a - clr2.a)

	return dif
end

local Ambilight = {}
Ambilight.__index = Ambilight

function esclib.util:PrechacheAmbilight(rounding, colors, speed, radius_multiplier, initial_angle)
    local instance = setmetatable({}, Ambilight)
    
    instance.colors = colors or {
        Color(255,215,130),
        Color(0,255,136),
        Color(82,82,255),
        Color(255,102,82)
    }
    instance.colors_count = #instance.colors
    instance.speed = speed or 2
    instance.grad_mat = esclib:GetMaterial("radial_gradient.png")
    instance.poly = nil
	instance.rounding = rounding or 16
	instance.radius_multiplier = radius_multiplier or 1
	instance.initial_angle = initial_angle or 0
	
    
    return instance
end

function Ambilight.DrawMask(self, x, y, w, h)
    if not self.poly then
        self.poly = esclib.util:PrecacheRoundedPoly(x, y, w, h, self.rounding, 6)
    end
    draw.NoTexture()
    surface.SetDrawColor(color_white)
    surface.DrawPoly(self.poly)
end

function Ambilight.DrawContent(self, x, y, w, h)
    local time = CurTime() * self.speed
    local radius = math.max(w, h) * self.radius_multiplier
	local t = math.max(w,h)
    
    for i = 1, self.colors_count do
        local angle = self.initial_angle + time + math.pi * 2 * (i-1) / self.colors_count
        local mx = x + w*0.5 + math.cos(angle) * w*0.5
        local my = y + h*0.5 + math.sin(angle) * h*0.5
        
        esclib.draw:MaterialCentered(mx, my, radius, self.colors[i], self.grad_mat)
    end
end

function Ambilight:Draw(x,y,w, h)
    esclib.draw:Mask(
        self.DrawMask,
        self.DrawContent,
        false, nil, self, x, y, w, h
    )
end

-- Ambilight test
-- if IsValid(tests) then tests:Remove() end
-- tests = vgui.Create("DPanel")
-- tests:SetSize(500,500)
-- tests:Center()
-- tests:NoClipping(true)

-- local colors = {
-- 	Color(0,0,255),
--     Color(0,255,213),
-- }
-- local ambilight = esclib.util:PrechacheAmbilight(16, colors, 1, 2)
-- function tests:Paint(w,h)
-- 	-- esclib.draw:Mask(draw_mask, draw_paint, false,nil, w,h)
-- 	ambilight:Draw(w,h)

-- 	draw.RoundedBox(ambilight.rounding, 2, 2, w-4, h-4, Color(13,13,13,252))
-- end


--PATH addons/____esclib/lua/elib/essentials/settings_menu/esc_settings_default_tabs.lua:
--esclib.settings_shared_funcs.draw_bg(w,h,hovered,clr, is_changed)
local draw_bg = esclib.settings_shared_funcs.draw_bg

esclib.default_settings_tabs = esclib.default_settings_tabs or {}

-----------------
--# FUNCTIONS #--
-----------------
--Add tab to all addons settings
--func parameters: addon, background_panel, combo_panel, callback
local allowed_realms = {
	["realm_Client"] = true,
	["realm_Server"] = true
}

function esclib:AddDefaultTab(uid, realm, sort_order,func)
	if not allowed_realms[realm] then
		error("Invalid realm (Must be realm_Client or realm_Server)")
	end
	local func = func or sort_order

	self.default_settings_tabs[uid] = {
		name = uid,
		realm = realm,
		func = func,
		sortOrder = sort_order,
	}
end

function esclib:RemoveDefaultTab(uid)
	self.default_settings_tabs[uid] = nil
end

function esclib:GetAllDefaultTabs()
	return self.default_settings_tabs
end

--------------------
--# LANGUAGE TAB #--
--------------------
esclib:AddDefaultTab("lang_tab", "realm_Client", 100, function(add, settab, combolist, callback)

	local clr = esclib.addon:GetColors()
	local addon_language = add:GetLanguage()

	local tabname_translated = esclib.addon:Translate("tab_language",add:GetLanguage())
	if not table.IsEmpty(add:GetLanguages()) then
		combolist:AddTab(tabname_translated,function(tab_content)

			local scroll = tab_content:Add("esclib.scrollpanel")
			scroll:SetSize(tab_content:GetWide(),tab_content:GetTall())

			local list = scroll:Add("DIconLayout")
			list:SetSize(tab_content:GetWide(),tab_content:GetTall())
			list:SetBorder(esclib:AdaptiveSize(15))
			list:SetSpaceY(5)
			list:SetSpaceX(5)

			local langs = add:GetLanguages()

			local button_wide = list:GetWide()*0.332-list:GetBorder()
			local button_tall = list:GetTall()*0.08
			local half_tall = button_tall * 0.5

			local icon_w = 24
			local icon_h = 16

			local true_mat = esclib:GetMaterial("true.png")
			local box_mat = esclib:GetMaterial("box.png")
			local offset = 0
			for _,lang in ipairs(table.GetKeys(add:GetLanguages())) do
				local lbutton = list:Add("DButton")
				lbutton:SetSize(button_wide,button_tall)
				lbutton:SetText("")
				local lang_name = langs[lang]["__name__"] or esclib.text:Capitalize(lang)
				local lang_code = langs[lang]["__code__"] or ""
				local lang_icon = Material("materials/flags16/"..lang_code..".png")
				local has_mat = not lang_icon:IsError()

				if has_mat then
					offset = icon_w+10
				end
				local font = esclib:AdaptiveFont("esclib", 24, 500)
				function lbutton:Paint(w,h)
					local hovered = self:IsHovered()
					local selected = add.info.language == lang
					local changed = (not selected and addon_language == lang)
					draw_bg(w,h,hovered,clr, changed)
					draw.SimpleText( lang_name.." ["..lang_code.."]",font,15+offset,h*0.5,selected and clr.button.accent or clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)

					local checkbox_size = h*0.25
					esclib.draw:MaterialCentered(w-checkbox_size-15, h*0.5, checkbox_size, hovered and clr.button.main or clr.button.hover , box_mat)
					if selected and addon_language == lang then
						esclib.draw:MaterialCentered(w-checkbox_size-15, h*0.5, checkbox_size*0.6, clr.button.accent, true_mat)
					end

					if has_mat then
						esclib.draw:Material(15,half_tall-icon_h*0.5,icon_w,icon_h,clr.default.white, lang_icon)
					end

					if changed then
						esclib.draw:MaterialCentered(w-checkbox_size-15, h*0.5, checkbox_size*0.6, clr.button.accent, true_mat)
					end
				end

				function lbutton:DoClick()
					addon_language = lang
					-- if add.info.language ~= addon_language then
					-- 	settings_changed = true
					-- end
					callback("language",addon_language)
				end

			end

			return scroll

		end)
	end

end)


-----------------
--# SKINS TAB #--
-----------------
esclib:AddDefaultTab("skin_tab", "realm_Client", 101, function(add, settab, combolist, callback)

	local addon_active_skin = add.info.active_skin
	local addon_custom_skin = table.Copy(add:GetSkinByName("skin_custom"))
	local clr = esclib.addon:GetColors()
	local tabname_translated = esclib.addon:Translate("tab_theme",add:GetLanguage())

	local function save_skin()
		add.data.skins["skin_custom"] = table.Copy(addon_custom_skin)
		add:SaveCustomSkin()
		if add.info.active_skin == "skin_custom" then
			hook.Run(add.info.uid.."_skin_changed","skin_custom")
		end
		if IsValid(settab.c_themepanel) then
			settab.c_themepanel:Close()
		end
	end

	combolist:AddTab(tabname_translated,function(tab_content)

		local scroll = tab_content:Add("esclib.scrollpanel")
		scroll:SetSize(tab_content:GetWide(),tab_content:GetTall())

		local list = scroll:Add("DIconLayout")
		list:SetSize(tab_content:GetWide(),tab_content:GetTall())
		list:SetBorder(esclib:AdaptiveSize(15))
		list:SetSpaceY(5)
		list:SetSpaceX(5)

		local button_wide = list:GetWide()*0.332-list:GetBorder()
		local button_tall = list:GetTall()*0.08

		local true_mat = esclib:GetMaterial("true.png")
		local box_mat = esclib:GetMaterial("box.png")

		for name,skin in pairs(add.data.skins) do
			if name == "skin_custom" then continue end

			local lbutton = list:Add("DButton")
			lbutton:SetSize(button_wide,button_tall)
			lbutton:SetText("")

			local skin_color = skin.color or Color(100,100,100)
			local font = esclib:AdaptiveFont("esclib", 24, 500)
			function lbutton:Paint(w,h)
				local hovered = self:IsHovered()
				local selected = add.info.active_skin == name
				local changed = (not selected and addon_active_skin == name)
				draw_bg(w,h,hovered,clr, changed)
				draw.SimpleText(skin.name or name,font,50,h*0.5,clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)

				draw.RoundedBox(8,10,h*0.5-h*0.25,h*0.5,h*0.5,clr.default.black)
				draw.RoundedBox(8,8,h*0.5-h*0.25,h*0.5,h*0.5,skin_color)

				local checkbox_size = h*0.25
				esclib.draw:MaterialCentered(w-checkbox_size-15, h*0.5, checkbox_size, hovered and clr.button.main or clr.button.hover , box_mat)
				if addon_active_skin == name then
					esclib.draw:MaterialCentered(w-checkbox_size-15, h*0.5, checkbox_size*0.6, clr.button.accent, true_mat)
				end
			end

			function lbutton:DoClick()
				if addon_active_skin == name then return end
				addon_active_skin = name

				callback("skin",addon_active_skin)

				-- settings_changed = true
			end

			function lbutton:DoRightClick()
				local context = settab:Add("esclib.contextmenu")
				context:SetPosClamped(gui.MouseX()+5,gui.MouseY()+5)

				context:AddHeader(skin.name)

				if add.info.active_skin ~= name then
					context:AddButton(esclib.addon:Translate("phrase_Activate", add:GetLanguage()),function()
						addon_active_skin = name
						callback("skin",addon_active_skin)
						-- save_settings()
					end, esclib:GetMaterial("power.png"))
				end

				context:AddButton(esclib.addon:Translate("button_PrintToConsole", add:GetLanguage()),function()
					add:PrintSkin(name)
				end)
			end
		end

		-----------------------
		--# CUSTOM SKIN TAB #--
		-----------------------
		local ug = LocalPlayer():GetUserGroup() or ""
		local allowed_ug = {
			["superadmin"] = true,
		}
		if not allowed_ug[ug] then return end

		local font = esclib:AdaptiveFont("esclib", 24, 500)
		local lbutton = list:Add("DButton")
		lbutton:SetSize(button_wide,button_tall)
		lbutton:SetText("")
		lbutton:eAddHint(esclib.addon:Translate("hint_CustomSkin", add:GetLanguage()),font,TEXT_ALIGN_CENTER,settab)

		local custom_name = esclib.addon:Translate("phrase_CustomSkin", add:GetLanguage())
		local name = "skin_custom"
		function lbutton:Paint(w,h)
			local hovered = self:IsHovered()
			local selected = add.info.active_skin == name
			local changed = (not selected and addon_active_skin == name)

			draw_bg(w,h,hovered,clr, changed)
			draw.SimpleText(custom_name,font,h*0.35+35,h*0.5,clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)

			esclib.draw:MaterialCentered(h*0.35+10,h*0.5,h*0.35,clr.button.text,esclib:GetMaterial("cog.png"))

			local checkbox_size = h*0.25
			esclib.draw:MaterialCentered(w-checkbox_size-15, h*0.5, checkbox_size, hovered and clr.button.main or clr.button.hover , box_mat)
			if addon_active_skin == name then
				esclib.draw:MaterialCentered(w-checkbox_size-15, h*0.5, checkbox_size*0.6, clr.button.accent, true_mat)
			end
		end

		function lbutton:DoRightClick()
			local mx,my = gui.MouseX(), gui.MouseY()

			local context = settab:Add("esclib.contextmenu")
			context:SetPosClamped(mx+5,my+5)

			context:AddHeader(custom_name)

			if (add.info.active_skin ~= "skin_custom") then
				context:AddButton(esclib.addon:Translate("phrase_Activate", add:GetLanguage()),function()
					addon_active_skin = "skin_custom"
					callback("skin",addon_active_skin)
				end, esclib:GetMaterial("power.png"))
			end

			context:AddButton(esclib.addon:Translate("button_Edit", add:GetLanguage()),function()
				local function GenerateThemeEditPanel(bg,saved)
					if not addon_custom_skin then
						return 
					end

					local skin = esclib.addon:GetCurrentSkin()
					local clr = skin.colors
					local unsaved = saved

					local pnl = bg:Add("esclib.frame")
					pnl:SetSize(bg:GetWide()*0.7,bg:GetTall()*0.9)
					pnl:Center()
					pnl:SetTitle(custom_name)
					pnl:SetIcon(esclib:GetMaterial("cog.png"))
					settab:SetKeyBoardInputEnabled(true)

					function pnl:OnClose()
						callback("custom_skin",self)
					end
					local content = pnl:GetContent()


					local dobar_size = content:GetTall()*0.07
					local dobar = content:Add("DPanel")
					dobar:SetSize(content:GetWide(),dobar_size)
					dobar:SetY(content:GetTall()-dobar:GetTall())

					local phrase_unsaved = esclib.addon:Translate("phrase_Unsaved", add:GetLanguage())
					function dobar:Paint(w,h)
						draw.RoundedBoxEx(skin.roundsize, 0,0,w,h, clr.frame.accent,false,false,true,true)
					end

					local titlepnl = pnl:GetTitlePanel()
					local font = esclib:AdaptiveFont("esclib", 22, 500)
					function titlepnl:PaintOver(w,h)
						if unsaved then
							draw.SimpleText(phrase_unsaved.."!", font, w-35, h*0.5, clr.default.red, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
						end
					end

					local scroll = content:Add("esclib.scrollpanel", add:GetLanguage())
					scroll:SetSize(content:GetWide(),content:GetTall()-dobar_size)

					local list = scroll:Add("DIconLayout")
					list:SetSize(tab_content:GetWide(),tab_content:GetTall())
					list:SetBorder(esclib:AdaptiveSize(15))
					list:SetSpaceY(5)
					list:SetSpaceX(10)

					local button_sizex = list:GetWide()*0.33-list:GetBorder()-2
					local button_sizey = list:GetTall()*0.08

					for color_tab_name, tab_colors in pairs(addon_custom_skin.colors) do
						if color_tab_name == "default" then continue end

						local color_tab = list:Add("DPanel")
						color_tab:SetSize(list:GetWide()-list:GetBorder()*2,list:GetTall()*0.07)
						local font_30 = esclib:AdaptiveFont("esclib", 28, 500)
						local font_24 = esclib:AdaptiveFont("esclib", 20, 500) --haha
						local font_16 = esclib:AdaptiveFont("esclib", 16, 500)
						local texts = esclib.util.GetTextSize(esclib.text:Capitalize(color_tab_name),font_30)
						function color_tab:Paint(w,h)
							draw.SimpleText(esclib.text:Capitalize(color_tab_name),font_30,15,h*0.5,clr.frame.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)
							draw.RoundedBox(0, texts.w + 30, h*0.5-2,w-texts.w-45,4,clr.button.hover)
						end

						for color_name, color in pairs(tab_colors) do
							local color_panel = list:Add("esclib.button")
							color_panel:SetSize(button_sizex,button_sizey)
							color_panel:SetBorderRadius(16)
							color_panel:SetButtonText(color_name)

							local clblack = Color(13,13,13)
							local nalpha = color.a < 255
							function color_panel:Paint(w,h)
								local hovered = self:IsHovered()
								-- draw.RoundedBox(self:GetBorderRadius(),0,0,w,h,hovered and clr.button.hover or clr.button.main)
								draw_bg(w,h,hovered,clr)
								draw.SimpleText(color_name, font_24, 15, h*0.5, hovered and clr.button.text_hover or clr.button.text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

								esclib.draw:ShadowText(""..color.r.." "..color.g.." "..color.b..(nalpha and (" "..color.a) or "").."", font_16, w-60, h*0.5, clr.button.text, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER,1)

								if not nalpha then draw.RoundedBox(16,w-43,h*0.5-h*0.25,h*0.5,h*0.5, color) end
								draw.RoundedBox(8,w-45,h*0.5-h*0.25,h*0.5,h*0.5, color)
							end

							function color_panel:DoClick()
								local cbg = esclib:GenerateBGClicker(true)
								-- cbg.Paint = nil

								local x,y = self:LocalToScreen(0,0)

								local change_panel = cbg:Add("DPanel")
								change_panel:SetSize(self:GetWide(),tab_content:GetTall()*0.4)
								change_panel:SetPos(math.Clamp(x, 0, esclib.scrw - change_panel:GetWide()),  math.Clamp(y+self:GetTall()+5, 0, esclib.scrh - change_panel:GetTall()))

								local close_btn = change_panel:Add("esclib.button")
								close_btn:SetSize(20,20)
								close_btn:SetFont("Marlett")
								close_btn:SetButtonText("r")
								close_btn:SetPos(change_panel:GetWide()-close_btn:GetWide()-2,2)
								function close_btn:Paint(w,h)
									local hovered = self:IsHovered()
									draw.SimpleText(self:GetButtonText(),self:GetFont(), w*0.5, h*0.5, hovered and clr.button.discard or clr.frame.text, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
								end
								function close_btn:DoClick()
									cbg:Close()
								end

								local colorpicker = change_panel:Add("esclib.colorpicker")
								colorpicker:SetPos(10,10)
								colorpicker:SetColor(table.Copy(color))
								colorpicker:Dock(FILL)

								local accept_btn = change_panel:Add("esclib.button")
								accept_btn:SetSize(change_panel:GetWide()*0.12,change_panel:GetTall()*0.1)
								accept_btn:SetFont(esclib:AdaptiveFont("esclib", 16, 500))
								accept_btn:SetButtonText(esclib.addon:Translate("phrase_Save", add:GetLanguage()), addon_lang)
								accept_btn:SetPos(change_panel:GetWide()-accept_btn:GetWide()-5,change_panel:GetTall()-accept_btn:GetTall()-26)
								accept_btn:SetZPos(1)
								function accept_btn:Paint(w,h)
									local hovered = self:IsHovered()

									draw.RoundedBox(8,0,0,w,h,hovered and clr.button.accent_hover or clr.button.accent)

									esclib.draw:ShadowText(self:GetButtonText(),self:GetFont(), w*0.5, h*0.5, clr.default.white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
								end
								function accept_btn:DoClick()
									unsaved = true
									local newclr = table.Copy(colorpicker:GetColor())
									color = newclr
									addon_custom_skin.colors[color_tab_name][color_name] = newclr

									cbg:Close()
								end

								local matGrid = Material( "gui/alpha_grid.png", "nocull" )
								local clwhite = Color(255,255,255)
								function change_panel:Paint(w,h)
									esclib.draw:Material(0,0,w*0.5,h,clwhite,matGrid)
									esclib.draw:Material(w*0.5,0,w*0.5,h,clwhite,matGrid)
									local clr = colorpicker:GetColor()

									draw.RoundedBox(0,0,0,w,h*0.5,clr)
									local clr_copy = table.Copy(clr)
									clr_copy.a = 255
									draw.RoundedBox(0,0,h*0.5,w,h*0.5+2,clr_copy)
								end

								
							end
						end
					end


					local back_button = dobar:Add("esclib.button")
					back_button:SetSize(dobar:GetTall(),dobar:GetTall())
					back_button:SetX(dobar:GetWide()*0.5-back_button:GetWide()-5)
					back_button:SetButtonText(esclib.addon:Translate("phrase_ReturnDefault", add:GetLanguage()))
					back_button:SetBorderRadius(16)
					back_button:eAddHint(back_button:GetButtonText(),esclib:AdaptiveFont("esclib", 24, 500),TEXT_ALIGN_CENTER,settab)

					function back_button:Paint(w,h)
						local hovered = self:IsHovered()
						esclib.draw:MaterialCentered(w*0.5,h*0.5,h*0.3,hovered and clr.button.discard_hover or clr.button.discard, esclib:GetMaterial("revert.png"))
					end

					function back_button:DoClick()
						esclib:ConfirmWindow(esclib.addon:Translate("phrase_AreYouSure", add:GetLanguage()),esclib.addon:Translate("phrase_SureToReturn", add:GetLanguage()),function(res)
							if res then
								add:ReturnCustomSkinToDefault()
								if add.info.active_skin == "skin_custom" then
									settab:Remove()
								else
									settab.c_themepanel:Close()
								end
							end
						end)
					end

					local apply_button = dobar:Add("esclib.button")
					local font = esclib:AdaptiveFont("esclib", 24, 500)
					local text = esclib.addon:Translate("phrase_Save", add:GetLanguage())
					apply_button:SetSize(dobar:GetTall(),dobar:GetTall())
					apply_button:SetX(dobar:GetWide()*0.5+5)
					apply_button:SetButtonText(text)
					apply_button:SetBorderRadius(16)
					apply_button:eAddHint(text,font,TEXT_ALIGN_CENTER,settab)

					function apply_button:Paint(w,h)
						local hovered = self:IsHovered()
						esclib.draw:MaterialCentered(w*0.5,h*0.5,h*0.3,hovered and clr.button.accent_hover or clr.button.accent, esclib:GetMaterial("save.png"))
					end

					function apply_button:DoClick()
						unsaved = false
						save_skin()
					end

					local copy_button = dobar:Add("esclib.button")
					copy_button:SetSize(dobar:GetWide()*0.27,dobar:GetTall()*0.7)
					copy_button:SetPos(dobar:GetWide() - copy_button:GetWide() - 15, dobar:GetTall()*0.5 - copy_button:GetTall()*0.5)
					copy_button:SetBorderRadius(16)
					copy_button:SetFont(esclib:AdaptiveFont("esclib", 20, 500))
					copy_button:SetButtonText(esclib.addon:Translate("button_LoadOtherSkin", add:GetLanguage()))

					function copy_button:DoClick()
						local cbg = esclib:GenerateBGClicker()

						local pnl = cbg:Add("esclib.frame")
						pnl:SetSize(esclib.scrw*0.5,esclib.scrh*0.5)
						pnl:Center()
						pnl:SetTitle(esclib.addon:Translate("button_LoadOtherSkin", add:GetLanguage()))
						local content = pnl:GetContent()

						local scroll = content:Add("esclib.scrollpanel")
						scroll:SetSize(content:GetWide(),content:GetTall())

						local list = scroll:Add("DIconLayout")
						list:SetSize(scroll:GetWide(),scroll:GetTall())
						list:SetBorder(10)
						list:SetSpaceY(5)
						list:SetSpaceX(10)

						local font = esclib:AdaptiveFont("esclib", 24, 500)
						for name,skin in pairs(add.data.skins) do
							if (name == "skin_custom") then continue end

							local btn = list:Add("esclib.button")
							btn:SetSize(list:GetWide()*0.5-list:GetBorder()*2,50)
							function btn:Paint(w,h)
								local hovered = self:IsHovered()
								draw.RoundedBox(0,0,0,w,h,hovered and clr.button.hover or clr.button.main)
								draw.SimpleText(skin.name or name,font,50,h*0.5,clr.button.text,TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER)

								draw.RoundedBox(8,10,h*0.5-15,30,30,skin.color or clr.default.white)
							end
							function btn:DoClick()
								addon_custom_skin = table.Copy(skin)

								unsaved = true
								cbg:AlphaTo(0,esclib.addon:GetVar("animtime"),0,function()
									cbg:Remove()
									if IsValid(settab.c_themepanel) then settab.c_themepanel:Remove() end
									settab.c_themepanel = GenerateThemeEditPanel(settab,true)
									function settab.c_themepanel:OnClose(pnl,unsaved)
										settab:SetKeyBoardInputEnabled(false)
										callback("custom_skin",settab.c_themepanel)
										-- settings_on_close_any(self)
									end
								end)
							end
						end
					end

					local print_button = dobar:Add("esclib.button")
					print_button:SetSize(dobar:GetWide()*0.27,dobar:GetTall()*0.7)
					print_button:SetPos(15, dobar:GetTall()*0.5 - print_button:GetTall()*0.5)
					print_button:SetBorderRadius(16)
					print_button:SetFont(esclib:AdaptiveFont("esclib", 20, 500))
					print_button:SetButtonText(esclib.addon:Translate("button_PrintToConsole", add:GetLanguage()))

					function print_button:DoClick()
						add:PrintSkin("skin_custom")
					end

					return pnl
				end

				addon_custom_skin = table.Copy(add:GetSkinByName("skin_custom"))
				settab.c_themepanel = GenerateThemeEditPanel(settab)
				local c_themepanel = settab.c_themepanel

				-- callback("custom_skin",settab.c_themepanel)

				function c_themepanel:OnClose(pnl)
					settab:SetKeyBoardInputEnabled(false)
					callback("custom_skin",settab.c_themepanel)
					-- settings_on_close_any(self)
				end

				if IsValid(settab.c_themepanel) and IsValid(settab.c_addonpnl) then
					settab.c_addonpnl:SetAlpha(255)
					settab.c_addonpnl:AlphaTo(0,esclib.addon:GetVar("animtime"),0,function()
						if IsValid(settab.c_addonpnl) then settab.c_addonpnl:Hide() end
					end)
				end
			end, esclib:GetMaterial("wrench.png"))

			context:AddButton(esclib.addon:Translate("phrase_ReturnDefault", add:GetLanguage()),function()
				esclib:ConfirmWindow(esclib.addon:Translate("phrase_AreYouSure"),esclib.addon:Translate("phrase_SureToReturn", add:GetLanguage()),function(res)
					if res then
						add:ReturnCustomSkinToDefault()
						if add.info.active_skin == "skin_custom" then
							settab:Remove()
						end
					end
				end)
			end)

			context:AddButton(esclib.addon:Translate("button_PrintToConsole", add:GetLanguage()),function()
				add:PrintSkin("skin_custom")
			end)

		end

		function lbutton:DoClick()
			if addon_active_skin == "skin_custom" then 
				self:DoRightClick()
				return 
			end
			addon_active_skin = "skin_custom"

			callback("skin",addon_active_skin)
		end

		return scroll

	end)
end)
--PATH addons/____echat/lua/echat/vgui/echat_dmenu_option.lua:
local PANEL = {}

AccessorFunc( PANEL, "description", "Description" )
AccessorFunc( PANEL, "args", "Args" )
AccessorFunc( PANEL, "m_pMenu", "Menu" )
AccessorFunc( PANEL, "m_bChecked", "Checked" )
AccessorFunc( PANEL, "m_bCheckable", "IsCheckable" )

function PANEL:Init()
	self.clr = echat.addon:GetColors()
	
	self:SetContentAlignment( 4 )
	self:SetTextInset( 10, 0 ) -- Room for icon on left
	self:SetChecked( false )
	self:SetDescription("")
	self:SetArgs({})

	self.icon = nil
	self.text_width = ""
	self.internal_text = ""
	self.icon_color = Color(255,255,255)

	self:SetText("") --disable drawing of dlabel
	function self:SetText(text) --replace
		self.internal_text = text
		local tw, th = esclib.util:TextSize(self:GetText(),self:GetFont())
		self.text_width = tw
	end

	local old_setfont = self.SetFont
	function self:SetFont(font)
		old_setfont(self,font)
		local tw, th = esclib.util:TextSize(self:GetText(),self:GetFont())
		self.text_width = tw
	end
end

function PANEL:GetFullWide()
	local offset = 10
	if self:HasIcon() then
		offset = 25
	end
	local tw, th = esclib.util:TextSize(self:GetDescription() or "",self:GetFont())
	return self.text_width + offset + tw
end

function PANEL:GetText()
	return self.internal_text
end

function PANEL:SetSubMenu( menu )
	self.SubMenu = menu

	if ( not IsValid( self.SubMenuArrow ) ) then
		self.SubMenuArrow = vgui.Create( "DPanel", self )
		self.SubMenuArrow.Paint = function( panel, w, h ) derma.SkinHook( "Paint", "MenuRightArrow", panel, w, h ) end

	end
end

function PANEL:AddSubMenu()
	local SubMenu = DermaMenu( true, self )
	SubMenu:SetVisible( false )
	SubMenu:SetParent( self )

	self:SetSubMenu( SubMenu )

	return SubMenu
end

function PANEL:OnCursorEntered()
	if ( IsValid( self.ParentMenu ) ) then
		self.ParentMenu:OpenSubMenu( self, self.SubMenu )
		return
	end

	self:GetParent():OpenSubMenu( self, self.SubMenu )

end

function PANEL:SetIcon(material, clr)
	self.icon = material
	if clr and IsColor(clr) then self.icon_color = clr end
end
function PANEL:SetIconColor(clr)
	self.icon_color = clr
end

function PANEL:OnCursorExited()

end

function PANEL:HasIcon()
	return self.icon ~= nil
end

function PANEL:Paint( w, h )
	local parent = self:GetMenu()
	local scroll = parent:GetVBar():GetScroll()
	local y = self:GetY()

	if y-parent:GetTall() > scroll then return end

	local offset_x = 10
	if self.Highlight || self:IsHovered() then
		draw.RoundedBox(8,0,0,w,h,self.clr.main.button_hover)
	end
	if self:HasIcon() then
		offset_x = 35
		esclib.draw:MaterialCentered(h*0.6, h*0.5,h*0.3, self.icon_color, self.icon)
	end

	local font = self:GetFont()
	local text = self:GetText()
	draw.SimpleText(text, font, offset_x, h*0.5, self.clr.main.text, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)

	local args = self:GetArgs()
	if args then
		local off_x, _ = esclib.util:TextSize(text, font)
		offset_x = offset_x + off_x + 5
		for _, v in ipairs(args) do
			draw.SimpleText(v, font, offset_x, h*0.5, self.clr.main.text_gray, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
			local tw, _ = esclib.util:TextSize(v, font)
			offset_x = offset_x + tw + 5
		
		end
	end

	local desc = esclib.util:TextCut(self:GetDescription(),font,w-(offset_x+self.text_width)-25,"...")
	draw.SimpleText(desc,font, w-5, h*0.5, self.clr.main.text_gray, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
end

function PANEL:OnMousePressed( mousecode )
	self.m_MenuClicking = true
	DButton.OnMousePressed( self, mousecode )
end

function PANEL:OnMouseReleased( mousecode )
	DButton.OnMouseReleased( self, mousecode )
	if ( self.m_MenuClicking && mousecode == MOUSE_LEFT ) then
		self.m_MenuClicking = false
		CloseDermaMenus()
	end
end

function PANEL:DoRightClick()
	if ( self:GetIsCheckable() ) then
		self:ToggleCheck()
	end
end

function PANEL:DoClickInternal()
	if ( self:GetIsCheckable() ) then
		self:ToggleCheck()
	end

	if ( self.m_pMenu ) then
		self.m_pMenu:OptionSelectedInternal( self )
	end
end

function PANEL:ToggleCheck()
	self:SetChecked( not self:GetChecked() )
	self:OnChecked( self:GetChecked() )
end

function PANEL:OnChecked( b )
	
end

function PANEL:PerformLayout( w, h )
	self:SizeToContents()
	local adasize_30 = echat:AdaptiveSize(30)
	local adasize_15 = echat:AdaptiveSize(15)
	self:SetWide( self:GetWide() + adasize_30 )

	local w = math.max( self:GetParent():GetWide(), self:GetWide() )

	self:SetSize( w, adasize_30 )

	if ( IsValid( self.SubMenuArrow ) ) then

		self.SubMenuArrow:SetSize( adasize_15, adasize_15 )
		self.SubMenuArrow:CenterVertical()
		self.SubMenuArrow:AlignRight( 4 )

	end

	DButton.PerformLayout( self, w, h )
end

vgui.Register("echat.menu.option", PANEL, "DButton")
--PATH addons/____echat/lua/echat/vgui/echat_richtext.lua:
local clamp = math.Clamp
local max, min = math.max, math.min
local random = math.random

local shadow_clr = Color(0,0,0)
local mat_shadow_clr = Color(0,0,0, 200)


local function isPointInRect(x, y, rx, ry, rw, rh)
    return x >= rx and y >= ry and x < rx + rw and y < ry + rh
end

local function GetIndexFromX(text, font, x)
	local px = 0
	for i = 1, #text do
		surface.SetFont(font)
		local w = surface.GetTextSize(utf8.sub(text, i, i))
		if x >= px and x <= px + w then
		 	return i
		end
		px = px + w
	end
	return nil
end


local function GetOffsetFromX(text, font, x)
	local px = 0
	for i = 1, #text do
		surface.SetFont(font)
		local w = surface.GetTextSize(utf8.sub(text, i, i))
		if x >= px and x <= px + w then
		 	return px
		end
		px = px + w
	end
	return 0
end





-- rewrited https://github.com/Herover/fancytext
PANEL = {}
function PANEL:Init()
	local clr = echat.addon:GetColors()
	self.selection_color = clr.main.text_selection
	self.default_color = clr.main.text

	self:SetMouseInputEnabled(true)
	self.mx_start, self.my_start, self.mx_end, self.my_end = nil

	self.sepwide = 18	-- We cant run surface.GetTextSize if the panel is made too early

	self.should_draw = true
	self.lines = {}
	self.maxlines = false --false or number
	self.curwide = 0
	self.margin = 5
	self.line_space_y = echat.addon:GetVar("chat_spacey") or 1

  	self.maxwide = 0 --Max known curwide used
	
	self.fontInternal = nil
	self.font = echat:AdaptiveFont("echat", 16, 500)
	
	self.scroll = 0
	self.max_tall = 0
	
	self.pnlCanvas = vgui.Create( "Panel", self )
	-- self.pnlCanvas:SetCursor("beam")
	self.pnlCanvas.OnMousePressed = function( self, code ) self:GetParent():OnMousePressed( code ) end
	self.pnlCanvas:SetMouseInputEnabled( true )
	self.pnlCanvas.PerformLayout = function( pnl )
		self.pnlCanvas.VBar = self.vBar
		self.pnlCanvas.OnMouseReleased = function(pnl, code) self:OnMouseReleased(code) end
		-- self.pnlCanvas.Think = self.CanvasThink
		self:_PerformLayout()
		self:InvalidateParent()
	end

	-- Create the scroll bar
	self.VBar = vgui.Create( "esclib.scrollbar", self )
	self.VBar:Dock( RIGHT )
	self.VBar:SetSpeed(6)
	self.VBar:SetSoftness(0.1)
	self.VBar:SetColor(clr.main.accent)

	-- local me = self
	self.sel_start = nil 
	self.sel_end = nil
	self.selected = {}

	local selected = self.selected
	local lines = self.lines
	local sel_start = self.sel_start
	local sel_end = self.sel_end

	local spacer, ctall = surface.GetTextSize( " " )

	self.pnlCanvas.CalculateMaxTall = function(pnl)
		local liney = 0

		for l_n=1, #lines do
			local l_v = lines[l_n]

			local h = 0
			for i_n=1, #l_v do
				local i_v = l_v[i_n]
				if istable(i_v[2]) then
					h = max(h, (i_v[2].h or 0))
				end
			end

			liney = liney + h + self.line_space_y
		end

		return liney
	end

	self.pnlCanvas.Paint = function(pnl, width, height)
		table.Empty(selected)

		local has_selection = self.mx_start and self.my_start and self.mx_end and self.my_end

		if font then
			surface.SetFont( font )
		end

		local bg_col = nil
		local color = self.default_color
		local font = self.font
		local offsetX, offsetY = 0, 0
		local clickable_context = nil
		local selection_color = self.selection_color

		
		self.sepwide = spacer
		local liney = 0

		for l_n=1, #lines do
			local l_v = lines[l_n]
			local lastx = 0
			local scroll = self.VBar:GetScroll()
			local should_draw = ((liney+20 > scroll) and (liney < scroll + self:GetTall())) and self.should_draw

			local h = 0
			local w = 0

			for i_n=1, #l_v do
				local i_v = l_v[i_n]

				local is_selected, reversed = false
				if sel_start and sel_end then
					local start_line, end_line, start_pos, end_pos = sel_start.line, sel_end.line, sel_start.pos, sel_end.pos
				  
					--reverse if needed
					if start_line > end_line or (start_line == end_line and start_pos > end_pos) then
						start_line, end_line = end_line, start_line
						start_pos, end_pos = end_pos, start_pos
						reversed = true
					elseif (start_pos == end_pos) and (start_line == end_line) then
						if (sel_start.offset_i or 0) >= (sel_end.offset_i or 0) then
							reversed = true
						end
					end

					if (l_n >= start_line and l_n <= end_line) and
						((l_n ~= end_line or i_n <= end_pos) and (l_n ~= start_line or i_n >= start_pos)) then
						is_selected = true
					end
				end

				local is_startword = false
				local is_endword = false
				local text_type = i_v[1]

				if is_selected then
					is_startword = (sel_start.line == l_n and sel_start.pos == i_n)
					is_endword = (sel_end.line == l_n and sel_end.pos == i_n)
				end

				w = i_v[2].w or 0
				h = max(h, i_v[2].h or 0)


				-------------
				/// TYPES ///
				-------------
				if text_type == "text" and should_draw then

					if bg_col then
						draw.RoundedBox(0,lastx,liney,w,h,bg_col)
					end

					--draw selection
					if is_selected then
						if is_startword and is_endword then --if only one world
							if not reversed then
								local offset_start = sel_start.offset_x
								local offset_end = w - sel_end.offset_x
								draw.RoundedBox(0, lastx + offset_start, liney, w - offset_start - offset_end, h, selection_color)
							else
								local offset_start = sel_end.offset_x
								local offset_end = w - sel_start.offset_x
								draw.RoundedBox(0, lastx + offset_start, liney, w - offset_start - offset_end, h, selection_color)
							end
						elseif is_startword then
							if reversed then
								local offset = sel_start.offset_x
								draw.RoundedBox(0,lastx, liney, offset,h, selection_color)
							else
								local offset = sel_start.offset_x
								draw.RoundedBox(0,lastx+offset, liney, w-offset,h, selection_color)
							end
						elseif is_endword then
							if reversed then
								local offset = sel_end.offset_x
								draw.RoundedBox(0,lastx+offset, liney, w-offset,h, selection_color)
							else
								local offset = sel_end.offset_x
								draw.RoundedBox(0,lastx, liney, offset,h, selection_color)
							end
						else
							draw.RoundedBox(0,lastx, liney, w,h, selection_color)
						end
					end
					
					if ( (color.r + color.g + color.b)/3 > 50 ) then --draw shadow only for daaaaaaark colors
						self:PaintTextpart( i_v[2].text, font, lastx+1 + offsetX, liney+1 + offsetY, shadow_clr ) --shadow
					end
					self:PaintTextpart( i_v[2].text, font, lastx + offsetX, liney + offsetY, color)

				elseif (text_type == "image" or text_type == "emoji") and should_draw then
					if bg_col then
						draw.RoundedBox(0,lastx,liney,w,h,bg_col)
					end

					if is_selected then
						draw.RoundedBox(0,lastx, liney, w,h, selection_color)
					end

					surface.SetMaterial( i_v[2].mat )

					surface.SetDrawColor(mat_shadow_clr)
					surface.DrawTexturedRect( lastx + offsetX+1, liney + offsetY+1, i_v[2].w, i_v[2].h )

					surface.SetDrawColor(color)
					surface.DrawTexturedRect( lastx + offsetX, liney + offsetY, i_v[2].w, i_v[2].h )
				elseif text_type == "color" then
					color = i_v[2].clr
				elseif text_type == "rainbow" then
					color = HSVToColor(  ( (CurTime() * i_v[2].speed ) + i_v[2].offset) % 360, 1, 1 )
				elseif text_type == "shaking" then
					local value = i_v[2].speed
					if (value == 0) then
						offsetX = 0
						offsetY = 0
					else
						offsetX = random(-value, value)
						offsetY = random(-value, value)
					end
				elseif text_type == "font" then
					font = i_v[2]["font"]
				elseif text_type == "blank" or text_type == "gap" and should_draw then
					if bg_col and text_type ~= "gap" then
						draw.RoundedBox(0,lastx,liney,w,h,bg_col)
					end

					if is_selected and text_type ~= "gap" then
						draw.RoundedBox(0,lastx, liney, w,h, selection_color)
					end
				elseif text_type == "separator" and should_draw then
					if bg_col then
						draw.RoundedBox(0,lastx,liney,w,h,bg_col)
					end

					if is_selected then
						draw.RoundedBox(0,lastx, liney, w,h, selection_color)
					else
						draw.RoundedBox(0,lastx, liney+h*0.5 + offsetY-2, w-10, h*0.25, color)
					end

				elseif text_type == "panel" and should_draw then
					if bg_col then
						draw.RoundedBox(0,lastx,liney,w,h,bg_col)
					end

					if is_selected then
						draw.RoundedBox(0,lastx, liney, w,h, selection_color)
					end

					i_v[2].panel:SetPos( lastx, liney )
					i_v[2].panel:SetVisible( true )
				elseif text_type == "clickable" then
					if not i_v[2].fn then 
						clickable_context = nil 
					else
						clickable_context = {fn = i_v[2].fn, key=i_v[2].key}
					end
				elseif text_type == "bg_col" then
					bg_col = i_v[2].clr
				end
			


				-----------------------
				/// SELECTION LOGIC ///
				-----------------------
				-- if w and h then

				---- if you need to draw clickable_context then uncomment following:
				-- if should_draw and clickable_context and w and h then
				-- 	draw.RoundedBox(0, lastx, liney+h+2, w,1, selection_color)
				-- end
				
				if should_draw then

					local mx,my = gui.MouseX(), gui.MouseY()
					mx, my = pnl:ScreenToLocal(mx,my)

					if isPointInRect(mx, my, lastx, liney, w, h) then
						if clickable_context then
							pnl:SetCursor("hand")
							
							if self.lmb_clicked then
								clickable_context.fn(i_v)
								self.lmb_clicked = false
							end
						else
							pnl:SetCursor("beam")
						end
					end
						

					if has_selection then
						--if start point at element
						if isPointInRect(self.mx_start, self.my_start, lastx, liney, w, h) then
							if text_type == "text" then
								local ind = GetIndexFromX(i_v[2].text, font, self.mx_start-lastx)
								if not ind then continue end
								if not reversed then ind = ind - 1 end
								local subbed = utf8.sub(i_v[2].text, 1, ind)
								sel_start = {
									line=l_n,
									pos=i_n,
									offset_i=ind,
									offset_x=esclib.util.GetTextSize(subbed,font).w
								}
							else
								sel_start = {line=l_n,pos=i_n}
							end
						end

						--if end point at element
						if isPointInRect(self.mx_end, self.my_end, lastx, liney, w, h) then
							if text_type == "text" then --if text
								local ind = GetIndexFromX(i_v[2].text, font, self.mx_end-lastx)
								if not ind then continue end
								if reversed then ind = ind - 1 end
								local subbed = utf8.sub(i_v[2].text, 1, ind)
								sel_end = {
									line=l_n,
									pos=i_n,
									offset_i=ind,
									offset_x=esclib.util.GetTextSize(subbed,font).w
								}
							else
								sel_end = {line=l_n,pos=i_n}
							end
						end
					end
				end
				
				if not has_selection then
					--clear selection
					sel_start = nil
					sel_end = nil
				end

				-------------------------
				/// START / END WORDS ///
				-------------------------
				if is_selected then
					if is_startword and is_endword then
						local news_tbl = {}
						esclib:SafeMerge(news_tbl, i_v, true)
						news_tbl["data"] = {}
						news_tbl["data"]["start"] = sel_start
						news_tbl["data"]["end"] = sel_end
						news_tbl["data"]["is_start"] = true
						news_tbl["data"]["is_end"] = true
						news_tbl["data"]["reversed"] = reversed
						table.insert(selected, news_tbl)
					elseif is_startword then
						local news_tbl = {}
						esclib:SafeMerge(news_tbl, i_v, true)
						news_tbl["data"] = {}
						news_tbl["data"]["start"] = sel_start
						news_tbl["data"]["is_start"] = true
						news_tbl["data"]["reversed"] = not reversed
						table.insert(selected, news_tbl)
					elseif is_endword then
						local news_tbl = {}
						esclib:SafeMerge(news_tbl, i_v, true)
						news_tbl["data"] = {}
						news_tbl["data"]["end"] = sel_end
						news_tbl["data"]["is_end"] = true
						news_tbl["data"]["reversed"] = reversed
						table.insert(selected, news_tbl)
					else
						if istable(i_v[2]) then
							i_v[2].line = l_n
						end
						table.insert(selected, i_v)
					end
				end
				-- end

				lastx = lastx + w
				
			end

			liney = liney + h + self.line_space_y
		end
	end

end

function PANEL:DataToText(data)
	local l_v = data
	local i_v
	local result = ""
	for i_n=1, #l_v do
		i_v = l_v[i_n]
		local text_type = i_v[1]
		local value = i_v[2]
		prev_line = cur_line
		if text_type == "text" then
			if i_v["data"] ~= nil and (i_v["data"].is_start or i_v["data"].is_end) then
				local data = i_v["data"]

				if data.is_start and data.is_end then
					local is_reversed = data.reversed
					local text = value.text

					if is_reversed then
						text = utf8.sub(text, data["end"].offset_i+1, data["start"].offset_i)
					else --if not reversed
						text = utf8.sub(text, data["start"].offset_i+1, data["end"].offset_i)
					end

					result = result..text
				elseif data.is_start then
					local is_reversed = data.reversed
					local text = value.text

					data = data["start"]

					if is_reversed then
						text = utf8.sub(text, data.offset_i+1, -1)
					else
						text = utf8.sub(text, 1, data.offset_i)
					end

					result = result..text
				elseif data.is_end then
					local is_reversed = data.reversed
					local text = value.text

					data = data["end"]

					if is_reversed then
						text = utf8.sub(text, data.offset_i+1, -1)
					else
						text = utf8.sub(text, 1, data.offset_i)
					end

					result = result..text
				end
			else
				result = result..value.text
			end
		elseif text_type == "blank" then
			result = result.." "
		elseif text_type == "emoji" then
			result = result..":"..value.name..":"
		elseif text_type == "separator" or (text_type == "gap" and value.use_as_newline) then
			result = result.."\n"
		end
	end
	return result
end

function PANEL:SetMaximumLines(num)
	self.maxlines = num
end

function PANEL:GetSelectedText()
	if table.IsEmpty(self.selected) then return end
	return self:DataToText(self.selected)
end

function PANEL:GetText()
	local result = ""
	local l_n, l_v
	for l_n=1, #self.lines do
		l_v = self.lines[l_n]
		result = result .. self:DataToText(l_v)
	end
	return result
end

function PANEL:CopySelectedToClipboard(notify)
	local text = self:GetSelectedText()
	if text then
		SetClipboardText(text)
		self:ClearSelection()
		
		if notification and notify then
			notification.AddLegacy(echat.addon:Translate("copied_to_clipboard"), NOTIFY_GENERIC, 3)
			chat.PlaySound()
		end
	end
end

function PANEL:OnKeyCodePressed(code)
	if (input.IsKeyDown(KEY_LCONTROL) or input.IsKeyDown(KEY_RCONTROL)) and (code == KEY_C) then
		self:CopySelectedToClipboard(true)
	end
end

function PANEL:UpdateCanvasTall()
	local pnl = self:GetCanvas()
	local liney = pnl:CalculateMaxTall()
	if liney > self.max_tall then
		self.max_tall = liney
		pnl:SetTall(liney)
	end
end

--[[---------------------------------------------------------
   Name: SizeToContents
-----------------------------------------------------------]]
function PANEL:SizeToContents()
	self:SetSize( self.pnlCanvas:GetSize() )
end

function PANEL:GetVBar()
	return self.VBar
end

function PANEL:GetCanvas()
	return self.pnlCanvas
end

function PANEL:InnerWidth()

	return self:GetCanvas():GetWide()

end

function PANEL:GetContentWide()
  return self.maxwide
end

function PANEL:SetW(w)
  self:SetWide(w)
  self:GetCanvas():SetWide(w)
end

--[[---------------------------------------------------------
   Name: Rebuild
-----------------------------------------------------------]]
function PANEL:Rebuild()

	--self:GetCanvas():SizeToChildren( false, true )
		
	-- Although this behaviour isn't exactly implied, center vertically too
	if ( self.m_bNoSizing && self:GetCanvas():GetTall() < self:GetTall() ) then
		self:GetCanvas():SetPos( 0, (self:GetTall()-self:GetCanvas():GetTall()) * 0.5 )
	end
	
end

--[[---------------------------------------------------------
   Name: PerformLayout
-----------------------------------------------------------]]
function PANEL:_PerformLayout()

	self:UpdateCanvasTall()

	self.scroll = self.VBar:GetScroll()
	local vbarvisible = self.VBar:IsVisible()
	
	if self.PerformLayout then
		self:PerformLayout()
	end

	local Wide = self:GetWide()
	local YPos = 0

	self.pnlCanvas:SetTall( self.max_tall )

	
	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()
	self.pnlCanvas:SetWide( Wide )
	
	self.VBar:SetScroll( self.scroll )
	self.VBar:SetVisible( vbarvisible )
end

--[[---------------------------------------------------------
   Name: OnMouseWheeled
-----------------------------------------------------------]]
function PANEL:OnMouseWheeled( dlta )
	if not self.VBar:IsEnabled() then return end
	return self.VBar:OnMouseWheeled( dlta )
end

--[[---------------------------------------------------------
   Name: OnVScroll
-----------------------------------------------------------]]
function PANEL:OnVScroll( iOffset )
	if self.max_tall < self:GetTall() then
		self.pnlCanvas:SetPos( 0, self:GetTall()-self.max_tall )
	else
		self.pnlCanvas:SetPos( 0, iOffset )
	end
	self.scroll = -iOffset
end

function PANEL:Clear()

	return self.pnlCanvas:Clear()

end

function PANEL:GotoTextEnd()
	self.VBar:SetScroll( self.pnlCanvas:GetTall()-self:GetTall() )
	self.scroll = self.VBar:GetScroll()
end

function PANEL:SetVerticalScrollbarEnabled( bool )
	self.VBar:SetEnabled( bool )
	self.VBar:SetVisible( bool )
end

function PANEL:SetFontInternal( font )
	self:InsertFontChange( font )
	self.fontInternal = font
end






---------------------------
/// ADDING CUSTOM ITEMS ///
---------------------------
function PANEL:AppendItem( item )
	if #self.lines == 0 then
		table.insert(self.lines, {})
	end

	if type(item) == "string" then
		return self:AppendText( item )
	end
	local wide = istable(item[2]) and item[2].w or 0
	if self.curwide + wide < self:GetWide() - self.margin*2 then
		--If above passes, theres enough room to add another word
		self.curwide = self.curwide + wide
		table.insert( self.lines[#self.lines], item )
		self.maxwide = max(self.curwide, self.maxwide)
	else
		--Otherwise add another line before inserting part
		local spacing_line = {"gap", {w = self:GetWide() - (self.curwide+self.margin*2+5), h = 4, use_as_newline = true}}
		table.insert(self.lines[#self.lines], spacing_line)

		table.insert(self.lines, {})
		self.maxwide = max(self.curwide, self.maxwide)
		self.curwide = wide
		table.insert( self.lines[#self.lines], item )
	end

	if self.maxlines and #self.lines > self.maxlines then
		table.remove( self.lines, 1 )
	end
	
	self:_PerformLayout()
end

function PANEL:AppendText( text )
    surface.SetFont( self.fontInternal and self.fontInternal or self.font )
	
	local function appendPart(part)
		local wide, tall = surface.GetTextSize(part)
		if part and (part ~= "") then
			self:AppendItem( {"text", {text = part, w = wide, h = tall}} )
		end
	end

	local function processLine(line)
		local parts = {}
		local currentPart = ""
		for i = 1, #line do
			local char = line:sub(i, i)
			local testPart = currentPart .. char
			local wide, _ = surface.GetTextSize(testPart)

			if char == " " then
				table.insert(parts, currentPart)
				currentPart = char
				continue
			end

			if (wide) <= (self.pnlCanvas:GetWide()-5) then
				currentPart = testPart
			else
				table.insert(parts, currentPart)
				currentPart = char
			end
		end
		table.insert(parts, currentPart)
		return parts
	end

	local etext = string.Explode("\n", text) -- Split newlines in sections

	for l, line in pairs(etext) do -- Loop lines
		local lineParts = processLine(line)

		for n, part in pairs(lineParts) do
			appendPart(part)
		end

		if l ~= #etext then -- Begin new line, except if it's the last line
			self:AppendEmptyToEnd(nil, false) --bool add \n to copied text
		end
	end

	self.maxwide = max(self.curwide, self.maxwide)
	self:_PerformLayout()
end


function PANEL:AppendBlank(width)
	if not width then width = 4 end

	if self.fontInternal then
		surface.SetFont( self.fontInternal )
	else
		surface.SetFont( self.font )
	end
	local wide, tall = surface.GetTextSize( " " )

	self:AppendItem( {"blank", {w = width, h = tall}} )
end

function PANEL:AppendSeparator(height)
	if not height then height = 10 end
	self:AppendItem( {"separator", {w = self:GetWide(), h = height}} )
end

function PANEL:AppendEmptyLine(height)
	if not height then height = 4 end
	self:AppendItem( {"gap", {w = self:GetWide() - self.margin*2-5, h = height}} ) --gap is blank but with no selection
end

function PANEL:AppendEmptyToEnd(height, use_as_newline) --add empty space to the end of current width
	if not height then height = 4 end
	self:AppendItem( {"gap", {w = self:GetWide() - (self.curwide+self.margin*2+5), h = height, use_as_newline = use_as_newline}} ) --gap is blank but with no selection
end

function PANEL:AppendImage( w,h,mat )
	self:AppendItem( {"image", {w=w, h=h, mat=mat}} )
end

--echat functionality
function PANEL:AppendEmoji( name )
	local emojies = echat:GetEmojiTable()
	if not emojies[name] then
		self:AppendText(":"..name..":") 
		return 
	end

	local size = draw.GetFontHeight(self.font)
	self:AppendItem( {"emoji", {mat = emojies[name], name=name, w = size, h = size}} )
end

function PANEL:AppendPanel( pnl )
	if not IsValid(pnl) then return end
	pnl:SetParent( self.pnlCanvas )
	self.pnlCanvas:Add( pnl )
	self:AppendItem( {"panel", {w=pnl:GetWide(),h=pnl:GetTall(), panel=pnl}} )
end

function PANEL:InsertColorChange( r, g, b, a )
	local clr = color_white
	local clr = IsColor(r) and r or Color(r,g,b,a)

	self:AppendItem( {"color", {["clr"]= Color(r, g, b, a), ["w"] = 0, ["h"] = 0}} )
end

function PANEL:InsertBackgroundColorChange( r, g, b, a )
	if not r then
		self:AppendItem( {"bg_col", {["clr"]=nil, ["w"] = 0, ["h"] = 0}} )
		return
	end

	local clr = IsColor(r) and r or Color(r,g,b,a)
	self:AppendItem( {"bg_col", {["clr"]= clr, ["w"] = 0, ["h"] = 0}} )
end

--KEY: ONLY MOUSE_LEFT 
function PANEL:InsertClickable(fun, key)
	local key = key or MOUSE_LEFT
	if not isfunction(fun) then
		self:AppendItem( {"clickable", {["fn"]=nil, ["key"]=key, ["w"] = 0, ["h"] = 0}} )
		return
	end
	self:AppendItem( {"clickable", {["fn"]=fun, ["key"]=key, ["w"] = 0, ["h"] = 0}} )
end

--speed, offset
function PANEL:InsertRainbowEffect( speed, offset )
	local speed = speed or 75
	if not offset then
		offset = 10--math.random(0,255) --if you want to randomize different messages
	end
	
	self:AppendItem( {"rainbow", {speed=speed, offset = offset, w = 0, h = 0}} )
end

--expensive effect
function PANEL:AppendRainbowText( text, speed )
	local speed = speed or 100
	for i = 1, #text do
		self:InsertRainbowEffect(speed, -10*i)
		self:AppendText(text[i], true)
    end
end

function PANEL:InsertShakingEffect(speed) 
	local speed = speed or 0.5

	self:AppendItem( {"shaking", {["speed"]=speed, ["w"] = 0, ["h"] = 0}} )
end

function PANEL:InsertFontChange( font )
	surface.SetFont( font )
	self.font = font
	self:AppendItem( {"font", {["font"]=font, ["w"] = 0, ["h"] = 0}} )
end

function PANEL:GetFont()
	return self.font
end

function PANEL:Paint( w, h ) --background painting
	--for override
end

function PANEL:PaintTextpart( text, font, x, y, colour )
	surface.SetFont( font )
	surface.SetTextPos( x, y )
	surface.SetTextColor( colour )
	surface.DrawText( text )
	local px, py = surface.GetTextPos()
	return px-x, py-y
end

function PANEL:MouseAtPanel()
	local screenX, screenY = self:LocalToScreen( 0, 0 )
	local w,h = self:GetSize()
	local mx, my = gui.MousePos()

	return ((mx > screenX) && (mx < (screenX+w))) && ((my > screenY) && (my < (screenY+h)))
end


function PANEL:DoRightClick()
	--for override
end

function PANEL:OnMousePressed(code)
	if (code == MOUSE_RIGHT) then
		self:DoRightClick()
	end

	if self:MouseAtPanel() and (code == MOUSE_LEFT) then
		self:RequestFocus()
		self.selecting = true

		local scroll = self.VBar:GetScroll()
		local x,y = self:ScreenToLocal(gui.MouseX(),gui.MouseY())
		if self.max_tall < self:GetTall() then
			y = -(self:GetTall()- self.max_tall-y)
		else
			y = y + scroll
		end

		self.sel_start = nil
		self.sel_end = nil

		self.mx_start = x
		self.my_start = y
	end
end

--just drop all vars
function PANEL:ClearSelection()
	self.sel_start = nil
	self.sel_end = nil
	self.mx_start = nil
	self.my_start = nil
	self.mx_end = nil
	self.my_end = nil
end

function PANEL:OnMouseReleased(code)
	self.lmb_clicked = (code == MOUSE_LEFT)
	timer.Simple(0, function()
		self.lmb_clicked = false
	end)
	if self.selecting then self.selecting = false end
end

function PANEL:Think()
	if self.selecting then
		if not input.IsMouseDown(MOUSE_LEFT) and not self:MouseAtPanel() then
			self.selecting = false
			return
		end

		local scroll = self.VBar:GetScroll()
		local x,y = self:ScreenToLocal(gui.MouseX(),gui.MouseY())
		if self.max_tall < self:GetTall() then
			y = -(self:GetTall()- self.max_tall-y)
		else
			y = y + scroll
		end

		self.mx_end = x
		self.my_end = y

		if input.IsMouseDown(MOUSE_LEFT) then
			local screenX, screenY = self:LocalToScreen( 0, 0 )
			local w,h = self:GetSize()
			local mx, my = gui.MousePos()

			if ((mx > screenX) && (mx < (screenX+w))) && ((my < (screenY+10))) then
				local strenght = clamp(-0.5 * ((screenY+10) / (my or 1)), -1, 0)
				self.VBar:AddScroll( strenght )
			end

			if ((mx > screenX) && (mx < (screenX+w))) && ((my > (screenY+h-10))) then
				local strenght = clamp(0.7 * ((my or 1) / (screenY+h)), 0, 1)
				self.VBar:AddScroll( strenght )
			end
		end
	end
end

function PANEL:OnFocusChanged(gained)
	if not gained then
		self:ClearSelection()
	end
end


vgui.Register('echat.richtext', PANEL)
--PATH addons/____echat/lua/echat/core/tools/auto_complete.lua:
-----------------------------
/// AUTO COMPLETE HELPERS ///
-----------------------------
--suggestions must return as {}
--offset is the number by which the command will be shifted. (Useful if you are replacing some character with your sentence.
--example: return {{text="hello" , offset = 0, type = "anything here"}, {text="hello2" , offset = 0, type = "anything here"}}

echat.auto_complete = echat.auto_complete or {}

function echat:AddAutoComplete(uid, func)
	if echat.config.autocompleters[uid] ~= false then --nil == true. except only false
		echat.auto_complete[uid] = func
	end
end

--example: echat:AddCommandHelper("/ooc") --single command
function echat:AddCommandHelper(command_text)
	local fn = function(text)
		if string.find(text, "/", 1, true) ~= 1 then return nil end
    	if (string.find(command_text, text, 1, true) ~= nil) && not string.find(text, command_text, 1, true) then
			return {{text=command_text}}
		end
		return nil
	end
	self:AddAutoComplete(command_text,fn)
end
--PATH addons/____echat/lua/echat/core/complete_helpers.lua:

------------------------------
--# PLAYER NICKNAME HELPER #--
------------------------------
--use: @player_nickname
echat:AddAutoComplete("PlayerHelper", function(text, word)
	if not string.find(word, "@", 1, true) then return end

	word = string.sub(string.lower(word),2,-1)
	local checking = word:len() > 0

	local suggestions = {}
	for k, ply in ipairs(player.GetAll()) do
		local new_text = (ply:Nick() or "unknown")
		if checking then
			if not string.find(string.lower(new_text), word, 1, "true") then continue end
		end

		table.insert(suggestions, {type = "player", offset=-1, text=new_text})
	end
	return suggestions
end)



-------------
--# EMOJI #--
-------------
echat:AddAutoComplete("EmojiHelper", function(text, word)
	if not echat.config.emojies then return end
	if word[1] then
		if word[1] ~= ":" then return nil end
	end

	local suggestions = {}
	
	for i, name in ipairs(echat:GetEmojiList()) do
		
		local command_text = string.Trim(":"..name..":") --example
		if (string.find(command_text, word, 1, true) ~= nil) then
			table.insert(suggestions, {type="command", icon=echat:GetEmoji(name), offset=0, text=command_text})
		end

	end

	return suggestions
end)



---------------
--# PARSERS #--
---------------
echat:AddAutoComplete("ParserHelper", function(text, word)
	if word[1] then
		if word[1] ~= echat.COMMAND_BRACKET_1 then return nil end
	end

	local suggestions = {}
	local ply = LocalPlayer()

	for i, name in ipairs(echat:GetParserList()) do
		local parser = echat:GetParser(name)

		if isfunction(parser.custom_check) then
			if not parser.custom_check(ply, parser) then --custom check definition
				continue
			end
		end
		
		local example = parser.example or name
		if istable(example) and table.IsSequential(example) then
			for k,v in ipairs(example) do
				local ex = example[k] or name
				local command_text = string.Trim(echat.COMMAND_BRACKET_1..(ex)..echat.COMMAND_BRACKET_2) --example
				if (string.find(command_text, word, 1, true) ~= nil) then
					table.insert(suggestions, {type="command", icon=parser.icon, offset=0, text=command_text, description = parser.description})
				end
			end
		else
			local command_text = string.Trim(echat.COMMAND_BRACKET_1..(example)..echat.COMMAND_BRACKET_2) --example
			if (string.find(command_text, word, 1, true) ~= nil) then
				table.insert(suggestions, {type="command", offset=0, text=command_text, description = parser.description})
			end
		end

	end

	return suggestions
end)


echat:AddAutoComplete("CustomCommands",function(text, word)
	local suggestions = {}
	for cmd_name, values in pairs(echat.config.custom_commands) do
		local command_text = string.Trim(cmd_name)
		if (string.find(command_text, text, 1, true) ~= nil) then
			table.insert(suggestions, {
				type="command", 
				offset=0, 
				text=command_text, 
				args=values["args"],
				description=values["description"]
			})
		end
	end
	return suggestions
end)



-------------------------------
--# DARKRP DEFAULT COMMANDS #--
-------------------------------
-- /command
if DarkRP then
	echat:AddAutoComplete("DarkRP_Commands",function(text, word)
		if not string.StartsWith(text or "", "/") then return end

		local suggestions = {}
		for k,v in ipairs(rp.Chat.Commands) do
			local command_text = string.Trim("/"..v.command)
			if not v.check and true or v.check(LocalPlayer()) then
				if (string.find(command_text, text, 1, true) ~= nil) then
					table.insert(suggestions, {type="command", offset=0, text=command_text,description=v.description})
				end
			end
		end
		return suggestions
	end)
end


-------------------
--# SAM SUPPORT #--
-------------------
if sam and sam.command then
	local commands = sam.command.get_commands()

    local function getSamCommandsAutoComplete(text, word)
		if not string.StartsWith(text or "", "!") then return end

        local ply = LocalPlayer()
        local suggestions = {}

        for _, v in ipairs(commands) do

            if not v.name or not sam.ranks.has_permission(ply:GetUserGroup(), v.permission) then
                continue
            end

            local commandText = string.Trim("!" .. v.name)

            if string.find(commandText, text, 1, true) then
                local args

                if v.args then
                    args = {}

                    for _, arg in ipairs(v.args) do
                        table.insert(args, string.format("<%s>", arg.hint or arg.name))
                    end
                end

                table.insert(suggestions, {
                    type = "command",
                    offset = 0,
                    text = commandText,
                    args = args,
                    description = v.help
                })
            end
        end

        return suggestions
    end

    echat:AddAutoComplete("SAM_Commands", getSamCommandsAutoComplete)
end

----------------------
--# sAdmin support #--
----------------------
if sAdmin then
	local sadmin_prefixes = {"!", "/"}
	local commands = sAdmin.commands

	local function getsAdminAutoComplete(text, word)
		local cont = false
		local cmd_pref = "!"

		for _, pref in ipairs(sadmin_prefixes) do
			if string.StartsWith(text or "", pref) then 
				cont = true
				cmd_pref = pref
				break
			end
		end
		if not cont then return end

        local ply = LocalPlayer()
        local suggestions = {}

        for _, v in pairs(commands) do

            if not v.name then
                continue
            end

            local commandText = cmd_pref..v.name

            if string.find(commandText, text, 1, true) then
                local args

                if v.inputs then
                    args = {}

                    for _, arg in ipairs(v.inputs) do
						if not arg[2] then continue end
                        table.insert(args, string.format("<%s>", arg[2]))
                    end
                end

                table.insert(suggestions, {
                    type = "command",
                    offset = 0,
                    text = commandText,
                    args = args,
                    description = v.help
                })
            end
        end

        return suggestions
    end

	echat:AddAutoComplete("sAdmin_Commands", getsAdminAutoComplete)
end

-------------------
--# ULX SUPPORT #--
-------------------
if ulx then
	local cmds = {}
	local prefix = "!"

	for _,category in pairs(ulx.cmdsByCategory) do
		for _,cmd in ipairs(category) do
			local desc = cmd.helpStr

			local args = {}
			for _, v in ipairs(cmd.args or {}) do
				if not v.hint then continue end
				table.insert(args,  "<"..tostring(v.hint)..">")
			end

			for _, v in ipairs(cmd.say_cmd or {}) do
				if string.len(v) < 2 then continue end
				if v[1] ~= prefix then continue end
				table.insert(cmds, {
					["desc"] = desc, 
					["cmd"] = v,
					["args"] = args,
				})
			end
		end
	end

	local function getsULXAutoComplete(text, word)
		if text[1] ~= prefix then return end

        local ply = LocalPlayer()
        local suggestions = {}

        for _, v in pairs(cmds) do

            local commandText = v.cmd

            if string.find(commandText, text, 1, true) then
                table.insert(suggestions, {
                    type = "command",
                    offset = 0,
                    text = commandText,
                    args = v.args,
                    description = v.desc
                })
            end
        end

        return suggestions
    end

	echat:AddAutoComplete("ULX_Commands", getsULXAutoComplete)
end
--PATH addons/____inventory/lua/itemstore/items/base_entity.lua:
ITEM.Name = "Entity Item Base"
ITEM.Model = "models/error.mdl"

function ITEM:Load()
	self:RegisterPickup( self.Class )
end

function ITEM:CreateEntity( pos )
	local ent = ents.Create( self.Class )
	ent:SetPos( pos )
	self:LoadData( ent )
	ent:Spawn()

	return ent
end

function ITEM:SaveData()
end

function ITEM:LoadData( )
end
--PATH addons/____inventory/lua/itemstore/items/spawned_ammo.lua:
ITEM.Name = itemstore.Translate( "ammo_name" )
ITEM.Description = itemstore.Translate( "ammo_desc" )
ITEM.HighlightColor = itemstore.config.HighlightColours.Ammo
ITEM.Stackable = true
ITEM.DropStack = true
ITEM.Base = "base_rp"

function ITEM:GetName()
	if SERVER then
		return self:GetData( "Name", self.Name )
	else
		return self:GetData( "Name", language.GetPhrase( self:GetData( "AmmoType" ) .. "_ammo" )  )
	end
end

function ITEM:Use( pl )
	pl:GiveAmmo( self:GetAmount(), self:GetData( "AmmoType" ) )
	return true
end

function ITEM:CanMerge( item )
	return self.Stackable and self:GetClass() == item:GetClass() and
		self:GetData( "AmmoType" ) == item:GetData( "AmmoType" )
end

function ITEM:SaveData( ent )
	self:SetModel( ent:GetModel() )
	self:SetAmount( ent.amountGiven )	
	self:SetData( "AmmoType", ent.ammoType )
end

function ITEM:LoadData( ent )
	ent:SetModel( self:GetModel() )
	ent.amountGiven = self:GetAmount()	
	ent.ammoType = self:GetData( "AmmoType" )
end

--PATH addons/____inventory/lua/itemstore/items/spawned_money.lua:
ITEM.Name = itemstore.Translate( "money_name" )
ITEM.Description = itemstore.Translate( "money_desc" )
ITEM.Model = "models/props/cs_assault/money.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Money
ITEM.Base = "base_rp"
ITEM.Stackable = true
ITEM.DropStack = true
ITEM.MaxStack = math.huge

function ITEM:FormatAmount()
	return rp.FormatMoney(self:GetAmount())
end

function ITEM:Use( pl )
	itemstore.gamemodes.GiveMoney( pl, self:GetAmount() )
	return true
end

function ITEM:SaveData( ent )
	self:SetAmount( ent:GetNWInt('GetMoney') )
end

function ITEM:LoadData( ent )
	ent:SetNWInt('GetMoney',self:GetAmount())
end
