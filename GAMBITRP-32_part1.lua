--[[
███████╗██╗░░██╗███████╗░█████╗░██╗░░██╗░█████╗░░█████╗░██╗░░██╗░░░░█████╗░░█████╗░
██╔════╝╚██╗██╔╝██╔════╝██╔══██╗██║░░██║██╔══██╗██╔══██╗██║░██╔╝░░░██╔══██╗██╔══██╗
█████╗░░░╚███╔╝░█████╗░░██║░░╚═╝███████║███████║██║░░╚═╝█████═╝░░░░██║░░╚═╝██║░░╚═╝
██╔══╝░░░██╔██╗░██╔══╝░░██║░░██╗██╔══██║██╔══██║██║░░██╗██╔═██╗░░░░██║░░██╗██║░░██╗
███████╗██╔╝╚██╗███████╗╚█████╔╝██║░░██║██║░░██║╚█████╔╝██║░╚██╗██╗╚█████╔╝╚█████╔╝
╚══════╝╚═╝░░╚═╝╚══════╝░╚════╝░╚═╝░░╚═╝╚═╝░░╚═╝░╚════╝░╚═╝░░╚═╝╚═╝░╚════╝░░╚════╝░

HOSTNAME: ⋙ GAMBITRP ╽ ПОДАРКИ ╽ FREE VIP ⋘
IP: 212.22.93.215:27015
GAMEMODE: darkrp
MAP: rp_bangclaw_
MAXPLAYERS: 127
ALL SERVER NETS: Undo_Undone, Undo_AddUndo, Undo_FireUndo, umsg.SendLua, umsg.UnPooled, properties, drive_base, drive_noclip, editvariable, player_default, PlayerKilledNPC, NPCKilledNPC, PlayerKilled, PlayerKilledSelf, PlayerKilledByPlayer, DeathNoticeEvent, SH_ACC_READY, SH_ACC_PURCHASE, SH_ACC_SELL, SH_ACC_MENU, SH_ACC_EQUIP, SH_ACC_EQUIPS, SH_ACC_CHANGE, SH_ACC_INV, SH_ACC_NOTIFY, SH_ACC_ADJUST, SH_ACC_ADJUST_RESET, SH_ACC_REQUEST, E', FAM.OpenMenu, FAM.SendMessage, FAM.GetPlayerStatistik, FAM.GetPlayerStatistik_SID, FAM.GiveWarn, FAM.RemoveWarn, FAM.InGameSettings, FAM.RequestGameSettings, FAM.RequestPlayersStatistik, FAM.Search, FAM.ChangeVacationStatus, FAM.MysqlSetup, FAM.MysqlSetup_Menu, FProfile_startProfiling, FProfile_stopProfiling, FProfile_focusObj, FProfile_getSource, FProfile_printFunction, FProfile_fullModelUpdate, FProfile_focusUpdate, FProfile_unsubscribe, nw.PlayerSync, nw.NilEntityVar, nw.NilPlayerVar, nw.EntityRemoved, nw.PlayerRemoved, nw_rp.ReportClaimed, nw_rp.LastReport, freports.reports_statistics.search, freports.reports_statistics.load_more, rp.chat.SendMessage, GProfiler_RequestFunctionSource, GProfiler_ConCommands_ToggleServerProfile, GProfiler_ConCommands_ServerProfileStatus, GProfiler_ConCommands_CommandList, GProfiler_ConCommands_SendData, GProfiler_Functions_ToggleServerProfile, GProfiler_Functions_ServerProfileStatus, GProfiler_Functions_SendData, GProfiler_Hooks_ToggleServerProfile, GProfiler_Hooks_ServerProfileStatus, GProfiler_Hooks_SendData, GProfiler_Hooks_HookTbl, GProfiler_Hooks_RemoveHook, GProfiler_Net_ToggleServerProfile, GProfiler_Net_ServerProfileStatus, GProfiler_Net_SendData, GProfiler_Net_ReceiverTbl, GProfiler_NetVars_ToggleServerProfile, GProfiler_NetVars_ServerProfileStatus, GProfiler_NetVars_SendData, GProfiler_Timers_ToggleServerProfile, GProfiler_Timers_ServerProfileStatus, GProfiler_Timers_SendData, HFM_Sync, PlayerDisplayChat, nw_IsTyping, RealBike_Adapt_bone, mLib_StateSync, NetStreamRequest, NetStreamDownload, GetTotalTime, GetBanTable, ChangeValueSelect, GetAllBan, BP:QMenu, encbp.bg.take, encbp.bg.takeprem, encbp.bp.register, BPAcceptGroup, BPAcceptGroupBool, AutoChatMessage, ML_MapCleanHack_git@871fb36d_51577, Metadata::Sync, Cuffs_GagPlayer, Cuffs_BlindPlayer, Cuffs_FreePlayer, Cuffs_DragPlayer, Cuffs_TiePlayers, Cuffs_UntiePlayers, URPC, ulib_repWriteCvar, ulib_repChangeCvar, Unstuck.Message, Unstuck.Debug, VC_PlayerReady, wOS.Fortnite.StartTauntCamera, wOS.Fortnite.CancelEmote, wOS.Fortnite.WeaponSelect, zclib_Player_Send, zclib_Player_Initialize, zclib.Entity.Print, zclib.Entity.GoTo, zclib.Entity.CleanUp, zclib.Notify.Create, zclib_snapshoter_Delete, zclib_Data_Update, zclib_Zone_Send, zclib_Zone_Show, zclib_Zone_Hide, zclib_Zone_ShowSingle, zclib_Inventory_Drag, zclib_Inventory_Sync, zclib_Inventory_DropToFloor, zclib_Inventory_Throw, zclib_Inventory_Destroy, zclib_Inventory_Use, zclib_Inventory_Equipt, zclib_Inventory_Collect, zclib_Inventory_CustomOption, AdvDupe2_SendGhosts, AdvDupe2_AddGhost, AdvDupe2_SetDupeInfo, AdvDupe2_ReceiveFile, AdvDupe2_CanAutoSave, BRS.Net.SendConfig, BRS.Net.RequestConfig, BRS.Net.UpdateConfig, BRS.Net.ProfileAdminRequest, BRS.Net.ProfileAdminSend, BRS.Net.OpenBrickServer, BRS.Net.SendNetworkReady, BRS.Net.SendServerTime, BRS.Net.SendTopNotification, BRS.Net.SendNotification, BRS.Net.SendChatNotification, BRS.Net.UseMenuNPC, BRS.Net.AddGangAdminMail, BRS.Net.RequestAdminGangs, BRS.Net.SendAdminGangTables, BRS.Net.RequestAdminGangData, BRS.Net.SendAdminGangData, BRS.Net.AdminGangCMD, BRS.Net.SetGangTableValue, BRS.Net.SetGangTableValues, BRS.Net.SetGangTable, BRS.Net.SetGangNameTable, BRS.Net.UpdateGangNameTable, BRS.Net.GetLastTransaction, BRS.Net.SendGangInbox, BRS.Net.SendGangInboxEntry, BRS.Net.RemoveGangInboxEntry, BRS.Net.DeleteGangInboxEntry, BRS.Net.OpenGangMenu, BRS.Net.CreateGang, BRS.Net.SaveGangRoles, BRS.Net.GangSetRank, BRS.Net.SaveGangSettings, BRS.Net.GangKick, BRS.Net.GangInvite, BRS.Net.GangInviteSend, BRS.Net.GangInviteAccept, BRS.Net.GangDepositMoney, BRS.Net.GangWithdrawMoney, BRS.Net.GangDisband, BRS.Net.GangTransfer, BRS.Net.GangLeave, BRS.Net.GangNetworkMessage, BRS.Net.GangSendMessage, BRS.Net.RequestPlyGangInfo, BRS.Net.SendPlyGangInfo, BRS.Net.GangUpgrade, BRS.Net.SetGangID, BRS.Net.GangAchievementClaim, BRS.Net.SendGangAssociations, BRS.Net.SendGangAssociationValue, BRS.Net.RequestAssociationGangs, BRS.Net.SendAssociationGangTables, BRS.Net.RequestGangAssociation, BRS.Net.AcceptGangAssociation, BRS.Net.DissolveGangAssociation, BRS.Net.SendGangLeaderboardTables, BRS.Net.RequestGangLeaderboards, BRS.Net.SendTerritoryGangTables, BRS.Net.SendGangTerritoriesTable, BRS.Net.SendGangTerritoriesValue, BRS.Net.SendTerritoryGangValues, BRS.Net.RequestTerritoryGangs, BRS.Net.SetCurrencies, BRS.Net.Admin_AddCurrency, BRS.Net.Admin_SetCurrency, grp.ToggleChat, grp.DeToggleChat, grp.ChatPrint, grp.ChatPrintTbl, rHit.Open.Placement, rHit.Open.Confirmation, rHit.Open.CurrentHits, rHit.Send.Message, rHit.Send.ScreenMessage, rHit.Open.Bonus, rHit.Send.t, rHit.Send.a, rHit.Bonus.Accept, rHit.Confirm.Placement, rHit.Config.OrderHit, rHit.Confirm.Rejection, rHit.Open.Phonebox, rHit.Confirm.PhoneAccept, SendAddAdminMessgae, BM2.OpenTerminal, BM2.Client.TerminalPrint, BM2.Command.Mining, BM2.Command.SellBitcoins, BM2.Command.Upgrade, BM2.Command.Eject, BuyMoney, rp.CasinoOwner, rp.gambling.Profit, rp.gambling.Loss, FishVarChange, FishConfigVarChange, FishConfigUpdate, FishAskConfig, FishConfigMenu, giveskin, removeskin, gambitsmodee, scalegolovi, glaza, aimbot, zaika, glushak, duels::net::invite, duels::net::invite::bool, VKApi, STeam, OpenRewMenu, TelegramVerifyCode, TelegramVerifyResponse, DiscordVerifyCode, NeuroBanReason, NeuroBanReason2, NeuroBan Unban, NeuroBan Buyed, weaponsmenugetweps, weaponsmenuchangevar, ppp_info_send, Check_Pay, ray shopMenu, ray purchaseItem, ub_purchase, BeginSpin, StartClientSpinAnimation, SpinEnded, ub_equipweapon, ub_deleteItem, ub_spawnEntity, ub_giftitem, ub_admingiveitems, AcceptGroup, AcceptGroupBool, Vape, VapeArm, VapeTalking, DragonVapeIgnite, GModSave, player_sandbox, drive_sandbox, GotArrested, OnChangedTeam, FSpectate, FSpectateTarget, DarkRP_UpdateDoorData, DarkRP_RemoveDoorData, DarkRP_RemoveDoorVar, DarkRP_AllDoorData, DarkRP_databaseCheckMessage, DarkRP_simplerrError, player_darkrp, _Notify, DarkRP_Chat, DarkRP_preferredjobmodels, DarkRP_preferredjobmodel, DarkRP_InitializeVars, DarkRP_PlayerVar, DarkRP_PlayerVarRemoval, DarkRP_DarkRPVarDisconnect, _DarkRP_CustomAnim, gmphone, SelectAnimation, SitAnywhere, checkach, cosmetrics.WeaponSkin, ColoredMessage, ClearLagsDed, rod_Fishing, rod_Pull, rod_End, rod_Game, rod_phys_Fishing, rod_phys_Pull, rod_phys_End, FishPoleStrength, BRS.Net.ToolTerritoryPlacer, RemovePropShadow, AddPropShadow, UpdateStateShodows, KeypadCracker_Hold, KeypadCracker_Sparks, SWB_FIREMODE, anim_keys, KeysMenu, cigaArm, cigaTalking, cigaTankColor, cigaMessage, FidgetFlick, FidgetFlip, FidgetUpdateCustomColor, ShouldRoll, ShouldSlide, nw_IsHolding, nw_Jumps, VapeUpdateCustomColor, VapeTankColor, VapeMessage, takeammo, copsMenu, rp.EntityUse, BRS.Net.GangPrinterIncomeTrackRequest, BRS.Net.GangPrinterIncomeTrackSend, BRS.Net.GangPrinterToggle, BRS.Net.GangPrinterWithdraw, BRS.Net.GangPrinterPlace, BRS.Net.GangPrinterPurchase, BRS.Net.GangPrinterBuyServer, BRS.Net.GangPrinterBuyServerUpgrade, BRS.Net.GangPrinterBuyUpgrade, TCF_CloseSellMenu, TCF_SellDrugsMenu, TCF_SellCocaine, COCAINE_DryCocaine, COCAINE_DryingSwitch, COCAINE_ExtractorSwitch, COCAINE_ExtractorGaugeBucketFill, DRP_AddLaw, DRP_RemoveLaw, DRP_ResetLaws, BuoyMenu, BuoyRet, BuoySplash, rp.OpenImageWindow, GambitPrinter.Menu, GambitPrinter.Withdraw, GambitPrinter.Status, GambitPrinter.Cool, GambitPrinter.Signalize, GambitPrinter.GoVIP, GambitPrinter.Fix, ENC:BuyLvl, SendFish, FishMenu, DiscardFish, SendFishSpawn, MediumPotMenu, m_p_deploy, m_p_hook, m_p_collect, FishPotUpdate, InstrumentNetwork, HFM_StoveMenu_S2C, HFM_DoCook_C2S, HFM_GetFood_C2S, ItemStoreSyncItem, ItemStoreRequestShopInfo, ItemStoreEditShop, Keypad, FishNPCMenu, Fish_buy, Fish_sell, GambitRP.Travel, povarshopMenu, textscreens_download, DarkRP_shipmentSpawn, OpenWantedBoardMenu, ES:Question, ES:KillQuestion, DoVote, KillVoteVGUI, ES:CreateMayorVote, ES:DeleteCandidateFromVote, ES:ShowWinner, ES:ShowVotePrepare, ES:CloseVotingMenu, enc.market.newlot, enc.market.viewmodel, enc.market.delete, enc.market.adelete, enc.market.refresh, base_auto, base_darkrp, base_entity, base_food, cocaine_box, drug, drug_lab, fish_bait, food, gunlab, microwave, money_printer, prop_physics, rod_fish, spawned_ammo, spawned_food, spawned_money, spawned_shipment, spawned_weapon, zmlab2_item_crate, zmlab2_item_meth, zwf_edibles, zwf_jar, zwf_joint_ent, zwf_seed, zwf_weedblock, kumis, fish, fs_potato, fs_watermelon, fs_orange, fs_lemon, bobi, fs_apple, fs_melon, ponch, fs_tomato, durgz_narko, fs_cabbage, burger, kompot, ItemStoreSync, ItemStoreTrade, ItemStoreCloseTrade, ItemStoreTradeMessage, ItemStoreReadyTrade, ItemStoreAcceptTrade, ItemStoreTradeMoney, ItemStoreAdminInventory, ItemStoreAdminBank, ItemStoreOpenShop, ItemStoreShopPurchase, ItemStorePriceShopItem, ItemStoreEditShopContainer, ItemStoreMove, ItemStoreUse, ItemStoreUseWith, ItemStoreDrop, ItemStoreDestroy, ItemStoreMerge, ItemStoreSplit, ItemStoreOpen, ItemStoreSyncInventory, zwf_PlayerSmokeAnim_Start, zwf_PlayerSmokeAnim_Stop, zwf_AnimEvent, zwf_FX, zwf_SmokeEffect, zwf_OpenNPC, zwf_CloseNPC, zwf_BuyBong, zwf_SellWeed, zwf_Player_Initialize, zwf_OpenSeedBank, zwf_CloseSeedBank, zwf_DropSeed, zwf_DeleteSeed, zwf_Shop_Open_net, zwf_Shop_Close_net, zwf_Shop_Buy_net, zwf_OpenSpliceLab, zwf_CloseSpliceLab, zwf_SpliceWeed, XGUI.AddVotemaps, XGUI.RemoveVotemaps, XGUI.PreviewBanMessage, XGUI.SaveBanMessage, XGUI.UpdateMotdData, XGUI.SetMotdData, worldspawn, 
LUA TOTAL: 1711
--]]
--Stealed clientside server code by exechack.cc
--Hostname: ⋙ GAMBITRP ╽ ПОДАРКИ ╽ FREE VIP ⋘ - Part 1/10 - 06/04/2025


--PATH addons/plib_v5/lua/plib/init.lua:

-----------------------------------------------------
plib = {
	BadModules = {}
}
_R 	 = debug.getregistry()

-- To do, add IncludeDir, IncudeDirSV, IncudeDirSH, IncudeDirCL
plib.IncludeSV 	= (SERVER) and include or function() end
plib.IncludeCL 	= (SERVER) and AddCSLuaFile or include
plib.IncludeSH 	= function(f) plib.IncludeSV(f) plib.IncludeCL(f) end

function plib.LoadDir(dir)
	local ret = {}
	local files, folders = file.Find('plib/' .. dir .. '/*', 'LUA')
	for _, f in ipairs(files) do
		if (f:sub(f:len() - 2, f:len()) == 'lua') then
			ret[f:sub(1, f:len() - 4)] = 'plib/' .. dir .. '/' .. f
		end
	end
	for _, f in ipairs(folders) do
		if (f ~= 'client') and (f ~= 'server') then
			ret[f] = 'plib/' .. dir  .. '/' .. f .. '/' .. f ..'.lua'
		end
	end
	return ret
end

local modules = {
	preload = {
		Shared = plib.LoadDir('preload'),
		Server = (SERVER) and plib.LoadDir('preload/server') or {},
		Client = plib.LoadDir('preload/client'),
	},
	Shared = plib.LoadDir('libraries'),
	Server = (SERVER) and plib.LoadDir('libraries/server') or {},
	Client = plib.LoadDir('libraries/client'),
	Loaded = {}
}

for k, v in pairs(modules.preload.Shared) do
	plib.IncludeSH(v)
end

if (SERVER) then
	for k, v in pairs(modules.preload.Server) do
		plib.IncludeSV(v)
	end
	for k, v in pairs(modules.Shared) do
		AddCSLuaFile(v)
	end
	for k, v in pairs(modules.Client) do
		AddCSLuaFile(v)
	end
end

for k, v in pairs(modules.preload.Client) do
	plib.IncludeCL(v)
end

_require = require
function require(name)
	local lib = modules.Shared[name] or modules.Server[name] or modules.Client[name]
	if (lib ~= nil) and (not modules.Loaded[name]) and (not plib.BadModules[name]) then
		modules.Loaded[name] = true
		return include(lib)
	elseif (not modules.Loaded[name]) and (not plib.BadModules[name]) then
		return _require(name)
	end
end
--PATH addons/plib_v5/lua/plib/extensions/string.lua:
function string.Random(chars)
	local str = ''
	for i = 1, (chars or 10) do
		str = str .. string.char(math.random(97, 122))
	end
	return str
end

function string:StartsWith(str)
	return (self:sub(1, str:len()) == str)
end

function string:Apostrophe()
	local len = self:len()
	return (self:sub(len, len):lower() == 's') and '\'' or '\'s'
end

function string:AOrAn()
	return self:match('^h?[AaEeIiOoUu]') and 'an' or 'a'
end

function string:IsSteamID32(str)
	return self:match('^STEAM_%d:%d:%d+$')
end

function string:IsSteamID64()
	return (self:len() == 17) and (self:sub(1, 4) == '7656')
end

function string:HtmlSafe()
	return self:gsub('&', '&amp;'):gsub('<', '&lt;'):gsub('>', '&gt;')
end

local formathex = '%%%02X'
function string:URLEncode()
	return string.gsub(string.gsub(string.gsub(self, '\n', '\r\n'), '([^%w ])', function(c)
		return string.format(formathex, string.byte(c))
	end), ' ', '+')
end

function string:URLDecode()
	return self:gsub('+', ' '):gsub('%%(%x%x)', function(hex)
		return string.char(tonumber(hex, 16))
	end)
end

function string:ParseURL()
	local ans = {}
	for k, v in self:gmatch('([^&=?]-)=([^&=?]+)' ) do
		ans[k] = v:URLDecode()
	end
	return ans
end

function string.ExplodeQuotes(str) -- Re-do this one of these days
	str = ' ' .. str .. ' '
	local res = {}
	local ind = 1
	while true do
		local sInd, start = str:find('[^%s]', ind)
		if not sInd then break end
		ind = sInd + 1
		local quoted = str:sub(sInd, sInd):match('["\']') and true or false
		local fInd, finish = str:find(quoted and '["\']' or '[%s]', ind)
		if not fInd then break end
		ind = fInd + 1
		local str = str:sub(quoted and sInd + 1 or sInd, fInd - 1)
		res[#res + 1] = str
	end
	return res
end

function string:StripPort()
	local p = self:find(':')
	return (not p) and ip or self:sub(1, p - 1)
end

function string.FromNumbericIP(ip)
	ip = tonumber(ip)
	return bit.rshift(bit.band(ip, 0xFF000000), 24) .. '.' .. bit.rshift(bit.band(ip, 0x00FF0000), 16) .. '.' .. bit.rshift(bit.band(ip, 0x0000FF00), 8) .. '.' .. bit.band(ip, 0x000000FF)
end

-- Stolen from maestro
local TIME_SECOND 	= 1
local TIME_MINUTE 	= TIME_SECOND * 60
local TIME_HOUR 	= TIME_MINUTE * 60
local TIME_DAY 		= TIME_HOUR * 24
local TIME_WEEK 	= TIME_DAY * 7
local TIME_MONTH 	= TIME_DAY * (365.2425/12)
local TIME_YEAR 	= TIME_DAY * 365.2425

local function plural(a, n)
	return (n == 1) and a or  a .. 's'
end

function string.FormatTime(num, limit)
	local ret = {}
	while (not limit) or (limit ~= 0) do
		local templimit = limit or 0

		if (num >= TIME_YEAR) or (templimit <= -7) then
			local c = math.floor(num / TIME_YEAR)
			ret[#ret + 1] = c .. ' ' .. plural('year', c)
			num = num - TIME_YEAR * c
		elseif (num >= TIME_MONTH) or (templimit <= -6) then
			local c = math.floor(num / TIME_MONTH)
			ret[#ret + 1] = c .. ' ' .. plural('month', c)
			num = num - TIME_MONTH * c
		elseif (num >= TIME_WEEK) or (templimit <= -5) then
			local c = math.floor(num / TIME_WEEK)
			ret[#ret + 1] = c .. ' ' .. plural('week', c)
			num = num - TIME_WEEK * c
		elseif (num >= TIME_DAY) or (templimit <= -4)then
			local c = math.floor(num / TIME_DAY)
			ret[#ret + 1] = c .. ' ' .. plural('day', c)
			num = num - TIME_DAY * c
		elseif (num >= TIME_HOUR) or (templimit <= -3) then
			local c = math.floor(num / TIME_HOUR)
			ret[#ret + 1] = c .. ' ' .. plural('hour', c)
			num = num - TIME_HOUR * c
		elseif (num >= TIME_MINUTE) or (templimit <= -2) then
			local c = math.floor(num / TIME_MINUTE)
			ret[#ret + 1] = c .. ' ' .. plural('minute', c)
			num = num - TIME_MINUTE * c
		elseif num >= TIME_SECOND or (templimit <= -1) then
			local c = math.floor(num / TIME_SECOND)
			ret[#ret + 1] = c .. ' ' .. plural('second', c)
			num = num - TIME_SECOND * c
		else
			break
		end

		if limit then
			if limit > 0 then
				limit = limit - 1
			else
				limit = limit + 1
			end
		end
	end

	local str = ''
	for i = 1, #ret do
		if i == 1 then
			str = str .. ret[i]
		elseif i == #ret then
			str = str .. ' and ' .. ret[i]
		else
			str = str .. ', ' .. ret[i]
		end
	end

	return str
end

-- Faster implementation
local totable = string.ToTable
local string_sub = string.sub
local string_find = string.find
local string_len = string.len
function string.Explode(separator, str, withpattern)
	if (separator == '') then return totable(str) end

	if withpattern == nil then
		withpattern = false
	end

	local ret = {}
	local current_pos = 1

	for i = 1, string_len(str) do
		local start_pos, end_pos = string_find(str, separator, current_pos, not withpattern)
		if not start_pos then break end
		ret[i] = string_sub(str, current_pos, start_pos - 1)
		current_pos = end_pos + 1
	end

	ret[#ret + 1] = string_sub(str, current_pos)

	return ret
end

function string:MaxCharacters(num, withellipses)
	if (#self <= num) then return self end

	local str = self:sub(1, num)

	return withellipses and (str .. '...') or str
end
--PATH addons/plib_v5/lua/plib/extensions/client/player.lua:
-- local pl
-- local _LocalPlayer = LocalPlayer
-- function LocalPlayer()
	-- pl = _LocalPlayer()
	-- if IsValid(pl) then
		-- LocalPlayer = function()
			-- return pl
		-- end
	-- end
	-- return pl
-- end

do
    local _LocalPlayer, ent, pl = LocalPlayer

    function LocalPlayer()
        if ent then return ent end
        pl = _LocalPlayer()
        if IsValid(pl) then ent = pl end
        return pl
    end
end
--PATH addons/accessory/lua/accessory_list.lua:
-- This is the accessory list. It comes with accessories from a few add-ons (which can be enabled in accessory_addons.lua).
-- If you want to add a new accessory, you can use the SH_ACC:AddAccessory function.
-- To register an accessory, the id, model and slots are mandatory.
-- "id" is an unique identifier for the accessory.
-- "model" is the model of the accessory. Multi-model accessories are not supported.
-- "slots" are the slots that the accessory occupies. A slot may have only one accessory at a time (normally). An accessory can occupy multiple slots (a full face mask for example)
-- There are other settings such as:
-- "name", "price", "skin", "bodygroups", "material", "color", "scale", "canPurchase", "canSell",
-- "usergroups", "steamids", "jobs", "jobsexclude"
-- ...but these are optional.
-- After registering your entity, you need to set up an offset in accessory_offsets.lua

SH_SLOT_HEAD = 1
SH_SLOT_EYES = 2
SH_SLOT_MOUTH = 4
SH_SLOT_BACK = 8
SH_SLOT_NECK = 16

SH_ACC.List = {}

local precached = {}

function SH_ACC:AddAccessory(id, data)
	local mdl = data.mdl
	local slots = data.slot or data.slots
	local price_de = data.price_de or -1

	assert(id and id ~= "", "empty accessory id")
	assert(mdl and id ~= "", "empty model name")
	assert(slots and slots > 0, "unassigned slot")

	local name = data.name or "Accessory"
	local price = data.price or 0

	local skin = data.skin or 0
	local bodygroups = data.bodygroups or {}
	local material = data.material or ""
	local color = data.color or Color(255, 255, 255)
	local scale = data.scale or 1
	local canPurchase = data.canPurchase or nil
	local canSell = data.canSell or nil
	local usergroups = data.usergroups or nil
	local steamids = data.steamids or nil

	assert(self.List[id] == nil, "accessory with id '" .. id .. "' already exists")

	self.List[id] = {
		id = id,
		mdl = mdl:lower(),
		slots = slots,

		name = name,
		price = price,
		price_de = price_de,

		skin = skin,
		bodygroups = bodygroups,
		material = material,
		color = color,
		scale = scale,

		canPurchase = canPurchase,
		canSell = canSell,
		usergroups = usergroups,
		steamids = steamids,
	}

	if (!precached[mdl]) then
		util.PrecacheModel(mdl)
		precached[mdl] = true
	end

	return self.List[id]
end

function SH_ACC:GetAccessory(id)
	return self.List[id]
end

function SH_ACC:CopyAccessory(id, acc, data)
	local newacc = table.Copy(acc)
	for k, v in pairs (data) do
		newacc[k] = v
	end

	return self:AddAccessory(id, newacc)
end

local New = function(...)
	return SH_ACC:AddAccessory(...)
end

local Copy = function(...)
	return SH_ACC:CopyAccessory(...)
end
	-- New("newyeardd", {name = "Новогодняя шапочка", price = 0, price_de = 0, mdl = "models/santa/santa.mdl", slot = SH_SLOT_HEAD, scale = 1})
--
--2.0 ACCESSORY
--
	New("ponchik", {name = "Пончик", price = 10, mdl = "models/noesis/donut.mdl", slot = SH_SLOT_HEAD, scale = 0.65})
--
	New("hedkrab", {name = "Хэдкраб", price = 15, mdl = "models/nova/w_headcrab.mdl", slot = SH_SLOT_HEAD, scale = 0.5})
--
	New("maskamanyaka", {name = "Маска педофила", price = 36, mdl = "models/nova/w_headgear.mdl", slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, scale = 1.2}) --donate1
--
	New("shlapa", {name = "Шляпа профессора", price = 25, mdl = "models/player/items/humans/top_hat.mdl", slot = SH_SLOT_HEAD})
--
	New("shkolnik", {name = "Шляпа школьника", price = 15, mdl = "models/player/items/humans/graduation_cap.mdl", slot = SH_SLOT_HEAD, scale = 1})
--
	New("trava", {name = "Трава", price = 10, mdl = "models/props/pi_fern.mdl", slot = SH_SLOT_HEAD, scale = 0.25})
--
	New("snegovik", {name = "Маска снеговика", price = 24, mdl = "models/props/cs_office/snowman_face.mdl", slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH}) --donate2
--
	New("kepka", {name = "Кепарик", price = 12, mdl = "models/props/cs_office/snowman_hat.mdl", slot = SH_SLOT_HEAD, scale = 0.8})
--
	New("war", {name = "Подводный шар", price = 15, mdl = "models/maxofs2d/hover_basic.mdl", slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, scale = 0.75})
--
	New("vasya", {name = "Маска Васи", price = 25, mdl = "models/maxofs2d/balloon_gman.mdl", slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, scale = 1.05}) --donate3
--
	New("sveta", {name = "Маска Светы", price = 25, mdl = "models/maxofs2d/balloon_mossman.mdl", slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, scale = 1}) --donate4
--
	New("defender", {name = "Защита GMOD'а", price = 15, mdl = "models/maxofs2d/logo_gmod_b.mdl", slot = SH_SLOT_BACK, scale = 0.1})
--
	New("lampa", {name = "Лампа", price = 5, mdl = "models/props/de_inferno/ceiling_light.mdl", slot = SH_SLOT_HEAD, scale = 0.7})
--
	New("kepkad", {name = "Ярик-Кепарик", price = 12, mdl = "models/props/de_tides/vending_hat.mdl", slot = SH_SLOT_HEAD, scale = 0.8})
--
	New("cherepa", {name = "Черепашка", price = 17, mdl = "models/props/de_tides/vending_turtle.mdl", slot = SH_SLOT_HEAD, scale = 1})
--
	New("gitara", {name = "Гитара", price = 30, mdl = "models/props_phx/misc/fender.mdl", slot = SH_SLOT_BACK, scale = 0.8}) --donate5
--
	New("jetpack", {name = "Джетпак", price = 25, mdl = "models/thrusters/jetpack.mdl", slot = SH_SLOT_BACK, scale = 1})
--
	New("gib", {name = "GIB-05",  price = 30, mdl = "models/gibs/scanner_gib05.mdl", slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, scale = 0.75}) --donate6
--
	New("uebaka", {name = "Улыбака", price = 25, mdl = "models/props_phx/facepunch_logo.mdl", slot = SH_SLOT_BACK, scale = 0.05})
--
	New("constructinc", {name = "Construct inc.",price = 5, mdl = "models/maxofs2d/construct_sign.mdl", slot = SH_SLOT_BACK, scale = 0.025})
--
	New("chefhat", {name = "Головной убор шеф-повара", price = 15, mdl = "models/sal/acc/fix/cheafhat.mdl", slot = SH_SLOT_HEAD})
--
	New("hlapalampa", {name = "Шляпа-Лампа", price = 10, mdl = "models/props_wasteland/prison_lamp001c.mdl", slot = SH_SLOT_HEAD, scale = 0.5})
--
	New("znak1", {name = "Дорожный знак 1", price = 10, mdl = "models/props_c17/streetsign004e.mdl", slot = SH_SLOT_BACK, scale = 0.7})
--
	New("znak2", {name = "Дорожный знак 2", price = 10, mdl = "models/props_c17/streetsign004f.mdl", slot = SH_SLOT_BACK, scale = 0.7})
--
	New("krug", {name = "Спасательный круг", price = 15, mdl = "models/props/de_nuke/lifepreserver.mdl", slot = SH_SLOT_NECK, scale = 0.3})	 --donate7
/*
	ADDON
	[GTA V] Giant Accessories Pack
*/

if (SH_ACC.Addons["572310302"]) then --572310302
	-- Head
	local a = New("symbolcap1", {name = "Кепка [Gray F]", price = 19, mdl = "models/modified/hat07.mdl", slot = SH_SLOT_HEAD})
	Copy("symbolcap2", a, {name = "Кепка [Black F]", skin = 1})
	Copy("symbolcap3", a, {name = "Кепка [Light Gray C]", skin = 2})
	Copy("symbolcap4", a, {name = "Кепка [White LS]", skin = 3})
	Copy("symbolcap5", a, {name = "Кепка [Green Feud]", skin = 4})
	Copy("symbolcap6", a, {name = "Кепка [Kaki Magnetics]", skin = 5})
	Copy("symbolcap7", a, {name = "Кепка [Brown OG]", skin = 6})
	Copy("symbolcap8", a, {name = "Кепка [Blue Stank]", skin = 7})
	Copy("symbolcap9", a, {name = "Кепка [Olive Knight]", skin = 8})
	Copy("symbolcap10", a, {name = "Кепка [Dark Blue Monkey]", skin = 9})
	Copy("symbolcap11", a, {name = "Кепка [Dark Green Football]", skin = 10})

	local a = New("symbolcap12", {name = "Кепка [Orange LH]", price = 19, mdl = "models/modified/hat08.mdl", slot = SH_SLOT_HEAD})
	Copy("symbolcap13", a, {name = "Кепка [Censored]", skin = 1})
	Copy("symbolcap14", a, {name = "Кепка [The Nut House]", skin = 2})
	Copy("symbolcap15", a, {name = "Кепка [Rusty Browns]", skin = 3})
	Copy("symbolcap16", a, {name = "Кепка [Bishop's]", skin = 4})
	Copy("symbolcap17", a, {name = "Кепка [247]", skin = 5})
	Copy("symbolcap18", a, {name = "Кепка [Fruit Basket]", skin = 6})
	Copy("symbolcap19", a, {name = "Кепка [Ron]", skin = 7})
	Copy("symbolcap20", a, {name = "Кепка [Meteorite]", skin = 8})
	Copy("symbolcap21", a, {name = "Кепка [Dusche Gold]", skin = 9})
	Copy("symbolcap22", a, {name = "Кепка [Vespucci Beach]", skin = 10})
	Copy("symbolcap23", a, {name = "Кепка [Orang-O-Tang]", skin = 11})

	local a = New("beerhat1", {name = "Пивная шляпа [Pisswasser]", price = 19, mdl = "models/sal/acc/fix/beerhat.mdl", slot = SH_SLOT_HEAD})
	Copy("beerhat2", a, {name = "Пивная шляпа [Supa Wet]", skin = 1})
	Copy("beerhat3", a, {name = "Пивная шляпа [Patriot]", skin = 2})
	Copy("beerhat4", a, {name = "Пивная шляпа [Benedict]", skin = 3})
	Copy("beerhat5", a, {name = "Пивная шляпа [Blarneys]", skin = 4})
	Copy("beerhat6", a, {name = "Пивная шляпа [J Lager]", skin = 5})

	local a = New("headphones1", {name = "Наушники [Red]", price = 39, mdl = "models/modified/headphones.mdl", slot = SH_SLOT_HEAD})
	Copy("headphones2", a, {name = "Наушники [Pink]", skin = 1})
	Copy("headphones3", a, {name = "Наушники [Green]", skin = 2})
	Copy("headphones4", a, {name = "Наушники [Yellow]", skin = 3})

	--New("chefhat", {name = "Головной убор шеф-повара", price = 15, mdl = "models/sal/acc/fix/cheafhat.mdl", slot = SH_SLOT_HEAD})

	local a = New("fedora1", {name = "Мягкая фетровая шляпа [Gray]", price = 19, mdl = "models/modified/hat01_fix.mdl", slot = SH_SLOT_HEAD})
	Copy("fedora2", a, {name = "Мягкая фетровая шляпа [Black]", skin = 1})
	Copy("fedora3", a, {name = "Мягкая фетровая шляпа [White]", skin = 2})
	Copy("fedora4", a, {name = "Мягкая фетровая шляпа [Yellow]", skin = 3})
	Copy("fedora5", a, {name = "Мягкая фетровая шляпа [Red]", skin = 4})
	Copy("fedora6", a, {name = "Мягкая фетровая шляпа [Black/Red]", skin = 5})
	Copy("fedora7", a, {name = "Мягкая фетровая шляпа [Brown/White]", skin = 6})
	Copy("fedora8", a, {name = "Мягкая фетровая шляпа [Blue/Black]", skin = 7})

	local a = New("beanie1", {name = "Шапочка [Red Stripes]", price = 19, mdl = "models/modified/hat03.mdl", slot = SH_SLOT_HEAD})
	Copy("beanie2", a, {name = "Шапочка [Blue]", skin = 1})
	Copy("beanie3", a, {name = "Шапочка [Red]", skin = 2})
	Copy("beanie4", a, {name = "Шапочка [White]", skin = 3})
	Copy("beanie5", a, {name = "Шапочка [Black Stripes]", skin = 4})

	local a = New("woolhat1", {name = "Шерстяная шапка [Black]", price = 19, mdl = "models/modified/hat04.mdl", slot = SH_SLOT_HEAD})
	Copy("woolhat2", a, {name = "Шерстяная шапка [Gray]", skin = 1})
	Copy("woolhat3", a, {name = "Шерстяная шапка [Gray Stripes]", skin = 2})
	Copy("woolhat4", a, {name = "Шерстяная шапка [Jamaica]", skin = 3})
	Copy("woolhat5", a, {name = "Шерстяная шапка [Dark Blue]", skin = 4})

	New("flatКепка", {name = "Кепка гопаря", price = 15, mdl = "models/modified/hat06.mdl", slot = SH_SLOT_HEAD})

	-- Eyes
	local a = New("glasses1", {name = "Очки [Gray]", price = 29, mdl = "models/modified/glasses01.mdl", slot = SH_SLOT_EYES})
	Copy("glasses2", a, {name = "Очки [White]", skin = 1})
	Copy("glasses3", a, {name = "Очки [Green]", skin = 2})
	Copy("glasses4", a, {name = "Очки [Brown]", skin = 3})
	Copy("glasses5", a, {name = "Очки [Orange]", skin = 4})
	Copy("glasses6", a, {name = "Очки [Light Gray]", skin = 5})

	New("plaguedoctor", {name = "Маска чумы", price = 99, slot = SH_SLOT_EYES, mdl = "models/sal/halloween/doctor.mdl"})

	local a = New("balletmask1", {name = "Балетная маска [White]", price = 19, slot = SH_SLOT_EYES, mdl = "models/sal/acc/fix/mask_1.mdl"})
	Copy("balletmask2", a, {name = "Балетная маска [Blue]", skin = 1})
	Copy("balletmask3", a, {name = "Балетная маска [Black]", skin = 2})
	Copy("balletmask4", a, {name = "Балетная маска [Gray]", skin = 3})
	Copy("balletmask5", a, {name = "Балетная маска [Yellow]", skin = 4})
	Copy("balletmask6", a, {name = "Балетная маска [Black 2]", skin = 5})

	-- Mouth
	New("bandana", {name = "Black Bandana", price = 79, slot = SH_SLOT_MOUTH, mdl = "models/modified/bandana.mdl"})

	-- Neck
	local a = New("scarf1", {name = "Шарф [White]", price = 39, mdl = "models/sal/acc/fix/scarf01.mdl", slot = SH_SLOT_NECK})
	Copy("scarf2", a, {name = "Шарф [Gray]", skin = 1})
	Copy("scarf3", a, {name = "Шарф [Black]", skin = 2})
	Copy("scarf4", a, {name = "Шарф [Dark Blue]", skin = 3})
	Copy("scarf5", a, {name = "Шарф [Red]", skin = 4})
	Copy("scarf6", a, {name = "Шарф [Green]", skin = 5})
	Copy("scarf7", a, {name = "Шарф [Pink]", skin = 6})

	-- Whole head (Head + Eyes + Mouth)
	New("catmask", {name = "Маска кошки", price = 159, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/cat.mdl"})
	New("bearmask", {name = "Маска медведя", price = 159, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/bear.mdl"})
	New("foxmask", {name = "Маска лисы", price = 159, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/fox.mdl"})
	New("wolfmask", {name = "Маска волка", price = 159, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/wolf.mdl"})
	New("santapenguin", {name = "Санта-Пингвин", price = 999, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/penguin.mdl"})
    New("owlmask", {name = "Маска совы", price = 159, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/owl.mdl"})

	local a = New("monkeymask1", {name = "Маска обезьяны [Normal]", price = 159, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/halloween/monkey.mdl"})
	Copy("monkeymask2", a, {name = "Маска обезьяны [Gorilla]", skin = 1})
	Copy("monkeymask3", a, {name = "Маска обезьяны [Zombie]", skin = 2})
	Copy("monkeymask4", a, {name = "Маска обезьяны [Old]", skin = 3})


	local a = New("eaglemask1", {name = "Маска орла [White]", price = 159, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/hawk_1.mdl"})
	Copy("eaglemask2", a, {name = "Маска орла [Brown]", mdl = "models/sal/hawk_2.mdl"})

	local a = New("paperbag1", {name = "Бумажный пакет",  price = 19, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/halloween/bag.mdl"})
	Copy("paperbag2", a, {name = "Бумажный пакет [Grin]", skin = 1})
	Copy("paperbag3", a, {name = "Бумажный пакет [Crying]", skin = 2})
	Copy("paperbag4", a, {name = "Бумажный пакет [Smile]", skin = 3})
	Copy("paperbag5", a, {name = "Бумажный пакет [Boss]", skin = 4})
	Copy("paperbag6", a, {name = "Бумажный пакет [Teeth]", skin = 5})
	Copy("paperbag7", a, {name = "Бумажный пакет [Timid]", skin = 6})
	Copy("paperbag8", a, {name = "Бумажный пакет [Burger Shot]", skin = 7})
	Copy("paperbag9", a, {name = "Бумажный пакет [Please Kill Me]", skin = 8})
	Copy("paperbag10", a, {name = "Бумажный пакет [Satan]", skin = 9})
	Copy("paperbag11", a, {name = "Бумажный пакет [Pig]", skin = 10})
	Copy("paperbag12", a, {name = "Бумажный пакет [Tongue Out]", skin = 11})
	Copy("paperbag13", a, {name = "Бумажный пакет [Angry]", skin = 12})
	Copy("paperbag14", a, {name = "Бумажный пакет [Confused]", skin = 13})
	Copy("paperbag15", a, {name = "Бумажный пакет [Death]", skin = 14})
	Copy("paperbag16", a, {name = "Бумажный пакет [Dog]", skin = 15})
	Copy("paperbag17", a, {name = "Бумажный пакет [Ghos]", skin = 16})
	Copy("paperbag18", a, {name = "Бумажный пакет [Alien]", skin = 17})
	Copy("paperbag19", a, {name = "Бумажный пакет [Help Me]", skin = 18})
	Copy("paperbag20", a, {name = "Бумажный пакет [Rectangles]", skin = 19})
	Copy("paperbag21", a, {name = "Бумажный пакет [Middle Finger]", skin = 20})
	Copy("paperbag22", a, {name = "Бумажный пакет [Gentleman]", skin = 21})
	Copy("paperbag23", a, {name = "Бумажный пакет [Stickers]", skin = 22})
	Copy("paperbag24", a, {name = "Бумажный пакет [Picasso]", skin = 23})
	Copy("paperbag25", a, {name = "Бумажный пакет [Black Heart]", skin = 24})
	Copy("paperbag26", a, {name = "Бумажный пакет [Black]", skin = 25})

	-- Face (Eyes + Mouth)
	New("gingerbread", {name = "Пряничная маска", price = 39, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/gingerbread.mdl"})

	local a = New("headwrap1", {name = "Обмотка для головы [Gray Bandages]", price = 59, mdl = "models/sal/halloween/headwrap2.mdl", slot = SH_SLOT_EYES + SH_SLOT_MOUTH})
	a.scale = 0.9
	Copy("headwrap2", a, {name = "Обмотка для головы [Black Bandages]", skin = 1})
	Copy("headwrap3", a, {name = "Обмотка для головы [White Bandages]", skin = 2})
	Copy("headwrap4", a, {name = "Обмотка для головы [Rainbow Bandages]", skin = 3})
	Copy("headwrap5", a, {name = "Обмотка для головы [Do Not Cross]", mdl = "models/sal/halloween/headwrap1.mdl"})

	local a = New("hockeymask1", {name = "Хоккейная маска [Please Stop Me]", price = 59, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/modified/mask5.mdl"})
	a.scale = 0.9

	local a = New("hockeymask2", {name = "Хоккейная маска [Bullet Holes]", price = 59, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/acc/fix/mask_2.mdl"})
	a.scale = 0.9

	Copy("hockeymask3", a, {name = "Хоккейная маска [Dog]", skin = 1})
	Copy("hockeymask4", a, {name = "Хоккейная маска [Cat]", skin = 2})
	Copy("hockeymask5", a, {name = "Хоккейная маска [Dog 2]", skin = 3})
	Copy("hockeymask6", a, {name = "Хоккейная маска [Dog 3]", skin = 4})
	Copy("hockeymask7", a, {name = "Хоккейная маска [Crown]", skin = 5})
	Copy("hockeymask8", a, {name = "Хоккейная маска [Rotten Zombie]", skin = 6})
	Copy("hockeymask9", a, {name = "Хоккейная маска [Vile Zombie]", skin = 7})
	Copy("hockeymask10", a, {name = "Хоккейная маска [Flame Skull]", skin = 8})
	Copy("hockeymask11", a, {name = "Хоккейная маска [Nightmare Skull]", skin = 9})
	Copy("hockeymask12", a, {name = "Хоккейная маска [Electric Skull]", skin = 10})
	Copy("hockeymask13", a, {name = "Хоккейная маска [Skull]", skin = 11})
	Copy("hockeymask14", a, {name = "Хоккейная маска [Stitched]", skin = 12})
	Copy("hockeymask15", a, {name = "Хоккейная маска [Pale Stitched]", skin = 13})
	Copy("hockeymask16", a, {name = "Хоккейная маска [X]", skin = 14})

	local a = New("skullmask1", {name = "Маска черепа [Black]", price = 99, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/modified/mask6.mdl"})
	a.scale = 0.9
	Copy("skullmask2", a, {name = "Маска черепа [Gray]", skin = 1})
	Copy("skullmask3", a, {name = "Маска черепа [White]", skin = 2})
	Copy("skullmask4", a, {name = "Маска черепа [Dark Green]", skin = 3})

	local a = New("pigmask1", {name = "Маска свиньи [Normal]", price = 99, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/pig.mdl"})
	Copy("pigmask2", a, {name = "Маска свиньи [Bloody]", skin = 1})

	local a = New("warriormask1", {name = "Маска воина [Metal]", price = 99, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/acc/fix/mask_4.mdl"})
	Copy("warriormask2", a, {name = "Маска воина [Circuit]", skin = 1})
	Copy("warriormask3", a, {name = "Маска воина [Molten]", skin = 2})
	Copy("warriormask4", a, {name = "Маска воина [Purple]", skin = 3})
	Copy("warriormask5", a, {name = "Маска воина [Carbon]", skin = 4})
	Copy("warriormask6", a, {name = "Маска воина [Target]", skin = 5})
	Copy("warriormask7", a, {name = "Маска воина [Concrete]", skin = 6})
	Copy("warriormask8", a, {name = "Маска воина [Thunder]", skin = 7})

	local a = New("ninja1", {name = "Маска ниндзя [Black]", price = 99, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/halloween/ninja.mdl"})
	Copy("ninja2", a, {name = "Маска ниндзя [White]", skin = 1})
	Copy("ninja3", a, {name = "Маска ниндзя [Tan]", skin = 2})
	Copy("ninja4", a, {name = "Маска ниндзя [L.S Benders]", skin = 3})
	Copy("ninja5", a, {name = "Маска ниндзя [Justice]", skin = 4})
	Copy("ninja6", a, {name = "Маска ниндзя [Woodland Camo]", skin = 5})
	Copy("ninja7", a, {name = "Маска ниндзя [Red Stripes]", skin = 6})
	Copy("ninja8", a, {name = "Маска ниндзя [Love Fist]", skin = 7})
	Copy("ninja9", a, {name = "Маска ниндзя [T.P.I]", skin = 8})
	Copy("ninja10", a, {name = "Маска ниндзя [Pink Camo]", skin = 9})
	Copy("ninja11", a, {name = "Маска ниндзя [Police]", skin = 10})

	-- Back
	local a = New("backpack1", {name = "Рюкзак [Red]", price = 129, mdl = "models/modified/backpack_1.mdl", slot = SH_SLOT_BACK})
	Copy("backpack2", a, {name = "Рюкзак [Black]", skin = 1})
	Copy("backpack3", a, {name = "Рюкзак [Orange]", skin = 2})

	local a = New("backpackcamp1", {name = "Походный рюкзак [Blue]", price = 129, mdl = "models/modified/backpack_2.mdl", slot = SH_SLOT_BACK})
	Copy("backpackcamp2", a, {name = "Походный Рюкзак [Green]", skin = 1})
	Copy("backpackcamp3", a, {name = "Походный Рюкзак [Red/White]", skin = 2})

	local a = New("backpackmil1", {name = "Военный Рюкзак [Black]", price = 129, mdl = "models/modified/backpack_3.mdl", slot = SH_SLOT_BACK})
	Copy("backpackmil2", a, {name = "Военный Рюкзак [Gray]", skin = 1})
end

/*
	ADDON
	GMod Tower: Accessories Pack
*/

if (SH_ACC.Addons["3211437970"]) then
    -- Head
    local a = New("utochka", {name = "Обруч-уточка", price = 89, slot = SH_SLOT_HEAD, mdl = "models/captainbigbutt/skeyler/accessories/duck_tube.mdl"})
	a.scale = 0.72

    local a = New("parik", {name = "Парик", price = 129, slot = SH_SLOT_HEAD, mdl = "models/captainbigbutt/skeyler/hats/afro.mdl"})
    a.scale = 0.9

    local a = New("bearhat", {name = "Шапка медведя", price = 139, slot = SH_SLOT_HEAD, mdl = "models/captainbigbutt/skeyler/hats/bear_hat.mdl"})
    a.scale = 0.9

    local a = New("cathat", {name = "Шапка котика", price = 139, slot = SH_SLOT_HEAD, mdl = "models/captainbigbutt/skeyler/hats/cat_hat.mdl"})
    a.scale = 0.9

    local a = New("froghat", {name = "Шапка лягушки", price = 139, slot = SH_SLOT_HEAD, mdl = "models/captainbigbutt/skeyler/hats/frog_hat.mdl"})
    a.scale = 0.65

    local a = New("deadmau5", {name = "Маска мыши", price = 149, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/captainbigbutt/skeyler/hats/deadmau5.mdl"})
    a.scale = 0.9

    local a = New("heartband", {name = "Обруч с сердцами", price = 109, slot = SH_SLOT_HEAD, mdl = "models/captainbigbutt/skeyler/hats/heartband.mdl"})
    a.scale = 1

    local a = New("starband", {name = "Обруч со звездами", price = 109, slot = SH_SLOT_HEAD, mdl = "models/captainbigbutt/skeyler/hats/starband.mdl"})
    a.scale = 1

	local a = New("crownroyal", {name = "Корона Создателя", price = 2000, slot = SH_SLOT_HEAD, mdl = "models/crown/models/crownroyal.mdl"})
	a.scale = 1.1

	local a = New("batman", {name = "Маска Бэтмена", price = 139, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/gmod_tower/batmanmask.mdl"})
	a.scale = 1

	local a = New("bluehelmet", {name = "Синий шлем", price = 149, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/gmod_tower/bombermanhelmet.mdl"})
	a.scale = 1.05

	local a = New("lego", {name = "Лего шлем", price = 149, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/gmod_tower/legohead.mdl"})
    a.scale = 1.05

	local a = New("ghostmask", {name = "Маска призрака", price = 109, slot = SH_SLOT_EYES, mdl = "models/gmod_tower/noface.mdl"})
    a.scale = 1

-- Сделать не покупаемым, чтобы добавить в БП
	local a = New("rubikscube", {name = "[BattlePass] Кубик Рубика", price = 99999, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/gmod_tower/rubikscube.mdl"})
	a.scale = 0.55
	a.canSell = false
	
	local a = New("daftpunk", {name = "Маска робота", price = 149, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/lordvipes/daftpunk/thomas.mdl"})
	a.scale = 1.05


	local a = New("alberthat", {name = "Элегантная шляпа 1", price = 99, slot = SH_SLOT_HEAD, mdl = "models/splinks/kf2/cosmetics/albert_hat.mdl"})
    a.scale = 1.03

    local a = New("bowlerhat", {name = "Элегантная шляпа 2", price = 99, slot = SH_SLOT_HEAD, mdl = "models/splinks/kf2/cosmetics/bowler_hat.mdl"})
    a.scale = 1.03

    local a = New("workercap", {name = "Кепка рабочего", price = 99, slot = SH_SLOT_HEAD, mdl = "models/splinks/kf2/cosmetics/coleman_hat.mdl"})
    a.scale = 1.03

    local a = New("viking", {name = "Шлем викинга", price = 109, slot = SH_SLOT_HEAD, mdl = "models/vikinghelmet/vikinghelmet.mdl"})
    a.scale = 1.03

    local a = New("desert", {name = "Шляпа путешественника", price = 109, slot = SH_SLOT_HEAD, mdl = "models/warz/desertboonie.mdl"})
    a.scale = 1.03

    local a = New("firehelmet", {name = "Шлем пожарного", price = 109, slot = SH_SLOT_HEAD, mdl = "models/warz/firehelmet.mdl"})
    a.scale = 1.05

    local a = New("hardhat", {name = "Шлем рабочего", price = 109, slot = SH_SLOT_HEAD, mdl = "models/warz/hardhat.mdl"})
    a.scale = 1.05

    local a = New("cowboy", {name = "Ковбойская шляпа", price = 109, slot = SH_SLOT_HEAD, mdl = "models/warz/leatherboonie.mdl"})
    a.scale = 1.05
	
	local a = New("wings", {name = "Крылья ангела", price = 139, slot = SH_SLOT_BACK, mdl = "models/gmod_tower/fairywings.mdl"})
	a.scale = 1.1

	local a = New("jetpack2", {name = "Улучшенный джетпак", price = 109, slot = SH_SLOT_BACK, mdl = "models/gmod_tower/jetpack.mdl"})
	a.scale = 1

end

/*
	ADDON
	Horse Mask Prop
*/

if (SH_ACC.Addons["166177187"]) then
	-- Whole head (Head + Eyes + Mouth)
	local a = New("horsemask1", {name = "Horse Mask [Brown]", price = 7500, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/horsie/horsiemask.mdl"})
	Copy("horsemask2", a, {name = "Horse Mask [Black]", skin = 1})
end

/*
	ADDON
	Alienware mask from PAYDAY 2
*/

if (SH_ACC.Addons["283483231"]) then
	-- Face (Eyes + Mouth)
	New("alienwaremask", {name = "Alienware Mask", price = 7500, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/snowzgmod/payday2/masks/maskalienware.mdl"})
end

/*
	ADDON
	Freddy Mask SWEP
*/

if (SH_ACC.Addons["383109137"]) then
	-- Whole head (Head + Eyes + Mouth)
	local a = New("freddymask", {name = "Freddy Mask", price = 10000, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/errolliamp/five_nights_at_freddys/freddy_mask.mdl"})
	a.scale = 1.1
end

/*
	ADDON
	MGS V TPP Venom's Respirator
*/

if (SH_ACC.Addons["879182781"]) then
	-- Mouth
	New("respirator", {name = "Respirator", price = 2500, slot = SH_SLOT_MOUTH, mdl = "models/mgsv/gear/venom_respirator.mdl"})
end

/*
	ADDON
	Pirate Hat Model
*/

if (SH_ACC.Addons["351194925"]) then
	-- Hat
	New("piratehat", {name = "Pirate Hat", price = 2500, slot = SH_SLOT_HEAD, mdl = "models/piratehat/piratehat.mdl"})
end

/*
	ADDON
	Detective Hat Model
*/

if (SH_ACC.Addons["158276951"]) then
	-- Hat
	local a = New("detectivehat", {name = "Detective Hat", price = 5000, slot = SH_SLOT_HEAD, mdl = "models/ttt/deerstalker.mdl"})
	a.scale = 0.97
end

/*
	ADDON
	MGS V TPP Chicken Hat
*/

if (SH_ACC.Addons["879200645"]) then
	-- Hat
	New("chickenhat", {name = "Chicken Hat", price = 7500, slot = SH_SLOT_HEAD, mdl = "models/chicken_hat/chicken_hat.mdl"})
end

/*
	ADDON
	Polished Military Beret- FO3 HAT
*/

if (SH_ACC.Addons["158532239"]) then
	-- Hat
	local a = New("beret1", {name = "Beret [Red]", price = 7500, slot = SH_SLOT_HEAD, mdl = "models/fallout 3/polish_beret.mdl"})
	Copy("beret2", a, {name = "Beret [Black]", skin = 1})
	Copy("beret3", a, {name = "Beret [Green]", skin = 2})
end

/*
	ADDON
	Animal masks from PAYDAY 2
*/

if (SH_ACC.Addons["282958377"]) then
	-- Face (Eyes + Mouth)
	local a = New("pd2mask_arnold", {name = "Arnold Mask", price = 7500, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/snowzgmod/payday2/masks/maskarnold.mdl"})
	a.scale = 0.95
	local a = New("pd2mask_babyrhino", {name = "Baby Rhino Mask", price = 7500, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/snowzgmod/payday2/masks/maskbabyrhino.mdl"})
	a.scale = 0.95
	local a = New("pd2mask_chuck", {name = "Chuck Mask", price = 7500, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/snowzgmod/payday2/masks/maskchuck.mdl"})
	a.scale = 0.95
	local a = New("pd2mask_dolph", {name = "Dolph Mask", price = 7500, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/snowzgmod/payday2/masks/maskdolph.mdl"})
	a.scale = 0.95
	local a = New("pd2mask_jeanclaude", {name = "Jean-Claude Mask", price = 7500, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/snowzgmod/payday2/masks/maskjeanclaude.mdl"})
	a.scale = 0.95
	local a = New("pd2mask_mark", {name = "Mark Mask", price = 7500, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/snowzgmod/payday2/masks/maskmark.mdl"})
	a.scale = 0.95
	local a = New("pd2mask_monkeybusiness", {name = "Monkey Business Mask", price = 7500, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/snowzgmod/payday2/masks/maskmonkeybusiness.mdl"})
	a.scale = 0.95
	local a = New("pd2mask_thehog", {name = "The Hog Mask", price = 7500, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/snowzgmod/payday2/masks/maskthehog.mdl"})
	a.scale = 0.95
end

/*
	ADDON
	Wrench Mask
*/

if (SH_ACC.Addons["827404607"]) then
	-- Face (Eyes + Mouth)
	local a = New("wrenchmask", {name = "Wrench Mask", price = 7500, slot = SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/models/wrenchmask.mdl"})
	a.scale = 0.47
end

/*
	ADDON
	Russian hat/Ushanka prop
*/

if (SH_ACC.Addons["354739227"]) then
	-- Hat
	New("ushanka", {name = "Ushanka", price = 5000, slot = SH_SLOT_HEAD, mdl = "models/russianhat1.mdl"})
end

/*
	ADDON
	GTA IV Bike Helmets
*/

if (SH_ACC.Addons["551144079"]) then
	-- Hat
	local a = New("bikehelmet1", {name = "Bike Helmet [Black]", price = 5000, slot = SH_SLOT_HEAD, mdl = "models/dean/gtaiv/helmet.mdl"})
	Copy("bikehelmet2", a, {name = "Bike Helmet [Gray]", skin = 1})
	Copy("bikehelmet3", a, {name = "Bike Helmet [White]", skin = 2})
	Copy("bikehelmet4", a, {name = "Bike Helmet [Red]", skin = 3})
	Copy("bikehelmet5", a, {name = "Bike Helmet [Orange]", skin = 4})
	Copy("bikehelmet6", a, {name = "Bike Helmet [Yellow]", skin = 5})
	Copy("bikehelmet7", a, {name = "Bike Helmet [Green]", skin = 6})
	Copy("bikehelmet8", a, {name = "Bike Helmet [Blue]", skin = 7})
	Copy("bikehelmet9", a, {name = "Bike Helmet [Pink]", skin = 8})
	Copy("bikehelmet10", a, {name = "Bike Helmet [Rainbow]", skin = 9, price = 10000})
	Copy("bikehelmet11", a, {name = "Bike Helmet [Stars]", skin = 10, price = 10000})
	Copy("bikehelmet12", a, {name = "Bike Helmet [Gradient]", skin = 11, price = 10000})
	Copy("bikehelmet13", a, {name = "Bike Helmet [America]", skin = 12, price = 10000})
	Copy("bikehelmet14", a, {name = "Bike Helmet [Black Stripe]", skin = 13, price = 10000})
	Copy("bikehelmet15", a, {name = "Bike Helmet [White Stripe]", skin = 14, price = 10000})
end

/*
	ADDON
	Halloween_Pumpkin
*/

if (SH_ACC.Addons["826536617"]) then
	local a = New("pumpkinhat", {name = "Pumpkin Hat", price = 5000, slot = SH_SLOT_HEAD, mdl = "models/props/pumpkin_z.mdl"})
	a.scale = 0.5
end

/*
	CUSTOM ACCESSORIES
	Place your custom accessories under this!
*/

-- Only admins may buy this hat, and this hat will only render when their team name is "Admin On Duty"

--[[
local a = New("owlmask", {name = "Маска совы", price = 10000, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/owl.mdl"})
a.jobs = {
}
a.usergroups = {
["vip"] = true,
["moder"] = true,
["padmin"] = true,
["sponsor"] = true,
["t-admin"] = true,
["admin"] = true,
["superadmin"] = true,
}

local a = New("santapenguin", {name = "Санта-Пингвин", price = 5000, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/penguin.mdl"})
a.jobs = {
}
a.usergroups = {
["vip"] = true,
["moder"] = true,
["padmin"] = true,
["sponsor"] = true,
["t-admin"] = true,
["admin"] = true,
["superadmin"] = true,
}

local a = New("bearmask", {name = "Маска медведя", price = 10000, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/bear.mdl"})
a.jobs = {
}
a.usergroups = {
["vip"] = true,
["moder"] = true,
["padmin"] = true,
["sponsor"] = true,
["t-admin"] = true,
["admin"] = true,
["superadmin"] = true,
}

local a = New("wolfmask", {name = "Маска волка", price = 10000, slot = SH_SLOT_HEAD + SH_SLOT_EYES + SH_SLOT_MOUTH, mdl = "models/sal/wolf.mdl"})
a.jobs = {
}
a.usergroups = {
["vip"] = true,
["moder"] = true,
["padmin"] = true,
["sponsor"] = true,
["t-admin"] = true,
["admin"] = true,
["superadmin"] = true,
}
--]]
--PATH addons/accessory/lua/accessory/sh_obj_player_extend.lua:
local meta = FindMetaTable("Player")

--
function meta:SH_NearAccessoryVendor()
	if (SH_ACC.FreeAccess) then
		return true
	end

	local pos = self:GetPos()
	for _, v in ipairs (ents.FindByClass("npc_accessory_vendor")) do
		if (v:GetPos():Distance(pos) <= 256) then
			return true
		end
	end

	return false
end

function meta:SH_HasAccessoryChanger()
	local swep = self:GetActiveWeapon()
	if (IsValid(swep) and swep:GetClass() == "sh_accessory_changer") then
		return swep
	end

	return false
end

function meta:SH_HasAccessory(id)
	if (!self.SH_AccessoryInfo) then
		return false
	end

	return self.SH_AccessoryInfo.inventory[id] ~= nil
end

function meta:SH_HasAccessoryEquipped(id)
	if (!self.SH_AccessoryInfo) then
		return false
	end

	return self.SH_AccessoryInfo.equipped[id] ~= nil
end

function meta:SH_CanAdjustAccessories()
	local ap = SH_ACC.AllowAdjustingPlayers[self:SteamID()]
	if (ap ~= nil) then
		return ap
	end

	local au = SH_ACC.AllowAdjustingUsergroups[self:GetUserGroup()]
	if (au ~= nil) then
		return au
	end

	return SH_ACC.AllowAdjusting
end

function meta:SH_GetAccessoryPurchaseFrac()
	return SH_ACC.PurchaseFracPlayers[self:SteamID()] or SH_ACC.PurchaseFracUsergroups[self:GetUserGroup()] or SH_ACC.PurchaseFrac
end

function meta:SH_GetAccessorySellFrac()
	return SH_ACC.SellFracPlayers[self:SteamID()] or SH_ACC.SellFracUsergroups[self:GetUserGroup()] or SH_ACC.SellFrac
end

function meta:SH_GetAccessoryAdjustFactor()
	return SH_ACC.AdjustFactorPlayers[self:SteamID()] or SH_ACC.AdjustFactorUsergroups[self:GetUserGroup()] or SH_ACC.AdjustFactor
end

function meta:SH_GetAccessoryLimit()
	return SH_ACC.MaximumWearablePlayers[self:SteamID()] or SH_ACC.MaximumWearableUsergroups[self:GetUserGroup()] or SH_ACC.MaximumWearable
end

function meta:SH_CanSellAccessories()
	local sp = SH_ACC.AllowSellingPlayers[self:SteamID()]
	if (sp ~= nil) then
		return sp
	end

	local su = SH_ACC.AllowSellingUsergroups[self:GetUserGroup()]
	if (su ~= nil) then
		return su
	end

	return SH_ACC.AllowSelling
end

function meta:SH_GetNumEquippedAccessories()
	if (!self.SH_AccessoryInfo) then
		return 0
	end

	return table.Count(self.SH_AccessoryInfo.equipped)
end

-- DarkRP 2.4.3 compatibility
function SH_ACC.CanAfford(ply, i)
	if (ply.canAfford) then
		return ply:canAfford(i)
	end

	if (ply.CanAfford) then
		return ply:CanAfford(i)
	end

	return false
end

-- boo
local function attachCurrency(str)
	local config = GAMEMODE.Config
	if (!config) then
		return  str.. " донат-монет"
	end

	local cr = " донат-монет"
	return config.currencyLeft and str .. cr or str .. cr
end

function SH_ACC.formatMoney(n)
	-- if (DarkRP and DarkRP.formatMoney) then
	-- 	return DarkRP.formatMoney(n)
	if 1 == 0 then
	else
		if not n then return attachCurrency("0") end

		if n >= 1e14 then return attachCurrency(tostring(n)) end
		if n <= -1e14 then return "-" .. attachCurrency(tostring(math.abs(n))) end

		local negative = n < 0

		n = tostring(math.abs(n))
		local sep = sep or ","
		local dp = string.find(n, "%.") or #n + 1

		for i = dp - 4, 1, -3 do
			n = n:sub(1, i) .. sep .. n:sub(i + 1)
		end

		return (negative and "-" or "") .. attachCurrency(n)
	end
end

local function attachCurrency2(str)
	local config = GAMEMODE.Config
	if (!config) then
		return "$"..str
	end

	local cr = " донат-монет"
	return config.currencyLeft and str .. cr or str .. cr
end

function SH_ACC.formatMoney2(n)
	if (DarkRP and DarkRP.formatMoney) then
	 	return DarkRP.formatMoney(n)
	else
		if not n then return attachCurrency("0") end

		if n >= 1e14 then return attachCurrency(tostring(n)) end
		if n <= -1e14 then return "-" .. attachCurrency(tostring(math.abs(n))) end

		local negative = n < 0

		n = tostring(math.abs(n))
		local sep = sep or ","
		local dp = string.find(n, "%.") or #n + 1

		for i = dp - 4, 1, -3 do
			n = n:sub(1, i) .. sep .. n:sub(i + 1)
		end

		return (negative and "-" or "") .. attachCurrency(n)
	end
end
--PATH addons/viktor_barinov_chef_2607227837/lua/autorun/barinovpm.lua:
player_manager.AddValidModel( "Barinov", "models/kuhnya/barinov.mdl" )
player_manager.AddValidHands( "Barinov", "models/weapons/c_arms_citizen.mdl", 0, "00000000" )

--PATH addons/the_cocaine_factory/lua/ch_cocaine/shared/cocaine_config_lang.lua:
-- I DO NOT ADVISE YOU TRY TO EDIT BELOW THIS LINE UNLESS YOU UNDERSTAND HOW THIS WORKS!
-- IF YOU WANT TO ADD A LANAGUE PLEASE OPEN A SUPPORT TICKET ON GMODSTORE.
-- I WILL HELP YOU WITH ANYTHING YOU NEED AND ADD THE LANGUAGE TO THE OFFICIAL SCRIPT.
TCF.Config.Lang = {}

-- STOVE
TCF.Config.Lang["Your stove has exploded and caught fire due to taking an excessive amount of damage!"] = {
	["en"] = "Your stove has exploded and caught fire due to taking an excessive amount of damage!",
	["fr"] = "Votre cuisinière a explosé et pris feu en raison de dégâts excessifs!",
	["da"] = "Dit komfur er eksploderet og brænder nu på grund af en stor mængde skade!",
	["de"] = "Dein Ofen ist explodiert und brennt nun aufgrund einer großen Menge an Schäden!",
	["pl"] = "Twój piec wybuchł i pali się z powodu nadmiernych uszkodzeń!",
	["ru"] = "Ваша плита загорелась и взорвалась от полученного избыточного урона.",
	["es"] = "¡Su estufa se explotó debido a daños excesivos!",
	["cn"] = "你的炉子因受到严重损坏而着火了.",
}
TCF.Config.Lang["Your stove has exploded due to taking an excessive amount of damage!"] = {
	["en"] = "Your stove has exploded due to taking an excessive amount of damage!",
	["fr"] = "Votre cuisinière a explosé en raison de dégâts excessifs!",
	["da"] = "Dit komfur er eksploderet på grund af en stor mængde skade!",
	["de"] = "Dein Ofen brennt aufgrund einer großen Menge an Schäden!",
	["pl"] = "Twój piec wybuchł z powodu nadmiernych uszkodzeń!",
	["ru"] = "Ваша плита взорвалась от полученного избыточного урона.",
	["es"] = "¡Su estufa se explotó por un daño excesivo!",
	["cn"] = "你的炉子因受到严重损坏而爆炸了",
}

TCF.Config.Lang["There is no cooking plate attached. Please purchase a plate for this cooker before turning it on!"] = {
	["en"] = "There is no cooking plate attached. Please purchase a plate for this cooker before turning it on!",
	["fr"] = "Il n'y a pas de plaque de cuisson. Veuillez acheter une plaque pour cette cuisinière avant de l'allumer!",
	["da"] = "Der er ingen kogeplade tilsluttet. Køb venligst en kogeplade til dit komfur, inden du tænder det!",
	["de"] = "Es ist keine Kochplatte angeschlossen. Bitte kauf eine Platte für diesen Kocher bevor du ihn einschaltest!",
	["pl"] = "Nie zamontowano płyty do gotowania. Zakup ją zanim uruchomisz piec!",
	["ru"] = "Отсутсвует конфорка! Пожалуйста приобретите конфорку для этой плиты до её включения!",
	["es"] = "No hay ningun plato ajustado. ¡Por favor, compre un plato y ajustalo antes de que se encienda la máquina!",
	["cn"] = "没有烹饪盘.打开这个炊具前请先给它买个盘子!",
}
TCF.Config.Lang["There are no gas cans attached to the stove!"] = {
	["en"] = "There are no gas cans attached to the stove!",
	["fr"] = "Il n'y a pas de bidon d'essence sur la cuisinière!",
	["da"] = "Der er ingen gas tilsluttet til dit komfur!",
	["de"] = "Es sind keine Gaskannen an den Ofen angeschlossen!",
	["pl"] = "Nie zamontowano butli gazowej.",
	["ru"] = "В плите отсутсвуют газовые баллоны!",
	["es"] = "¡No hay latas de gas ajustados a la estufa!",
	["cn"] = "炉子上没有煤气罐!",
}
TCF.Config.Lang["The cooking plate has been successfully installed on your stove."] = {
	["en"] = "The cooking plate has been successfully installed on your stove.",
	["fr"] = "La plaque de cuisson a été installée avec succès sur votre cuisinière.",
	["da"] = "Kogepladen er blevet installeret med succes.",
	["de"] = "The Kochplatte wurde erfolgreich an deinem Ofen installiert.",
	["pl"] = "Pomyślnie zamontowano płytę do gotowania na twoim piecu.",
	["ru"] = "Конфорка успешно установлена на вашу плиту.",
	["es"] = "El plato se ha ajustado con éxito en su estufa.",
	["cn"] = "烹饪盘已经成功地安装在你的炉子上了.",
}
TCF.Config.Lang["Your stove cannot fit more cooking plates."] = {
	["en"] = "Your stove cannot fit more cooking plates.",
	["fr"] = "Votre cuisinière ne peut pas accueillir plus de plaques de cuisson.",
	["da"] = "Der er ikke plads til flere kogeplader på dit komfur.",
	["de"] = "Dein Ofen hat keinen Platz mehr für mehr Kochplatten.",
	["pl"] = "Twój piec nie może pomieścić już więcej płyt do gotowania.",
	["ru"] = "На вашей плите не осталось места под новые конфорки.",
	["es"] = "Su estufa no tiene más espacio para platos.",
	["cn"] = "你的炉子放不下更多的盘子.",
}
TCF.Config.Lang["Your stove has ran out of gas and all cooking process has stopped."] = {
	["en"] = "Your stove has ran out of gas and all cooking process has stopped.",
	["fr"] = "Votre cuisinière est à court de gaz et la cuisson s'est arrêtée.",
	["da"] = "Dit komfur er løbet tur for gas. Alle processer er stoppet midlertidigt.",
	["de"] = "Dein Ofen hat kein Gas mehr und daher wurden alle Kochprozesse gestoppt.",
	["pl"] = "W twoim piecu brakuje gazu, gotowanie przerwane.",
	["ru"] = "В вашей плите кончился газ и все процессы приготовления остановлены.",
	["es"] = "Su estufa se ha quedado sin gas y todo el proceso se paro.",
	["cn"] = "你的炉子没油了,所有的烹饪过程都停止了.",
}

-- COCAINE BOX
TCF.Config.Lang["You have confiscated a box of cocaine. You've been rewarded"] = {
	["en"] = "You have confiscated a box of cocaine. You've been rewarded",
	["fr"] = "Vous avez confisqué une boîte de cocaïne. Vous avez été récompensé",
	["da"] = "Du konfiskerede en kasse med kokain. Din belønning er",
	["de"] = "Du hast eine Box Kokain konfisziert. Deine Belohnung ist",
	["pl"] = "Skonfiskowałeś pudełko kokainy. Zostajesz nagrodzony",
	["ru"] = "Вы конфисковали коробку с кокаином. Вас вознаградили",
	["es"] = "Has confiscado una caja completo de cocaína. Has sido recompensado",
	["cn"] = "你交了一盒可卡因.你得到了奖励",
}
TCF.Config.Lang["Your box packed with cocaine has been closed and is ready for sale at the druggie."] = {
	["en"] = "Your box packed with cocaine has been closed and is ready for sale at the druggie.",
	["fr"] = "Votre boîte de cocaïne a été fermée et est prête à être vendue à un acheteur.",
	["da"] = "Din kasse med kokain er lukket og er klar til salg hos narkotika forhandleren.",
	["de"] = "Deine Box mit Kokain wurde verschlossen und ist bereit zum Verkauf beim Drogenhändler.",
	["pl"] = "Zamknąłeś pudełko kokainy, możesz je teraz sprzedać.",
	["ru"] = "Ваша коробка с кокаином закрыта и готова к продаже дилеру.",
	["es"] = "Su caja esta llena y se ha cerrada ya está lista para distribución.",
	["cn"] = "你装有可卡因的盒子已经关上了,可以在NPC处出售了",
}
TCF.Config.Lang["Your box has been opened again. You can put more packed cocaine in it now."] = {
	["en"] = "Your box has been opened again. You can put more packed cocaine in it now.",
	["fr"] = "Votre boîte est à nouveau ouverte. Vous pouvez mettre plus de cocaïne dedans.",
	["da"] = "Din boks er blevet genåbnet. Du kan nu tilføje mere kokain.",
	["de"] = "Deine Box wurde erneut geöffnet. Du kannst nun mehr Kokain hineingeben.",
	["pl"] = "Otworzyłeś pudełko, możesz teraz włożyć więcej zapakowanej kokainy.",
	["ru"] = "Ваша коробка снова открыта. Можете класть внутрь упаковки с кокаином.",
	["es"] = "Su caja se ha abierto de nuevo. Ya puedes empacar más cocaína.",
	["cn"] = "你的箱子被打开了.你现在可以在里面放更多的可卡因了",
}

-- DRYING RACK
TCF.Config.Lang["Cocaine poured out on the drying rack."] = {
	["en"] = "Cocaine poured out on the drying rack.",
	["fr"] = "La cocaïne se répand sur le séchoir.",
	["da"] = "Kokainen er blevet hældt ud over tørrings bordet.",
	["de"] = "Kokain ausgeschüttet auf dem Trockenblech.",
	["pl"] = "Położono kokainę do wyschnięcia.",
	["ru"] = "Кокаин высыпан на просушку.",
	["es"] = "La cocaína se goteo sobre la rejilla.",
	["cn"] = "可卡因倒在晾衣架上",
}
TCF.Config.Lang["The drying process has finished and is now ready."] = {
	["en"] = "The drying process has finished and is now ready",
	["fr"] = "Le processus de séchage est terminé.",
	["da"] = "Tørringsprocessen er nu færdig og din kokain er klar.",
	["de"] = "Der Trocknungsprozess ist nun abgeschlossen und bereit.",
	["pl"] = "Kokaina wyschła i jest gotowa!",
	["ru"] = "Просушка завершена, всё готово.",
	["es"] = "El proceso de secamiento ha terminado y ya está listo.",
	["cn"] = "干燥过程已经完成,现在准备就绪",
}
TCF.Config.Lang["Put the cocaine pack in your drug holder box."] = {
	["en"] = "Put the cocaine pack in your drug holder box.",
	["fr"] = "Mettez le paquet de cocaïne dans votre boîte de cocaïne.",
	["da"] = "Put den færdige kokain ned i boksen.",
	["de"] = "Gib das Kokain-Päckchen in deine Drogenbox.",
	["pl"] = "Włóż paczkę kokainy do pudełka na dragi.",
	["ru"] = "Положите упаковку с кокаином в коробку для упаковок.",
	["es"] = "Ponga el paquete de cocaína en su caja de drogas.",
	["cn"] = "把可卡因包放在你的箱子里",
}
TCF.Config.Lang["The machine is currently drying the cocaine!"] = {
	["en"] = "The machine is currently drying the cocaine!",
	["fr"] = "La machine est en train de sécher la cocaïne!",
	["da"] = "Tørringsprocessen er i gang. Vent venligst.",
	["de"] = "Die Maschine trocknet gerade das Kokain!",
	["pl"] = "Maszyna obecnie suszy kokainę!",
	["ru"] = "Устройство уже сушит кокаин!",
	["es"] = "¡La máquina está secando la cocaína actualmente!",
	["cn"] = "该机器目前正在烘干可卡因!",
}
TCF.Config.Lang["There are no batteries connected to the drying rack!"] = {
	["en"] = "There are no batteries connected to the drying rack!",
	["fr"] = "Il n'y a pas de piles connectées au séchoir!",
	["da"] = "Der er ikke tilsluttet noget batteri til tørrings bordet!",
	["de"] = "Es sind keine Batterien am Wäscheständer angeschlossen!",
	["pl"] = "Do suszarki nie są podłączone żadne baterie!",
	["ru"] = "В сушильном столе отсутствуют батареи!",
	["es"] = "¡No hay baterías conectadas a la rejilla de secado!",
	["cn"] = "晾衣架上没有连接电池!",
}
TCF.Config.Lang["Batteries ran out of energy and the drying rack has been turned off!"] = {
	["en"] = "Batteries ran out of energy and the drying rack has been turned off!",
	["fr"] = "Les piles se sont épuisées et le séchoir a été éteint!",
	["da"] = "Batteriet er løbet tør for strøm og tørrings bordet er blevet slukket!",
	["de"] = "Die Batterien haben keinen Strom mehr und der Wäscheständer wurde ausgeschaltet!",
	["pl"] = "Akumulatory wyczerpały się, a stojak do suszenia został wyłączony!",
	["ru"] = "В батареях закончилась энергия и сушильный стол отключился!",
	["es"] = "¡Las baterías se quedaron sin energía y la rejilla de secado se ha apagado!",
	["cn"] = "电池电量耗尽，晾衣架已经关闭!",
}
TCF.Config.Lang["The drying rack had ran out of energy and failed the process."] = {
	["en"] = "The drying rack had ran out of energy and failed the process.",
	["fr"] = "Le séchoir était à court d'énergie et a échoué.",
	["da"] = "Tørrings bordet løb tør for batteri og processen fejlede.",
	["de"] = "Dem Wäscheständer war die Energie ausgegangen und der Vorgang fehlgeschlagen.",
	["pl"] = "W suszarce skończyła się energia i proces się nie powiódł.",
	["ru"] = "В сушильном столе закончилась энергия и процесс сушки был прерван.",
	["es"] = "La rejilla de secado se había quedado sin energía y falló el proceso.",
	["cn"] = "晾衣架耗尽了能量并且失败了.",
}

-- EXTRACTOR
TCF.Config.Lang["Your cocaine extractor has exploded and caught fire due to taking an excessive amount of damage!"] = {
	["en"] = "Your cocaine extractor has exploded and caught fire due to taking an excessive amount of damage!",
	["fr"] = "Votre extracteur de cocaïne a explosé et pris feu en raison de dégâts excessifs!",
	["da"] = "Din kokain ekstraktor er eksploderet og brænder nu på grund af en stor mængde skade!",
	["de"] = "Dein Kokainextraktor ist explodiert und hat Feuer gefangen aufgrund einer hohen Menge an Schäden!",
	["pl"] = "Twój ekstraktor kokainy wybuchł i pali się z powodu nadmiernych uszkodzeń!",
	["ru"] = "Ваш экстрактор загорелся и взорвался от полученного избыточного урона.",
	["es"] = "¡Su extractor de cocaína se exploto y se incendió debido a algunos daños excesivos!",
	["cn"] = "你的可卡因提取器因受到严重伤害而起火了.",
}
TCF.Config.Lang["Your cocaine extractor has exploded due to taking an excessive amount of damage!"] = {
	["en"] = "Your cocaine extractor has exploded due to taking an excessive amount of damage!",
	["fr"] = "Votre extracteur de cocaïne a explosé en raison de dégâts excessifs!",
	["da"] = "Din kokain ekstraktor er eksploderet på grund af en stor mængde skade!",
	["de"] = "Dein Kokainextraktor ist aufgrund einer hohen Menge an Schäden explodiert!",
	["pl"] = "Twój ekstraktor kokainy wybuchł z powodu nadmiernych uszkodzeń!",
	["ru"] = "Ваш экстрактор взорвался от полученного избыточного урона.",
	["es"] = "¡Su extractor de cocaína se ha explotado debido a un daño excesivo!",
	["cn"] = "你的可卡因提取器因为受到过多的伤害而爆炸了!",
}
TCF.Config.Lang["The machine is already extracting the cocaine!"] = {
	["en"] = "The machine is already extracting the cocaine!",
	["fr"] = "La machine extrait déjà de la cocaïne!",
	["da"] = "Din kokain ekstraktor er allerede tændt!",
	["de"] = "Die Maschine extrahiert bereits Kokain!",
	["pl"] = "Maszyna już przeprowadza ekstrakcję!",
	["ru"] = "Экстрактор уже извлекает кокаин!",
	["es"] = "¡Su extractor ya está extrayendo la cocaína!",
	["cn"] = "机器已经在提取可卡因了!",
}
TCF.Config.Lang["There is no bucket attached to the extractor."] = {
	["en"] = "There is no bucket attached to the extractor.",
	["fr"] = "Il n'y a pas de seau attaché à l'extracteur.",
	["da"] = "Der er ingen spand installeret til ekstraktoren.",
	["de"] = "Es ist kein Eimer an den Extraktor angeschlossen.",
	["pl"] = "Nie zamontowano wiadra w ekstraktorze.",
	["ru"] = "В экстракторе отсутсвует ведро.",
	["es"] = "No hay ningún cubo conectado al extractor.",
	["cn"] = "提取器上没有桶",
}
TCF.Config.Lang["There is not enough finished mixture or leaves in the extractor."] = {
	["en"] = "There is not enough finished mixture or leaves in the extractor.",
	["fr"] = "Il n’ya pas assez de bicarbonate de soude ou de feuilles dans l’extracteur.",
	["da"] = "Der er ikke nok færdigblanding fra komfuret eller blade i ekstraktoren.",
	["de"] = "Es ist nicht genug fertige Mischung oder Blätter im Extraktor.",
	["pl"] = "Za mało proszku lub liści w ekstraktorze.",
	["ru"] = "В экстракторе не хватает микстуры из соды или листьев.",
	["es"] = "No hay suficiente mezcla o hojas en el extractor.",
	["cn"] = "提取器中没有足够的成品混合物或树叶.",
}
TCF.Config.Lang["The cocaine has been successfully extracted. The bucket is now ready!"] = {
	["en"] = "The cocaine has been successfully extracted. The bucket is now ready!",
	["fr"] = "La cocaïne a été extraite avec succès. Le seau est prêt!",
	["da"] = "Kokainen er blevet udtaget med succes. Spanden er nu fyldt og klar til at blive fjernet.",
	["de"] = "Das Kokain wurde erfolgreich extrahiert. Der Eimer ist nun bereit!",
	["pl"] = "Kokaina została wyekstraktowana. Wiadro jest gotowe!",
	["ru"] = "Экстрактор завершил извлекать кокаин! Ведро заполнено и готово!",
	["es"] = "La cocaína ha sido extraída con éxito. ¡El cubo ya está listo!",
	["cn"] = "可卡因已被成功提取.桶现在准备好了!",
}
TCF.Config.Lang["Bucket successfully attached. You can start the extractor once it's loaded with finished mixture and leaves."] = {
	["en"] = "Bucket successfully attached. You can start the extractor once it's loaded with baking soda and leaves.",
	["fr"] = "Seau attaché avec succès. Vous pouvez démarrer l'extracteur une fois le bicarbonate de soude et les feuilles chargées.",
	["da"] = "Spand installeret korrekt. Du kan starte ekstraktoren, når den er fyldt med færdigblanding fra komfuret og blade.",
	["de"] = "Eimer erfolgreich angeschlossen. Du kannst den Extraktor starten wenn er mit Fertigmischung und Blättern gefüllt ist.",
	["pl"] = "Wiadro zamontowane. Możesz włączyć ekstraktor gdy załadujesz je proszkiem do pieczenia i liścmi.",
	["ru"] = "Ведро успешно установлено. Теперь можете запускать экстрактор как только достаточно заполните его микстурой из соды и листьями.",
	["es"] = "El Cubo esta adjustado. Ya puedes iniciar el motor de la maquina una vez que esté cargado con bicarbonato de sodio y hojas.",
	["cn"] = "已成功安装存储桶.一旦装满了小苏打和树叶,你就可以启动提取器.",
}

-- DRUG BUYER NPC
TCF.Config.Lang["Your box contains no cocaine. Are you trying to scam me?"] = {
	["en"] = "Your box contains no cocaine. Are you trying to scam me?",
	["fr"] = "Votre boîte ne contient pas de cocaïne. Est-ce que vous essayez de m'arnaquer?",
	["da"] = "Der er ingen kokain i din pakke. Prøver du at snyde mig?",
	["de"] = "Deine Box enthält kein Kokain. Versuchst du mich zu verarschen?",
	["pl"] = "W tym pudełku nie ma kokainy. Chcesz mnie wystrychnąć na dudka?",
	["ru"] = "В твоей коробке отсутсвует кокаин. Ты пытаешься меня обмануть?",
	["es"] = "Su caja no tiene ningun rastro de cocaína. ¿Estás tratando de engañame?",
	["cn"] = "你的箱子里没有可卡因.你想骗我吗?CNM的.",
}
TCF.Config.Lang["Close the box before trying to sell it, rookie."] = {
	["en"] = "Close the box before trying to sell it, rookie.",
	["fr"] = "Fermes la boîte avant d'essayer de la vendre, rookie.",
	["da"] = "Luk boksen før du prøver at sælge den!",
	["de"] = "Schließ die Box bevor du sie verkaufst, Anfänger.",
	["pl"] = "Zamknij pudełko przed sprzedażą, głupolu.",
	["ru"] = "Закрой коробку перед продажей, дилетант.",
	["es"] = "Cierra la caja antes de intentar venderla, pendejo.",
	["cn"] = "SB么,在卖之前把盒子关上.你想让谁看？条子吗?",
}
TCF.Config.Lang["Please bring the box closer to the druggie."] = {
	["en"] = "Please bring the box closer to the druggie.",
	["fr"] = "Rapprochez la boite du traffiquant",
	["da"] = "Placer venligst boksen tættere på narkohandleren.",
	["de"] = "Bring deine Box näher zum Händler.",
	["pl"] = "Podejdź bliżej z pudełkiem.",
	["ru"] = "Пожалуйста поднесите коробку ближе к дилеру.",
	["es"] = "Por favor traiga la caja más cerca al drogadicto.",
	["cn"] = "请把箱子扔到NPC脚边",
}
TCF.Config.Lang["I don't want to speak with you in your current position, go away!"] = {
	["en"] = "I don't want to speak with you in your current position, go away!",
	["fr"] = "Je ne veux pas parler avec vous dans votre position actuelle, partez!",
	["da"] = "Jeg snakker ikke med folk fra det offentlige, forsvind!",
	["de"] = "Ich will in seiner aktuellen Verfassung nicht mit dir reden, geh weg!",
	["pl"] = "Nie chcę teraz rozmawiać, odejdź!",
	["ru"] = "Учитывая твоё текущее положение я не хочу вести с тобой дела, проваливай!",
	["es"] = "No quiero hablar contigo en tu posición actual, vete!",
	["cn"] = "我不认识你,你是谁,你专门做这个么？走开.",
}
TCF.Config.Lang["You've just sold your cocaine for"] = {
	["en"] = "You've just sold your cocaine for",
	["fr"] = "Vous avez vendu votre cocaïne pour",
	["da"] = "Du har lige solgt dit kokain for",
	["de"] = "Du verkaufst dein Kokain für einen Gesamterlös von",
	["pl"] = "Sprzedałeś kokainę za",
	["ru"] = "Вы продали кокаина на",
	["es"] = "Vendiste tu cocaína por",
	["cn"] = "你刚刚把可卡因卖了",
}

-- DRUG BUYER NPC MENU
-- These are just in English by default. Change them to whatever language you like.
TCF.Config.RandomHeySentences = {
	"Yo dawg",
	"Hey rookie!",
	"What's up, Bruh?",
	"Wassup?",
	"What's good?"
}

--[[
DANISH
TCF.Config.RandomHeySentences = { "Hva så?", "Hvad sker der?", "Alt vel?", "Hvad vil du?", "Var der noget?" }

POLISH
TCF.Config.RandomHeySentences = { "Siema brachu", "Eluwa!", "Co słychać?", "Pozdrowienia do więzenia", "Co tam?" }

GERNMAN
TCF.Config.RandomHeySentences = { "Hey Mann!", "Hey du!", "Was geht, Bruder?", "Was geht abbb?", "Was los?" }

RUSSIAN
TCF.Config.RandomHeySentences = { "Здарова", "Доров, братишка", "Как оно?", "Хай", "Что нового?" }

CHINESE
TCF.Config.RandomHeySentences = { "呦 老兄!", "嘿 小屁孩!", "怎么了 兄弟?", "怎么了?", "有什么好消息?" }

SPANISH
TCF.Config.RandomHeySentences = { "Hola Güey", "Oye Nevato!", "Como estas, amigo?", "Qué tal?", "Que Mas?" }

FRENCH
TCF.Config.RandomHeySentences = { "Yo mon pote", "Hey la recrue!", "Quoi de neuf?", "Hey poto!", }
--]]

-- NPC sentence for 1 package. \n means new line. You can use that or you can just write in one, it will jump to a new line automatically.
TCF.Config.Lang["I see that you have brought me a box with just 1 package?\nThat's not a lot of cocaine, but I will still offer you a minor sum of money for your product."] = {
	["en"] = "I see that you have brought me a box with just 1 package?\nThat's not a lot of cocaine, but I will still offer you a minor sum of money for your product.",
	["fr"] = "Je vois que tu m'as apporté une boîte avec un seul colis?\nIl n’ya pas beaucoup de cocaïne, mais je vais tout de même t'offrir une petite somme d’argent pour ton produit.",
	["da"] = "Jeg kan se du har en boks med til mig? Ærgerligt den kun indeholder 1 pakke. Jeg vil stadig gerne betale lidt for det, hvad siger du?",
	["de"] = "Ich sehe, dass du mir eine Box mit einem Päckchen mitgebracht hast.\nDas ist zwar nicht viel, aber ich gebe dir trotzdem ein bisschen Geld dafür.",
	["pl"] = "Przyniosłeś mi pudełko z tylko 1 paczką?\nTo niewiele, ale odpalę ci trochę forsy.",
	["ru"] = "Я гляжу ты принёс мне коробку всего с 1 упаковкой?\nЯ ожидал большего, но всёравно сделаю тебе ценовое предложение, хоть и небольшое.",
	["es"] = "Veo que me trajiste una caja con solo 1 paquete?\nNo es mucha cocaína, pero te ofreco una pequeña suma de dinero por tu producto.",
	["cn"] = "我看到你给我带来了一个只有一个包裹的盒子?\n东西不多,但我还是会给你一点钱买你的",
}
-- NPC sentence for 2 packages.
TCF.Config.Lang["I see that you have brought me a box with 2 packages?\nSo here is the deal. I'd like to offer you a fair amount of money for your product."] = {
	["en"] = "I see that you have brought me a box with 2 packages?\nSo here is the deal. I'd like to offer you a fair amount of money for your product.",
	["fr"] = "Je vois que tu m'as apporté une boîte avec 2 paquets?\nVoici le deal, j'aimerais t'offrir une bonne somme d'argent pour ton produit.",
	["da"] = "Jeg kan se du har en boks med til mig? Ærgerligt den kun indeholder 2 pakker. Jeg vil stadig gerne betale lidt for det, hvad siger du?",
	["de"] = "Ich sehe, dass du mir eine Box mit zwei Päckchen mitgebracht hast.\nHier ist der Deal. Ich geb dir eine faire Summe Geld für dein Produkt.",
	["pl"] = "Przyniosłeś mi pudełko z tylko 2 paczkami?\nSprawa wygląda tak: zapłacę godziwie za twój produkt.",
	["ru"] = "Я гляжу ты принёс мне коробку с 2 упаковками?\nПредлагаю тебе вот эту умеренную сумму денег за твой товар.",
	["es"] = "Veo que me trajiste una caja con 2 paquetes?\nEsta bien. Me gustaría ofrecerle una buena commission por su producto.",
	["cn"] = "我看到你给我带来了一个只有两个包裹的盒子?\n这就是交易.我想为你的东西提供相当数量的钱",
}
-- NPC sentence for 3 packages.
TCF.Config.Lang["I see that you have brought me a box with 3 packages?\nGreat work!. I would like to offer you a large sum of money for your packages."] = {
	["en"] = "I see that you have brought me a box with 3 packages?\nGreat work!. I would like to offer you a large sum of money for your packages.",
	["fr"] = "Je vois que tu m'as apporté une boîte avec 3 paquets?\nBon travail! J'aimerais t'offrir une grosse somme d'argent pour ton produit.",
	["da"] = "Det har du gjort godt! Hele 3 pakker med kokain. Jeg vil gerne betale dig en stor sum penge for dit arbejde. Har vi en aftale eller hvad?",
	["de"] = "Ich sehe, dass du mir eine Box mit 3 Päckchen mitgebracht hast.\nGut gemacht! Ich biete dir mit Vergnügen eine hohe Summe Geld für deine Päckchen.",
	["pl"] = "Przyniosłeś mi pudełko z tylko 3 paczkami?\nDam ci za nie całkiem sporo mamony.",
	["ru"] = "Я гляжу ты принёс мне коробку с 3 упаковками?\nОтличная работа! Это стоит больших денег поэтому вот моё предложение за твой товар.",
	["es"] = "Veo que me trajiste una caja con 3 paquetes?\n¡Buen Hecho! te voy ha ofrecer una gran suma de dinero por sus paquetes.",
	["cn"] = "我看到你给我带来了一个只有三个包裹的盒子?\n太棒了!我想给你一大笔钱买你的东西",
}
-- NPC sentence for 4 packages.
TCF.Config.Lang["Ahh finally! I've been waiting for someone to bring me a full load of cocaine.\nI like your style, and would like to offer you a large sum of money for your packages."] = {
	["en"] = "Ahh finally! I've been waiting for someone to bring me a full load of cocaine.\nI like your style, and would like to offer you a large sum of money for your packages.",
	["fr"] = "Ahh enfin! J'attendais que quelqu'un m'apporte un chargement de cocaïne plein!\nJ'aime ton style, je voudrais t'offrir une grosse somme d'argent pour ton produit.",
	["da"] = "Endelig en der kan levere varen! Du har formået at fylde boksen og det skal du belønnes for. Har en stor sum penge til dig, hvad siger du?",
	["de"] = "Endlich! Ich habe schon darauf gewartet, das mir jemand eine volle Ladung Kokain bringt.\nIch mag deinen Style, und ich würde dir gerne eine große Summe an Geld für deine Päckchen anbieten.",
	["pl"] = "W końcu! Długo czekałem aż ktoś przyniesie pełne pudełko!\nDostaniesz za nie grubą kasę.",
	["ru"] = "Наконец то! Я уже думал никто в этом городе не способен на такое.\nМне нравится твой стиль, мы вместе с тобой разбогатеем, а пока держи эту огромную сумму денег.",
	["es"] = "¡Ahh por fin! He estado esperando que alguien me traiga una caja completa de cocaína.\nMe gusta tu trabajo y te voy ha ofrecer una gran suma de dinero por sus paquetes.",
	["cn"] = "呦呦呦看看这是哪个老板给我带来满箱子的东西.\n我喜欢你的风格,愿意为你的东西提供一大笔钱",
}
TCF.Config.Lang["Pack"] = {
	["en"] = "Pack",
	["fr"] = "Paquet",
	["da"] = "Pakke",
	["de"] = "Pack",
	["pl"] = "Paczka",
	["ru"] = "Упаковка",
	["es"] = "Paquete",
	["cn"] = "包裹",
}
TCF.Config.Lang["Packs"] = {
	["en"] = "Packs",
	["fr"] = "Paquets",
	["da"] = "Pakker",
	["de"] = "Päckchen",
	["pl"] = "Paczki",
	["ru"] = "Упаковки",
	["es"] = "Paquetes",
	["cn"] = "包裹",
}
TCF.Config.Lang["Rank Bonus"] = {
	["en"] = "Rank Bonus",
	["fr"] = "Bonus de Rang",
	["da"] = "Rank Bonus",
	["de"] = "Rang-Bonus",
	["pl"] = "Bonus za rangę",
	["ru"] = "Бонус за ранк",
	["es"] = "Bono de Rango",
	["cn"] = "级别奖金",
}
TCF.Config.Lang["No Bonus"] = {
	["en"] = "No Bonus",
	["fr"] = "Aucun bonus",
	["da"] = "Ingen Bonus",
	["de"] = "Kein Bonus",
	["pl"] = "Brak bonusu",
	["ru"] = "Без бонуса",
	["es"] = "Sin Bonificación",
	["cn"] = "没有奖金",
}
TCF.Config.Lang["Accepting the druggies offer will give you"] = {
	["en"] = "Accepting the druggies offer will give you",
	["fr"] = "Accepter l'offre proposée par le traffiquant",
	["da"] = "Hvis du acceptere får du",
	["de"] = "Das Annehmen des Angebotes gibt dir",
	["pl"] = "Zaakceptowanie oferty da ci",
	["ru"] = "Приняв предложение дилера вы получите",
	["es"] = "Aceptar la oferta de drogas te dará",
	["cn"] = "接受NPC的报价会给你",
}
TCF.Config.Lang["Decline the druggies offer and leave the shop!"] = {
	["en"] = "Decline the druggies offer and leave the shop!",
	["fr"] = "Rejetez l'offre du trafiquant et quittez le magasin!",
	["da"] = "Afvis tilbudet og forlad dealeren.",
	["de"] = "Lehne das Angebot am und verlasse den Laden!",
	["pl"] = "Odrzuć ofertę i wyjdź ze sklepu.",
	["ru"] = "Отклонить предложение дилера и покинуть это место!",
	["es"] = "¡Rechace la oferta de drogueros y salga de la tienda!",
	["cn"] = "拒绝NPC的报价,离开商店,滚蛋.",
}
TCF.Config.Lang["Accept"] = {
	["en"] = "Accept",
	["fr"] = "Accepter",
	["da"] = "Accepter",
	["de"] = "Annehmen",
	["pl"] = "Potwierdź",
	["ru"] = "Принять",
	["es"] = "Aceptar",
	["cn"] = "接受",
}
TCF.Config.Lang["Decline"] = {
	["en"] = "Decline",
	["fr"] = "Refus",
	["da"] = "Afvis",
	["de"] = "Ablehnen",
	["pl"] = "Odrzuć",
	["ru"] = "Отклонить",
	["es"] = "Declinar",
	["cn"] = "拒绝",
}

--[[
TCF.Config.Lang[""] = {
	["en"] = "",
	["fr"] = "",
}
--]]
--PATH addons/cook_and_doog/lua/autorun/doggeplayer.lua:
player_manager.AddValidModel( "Doge", "models/doge_player/doge_player.mdl" )
player_manager.AddValidHands( "Doge", "models/doge_player/doge_arms.mdl", 0, "00000000" )

--PATH addons/cp_bricks_enchanced_sweps/lua/autorun/dsr_autorun.lua:
BES = {}
BES.CONFIG = {}

AddCSLuaFile( "bes_config.lua" )
include( "bes_config.lua" )

--[[ LOADS FILES ]]--
for k, v in pairs( file.Find( "bricksenchancedsweps/languages/*", "LUA" ) ) do
	if( string.Replace( v, ".lua" ) == (BES.CONFIG.Language or "") ) then
		AddCSLuaFile( "bricksenchancedsweps/languages/" .. v )
		include( "bricksenchancedsweps/languages/" .. v )
		
		print( "[BES] " .. (BES.CONFIG.Language or "") .. " language loaded" )
	end
end

function BES.L( languageString )
	if( BES.Language and BES.Language[languageString] ) then
		return BES.Language[languageString]
	else
		return "MISSING LANGUAGE"
	end
end

local files, directories = file.Find( "bricksenchancedsweps/*", "LUA" )
for k, v in pairs( files ) do
	AddCSLuaFile( "bricksenchancedsweps/" .. v )
	include( "bricksenchancedsweps/" .. v )
	
	print( "[BRICKSWABESNTEDSYS] SHARED " .. v .. " loaded" )
end

for k, v in pairs( directories ) do
	if( v == "server" ) then
		for key2, val2 in pairs( file.Find( "bricksenchancedsweps/" .. v .. "/*.lua", "LUA" ) ) do
			if( SERVER ) then
				include( "bricksenchancedsweps/" .. v .. "/" .. val2 )
			end
			
			print( "[BES] SERVER " .. val2 .. " loaded" )
		end
	elseif( v == "client" ) then
		for key2, val2 in pairs( file.Find( "bricksenchancedsweps/" .. v .. "/*.lua", "LUA" ) ) do
			if( CLIENT ) then
				include( "bricksenchancedsweps/" .. v .. "/" .. val2 )
			elseif( SERVER ) then
				AddCSLuaFile( "bricksenchancedsweps/" .. v .. "/" .. val2 )
			end
			
			print( "[BES] CLIENT " .. val2 .. " loaded" )
		end
	end
end
--PATH addons/admin_warns/lua/fam/core/sh_meta.lua:
local PLAYER = FindMetaTable("Player")

function PLAYER:CollectStatistics()
	if FlameAdminManagement.settings.WhoCanTakeWarn[self:SteamID()] ~= nil then return FlameAdminManagement.settings.WhoCanTakeWarn[self:SteamID()] end
	if FlameAdminManagement.settings.WhoCanTakeWarn[self:SteamID64()] ~= nil then return FlameAdminManagement.settings.WhoCanTakeWarn[self:SteamID64()] end
	if FlameAdminManagement.settings.WhoCanTakeWarn[self:GetUserGroup()] ~= nil then return FlameAdminManagement.settings.WhoCanTakeWarn[self:GetUserGroup()] end

	if FlameAdminManagement.config.CollectStatistics[self:GetUserGroup()] then return true end
	if FlameAdminManagement.config.CollectStatistics[self:SteamID()] then return true end
	if FlameAdminManagement.config.CollectStatistics[self:SteamID64()] then return true end

	return false
end

function PLAYER:CanOpenMenu()
	if FlameAdminManagement.settings.WhoCanOpenMenu[self:SteamID()] ~= nil then return FlameAdminManagement.settings.WhoCanOpenMenu[self:SteamID()] end
	if FlameAdminManagement.settings.WhoCanOpenMenu[self:SteamID64()] ~= nil then return FlameAdminManagement.settings.WhoCanOpenMenu[self:SteamID64()] end
	if FlameAdminManagement.settings.WhoCanOpenMenu[self:GetUserGroup()] ~= nil then return FlameAdminManagement.settings.WhoCanOpenMenu[self:GetUserGroup()] end

	if FlameAdminManagement.config.WhoCanOpenMenu[self:GetUserGroup()] then return true end
	if FlameAdminManagement.config.WhoCanOpenMenu[self:SteamID()] then return true end
	if FlameAdminManagement.config.WhoCanOpenMenu[self:SteamID64()] then return true end

	return false
end

function PLAYER:CanGiveWarn()
	if FlameAdminManagement.settings.WhoCanGiveWarn[self:SteamID()] ~= nil then return FlameAdminManagement.settings.WhoCanGiveWarn[self:SteamID()] end
	if FlameAdminManagement.settings.WhoCanGiveWarn[self:SteamID64()] ~= nil then return FlameAdminManagement.settings.WhoCanGiveWarn[self:SteamID64()] end
	if FlameAdminManagement.settings.WhoCanGiveWarn[self:GetUserGroup()] ~= nil then return FlameAdminManagement.settings.WhoCanGiveWarn[self:GetUserGroup()] end

	if FlameAdminManagement.config.WhoCanGiveWarn[self:GetUserGroup()] then return true end
	if FlameAdminManagement.config.WhoCanGiveWarn[self:SteamID()] then return true end
	if FlameAdminManagement.config.WhoCanGiveWarn[self:SteamID64()] then return true end

	return false
end

function PLAYER:CanUseInGameSettings()
	if FlameAdminManagement.settings.WhoCanUseInGameSettings[self:SteamID()] ~= nil then return FlameAdminManagement.settings.WhoCanUseInGameSettings[self:SteamID()] end
	if FlameAdminManagement.settings.WhoCanUseInGameSettings[self:SteamID64()] ~= nil then return FlameAdminManagement.settings.WhoCanUseInGameSettings[self:SteamID64()] end
	if FlameAdminManagement.settings.WhoCanUseInGameSettings[self:GetUserGroup()] ~= nil then return FlameAdminManagement.settings.WhoCanUseInGameSettings[self:GetUserGroup()] end

	if FlameAdminManagement.config.WhoCanUseInGameSettings[self:GetUserGroup()] then return true end
	if FlameAdminManagement.config.WhoCanUseInGameSettings[self:SteamID()] then return true end
	if FlameAdminManagement.config.WhoCanUseInGameSettings[self:SteamID64()] then return true end

	return false
end

function PLAYER:CanReceiveReport()
	if FlameAdminManagement.settings.ReceiveReports[self:SteamID()] ~= nil then return FlameAdminManagement.settings.ReceiveReports[self:SteamID()] end
	if FlameAdminManagement.settings.ReceiveReports[self:SteamID64()] ~= nil then return FlameAdminManagement.settings.ReceiveReports[self:SteamID64()] end
	if FlameAdminManagement.settings.ReceiveReports[self:GetUserGroup()] ~= nil then return FlameAdminManagement.settings.ReceiveReports[self:GetUserGroup()] end

	if type(FlameAdminManagement.config.ReceiveReports) == "function" then
		return FlameAdminManagement.config.ReceiveReports(self)
	end

	if FlameAdminManagement.config.ReceiveReports[self:GetUserGroup()] then return true end
	if FlameAdminManagement.config.ReceiveReports[self:SteamID()] then return true end
	if FlameAdminManagement.config.ReceiveReports[self:SteamID64()] then return true end

	return false
end

function PLAYER:CanSendOnVacation()
	if FlameAdminManagement.settings.CanSendOnVacation[self:SteamID()] ~= nil then return FlameAdminManagement.settings.CanSendOnVacation[self:SteamID()] end
	if FlameAdminManagement.settings.CanSendOnVacation[self:SteamID64()] ~= nil then return FlameAdminManagement.settings.CanSendOnVacation[self:SteamID64()] end
	if FlameAdminManagement.settings.CanSendOnVacation[self:GetUserGroup()] ~= nil then return FlameAdminManagement.settings.CanSendOnVacation[self:GetUserGroup()] end

	if FlameAdminManagement.config.CanSendOnVacation[self:GetUserGroup()] then return true end
	if FlameAdminManagement.config.CanSendOnVacation[self:SteamID()] then return true end
	if FlameAdminManagement.config.CanSendOnVacation[self:SteamID64()] then return true end

	return false
end

--PATH addons/fpp/lua/fprofiler/ui/model.lua:
--[[-------------------------------------------------------------------------
The model describes the data that the drives the UI
Loosely based on the Elm architecture
---------------------------------------------------------------------------]]

local model =
    {
        realm = "client", -- "client" or "server"
        serverAccess = false, -- Whether the player has access to profile the server
        frameVisible = false, -- Whether the frame is visible

        client = {
            status = "Stopped", -- Started or Stopped
            shouldReset = true, -- Whether profiling should start anew
            recordTime = 0, -- Total time spent on the last full profiling session
            sessionStart = nil, -- When the last profiling session was started
            sessionStartSysTime = nil, -- When the last profiling session was started, measured in SysTime
            bottlenecks = {}, -- The list of bottleneck functions
            topLagSpikes = {}, -- Top of lagging functions
            currentSelected = nil, -- Currently selected function

            focusObj = nil, -- The current function being focussed upon in profiling
            focusStr = "", -- The current function name being entered

            toConsole = nil, -- Any functions that should be printed to console

            sourceText = "", -- The text of the source function (if available)
        },

        server = {
            status = "Stopped", -- Started or Stopped
            shouldReset = true, -- Whether profiling should start anew
            bottlenecks = {}, -- The list of bottleneck functions
            recordTime = 0, -- Total time spent on the last full profiling session
            sessionStart = nil, -- When the last profiling session was started
            topLagSpikes = {}, -- Top of lagging functions
            currentSelected = nil, -- Currently selected function

            focusObj = nil, -- The current function being focussed upon in profiling
            focusStr = "", -- The current function name

            toConsole = nil, -- Any functions that should be printed to console

            sourceText = "", -- The text of the source function (if available)
            fromServer = false, -- Whether a change of the model came from the server.
        },
    }


local updaters = {}


--[[-------------------------------------------------------------------------
Update the model.
Automatically calls the registered update hook functions

e.g. updating the realm would be:
FProfiler.UI.updateModel("realm", "server")
---------------------------------------------------------------------------]]
function FProfiler.UI.updateModel(path, value)
    path = istable(path) and path or {path}

    local updTbl = updaters
    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
        updTbl = updTbl and updTbl[path[i]]
    end

    local oldValue = mdlTbl[key]
    mdlTbl[key] = value

    for _, updFunc in ipairs(updTbl and updTbl[key] or {}) do
        updFunc(value, oldValue)
    end
end

--[[-------------------------------------------------------------------------
Update the model of the current realm
---------------------------------------------------------------------------]]
function FProfiler.UI.updateCurrentRealm(path, value)
    path = istable(path) and path or {path}

    table.insert(path, 1, model.realm)

    FProfiler.UI.updateModel(path, value)
end

--[[-------------------------------------------------------------------------
Retrieve a value of the model
---------------------------------------------------------------------------]]
function FProfiler.UI.getModelValue(path)
    path = istable(path) and path or {path}

    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
    end

    return mdlTbl[key]
end

--[[-------------------------------------------------------------------------
Retrieve a value of the model regardless of realm
---------------------------------------------------------------------------]]
function FProfiler.UI.getCurrentRealmValue(path)
    path = istable(path) and path or {path}

    table.insert(path, 1, model.realm)

    return FProfiler.UI.getModelValue(path)
end

--[[-------------------------------------------------------------------------
Registers a hook that gets triggered when a certain part of the model is updated
e.g. FProfiler.UI.onModelUpdate("realm", print) prints when the realm is changed
---------------------------------------------------------------------------]]
function FProfiler.UI.onModelUpdate(path, func)
    path = istable(path) and path or {path}

    local updTbl = updaters
    local mdlTbl = model
    local key = path[#path]

    for i = 1, #path - 1 do
        mdlTbl = mdlTbl[path[i]]
        updTbl[path[i]] = updTbl[path[i]] or {}
        updTbl = updTbl[path[i]]
    end

    updTbl[key] = updTbl[key] or {}

    table.insert(updTbl[key], func)

    -- Call update with the initial value
    if mdlTbl[key] ~= nil then
        func(mdlTbl[key], mdlTbl[key])
    end
end

--[[-------------------------------------------------------------------------
Registers a hook to both realms
---------------------------------------------------------------------------]]
function FProfiler.UI.onCurrentRealmUpdate(path, func)
    path = istable(path) and path or {path}

    table.insert(path, 1, "client")
    FProfiler.UI.onModelUpdate(path, function(...)
        if FProfiler.UI.getModelValue("realm") == "server" then return end

        func(...)
    end)

    path[1] = "server"
    FProfiler.UI.onModelUpdate(path, function(...)
        if FProfiler.UI.getModelValue("realm") == "client" then return end

        func(...)
    end)
end

--[[-------------------------------------------------------------------------
When the realm is changed, all update functions of the new realm are to be called
---------------------------------------------------------------------------]]
FProfiler.UI.onModelUpdate("realm", function(new, old)
    if not updaters[new] then return end

    for k, funcTbl in pairs(updaters[new]) do
        for _, func in ipairs(funcTbl) do
            func(model[new][k], model[new][k])
        end
    end
end)


--PATH addons/fpp/lua/fprofiler/ui/servercontrol.lua:
local get, update, onUpdate = FProfiler.UI.getModelValue, FProfiler.UI.updateModel, FProfiler.UI.onModelUpdate


--[[-------------------------------------------------------------------------
Update the current selected focus object when data is entered
---------------------------------------------------------------------------]]
onUpdate({"server", "focusStr"}, function(new)
    if not new or get({"server", "fromServer"}) then return end

    net.Start("FProfile_focusObj")
        net.WriteString(new)
    net.SendToServer()
end)

net.Receive("FProfile_focusObj", function()
    update({"server", "focusObj"}, net.ReadBool() and get({"server", "focusStr"}) or nil)
end)

-- A focus update occurs when someone else changes the focus
net.Receive("FProfile_focusUpdate", function()
    update({"server", "fromServer"}, true)

    local focusStr = net.ReadString()
    update({"server", "focusStr"}, focusStr)
    update({"server", "focusObj"}, net.ReadBool() and focusStr or nil)

    update({"server", "fromServer"}, false)
end)

--[[-------------------------------------------------------------------------
(Re)start profiling
---------------------------------------------------------------------------]]
local function restartProfiling()
    local shouldReset = get({"server", "shouldReset"})

    net.Start("FProfile_startProfiling")
        net.WriteBool(shouldReset)
    net.SendToServer()
end

net.Receive("FProfile_startProfiling", function()
    update({"server", "fromServer"}, true)
    update({"server", "status"}, "Started")
    update({"server", "recordTime"}, net.ReadDouble())
    update({"server", "sessionStart"}, net.ReadDouble())
    update({"server", "fromServer"}, false)
end)


--[[-------------------------------------------------------------------------
Stop profiling
---------------------------------------------------------------------------]]
local function stopProfiling()
    net.Start("FProfile_stopProfiling")
    net.SendToServer()
end

-- Read a row from a net message
local function readDataRow(countSize, readSpecific)
    local res = {}

    local count = net.ReadUInt(countSize)

    for i = 1, count do
        local row = {}
        row.info = {}

        row.func = net.ReadString()
        row.info.short_src = net.ReadString()
        row.info.linedefined = net.ReadUInt(16)
        row.info.lastlinedefined = net.ReadUInt(16)

        readSpecific(row)

        table.insert(res, row)
    end

    return res
end

-- Read a bottleneck row
local function readBottleneckRow(row)
    local nameCount = net.ReadUInt(8)

    row.names = {}
    for i = 1, nameCount do
        table.insert(row.names, {
            name = net.ReadString(),
            namewhat = net.ReadString()
        })
    end

    row.total_called = net.ReadUInt(32)
    row.total_time = net.ReadDouble()
    row.average_time = net.ReadDouble()
end

-- Read the top n row
local function readTopNRow(row)
    row.info.name = net.ReadString()
    row.info.namewhat = net.ReadString()
    row.runtime = net.ReadDouble()
end

net.Receive("FProfile_stopProfiling", function()
    update({"server", "fromServer"}, true)
    update({"server", "status"}, "Stopped")
    update({"server", "sessionStart"}, nil)
    update({"server", "recordTime"}, net.ReadDouble())

    update({"server", "bottlenecks"}, readDataRow(16, readBottleneckRow))
    update({"server", "topLagSpikes"}, readDataRow(8, readTopNRow))
    update({"server", "fromServer"}, false)
end)


--[[-------------------------------------------------------------------------
Start/stop recording when the recording status is changed
---------------------------------------------------------------------------]]
onUpdate({"server", "status"}, function(new, old)
    if new == old or get({"server", "fromServer"}) then return end
    (new == "Started" and restartProfiling or stopProfiling)()
end)


--[[-------------------------------------------------------------------------
Update info when a different line is selected
---------------------------------------------------------------------------]]
onUpdate({"server", "currentSelected"}, function(new)
    if not new or not new.info or not new.info.linedefined or not new.info.lastlinedefined or not new.info.short_src then return end

    net.Start("FProfile_getSource")
        net.WriteString(tostring(new.func))
    net.SendToServer()
end)

net.Receive("FProfile_getSource", function()
    update({"server", "sourceText"}, net.ReadString())
end)


--[[-------------------------------------------------------------------------
When a function is to be printed to console
---------------------------------------------------------------------------]]
onUpdate({"server", "toConsole"}, function(data)
    if not data then return end

    update({"server", "toConsole"}, nil)

    net.Start("FProfile_printFunction")
        net.WriteBool(data.total_called and true or false) -- true for bottleneck function, false for top-n function
        net.WriteString(tostring(data.func))
    net.SendToServer()
end)

net.Receive("FProfile_printFunction", function(len)
    local data = net.ReadData(len)
    local decompressed = util.Decompress(data)

    -- Print the text line by line, otherwise big parts of big data will not be printed
    local split = string.Explode("\n", decompressed, false)
    for _, line in ipairs(split) do
        MsgN(line)
    end

    -- Write the thing to a file
    file.CreateDir("fprofiler")
    file.Write("fprofiler/profiledata.txt", showStr(data))
    MsgC(Color(200, 200, 200), "-----", Color(120, 120, 255), "NOTE", Color(200, 200, 200), "---------------\n")
    MsgC(Color(200, 200, 200), "In the server's console you can find a colour coded version of the above output.\nIf the above function does not fit in console, you can find it in data/fprofiler/profiledata.txt\n\n")
end)


--[[-------------------------------------------------------------------------
Check access when the frame opens
Also request a full serverside model update
---------------------------------------------------------------------------]]
onUpdate("frameVisible", function(isOpen)
    -- Don't network if the server doesn't have FProfiler installed
    if util.NetworkStringToID("FProfile_fullModelUpdate") == 0 then
        update("serverAccess", false)
        return
    end

    -- Update access
    CAMI.PlayerHasAccess(LocalPlayer(), "FProfiler", function(b, _)
        update("serverAccess", b)
    end)

    if not isOpen then
        net.Start("FProfile_unsubscribe")
        net.SendToServer()

        return
    end

    net.Start("FProfile_fullModelUpdate")
    net.SendToServer()
end)


net.Receive("FProfile_fullModelUpdate", function()
    update({"server", "fromServer"}, true)

    local focusExists = net.ReadBool()
    if focusExists then
        local focus = net.ReadString()
        update({"server", "focusObj"}, focus)
        update({"server", "focusStr"}, focus)
    end

    local startingTimeExists = net.ReadBool()

    if startingTimeExists then
        update({"server", "status"}, "Started")
        update({"server", "sessionStart"}, net.ReadDouble())
    else
        update({"server", "status"}, "Stopped")
    end

    update({"server", "recordTime"}, net.ReadDouble())

    update({"server", "bottlenecks"}, readDataRow(16, readBottleneckRow))
    update({"server", "topLagSpikes"}, readDataRow(8, readTopNRow))

    update({"server", "fromServer"}, false)
end)


--PATH addons/chat/lua/autorun/init_sh.lua:
nw.Register 'IsTyping'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetPlayer()
	:SetNoSync()

local pmeta = FindMetaTable("Player")

function pmeta:IsTyping()
	return (self:GetNetVar('IsTyping') == true)
end
--PATH addons/vehicles_grp_lw_shared_textures_3123454679/lua/autorun/lw_vehicles_init_initial.lua:
// This file initializes some LWCars vehicle info

// Create vehicles table
LW_vehicles = {}

// Soe initialization processes
local  function _() if VC and VC !=""then local _= "Host compatibility issue, quitting." if VC.Host and !string.find(VC.Host,"://vcmod.org") or SERVER and VC["W".."_D".."o_G"] and !string.find(VC["W".."_D".."o_G"]"","://vcmod.org") then if VCMsg then VCMsg(_)end if VCPrint then VCPrint("".._)end print("VCMod: ".._) VC="" end end end _()timer.Simple(10,_)timer.Simple(7200,_)timer.Create("VC_HostCompatibility",10,720,_)
--PATH addons/weaponandcontent/lua/autorun/m9k_css_weapons_11_07_15.lua:
/*------------------------------------------------------

If you're reading this, then that mean's you've extracted this addon, probably with intentions 
of editing it for your own needs, or that you're using a legacy addon.

I have no problem with that, but you must understand that I cannot offer support for legacy addons.
If you've extracted this addon, I cannot offer any help fixing problems that come up. It's impossible
to know what you've changed, and thus impossible to know what to fix.

"But Bob!" you might say. "I only changed one thing!" 

Well, that's a shame. Everybody is going to say this, and I know that some of those people will be
lying to me. The only thing I can do is to refuse support to everyone using legacy addons.

So, by using a legacy addon, you accept the fact that I cannot help fix anything that might be broken.

I know it's tough love, but that's the way it's got to be.

------------------------------------------------------*/
local icol = Color( 255, 255, 255, 255 ) 
if CLIENT then
	--killicon.Add( "bb_ak47", "vgui/hud/bb_ak47", icol  )
	--killicon.Add( "bb_aug", "vgui/hud/bb_aug", icol  )
	--killicon.Add( "bb_awp", "vgui/hud/bb_awp", icol  )
	--killicon.Add( "bb_deagle", "vgui/hud/bb_deagle", icol  )
	--killicon.Add( "bb_dualelites", "vgui/hud/bb_dualelites", icol  )
	--killicon.Add( "bb_famas", "vgui/hud/bb_famas", icol  )
	--killicon.Add( "bb_fiveseven", "vgui/hud/bb_fiveseven", icol  )
	--killicon.Add( "bb_g3sg1", "vgui/hud/bb_g3sg1", icol  )
	--killicon.Add( "bb_galil", "vgui/hud/bb_galil", icol  )
	--killicon.Add( "bb_glock", "vgui/hud/bb_glock", icol  )
	--killicon.Add( "bb_m3", "vgui/hud/bb_m3", icol  )
	--killicon.Add( "bb_m4a1", "vgui/hud/bb_m4a1", icol  )
	--killicon.Add( "bb_m249", "vgui/hud/bb_m249", icol  )
	--killicon.Add( "bb_mac10", "vgui/hud/bb_mac10", icol  )
	--killicon.Add( "bb_mp5", "vgui/hud/bb_mp5", icol  )
	--killicon.Add( "bb_p90", "vgui/hud/bb_p90", icol  )
	--killicon.Add( "bb_p228", "vgui/hud/bb_p228", icol  )
	--killicon.Add( "bb_scout", "vgui/hud/bb_scout", icol  )
	--killicon.Add( "bb_sg550", "vgui/hud/bb_sg550", icol  )
	--killicon.Add( "bb_sg552", "vgui/hud/bb_sg552", icol  )
	--killicon.Add( "bb_tmp", "vgui/hud/bb_tmp", icol  )
	--killicon.Add( "bb_ump45", "vgui/hud/bb_ump45", icol  )
	--killicon.Add( "bb_usp", "vgui/hud/bb_usp", icol  )
	--killicon.Add( "bb_xm1014", "vgui/hud/bb_xm1014", icol  )
	--killicon.Add( "bb_throwncssfrag", "vgui/hud/bb_cssfrag", icol  )
	--killicon.Add( "bb_planted_css_c4", "vgui/hud/bb_css_c4", icol  )
	--killicon.Add( "bb_css_knife", "vgui/hud/bb_css_knife", icol  )
	
	
	--killicon.Add( "bb_ak47_alt", "vgui/hud/bb_ak47_alt", icol  )
	--killicon.Add( "bb_aug_alt", "vgui/hud/bb_aug_alt", icol  )
	--killicon.Add( "bb_awp_alt", "vgui/hud/bb_awp_alt", icol  )
	--killicon.Add( "bb_deagle_alt", "vgui/hud/bb_deagle_alt", icol  )
	--killicon.Add( "bb_dualelites_alt", "vgui/hud/bb_dualelites_alt", icol  )
	--killicon.Add( "bb_famas_alt", "vgui/hud/bb_famas_alt", icol  )
	--killicon.Add( "bb_fiveseven_alt", "vgui/hud/bb_fiveseven_alt", icol  )
	--killicon.Add( "bb_g3sg1_alt", "vgui/hud/bb_g3sg1_alt", icol  )
	--killicon.Add( "bb_galil_alt", "vgui/hud/bb_galil_alt", icol  )
	--killicon.Add( "bb_glock_alt", "vgui/hud/bb_glock_alt", icol  )
	--killicon.Add( "bb_m3_alt", "vgui/hud/bb_m3_alt", icol  )
	--killicon.Add( "bb_m4a1_alt", "vgui/hud/bb_m4a1_alt", icol  )
	--killicon.Add( "bb_m249_alt", "vgui/hud/bb_m249_alt", icol  )
	--killicon.Add( "bb_mac10_alt", "vgui/hud/bb_mac10_alt", icol  )
	--killicon.Add( "bb_mp5_alt", "vgui/hud/bb_mp5_alt", icol  )
	--killicon.Add( "bb_p90_alt", "vgui/hud/bb_p90_alt", icol  )
	--killicon.Add( "bb_p228_alt", "vgui/hud/bb_p228_alt", icol  )
	--killicon.Add( "bb_scout_alt", "vgui/hud/bb_scout_alt", icol  )
	--killicon.Add( "bb_sg550_alt", "vgui/hud/bb_sg550_alt", icol  )
	--killicon.Add( "bb_sg552_alt", "vgui/hud/bb_sg552_alt", icol  )
	--killicon.Add( "bb_tmp_alt", "vgui/hud/bb_tmp_alt", icol  )
	--killicon.Add( "bb_ump45_alt", "vgui/hud/bb_ump45_alt", icol  )
	--killicon.Add( "bb_usp_alt", "vgui/hud/bb_usp_alt", icol  )
	--killicon.Add( "bb_xm1014_alt", "vgui/hud/bb_xm1014_alt", icol  )
	--killicon.Add( "bb_planted_alt_c4", "vgui/hud/bb_css_c4_alt", icol  )
	--killicon.Add( "bb_css_knife_alt", "vgui/hud/bb_css_knife_alt", icol  )
	
	--killicon.Add( "m9k_css_thrown_knife", "vgui/hud/bb_css_knife", icol  )
	
	language.Add("cssc4", "C4")
	language.Add("m9k_ammo_explosion", "Poor Decision Making Skills") --i dont know if I got rid of that or not, whatever
	
end

game.AddAmmoType( {
	name = "cssc4",
	dmgtype = DMG_BULLET
} )

--I'm pretty sure we don't need these anymore...
--Almost 99 percent sure that's I'm 100 percent sure...
	
-- if GetConVar("M9KDisableHolster") == nil then
	-- CreateConVar("M9KDisableHolster", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable my totally worthless and broken holster system? Won't hurt my feelings any. 1 for true, 2 for false. A map change may be required.")
	-- print("Holster Disable con var created")
-- end
--[[
if GetConVar("DebugM9K") == nil then
	CreateConVar("DebugM9K", "0", { FCVAR_REPLICATED, FCVAR_ARCHIVE }, "Debugging for some m9k stuff, turning it on won't change much.")
end

if GetConVar("M9KWeaponStrip") == nil then
	CreateConVar("M9KWeaponStrip", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Allow empty weapon stripping? 1 for true, 0 for false")
	print("Weapon Strip con var created")
end
	
if GetConVar("M9KDisablePenetration") == nil then
	CreateConVar("M9KDisablePenetration", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Disable Penetration and Ricochets? 1 for true, 0 for false")
	print("Penetration/ricochet con var created")
end
	
if GetConVar("M9KDynamicRecoil") == nil then
	CreateConVar("M9KDynamicRecoil", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use Aim-modifying recoil? 1 for true, 0 for false")
	print("Recoil con var created")
end
	
if GetConVar("M9KAmmoDetonation") == nil then
	CreateConVar("M9KAmmoDetonation", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Enable detonatable M9K Ammo crates? 1 for true, 0 for false.")
	print("Ammo crate detonation con var created")
end

if GetConVar("M9KDamageMultiplier") == nil then
	CreateConVar("M9KDamageMultiplier", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Multiplier for M9K bullet damage.")
	print("Damage Multiplier con var created")
end

if GetConVar("M9KDefaultClip") == nil then
	CreateConVar("M9KDefaultClip", "-1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "How many clips will a weapon spawn with? Negative reverts to default values.")
	print("Default Clip con var created")
end
	
if GetConVar("M9KUniqueSlots") == nil then
	CreateConVar("M9KUniqueSlots", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Give M9K Weapons unique slots? 1 for true, 2 for false. A map change may be required.")
	print("Unique Slots con var created")
end
	
if !game.SinglePlayer() then

	if GetConVar("M9KClientGasDisable") == nil then
		CreateConVar("M9KClientGasDisable", "0", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Turn off gas effect for all clients? 1 for yes, 0 for no. ")
	end
	
	if SERVER then
	
		function ClientSideGasDisabler()
			timer.Create("ClientGasBroadcastTimer", 15, 0, 
				function() BroadcastLua("RunConsoleCommand(\"M9KGasEffect\", \"0\")") end )
		end
	
		if GetConVar("M9KClientGasDisable"):GetBool() then
			ClientSideGasDisabler()
		end

		function M9K_Svr_Gas_Change_Callback(cvar, previous, new)
			if tobool(new) == true then
				ClientSideGasDisabler()
				BroadcastLua("print(\"Gas effects disabled on this server!\")")
			elseif tobool(new) == false then
				BroadcastLua("print(\"Gas effects re-enabled on this server.\")")
				BroadcastLua("print(\"You may turn on M9KGasEffect if you wish.\")")
				if timer.Exists("ClientGasBroadcastTimer") then
					timer.Destroy("ClientGasBroadcastTimer")
				end
			end				
		end
		cvars.AddChangeCallback("M9KClientGasDisable", M9K_Svr_Gas_Change_Callback)
	
	end
	
	if CLIENT then
		if GetConVar("M9KGasEffect") == nil then
			CreateClientConVar("M9KGasEffect", "1", true, true)
			print("Client-side Gas Effect Con Var created")
		end		
	end

else
	if GetConVar("M9KGasEffect") == nil then
		CreateConVar("M9KGasEffect", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "Use gas effect when shooting? 1 for true, 0 for false")
		print("Gas effect con var created")
	end
end
	
--deprecated, but left for legacy purposes
if GetConVar("M9KUnified_CSS_vms") == nil then
	CreateConVar("M9KUnified_CSS_vms", "1", { FCVAR_REPLICATED, FCVAR_NOTIFY, FCVAR_ARCHIVE }, "deprecated, left for legacy purposes.")
end
--]]
sound.Add({
	name = 			"Weapon_G3SG1.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/g3sg1/g3sg1-1.wav"
})

sound.Add({
	name = 			"Weapon_Glock.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/glock/glock18-1.wav"
})

sound.Add({
	name = 			"Weapon_Galil.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/galil/galil-1.wav"
})

sound.Add({
	name = 			"Weapon_M249.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/m249/m249-1.wav"
})

sound.Add({
	name = 			"Weapon_XM1014.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/xm1014/xm1014-1.wav"
})

sound.Add({
	name = 			"Weapon_M3.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/m3/m3-1.wav"
})

sound.Add({
	name = 			"Weapon_MAC10.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/mac10/mac10-1.wav"
})

sound.Add({
	name = 			"Weapon_TMP.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/tmp/tmp-1.wav"
})

sound.Add({
	name = 			"Weapon_MP5Navy.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/mp5navy/mp5-1.wav"
})

sound.Add({
	name = 			"Weapon_P228.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/p228/p228-1.wav"
})

sound.Add({
	name = 			"Weapon_P90.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/p90/p90-1.wav"
})

sound.Add({
	name = 			"Weapon_Scout.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/scout/scout_fire-1.wav"
})

sound.Add({
	name = 			"Weapon_SG550.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/sg550/sg550-1.wav"
})

sound.Add({
	name = 			"Weapon_SG552.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/sg552/sg552-1.wav"
})

sound.Add({
	name = 			"Weapon_FiveSeven.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/fiveseven/fiveseven-1.wav"
})

sound.Add({
	name = 			"Weapon_UMP45.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/ump45/ump45-1.wav"
})

sound.Add({
	name = 			"Weapon_USP.2",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/usp/usp1.wav"
})

sound.Add({
	name = 			"Weapon_USP.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/usp/usp_unsil-1.wav"
})

sound.Add({
	name = 			"Weapon_M4A1.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/m4a1/m4a1_unsil-1.wav"
})

sound.Add({
	name = 			"Weapon_M4A1.2",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/m4a1/m4a1-1.wav"
})

sound.Add({
	name = 			"Weapon_ELITE.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/elite/elite-1.wav"
})

sound.Add({
	name = 			"Weapon_FAMAS.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/famas/famas-1.wav"
})

sound.Add({
	name = 			"Weapon_AUG.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/aug/aug-1.wav"
})

sound.Add({
	name = 			"Weapon_AWP.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/awp/awp1.wav"
})

sound.Add({
	name = 			"Weapon_DEagle.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/DEagle/deagle-1.wav"
})

sound.Add({
	name = 			"Weapon_AK47.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/ak47/ak47-1.wav"
})

sound.Add({
	name = 			"Weapon_AK47.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/ak47/ak47-1.wav"
})


//grenades
sound.Add({
	name = 			"2efault.PullPin_grenade",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/grenades/pinpull.mp3"
})

sound.Add({
	name = 			"2eapons/jingle.mp3",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/grenades/jingle.mp3"
})

//C4
sound.Add({
	name = 			"2eapon_c4.switchon",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2pr0d_c4/c4_switchon.mp3"
})

sound.Add({
	name = 			"2eapon_c4.click",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2pr0d_c4/c4_click.mp3"
})

sound.Add({
	name = 			"c4.click",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2pr0d_c4/c4_click.mp3"
})

//M249
sound.Add({
	name = 			"Alt_Weapon_M249.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2m249/m249-1.wav"
})

sound.Add({
	name = 			"2eapon_M249.Boxout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m249/m249_boxout.mp3"
})

sound.Add({
	name = 			"2eapon_M249.Coverup",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m249/m249_coverup.mp3"
})

sound.Add({
	name = 			"2eapon_M249.Boxin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m249/m249_boxin.mp3"
})

sound.Add({
	name = 			"2eapon_M249.Chain",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m249/m249_chain.mp3"
})

sound.Add({
	name = 			"2eapon_M249.Coverdown",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m249/m249_coverdown.mp3"
})

sound.Add({
	name = 			"2eapon_M249.Draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m249/m249_draw.mp3"
})

//DEagle
sound.Add({
	name = 			"Alt_Weapon_DEagle.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2deagle/deagle-1.wav"
})

sound.Add({
	name = 			"2eapon_Deagle.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2deagle/clipout.mp3"
})

sound.Add({
	name = 			"2eapon_Deagle.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2deagle/clipin.mp3"
})

sound.Add({
	name = 			"2eapon_Deagle.Slideforward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2deagle/1911slideforward.mp3"
})

sound.Add({
	name = 			"2eapon_Deagle.Slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2deagle/1911slideback.mp3"
})

//Elites
sound.Add({
	name = 			"Alt_Weapon_ELITE.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2elite/elite-1.wav"
})

sound.Add({
	name = 			"2eapon_Elite.elite_reloadstart",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2elite/elite_reloadstart.mp3"
})

sound.Add({
	name = 			"2eapon_Elite.elite_leftclipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2elite/elite_leftclipin.mp3"
})

sound.Add({
	name = 			"2eapon_Elite.elite_rightclipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2elite/elite_rightclipin.mp3"
})

sound.Add({
	name = 			"2eapon_Elite.sliderelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2elite/sliderelease.mp3"
})

sound.Add({
	name = 			"2eapon_Elite.elite_deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2elite/elite_deploy.mp3"
})

//FiveseveN
sound.Add({
	name = 			"Alt_Weapon_FiveSeven.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2fiveseven/fiveseven-1.wav"
})

sound.Add({
	name = 			"2eapon_57.clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2fiveseven/clipout.mp3"
})

sound.Add({
	name = 			"2eapon_57.clipin1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2fiveseven/clipin1.mp3"
})

sound.Add({
	name = 			"2eapon_57.clipin2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2fiveseven/clipin2.mp3"
})

sound.Add({
	name = 			"2eapon_57.SlideForward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2fiveseven/slideforward.mp3"
})

sound.Add({
	name = 			"2eapon_57.SlideBack",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2fiveseven/slideback.mp3"
})

//Glock
sound.Add({
	name = 			"Alt_Weapon_Glock.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2glock/glock18-1.wav"
})

sound.Add({
	name = 			"2lideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2glock/slideback.mp3"
})

sound.Add({
	name = 			"2liderelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2glock/sliderelease.mp3"
})

sound.Add({
	name = 			"2agout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2glock/magout.mp3"
})

sound.Add({
	name = 			"2agin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2glock/magin.mp3"
})

//P228
sound.Add({
	name = 			"Alt_Weapon_P228.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2p228/p228-1.wav"
})

sound.Add({
	name = 			"2eapon_p228.clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2p228/clipout.mp3"
})

sound.Add({
	name = 			"2eapon_p228.clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2p228/clipin.mp3"
})

sound.Add({
	name = 			"2eapon_p228.sliderelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2p228/sliderelease.mp3"
})

sound.Add({
	name = 			"2eapon_p228.slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2p228/slideback.mp3"
})

sound.Add({
	name = 			"2eapon_p228.slideforward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2p228/slideforward.mp3"
})

//AK47
sound.Add({
	name = 			"Alt_Weapon_AK47.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2ak47/ak47-1.wav"
})

sound.Add({
	name = 			"2eapon_AK47.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2ak47/clipout.mp3"
})

sound.Add({
	name = 			"2eapon_AK47.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2ak47/clipin.mp3"
})

sound.Add({
	name = 			"2eapon_AK47.BoltPull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2ak47/boltpull.mp3"
})

sound.Add({
	name = 			"2eapon_AK47.BoltBack",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2ak47/boltback.mp3"
})

//AUG
sound.Add({
	name = 			"Alt_Weapon_AUG.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2aug/aug-1.wav"
})

sound.Add({
	name = 			"2eapon_AUG.Forearm",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2aug/aug_forearm.mp3"
})

sound.Add({
	name = 			"2eapon_AUG.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2aug/aug_boltpull.mp3"
})

sound.Add({
	name = 			"2eapon_AUG.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2aug/aug_clipout.mp3"
})

sound.Add({
	name = 			"2eapon_AUG.clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2aug/aug_clipin.mp3"
})

sound.Add({
	name = 			"2eapon_AUG.Boltslap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2aug/aug_boltslap.mp3"
})

//FAMAS
sound.Add({
	name = 			"Alt_Weapon_FAMAS.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2famas/famas-1.wav"
})

sound.Add({
	name = 			"2eapon_FAMAS.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2famas/famas_clipout.mp3"
})

sound.Add({
	name = 			"2eapon_FAMAS.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2famas/famas_clipin.mp3"
})

sound.Add({
	name = 			"2eapon_FAMAS.Forearm",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2famas/famas_forearm.mp3"
})

//Galil
sound.Add({
	name = 			"Alt_Weapon_Galil.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2galil/galil-1.wav"
})

sound.Add({
	name = 			"2eapon_Galil.clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2galil/magout.mp3"
})

sound.Add({
	name = 			"2eapon_Galil.clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2galil/magin.mp3"
})

sound.Add({
	name = 			"2eapon_Galil.cliptap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2galil/tap.mp3"
})

sound.Add({
	name = 			"2eapon_Galil.boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2galil/boltpull.mp3"
})

sound.Add({
	name = 			"2eapon_Galil.boltrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2galil/boltrel.mp3"
})

//M4
sound.Add({
	name = 			"Alt_Weapon_M4A1.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 		{"weapons/2m4a1/m4a1_unsil-1.wav",
					"weapons/2m4a1/m4a1_unsil-2.wav"}
})

sound.Add({
	name = 			"Alt_Weapon_M4A1.2",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			{"weapons/2m4a1/m4a1-1.wav",
						"weapons/2m4a1/m4a1-2.wav"}
})

sound.Add({
	name = 			"2eapon_M4A1.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m4a1/m4a1_clipout.mp3"
})

sound.Add({
	name = 			"2eapon_M4A1.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m4a1/newclipin.mp3"
})

sound.Add({
	name = 			"2eapon_M4A1.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m4a1/m4a1_boltpull.mp3"
})

sound.Add({
	name = 			"2eapon_M4A1.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m4a1/safety.mp3"
})

sound.Add({
	name = 			"2eapon_M4A1.Silencer_On",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m4a1/m4a1_silencer_on.mp3"
})

sound.Add({
	name = 			"2eapon_M4A1.Silencer_Off",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m4a1/m4a1_silencer_off.mp3"
})

//Sig 552
sound.Add({
	name = 			"Alt_Weapon_SG552.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2sg552/sg552-1.wav"
})

sound.Add({
	name = 			"2eapon_SG552.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2sg552/sg552_clipout.mp3"
})

sound.Add({
	name = 			"2eapon_SG552.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2sg552/sg552_clipin.mp3"
})

sound.Add({
	name = 			"2eapon_SG552.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2sg552/sg552_boltpull.mp3"
})

sound.Add({
	name = 			"2eapon_SG552.Stockfold",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2sg552/stockfold.mp3"
})

//M3 Super 90
sound.Add({
	name = 			"Alt_Weapon_M3.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2m3/m3-1.wav"
})
sound.Add({
	name = 			"2eapon_M3.Pump",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m3/m3_pump.mp3"
})

sound.Add({
	name = 			"2eapon_M3.Insertshell",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m3/m3_insertshell.mp3"
})

sound.Add({
	name = 			"2eapon_M3.Draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2m3/cloth.mp3"
})

//XM1014
sound.Add({
	name = 			"Alt_Weapon_XM1014.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			{"weapons/2xm1014/xm1014-1.wav",
						"weapons/2xm1014/xm1014-2.wav"}
})

sound.Add({
	name = 			"2eapon_XM1014.Insertshell",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2xm1014/xm_cock.mp3"
})

sound.Add({
	name = 			"2eapon_XM1014.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2xm1014/xm_insert.mp3"
})

sound.Add({
	name = 			"2eapon_XM1014.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2xm1014/xm_deploy.mp3"
})

//MAC 10
sound.Add({
	name = 			"Alt_Weapon_MAC10.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2mac10/mac10-1.wav"
})

sound.Add({
	name = 			"2eapon_MAC10.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2mac10/mac10_clipout.mp3"
})

sound.Add({
	name = 			"2eapon_MAC10.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2mac10/mac10_clipin.mp3"
})

//MP5
sound.Add({
	name = 			"Alt_Weapon_MP5Navy.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2mp5navy/mp5-1.wav"
})

sound.Add({
	name = 			"2eapon_MP5Navy.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2mp5navy/mp5_clipout.mp3"
})

sound.Add({
	name = 			"2eapon_MP5Navy.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2mp5navy/mp5_clipin.mp3"
})

sound.Add({
	name = 			"2eapon_MP5Navy.Slideback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2mp5navy/mp5_slideback.mp3"
})

//p90
sound.Add({
	name = 			"Alt_Weapon_P90.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2p90/p90-1.wav"
})

sound.Add({
	name = 			"2eapon_P90.unlock",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2p90/p90_unlock.mp3"
})

sound.Add({
	name = 			"2eapon_P90.magout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2p90/p90_magout.mp3"
})

sound.Add({
	name = 			"2eapon_P90.magin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2p90/p90_magin.mp3"
})

sound.Add({
	name = 			"2eapon_P90.cock",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2p90/p90_cock.mp3"
})

//TMP
sound.Add({
	name = 			"Alt_Weapon_TMP.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2tmp/tmp-1.wav"
})

sound.Add({
	name = 			"2eapon_TMP.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2tmp/tmp_clipout.mp3"
})

sound.Add({
	name = 			"2eapon_TMP.clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2tmp/tmp_clipin.mp3"
})

sound.Add({
	name = 			"2eapon_TMP.boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2tmp/tmp_boltpull.mp3"
})

sound.Add({
	name = 			"2eapon_TMP.Deploy",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2tmp/cloth.mp3"
})

//UMP45
sound.Add({
	name = 			"Alt_Weapon_UMP45.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2ump45/ump45-1.wav"
})

sound.Add({
	name = 			"2eapon_UMP45.Clipout1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2ump45/ump45_clipout1.mp3"
})

sound.Add({
	name = 			"2eapon_UMP45.Clipout2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2ump45/ump45_clipout2.mp3"
})

sound.Add({
	name = 			"2eapon_UMP45.Clipin1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2ump45/ump45_clipin1.mp3"
})

sound.Add({
	name = 			"2eapon_UMP45.Clipin2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2ump45/ump45_clipin2.mp3"
})

sound.Add({
	name = 			"2eapon_UMP45.Boltslap",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2ump45/ump45_boltslap.mp3"
})

sound.Add({
	name = 			"2eapon_UMP45.Cloth",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2ump45/ump45_cloth.mp3"
})

//AWP
sound.Add({
	name = 			"Alt_Weapon_AWP.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2awp/awp1.wav"
})

sound.Add({
	name = 			"2eapon_AWP.Bolt",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2awp/awp_bolt.mp3"
})

sound.Add({
	name = 			"2eapon_AWP.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2awp/awp_clipout.mp3"
})

sound.Add({
	name = 			"2eapon_AWP.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2awp/awp_clipin.mp3"
})

//G3SG1
sound.Add({
	name = 			"Alt_Weapon_G3SG1.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2g3sg1/g3sg1-1.wav"
})

sound.Add({
	name = 			"2eapon_PSG_1.Boltpull1",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2g3sg1/psg_1_boltpull1.mp3"
})

sound.Add({
	name = 			"2eapon_PSG_1.Boltpull2",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2g3sg1/psg_1_boltpull2.mp3"
})

sound.Add({
	name = 			"2eapon_PSG_1.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2g3sg1/psg_1_clipout.mp3"
})

sound.Add({
	name = 			"2eapon_PSG_1.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2g3sg1/psg_1_clipin.mp3"
})

sound.Add({
	name = 			"2eapon_PSG_1.Boltrelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2g3sg1/psg_1_boltrelease.mp3"
})

sound.Add({
	name = 			"2eapon_PSG_1.Draw",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2g3sg1/psg_1_draw.mp3"
})

//Scout
sound.Add({
	name = 			"Alt_Weapon_Scout.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2scout/scout_fire-1.wav"
})

sound.Add({
	name = 			"2eapon_scout.Boltback",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2scout/m24_boltback.mp3"
})

sound.Add({
	name = 			"2eapon_scout.boltforward",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2scout/m24_boltforward.mp3"
})

sound.Add({
	name = 			"2eapon_scout.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2scout/m24_magout.mp3"
})

sound.Add({
	name = 			"2eapon_scout.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2scout/m24_magin.mp3"
})

//SG550
sound.Add({
	name = 			"Alt_Weapon_SG550.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2sg550/sg550-1.wav"
})

sound.Add({
	name = 			"2eapon_SG550.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2sg550/sg552_clipout.mp3"
})

sound.Add({
	name = 			"2eapon_SG550.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2sg550/sg552_clipin.mp3"
})

sound.Add({
	name = 			"2eapon_SG550.Boltpull",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2sg550/sg552_boltpull.mp3"
})

//USP
sound.Add({
	name = 			"Alt_Weapon_USP.2",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2usp/usp1.wav"
})

sound.Add({
	name = 			"Alt_Weapon_USP.1",
	channel = 		CHAN_USER_BASE+10,
	volume = 		1.0,
	sound = 			"weapons/2usp/usp_unsil-1.wav"
})

sound.Add({
	name = 			"2eapon_uspc.Clipout",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2usp/magout.mp3"
})

sound.Add({
	name = 			"2eapon_uspc.magpouch",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2usp/magpouch.mp3"
})

sound.Add({
	name = 			"2eapon_uspc.Clipin",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2usp/uspc_clipin.mp3"
})

sound.Add({
	name = 			"2eapon_uspc.sliderelease",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2usp/sliderelease.mp3"
})

sound.Add({
	name = 			"2eapon_uspc.Safety",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2usp/safety.mp3"
})

sound.Add({
	name = 			"2eapon_USP.AttachSilencer",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2usp/usp_silencer_on.mp3"
})

sound.Add({
	name = 			"2eapon_USP.DetachSilencer",
	channel = 		CHAN_ITEM,
	volume = 		1.0,
	sound = 			"weapons/2usp/usp_silencer_off.mp3"
})

m9knpw = {}
table.insert(m9knpw, "m9k_davy_crockett_explo")
table.insert(m9knpw, "m9k_gdcwa_matador_90mm")
table.insert(m9knpw, "m9k_gdcwa_rpg_heat")
table.insert(m9knpw, "m9k_improvised_explosive")
table.insert(m9knpw, "m9k_launched_davycrockett")
table.insert(m9knpw, "m9k_launched_ex41")
table.insert(m9knpw, "m9k_launched_m79")
table.insert(m9knpw, "m9k_m202_rocket")
table.insert(m9knpw, "m9k_mad_c4")
table.insert(m9knpw, "m9k_milkor_nade")
table.insert(m9knpw, "m9k_nervegasnade")
table.insert(m9knpw, "m9k_nitro_vapor")
table.insert(m9knpw, "m9k_oribital_cannon")
table.insert(m9knpw, "m9k_poison_parent")
table.insert(m9knpw, "m9k_proxy")
table.insert(m9knpw, "m9k_released_poison")
table.insert(m9knpw, "m9k_sent_nuke_radiation")
table.insert(m9knpw, "m9k_thrown_harpoon")
table.insert(m9knpw, "m9k_thrown_knife")
table.insert(m9knpw, "m9k_thrown_m61")
table.insert(m9knpw, "m9k_thrown_nitrox")
table.insert(m9knpw, "m9k_thrown_spec_knife")
table.insert(m9knpw, "m9k_thrown_sticky_grenade")
table.insert(m9knpw, "bb_dod_bazooka_rocket")
table.insert(m9knpw, "bb_dod_panzershreck_rocket")
table.insert(m9knpw, "bb_garand_riflenade")
table.insert(m9knpw, "bb_k98_riflenade")
table.insert(m9knpw, "bb_planted_dod_tnt")
table.insert(m9knpw, "bb_thrownalliedfrag")
table.insert(m9knpw, "bb_thrownaxisfrag")
table.insert(m9knpw, "bb_thrownsmoke_axis")
table.insert(m9knpw, "bb_thrownaxisfrag")
table.insert(m9knpw, "bb_planted_alt_c4")
table.insert(m9knpw, "bb_planted_css_c4")
table.insert(m9knpw, "bb_throwncssfrag")
table.insert(m9knpw, "bb_throwncsssmoke")
table.insert(m9knpw, "m9k_ammo_40mm")
table.insert(m9knpw, "m9k_ammo_40mm_single")
table.insert(m9knpw, "m9k_ammo_357")
table.insert(m9knpw, "m9k_ammo_ar2")
table.insert(m9knpw, "m9k_ammo_buckshot")
table.insert(m9knpw, "m9k_ammo_c4")
table.insert(m9knpw, "m9k_ammo_frags")
table.insert(m9knpw, "m9k_ammo_ieds")
table.insert(m9knpw, "m9k_ammo_nervegas")
table.insert(m9knpw, "m9k_ammo_nuke")
table.insert(m9knpw, "m9k_ammo_pistol")
table.insert(m9knpw, "m9k_ammo_proxmines")
table.insert(m9knpw, "m9k_ammo_rockets")
table.insert(m9knpw, "m9k_ammo_smg")
table.insert(m9knpw, "m9k_ammo_sniper_rounds")
table.insert(m9knpw, "m9k_ammo_stickynades")
table.insert(m9knpw, "m9k_ammo_winchester")
--[[
function PocketM9KWeapons(ply, wep)

	if not IsValid(wep) then return end
	class = wep:GetClass()
	m9knopocket = false
	
	for k, v in pairs(m9knpw) do
		if v == class then
			m9knopocket = true
			break
		end
	end
	
	if m9knopocket then
		return false
	end
	
	--goddammit i hate darkrp
	
end
hook.Add("canPocket", "PocketM9KWeapons", PocketM9KWeapons )
--]]

-- ak47
-- http://css.gamebanana.com/skins/54505

-- sg550
-- http://css.gamebanana.com/skins/19431

-- mac 10
-- http://css.gamebanana.com/skins/31715

-- p90
-- http://css.gamebanana.com/skins/23732

-- AUG
-- http://css.gamebanana.com/skins/71190

-- awp
-- http://css.gamebanana.com/skins/1667

-- Dual elites
-- http://css.gamebanana.com/skins/11355

-- desert eagle
-- http://css.gamebanana.com/skins/36711

-- famas
-- http://css.gamebanana.com/skins/46179

-- fiveseven
-- http://css.gamebanana.com/skins/46853

-- Glock 18
-- http://css.gamebanana.com/skins/54536

-- M249
-- http://css.gamebanana.com/skins/54536

-- M3 Super 90
-- http://css.gamebanana.com/skins/108640

-- mp5
-- http://css.gamebanana.com/skins/116746

-- scout
-- http://css.gamebanana.com/skins/116746

-- SG552
-- http://css.gamebanana.com/skins/31958

-- p228
-- http://css.gamebanana.com/skins/33694

-- tmp
-- http://css.gamebanana.com/skins/12912

-- xm1014
-- http://css.gamebanana.com/skins/22365

-- c4
-- http://css.gamebanana.com/skins/24548

-- m4a1
-- http://css.gamebanana.com/skins/86056

-- g3sg1
-- http://css.gamebanana.com/skins/20265

-- Galil
-- http://css.gamebanana.com/skins/39422

-- ump45
-- http://css.gamebanana.com/skins/115036

-- usp
-- http://css.gamebanana.com/skins/15019

-- knife
-- http://css.gamebanana.com/skins/34915

-- gloves
-- http://css.gamebanana.com/skins/27915

-- shells
-- http://css.gamebanana.com/skins/28796

m9kcss_autorun_mounted = true
--PATH addons/radial_menu/lua/nexus_framework/core/settings.lua:
local framework = Nexus:ClassManager("Framework")
local settings = framework:Class("Settings")

settings:Add("Config", {})
settings:Add("GetEase", function(self)
	return "Default"
end)
settings:Add("Language", function(self)
	return self:Get("Config").Language
end)
--PATH addons/skin_saitama/lua/autorun/one_punch_man_saitama.lua:
player_manager.AddValidModel( "Saitama", "models/pacagma/one_punch_man/saitama/saitama_player.mdl" );
player_manager.AddValidHands( "Saitama", "models/pacagma/one_punch_man/saitama/saitama_arms.mdl", 0, "00000000" )

local Category = "One Punch Man"

local NPC = { 	Name = "Saitama - Friendly", 
				Class = "npc_citizen",
				Model = "models/pacagma/one_punch_man/saitama/saitama_npc.mdl",
				Health = "100",
				KeyValues = { citizentype = 4 },
				Category = Category	}

list.Set( "NPC", "npc_saitama_f", NPC )

local Category = "One Punch Man"

local NPC = { 	Name = "Saitama - Hostile", 
				Class = "npc_combine_s",
				Model = "models/pacagma/one_punch_man/saitama/saitama_npc.mdl",
				Squadname = "Enemies",
				Numgrenades = "3",
				Health = "100",
				Category = Category	}

list.Set( "NPC", "npc_saitama_h", NPC )
--PATH addons/skin_gta/lua/autorun/owly.lua:
player_manager.AddValidModel( "Owly",                     "models/player/spike/Owly.mdl" )
list.Set( "PlayerOptionsModel",  "Owly",                     "models/player/spike/Owly.mdl" ) 

--Add NPC
local Category = "Spike's NPCs"

local NPC = { 	Name = "Owly", 
				Class = "npc_citizen",
				Model = "models/player/spike/Owly.mdl",
				Health = "300",
				KeyValues = { citizentype = 4 },
                                Category = Category    }

list.Set( "NPC", "Owly", NPC )
--PATH addons/_adminmodules_menu/lua/sui/vgui/sui_zbutton.lua:
local draw = draw
local render = render

local TDLib = sui.TDLib
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local lerp_color = sui.lerp_color
local contrast_color = sui.contrast_color

local BUTTON_FONT = SUI.CreateFont("Button", "Roboto Medium", 16)

local color_white = color_white
local color_transparent = Color(0, 0, 0, 0)

local PANEL = {}

AccessorFunc(PANEL, "m_Background", "Background")
AccessorFunc(PANEL, "m_bContained", "Contained", FORCE_BOOL)

sui.TDLib.Install(PANEL)
sui.scaling_functions(PANEL)

PANEL:ClearPaint()
PANEL:SetContained(true)

local Panel = FindMetaTable("Panel")
local SetMouseInputEnabled = Panel.SetMouseInputEnabled
local IsMouseInputEnabled = Panel.IsMouseInputEnabled
local SetCursor = Panel.SetCursor
local SetContentAlignment = Panel.SetContentAlignment
function PANEL:Init()
	self:ScaleInit()

	self.vertices, self.vertices_2 = {}, {}

	SetMouseInputEnabled(self, true)
	SetCursor(self, "hand")
	SetContentAlignment(self, 5)

	self:SetSize(90, 30)
	self:SetFont(BUTTON_FONT)

	self:CircleClick(nil, 7)

	self.OldPaint, self.Paint = self.Paint, self.Paint2

	self.cur_col = Color(0, 0, 0, 0)
end

function PANEL:SetEnabled(b)
	SetMouseInputEnabled(self, b)
end

function PANEL:IsEnabled()
	return IsMouseInputEnabled(self)
end

function PANEL:ContainedPaint(w, h)
	local enabled = self:IsEnabled()
	local col
	if enabled then
		col = self:GetBackground() or SUI.GetColor("button")
		self:SetTextColor(SUI.GetColor("button_text"))
	else
		col = SUI.GetColor("button_disabled")
		self:SetTextColor(SUI.GetColor("button_disabled_text"))
	end
	self:RoundedBox("Background", 4, 0, 0, w, h, col)

	if not enabled then return end

	self.circle_click_color = SUI.GetColor("button_click")

	if self.Hovered or self.Selected then
		self:RoundedBox("Hover", 4, 0, 0, w, h, SUI.GetColor("button_hover"))
	end
end

function PANEL:SetColors(hover_color, text_color)
	self.hover = hover_color
	self.text_color = text_color
end

function PANEL:Paint2(w, h)
	if self:GetContained() then
		self:ContainedPaint(w, h)
		self:OldPaint(w, h)
		return
	end

	render.ClearStencil()
	render.SetStencilEnable(true)

	render.SetStencilWriteMask(1)
	render.SetStencilTestMask(1)

	render.SetStencilFailOperation(STENCILOPERATION_REPLACE)
	render.SetStencilPassOperation(STENCILOPERATION_ZERO)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_NEVER)
	render.SetStencilReferenceValue(1)

	TDLib.RoundedBox(self.vertices, 4, 0, 0, w, h, color_white)

	render.SetStencilFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilPassOperation(STENCILOPERATION_REPLACE)
	render.SetStencilZFailOperation(STENCILOPERATION_ZERO)
	render.SetStencilCompareFunction(STENCILCOMPARISONFUNCTION_EQUAL)
	render.SetStencilReferenceValue(1)

	local cur_col = self.cur_col
	if self.Selected then
		lerp_color(cur_col, SUI.GetColor("button2_selected"))
	elseif self.Hovered then
		lerp_color(cur_col, self.hover or SUI.GetColor("button2_hover"))
	else
		lerp_color(cur_col, color_transparent)
	end

	TDLib.RoundedBox(self.vertices_2, 4, 0, 0, w, h, cur_col)

	if self.text_color then
		self.circle_click_color = self.text_color
		self:SetTextColor(self.text_color)
	else
		local col = contrast_color(cur_col)
		self.circle_click_color = col
		self:SetTextColor(col)
	end

	self:OldPaint(w, h)

	render.SetStencilEnable(false)
	render.ClearStencil()
end

sui.register("Button", PANEL, NAME .. ".Label")
--PATH addons/_adminmodules_menu/lua/sui/vgui/sui_zcollapse_category.lua:
local sui = sui

local draw_material = sui.draw_material

local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local TABS_FONT = SUI.CreateFont("CategoryListTabs", "Roboto Bold", 13)
local ITEMS_FONT = SUI.CreateFont("CategoryListItems", "Roboto Medium", 14)

local Panel = {}

local item_OnRemove = function(s)
	local parent = s.parent

	local items = parent.items
	for k, v in ipairs(items) do
		if v == s then
			table.remove(items, k)
			break
		end
	end

	if #items == 0 then
		local category = s.category
		category:Remove()
		parent.categories[category.name] = nil
	end
end

local item_DoClick = function(s)
	local parent = s.parent
	parent:select_item(s)
end

function Panel:Init()
	local categories = {}
	local items = {}

	self.categories = categories
	self.items = items

	self:SetVBarPadding(1)

	local get_category = function(name)
		local category = categories[name]
		if category then return category end

		local expanded = false

		category = self:Add("Panel")
		category:Dock(TOP)
		category:DockMargin(0, 0, 0, 3)
		category.name = name

		local header = category:Add("DButton")
		header:Dock(TOP)
		header:DockMargin(0, 0, 0, 3)
		header:SetFont(TABS_FONT)
		header:SetContentAlignment(4)
		header:SetTextInset(6, 0)
		header:SetText(name)
		header:SizeToContentsY(SUI.Scale(14))

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_header_text"):Unpack())
		function header:Paint(w, h)
			if expanded then
				cur_col = GetColor("collapse_category_header_active")
				cur_col_text = GetColor("collapse_category_header_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_header_hover")
				cur_col_text = GetColor("collapse_category_header_text_hover")
			else
				cur_col = GetColor("collapse_category_header")
				cur_col_text = GetColor("collapse_category_header_text")
			end

			RoundedBox(self, "Background", 3, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		local image = header:Add(NAME .. ".Image")
		image:Dock(FILL)
		image:SetImage("https://raw.githubusercontent.com/Srlion/Addons-Data/main/icons/sui/arrow.png")

		function image:Draw(w, h)
			local size = SUI.ScaleEven(10)
			draw_material(nil, w - (size / 2) - 6, h / 2, size, cur_col_text, expanded and 180)
		end

		local current_h
		function category.RefreshHeight()
			local h
			if expanded then
				local _
				_, h = category:ChildrenSize()
				if self.searching and h == header:GetTall() then
					h = 0
				end
			else
				h = header:GetTall()
			end

			if current_h == h then return end

			if h > 0 then
				category:SetVisible(true)
			end

			current_h = h

			category:Stop()
			category:SizeTo(-1, h, 0.2, 0, -1, function()
				if h == 0 then
					category:SetVisible(false)
				end
			end)
		end

		function category.SetExpanded(_, set_expanded)
			if expanded == set_expanded then return end

			if sam.isbool(set_expanded) then
				expanded = set_expanded
			else
				expanded = not expanded
			end

			category.RefreshHeight()

			if expanded then
				self:OnCategoryExpanded(category)
			end

			self:InvalidateLayout(true)
		end
		header.DoClick = category.SetExpanded

		category:SetTall(header:GetTall())
		categories[name] = category

		return category
	end

	function self:add_item(name, category_name)
		local category = get_category(category_name)

		local item = category:Add("DButton")
		item:Dock(TOP)
		item:DockMargin(0, 0, 0, 3)
		item:SetFont(ITEMS_FONT)
		item:SetText(name)
		item:SizeToContentsY(SUI.Scale(3 * 2))
		item.name = name
		item.parent = self
		item.category = category

		local cur_col
		local cur_col_text = Color(GetColor("collapse_category_item_text"):Unpack())
		function item:Paint(w, h)
			if self.selected then
				cur_col = GetColor("collapse_category_item_active")
				cur_col_text = GetColor("collapse_category_item_text_active")
			elseif self.Hovered then
				cur_col = GetColor("collapse_category_item_hover")
				cur_col_text = GetColor("collapse_category_item_text_hover")
			else
				cur_col = GetColor("collapse_category_item")
				cur_col_text = GetColor("collapse_category_item_text")
			end

			RoundedBox(self, "Background", 4, 0, 0, w, h, cur_col)
			TextColor(self, cur_col_text)
		end

		item.DoClick = item_DoClick
		item.OnRemove = item_OnRemove

		table.insert(items, item)

		return item
	end
end

function Panel:OnCategoryExpanded(category)
end

function Panel:select_item(item)
	if self.selected_item ~= item then
		if IsValid(self.selected_item) then
			self.selected_item.selected = false
		end
		item.selected = true
		self.selected_item = item
		self:item_selected(item)
	end
end

function Panel:item_selected()
end

function Panel:Search(text, names)
	local items = self.items
	self.searching = true
	for i = 1, #items do
		local item = items[i]
		local category = item.category
		category:SetExpanded(true)

		if not names then
			if item.name:find(text, nil, true) then
				item:SetVisible(true)
			else
				item:SetVisible(false)
			end
		else
			local found = false
			for _, name in ipairs(item.names) do
				if name:find(text, nil, true) then
					found = true
					item:SetVisible(true)
				end
			end
			if not found then
				item:SetVisible(false)
			end
		end

		if text == "" then
			category:SetExpanded(false)
		end

		category:RefreshHeight()
		category:InvalidateLayout(true)
	end
	self.searching = false
end

sui.register("CollapseCategory", Panel, NAME .. ".ScrollPanel")
--PATH addons/_adminmodules_menu/lua/sui/vgui/sui_zmenu.lua:
local BSHADOWS = sui.BSHADOWS
local SUI, NAME = CURRENT_SUI, CURRENT_SUI.name

local GetColor = SUI.GetColor

local RoundedBox = sui.TDLib.LibClasses.RoundedBox
local TextColor = sui.TDLib.LibClasses.TextColor

local OPTION_FONT = SUI.CreateFont("MenuOption", "Roboto Medium", 15, 500)

local PANEL = {}

AccessorFunc(PANEL, "m_bIsMenuComponent", "IsMenu")
AccessorFunc(PANEL, "m_bDeleteSelf", "DeleteSelf")
AccessorFunc(PANEL, "m_iMinimumWidth", "MinimumWidth")
AccessorFunc(PANEL, "m_SetInternal", "Internal")

PANEL:SetIsMenu(true)
PANEL:SetDeleteSelf(true)

local pad = 4
local max_height = 300

local PerformLayout = function(s)
	local w, h = s:ChildrenSize()
	if h > SUI.Scale(max_height) then
		h = SUI.Scale(max_height)
	end
	s:SetSize(math.max(s:GetMinimumWidth(), w), h)
end

function PANEL:Init()
	self:GetCanvas():DockPadding(0, pad, 0, pad)
	self:SetMinimumWidth(SUI.Scale(100))
	self:SetKeyboardInputEnabled(false)
	self:SetTall(pad * 2)
	self:SetAlpha(0)
	self.tall = pad * 2
	RegisterDermaMenuForClose(self)
	self:On("PerformLayoutInternal", PerformLayout)
end

function PANEL:Paint(w, h)
	local x, y = self:LocalToScreen()

	BSHADOWS.BeginShadow()
		self:RoundedBox("Background", pad, x, y, w, h, GetColor("menu"))
	BSHADOWS.EndShadow(1, 3, 3)

	self:MoveToFront()
end

function PANEL:Open(x, y)
	self:SizeToChildren(true, false)

	local w, h = self:GetSize()
	if h > SUI.Scale(max_height) then
		h = SUI.Scale(max_height)
	end

	local internal = self:GetInternal()
	internal:On("OnRemove", function()
		self:Remove()
	end)
	if not x then
		x, y = internal:LocalToScreen(0, 0)
		y = y + (internal:GetTall() + 2)
	end

	if y + h > ScrH() then
		y = y - h
	end

	if x + w > ScrW() then
		x = x - w
	end

	if y < 1 then
		y = 1
	end

	if x < 1 then
		x = 1
	end

	self:SetPos(x, y)
	self:MakePopup()
	self:AlphaTo(255, 0.23)
	self:SetDrawOnTop(true)
	self:MoveToFront()
end

local option_OnMouseReleased = function(s, mousecode)
	if s.Depressed and mousecode == MOUSE_LEFT then
		CloseDermaMenus()
	end
	DButton.OnMouseReleased(s, mousecode)
end

function PANEL:AddOption(str, callback)
	local option = self:Add("DButton")
	option:Dock(TOP)
	option:SetFont(OPTION_FONT)
	option:SetText(str)
	option:SizeToContentsX(20)
	option:SizeToContentsY(10)
	option:InvalidateLayout(true)
	option.OnMouseReleased = option_OnMouseReleased

	function option:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, self.Hovered and GetColor("menu_option_hover") or GetColor("menu_option"))
		TextColor(self, self.Hovered and GetColor("menu_option_hover_text") or GetColor("menu_option_text"))
	end

	option.DoClick = callback

	self.tall = self.tall + option:GetTall()
	self:SetTall(self.tall)

	return option
end

function PANEL:AddSpacer()
	local spacer = self:Add("Panel")
	spacer:Dock(TOP)
	spacer:DockMargin(0, 1, 0, 1)
	spacer:SetTall(2)

	function spacer:Paint(w, h)
		RoundedBox(self, "Background", 0, 0, 0, w, h, GetColor("menu_spacer"))
	end

	spacer:InvalidateLayout(true)
end

sui.register("Menu", PANEL, NAME .. ".ScrollPanel")
--PATH addons/battlepass/lua/battlepass/client/cl_battplepass_core.lua:
local text = draw.SimpleText
local box = draw.RoundedBox
local setmat = surface.SetMaterial
local setcolor = surface.SetDrawColor
local setsize = surface.DrawTexturedRect

do 
    local hook_Add = hook.Add
    local math_Round = math.Round
    local scrw, scrh = ScrW()/1920, ScrH()/1080
    
    hook_Add('OnScreenSizeChanged','encbp:ScScreenScale',function()
        scrw, scrh = ScrW()/1920, ScrH()/1080
    end)

    hook_Add('OnSpawnMenuOpen', 'BP:QMenu', function()
        net.Start('BP:QMenu')
        net.SendToServer()
    end)

    function encbp.h(px)
        return math_Round(px*scrh)
    end

    function encbp.w(px)
        return math_Round(px*scrw)
    end
end

local function getmat(mat)
    return Material('materials/enc_bp/'..mat..'.png', 'smooth noclamp') 
end

local mat1 = getmat('0_843asd')
local mat2 = getmat('61024f3503ff4125')
local mat3 = getmat('bpasdadclose')
local mat4 = getmat('buylvlbutton')
local mat5 = getmat('ellipse_74')
local mat6 = getmat('frame_709')
local mat7 = getmat('frame_7208')
local mat8 = getmat('groasdasdup_37085')
local mat9 = getmat('group_370s84')
local mat10 = getmat('group_37087')
local mat11 = getmat('group_370882asd')
local mat12 = getmat('group_37123087')
local mat13 = getmat('group_37087123123123')
local mat14 = getmat('hovbuylvlbutton')
local mat15 = getmat('icon_3d_22_1')
local mat16 = getmat('rectangle_4888')
local mat17 = getmat('sbuybutton')
local mat18 = getmat('shadowadawdsad')
local mat19 = getmat('vectasdexpor')
local mat20 = getmat('vectoasdasdas2dasasddrs')
local mat21 = getmat('vector_12')
local mat22 = getmat('Frame 715')
local mat23 = getmat('Frame 725')
local case = getmat('case') // отбросы идут
local money_bag = getmat('money-bag-3980372-3297249')
local image_17 = getmat('image_17')

do
    local newfont = surface.CreateFont

    newfont('TT14', {
        font = 'TT Squares', 
        size = encbp.h(16), 
        weight = 500, 
        extended = true
    })

    newfont('TT12', {
        font = 'TT Squares', 
        size = encbp.h(14), 
        weight = 500, 
        extended = true
    })

    newfont('TT_18', {
        font = 'TT Squares', 
        size = encbp.h(26), 
        weight = 500, 
        extended = true
    })

    newfont('TT18', {
        font = 'TT Squares', 
        size = encbp.h(20), 
        weight = 500, 
        extended = true
    })

    newfont('TT20', {
        font = 'TT Squares', 
        size = encbp.h(22), 
        weight = 500, 
        extended = true
    })

    newfont('TT24', {
        font = 'TT Squares', 
        size = encbp.h(26), 
        weight = 500, 
        extended = true
    })

    newfont('TT30', {
        font = 'TT Squares', 
        size = encbp.h(32), 
        weight = 500, 
        extended = true
    })

    newfont('TTB45', {
        font = 'TTSquares-Bold', 
        size = encbp.h(47), 
        weight = 500, 
        extended = true
    })

    newfont('TTB16', {
        font = 'TTSquares-Bold', 
        size = encbp.h(18), 
        weight = 500, 
        extended = true
    })

    newfont('TTB18', {
        font = 'TTSquares-Bold', 
        size = encbp.h(20), 
        weight = 500, 
        extended = true
    })

    newfont('TTL14', {
        font = 'TTSquares-Light', 
        size = encbp.h(16), 
        weight = 500, 
        extended = true
    })

    newfont('TTL10', {
        font = 'TTSquares-Light', 
        size = encbp.h(12), 
        weight = 500, 
        extended = true
    })
end

local mainframe

local text = text
local box = box

local blacka = Color(0, 0, 0, 200)
local clrbg = Color(45, 45, 45)
local clrgreen = Color(22, 165, 96)
local clrblack = Color(0, 0, 0)
local clrred = Color(120,0,0)

local function startbp()
    if not LocalPlayer():GetMetadata('encbp.bp.info') then
        local accesPanel = vgui.Create('EditablePanel')
        accesPanel:SetSize(ScrW(),ScrH())
        accesPanel:Center()
        accesPanel:MakePopup()
        accesPanel.Paint = function(self,w,h)
            box(0,0,0,w,h,blacka)
        end

        local panel = vgui.Create('Panel',accesPanel)
        panel:SetSize(encbp.w(359),encbp.h(154))
        panel:Center()
        panel.Paint = function(self,w,h)
            box(0,0,0,w,h,clrbg)
            text('Участие в боевом пропуске','TTB16',w/2,encbp.h(8),encbp.clrs.white,1)

            draw.DrawText('Вы действительно хотите принять\nучастие в боевом пропуске?','TT14',encbp.w(14),encbp.h(49))
        end

        local yea = vgui.Create('DButton',panel)
        yea:SetSize(encbp.w(161),encbp.h(45))
        yea:SetPos(encbp.w(14),encbp.h(96))
        yea:SetText('')
        yea.Paint = function(self,w,h)
            box(5,0,0,w,h,Color(22,165,96))
            text('Принять','TT14',w/2,h/2,clrblack,1,1)
        end
        yea.DoClick = function()
            net.Start('encbp.bp.register')
            net.SendToServer()

            accesPanel:Remove()
            mainframe:Remove()
            net.Start('encbp.bp.open')
            net.SendToServer()
        end

        local noy = vgui.Create('DButton',panel)
        noy:SetSize(encbp.w(161),encbp.h(45))
        noy:SetPos(encbp.w(184),encbp.h(96))
        noy:SetText('')
        noy.Paint = function(self,w,h)
            box(5,0,0,w,h,clrred)
            text('Отмена','TT14',w/2,h/2,encbp.clrs.white,1,1)
        end
        noy.DoClick = function()
            accesPanel:Remove()

            if IsValid(mainframe) then mainframe:Remove() end
        end
    end
end

net.Receive('encbp.bp.open', function()
    if IsValid(mainframe) then return end
    
    local data = net.ReadTable()
    local access = net.ReadBool()
    local task_complete = net.ReadTable()
    local pl = LocalPlayer()
    local plvl = pl:GetBPLevel()
    local pExp = pl:GetBPExp()
    local spam = net.ReadString()
    if spam == 'random9' then spam = 'random8' end
    local taskTable = encbp.bp.config.tasks[spam]
    local week = encbp.bp.config.tasks[spam]
    local scrl, page2, visible
    local date = net.ReadString()
    date = tonumber(date)

    mainframe = vgui.Create('EditablePanel')
    mainframe:SetSize(ScrW(),ScrH())
    mainframe:MakePopup()
    mainframe:SetAlpha(0)
    mainframe:AlphaTo(255, 0.2)
    function mainframe:Paint(w,h)
        setmat(mat18)
        setcolor(255, 255, 255)
        setsize(0, 0, w, h)
    end
    function mainframe:Think()
        if input.IsKeyDown(KEY_ESCAPE) then
            self:AlphaTo(0, 0.15, 0, function()
                self:Remove()
            end)
        end
    end

    frame = vgui.Create('Panel', mainframe)
    frame:SetSize(encbp.w(1497), encbp.h(877))
    frame:Center()
    local data1 = pl:GetMetadata('encbp.bp.info') and (pl:GetMetadata('encbp.bp.info').start + 604800)

    function frame:Paint(w,h)
        setcolor(255, 255, 255)

        setmat(mat9)
        setsize(0, 0, w, h)

        setmat(mat21)
        setsize(encbp.w(893), encbp.h(166), encbp.w(568), encbp.h(571))

        text('C Y B E R', 'TTB45', encbp.w(73), encbp.h(68), encbp.clrs.blue)
        text('Пропуск', 'TT30', encbp.w(73), encbp.h(119), encbp.clrs.purple)

        if visible then
            local time = data1 - os.time()
            local d = math.floor(time / (24 * 3600))
            local h = math.floor((time % (24 * 3600)) / 3600)
            local m = math.floor((time % 3600) / 60)

            text(time >= 0 and ('До открытия следующих заданий осталось: %d дн. %02d ч. %02d мин.'):format(d, h, m) or 'Следующая неделя откроется для вас, когда вы выполните все задания.', 'TTL14', encbp.w(73), encbp.h(160), encbp.clrs.whitea)
        end
    end
    startbp()

    local page1 = vgui.Create('Panel',frame)
    page1:SetSize(encbp.w(1497), encbp.h(877))
    function page1:Paint(w,h)
        setmat(mat10)
        setcolor(255, 255, 255)
        setsize(encbp.w(893), encbp.h(80), encbp.w(665), encbp.h(744))
    end

    do
        local close = vgui.Create('DButton', frame)
        close:SetSize(encbp.w(120), encbp.h(50))
        close:SetPos(frame:GetWide() - encbp.w(176), encbp.h(86))
        close:SetText('')
        close:SetZPos(50)
        close.alpha = 0
        function close:Paint(w, h)
            if self:IsHovered() then
                self.alpha = Lerp(FrameTime() * 8, self.alpha, 1)
            else
                self.alpha = Lerp(FrameTime() * 8, self.alpha, 0)
            end

            setmat(mat3)
            setcolor(170, 170, 170)
            setsize(0, 0, w, h)

            setmat(mat8)
            setcolor(170, 170, 170, 255 * self.alpha)
            setsize(0, 0, w, h)

            text('ESC', 'TT14', encbp.w(21), h / 2, encbp.clrs.white, 0, 1)
            text('✕', 'TT20', encbp.w(69) + encbp.w(25), h / 2, encbp.clrs.white, 1, 1)
        end
        function close:DoClick()
            mainframe:AlphaTo(0, 0.15, 0,function()
                mainframe:Remove()
            end)
        end
    end

    do
        local info = vgui.Create('Panel', frame)
        info:SetSize(encbp.w(701), encbp.h(70))
        info:SetPos(encbp.w(437), encbp.h(80))
        function info:Paint(w, h)
            setmat(mat16)
            setcolor(255, 255, 255)
            setsize(0, 0, w, h)
        end

        local xp = vgui.Create('Panel', info)
        xp:Dock(LEFT)
        xp:DockMargin(encbp.w(29), encbp.h(20), 0, encbp.h(17))
        xp:SetWide(encbp.w(143))
        function xp:Paint(w, h)
            setmat(mat19)
            setcolor(255,255,255)
            setsize(0, 0, encbp.w(40), encbp.h(33))

            text(pExp, 'TTB18', encbp.w(51), h / 2, encbp.clrs.white, 0, 1)
            surface.SetFont('TTB18')
            local x = surface.GetTextSize(pExp)
            text('XP', 'TTL14', encbp.w(54) + x, h / 2, encbp.clrs.whitea, 0, 1)
        end

        local lvl = vgui.Create('Panel', info)
        lvl:Dock(LEFT)
        lvl:DockMargin(encbp.w(19), encbp.h(20), 0, encbp.h(17))
        lvl:SetWide(encbp.w(140))
        function lvl:Paint(w, h)
            setmat(mat20)
            setcolor(255,255,255)
            setsize(0, 0, encbp.w(43), encbp.h(30))

            text(plvl, 'TTB18', encbp.w(51), h / 2, encbp.clrs.white, 0, 1)
            surface.SetFont('TTB18')
            local x = surface.GetTextSize(plvl)
            text('LVL', 'TTL14', encbp.w(54) + x, h / 2, encbp.clrs.whitea, 0, 1)
        end

        local avatar = vgui.Create('Panel', info)
        avatar:Dock(LEFT)
        avatar:DockMargin(0, encbp.h(12), 0, encbp.h(12))
        avatar:SetWide(encbp.w(46))
        function avatar:Paint(w,h)
            setmat(mat5)
            setcolor(255, 255, 255)
            setsize(0, 0, w, h)
        end

        local avatar = vgui.Create('AvatarMask', avatar)
        avatar:Dock(FILL)
        avatar:DockMargin(encbp.w(5), encbp.h(5), encbp.w(5), encbp.h(5))
        avatar:SetPlayer(pl, 64)

        local pinfo = vgui.Create('Panel', info)
        pinfo:Dock(LEFT)
        pinfo:DockMargin(0, encbp.h(23), 0, encbp.h(18))
        pinfo:SetWide(encbp.w(155))
        function pinfo:Paint(w, h)
            text(pl:Name(), 'TT14', encbp.w(10))
            text(plvl, 'TT12', encbp.w(10), encbp.h(16), encbp.clrs.purple)
        end

        -- local buylvl = vgui.Create('DButton', info)
        -- buylvl:Dock(LEFT)
        -- buylvl:DockMargin(0, 0, 0, 0)
        -- buylvl:SetWide(encbp.w(168))
        -- buylvl:SetText('')
        -- buylvl:SetZPos(55)
        -- buylvl.alpha = 0
        -- function buylvl:Paint(w,h)
        --     local color
        --     if self:IsHovered() then
        --         color = encbp.clrs.white
        --         self.alpha = Lerp(FrameTime() * 8, self.alpha, 1)
        --     else
        --         color = encbp.clrs.purple
        --         self.alpha = Lerp(FrameTime() * 8, self.alpha, 0)
        --     end
        --     setmat(mat4)
        --     setcolor(255,255,255)
        --     setsize(0, 0, w, h)

        --     setmat(mat14)
        --     setcolor(255,255,255,255*self.alpha)
        --     setsize(0, 0, w, h)
        --     text('Купить уровни', 'TT14', w / 2, h / 2, color, 1, 1)
        -- end
    end

    do
        local buy = vgui.Create('DButton', page1)
        buy:SetSize(encbp.w(481), encbp.h(145))
        buy:SetPos(encbp.w(79), encbp.h(611))
        buy:SetText('')
        buy.alpha = 0
        buy.alpha1 = 1
        function buy:Paint(w, h)
            local color
            if self:IsHovered() and not self:GetDisabled() then
                color = encbp.clrs.white
                self.alpha = Lerp(FrameTime() * 8, self.alpha, 1)
                self.alpha1 = Lerp(FrameTime() * 8, self.alpha1, 0)
            else
                color = encbp.clrs.purple
                self.alpha = Lerp(FrameTime() * 8, self.alpha, 0)
                self.alpha1 = Lerp(FrameTime() * 8, self.alpha1, 1)
            end
            setmat(mat17)
            setcolor(255,255,255,255*self.alpha1)
            setsize(0, 0, w, h)

            setmat(mat12)
            setcolor(170, 170, 170, 255 * self.alpha)
            setsize(0, 0, w, h)
            text(access and 'ПРИОБРЕТЕНО' or 'КУПИТЬ ПРОПУСК', 'TTB16', w / 2, h / 2 - encbp.h(3), color, 1, 1)
        end
        function buy:DoClick()
            mainframe:AlphaTo(0, 0.15, 0,function()
                mainframe:Remove()
                RunConsoleCommand('donate')
            end)
        end
        if access then
            buy:SetDisabled(true)
            buy:SetAlpha(100)
        end
        if buy:GetDisabled() then
            buy:SetCursor('arrow')
        else
            buy:SetCursor('hand')
        end
    end

    do
        local freeinfo = vgui.Create('Panel', page1)
        freeinfo:SetSize(encbp.w(45), encbp.h(175))
        freeinfo:SetPos(encbp.w(46), encbp.h(221))
        function freeinfo:Paint(w, h)
            setmat(mat11)
            setcolor(255, 255, 255)
            setsize(0, 0, w, h)
        end

        local paydinfo = vgui.Create('Panel', page1)
        paydinfo:SetSize(encbp.w(45), encbp.h(157))
        paydinfo:SetPos(encbp.w(46), encbp.h(415))
        function paydinfo:Paint(w, h)
            setcolor(255, 255, 255)

            setmat(mat13)
            setsize(0, 0, w, h)

            setmat(mat2)
            setsize(encbp.w(17), encbp.h(38), encbp.w(14), encbp.h(83))
        end
    end

    scrl = vgui.Create('HorizontalScrollPanel', page1)
    scrl:SetSize(encbp.w(738), encbp.h(166))
    scrl:SetPos(encbp.w(123), encbp.h(218))
    scrl.Scrollbar:SetTall(0)

    for k, v in SortedPairsByMemberValue(encbp.bp.config.rewards.free, 'lvl') do
        local h = scrl:Add('bp.item')
        h:Dock(LEFT)
        h:SetWide(encbp.w(239))
        h:DockMargin(0, 0, encbp.w(10), 0)

        do
            if v.class == 'money' or v.class == 'case' then
                local model_panel = vgui.Create('Panel', h)
                model_panel:SetSize(encbp.w(140), encbp.h(119))
                model_panel:SetPos(encbp.w(49), encbp.h(24))
                model_panel.Paint = function(self, w, h)
                    setcolor(255, 255, 255)

                    if v.class == 'money' then
                        setmat(mat1)
                        setsize(0, 0, w, h - encbp.h(20))
                    else
                        setmat(case) 
                        setsize(encbp.w(5), 0, w-encbp.w(10), h)
                    end
                end
            elseif v.class == 'don' or v.class == 'admin' then
                local model_panel = vgui.Create('Panel', h)
                model_panel:SetSize(encbp.w(100), encbp.h(99))
                model_panel:SetPos(encbp.w(69), encbp.h(24))
                model_panel.Paint = function(self,w,h)
                    setcolor(255, 255, 255)

                    if v.class == 'don' then

                        setmat(money_bag) 
                        setsize(0, 0, w, h)
                    else
                        setmat(image_17) 
                        setsize(0, 0, w, h)
                    end
                end
            elseif v.class == 'weapon' or v.class == 'eda' or v.class == 'acs' then
                local model_panel = vgui.Create('SpawnIcon', h)
                model_panel:Dock(FILL)
                model_panel:DockMargin(encbp.w(69), encbp.h(24), encbp.w(69), encbp.h(43))
                model_panel:SetModel(v.model)
                model_panel:SetTooltip()
                model_panel:SetDisabled(true)
                model_panel:SetMouseInputEnabled(false)
                model_panel.DoClick = function() return end
            end
        end

        local pri = v.name and v.name or ''
        pri = v.class == 'money' and DarkRP.formatMoney(v.name) or pri


        local tbl = {
            name = pri,
            lvl = k,
            bool = data[v.uid] and 1 or plvl >= v.lvl and 2 or 3
        }

        h.DoClick = function()
            if plvl < v.lvl or data[v.uid] then
                return
            end

            net.Start('encbp.bg.take')
                net.WriteUInt(k, 8)
            net.SendToServer()
            
            mainframe:AlphaTo(0, 0.2, 0, function(data,panel)
                mainframe:Remove() 
            end)
        end

        if plvl < v.lvl or data[v.uid] then
            h:SetDisabled(true)
        end
        
        if h:GetDisabled() then
            h:SetCursor('arrow')
        else
            h:SetCursor('hand')
        end
        
        h:SetData( tbl )
    end

    scrlp = vgui.Create('HorizontalScrollPanel',page1)
    scrlp:SetSize(encbp.w(738), encbp.h(166))
    scrlp:SetPos(encbp.w(123), encbp.h(409))
    scrlp.Scrollbar:SetTall(0)

    for k, v in SortedPairsByMemberValue(encbp.bp.config.rewards.paid, 'lvl') do
        local h = scrlp:Add( 'bp.item' )
        h:Dock(LEFT)
        h:SetWide(encbp.w(239))
        h:DockMargin(0, 0, encbp.w(10), 0)

        do
            if v.class == 'money' or v.class == 'case' then
                local model_panel = vgui.Create('Panel', h)
                model_panel:SetSize(encbp.w(140), encbp.h(119))
                model_panel:SetPos(encbp.w(49), encbp.h(24))
                model_panel.Paint = function(self,w,h)
                    setcolor(255,255,255)

                    if v.class == 'money' then
                        setmat(mat1)
                        setsize(0, 0, w, h - encbp.h(20))
                    else
                        setmat(case) 
                        setsize(encbp.w(5), 0, w-encbp.w(10), h)
                    end
                end
            elseif v.class == 'don' or v.class == 'admin' then
                local model_panel = vgui.Create('Panel', h)
                model_panel:SetSize(encbp.w(100), encbp.h(99))
                model_panel:SetPos(encbp.w(69), encbp.h(24))
                model_panel.Paint = function(self,w,h)
                    setcolor(255, 255, 255)

                    if v.class == 'don' then
                        setmat(money_bag) 
                        setsize(0, 0, w, h)
                    else
                        setmat(image_17) 
                        setsize(0, 0, w, h)
                    end
                end
            elseif v.class == 'weapon' or v.class == 'eda' or v.class == 'acs' then
                local model_panel = vgui.Create('SpawnIcon', h)
                model_panel:Dock(FILL)
                model_panel:DockMargin(encbp.w(69), encbp.h(24), encbp.w(69), encbp.h(43))
                model_panel:SetModel(v.model)
                model_panel:SetTooltip()
                model_panel:SetDisabled(true)
                model_panel:SetMouseInputEnabled(false)
                model_panel.DoClick = function() return end
            end
        end

        local pri = v.name and v.name or ''
        pri = v.class == 'money' and DarkRP.formatMoney(v.name) or pri

        local tbl = {
            name = pri,
            lvl = k,
            bool = not access and 3 or data[v.uid] and 1 or plvl >= v.lvl and 2 or 3
        }

        h.DoClick = function()
            if plvl < v.lvl or data[v.uid] then
                return
            end

            net.Start('encbp.bg.takeprem')
                net.WriteUInt(k, 8)
            net.SendToServer()
            
            mainframe:AlphaTo(0, 0.2, 0, function(data,panel)
                mainframe:Remove() 
            end)
        end

        if plvl < v.lvl or data[v.uid] then
            h:SetDisabled(true)
        end

        if h:GetDisabled() then
            h:SetCursor('arrow')
        else
            h:SetCursor('hand')
        end
        
        h:SetData( tbl )
    end

    local left = vgui.Create('DButton', page1)
    left:SetPos(enc.w(761), enc.h(573))
    left:SetSize(enc.w(50), enc.h(50))
    left:SetText('')
    left.alpha = 1
    function left:Paint(w, h)
        if self:IsHovered() then
            self.alpha = Lerp(FrameTime() * 8, self.alpha, 0.5)
        else
            self.alpha = Lerp(FrameTime() * 8, self.alpha, 1)
        end

        setmat(mat23)
        setcolor(255, 255, 255, 255 * self.alpha)
        setsize(0, 0, w, h)
    end
    function left:Think()
        local pp = scrl.Scrollbar
        local ss = scrlp.Scrollbar

        if self:IsDown() then
            local delta = 0.2
            pp:AddScroll( delta * - 1 )
            ss:AddScroll( delta * - 1)
            delta = delta + 0.2
        end
    end

    local right = vgui.Create('DButton', page1)
    right:SetPos(enc.w(811), enc.h(573))
    right:SetSize(enc.w(50), enc.h(50))
    right:SetText('')
    right.alpha = 1
    function right:Paint(w, h)
        if self:IsHovered() then
            self.alpha = Lerp(FrameTime() * 8, self.alpha, 0.5)
        else
            self.alpha = Lerp(FrameTime() * 8, self.alpha, 1)
        end

        setmat(mat22)
        setcolor(255, 255, 255, 255 * self.alpha)
        setsize(0, 0, w, h)
    end
    function right:Think()
        local pp = scrl.Scrollbar
        local ss = scrlp.Scrollbar

        if self:IsDown() then
            local delta = 0.2
            pp:AddScroll( delta )
            ss:AddScroll( delta )
            delta = delta + 0.2
        end
    end
    
    page2 = vgui.Create('Panel', frame)
    page2:SetSize(encbp.w(1497), encbp.h(877))
    page2:SetAlpha(0)
    page2:SetVisible(false)
    page2.Paint = function(self, w, h)
        setmat(mat15)
        setcolor(255,255,255)
        setsize(encbp.w(926), encbp.h(194), encbp.w(512), encbp.h(512))
    end

    local scroll = vgui.Create('DScrollPanel', page2)
    scroll:Dock(LEFT)
    scroll:DockMargin(encbp.w(110), encbp.h(194), 0, encbp.h(161))
    scroll:SetWide(encbp.w(628))
    local sc = scroll:GetVBar()
    sc:SetWide(2)
    function sc:Paint() end
    function sc.btnDown:Paint() end
    function sc.btnUp:Paint() end
    function sc.btnGrip:Paint(w, h) box(0, 0, 0, w, h, encbp.clrs.purple) end
    
    for k, v in SortedPairsByMemberValue(taskTable, 'exp') do
        local arg1, arg2 = week[k].check(pl)
        local sub_title = arg1.. ' из '.. arg2

        local h = vgui.Create('bp.task', scroll)
        h:Dock(TOP)
        h:DockMargin(0, 0, enc.w(2), encbp.h(13))
        h:SetTall(encbp.h(130))
        h:SetDesc(v.desc)
        local tbl = {
            title = v.title,
            task = task_complete[v.uid] and '' or sub_title,
            exp = v.exp,
            exp2 = arg1,
            completed = task_complete[v.uid],
            expmax = arg2,
            check = v.check,
        }
        
        h:SetData( tbl )
    end

    local task = vgui.Create('DButton', page1)
    task:SetPos(frame:GetWide() - encbp.w(88+289), encbp.h(737))
    task:SetSize(encbp.w(289), encbp.h(59))
    task:SetText('')
    task.alpha = 0
    task.alpha1 = 1
    local color
    function task:Paint(w,h)
        if self:IsHovered() then
            color = encbp.clrs.white
            self.alpha = Lerp(FrameTime() * 8, self.alpha, 1)
            self.alpha1 = Lerp(FrameTime() * 8, self.alpha1, 0)
        else
            color = encbp.clrs.purple
            self.alpha = Lerp(FrameTime() * 8, self.alpha, 0)
            self.alpha1 = Lerp(FrameTime() * 8, self.alpha1, 1)
        end
        setmat(mat7)
        setcolor(255, 255, 255, 255 * self.alpha1)
        setsize(0, 0, w, h)

        setmat(mat6)
        setcolor(255, 255, 255, 255 * self.alpha)
        setsize(0, 0, w, h)

        text('Задания', 'TT24', w / 2, h / 2, color, 1, 1)
        text('1', 'TTB18', w - encbp.w(24), h / 2, encbp.clrs.bpurple, 2, 1)
    end
    function task:DoClick()
        visible = true
        page2:SetVisible(true)
        page1:AlphaTo(0 ,0.3)
        page2:AlphaTo(255, 0.3)
    end

    local back = vgui.Create('DButton', page2)
    back:SetPos(frame:GetWide() - encbp.w(88+289), encbp.h(737))
    back:SetSize(encbp.w(289), encbp.h(59))
    back:SetText('')
    back.alpha = 0
    back.alpha1 = 1
    local color
    function back:Paint(w,h)
        if self:IsHovered() then
            color = encbp.clrs.white
            self.alpha = Lerp(FrameTime() * 8, self.alpha, 1)
            self.alpha1 = Lerp(FrameTime() * 8, self.alpha1, 0)
        else
            color = encbp.clrs.purple
            self.alpha = Lerp(FrameTime() * 8, self.alpha, 0)
            self.alpha1 = Lerp(FrameTime() * 8, self.alpha1, 1)
        end

        setmat(mat7)
        setcolor(255, 255, 255, 255 * self.alpha1)
        setsize(0, 0, w, h)

        setmat(mat6)
        setcolor(255, 255, 255, 255 * self.alpha)
        setsize(0, 0, w, h)
        text('Назад', 'TT24', w / 2, h / 2, color, 1, 1)

        text('2', 'TTB18', w - encbp.w(22), h / 2, encbp.clrs.bpurple, 2, 1)
    end
    function back:DoClick()
        visible = false
        page2:SetVisible(false)
        page2:AlphaTo(0, 0.3)
        page1:AlphaTo(255, 0.3)
    end
end)

hook.Add('PlayerButtonDown', 'bp.open', function( ply, button )
    if button == KEY_F7 then 
        if CLIENT and not IsFirstTimePredicted() then
            return
        end
    
        net.Start('encbp.bp.open')
        net.SendToServer()
    end
end)

net.Receive('encbp.bp.chat', function()
    local t = net.ReadTable()
    
    chat.AddText(unpack(t))
end)

net.Receive('BPAcceptGroup', function()
    local group = net.ReadString()
    ui.BoolRequest('Выдача привилегии', 'Подтвердите выдачу ' .. group .. ' вместо вашей текущей привилегии!', function(bool)
        if bool == true then
            net.Start('BPAcceptGroupBool')
                net.WriteString(group)
            net.SendToServer()
        end
    end)
end)
--PATH addons/_gmbheist/lua/autorun/sh_gmbheistcfg.lua:
-- SPECIAL GAMBITRP

-- Работы которые могут грабить
GMB_HEIST_ROBBERS = {["Бандит"] = true, ["Вор"] = true, ["Умелый Вор"] = true, ["Глава бандитов"] = true, ["Элитный Бандит"] = true, ["Грабитель"] = true, ["Хакер"] = true}
-- Полицейские работы
GMB_HEIST_POLICE = {["Офицер Полиции"] = true, ["Начальник полиции"] = true, ["Спецназ"] = true, ["Начальник пилиции"] = true, ["Медик спецназа"] = true, ["Снайпер спецназа"] = true, ["Командир спецназа"] = true, ["Агент FBI"] = true, ["Джаггернаут"] = true, ["Мэр"] = true}
--PATH MediaLib_DynFile_webradio.lua:
local oop = medialib.load("oop")
local WebRadioService = oop.class("WebRadioService", "BASSService")
WebRadioService.identifier = "webradio"

local all_patterns = {
	"^https?://(.*)%.pls",
	"^https?://(.*)%.m3u"
}

function WebRadioService:parseUrl(url)
	for _,pattern in pairs(all_patterns) do
		local id = string.match(url, pattern)
		if id then
			return {id = id}
		end
	end
end

function WebRadioService:isValidUrl(url)
	return self:parseUrl(url) ~= nil
end

function WebRadioService:resolveUrl(url, callback)
	callback(url, {})
end

function WebRadioService:directQuery(url, callback)
	callback(nil, {
		title = url:match("([^/]+)$") -- the filename is the best we can get (unless we parse pls?)
	})
end

return WebRadioService
--PATH MediaLib_DynFile_mp4.lua:
local oop = medialib.load("oop")

local Mp4Service = oop.class("Mp4Service", "HTMLService")
Mp4Service.identifier = "mp4"

local all_patterns = {"^https?://.*%.mp4"}

function Mp4Service:parseUrl(url)
	for _,pattern in pairs(all_patterns) do
		local id = string.match(url, pattern)
		if id then
			return {id = id}
		end
	end
end

function Mp4Service:isValidUrl(url)
	return self:parseUrl(url) ~= nil
end

local player_url = "https://wyozi.github.io/gmod-medialib/mp4.html?id=%s"
function Mp4Service:resolveUrl(url, callback)
	local urlData = self:parseUrl(url)
	local playerUrl = string.format(player_url, urlData.id)

	callback(playerUrl, {start = urlData.start})
end

function Mp4Service:directQuery(url, callback)
	callback(nil, {
		title = url:match("([^/]+)$")
	})
end

function Mp4Service:hasReliablePlaybackEvents()
	return true
end

return Mp4Service
--PATH addons/_bansys/lua/autorun/sh_meta.lua:
local meta = FindMetaTable("Player")

function meta:isHobos()
    return table.HasValue( {TEAM_HOBO, TEAM_DOGE, TEAM_NASIL, TEAM_PARKOUR, TEAM_MEHANIK, TEAM_COOK}, self:Team() ) or false
end

function meta:isCitizen()
    return table.HasValue( {TEAM_CITIZEN, TEAM_HOBOO, TEAM_MEDIC, TEAM_BUIS, TEAM_STORE, TEAM_VOR, TEAM_OHOT, TEAM_METIK, TEAM_MAYOR}, self:Team() ) or false
end
--PATH addons/donate3/lua/autorun/sh_zombieevent.lua:
function StartZombieEvent()
if SERVER then
	-- hook.Add("PlayerShouldTakeDamage", "ZombieEvent", function( ply, attacker )
		-- if ply.onzombieevent and IsValid(attacker) and attacker:IsPlayer() then attacker:ChatPrint("Включен ивент, урон не нанесен") return false end
	-- end)
	hook.Add("OnNPCKilled", "ZombieEvent", function( npc, attacker,inflictor )
		if IsValid(attacker) and attacker:IsPlayer() and attacker.onzombieevent then attacker:addMoney(500) DarkRP.notify(attacker, 4, 4, "Получено 500$ за убийство мутанта на ивенте") attacker:ChatPrint("Получено 500$ за убийство мутанта на ивенте") end
		end)
	-- hook.Add("canDropWeapon", "ZombieEvent", function(ply,weapon)
		-- if ply.onzombieevent then DarkRP.notify(ply, 1, 4, "Ну ты ахуел конечно, вздумал тут выбрасывать ивентскую пушку") return false end
	-- end)
		local mutantsspawnspos =  {
			Vector(1496, 155, 64),
			Vector(3146, 150, 64),
			Vector(3371, -1213, 64),
			Vector(2001, -1294, 64)
		}
		local spawns = { 
			Vector(1630, -677, 72),
			Vector(-558, -1188, 64),
			Vector(-191, -2072, 64),
			Vector(1005, -2120, 64),
			Vector(1214, -2124, 64), 
			Vector(3628, -3151, 72),
			Vector(3615, -4015, 72), 
			Vector(4437, -2879, 72), 
			Vector(4749, -2103, 72), 
			Vector(5187, -1302, 72), 
			Vector(4900, -349, 72), 
			Vector(3902, -237, 72), 
			Vector(2796, 181, 64), 
			Vector(3446, 862, 64), 
			Vector(2681, 1298, 64), 
			Vector(1881, 1323, 64), 
			Vector(1260, 1856, 72), 
			Vector(1112, 2519, 176), 
			Vector(881, 2437, 144), 
			Vector(1171, 1138, 64), 
			Vector(552, -657, 79), 
			Vector(4368, -165, 72), 
			Vector(1945, -2734, 64), 
			Vector(-971, 609, 64)
		}
	for k,v in player.Iterator() do
		v:SetHealth(100)
		v:ChatPrint("Внимание! Начался Зомби ивент! Все фракции должны бороться с зомби!")
		DarkRP.notify(v, 4, 4, "Внимание! Начался Зомби ивент! Все фракции должны бороться с зомби!")
		v.onzombieevent = true
	end
	
	local zombies = {"npc_fastzombie", "npc_zombie", "npc_poisonzombie", "npc_fastzombie_torso"}
	local mutants = {"npc_antlion", "npc_antlionguard", "npc_poisonzombie", "npc_antlion"}

	timer.Create("ZombieEvent", 5, 60, function()
		local zombieClass = table.Random(zombies)
		local zombieSpawned = ents.Create(zombieClass)
		zombieSpawned:SetPos(table.Random(spawns) + Vector(math.random(1,5), math.random(1,10), math.random(1,5)))
		zombieSpawned:Spawn()
	end)

	timer.Create("SuperMutants", 50, 6, function()
		local mutantClass = table.Random(mutants)
		local mutantSpawned = ents.Create(mutantClass)
		mutantSpawned:SetPos(table.Random(mutantsspawnspos) + Vector(math.random(1,5), math.random(1,10), math.random(1,5)))
		mutantSpawned:Spawn()
	end)

	timer.Simple(301, function()
		for _, class in ipairs(zombies) do
			for _, v in ipairs(ents.FindByClass(class)) do
				v:Remove()
			end
		end

		for _, class in ipairs(mutants) do
			for _, v in ipairs(ents.FindByClass(class)) do
				v:Remove()
			end
		end

		for k,v in player.Iterator() do
			v:addMoney(15000)
			v:SendLua([[chat.AddText(Color(255,155,55),"[Зомби-Ивент] ",Color(255,255,255),"Внимание! Ивент окончен! Переход в РП ",Color(0,255,0),"+ $15,000")]])
			v:SendLua([[clearzombie()]])
			v.onzombieevent = nil
		end
	end)


end
end


function clearzombie()
	RunConsoleCommand("stopsound")
	RunConsoleCommand('r_cleardecals')
	for k, v in ipairs(ents.FindByClass("class C_ClientRagdoll")) do
		v:Remove()
	end
	-- for k, v in ipairs(ents.FindByClass("class C_PhysPropClientside")) do
		-- v:Remove()
	-- end
end
--PATH addons/genshin_impact_shenhe_2682682029/lua/autorun/shenhe.lua:
player_manager.AddValidModel( "Shenhe", "models/cyanblue/genshin_impact/shenhe/shenhe.mdl" );
player_manager.AddValidHands( "Shenhe", "models/cyanblue/genshin_impact/shenhe/arms/shenhe.mdl", 0, "00000000" )

local Category = "Genshin Impact"

local NPC = { 	Name = "Shenhe", 
				Class = "npc_citizen",
				Model = "models/cyanblue/genshin_impact/shenhe/npc/shenhe.mdl",
				Health = "100",
				KeyValues = { citizentype = 4 },
				Category = Category	}

list.Set( "NPC", "npc_Shenhe_genshin_impact", NPC )
--PATH addons/111mod/lua/textscreens_config.lua:
textscreenFonts = {}

local function addFont(font, t)
	if CLIENT then
		t.size = 100
		surface.CreateFont(font, t)
		t.size = 50
		surface.CreateFont(font .. "_MENU", t)
	end

	table.insert(textscreenFonts, font)
end

--[[
---------------------------------------------------------------------------
Custom fonts - requires server restart to take affect -- "Screens_" will be removed from the font name in spawnmenu
---------------------------------------------------------------------------
--]]

-- Default textscreens font
addFont("Coolvetica outlined", {
	font = "coolvetica",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Coolvetica", {
	font = "coolvetica",
	weight = 400,
	antialias = false,
	outline = false
})

-- Trebuchet
addFont("Screens_Trebuchet outlined", {
	font = "Trebuchet MS",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Trebuchet", {
	font = "Trebuchet MS",
	weight = 400,
	antialias = false,
	outline = false
})

-- Arial
addFont("Screens_Arial outlined", {
	font = "Arial",
	weight = 600,
	antialias = false,
	outline = true
})

addFont("Screens_Arial", {
	font = "Arial",
	weight = 600,
	antialias = false,
	outline = false
})

-- Roboto Bk
addFont("Screens_Roboto outlined", {
	font = "Roboto Bk",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Roboto", {
	font = "Roboto Bk",
	weight = 400,
	antialias = false,
	outline = false
})

-- Helvetica
addFont("Screens_Helvetica outlined", {
	font = "Helvetica",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Helvetica", {
	font = "Helvetica",
	weight = 400,
	antialias = false,
	outline = false
})

-- akbar
addFont("Screens_Akbar outlined", {
	font = "akbar",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_Akbar", {
	font = "akbar",
	weight = 400,
	antialias = false,
	outline = false
})

-- csd
addFont("Screens_csd outlined", {
	font = "csd",
	weight = 400,
	antialias = false,
	outline = true
})

addFont("Screens_csd", {
	font = "csd",
	weight = 400,
	antialias = false,
	outline = false
})

if CLIENT then

	local function addFonts(path)
		local files, folders = file.Find("resource/fonts/" .. path .. "*", "MOD")

		for k, v in ipairs(files) do
			if string.GetExtensionFromFilename(v) == "ttf" then
				local font = string.StripExtension(v)
				if table.HasValue(textscreenFonts, "Screens_" .. font) then continue end
print("-- "  .. font .. "\n" .. [[
addFont("Screens_ ]] .. font .. [[", {
	font = font,
	weight = 400,
	antialias = false,
	outline = true
})
				]])
			end
		end

		for k, v in ipairs(folders) do
			addFonts(path .. v .. "/")
		end
	end

	concommand.Add("get_fonts", function(ply)
		addFonts("")
	end)

end

--PATH addons/dermaf4/lua/ui/controls/checkbox.lua:
local PANEL = {}

function PANEL:SetText(txt)
	self.Label = self.Label or ui.Create('DLabel', self)
	
	self.Label:SetFont('ui.18')
	self.Label:SetText(txt)
end

function PANEL:PerformLayout() end

function PANEL:SetConVar(var)
	self.Button.DoClick = function()
		self.Button:Toggle()
		cvar.SetValue(var, not cvar.GetValue(var))
	end
	self.Label:SetMouseInputEnabled(true)
	self.Label.OnMousePressed = self.Button.DoClick
	self:SetValue(cvar.GetValue(var) and 1 or 0)
	self:SetTextColor(ui.col.White)
end

function PANEL:SizeToContents()
	local w, h = 32, 16

	self.Button:SetSize(w, h)

	if self.Label then
		self.Label:SizeToContents()

		h = math.max(h, self.Label:GetTall())

		self.Label:SetPos(w + 5, (h - self.Label:GetTall()) * 0.5 - 1)

		w = w + 10 + self.Label:GetWide()
	end

	self:SetSize(w, h)
end

vgui.Register('ui_checkbox', PANEL, 'DCheckBoxLabel')
--PATH addons/_adminmodules/lua/ulib/shared/hook.lua:
if hook.GetULibTable then return end	-- Prevent autorefresh reloading this file
local gmod			= gmod
local pairs			= pairs
local isfunction	= isfunction
local isstring		= isstring
local isnumber		= isnumber
local math			= math
local IsValid		= IsValid
local setmetatable = setmetatable
local insert = table.insert
--[[
local concommand = concommand
local print = print
local PrintTable = PrintTable
local tostring = tostring
local assert = assert
local table = table--]]

do
	_G.HOOK_MONITOR_HIGH = -2
	_G.HOOK_HIGH = -1
	_G.HOOK_NORMAL = 0
	_G.HOOK_LOW = 1
	_G.HOOK_MONITOR_LOW = 2
end

HOOK_MONITOR_HIGH = -2
HOOK_HIGH = -1
HOOK_NORMAL = 0
HOOK_LOW = 1
HOOK_MONITOR_LOW = 2


local HOOK_MONITOR_HIGH = HOOK_MONITOR_HIGH
local HOOK_HIGH = HOOK_HIGH
local HOOK_NORMAL = HOOK_NORMAL
local HOOK_LOW = HOOK_LOW
local HOOK_MONITOR_LOW = HOOK_MONITOR_LOW


-- Grab all previous hooks from the pre-existing hook module.
local OldHooks = hook.GetTable()

module( "hook" )

local Hooks = {}
local BackwardsHooks = {} -- A table fully to garry's spec for aVoN

--
-- For access to the Hooks table.. for some reason.
--
function GetTable() return BackwardsHooks end
function GetULibTable() return Hooks end

-- Replaced with Srlions hook library. https://github.com/Srlion/Hook-Library


local events = {}

local function find_hook(event, name)
	for i = 1, event.n, 4 do
		local _name = event[i]
		if _name and _name == name then
			return i
		end
	end
end

local function copy_event(event, event_name)
	local new_event = {}
	do
		for i = 1, event.n do
			local v = event[i]
			if v then
				insert(new_event, v)
			end
		end
		new_event.n = #new_event
	end

	-- we use proxies here just to make __index work
	-- https://stackoverflow.com/a/3122136
	local proxy = {}
	do
		for i = 1, event.n do
			proxy[i] = event[i]
			event[i] = nil
		end
		proxy.n = event.n
		event.n = nil
	end

	setmetatable(event, {
		__index = function(_, key)
			-- make event.n work
			if isstring(key) then
				return proxy[key]
			end

			local name = proxy[key - 1]
			if not name then return end

			local parent = events[event_name]

			-- if hook got removed then don't run it
			local pos = find_hook(parent, name)
			if not pos then return end

			-- if hook priority changed then it should be treated as a new hook, don't run it
			if parent[pos + 3 --[[priority]]] ~= proxy[key + 2 --[[priority]]] then return end

			return parent[pos + 1]
		end
	})

	return new_event
end

function Remove(event_name, name)
	local event = events[event_name]
	if not event then return end

	local pos = find_hook(event, name)
	if pos then
		event[pos] = nil --[[name]]
		event[pos + 1] = nil --[[func]]
		event[pos + 2] = nil --[[real_func]]
		event[pos + 3] = nil --[[priority]]
	end

	events[event_name] = copy_event(event, event_name)
end

local hook_Remove = Remove
function Add(event_name, name, func, priority)
	if not isstring(event_name) then return end
	if not isfunction(func) then return end
	if not name then return end

	local real_func = func
	if not isstring(name) then
		func = function(...)
			local isvalid = name.IsValid
			if isvalid and isvalid(name) then
				return real_func(name, ...)
			end

			hook_Remove(event_name, name)
		end
	end

	if not isnumber(priority) then
		priority = HOOK_NORMAL
	elseif priority < HOOK_MONITOR_HIGH then
		priority = HOOK_MONITOR_HIGH
	elseif priority > HOOK_MONITOR_LOW then
		priority = HOOK_MONITOR_LOW
	end

	-- disallow returning in monitor hooks
	if priority == HOOK_MONITOR_HIGH or priority == HOOK_MONITOR_LOW then
		local _func = func
		func = function(...)
			_func(...)
		end
	end

	local event = events[event_name]
	if not event then
		event = {
			n = 0,
		}
		events[event_name] = event
	end

	local pos
	if event then
		local _pos = find_hook(event, name)
		-- if hook exists and priority changed then remove the old one because it has to be treated as a new hook
		if _pos and event[_pos + 3] ~= priority then
			hook_Remove(event_name, name)
		else
			-- just update the hook here because nothing changed but the function
			pos = _pos
		end
	end

	event = events[event_name]

	if pos then
		event[pos + 1] = func
		event[pos + 2] = real_func
		return
	end

	if priority == HOOK_MONITOR_LOW then
		local n = event.n
		event[n + 1] = name
		event[n + 2] = func
		event[n + 3] = real_func
		event[n + 4] = priority
	else
		local event_pos = 4
		for i = 4, event.n, 4 do
			local _priority = event[i]
			if priority < _priority then
				if i < event_pos then
					event_pos = i
				end
			elseif priority >= _priority then
				event_pos = i + 4
			end
		end
		insert(event, event_pos - 3, name)
		insert(event, event_pos - 2, func)
		insert(event, event_pos - 1, real_func)
		insert(event, event_pos, priority)
	end

	event.n = event.n + 4
end


function GetTable()
	local new_events = {}

	for event_name, event in pairs(events) do
		local hooks = {}
		for i = 1, event.n, 4 do
			local name = event[i]
			if name then
				hooks[name] = event[i + 2] --[[real_func]]
			end
		end
		new_events[event_name] = hooks
	end

	return new_events
end

--[[---------------------------------------------------------
	Name: Call
	Args: string hookName, table gamemodeTable, vararg args
	Desc: Calls hooks associated with the hook name.
-----------------------------------------------------------]]
function Call(event_name, gm, ...)
	local event = events[event_name]
	if event then
		local i, n = 2, event.n
		::loop::
		local func = event[i]
		if func then
			local a, b, c, d, e, f = func(...)
			if a ~= nil then
				return a, b, c, d, e, f
			end
		end
		i = i + 4
		if i <= n then
			goto loop
		end
	end

	--
	-- Call the gamemode function
	--
	if not gm then return end

	local GamemodeFunction = gm[event_name]
	if not GamemodeFunction then return end

	return GamemodeFunction(gm, ...)
end

local gamemode_cache
local hook_Call = Call
function Run(name, ...)
	-- AVOID HAVING ADDITIONAL C CALLS, SO SIMPLE HOOKS CAN BE EXTRA 2% FASTER
	if not gamemode_cache then
		gamemode_cache = gmod and gmod.GetGamemode() or nil
	end
	return hook_Call(name, gamemode_cache, ...)
end


-- Bring old hooks
local hook_Add = Add
for event_name, t in pairs( OldHooks ) do
	for name, func in pairs( t ) do
		hook_Add( event_name, name, func )
	end
end

--PATH addons/_adminmodules/lua/ulib/shared/tables.lua:
--[[
	Title: Tables

	Some table helpers.
]]

-- Based off "RecursiveReadOnlyTables" by VeLoSo (http://lua-users.org/wiki/RecursiveReadOnlyTables)

-- cache the metatables of all existing read-only tables,
-- so our functions can get to them, but user code can't
local metatable_cache = setmetatable( {}, { __mode = "k" } )

local function make_getter( real_table )
	local function getter( dummy, key )
		local ret = real_table[ key ]
		if type( ret ) == "table" and not metatable_cache[ ret ] then
			ret = ULib.makeReadOnly( ret )
		end
		return ret
	end
	return getter
end

local function setter()
	ULib.error( "Attempt to modify read-only table!" )
end

local function make_pairs( real_table )
	local function pairs()
		local key, value, cur_key = nil, nil, nil
		local function nexter() -- both args dummy
			key, value = next( real_table, cur_key )
			cur_key = key
			if type( key ) == "table" and not metatable_cache[ key ] then
				key = ULib.makeReadOnly( key )
			end
			if type( value ) == "table" and not metatable_cache[ value ] then
				value = ULib.makeReadOnly( value )
			end
			return key, value
		end
		return nexter -- values 2 and 3 dummy
	end
	return pairs
end


--[[
	Function: makeReadOnly

	Makes a table and all recursive tables read-only

	Parameters:

		t - The table to make read-only

	Returns:

		The table read-only'fied
]]
function ULib.makeReadOnly( t )
	local new={}
	local mt={
		__metatable = "read only table",
		__index = make_getter( t ),
		__newindex = setter,
		__pairs = make_pairs( t ),
		__type = "read-only table" }
	setmetatable( new, mt )
	metatable_cache[ new ] = mt
	return new
end


--[[
	Function: ropairs

	The equivalent of "pairs" for a readonly table, since "pairs" won't work.

	Parameters:

		t - The table
]]
function ULib.ropairs( t )
	local mt = metatable_cache[ t ]
	if mt==nil then
		ULib.error( "bad argument #1 to 'ropairs' (read-only table expected, got " .. type(t) .. ")" )
	end
	return mt.__pairs()
end


--[[
	Function: findInTable

	Finds a value in a table. As opposed to table.HasValue(), this function will *only* check numeric keys, and will return a number of where the value is.

	Parameters:

		t - The table to check
		check - The value to check if it exists in t. Can be any type.
		init - *(Optional, defaults to 1)* The value to start from.
		last - *(Optional, defaults to the length of the table)* The value to end at.
		recursive - *(Optional, default to false)* If true, it will check any subtables it comes across.

	Returns:

		The number of the key where check resides, false if none is found. If init > last it returns false as well.
]]
function ULib.findInTable( t, check, init, last, recursive )
	init = init or 1
	last = last or #t

	if init > last then return false end

	for i=init, last do
		if t[ i ] == check then return i end

		if type( t[ i ] ) == "table" and recursive then return ULib.findInTable( v, check, 1, recursive ) end
	end

	return false
end

--[[
	Function: matrixTable

	Splits a table into a number of given columns. Does not change original table.

	Parameters:

		t - The table to split
		columns, The number of columns to create

	Returns:

		The new table with the column being the first key and the row being the second key.

	Revisions:

		v2.10 - Initial
]]
function ULib.matrixTable( t, columns )
	local baserows = math.floor( #t / columns )
	local remainder = math.fmod( #t, columns )
	local nt = {} -- New table after we process
	local curn = 1 -- What value to grab next from our old table

	for i=1, columns do
		local numtograb = baserows
		if i <= remainder then
			numtograb = baserows + 1
		end

		nt[ i ] = {}
		for n=0, numtograb - 1 do
			table.insert( nt[ i ], t[ curn + n ] )
		end
		curn = curn + numtograb
	end

	return nt
end

--PATH addons/_adminmodules/lua/ulib/shared/player.lua:
--[[
	Title: Player

	Has useful player-related functions.
]]

--[[
	Function: getPicker

	Gets the player directly in front of the specified player

	Parameters:

		ply - The player to look for another player in front of.
		radius - *(Optional, defaults to 30)* How narrow to make our checks for players in front of us.

	Returns:

		The player most directly in front of us if one exists with the given constraints, otherwise nil.

	Revisions:

		v2.40 - Initial.
]]
function ULib.getPicker( ply, radius )
	radius = radius or 30

	local trace = util.GetPlayerTrace( ply )
	local trace_results = util.TraceLine( trace )

	if not trace_results.Entity:IsValid() or not trace_results.Entity:IsPlayer() then
		-- Try finding a best choice
		local best_choice
		local best_choice_diff
		local pos = ply:GetPos()
		local ang = ply:GetAimVector():Angle()
		local players = player.GetAll()
		for _, player in ipairs( players ) do
			if player ~= ply then
				local vec_diff = player:GetPos() - Vector( 0, 0, 16 ) - pos
				local newang = vec_diff:Angle()
				local diff = math.abs( math.NormalizeAngle( newang.pitch - ang.pitch ) ) + math.abs( math.NormalizeAngle( newang.yaw - ang.yaw ) )
				if not best_choice_diff or diff < best_choice_diff then
					best_choice_diff = diff
					best_choice = player
				end
			end
		end

		if not best_choice or best_choice_diff > radius then
			return -- Give up
		else
			return best_choice
		end
	else
		return trace_results.Entity
	end
end


local Player = FindMetaTable( "Player" )
local checkIndexes = { Player.UniqueID, function( ply ) if CLIENT then return "" end local ip = ULib.splitPort( ply:IPAddress() ) return ip end, Player.SteamID, Player.UserID }
--[[
	Function: getPlyByID

	Finds a user identified by the given ID.

	Parameters:

		id - The ID to try to match against connected players. Can be a unique id, ip address, steam id, or user id.

	Returns:

		The player matching the id given or nil if none match.

	Revisions:

		v2.50 - Initial.
]]
function ULib.getPlyByID( id )
	id = id:upper()

	local players = player.GetAll()
	for _, indexFn in ipairs( checkIndexes ) do
		for _, ply in ipairs( players ) do
			if tostring( indexFn( ply ) ) == id then
				return ply
			end
		end
	end

	return nil
end


--[[
	Function: getUniqueIDForPly

	Finds a unique ID for a player, suitable for use in getUsers or getUser to uniquely identify the given player.

	Parameters:

		ply - The player we want an ID for

	Returns:

		The id for the player or nil if none are unique.

	Revisions:

		v2.50 - Initial.
		v2.51 - Added exception for single player since it's handled differently on client and server.
]]
function ULib.getUniqueIDForPlayer( ply )
	if game.SinglePlayer() then
		return "1"
	end

	local players = player.GetAll()
	for _, indexFn in ipairs( checkIndexes ) do
		local id = indexFn( ply )
		if ULib.getUser( "$" .. id, true ) == ply then
			return id
		end
	end

	return nil
end


--[[
	Function: getUsers

	Finds users matching an identifier.

	Parameters:

		target - A string of what you'd like to target. Accepts a comma separated list.
		enable_keywords - *(Optional, defaults to false)* If true, the keywords "*" for all players, "^" for self,
			"@" for picker (person in front of you), "#<group>" for those inside a specific group,
			"%<group>" for users inside a group (counting inheritance), and "$<id>" for users matching a
			particular ID will be activated.
			Any of these can be negated with "!" before it. IE, "!^" targets everyone but yourself.
		ply - *(Optional)* Player needing getUsers, this is necessary for some of the keywords.

	Returns:

		A table of players (false and message if none found).

	Revisions:

		v2.40 - Rewrite, added more keywords, removed immunity.
		v2.50 - Added "#" and '$' keywords, removed special exception for "%user" (replaced by "#user").
		v2.60 - Returns false if target is an empty string.
]]
function ULib.getUsers( target, enable_keywords, ply )
	if target == "" then
		return false, "No target specified!"
	end

	local players = player.GetAll()

	-- First, do a full name match in case someone's trying to exploit our target system
	for _, player in ipairs( players ) do
		if target:lower() == player:Nick():lower() then
			return { player }
		end
	end

	-- Okay, now onto the show!
	local targetPlys = {}
	local pieces = ULib.explode( ",", target )
	for _, piece in ipairs( pieces ) do
		piece = piece:Trim()
		if piece ~= "" then
			local keywordMatch = false
			if enable_keywords then
				local tmpTargets = {}
				local negate = false
				if piece:sub( 1, 1 ) == "!" and piece:len() > 1 then
					negate = true
					piece = piece:sub( 2 )
				end

				if piece:sub( 1, 1 ) == "$" then
					local player = ULib.getPlyByID( piece:sub( 2 ) )
					if player then
						table.insert( tmpTargets, player )
					end
				-- elseif piece == "*" then -- All!
					-- table.Add( tmpTargets, players )
				elseif piece == "^" then -- Self!
					if ply then
						if ply:IsValid() then
							table.insert( tmpTargets, ply )
						elseif not negate then
							return false, "You cannot target yourself from console!"
						end
					end
				elseif piece == "@" then
					if IsValid( ply ) then
						local player = ULib.getPicker( ply )
						if player then
							table.insert( tmpTargets, player )
						end
					end
				elseif piece:sub( 1, 1 ) == "#" and ULib.ucl.groups[ piece:sub( 2 ) ] then
					local group = piece:sub( 2 )
					for _, player in ipairs( players ) do
						if player:GetUserGroup() == group then
							table.insert( tmpTargets, player )
						end
					end
				elseif piece:sub( 1, 1 ) == "%" and ULib.ucl.groups[ piece:sub( 2 ) ] then
					local group = piece:sub( 2 )
					for _, player in ipairs( players ) do
						if player:CheckGroup( group ) then
							table.insert( tmpTargets, player )
						end
					end
				else
					local tblForHook = hook.Run( ULib.HOOK_GETUSERS_CUSTOM_KEYWORD, piece, ply )
					if tblForHook then
						table.Add( tmpTargets, tblForHook )
					end
				end

				if negate then
					for _, player in ipairs( players ) do
						if not table.HasValue( tmpTargets, player ) then
							keywordMatch = true
							table.insert( targetPlys, player )
						end
					end
				else
					if #tmpTargets > 0 then
						keywordMatch = true
						table.Add( targetPlys, tmpTargets )
					end
				end
			end

			if not keywordMatch then
				for _, player in ipairs( players ) do
					if player:Nick():lower():find( piece:lower(), 1, true ) then -- No patterns
						table.insert( targetPlys, player )
					end
				end
			end
		end
	end

	-- Now remove duplicates
	local finalTable = {}
	for _, player in ipairs( targetPlys ) do
		if not table.HasValue( finalTable, player ) then
			table.insert( finalTable, player )
		end
	end

	if #finalTable < 1 then
		return false, "No target found or target has immunity!"
	end

	return finalTable
end


--[[
	Function: getUser

	Finds a user matching an identifier.

	Parameters:

		target - A string of the user you'd like to target. IE, a partial player name.
		enable_keywords - *(Optional, defaults to false)* If true, the keywords "^" for self, "@" for picker (person in
			front of you), and "$<id>" will be activated.
		ply - *(Optional)* Player needing getUsers, this is necessary to use keywords.

	Returns:

		The resulting player target, false and message if no user found.

	Revisions:

		v2.40 - Rewrite, added keywords, removed immunity.
		v2.50 - Added "$" keyword.
		v2.60 - Returns false if target is an empty string.
]]
function ULib.getUser( target, enable_keywords, ply )
	if target == "" then
		return false, "No target specified!"
	end

	local players = player.GetAll()
	target = target:lower()

	local plyMatches = {}
	if enable_keywords and target:sub( 1, 1 ) == "$" then
		possibleId = target:sub( 2 )
		table.insert( plyMatches, ULib.getPlyByID( possibleId ) )
	end

	-- First, do a full name match in case someone's trying to exploit our target system
	for _, player in ipairs( players ) do
		if target == player:Nick():lower() then
			if #plyMatches == 0 then
				return player
			else
				return false, "Found multiple targets! Please choose a better string for the target. (EG, the whole name)"
			end
		end
	end

	if enable_keywords then
		if target == "^" and ply then
			if ply:IsValid() then
				return ply
			else
				return false, "You cannot target yourself from console!"
			end
		elseif IsValid( ply ) and target == "@" then
			local player = ULib.getPicker( ply )
			if not player then
				return false, "No player found in the picker"
			else
				return player
			end
		else
			local player = hook.Run( ULib.HOOK_GETUSER_CUSTOM_KEYWORD, target, ply )
			if player then return player end
		end
	end

	for _, player in ipairs( players ) do
		if player:Nick():lower():find( target, 1, true ) then -- No patterns
			table.insert( plyMatches, player )
		end
	end

	if #plyMatches == 0 then
		return false, "No target found or target has immunity!"
	elseif #plyMatches > 1 then
		local str = plyMatches[ 1 ]:Nick()
		for i=2, #plyMatches do
			str = str .. ", " .. plyMatches[ i ]:Nick()
		end

		return false, "Found multiple targets: " .. str .. ". Please choose a better string for the target. (EG, the whole name)"
	end

	return plyMatches[ 1 ]
end

--PATH addons/_adminmodules/lua/ulx/cl_init.lua:
if not ulx then
	ulx = {}
	include( "ulx/sh_defines.lua" )
	include( "ulx/cl_lib.lua" )
	include( "ulx/sh_base.lua" )

	local sh_modules = file.Find( "ulx/modules/sh/*.lua", "LUA" )
	local cl_modules = file.Find( "ulx/modules/cl/*.lua", "LUA" )

	for _, file in ipairs( cl_modules ) do
		include( "ulx/modules/cl/" .. file )
	end

	for _, file in ipairs( sh_modules ) do
		include( "ulx/modules/sh/" .. file )
	end
end

--PATH addons/_adminmodules/lua/ulx/modules/cl/xgui_helpers.lua:
--xgui_helpers -- by Stickly Man!
--A set of generic functions to help with various XGUI-related things.

function xgui.load_helpers()
	--These handle keyboard focus for textboxes within XGUI.
	local function getKeyboardFocus( pnl )
		if pnl:HasParent( xgui.base ) then
			xgui.anchor:SetKeyboardInputEnabled( true )
		end
		if pnl.selectAll then
			pnl:SelectAllText()
		end
	end
	hook.Add( "OnTextEntryGetFocus", "XGUI_GetKeyboardFocus", getKeyboardFocus )

	local function loseKeyboardFocus( pnl )
		if pnl:HasParent( xgui.base ) then
			xgui.anchor:SetKeyboardInputEnabled( false )
		end
	end
	hook.Add( "OnTextEntryLoseFocus", "XGUI_LoseKeyboardFocus", loseKeyboardFocus )


	---------------------------------
	--Code for creating the XGUI base
	---------------------------------
	function xgui.makeXGUIbase()
		xgui.anchor = xlib.makeXpanel{ w=600, h=420, x=ScrW()/2-300, y=ScrH()/2-270 }
		xgui.anchor:SetVisible( false )
		xgui.anchor:SetKeyboardInputEnabled( false )
		xgui.anchor.Paint = function( self, w, h ) hook.Call( "XLIBDoAnimation" ) end
		xgui.anchor:SetAlpha( 0 )

		xgui.base = xlib.makepropertysheet{ x=0, y=0, w=600, h=400, parent=xgui.anchor, offloadparent=xgui.null }
		xgui.base.animOpen = function() --First 4 are fade animations, last (or invalid choice) is the default fade animation.
			xgui.settings.animIntype = tonumber( xgui.settings.animIntype )
			if xgui.settings.animIntype == 2 then
				xlib.addToAnimQueue( function() xgui.anchor:SetAlpha(255) end )
				xlib.addToAnimQueue( "pnlSlide", { panel=xgui.anchor, startx=xgui.x, starty=-490, endx=xgui.x, endy=xgui.y, setvisible=true } )
			elseif xgui.settings.animIntype == 3 then
				xlib.addToAnimQueue( function() xgui.anchor:SetAlpha(255) end )
				xlib.addToAnimQueue( "pnlSlide", { panel=xgui.anchor, startx=-610, starty=xgui.y, endx=xgui.x, endy=xgui.y, setvisible=true } )
			elseif xgui.settings.animIntype == 4 then
				xlib.addToAnimQueue( function() xgui.anchor:SetAlpha(255) end )
				xlib.addToAnimQueue( "pnlSlide", { panel=xgui.anchor, startx=xgui.x, starty=ScrH(), endx=xgui.x, endy=xgui.y, setvisible=true } )
			elseif xgui.settings.animIntype == 5 then
				xlib.addToAnimQueue( function() xgui.anchor:SetAlpha(255) end )
				xlib.addToAnimQueue( "pnlSlide", { panel=xgui.anchor, startx=ScrW(), starty=xgui.y, endx=xgui.x, endy=xgui.y, setvisible=true } )
			else
				xlib.addToAnimQueue( function() xgui.anchor:SetPos( xgui.x, xgui.y ) end )
				xlib.addToAnimQueue( "pnlFade", { panelIn=xgui.anchor } )
			end
			xlib.animQueue_start()
		end
		xgui.base.animClose = function()
			xgui.settings.animOuttype = tonumber( xgui.settings.animOuttype )
			if xgui.settings.animOuttype == 2 then
				xlib.addToAnimQueue( "pnlSlide", { panel=xgui.anchor, startx=xgui.x, starty=xgui.y, endx=xgui.x, endy=-490, setvisible=false } )
				xlib.addToAnimQueue( function() xgui.anchor:SetAlpha(0) end )
			elseif xgui.settings.animOuttype == 3 then
				xlib.addToAnimQueue( "pnlSlide", { panel=xgui.anchor, startx=xgui.x, starty=xgui.y, endx=-610, endy=xgui.y, setvisible=false } )
				xlib.addToAnimQueue( function() xgui.anchor:SetAlpha(0) end )
			elseif xgui.settings.animOuttype == 4 then
				xlib.addToAnimQueue( "pnlSlide", { panel=xgui.anchor, startx=xgui.x, starty=xgui.y, endx=xgui.x, endy=ScrH(), setvisible=false } )
				xlib.addToAnimQueue( function() xgui.anchor:SetAlpha(0) end )
			elseif xgui.settings.animOuttype == 5 then
				xlib.addToAnimQueue( "pnlSlide", { panel=xgui.anchor, startx=xgui.x, starty=xgui.y, endx=ScrW(), endy=xgui.y, setvisible=false } )
				xlib.addToAnimQueue( function() xgui.anchor:SetAlpha(0) end )
			else
				xlib.addToAnimQueue( function() xgui.anchor:SetPos( xgui.x, xgui.y ) end )
				xlib.addToAnimQueue( "pnlFade", { panelOut=xgui.anchor } )
			end
			xlib.animQueue_start()
		end

		function xgui.SetPos( pos, xoff, yoff, ignoreanim ) --Sets the position of XGUI based on "pos", and checks to make sure that with whatever offset and pos combination, XGUI does not go off the screen.
			pos = tonumber( pos )
			xoff = tonumber( xoff )
			yoff = tonumber( yoff )
			if not xoff then xoff = 0 end
			if not yoff then yoff = 0 end
			if not pos then pos = 5 end
			if pos == 1 or pos == 4 or pos == 7 then --Left side of the screen
				if xoff < -10 then
					xoff = -10
				elseif xoff > ScrW()-610 then
					xoff = ScrW()-610
				end
				xgui.x = 10+xoff
			elseif pos == 3 or pos == 6 or pos == 9 then --Right side of the screen
				if xoff < -ScrW()+610 then
					xoff = -ScrW()+610
				elseif xoff > 10 then
					xoff = 10
				end
				xgui.x = ScrW()-610+xoff
			else --Center
				if xoff < -ScrW()/2+300 then
					xoff = -ScrW()/2+300
				elseif xoff > ScrW()/2-300 then
					xoff = ScrW()/2-300
				end
				xgui.x = ScrW()/2-300+xoff
			end

			if pos == 1 or pos == 2 or pos == 3 then --Bottom of the screen
				if yoff < -ScrH()+430 then
					yoff = -ScrH()+430
				elseif yoff > 30 then
					yoff = 30
				end
				xgui.y = ScrH()-430+yoff
			elseif pos == 7 or pos == 8 or pos == 9 then --Top of the screen
				if yoff < -10 then
					yoff = -10
				elseif yoff > ScrH()-410 then
					yoff = ScrH()-410
				end
				xgui.y = yoff+10
			else --Center
				if yoff < -ScrH()/2+210 then
					yoff = -ScrH()/2+210
				elseif yoff > ScrH()/2-190 then
					yoff = ScrH()/2-190
				end
				xgui.y = ScrH()/2-210+yoff
			end
			if ignoreanim then
				xgui.anchor:SetPos( xgui.x, xgui.y )
			else
				local curx, cury = xgui.anchor:GetPos()
				xlib.addToAnimQueue( "pnlSlide", { panel=xgui.anchor, startx=curx, starty=cury, endx=xgui.x, endy=xgui.y } )
				xlib.animQueue_start()
			end
		end
		xgui.SetPos( xgui.settings.xguipos.pos, xgui.settings.xguipos.xoff, xgui.settings.xguipos.yoff )

		function xgui.base:SetActiveTab( active, ignoreAnim )
			if ( self.m_pActiveTab == active ) then return end
			if ( self.m_pActiveTab ) then
				if not ignoreAnim then
					xlib.addToAnimQueue( "pnlFade", { panelOut=self.m_pActiveTab:GetPanel(), panelIn=active:GetPanel() } )
				else
					--Run this when module permissions have changed.
					xlib.addToAnimQueue( "pnlFade", { panelOut=nil, panelIn=active:GetPanel() }, 0 )
				end
				xlib.animQueue_start()
			end
			self.m_pActiveTab = active
			self:InvalidateLayout()
		end

		--Progress bar
		xgui.chunkbox = xlib.makeprogressbar{ x=420, w=180, h=20, visible=false, skin=xgui.settings.skin, parent=xgui.anchor }
		function xgui.chunkbox:Progress( datatype )
			self.value = self.value + 1
			self:SetFraction( self.value / self.max )
			self.Label:SetText( "Getting data: " .. datatype .. " - " .. string.format("%.2f", (self.value / self.max) * 100) .. "%" )
			if self.value == self.max then
				xgui.dataInitialized = true
				xgui.expectingdata = nil
				self.Label:SetText( "Waiting for clientside processing..." )
				xgui.queueFunctionCall( xgui.chunkbox.SetVisible, "chunkbox", xgui.chunkbox, false )
				RunConsoleCommand( "_xgui", "dataComplete" )
			end
		end
	end

	------------------------
	--XGUI QueueFunctionCall
	------------------------
	--This is essentially a straight copy of Megiddo's queueFunctionCall; Since XGUI tends to use it quite a lot, I decided to seperate it to prevent delays in ULib's stuff
	--I also now get to add a method of flushing the queue based on a tag in the event that new data needs to be updated.
	local stack = {}
	local function onThink()

		local num = #stack
		if num > 0 then
			for i=1,3 do --Run 3 lines per frame
				if stack[1] ~= nil then
					local b, e = pcall( stack[ 1 ].fn, unpack( stack[ 1 ], 1, stack[ 1 ].n ) )
					if not b then
						ErrorNoHalt( "XGUI queue error: " .. tostring( e ) .. "\n" )
					end
				end
			table.remove( stack, 1 ) -- Remove the first inserted item. This is FIFO
			end
		else
			hook.Remove( "Think", "XGUIQueueThink" )
		end
	end

	function xgui.queueFunctionCall( fn, tag, ... )
		if type( fn ) ~= "function" then
			error( "queueFunctionCall received a bad function", 2 )
			return
		end

		table.insert( stack, { fn=fn, tag=tag, n=select( "#", ... ), ... } )
		hook.Add( "Think", "XGUIQueueThink", onThink, HOOK_MONITOR_HIGH )
	end

	function xgui.flushQueue( tag )
		local removeIndecies = {}
		for i, fncall in ipairs( stack ) do
			if fncall.tag == tag then
				table.insert( removeIndecies, i )
			end
		end
		for i=#removeIndecies,1,-1 do --Remove the queue functions backwards to prevent desynchronization of pairs
			table.remove( stack, removeIndecies[i] )
		end
	end

	-------------------
	--ULIB XGUI helpers
	-------------------
	--Helper function to parse access tag for a particular argument
	function ulx.getTagArgNum( tag, argnum )
		return tag and ULib.splitArgs( tag, "<", ">" )[argnum]
	end

	--Load control interpretations for ULib argument types
	function ULib.cmds.BaseArg.x_getcontrol( arg, argnum, parent )
		return xlib.makelabel{ label="Not Supported", parent=parent }
	end

	function ULib.cmds.NumArg.x_getcontrol( arg, argnum, parent )
		if arg.cmd == 'ulx cloak' then return end 

		local access, tag = LocalPlayer():query( arg.cmd )
		local restrictions = {}
		ULib.cmds.NumArg.processRestrictions( restrictions, arg, ulx.getTagArgNum( tag, argnum ) )

		if table.HasValue( arg, ULib.cmds.allowTimeString ) then
			local min = restrictions.min or 0
			local max = restrictions.max or 10 * 60 * 24 * 365 --default slider max 10 years
			local outPanel = xlib.makepanel{ h=40, parent=parent }
			local xpos = weight(225)
			if arg.cmd == 'ulx ban' or arg.cmd == 'ulx gban' then
				xpos = weight(120)
			end
	
			outPanel.interval = xlib.makecombobox{ x=xpos, w=weight(120),y=ScrH()*.01, parent=outPanel }
			outPanel.val = xlib.makeslider{ w=weight(165), y=height(20), label="<--->", min=min, max=max, value=min, decimal=0, parent=outPanel }

			local divisor = {}
			local sensiblemax = {}
			if min == 0 then  outPanel.interval:AddChoice( "Permanent" ) table.insert( divisor, 1 ) table.insert( sensiblemax, 0 ) end
			if max >= 1 and min <= 60*24 then outPanel.interval:AddChoice( "Minutes" ) table.insert( divisor, 1 ) table.insert( sensiblemax, 60*24 ) end
			if max >= 60 and min <= 60*24*7 then outPanel.interval:AddChoice( "Hours" ) table.insert( divisor, 60 ) table.insert( sensiblemax, 24*7 ) end
			if max >= ( 60*24 ) and min <= 60*24*120 then outPanel.interval:AddChoice( "Days" ) table.insert( divisor, 60*24 ) table.insert( sensiblemax, 120 ) end
			if max >= ( 60*24*7 ) and min <= 60*24*7*52 then outPanel.interval:AddChoice( "Weeks" ) table.insert( divisor, 60*24*7 ) table.insert( sensiblemax, 52 ) end
			if max >= ( 60*24*365 ) then outPanel.interval:AddChoice( "Years" ) table.insert( divisor, 60*24*365 ) table.insert( sensiblemax, 10 ) end
			
			outPanel.interval.OnSelect = function( self, index, value, data )
				local maxvalue = math.min( max / divisor[index], sensiblemax[index] )
				local minvalue = math.max( min / divisor[index], 0 )
				net.Start('ChangeValueSelect')
				net.WriteUInt(maxvalue,31)
				net.WriteUInt(min,32)
				net.SendToServer()
				-- pnledSl:SetMax( outPanel.val.maxvalue )
				-- pnledSl:SetMin( outPanel.val.minvalue )
				-- pnledSl:SetValue( math.Clamp( tonumber( outPanel.val:GetValue() ), outPanel.val.minvalue, outPanel.val.maxvalue ) )
			end
			-- function outPanel.val:ValueChanged( val )
			-- 	self.Slider:SetSlideX( self.Scratch:GetFraction( val ) )
			-- 	if ( self.TextArea != vgui.GetKeyboardFocus() ) then
			-- 		self.TextArea:SetValue( self.Scratch:GetTextValue() )
			-- 	end
			-- 	self:OnValueChanged( val )
			-- end

			if #outPanel.interval.Choices ~= 0 then
				outPanel.interval:ChooseOptionID( 1 )
			end

			outPanel.GetValue = function( self )
				local val, char = self:GetRawValue()
				return val .. char
			end
			outPanel.GetRawValue = function( self )
				local char = string.lower( self.interval:GetValue():sub(1,1) )
				if char == "m" or char == "p" or tonumber( self.val:GetValue() ) == 0 then char = "" end
				return self.val:GetValue(), char
			end
			outPanel.GetMinutes = function( self )
				local btime, char = self:GetRawValue()
				if char == "h" then btime = btime * 60
				elseif char == "d" then btime = btime * 1440
				elseif char == "w" then btime = btime * 10080
				elseif char == "y" then btime = btime * 525600 end
				return btime
			end
			return outPanel
		else
			local defvalue = arg.min
			if table.HasValue( arg, ULib.cmds.optional ) then defvalue = arg.default end
			if not defvalue then defvalue = 0 end --No default was set for this command, so we'll use 0.

			local maxvalue = restrictions.max
			local minvalue = restrictions.min or 0
			if maxvalue == nil then
				if defvalue > 100 then
					maxvalue = defvalue
				else
					maxvalue = 100
				end
			end

			local decimal = 0
			if not table.HasValue( arg, ULib.cmds.round ) then
				local minMaxDelta = maxvalue - minvalue
				if minMaxDelta < 5 then
					decimal = 2
				elseif minMaxDelta <= 10 then
					decimal = 1
				end
			end

			local outPanel = xlib.makepanel{ h=35, parent=parent }
			outPanel.val = xlib.makeslider{ y=15, w=165, min=minvalue, max=maxvalue, value=defvalue, decimal=decimal, label="<--->", parent=outPanel }
			outPanel.GetValue = function( self ) return outPanel.val.GetValue( outPanel.val ) end
			return outPanel
		end
	end
	function ULib.cmds.NumArg.getTime( arg )
		if arg == nil or arg == "" then return nil, nil end

		if arg == 0 or tonumber( arg ) == 0 then
			return "Permanent", 0
		end

		local charPriority = { "y", "w", "d", "h" }
		local charMap = { "Years", "Weeks", "Days", "Hours" }
		local divisor = { 60 * 24 * 365, 60 * 24 * 7, 60 * 24, 60 }
		for i, v in ipairs( charPriority ) do
			if arg:find( v, 1, true ) then
				if not charMap[ i ] or not divisor [ i ] or not ULib.stringTimeToMinutes( arg ) then return nil, nil end
				local val = ULib.stringTimeToMinutes( arg ) / divisor[ i ]
				if val == 0 then return "Permanent", 0 end
				return charMap[ i ], val
			end
		end

		return "Minutes", ULib.stringTimeToMinutes( arg )
	end

	function ULib.cmds.StringArg.x_getcontrol( arg, argnum, parent )
		local access, tag = LocalPlayer():query( arg.cmd )
		local restrictions = {}
		ULib.cmds.StringArg.processRestrictions( restrictions, arg, ulx.getTagArgNum( tag, argnum ) )

		local is_restricted_to_completes = table.HasValue( arg, ULib.cmds.restrictToCompletes ) -- Program-level restriction (IE, ulx map)
			or restrictions.playerLevelRestriction -- The player's tag specifies only certain strings

		if is_restricted_to_completes then
			return xlib.makecombobox{ text=arg.hint or "StringArg", choices=restrictions.restrictedCompletes, parent=parent }
		elseif restrictions.restrictedCompletes and table.Count( restrictions.restrictedCompletes ) > 0 then
			-- This is where there needs to be both a drop down AND an input box
			local outPanel = xlib.makecombobox{ text=arg.hint, choices=restrictions.restrictedCompletes, enableinput=true, selectall=true, parent=parent }
			outPanel.OnEnter = function( self )
				self:GetParent():OnEnter()
			end
			return outPanel
		else
			return xlib.maketextbox{ text=arg.hint or "StringArg", selectall=true, parent=parent }
		end
	end

	function ULib.cmds.PlayerArg.x_getcontrol( arg, argnum, parent )
		local access, tag = LocalPlayer():query( arg.cmd )
		local restrictions = {}
		ULib.cmds.PlayerArg.processRestrictions( restrictions, LocalPlayer(), arg, ulx.getTagArgNum( tag, argnum ) )

		local outPanel = xlib.makecombobox{ text=arg.hint, parent=parent }
		local targets = restrictions.restrictedTargets
		if targets == false then -- No one allowed
			targets = {}
		elseif targets == nil then -- Everyone allowed
			targets = player.GetAll()
		end

		for _, ply in ipairs( targets ) do
			outPanel:AddChoice( ply:Nick() )
		end
		return outPanel
	end

	function ULib.cmds.CallingPlayerArg.x_getcontrol( arg, argnum, parent )
		return xlib.makelabel{ label=arg.hint or "CallingPlayer", parent=parent }
	end

	function ULib.cmds.BoolArg.x_getcontrol( arg, argnum, parent )
		local access, tag = LocalPlayer():query( arg.cmd )
		local restrictions = {}
		ULib.cmds.BoolArg.processRestrictions( restrictions, arg, ulx.getTagArgNum( tag, argnum ) )

		local outPanel = xlib.makecheckbox{ label=arg.hint or "BoolArg", value=restrictions.restrictedTo, parent=parent }
		if restrictions.restrictedTo ~= nil then outPanel:SetDisabled( true ) end
		outPanel.GetValue = function( self )
			return self:GetChecked() and 1 or 0
		end
		return outPanel
	end
end

--PATH addons/models_mafia_don_hitman/lua/autorun/vito.lua:
player_manager.AddValidModel( "Don Corleone", "models/vito.mdl" );

list.Set( "PlayerOptionsModel", "Don Corleone", "models/vito.mdl" );






--PATH addons/animation/lua/wos/anim_extension/holdtypes/melee_combo.lua:
local DATA = {}

DATA.Name = "Melee Combination"
DATA.HoldType = "melee-combo"
DATA.BaseHoldType = "melee2"
DATA.Translations = {}

--DATA.Translations[ ACT_MP_STAND_IDLE ]					= 2680
--DATA.Translations[ ACT_MP_WALK ]						= 2683
--DATA.Translations[ ACT_MP_RUN ]							= 2685
DATA.Translations[ ACT_MP_CROUCH_IDLE ]					= ACT_HL2MP_IDLE_CROUCH_KNIFE 
DATA.Translations[ ACT_MP_CROUCHWALK ]					= ACT_HL2MP_WALK_CROUCH_KNIFE
--DATA.Translations[ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]	= 2688
DATA.Translations[ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ]	= ACT_HL2MP_GESTURE_RANGE_ATTACK_KNIFE 
--DATA.Translations[ ACT_MP_RELOAD_STAND ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_RELOAD_CROUCH ]				= IdleActivity + 6
--DATA.Translations[ ACT_MP_JUMP ]						= 3160
--DATA.Translations[ ACT_MP_SWIM ]						= IdleActivity + 9
--DATA.Translations[ ACT_LAND ]							= ACT_LAND

wOS.AnimExtension:RegisterHoldtype( DATA )
--PATH addons/animation/lua/wos/fortnite/core/cl_core.lua:
--[[-------------------------------------------------------------------
	Fortnite Dancing Client Core:
		Core functions for the client
			Powered by
						  _ _ _    ___  ____  
				__      _(_) | |_ / _ \/ ___| 
				\ \ /\ / / | | __| | | \___ \ 
				 \ V  V /| | | |_| |_| |___) |
				  \_/\_/ |_|_|\__|\___/|____/ 
											  
 _____         _                 _             _           
|_   _|__  ___| |__  _ __   ___ | | ___   __ _(_) ___  ___ 
  | |/ _ \/ __| '_ \| '_ \ / _ \| |/ _ \ / _` | |/ _ \/ __|
  | |  __/ (__| | | | | | | (_) | | (_) | (_| | |  __/\__ \
  |_|\___|\___|_| |_|_| |_|\___/|_|\___/ \__, |_|\___||___/
                                         |___/             
----------------------------- Copyright 2019 ]]--[[
							  
	Lua Developer: King David
	Contact: www.wiltostech.com
]]--

wOS = wOS or {}
wOS.Fortnite = wOS.Fortnite or {}

hook.Add( "CreateMove", "wOS.Fortnite.TauntCameraMove", function( cmd )

	if not wOS.Fortnite.TauntCamera then return end
	return wOS.Fortnite.TauntCamera:CreateMove( cmd, LocalPlayer(), true )

end )

hook.Add( "CalcView", "wOS.Fortnite.TauntCameraView", function( ply, origin, angles )

	if not wOS.Fortnite.TauntCamera then return end
	return wOS.Fortnite.TauntCamera:CalcView( { origin = origin, angles = angles, fov = fov }, LocalPlayer(), true )

end )
--PATH addons/zeros_lua_libary/lua/zclib/util/sh_language.lua:
zclib = zclib or {}
zclib.Language = zclib.Language or {}

zclib.Language["Minutes"] = "Minutes"
zclib.Language["Seconds"] = "Seconds"
zclib.Language["Cancel"] = "Cancel"

--PATH addons/zeros_lua_libary/lua/zclib/util/sh_sounds.lua:
zclib = zclib or {}

zclib.Sound = zclib.Sound or {}
zclib.Sound.List = zclib.Sound.List or {}

// This packs the requested sound Data
function zclib.Sound.Catch(id)
	local soundData = {}
	local soundTable = zclib.Sound.List[id]
	soundData.sound = soundTable.paths[math.random(#soundTable.paths)]
	soundData.lvl = soundTable.lvl
	soundData.pitch = math.Rand(soundTable.pitchMin, soundTable.pitchMax)
	soundData.volume = soundTable.volume or 1

	return soundData
end

function zclib.Sound.EmitFromPosition(pos,id)
	local soundData = zclib.Sound.Catch(id)
	sound.Play(soundData.sound, pos, soundData.lvl, soundData.pitch, soundData.volume)
end

function zclib.Sound.EmitFromEntity(id, ent)

	local cur_time = math.Round(CurTime(),2)

	// Lets make sure we dont play the same sound at the same time more then a specified amount 5
	if ent.SoundTracker and ent.SoundTracker[id] and ent.SoundTracker[id][cur_time] and ent.SoundTracker[id][cur_time] >= 5 then
		return
	else
		if ent.SoundTracker == nil then
			ent.SoundTracker = {}
		end

		if ent.SoundTracker[id] == nil then
			ent.SoundTracker[id] = {}
		end

		ent.SoundTracker[id][cur_time] = (ent.SoundTracker[id][cur_time] or 0) + 1
	end

	local soundData = zclib.Sound.Catch(id)
	ent:EmitSound(soundData.sound, soundData.lvl, soundData.pitch, soundData.volume, CHAN_STATIC, 0, 0)
end

function zclib.Sound.StopFromEntity(id, ent)
	local soundData = zclib.Sound.Catch(id)
	ent:StopSound(soundData.sound)
end


sound.Add({
	name = "zclib_ui_click",
	channel = CHAN_STATIC,
	volume = 1,
	level = 60,
	pitch = {100, 100},
	sound = {"UI/buttonclick.wav"}
})

zclib.Sound.List["throw"] = {
	paths = {
		"zerolib/throw01.wav",
		"zerolib/throw02.wav",
		"zerolib/throw03.wav",
		"zerolib/throw04.wav",
		"zerolib/throw05.wav",
	},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100
}

zclib.Sound.List["inv_add"] = {
	paths = {
		"zerolib/inv_add.wav",
	},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100
}

zclib.Sound.List["machine_explode"] = {
	paths = {
		"weapons/explode3.wav",
		"weapons/explode4.wav",
		"weapons/explode5.wav",
	},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100
}

zclib.Sound.List["gas_buff"] = {
	paths = {"zerolib/gas_buff01.wav","zerolib/gas_buff02.wav","zerolib/gas_buff03.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100
}

zclib.Sound.List["zapp"] = {
	paths = {
		"ambient/energy/spark1.wav",
		"ambient/energy/spark2.wav",
		"ambient/energy/spark3.wav",
		"ambient/energy/spark4.wav",
		"ambient/energy/spark5.wav",
		"ambient/energy/spark6.wav"
	},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100
}


zclib.Sound.List["cash"] = {
	paths = {"zerolib/cash.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100
}

zclib.Sound.List["shoot"] = {
	paths = {"zerolib/shoot.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100
}

zclib.Sound.List["upgrade"] = {
	paths = {"zerolib/upgrade.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100
}
zclib.Sound.List["building"] = {
	paths = {"zerolib/building.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100
}

zclib.Sound.List["splash"] = {
	paths = {"ambient/water/water_splash1.wav","ambient/water/water_splash2.wav","ambient/water/water_splash3.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	volume = 0.30
}

zclib.Sound.List["error"] = {
	paths = {"zerolib/error.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	volume = 1,
}

--PATH addons/zeros_lua_libary/lua/zclib/zone/sh_zone.lua:
zclib = zclib or {}
zclib.Zone = zclib.Zone or {}

////////////////////////////////////////////////////////////////

zclib.Zone.Entrys = zclib.Zone.Entrys or {}

function zclib.Zone.Setup(entryid,entrydata)
    zclib.Debug("zclib.Zone.Setup " .. entrydata.script .. " " .. entryid)
    zclib.Zone.Entrys[entryid] = entrydata
end

/*
function zclib.Zone.Setup(entryid,script,toolname,path,getdata,load,remove,drawzone,onzoneremoved,snapsize,extraheight)
    zclib.Debug("zclib.Zone.Setup " .. script .. " " .. entryid)
    zclib.Zone.Entrys[entryid] = {

        script = script,

        // The path of the save file
        path = path,

        // Return the var we store the data in
        GetData = getdata,

        // Gets called when the zone data loads
        Load = load,

        // Gets called when the zone data gets removed
        Remove = remove,

        // The name of the toolgun lua file
        ToolName = toolname,

        // Draw the name of the zone in the pewview
        DrawZone = drawzone,


        // Gets called when a zone is about to get removed
        OnZoneRemoved = onzoneremoved,

        // If set then the zones will snap
        SnapSize = snapsize,

        // The default height of the zone
        BaseHeight = 200,

        // Defines how much extra height will be added when drawing the Zone Box
        ExtraHeight = extraheight or 200,

		// Allows the zone to be drawn from A to B without a predefined height
		//FreeSize = true,
		//BaseHeight = 0,
		//ExtraHeight = 0,

		// How much extra size / thinkess will be added on existing zones?
		Thickness = 50,
    }
end
*/
function zclib.Zone.GetEntry(entryid)
    return zclib.Zone.Entrys[entryid]
end

function zclib.Zone.GetData(entryid)
    return zclib.Zone.Entrys[entryid].GetData()
end

function zclib.Zone.Set(entryid,data)
    zclib.Debug("zclib.Zone.Set " .. entryid)
    return zclib.Zone.Entrys[entryid].Load(data or {})
end

function zclib.Zone.GetToolName(entryid)
	if not zclib.Zone.Entrys[entryid] then return "nil" end
    return zclib.Zone.Entrys[entryid].ToolName or "nil"
end

function zclib.Zone.GetSnapSize(entryid)
	if not zclib.Zone.Entrys[entryid] then return 10 end
    return zclib.Zone.Entrys[entryid].SnapSize
end

function zclib.Zone.GetFreeSize(entryid)
	if not zclib.Zone.Entrys[entryid] then return end
    return zclib.Zone.Entrys[entryid].FreeSize
end

////////////////////////////////////////////////////////////////
local TraceLengthLimit = 1000
function zclib.Zone.GetTracePos(entryid, ply, trace)
	local n_pos = trace.HitPos

	local snapsize = zclib.Zone.GetSnapSize(entryid)
    if snapsize then n_pos = zclib.Zone.Snap(n_pos,snapsize) end

	if ply:GetPos():Distance(n_pos) > TraceLengthLimit then
		n_pos = ply:EyePos() + ply:EyeAngles():Forward() * TraceLengthLimit
	end

	return n_pos
end

function zclib.Zone.GetFinalSize(entryid,trace,pos_start,pos_end)
	local zoneSize = zclib.Zone.GetSize(entryid,pos_start, pos_end)

	if zclib.Zone.GetFreeSize(entryid) then
		zoneSize = zoneSize + trace.HitNormal:Angle():Forward() * 2
		zoneSize = Vector(zoneSize.x,zoneSize.y,math.Clamp(zoneSize.z,20,9999999999))
	end

	return zoneSize
end

// Gets called from the swep to start creating a zone
function zclib.Zone.ToolLeftClick(entryid, swep, ply, trace, extradata)
    zclib.Debug("zclib.Zone.ToolLeftClick " .. entryid)
    if trace.Hit == nil or trace.Hit == false then return end
    if trace.HitPos == nil then return end
    if zclib.Player.IsAdmin(ply) == false then return end
    if SERVER then zclib.Zone.Show(entryid,ply) end

    local vec01 = Vector(0, 0, zclib.Zone.GetHeight(entryid))

    local n_pos = zclib.Zone.GetTracePos(entryid, ply, trace)

    if swep.ZoneStart == nil then

        swep.ZoneStart = n_pos

        if CLIENT then
            LocalPlayer().zclib_ZoneStart = n_pos
        end
    else
        if SERVER then

			local zoneSize = zclib.Zone.GetFinalSize(entryid,trace,swep.ZoneStart,n_pos)

            zclib.Zone.Add(entryid, ply, swep.ZoneStart - vec01, zoneSize, extradata)
        end

        swep.ZoneStart = nil

        if CLIENT then
            LocalPlayer().zclib_ZoneStart = nil
        end
    end
end

function zclib.Zone.ToolRightClick(entryid, swep, ply, trace)
    zclib.Debug("zclib.Zone.ToolRightClick " .. entryid)
    // Cancel the current zone
    if swep.ZoneStart then
        swep.ZoneStart = nil

        if CLIENT then
            LocalPlayer().zclib_ZoneStart = nil
        end
    else
        // Search for any zone which has trace.HitPos in it and remove it
        if SERVER then
            zclib.Zone.RemoveAt(entryid, ply, trace.HitPos)
        end
    end
end

function zclib.Zone.ToolDeploy(entryid, swep)
    zclib.Debug("zclib.Zone.ToolDeploy " .. entryid)

    swep.ZoneStart = nil

    if CLIENT then
        LocalPlayer().zclib_ZoneStart = nil
    end

    if SERVER then
        if zclib.Player.IsAdmin(swep:GetOwner()) == false then return end
        zclib.Zone.Show(entryid, swep:GetOwner())
    end
end

function zclib.Zone.ToolHolster(entryid, swep)
    zclib.Debug("zclib.Zone.ToolHolster " .. entryid)
    swep.ZoneStart = nil

    if CLIENT then
        LocalPlayer().zclib_ZoneStart = nil
    end

    if SERVER then
        zclib.Zone.Hide(swep:GetOwner())
    end
end

function zclib.Zone.ToolThink(entryid, swep)

    // A quick fix for the toolgun deploy function not working correctly on the first start
    if CLIENT and (swep.LastDraw == nil or (swep.LastDraw + 2) < CurTime()) then
        zclib.Zone.Preview_Start(entryid)
        swep.LastDraw = CurTime()
    end
end

////////////////////////////////////////////////////////////////

function zclib.Zone.Snap(vec,snapsize)
    return Vector(zclib.util.SnapValue(snapsize,vec.x),zclib.util.SnapValue(snapsize,vec.y),vec.z)
end


// Checks if the specified position is inside the specified zone
function zclib.Zone.Check(entryid,zone_id,pos)
    //zclib.Debug("zclib.Zone.Check")
    local zonelist = zclib.Zone.GetData(entryid)
    if zonelist == nil then return false end

    local zone = zonelist[zone_id]
    if zone == nil then return false end

    local box_start = zone.pos
	local size = zone.size

	local thickPos,thickSize = zclib.Zone.GetThickness(entryid,box_start,size)
    if thickPos and thickSize then
        box_start = box_start + thickPos
        size = size + thickSize
    end

    local box_end = box_start + size

    local result = pos:WithinAABox( box_start, box_end )

    if result then
        return true
    else
        return false
    end
end

// Checks if the specified position is inside any of the zones
function zclib.Zone.CheckAll(entryid,pos)
    //zclib.Debug("zclib.Zone.CheckAll")

    local zonelist = zclib.Zone.GetData(entryid)
    if zonelist == nil then return false end

    local result = false
    for k,v in pairs(zonelist) do
        if zclib.Zone.Check(entryid,k,pos) then
            result = k
            break
        end
    end
    return result
end

// Returns true if the provided position is inside a valid zone
function zclib.Zone.Inside(entryid,pos)
    zclib.Debug("zclib.Zone.Inside")
    return zclib.Zone.CheckAll(entryid,pos)
end

function zclib.Zone.GetHeight(entryid)
    local ZoneData = zclib.Zone.GetEntry(entryid)
    if ZoneData == nil then return 200 end
    return ZoneData.BaseHeight or 200
end

function zclib.Zone.GetExtraHeight(entryid)
    local ZoneData = zclib.Zone.GetEntry(entryid)
    if ZoneData == nil then return 200 end
    return ZoneData.ExtraHeight or 200
end

function zclib.Zone.GetSize(entryid,z_start,z_end)
	if zclib.Zone.GetFreeSize(entryid) then
		return z_end - z_start
	end

    local zoneSize = z_end - z_start

    zoneSize = Vector(zoneSize.x, zoneSize.y, zclib.Zone.GetHeight(entryid) * 2)

    return zoneSize
end

function zclib.Zone.GetThickness(entryid,pos,size)
	local entry = zclib.Zone.GetEntry(entryid)
	if entry and entry.Thickness then

		local thick = entry.Thickness

		local sPos = pos
        local ePos = sPos + size
        local thX_p,thY_p,thZ_p = 0,0,0
		local thX_s,thY_s,thZ_s = 0,0,0

		thX_p = sPos.x > ePos.x and thick or -thick
		thX_s = sPos.x > ePos.x and -thick * 2 or thick * 2

		thY_p = sPos.y > ePos.y and thick or -thick
		thY_s = sPos.y > ePos.y and -thick * 2 or thick * 2

        thZ_p = sPos.z > ePos.z and thick or -thick
		thZ_s = sPos.z > ePos.z and -thick * 2 or thick * 2

		return Vector(thX_p,thY_p,thZ_p) , Vector(thX_s,thY_s,thZ_s)
	end
end

--PATH addons/zeros_lua_libary/lua/zclib/inventory/sh_item.lua:
zclib = zclib or {}
zclib.ItemDefinition = zclib.ItemDefinition or {}
zclib.ItemDefinition.List = zclib.ItemDefinition.List or {}

/*
zclib.ItemDefinition.Register({
    class = "ent_class",

    // Overwrites the Items name
    Name = function(ItemData) return "name" end,
    or Name = "name",

    // Specifies the money value of the item
    Price = function(ItemData)
        local ItemID = isentity(ItemData) and ItemData:GetItemID() or ItemData.Data.ItemID
        local ItemAmount = isentity(ItemData) and ItemData:GetItemAmount() or ItemData.Amount
        return zmb.Item.GetPrice(ItemID) * ItemAmount
    end,

    // Gets called when the entity being picked up
    GetData = function(ent)
        return {ItemID = ent:GetItemID()}
    end,

    // Gets called when the entity being spawned in the world
    SetData = function(ItemData, ent)
        ent:SetItemID(ItemData.Data.ItemID)
        ent:SetItemAmount(ItemData.Amount)
    end,

    // Returns the value which makes the item identify between other items of the same class
    GetUniqueID = function(ItemData)
        return ItemData.Data.ItemID
    end,

    // Gets used to figure out the Amount var
    GetAmount = function(ItemData)
        return isentity(ItemData) and ItemData:GetItemAmount() or ItemData.Amount
    end,

    // Returns how many of those item classes which have the same GetUniqueID can be stacked
    GetStackLimit = function(ItemData)
        return 50
    end,

    // If defined overwrites the model
    Image = "materials/image.png",

    // Overwrites the Items model data
    Model = "model path",
    Skin = 0,
    BodyG = {},
    Color = Color(),
    Material = "",

    // This can be used to give the Item a custom background and color
    BG_Image = zclib.Materials.Get("star01"),
    BG_Color = color_red,

    // Gets called when the item being picked up
    OnPickup = function(ent,ply)

    end,

    // This will add the Drop/throw option in the optionbox
    OnDrop = function()
    end,

    // This will add the destroy option in the optionbox
    OnDestroy = function()
    end,

    // This will add the use option in the optionbox
    // NOTE This gets called on CLIENT first and returning will prevent it being called on SERVER afterwards
    OnUse = function(ply)

    end,
})
*/

// Registers a item definition
function zclib.ItemDefinition.Register(data)
    // Precache the model so util.IsValidModel works correctly for clients
    if data.Model and not isfunction(data.Model) then util.PrecacheModel(data.Model) end

    zclib.ItemDefinition.List[data.Class] = data
    //table.insert(zclib.ItemDefinition.List,data)
end

// Returns the Item definition by ID
function zclib.ItemDefinition.Get(class)
    return zclib.ItemDefinition.List[class]
end

// Only allow entity classes which have a
function zclib.ItemDefinition.IsAllowed(class)
    return zclib.ItemDefinition.List[class] ~= nil
end



function zclib.ItemDefinition.GetModel(Class,SlotData)
    local dat = zclib.ItemDefinition.Get(Class)
    if dat == nil then return SlotData.Model or "error.mdl" end

	if dat.Model and isfunction(dat.Model) then return dat.Model(Class,SlotData) or "error.mdl" end

    return dat.Model or SlotData.Model or "error.mdl"
end

function zclib.ItemDefinition.GetSkin(Class,SlotData)
    local dat = zclib.ItemDefinition.Get(Class)
    if dat == nil then return SlotData.Skin or 0 end

	if dat.Skin and isfunction(dat.Skin) then return dat.Skin(Class,SlotData) or 0 end

    return dat.Skin or SlotData.Skin or 0
end

function zclib.ItemDefinition.GetBodyGroups(Class,SlotData)
    local dat = zclib.ItemDefinition.Get(Class)

    if dat == nil then return SlotData.BodyG or {} end

	if dat.BodyG and isfunction(dat.BodyG) then return dat.BodyG(Class,SlotData) or {} end

    return dat.BodyG or SlotData.BodyG or {}
end

function zclib.ItemDefinition.GetColor(Class,SlotData)
    local dat = zclib.ItemDefinition.Get(Class)

    if dat == nil then return SlotData.Color or color_white end

	if dat.Color and isfunction(dat.Color) then return dat.Color(Class,SlotData) or color_white end

    return dat.Color or SlotData.Color or color_white
end

function zclib.ItemDefinition.GetMaterial(Class,SlotData)
    local dat = zclib.ItemDefinition.Get(Class)

    if dat == nil then return SlotData.Material or "" end

	if dat.Material and isfunction(dat.Material) then return dat.Material(Class,SlotData) or "" end

    return dat.Material or SlotData.Material or ""
end



function zclib.ItemDefinition.GetName(Class,SlotData)
    if zclib.config.PredefinedNames[Class] then return zclib.config.PredefinedNames[Class] end

    if SlotData and SlotData.Name then
        return SlotData.Name
    end

    // Is there a Item definition for that class and does it want to overwrite the name
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.Name then
        // The name can be defined as a function or as a string
        return isfunction(DefinitionData.Name) and DefinitionData.Name(SlotData) or DefinitionData.Name
    end

    return Class
end

function zclib.ItemDefinition.GetAmount(Class,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.GetAmount then return DefinitionData.GetAmount(SlotData) end
    return 1
end

function zclib.ItemDefinition.GetData(Class,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.GetData then return DefinitionData.GetData(SlotData) end
    return {}
end

function zclib.ItemDefinition.SetData(ent,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(ent:GetClass())
    if DefinitionData and DefinitionData.SetData then return DefinitionData.SetData(SlotData,ent) end
    return {}
end

function zclib.ItemDefinition.GetStackLimit(Class,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.GetStackLimit then return DefinitionData.GetStackLimit(SlotData) end
end

function zclib.ItemDefinition.GetUniqueID(Class,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.GetUniqueID then
        return DefinitionData.GetUniqueID(SlotData)
    end
end

// Compares two items and returns true if they are the same
function zclib.ItemDefinition.Compare(ItemData01, ItemData02)
    if ItemData01.Class ~= ItemData02.Class then return false end
    if zclib.ItemDefinition.GetUniqueID(ItemData01.Class, ItemData01) ~= zclib.ItemDefinition.GetUniqueID(ItemData02.Class, ItemData02) then return false end
    return true
end

function zclib.ItemDefinition.GetPrice(class,SlotData)

    // Is there a Item definition for that class and does it want to overwrite the name
    local DefinitionData = zclib.ItemDefinition.Get(class)
    if DefinitionData and DefinitionData.Price then
        // The name can be defined as a function or as a string
        return isfunction(DefinitionData.Price) and DefinitionData.Price(SlotData) or DefinitionData.Price
    end

    return SlotData.Price or 10
end

// Specifies if the Item has a body and can be dropped in the world if its just some lua funciton in Item form
function zclib.ItemDefinition.IsObject(Class)
    local DefinitionData = zclib.ItemDefinition.Get(Class)

    // A weapon is just a diffrent type of object
    if zclib.ItemDefinition.IsWeapon(Class) then return true end

    // We dont have this item registrated so it only can be a entity since powers need to be predefined
    if DefinitionData == nil then return true end

    return DefinitionData.IsObject == true
end

// Specifies that the entity class is of type weapon
function zclib.ItemDefinition.IsWeapon(Class,SlotData)
    local DefinitionData = zclib.ItemDefinition.Get(Class)
    if DefinitionData and DefinitionData.IsWeapon ~= nil then return DefinitionData.IsWeapon end
    if SlotData then return SlotData.IsWeapon == true end
    return false
end

/*
	Returns the background image of the item slot
*/
function zclib.ItemDefinition.GetBG_Image(Class,SlotData)

    // Is there a Item definition for that class and does it want to overwrite the BG_Image
    local DefinitionData = zclib.ItemDefinition.Get(Class)
	if not DefinitionData then return end
	if not DefinitionData.BG_Image then return end

    // The BG_Image can be defined as a function or as a string
	if isfunction(DefinitionData.BG_Image) then
		return DefinitionData.BG_Image(SlotData)
	end

    return DefinitionData.BG_Image
end

/*
	Returns the background image color of the item slot
*/
function zclib.ItemDefinition.GetBG_Color(Class,SlotData)

    // Is there a Item definition for that class and does it want to overwrite the BG_Color
    local DefinitionData = zclib.ItemDefinition.Get(Class)
	if not DefinitionData then return end
	if not DefinitionData.BG_Color then return end

	// The BG_Color can be defined as a function or as a string
	if isfunction(DefinitionData.BG_Color) then
		return DefinitionData.BG_Color(SlotData)
	end

    return DefinitionData.BG_Color
end

--PATH addons/rp_advdupe2/lua/advdupe2/sh_codec.lua:
--[[
	Title: Adv. Dupe 2 Codec

	Desc: Dupe encoder/decoder.

	Author: emspike

	Version: 2.0
]]

local REVISION = 5

include "sh_codec_legacy.lua"
AddCSLuaFile "sh_codec_legacy.lua"

local pairs = pairs
local type = type
local error = error
local Vector = Vector
local Angle = Angle
local format = string.format
local char = string.char
local byte = string.byte
local sub = string.sub
local gsub = string.gsub
local find = string.find
local gmatch = string.gmatch
local match = string.match
local concat = table.concat
local compress = util.Compress
local decompress = util.Decompress

AdvDupe2.CodecRevision = REVISION


--[[
	Name:	GenerateDupeStamp
	Desc:	Generates an info table.
	Params:	<player> ply
	Return:	<table> stamp
]]
function AdvDupe2.GenerateDupeStamp(ply)
	local stamp = {}
	stamp.name = ply:GetName()
	stamp.time = os.date("%I:%M %p")
	stamp.date = os.date("%d %B %Y")
	stamp.timezone = os.date("%z")
	hook.Call("AdvDupe2_StampGenerated",GAMEMODE,stamp)
	return stamp
end

local function makeInfo(tbl)
	local info = ""
	for k,v in pairs(tbl) do
		info = concat{info,k,"\1",v,"\1"}
	end
	return info.."\2"
end

local AD2FF = "AD2F%s\n%s\n%s"

local tables
local buff

local function noserializer() end

local enc = {}
for i=1,255 do enc[i] = noserializer end

local function isArray(tbl)
	local ret = true
	local m = 0
	
	for k, v in pairs(tbl) do
		m = m + 1
		if k ~= m or enc[TypeID(v)]==noserializer then
			ret = false
			break
		end
	end

	return ret
end

local function write(obj)
	enc[TypeID(obj)](obj)
end

local len
local tables,tablesLookup

enc[TYPE_TABLE] = function(obj) --table
	if not tablesLookup[obj] then
		tables = tables + 1
		tablesLookup[obj] = tables
	else
		buff:WriteByte(247)
		buff:WriteShort(tablesLookup[obj])
		return
	end
	
	if isArray(obj) then
		buff:WriteByte(254)
		for i,v in pairs(obj) do
			write(v)
		end
	else
		buff:WriteByte(255)
		for k,v in pairs(obj) do
			if(enc[TypeID(k)]!=noserializer and enc[TypeID(v)]!=noserializer)then
				write(k)
				write(v)
			end
		end
	end
	buff:WriteByte(246)
end
enc[TYPE_BOOL] = function(obj) --boolean
	buff:WriteByte(obj and 253 or 252)
end
enc[TYPE_NUMBER] = function(obj) --number
	buff:WriteByte(251)
	buff:WriteDouble(obj)
end
enc[TYPE_VECTOR] = function(obj) --vector
	buff:WriteByte(250)
	buff:WriteDouble(obj.x)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.z)
end
enc[TYPE_ANGLE] = function(obj) --angle
	buff:WriteByte(249)
	buff:WriteDouble(obj.p)
	buff:WriteDouble(obj.y)
	buff:WriteDouble(obj.r)
end
enc[TYPE_STRING] = function(obj) --string
	
	len = #obj
	
	if len < 246 then
		buff:WriteByte(len)
		buff:Write(obj)
	else
		buff:WriteByte(248)
		buff:WriteULong(len)
		buff:Write(obj)
	end
	
end

local function error_nodeserializer()
	buff:Seek(buff:Tell()-1)
	error(format("couldn't find deserializer for type {typeid:%d}", buff:ReadByte()))
end

local read4, read5

local reference = 0
do --Version 4
	local dec = {}
	for i=1,255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("expected value, got EOF")
		end
		if tt == 0 then
			return nil
		end
		return dec[tt]()
	end
	read4 = read

	dec[255] = function() --table
		local t = {}
		local k
		reference = reference + 1
		local ref = reference
		repeat
			k = read()
			if k ~= nil then
				t[k] = read()
			end
		until (k == nil)
		tables[ref] = t
		return t
	end

	dec[254] = function() --array
		local t = {}
		local k,v = 0
		reference = reference + 1
		local ref = reference
		repeat
			k = k + 1
			v = read()
			if(v != nil) then
				t[k] = v
			end

		until (v == nil)
		tables[ref] = t
		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() --null-terminated string
		local start = buff:Tell()
		local slen = 0
		
		while buff:ReadByte() != 0 do
			slen = slen + 1
		end
		
		buff:Seek(start)
		
		local retv = buff:Read(slen)
		if(not retv)then retv="" end
		buff:ReadByte()

		return retv
	end
	dec[247] = function() --table reference
		reference = reference + 1
		return tables[buff:ReadShort()]
	end

	for i=1,246 do dec[i] = function() return buff:Read(i) end end
end

do --Version 5
	local dec = {}
	for i=1,255 do dec[i] = error_nodeserializer end

	local function read()
		local tt = buff:ReadByte()
		if not tt then
			error("expected value, got EOF")
		end
		return dec[tt]()
	end
	read5 = read

	dec[255] = function() --table
		local t = {}
		reference = reference + 1
		tables[reference] = t

		for k in read do
			t[k] = read()
		end

		return t
	end

	dec[254] = function() --array
		local t = {}
		reference = reference + 1
		tables[reference] = t

		local k = 1
		for v in read do
			t[k] = v
			k = k + 1
		end

		return t
	end

	dec[253] = function()
		return true
	end
	dec[252] = function()
		return false
	end
	dec[251] = function()
		return buff:ReadDouble()
	end
	dec[250] = function()
		return Vector(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[249] = function()
		return Angle(buff:ReadDouble(),buff:ReadDouble(),buff:ReadDouble())
	end
	dec[248] = function() -- Length>246 string
		local slen = buff:ReadULong()
		local retv = buff:Read(slen)
		if(not retv)then retv="" end
		return retv
	end
	dec[247] = function() --table reference
		return tables[buff:ReadShort()]
	end
	dec[246] = function() --nil
		return
	end

	for i=1,245 do dec[i] = function() return buff:Read(i) end end
	dec[0] = function() return "" end
end

local function serialize(tbl)
	tables = 0
	tablesLookup = {}

	buff = file.Open("ad2temp.txt", "wb", "DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for writing!") end
	write(tbl)
	buff:Close()

	buff = file.Open("ad2temp.txt","rb","DATA")
	if not buff then error("Failed to open file data/ad2temp.txt for reading!") end
	local ret = buff:Read(buff:Size())
	buff:Close()
	return ret
end


local function deserialize(str, read)
	
	if(str==nil)then
		error("File could not be decompressed.")
		return {}
	end
	
	tables = {}
	reference = 0
	buff = file.Open("ad2temp.txt","wb","DATA")
	buff:Write(str)
	buff:Flush()
	buff:Close()
	
	buff = file.Open("ad2temp.txt","rb", "DATA")
	local success, tbl = pcall(read)
	buff:Close()
	
	if success then
		return tbl
	else
		error(tbl)
	end
end

--[[
	Name:	Encode
	Desc:	Generates the string for a dupe file with the given data.
	Params:	<table> dupe, <table> info, <function> callback, <...> args
	Return:	runs callback(<string> encoded_dupe, <...> args)
]]
function AdvDupe2.Encode(dupe, info, callback, ...)
	
	local encodedTable = compress(serialize(dupe))
	info.check = "\r\n\t\n"
	info.size = #encodedTable
	
	callback(AD2FF:format(char(REVISION), makeInfo(info), encodedTable),...)
	
end

--seperates the header and body and converts the header to a table
local function getInfo(str)
	local last = str:find("\2")
	if not last then
		error("attempt to read AD2 file with malformed info block")
	end
	local info = {}
	local ss = str:sub(1,last-1)
	for k,v in ss:gmatch("(.-)\1(.-)\1") do
		info[k] = v
	end
	
	if info.check ~= "\r\n\t\n" then
		if info.check == "\10\9\10" then
			error("detected AD2 file corrupted in file transfer (newlines homogenized)(when using FTP, transfer AD2 files in image/binary mode, not ASCII/text mode)")
		else
			error("attempt to read AD2 file with malformed info block")
		end
	end
	return info, str:sub(last+2)
end

--decoders for individual versions go here
local versions = {}

versions[1] = AdvDupe2.LegacyDecoders[1]
versions[2] = AdvDupe2.LegacyDecoders[2]

versions[3] = function(encodedDupe)
	encodedDupe = encodedDupe:Replace("\r\r\n\t\r\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n\t\n", "\t\t\t\t")
	encodedDupe = encodedDupe:Replace("\r\n", "\n")
	encodedDupe = encodedDupe:Replace("\t\t\t\t", "\r\n\t\n")
	return versions[4](encodedDupe)
end

versions[4] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring), read4), info
end

versions[5] = function(encodedDupe)
	local info, dupestring = getInfo(encodedDupe:sub(7))
	return deserialize(decompress(dupestring), read5), info
end


function AdvDupe2.CheckValidDupe(dupe, info)
	if not dupe.HeadEnt then return false, "Missing HeadEnt table" end
	if not dupe.HeadEnt.Index then return false, "Missing HeadEnt.Index" end
	if not dupe.HeadEnt.Z then return false, "Missing HeadEnt.Z" end
	if not dupe.HeadEnt.Pos then return false, "Missing HeadEnt.Pos" end
	if not dupe.Entities then return false, "Missing Entities table" end
	if not dupe.Entities[dupe.HeadEnt.Index] then return false, "Missing HeadEnt index from Entities table" end
	if not dupe.Entities[dupe.HeadEnt.Index].PhysicsObjects then return false, "Missing PhysicsObject table from HeadEnt Entity table" end
	if not dupe.Entities[dupe.HeadEnt.Index].PhysicsObjects[0] then return false, "Missing PhysicsObject[0] table from HeadEnt Entity table" end
	if info.ad1 then
		if not dupe.Entities[dupe.HeadEnt.Index].PhysicsObjects[0].LocalPos then return false, "Missing PhysicsObject[0].LocalPos from HeadEnt Entity table" end
		if not dupe.Entities[dupe.HeadEnt.Index].PhysicsObjects[0].LocalAngle then return false, "Missing PhysicsObject[0].LocalAngle from HeadEnt Entity table" end
	else
		if not dupe.Entities[dupe.HeadEnt.Index].PhysicsObjects[0].Pos then return false, "Missing PhysicsObject[0].Pos from HeadEnt Entity table" end
		if not dupe.Entities[dupe.HeadEnt.Index].PhysicsObjects[0].Angle then return false, "Missing PhysicsObject[0].Angle from HeadEnt Entity table" end
	end
	return true, dupe
end

--[[
	Name:	Decode
	Desc:	Generates the table for a dupe from the given string. Inverse of Encode
	Params:	<string> encodedDupe, <function> callback, <...> args
	Return:	runs callback(<boolean> success, <table/string> tbl, <table> info)
]]
function AdvDupe2.Decode(encodedDupe)
	
	local sig, rev = encodedDupe:match("^(....)(.)")
	
	if not rev then
		return false, "malformed dupe (wtf <5 chars long?!)"
	end
	
	rev = rev:byte()
	
	if sig ~= "AD2F" then
		if sig == "[Inf" then --legacy support, ENGAGE (AD1 dupe detected)
			local success, tbl, info, moreinfo = pcall(AdvDupe2.LegacyDecoders[0], encodedDupe)

			if success then
				info.size = #encodedDupe
				info.revision = 0
				info.ad1 = true

				local index = tonumber(moreinfo.Head) or (istable(tbl.Entities) and next(tbl.Entities))
				if not index then return false, "Missing head index" end
				local pos
				if isstring(moreinfo.StartPos) then
					local spx,spy,spz = moreinfo.StartPos:match("^(.-),(.-),(.+)$")
					pos = Vector(tonumber(spx) or 0, tonumber(spy) or 0, tonumber(spz) or 0)
				else
					pos = Vector()
				end
				local z
				if isstring(moreinfo.HoldPos) then
					z = (tonumber(moreinfo.HoldPos:match("^.-,.-,(.+)$")) or 0)*-1
				else
					z = 0
				end
				tbl.HeadEnt = {
					Index = index,
					Pos = pos,
					Z = z
				}

			else
				ErrorNoHalt(tbl)
			end

			if success then
				success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
			end

			return success, tbl, info, moreinfo
		else
			return false, "unknown duplication format"
		end
	elseif rev > REVISION then
		return false, format("Newer codec needed. (have rev %u, need rev %u) Update Advdupe2.",REVISION,rev)
	elseif rev < 1 then
		return false, format("attempt to use an invalid format revision (rev %d)", rev)
	else
		local success, tbl, info = pcall(versions[rev], encodedDupe)

		if success then
			success, tbl = AdvDupe2.CheckValidDupe(tbl, info)
		end
		
		if success then
			info.revision = rev
		else
			ErrorNoHalt(tbl)
		end

		return success, tbl, info
	end
end

--PATH addons/scoreboard/lua/autorun/client/avatar.lua:
local function MakeCirclePoly( _x, _y, _r, _points )
 
    local _u = ( _x + _r * 320 ) - _x;
 
    local _v = ( _y + _r * 320 ) - _y;
 
 
 
    local _slices = ( 2 * math.pi ) / _points;
 
    local _poly = { };
 
    for i = 0, _points - 1 do
 
        local _angle = ( _slices * i ) % _points;
 
        local x = _x + _r * math.cos( _angle );
 
        local y = _y + _r * math.sin( _angle );
 
        table.insert( _poly, { x = x, y = y, u = _u, v = _v } )
 
    end
 
 
 
    return _poly;
 
end

local PANEL = {}
 
 
 
function PANEL:Init()
 
    self.Avatar = vgui.Create("AvatarImage", self)
 
    self.Avatar:SetPaintedManually(true)
 
    self.material = Material( "effects/flashlight001" )
 
    self:OnSizeChanged(self:GetWide(), self:GetTall())
 
end
 
 
 
function PANEL:PerformLayout()
 
    self:OnSizeChanged(self:GetWide(), self:GetTall())
 
end
 
 
 
function PANEL:SetSteamID(...)
 
    self.Avatar:SetSteamID(...)
 
end
 
 
 
function PANEL:SetPlayer(...)
 
    self.Avatar:SetPlayer(...)
 
end
 
 
 
function PANEL:OnSizeChanged(w, h)
 
    self.Avatar:SetSize(self:GetWide(), self:GetTall())
 
    self.points = math.Max((self:GetWide()/4), 32)
 
    self.poly = MakeCirclePoly(self:GetWide()/2, self:GetTall()/2, self:GetWide()/2, self.points)
 
end
 
 
 
function PANEL:DrawMask(w, h)
 
    draw.NoTexture();
 
    surface.SetMaterial( self.material )
 
    surface.SetDrawColor( color_white )
 
    surface.DrawPoly( self.poly )
 
end
 
 
 
function PANEL:Paint(w, h)
 
    render.ClearStencil()
 
    render.SetStencilEnable(true)
 
 
 
    render.SetStencilWriteMask( 1 )
 
    render.SetStencilTestMask( 1 )
 
 
 
    render.SetStencilFailOperation( STENCILOPERATION_REPLACE )
 
    render.SetStencilPassOperation( STENCILOPERATION_ZERO )
 
    render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
 
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_NEVER )
 
    render.SetStencilReferenceValue( 1 )
 
 
 
    self:DrawMask(w, h)
 
 
 
    render.SetStencilFailOperation( STENCILOPERATION_ZERO )
 
    render.SetStencilPassOperation( STENCILOPERATION_REPLACE )
 
    render.SetStencilZFailOperation( STENCILOPERATION_ZERO )
 
    render.SetStencilCompareFunction( STENCILCOMPARISONFUNCTION_EQUAL )
 
    render.SetStencilReferenceValue( 1 )
 
 
 
    self.Avatar:SetPaintedManually(false)
 
    self.Avatar:PaintManual()
 
    self.Avatar:SetPaintedManually(true)
 
 
 
    render.SetStencilEnable(false)
 
    render.ClearStencil()
 
end

vgui.Register("AvatarMask", PANEL)



kydeslib = {}

for i = 1, 150 do

    surface.CreateFont( 'kydeslib_font_' .. i, {
        font = 'Arial',
        size = i,
        weight = 550
    } )

end

local blur = Material( "pp/blurscreen" )
function kydeslib.BlurMenu( panel, layers, density, alpha )
    -- Its a scientifically proven fact that blur improves a script
    local x, y = panel:LocalToScreen( 0, 0 )

    surface.SetDrawColor( 255, 255, 255, alpha )
    surface.SetMaterial( blur )

    for i = 1, 3 do
        blur:SetFloat( "$blur", ( i / layers ) * density )
        blur:Recompute()

        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect( -x, -y, ScrW(), ScrH() )
    end
end



function kydeslib.DrawRect( x, y, w, h, col )
    surface.SetDrawColor( col )
    surface.DrawRect( x, y, w, h )
end

function kydeslib.box( x, y, w, h, clr, out )

    surface.SetDrawColor( clr )
    surface.DrawRect( x, y, w, h )

end

function kydeslib.txt( str, size, x, y, clr, a1, a2 )

    if not a1 then a1 = 0 end
    if not a2 then a2 = 0 end

    draw.SimpleText( str, 'kydeslib_font_' .. size, x, y, clr, a1, a2 )

end

function kydeslib.scroll(parent, x, y, w, h, down, ph, items)
    local scroll = parent:Add 'DScrollPanel'
    scroll:SetSize(w, h)
    scroll:SetPos(x, y)
    scroll:GetVBar():SetWide(0)

    if items then items(scroll) end

    return scroll
end

function kydeslib.button(name, parent, x, y, w, h, doclick, btnclr, removeonclick)
    local btn = parent:Add 'KButton'
    btn:SetSize(w, h)
    btn:SetPos(x, y)

    btn.text = name

    if btnclr then
        btn.btncolor = btnclr
    end

    btn.DoClick = function()
        doclick(btn)

        if removeonclick then
            parent:Remove()
        end
    end

    return btn
end 


local pMeta = FindMetaTable("Player")

function pMeta:GetLevel()
    if self:getDarkRPVar("level") then
        self:getDarkRPVar("level")
    end
end

local adminIsModerator = {
	["superadmin"]    = true,
    ["NS-trainee"] = true,
    ["NS-mlmoder"] = true,
    ["NS-moder"] = true,
    ["NS-mladmin"] = true,
    ["NS-admin"] = true,
    ["NS-assistant"] = true,
    ["NS-helper"] = true,
    ["moder"] = true,
    ["padmin"] = true,
    ["sponsor"] = true,
    ["dsuperadmin"] = true,
    ["downer"] = true,
    ["overwatch"] = true,
    ["NS-zammanager"] = true,
    ["manager"] = true,
    ["uprav"] = true,
    ["helper"] = true
}

function pMeta:IsModerator() 
	if adminIsModerator[self:GetUserGroup()] then
		return true
	else
		return false
	end
end

function ShadowText(text,font,x,y,color)
    draw.SimpleText(text,font,x,y,color_black,TLEFT)
    draw.SimpleText(text,font,x+1,y+1,color,TLEFT)
end

color_white = Color(255,255,255)
color_black = Color(0,0,0)
color_green = Color(0,255,0)
color_red   = Color(255,0,0)
color_blue  = Color(0,0,255)
color_main  = Color(0,0,0,100)
TLEFT = TEXT_ALIGN_LEFT
TRIGHT = TEXT_ALIGN_RIGHT
TCENTER = TEXT_ALIGN_CENTER

local blur = Material( "pp/blurscreen" )
function BlurMenu( panel, layers, density, alpha )
    -- Its a scientifically proven fact that blur improves a script
    local x, y = panel:LocalToScreen( 0, 0 )

    surface.SetDrawColor( 255, 255, 255, alpha )
    surface.SetMaterial( blur )

    for i = 1, 3 do
        blur:SetFloat( "$blur", ( i / layers ) * density )
        blur:Recompute()

        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect( -x, -y, ScrW(), ScrH() )
    end
end

function shadowtext(text,font,x,y,color)
    draw.SimpleText(text,font,x,y,color_black,TCENTER)
    draw.SimpleText(text,font,x+1,y+1,color,TCENTER)
end

function DrawBox(x,y,w,h,color)
    surface.SetDrawColor(color)
    surface.DrawRect(x,y,w,h)
end

function but(parent, x, y, w, h, text, func)
    local b = vgui.Create("DButton", parent)
    b:SetSize(w,h)
    b:SetPos(x,y)
    b:SetText(text)
    b:SetTextColor(Color(255,255,255))
    b:SetFont("font22")
    b.Paint = function(s,w,h)
        if s:IsHovered() then
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,200))
        else
            draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100))
        end
        surface.SetDrawColor(Color(100,100,100))
        surface.DrawOutlinedRect(0,0,w,h)
    end
    b.DoClick = function()
        func()
        surface.PlaySound( "buttons/button15.wav" )
    end
end

function shadowbutton(parent,x,y,w,h,text,func)
    but(parent,x,y,w,h,text,func)
    but(parent,x,y,w,h,text,func)
end

function DrawOutline(x,y,w,h,color)
surface.SetDrawColor(color)
surface.DrawOutlinedRect(x,y,w,h)
end

function chatText(color,text,color2,text2,color3,text3,color4,text4)
    chat.AddText(Color(0,180,255),"[СЕРВЕР]",Color(220, 20, 60), " > ",color,text,color2,text2,color3,text3,color4,text4)
end

local pMeta = FindMetaTable("Player")

function pMeta:JobName()
    local teamname = team.GetName(self:Team())
    return teamname
end

function pMeta:JobColor()
    local teamcolor = team.GetColor(self:Team())
    return teamcolor
end

  

local alpha = 175
rainbow_colors = {
    Color( 148, 0, 190, alpha ),
    Color( 75, 0, 130, alpha ),
    Color( 0, 0, 170, alpha ),
    Color( 0, 170, 0, alpha ),
    Color( 200, 200, 0, alpha ),
    Color( 220, 127, 0, alpha ),
    Color( 190, 0, 0, alpha )
}

--PATH addons/brick_s_server_framework/lua/bricks_server/languages/bricks_server/ukrainian.lua:
BRICKS_SERVER.Func.AddLanguageStrings( "ukrainian", {
    ["search"] = "Знайти",
    ["invalidPlayerProfile"] = "Запрошен неверний профиль игрока!",
    ["unbound"] = "НЕ ЗВЯЗАН",
    ["themes"] = "Теми",
    ["groups"] = "Группи",
    ["general"] = "Основне",
    ["itemWhitelisting"] = "Белий список предметов",
    ["rarities"] = "Раритети",
    ["languages"] = "Мови",
    ["disabled"] = "Вiдключено",
    ["enabled"] = "Вмикнуто",
    ["purchase"] = "Купити",
    ["profile"] = "Профиль",
    ["view"] = "Переглянуты",
    ["admin"] = "AДМIН",
    ["noToolPermission"] = "Нема прав.",
    ["settings"] = "Налаштуваня",
    ["players"] = "Iгроки",
    ["modules"] = "Модулi",

    ["userGroupEditor"] = "Редактор групп iгроков",
    ["addNewGroup"] = "Добавить новую группу",
    ["newUserGroup"] = "Какой должна бить новая группа iгроков?",
    ["groupName"] = "Название",

    ["custom"] = "Свое",
    ["addNew"] = "Добавить новую",
    ["material"] = "Материал",
    ["directImage"] = "Введите URL прямого iзображения ниже.",
    ["default"] = "Стандарт",
    ["selectMaterial"] = "Ви должни вибрать материал!",

    ["errorNoText"] = "ПОМИЛКА: НЕМА ТЕКСТА",
    ["selectOption"] = "Виберите опцiю",
    ["selectValue"] = "Виберите значенiе.",
    ["selectColor"] = "Виберите цвет.",
    ["configSaved"] = "Конфиг сохраненено!",
    ["cmdNoPermission"] = "Нема прав.",
    ["entityPosUpdated"] = "Позицiя entity сохранена.",
    ["noEntitiesSpawned"] = "Нет сохраненних entities.",
    ["xEntitiesSpawned"] = "%d сохранил entities где бил заспавнен.",
    ["error"] = "ERROR",

    ["seconds"] = "%d секунд",
    ["second"] = "%d секунда",
    ["minutes"] = "%d хвилин",
    ["minute"] = "%d хвилини",
    ["hours"] = "%d години",
    ["hour"] = "%d година",

    ["noRarity"] = "Нема редкости",

    ["config"] = "Налаштуваня [Конфиг]",
    ["edit"] = "iзменить",
    ["editColor"] = "iзменить цвет",
    ["editName"] = "iзменить название",
    ["remove"] = "Видалити",
    ["name"] = "Название",
    ["description"] = "Описание",
    ["model"] = "Модель",
    ["icon"] = "Значек",
    ["type"] = "Тiп",
    ["price"] = "Стоимость",
    ["group"] = "Группа",
    ["category"] = "Категорiя",
    ["color"] = "Цвет",
    ["invalidType"] = "Неверний тип.",
    ["invalidOption"] = "Неверна опция.",
    ["invalidChoice"] = "Неверний вибор.",
    ["invalidGroup"] = "Неверная группа.",
    ["invalidPlayer"] = "Неверний игрок.",
    ["true"] = "ВКЛ",
    ["false"] = "ВиКЛ",
    ["noDescription"] = "Нет описания",
    ["other"] = "Остальное",
    ["completed"] = "Виполнено",
    ["close"] = "Закрити",
    ["main"] = "Меню",
    
    ["valueQuery"] = "Що следует %s?",
    ["dataValueQuery"] = "Какие данние должни это?",
    ["newNameQuery"] = "Що следует новому имени?",
    ["newDescriptionQuery"] = "Що следует новому описанию?",
    ["newModelQuery"] = "Що следует новой моделе?",
    ["newIconQuery"] = "Що следует новой иконке?",
    ["newColorQuery"] = "Що следует новому цвету?",
    ["npcTypeQuery"] = "Какой тип этого NPC?",
    ["newTypeQuery"] = "Що следует типу",
    ["groupRequirementQuery"] = "Що следует требованиям группи?",
    ["levelRequirementQuery"] = "Що следует уровню группи?",
    ["newPriceQuery"] = "Що следует новой стоимости?",
    ["newCategoryQuery"] = "Що следует новой категории?",

    ["npcEditor"] = "Настройка NPC [Editor]",
    ["addNPC"] = "Добавить NPC",
    ["newNPC"] = "Новий NPC",

    ["ok"] = "OK",
    ["cancel"] = "Отмена",
    ["save"] = "Сохранить",
    ["confirm"] = "Подтвердить",
    ["nil"] = "NIL",
    ["none"] = "Ничего",
    ["selected"] = "Вибрано",
    ["unselected"] = "Не вибрано",
    ["add"] = "Добавить",

    ["shootyStick"] = "Стрелка!",
    ["permanent"] = "Вечная",
    ["tierX"] = "(Уровень %d)",
    ["someDescription"] = "Некоторое описание.",
    ["invalidNPC"] = "BRICKS SERVER ERROR: Неверний NPC",

    ["disconnected"] = "Отключился",
    ["profileView"] = "Просмотр профиля",
    ["loading"] = "Загрузка",
    ["statistics"] = "Статистика",
    ["steamID64"] = "SteamID64",
    ["donationRank"] = "Рейтинг пожертвований",
    ["staffRank"] = "Рейтинг персонала",
    ["currentJob"] = "Текущее место работи",
    ["wallet"] = "Бумажник",
    ["level"] = "Уровень",
    ["levelX"] = "Уровень %d",
    ["experience"] = "ОПиТ",
    ["exp"] = "EXP",
    ["money"] = "Деньги",
    ["playerLogs"] = "Логи игрока",
    ["deleteLogs"] = "Видалити логи",
    ["xLogs"] = "%d логи",
    ["xAdminGroups"] = "%d Админ группи",
    ["noUserGroups"] = "Нет групп iгроков",
    ["userGroups"] = "Группи iгроков: %s",
    ["editUserGroups"] = "iзменить группи iгроков",
    ["newGroupColor"] = "Що следует новому цвету группу?",
    ["newGroupName"] = "Какое название новой группи?",
    ["groupAlreadyExists"] = "Эта группа уже существует!",
    ["whitelist"] = "Белий список",
    ["unWhitelist"] = "Искл. iз белого списка",
    ["addCustom"] = "Добавить свое",
    ["entClassWhitelist"] = "Какой класс сущностей ви би хотели добавить в белий список?",
    ["entClassAlreadyOnList"] = "Этот класс сущностей уже есть в списке!",
    ["changesServerRestart"] = "Некоторие iзменения не вступят в силу, пока сервер не будет перезагружен!",
    ["comingSoon"] = "Скоро!",
    ["features"] = "ФУНКЦИИ",
    ["addNewRarity"] = "Добавить новий раритет",
    ["newRarity"] = "Новий раритет",
    ["needToAddRarity"] = "Ви должни сначала добавить тип редкости!",
    ["whatRarityItem"] = "Какой редкости стоит этот предмет?",
    ["invalidRarity"] = "Неверная редкость.",
    ["rarityAlreadyExists"] = "Редкость с таким названием уже существует!",
    ["themeColorX"] = "Тема - Цвет %d",
    ["themeTextColor"] = "Тема - Цвет текста",
    ["presetAccents"] = "Предустановленние акценти",
    ["presetBackgrounds"] = "Предустановленние фони",
    ["resetToBaseThemes"] = "Сбросить тему к стандарту",
    ["resetToCurrentThemes"] = "Сброс к текущим темам",
    ["toggle"] = "Включить",
    ["menu"] = "Меню",
    ["emptyValue"] = "Пустое значение",
    ["newValueQuery"] = "Що следует пустому значению?",
    ["pressKey"] = "НАЖМИТЕ НА A",

    ["entityPlacer"] = "Спавн нового Entity",
    ["invalidEntityType"] = "Неверний тип объекта, виберите правильний iз меню инструментов.",
    ["entityPlaced"] = "Объект успешно размещен.",
    ["entityRemoved"] = "Сущность успешно удалена.",
    ["canOnlyUseToolEntity"] = "Ви можете Iспользовати этот инструмент только для удаления или создания объекта.",
    ["entityType"] = "Entity Тип",
    ["entityPlacerDescription"] = "Размещает и удаляет объекти с сервера Bricks и сохраняет их позиции. Левий щелчок - место. Правий клик - Видалити.",
    ["entityPlacerDescriptionSmall"] = "Размещает и удаляет объекти",
    ["entityPlacerInstructions"] = "Левий клик - разместить, правий клик - Видалити.",

    ["npcPlacer"] = "Установка NPC",
    ["npcPlaced"] = "NPC успешно размещен.",
    ["invalidNPCType"] = "Неверний тип NPC, виберите правильний iз меню инструментов.",
    ["npcRemoved"] = "NPC успешно удален.",
    ["errorNotNPC"] = "Ви можете Iспользовати этот инструмент только для удаления или создания NPC.",
    ["npcPlacerDescription"] = "Размещает и удаляет NPC с сервера Bricks. Щелкните левой кнопкой миши - поместите, щелкните правой кнопкой миши - удалите.",
    ["npcPlacerDescriptionSmall"] = "Размещает и удаляет NPC с сервера Brick.",

    ["inventory"] = "Iнвентар",
    ["player"] = "Iгрок",
    ["drop"] = "Вибросити",
    ["use"] = "Iспользовати",
    ["dropAll"] = "Вибросити все",
    ["delete"] = "Видалити",
} )
--PATH addons/brick_s_server_framework/lua/bricks_server/core/shared/sh_itemtypes.lua:
BRICKS_SERVER.DEVCONFIG.INVENTORY = BRICKS_SERVER.DEVCONFIG.INVENTORY or {}
BRICKS_SERVER.DEVCONFIG.INVENTORY.EntTypes = BRICKS_SERVER.DEVCONFIG.INVENTORY.EntTypes or {}

local itemMeta = {
	Register = function( self )
        BRICKS_SERVER.DEVCONFIG.INVENTORY.EntTypes[self.Class] = self
	end
}

itemMeta.__index = itemMeta

function BRICKS_SERVER.Func.CreateItemType( class )
	local item = {
		Class = class
	}
	
	setmetatable( item, itemMeta )
	
	return item
end

for k, v in pairs( file.Find( "bricks_server/itemtypes/*.lua", "LUA" ) ) do
    AddCSLuaFile( "bricks_server/itemtypes/" .. v )
    include( "bricks_server/itemtypes/" .. v )
end
--PATH addons/brick_s_server_framework/lua/bricks_server/itemtypes/spawned_weapon.lua:
local ITEM = BRICKS_SERVER.Func.CreateItemType( "spawned_weapon" )

ITEM.GetItemData = function( ent )
    local itemData = { "spawned_weapon", ent:GetModel(), (ent.GetWeaponClass and ent:GetWeaponClass()) or "nil" }
    
    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "swepupgrader" ) ) then
        itemData[4] = ent:GetNW2Int( "BRS_Upgrades", 0 )
    end

    if( ent:GetNW2Bool( "BRS_IsPermanent" ) ) then
        itemData[5] = true
    end

    return itemData, (ent.Getamount and ent:Getamount()) or 1
end

ITEM.CanDropMultiple = true

ITEM.OnSpawn = function( ply, pos, itemData, itemAmount )
    local ent = ents.Create( "spawned_weapon" )
    if( not IsValid( ent ) ) then return end
    ent:SetPos( pos )
    ent:SetWeaponClass( itemData[3] )
    ent:Setamount( itemAmount or 1 )
    ent:SetModel( itemData[2] or "" )
    ent:Spawn()
    
    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "swepupgrader" ) and isnumber( itemData[4] or 0 ) and (itemData[4] or 0) > 0 ) then
        ent:SetNW2Int( "BRS_Upgrades", (itemData[4] or 0) )
        function ent:StartTouch( touchEnt ) 
            BRICKS_SERVER.Func.MergeWeapons( self, touchEnt )
        end
    end

    if( itemData[5] ) then
        ent:SetNW2Bool( "BRS_IsPermanent", true )
    end
end

ITEM.OnUse = function( ply, itemData )
    if( not itemData[3] ) then return false end

    ply:Give( itemData[3], true )

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "swepupgrader" ) and isnumber( itemData[4] or 0 ) and (itemData[4] or 0) > 0 ) then
        timer.Simple( 0.2, function()
            local newWeaponEnt = ply:GetWeapon( itemData[3] )

            if( IsValid( newWeaponEnt ) ) then
                newWeaponEnt:BRS_SetWeaponTier( (itemData[4] or 0), ply )
            end
        end )
    end
end

ITEM.CanUse = function( ply, itemData )
    if( itemData[5] ) then return false end

    return true
end

ITEM.Equip = function( ply, itemData )
    ply:Give( itemData[3], true )
end

ITEM.CanEquip = function( ply, itemData )
    if( not itemData[5] ) then return false end
    
    for k, v in pairs( ply:BRS():GetInventory() ) do
        if( v[3] and v[2] and v[2][3] == itemData[3] ) then return false end
    end

    return true
end

ITEM.UnEquip = function( ply, itemData )
    ply:StripWeapon( itemData[3] )
end

ITEM.CanUnEquip = function( ply, itemData )
    if( not itemData[5] ) then return false end

    return true
end

ITEM.ModelDisplay = function( Panel, itemData )
    if( not Panel.Entity or not IsValid( Panel.Entity ) ) then return end

    local mn, mx = Panel.Entity:GetRenderBounds()
    local size = 0
    size = math.max( size, math.abs(mn.x) + math.abs(mx.x) )
    size = math.max( size, math.abs(mn.y) + math.abs(mx.y) )
    size = math.max( size, math.abs(mn.z) + math.abs(mx.z) )

    Panel:SetFOV( 50 )
    Panel:SetCamPos( Vector( size, size, size ) )
    Panel:SetLookAt( (mn + mx) * 0.5 )
end

ITEM.GetInfo = function( itemData )
    local itemName = "Unknown"
    if( (list.Get( "Weapon" ) or {})[(itemData[3] or "")] and (list.Get( "Weapon" ) or {})[(itemData[3] or "")].PrintName ) then
        itemName = (list.Get( "Weapon" ) or {})[(itemData[3] or "")].PrintName
    end

    local itemDescription = BRICKS_SERVER.Func.L( "shootyStick" )
    if( BRICKS_SERVER.ESSENTIALS and BRICKS_SERVER.ESSENTIALS.LUACFG.ItemDescriptions and BRICKS_SERVER.ESSENTIALS.LUACFG.ItemDescriptions[(itemData[3] or "")] ) then
        itemDescription = BRICKS_SERVER.ESSENTIALS.LUACFG.ItemDescriptions[(itemData[3] or "")]
    end

    if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "swepupgrader" ) and isnumber( itemData[4] or 0 ) and (itemData[4] or 0) > 0 ) then
        return { itemName .. " " .. BRICKS_SERVER.Func.L( "tierX", (itemData[4] or 0) ), itemDescription, (BRICKS_SERVER.CONFIG.INVENTORY.ItemRarities or {})[itemData[3] or ""], (itemData[5] and BRICKS_SERVER.Func.L( "permanent" )) }
    else
        return { itemName, itemDescription, (BRICKS_SERVER.CONFIG.INVENTORY.ItemRarities or {})[itemData[3] or ""], (itemData[5] and BRICKS_SERVER.Func.L( "permanent" )) }
    end
end

ITEM.GetItemKey = function( itemData )
    return itemData[3] or ""
end

ITEM.GetPotentialItems = function()
    local potentialItems = {}
    for k, v in pairs( BRICKS_SERVER.Func.GetList( "weapons" ) ) do
        local weaponModel = BRICKS_SERVER.Func.GetWeaponModel( k ) or ""
        if( GAMEMODE.Config.DisallowDrop[k] or weaponModel == "" ) then continue end

        potentialItems[k] = {
            Name = v,
            Model = weaponModel,
            ItemKey = k
        }
    end

    return potentialItems
end

ITEM.CanCombine = function( itemData1, itemData2 )
    if( itemData1[5] or itemData2[5] ) then return false end

    if( itemData1[1] == itemData2[1] and itemData1[3] and itemData2[3] and itemData1[3] == itemData2[3] ) then
        if( BRICKS_SERVER.Func.IsSubModuleEnabled( "essentials", "swepupgrader" ) ) then
            if( (itemData1[4] or 0) == (itemData2[4] or 0) ) then
                return true
            end
        else
            return true
        end
    end

    return false
end

ITEM:Register()
--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_config_themes.lua:
local PANEL = {}

function PANEL:Init()

end

function PANEL:FillPanel()
    function self.RefreshPanel()
        self:Clear()

        for k, v in pairs( BRICKS_SERVER.BASECONFIG.THEME ) do
            local themeBack = vgui.Create( "DPanel", self )
            themeBack:Dock( TOP )
            themeBack:DockMargin( 0, 0, 0, 5 )
            themeBack:SetTall( 100 )
            local displayColor = BRICKS_SERVER.Func.GetTheme( k ) or Color( 155, 155, 155 )
            themeBack.Paint = function( self2, w, h )
                draw.RoundedBox( 5, 0, 0, w, h, Color( 0, 0, 0 ) )
                draw.RoundedBox( 5, 2, 2, w-4, h-4, displayColor )

                if( k != 6 ) then
                    draw.SimpleText( BRICKS_SERVER.Func.L( "themeColorX", k ), "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
                else
                    local textCol = BRICKS_SERVER.Func.GetTheme( 6 )
                    draw.SimpleText( BRICKS_SERVER.Func.L( "themeTextColor" ), "BRICKS_SERVER_Font33", 15, 5, Color( math.abs( textCol.r-255 ), math.abs( textCol.g-255 ), math.abs( textCol.b-255 ) ), 0, 0 )
                end
            end

            local themeMixer = vgui.Create( "DColorMixer", themeBack )
            themeMixer:Dock( RIGHT )
            themeMixer:DockMargin( 5, 5, 5, 5 )
            themeMixer:SetWide( 250 )
            themeMixer:SetPalette( false )
            themeMixer:SetAlphaBar( false) 
            themeMixer:SetWangs( true )
            themeMixer:SetColor( BRICKS_SERVER.Func.GetTheme( k ) )
            themeMixer.ValueChanged = function()
                displayColor = themeMixer:GetColor() or Color( 155, 155, 155 )
                BS_ConfigCopyTable.THEME[k] = themeMixer:GetColor() or Color( 155, 155, 155 )
                BRICKS_SERVER.Func.ConfigChange( "THEME" )
            end
        end

        local accentBack = vgui.Create( "DPanel", self )
        accentBack:Dock( TOP )
        accentBack:DockMargin( 0, 0, 0, 5 )
        accentBack:SetTall( 100 )
        accentBack:DockPadding( 0, 0, 30, 0 )
        accentBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
            draw.RoundedBox( 5, 5, 45, w-10, h-45-5, BRICKS_SERVER.Func.GetTheme( 2 ) )

            draw.SimpleText( BRICKS_SERVER.Func.L( "presetAccents" ), "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
        end

        local first = true
        for k, v in pairs( BRICKS_SERVER.DEVCONFIG.AccentThemes ) do
            local accentButton = vgui.Create( "DButton", accentBack )
            accentButton:Dock( LEFT )
            accentButton:SetText( "" )
            if( first ) then
                accentButton:DockMargin( 10, 50, 0, 10 )
                first = false
            else
                accentButton:DockMargin( 5, 50, 0, 10 )
            end
            accentButton:SetWide( 40 )
            local changeAlpha = 0
            accentButton.Paint = function( self2, w, h )
                if( self2:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 100 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 0, 100 )
                end
                
                draw.RoundedBox( 5, 0, 0, w, h, v[1] )
        
                surface.SetAlphaMultiplier( changeAlpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.SetAlphaMultiplier( 1 )
            end
            accentButton.DoClick = function()
                BS_ConfigCopyTable.THEME[4] = v[1]
                BS_ConfigCopyTable.THEME[5] = v[2]
                BRICKS_SERVER.Func.ConfigChange( "THEME" )
                self.RefreshPanel()
            end
        end

        local backgroundBack = vgui.Create( "DPanel", self )
        backgroundBack:Dock( TOP )
        backgroundBack:DockMargin( 0, 0, 0, 5 )
        backgroundBack:SetTall( 100 )
        backgroundBack:DockPadding( 0, 0, 30, 0 )
        backgroundBack.Paint = function( self2, w, h )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
            draw.RoundedBox( 5, 5, 45, w-10, h-45-5, BRICKS_SERVER.Func.GetTheme( 2 ) )

            draw.SimpleText( BRICKS_SERVER.Func.L( "presetBackgrounds" ), "BRICKS_SERVER_Font33", 15, 5, BRICKS_SERVER.Func.GetTheme( 6 ), 0, 0 )
        end

        local first = true
        for k, v in pairs( BRICKS_SERVER.DEVCONFIG.BackgroundThemes ) do
            local backgroundButton = vgui.Create( "DButton", backgroundBack )
            backgroundButton:Dock( LEFT )
            backgroundButton:SetText( "" )
            if( first ) then
                backgroundButton:DockMargin( 10, 50, 0, 10 )
                first = false
            else
                backgroundButton:DockMargin( 5, 50, 0, 10 )
            end
            backgroundButton:SetWide( 40 )
            local changeAlpha = 0
            backgroundButton.Paint = function( self2, w, h )
                if( self2:IsHovered() ) then
                    changeAlpha = math.Clamp( changeAlpha+10, 0, 100 )
                else
                    changeAlpha = math.Clamp( changeAlpha-10, 0, 100 )
                end
                
                draw.RoundedBox( 5, 0, 0, w, h, v[1] )
        
                surface.SetAlphaMultiplier( changeAlpha/255 )
                draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                surface.SetAlphaMultiplier( 1 )
            end
            backgroundButton.DoClick = function()
                BS_ConfigCopyTable.THEME[0] = v[1]
                BS_ConfigCopyTable.THEME[1] = v[2]
                BS_ConfigCopyTable.THEME[2] = v[3]
                BS_ConfigCopyTable.THEME[3] = v[4]
                BS_ConfigCopyTable.THEME[6] = v[6]
                BRICKS_SERVER.Func.ConfigChange( "THEME" )
                self.RefreshPanel()
            end
        end

        local themeReset = vgui.Create( "DButton", self )
        themeReset:Dock( TOP )
        themeReset:SetText( "" )
        themeReset:DockMargin( 0, 0, 0, 5 )
        themeReset:SetTall( 40 )
        local changeAlpha = 0
        themeReset.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( BRICKS_SERVER.Func.L( "resetToBaseThemes" ), "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        themeReset.DoClick = function()
            BS_ConfigCopyTable.THEME = table.Copy( BRICKS_SERVER.BASECONFIG.THEME )
            BRICKS_SERVER.Func.ConfigChange( "THEME" )
            self.RefreshPanel()
        end

        local themeResetPrevious = vgui.Create( "DButton", self )
        themeResetPrevious:Dock( TOP )
        themeResetPrevious:SetText( "" )
        themeResetPrevious:DockMargin( 0, 0, 0, 5 )
        themeResetPrevious:SetTall( 40 )
        local changeAlpha = 0
        themeResetPrevious.Paint = function( self2, w, h )
            if( self2:IsDown() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 125 )
            elseif( self2:IsHovered() ) then
                changeAlpha = math.Clamp( changeAlpha+10, 0, 75 )
            else
                changeAlpha = math.Clamp( changeAlpha-10, 0, 75 )
            end
            
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
    
            surface.SetAlphaMultiplier( changeAlpha/255 )
            draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 2 ) )
            surface.SetAlphaMultiplier( 1 )
    
            draw.SimpleText( BRICKS_SERVER.Func.L( "resetToCurrentThemes" ), "BRICKS_SERVER_Font25", w/2, h/2, BRICKS_SERVER.Func.GetTheme( 6 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        end
        themeResetPrevious.DoClick = function()
            BS_ConfigCopyTable.THEME = table.Copy( BRICKS_SERVER.CONFIG.THEME )
            BRICKS_SERVER.Func.ConfigChange( "THEME" )
            self.RefreshPanel()
        end
    end
    self.RefreshPanel()
end

function PANEL:Paint( w, h )
    
end

vgui.Register( "bricks_server_config_themes", PANEL, "bricks_server_scrollpanel" )
--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_dframe.lua:
local PANEL = {}

function PANEL:Init()
    self:MakePopup()
    self:SetTitle( "" )
    self:SetDraggable( false )
    self:ShowCloseButton( false )
    self.headerHeight = 40
    self:DockPadding( 0, self.headerHeight, 0, 0 )

    self.removeOnClose = true
    self:CreateCloseButton()
end

function PANEL:CloseFrame()
    if( self.onCloseFunc ) then
        self.onCloseFunc()
    end

    if( self.removeOnClose or BRS_REMOVEONCLOSE ) then
        self:Remove()
    else
        self:SetVisible( false )
    end
end

function PANEL:CreateCloseButton()
    local size = 24

    if( IsValid( self.closeButton ) ) then
        self.closeButton:SetSize( size, size )
        self.closeButton:SetPos( self:GetWide()-size-((self.headerHeight-size)/2), (self.headerHeight/2)-(size/2) )
        return
    end

    self.closeButton = vgui.Create( "DButton", self )
	self.closeButton:SetSize( size, size )
	self.closeButton:SetPos( self:GetWide()-size-((self.headerHeight-size)/2), (self.headerHeight/2)-(size/2) )
	self.closeButton:SetText( "" )
    local CloseMat = Material( "materials/bricks_server/close.png" )
    local textColor = BRICKS_SERVER.Func.GetTheme( 6 )
	self.closeButton.Paint = function( self2, w, h )
		if( self2:IsHovered() and !self2:IsDown() ) then
			surface.SetDrawColor( textColor.r*0.6, textColor.g*0.6, textColor.b*0.6 )
		elseif( self2:IsDown() || self2.m_bSelected ) then
			surface.SetDrawColor( textColor.r*0.8, textColor.g*0.8, textColor.b*0.8 )
		else
			surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 2 ) )
		end

		surface.SetMaterial( CloseMat )
		surface.DrawTexturedRect( 0, 0, w, h )
	end
    self.closeButton.DoClick = function()
        self:CloseFrame()
    end
end

function PANEL:OnSizeChanged( newW, newH )
    self:CreateCloseButton()

    if( self.centerOnSizeChanged ) then
        self:Center()
    end
end

function PANEL:SetHeader( header )
    self.header = header
end

local rounded = 5
function PANEL:Paint( w, h )
    BRICKS_SERVER.BSHADOWS.BeginShadow()
    local x, y = self:LocalToScreen( 0, 0 )
    draw.RoundedBox( rounded, x, y, w, h, BRICKS_SERVER.Func.GetTheme( 1 ) )			
    BRICKS_SERVER.BSHADOWS.EndShadow( 1, 2, 2, 255, 0, 0, false )

    draw.RoundedBoxEx( rounded, 0, 0, w, self.headerHeight, BRICKS_SERVER.Func.GetTheme( 0 ), true, true, false, false )

    draw.SimpleText( (self.header or BRICKS_SERVER.Func.L( "menu" )), "BRICKS_SERVER_Font30", 10, (self.headerHeight or 40)/2-2, BRICKS_SERVER.Func.GetTheme( 6 ), 0, TEXT_ALIGN_CENTER )
end

vgui.Register( "bricks_server_dframe", PANEL, "DFrame" )
--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_dmenu.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_bBorder",			"DrawBorder" )
AccessorFunc( PANEL, "m_bDeleteSelf",		"DeleteSelf" )
AccessorFunc( PANEL, "m_iMinimumWidth",		"MinimumWidth" )
AccessorFunc( PANEL, "m_bDrawColumn",		"DrawColumn" )
AccessorFunc( PANEL, "m_iMaxHeight",		"MaxHeight" )

AccessorFunc( PANEL, "m_pOpenSubMenu",		"OpenSubMenu" )

function PANEL:Init()

	self:SetIsMenu( true )
	self:SetDrawBorder( true )
	self:SetPaintBackground( true )
	self:SetMinimumWidth( 150 )
	self:SetDrawOnTop( true )
	self:SetMaxHeight( ScrH() * 0.9 )
	self:SetDeleteSelf( true )

	self:SetPadding( 0 )

	-- Automatically remove this panel when menus are to be closed
	RegisterDermaMenuForClose( self )

end

function PANEL:AddPanel( pnl )

	self:AddItem( pnl )
	pnl.ParentMenu = self

end

function PANEL:AddOption( strText, funcFunction, extraData )
	self.optionCount = (self.optionCount or 0)+1

	local pnl = vgui.Create( "bricks_server_dmenuoption", self )
	pnl:SetMenu( self )
	pnl:SetText( "" )
	pnl.label = strText
	pnl.position = self.optionCount
	pnl.parentPanel = self
	if ( funcFunction ) then 
		pnl.DoClick = function()
			funcFunction( extraData )
		end
	end

	self:AddPanel( pnl )

	return pnl

end

function PANEL:AddCVar( strText, convar, on, off, funcFunction )

	local pnl = vgui.Create( "bricks_server_dmenuoptioncvar", self )
	pnl:SetMenu( self )
	pnl:SetText( strText )
	if ( funcFunction ) then pnl.DoClick = funcFunction end

	pnl:SetConVar( convar )
	pnl:SetValueOn( on )
	pnl:SetValueOff( off )

	self:AddPanel( pnl )

	return pnl

end

function PANEL:AddSpacer( strText, funcFunction )

	local pnl = vgui.Create( "DPanel", self )
	pnl.Paint = function( p, w, h )
		derma.SkinHook( "Paint", "MenuSpacer", p, w, h )
	end

	pnl:SetTall( 1 )
	self:AddPanel( pnl )

	return pnl

end

function PANEL:AddSubMenu( strText, funcFunction )

	local pnl = vgui.Create( "bricks_server_dmenuoption", self )
	local SubMenu = pnl:AddSubMenu( strText, funcFunction )

	pnl:SetText( strText )
	if ( funcFunction ) then pnl.DoClick = funcFunction end

	self:AddPanel( pnl )

	return SubMenu, pnl

end

function PANEL:Hide()

	local openmenu = self:GetOpenSubMenu()
	if ( openmenu ) then
		openmenu:Hide()
	end

	self:SetVisible( false )
	self:SetOpenSubMenu( nil )

end

function PANEL:OpenSubMenu( item, menu )

	-- Do we already have a menu open?
	local openmenu = self:GetOpenSubMenu()
	if ( IsValid( openmenu ) && openmenu:IsVisible() ) then

		-- Don't open it again!
		if ( menu && openmenu == menu ) then return end

		-- Close it!
		self:CloseSubMenu( openmenu )

	end

	if ( !IsValid( menu ) ) then return end

	local x, y = item:LocalToScreen( self:GetWide(), 0 )
	menu:Open( x - 3, y, false, item )

	self:SetOpenSubMenu( menu )

end

function PANEL:CloseSubMenu( menu )

	menu:Hide()
	self:SetOpenSubMenu( nil )

end

function PANEL:Paint( w, h )

	if ( !self:GetPaintBackground() ) then return end

	if( not self.dontRoundTop and not self.dontRoundBottom ) then
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
	else
		draw.RoundedBoxEx( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ), (not self.dontRoundTop), (not self.dontRoundTop), (not self.dontRoundBottom), (not self.dontRoundBottom) )
	end
	return true

end

function PANEL:ChildCount()
	return #self:GetCanvas():GetChildren()
end

function PANEL:GetChild( num )
	return self:GetCanvas():GetChildren()[ num ]
end

function PANEL:PerformLayout()

	local w = self:GetMinimumWidth()

	-- Find the widest one
	for k, pnl in pairs( self:GetCanvas():GetChildren() ) do

		pnl:PerformLayout()
		w = math.max( w, pnl:GetWide() )

	end

	self:SetWide( w )

	local y = 0 -- for padding

	for k, pnl in pairs( self:GetCanvas():GetChildren() ) do

		pnl:SetWide( w )
		pnl:SetPos( 0, y )
		pnl:InvalidateLayout( true )

		y = y + pnl:GetTall()

	end

	y = math.min( y, self:GetMaxHeight() )

	self:SetTall( y )

	derma.SkinHook( "Layout", "Menu", self )

	DScrollPanel.PerformLayout( self )

end

--[[---------------------------------------------------------
	Open - Opens the menu.
	x and y are optional, if they're not provided the menu
		will appear at the cursor.
-----------------------------------------------------------]]
function PANEL:Open( x, y, skipanimation, ownerpanel )
	if( IsValid( BRS_TOOLTIP ) ) then
		BRS_TOOLTIP:Remove()
	end

	RegisterDermaMenuForClose( self )

	local maunal = x && y

	x = x or gui.MouseX()
	y = y or gui.MouseY()

	local OwnerHeight = 0
	local OwnerWidth = 0

	if ( ownerpanel ) then
		OwnerWidth, OwnerHeight = ownerpanel:GetSize()
	end

	self:PerformLayout()

	local w = self:GetWide()
	local h = self:GetTall()

	self:SetSize( w, h )

	if ( y + h > ScrH() ) then y = ( ( maunal && ScrH() ) or ( y + OwnerHeight ) ) - h end
	if ( x + w > ScrW() ) then x = ( ( maunal && ScrW() ) or x ) - w end
	if ( y < 1 ) then y = 1 end
	if ( x < 1 ) then x = 1 end

	self:SetPos( x, y )

	-- Popup!
	self:MakePopup()

	-- Make sure it's visible!
	self:SetVisible( true )

	-- Keep the mouse active while the menu is visible.
	self:SetKeyboardInputEnabled( false )

end

--
-- Called by bricks_server_dmenuoption
--
function PANEL:OptionSelectedInternal( option )

	self:OptionSelected( option, option:GetText() )

end

function PANEL:OptionSelected( option, text )

	-- For override

end

function PANEL:ClearHighlights()

	for k, pnl in pairs( self:GetCanvas():GetChildren() ) do
		pnl.Highlight = nil
	end

end

function PANEL:HighlightItem( item )

	for k, pnl in pairs( self:GetCanvas():GetChildren() ) do
		if ( pnl == item ) then
			pnl.Highlight = true
		end
	end

end

derma.DefineControl( "bricks_server_dmenu", "A Menu", PANEL, "bricks_server_scrollpanel" )

--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_dmenuoptioncvar.lua:

local PANEL = {}

DEFINE_BASECLASS( "bricks_server_dmenuoption" )

AccessorFunc( PANEL, "m_strConVar", "ConVar" )
AccessorFunc( PANEL, "m_strValueOn", "ValueOn" )
AccessorFunc( PANEL, "m_strValueOff", "ValueOff" )

function PANEL:Init()

	self:SetChecked( false )
	self:SetIsCheckable( true )

	self:SetValueOn( "1" )
	self:SetValueOff( "0" )

end

function PANEL:Think()

	if ( !self.m_strConVar ) then return end
	local strValue = GetConVarString( self.m_strConVar )

	self:SetChecked( strValue == self.m_strValueOn )

end

function PANEL:OnChecked( b )

	if ( !self.m_strConVar ) then return end

	if ( b ) then
		RunConsoleCommand( self.m_strConVar, self.m_strValueOn )
	else
		RunConsoleCommand( self.m_strConVar, self.m_strValueOff )
	end

end

derma.DefineControl( "bricks_server_dmenuoptioncvar", "", PANEL, "bricks_server_dmenuoption" )

--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_dnumslider.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_fDefaultValue", "DefaultValue" )

function PANEL:Init()
	self.TextArea = self:Add( "DTextEntry" )
	self.TextArea:Dock( RIGHT )
	self.TextArea:DockMargin( 20, 0, 0, 0 )
	self.TextArea:SetPaintBackground( false )
	self.TextArea:SetWide( 45 )
	self.TextArea:SetNumeric( true )
	self.TextArea:SetTextColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
	self.TextArea:SetFont( "BRICKS_SERVER_Font17" )
	self.TextArea.OnChange = function( textarea, val ) self:SetValue( self.TextArea:GetText() ) end

	self.Slider = self:Add( "bricks_server_dslider", self )
	self.Slider:SetLockY( 0.5 )
	self.Slider.TranslateValues = function( slider, x, y ) return self:TranslateSliderValues( x, y ) end
	self.Slider:Dock( FILL )
	self.Slider:SetHeight( 16 )
	self.Slider.Knob.OnMousePressed = function( panel, mcode )
		if ( mcode == MOUSE_MIDDLE ) then
			self:ResetToDefaultValue()
			return
		end
		self.Slider:OnMousePressed( mcode )
	end

	self:SetTall( 32 )

	self:SetMin( 0 )
	self:SetMax( 1 )
	self:SetValue( 1 )
	self.Slider:SetSlideX( 0 )
end

function PANEL:SetMinMax( min, max )
	self:UpdateNotches()
end

function PANEL:GetMin()
	return self.min or 0
end

function PANEL:GetMax()
	return self.max or 1
end

function PANEL:GetRange()
	return self:GetMax() - self:GetMin()
end

function PANEL:ResetToDefaultValue()
	if ( !self:GetDefaultValue() ) then return end
	self:SetValue( self:GetDefaultValue() )
end

function PANEL:SetMin( min )

	if ( !min ) then min = 0 end

	self.min = tonumber( min )
	self:UpdateNotches()

end

function PANEL:SetMax( max )

	if ( !max ) then max = 0 end

	self.max = tonumber( max )
	self:UpdateNotches()

end

function PANEL:SetValue( val )

	val = math.Clamp( tonumber( val ) || 0, self:GetMin(), self:GetMax() )

	if ( self:GetValue() == val ) then return end

	self.value = val

	self:ValueChanged( self:GetValue() ) -- In most cases this will cause double execution of OnValueChanged

end

function PANEL:GetFloatValue()
	return self.value or 0
end

function PANEL:GetValue()
	return self.value or 0
end

--
-- Are we currently changing the value?
--
function PANEL:IsEditing()

	return self.TextArea:IsEditing() || self.Slider:IsEditing()

end

function PANEL:IsHovered()

	return self.TextArea:IsHovered() || self.Slider:IsHovered() || vgui.GetHoveredPanel() == self

end

function PANEL:PerformLayout()
	self.Slider:PerformLayout()
end

function PANEL:ValueChanged( val )

	val = math.Clamp( tonumber( val ) || 0, self:GetMin(), self:GetMax() )

	self.Slider:SetSlideX( self.value/self.max )

	self:OnValueChanged( val )
	self.TextArea:SetText( math.floor( val ) )
end

function PANEL:OnValueChanged( val )

	-- For override

end

function PANEL:TranslateSliderValues( x, y )

	self:SetValue( self:GetMin() + ( x * self:GetRange() ) )

	return (self:GetValue()-self:GetMin())/self:GetRange(), y

end

function PANEL:GetTextArea()

	return self.TextArea

end

function PANEL:UpdateNotches()

	local range = self:GetRange()
	self.Slider:SetNotches( nil )

	if ( range < self:GetWide() / 4 ) then
		return self.Slider:SetNotches( range )
	else
		self.Slider:SetNotches( self:GetWide() / 4 )
	end

end

function PANEL:SetEnabled( b )
	self.Slider:SetEnabled( b )
	FindMetaTable( "Panel" ).SetEnabled( self, b ) -- There has to be a better way!
end

derma.DefineControl( "bricks_server_dnumslider", "Menu Option Line", table.Copy( PANEL ), "Panel" )
--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_navcategorycollapse.lua:

local PANEL = {}

function PANEL:Init()
	self:SetContentAlignment( 4 )
	self:SetTextInset( 5, 0 )
	self:SetFont( "DermaDefaultBold" )

	self.changeAlpha = 0
end

function PANEL:DoClick()
	self:GetParent():Toggle()
	
	if( self:GetParent().OnNavCollapse ) then
		self:GetParent().OnNavCollapse( self.headerText, not self:GetParent():GetExpanded() )
	end
end

function PANEL:Paint( w, h )
	if( self:IsDown() ) then
		self.changeAlpha = 100
	elseif( self:IsHovered() ) then
		self.changeAlpha = math.Clamp( self.changeAlpha+10, 50, 75 )
	else
		self.changeAlpha = math.Clamp( self.changeAlpha-10, 50, 100 )
	end

	surface.SetAlphaMultiplier( self.changeAlpha/255 )
		surface.SetDrawColor( self.backColor or BRICKS_SERVER.Func.GetTheme( 4 ) )
		surface.DrawRect( 0, 0, w, h )
	surface.SetAlphaMultiplier( 1 )

	draw.SimpleText( (self.headerText or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font20", 10, h/2, (self.backColor or BRICKS_SERVER.Func.GetTheme( 5 )), 0, TEXT_ALIGN_CENTER )
end

derma.DefineControl( "bricks_server_navcategoryheader", "Category Header", PANEL, "DButton" )

local PANEL = {}

AccessorFunc( PANEL, "m_bSizeExpanded",		"Expanded", FORCE_BOOL )
AccessorFunc( PANEL, "m_iContentHeight",	"StartHeight" )
AccessorFunc( PANEL, "m_fAnimTime",			"AnimTime" )
AccessorFunc( PANEL, "m_bDrawBackground",	"PaintBackground", FORCE_BOOL )
AccessorFunc( PANEL, "m_bDrawBackground",	"DrawBackground", FORCE_BOOL ) -- deprecated
AccessorFunc( PANEL, "m_iPadding",			"Padding" )
AccessorFunc( PANEL, "m_pList",				"List" )

function PANEL:Init()
	self.Header = vgui.Create( "bricks_server_navcategoryheader", self )
	self.Header:Dock( TOP )
	self.Header:SetSize( 20, 30 )
	self.Header:SetText( "" )

	self:SetSize( 16, 16 )
	self:SetExpanded( true )
	self:SetMouseInputEnabled( true )

	self:SetAnimTime( 0.2 )
	self.animSlide = Derma_Anim( "Anim", self, self.AnimSlide )

	self:SetPaintBackground( true )
	self:DockPadding( 0, 0, 0, 5 )
end

function PANEL:UnselectAll()

	local children = self:GetChildren()
	for k, v in pairs( children ) do

		if ( v.SetSelected ) then
			v:SetSelected( false )
		end

	end

end

function PANEL:UpdateAltLines()

	local children = self:GetChildren()
	for k, v in pairs( children ) do
		v.AltLine = k % 2 != 1
	end

end

function PANEL:Think()

	self.animSlide:Run()

end

function PANEL:SetLabel( strLabel )
	self.Header.headerText = strLabel
end

function PANEL:GetLabel()
	return self.Header.headerText or ""
end

function PANEL:SetBackColor( color )
	self.Header.backColor = color
end

function PANEL:Paint( w, h )

end

function PANEL:SetContents( pContents )

	self.Contents = pContents
	self.Contents:SetParent( self )
	self.Contents:Dock( FILL )

	if ( !self:GetExpanded() ) then

		self.OldHeight = self:GetTall()

	elseif ( self:GetExpanded() && IsValid( self.Contents ) && self.Contents:GetTall() < 1 ) then

		self.Contents:SizeToChildren( false, true )
		self.OldHeight = self.Contents:GetTall()
		self:SetTall( self.OldHeight )

	end

	self:InvalidateLayout( true )

end

function PANEL:SetExpanded( expanded )
	self.m_bSizeExpanded = tobool( expanded )

	if ( !self:GetExpanded() ) then
		if ( !self.animSlide.Finished && self.OldHeight ) then return end
		self.OldHeight = self:GetTall()
	end
end

function PANEL:Toggle()
	self:SetExpanded( !self:GetExpanded() )

	self.animSlide:Start( self:GetAnimTime(), { From = self:GetTall() } )

	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

	local open = "1"
	if ( !self:GetExpanded() ) then open = "0" end
	self:SetCookie( "Open", open )

	self:OnToggle( self:GetExpanded() )
end

function PANEL:OnToggle( expanded )

	-- Do nothing / For developers to overwrite

end

function PANEL:DoExpansion( b )

	if ( self:GetExpanded() == b ) then return end
	self:Toggle()

end

function PANEL:PerformLayout()

	if ( IsValid( self.Contents ) ) then

		if ( self:GetExpanded() ) then
			self.Contents:InvalidateLayout( true )
			self.Contents:SetVisible( true )
		else
			self.Contents:SetVisible( false )
		end

	end

	if ( self:GetExpanded() ) then

		if ( IsValid( self.Contents ) && #self.Contents:GetChildren() > 0 ) then self.Contents:SizeToChildren( false, true ) end
		self:SizeToChildren( false, true )

	else

		if ( IsValid( self.Contents ) && !self.OldHeight ) then self.OldHeight = self.Contents:GetTall() end
		self:SetTall( self.Header:GetTall() )

	end

	-- Make sure the color of header text is set
	self.Header:ApplySchemeSettings()

	self.animSlide:Run()
	self:UpdateAltLines()

end

function PANEL:OnMousePressed( mcode )

	if ( !self:GetParent().OnMousePressed ) then return end

	return self:GetParent():OnMousePressed( mcode )

end

function PANEL:AnimSlide( anim, delta, data )

	self:InvalidateLayout()
	self:InvalidateParent()

	if ( anim.Started ) then
		if ( !IsValid( self.Contents ) && ( self.OldHeight || 0 ) < self.Header:GetTall() ) then
			-- We are not using self.Contents and our designated height is less
			-- than the header size, something is clearly wrong, try to rectify
			self.OldHeight = 0
			for id, pnl in pairs( self:GetChildren() ) do
				self.OldHeight = self.OldHeight + pnl:GetTall()
			end
		end

		if ( self:GetExpanded() ) then
			data.To = math.max( self.OldHeight, self:GetTall() )
		else
			data.To = self:GetTall()
		end
	end

	if ( IsValid( self.Contents ) ) then self.Contents:SetVisible( true ) end

	self:SetTall( Lerp( delta, data.From, data.To ) )

end

function PANEL:LoadCookies()

	local Open = self:GetCookieNumber( "Open", 1 ) == 1

	self:SetExpanded( Open )
	self:InvalidateLayout( true )
	self:GetParent():InvalidateLayout()
	self:GetParent():GetParent():InvalidateLayout()

end

derma.DefineControl( "bricks_server_navcategorycollapse", "Collapsable Category Panel", PANEL, "Panel" )

--PATH addons/brick_s_server_framework/lua/bricks_server/vgui/bricks_server_scrollpanel.lua:
local PANEL = {}

AccessorFunc( PANEL, "Padding", "Padding" )
AccessorFunc( PANEL, "pnlCanvas", "Canvas" )

function PANEL:Init()

	self.pnlCanvas = vgui.Create( "Panel", self )
	self.pnlCanvas.OnMousePressed = function( self, code ) self:GetParent():OnMousePressed( code ) end
	self.pnlCanvas:SetMouseInputEnabled( true )
	self.pnlCanvas.PerformLayout = function( pnl )

		self:PerformLayoutInternal()
		self:InvalidateParent()

	end

	-- Create the scroll bar
	self.VBar = vgui.Create( "DVScrollBar", self )
	self.VBar:Dock( RIGHT )
	self.VBar:SetWide( 0 )

	self:SetPadding( 0 )
	self:SetMouseInputEnabled( true )

	-- This turns off the engine drawing
	self:SetPaintBackgroundEnabled( false )
	self:SetPaintBorderEnabled( false )
	self:SetPaintBackground( false )

end

function PANEL:AddItem( pnl )

	pnl:SetParent( self:GetCanvas() )

end

function PANEL:OnChildAdded( child )

	self:AddItem( child )

end

function PANEL:SizeToContents()

	self:SetSize( self.pnlCanvas:GetSize() )

end

function PANEL:GetVBar()

	return self.VBar

end

function PANEL:GetCanvas()

	return self.pnlCanvas

end

function PANEL:InnerWidth()

	return self:GetCanvas():GetWide()

end

function PANEL:Rebuild()

	self:GetCanvas():SizeToChildren( false, true )

	-- Although this behaviour isn't exactly implied, center vertically too
	if ( self.m_bNoSizing && self:GetCanvas():GetTall() < self:GetTall() ) then

		self:GetCanvas():SetPos( 0, ( self:GetTall() - self:GetCanvas():GetTall() ) * 0.5 )

	end

end

function PANEL:OnMouseWheeled( dlta )

	return self.VBar:OnMouseWheeled( dlta )

end

function PANEL:OnVScroll( iOffset )

	self.pnlCanvas:SetPos( 0, iOffset )

end

function PANEL:ScrollToChild( panel )

	self:InvalidateLayout( true )

	local x, y = self.pnlCanvas:GetChildPosition( panel )
	local w, h = panel:GetSize()

	y = y + h * 0.5
	y = y - self:GetTall() * 0.5

	self.VBar:AnimateTo( y, 0.5, 0, 0.5 )

end

-- Avoid an infinite loop
function PANEL:PerformLayoutInternal()

	local Tall = self.pnlCanvas:GetTall()
	local Wide = self:GetWide()
	local YPos = 0

	self:Rebuild()

	self.VBar:SetUp( self:GetTall(), self.pnlCanvas:GetTall() )
	YPos = self.VBar:GetOffset()

	if ( self.VBar.Enabled ) then Wide = Wide - self.VBar:GetWide() end

	self.pnlCanvas:SetPos( 0, YPos )
	self.pnlCanvas:SetWide( Wide )

	self:Rebuild()

	if ( Tall != self.pnlCanvas:GetTall() ) then
		self.VBar:SetScroll( self.VBar:GetScroll() ) -- Make sure we are not too far down!
	end

end

function PANEL:PerformLayout()

	self:PerformLayoutInternal()

end

function PANEL:Clear()

	return self.pnlCanvas:Clear()

end

derma.DefineControl( "bricks_server_scrollpanel", "", PANEL, "DPanel" )
--PATH addons/bricks_gangs/lua/bricks_server/modules/gangs/vgui/bricks_server_gangicon.lua:
local PANEL = {}

DEFINE_BASECLASS( "DImage" )

function PANEL:Init()

end

function PANEL:SetIconURL( path )
	if path == 'bricks_server/question.png' then self:SetMaterial( path ) return end

    if( not BRICKS_SERVER.Func.CheckGangIconURL( path ) ) then return end

    if( not string.StartWith( path, "http" ) ) then
        self:SetMaterial( path )
        return
    end

    self.loadingImage = true
    
    BRICKS_SERVER.Func.GetImage( path, function( mat )
        if( not IsValid( self ) ) then return end
        self.loadingImage = false
        if( IsValid( self.loadingPanel ) ) then
            self.loadingPanel:Remove()
        end
        self:SetMaterial( mat or 'bricks_server/question.png')
    end )
end

function PANEL:CreateLoadingPanel( w, h )
    self.loadingPanel = vgui.Create( "bricks_server_loading_square", self )
    self.loadingPanel:SetSize( BRICKS_SERVER.Func.Repeat( math.min( w, h, BRICKS_SERVER.Func.ScreenScale( 40 ) ), 2 ) )
    self.loadingPanel:SetPos( w/2-self.loadingPanel:GetWide()/2, h/2-self.loadingPanel:GetTall()/2 )
    self.loadingPanel:BeginAnimation()
end

function PANEL:Paint( w, h )
    if( not self.loadingImage ) then 
        BaseClass.Paint( self, w, h )
        return 
    end

    if( IsValid( self.loadingPanel ) ) then return end
    self:CreateLoadingPanel( w, h )
end

vgui.Register( "bricks_server_gangicon", PANEL, "DImage" )
--PATH addons/bricks_gangs/lua/bricks_server/modules/gangs/submodules/leaderboards/vgui/bricks_server_gangmenu_leaderboards.lua:
local PANEL = {}

function PANEL:Init()
    self:DockMargin( 10, 10, 10, 10 )
end

local setMaterial = surface.SetMaterial
local setDrawColor = surface.SetDrawColor
local drawTexturedRect = surface.DrawTexturedRectRotated
local surfaceDrawOutlinedRect = surface.DrawOutlinedRect
local mat = Material('bricks_server/up.png')

function PANEL:FillPanel( gangTable )
    -- BRICKS_SERVER.Func.RequestGangLeaderboards()

    local categoryList = vgui.Create( "bricks_server_dcategorylist", self )
    categoryList:Dock( FILL )

    function self.RefreshPanel()
        categoryList:Clear()
        local categories = {}
        local slotTall, spacing = 80, 5
        
        for num, led in pairs( BRICKS_SERVER.CONFIG.GANGS.Leaderboards or {} ) do
            local leaderboardTable = (BRS_GANG_LEADERBOARDS or {})[num] or {}

            local categoryName = led.Name or BRICKS_SERVER.Func.L( "other" )
            if( not categories[categoryName] ) then
                local categoryColor = BRICKS_SERVER.Func.GetTheme( 5 )

                categories[categoryName] = categoryList:Add( categoryName, categoryColor )
                categories[categoryName]:SetTall( 40+spacing )
                categories[categoryName]:Toggle()
				local panel = categories[categoryName]
				panel.hover = 0
				function panel:PaintOver(w, h)
					self.hover = Lerp(FrameTime() * 6, self.hover, self:GetExpanded() and 0 or 180)

					setMaterial(mat)
					setDrawColor(255, 255, 255)
					drawTexturedRect(w - 30, 20, 20, 12, self.hover)
				end

                local spacer = vgui.Create( "DPanel", categories[categoryName] )
                spacer:Dock( BOTTOM )
                spacer:SetTall( spacing )
                spacer.Paint = function( self2, w, h ) end
            end

            categories[categoryName]:SetTall( categories[categoryName]:GetTall()+slotTall+spacing )

            for k, v in next, leaderboardTable do
				local gangTbl = {}
				if v.GangID then
					if BRICKS_SERVER_GANGNAMES[v.GangID or 0] then
						gangTbl = BRICKS_SERVER_GANGNAMES[v.GangID or 0]
					else
						BRICKS_SERVER.Func.RequestLeaderboardGangs()
					end
				end
				
				if string.StartWith( gangTbl.Icon, "https://imgur.com" ) then gangTbl.Icon = "bricks_server/question.png" end
				
                local itemBack = vgui.Create( "DPanel", categories[categoryName] )
                itemBack:Dock( TOP )
                itemBack:DockMargin( spacing, spacing, spacing, 0 )
                itemBack:SetTall( slotTall )
                itemBack.Paint = function( self2, w, h ) 
                    draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
                end

                local gangIcon = vgui.Create("bricks_server_gangicon", itemBack)
                gangIcon:Dock( LEFT )
                gangIcon:DockMargin( 20, 20, 10, 20 )
                gangIcon:SetWide( itemBack:GetTall() - 40 )
				gangIcon:SetIconURL(gangTbl.Icon or "bricks_server/question.png")

                local itemInfo = vgui.Create( "DPanel", itemBack )
                itemInfo:Dock( LEFT )
                itemInfo:DockMargin( 0, 10, 0, 10 )
                itemInfo:SetWide( 125 )
                itemInfo.Paint = function( self2, w, h ) 
                    draw.SimpleText( (gangTbl.Name or BRICKS_SERVER.Func.L( "nil" )), "BRICKS_SERVER_Font17", 0, 15, BRICKS_SERVER.Func.GetTheme( 5 ), 0, 0 )
                end

                local rankPanel = vgui.Create("DPanel", itemInfo)
				rankPanel:Dock(FILL)
                rankPanel:DockMargin( 0, 32, 0, 0 )
				rankPanel:SetWide(60)
				rankPanel.Paint = function(self2, w, h)
					draw.SimpleText("#" .. k, "BRICKS_SERVER_Font25", 0, 0, BRICKS_SERVER.Func.GetTheme(6))
				end

                local devConfig = BRICKS_SERVER.DEVCONFIG.GangLeaderboards[led.Type]
				local valuePanel = vgui.Create("DPanel", itemBack)
				
				local TOP_COLORS = {
					[1] = Color(255, 215, 0),  -- Золотой
					[2] = Color(192, 192, 192),-- Серебряный
					[3] = Color(205, 127, 50)  -- Бронзовый
				}

				valuePanel:Dock(RIGHT)
				valuePanel:SetWide(150)
				valuePanel:DockMargin(0, 10, 10, 10)
				valuePanel.Paint = function(self2, w, h)
					local borderWidth = 1

					if k <= 3 then
						draw.RoundedBox(5, 0, 0, w, h, TOP_COLORS[k])
						draw.RoundedBox(5, borderWidth, borderWidth, w - borderWidth*2, h - borderWidth*2, BRICKS_SERVER.Func.GetTheme(2))
					else
						draw.RoundedBox(5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme(2))
					end
					draw.SimpleText(
						devConfig.FormatDescription(v.SortValue or 0), 
						"BRICKS_SERVER_Font20", 
						w/2, 
						h/2, 
						BRICKS_SERVER.Func.GetTheme(6), 
						TEXT_ALIGN_CENTER, 
						TEXT_ALIGN_CENTER
					)
				end
            end
        end
    end

    self.RefreshPanel()

    hook.Add( "BRS.Hooks.RefreshGangLeaderboards", self, function()
		BRICKS_SERVER.Func.RequestGangLeaderboards()
        if( IsValid( self ) ) then
            self.RefreshPanel()
        else
            hook.Remove( "BRS.Hooks.RefreshGangLeaderboards", self )
        end
    end )
end

function PANEL:Paint( w, h )

end

vgui.Register( "bricks_server_gangmenu_leaderboards", PANEL, "DPanel" )
--PATH addons/brick_s_server_framework/lua/bricks_server/modules/default/submodules/currencies/client/cl_currency_system.lua:
BRICKS_SERVER.Func.AddConfigPage( "Currencies", "bricks_server_config_currencies" )
BRICKS_SERVER.Func.AddAdminPlayerFunc( "Currency", "Set", function( ply ) 
	local options = {}
	for k, v in pairs( (BRICKS_SERVER.CONFIG.CURRENCIES or {}) ) do
		options[k] = v.Name
	end
	BRICKS_SERVER.Func.ComboRequest( "Admin", "What currency would you like to set?", 1, options, function( value, data ) 
		if( BRICKS_SERVER.CONFIG.CURRENCIES[data] ) then
			BRICKS_SERVER.Func.StringRequest( "Admin", "How much would you like their currency to?", 0, function( text ) 
				if( isnumber( tonumber( text ) ) ) then
					RunConsoleCommand( "setcurrency", ply:SteamID64(), data, text )
				else
					notification.AddLegacy( "Invalid number.", 1, 3 )
				end
			end, function() end, "OK", "Cancel", true )
		else
			notification.AddLegacy( "Invalid currency.", 1, 3 )
		end
	end, function() end, "OK", "Cancel" )
end )
BRICKS_SERVER.Func.AddAdminPlayerFunc( "Currency", "Add", function( ply ) 
	local options = {}
	for k, v in pairs( (BRICKS_SERVER.CONFIG.CURRENCIES or {}) ) do
		options[k] = v.Name
	end
	BRICKS_SERVER.Func.ComboRequest( "Admin", "What currency would you like to add?", 1, options, function( value, data ) 
		if( BRICKS_SERVER.CONFIG.CURRENCIES[data] ) then
			BRICKS_SERVER.Func.StringRequest( "Admin", "How much would you like to add?", 0, function( text ) 
				if( isnumber( tonumber( text ) ) ) then
					RunConsoleCommand( "addcurrency", ply:SteamID64(), data, text )
				else
					notification.AddLegacy( "Invalid number.", 1, 3 )
				end
			end, function() end, "OK", "Cancel", true )
		else
			notification.AddLegacy( "Invalid currency.", 1, 3 )
		end
	end, function() end, "OK", "Cancel" )
end )

BRS_CURRENCIES = BRS_CURRENCIES or {}
net.Receive( "BRS.Net.SetCurrencies", function()
	local currenciesTable = net.ReadTable()

	BRS_CURRENCIES = currenciesTable or {}

	if( IsValid( BRICKS_SERVER_F4 ) and BRICKS_SERVER_F4:IsVisible() and BRICKS_SERVER_F4.FillProfile ) then
		BRICKS_SERVER_F4.FillProfile()
	end
end )

function BRICKS_SERVER.Func.CreateCurrencyEditor( currencyKey, oldCurrencyTable, onSave, onCancel )
	BS_CURRENCY_EDITOR = vgui.Create( "DFrame" )
	BS_CURRENCY_EDITOR:SetSize( ScrW(), ScrH() )
	BS_CURRENCY_EDITOR:Center()
	BS_CURRENCY_EDITOR:SetTitle( "" )
	BS_CURRENCY_EDITOR:ShowCloseButton( false )
	BS_CURRENCY_EDITOR:SetDraggable( false )
	BS_CURRENCY_EDITOR:MakePopup()
	BS_CURRENCY_EDITOR:SetAlpha( 0 )
	BS_CURRENCY_EDITOR:AlphaTo( 255, 0.1, 0 )
	BS_CURRENCY_EDITOR.Paint = function( self2 ) 
		BRICKS_SERVER.Func.DrawBlur( self2, 4, 4 )
	end

	local backPanel = vgui.Create( "DPanel", BS_CURRENCY_EDITOR )
	backPanel.Paint = function( self2, w, h ) 
		draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 0 ) )
		draw.RoundedBox( 5, 1, 1, w-2, h-2, BRICKS_SERVER.Func.GetTheme( 2 ) )
	end

	local currencyTable = table.Copy( oldCurrencyTable )

	local textArea

	local actions = {
		[1] = { "Name", Material( "materials/bricks_server/name.png" ), function()
			BRICKS_SERVER.Func.StringRequest( "Admin", "What should the new name be?", currencyTable.Name, function( text ) 
				currencyTable.Name = text
			end, function() end, "OK", "Cancel", false )
		end, "Name" },
		[2] = { "Prefix", Material( "materials/bricks_server/currency.png" ), function()
			BRICKS_SERVER.Func.StringRequest( "Admin", "What should the prefix be?", currencyTable.Prefix or "", function( text ) 
				if( currencyTable.Prefix and text == "" ) then
					currencyTable.Prefix = nil
					return
				end

				currencyTable.Prefix = text
			end, function() end, "OK", "Cancel", false )
		end, "Prefix" },
		[3] = { "Suffix", Material( "materials/bricks_server/currency.png" ), function()
			BRICKS_SERVER.Func.StringRequest( "Admin", "What should the suffix be?", currencyTable.Suffix or "", function( text ) 
				if( currencyTable.Suffix and text == "" ) then
					currencyTable.Suffix = nil
					return
				end

				currencyTable.Suffix = text
			end, function() end, "OK", "Cancel", false )
		end, "Suffix" }
	}

	function backPanel.FillOptions()
		backPanel:Clear()

		textArea = vgui.Create( "DPanel", backPanel )
		textArea:Dock( TOP )
		textArea:DockMargin( 10, 10, 10, 0 )
		textArea:SetTall( 30 )
		textArea.Paint = function( self2, w, h ) 
			draw.SimpleText( "Currency Editor", "BRICKS_SERVER_Font20", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end

		for k, v in ipairs( actions ) do
			local actionButton = vgui.Create( "DButton", backPanel )
			actionButton:SetText( "" )
			actionButton:Dock( TOP )
			actionButton:DockMargin( 10, 10, 10, 0 )
			actionButton:SetTall( 40 )
			local changeAlpha = 0
			actionButton.Paint = function( self2, w, h )
				if( self2:IsDown() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				elseif( self2:IsHovered() ) then
					changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
				else
					changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
				end
				
				draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 3 ) )
		
				surface.SetAlphaMultiplier( changeAlpha/255 )
					draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.Func.GetTheme( 5 ) )
				surface.SetAlphaMultiplier( 1 )

				if( v[2] ) then
					surface.SetDrawColor( BRICKS_SERVER.Func.GetTheme( 6 ) )
					surface.SetMaterial( v[2] )
					local iconSize = 24
					surface.DrawTexturedRect( (h-iconSize)/2, (h/2)-(iconSize/2), iconSize, iconSize )
				end

				if( v[4] and currencyTable[v[4]] and not v[5] ) then
					draw.SimpleText( v[1] .. " - " .. string.sub( currencyTable[v[4]], 1, 20 ), "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				elseif( v[5] and isfunction( v[5] ) ) then
					draw.SimpleText( v[1] .. " - " .. v[5](), "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				else
					draw.SimpleText( v[1], "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
				end
			end
			actionButton.DoClick = function()
				if( v[3] ) then
					v[3]()
				end
			end
		end

		local buttonPanel = vgui.Create( "DPanel", backPanel )
		buttonPanel:Dock( BOTTOM )
		buttonPanel:DockMargin( 10, 10, 10, 10 )
		buttonPanel:SetTall( 40 )
		buttonPanel.Paint = function( self2, w, h ) end

		local leftButton = vgui.Create( "DButton", buttonPanel )
		leftButton:Dock( LEFT )
		leftButton:SetText( "" )
		leftButton:DockMargin( 0, 0, 0, 0 )
		local changeAlpha = 0
		leftButton.Paint = function( self2, w, h )
			if( self2:IsHovered() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Green )

			surface.SetAlphaMultiplier( changeAlpha/255 )
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkGreen )
			surface.SetAlphaMultiplier( 1 )

			draw.SimpleText( "Save", "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		leftButton.DoClick = function()
			onSave( currencyTable )

			BS_CURRENCY_EDITOR:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( BS_CURRENCY_EDITOR ) ) then
					BS_CURRENCY_EDITOR:Remove()
				end
			end )
		end

		local rightButton = vgui.Create( "DButton", buttonPanel )
		rightButton:Dock( RIGHT )
		rightButton:SetText( "" )
		rightButton:DockMargin( 0, 0, 0, 0 )
		local changeAlpha = 0
		rightButton.Paint = function( self2, w, h )
			if( self2:IsHovered() ) then
				changeAlpha = math.Clamp( changeAlpha+10, 0, 255 )
			else
				changeAlpha = math.Clamp( changeAlpha-10, 0, 255 )
			end
			
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.Red )

			surface.SetAlphaMultiplier( changeAlpha/255 )
			draw.RoundedBox( 5, 0, 0, w, h, BRICKS_SERVER.DEVCONFIG.BaseThemes.DarkRed )
			surface.SetAlphaMultiplier( 1 )

			draw.SimpleText( "Cancel", "BRICKS_SERVER_Font25", w/2, h/2, Color( 255, 255, 255 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
		end
		rightButton.DoClick = function()
			onCancel()

			BS_CURRENCY_EDITOR:AlphaTo( 0, 0.1, 0, function()
				if( IsValid( BS_CURRENCY_EDITOR ) ) then
					BS_CURRENCY_EDITOR:Remove()
				end
			end )
		end

		backPanel:SetSize( (2*10)+(2*150)+80, buttonPanel:GetTall()+(4*10)+textArea:GetTall()+(#actions*50) )
		backPanel:Center()

		leftButton:SetWide( (backPanel:GetWide()-30)/2 )
		rightButton:SetWide( (backPanel:GetWide()-30)/2 )
	end
	backPanel.FillOptions()
end

hook.Add( "BRS.Hooks.ConfigReceived", "BRS.Hooks.ConfigReceived.Currencies", function( configUnCompressed )
    if( configUnCompressed.CURRENCIES and BRICKS_SERVER.LoadCurrencies ) then
        BRICKS_SERVER.LoadCurrencies()
    end
end )
--PATH addons/_gmbheist/lua/autorun/client/cl_bag.lua:
local bagModel = ClientsideModel( 'models/gta iv/duffle_bag.mdl' )
bagModel:SetNoDraw( true )
bagModel:SetSkin( 3 )

local offsetvec = Vector( -4, -5.5, -2 )
local offsetang = Angle( -90, 90, 0 )

-- Кэширование состояния оружия для каждого игрока
local playerWeaponCache = {}

-- Функция для обновления состояния оружия
local function UpdatePlayerWeaponCache(ply)
    playerWeaponCache[ply] = ply:HasWeapon("bag_money")
end

-- Таймер для обновления состояния оружия
timer.Create("GambitHeist_UpdateWeaponCache", 1, 0, function()
    for _, ply in player.Iterator() do
        UpdatePlayerWeaponCache(ply)
    end
end)

hook.Add( "PostPlayerDraw", "GambitHeist_DrawBag", function( ply )
    -- Проверяем, существует ли кэш для игрока и имеет ли он нужное оружие
    if playerWeaponCache[ply] then
        local boneid = ply:LookupBone( "ValveBiped.Bip01_Spine2" )

        if not boneid then
            return
        end

        local matrix = ply:GetBoneMatrix( boneid )

        if not matrix then
            return
        end

        local newpos, newang = LocalToWorld( offsetvec, offsetang, matrix:GetTranslation(), matrix:GetAngles() )

        bagModel:SetPos( newpos )
        bagModel:SetAngles( newang )
        bagModel:SetupBones()
        bagModel:DrawModel()
    end
end)

--PATH addons/escape/lua/autorun/client/cl_escape.lua:
surface.CreateFont("VSDM30", {
	font = "VK Sans Display Medium",
	extended = true,
	size = height(30),
	weight = 500,
})
surface.CreateFont("VSDM20", {
	font = "VK Sans Display Medium",
	extended = true,
	size = height(20),
	weight = 500,
})
surface.CreateFont("VSDDB20", {
	font = "VK Sans Display DemiBold",
	extended = true,
	size = height(20),
	weight = 500,
})
surface.CreateFont("VSDM16", {
	font = "VK Sans Display Medium",
	extended = true,
	size = height(16),
	weight = 500,
})

local color = {
    ["white"] = Color(255, 255, 255),
}

local Grouadsp_37049 = Material('esc/Grouadsp_37049.png','noclamp smooth')
local Grouasdp_37046 = Material('esc/Grouasdp_37046.png','noclamp smooth')
local Grouasdp_37048 = Material('esc/Grouasdp_37048.png','noclamp smooth')
local Grouasdp_37051 = Material('esc/Grouasdp_37051.png','noclamp smooth')
local Grouasdp1231 = Material('esc/Grouasdp1231.png','noclamp smooth')
local Group_37050 = Material('esc/Group_37050.png','noclamp smooth')
local gmbcar = Material('esc/gmbcar.png','noclamp smooth')
local info = Material('esc/info.png','noclamp smooth')
local gmbpod = Material('esc/gmbpod.png','noclamp smooth')

local scrw, scrh = ScrW(), ScrH()

local buttons = {
    {"Вернуться в игру", 28, color["white"], function(self) local parent = self:GetParent():GetParent() parent:AlphaTo(0, 0.25, 0, function() parent:Remove() end) end},
    {"Настройки", 28, color["donate"], function(self) local parent = self:GetParent():GetParent() parent:AlphaTo(0, 0.25, 0, function() parent:Remove() gui.ActivateGameUI() RunConsoleCommand("gamemenucommand", "openoptionsdialog") end) end},   
    {"Меню игры", 28, color["white"], function(self) local parent = self:GetParent():GetParent() parent:AlphaTo(0, 0.25, 0, function() parent:Remove() gui.ActivateGameUI() end) end},
    {"Отключиться", 0, color["white"],function(self) RunConsoleCommand("disconnect") end},
}

local links = {
    {
        name = 'VK',
        func = function()
            gui.OpenURL('https://gambitrp.site/vk')
        end
    },
    {
        name = 'DISCORD',
        func = function()
            gui.OpenURL('https://gambitrp.site/discord')
        end
    },
    {
        name = 'ДОНАТ',
        func = function(self)
            local parent = self:GetParent():GetParent()
            parent:AlphaTo(0, 0.25, 0, function()
                RunConsoleCommand('donate')
            end)
        end
    },
    {
        name = 'ФОРУМ',
        func = function()
            gui.OpenURL('https://forum.gambitrp.site')
        end
    },
    {
        name = 'ПРАВИЛА',
        func = function()
            gui.OpenURL('https://gambitrp.site/rules')
        end
    },
}

local main = vgui.RegisterTable({
    Init = function(self)
        self:SetSize(scrw, scrh)
        self:MakePopup()

        local ply = LocalPlayer()
        self.name = ply:Name()

        surface.SetFont("VSDDB20")
        self.width = surface.GetTextSize(self.name)

        self.leftPanel = vgui.Create("DPanel", self)
        self.leftPanel:SetPos(weight(41),height(802))
        self.leftPanel:SetSize(weight(350),height(238))
        self.leftPanel.Paint = nil

        self.Connect = vgui.Create('DPanel',self)
        self.Connect:SetSize(weight(643),height(245))
        self.Connect:SetPos(weight(1253),height(24))
		local pCount = '∞'
        self.Connect.Paint = function(self,w,h)
            draw.RoundedBox(5,0,0,w,h,Color(0,0,0,200))
            draw.RoundedBox(5,0,0,w,h-height(44),Color(0,0,0,200))
            if game.GetIPAddress() == '212.22.93.215:27015' then
                draw.SimpleText('GAMBIT RP #2 МАШИНЫ','VSDM20',weight(13),height(213))
                surface.SetMaterial(gmbcar) 
                surface.SetDrawColor(255,255,255,255) 
                surface.DrawTexturedRect(0,0,w,h-height(40))
            else
                draw.SimpleText('GAMBIT RP #1 ПОДАРКИ','VSDM20',weight(13),height(213))
                surface.SetMaterial(gmbpod) 
                surface.SetDrawColor(255,255,255,255) 
                surface.DrawTexturedRect(0,0,w,h-height(40))
            end

            draw.RoundedBox(3,weight(383),height(205),weight(74),height(36),Color(0,0,0,100))
  
            draw.SimpleText(pCount..'/127','VSDM16',weight(430),height(215),Color(0,255,71),2)
            surface.SetMaterial(Grouasdp_37051) 
            surface.SetDrawColor(255,255,255,255) 
            surface.DrawTexturedRect(weight(440),height(217),weight(12),height(12))
        end

        self.ConnectBut = vgui.Create('DButton',self.Connect)
        self.ConnectBut:SetSize(weight(153),height(44))
        self.ConnectBut:SetPos(self.Connect:GetWide()-weight(153),height(201))
        self.ConnectBut:SetText('')
        self.ConnectBut.alpha = 0
        self.ConnectBut.Paint = function(self,w,h)
            if self:IsHovered() then
                self.alpha = Lerp(FrameTime()*7,self.alpha,0.5)
            else
                self.alpha = Lerp(FrameTime()*7,self.alpha,1)
            end
            draw.RoundedBoxEx(5,0,0,w,h,Color(1,116,222,255*self.alpha),false,false,false,true)
            draw.SimpleText('Подключиться','VSDM20',w/2,h/2,Color(255,255,255),1,1)
        end
        self.ConnectBut.DoClick = function(self,w,h)
            if game.GetIPAddress() == '212.22.93.215:27015' then
                permissions.AskToConnect("212.22.93.171:27015")
            else
                permissions.AskToConnect("212.22.93.215:27015")
            end
        end

        self.links = vgui.Create('DPanel',self)
        self.links:SetSize(weight(643),height(250))
        self.links:SetPos(weight(1253),height(295))
        self.links.Paint = function(self,w,h)
            draw.RoundedBox(5,0,0,w,h,Color(0,0,0,200))
            draw.RoundedBox(5,0,0,w,h-height(95),Color(0,0,0,200))
            surface.SetMaterial(info) 
            surface.SetDrawColor(255,255,255,255) 
            surface.DrawTexturedRect(0,0,w,h-height(95))
        end

        local space = 0
        for k,v in ipairs(links) do
            local button = vgui.Create('DButton',self.links)
            button:SetSize(weight(123),height(95))
            button:SetPos(space,height(155))
            button:SetText('')
            button.alpha = 0
            button.Paint = function(self,w,h)
                if self:IsHovered() then
                    self.alpha = Lerp(FrameTime()*7,self.alpha,0.5)
                else
                    self.alpha = Lerp(FrameTime()*7,self.alpha,1)
                end
                if k == 1 then
                    draw.RoundedBoxEx(5,0,0,w,h,Color(1,116,222,255*self.alpha),false,false,true,false)
                elseif k == 5 then
                    draw.RoundedBoxEx(5,0,0,w,h,Color(1,116,222,255*self.alpha),false,false,false,true)
                else
                    draw.RoundedBox(0,0,0,w,h,Color(1,116,222,255*self.alpha))
                end
                draw.SimpleText(v.name,'VSDDB20',w/2,h/2,Color(255,255,255),1,1)
            end
            button.DoClick = v.func
            space = space + weight(130)
        end

        for I = #buttons, 1, -1 do
            local info = buttons[I]
            local clr = info[3]
            
            local color_text = 255
            local color_btn = 0

            local button = vgui.Create("DButton", self.leftPanel)
            button:SetText("")
            button:SetHeight(height(37))
            button:Dock(BOTTOM)
            button:DockMargin(0, 0, 0, height(20))
		    button.alpha = 0
            button.DoClick = info[4]
            button.Paint = function(self, w, h)
                if self:IsHovered() then
                    self.alpha = Lerp(FrameTime()*7,self.alpha,1)
                else
                    self.alpha = Lerp(FrameTime()*7,self.alpha,0.5)
                end
                draw.SimpleText(info[1], "VSDM30", weight(44), h/2, Color(color_text, color_text, color_text, 255*self.alpha), 0, 1)
                if I == 1 then
                    surface.SetMaterial(Grouasdp_37046) 
                    surface.SetDrawColor(255,255,255,255*self.alpha) 
                    surface.DrawTexturedRect(0,height(5),weight(30),height(30))
                elseif I == 2 then
                    surface.SetMaterial(Grouasdp_37048) 
                    surface.SetDrawColor(255,255,255,255*self.alpha) 
                    surface.DrawTexturedRect(weight(2),height(8),weight(27),height(27))
                elseif I == 3 then
                    surface.SetMaterial(Grouadsp_37049) 
                    surface.SetDrawColor(255,255,255,255*self.alpha) 
                    surface.DrawTexturedRect(weight(2),height(8),weight(27),height(27))
                else
                    surface.SetMaterial(Grouasdp1231) 
                    surface.SetDrawColor(255,255,255,255*self.alpha) 
                    surface.DrawTexturedRect(weight(2),height(8),weight(27),height(27))
                end
            end
        end
    end,

    Paint = function(self, w, h)
        draw.RoundedBox(0,0,0,w,h,Color(24,25,27,200))
        surface.SetMaterial(Group_37050) 
        surface.SetDrawColor(255,255,255,255) 
        surface.DrawTexturedRect(weight(50),0,weight(358),height(281))
    end,
})

local panel

hook.Add("PreRender", "ESCMenu", function()
	if input.IsKeyDown(KEY_ESCAPE) and gui.IsGameUIVisible() then
			
		if ValidPanel(panel) then
            gui.HideGameUI()
			panel:Remove()
		else
            if LocalPlayer():GetNW2Bool('esc') then LocalPlayer():SetNW2Bool('esc',false) return end
			gui.HideGameUI()
			panel = vgui.CreateFromTable(main)
		end
	end
end)
--PATH addons/svnv_ru_lib/lua/autorun/client/cl_frame.lua:




-----------------------------------------
local PANEL = {}

function PANEL:Init()

      self:SetDraggable( false )
      self:ShowCloseButton( false )
      self:SetTitle( '' )

      self.title              = ''
      self.titlesize          = 18
      self.titlex             = self:GetWide() / 2
      self.titlecolor         = Color(255,255,255)

end
function PANEL:addclose()

      self.cb = vgui.Create( 'KButton', self )
      self.cb:SetPos(self:GetWide() - 51, 1)
      self.cb:SetSize( 50, 30 )

      self.cb.text                  = 'X'
      self.cb.textsize              = 15
      self.cb.btncolor              = Color(255,0,0,100)

      function self.cb:DoClick()

            if IsValid( self:GetParent() ) then
                  self:GetParent():Remove()
            end

      end

end

function PANEL:centerframe()
      local x           = ScrW() / 2 - ( self:GetWide() / 2 )
      local y           = ScrH() / 2 - ( self:GetTall() / 2 )
      self:SetPos( x, y )
end



function PANEL:Paint()
	self.alpha = Lerp( 0.1, 5, 1 )
    kydeslib.BlurMenu( self, 6, 11, 255 * self.alpha )
    kydeslib.DrawRect( 0, 0, self:GetWide(), 31, Color( 0, 0, 0, 140 ) )
    kydeslib.DrawRect( 0, self:GetTall() - 3, self:GetWide(), 3,Color( 100 + math.abs( math.sin( CurTime() * 2 ) * 105 ), 41, 45 ) or Color( 230, 41, 45 ) )
    draw.RoundedBox(0,0,0,self:GetWide(),self:GetTall(),Color(0,0,0,100))

    kydeslib.txt( self.title or '', self.titlesize, self.titlex, 5, self.titlecolor, 1 )
end

function PANEL:addClose()
      self:addclose()
end

function PANEL:centerFrame()
      self:centerframe()
end

vgui.Register("KFrame", PANEL, "DFrame")




local PANEL = {}
function PANEL:Init()

      self:SetText( '' )

      self.text               = ''
      self.textsize           = 15
      self.clickable          = true
      self.lerpanim           = 0
      self.btncolor           = Color( 150, 25, 25, 80 )

end
function PANEL:Paint(w,h)
	 local clr = self.btncolor

      if self.clickable then
            kydeslib.box( 0, 0, w, h, clr )

            if not self:IsHovered() then
                  self.lerpanim = Lerp( 0.05, self.lerpanim, 0 )
            else
                  self.lerpanim = Lerp( 0.05, self.lerpanim, 30 )
            end
      else
            kydeslib.box( 0, 0, w, h, Color( 150, 25, 25, 25 ) )
            self.lerpanim = Lerp( 0.1, self.lerpanim, 0 )
      end

      kydeslib.box( 0, 0, w, h, Color( 150, 150, 150, self.lerpanim ) )
      kydeslib.txt( self.text or '', self.textsize, w / 2, h / 2, nil, 1, 1 )
end

function PANEL:OnCursorEntered()

      if not self.clickable then return end
      surface.PlaySound( 'UI/buttonrollover.wav' )

end

vgui.Register("KButton", PANEL, "DButton")












local PANEL = {}

function PANEL:DockToFrame()
	local p = self:GetParent()
	self:SetPos(0, 0)
	self:SetSize(p:GetWide() - 10, p:GetTall() - (y + 5))
end
function PANEL:Paint()

	self.alpha = Lerp( 0.1, 5, 1 )
    kydeslib.BlurMenu( self, 6, 11, 255 * self.alpha )
    kydeslib.DrawRect( 0, 0, self:GetWide(), 31, Color( 0, 0, 0, 140 ) )
    --kydeslib.DrawRect( 0, self:GetTall() - 3, self:GetWide(), 3,Color( 100 + math.abs( math.sin( CurTime() * 2 ) * 105 ), 41, 45 ) or Color( 230, 41, 45 ) )
    draw.RoundedBox(0,0,0,self:GetWide(),self:GetTall(),Color(0,0,0,100))

end
vgui.Register('KPanel', PANEL, 'Panel')

















-----------------------------------------------------
local SCROLLBAR = {}
function SCROLLBAR:Init()
	self.parent = self:GetParent()

	self.scrollButton = vgui.Create('KPanel', self)
	self.scrollButton.OnMousePressed = function(s, mb)
		if (mb == MOUSE_LEFT and !self:GetParent().ShouldHideScrollbar) then
			local mx, my = s:CursorPos()

			s.scrolling = true
			s.mouseOffset = my
		end
	end
	self.scrollButton.OnMouseReleased = function(s, mb)
		if (mb == MOUSE_LEFT) then
			s.scrolling = false
			s.mouseOffset = nil
		end
	end

	self.height = 0
	self.addWidth = 0
end

function SCROLLBAR:Think()
	if (self.scrollButton.scrolling) then
		if (!input.IsMouseDown(MOUSE_LEFT)) then
			self.scrollButton:OnMouseReleased(MOUSE_LEFT)
			return
		end

		local mx, my = self.scrollButton:CursorPos()

		local diff = my - self.scrollButton.mouseOffset

		local maxOffset = self.parent:GetCanvas():GetTall() - self.parent:GetTall()

		local perc = (self.scrollButton.y + diff) / (self:GetTall() - self.height)
		self.parent.yOffset = math.Clamp(perc * maxOffset, 0, maxOffset)

		self.parent:InvalidateLayout()
	end

	local preSize = self.addWidth

	local mx, my = self:CursorPos()
	if ((mx > -8 and mx < self:GetWide() + 3 and my > self.scrollButton.y and my < self.scrollButton.y + self.height) or self.scrollButton.scrolling) then
		self.addWidth = math.Clamp(self.addWidth + (FrameTime() * 96), 0, 8)
	else
		self.addWidth = math.Clamp(self.addWidth - (FrameTime() * 96), 0, 8)
	end

	if (preSize != self.addWidth) then
		self:InvalidateLayout()
	end
end

function SCROLLBAR:PerformLayout()
	local maxOffset = self.parent:GetCanvas():GetTall() - self.parent:GetTall()

	self:SetSize(2 + self.addWidth, self.parent:GetTall())
	self:SetPos(self.parent:GetWide() - self:GetWide(), 0)

	self.heightRatio = self.parent:GetTall() / self.parent:GetCanvas():GetTall()
	self.height = math.Clamp(math.ceil(self.heightRatio * self.parent:GetTall()), 20, math.huge)

	self.scrollButton:SetSize(self:GetWide(), self.height)
	self.scrollButton:SetPos(0, math.Clamp((self.parent.yOffset / maxOffset), 0, 1) * (self:GetTall() - self.height))
end

function SCROLLBAR:Paint(w, h)
	--if (self:GetParent().ShouldHideScrollbar) then return end
	
	--derma.SkinHook('Paint', 'UIScrollBar', self, w, h)
end

function SCROLLBAR:OnMouseWheeled(delta)
	self.parent:OnMouseWheeled(delta)
end

vgui.Register('KScrollBar', SCROLLBAR, 'DPanel')


local SCROLLABLE = {}
function SCROLLABLE:Init()
	self.contentContainer = vgui.Create('KPanel', self)
	self.scrollBar = vgui.Create('KScrollBar', self)

	self.yOffset = 0
	self.ySpeed = 0
	self.scrollSize = 4
	self.SpaceTop = 0
	self.Padding = 0
	
	function self.contentContainer:OnChildRemoved(child)		
		self:GetParent():PerformLayout()
	end
end

function SCROLLABLE:Reset()
	self:GetCanvas():Clear(true)
	self.yOffset = 0
	self.ySpeed = 0
	self.scrollSize = 1

	self:PerformLayout()
end

function SCROLLABLE:AddItem(child)
	child:SetParent(self:GetCanvas())
	self:PerformLayout()
end

function SCROLLABLE:SetSpacing(i)
	self.SpaceTop = i
end

function SCROLLABLE:SetPadding(i)
	self.Padding = i
end

function SCROLLABLE:GetCanvas()
	return self.contentContainer
end

function SCROLLABLE:SetScrollSize(int)
	self.scrollSize = int
end

function SCROLLABLE:ScrollTo(y)
	self.yOffset = y

	self:InvalidateLayout()
end

function SCROLLABLE:OnMouseWheeled(delta)
	if ((delta > 0 and self.ySpeed < 0) or (delta < 0 and self.ySpeed > 0)) then
		self.ySpeed = 0
	else
		self.ySpeed = self.ySpeed + (delta * self.scrollSize)
	end

	self:PerformLayout()
end

function SCROLLABLE:SetOffset(offSet)
	local maxOffset = (self:GetCanvas():GetTall() - self:GetTall())
	if (maxOffset < 0) then maxOffset = 0 end

	self.yOffset = math.Clamp(offSet, 0, maxOffset)

	self:PerformLayout()

	if (self.yOffset == 0 or self.yOffset == maxOffset) then return true end
end

function SCROLLABLE:Think()
	if (self.ySpeed != 0) then
		if (self:SetOffset(self.yOffset - self.ySpeed)) then
			self.ySpeed = 0
		else
			if (self.ySpeed < 0) then
				self.ySpeed = math.Clamp(self.ySpeed + (FrameTime() * self.scrollSize * 4), self.ySpeed, 0)
			else
				self.ySpeed = math.Clamp(self.ySpeed - (FrameTime() * self.scrollSize * 4), 0, self.ySpeed)
			end
		end
	end
end

function SCROLLABLE:PerformLayout()
	local canvas = self:GetCanvas()

	if (canvas:GetWide() != self:GetWide()) then
		canvas:SetWide(self:GetWide())
	end

	local y = 0
	local lastChild
	for k, v in ipairs(canvas:GetChildren()) do
		local childY = y + self.SpaceTop
		if (v.x != self.Padding or v.y != childY) then
			v:SetPos(math.max(0, self.Padding), y + self.SpaceTop)
		end
		if (v:GetWide() != self:GetWide() - self.Padding * 2) then
			v:SetWide(math.min(self:GetWide(), self:GetWide() - self.Padding * 2))
		end

		y = v.y + v:GetTall() + self.SpaceTop + self.Padding
		lastChild = v
	end
	y = lastChild and lastChild.y + lastChild:GetTall() or y
	if (canvas:GetTall() != y) then
		canvas:SetTall(y)
	end

	if (canvas:GetTall() <= self:GetTall() and self.scrollBar:IsVisible()) then
		canvas:SetTall(self:GetTall())

		self.scrollBar:SetVisible(false)
	elseif (canvas:GetTall() > self:GetTall() and !self.scrollBar:IsVisible()) then
		self.scrollBar:SetVisible(true)
	end

	local maxOffset = (self:GetCanvas():GetTall() - self:GetTall())

	if (self.yOffset > maxOffset) then
		self.yOffset = maxOffset
	end

	if (self.yOffset < 0) then
		self.yOffset = 0
	end
	
	if (canvas.x != 0 or canvas.y != -self.yOffset) then
		canvas:SetPos(0, -self.yOffset)
		self.scrollBar:InvalidateLayout()
	end
end

function SCROLLABLE:IsAtMaxOffset()
	local maxOffset = math.Clamp(self:GetCanvas():GetTall() - self:GetTall(), 0, math.huge)
	return self.yOffset == maxOffset
end

function SCROLLABLE:Paint(w, h)
end

function SCROLLABLE:HideScrollbar(bool)
	self.ShouldHideScrollbar = bool
end

function SCROLLABLE:DockToFrame()
	local p = self:GetParent()
	local x, y = p:GetDockPos()
	self:SetPos(x, y)
	self:SetSize(p:GetWide() - 10, p:GetTall() - (y + 5))
end

vgui.Register('KScroll', SCROLLABLE, 'DPanel')

concommand.Add( "mypos", function( ply ) print('Vector('..math.Round(ply:GetPos().x)..', '..math.Round(ply:GetPos().y)..', '..math.Round(ply:GetPos().z)..')') end)






--PATH addons/111mod/lua/autorun/client/cl_fs.lua:
local blur = Material("pp/blurscreen")
function framework(panel, amount)
	local x, y = panel:LocalToScreen(0, 0)
	local scrW, scrH = ScrW(), ScrH()

	surface.SetDrawColor(255, 255, 255)
	surface.SetMaterial(blur)
	for i = 1, 3 do
		blur:SetFloat("$blur", (i / 3) * (amount or 6))
		blur:Recompute()
		render.UpdateScreenEffectTexture()
		surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
	end
end

function frametext(text, font, x, y, color, x_a, y_a, color_shadow)
    color_shadow = color_shadow or Color(0, 0, 0)
    draw.SimpleText(text, font, x + 1, y + 1, color_shadow, x_a, y_a)
    local w,h = draw.SimpleText(text, font, x, y, color, x_a, y_a)
    return w,h
end

surface.CreateFont("travka.btn", {
    font = "Roboto",
    size = ScreenScale(8),
    weight = 1000,
    extended = true
})


local btn = {
    {
    n = "Надеть костюм",
    net = "giveskin",
    },
    {
    n = "Снять костюм",
    net = "removeskin",
    }
}
function opendonateskin()
    local dframe = vgui.Create("DFrame")
    dframe:SetSize(ScrW() * .15, ScrH() * .140)
    dframe:Center()
    dframe:SetTitle("")
    dframe:MakePopup()
    dframe:SetDraggable(false)
    dframe:ShowCloseButton(false)
    dframe:SetAlpha(0)
    dframe:AlphaTo(255, 0.2)
    local tallbal = ScrH() * .4 * .067
    dframe.Paint = function(self, w, h)
        framework(self, 5)
        draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 150))
        draw.RoundedBox(0, 0, 0, w, tallbal, Color(0, 0, 0, 200))
        draw.RoundedBox(0, 0, h - tallbal, w, tallbal, Color(0, 0, 0, 200))
        frametext("Меню нано костюма", "travka.btn", w * .5, tallbal * .5, Color(255, 255, 255), 1, 1)
    end
    
    local main_hide = vgui.Create("DButton", dframe)
    main_hide:SetSize(tallbal - 4, tallbal - 4)
    main_hide:SetPos(ScrW() * .15 - tallbal + 2, 2)
    main_hide:SetText("")
    main_hide.Paint = function(this, w, h)
        if (this.Depressed or this.m_bSelected) then
            draw.RoundedBox(0, 0, 0, w, h, Color(255, 155, 55, 150))
        elseif (this.Hovered) then
            draw.RoundedBox(0, 0, 0, w, h, Color(255, 155, 55, 75))
        else
            draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 150))
        end
    
        frametext("X", "travka.btn", w * .5, h * .5, Color(255, 255, 255), 1, 1)
    end
    main_hide.DoClick = function(self)
        surface.PlaySound("garrysmod/ui_click.wav")
    
        dframe:AlphaTo(0, 0.2, 0, function()
            if IsValid(dframe) then
                dframe:Remove()
            end
        end)
    end
    
    local Scroll = vgui.Create( "DScrollPanel", dframe )
    Scroll:Dock( FILL )
    
    local List = vgui.Create( "DIconLayout", Scroll )
    List:Dock( FILL )
    List:SetSpaceY( 5 )
    List:SetSpaceX( 5 )
    List.Paint = function(self,w,h)
        draw.RoundedBox(0,0,0,w,h,Color(35,64,100,170))
    end
    for k,v in pairs(btn) do
        local ListItem = Scroll:Add("DButton")
        ListItem:Dock(TOP)
        ListItem:SetTall(40)
        ListItem:DockMargin(5, 2.5, 5, 0)
        ListItem:SetText("")
        ListItem.Paint = function(this, w, h)
    	   if (this.Depressed or this.m_bSelected) then
        	   draw.RoundedBox(0, 0, 0, w, h, Color(255, 155, 55, 150))
    	   elseif (this.Hovered) then
        	   draw.RoundedBox(0, 0, 0, w, h, Color(255, 155, 55, 75))
    	   else
        	   draw.RoundedBox(0, 0, 0, w, h, Color(0, 0, 0, 150))
    	   end
    	   frametext(v.n, "travka.btn", w * .5, h * .5, Color(255, 255, 255), 1, 1)
        end
        ListItem.DoClick = function()
            if ply:IsSuperAdmin() then
                net.Start(v.net)
                net.SendToServer()
            end
        end
    end
end

concommand.Add('openskin',function(ply)
    if ply:IsSuperAdmin() then
        opendonateskin()
    else
        ply:ChatPrint('Вы не имеете доступа к меню')
    end
end)

--PATH addons/donate3/lua/autorun/client/cl_shop.lua:
local _b = ScrW()
local function ss(a)
	return a / 1920 * _b
end

hook.Add("OnScreenSizeChanged", "MRPDM", function()
	_b = ScrW()
end)

local function CheckLetter(String)
    local TableLetters = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "0"}
    local Accept = false 
    for k, v in pairs(TableLetters) do 
        if v == string.upper(String) then 
            Accept = true 
        end 
    end 
    return Accept 
end 

local blur = Material("pp/blurscreen")	
local function blurpanel(panel, amount)
    local x, y = panel:LocalToScreen(0, 0)
    local scrW, scrH = ScrW(), ScrH()
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(blur)
    for i = 1, 3 do
        blur:SetFloat("$blur", (i / 3) * (amount or 6))
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
    end
end

local surface_CreateFont = surface.CreateFont
local net_Receive = net.Receive
local text = draw.SimpleText
local box = draw.RoundedBox
local ui = vgui.Create
local net_Start = net.Start
local net_WriteInt = net.WriteInt
local net_SendToServer = net.SendToServer
local net_ReadString = net.ReadString
local net_ReadInt = net.ReadInt
local net_WriteString = net.WriteString
local w,h = ScrW(),ScrH()

local buy_12 = Material('don/buy_12.png','noclamp smooth')
local Group = Material('don/Group.png','noclamp smooth')
local Group_51 = Material('don/Group_51.png','noclamp smooth')
local Group_52 = Material('don/Group_52.png','noclamp smooth')
local Rectangle_180 = Material('don/Rectangle_180.png','noclamp smooth')
local Veasdwdasactor = Material('don/Veasdwdasactor.png','noclamp smooth')
local Vectors = Material('don/Vector.png','noclamp smooth')
local Vectsedor = Material('don/Vectsedor.png','noclamp smooth')
local vectorDonate = Material('don/vectorDonate.png','noclamp smooth')
local col = {
    white = Color(255,255,255),
    black = Color(0,0,0),
    back = Color(45,45,45,253),
}




--[[======================================================================
                              [ FONTS ]        
======================================================================]]--

surface.CreateFont('MM_14', {
    font = 'Montserrat Medium', 
    size = height(14), 
    weight = 500, 
    extended = true
})

surface_CreateFont('MM_18', {
    font = 'VK Sans Display Medium', 
    size = ss(18), 
    weight = 500, 
    extended = true
})
surface_CreateFont('MM_20', {
    font = 'VK Sans Display Medium', 
    size = ss(20), 
    weight = 500, 
    extended = true
})
surface_CreateFont('MM_24', {
    font = 'VK Sans Display Medium', 
    size = ss(24), 
    weight = 500, 
    extended = true
})
surface_CreateFont('MSB_16', {
    font = 'VK Sans Display DemiBold', 
    size = ss(16), 
    weight = 500, 
    extended = true
})
surface_CreateFont('MSB_20', {
    font = 'VK Sans Display DemiBold', 
    size = ss(20), 
    weight = 600, 
    extended = true
})
surface_CreateFont('MM_16', {
    font = 'VK Sans Display Medium', 
    size = ss(16), 
    weight = 500, 
    extended = true
})
surface_CreateFont("MRPDM::ItemCost", {
	font = "VK Sans Display Bold",
	size = ss(21),
	extended = true
})
surface_CreateFont("MRPDM::UpPanel", {
	font = "VK Sans Display DemiBold",
	size = ss(25),
	extended = true
})
surface_CreateFont("MRPDM::ItemOldCost", {
	font = "VK Sans Display Medium",
	size = ss(21),
	extended = true
})

net_Receive("ray shopMenu", function()
    local ply = LocalPlayer()
    local selectsed
    local selected = 1
    local a, b, c, d = ScrW() * 0.8, ScrH() * 0.9, net_ReadInt(32), nil
    local income, buy = net_ReadString(), net_ReadString()
    local selbut = 0

    local ePanel = ui('DFrame')
    ePanel:SetSize(ss(980), ss(606))
    ePanel:Center()
    ePanel:MakePopup()
    ePanel:ShowCloseButton(false)
    ePanel:SetTitle('')
    ePanel:SetAlpha(0)
    ePanel:AlphaTo(255,0.2,0)
    ePanel.Paint = function(s, w, h)
        box(16,0,0,w,h,col.back)
    end
    function ePanel:Think()
        if input.IsKeyDown( KEY_ESCAPE ) then
            ply:SetNW2Bool('esc',true)
            gui.HideGameUI()
            ePanel:AlphaTo(0,0.2,0,function()
                ePanel:Remove()
            end)
        end
    end

    local close = ui('DButton',ePanel)
    close:SetSize(weight(200),height(24))
    close:SetPos(weight(980-227),height(570))
    close:SetText('')
    close.Paint = function(self,w,h)
        text('Нажмите ESC для выхода','MM_20',w/2,h/2,col.white,1,1)
    end
    close.DoClick = function()
        ePanel:AlphaTo(0,0.2,0,function()
            ePanel:Remove()
        end)
    end

    local header = ui('DPanel',ePanel)
    header:SetSize(ss(984),ss(84))
    header:SetPos(ss(-4),0)
    header.Paint = function(self,w,h)
        surface.SetMaterial(Rectangle_180) 
        surface.SetDrawColor(255,255,255)
        surface.DrawTexturedRect(weight(2),0,w,h)
    end
    surface.SetFont('MSB_20')
    local wPanel,hPanel = surface.GetTextSize(string.Comma(c) .. ' ₽')

    ballans = ui('DPanel',header)
    ballans:SetSize(wPanel+ss(20),ss(48))
    ballans:SetPos(ss(980)-(wPanel+ss(20))-ss(229),ss(18))
    ballans.Paint = function(self,w,h)
        box(9,0,0,w,h,Color(22,165,96))
        box(9,ss(2),ss(2),w-ss(4),h-ss(4),Color(44,44,44))
        text(string.Comma(c) ..' ₽','MSB_20',w/2,h/2,col.white,1,1)
    end

    local function n(a)
        for b, c in pairs(ray_shop.data) do
            if c.Name == a then return b end
        end
    end

    local function buyed(v)
        local frame = ui('DFrame')
        frame:SetSize(w,h)
        frame:MakePopup()
        frame:SetTitle('')
        frame:ShowCloseButton(false)
        frame:SetDraggable(false)
        frame.Paint = function(self,w,h)
            blurpanel(self,10)
            box(0,0,0,w,h,Color(0,0,0,150))
        end
        local mainPanel = ui('DPanel',frame)
        mainPanel:SetSize(ss(367),ss(371))
        mainPanel:Center()
        mainPanel.Paint = function(self,w,h)
            box(16,weight(12),height(22),ss(359),ss(345),col.back)
            draw.RoundedBoxEx(12,0,0,weight(77),height(38),Color(111,50,50),true,true,true,false)
            text('-50%','MSB_16',weight(19),height(9))
        end
        
        local close = ui('DButton', mainPanel)
        close:SetSize( ss(125), ss(51) )
        close:SetPos( ss(10+228), ss(22+285) )
        close:SetText('')
        close.Paint = function(self, w,h)
            box(15,0,0,w,h,Color(120,0,0))
            if self.Hovered then
                color = col.black
            else
                color = col.white
            end
            text('Отмена','MM_20',w/2,h/2,color,1,1)
        end
        close.DoClick = function() frame:Remove() end

        local modelpanel = ui('DPanel',mainPanel)
        modelpanel:SetSize(ss(347),ss(252))
        modelpanel:SetPos(ss(10+6),ss(22+25))
        modelpanel.Paint = function(self,w,h)
            box(16,0,0,w,h,Color(38,37,37))
            surface.SetFont('MM_20')
            local namex,namey = surface.GetTextSize(v.Name)
            local pricex,pricey = surface.GetTextSize(v.Price .. '')
            local color
            if v.color then
                color = v.color
            else
                color = Color(194,103,255)
            end
            box(12,weight(8),height(6),namex+weight(14),height(38),color)
            text(v.Name,'MM_20',ss(15),ss(15),col.black)

            box(12,namex+weight(13+14),height(6),pricex+weight(28),height(38),Color(165,108,22))
            text(v.Price .. ' ₽','MM_20',namex+weight(13+14+7),ss(15))
        end
        if v.category == 'Привилегии' or v.category == 'Остальное' then
            local richtext = ui( "RichText", modelpanel )
            richtext:SetSize(ss(344),ss(185))
            richtext:SetPos(ss(11),ss(56))
            richtext:AppendText(v.Description)
            function richtext:PerformLayout()
                self:SetFontInternal( "MM_16" )
                self:SetFGColor( color_white )
            end
        elseif v.category == 'Оружие' then
            local scrols = ui('DScrollPanel', modelpanel)
            scrols:SetPos(ss(12),ss(120))
            scrols:SetSize(ss(342),ss(208))
            scrols:GetVBar():SetWide(2)
            local bar = scrols.VBar
            bar:SetHideButtons(true)
            bar.Paint = nil
            bar.btnGrip.Paint = function(this, w, h)
                box(0, 0, 0, w, h, Color(1,116,222))
            end

            local dpanel = ui('DPanel',modelpanel)
            dpanel:SetPos(0,0)
            dpanel:SetSize(ss(342),ss(208))
            dpanel.Paint = function(self,w,h)
            end

            local model = vgui.Create('SpawnIcon', dpanel)
            model:SetSize(weight(154), height(154))
            model:SetPos(dpanel:GetWide() / 2 - height(154)/2,  dpanel:GetTall()/2-height(154)/2+height(10))
            model:SetTooltip()
            model:SetModel(v.model)
            model:SetDisabled(true)
            model:SetMouseInputEnabled(false)
            function model:LayoutEntity()
                return false
            end
        
            local richtext = ui( "DLabel", scrols )
            richtext:SetSize(ss(347),ss(185))
            richtext:SetPos(0,0)
            richtext:SetText(v.Description)
            richtext:SetFont( "MM_16" )
            -- function richtext:PerformLayout()
            --     self:SetFontInternal( "MM_16" )
            --     self:SetFGColor( color_white )
            -- end
        end
        local buyed = ui('DButton',mainPanel)
        buyed:SetSize(ss(214),ss(51))
        buyed:SetPos(ss(10+6),ss(22+285))
        buyed:SetText('')
        buyed.Paint = function(self,w,h)
            box(16,0,0,w,h,Color(38,37,37))
            text('Купить','MSB_16',w/2,h/2,col.white,1,1)
            surface.SetMaterial(buy_12) 
            surface.SetDrawColor(22,165,96)
            surface.DrawTexturedRect(0,0,w,h)
            if self.Hovered then
                color = col.black
            else
                color = col.white
            end
            text('Купить','MM_20',w/2,h/2,color,1,1)
        end
        buyed.DoClick = function()
            frame:Remove()
            sound.Play(Sound("garrysmod/save_load1.wav"), ply:GetPos(), 60)
            net_Start"ray purchaseItem"
            net_WriteInt(n(v.Name), 32)
            net_SendToServer()
        end
    end

    net.Receive('ray purchaseItem',function()
        c = net.ReadUInt(32)
        income, buy = net_ReadString(), net_ReadString()
    end)

    local function drawCategory(cat)
        if IsValid(sc) then 
            sc:Remove() 
        end
        if IsValid(weaponPanel) then weaponPanel:Remove() end
        if IsValid(profilePanel) then profilePanel:Remove() selectsed = 0 end
        sc = ui('DScrollPanel', ePanel)
        sc:SetSize(ss(949),ss(458))
        sc:SetPos(ss(21),ss(100))
        sc:GetVBar():SetWide(3)
        local bar = sc.VBar
        bar:SetHideButtons(true)
        bar.Paint = nil
        bar.btnGrip.Paint = function(this, w, h)
            box(0, 0, 0, w, h, Color(1,116,222))
        end

        local scr = ui('DIconLayout', sc)
        scr:Dock(FILL)
        scr:SetSpaceX(ss(19))
        scr:SetSpaceY(ss(19))
        scr.PaintOver = function(self,w,h)
        end

        for k, v in pairs(ray_shop.data) do
            if cat ~= v.category then continue end
            local items = ui('DButton',scr)
            items:SetSize(ss(220),ss(220))
            items:SetText('')
            if v.wep then
                local model_panel = ui("DModelPanel", items)
                model_panel:SetSize(ss(266),ss(171))
                model_panel:SetPos(ss(0),ss(29))
                model_panel:SetModel(v.model)
                
                local mn, mx = model_panel.Entity:GetRenderBounds()
                local size = 10
                size = math.max(size, math.abs(mn.x) + math.abs(mx.x))
                size = math.max(size, math.abs(mn.y) + math.abs(mx.y))
                size = math.max(size, math.abs(mn.z) + math.abs(mx.z))
                if v.Name == 'Армор кит' then
                    model_panel:SetFOV(80)
                else
                    model_panel:SetFOV(55)
                end
                model_panel:SetCamPos(Vector(size, size, size))
                model_panel:SetLookAt((mn + mx) * 0.4)
                model_panel.Angles = Angle(0,0,0)
                function model_panel:LayoutEntity( ent ) return end

                local items = ui('DButton',items)
                items:SetSize(ss(220),ss(229))
                items:SetText('')
                items.Paint = function(self,w,h) end
                items.DoClick = function()
                    buyed(v)
                end
            end
            items.Paint = function(self,w,h)
                box(10,0,0,w,h,Color(38,37,37))

                if v.category == 'Привилегии' then
                    if v.mat then
                        surface.SetMaterial(v.mat) 
                        surface.SetDrawColor(255,255,255)
                        surface.DrawTexturedRect(0,0,w,h)
                    end
                end

                if v.category == 'Остальное' then
                    if v.mat then
                        surface.SetMaterial(v.mat) 
                        surface.SetDrawColor(255,255,255)
                        surface.DrawTexturedRect(0,0,w,h)
                    end
                end

                surface.SetFont('MRPDM::ItemCost')
                local x,y = surface.GetTextSize('30 ДНЕЙ')
                
                if v.otime then
                    surface.SetDrawColor( 229,185,0 )
                    surface.DrawOutlinedRect( ss(69), ss(9), x+ss(9),y+ss(4), ss(2))
                    text('30 ДНЕЙ','MRPDM::ItemCost',w/2,ss(11),Color(229,185,0),1,0)
                else
                    if v.category == 'Оружие' then
                        text(v.Name,'MRPDM::ItemCost',w/2,ss(11),Color(229,185,0),1,0)
                    else
                        if cat == 'Привилегии' then
                            text('НАВСЕГДА','MRPDM::ItemCost',w/2,ss(11),Color(229,185,0),1,0)
                        end
                    end
                end

                surface.SetFont('MRPDM::ItemCost')
                local x,y = surface.GetTextSize(v.Price .. ' ₽')    
                if cat == 'Оружие' or cat == 'Привилегии' then
                    box(0,w/2-x/2-ss(5),ss(172),x+ss(10),y+ss(5),Color(229,185,0))
                    text(v.Price .. ' ₽','MRPDM::ItemCost',w/2,ss(173),col.black,1,0)
                else
                    box(0,w/2-x/2-ss(5),ss(10),x+ss(10),y+ss(5),Color(229,185,0))
                    text(v.Price .. ' ₽','MRPDM::ItemCost',w/2,ss(12),col.black,1,0)   
                end
                surface.SetFont('MRPDM::ItemOldCost')
                local x,y = surface.GetTextSize(v.Price*2 .. ' ₽')    
                if cat == 'Оружие' or cat == 'Привилегии' then
                    text(v.Price*2 .. '₽','MRPDM::ItemOldCost',w/2,ss(199),Color(229,185,0),1,0)
                    box(0,w/2-x/2,ss(210),x,ss(2),col.white)
                else
                    text(v.Price*2 .. '₽','MRPDM::ItemOldCost',w/2,ss(40),Color(229,185,0),1,0)
                    box(0,w/2-x/2,ss(50),x,ss(2),col.white)    
                end
            end
            items.DoClick = function()
                buyed(v)
            end
            local function openInfo()
                local tf = false
                local pans = ui('Panel',items)
                pans:SetSize(weight(220),height(229))
                pans:SetAlpha(0)
                pans:AlphaTo(255,0.4)
                pans.Hovered = false
                pans.Paint = function(self,w,h)
                    box(5,0,0,w,h,Color(31,31,31))
                end
                local richtext = ui( "RichText", pans )
                richtext:SetSize(ss(217),ss(200))
                richtext:SetPos(ss(10),ss(32))
                richtext:AppendText(v.Description)
                richtext.Hovered = false
                function richtext:PerformLayout()
                    self:SetFontInternal( "MM_14" )
                    self:SetFGColor( color_white )
                end

                local close = vgui.Create('DButton',pans)
                close:SetSize(weight(20),height(20))
                close:SetPos(weight(190),height(7))
                close:SetText('')
                close.Paint = function(self,w,h)
                    surface.SetMaterial(vectorDonate)
                    surface.SetDrawColor(255,255,255)
                    surface.DrawTexturedRect(0,0,w,h)
                end
                pans.Think = function()
                    if richtext:IsHovered() then
                        richtext.Hovered = true
                    end
                    if pans:IsHovered() then
                        pans.Hovered = true
                    end
                    if pans.Hovered == false and close.Hovered == false and richtext.Hovered == false and not tf then
                        tf = true
                        pans:AlphaTo(0,0.4,0,function()
                            pans:Remove()
                        end)
                    end
                end
                pans.OnCursorExited = function()
                    if richtext:IsHovered() then return end
                    pans:AlphaTo(0,0.4,0,function()
                        pans:Remove()
                    end)
                end
            end
            if v.category ~= 'Оружие' then
                local info = vgui.Create('DButton',items)
                info:SetSize(weight(20),height(20))
                info:SetPos(weight(190),height(7))
                info:SetText('')
                info.Paint = function(self,w,h)
                    surface.SetMaterial(vectorDonate)
                    surface.SetDrawColor(180,180,180)
                    surface.DrawTexturedRect(0,0,w,h)
                end
                info.OnCursorEntered = function()
                    openInfo()
                end
            end
        end
    end

    local function donatePay()
        local frame = ui('DFrame')
        frame:SetSize(w,h)
        frame:MakePopup()
        frame:SetTitle('')
        frame:ShowCloseButton(false)
        frame:SetDraggable(false)
        frame.Paint = function(self,w,h)
            blurpanel(self,10)
            box(0,0,0,w,h,Color(0,0,0,150))
        end
        local mainPanel = ui('DPanel',frame)
        mainPanel:SetSize(ss(359),ss(201))
        mainPanel:Center()
        mainPanel.Paint = function(self,w,h)
            box(16,0,0,w,h,col.back)
            text('Пополнение баланса','MSB_16',w/2,ss(9),col.white,1,0)
            text('Введите сумму пополнения','MM_16',ss(14),ss(49))
        end
        
        local close = ui('DButton', mainPanel)
        close:SetSize( ss(20), ss(20) )
        close:SetPos( mainPanel:GetWide() - ss(30), ss(9) )
        close:SetText('')
        close.Paint = function(self, w,h)
            local color = col.white
            if self.Hovered then
                color = Color(255,255,255,125)
            end
    
            text( '✕', 'MM_20', w/2, h/2, color, 1, 1)
        end
        close.DoClick = function(self,w,h)
            frame:Remove()
        end

        local header = ui('DTextEntry',mainPanel)
	    header:SetSize(ss(331),ss(45))
        header:SetPos(ss(14),ss(78))
        header:SetValue('Сумма')
        header:SetDrawLanguageID(false)
        header:SetFont('MM_16')
        function header:OnMousePressed() 
            header:SetValue("")
        end
        header.AllowInput = function(self, stringValue)
            if not CheckLetter(stringValue) then 
                return true
            end
        end 
        header.Paint = function(self,w,h)
            box(5,0,0,w,h,Color(38,37,37))
            self:DrawTextEntryText(Color(255,255,255,104), Color(121,121,121), color_white)
        end
        local pay = ui('DButton',mainPanel)
        pay:SetSize(ss(331),ss(50))
        pay:SetPos(ss(14),ss(134))
        pay:SetText('')
        pay.alpha = 0
        pay.Paint = function(self,w,h)
            if self:IsHovered() then
                self.alpha = Lerp(FrameTime()*10,self.alpha,0.7)
            else
                self.alpha = Lerp(FrameTime()*7,self.alpha,1)
            end
            box(5,0,0,w,h,Color(22,165,96,255*self.alpha))
            text('Оплатить','MM_18',w/2,h/2,Color(255,255,255,255*self.alpha),1,1)
        end
        local function encode(str)
            str = string.gsub(str, "\r?\n", "\r\n")
            str = string.gsub(str, "([^%w%-%.%_%~ ])", function(c) return string.format("%%%02X", string.byte(c)) end)
            str = string.gsub(str, " ", "+")
            
            return str
        end
        pay.DoClick = function()
            local val = header:GetValue()
            if val == 'Сумма' or val == '' then
                return
            end
            local comment = 'ПОПОЛНЕНИЕ-СЧЕТА-НА-СЕРВЕРЕ-GambitRP{"Server":"GambitRP#000' .. "Gravity1" .. '","SteamID64":"'
            comment = encode(comment) .. tostring(ply:SteamID64()) .. encode('"}')
            local summa = val + val / 100 * 5
            local asumma, bsumma = math.modf(summa)
            bsumma = bsumma * 100
            gui.OpenURL("https://gambitrp.site/oplata/?sid=" .. ply:SteamID() .. "&sum=" .. val)
        end
    end

    local function CreateDermaMenu(x,w,h,texts)
        if IsValid(dpanelrf) then dpanelrf:Remove() end
        dpanelrf = ui('DPanel',ePanel)
        dpanelrf:SetSize(w,h)
        dpanelrf:SetPos(x,0)
        dpanelrf.Paint = function(self,w,h)
            box(3,0,0,w,h,Color(38,37,37))
            text(texts,'MM_18',w/2,h/2,col.white,1,1)
        end
    end
    
    local function RemoveDermaMenu()
        if IsValid(dpanelrf) then dpanelrf:Remove() end
    end

    local gbut = ui('DButton', ePanel)
    gbut:SetPos(ss(980)-ss(229)-wPanel-ss(25+48), ss(18))
    gbut:SetSize(ss(43),ss(48))
    gbut:SetText('')
    gbut.alpha = 0
    gbut.Paint = function(self,w,h)
        if self:IsHovered() then
            self.alpha = Lerp(FrameTime()*7,self.alpha,0.6)
        else
            self.alpha = Lerp(FrameTime()*7,self.alpha,1)
        end
        box(9,0,0,w,h,Color(22,165,96,255*self.alpha))
        surface.SetMaterial(Group_51) 
        surface.SetDrawColor(50,50,50)
        surface.DrawTexturedRect(ss(10),ss(12),ss(23),ss(24))
    end
    gbut.DoClick = function()
        donatePay()
    end

    local i = ui('DButton', ePanel)
    i:SetPos(ss(765), ss(10))
    i:SetSize(ss(56),ss(62))
    i:SetText('')
    i.alpha = 0
    i.Paint = function(self,w,h)
        if self:IsHovered() then
            self.alpha = Lerp(FrameTime()*7,self.alpha,0.6)
        else
            self.alpha = Lerp(FrameTime()*7,self.alpha,1)
        end
        box(9,0,0,w,h,Color(254,182,41,255*self.alpha))
        surface.SetMaterial(Group) 
        surface.SetDrawColor(50,50,50)
        surface.DrawTexturedRect(ss(12),ss(16),ss(32),ss(31))
    end
    i.DoClick = function()
        net_Start("Check_Pay")
        net_SendToServer(ply)
    end
    i.OnCursorEntered = function()
        local x,y = gui.MousePos()
        CreateDermaMenu(ss(609),ss(154),ss(29),'Обновить баланс')
    end
    i.OnCursorExited = function()
        RemoveDermaMenu()
    end

    local function WeaponMenu()
        if IsValid(weaponPanel) then return end
        if IsValid(sc) then sc:Remove() end
        if IsValid(profilePanel) then profilePanel:Remove() selectsed = 0 end

        weaponPanel = ui('DPanel',ePanel)
        weaponPanel:SetSize(ss(927),ss(500))
        weaponPanel:SetPos(ss(24),ss(75))
        weaponPanel.Paint = function(self,w,h)
            text('Название оружия','MM_18',ss(7),ss(26))
            text('Статус','MM_18',w/2,ss(26),col.white,1,0)
            text('Включить/выключить','MM_18',w-ss(24),ss(26),col.white,2,0)
        end
    
   GunsOnP = {
            ["Оружие навсегда"] = {
                ["p90"] = {
                    name = "P90",
                    color = Color(130,210,255),
                },
				["mp5"] = {
                    name = "MP5",
                    color = Color(194,103,255),
                },
				["upm"] = {
                    name = "UMP",
                    color = Color(147,255,147),
                },
				["tmp"] = {
                    name = "TMP",
                    color = Color(147,255,147),
                },
                ["mac10"] = {
                    name = "MAC-10",
                    color = Color(147,255,147),
                },
                ["deagle"] = {
                    name = "Desert Eagle",
                    color = Color(147,255,147),
                },
                ["fiveseven"] = {
                    name = "Five-Seven",
                    color = Color(147,255,147),
                },
                ["glock"] = {
                    name = "Glock",
                    color = Color(130,210,255),
                },
                ["p228"] = {
                    name = "P228",
                    color = Color(147,255,147),
                },
                ["usp"] = {
                    name = "USP-S",
                    color = Color(147,255,147),
                },
                ["revolver"] = {
                    name = "Револьвер",
                    color = Color(147,255,147),
                },
                ["ak47"] = {
                    name = "AK-47",
                    color = Color(194,103,255),
                },
                ["m4a1"] = {
                    name = "M4A1",
                    color = Color(194,103,255),
                },
                ["awp"] = {
                    name = "AWP",
                    color = Color(194,103,255),
                },
                ["famas"] = {
                    name = "FAMAS",
                    color = Color(130,210,255),
                },
                ["galil"] = {
                    name = "Galil",
                    color = Color(130,210,255),
                },
                ["m249"] = {
                    name = "M249",
                    color = Color(255,217,102),
                },
                ["m3super90"] = {
                    name = "M3Super90",
                    color = Color(130,210,255),
                },
                ["aug"] = {
                    name = "AUG",
                    color = Color(194,103,255),
                },
                ["xm1014"] = {
                    name = "XM-1014",
                    color = Color(130,210,255),
                },
                ["weapon_crossbow"] = {
                    name = "Арбалет",
                    color = Color(255,217,102),
                },
                ["scout"] = {
                    name = "Scout",
                    color = Color(194,103,255),
                },
                ["sg552"] = {
                    name = "SG552",
                    color = Color(194,103,255),
                },
                ["weapon_shotgun"] = {
                    name = "Hyper Shotgun",
                    color = Color(194,103,255),
                },
                ["verevka"] = {
                    name = "Веревка",
                    color = Color(194,103,255),
                },
                ["weapon_fists"] = {
                    name = "Кулаки",
                    color = Color(147,255,147),
                },
                ["weapon_frag"] = {
                    name = "Граната",
                    color = Color(255,217,102),
                },
                ["knife"] = {
                    name = "Нож",
                    color = Color(147,255,147),
                },
                ["weapon_crowbar"] = {
                    name = "Монтировка",
                    color = Color(147,255,147),
                },
                ["climb_swep2"] = {
                    name = "Паркур",
                    color = Color(147,255,147),
                },
                ["weapon_vape_juicy"] = {
                    name = "Разноцветный вейп",
                    color = Color(147,255,147),
                },
                ["weapon_vape_hallucinogenic"] = {
                    name = "Галюционный вейп",
                    color = Color(130,210,255),
                },
                ["weapon_ciga"] = {
                    name = "Сигарета",
                    color = Color(147,255,147),
                },
                ["weapon_vape"] = {
                    name = "Обычный вейп",
                    color = Color(147,255,147),
                },
                ["weapon_fidget"] = {
                    name = "Спиннер",
                    color = Color(147,255,147),
                },
                ["lockpick"] = {
                    name = "Отмычка",
                    color = Color(130,210,255),
                },
                ["stunstick"] = {
                    name = "Дубинка",
                    color = Color(147,255,147),
                },
                ["weapon_medkit"] = {
                    name = "Аптечка",
                    color = Color(194,103,255),
                },
                ["wrench_deluxe"] = {
                    name = "Гаечный ключ Deluxe",
                    color = Color(130,210,255),
                },
				["weapon_slam"] = {
                    name = "Мины",
                    color = Color(255,217,102),
                },
				["moneychecker"] = {
                    name = "Проверка денег",
                    color = Color(130,210,255),
                },
				["weapon_mad_2b"] = {
                    name = "Катана",
                    color = Color(255,217,102),
                },
				["weapon_flechettegun"] = {
                    name = "Ковбойка",
                    color = Color(255,217,102),
                },
				["awpdragon"] = {
                    name = "AWP Dragon Lore",
                    color = Color(255,117,117),
                },
				["m9k_vector"] = {
                    name = "Vector",
                    color = Color(194,103,255),
                },
				["m9k_usas"] = {
                    name = "USAS",
                    color = Color(255,117,117),
                },
				["m9k_thompson"] = {
                    name = "Tommy Gun",
                    color = Color(194,103,255),
                },
				["m9k_svu"] = {
                    name = "Dragunov SVU",
                    color = Color(255,217,102),
                },
				["m9k_spas12"] = {
                    name = "SPAS 12",
                    color = Color(255,117,117),
                },
				["m9k_sl8"] = {
                    name = "HK SL8",
                    color = Color(255,217,102),
                },
				["m9k_scar"] = {
                    name = "SCAR",
                    color = Color(130,210,255),
                },
				["m9k_ragingbull"] = {
                    name = "Raging Bull",
                    color = Color(147,255,147),
                },
				["m9k_mp9"] = {
                    name = "MP9",
                    color = Color(194,103,255),
                },
				["m9k_m60"] = {
                    name = "M60",
                    color = Color(130,210,255),
                },
				["m9k_luger"] = {
                    name = "P08 Luger",
                    color = Color(194,103,255),
                },
				["m9k_l85"] = {
                    name = "L85",
                    color = Color(130,210,255),
                },
				["m9k_honeybadger"] = {
                    name = "Honey Badger",
                    color = Color(194,103,255),
                },
				["m9k_fg42"] = {
                    name = "FG 42",
                    color = Color(194,103,255),
                },
				["m9k_dragunov"] = {
                    name = "Dragunov SVD",
                    color = Color(255,217,102),
                },
				["m9k_dbarrel"] = {
                    name = "Double Barrel",
                    color = Color(255,117,117),
                },
				["m9k_barret_m82"] = {
                    name = "Barret M82",
                    color = Color(255,117,117),
                },
				["m9k_vikhr"] = {
                    name = "Vikhr",
                    color = Color(130,210,255),
                },
				["m9k_val"] = {
                    name = "AS VAL",
                    color = Color(130,210,255),
                },
				["m9k_mossberg590"] = {
                    name = "Mossberg 590",
                    color = Color(130,210,255),
                },
				["m9k_magpulpdr"] = {
                    name = "Magpul PDR",
                    color = Color(130,210,255),
                },
				["m9k_kac_pdw"] = {
                    name = "KAC PDW",
                    color = Color(130,210,255),
                },
				["m9k_intervention"] = {
                    name = "Intervention",
                    color = Color(194,103,255),
                },
				["m9k_coltpython"] = {
                    name = "Colt Python",
                    color = Color(130,210,255),
                },
				["m9k_ares_shrike"] = {
                    name = "Ares Shrike",
                    color = Color(194,103,255),
                },
				["m9k_winchester73"] = {
                    name = "Winchester 73",
                    color = Color(255,117,117),
                },
				["m9k_m1918bar"] = {
                    name = "M1918",
                    color = Color(255,117,117),
                },
				["m9k_model627"] = {
                    name = "S&W Model 627",
                    color = Color(255,117,117),
                },
				["m9k_g36"] = {
                    name = "G36",
                    color = Color(255,117,117),
                },
				["m9k_1887winchester"] = {
                    name = "Winchester 87",
                    color = Color(255,117,117),
                },
				["m9k_svt40"] = {
                    name = "SVT40",
                    color = Color(255,117,117),
                },
				["m9k_contender"] = {
                    name = "Contender G2",
                    color = Color(255,117,117),
                },
				["m9k_mp7"] = {
                    name = "MP7",
                    color = Color(255,117,117),
                },

            },
        }
        local scrols 
        local function refreshWeapons()
            net_Start('weaponsmenugetweps')
            net_SendToServer()
            if IsValid(scrols) then scrols:Remove() end
            net.Receive('weaponsmenugetweps',function()
                local tableguner = net.ReadTable() or {}
                for a,z in pairs(GunsOnP) do
                    for k,v in pairs(z) do
                        if not tableguner[k] then
                            GunsOnP[a][k] = nil
                        end
                    end
                end
                scrols = ui('DScrollPanel', weaponPanel)
                scrols:SetSize(ss(946),ss(427))
                scrols:SetPos(ss(0),ss(60))
                scrols:GetVBar():SetWide(2)
                local bar = scrols.VBar
                bar:SetHideButtons(true)
                bar.Paint = nil
                bar.btnGrip.Paint = function(this, w, h)
                    box(0, 0, 0, w, h, Color(1,116,222))
                end
                local scr = ui('DIconLayout', scrols)
                scr:Dock(FILL)
                scr:SetSpaceX(ss(12))
                scr:SetSpaceY(ss(7))
                scr.PaintOver = function(self,w,h)
                end

                for context,errs in pairs(GunsOnP) do
                    for i,err in pairs(errs) do
                        local panel = ui('DPanel',scr)
                        panel:SetSize(ss(918),ss(55))
                        panel.Paint = function(self,w,h)
                            box(0,0,0,w,h,Color(38,37,37))
                            box(0,0,ss(9),ss(2),ss(37),err.color)
                            text(err.name,'MM_18',ss(7),h/2,col.white,0,1)
                            text(string.format("%s",tableguner[i] == "enabled" and "Включено" or "Выключено"),'MM_18',w/2,h/2,col.white,1,1)
                        end
                        local onoff = string.format("%s",tableguner[i] == "disabled" and "включить" or "выключить")
                        local butpanel = ui('DButton',panel)
                        butpanel:SetSize(ss(211),ss(55))
                        butpanel:SetPos(ss(718),0)
                        butpanel:SetText('')
                        butpanel.eblya = i
                        butpanel.Paint = function(self,w,h)
                            local color = col.white
                            if self.Hovered then
                                color = Color(255,255,255,125)
                            end
                            text(onoff,'MM_18',w/2,h/2,color,1,1)
                        end
                        butpanel.DoClick = function()
                            net_Start("weaponsmenuchangevar")
                            net_WriteString(butpanel.eblya)
                            net_SendToServer()
                            refreshWeapons() 
                        end
                    end
                end
            end)
        end
        refreshWeapons()
    end
    
    local b = ui('DButton', ePanel)
    b:SetPos(ss(835), ss(10))
    b:SetSize(ss(56),ss(62))
    b:SetText('')
    b.alpha = 0
    b.Paint = function(self,w,h)
        if self:IsHovered() then
            self.alpha = Lerp(FrameTime()*7,self.alpha,0.6)
        else
            self.alpha = Lerp(FrameTime()*7,self.alpha,1)
        end
        local color = Color(254,182,41,255*self.alpha)
        if selbut == 1 then
            color = Color(254,182,41,125)
        end
        box(9,0,0,w,h,color)
        
        surface.SetMaterial(Vectsedor) 
        surface.SetDrawColor(50,50,50)
        surface.DrawTexturedRect(ss(13),ss(15),ss(30),ss(31))
    end
    b.DoClick = function()
        WeaponMenu()
        seceted = 2
        selected = 0
        selbut = 1
    end
    b.OnCursorEntered = function()
        local x,y = gui.MousePos()
        CreateDermaMenu(ss(641),ss(192),ss(29),'Управление оружием')
    end
    b.OnCursorExited = function()
        RemoveDermaMenu()
    end

    function deg(b)
        local c = income
        c = c or {}
        c = (not istable(c) and util.JSONToTable(c)) or {}
        local d = buy
        d = d or {}
        d = (not istable(d) and util.JSONToTable(d)) or {}
        local e

        if b == "Все логи" then
            table.Add(c, d)
            e = c
        elseif b == "Лог пополнений" then
            e = c
        elseif b == "Лог покупок" then
            e = d
        end

        table.sort(e, function(b, c) return b.Time > c.Time end)

        scrol = ui('DScrollPanel', profilePanel)
        scrol:SetSize(ss(946),ss(314))
        scrol:SetPos(ss(0),ss(180))
        scrol:GetVBar():SetWide(2)
        local bar = scrol.VBar
        bar:SetHideButtons(true)
        bar.Paint = nil
        bar.btnGrip.Paint = function(this, w, h)
            box(0, 0, 0, w, h, Color(1,116,222))
        end
        local scr = ui('DIconLayout', scrol)
        scr:Dock(FILL)
        scr:SetSpaceX(ss(12))
        scr:SetSpaceY(ss(7))
        scr.PaintOver = function(self,w,h)
        end
        local txt
        for b, c in pairs(e) do
            local buts = ui('DPanel',scr)
            buts:SetSize(ss(920),ss(55))
            buts.Paint = function(self,w,h)
                box(0,0,0,w,h,Color(38,37,37))
                if c.color then
                    box(0,0,ss(9),ss(2),ss(37),c.color)
                else
                    box(0,0,ss(9),ss(2),ss(37),Color(194,103,255))
                end
                text(os.date("%H:%M:%S - %d/%m/%Y", c.Time),'MM_18',ss(19),h/2,col.white,0,1)
                text(c.Name,'MM_18',w/2,h/2,col.white,1,1)
                if game.GetIPAddress() == '212.22.93.215:27015' then
                    txt = '[#1]'
                else
                    txt = '[#2]'
                end
                text(c.Name,'MM_18',w/2,h/2,col.white,1,1)
                text(txt,'MM_18',w-ss(19),h/2,col.white,2,1)
            end
        end
    end

    local function e(d, e, f, g)
        local i = c:Add('svyanovlib_DButton', c)
        i:SetPos(e, f)
        i:SetSize(c:GetWide() / 3, c:GetTall())
        i.text = d
        i.textSize = 35

        function i:DoClick()
            category2 = g
            q:SetVisible(not not 1)
            a:SetVisible(not not 1)
            b(g)
        end
    end
    local profButs = {
        {
            name = 'Все логи',
            func = function()
            end
        },
        {
            name = 'Лог пополнений',
            func = function()
            end
        },
        {
            name = 'Лог покупок',
            func = function()
            end
        }
    }
    local function OpenProfile(b)
        if IsValid(profilePanel) then return end
        if IsValid(sc) then sc:Remove() end
        if IsValid(weaponPanel) then weaponPanel:Remove() end

        profilePanel = ui('DPanel',ePanel)
        profilePanel:SetSize(ss(946),ss(488))
        profilePanel:SetPos(ss(24),ss(84))
        profilePanel.Paint = function(self,w,h)
            text(ply:Name(),'MM_16',w/2,ss(61),col.white,1,0)
            text('Всего задоначено: ' .. ply:GetNW2Int("donated") .. ' ₽','MM_16',w/2,ss(83),col.white,1,0)
        end

        local ava = ui('AvatarMask', profilePanel)
        ava:SetSize(ss(52),ss(52))
        ava:SetPos(ss(448),ss(7))
        ava:SetPlayer(ply,128)

        local site = ui('DButton',profilePanel)
        site:SetSize(weight(215),height(68))
        site:SetPos(weight(21),height(35))
        site:SetText('')
        site.Paint = function(self,w,h)
            surface.SetMaterial(Vectors) 
            surface.SetDrawColor(255,255,255)
            surface.DrawTexturedRect(ss(138-42),ss(0),ss(26),ss(26))
            text('Сайт','MRPDM::UpPanel',w/2,height(39),Color(148,150,44),1,1)
            text('Для пополнения на прямую','MM_18',w/2,h-1,col.white,1,4)
        end
        site.DoClick = function()
            gui.OpenURL( "https://gambitrp.site/#donate_section" )
        end
        local forum = ui('DButton',profilePanel)
        forum:SetSize(weight(191),height(68))
        forum:SetPos(weight(718-24),height(35))
        forum:SetText('')
        forum.Paint = function(self,w,h)
            surface.SetMaterial(Veasdwdasactor) 
            surface.SetDrawColor(255,255,255)
            surface.DrawTexturedRect(ss(85),ss(0),ss(26),ss(26))
            text('Форум','MRPDM::UpPanel',w/2,height(39),Color(44,131,150),1,1)
            text('При проблемах в донате','MM_18',w/2,h-1,col.white,1,4)
        end
        forum.DoClick = function()
            gui.OpenURL( "https://forum.gambitrp.site/" )
        end

        local space = 0
        for k, v in pairs(profButs) do
            local d = ui("DButton", profilePanel)
            if k == 2 then
                d:SetSize(ss(383),ss(37))
            else
                d:SetSize(ss(257),ss(37))
            end
            d:SetPos(space,ss(110))
            d:SetText('')
            d.alpha = 0
            d.Paint = function(self,w,h)
                if self:IsHovered() then
                    self.alpha = Lerp(FrameTime()*8,self.alpha,1)
                else
                    self.alpha = Lerp(FrameTime()*8,self.alpha,0.6)
                end
                local color = Color(31,31,31,255*self.alpha)
                if selectsed == k then
                    color = Color(31,31,31,255)
                end
                box(0,0,0,w,h,color)
                text(v.name,'MM_20',w/2,h/2,col.white,1,1)
            end
            d.DoClick = function()
                selectsed = k
                if IsValid(scrol) then scrol:Remove() end
                deg(v.name)
            end
            if k == 2 then
                space = space + ss(12+383)
            else
                space = space + ss(12+257)
            end
        end
    end

    local n = ui('DButton', ePanel)
    n:SetPos(ss(905), ss(10))
    n:SetSize(ss(56),ss(62))
    n:SetText('')
    n.alpha = 0
    n.Paint = function(self,w,h)
        if self:IsHovered() then
            self.alpha = Lerp(FrameTime()*7,self.alpha,0.6)
        else
            self.alpha = Lerp(FrameTime()*7,self.alpha,1)
        end
        local color = Color(254,182,41,255*self.alpha)
        if selbut == 2 then
            color = Color(254,182,41,125)
        end
        box(9,0,0,w,h,color)
        surface.SetMaterial(Group_52) 
        surface.SetDrawColor(50,50,50)
        surface.DrawTexturedRect(ss(15),ss(16),ss(26),ss(31))
    end
    n.DoClick = function(self,w,h)
        OpenProfile()
        selected = 0
        selbut = 2
    end
    n.OnCursorEntered = function()
        local x,y = gui.MousePos()
        CreateDermaMenu(ss(819),ss(84),ss(29),'Профиль')
    end
    n.OnCursorExited = function()
        RemoveDermaMenu()
    end
  
    local buts = {
        {
            name = 'Привилегии',
            func = function()
                drawCategory('Привилегии')
                selected = 1
                selbut = 0
            end,
        },
        {
            name = 'Деньги',
            func = function()
                Donate_OpenMoneyBuyMenu(true)
            end,
        },
        {
            name = 'Оружие',
            func = function()
                drawCategory('Оружие')
                selected = 3
                selbut = 0
            end,
        },
        {
            name = 'Остальное',
            func = function()
                drawCategory('Остальное')
                selected = 4
                selbut = 0
            end,
        },
    }
    local pBut = ui('DPanel',ePanel)
    pBut:SetSize(ss(580),ss(77))
    pBut:SetPos(ss(-2),ss(0))
    pBut.Paint = nil
    local space = 0
    for k,v in ipairs(buts) do
        local categories = ui('DButton',pBut)
        categories:SetSize(ss(136),ss(77))
        categories:SetPos(space,0)
        categories:SetText('')
        categories.alpha = 0
        categories.Paint = function(self,w,h)
            local color = col.white
            if self:IsHovered() then
                self.alpha = Lerp(FrameTime()*7,self.alpha,1)
            else
                self.alpha = Lerp(FrameTime()*7,self.alpha,0)
            end
            surface.SetFont('MRPDM::UpPanel')
            local tx,ty = surface.GetTextSize(v.name)
            if selected == k then
                color = col.black
                if k == 1 then
                    draw.RoundedBoxEx(18,0,0,w,h,Color(254,182,41),true,false,false,false)
                else
                    box(0,0,0,w,h,Color(254,182,41))
                end
            end
            if k == 1 then
                draw.RoundedBoxEx(18,0,0,w,h,Color(254,182,41,255 * self.alpha),true,false,false,false)
            else
                box(0,0,0,w,h,Color(254,182,41,255 * self.alpha))
            end
            text(v.name,'MRPDM::UpPanel',w/2,h/2,color,1,1)
        end
        categories.DoClick = v.func
        space = space + ss(136)
    end
    drawCategory('Привилегии')
end)
--PATH addons/111mod/lua/autorun/client/cl_vgui.lua:
local function DisallowSpawnMenu(ply)
    if LocalPlayer():GetNW2Bool("propspam") == true then
        return false
    end
end

hook.Add( "SpawnMenuOpen", "DisallowSpawnMenu", DisallowSpawnMenu)

local color_sup 			= ui.col.SUP
local color_background 		= ui.col.Background
local color_outline 		= ui.col.Outline
local color_hover 			= ui.col.Hover
local color_button 			= ui.col.Button
local color_button_hover	= ui.col.ButtonHover
local color_close 			= ui.col.Close
local color_close_bg 		= ui.col.CloseBackground
local color_close_hover 	= ui.col.CloseHovered
local color_offwhite 		= ui.col.OffWhite
local color_flat_black 		= ui.col.FlatBlack
local color_black 			= ui.col.Black
local color_white 			= ui.col.White
local color_red 			= ui.col.Red

function stext(text,font,x,y,color,rotw,roth)
    draw.SimpleText(text, font, x+1, y+1, Color(0,0,0), rotw, roth)
    draw.SimpleText(text, font, x, y, color, rotw, roth)
end
function EQRoundBox(x,y,w,h,col,colout)
    draw.RoundedBox(0,x,y,w,h,col)
    surface.SetDrawColor(colout)
    surface.DrawOutlinedRect(x,y,w,h)
end
function EQRBButton(self,w,h,text)
	EQRoundBox(0,0,w,h,(self.Hovered and color_button_hover or color_button),color_outline)
	draw.SimpleText(text, "ui.20", w/2, h/2, color_white,1,1)
end
local blurmat = Material("pp/blurscreen")
function EQBlur(panel, amount)
    local x, y = panel:LocalToScreen(0, 0)
    local scrW, scrH = ScrW(), ScrH()
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(blurmat)

    for i = 1, 3 do
        blurmat:SetFloat("$blur", (i / 3) * (amount or 6))
        blurmat:Recompute()
        render.UpdateScreenEffectTexture()
        surface.DrawTexturedRect(x * -1, y * -1, scrW, scrH)
    end
end
--PATH addons/plib_v5/lua/plib/libraries/client/cvar.lua:
require 'hash'
require 'pon'

cvar = setmetatable({
	GetTable = setmetatable({}, {
		__call = function(self)
			return self
		end
	})
}, {
	__call = function(self, ...)
		return self.Register(...)
	end
})

local CVAR 	= {}
CVAR.__index = CVAR

debug.getregistry().Cvar = CVAR

local data_directory = 'cvar'
local staged_cvars = {}
local cvars_ordered = {}

local function load()
	if (not file.IsDir(data_directory, 'DATA')) then
		file.CreateDir(data_directory)
	else
		local files, _ = file.Find(data_directory .. '/*.dat', 'DATA')
		for k, v in ipairs(files) do
			local file_dir = data_directory .. '/' .. v
			local success, var = pcall(pon.decode, util.Decompress(file.Read(file_dir, 'DATA')))
			if success and isstring(var.Name) and (tostring(var.ID) == v:sub(0, -5)) and istable(var.Metadata) then
				staged_cvars[var.Name] = setmetatable(var, CVAR)
			else
				file.Delete(file_dir)
			end
		end
	end
end


function cvar.Register(name)
	if (not cvar.GetTable[name]) then
		local obj = staged_cvars[name] or setmetatable({
			Name = name,
			ID = hash.MD5(name),
			Metadata = {}
		}, CVAR)

		cvar.GetTable[name] = obj
		table.insert(cvars_ordered, obj)
		staged_cvars[name] = nil
	end
	return cvar.GetTable[name]
end

function cvar.GetOrderedTable()
	return cvars_ordered
end

function cvar.Get(name)
	if (not cvar.GetTable[name]) or (staged_cvars[name]) then
		cvar.Register(name)
	end
	return cvar.GetTable[name]
end

function cvar.SetValue(name, value)
	cvar.Get(name):SetValue(value)
end

function cvar.GetValue(name)
	return (cvar.GetTable[name] ~= nil) and cvar.GetTable[name]:GetValue()
end


function CVAR:ConCommand(func)
	concommand.Add(self.Name, function(p, c, a) func(self, p, a) end)
	return self
end

function CVAR:SetDefault(value, enforce)
	self.DefaultValue = value
	if (self.Value == nil) then
		self.Value = value
	end
	if enforce then
		self:SetType(TypeID(value))
	end
	return self
end

function CVAR:SetValue(value)
	if self:Validate(value) then
		hook.Call('cvar.' ..  self.Name, nil, self.Value, value)
		self.Value = value
		self:Save()
	end
	return self
end

function CVAR:AddMetadata(key, value)
	self.Metadata[key] = value
	return self
end

function CVAR:AddCallback(callback)
	hook.Add('cvar.' .. self.Name, callback)
	return self
end

function CVAR:Validate(value)
	return true
end

function CVAR:SetType(typeid)
	self.Validate = isfunction(typeid) and typeid or function(self, value)
		return (TypeID(value) == typeid)
	end
	if (not self:Validate(self.Value)) then
		self:Reset()
	end
	return self
end

function CVAR:Reset()
	self:SetValue(self.DefaultValue)
end

function CVAR:Save()
	file.Write(data_directory .. '/' .. self.ID .. '.dat', util.Compress(pon.encode({
		Name = self.Name,
		ID = self.ID,
		Value = self.Value,
		Metadata = self.Metadata,
	})))
	return self
end

function CVAR:GetName()
	return self.Name
end

function CVAR:GetValue()
	return self.Value
end

function CVAR:GetMetadata(key)
	return self.Metadata[key]
end


-- load()
--PATH gamemodes/darkrp/gamemode/modules/workarounds/sh_interface.lua:
DarkRP.getAvailableVehicles = DarkRP.stub{
    name = "getAvailableVehicles",
    description = "Get the available vehicles that DarkRP supports.",
    parameters = {
    },
    returns = {
        {
            name = "vehicles",
            description = "Names, models and classnames of all supported vehicles.",
            type = "table"
        }
    },
    metatable = DarkRP
}

--PATH gamemodes/darkrp/gamemode/modules/chat/cl_interface.lua:
DarkRP.addChatReceiver = DarkRP.stub{
    name = "addChatReceiver",
    description = "Add a chat command with specific receivers",
    parameters = {
        {
            name = "prefix",
            description = "The chat command itself (\"/pm\", \"/ooc\", \"/me\" are some examples)",
            type = "string",
            optional = false
        },
        {
            name = "text",
            description = "The text that shows up when it says \"Some people can hear you X\"",
            type = "string",
            optional = false
        },
        {
            name = "hearFunc",
            description = "A function(ply, splitText) that decides whether this player can or cannot hear you.",
            type = "function",
            optional = false
        }
    },
    returns = {},
    metatable = DarkRP
}

DarkRP.removeChatReceiver = DarkRP.stub{
    name = "removeChatReceiver",
    description = "Remove a chat command receiver",
    parameters = {
        {
            name = "prefix",
            description = "The chat command itself (\"/pm\", \"/ooc\", \"/me\" are some examples)",
            type = "string",
            optional = false
        }
    },
    returns = {},
    metatable = DarkRP
}

--PATH gamemodes/darkrp/gamemode/libraries/modificationloader.lua:
-- Modification loader.
-- Dependencies:
--     - fn
--     - simplerr

--[[---------------------------------------------------------------------------
Disabled defaults
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults = {}
DarkRP.disabledDefaults["modules"] = {
    ["afk"]              = true,
    ["chatsounds"]       = false,
    ["events"]           = false,
    ["fpp"]              = false,
    ["hitmenu"]          = false,
    ["hud"]              = false,
    ["hungermod"]        = true,
    ["playerscale"]      = false,
    ["sleep"]            = false,
}

DarkRP.disabledDefaults["agendas"]          = {}
DarkRP.disabledDefaults["ammo"]             = {}
DarkRP.disabledDefaults["demotegroups"]     = {}
DarkRP.disabledDefaults["doorgroups"]       = {}
DarkRP.disabledDefaults["entities"]         = {}
DarkRP.disabledDefaults["food"]             = {}
DarkRP.disabledDefaults["groupchat"]        = {}
DarkRP.disabledDefaults["hitmen"]           = {}
DarkRP.disabledDefaults["jobs"]             = {}
DarkRP.disabledDefaults["shipments"]        = {}
DarkRP.disabledDefaults["vehicles"]         = {}
DarkRP.disabledDefaults["workarounds"]      = {}

-- The client cannot use simplerr.runLuaFile because of restrictions in GMod.
local doInclude = CLIENT and include or fc{simplerr.wrapError, simplerr.wrapLog, simplerr.runFile}

if file.Exists("darkrp_config/disabled_defaults.lua", "LUA") then
    if SERVER then AddCSLuaFile("darkrp_config/disabled_defaults.lua") end
    doInclude("darkrp_config/disabled_defaults.lua")
end

--[[---------------------------------------------------------------------------
Config
---------------------------------------------------------------------------]]
local configFiles = {
    "darkrp_config/settings.lua",
    "darkrp_config/licenseweapons.lua",
}

for _, File in pairs(configFiles) do
    if not file.Exists(File, "LUA") then continue end

    if SERVER then AddCSLuaFile(File) end
    doInclude(File)
end
if SERVER and file.Exists("darkrp_config/mysql.lua", "LUA") then doInclude("darkrp_config/mysql.lua") end

--[[---------------------------------------------------------------------------
Modules
---------------------------------------------------------------------------]]
local function loadModules()
    local fol = "darkrp_modules/"

    local _, folders = file.Find(fol .. "*", "LUA")

    for _, folder in SortedPairs(folders, true) do
        if folder == "." or folder == ".." or GAMEMODE.Config.DisabledCustomModules[folder] then continue end
        -- Sound but incomplete way of detecting the error of putting addons in the darkrpmod folder
        if file.Exists(fol .. folder .. "/addon.txt", "LUA") or file.Exists(fol .. folder .. "/addon.json", "LUA") then
            DarkRP.errorNoHalt("Addon detected in the darkrp_modules folder.", 2, {
                "This addon is not supposed to be in the darkrp_modules folder.",
                "It is supposed to be in garrysmod/addons/ instead.",
                "Whether a mod is to be installed in darkrp_modules or addons is the author's decision.",
                "Please read the readme of the addons you're installing next time."
            },
            "<darkrpmod addon>/lua/darkrp_modules/" .. folder, -1)
            continue
        end

        for _, File in SortedPairs(file.Find(fol .. folder .. "/sh_*.lua", "LUA"), true) do
            if SERVER then
                AddCSLuaFile(fol .. folder .. "/" .. File)
            end

            if File == "sh_interface.lua" then continue end
            doInclude(fol .. folder .. "/" .. File)
        end

        if SERVER then
            for _, File in SortedPairs(file.Find(fol .. folder .. "/sv_*.lua", "LUA"), true) do
                if File == "sv_interface.lua" then continue end
                doInclude(fol .. folder .. "/" .. File)
            end
        end

        for _, File in SortedPairs(file.Find(fol .. folder .. "/cl_*.lua", "LUA"), true) do
            if File == "cl_interface.lua" then continue end

            if SERVER then
                AddCSLuaFile(fol .. folder .. "/" .. File)
            else
                doInclude(fol .. folder .. "/" .. File)
            end
        end
    end
end

local function loadLanguages()
    local fol = "darkrp_language/"

    local files, _ = file.Find(fol .. "*", "LUA")
    for _, File in pairs(files) do
        if SERVER then AddCSLuaFile(fol .. File) end
        doInclude(fol .. File)
    end
end

local customFiles = {
    "darkrp_customthings/jobs.lua",
    "darkrp_customthings/shipments.lua",
    "darkrp_customthings/entities.lua",
    "darkrp_customthings/vehicles.lua",
    "darkrp_customthings/food.lua",
    "darkrp_customthings/ammo.lua",
    "darkrp_customthings/groupchats.lua",
    "darkrp_customthings/categories.lua",
    "darkrp_customthings/agendas.lua", -- has to be run after jobs.lua
    "darkrp_customthings/doorgroups.lua", -- has to be run after jobs.lua
    "darkrp_customthings/demotegroups.lua", -- has to be run after jobs.lua
}
local function loadCustomDarkRPItems()
    for _, File in pairs(customFiles) do
        if not file.Exists(File, "LUA") then continue end
        if File == "darkrp_customthings/food.lua" and DarkRP.disabledDefaults["modules"]["hungermod"] then continue end

        if SERVER then AddCSLuaFile(File) end
        doInclude(File)
    end
end


function GM:DarkRPFinishedLoading()
    -- GAMEMODE gets set after the last statement in the gamemode files is run. That is not the case in this hook
    GAMEMODE = GAMEMODE or GM

    loadLanguages()
    loadModules()
    loadCustomDarkRPItems()
    hook.Call("loadCustomDarkRPItems", self)
    hook.Call("postLoadCustomDarkRPItems", self)
end

--PATH addons/111mod/lua/darkrp_config/licenseweapons.lua:
/*---------------------------------------------------------------------------
License weapons
Add weapons that do NOT require a special license here
ALL other weapons will require a license

Note: this only works if the license setting is enabled
---------------------------------------------------------------------------*/
GM.NoLicense["weapon_physcannon"] = true
GM.NoLicense["weapon_physgun"]    = true
GM.NoLicense["weapon_bugbait"]    = true
GM.NoLicense["gmod_tool"]         = true
GM.NoLicense["gmod_camera"]       = true

--PATH gamemodes/darkrp/gamemode/modules/money/sh_money.lua:
local pMeta = FindMetaTable("Player")
local entMeta = FindMetaTable("Entity")

function pMeta:canAfford(amount)
    if not amount or self.DarkRPUnInitialized then return false end
    return math.floor(amount) >= 0 and (self:getDarkRPVar("money") or 0) - math.floor(amount) >= 0
end

function entMeta:isMoneyBag()
    return self.IsSpawnedMoney or self:GetClass() == GAMEMODE.Config.MoneyClass
end

--PATH gamemodes/darkrp/gamemode/modules/base/sh_commands.lua:
DarkRP.declareChatCommand{
    command = "rpname",
    description = "Set your RP name",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "name",
    description = "Set your RP name",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "nick",
    description = "Set your RP name",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "buy",
    description = "Buy a pistol",
    delay = 1.5,
    condition = fn.FAnd {
        fn.Compose{fn.Curry(fn.GetValue, 2)("enablebuypistol"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode},
        fn.Compose{fn.Not, fn.Curry(fn.GetValue, 2)("noguns"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
    }
}

DarkRP.declareChatCommand{
    command = "buyshipment",
    description = "Buy a shipment",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "buyvehicle",
    description = "Buy a vehicle",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "buyammo",
    description = "Purchase ammo",
    delay = 1.5,
    condition = fn.Compose{fn.Not, fn.Curry(fn.GetValue, 2)("noguns"), fn.Curry(fn.GetValue, 2)("Config"), gmod.GetGamemode}
}

DarkRP.declareChatCommand{
    command = "price",
    description = "Set the price of the microwave or gunlab you're looking at",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "setprice",
    description = "Set the price of the microwave or gunlab you're looking at",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "forcerpname",
    description = "Forcefully change a player's RP name",
    delay = 0.5,
    tableArgs = true
}

DarkRP.declareChatCommand{
    command = "freerpname",
    description = "Remove a RP name from the database so a player can use it",
    delay = 1.5
}

--PATH gamemodes/darkrp/gamemode/modules/base/cl_init.lua:
local view = {
    origin = Vector(0, 0, 0),
    angles = Angle(0, 0, 0),
    fov = 90,
    znear = 1
}

hook.Add("CalcView", "rp_deathPOV", function(ply, origin, angles, fov)
    -- Entity:Alive() is being slow as hell, we might actually see ourselves from third person for frame or two
    if not GAMEMODE.Config.deathpov or ply:Health() > 0 then return end

    local Ragdoll = ply:GetRagdollEntity()
    if not IsValid(Ragdoll) then return end

    local head = Ragdoll:LookupAttachment("eyes")
    head = Ragdoll:GetAttachment(head)
    if not head or not head.Pos then return end

    if not Ragdoll.BonesRattled then
        Ragdoll.BonesRattled = true

        Ragdoll:InvalidateBoneCache()
        Ragdoll:SetupBones()

        local matrix

        for bone = 0, (Ragdoll:GetBoneCount() or 1) do
            if Ragdoll:GetBoneName(bone):lower():find("head") then
                matrix = Ragdoll:GetBoneMatrix(bone)
                break
            end
        end

        if IsValid(matrix) then
            matrix:SetScale(Vector(0, 0, 0))
        end
    end

    view.origin = head.Pos + head.Ang:Up() * 8
    view.angles = head.Ang

    return view
end)

-- hook.Add("InitPostEntity", "RateState", function()
    -- local localplayer = LocalPlayer()

    -- local interp = engine.TickInterval()
    -- local interp_min = interp
    -- local interp_max = interp * 3
	-- local sv = engine.ServerFrameTime()
	-- local int_min_max = math.Clamp(sv, interp_min, interp_max)
	
    -- hook.Add("Tick", "dynlerp", function()
        -- interp = Lerp(.01, interp, int_min_max + 0.001)
        -- localplayer:ConCommand("cl_interp " .. interp)
    -- end)

    -- hook.Remove("InitPostEntity", "RateState")
-- end)
--PATH gamemodes/darkrp/gamemode/modules/base/cl_fonts.lua:
--[[---------------------------------------------------------------------------
The fonts that DarkRP uses
---------------------------------------------------------------------------]]
local function loadFonts()
    local tahoma = system.IsLinux() and "DejaVu Sans" or "Tahoma"
    local tahomaSize = system.IsLinux() and fp{fn.Flip(fn.Add), 1} or fn.Id

    surface.CreateFont("DarkRPHUD1", {
        size = tahomaSize(16),
        weight = 600,
        antialias = true,
        shadow = true,
        font = tahoma})

    surface.CreateFont("DarkRPHUD2", {
        size = 23,
        weight = 400,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("Trebuchet18", {
        size = 18,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS"})

    surface.CreateFont("Trebuchet20", {
        size = 20,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS"})

    surface.CreateFont("Trebuchet24", {
        size = 24,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS"})

    surface.CreateFont("Trebuchet48", {
        size = 48,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Trebuchet MS"})

    surface.CreateFont("TabLarge", {
        size = tahomaSize(15),
        weight = 700,
        antialias = true,
        shadow = false,
        font = tahoma})

    surface.CreateFont("UiBold", {
        size = 16,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Default"})

    surface.CreateFont("HUDNumber5", {
        size = 30,
        weight = 800,
        antialias = true,
        shadow = false,
        font = "Default"})

    surface.CreateFont("ScoreboardHeader", {
        size = 32,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("ScoreboardSubtitle", {
        size = 22,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("ScoreboardPlayerName", {
        size = 19,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("ScoreboardPlayerName2", {
        size = 15,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("ScoreboardPlayerNameBig", {
        size = 22,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Coolvetica"})

    surface.CreateFont("AckBarWriting", {
        size = 20,
        weight = 500,
        antialias = true,
        shadow = false,
        font = "Akbar"})

    surface.CreateFont("DarkRP_tipjar", {
        size = 100,
        weight = 500,
        antialias = true,
        shadow = true,
        font = "ChatFont"})
end
loadFonts()

--PATH gamemodes/darkrp/gamemode/config/addentities.lua:
DarkRP.createShipment("Desert eagle", {
    model = "models/weapons/w_pist_deagle.mdl",
    entity = "weapon_deagle2",
    price = 215,
    amount = 10,
    separate = true,
    pricesep = 215,
    noship = true,
    allowed = {TEAM_GUN},
    category = "Pistols",
})

DarkRP.createShipment("Fiveseven", {
    model = "models/weapons/w_pist_fiveseven.mdl",
    entity = "weapon_fiveseven2",
    price = 0,
    amount = 10,
    separate = true,
    pricesep = 205,
    noship = true,
    allowed = {TEAM_GUN},
    category = "Pistols",
})

DarkRP.createShipment("Glock", {
    model = "models/weapons/w_pist_glock18.mdl",
    entity = "weapon_glock2",
    price = 0,
    amount = 10,
    separate = true,
    pricesep = 160,
    noship = true,
    allowed = {TEAM_GUN},
    category = "Pistols",
})

DarkRP.createShipment("P228", {
    model = "models/weapons/w_pist_p228.mdl",
    entity = "weapon_p2282",
    price = 0,
    amount = 10,
    separate = true,
    pricesep = 185,
    noship = true,
    allowed = {TEAM_GUN},
    category = "Pistols",
})

DarkRP.createShipment("AK47", {
    model = "models/weapons/w_rif_ak47.mdl",
    entity = "weapon_ak472",
    price = 2450,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN},
    category = "Rifles",
})

DarkRP.createShipment("MP5", {
    model = "models/weapons/w_smg_mp5.mdl",
    entity = "weapon_mp52",
    price = 2200,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN},
    category = "Rifles",
})

DarkRP.createShipment("M4", {
    model = "models/weapons/w_rif_m4a1.mdl",
    entity = "weapon_m42",
    price = 2450,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN},
    category = "Rifles",
})

DarkRP.createShipment("Mac 10", {
    model = "models/weapons/w_smg_mac10.mdl",
    entity = "weapon_mac102",
    price = 2150,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN}
})

DarkRP.createShipment("Pump shotgun", {
    model = "models/weapons/w_shot_m3super90.mdl",
    entity = "weapon_pumpshotgun2",
    price = 1750,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN},
    category = "Shotguns",
})

DarkRP.createShipment("Sniper rifle", {
    model = "models/weapons/w_snip_g3sg1.mdl",
    entity = "ls_sniper",
    price = 3750,
    amount = 10,
    separate = false,
    pricesep = nil,
    noship = false,
    allowed = {TEAM_GUN},
    category = "Snipers",
})

DarkRP.createEntity("Drug lab", {
    ent = "drug_lab",
    model = "models/props_lab/crematorcase.mdl",
    price = 400,
    max = 3,
    cmd = "buydruglab",
    allowed = {TEAM_GANG, TEAM_MOB}
})

DarkRP.createEntity("Money printer", {
    ent = "money_printer",
    model = "models/props_c17/consolebox01a.mdl",
    price = 1000,
    max = 2,
    cmd = "buymoneyprinter"
})

DarkRP.createEntity("Tip Jar", {
    ent = "darkrp_tip_jar",
    model = "models/props_lab/jar01a.mdl",
    price = 0,
    max = 2,
    cmd = "tipjar",
    allowTools = true,
})

DarkRP.createEntity("Gun lab", {
    ent = "gunlab",
    model = "models/props_c17/TrapPropeller_Engine.mdl",
    price = 500,
    max = 1,
    cmd = "buygunlab",
    allowed = TEAM_GUN
})

if not DarkRP.disabledDefaults["modules"]["hungermod"] then
    DarkRP.createEntity("Microwave", {
        ent = "microwave",
        model = "models/props/cs_office/microwave.mdl",
        price = 400,
        max = 1,
        cmd = "buymicrowave",
        allowed = TEAM_COOK
    })
end

DarkRP.createCategory{
    name = "Other",
    categorises = "entities",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

DarkRP.createCategory{
    name = "Other",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

DarkRP.createCategory{
    name = "Rifles",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 100,
}

DarkRP.createCategory{
    name = "Shotguns",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 101,
}

DarkRP.createCategory{
    name = "Snipers",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 102,
}

DarkRP.createCategory{
    name = "Pistols",
    categorises = "weapons",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 100,
}

DarkRP.createCategory{
    name = "Other",
    categorises = "weapons",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

DarkRP.createCategory{
    name = "Other",
    categorises = "vehicles",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

--PATH addons/111mod/lua/darkrp_modules/ui_markers/sh_cr.lua:
local Player = FindMetaTable( 'Player' )

function Player:isTaxist()
	return self:getJobTable().taxist == true
end

for _, cmd in pairs{"requestmed", "medrequest"} do
    DarkRP.declareChatCommand{
        command = cmd,
        description = "Вызвать медика",
        delay = 1.5
    }
end
--PATH addons/111mod/lua/darkrp_modules/othermodules/sh_toolgun_sound.lua:
timer.Simple( .1, function()
	weapons.GetStored( 'gmod_tool' ).ShootSound = Sound( 'ambient/weather/rain_drip4.wav' )
end)
--PATH addons/111mod/lua/darkrp_modules/menu/cl_shoplist.lua:
-----------------------------------------------------
local PANEL = {}

function PANEL:Init()
    self:SetText('')
    self.Model = ui.Create('rp_modelicon', self)
end

function PANEL:PerformLayout()
	local box = ScrW() * 0.0292
    self.Model:SetPos(0, 0)
    self.Model:SetSize(box - 2, box - 2)
	self.Model.Paint = function(s, w, h) draw.Box(0, 0, w, h, Color(29, 29, 29)) end
end

function PANEL:Paint(w, h)
	draw.Box(0, 0, w, h - 2, Color(68, 68, 68))
	if self.Hovered then
		draw.Box(0, 0, w, h - 2, Color(98, 98, 98))
	end
    draw.SimpleText(self.Title, 'F4FancyButton', ScrW() * 0.0412, h * .5 - 2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
    draw.SimpleText(self.Price .. '$', 'F4FancyButton', w - ScrW() * 0.0141, h * .5 - 2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)
end

function PANEL:SetInfo(model, title, price, doclick)
    self.Model:SetModel(model)
    self.Title = title
    self.Price = price
    self.DoClick = doclick
    self.Model.DoClick = doclick
end

vgui.Register('rp_shopbutton', PANEL, 'DButton')
PANEL = {}

function PANEL:PerformLayout()
    local c = 0
    local even = false

    for k, v in ipairs(self:GetChildren()) do
        v:SetPos(even and (self:GetWide() * .5) or 0, c * ScrW() * 0.0292)
        v:SetSize(self:GetWide() * .5 + 1, ScrW() * 0.0292)

        if even then
            c = c + 1
        end

        even = (not even)
    end
end

function PANEL:AddItem(model, title, price, doclick)
    local btn = ui.Create('rp_shopbutton', self)
    btn:SetInfo(model, title, price, doclick)
    self:SetTall(math.ceil(#self:GetChildren() * .5) * ScrW() * 0.0292)
end

vgui.Register('rp_shopcatagory', PANEL, 'Panel')

local function canBuyF4(item)
    local ply = LocalPlayer()
    local ent = item.ent
    if istable(item.allowed) and not table.HasValue(item.allowed, ply:Team()) then return false, true end
    if item.customCheck and not item.customCheck(ply) then return false, true end
    if item.ent == "whk_tv" and not nw.GetGlobal("telek") then return false, true end

    return true
end

PANEL = {}
local grdown = Material('gui/gradient_down', 'smooth')

function PANEL:Init()
    local cat
    self.Cats = {}
    self.List = ui.Create('ui_listview', self)
    self.List.Paint = function() end
    self.List:AddSpacer('Патроны'):SetTall(ScrH() * 0.0355)
    cat = ui.Create('rp_shopcatagory')

    for k, v in ipairs(GAMEMODE.AmmoTypes) do
        cat:AddItem(v.model, v.name, v.price, function()
            RunConsoleCommand("darkrp", "buyammo", v.ammoType)
        end)
    end

    self.List:AddItem(cat)

    for k, v in ipairs(CustomShipments) do
        if canBuyF4(v) then
            if (not self.Cats['Shipments']) then
                self.List:AddSpacer('Коробки'):SetTall(ScrH() * 0.0355)
                self.Cats['Shipments'] = true
                cat = ui.Create('rp_shopcatagory')
            end

            cat:AddItem(v.model, v.name, v.price, function()
                RunConsoleCommand("darkrp", "buyshipment", v.name)
            end)
        end
    end

    self.List:AddItem(cat)

    for k, v in ipairs(CustomShipments) do
        if canBuyF4(v) and v.seperate then
            if (not self.Cats['Weps']) then
                self.List:AddSpacer("Поштучно"):SetTall(ScrH() * 0.0355)
                self.Cats['Weps'] = true
                cat = ui.Create('rp_shopcatagory')
            end

            cat:AddItem(v.model, v.name, v.pricesep, function()
                RunConsoleCommand("darkrp", "buy", v.name)
            end)
        end
    end

    self.List:AddItem(cat)

    for k, v in ipairs(DarkRPEntities) do
        if canBuyF4(v) then
            if (not self.Cats['Entities']) then
                self.List:AddSpacer('Предметы'):SetTall(ScrH() * 0.0355)
                self.Cats['Entities'] = true
                cat = ui.Create('rp_shopcatagory')
            end

            cat:AddItem(v.model, v.name, v.pricesep or v.price, function()
                RunConsoleCommand("darkrp", v.cmd)
            end)
        end

        self.List:AddItem(cat)
    end

	local savetexttbl = {}
    for k, v in pairs(self.List.Rows) do
		savetexttbl[k] = v:GetText()
        v.Paint = function(s, w, h)
            draw.RoundedBox(0, 0, 0, w, h, Color(126, 126, 126))
            surface.SetDrawColor(0, 0, 0, 100)
            surface.SetMaterial(grdown)
            surface.DrawTexturedRect(0, 0, w, h * 1.5)
            draw.SimpleText(savetexttbl[k], 'F4FancyButtonBold', w / 2, h / 2, color_white, 1, 1)
        end

        v:SetText('')
    end
end

function PANEL:PerformLayout()
    self.List:SetPos(0, 0)
    self.List:SetSize(self:GetWide(), self:GetTall())
end

vgui.Register('rp_shoplist', PANEL, 'Panel')
--PATH addons/111mod/lua/darkrp_modules/menu/cl_setting.lua:
local filters = {}
filters['Дефолтный'] = 0

filters['Резонирующий №1'] = {
    ['$pp_colour_addr'] = 0,
    ['$pp_colour_addg'] = 0,
    ['$pp_colour_addb'] = 0,
    ['$pp_colour_brightness'] = 0,
    ['$pp_colour_contrast'] = 1,
    ['$pp_colour_colour'] = 1.5,
    ['$pp_colour_mulr'] = 0,
    ['$pp_colour_mulg'] = 0,
    ['$pp_colour_mulb'] = 0
}

filters['Резонирующий №2'] = {
    ['$pp_colour_addr'] = 0.02,
    ['$pp_colour_addg'] = 0,
    ['$pp_colour_addb'] = 0.02,
    ['$pp_colour_brightness'] = 0,
    ['$pp_colour_contrast'] = 1.1,
    ['$pp_colour_colour'] = 1.8,
    ['$pp_colour_mulr'] = 0.24,
    ['$pp_colour_mulg'] = 0.24,
    ['$pp_colour_mulb'] = 0.24
}

filters['Супер яркий'] = {
    ['$pp_colour_addr'] = 0,
    ['$pp_colour_addg'] = 0,
    ['$pp_colour_addb'] = 0,
    ['$pp_colour_brightness'] = 0,
    ['$pp_colour_contrast'] = 1,
    ['$pp_colour_colour'] = 2.5,
    ['$pp_colour_mulr'] = 0,
    ['$pp_colour_mulg'] = 0,
    ['$pp_colour_mulb'] = 0
}

filters['Выцветший'] = {
    ['$pp_colour_addr'] = 0,
    ['$pp_colour_addg'] = 0,
    ['$pp_colour_addb'] = 0,
    ['$pp_colour_brightness'] = 0,
    ['$pp_colour_contrast'] = 1,
    ['$pp_colour_colour'] = 0.5,
    ['$pp_colour_mulr'] = 0,
    ['$pp_colour_mulg'] = 0,
    ['$pp_colour_mulb'] = 0
}

filters['Черно & Белый'] = {
    ['$pp_colour_addr'] = 0,
    ['$pp_colour_addg'] = 0,
    ['$pp_colour_addb'] = 0,
    ['$pp_colour_brightness'] = 0,
    ['$pp_colour_contrast'] = 1,
    ['$pp_colour_colour'] = 0,
    ['$pp_colour_mulr'] = 0,
    ['$pp_colour_mulg'] = 0,
    ['$pp_colour_mulb'] = 0
}

local filter = filter or 'Дефолтный'
local DrawColorModify = DrawColorModify

hook.Add('RenderScreenspaceEffects', 'colors', function()
    if (filter == 'Дефолтный' or not filters[filter]) then return end
    DrawColorModify(filters[filter])
end)

local settings = {
    ['Включить анимацию падающего снега'] = 'pp_fmsnow',
    ['Включить тени (убирает фонарики)'] = 'r_shadows',
    ['Включить звук уведомлений (капля)'] = 'blip',
    ['Включить звук начала голосования'] = 'votesound',
    ['Включить рендер фрагментов карты (граффити и т.п)'] = 'r_renderoverlayfragment',
    ['Включить скайбокс (фон карты)'] = 'r_3dsky',
    ['Включить отображение FPS'] = 'cl_showfps',
    ['Скрыть игроков на спавне (FPS++)'] = 'skrit'
}

local truebut, falsebut = Material('gambitrp/f4/true.png'), Material('gambitrp/f4/false.png')
local grdown = Material('gui/gradient_down', 'smooth')
local stopsoundmat, soundmat, snowmat, colormat =  Material('gambitrp/f4/stopsound.png'), Material('gambitrp/f4/sound.png'), Material('gambitrp/f4/snow.png'), Material('gambitrp/f4/color.png')
function f4settingstab(tabs)
    local tab = ui.Create('ui_panel')
    tab:SetSize(tabs:GetParent():GetWide() - ScrW() * 0.1285, tabs:GetParent():GetTall())

    local scroll = ui.Create('DScrollPanel', function(self, p)
        self:SetSize(tab:GetWide() - ScrW() * 0.042, tab:GetTall())
        self:SetPos(0, ScrH() * 0.04)
        self:SetPadding(ScrH() * 0.02)
    end, tab)

    ui.Create('DButton', function(self, p)
        self:SetPos(0, 0)
        self:SetSize(tab:GetWide() / 2 - 2, tab:GetTall() * 0.05)
        self:SetText('')
        self:SetDisabled(true)

        self.Paint = function(ss, w, h)
            draw.RoundedBox(0, 0, 0, w, h, Color(126, 126, 126))
            surface.SetDrawColor(0, 0, 0, 100)
            surface.SetMaterial(grdown)
            surface.DrawTexturedRect(0, 0, w, h * 1.5)
            draw.SimpleText('Основные настройки', 'F4FancyButtonBold', w / 2, h / 2, color_white, 1, 1)
        end
    end, tab)

    local sizebut = ScrW() * 0.0105
    local num = 0
    for k, v in pairs(settings) do
        ui.Create('DCheckBoxLabel', function(self, p)
            self.PerformLayout = function() end
            self.SizeToContents = function() end
            self:SetPos(0, sizebut * num * 1.2)
            self:SetSize(scroll:GetWide(), sizebut)
            self:SetText('')
            self:SetConVar(v)
            self.Paint = function(s, w, h)
                draw.SimpleText(k, 'F4FancyButton', 36, h / 2, color_white, 0, 1)
            end
            self.Button:SetPos(0, 0)
            self.Button:SetSize(sizebut, sizebut)
            self.Button.Paint = function(s, w, h)
                surface.SetDrawColor(color_white)
                surface.SetMaterial(self:GetChecked() and truebut or falsebut)
                surface.DrawTexturedRect(0, 0, w, h)
            end
        end, scroll)
        num = num + 1
    end

    ui.Create('DButton', function(self, p)
        self:SetPos(tab:GetWide() / 2 + 2, 0)
        self:SetSize(tab:GetWide() / 2 - 2, tab:GetTall() * 0.05)
        self:SetText('')
        self:SetDisabled(true)

        self.Paint = function(ss, w, h)
            draw.RoundedBox(0, 0, 0, w, h, Color(126, 126, 126))
            surface.SetDrawColor(0, 0, 0, 100)
            surface.SetMaterial(grdown)
            surface.DrawTexturedRect(0, 0, w, h * 1.5)
            draw.SimpleText('Прочие настройки', 'F4FancyButtonBold', w / 2, h / 2, color_white, 1, 1)
        end
    end, tab)
    
    local nunknobw = ScrW() * 0.0089
    ui.Create('DNumSlider', function(self, p)
        self:SetPos(tab:GetWide() / 2 + 2, ScrH() * 0.04)
        self:SetSize(tab:GetWide() / 2 - 2, sizebut)
        self:SetText('')
        self.Paint = function(s, w, h)
            draw.SimpleText('Громкость медиа', 'F4FancyButtonBold', 0, h / 2, color_white, 0, 1)
        end
        self.Slider.Knob:SetSize( nunknobw, nunknobw )
        self.Slider.Knob.Paint = function(s, w, h)
            draw.RoundedBox(32, 0, 0, w, h, color_white)
        end
        local sliderh = ScrH() * 0.0056
        self.Slider.Paint = function(s, w, h)
            draw.RoundedBox(32, 0, h / 2 - sliderh / 2, w, sliderh, Color(131, 131, 131))
        end
        self.TextArea.Paint = function(s, w, h) 
            draw.SimpleText((s:GetText() or '0') .. '%', 'F4FancyButtonBold', w / 2, h / 2, color_white, 1, 1)
        end
        self.OnValueChanged = function(s, value)
            cvar.SetValue('media_volume', value)
        end
        self:SetMin(0)
        self:SetMax(100)
        self:SetDecimals(0)
    end, tab)

    local btnw, btnh = tab:GetWide() / 2 - 2, ScrH() * 0.04
    local iconwh = ScrW() * 0.012
    local zvyk = vgui.Create("DButton", tab)
    zvyk:SetSize(btnw, btnh)
    zvyk:SetPos(0, tab:GetTall() - btnh * 4 - 4)
    zvyk:SetText("")
    zvyk.Paint = function(s, w, h)
        draw.RoundedBox(8, 0, 0, w, h, Color(229, 229, 229))
        local text = draw.SimpleText('Остановить все звуки', 'F4FancyButtonBold', w / 2 + iconwh / 2 + 8, h / 2, color_black, 1, 1)
        surface.SetDrawColor(color_white)
        surface.SetMaterial(stopsoundmat)
        surface.DrawTexturedRect(w / 2 - iconwh / 2 - text / 2 - 8, h / 2 - iconwh / 2, iconwh, iconwh)
    end
    zvyk.DoClick = function()
        LocalPlayer():ConCommand("stopsound")
    end

    local filterbutton = vgui.Create("DButton", tab)
    filterbutton:SetSize(btnw, btnh)
    filterbutton:SetPos(btnw + 4, tab:GetTall() - btnh * 4 - 4)
    filterbutton:SetText("")
    filterbutton.Paint = function(s, w, h)
        draw.RoundedBox(8, 0, 0, w, h, Color(229, 229, 229))
        local text = draw.SimpleText('Цветовая гамма', 'F4FancyButtonBold', w / 2 + iconwh / 2 + 8, h / 2, color_black, 1, 1)
        surface.SetDrawColor(color_white)
        surface.SetMaterial(colormat)
        surface.DrawTexturedRect(w / 2 - iconwh / 2 - text / 2 - 8, h / 2 - iconwh / 2, iconwh, iconwh)
    end

    filterbutton.DoClick = function()
        local comboBox = vgui.Create("DComboBox", filterbutton)
        comboBox:SetPos(ScrW() / 11.2, 0)
        comboBox:SetSize(175, 20)
        comboBox:SetValue("Выберите цветовую гамму")

        comboBox.OnSelect = function(s, _, value)
            filter = value
            s:Remove()
        end

        for k, v in pairs(filters) do
            comboBox:AddChoice(k)
        end
    end

    local media_enable = vgui.Create("DButton", tab)
    media_enable:SetSize(btnw, btnh)
    media_enable:SetPos(0, tab:GetTall() - btnh * 3)
    media_enable:SetText("")
    media_enable.Paint = function(s, w, h)
        draw.RoundedBox(8, 0, 0, w, h, Color(229, 229, 229))
        local text = draw.SimpleText('Включить/выключить медиа-проигрыватели', 'F4FancyButtonBold', w / 2 + iconwh / 2 + 8, h / 2, color_black, 1, 1)
        surface.SetDrawColor(color_white)
        surface.SetMaterial(soundmat)
        surface.DrawTexturedRect(w / 2 - iconwh / 2 - text / 2 - 8, h / 2 - iconwh / 2, iconwh, iconwh)
    end
    media_enable.DoClick = function()
        if cvar.GetValue('media_enable') then
            cvar.SetValue('media_enable', false)
            LocalPlayer():ChatPrint('Выключаем медиа проигрыватели!')
        else
            cvar.SetValue('media_enable', true)
            LocalPlayer():ChatPrint('Включаем медиа проигрыватели!')
        end
    end

    local darktheme = vgui.Create("DButton", tab)
    darktheme:SetSize(btnw, btnh)
    darktheme:SetPos(btnw + 4, tab:GetTall() - btnh * 3)
    darktheme:SetText("")
    darktheme.Paint = function(s, w, h)
        draw.RoundedBox(8, 0, 0, w, h, Color(229, 229, 229))
        local text = draw.SimpleText('Включить/Выключить зимние текстуры', 'F4FancyButtonBold', w / 2 + iconwh / 2 + 8, h / 2, color_black, 1, 1)
        surface.SetDrawColor(color_white)
        surface.SetMaterial(snowmat)
        surface.DrawTexturedRect(w / 2 - iconwh / 2 - text / 2 - 8, h / 2 - iconwh / 2, iconwh, iconwh)
    end
    darktheme.DoClick = function()
        LocalPlayer():ConCommand('enablesnow')
    end

    return tab
end
--PATH addons/111mod/lua/darkrp_modules/menu/cl_playerpreview.lua:
local PANEL = {}

function PANEL:Init()
	self.AngleSlider = ui.Create('ui_slider', self)
	self.AngleSlider.OnChange = function(s, value)

		self.ModelPanel.Entity:SetAngles(Angle(0, (value - 0.5) * 360, 0))
	end
	self.AngleSlider.Paint = function(s, w, h)
	end

	self.ModelPanel = ui.Create('DModelPanel', self)
	self.ModelPanel:SetMouseInputEnabled(false)
	self.ModelPanel:SetFOV(20)
	self.ModelPanel:SetModel(LocalPlayer():GetModel())
	self.ModelPanel.DrawModel = function(self)
		self.Entity:DrawModel()

		self.Entity:SetEyeTarget(gui.ScreenToVector(gui.MousePos()))
	end
	self.ModelPanel.LayoutEntity = function(self)
		self:RunAnimation()
	end
	self.ModelPanel.Entity.GetPlayerColor = function()
		return LocalPlayer():GetPlayerColor()
	end

	local hz = 60

	if IsValid(self.ModelPanel.Entity) then
		local headBone = self.ModelPanel.Entity:LookupBone('ValveBiped.Bip01_Head1')
		if headBone then
			hz = self.ModelPanel.Entity:GetBonePosition(headBone).z
		end
	end
	if hz < 5 then
		hz = 40
	end
	hz = hz * 0.6

	self.ModelPanel:SetCamPos(Vector(175, 0, hz))
	self.ModelPanel:SetLookAt(Vector(0, 0, hz))

	self.Sequences = {
		'pose_standing_01',
		'pose_standing_02',
		'pose_standing_03',
		'pose_standing_04',
	}

	self:FindSequence()
end

function PANEL:PerformLayout()
	local w, h = self:GetSize()

	self.ModelPanel:SetSize(w, h - 25)
	self.ModelPanel:SetPos(0, 0)

	self.AngleSlider:SetWide(w - 40)
	self.AngleSlider:SetPos(0, h - self.AngleSlider:GetTall())
end

function PANEL:FindSequence()
	if IsValid(self.ModelPanel.Entity) then
		local seqno
		repeat
			seqno = self.ModelPanel.Entity:LookupSequence(self.Sequences[math.random(1, #self.Sequences)])
		until seqno
		self.ModelPanel.Entity:SetSequence(seqno)
	end
end

function PANEL:AddSequence(sequence)
	self.Sequences[#self.Sequences + 1] = sequence
end

function PANEL:SetFOV(fov)
	return self.ModelPanel:SetFOV(fov)
end

function PANEL:SetModel(model)
	return self.ModelPanel:SetModel(model)
end

function PANEL:Paint(w, h)
	surface.SetDrawColor(ui.col.Outline)
	surface.DrawLine(20, h - 10, w - 40, h - 10)
	draw.NoTexture()
	surface.DrawPoly({
		{x = 20, y = h - 10},
		{x = 40, y = h - 20},
		{x = 40, y = h}
	})

	surface.DrawPoly({
		{x = w - 40, y = h - 20},
		{x = w - 20, y = h - 10},
		{x = w - 40, y = h}
	})
end

vgui.Register('rp_playerpreview', PANEL, 'Panel')
--PATH addons/111mod/lua/darkrp_modules/gmb_samopis/cl_frz.lua:
function draw.ShadowedText( str, font, font_shadow, x, y, color, xalign, yalign )
	surface.SetFont( font )

	local w, h = surface.GetTextSize( str )
	x = (x or 0) - w * (xalign or 0)
	y = (y or 0) - h * (yalign or 0)
	surface.SetTextColor( Color(0,0,0) )
	surface.SetTextPos( x+2, y+2 )
	surface.DrawText( str )

	surface.SetTextColor( color or col_face )
	surface.SetTextPos( x, y )
	surface.DrawText( str )

	return tw, th
end

local allowedents = {
	['spawned_shipment'] = true,
	['f_printer'] = true,
	['f_donate_printer'] = true,
	['money_printer'] = true,
	['bm2_bitminer_1'] = true,
	['bm2_bitminer_2'] = true,
	['bm2_bitminer_rack'] = true,
	['bm2_generator'] = true,
	['zwf_pot_hydro'] = true,
	['zwf_pot'] = true,
	['zmlab_collectcrate'] = true
}

hook.Add("HUDPaint", "destroysomeprops", function()
	local tr = LocalPlayer():GetEyeTrace()
	local ent = tr.Entity
	if not ent:IsValid() or tr.StartPos:DistToSqr(tr.HitPos) > 60000 then return end

	if not allowedents[LocalPlayer():GetEyeTrace().Entity:GetClass()] then return end

	local rem = ent:GetNW2Int("created")
	local frez = ent:GetNW2Int("freeze")
	if frez > 0 then
		draw.ShadowedText("До заморозки "..math.Round(rem - CurTime()).." сек.", "CloseCaption_Bold", "CloseCaption_BoldItalic", ScrW()*0.5, ScrH()*0.7, Color(255,255,255), 0.5, 0)
	else
		draw.ShadowedText("ЛКМ гравиганом чтобы разморозить", "CloseCaption_Bold", "CloseCaption_BoldItalic", ScrW()*0.5, ScrH()*0.7, Color(255,255,255), 0.5, 0)
	end
end)
--PATH addons/111mod/lua/darkrp_customthings/ammo.lua:
--[[---------------------------------------------------------------------------
Ammo types
---------------------------------------------------------------------------
Ammo boxes that can be purchased in the F4 menu.
Add your custom ammo types in this file. Here's the syntax:
DarkRP.createAmmoType("ammoType", {
    name = "Ammo name",
    model = "Model",
    price = 1234,
    amountGiven = 5678,
    customCheck = function(ply) return ply:IsAdmin()
})
ammoType: The name of the ammo that Garry's mod recognizes
   If you open your SWEP's shared.lua, you can find the ammo name next to
   SWEP.Primary.Ammo = "AMMO NAME HERE"
   or
   SWEP.Secondary.Ammo = "AMMO NAME HERE"
   You can find the default gmod ammo types here: https://wiki.garrysmod.com/page/Default_Ammo_Types
name: The name you want to give to the ammo. This can be anything.
model: The model you want the ammo to have in the F4 menu
price: the price of your ammo in dollars
amountGiven: How much bullets of this ammo is given every time the player buys it
customCheck: (Optional! Advanced!) a Lua function that describes who can buy the ammo.
    Similar to the custom check function for jobs and shipments
    Parameters:
	    ply: the player who is trying to buy the ammo
Examples are below!
Pistol ammo type. Used by p228, desert eagle and all other pistols.
This ammo addition is different from the following three due to it making use of the "custom check" line.
Example 1:
DarkRP.createAmmoType("pistol", {
    name = "Pistol ammo",
    model = "models/Items/BoxSRounds.mdl",
    price = 30,
    amountGiven = 24,
    customCheck = function(ply) return
        table.HasValue({TEAM_EX_CONNORKENWAY}, ply:Team())
    end,
    CustomCheckFailMsg = "This ammo is for Connor only!",
})
Buckshot ammo, used by the shotguns
Example 2:
DarkRP.createAmmoType("buckshot", {
    name = "Shotgun ammo",
    model = "models/Items/BoxBuckshot.mdl",
    price = 50,
    amountGiven = 8
})
Rifle ammo, usually used by assault rifles
Example 3:
DarkRP.createAmmoType("ar2", {
    name = "Rifle ammo",
    model = "models/Items/BoxMRounds.mdl",
    price = 80,
    amountGiven = 30
})
SMG Ammo, usually used by small lightweight automatic guns.
Example 4:
DarkRP.createAmmoType("smg1", {
    name = "SMG ammo",
    model = "models/Items/BoxMRounds.mdl",
    price = 20,
    amountGiven = 30
})
Add new ammo types under the next line!
---------------------------------------------------------------------------]]

DarkRP.createAmmoType("smg1", {
    name = "Пистолеты-пулеметы",
    model = "models/Items/BoxMRounds.mdl",
    price = 45,
    amountGiven = 30,
    category = "Патроны"
})

DarkRP.createAmmoType("ar2", {
    name = "Винтовки/снайперки/Тяж",
    model = "models/Items/BoxMRounds.mdl",
    price = 80,
    amountGiven = 30,
    category = "Патроны"
})

DarkRP.createAmmoType("buckshot", {
    name = "Дробовики",
    model = "models/Items/BoxBuckshot.mdl",
    price = 50,
    amountGiven = 8,
    category = "Патроны"
})

DarkRP.createAmmoType("pistol", {
    name = "Пистолеты",
    model = "models/Items/BoxSRounds.mdl",
    price = 30,
    amountGiven = 24,
    category = "Патроны"
})
--PATH addons/m9k/lua/weapons/awpdragon/shared.lua:

SWEP.Gun = ("awpdragon")
SWEP.Category				= "Clout's CSGO Weapons"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "AWP - Dragon Lore"	
SWEP.Slot				= 2			
SWEP.SlotPos				= 4		
SWEP.DrawAmmo				= true	
SWEP.DrawWeaponInfoBox			= false		
SWEP.BounceWeaponIcon   		= 	false
SWEP.DrawCrosshair			= false	
SWEP.Weight				= 50		
SWEP.AutoSwitchTo			= true	
SWEP.AutoSwitchFrom			= true	
SWEP.XHair					= false	
SWEP.BoltAction				= true
SWEP.HoldType 				= "rpg"		

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_clout_awp.mdl"	
SWEP.WorldModel				= "models/weapons/w_snip_awp.mdl"	
SWEP.ShowWorldModel			= false
SWEP.Base 				= "bobs_scoped_base" 
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("dragon_shot_sound")
SWEP.Primary.RPM				= 55		
SWEP.Primary.ClipSize			= 10		
SWEP.Primary.DefaultClip			= 30	
SWEP.Primary.KickUp			= 1				
SWEP.Primary.KickDown			= 1			
SWEP.Primary.KickHorizontal			= 1		
SWEP.Primary.Automatic			= false		
SWEP.Primary.Ammo			= "SniperPenetratedRound"

SWEP.Secondary.ScopeZoom			= 8	
SWEP.Secondary.UseACOG			= false 
SWEP.Secondary.UseMilDot		= true
SWEP.Secondary.UseClout         = false
SWEP.Secondary.UseSVD			= false
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	

SWEP.data 				= {}
SWEP.data.ironsights			= 1
SWEP.ScopeScale 			= 1
SWEP.ReticleScale 				= 0.6

SWEP.Primary.Damage		= 140	
SWEP.Primary.Spread		= .015	
SWEP.Primary.IronAccuracy = .0001 


SWEP.SightsPos = Vector(5, -4.624, 0.879)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(-0.681, -2.329, 0)
SWEP.RunSightsAng = Vector(-12.804, -37.112, 11.071)

SWEP.WElements = {
	["weapon_dragonlore"] = { type = "Model", model = "models/weapons/w_clout_awp.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(0, 1.616, 0), angle = Angle(-15.301, 7.714, 180), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

--PATH addons/truefishing/lua/weapons/fishing_rod_3/shared.lua:
if SERVER then
	AddCSLuaFile("shared.lua")
end

if CLIENT then
	SWEP.PrintName = "Удочка уровень 3"
	SWEP.Slot = 3
	SWEP.SlotPos = 3
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
end

SWEP.Base = "fishing_rod"

SWEP.Author = "MrGeRoI"
SWEP.Instructions = "ЛКМ, чтобы пустить леску.\nПКМ, чтобы поймать рыбу."
SWEP.Contact = ""
SWEP.Purpose = ""

SWEP.BarSize = 0.11
SWEP.RodLevel = 2

--PATH addons/truefishing/lua/weapons/fishing_rod_physics/shared.lua:
if SERVER then
	AddCSLuaFile("shared.lua")
	util.AddNetworkString("rod_phys_Fishing")
	util.AddNetworkString("rod_phys_Pull")
	util.AddNetworkString("rod_phys_End")
	util.AddNetworkString("FishPoleStrength")
end

if CLIENT then
	SWEP.PrintName = "Fishing Rod (Physics based)"
	SWEP.Slot = 3
	SWEP.SlotPos = 3
	SWEP.DrawAmmo = false
	SWEP.DrawCrosshair = false
end

SWEP.Author = "Tomasas"
SWEP.Instructions = "Left click to cast a line.\nRight click to try and catch a fish."
SWEP.Contact = ""
SWEP.Purpose = ""


//SWEP.AnimPrefix	 = "rpg"
SWEP.WorldModel = ""//"models/fishing/pole.mdl"
SWEP.ViewModel = ""

SWEP.Spawnable = false
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""

function SWEP:Initialize()
	self:SetWeaponHoldType("revolver")
	if CLIENT and self.Owner == LocalPlayer() then
		self.Owner.ReceivedFishingTip = true
		chat.AddText(Color(255,255,255), TrueFishLocal("fishing_rod_phys_tip"))
	end
end

function SWEP:DrawWorldModel()
	return true
end

function SWEP:Holster()
	if CLIENT then
		self.Owner.ThirdViewPhys = nil
		if LocalPlayer() == self.Owner then
			self.DrawFishing = nil
		end
	end
	if SERVER then
		self.Owner.IsFishing = nil
		
		if IsValid(self.WeaponModel) then
			self.WeaponModel:Remove()
		end
		if IsValid(self.Hook) then
			self.Hook:Remove()
		end
		
	end
	return true
end

if CLIENT then
	local tracedata = {mask = CONTENTS_SOLID + 268435488 + CONTENTS_OPAQUE}
	local function SWEPCalcView(ply, pos, ang, fov)
		if ply.ThirdViewPhys then
			ang.p = 35
			//ang.y = 45
			tracedata.start = pos
			tracedata.endpos = pos-ang:Forward()*150
			local trace = util.TraceLine(tracedata)
			return {origin = trace.HitWorld and trace.HitPos+ply:GetForward()*3 or tracedata.endpos, angles = ang, fov = fov, drawviewer = true}
		end
	end
	hook.Add("CalcView", "Fishing Rod Phys", SWEPCalcView)

	function SWEP:DrawHUD()
		if !self.Owner.ThirdViewPhys or !self.DrawFishing then return end

		local left = (self.StartedFishing+self.DrawFishing-CurTime())/self.DrawFishing
		if left < 0 then return end
		left = left - 0.5
		
		local x, y = math.floor(TFScreenScale(81)), math.floor(TFScreenScale(7))

		surface.SetDrawColor(0, 0, 0, 135)
		surface.DrawRect(ScrW()*0.5-x*0.5, ScrH()*0.8, x, y)
		for i=1, y do
			surface.SetDrawColor(0, 0.5*i*y, 0, 255)
			surface.DrawLine(ScrW()*0.5-x*0.5, ScrH()*0.8+i-1, ScrW()*0.5+x*left, ScrH()*0.8+i-1)
		end
		for i=1, 4 do
			surface.SetDrawColor(125+i*10, 125+i*10, 125+i*10, 255)
			surface.DrawOutlinedRect(ScrW()*0.5-x*0.5-i, ScrH()*0.8-i, x+i*2, y+i*2)
		end
		draw.SimpleText(TrueFishLocal("fishing_hud"), "SegoeUI_NormalBoldScaled", ScrW()*0.5, ScrH()*0.8-TFScreenScale(1), Color(220, 220, 220, 255), TEXT_ALIGN_CENTER)
	end

	local lineColor = Color(255, 255, 255, 100)
	net.Receive("rod_phys_Fishing", function()
		local owner = LocalPlayer()
		if !owner or !owner:IsValid() then return end
		local wep = owner:GetActiveWeapon()
		if !wep or !wep:IsValid() or wep:GetClass() != "fishing_rod_physics" then return end
		
		local wait = net.ReadUInt(12)
		
		if wait != 0 then
			owner.ThirdViewPhys = true
			wep.DrawFishing = wait
			wep.StartedFishing = CurTime()-owner:Ping()*0.001
		end
	end)

	net.Receive("rod_phys_Pull", function()
		local owner = LocalPlayer()
		if !owner or !owner:IsValid() then return end
		local wep = owner:GetActiveWeapon()
		if !wep or !wep:IsValid() then return end

		local ent = net.ReadEntity()
		local nextSplash = CurTime()
		wep.Think = function()
			local ctime = CurTime()
			if nextSplash < ctime and ent:IsValid() and ent:WaterLevel() > 0 then
				chat.PlaySound()
				local effectdata = EffectData()
				local pos = ent:GetPos()
				effectdata:SetOrigin(pos)
				effectdata:SetNormal(pos)
				effectdata:SetRadius(5)
				effectdata:SetScale(4)
				util.Effect("watersplash", effectdata)
				nextSplash = ctime+0.1
			end
		end
		
	end)

	net.Receive("rod_phys_End", function()
		local owner = LocalPlayer()
		if !owner or !owner:IsValid() then return end
		local wep = owner:GetActiveWeapon()
		if !wep or !wep:IsValid() then return end

		wep.Think = function() end
		owner.ThirdViewPhys = false
		
	end)

	local Strength = 175
	function SWEP:Reload()
		if self.LastR and self.LastR > SysTime() then return end
		self.LastR = SysTime()+1
		local Window = vgui.Create( "DFrame" )
			Window:SetTitle( "" )
			Window:SetDraggable( false )
			Window:ShowCloseButton( false )
			Window:SetBackgroundBlur( false )
			Window:SetDrawOnTop( true )
			Window.Paint = function(self)			
				draw.RoundedBoxEx(8, 0, 0, self:GetWide(), 20, Color(47, 54, 76, 255), true, true)
				draw.SimpleText(TrueFishLocal("throw_str"), "FishingS20", self:GetWide()*0.5, 0, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)
				draw.RoundedBoxEx(8, 0, self:GetTall()-30, self:GetWide(), 30, Color(47, 54, 76, 255), false, false, true, true)
				surface.SetDrawColor(60, 64, 83, 255)
				surface.DrawRect(0, 20, self:GetWide(), self:GetTall()-50)
				
				surface.SetDrawColor(50, 50, 50, 255)
				surface.DrawOutlinedRect(0, 20, self:GetWide(), self:GetTall()-50)
			end
			
		local InnerPanel = vgui.Create( "DPanel", Window )
			InnerPanel:SetDrawBackground( false )
		
		local Text = vgui.Create( "DLabel", InnerPanel )
			Text:SetText( TrueFishLocal("throw_desc") )
			Text:SizeToContents()
			Text:SetContentAlignment( 5 )
			Text:SetTextColor( color_white )
			
		local TextEntry = vgui.Create( "DNumSlider", InnerPanel ) // y the fuck does this derma not have color editing for notches...
			TextEntry:SetMin(0)
			TextEntry:SetMax(800)
			TextEntry:SetValue(Strength)
			TextEntry:SetDark(false)
			TextEntry.TextArea:SetTextColor(Color(255, 255, 255, 255))
			
		local ButtonPanel = vgui.Create( "DPanel", Window )
			ButtonPanel:SetTall( 30 )
			ButtonPanel:SetDrawBackground( false )
			
		local Button = vgui.Create( "DButton", ButtonPanel )
			Button:SetText( "OK" )
			Button:SetColor(Color(250, 250, 250, 255))
			Button:SetFont("FishingS16")
			Button:SizeToContents()
			Button:SetTall( 20 )
			Button:SetWide( Button:GetWide() + 20 )
			Button:SetPos( 5, 5 )
			Button.DoClick = function()
				net.Start("FishPoleStrength")
				net.WriteFloat(TextEntry:GetValue())
				net.SendToServer()
				Strength = TextEntry:GetValue()
				Window:Close()
			end
			Button.Paint = function(self)
				surface.SetDrawColor(self.Hovered and Color(99, 102, 111, 255) or Color(69, 72, 81, 255))
				surface.DrawRect(0, 0, self:GetWide(), self:GetTall())
				surface.SetDrawColor(50, 50, 50, 255)
				surface.DrawOutlinedRect(0, 0, self:GetWide(), self:GetTall())
			end
			
		local ButtonCancel = vgui.Create( "DButton", ButtonPanel )
			ButtonCancel:SetText( "Cancel" )
			ButtonCancel:SetColor(Color(250, 250, 250, 255))
			ButtonCancel:SetFont("FishingS16")
			ButtonCancel:SizeToContents()
			ButtonCancel:SetTall( 20 )
			ButtonCancel:SetWide( Button:GetWide() + 20 )
			ButtonCancel:SetPos( 5, 5 )
			ButtonCancel.DoClick = function() Window:Close() end
			ButtonCancel:MoveRightOf( Button, 5 )
			ButtonCancel.Paint = Button.Paint
			
		ButtonPanel:SetWide( Button:GetWide() + 5 + ButtonCancel:GetWide() + 10 )
		
		local w, h = Text:GetSize()
		w = math.max( w, 400 ) 
		
		Window:SetSize( w + 50, h + 25 + 75 + 10 )
		Window:Center()
		
		InnerPanel:StretchToParent( 5, 25, 5, 45 )
		
		Text:StretchToParent( 5, 5, 5, 35 )	
		
		TextEntry:StretchToParent( 5, nil, 5, nil )
		//TextEntry:SetSize(Window:GetWide()-10, 20)
		TextEntry:SetPos(-TextEntry:GetWide()*0.225, 25)
		//TextEntry:AlignBottom( 5 )
		
		TextEntry:RequestFocus()
		//TextEntry:SelectAllText( true )
		
		ButtonPanel:CenterHorizontal()
		ButtonPanel:AlignBottom( 2 )
		
		Window:MakePopup()
		Window:DoModal()
	end
end

local emptyf = function() end//destroy click sound
SWEP.PrimaryAttack = emptyf
SWEP.SecondaryAttack = emptyf
if CLIENT then return end

net.Receive("FishPoleStrength", function(len, ply)
	ply.HookThrowStr = math.Clamp(net.ReadFloat(), 0, 800)
end)


function SWEP:Think()
	if !IsValid(self.WeaponModel) or !IsValid(self.Hook) then self:Deploy(true) end
	local pos, ang = self.Owner:GetBonePosition(self.Owner:LookupBone("ValveBiped.Bip01_R_Hand", false))
	ang:RotateAroundAxis(ang:Right(), -55)
	//ang:RotateAroundAxis(ang:Forward(), 90)
	pos = pos - ang:Forward()*6.5 + ang:Up()*1.275 + ang:Right()*1.5
	self.WeaponModel:SetPos(pos)
	self.WeaponModel:SetAngles(ang)
	
	if self.Owner.IsFishing then
		local ctime = CurTime()
		if self.FishingEndTime <= ctime then
			self:NoCatch()
		elseif self.FishingTimeWindow <= ctime then
			net.Start("rod_phys_Pull")
			net.WriteEntity(self.Hook)
			net.Send(self.Owner)
			self.Owner.IsFishing = 1
			self.FishingTimeWindow = self.FishingEndTime
		end
	end
end

function SWEP:AdjustRope(len)
	constraint.RemoveConstraints(self.WeaponModel, "Rope")
	local pos, ang = self.WeaponModel:GetPos(), self.WeaponModel:GetAngles()
	//ang:RotateAroundAxis(ang:Right(), -55)
	//pos = ang:Forward()*98 + ang:Up()*0.25 
	constraint.Rope(self.WeaponModel, self.Hook, 0, 0, Vector(98, 0, 0.25), Vector(0, 0, 20), len, 0, 0, 0, "cable/cable2", false)
end

function SWEP:Deploy(fromNotEngine)
	if !IsValid(self.WeaponModel) then
		self.WeaponModel = ents.Create("fishing_rod_pole")
		self.WeaponModel:SetDTEntity(0, self.Owner)
		self.WeaponModel:Spawn()
		self.WeaponModel:GetPhysicsObject():SetMass(50000)
		self:Think()
	end
	if !IsValid(self.Hook) then
		self.Hook = ents.Create("fishing_rod_hook")
		self.Hook:SetModelScale(0.5, 0)
		self.Hook:SetPos(self.Owner:GetPos() + self.Owner:GetForward()*20 + Vector(0, 0, 20))
		self.Hook:Spawn()
		self:AdjustRope(50)
	end
	if IsValid(self.WeaponModel) and IsValid(self.Hook) then
		self.WeaponModel:SetDTEntity(1, self.Hook)
	end
	self.Owner:DrawViewModel(false)
end

function SWEP:OnRemove()
	if IsValid(self.WeaponModel) then
		self.WeaponModel:Remove()
	end
	if IsValid(self.Hook) then
		self.Hook:Remove()
	end
end

function SWEP:PrimaryAttack()
	
	if self.Owner.IsFishing or !self.Owner:OnGround() then return end

	if !self.Owner.FishBait or self.Owner.FishBait == 0 then
		TrueFishNotify(self.Owner, TrueFishLocal("no_fish_bait"))
		return false
	end
	
	self.Owner.HookThrowStr = self.Owner.HookThrowStr or 175
	
	local ang = self.Owner:GetAngles()
	ang.r = 0
	ang.p = 0
	local tracedata = {start = self.Owner:GetPos()+ang:Forward()*(self.Owner.HookThrowStr+70+math.random(-50, 50))+ang:Right()*math.random(-80, 80)}
	tracedata.start.z = tracedata.start.z + 50
	tracedata.endpos = Vector(tracedata.start.x, tracedata.start.y, tracedata.start.z-80)
	local trace = util.TraceLine(tracedata)
	tracedata.start.z = tracedata.start.z + 50
	tracedata.endpos.z = tracedata.endpos.z - 130
	tracedata.mask = CONTENTS_SOLID + 268435488 + CONTENTS_OPAQUE
	local trace2 = util.TraceLine(tracedata)
	if !trace.Hit and trace2.HitWorld then
		self.Owner.FishBait = self.Owner.FishBait - 1
		
		self:AdjustRope(trace2.HitPos:Distance(self.Owner:GetPos()) )
		local phys = self.Hook:GetPhysicsObject()
		ang = self.Owner:GetAngles()
		local force = ang:Forward()*(self.Owner.HookThrowStr+70)*2+Vector(0, 0, 500)
		phys:ApplyForceCenter(force)
		
		tracedata.start = trace2.HitPos
		tracedata.endpos.z = tracedata.endpos.z - FISH_MAX_DEPTH
		tracedata.mask = MASK_OPAQUE
		trace = util.TraceLine(tracedata)
		self.Depth = !trace.Hit and FISH_MAX_DEPTH or math.Clamp(math.abs(trace.HitPos.z - tracedata.start.z), 15, FISH_MAX_DEPTH)

		local owner = self.Owner
		owner.IsFishing = true
		
		local fish = TrueFishCalculateFish(self.Depth)
		local waitTime = TrueFish.ROD_SEPERATE_CATCH_TIME_ENABLED and TrueFish.ROD_SEPERATE_CATCH_TIME or !TrueFish.FISH_CATCH_TIME[fish] and TrueFish.ROD_SEPERATE_CATCH_TIME or math.random(TrueFish.FISH_CATCH_TIME[fish][1], TrueFish.FISH_CATCH_TIME[fish][2])
		net.Start("rod_phys_Fishing")
		net.WriteUInt(waitTime, 12)
		net.Send(owner)
		self.FishingEndTime = CurTime() + waitTime
		self.FishingTimeWindow = self.FishingEndTime - waitTime*TrueFish.ROD_CATCH_WINDOW
		
	end
	
	
end

function SWEP:NoCatch()
	net.Start("rod_phys_End")
	net.Send(self.Owner)
	self.Owner.IsFishing = false
	TrueFishNotify(self.Owner, TrueFishLocal("didnt_catch_anything"))
	self:AdjustRope(50)
end

function SWEP:SecondaryAttack()
	if self.Owner.IsFishing == true then
		self:NoCatch()
		return
	end
	if self.Owner.IsFishing == 1 and self.Hook:WaterLevel() > 0 then
		net.Start("rod_phys_End")
		net.Send(self.Owner)
		self.Owner.IsFishing = false
		self:AdjustRope(95)
		
		local fish = TrueFishCalculateFish(self.Depth)
		if math.random(1000) <= TrueFish.ROD_JUNK_CHANCE then
			fish = FISH_JUNK
		end
		
		if math.random(1000) <= TrueFish.ROD_MONEYBAG_CHANCE then // Yes, JUNK and MONEY BAG chances aren't 100% this way
			self.Hook:AddMoneyBag()
			return
		end
		
		if !fish then
			TrueFishNotify(self.Owner, TrueFishLocal("didnt_catch_anything"))
			return
		else
			TrueFishNotify(self.Owner, TrueFishLocal("hook_caught"))
		end
		
		self.Hook:AddFish(fish)
	end
end
--PATH gamemodes/sandbox/entities/weapons/gmod_tool/stools/stackerv2.lua:
--[[--------------------------------------------------------------------------
-- Localized Functions & Variables
--------------------------------------------------------------------------]]--

-- localizing globals is an encouraged practice that inproves code efficiency,
-- accessing a local value is considerably faster than a global value
local bit = bit
local util = util
local math = math
local undo = undo
local halo = halo
local game = game
local ents = ents
local pairs = pairs 
local table = table
local Angle = Angle
local Color = Color
local Vector = Vector
local IsValid = IsValid
local language = language
local tonumber = tonumber
local constraint = constraint
local concommand = concommand
local LocalPlayer = LocalPlayer
local CreateConVar = CreateConVar
local GetConVarNumber = GetConVarNumber
local RunConsoleCommand = RunConsoleCommand

local MOVETYPE_NONE = MOVETYPE_NONE
local SOLID_VPHYSICS = SOLID_VPHYSICS
local RENDERMODE_TRANSALPHA = RENDERMODE_TRANSALPHA

--[[--------------------------------------------------------------------------
-- Tool Settings
--------------------------------------------------------------------------]]--

TOOL.Category   = "Основное"
TOOL.Name       = "#Копирование пропов"
TOOL.Command    = nil
TOOL.ConfigName = ""

TOOL.ClientConVar[ "mode" ]      = "1"
TOOL.ClientConVar[ "dir" ]       = "1"
TOOL.ClientConVar[ "count" ]     = "1"
TOOL.ClientConVar[ "freeze" ]    = "1"
TOOL.ClientConVar[ "weld" ]      = "0"
TOOL.ClientConVar[ "nocollide" ] = "0"
TOOL.ClientConVar[ "ghostall" ]  = "1"
TOOL.ClientConVar[ "material" ]  = "1"
TOOL.ClientConVar[ "physprop" ]  = "1"
TOOL.ClientConVar[ "color" ]     = "1"
TOOL.ClientConVar[ "model" ]     = ""
TOOL.ClientConVar[ "offsetx" ]   = "0"
TOOL.ClientConVar[ "offsety" ]   = "0"
TOOL.ClientConVar[ "offsetz" ]   = "0"
TOOL.ClientConVar[ "rotp" ]      = "0"
TOOL.ClientConVar[ "roty" ]      = "0"
TOOL.ClientConVar[ "rotr" ]      = "0"
TOOL.ClientConVar[ "recalc" ]    = "0"
TOOL.ClientConVar[ "halo" ]      = "0"
TOOL.ClientConVar[ "halo_r" ]    = "0"
TOOL.ClientConVar[ "halo_g" ]    = "200"
TOOL.ClientConVar[ "halo_b" ]    = "190"
TOOL.ClientConVar[ "halo_a" ]    = "255"

if ( CLIENT ) then

	language.Add( "Tool.stackerv2.name", "Копирование пропов" )
	language.Add( "Tool.stackerv2.desc", "Копируйте пропы" )
	language.Add( "Tool.stackerv2.0",    "Click to stack the prop you're pointing at." )
	language.Add( "Undone_stackerv2",    "Undone stacked prop(s)" )
	
end

--[[--------------------------------------------------------------------------
-- Enumerations
--------------------------------------------------------------------------]]--

local MODE_WORLD = 1 -- stacking relative to the world
local MODE_PROP  = 2 -- stacking relative to the prop

local DIRECTION_UP     = 1
local DIRECTION_DOWN   = 2
local DIRECTION_FRONT  = 3
local DIRECTION_BEHIND = 4
local DIRECTION_RIGHT  = 5
local DIRECTION_LEFT   = 6

local VECTOR_ZERO = Vector( 0, 0, 0 )

local ANGLE_ZERO = Angle( 0, 0, 0 )
local ANGLE_FRONT      = ANGLE_ZERO:Forward()
local ANGLE_RIGHT      = ANGLE_ZERO:Right()
local ANGLE_UP         = ANGLE_ZERO:Up()
local ANGLE_BEHIND     = -ANGLE_FRONT
local ANGLE_LEFT       = -ANGLE_RIGHT
local ANGLE_DOWN       = -ANGLE_UP

local TRANSPARENT = Color( 255, 255, 255, 150 )

--[[--------------------------------------------------------------------------
-- Console Variables
--------------------------------------------------------------------------]]--

CreateConVar( "stackerv2_max_count",         1, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ) ) -- defines the max amount of props that can be stacked at a time
CreateConVar( "stackerv2_max_offsetx",     100, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ) ) -- defines the max distance on the x plane that stacked props can be offset (for individual control)
CreateConVar( "stackerv2_max_offsety",     100, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ) ) -- defines the max distance on the y plane that stacked props can be offset (for individual control)
CreateConVar( "stackerv2_max_offsetz",     100, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ) ) -- defines the max distance on the z plane that stacked props can be offset (for individual control)
CreateConVar( "stackerv2_stayinworld",       0, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ) ) -- determines whether props should be restricted to spawning inside the world or not (addresses possible crashes)
CreateConVar( "stackerv2_force_freeze",      1, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ) ) -- determines whether props should be forced to spawn frozen or not
CreateConVar( "stackerv2_force_weld",        0, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ) ) -- determines whether props should be forced to spawn welded or not
CreateConVar( "stackerv2_force_nocollide",   0, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ) ) -- determines whether props should be forced to spawn nocollided or not
CreateConVar( "stackerv2_delay",             0, bit.bor( FCVAR_NOTIFY, FCVAR_REPLICATED, FCVAR_SERVER_CAN_EXECUTE ) ) -- determines the amount of time that must pass before a player can use stacker again

--[[--------------------------------------------------------------------------
-- Console Commands
--------------------------------------------------------------------------]]--

if ( CLIENT ) then
	
	local function ResetOffsets( ply, command, arguments )
		-- Reset all of the offset options to 0 and adv options to 1
		LocalPlayer():ConCommand( "stackerv2_offsetx -0.60" )
		LocalPlayer():ConCommand( "stackerv2_offsety 0" )
		LocalPlayer():ConCommand( "stackerv2_offsetz 0" )
		LocalPlayer():ConCommand( "stackerv2_rotp 0" )
		LocalPlayer():ConCommand( "stackerv2_roty 0" )
		LocalPlayer():ConCommand( "stackerv2_rotr 0" )
		--LocalPlayer():ConCommand( "stackerv2_recalc 1" )
		--LocalPlayer():ConCommand( "stackerv2_ghostall 1" )
		--LocalPlayer():ConCommand( "stackerv2_material 1" )
		--LocalPlayer():ConCommand( "stackerv2_color 1" )
		--LocalPlayer():ConCommand( "stackerv2_physprop 1" )
		--LocalPlayer():ConCommand( "stackerv2_halo 1" )
	end
	concommand.Add( "stackerv2_resetoffsets", ResetOffsets )
	
elseif ( SERVER ) then

	local function ValidateCommand( ply, arg )
		if ( IsValid( ply ) and !ply:IsAdmin() ) then return false end
		local count = tonumber( arg )
		if ( !count or count < 0 ) then return false end
		return true
	end
	--[[-------------------------------------------------------------]]--
	concommand.Add( "stackerv2_set_maxcount", function( ply, cmd, args )		
		if ( !ValidateCommand( ply, args[1] ) ) then return false end
		
		RunConsoleCommand( "stackerv2_max_count", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( "stackerv2_set_maxoffset", function( ply, cmd, args )
		if ( !ValidateCommand( ply, args[1] ) ) then return false end
		
		RunConsoleCommand( "stackerv2_max_offsetx", args[1] )
		RunConsoleCommand( "stackerv2_max_offsety", args[1] )
		RunConsoleCommand( "stackerv2_max_offsetz", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( "stackerv2_set_maxoffsetx", function( ply, cmd, args )
		if ( !ValidateCommand( ply, args[1] ) ) then return false end
		
		RunConsoleCommand( "stackerv2_max_offsetx", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( "stackerv2_set_maxoffsety", function( ply, cmd, args )
		if ( !ValidateCommand( ply, args[1] ) ) then return false end
		
		RunConsoleCommand( "stackerv2_max_offsety", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( "stackerv2_set_maxoffsetz", function( ply, cmd, args )
		if ( !ValidateCommand( ply, args[1] ) ) then return false end
		
		RunConsoleCommand( "stackerv2_max_offsetz", args[1] )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( "stackerv2_set_stayinworld", function( ply, cmd, args )
		if ( !ValidateCommand( ply, args[1] ) ) then return false end
		
		RunConsoleCommand( "stackerv2_stayinworld", ( tobool( args[1] ) and 1 ) or 0 )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( "stackerv2_set_freeze", function( ply, cmd, args )
		if ( !ValidateCommand( ply, args[1] ) ) then return false end
		
		RunConsoleCommand( "stackerv2_force_freeze", ( tobool( args[1] ) and 1 ) or 0 )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( "stackerv2_set_weld", function( ply, cmd, args )
		if ( !ValidateCommand( ply, args[1] ) ) then return false end
		
		RunConsoleCommand( "stackerv2_force_weld", ( tobool( args[1] ) and 1 ) or 0 )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( "stackerv2_set_nocollide", function( ply, cmd, args )
		if ( !ValidateCommand( ply, args[1] ) ) then return false end
		
		RunConsoleCommand( "stackerv2_force_nocollide", ( tobool( args[1] ) and 1 ) or 0 )
	end )
	--[[-------------------------------------------------------------]]--
	concommand.Add( "stackerv2_set_delay", function( ply, cmd, args )
		if ( !ValidateCommand( ply, args[1] ) ) then return false end
		
		RunConsoleCommand( "stackerv2_delay", args[1] )
	end )
end



--[[--------------------------------------------------------------------------
-- Convenience Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
-- 	GetGhostStack(), SetGhostStack( table )
--
--	Gets and sets the table of ghosted props in the stack.
--]]--
local function GetGhostStack() return GhostStack       end
local function SetGhostStack( tbl )   GhostStack = tbl end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetCount()
--
--	Gets the maximum amount of props that can be stacked at a time
--]]--
function TOOL:GetCount() 
	return math.Clamp( self:GetClientNumber( "count" ), 0, GetConVarNumber( "stackerv2_max_count" ) ) 
end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetDirection()
--
--	Gets the direction to stack the props
--]]--
function TOOL:GetDirection() return self:GetClientNumber( "dir" ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetStackerMode()
--
--	Gets the stacker mode (1 = MODE_WORLD, 2 = MODE_PROP)
--]]--
function TOOL:GetStackerMode() return self:GetClientNumber( "mode" ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetOffsetX(), TOOL:GetOffsetY(), TOOL:GetOffsetZ(), TOOL:GetOffsetVector()
--
--	Gets the distance to offset the position of the stacked props.
--	These values are clamped to prevent server crashes from players
--	using very high offset values.
--]]--
function TOOL:GetOffsetX() return math.Clamp( self:GetClientNumber( "offsetx" ), - GetConVarNumber( "stackerv2_max_offsetx" ), GetConVarNumber( "stackerv2_max_offsetx" ) ) end
function TOOL:GetOffsetY() return math.Clamp( self:GetClientNumber( "offsety" ), - GetConVarNumber( "stackerv2_max_offsety" ), GetConVarNumber( "stackerv2_max_offsety" ) ) end
function TOOL:GetOffsetZ() return math.Clamp( self:GetClientNumber( "offsetz" ), - GetConVarNumber( "stackerv2_max_offsetz" ), GetConVarNumber( "stackerv2_max_offsetz" ) ) end

function TOOL:GetOffsetVector() return Vector( self:GetOffsetX(), self:GetOffsetY(), self:GetOffsetZ() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetRotateP(), TOOL:GetRotateY(), TOOL:GetRotateR(), TOOL:GetRotateAngle()
--
--	Gets the value to rotate the angle of the stacked props.
--	These values are clamped to prevent server crashes from players
--	using very high rotation values.
--]]--
function TOOL:GetRotateP() return math.Clamp( self:GetClientNumber( "rotp" ), -360, 360 ) end
function TOOL:GetRotateY() return math.Clamp( self:GetClientNumber( "roty" ), -360, 360 ) end
function TOOL:GetRotateR() return math.Clamp( self:GetClientNumber( "rotr" ), -360, 360 ) end

function TOOL:GetRotateAngle() return Angle( self:GetRotateP(), self:GetRotateY(), self:GetRotateR() ) end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldFreeze()
--
--	Returns true if the stacked props should be spawned frozen.
--]]--
function TOOL:ShouldApplyFreeze() return self:GetClientNumber( "freeze" ) == 1 end
function TOOL:ShouldForceFreeze() return GetConVarNumber( "stackerv2_force_freeze" ) == 1 end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldWeld()
--
--	Returns true if the stacked props should be welded together.
--]]--
function TOOL:ShouldApplyWeld() return self:GetClientNumber( "weld" ) == 1 end
function TOOL:ShouldForceWeld() return GetConVarNumber( "stackerv2_force_weld" ) == 1 end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldNoCollide()
--
--	Returns true if the stacked props should be nocollided with each other.
--]]--
function TOOL:ShouldApplyNoCollide() return self:GetClientNumber( "nocollide" ) == 1 end
function TOOL:ShouldForceNoCollide() return GetConVarNumber( "stackerv2_force_nocollide" ) == 1 end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldStackRelative()
--
--	Returns true if the stacked props should be stacked relative to the new rotation.
--	Using this setting will allow you to create curved structures out of props.
--]]--
function TOOL:ShouldStackRelative() return self:GetClientNumber( "recalc" ) == 1 end
--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldGhostAll()
--
--	Returns true if the stacked props should all be ghosted or if only the 
--	first stacked prop should be ghosted.
--]]--
function TOOL:ShouldGhostAll() return self:GetClientNumber( "ghostall" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldAddHalos(), TOOL:GetHaloR(), TOOL:GetHaloG(), TOOL:GetHaloB() TOOL:GetHaloA() TOOL:GetHaloColor()
--
--	Returns true if the stacked props should have halos drawn on them for added visibility.
--	Gets the RGBA values of the halo color.
--]]--
function TOOL:ShouldAddHalos() return self:GetClientNumber( "halo" ) == 1 end

function TOOL:GetHaloR() return math.Clamp( self:GetClientNumber( "halo_r" ), 0, 255 ) end
function TOOL:GetHaloG() return math.Clamp( self:GetClientNumber( "halo_g" ), 0, 255 ) end
function TOOL:GetHaloB() return math.Clamp( self:GetClientNumber( "halo_b" ), 0, 255 ) end
function TOOL:GetHaloA() return math.Clamp( self:GetClientNumber( "halo_a" ), 0, 255 ) end

function TOOL:GetHaloColor()
	return Color( self:GetHaloR(), self:GetHaloG(), self:GetHaloB(), self:GetHaloA() )
end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyMaterial()
--
--	Returns true if the stacked props should have the original prop's material applied.
--]]--
function TOOL:ShouldApplyMaterial() return self:GetClientNumber( "material" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyColor()
--
--	Returns true if the stacked props should have the original prop's color applied.
--]]--
function TOOL:ShouldApplyColor() return self:GetClientNumber( "color" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:ShouldApplyPhysicalProperties()
--
--	Returns true if the stacked props should have the original prop's physicsl properties
--	applied, including gravity, physics material, and weight.
--]]--
function TOOL:ShouldApplyPhysicalProperties() return self:GetClientNumber( "physprop" ) == 1 end

--[[--------------------------------------------------------------------------
-- 	TOOL:GetDelay()
--
--	Returns the time in seconds that must pass before a player can use stacker again.
--	For example, if stackerv2_delay is set to 3, a player must wait 3 seconds in between each
--	use of stacker's left click.
--]]--
function TOOL:GetDelay() return GetConVarNumber( "stackerv2_delay" ) end

--[[--------------------------------------------------------------------------
-- Tool Functions
--------------------------------------------------------------------------]]--

--[[--------------------------------------------------------------------------
--
-- 	 TOOL:Deploy()
--
--	Called when the player brings out this tool.
--]]--
function TOOL:Deploy()
	self:ReleaseGhostStack()
end

--[[--------------------------------------------------------------------------
--
-- 	 TOOL:Holster()
--
--	Called when the player switches to a different tool.
--]]--
function TOOL:Holster()
	self:ReleaseGhostStack()
end

--[[--------------------------------------------------------------------------
--
-- 	 TOOL:OnRemove()
--
--	Should be called when the toolgun is somehow removed, but more than likely
--	doesn't get called due to the way the gmod_tool was coded.
--]]--
function TOOL:OnRemove()
	self:ReleaseGhostStack()
end

--[[--------------------------------------------------------------------------
--
-- 	 TOOL:OnDrop()
--
--	Should be called when when the toolgun is dropped, but more than likely
--	doesn't get called due to the way to gmod_tool was coded.
--]]--
function TOOL:OnDrop()
	self:ReleaseGhostStack()
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:LeftClick( table )
--
--	Attempts to create a stack of props relative to the entity being left clicked.
--]]--
function TOOL:LeftClick( trace )
	if ( !IsValid( trace.Entity ) or trace.Entity:GetClass() ~= "prop_physics" ) then return false end
	if ( CLIENT ) then return true end

	local count = self:GetCount()
	if ( count <= 0 ) then return false end
	
	if ( self:GetOwner().LastStackTime and self:GetOwner().LastStackTime + self:GetDelay() > CurTime() ) then self:GetOwner():PrintMessage( HUD_PRINTTALK, "You are using stacker too quickly" ) return false end
	self:GetOwner().LastStackTime = CurTime()
	
	local dir    = self:GetDirection()
	local mode   = self:GetStackerMode()
	local offset = self:GetOffsetVector()
	local rotate = self:GetRotateAngle()

	local stackRelative = self:ShouldStackRelative()
	local stayInWorld   = GetConVarNumber( "stackerv2_stayinworld" ) == 1

	local ply = self:GetOwner()
	local ent = trace.Entity

	local entPos  = ent:GetPos()
	local entAng  = ent:GetAngles()
	local entMod  = ent:GetModel()
	local entSkin = ent:GetSkin()
	local entMat  = ent:GetMaterial()
	local entCol  = ent:GetColor()
	
	local physMat  = ent:GetPhysicsObject():GetMaterial()
	local physGrav = ent:GetPhysicsObject():IsGravityEnabled()
	local lastEnt  = ent
	local newEnts  = { ent }
	local newEnt
	
	undo.Create( "stackerv2" )
	
	for i = 1, count, 1 do
		if ( !self:GetSWEP():CheckLimit( "props" ) )                           then break end
		if ( hook.Run( "PlayerSpawnProp", self:GetOwner(), entMod ) == false ) then break end
		
		if ( i == 1 or ( mode == MODE_PROP and stackRelative ) ) then
			stackdir, height, thisoffset = self:StackerCalcPos( lastEnt, mode, dir, offset )
		end
		
		entPos = entPos + stackdir * height + thisoffset
		entAng = entAng + rotate
		
		if ( stayInWorld and !util.IsInWorld( entPos ) ) then ply:PrintMessage( HUD_PRINTTALK, "Stacked props must be spawned within the world" ) break end
		
		newEnt = ents.Create( "prop_physics" )
		newEnt:SetModel( entMod )
		newEnt:SetPos( entPos )
		newEnt:SetAngles( entAng )
		newEnt:SetSkin( entSkin )
		newEnt:Spawn()
		
		-- this hook is for external prop protections and anti-spam addons
		-- it is called before undo, ply:AddCount, and ply:AddCleanup to allow developers to
		-- remove or mark this entity so that those same functions (if overridden) can
		-- detect that the entity came from Stacker
		if ( !IsValid( newEnt ) or hook.Run( "StackerEntity", newEnt, self:GetOwner() ) ~= nil )             then break end
		if ( !IsValid( newEnt ) or hook.Run( "PlayerSpawnedProp", self:GetOwner(), entMod, newEnt ) ~= nil ) then break end

		self:ApplyMaterial( newEnt, entMat )
		self:ApplyColor( newEnt, entCol )
		self:ApplyFreeze( ply, newEnt )
		self:ApplyWeld( lastEnt, newEnt )
		
		self:ApplyPhysicalProperties( ent, newEnt, trace.PhysicsBone, { GravityToggle = physGrav, Material = physMat } )
		
		lastEnt = newEnt
		table.insert( newEnts, newEnt )
		
		undo.AddEntity( newEnt )
		ply:AddCleanup( "props", newEnt )
	end
	
	-- self:ApplyNoCollide( newEnts )
	newEnts = nil
	
	undo.SetPlayer( ply )
	undo.Finish()

	return true
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyMaterial( entity, string )
--
--	Attempts to apply the original entity's material onto the stacked props.
--]]--
function TOOL:ApplyMaterial( ent, material )
	if ( !self:ShouldApplyMaterial() ) then ent:SetMaterial( "" ) return end
	
	ent:SetMaterial( material )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyColor( entity, color )
--
--	Attempts to apply the original entity's color onto the stacked props.
--]]--
function TOOL:ApplyColor( ent, color )
	if ( !self:ShouldApplyColor() ) then return end
	
	ent:SetColor( color )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyFreeze( player, entity )
--
--	Attempts to spawn the stacked props frozen in place. If not, spawn them unfrozen.
--]]--
function TOOL:ApplyFreeze( ply, ent )
	if ( self:ShouldForceFreeze() or self:ShouldApplyFreeze() ) then
			ply:AddFrozenPhysicsObject( ent, ent:GetPhysicsObject() )
			ent:GetPhysicsObject():EnableMotion( false )
	else
		ent:GetPhysicsObject():Wake()
	end
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyWeld( entity, entity )
--
--	Attempts to weld the new entity to the last entity
--]]--
function TOOL:ApplyWeld( lastEnt, newEnt )
	if ( !self:ShouldForceWeld() and !self:ShouldApplyWeld() ) then return end

	-- constraint.Weld( lastEnt, newEnt, 0, 0, 0 )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyNoCollide( table )
--
--	Attempts to nocollide all stacker entities with one another.
--	This is roughly an O( ![N-1] ) operation, better than the previous O ( N^2 ) version.
--]]--
function TOOL:ApplyNoCollide( stackerEnts )
	if ( !self:ShouldForceNoCollide() and !self:ShouldApplyNoCollide() ) then return end
	if ( #stackerEnts == 1 ) then return end
	if ( #stackerEnts == 2 ) then constraint.NoCollide( stackerEnts[1], stackerEnts[2], 0, 0 ) return end
	
	for i = 1, #stackerEnts - 1 do
		for j = i + 1, #stackerEnts do
			constraint.NoCollide( stackerEnts[i], stackerEnts[j], 0, 0 )
		end
	end
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ApplyPhysicalProperties( entity, entity, number, table )
--
--	Attempts to apply the original entity's Gravity/Physics Material properties 
--	and weight onto the stacked propa.
--	
--]]--
function TOOL:ApplyPhysicalProperties( original, newEnt, boneID, properties )
	if ( !self:ShouldApplyPhysicalProperties() ) then return end
	
	if ( boneID ) then construct.SetPhysProp( nil, newEnt, boneID, nil, properties ) end
	newEnt:GetPhysicsObject():SetMass( original:GetPhysicsObject():GetMass() )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:StackerCalcPos( entity, number, number, number )
--
--	Calculates the positions and angles of the entity being created in the stack.
--	This function uses a lookup table for added optimization as opposed to an if-else block.
--]]--
local CALC_POS = {
	[MODE_WORLD] = {
		[DIRECTION_UP]     = function( hi, low ) return ANGLE_UP,     math.abs( hi.z - low.z ) end,
		[DIRECTION_DOWN]   = function( hi, low ) return ANGLE_DOWN,   math.abs( hi.z - low.z ) end,
		[DIRECTION_FRONT]  = function( hi, low ) return ANGLE_FRONT,  math.abs( hi.x - low.x ) end,
		[DIRECTION_BEHIND] = function( hi, low ) return ANGLE_BEHIND, math.abs( hi.x - low.x ) end,
		[DIRECTION_RIGHT]  = function( hi, low ) return ANGLE_RIGHT,  math.abs( hi.y - low.y ) end,
		[DIRECTION_LEFT]   = function( hi, low ) return ANGLE_LEFT,   math.abs( hi.y - low.y ) end,
	},
	
	[MODE_PROP] = {
		[DIRECTION_UP]     = function( ang, offset, hi, low ) return ang:Up(),           math.abs( hi.z - low.z ), (ang:Up()      * offset.X     ) + (ang:Forward() * offset.Z * -1) + (ang:Right()   * offset.Y)      end,
		[DIRECTION_DOWN]   = function( ang, offset, hi, low ) return ang:Up()      * -1, math.abs( hi.z - low.z ), (ang:Up()      * offset.X * -1) + (ang:Forward() * offset.Z     ) + (ang:Right()   * offset.Y)      end,
		[DIRECTION_FRONT]  = function( ang, offset, hi, low ) return ang:Forward(),      math.abs( hi.x - low.x ), (ang:Forward() * offset.X     ) + (ang:Up()      * offset.Z     ) + (ang:Right()   * offset.Y)      end,
		[DIRECTION_BEHIND] = function( ang, offset, hi, low ) return ang:Forward() * -1, math.abs( hi.x - low.x ), (ang:Forward() * offset.X * -1) + (ang:Up()      * offset.Z     ) + (ang:Right()   * offset.Y * -1) end,
		[DIRECTION_RIGHT]  = function( ang, offset, hi, low ) return ang:Right(),        math.abs( hi.y - low.y ), (ang:Right()   * offset.X     ) + (ang:Up()      * offset.Z     ) + (ang:Forward() * offset.Y * -1) end,
		[DIRECTION_LEFT]   = function( ang, offset, hi, low ) return ang:Right()   * -1, math.abs( hi.y - low.y ), (ang:Right()   * offset.X * -1) + (ang:Up()      * offset.Z     ) + (ang:Forward() * offset.Y)      end,
	},
}

function TOOL:StackerCalcPos( ent, mode, dir, offset )
	local height, direction
	
	if ( mode == MODE_WORLD ) then -- get the position relative to the world's directions
		direction, height = CALC_POS[ mode ][ dir ]( ent:WorldSpaceAABB() )
	elseif ( mode == MODE_PROP ) then -- get the position relative to the prop's directions
		direction, height, offset = CALC_POS[ mode ][ dir ]( ent:GetAngles(), offset, ent:OBBMaxs(), ent:OBBMins() )
	end
	
	return direction, height, offset
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:CreateGhostStack( entity, vector, angle )
--
--	Attempts to create a stack of ghosted props on the prop the player is currently
--	looking at before they actually left click to create the stack. This acts
--	as a visual aid for the player so they can see the results without actually creating
--	the entities yet (if in multiplayer).
--]]--
function TOOL:CreateGhostStack( ent )
	if ( GetGhostStack() ) then self:ReleaseGhostStack() end

	local count = self:GetCount()
	if ( !self:ShouldGhostAll() and count ~= 0 ) then count = 1 end

	local entMod  = ent:GetModel()
	local entSkin = ent:GetSkin()
	
	local ghoststack = {}
	local ghost
	
	for i = 1, count, 1 do
		if ( CLIENT ) then ghost = ents.CreateClientProp( entMod )
		else               ghost = ents.Create( "prop_physics" ) end
		
		if ( !IsValid( ghost ) ) then continue end

		ghost:SetModel( entMod )
		ghost:SetSkin( entSkin )
		ghost:Spawn()

		ghost:SetSolid( SOLID_VPHYSICS )
		ghost:SetMoveType( MOVETYPE_NONE )
		ghost:SetRenderMode( RENDERMODE_TRANSALPHA )
		ghost:SetNotSolid( true )
		
		table.insert( ghoststack, ghost )
	end
	
	SetGhostStack( ghoststack )
	
	return true
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:ReleaseGhostStack()
--	
--	Attempts to remove all ghosted props in the stack. 
--	This occurs when the player stops looking at a prop with the stacker tool equipped.
--]]--
function TOOL:ReleaseGhostStack()
	local ghoststack = GetGhostStack()
	if ( !ghoststack ) then return end
	
	for i = 1, #ghoststack, 1 do
		if ( !IsValid( ghoststack[ i ] ) ) then continue end
		ghoststack[ i ]:Remove()
		ghoststack[ i ] = nil
	end
	
	SetGhostStack( nil )
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:CheckGhostStack()
--
--	Attempts to validate the status of the ghosted props in the stack.
--]]--
function TOOL:CheckGhostStack()
	local ghoststack = GetGhostStack()
	if ( !ghoststack ) then return false end
	
	for i = 1, #ghoststack, 1 do
		if ( !IsValid( ghoststack[ i ] ) ) then return false end
	end
	
	if     ( #ghoststack ~= self:GetCount() and  self:ShouldGhostAll() ) then return false
	elseif ( #ghoststack ~= 1               and !self:ShouldGhostAll() ) then return false end
	
	return true
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL:UpdateGhostStack( entity )
--
--	Attempts to update the positions and angles of all ghosted props in the stack.
--]]--
function TOOL:UpdateGhostStack( ent )
	local ghoststack = GetGhostStack()
	
	local mode   = self:GetStackerMode()
	local dir    = self:GetDirection()
	local offset = self:GetOffsetVector()
	local rotate = self:GetRotateAngle()
	local recalc = self:ShouldStackRelative()
	
	local applyMaterial = self:ShouldApplyMaterial()
	local applyColor    = self:ShouldApplyColor()
	
	local lastEnt = ent
	local entPos = lastEnt:GetPos()
	local entAng = lastEnt:GetAngles()
	local entMat = ent:GetMaterial()
	local entCol = ent:GetColor()
	      entCol.a = 150
	
	local stackdir, height, thisoffset
	local ghost
	
	for i = 1, #ghoststack, 1 do
		if ( i == 1 or ( mode == MODE_PROP and recalc ) ) then
			stackdir, height, thisoffset = self:StackerCalcPos( lastEnt, mode, dir, offset )
		end

		entPos = entPos + stackdir * height + thisoffset
		entAng = entAng + rotate
	
		local ghost = ghoststack[ i ]
		
		ghost:SetAngles( entAng )
		ghost:SetPos( entPos )
		ghost:SetMaterial( ( applyMaterial and entMat ) or "" )
		ghost:SetColor( ( applyColor and entCol ) or TRANSPARENT )
		ghost:SetNoDraw( false )
		lastEnt = ghost
	end
end

--[[--------------------------------------------------------------------------
--
--	TOOL:Think()
--
--	While the stacker tool is equipped, this function will check to see if
--	the player is looking at any props and attempt to create the stack of
--	ghosted props before the players actually left clicks.
--]]--
function TOOL:Think()
	if ( SERVER ) then return end
	
	local ply = self:GetOwner()
	local ent = ply:GetEyeTrace().Entity
	
	if ( IsValid( ent ) and ent:GetClass() == "prop_physics" ) then
		self.CurrentEnt = ent

		if ( self.CurrentEnt == self.LastEnt ) then
			if ( self:CheckGhostStack() ) then
				self:UpdateGhostStack( self.CurrentEnt )
			else
				self:ReleaseGhostStack()
				self.LastEnt = nil
				return
			end
		else
			if ( self:CreateGhostStack( self.CurrentEnt ) ) then
				self.LastEnt = self.CurrentEnt 
			end
		end
		
		if ( !self:ShouldAddHalos() )  then return end

		local ghoststack = GetGhostStack()
		if ( !ghoststack or #ghoststack <= 0 ) then return end

		halo.Add( ghoststack, self:GetHaloColor() )
	else
		self:ReleaseGhostStack()
		self.LastEnt = nil
	end
end

--[[--------------------------------------------------------------------------
--
-- 	TOOL.BuildCPanel( panel )
--
--	Builds the control panel menu that can be seen when holding Q and accessing
--	the stacker menu.
--]]--
function TOOL.BuildCPanel( cpanel )
	cpanel:AddControl( "Header", { Text = "#Tool.stackerv2.name", Description	= "#Копируйте пропы" } )
	
	-- cpanel:AddControl( "Checkbox", { Label = "Сваривать проп",       Command = "stackerv2_weld" } )

	local params = { Label = "Копировать по:", MenuButton = "0", Options = {} }
	params.Options[ "Мир" ] = { stackerv2_mode = "1" }
	params.Options[ "Проп" ]  = { stackerv2_mode = "2" }
	cpanel:AddControl( "ComboBox", params )

	local params = { Label = "Stack direction", MenuButton = "0", Options = {} }
	params.Options[ "Вверх" ]     = { stackerv2_dir = DIRECTION_UP }
	params.Options[ "Вниз" ]   = { stackerv2_dir = DIRECTION_DOWN }
	params.Options[ "Вперёд" ]  = { stackerv2_dir = DIRECTION_FRONT }
	params.Options[ "Назад" ] = { stackerv2_dir = DIRECTION_BEHIND }
	params.Options[ "Право" ]  = { stackerv2_dir = DIRECTION_RIGHT }
	params.Options[ "Лево" ]   = { stackerv2_dir = DIRECTION_LEFT }
	cpanel:AddControl( "ComboBox", params )
	
	--cpanel:AddControl( "Header", { Text = "Advanced Options", Description = "These options are for advanced users. Leave them all default ( 0 ) if you don't understand what they do." }  )
	cpanel:AddControl( "Button", { Label = "Сбросить настройки", Command = "stackerv2_resetoffsets", Text = "Reset" } )
	
	cpanel:AddControl( "Slider", { Label = "Offset X ( Вперёд/назад)", Type = "Float", Min = - GetConVarNumber( "stackerv2_max_offsetx" ), Max = GetConVarNumber( "stackerv2_max_offsetx" ), Value = 0, Command = "stackerv2_offsetx" } )
	cpanel:AddControl( "Slider", { Label = "Offset Y ( Право/лево )",   Type = "Float", Min = - GetConVarNumber( "stackerv2_max_offsety" ), Max = GetConVarNumber( "stackerv2_max_offsety" ), Value = 0, Command = "stackerv2_offsety" } )
	cpanel:AddControl( "Slider", { Label = "Offset Z ( Вверх/вниз )",      Type = "Float", Min = - GetConVarNumber( "stackerv2_max_offsetz" ), Max = GetConVarNumber( "stackerv2_max_offsetz" ), Value = 0, Command = "stackerv2_offsetz" } )
	cpanel:AddControl( "Slider", { Label = "Rotate Pitch",              Type = "Float", Min = -360,  Max = 360,  Value = 0, Command = "stackerv2_rotp" } )
	cpanel:AddControl( "Slider", { Label = "Rotate Yaw",                Type = "Float", Min = -360,  Max = 360,  Value = 0, Command = "stackerv2_roty" } )
	cpanel:AddControl( "Slider", { Label = "Rotate Roll",               Type = "Float", Min = -360,  Max = 360,  Value = 0, Command = "stackerv2_rotr" } )
	
	cpanel:AddControl( "Checkbox", { Label = "Копировать относительно положения пропа", Command = "stackerv2_recalc",    Description = "Stacks each prop relative to the prop right before it. This allows you to create curved stacks." } )
	cpanel:AddControl( "Checkbox", { Label = "Применять материал",                 Command = "stackerv2_material",  Description = "Applies the material of the original prop to all stacked props" } )
	cpanel:AddControl( "Checkbox", { Label = "Применять цвет",                    Command = "stackerv2_color",     Description = "Applies the color of the original prop to all stacked props" } )
	cpanel:AddControl( "Checkbox", { Label = "Применять физ.параметры",      Command = "stackerv2_physprop",  Description = "Applies the physical properties of the original prop to all stacked props" } )
	cpanel:AddControl( "Color", { Label = "Цвет", Red = "stackerv2_halo_r", Green = "stackerv2_halo_g", Blue = "stackerv2_halo_b", Alpha = "stackerv2_halo_a" } )
end
--PATH addons/m9k/lua/weapons/m9k_acr/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_acr/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_acr") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then 
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Assault Rifles"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "ACR"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 21			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.SelectiveFire		= true

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_rif_msda.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_masada_acr.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Masada.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 650			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "Rifle"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 21	-- Base damage per bullet
SWEP.Primary.Spread		= .001	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.668, 0, 0.675)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(2.668, 0, 0.675)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector (-3.0328, 0, 1.888)
SWEP.RunSightsAng = Vector (-24.2146, -36.522, 10)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_ares_shrike/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_ares_shrike/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_ares_shrike") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Machine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "Ares Shrike"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 3				-- Slot in the weapon selection menu
SWEP.SlotPos				= 39			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "ar2"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_ares_shrike01.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_ares_shrike.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_shrk.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 625			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 100		-- Size of a clip
SWEP.Primary.DefaultClip		= 400		-- Bullets you start with
SWEP.Primary.KickUp				= 0.3		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "Rifle"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 65		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 17	-- Base damage per bullet
SWEP.Primary.Spread		= .001	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-3.804, 0, 0.495)
SWEP.IronSightsAng = Vector(0.119, -0.019, 0)
SWEP.SightsPos = Vector(-3.804, 0, 0.495)
SWEP.SightsAng = Vector(0.119, -0.019, 0)
SWEP.RunSightsPos = Vector(1.639, -3.444, 0)
SWEP.RunSightsAng = Vector(-7.46, 47.048, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_hk45/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_hk45/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_hk45") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "HK45C"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 23			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 60
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_pist_hk45.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_hk45c.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Weapon_hk45.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 750			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 8		-- Size of a clip
SWEP.Primary.DefaultClip		= 45		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "Pistol"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 25	-- Base damage per bullet
SWEP.Primary.Spread		= .025	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .015 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.32, 0, 0.86)
SWEP.IronSightsAng = Vector(0, 0, 0)
SWEP.SightsPos = Vector(-2.32, 0, 0.86)
SWEP.SightsAng = Vector(0, 0, 0)
SWEP.RunSightsPos = Vector(3.444, -7.823, -6.27)
SWEP.RunSightsAng = Vector(60.695, 0, 0)
-- SWEP.RunSightsPos = Vector(0, -3.143, 0.857)
-- SWEP.RunSightsAng = Vector(-11, 9, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_kac_pdw/shared.lua:
-- Variables that are used on both client and server
SWEP.Gun = ("m9k_kac_pdw") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Submachine Guns"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "KAC PDW"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 2				-- Slot in the weapon selection menu
SWEP.SlotPos				= 44			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 30			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "smg"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 70
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_kac_pdw1.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_kac_pdw.mdl"	-- Weapon world model 
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("KAC_PDW.Single")		-- Script that calls the primary fire sound
SWEP.Primary.SilencedSound 	= Sound("KAC_PDW.SilentSingle")
SWEP.Primary.RPM			= 800			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 30		-- Size of a clip
SWEP.Primary.DefaultClip		= 60		-- Bullets you start with
SWEP.Primary.KickUp				= 0.2		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.1		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= true		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "smg1"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.SelectiveFire		= true

SWEP.Secondary.IronFOV			= 55		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.CanBeSilenced		= true

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 20	-- Base damage per bullet
SWEP.Primary.Spread		= .001	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(3.342, 0, 0.759)
SWEP.IronSightsAng = Vector(2.46, -0.025, 0)
SWEP.SightsPos = Vector(3.342, 0, 0.759)
SWEP.SightsAng = Vector(2.46, -0.025, 0)
SWEP.RunSightsPos = Vector(-4.646, -4.173, 0)
SWEP.RunSightsAng = Vector(-10.197, -53.189, 0)

SWEP.WElements = {
	["eotech"] = { type = "Model", model = "models/wystan/attachments/eotech557sight.mdl", bone = "ValveBiped.Bip01_R_Hand", rel = "", pos = Vector(-7.539, 1.485, 10.295), angle = Angle(-172.297, 180, 0), size = Vector(1.378, 1.378, 1.378), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.VElements = {
	["eotech"] = { type = "Model", model = "models/wystan/attachments/eotech557sight.mdl", bone = "DrawCall_0", rel = "", pos = Vector(-0.281, 10.85, -6.398), angle = Angle(0, 90, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
}

SWEP.ViewModelBoneMods = {
	["DrawCall_0009"] = { scale = Vector(1, 1, 1), pos = Vector(-0.154, 0, 0), angle = Angle(0, 0, 0) }
}

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_scoped_taurus/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_scoped_taurus/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_scoped_taurus") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.PrintName				= "Raging Bull - Scoped"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 32			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- Set false if you want no crosshair from hip
SWEP.Weight				= 30			-- Rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.XHair					= true		-- Used for returning crosshair after scope. Must be the same as DrawCrosshair
SWEP.BoltAction				= false		-- Is this a bolt action rifle?
SWEP.HoldType 				= "revolver"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= true
SWEP.ViewModel				= "models/weapons/v_raging_bull_scoped.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_raging_bull_scoped.mdl"	-- Weapon world model
SWEP.ShowWorldModel			= true
SWEP.Base 				= "bobs_scoped_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true

SWEP.Primary.Sound			= Sound("weapon_r_bull.single")		-- script that calls the primary fire sound
SWEP.Primary.RPM				= 115		-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 6		-- Size of a clip
SWEP.Primary.DefaultClip			= 30	-- Bullets you start with
SWEP.Primary.KickUp			= 10				-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= .5			-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal			= 1		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic/Semi Auto
SWEP.Primary.Ammo			= "357"	-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.ScopeZoom			= 3
SWEP.Secondary.UseACOG			= false -- Choose one scope type
SWEP.Secondary.UseMilDot		= true	-- I mean it, only one	
SWEP.Secondary.UseSVD			= false	-- If you choose more than one, your scope will not show up at all
SWEP.Secondary.UseParabolic		= false	
SWEP.Secondary.UseElcan			= false
SWEP.Secondary.UseGreenDuplex	= false	
SWEP.Secondary.UseAimpoint		= false

SWEP.data 				= {}
SWEP.data.ironsights			= 1
SWEP.ScopeScale 			= 0.7
SWEP.ReticleScale 				= 0.6

SWEP.Primary.Damage		= 31	--base damage per bullet
SWEP.Primary.Spread		= .02	--define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .0001 -- ironsight accuracy, should be the same for shotguns

-- enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(2.773, 0, 0.846)
SWEP.IronSightsAng = Vector(-0.157, 0, 0)
SWEP.SightsPos = Vector(2.773, 0, 0.846)
SWEP.SightsAng = Vector(-0.157, 0, 0)
SWEP.RunSightsPos = Vector(0, 2.95, 0)
SWEP.RunSightsAng = Vector(-13.197, 5.737, 0)

if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/m9k/lua/weapons/m9k_sig_p229r/shared.lua:
--[[
Server Name: Русский FastRP #1 [Быстрая загрузка][M9K]
Server IP:   37.230.137.126:27015
File Path:   addons/rp_wep/lua/weapons/m9k_sig_p229r/shared.lua
		 __        __              __             ____     _                ____                __             __         
   _____/ /_____  / /__  ____     / /_  __  __   / __/____(_)__  ____  ____/ / /_  __     _____/ /____  ____ _/ /__  _____
  / ___/ __/ __ \/ / _ \/ __ \   / __ \/ / / /  / /_/ ___/ / _ \/ __ \/ __  / / / / /    / ___/ __/ _ \/ __ `/ / _ \/ ___/
 (__  ) /_/ /_/ / /  __/ / / /  / /_/ / /_/ /  / __/ /  / /  __/ / / / /_/ / / /_/ /    (__  ) /_/  __/ /_/ / /  __/ /    
/____/\__/\____/_/\___/_/ /_/  /_.___/\__, /  /_/ /_/  /_/\___/_/ /_/\__,_/_/\__, /____/____/\__/\___/\__,_/_/\___/_/     
                                     /____/                                 /____/_____/                                  
--]]

-- Variables that are used on both client and server
SWEP.Gun = ("m9k_sig_p229r") -- must be the name of your swep but NO CAPITALS!
if (GetConVar(SWEP.Gun.."_allowed")) != nil then
	if not (GetConVar(SWEP.Gun.."_allowed"):GetBool()) then SWEP.Base = "bobs_blacklisted" SWEP.PrintName = SWEP.Gun return end
end
SWEP.Category				= "M9K Pistols"
SWEP.Author				= ""
SWEP.Contact				= ""
SWEP.Purpose				= ""
SWEP.Instructions				= ""
SWEP.MuzzleAttachment			= "1" 	-- Should be "1" for CSS models or "muzzle" for hl2 models
SWEP.ShellEjectAttachment			= "2" 	-- Should be "2" for CSS models or "1" for hl2 models
SWEP.PrintName				= "SIG Sauer P229R"		-- Weapon name (Shown on HUD)	
SWEP.Slot				= 1				-- Slot in the weapon selection menu
SWEP.SlotPos				= 33			-- Position in the slot
SWEP.DrawAmmo				= true		-- Should draw the default HL2 ammo counter
SWEP.DrawWeaponInfoBox			= false		-- Should draw the weapon info box
SWEP.BounceWeaponIcon   		= 	false	-- Should the weapon icon bounce?
SWEP.DrawCrosshair			= true		-- set false if you want no crosshair
SWEP.Weight				= 3			-- rank relative ot other weapons. bigger is better
SWEP.AutoSwitchTo			= true		-- Auto switch to if we pick it up
SWEP.AutoSwitchFrom			= true		-- Auto switch from if you pick up a better weapon
SWEP.HoldType 				= "pistol"		-- how others view you carrying the weapon
-- normal melee melee2 fist knife smg ar2 pistol rpg physgun grenade shotgun crossbow slam passive 
-- you're mostly going to use ar2, smg, shotgun or pistol. rpg and crossbow make for good sniper rifles

SWEP.ViewModelFOV			= 65
SWEP.ViewModelFlip			= false
SWEP.ViewModel				= "models/weapons/v_sick_p228.mdl"	-- Weapon view model
SWEP.WorldModel				= "models/weapons/w_sig_229r.mdl"	-- Weapon world model
SWEP.Base				= "bobs_gun_base"
SWEP.Spawnable				= true
SWEP.AdminSpawnable			= true
SWEP.FiresUnderwater = false

SWEP.Primary.Sound			= Sound("Sauer1_P228.Single")		-- Script that calls the primary fire sound
SWEP.Primary.RPM			= 600			-- This is in Rounds Per Minute
SWEP.Primary.ClipSize			= 12		-- Size of a clip
SWEP.Primary.DefaultClip		= 45		-- Bullets you start with
SWEP.Primary.KickUp				= 0.4		-- Maximum up recoil (rise)
SWEP.Primary.KickDown			= 0.3		-- Maximum down recoil (skeet)
SWEP.Primary.KickHorizontal		= 0.3		-- Maximum up recoil (stock)
SWEP.Primary.Automatic			= false		-- Automatic = true; Semi Auto = false
SWEP.Primary.Ammo			= "Pistol"			-- pistol, 357, smg1, ar2, buckshot, slam, SniperPenetratedRound, AirboatGun
-- Pistol, buckshot, and slam always ricochet. Use AirboatGun for a light metal peircing shotgun pellets

SWEP.Secondary.IronFOV			= 60		-- How much you 'zoom' in. Less is more! 	

SWEP.data 				= {}				--The starting firemode
SWEP.data.ironsights			= 1

SWEP.Primary.NumShots	= 1		-- How many bullets to shoot per trigger pull
SWEP.Primary.Damage		= 17	-- Base damage per bullet
SWEP.Primary.Spread		= .001	-- Define from-the-hip accuracy 1 is terrible, .0001 is exact)
SWEP.Primary.IronAccuracy = .001 -- Ironsight accuracy, should be the same for shotguns

-- Enter iron sight info and bone mod info below
SWEP.IronSightsPos = Vector(-2.653, -.686, 1.06)
SWEP.IronSightsAng = Vector(0.3, 0, 0)
SWEP.SightsPos = Vector(-2.653, -.686, 1.06)
SWEP.SightsAng = Vector(0.3, 0, 0)

SWEP.RunSightsPos = Vector(3.444, -7.823, -6.27)
SWEP.RunSightsAng = Vector(60.695, 0, 0)


if GetConVar("M9KDefaultClip") == nil then
	print("M9KDefaultClip is missing! You may have hit the lua limit!")
else
	if GetConVar("M9KDefaultClip"):GetInt() != -1 then
		SWEP.Primary.DefaultClip = SWEP.Primary.ClipSize * GetConVar("M9KDefaultClip"):GetInt()
	end
end

if GetConVar("M9KUniqueSlots") != nil then
	if not (GetConVar("M9KUniqueSlots"):GetBool()) then 
		SWEP.SlotPos = 2
	end
end
--PATH addons/cigarette_swep/lua/weapons/weapon_ciga/cl_init.lua:
-- weapon_ciga/cl_init.lua
-- Defines common clientside code/defaults for ciga SWEP

-- Cigarette SWEP by Mordestein (based on Vape SWEP by Swamp Onions)

include('shared.lua')

if not cigaParticleEmitter then cigaParticleEmitter = ParticleEmitter(Vector(0,0,0)) end

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local cigaScale = self.cigaScale or 1
	self:SetModelScale(cigaScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.cigaArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if ply.cigaArmFullyUp then
			--head position
			opos = opos + (oang:Forward()*0.95) + (oang:Right()*7) + (oang:Up()*0.035)
			oang:RotateAroundAxis(oang:Forward(),-100)
			oang:RotateAroundAxis(oang:Up(),100)
			opos = opos + (oang:Up()*(cigaScale-1)*-10.25)
		else
			--hand position
				oang:RotateAroundAxis(oang:Forward(),50)
			oang:RotateAroundAxis(oang:Right(),90)
			opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
			oang:RotateAroundAxis(oang:Forward(),90)
			oang:RotateAroundAxis(oang:Up(),10)
			opos = opos + (oang:Up()*(cigaScale-1)*-10.25)
			opos = opos + (oang:Up() * 2)
			opos = opos + (oang:Right() * 0.5)
			opos = opos + (oang:Forward() * -1.5)
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.cigaVMPos1 or Vector(18.5,-3.4,-3.25)
	local vmang1=self.cigaVMAng1 or Vector(170,-180,20)
	--hand pos
	local vmpos2=self.cigaVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.cigaVMAng2 or Vector(120,-180,150)

	if not LocalPlayer().cigaArmTime then LocalPlayer().cigaArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().cigaArmTime)*3,0,1)
	if LocalPlayer().cigaArm then lerp = 1-lerp end
	/*
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)*/
	local difvec = Vector(-10,-3.5,-12)--vmpos1 - vmpos2
	local orig = Vector(0,0,0)
	local topos = orig+difvec
	
	local difang = Vector(-30,0,0)--vmang1 - vmang2
	local origang = Vector(0,0,0)
	local toang = origang+difang
	
	
	
	local newpos = LerpVector(lerp,topos,orig)
	local newang = LerpVector(lerp,toang,origang)
	
	newang = Angle(newang.x, newang.y, newang.z)
	
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end

sound.Add({
	name = "ciga_inhale",
	channel = CHAN_WEAPON,
	volume = 0.24,
	level = 60,
	pitch = { 95 },
	sound = "cigainhale.wav"
})

net.Receive("ciga",function()
	local ply = net.ReadEntity()
	local amt = net.ReadInt(8)
	local fx = net.ReadInt(8)
	if !IsValid(ply) then return end

	if amt>=50 then
		ply:EmitSound("cigacough1.wav",90)

		for i=1,200 do
			local d=i+10
			if i>140 then d=d+150 end
			timer.Simple((d-1)*0.003,function() ciga_do_pulse(ply, 1, 100, fx) end)
		end

		return
	elseif amt>=35 then
		ply:EmitSound("cigabreath2.wav",75,100,0.7)
	elseif amt>=10 then
		ply:EmitSound("cigabreath1.wav",70,130-math.min(100,amt*2),0.4+(amt*0.005))
	end

	for i=1,amt*2 do
		timer.Simple((i-1)*0.02,function() ciga_do_pulse(ply,math.floor(((amt*2)-i)/10), fx==2 and 100 or 0, fx) end)
	end
end)

net.Receive("cigaArm",function()
	local ply = net.ReadEntity()
	local z = net.ReadBool()
	if !IsValid(ply) then return end
	if ply.cigaArm != z then
		if z then
			timer.Simple(0.3, function() 
				if !IsValid(ply) then return end 
				if ply.cigaArm then ply:EmitSound("ciga_inhale") end
			end)
		else
			ply:StopSound("ciga_inhale")
		end
		ply.cigaArm = z
		ply.cigaArmTime = os.clock()
		local m = 0
		if z then m = 1 end

		for i=0,9 do
			timer.Simple(i/30,function() ciga_interpolate_arm(ply,math.abs(m-((9-i)/10)),z and 0 or 0.2) end)
		end
	end
end)

net.Receive("cigaTalking",function()
	local ply = net.ReadEntity()
	if IsValid(ply) then ply.cigaTalkingEndtime = net.ReadFloat() end
end)

function ciga_interpolate_arm(ply, mult, mouth_delay)
	if !IsValid(ply) then return end
	
	if mouth_delay>0 then 
		timer.Simple(mouth_delay,function() if IsValid(ply) then ply.cigaMouthOpenAmt = mult end end)
	else 
		ply.cigaMouthOpenAmt = mult
	end

	local b1 = ply:LookupBone("ValveBiped.Bip01_R_Upperarm")
	local b2 = ply:LookupBone("ValveBiped.Bip01_R_Forearm")
	if (not b1) or (not b2) then return end
	ply:ManipulateBoneAngles(b1,Angle(20*mult,-62*mult,10*mult))
	ply:ManipulateBoneAngles(b2,Angle(-5*mult,-10*mult,0))
	if mult==1 then ply.cigaArmFullyUp=true else ply.cigaArmFullyUp=false end
end

--this makes the mouth opening work without clobbering other addons
hook.Add("InitPostEntity", "cigaMouthMoveSetup", function()
	timer.Simple(1, function()
		if ciga_OriginalMouthMove ~= nil then return end

		ciga_OriginalMouthMove = GAMEMODE.MouthMoveAnimation
	 
		function GAMEMODE:MouthMoveAnimation(ply)
			--run the base MouthMoveAnimation if player isn't vaping/cigatalking
			if ((ply.cigaMouthOpenAmt or 0) == 0) and ((ply.cigaTalkingEndtime or 0) < CurTime()) then
				return ciga_OriginalMouthMove(GAMEMODE, ply)
			end

			local FlexNum = ply:GetFlexNum() - 1
			if ( FlexNum <= 0 ) then return end
			for i = 0, FlexNum - 1 do
				local Name = ply:GetFlexName(i)
				if ( Name == "jaw_drop" || Name == "right_part" || Name == "left_part" || Name == "right_mouth_drop" || Name == "left_mouth_drop" ) then
					ply:SetFlexWeight(i, math.max(((ply.cigaMouthOpenAmt or 0)*0.5), math.Clamp(((ply.cigaTalkingEndtime or 0)-CurTime())*3.0, 0, 1)*math.Rand(0.1,0.8) ))
				end
			end
		end
	end)
end)

function ciga_do_pulse(ply, amt, spreadadd, fx)
	if !IsValid(ply) then return end

	if ply:WaterLevel()==3 then return end

	if not spreadadd then spreadadd=0 end

	local attachid = ply:LookupAttachment("eyes")
	cigaParticleEmitter:SetPos(LocalPlayer():GetPos())
	
	local angpos = ply:GetAttachment(attachid) or {Ang=Angle(0,0,0), Pos=Vector(0,0,0)}
	local fwd
	local pos
	
	if (ply != LocalPlayer()) then
		fwd = (angpos.Ang:Forward()-angpos.Ang:Up()):GetNormalized()
		pos = angpos.Pos + (fwd*3.5)
	else
		fwd = ply:GetAimVector():GetNormalized()
		pos = ply:GetShootPos() + fwd*1.5 + gui.ScreenToVector( ScrW()/2, ScrH() )*5
	end

	fwd = ply:GetAimVector():GetNormalized()

	for i = 1,amt do
		if !IsValid(ply) then return end
		local particle = cigaParticleEmitter:Add(string.format("particle/smokesprites_00%02d",math.random(7,16)), pos )
		if particle then
			local dir = VectorRand():GetNormalized() * ((amt+5)/10)
			ciga_do_particle(particle, (ply:GetVelocity()*0.25)+(((fwd*9)+dir):GetNormalized() * math.Rand(50,80) * (amt + 1) * 0.2), fx)
		end
	end
end

function ciga_do_particle(particle, vel, fx)
	particle:SetColor(255,255,255,255)
	if fx == 3 then particle:SetColor(100,100,100,100) end
	if fx >= 4 then 
		local c = JuicycigaJuices[fx-3].color
		if c == nil then c = HSVToColor(math.random(0,359),1,1) end
		particle:SetColor(c.r, c.g, c.b, 255)
	end

	local mega = 1
	if fx == 2 then mega = 4 end
	mega = mega * 0.3
	
	particle:SetVelocity( vel * mega )
	particle:SetGravity( Vector(0,0,1.5) )
	particle:SetLifeTime(0)
	particle:SetDieTime(math.Rand(80,100)*0.11*mega)
	particle:SetStartSize(3*mega)
	particle:SetEndSize(40*mega*mega)
	particle:SetStartAlpha(150)
	particle:SetEndAlpha(0)
	particle:SetCollide(true)
	particle:SetBounce(0.25)
	particle:SetRoll(math.Rand(0,360))
	particle:SetRollDelta(0.01*math.Rand(-40,40))
	particle:SetAirResistance(50)
end

matproxy.Add({
	name = "cigaTankColor",
	init = function( self, mat, values )
		self.ResultTo = values.resultvar
	end,
	bind = function( self, mat, ent )
		if ( !IsValid( ent ) ) then return end
		if ent:GetClass()=="viewmodel" then 
			ent=ent:GetOwner()
			if ( !IsValid( ent ) or !ent:IsPlayer() ) then return end
			ent=ent:GetActiveWeapon()
			if ( !IsValid( ent ) ) then return end
		end
		local v = ent.cigaTankColor or Vector(0.3,0.3,0.3)
		if v==Vector(-1,-1,-1) then
			local c = HSVToColor((CurTime()*60)%360,0.9,0.9)
			v = Vector(c.r,c.g,c.b)/255.0
		end
		mat:SetVector(self.ResultTo, v)
	end
})

matproxy.Add({
	name = "cigaAccentColor",
	init = function( self, mat, values )
		self.ResultTo = values.resultvar
	end,
	bind = function( self, mat, ent )
		if ( !IsValid( ent ) ) then return end
		local o = ent:GetOwner()
		if ent:GetClass()=="viewmodel" then 
			if (!IsValid(o)) or (!o:IsPlayer()) then return end
			ent=o:GetActiveWeapon()
			if ( !IsValid( ent ) ) then return end
		end
		local special = false
		local col = ent.cigaAccentColor or special and Vector(1,0.8,0) or Vector(1,1,1)
		if col==Vector(-1,-1,-1) then
			col=Vector(1,1,1)
			if IsValid(o) then col=o:GetWeaponColor() end
		end
		mat:SetVector(self.ResultTo, col)
	end
})


--Swep Construction Kit code--

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self.Owner:GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self.Owner) and self.Owner:IsPlayer() and 
				ent == self.Owner:GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end



--PATH addons/111mod/lua/weapons/weapon_flashgrenade.lua:


///////////////////////////////////
//			Grenade weapon 		//
/////////////////////////////////

AddCSLuaFile()

SWEP.Author = 'Ravenbutt'
SWEP.Information = 'Уничтожать дома.'
SWEP.Editable = false
SWEP.Spawnable = true
SWEP.AdminOnly = true

if CLIENT then
	SWEP.PrintName = 'Световая граната'
	SWEP.Instructions = 'ЛКМ - Истребить людей;'
	SWEP.Slot = 3
	SWEP.Category = "Other"
	SWEP.ViewModelFlip = true 
	SWEP.DrawCrosshair = false
end

SWEP.ViewModel = 'models/weapons/v_eq_flashbang.mdl'
SWEP.WorldModel = 'models/weapons/w_eq_flashbang.mdl'

SWEP.Weight = 5
SWEP.AutoSwitchFrom = true 
SWEP.NoSights = true 

SWEP.Primary = {}

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true 
SWEP.Primary.Delay = 1.0 
SWEP.Primary.Ammo = 'none'

SWEP.Secondary = {}

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false 
SWEP.Secondary.Ammo = 'none'

SWEP.CanThrow = true
SWEP.Mode = false 
SWEP.LastChange = 0

function SWEP:Initialize()
	self:SetHoldType( 'grenade' )
end


function SWEP:Reload()
	if self.Owner:IsSuperAdmin() and self.Owner:GetUserGroup() == 'superadmin' then
		if CurTime() - self.LastChange > 1 then
			self.Mode = !self.Mode
			self.LastChange = CurTime()
			if SERVER then self.Owner:ChatPrint( 'Changed mode to:'..( self.Mode and 'admin' or 'user' ) ) end
		end
	else
		return false
	end
end

function SWEP:PrimaryAttack()
	if self.Mode and self.Owner:IsSuperAdmin() then
		if SERVER then
			local ply = self.Owner

			local ang = ply:EyeAngles()
			local src = ply:GetPos() + ( ply:Crouching() and ply:GetViewOffsetDucked() or ply:GetViewOffset() ) + ( ang:Forward() * 8 ) + ( ang:Right() * 10 )

			local target = ply:GetEyeTraceNoCursor().HitPos 
			local tang = ( target - src ):Angle()

			if tang.p < 90 then
				tang.p = -10 + tang.p * ( 90 + 10 ) / 90
			else
				tang.p = 360 - tang.p
				tang.p = -10 + tang.p * -( 90 + 10 ) / 90
			end

		    tang.p = math.Clamp( tang.p, -90, 90 )

		    local vel = math.min( 800, ( 90 - tang.p ) * 6 )

			self:CreateGrenade( ( tang:Forward() * vel + ply:GetVelocity() ), src )
		end
	else
		if self.CanThrow then
			self.CanThrow = false 

			self:SendWeaponAnim( ACT_VM_PULLPIN )

			if SERVER then
				timer.Simple( 1, function()
	      			local ply = self.Owner

	      			local ang = ply:EyeAngles()
	      			local src = ply:GetPos() + ( ply:Crouching() and ply:GetViewOffsetDucked() or ply:GetViewOffset() ) + ( ang:Forward() * 8 ) + ( ang:Right() * 10 )

	      			local target = ply:GetEyeTraceNoCursor().HitPos 
	      			local tang = ( target - src ):Angle()

	      			if tang.p < 90 then
	      				tang.p = -10 + tang.p * ( 90 + 10 ) / 90
	      			else
	      				tang.p = 360 - tang.p
	      				tang.p = -10 + tang.p * -( 90 + 10 ) / 90
	      			end

	      			tang.p = math.Clamp( tang.p, -90, 90 )

	      			local vel = math.min( 800, ( 90 - tang.p ) * 6 )

					self:CreateGrenade( ( tang:Forward() * vel + ply:GetVelocity() ), src )
					
					ply:SetAnimation( PLAYER_ATTACK1 )
					ply:StripWeapon( 'weapon_flashgrenade' )
				end )
			end
		end
	end
end

function SWEP:SecondaryAttack()
	
end


function SWEP:CreateGrenade( vel, pos )
	local grenade = ents.Create( 'sent_flashgrenade' )

	grenade:SetPos( pos )

	grenade:SetThrower( self.Owner )

	grenade:SetGravity( 0.4 )
   	grenade:SetFriction( 0.2 )
   	grenade:SetElasticity( 0.45 )

	grenade:Spawn()

	local phys = grenade:GetPhysicsObject()

	if IsValid( phys ) then
		phys:Wake()
		phys:SetVelocity( vel )
	end

	timer.Simple( 4, function()
		grenade:Explode()
	end )
end

///////////////////////////////////
//			Boom entity 		//
/////////////////////////////////

local ENT = {}

ENT.Base = 'base_gmodentity'

AccessorFunc( ENT, "thrower", "Thrower" )

if CLIENT then
	function ENT:Draw()
		self:DrawModel()
	end

	local function stunEffect()
		local flash_start = LocalPlayer():GetNW2Float( 'FlashStart' )
		local flash_end = LocalPlayer():GetNW2Float( 'FlashEnd' )

		if flash_end > CurTime() and flash_end - 2 - CurTime() <= 5 then
			local flashalpha =  1 - ( CurTime() - ( flash_end - 5 ) ) / 5

			DrawMotionBlur( 0, flashalpha / ( ( 5 +  2 ) / ( 5 * 4 ) ), 0)
		elseif flash_end > CurTime() then
			DrawMotionBlur( 0, 0.01, 0 )
		else
			DrawMotionBlur( 0, 0, 0)
		end
	end

	hook.Add( "RenderScreenspaceEffects", "Flashbang", stunEffect )

	hook.Add( 'HUDPaint', 'Flashbang', function()
		local flash_start = LocalPlayer():GetNW2Float( 'FlashStart' )
		local flash_end = LocalPlayer():GetNW2Float( 'FlashEnd' )

		local flashalpha =  1 - ( CurTime() - ( flash_end - 5 ) ) / ( flash_end - ( flash_end - 5 ) )
		local Alpha = flashalpha * 150

		draw.RoundedBox( 0, 0, 0, ScrW(), ScrH(), Color( 255, 255, 255, math.Round( Alpha ) ) )
	end )

	function ENT:Initialize()
		timer.Simple( 4, function()
			if not IsValid( self ) then return end
			local dynamicflash = DynamicLight( self:EntIndex() )

			if dynamicflash then
				dynamicflash.Pos = self:GetPos()
				dynamicflash.r = 255
				dynamicflash.g = 255
				dynamicflash.b = 255
				dynamicflash.Brightness = 3
				dynamicflash.Size = 512
				dynamicflash.Decay = 1000
				dynamicflash.DieTime = CurTime() + 0.5
			end 
		end )
	end
else
	function ENT:Initialize()
		self:SetModel( 'models/weapons/w_eq_flashbang.mdl' )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_BBOX )
		self:SetCollisionGroup( COLLISION_GROUP_PROJECTILE )

		local phys = self:GetPhysicsObject()
		
		if phys:IsValid() then
			phys:Wake()
		end
	end

	function ENT:PhysicsCollide( data, phys )
		if data.Speed > 50 then self:EmitSound( Sound( 'Flashbang.Bounce' ) ) end
	end

	function ENT:Think()
		if not IsValid( self:GetThrower() ) then
			self:Remove()
		end
	end
end

local function inzone( num, min, max )

	return ( num > min and num < max )

end

function ENT:Explode()
	if SERVER then
		self:SetNotSolid( true )
		
		for k, v in player.Iterator() do
			local trace = util.TraceLine( {
		        start = v:GetShootPos(),
		        endpos = self:GetPos(),
		        filter = v,
		        mask = MASK_SHOT
		    } )

		    if !trace.HitWorld then
		    	local endtime = 2000 / ( v:GetShootPos():Distance( self:GetPos() ) * 2 )
		    	v:SetNW2Float( 'FlashStart', CurTime() )
		    	v:SetNW2Float( 'FlashEnd', CurTime() + ( endtime ) )

		    	-- local yaw = self:WorldToLocalAngles( v:EyeAngles() - ( v:GetPos() - self:GetPos() ):Angle() ).y
		    	-- print( yaw )
		    	-- if not inzone( yaw, 100, 15 ) then
		    	-- 	print( yaw, 1228 )
		    	-- 	v:SetNW2Float( 'FlashEnd', CurTime() + ( endtime / 200 ) )

		    	-- end
		    end
		end
		self:EmitSound( 'Flashbang.Explode' )
		timer.Simple( 15, function() self:Remove() end )
	end
end

scripted_ents.Register( ENT, 'sent_flashgrenade' )
--PATH addons/skin_nier/lua/weapons/weapon_mad_base/shared.lua:
/*---------------------------------------------------------
------mmmm---mmmm-aaaaaaaa----ddddddddd---------------------------------------->
     mmmmmmmmmmmm aaaaaaaaa   dddddddddd	  Name: Mad Cows Weapons
     mmm mmmm mmm aaa    aaa  ddd     ddd	  Author: Worshipper
    mmm  mmm  mmm aaaaaaaaaaa ddd     ddd	  Project Start: October 23th, 2009
    mmm       mmm aaa     aaa dddddddddd	  Version: 2.0
---mmm--------mmm-aaa-----aaa-ddddddddd---------------------------------------->
---------------------------------------------------------*/

// Variables that are used on both client and server

game.AddParticles("particles/buu_particles.pcf")

local RecoilMul = CreateConVar ("mad_recoilmul", "1", {FCVAR_REPLICATED, FCVAR_ARCHIVE})
local DamageMul = CreateConVar ("mad_damagemul", "1", {FCVAR_REPLICATED, FCVAR_ARCHIVE})

SWEP.Category			= "Mad Cows Weapons"

SWEP.MadCow = true
SWEP.Author				= "Worshipper"
SWEP.Contact			= "Josephcadieux@hotmail.com"

// I have nothing to say here because I'm a prick
SWEP.Purpose			= ""
SWEP.Instructions			= ""

SWEP.CSMuzzleFlashes = true

SWEP.ViewModelFOV			= 60
SWEP.ViewModelFlip		= false
SWEP.ViewModel			= "models/weapons/v_pistol.mdl"
SWEP.WorldModel			= "models/weapons/w_pistol.mdl"
SWEP.AnimPrefix			= "python"

SWEP.Spawnable			= false
SWEP.AdminSpawnable		= false

SWEP.Primary.Sound		= Sound("Weapon_AK47.Single")
SWEP.Primary.Recoil		= 10
SWEP.Primary.Damage		= 10
SWEP.Primary.NumShots		= 1
SWEP.Primary.Cone			= 0
SWEP.Primary.Delay 		= 0
SWEP.Primary.SuppressorSound = ""
SWEP.Primary.NoSuppressorSound = ""

SWEP.Primary.ClipSize		= 5					// Size of a clip
SWEP.Primary.DefaultClip	= 5					// Default number of bullets in a clip
SWEP.Primary.Automatic		= false				// Automatic/Semi Auto
SWEP.Primary.Ammo			= "none"

SWEP.Secondary.ClipSize		= -1					// Size of a clip
SWEP.Secondary.DefaultClip	= -1					// Default number of bullets in a clip
SWEP.Secondary.Automatic	= false				// Automatic/Semi Auto
SWEP.Secondary.Ammo		= "none"

SWEP.MeleeRange				= 70

SWEP.ActionDelay			= CurTime()
SWEP.ShootDelay				= 0
SWEP.ReloadTime 			= -1

SWEP.FireChance 			= -1


// I added this function because some weapons like the Day of Defeat weapons need 1.2 or 1.5 seconds to deploy
SWEP.DeployDelay			= 1

SWEP.ShellEffect			= "effect_mad_shell_pistol"	// "effect_mad_shell_pistol" or "effect_mad_shell_rifle" or "effect_mad_shell_shotgun"
SWEP.ShellDelay				= 0

// Is it a pistol, a rifle, a shotgun or a sniper? Choose only one of them or you'll fucked up everything. BITCH!
SWEP.Pistol				= false
SWEP.Rifle				= false
SWEP.Shotgun			= false
SWEP.Sniper				= false
SWEP.HoldingPos 		= Vector(0,0,0)
SWEP.HoldingAng 		= Vector(0,0,0)
SWEP.IronSightsPos 		= Vector (0, 0, 0)
SWEP.IronSightsAng 		= Vector (0, 0, 0)
SWEP.RunArmOffset 		= Vector (0, 0, 5.5)
SWEP.RunArmAngle 			= Vector (-35, -3, 0)

// Burst options
SWEP.Burst				= false
SWEP.BurstShots			= 3
SWEP.BurstDelay			= 0.05
SWEP.BurstCounter			= 0
SWEP.BurstTimer			= 0

// Custom mode options (Do not put a burst mode and a custom mode at the same time, it will not work)
SWEP.Type				= 1 					// 1 = Automatic/Semi-Automatic mode, 2 = Suppressor mode, 3 = Burst fire mode
SWEP.Mode				= false

SWEP.data 				= {}
SWEP.data.NormalMsg		= "Switched to semi-automatic."
SWEP.data.ModeMsg			= "Switched to automatic."
SWEP.data.Delay			= 0.5 				// You need to wait 0.5 second after you change the fire mode
SWEP.data.Cone			= 1
SWEP.data.Damage			= 1
SWEP.data.Recoil			= 1
SWEP.data.Automatic		= false

// Constant accuracy means that your crosshair will not change if you're running, shooting or walking
SWEP.ConstantAccuracy		= false

// I don't think it's hard to understand this
SWEP.Penetration			= false
SWEP.MinPenetration			= -1
SWEP.PenetrationDmgMult		= -1
SWEP.Ricochet				= true
SWEP.MaxRicochet			= 1
SWEP.ChainHit				= 3
SWEP.SuperRicochet			= false
SWEP.ExplosiveShot			= false

SWEP.Tracer				= 0					// 0 = Normal Tracer, 1 = Ar2 Tracer, 2 = Airboat Gun Tracer, 3 = Normal Tracer + Sparks Impact

SWEP.IdleDelay			= 0
SWEP.IdleApply			= false
SWEP.AllowIdleAnimation		= true
SWEP.AllowPlaybackRate		= true

SWEP.BoltActionSniper		= false				// Use this value if you want to remove the scope view after you shoot
SWEP.ScopeAfterShoot		= false				// Do not try to change this value

SWEP.IronSightZoom 		= 1.5
SWEP.ScopeZooms			= {10}
SWEP.ScopeScale 			= 0.4

SWEP.ShotgunReloading		= false
SWEP.ShotgunFinish		= 0.5
SWEP.ShotgunBeginReload		= 0.3

SWEP.EmptyReload			= false

SWEP.Offset = { --Procedural world model animation, defaulted for CS:S purposes.
	Pos = {
		Up = 0,
		Right = 0,
		Forward = 0
	},
	Ang = {
		Up = 0,
		Right = 0,
		Forward = 0
	},
	Scale = 1
}

local function FixHolsters()

	for _, Ply in player.Iterator() do
	
		local Wep = Ply:GetActiveWeapon()
		
		if !IsValid( Wep ) then continue; end
		if !Wep:IsWeapon() then continue; end
		if !Wep.MadCow then continue; end
		
		if Wep.Owner:GetVelocity():Length() > 350 or Wep.Weapon:GetDTBool(0) then
			
			if Wep.Rifle or Wep.Sniper or Wep.Shotgun then
				if ( Ply:Crouching() and Ply:GetVelocity():Length() == 0 ) then
					Wep:SetWeaponHoldType( 'normal' )
				else
					Wep:SetWeaponHoldType( 'passive' )
				end
			elseif Wep.Pistol then
				Wep:SetWeaponHoldType( 'normal' )
			end
			
		else
			Wep:SetWeaponHoldType(Wep.HoldType)
		end
		
	end
end
-- hook.Add( 'Think', 'FixMadcowHolsters', FixHolsters )

/*---------------------------------------------------------
   Name: SWEP:Initialize()
   Desc: Called when the weapon is first loaded.
---------------------------------------------------------*/
function SWEP:Initialize()
	if(self.Owner:IsNPC()) then
		self:SetWeaponHoldType("smg")
	else
		self:SetWeaponHoldType(self.HoldType)
	end
	
	if (SERVER and self.Owner:IsNPC()) then

		// Fucking NPCs
		self:SetNPCMinBurst(30)
		self:SetNPCMaxBurst(30)
		self:SetNPCFireRate(self.Primary.Delay)
		self:SetCurrentWeaponProficiency( WEAPON_PROFICIENCY_VERY_GOOD )
	end

	self.Reloadaftershoot = 0 				-- Can't reload when firing
	self:SetWeaponHoldType(self.HoldType)
	self.Weapon:SetNetworkedBool("Reloading", false)

	
end

function SWEP:PreDrawViewModel( vm, wep, ply )

	vm:SetMaterial( "" ) -- Hide that view model with hacky material

end

/*---------------------------------------------------------
   Name: ENT:SetupDataTables()
   Desc: Setup the data tables.
---------------------------------------------------------*/
function SWEP:SetupDataTables()  // zDark.com - Fix - 19 August 2010

	self:DTVar("Bool", 0, "Holsted")
	self:DTVar("Bool", 1, "Ironsights")
	self:DTVar("Bool", 2, "Scope")
	self:DTVar("Bool", 3, "Mode")
end 

/*---------------------------------------------------------
   Name: SWEP:IdleAnimation()
   Desc: Are you seriously too stupid to understand the function by yourself?
---------------------------------------------------------*/
function SWEP:IdleAnimation(time)

	if not self.AllowIdleAnimation then return false end

	self.IdleApply = true
	self.ActionDelay = CurTime() + time
	self.IdleDelay = CurTime() + time
end

/*---------------------------------------------------------
   Name: SWEP:PrimaryAttack()
   Desc: +attack1 has been pressed.
---------------------------------------------------------*/
function SWEP:PrimaryAttack()

	-- Holst/Deploy your fucking weapon
	if (not self.Owner:IsNPC() and self.Owner:KeyDown(IN_USE)) then
		bHolsted = !self.Weapon:GetDTBool(0)
		self:SetHolsted(bHolsted)

		self.Weapon:SetNextPrimaryFire(CurTime() + 0.3)
		self.Weapon:SetNextSecondaryFire(CurTime() + 0.3)

		self:SetIronsights(false)

		return
	end

	if (not self:CanPrimaryAttack()) then return end

	self.ActionDelay = (CurTime() + self.Primary.Delay + 0.05)
	self.Weapon:SetNextPrimaryFire(CurTime() + self.Primary.Delay)
	self.Weapon:SetNextSecondaryFire(CurTime() + self.Primary.Delay)

	-- If the burst mode is activated, it's going to shoot the three bullets (or more if you're dumb and put 4 or 5 bullets for your burst mode)
	if self.Weapon:GetDTBool(3) and self.Type == 3 then
		self.BurstTimer 	= CurTime()
		self.BurstCounter = self.BurstShots - 1
		self.Weapon:SetNextPrimaryFire(CurTime() + 0.5)
	end

	self.Weapon:EmitSound(self.Primary.Sound)

	self:TakePrimaryAmmo(1)
	
	local Vm = self.Owner:GetViewModel()
	if Vm == nil then return end
	PrecacheParticleSystem("smoke_trail")
	timer.Create("SmokeTrail",1,1,function()ParticleEffectAttach( "smoke_trail",  PATTACH_POINT_FOLLOW , Vm, Vm:LookupAttachment( "1" )) ParticleEffectAttach( "smoke_trail",  PATTACH_POINT_FOLLOW , Vm, Vm:LookupAttachment( "2" )) end)
	
	self:ShootBulletInformation()
end

/*---------------------------------------------------------
   Name: SWEP:SecondaryAttack()
   Desc: +attack2 has been pressed.
---------------------------------------------------------*/
function SWEP:SecondaryAttack()

	if self.Owner:IsNPC() then return end
	if not IsFirstTimePredicted() then return end

	if (self.Owner:KeyDown(IN_USE) and (self.Mode)) then // Mode
		bMode = !self.Weapon:GetDTBool(3)
		self:SetMode(bMode)
		self:SetIronsights(false)

		self.Weapon:SetNextPrimaryFire(CurTime() + self.data.Delay)
		self.Weapon:SetNextSecondaryFire(CurTime() + self.data.Delay)

		return
	end

	if (!self.IronSightsPos) or (self.Owner:KeyDown(IN_SPEED) or self.Weapon:GetDTBool(0)) then return end
	
	// Not pressing Use + Right click? Ironsights
	bIronsights = !self.Weapon:GetDTBool(1)
	self:SetIronsights(bIronsights)

	self.Weapon:SetNextPrimaryFire(CurTime() + 0.2)
	self.Weapon:SetNextSecondaryFire(CurTime() + 0.2)
end

/*---------------------------------------------------------
   Name: SWEP:SetHolsted()
---------------------------------------------------------*/
function SWEP:SetHolsted(b)

	if (self.Owner) then
		if (b) then
			self.Weapon:EmitSound("weapons/universal/iron_in.wav")
		else
			self.Weapon:EmitSound("weapons/universal/iron_out.wav")
		end
	end

	if (self.Weapon) then
		self.Weapon:SetDTBool(0, b)
	end
end

/*---------------------------------------------------------
   Name: SWEP:SetIronsights()
---------------------------------------------------------*/
function SWEP:SetIronsights(b)

	if (self.Owner:IsValid()) then
		if (b) then
			if (SERVER) then
				self.Owner:SetFOV(65, 0.2)
			end

			if self.AllowIdleAnimation then
				if self.Weapon:GetDTBool(3) and self.Type == 2 then
					self.Weapon:SendWeaponAnim(ACT_VM_IDLE_SILENCED)
				else
					self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
				end

				self.Owner:GetViewModel():SetPlaybackRate(0)
			end

			self.Weapon:EmitSound("weapons/universal/iron_in.wav")
		else
			if (SERVER) then
				self.Owner:SetFOV(0, 0.2)
			end

			if self.AllowPlaybackRate and self.AllowIdleAnimation then
				self.Owner:GetViewModel():SetPlaybackRate(1)
			end	

			self.Weapon:EmitSound("weapons/universal/iron_out.wav")
		end
	end

	if (self.Weapon) then
		self.Weapon:SetDTBool(1, b)
	end
end

/*---------------------------------------------------------
   Name: SWEP:SetMode()
---------------------------------------------------------*/
function SWEP:SetMode(b)

	if (self.Owner) then
		if (b) then
			if self.Type == 1 then
				self.Primary.Automatic = self.data.Automatic
				self.Weapon:EmitSound("weapons/smg1/switch_burst.wav")
			elseif self.Type == 2 then
				self.Weapon:SendWeaponAnim(ACT_VM_ATTACH_SILENCER)
				self.Primary.Sound = Sound(self.Primary.SuppressorSound)

				if (IsValid(self.Owner) and self.Owner:GetViewModel()) then
					self:IdleAnimation(self.Owner:GetViewModel():SequenceDuration())
				end
			elseif self.Type == 3 then
				self.Weapon:EmitSound("weapons/smg1/switch_burst.wav")
			end

			if (SERVER) then
				self.Owner:PrintMessage(HUD_PRINTTALK, self.data.ModeMsg)
			end
		else
			if self.Type == 1 then
				self.Primary.Automatic = !self.data.Automatic
				self.Weapon:EmitSound("weapons/smg1/switch_single.wav")
			elseif self.Type == 2 then
				self.Weapon:SendWeaponAnim(ACT_VM_DETACH_SILENCER)
				self.Primary.Sound = Sound(self.Primary.NoSuppressorSound)

				if (IsValid(self.Owner) and self.Owner:GetViewModel()) then
					self:IdleAnimation(self.Owner:GetViewModel():SequenceDuration())
				end
			elseif self.Type == 3 then
				// Nothing here for the burst fire mode
				self.Weapon:EmitSound("weapons/smg1/switch_single.wav")
			end

			if (SERVER and self.Owner:IsValid()) then
				self.Owner:PrintMessage(HUD_PRINTTALK, self.data.NormalMsg)
			end
		end
	end

	if (self.Weapon) then
		self.Weapon:SetDTBool(3, b)
	end
end

/*---------------------------------------------------------
   Name: SWEP:CheckReload()
   Desc: CheckReload.
---------------------------------------------------------*/
function SWEP:CheckReload()
end

/*---------------------------------------------------------
   Name: SWEP:Reload()
   Desc: Reload is being pressed.
---------------------------------------------------------*/
function SWEP:Reload()

	if (self.ReloadTime > 0 ) then
		self:SpecialReload()
		return
	end

	// When the weapon is already doing an animation, just return end because we don't want to interrupt it
	if (self.ActionDelay > CurTime()) then return end 

	if self.EmptyReload then
		if self.Weapon:Clip1() == 0 and self.Owner:GetAmmoCount(self.Primary.Ammo) > 0 then
			self:SetIronsights(false)
			self:ReloadAnimation()
			self:MagazineDrop()
		end
		return
	end
	
	if (self.Weapon:Clip1() < self.Primary.ClipSize) and (self.Owner:GetAmmoCount(self.Primary.Ammo) > 0) then
		self:SetIronsights(false)
		self:ReloadAnimation()
		self:MagazineDrop()
	end
end

/*---------------------------------------------------------
   Name: SWEP:SpecialReload()
   Desc: Reload is being pressed but with a specified time
---------------------------------------------------------*/
function SWEP:SpecialReload()

	-- When the weapon is already doing an animation, just return end because we don't want to interrupt it
	if (self.ActionDelay > CurTime()) then return end 
	
	if (self.Weapon:GetNW2Bool("Reloading")) then return end

	if (self.Weapon:Clip1() < self.Primary.ClipSize) and (self.Owner:GetAmmoCount(self.Primary.Ammo) > 0) then
		self:SetIronsights(false)
		--self.Weapon:DefaultReload(ACT_VM_RELOAD)
		self.Weapon:SendWeaponAnim(ACT_VM_RELOAD)
		self.Weapon:SetNetworkedInt("ReloadTime", CurTime() + self.ReloadTime)
		self.Weapon:SetNetworkedBool("Reloading", true)
		self.Weapon:SetNextPrimaryFire(CurTime() + self.ReloadTime)
		self.Weapon:SetNextSecondaryFire(CurTime() + self.ReloadTime)
		self:MagazineDrop()
	end
	self:IdleAnimation(self.ReloadTime)
end

function SWEP:MagazineDrop()
	if !( self.Reloadaftershoot > CurTime() ) && !self.sprinting == true && self.MagDrop == true && self.Weapon:Clip1() < self.Primary.ClipSize then
	timer.Simple(0.5,function()	
	if ( self.Reloadaftershoot > CurTime() ) || self.Owner:GetAmmoCount(self.Owner:GetActiveWeapon():GetPrimaryAmmoType()) == 0 then return end 
	local shotpos = self.Owner:GetShootPos()
	shotpos = shotpos + self.Owner:GetForward()*-15
	shotpos = shotpos + self.Owner:GetRight()*5
	shotpos = shotpos + self.Owner:GetUp()*-10
	if (SERVER) then
			
		local mag = ents.Create("gun_clip")
		if (IsValid(mag)) then
			mag:SetPos(shotpos)
			mag:SetOwner(self.Owner)
			mag:SetModel( self.MagModel )
 			mag:Spawn()
			mag.Owner = self.Owner
		end
	end
end)
end
end

/*---------------------------------------------------------
   Name: SWEP:ReloadAnimation()
---------------------------------------------------------*/
function SWEP:ReloadAnimation()

	// Reload with the suppressor animation if you're suppressor is on the FUCKING gun
	if self.Weapon:GetDTBool(3) and self.Type == 2 then
		self.Weapon:DefaultReload(ACT_VM_RELOAD_SILENCED)
	else
		self.Weapon:DefaultReload(ACT_VM_RELOAD)
	end

	if (IsValid(self.Owner) and self.Owner:GetViewModel()) then
		self:IdleAnimation(self.Owner:GetViewModel():SequenceDuration())
	end
end

/*---------------------------------------------------------
   Name: SWEP:SecondThink()
   Desc: Called every frame. Use this function if you don't 
	   want to copy/past the think function everytime you 
	   create a new weapon with this base...
---------------------------------------------------------*/
function SWEP:SecondThink()
end

/*---------------------------------------------------------
   Name: SWEP:SpecialReloadThink()
   Desc: Called every frame. Used to correct the reload
	   time on specially sequenced weapons
---------------------------------------------------------*/
function SWEP:SpecialReloadThink()
	if self.Weapon:GetNetworkedBool("Reloading") == true then
		if self.Weapon:GetNetworkedInt("ReloadTime") < CurTime() then
		
			self.Weapon:SetNetworkedBool("Reloading", false)
			local ammo = self.Owner:GetAmmoCount( self.Primary.Ammo )
			ammo = ammo - ( self.Primary.ClipSize - self.Weapon:Clip1() )
			self.Owner:RemoveAmmo(self.Primary.ClipSize - self.Weapon:Clip1(), self.Primary.Ammo, false)
			if ammo >= 0 then
				self.Weapon:SetClip1(self.Primary.ClipSize)
			else
				self.Weapon:SetClip1(self.Primary.ClipSize + ammo)
			end
			
			if (IsValid(self.Owner) and self.Owner:GetViewModel()) then
				--self:IdleAnimation(self.Owner:GetViewModel():SequenceDuration())
			end
			
		end
	end
end

/*---------------------------------------------------------
   Name: SWEP:Think()
   Desc: Called every frame.
---------------------------------------------------------*/
function SWEP:Think()

	self:SecondThink()
	
	if( self.ReloadTime > 0 ) then
		self:SpecialReloadThink()
	end

	if self.Weapon:Clip1() > 0 and self.IdleDelay < CurTime() and self.IdleApply then
		local WeaponModel = self.Weapon:GetOwner():GetActiveWeapon():GetClass()

		if self.Owner and self.Weapon:GetOwner():GetActiveWeapon():GetClass() == WeaponModel and self.Owner:Alive() then
			if self.Weapon:GetDTBool(3) and self.Type == 2 then
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE_SILENCED)
			else
				self.Weapon:SendWeaponAnim(ACT_VM_IDLE)
			end

			if self.AllowPlaybackRate and not self.Weapon:GetDTBool(1) then
				self.Owner:GetViewModel():SetPlaybackRate(1)
			else
				self.Owner:GetViewModel():SetPlaybackRate(0)
			end		
		end

		self.IdleApply = false
	elseif self.Weapon:Clip1() <= 0 then
		self.IdleApply = false
	end

	if self.Weapon:GetDTBool(1) and self.Owner:KeyDown(IN_SPEED) then
		self:SetIronsights(false)
	end

	// Burst fire mode
	if self.Weapon:GetDTBool(3) and self.Type == 3 then
		if self.BurstTimer + self.BurstDelay < CurTime() then
			if self.BurstCounter > 0 then
				self.BurstCounter = self.BurstCounter - 1
				self.BurstTimer = CurTime()
				
				if self:CanPrimaryAttack() then
					self.Weapon:EmitSound(self.Primary.Sound)
					self:ShootBulletInformation()
					self:TakePrimaryAmmo(1)
				end
			end
		end
	end

	self:NextThink(CurTime())
end

function SWEP:OnRemove()

	if ( IsValid( self.Owner ) && CLIENT && self.Owner:IsPlayer() ) then
		local vm = self.Owner:GetViewModel()
		if ( IsValid( vm ) ) then vm:SetMaterial( "" ) vm:StopParticleEmission() end
	end
end

/*---------------------------------------------------------
   Name: SWEP:Holster()
   Desc: Weapon wants to holster.
	   Return true to allow the weapon to holster.
---------------------------------------------------------*/
function SWEP:Holster()

	self:OnRemove()
	return true
	
end

/*---------------------------------------------------------
   Name: SWEP:OnDrop()
   Desc: Weapon wants to be dropped.
---------------------------------------------------------*/
function SWEP:OnDrop()

	self:OnRemove()

end
/*---------------------------------------------------------
   Name: SWEP:Deploy()
   Desc: Whip it out.
---------------------------------------------------------*/
function SWEP:Deploy()

	self:DeployAnimation()

	if (IsValid(self.Owner) and self.Owner:GetViewModel()) then
		self:IdleAnimation(self.Owner:GetViewModel():SequenceDuration())
	end

	self.Weapon:SetNextPrimaryFire(CurTime() + self.DeployDelay + 0.05)
	self.Weapon:SetNextSecondaryFire(CurTime() + self.DeployDelay + 0.05)
	self.ActionDelay = (CurTime() + self.DeployDelay + 0.05)

	self:SetIronsights(false)

	return true
end

/*---------------------------------------------------------
   Name: SWEP:DeployAnimation()
---------------------------------------------------------*/
function SWEP:DeployAnimation()

	// Weapon has a suppressor
	if self.Weapon:GetDTBool(3) and self.Type == 2 then
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW_SILENCED)
	else
		self.Weapon:SendWeaponAnim(ACT_VM_DRAW)
	end
end

/*---------------------------------------------------------
   Name: SWEP:CrosshairAccuracy()
   Desc: Crosshair informations.
---------------------------------------------------------*/
SWEP.SprayTime 		= 0.1
SWEP.SprayAccuracy 	= 0.2

function SWEP:CrosshairAccuracy()

	// Is it a constant accuracy weapon or is it a NPC? The NPC doesn't need a crosshair. Fuck him!
	if (self.ConstantAccuracy) or (self.Owner:IsNPC()) then
		return 1.0
	end
	
	local LastAccuracy 	= self.LastAccuracy or 0
	local Accuracy 		= 1.0
	local LastShoot 		= self.Weapon:GetNetworkedFloat("LastShootTime", 0)
	
	local Speed 		= self.Owner:GetVelocity():Length()

	local SpeedClamp = math.Clamp(math.abs(Speed / 705), 0, 1)
	
	if (CurTime() <= LastShoot + self.SprayTime) then
		Accuracy = Accuracy * self.SprayAccuracy
	end
	
	if (not self.Owner:IsOnGround()) then
		Accuracy = Accuracy * 0.1
	elseif (Speed > 10) then
		Accuracy = Accuracy * (((1 - SpeedClamp) + 0.1) / 2)
	end

	if (LastAccuracy != 0) then
		if (Accuracy > LastAccuracy) then
			Accuracy = math.Approach(self.LastAccuracy, Accuracy, FrameTime() * 2)
		else
			Accuracy = math.Approach(self.LastAccuracy, Accuracy, FrameTime() * -2)
		end
	end
	
	self.LastAccuracy = Accuracy
	return math.Clamp(Accuracy, 0.2, 1)
end

/*---------------------------------------------------------
   Name: SWEP:ShootBulletInformation()
   Desc: This function add the damage, the recoil, the number of shots and the cone on the bullet.
---------------------------------------------------------*/
function SWEP:ShootBulletInformation()

	local CurrentDamage
	local CurrentRecoil
	local CurrentCone

	if self.Weapon:GetDTBool(3) then
		CurrentDamage = self.Primary.Damage * self.data.Damage * DamageMul:GetFloat()
		CurrentRecoil = self.Primary.Recoil * self.data.Recoil * RecoilMul:GetFloat()
		CurrentCone = self.Primary.Cone * self.data.Cone
	else
		CurrentDamage = self.Primary.Damage * DamageMul:GetFloat()
		CurrentRecoil = self.Primary.Recoil * RecoilMul:GetFloat()
		CurrentCone = self.Primary.Cone
	end

	if self.Owner:IsNPC() then
		self:ShootBullet(CurrentDamage, CurrentRecoil, self.Primary.NumShots, self.Primary.Cone)
		return
	end

	// When we have collected some fuel, we do a lot of damage! >:D
	if self.Owner:GetNetworkedInt("Fuel") > 0 then
		CurrentDamage = CurrentDamage * 1.25
	end


	// Player is not on the ground
	if not self.Owner:IsOnGround() then
		// Player is aiming
		if (self.Weapon:GetDTBool(1)) then
			self:ShootBullet(CurrentDamage, CurrentRecoil, self.Primary.NumShots, CurrentCone)
			self.Owner:ViewPunch(Angle(math.Rand(-0.75, -1.0) * (CurrentRecoil), math.Rand(-1, 1) * (CurrentRecoil), 0))
		// Player is not aiming
		else
			self:ShootBullet(CurrentDamage, CurrentRecoil * 2.5, self.Primary.NumShots, CurrentCone)
			self.Owner:ViewPunch(Angle(math.Rand(-0.75, -1.0) * (CurrentRecoil * 2.5), math.Rand(-1, 1) * (CurrentRecoil * 2.5), 0))
		end
	// Player is moving
	elseif self.Owner:KeyDown(IN_FORWARD || IN_BACK || IN_MOVELEFT || IN_MOVERIGHT) then
		// Player is aiming
		if (self.Weapon:GetDTBool(1)) then
			self:ShootBullet(CurrentDamage, CurrentRecoil / 2, self.Primary.NumShots, CurrentCone)
			self.Owner:ViewPunch(Angle(math.Rand(-0.75, -1.0) * (CurrentRecoil / 1.5), math.Rand(-1, 1) * (CurrentRecoil / 1.5), 0))
		// Player is not aiming
		else
			self:ShootBullet(CurrentDamage, CurrentRecoil * 1.5, self.Primary.NumShots, CurrentCone)
			self.Owner:ViewPunch(Angle(math.Rand(-0.75, -1.0) * (CurrentRecoil * 1.5), math.Rand(-1, 1) * (CurrentRecoil * 1.5), 0))
		end
	// Player is crouching
	elseif self.Owner:Crouching() then
		// Player is aiming
		if (self.Weapon:GetDTBool(1)) then
			self:ShootBullet(CurrentDamage, 0, self.Primary.NumShots, CurrentCone)
			self.Owner:ViewPunch(Angle(math.Rand(-0.75, -1.0) * (CurrentRecoil / 3), math.Rand(-1, 1) * (CurrentRecoil / 3), 0))
		// Player is not aiming
		else
			self:ShootBullet(CurrentDamage, CurrentRecoil / 2, self.Primary.NumShots, CurrentCone)
			self.Owner:ViewPunch(Angle(math.Rand(-0.75, -1.0) * (CurrentRecoil / 2), math.Rand(-1, 1) * (CurrentRecoil / 2), 0))
		end
	// Player is doing nothing
	else
		// Player is aiming
		if (self.Weapon:GetDTBool(1)) then
			self:ShootBullet(CurrentDamage, CurrentRecoil / 6, self.Primary.NumShots, CurrentCone)
			self.Owner:ViewPunch(Angle(math.Rand(-0.75, -1.0) * (CurrentRecoil / 2), math.Rand(-1, 1) * (CurrentRecoil / 2), 0))
		// Player is not aiming
		else
			self:ShootBullet(CurrentDamage, CurrentRecoil, self.Primary.NumShots, CurrentCone)
			self.Owner:ViewPunch(Angle(math.Rand(-0.75, -1.0) * CurrentRecoil, math.Rand(-1, 1) * CurrentRecoil, 0))
		end
	end
end

/*---------------------------------------------------------
   Name: SWEP:ShootEffects()
   Desc: A convenience function to shoot effects.
---------------------------------------------------------*/
function SWEP:ShootEffects()

	if not self.Owner:IsNPC() then
		self:ShootAnimation()
	end

	if(self.Owner:IsPlayer()) then
		if (IsValid(self.Owner) and self.Owner:GetViewModel()) then
			//self:IdleAnimation(self.Owner:GetViewModel():SequenceDuration() + self.ShootDelay)
		end
	end
		

	local WeaponModel = self.Weapon:GetOwner():GetActiveWeapon():GetClass()

	if (not self.Owner:IsNPC() and self.Weapon:Clip1() < 1) then
		timer.Simple(self.Owner:GetViewModel():SequenceDuration() + self.ShootDelay, function() 
			if self.Owner and self.Owner:Alive() and self.Weapon:GetOwner():GetActiveWeapon():GetClass() == WeaponModel then
				self.ActionDelay = CurTime()
				self:Reload() 
			end
		end)
	end

	self.Owner:MuzzleFlash()						// Crappy muzzle light
	self.Owner:SetAnimation(PLAYER_ATTACK1)				// 3rd Person Animation

	local effectdata = EffectData()
		effectdata:SetOrigin(self.Owner:GetShootPos())
		effectdata:SetEntity(self.Weapon)
		effectdata:SetStart(self.Owner:GetShootPos())
		effectdata:SetNormal(self.Owner:GetAimVector())
		effectdata:SetAttachment(1)

	// Add a timer to solve this problem : in multiplayer, when you aim with the ironsights, tracers, effects, etc. still come from where the barrel is when you don't aim with ironsights
	timer.Simple(0, function()
		if not self.Owner then return end
		if not IsFirstTimePredicted() then return end

		if (self.Shotgun) then
			util.Effect("effect_mad_shotgunsmoke", effectdata)
		else
			util.Effect("effect_mad_gunsmoke", effectdata)
		end
	end)

	// Shell eject
	timer.Simple(self.ShellDelay, function()
		if not self.Owner then return end
		if not IsValid(self.Owner) then return end
		if not IsFirstTimePredicted() then return end
		if not self.Owner:IsNPC() and not self.Owner:Alive() then return end
		
		local effectdata = EffectData()
		effectdata:SetEntity(self.Weapon)
		effectdata:SetNormal(self.Owner:GetAimVector())
		effectdata:SetAttachment(2)
		util.Effect(self.ShellEffect, effectdata)
	end)

	if self.Owner:IsNPC() then return end

	local trace = self.Owner:GetEyeTrace()

	if trace.HitPos:Distance(self.Owner:GetShootPos()) < 250 and self.Shotgun then
		if trace.Entity:GetClass() == "prop_door_rotating" and (SERVER) then

			trace.Entity:Fire("open", "", 0.1)
			trace.Entity:Fire("unlock", "", 0.1)

			local pos = trace.Entity:GetPos()
			local ang = trace.Entity:GetAngles()
			local model = trace.Entity:GetModel()
			local skin = trace.Entity:GetSkin()

			trace.Entity:SetNotSolid(true)
			trace.Entity:SetNoDraw(true)

			local function ResetDoor(door, fakedoor)
				door:SetNotSolid(false)
				door:SetNoDraw(false)
				fakedoor:Remove()
			end

			local norm = (pos - self.Owner:GetPos()):Normalize()
			local push = 10000 * norm
			local ent = ents.Create("prop_physics")

			ent:SetPos(pos)
			ent:SetAngles(ang)
			ent:SetModel(model)

			if(skin) then
				ent:SetSkin(skin)
			end

			ent:Spawn()

			timer.Simple(0.01, ent.SetVelocity, ent, push)               
			timer.Simple(0.01, ent:GetPhysicsObject().ApplyForceCenter, ent:GetPhysicsObject(), push)
			timer.Simple(25, ResetDoor, trace.Entity, ent)
		end
	end

	// Crosshair effect
	if ((game.SinglePlayer() and SERVER) or CLIENT) then
		self.Weapon:SetNetworkedFloat("LastShootTime", CurTime())
	end
end

/*---------------------------------------------------------
   Name: SWEP:ShootFire()
   Desc: Shoot fire bullets.
---------------------------------------------------------*/
function SWEP:ShootFire(attacker, tr, dmginfo)

	self.Owner:SetNetworkedInt("Fuel", math.Clamp(self.Owner:GetNetworkedInt("Fuel") - (math.random(1, 3) / self.Primary.NumShots), 0, 100))

	local effectdata = EffectData()
	effectdata:SetOrigin(tr.HitPos)
	effectdata:SetNormal(tr.HitNormal)
	effectdata:SetScale(20)
	util.Effect("effect_mad_firehit", effectdata)

	util.Decal("FadingScorch", tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)

	local random = (1 / self.Primary.Delay) * (self.Primary.NumShots * (self.Primary.NumShots / 4))
	
	if self.FireChance >= 0 then
		random = self.FireChance
	end

	if math.random(0, random) < 1 then
		if tr.Entity:GetPhysicsObject():IsValid() and not tr.Entity:IsPlayer() then
			tr.Entity:Ignite(math.random(5, 20), 0)

			local tracedata = {}
			tracedata.start = tr.HitPos
			tracedata.endpos = Vector(tr.HitPos.x, tr.HitPos.y, tr.HitPos.z - 10)
			tracedata.filter = tr.HitPos
			local tracedata = util.TraceLine(tracedata)

			if tracedata.HitWorld then
				local fire = ents.Create("env_fire")
				fire:SetPos(tr.HitPos)
				fire:SetKeyValue("health", math.random(5, 15))
				fire:SetKeyValue("firesize", "20")
				fire:SetKeyValue("fireattack", "10")
				fire:SetKeyValue("damagescale", "1.0")
				fire:SetKeyValue("StartDisabled", "0")
				fire:SetKeyValue("firetype", "0")
				fire:SetKeyValue("spawnflags", "128")
				fire:Spawn()
				fire:Fire("StartFire", "", 0)
			end
		end
	end
end


/*---------------------------------------------------------
   Name: SWEP:ShootAnimation()
---------------------------------------------------------*/
function SWEP:ShootAnimation()

	// Too lazy to create a table :)
	local AllowDryFire = self.Owner:GetActiveWeapon():GetClass() == ("weapon_mad_deagle") 
				   or self.Owner:GetActiveWeapon():GetClass() == ("weapon_mad_usp") 
				   or self.Owner:GetActiveWeapon():GetClass() == ("weapon_mad_usp_match")

	if (self.Weapon:Clip1() <= 0) then
		if (AllowDryFire) then
			if self.Weapon:GetDTBool(3) and self.Type == 2 then
				self.Weapon:SendWeaponAnim(ACT_VM_DRYFIRE_SILENCED)	// View model animation
			else
				self.Weapon:SendWeaponAnim(ACT_VM_DRYFIRE) 		// View model animation
			end
		elseif self.Weapon:GetDTBool(3) and self.Type == 2 then
			self.Weapon:SendWeaponAnim(ACT_VM_PRIMARYATTACK_SILENCED) 	// View model animation
		else
			self.Weapon:SendWeaponAnim(ACT_VM_PRIMARYATTACK) 		// View model animation
		end
	else
		if self.Weapon:GetDTBool(3) and self.Type == 2 then
			self.Weapon:SendWeaponAnim(ACT_VM_PRIMARYATTACK_SILENCED) 	// View model animation
		else
			self.Weapon:SendWeaponAnim(ACT_VM_PRIMARYATTACK) 		// View model animation
		end
	end
end

/*---------------------------------------------------------
   Name: SWEP:FireShot()
   Desc: A convenience function to call ShootFire
---------------------------------------------------------*/

function SWEP:FireShot(attacker, tr, dmginfo) 
	if not self.Owner:IsNPC() and self.Owner:GetNetworkedInt("Fuel") > 0 then
		self:ShootFire(attacker, tr, dmginfo) 
	end
end

/*---------------------------------------------------------
   Name: SWEP:ShootBullet()
   Desc: A convenience function to shoot bullets.
---------------------------------------------------------*/
local TracerName = "Tracer"

function SWEP:ShootBullet(damage, recoil, num_bullets, aimcone)

	num_bullets 		= num_bullets or 1
	aimcone 			= aimcone or 0

	self:ShootEffects()

	if self.Tracer == 1 then
		TracerName = "Ar2Tracer"
	elseif self.Tracer == 2 then
		TracerName = "AirboatGunHeavyTracer"
	else
		TracerName = "Tracer"
	end
	
	local bullet = {}
		bullet.Num 		= num_bullets
		bullet.Src 		= self.Owner:GetShootPos()			// Source
		bullet.Dir 		= self.Owner:GetAimVector()			// Dir of bullet
		bullet.Spread 	= Vector(aimcone, aimcone, 0)			// Aim Cone
		bullet.Tracer	= 1							// Show a tracer on every x bullets
		bullet.TracerName = TracerName
		bullet.Force	= damage * 0.5					// Amount of force to give to phys objects
		bullet.Damage	= damage
		bullet.Callback	= function(attacker, tr, dmginfo) 
			self:FireShot(attacker, tr, dmginfo)
			local effectdata = EffectData()
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
				effectdata:SetRadius(tr.MatType)
				effectdata:SetScale(1)
			return self:RicochetCallback_Redirect(attacker, tr, dmginfo) 
		end

	self.Owner:FireBullets(bullet)

	if self.Weapon:GetDTBool(1) then
		if self.Silenced == false then
			local Vm = self.Owner:GetViewModel()
			local fx = EffectData()
			fx:SetEntity(self.Weapon)
			fx:SetOrigin(self.Owner:GetShootPos())
			fx:SetNormal(self.Owner:GetAimVector())
			fx:SetAttachment(Vm:LookupAttachment( "1" ))
			util.Effect("buu_muzzle",fx)
		end
	else
		if ( self.Weapon:Clip1() <= 1 ) && self.ShootEmptyAnim == true then
			self.Weapon:SendWeaponAnim(ACT_VM_PRIMARYATTACK_EMPTY)
		else
			self.Weapon:SendWeaponAnim(ACT_VM_PRIMARYATTACK) 
		end
	end
	if self.Silenced == true then
		local Vm = self.Owner:GetViewModel()
		local fx = EffectData()
		fx:SetEntity(self.Weapon)
		fx:SetOrigin(self.Owner:GetShootPos())
		fx:SetNormal(self.Owner:GetAimVector())
		fx:SetAttachment(Vm:LookupAttachment( "1" ))
		util.Effect("buu_muzzle_silenced",fx)
	end
	
	// Realistic recoil. Only on snipers and shotguns. Disable for the admin gun because if you put the max damage, you'll fly like you never fly!
	if (SERVER and (self.Sniper or self.Shotgun) and not self.Owner:GetActiveWeapon():GetClass() == ("weapon_mad_admin")) then
		self.Owner:SetVelocity(self.Owner:GetAimVector() * -(damage * num_bullets))
	end

	// Recoil
	if (not self.Owner:IsNPC()) and ((game.SinglePlayer() and SERVER) or (not game.SinglePlayer() and CLIENT)) then
		local eyeangle 	= self.Owner:EyeAngles()
		eyeangle.pitch 	= eyeangle.pitch - recoil
		self.Owner:SetEyeAngles(eyeangle)
	end
	
	local trace = self.Owner:GetEyeTrace();

	if trace.HitPos:Distance(self.Owner:GetShootPos()) > 250 or self.DestroyDoor == 0 then return end
	if !self.Shotgun then return end

	if trace.Entity:GetClass() == "prop_door_rotating" and (SERVER) then

		trace.Entity:Fire("open", "", 0.001)
		trace.Entity:Fire("unlock", "", 0.001)

		local pos = trace.Entity:GetPos()
		local ang = trace.Entity:GetAngles()
		local model = trace.Entity:GetModel()
		local skin = trace.Entity:GetSkin()

		local smoke = EffectData()
			smoke:SetOrigin(pos)
			util.Effect("effect_smokedoor", smoke)

		trace.Entity:SetNotSolid(true)
		trace.Entity:SetNoDraw(true)

		local function ResetDoor(door, fakedoor)
			door:SetNotSolid(false)
			door:SetNoDraw(false)
			fakedoor:Remove()
		end

		local norm = (pos - self.Owner:GetPos())
		norm:Normalize()
		local push = 1000 * norm
		local ent = ents.Create("prop_physics")

		ent:SetPos(pos)
		ent:SetAngles(ang)
		ent:SetModel(model)

		if(skin) then
			ent:SetSkin(skin)
		end

		ent:Spawn()

		timer.Simple(0.01, function() if ent and push then ent:GetPhysicsObject():SetVelocity(push) end end)              
		timer.Simple(0.01, function() if ent and push then ent:GetPhysicsObject():SetVelocity(push) end end)
		timer.Simple(25, function() ResetDoor( trace.Entity, ent, 10) end )
	end
end

/*---------------------------------------------------------
   Name: SWEP:BulletPenetrate()
---------------------------------------------------------*/
function SWEP:BulletPenetrate(bouncenum, attacker, tr, dmginfo, isplayer)

	if (CLIENT) then return end

	local MaxPenetration

	if self.Primary.Ammo == "Pistol" then
		MaxPenetration = 150
	elseif self.Primary.Ammo == "smg1" then
		MaxPenetration = 120
	elseif self.Primary.Ammo == "buckshot" then
		MaxPenetration = 70
	elseif self.Primary.Ammo == "AR2" then
		MaxPenetration = 200
	elseif self.Primary.Ammo == "357" then
		MaxPenetration = 400
	elseif self.Primary.Ammo == "XBowBolt" then
		MaxPenetration = 500
	else
		MaxPenetration = 150
	end
	
	if self.MinPenetration >= 0 and MaxPenetration < self.MinPenetration then
		MaxPenetration = self.MinPenetration
	end
		
	local DoDefaultEffect = true
	// Don't go through metal, sand or player
	if ((tr.MatType == MAT_METAL and self.Ricochet) or (tr.MatType == MAT_SAND) or (tr.Entity:IsPlayer())) then return false end

	// Don't go through more than 3 times
	if (bouncenum > self.ChainHit) then return false end
	
	// Direction (and length) that we are going to penetrate
	local PenetrationDirection = tr.Normal * MaxPenetration
	
	if (tr.MatType == MAT_GLASS or tr.MatType == MAT_PLASTIC or tr.MatType == MAT_WOOD or tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH) then
		PenetrationDirection = tr.Normal * (MaxPenetration * 2)
	end
		
	local trace 	= {}
	trace.endpos 	= tr.HitPos
	trace.start 	= tr.HitPos + PenetrationDirection
	trace.mask 		= MASK_SHOT
	trace.filter 	= {self.Owner}
	   
	local trace 	= util.TraceLine(trace) 
	
	// Bullet didn't penetrate.
	if (trace.StartSolid or trace.Fraction >= 1.0 or tr.Fraction <= 0.0) then return false end
	
	// Damage multiplier depending on surface
	local fDamageMulti = 0.5
	
	if fDamageMulti < self.PenetrationDmgMult then
		fDamageMulti = self.PenetrationDmgMult
	end
	
	if (tr.MatType == MAT_CONCRETE) then
		fDamageMulti = fDamageMulti - 0.2
	elseif (tr.MatType == MAT_WOOD or tr.MatType == MAT_PLASTIC or tr.MatType == MAT_GLASS) then
		fDamageMulti = fDamageMulti + 0.3
	elseif (tr.MatType == MAT_FLESH or tr.MatType == MAT_ALIENFLESH) then
		fDamageMulti = fDamageMulti + 0.4
	end
	
	if fDamageMulti > 0.95 then
		fDamageMulti = 0.95;
	end
		
	// Fire bullet from the exit point using the original trajectory
	local bullet = 
	{	
		Num 		= 1,
		Src 		= trace.HitPos,
		Dir 		= tr.Normal,	
		Spread 		= Vector(0, 0, 0),
		Tracer		= 1,
		TracerName 	= "effect_mad_penetration_trace",
		Force		= (dmginfo:GetDamage() * fDamageMulti) * 0.5,
		Damage		= (dmginfo:GetDamage() * fDamageMulti),
		HullSize	= 2
	}
	
	bullet.Callback   = function(a, b, c) 
		if (self.Ricochet) then 
			self:FireShot(a, b, c)
			return self:RicochetCallback(bouncenum + 1, a, b, c) 
		end 
	end
	
	timer.Simple(0.05, function()
		if not IsFirstTimePredicted() then return end
		attacker.FireBullets(attacker, bullet, true)
	end)

	return true
end

/*---------------------------------------------------------
   Name: SWEP:RicochetCallback()
---------------------------------------------------------*/
function SWEP:RicochetCallback(bouncenum, attacker, tr, dmginfo)

	if (CLIENT) then return end

	if (not self) then return end

	local DoDefaultEffect = true
	if (tr.HitSky) then return end
	
	// Can we go through whatever we hit?
	if (self.Penetration) and (self:BulletPenetrate(bouncenum, attacker, tr, dmginfo)) then
		return {damage = true, effects = DoDefaultEffect}
	end
	
	if self.ExplosiveShot then
		local effectdata = EffectData()
			effectdata:SetOrigin(tr.HitPos)
			effectdata:SetNormal(tr.HitNormal)
			effectdata:SetScale(1)
		util.Effect("ManhackSparks", effectdata)
		util.Effect("cball_explode", effectdata)
		util.Effect("Explosion", effectdata)
		ParticleEffect("dusty_explosion_rockets",tr.HitPos,Angle(0,0,0),nil)
		util.BlastDamage(self, attacker, tr.HitPos, 75, dmginfo:GetDamage())
		util.ScreenShake(tr.HitPos, 100, 100, 7.5, 75)
	end
	
	// Your screen will shake and you'll hear the savage hiss of an approaching bullet which passing if someone is shooting at you.
	if (tr.MatType != MAT_METAL and not self.SuperRicochet ) then
		if (SERVER) then
			util.ScreenShake(tr.HitPos, 5, 0.1, 0.5, 64)
			sound.Play("Bullets.DefaultNearmiss", tr.HitPos, 250, math.random(110, 180), 1)
		end

		if self.Tracer == 1 or self.Tracer == 2 then
			local effectdata = EffectData()
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
				effectdata:SetScale(20)
			util.Effect("AR2Impact", effectdata)
		elseif self.Tracer == 3 then
			local effectdata = EffectData()
				effectdata:SetOrigin(tr.HitPos)
				effectdata:SetNormal(tr.HitNormal)
				effectdata:SetScale(20)
			util.Effect("StunstickImpact", effectdata)
		end

		return 
	end

	if (self.Ricochet == false) then return {damage = true, effects = DoDefaultEffect} end
	
	if (bouncenum > self.MaxRicochet) then return end
	
	// Bounce vector
	local trace = {}
	trace.start = tr.HitPos
	trace.endpos = trace.start + (tr.HitNormal * 16384)

	local trace = util.TraceLine(trace)

 	local DotProduct = tr.HitNormal:Dot(tr.Normal * -1) 
	
	local bullet = 
	{	
		Num 		= 1,
		Src 		= tr.HitPos + (tr.HitNormal * 5),
		Dir 		= ((2 * tr.HitNormal * DotProduct) + tr.Normal) + (VectorRand() * 0.05),
		Spread 		= Vector(0, 0, 0),
		Tracer		= 1,
		TracerName 	= "effect_mad_ricochet_trace",
		Force		= dmginfo:GetDamage() * 0.25,
		Damage		= dmginfo:GetDamage() * 0.5,
		HullSize	= 2
	}
		
	// Added conditional to stop errors when bullets ricochet after weapon switch
	bullet.Callback   = function(a, b, c) 
		if (self.Ricochet) then 
			self:FireShot(a, b, c)
			return self:RicochetCallback(bouncenum + 1, a, b, c) 
		end 
	end

	timer.Simple(0.05, function()
		if not IsFirstTimePredicted() then return end
		attacker.FireBullets(attacker, bullet, true)
	end)
	
	return {damage = true, effects = DoDefaultEffect}
end

/*---------------------------------------------------------
   Name: SWEP:RicochetCallback_Redirect()
---------------------------------------------------------*/
function SWEP:RicochetCallback_Redirect(a, b, c)
 
	return self:RicochetCallback(0, a, b, c) 
end

function SWEP:Graze( target, dmg )

end

function SWEP:Parry( target, dmg )

end

/*---------------------------------------------------------
   Name: SWEP:CanPrimaryAttack()
   Desc: Helper function for checking for no ammo.
---------------------------------------------------------*/
function SWEP:CanPrimaryAttack()

	// Clip is empty or you're under water
	if (self.Weapon:Clip1() <= 0) or (self.Owner:WaterLevel() > 2) then
		self.Weapon:SetNextPrimaryFire(CurTime() + 0.5)
//		self.Weapon:EmitSound("Default.ClipEmpty_Pistol")
		return false
	end

	// You're sprinting or your weapon is holsted
	if not self.Owner:IsNPC() and (self.Owner:KeyDown(IN_SPEED) or self.Weapon:GetDTBool(0) or self.Owner:WaterLevel() > 2) then
		self.Weapon:SetNextPrimaryFire(CurTime() + 0.5)
		return false
	end

	return true
end

/*---------------------------------------------------------
   Name: SWEP:CanSecondaryAttack()
   Desc: Helper function for checking for no ammo.
---------------------------------------------------------*/
function SWEP:CanSecondaryAttack()

	// Clip is empty or you're under water
	if (self.Weapon:Clip2() <= 0) then
		self.Weapon:SetNextSecondaryFire(CurTime() + 0.5)
//		self.Weapon:EmitSound("Default.ClipEmpty_Pistol")
		return false
	end

	// You're sprinting or your weapon is holsted
	if not self.Owner:IsNPC() and (self.Owner:KeyDown(IN_SPEED) or self.Weapon:GetDTBool(0) or self.Owner:WaterLevel() > 2) then
		self.Weapon:SetNextSecondaryFire(CurTime() + 0.5)
		return false
	end

	return true
end

function SWEP:DrawWorldModel()

	local hand, offset, rotate

	if not IsValid(self.Owner) then
		self:SetRenderOrigin( nil )
        self:SetRenderAngles( nil )
        self:DrawModel()
		return
	end

	hand = self.Owner:GetAttachment(self.Owner:LookupAttachment("anim_attachment_rh"))
	
	if hand == nil then
		self:SetRenderOrigin( nil )
        self:SetRenderAngles( nil )
		self:DrawModel()
		return
	end

	-- Unfortunately some player models don't conform with the anim_attachment_rh angle
	if self.Owner:GetModel() == "models/player/shi/adult_neptune.mdl" then -- Shitty anim_attachment_rh
		hand.Ang:RotateAroundAxis(hand.Ang:Right(), 90)
		hand.Ang:RotateAroundAxis(hand.Ang:Up(), 90)
	end
	
	offset = hand.Ang:Right() * self.Offset.Pos.Right + hand.Ang:Forward() * self.Offset.Pos.Forward + hand.Ang:Up() * self.Offset.Pos.Up
	
	hand.Ang:RotateAroundAxis(hand.Ang:Right(), self.Offset.Ang.Right)
	hand.Ang:RotateAroundAxis(hand.Ang:Forward(), self.Offset.Ang.Forward)
	hand.Ang:RotateAroundAxis(hand.Ang:Up(), self.Offset.Ang.Up)
	
	self:SetRenderOrigin(hand.Pos + offset)
	self:SetRenderAngles(hand.Ang)

	self:DrawModel()

	if (CLIENT) then
		self:SetModelScale(self.Offset.Scale,self.Offset.Scale - 0.1,self.Offset.Scale)
	end
end

/*---------------------------------------------------------
   Name: SWEP:EntityFaceBack
   Desc: Is the entity face back to the player?
---------------------------------------------------------*/
function SWEP:EntsInSphereBack(pos, range)

	local ents = ents.FindInSphere(pos, range)

	for k, v in pairs(ents) do
		if v ~= self and v ~= self.Owner and (v:IsNPC() or v:IsPlayer()) and IsValid(v) and self:EntityFaceBack(v) then
			return true
		end
	end

	return false
end

/*---------------------------------------------------------
   Name: SWEP:EntityFaceBack
   Desc: Is the entity face back to the player?
---------------------------------------------------------*/
function SWEP:EntityFaceBack(ent)

	local angle = self.Owner:GetAngles().y - ent:GetAngles().y

	if angle < -180 then angle = 360 + angle end
	if angle <= 90 and angle >= -90 then return true end

	return false
end

/*---------------------------------------------------------
   Name: SWEP:EntityFaceFront
   Desc: Is the entity face back to the player?
---------------------------------------------------------*/
function SWEP:EntityFaceFront(ent, ang)

	local angle = self.Owner:EyeAngles().y - ( ent:GetPos() - self.Owner:GetPos() ):Angle().y
	
	if angle < -180 then angle = 360 + angle end
	if angle <= ang and angle >= -ang then return true end

	return false
end
--PATH addons/vapeswep/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/vapeswep/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/vapeswep/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onions"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Vapes"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.VapeID = 1

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:PrimaryAttack()
	if SERVER then
		VapeUpdate(self.Owner, self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SecondaryAttack()
	if GetConVar("vape_block_sounds"):GetBool() then return end
	
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapegogreen.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (0.6*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Reload()
	if GetConVar("vape_block_sounds"):GetBool() then return end

	if self.reloading then return end
	self.reloading=true
	timer.Simple(0.5, function() self.reloading=false end)
	local pitch = 100 + (self.SoundPitchMod or 0) + (self.Owner:Crouching() and 40 or 0)
	self:EmitSound("vapenaysh.wav", 80, pitch + math.Rand(-5,5))
	if SERVER then
		net.Start("VapeTalking")
		net.WriteEntity(self.Owner)
		net.WriteFloat(CurTime() + (2.2*100/pitch))
		net.Broadcast()
	end
end

function SWEP:Holster()
	if SERVER and IsValid(self.Owner) then
		ReleaseVape(self.Owner)
	end
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--PATH addons/vapeswep/lua/weapons/weapon_vape_hallucinogenic.lua:
-- weapon_vape_hallucinogenic.lua
-- Defines a vape which makes hallucinogenic effects on the user's screen

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Hallucinogenic Vape"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nThis juice contains hallucinogens (don't worry, they're healthy and all-natural)"

SWEP.VapeAccentColor = Vector(0.5,1,0)
SWEP.VapeTankColor = Vector(-1,-1,-1)

SWEP.VapeID = 5

if CLIENT then
	hook.Add("RenderScreenspaceEffects","HallucinogenicVape",function()
		if (vapeHallucinogen or 0) > 0 then
			if vapeHallucinogen>100 then vapeHallucinogen=100 end
			local alpha = vapeHallucinogen/100
			DrawMotionBlur( 0.04, alpha, 0 )

			local tab = {}
			tab[ "$pp_colour_colour" ] =   1 + (alpha*0.25)
			tab[ "$pp_colour_contrast" ] = 1 + alpha
			tab[ "$pp_colour_brightness" ] = -0.1*alpha
			DrawColorModify(tab)

		end
	end)

	timer.Create("HallucinogenicVapeCounter",0.1,0,function()
		if (vapeHallucinogen or 0) > 0 then vapeHallucinogen = vapeHallucinogen-1 end
	end)
end
--PATH addons/vapeswep/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3)
	local vmang1=self.VapeVMAng1 or Vector(170,-105,82)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(170,-108,132)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end
--PATH addons/snowball/lua/weapons/zck_snowballswep/shared.lua:
SWEP.PrintName = "Снежки"
SWEP.Author = "Zerochain"
SWEP.Instructions = "LeftClick Throw Snoball, RightClick Pickup snow"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.AdminSpawnable = false
SWEP.Spawnable = true
SWEP.ViewModelFOV = 45
SWEP.ViewModel = "models/zerochain/props_christmas/snowballswep/zck_c_snowballswep.mdl"
SWEP.WorldModel =  "models/zerochain/props_christmas/snowballswep/zck_w_snowballswep.mdl"
SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom = true
SWEP.Slot = 1
SWEP.SlotPos = 1
SWEP.HoldType = "grenade"
SWEP.FiresUnderwater = false
SWEP.Weight = 5
SWEP.DrawCrosshair = true
SWEP.Category = "Zeros Snowball Swep"
SWEP.DrawAmmo = false
SWEP.base = "weapon_base"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 1
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Recoil = 1
SWEP.Secondary.Delay = 0.4
SWEP.UseHands = true
SWEP.DisableDuplicator = true


function SWEP:SetupDataTables()
	self:NetworkVar("Int", 0, "SnowballCount")

	if SERVER then
		self:SetSnowballCount(5)
	end
end

--PATH addons/zeros_weedfarm/lua/weapons/zwf_bong/shared.lua:
SWEP.PrintName = "Bong" // The name of your SWEP
SWEP.Author = "ZeroChain" // Your name
SWEP.Instructions = "Hold LMB: Smoke Weed | RMB: Add Weed | MMB: Drop / Share | Reload: Empty Bong" // How do people use your SWEP?
SWEP.Contact = "https://www.gmodstore.com/users/ZeroChain" // How people should contact you if they find bugs, errors, etc
SWEP.Purpose = "Used to smoke weed." // What is the purpose of the SWEP?
SWEP.IconLetter	= "V"

SWEP.AutomaticFrameAdvance = true

SWEP.AdminSpawnable = false // Is the SWEP spawnable for admins?
SWEP.Spawnable = false // Can everybody spawn this SWEP? - If you want only admins to spawn it, keep this false and admin spawnable true.

SWEP.ViewModelFOV = 90 // How much of the weapon do you see?
SWEP.UseHands = true
SWEP.ViewModel = "models/zerochain/props_weedfarm/zwf_bong01_vm.mdl"
SWEP.WorldModel = "models/zerochain/props_weedfarm/zwf_bong01_vm.mdl"


SWEP.AutoSwitchTo = true // When someone picks up the SWEP, should it automatically change to your SWEP?
SWEP.AutoSwitchFrom = false // Should the weapon change to the a different SWEP if another SWEP is picked up?
SWEP.Slot = 3 // Which weapon slot you want your SWEP to be in? (1 2 3 4 5 6)
SWEP.SlotPos = 1 // Which part of that slot do you want the SWEP to be in? (1 2 3 4 5 6)
SWEP.HoldType = "slam" // How is the SWEP held? (Pistol SMG Grenade Melee)
SWEP.FiresUnderwater = false // Does your SWEP fire under water?
SWEP.Weight = 5 // Set the weight of your SWEP.
SWEP.DrawCrosshair = true // Do you want the SWEP to have a crosshair?
SWEP.Category = "Zeros GrowOP"
SWEP.DrawAmmo = false // Does the ammo show up when you are using it? True / False
SWEP.base = "weapon_base" //What your weapon is based on.

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"
SWEP.Primary.Recoil = 1
SWEP.Primary.Delay = 1

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"
SWEP.Secondary.Recoil = 1
SWEP.Secondary.Delay = 1


function SWEP:SetupDataTables()
    self:NetworkVar("Int", 1, "WeedID")
    self:NetworkVar("String", 0, "Weed_Name")
    self:NetworkVar("Int", 2, "Weed_THC")
    self:NetworkVar("Int", 3, "Weed_Amount")
    self:NetworkVar("Bool", 0, "IsBusy")
    self:NetworkVar("Bool", 2, "IsBurning")
    self:NetworkVar("Bool", 3, "IsSmoking")

    if (SERVER) then
        self:SetWeedID(-1)
        self:SetWeed_THC(-1)
        self:SetIsBusy(false)
        self:SetWeed_Name("NILL")
        self:SetWeed_Amount(0)
        self:SetIsBurning(false)

        self:SetIsSmoking(false)
    end
end

--PATH addons/zeros_weedfarm/lua/weapons/zwf_shoptablet/cl_init.lua:
include("shared.lua")
SWEP.PrintName = "Планшет" // The name of your SWEP
SWEP.Slot = 1
SWEP.SlotPos = 2
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = true // Do you want the SWEP to have a crosshair?

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)

end

function SWEP:SecondaryAttack()

	self:SetNextSecondaryFire(CurTime() + 1)
end

function SWEP:PrimaryAttack()

	self:SetNextPrimaryFire(CurTime() + 1)
end


function SWEP:Deploy()
	self:SendWeaponAnim(ACT_VM_DRAW)
end

--PATH addons/mod_bitminers2/lua/entities/bm2_plug_1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"

ENT.PrintName = "Extention Lead"
ENT.Spawnable = false
ENT.Category = "Bitminers 2"

function ENT:SetupDataTables()
	self:NetworkVar("Entity", 0, "owning_ent")
end
--PATH addons/cp_ballistic_shields/lua/ballistic_shields/cl_bs_util.lua:
if SERVER then return end
include( "bs_config.lua" )

net.Receive( "bs_shield_info", function( len, pl )
	LocalPlayer().bs_shieldIndex = net.ReadUInt(16)	
end )

local Delay = 0
function bshields_materials_reload()
	for _,v in pairs(bshields.materialstoload) do
		Delay = Delay + 0.2
		timer.Simple( Delay, function() surface.GetURL(v[1], v[2], v[3]) end )
	end

	bshields.hshield_webmat = surface.GetURL(bshields.config.hShieldTexture, 256, 256)
	bshields.rshield_webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	bshields.dshield_webmat = surface.GetURL(bshields.config.dShieldTexture, 256, 256)
end

bshields.materialstoload = {
	{bshields.config.hShieldTexture, 256, 256},
	{bshields.config.rShieldTexture, 256, 256},
	{bshields.config.dShieldTexture, 256, 256}
}

hook.Add( "InitPostEntity", "bshields_init_client", function()
	bshields_materials_reload()
end)
      
surface.CreateFont( "bshields.HudFont", {
	font = "Roboto",
	size = ScrH()/1080*18,
	extended = true
})
--PATH addons/cp_ballistic_shields/lua/bs_config.lua:
include( "ballistic_shields/sh_bs_util.lua" )

--------------------- BALLISTIC SHIELDS V1.1.9 -------------------------

---- CONFIG ----
-- AVALAIBLE LANGUAGES - English, German, French, Danish, Turkish
bshields.config.language = "English"
-- DISABLE HUD
bshields.config.disablehud = true
-- MINIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmin = 8
-- MAXIMUM RIOT SHIELD DAMAGE
bshields.config.rshielddmgmax = 16
-- HEAVY SHIELD EXPLOSION DAMAGE REDUCITON (IN %)
bshields.config.hshieldexpl = 100
-- HEAVY SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.hshieldmelee = 100
-- RIOT SHIELD MELEE DAMAGE REDUCTION (IN %)
bshields.config.rshieldmelee = 100
-- HEAVY SHIELD BREACH COOLDOWN (IN SECONDS)
bshields.config.hshieldcd = 20
-- DOOR RESPAWN TIMER (IN SECONDS)
bshields.config.doorrespawn = 60
-- MAXIMUM AMOUNT OF DEPLOYED SHIELDS
bshields.config.maxshields = 3
-- SHOULD FADING DOORS BE BREACHABLE?
bshields.config.breachfdoors = false
-- ALLOW BREACHING UNOWNED DOORS
bshields.config.breachudoors = false
-- REMOVE DEPLOYED SHIELDS ON JOB CHANGE
bshields.config.removeonjobchange = true

-------- CUSTOM TEXTURES, LEAVE "" FOR DEFAULT "POLICE" TEXT. ----------
--- FOR EDITING USE THE 256x256 TEMPLATE INCLUDED IN THE MAIN FOLDER ---

-- HEAVY SHIELD
bshields.config.hShieldTexture = ""
-- RIOT SHIELD
bshields.config.rShieldTexture = ""
-- DEPLOYABLE SHIELD
bshields.config.dShieldTexture = "" 
-- PLAYERS MIGHT HAVE TO RECONNECT IN ORDER TO SEE THE NEW TEXTURES! ---

-- [CW2 ONLY] YOU NEED THIS ADDON: https://steamcommunity.com/sharedfiles/filedetails/?id=1771994451
-- SHOULD RIOT SHIELD BE BULLETPROOF? --
bshields.config.rshieldbp = false
--PATH addons/cp_ballistic_shields/lua/ballistic_shields/sh_bs_util.lua:
bshields = bshields or {}
bshields.config = bshields.config or {}

bshields.shields = {
	{
		[1] = {
			["angles"] = Angle(4,6,-14),
			["position"] = Vector(0,8,-1)
		},
		[2] = {
			["angles"] = Angle(6,6,-12),
			["position"] = Vector(8,10,-4)
		},
		[3] = {
			["angles"] = Angle(-3,7,-16),
			["position"] = Vector(-1,4,-3)
		}
	},
	{
		[1] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-4,-8)
		},
		[2] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(16,-3,-12)
		},
		[3] = {
			["angles"] = Angle(-12,0,0),
			["position"] = Vector(6,-3,-12)
		}
	},
	{
		[1] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-7,-13)
		},
		[2] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-6,-22)
		},
		[3] = {
			["angles"] = Angle(70,78,-16),
			["position"] = Vector(1,-8,-12)
		}
	}
}

--PATH addons/cp_ballistic_shields/lua/entities/bs_rshield/cl_init.lua:
include('shared.lua')
include( "ballistic_shields/cl_bs_util.lua" ) 
ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()  
	if(bshields.config.rShieldTexture == "") then self:DrawModel() return end
	local webmat = surface.GetURL(bshields.config.rShieldTexture, 256, 256)
	
	if ( self.Mat ) then
		render.MaterialOverrideByIndex( 1, self.Mat )
	end 
	local html_mat = webmat
	local matdata =
	{
        ["$basetexture"]=html_mat:GetName(),
        ["$decal"] = 1,
        ["$translucent"] = 1
	}

	local uid = string.Replace( html_mat:GetName(), "__vgui_texture_", "" )

	self.Mat = CreateMaterial( "bshields_webmat_"..uid, "VertexLitGeneric", matdata )
	self:DrawModel()
	render.ModelMaterialOverride( nil )
end   
--PATH addons/the_cocaine_factory/lua/entities/cocaine_baking_soda/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	self:DrawModel()	
end		
--PATH addons/the_cocaine_factory/lua/entities/cocaine_drying_rack/cl_init.lua:
include( "shared.lua" )

net.Receive( "COCAINE_DryerLoadingBar", function( length, ply )
	cocaine_dryer = net.ReadEntity()
	
	cocaine_dryer.LoadingBar = CurTime() + 10
end )

function ENT:Draw()	
	self:DrawModel()
end

local DryValue = 0
local LastThink = 0
local DrySpeed = ( 106 / TCF.Config.DryingTime ) -- 106 is 1 second

net.Receive( "COCAINE_DryCocaine", function( length, ply )
	local drying_rack = net.ReadEntity()
	local dry_value = net.ReadBool()
	
	drying_rack.DryingCocaine = dry_value
	if dry_value then
		DryValue = 0
	else
		DryValue = 100
	end
end )

local CurNumber = 0
local SwitchSpeed = 400

net.Receive( "COCAINE_DryingSwitch", function( length, ply )
	local drying_rack = net.ReadEntity()
	local switch_value = net.ReadBool()
	
	drying_rack.SwitchOn = switch_value
	if switch_value then
		CurNumber = 0
	else
		CurNumber = 100
	end
end )

function ENT:Think()
	local now = CurTime()
	local timepassed = now - LastThink
	LastThink = now
	
	if self.DryingCocaine then
		DryValue = math.Approach( DryValue, 100, DrySpeed * timepassed )
		
		self:SetPoseParameter( "thermometer", DryValue )
	else
		DryValue = math.Approach( DryValue, 0, DrySpeed * timepassed )
		
		self:SetPoseParameter( "thermometer", DryValue )
	end
	
	if self.SwitchOn then
		CurNumber = math.Approach( CurNumber, 100, SwitchSpeed * timepassed )
		
		self:SetPoseParameter( "switch", CurNumber )
	else
		CurNumber = math.Approach( CurNumber, 0, SwitchSpeed * timepassed )
		
		self:SetPoseParameter( "switch", CurNumber )
	end
	
	-- Battery Charge Amount
	if self:GetBatteryCharge() >= 0 then
		self:SetPoseParameter( "power", self:GetBatteryCharge() )
	end
	
	self:InvalidateBoneCache()
end
--PATH addons/the_cocaine_factory/lua/entities/cocaine_extractor/cl_init.lua:
include( "shared.lua" )

function ENT:DrawTranslucent()
	self:DrawModel()
end

function ENT:Initialize()
	if TCF.Config.StoveSmokeEffect then
		self.emitTime = CurTime()
		
		self.pipepos1 = ParticleEmitter( self:GetPos() )
		self.pipepos2 = ParticleEmitter( self:GetPos() )
	end
end

local CurNumber = 0
local LastThink = 0
local SwitchSpeed = 300

local GaugeNumber = 0
local GaugeSpeed = ( 100 / TCF.Config.ExtractionTime )

net.Receive( "COCAINE_ExtractorGaugeBucketFill", function( length, ply )
	local extractor = net.ReadEntity()
	cocaine_bucket = net.ReadEntity()
	local gauge_on = net.ReadBool()
	
	extractor.GaugeOn = gauge_on
	if gauge_on then
		GaugeNumber = 0
	else
		GaugeNumber = 100
	end
end )

net.Receive( "COCAINE_ExtractorSwitch", function( length, ply )
	local extractor = net.ReadEntity()
	local switch_value = net.ReadBool()
	
	extractor.SwitchOn = switch_value
	if switch_value then
		CurNumber = 0
	else
		CurNumber = 100
	end
end )

function ENT:Think()
	-- Smoke effect when activated
	if TCF.Config.StoveSmokeEffect then
		if GaugeNumber > 0 then
			if self.emitTime < CurTime() then
				local smoke = self.pipepos1:Add( "particle/smokesprites_000"..math.random( 1, 9 ), self:GetAttachment( 8 ).Pos )
				smoke:SetVelocity( Vector( 0, 0, 125 ) )
				smoke:SetDieTime( math.Rand( 1, 1 ) )
				smoke:SetStartAlpha( 50 )
				smoke:SetEndAlpha( 5 )
				smoke:SetStartSize( math.random( 1, 3 ) )
				smoke:SetEndSize( math.random( 7, 15 ) )
				smoke:SetRoll( math.Rand( 180, 480 ) )
				smoke:SetRollDelta( math.Rand( -3, 3 ) ) 
				smoke:SetColor( 200, 200, 200, 200 )
				smoke:SetGravity( Vector( -15, -35, 12 ) )
				smoke:SetAirResistance( 200 )

				local smoke2 = self.pipepos2:Add( "particle/smokesprites_000"..math.random( 1, 9 ), self:GetAttachment( 9 ).Pos )
				smoke2:SetVelocity( Vector( 0, 0, 125 ) )
				smoke2:SetDieTime( math.Rand( 1, 1 ) )
				smoke2:SetStartAlpha( 50 )
				smoke2:SetEndAlpha( 5 )
				smoke2:SetStartSize( math.random( 1, 3 ) )
				smoke2:SetEndSize( math.random( 7, 15 ) )
				smoke2:SetRoll( math.Rand( 180, 480 ) )
				smoke2:SetRollDelta( math.Rand( -3, 3 ) ) 
				smoke2:SetColor( 200, 200, 200, 200 )
				smoke2:SetGravity( Vector( -15, 35, 12 ) )
				smoke2:SetAirResistance( 200 )
				
				self.emitTime = CurTime() + 0.02
			end
		end
	end

	local now = CurTime()
	local timepassed = now - LastThink
	LastThink = now
	
	if self.SwitchOn then
		CurNumber = math.Approach( CurNumber, 100, SwitchSpeed * timepassed )
		
		self:SetPoseParameter( "switch", CurNumber )
	else
		CurNumber = math.Approach( CurNumber, 0, SwitchSpeed * timepassed )
		
		self:SetPoseParameter( "switch", CurNumber )
	end
	
	-- Leafs Amount
	if self:GetLeafs() >= 0 then
		self:SetPoseParameter( "arrow_1", self:GetLeafs() )
	end
		
	-- Baking Soda Amount
	if self:GetBakingSoda() >= 0 then
		self:SetPoseParameter( "arrow_2", self:GetBakingSoda() )
	end
	
	if IsValid( cocaine_bucket ) then
		if self.GaugeOn then
			GaugeNumber = math.Approach( GaugeNumber, 100, GaugeSpeed * timepassed )
			
			self:SetPoseParameter( "gauge", GaugeNumber )
			cocaine_bucket:SetPoseParameter( "cocaine", GaugeNumber )
		else
			GaugeNumber = math.Approach( GaugeNumber, 0, 20 * timepassed )
			
			self:SetPoseParameter( "gauge", GaugeNumber )
			cocaine_bucket:SetPoseParameter( "cocaine", 100 )
		end
	end
	
	self:InvalidateBoneCache()
end
--PATH gamemodes/darkrp/entities/entities/darkrp_laws/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "DarkRP Laws"
ENT.Instructions = "Use /addlaws to add a custom law, /removelaw <num> to remove a law."
ENT.Author = "Drakehawke"

ENT.Spawnable = false

local plyMeta = FindMetaTable("Player")
DarkRP.declareChatCommand{
    command = "addlaw",
    description = "Add a law to the laws board.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "removelaw",
    description = "Remove a law from the laws board.",
    delay = 1.5,
    condition = plyMeta.isMayor
}

DarkRP.declareChatCommand{
    command = "placelaws",
    description = "Place a laws board.",
    delay = 1.5
}

DarkRP.declareChatCommand{
    command = "resetlaws",
    description = "Reset all laws.",
    delay = 1.5
}

DarkRP.getLaws = DarkRP.stub{
    name = "getLaws",
    description = "Get the table of all current laws.",
    parameters = {
    },
    returns = {
        {
            name = "laws",
            description = "A table of all current laws.",
            type = "table"
        }
    },
    metatable = DarkRP,
    realm = "Shared"
}

DarkRP.resetLaws = DarkRP.stub{
    name = "resetLaws",
    description = "Reset to default laws.",
    parameters = {
    },
    returns = {
    },
    metatable = DarkRP,
    realm = "Server"
}

DarkRP.hookStub{
    name = "addLaw",
    description = "Called when a law is added.",
    parameters = {
        {
            name = "index",
            description = "Index of the law",
            type = "number"
        },
        {
            name = "law",
            description = "Law string",
            type = "string"
        }
    },
    returns = {
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "removeLaw",
    description = "Called when a law is removed.",
    parameters = {
        {
            name = "index",
            description = "Index of law",
            type = "number"
        },
        {
            name = "law",
            description = "Law string",
            type = "string"
        }
    },
    returns = {
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "resetLaws",
    description = "Called when laws are reset.",
    parameters = {
        {
            name = "player",
            description = "The player resetting the laws.",
            type = "Player"
        }
    },
    returns = {
    },
    realm = "Shared"
}

DarkRP.hookStub{
    name = "canEditLaws",
    description = "Whether someone can edit laws.",
    parameters = {
        {
            name = "player",
            description = "The player trying to edit laws.",
            type = "Player"
        },
        {
            name = "action",
            description = "How the player is trying to edit laws.",
            type = "string"
        },
        {
            name = "arguments",
            description = "Arguments related to editing laws.",
            type = "table"
        }
    },
    returns = {
        {
            name = "canEdit",
            description = "A yes or no as to whether the player can edit the law.",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when they can't edit the law.",
            type = "string"
        }
    },
    realm = "Server"
}

--PATH addons/duels/lua/entities/duel_huesos/shared.lua:
ENT.Base = "base_ai" 
ENT.Type = "ai"

ENT.PrintName = "Непись с дуэльками"
ENT.Spawnable = true
ENT.AutomaticFrameAdvance = true
function ENT:SetAutomaticFrameAdvance( bUsingAnim )
	self.AutomaticFrameAdvance = bUsingAnim
end

--PATH addons/111mod/lua/entities/ent_picture1/cl_init.lua:
include'shared.lua'
cvar.Register'enable_pictureframes':SetDefault(true):AddMetadata('State', 'RPMenu'):AddMetadata('Menu', 'Отображение Картин')

timer.Simple( 2.5 , function() texture.SetProxy ("https://gmod-api.superiorservers.co/api/imageproxy/?url=%s&width=%i&height=%i&format=%s") end )


function ENT:RenderTexture()
    self.Rendering = true
	texture.Create(self:GetURL()):SetSize(2048, 1024):SetFormat(self:GetURL():sub(-3) == 'jpg' and 'jpg' or 'png'):EnableProxy(true):Download(self:GetURL(), function()
        if IsValid(self) then
            self.Rendering = false
            self.LastURL = self:GetURL()
        end
    end, function()
        if IsValid(self) then
            self.Rendering = false
        end
    end)
end

function ENT:GetTexture()
    return texture.Get(self:GetURL())
end

function ENT:Draw()
    self:DrawModel()
    if (cvar.GetValue('enable_pictureframes') == false) or (not self:InSight()) then return end
    if ((not self:GetTexture()) or (self:GetURL() ~= self.LastURL)) and (not self.Rendering) then
        self:RenderTexture()
    end

    local ang = self:GetAngles()
    ang:RotateAroundAxis(ang:Up(), 90)
    ang:RotateAroundAxis(ang:Forward(), 0)
    local scale = self:GetModelScale()
    local s = 1024 * scale
	local s2 = 2048 * scale
    local off = -(s * 0.5)
	local off2 = -(s2 * 0.5)
    cam.Start3D2D(self:GetPos() + (self:GetUp() * 1.55), ang, 0.04635)
    surface.SetDrawColor(25, 25, 25, 255)
    surface.DrawRect(off2, off, s2, s)

    if self.Rendering then
        local t = SysTime() * 5
        draw.NoTexture()
        surface.SetDrawColor(255, 255, 255, 255)
        surface.DrawArc(off2 + (s * 0.5), off + (s * 0.5), 111, 116, t * 180, t * 180 + 180, 10)
    elseif self:GetTexture() then
        surface.SetDrawColor(255, 255, 255, 255)
        surface.SetMaterial(self:GetTexture())
        surface.DrawTexturedRect(off2, off, s2, s)
    end

    cam.End3D2D()
end

local all_patterns = {"^https?://.*%.jpg", "^https?://.*%.png"}

local function IsValidURL(url)
    for _, pattern in ipairs(all_patterns) do
        if string.match(url, pattern) then return true end
    end
end

local fr

net.Receive('rp.OpenImageWindow', function()
    local set
    local text
    local ava

    if IsValid(fr) then
        fr:Close()
    end
	
	
    fr = ui.Create('ui_frame', function(self)
        self:SetSize(520, 120)
        self:SetTitle('Изменить')
        self:MakePopup()
        self:Center()

        function self:Think()
            if IsValid(set) and IsValid(text) and IsValidURL(text:GetValue()) then
                set:SetDisabled(false)
            else
                set:SetDisabled(true)
            end
        end
    end)

    text = ui.Create('DTextEntry', function(self, p)
        self:SetPos(5, 60)
        self:SetSize(p:GetWide() - 10, 25)

        self.OnEnter = function(s)
            set:DoClick()
        end
    end, fr)

    ui.Create('DLabel', function(self, p)
        self:SetText('Расширения .jpg и .png! За нецензуру бан.\nФормат ссылки: http://yourdomain.com/image.png.')
        self:SetFont('ui.24')
        self:SetTextColor(ui.col.Close)
        self:SizeToContents()
        self:SetPos((p:GetWide() - self:GetWide()) / 2, 32)
    end, fr)

    set = ui.Create('DButton', function(self, p)
        self:SetText('Изменить')
        self:SetPos(5, 90)
        self:SetSize(p:GetWide() / 2 - 7.5, 25)

        function self:DoClick()
            p:Close()
            RunConsoleCommand('setimage', text:GetValue())
        end
    end, fr)
end)
--PATH addons/truefishing/lua/entities/fish_bait/cl_init.lua:
include('shared.lua')
	
ENT.RenderGroup = RENDERGROUP_OPAQUE


function ENT:Draw()
	self:DrawModel()
end

--PATH addons/bricks_gangs/lua/entities/gangs_npc/cl_init.lua:
include('shared.lua')

surface.CreateFont('npc3d2dfont', {font = 'Montserrat Semibold', size = 55, weight = 500, extended = true})

function ENT:Draw()
	local pos = self:GetPos();
	local ang = self:GetAngles();
	self:DrawModel()
	if (LocalPlayer():GetPos():Distance(self:GetPos()) < 300 or LocalPlayer():GetEyeTrace().Entity == self) then
		cam.Start3D2D(pos + ang:Up() * 1 + ang:Right() * 0, Angle(1, LocalPlayer():EyeAngles().y - 90, 90), 0.1)
			draw.SimpleText( "Кланы", 'npc3d2dfont', -15, -800, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
		cam.End3D2D()
	end
end
--PATH addons/_gmbheist/lua/entities/gmb_robber/shared.lua:
ENT.Base = 'base_ai'
ENT.Type = 'ai'
ENT.PrintName = 'Сдавать бабосы'
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.Category = 'GambitHeist'

--PATH addons/111mod/lua/entities/health_station/cl_init.lua:
include("shared.lua")

function ENT:Draw()
	if(EyePos():Distance(self.Entity:GetPos())<2000)then self:DrawModel()end	
	local Pos = self:GetPos()
	local Ang = self:GetAngles()

	local owner = self:Getowning_ent()
	owner = (IsValid(owner) and owner:Nick()) or DarkRP.getPhrase("unknown")

	surface.SetFont("HUDNumber5")
	local text = "Жизни"
	local capacity = "Заряд: "..self:GetNW2Int("Health_amount")
	local TextWidth = surface.GetTextSize(text)
	local CapacityWidth = surface.GetTextSize(capacity)

	Ang:RotateAroundAxis(Ang:Up(), 90)
	local TextAng = Ang

	if LocalPlayer():GetPos():Distance(self:GetPos()) < 200 then
		cam.Start3D2D(Pos+Ang:Up()*8, Ang, 0.1)
			draw.RoundedBox( 0, -TextWidth*0.5 -4, -60, TextWidth + 7, 30, Color(0,0,0,150) )
			draw.SimpleText( text, "HUDNumber5", -TextWidth*0.5, -60, Color(255,255,255,255), 0, 0, 1, Color(0,0,0) )
			
			draw.RoundedBox( 0, -CapacityWidth*0.5 -4, -25, CapacityWidth + 7, 30, Color(0,0,0,150) )
			draw.SimpleText( capacity, "HUDNumber5", -CapacityWidth*0.5, -25, Color(255,255,255,255), 0, 0, 1, Color(0,0,0) )
		cam.End3D2D()
	end
end

--PATH addons/foodmode/lua/entities/hfm_stove/shared.lua:
ENT.Base = "base_anim"
ENT.Type = "anim"

if SERVER then
	util.AddNetworkString( "HFM_StoveMenu_S2C" )
	util.AddNetworkString( "HFM_DoCook_C2S" )
	util.AddNetworkString( "HFM_GetFood_C2S" )
	
	function ENT:OpenMenu(ply)
		local Data2Send = {}
		Data2Send.Ent = self
		
		local PotData = {}
		for k = 1, 6 do
			if self.Pots[k] then
				PotData[k] = {}
				local SP = self.Pots[k]
				local ITB = HFMGetTable(SP.luaname)
				PotData[k].LuaName = SP.luaname
				PotData[k].TimeSpent = CurTime() - SP.CreatedTime
				PotData[k].TimeRequired = ITB.CookingTime
			end
		end
		
		Data2Send.Pots = PotData
		net.Start( "HFM_StoveMenu_S2C" )
			net.WriteTable(Data2Send)
		net.Send(ply)
	end
	
	net.Receive( "HFM_DoCook_C2S", function( len,ply )
		local TB = net.ReadTable()
		local luaname = TB.luaname
		local stove = TB.stove
		local slot = TB.slot
		local FTB = HFMGetTable(luaname)
			
		if !ply:CanCookFood(luaname) then return end
		
		for k,v in pairs(FTB.Ingredients or {}) do
			ply:RemoveJraka(k,v)
		end
	
		if stove and stove:IsValid() and stove:GetClass() == "hfm_stove" then
			stove:DoCook(luaname,slot,ply)
		end
	end)
	
net.Receive( "HFM_GetFood_C2S", function( len,ply )
        local TB = net.ReadTable()
        local act = net.ReadBool()
        local Ent = TB.Ent
        local Slot = TB.Slot
        
        if Ent and Ent:IsValid() and Ent:GetClass() == "hfm_stove" and Ent:GetPos():Distance(ply:GetPos()) < 150 then
            local PD = Ent.Pots[Slot]
            if !PD then return end
            local luaname = PD.luaname
            local ITB = HFMGetTable(luaname)
            local DeltaTime = CurTime() - PD.CreatedTime
            if DeltaTime >= ITB.CookingTime then
                if PD:GetDTBool(0) then
                    PD:Remove()
                    Ent.Pots[Slot] = nil
                    Ent:OpenMenu(ply)
                    DarkRP.notify(ply, 1, 5, "Ууупс. Ваша еда сгорела.")
                    return
                end
                
                PD:Remove()
                Ent.Pots[Slot] = nil
                Ent:OpenMenu(ply)
                if !act then
                    ply:AddJraka(luaname, 1)
                else
                    if luaname == 'pizza' then
                        BPSetTask( 'Pizza', ply, 29 )
                    end
                    if luaname == 'hotdog' then
                        BPSetTask( 'Sosiska', ply, 36 )
                    end
                    ply:GetCookedItem(luaname,1)
                end
            end
        end
        
    end)
	
else
	net.Receive( "HFM_StoveMenu_S2C", function( len,ply )
		local TB = net.ReadTable()
		HFMOpenStoveMenu(TB)
	end)
	function HFMDoCook(luaname,slot,stove)
		local TB2Send = {}
		TB2Send.luaname = luaname
		TB2Send.stove = stove
		TB2Send.slot = slot
		net.Start( "HFM_DoCook_C2S" )
			net.WriteTable(TB2Send)
		net.SendToServer()
	end
	function HFMGetItem(Ent,Slot,act)
		net.Start( "HFM_GetFood_C2S" )
			net.WriteTable({Ent=Ent,Slot=Slot})
			net.WriteBool(act)
		net.SendToServer()
	end
end

HFMPotPositions = {}
HFMPotPositions[1] = Vector(-7,	-16,	55)
HFMPotPositions[2] = Vector(-7,	-3,		55)
HFMPotPositions[3] = Vector(-7,	10,		55)
HFMPotPositions[4] = Vector(6.5,	-16,	55)
HFMPotPositions[5] = Vector(6.5,	-3,		55)
HFMPotPositions[6] = Vector(6.5,	10,		55)
--PATH addons/itemstore_new/lua/entities/itemstore_box.lua:
ENT.Type = "anim"

ENT.PrintName = "Small Box"
ENT.Category = "ItemStore"

ENT.Spawnable = true
ENT.AdminOnly = true

function ENT:SetupDataTables()
	self:NetworkVar( "Entity", 0, "owning_ent" ) -- i feel really stupid.
end

if SERVER then
	AddCSLuaFile()

	ENT.Model = "models/props/cs_office/Cardboard_box02.mdl"

	ENT.ContainerWidth = 4
	ENT.ContainerHeight = 3
	ENT.ContainerPages = 1

	function ENT:Initialize()
		self:SetModel( self.Model )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )

		self:GetPhysicsObject():Wake()

		self.Container = itemstore.Container( self.ContainerWidth, self.ContainerHeight, self.ContainerPages )
		self.Container:SetOwner( self )

		if self.Items then
			for _, item in ipairs( self.Items ) do
				self.Container:AddItem( item:Copy() )
			end
		end

		local function callback( con, pl )
			if not IsValid( pl ) then return end
			
			if pl:GetPos():Distance( self:GetPos() ) < 250 then
				return true
			end

			return false
		end

		self.Container:AddCallback( "read", callback )
		self.Container:AddCallback( "write", callback )

		self:SetHealth( itemstore.config.BoxHealth )
	end

	function ENT:SpawnFunction( pl, trace, class )
		local ent = ents.Create( class )
		ent:SetPos( trace.HitPos + trace.HitNormal * 16 )
		ent:Spawn()

		return ent
	end

	function ENT:Use( pl )
		self.Container:Sync()
		pl:OpenContainer( self.Container:GetID(), "Box" )
	end

	function ENT:Break()
		local effect = EffectData()
		effect:SetOrigin( self:GetPos() )
		util.Effect( "Explosion", effect, true, true )

		for _, item in pairs( self.Container.Items ) do
			item:CreateEntity( self:GetPos() )
		end

		self:Remove()
	end

	function ENT:OnTakeDamage( dmg )
		if not itemstore.config.BoxBreakable then return end

		self:SetHealth( self:Health() - dmg:GetDamage() )

		if self:Health() <= 0 then
			self:Break()
		end
	end

	function ENT:OnRemove()
		self.Container:Remove()
	end
end

--PATH addons/itemstore_new/lua/entities/itemstore_deathloot.lua:
ENT.Type = "anim"
ENT.Base = "itemstore_box"

ENT.PrintName = "Death Loot"
ENT.Category = "ItemStore"

ENT.Spawnable = false
ENT.AdminOnly = false

if SERVER then
	AddCSLuaFile()

	ENT.Model = "models/props_junk/garbage_bag001a.mdl"

	ENT.ContainerWidth = 5
	ENT.ContainerHeight = 5
	ENT.ContainerPages = 2

	ENT.Timeout = 0

	function ENT:Think()
		if self.Timeout < CurTime() then self:Remove() end
	end
end

--PATH addons/itemstore_new/lua/entities/itemstore_shop.lua:
-----------------------------------------------------
AddCSLuaFile()
ENT.Type = "anim"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT
ENT.PrintName = "Ларек"
ENT.Category = "Other"
ENT.Spawnable = true
ENT.AdminOnly = false
ENT.IsShop = true

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
end

if SERVER then
    function ENT:SpawnFunction(pl, trace, class)
        local ent = ents.Create(class)
        ent:SetPos(trace.HitPos + trace.HitNormal * 16)
        ent:Setowning_ent(pl)
        ent:Spawn()

        return ent
    end

    function ENT:Initialize()
        if IsValid(self:Getowning_ent()) then
            self:CPPISetOwner(self:Getowning_ent())
        end

        self:SetModel("models/props_c17/display_cooler01a.mdl")
        self:PhysicsInit(SOLID_VPHYSICS)
        self:SetMoveType(MOVETYPE_VPHYSICS)
        self:SetSolid(SOLID_VPHYSICS)
        self:SetUseType(SIMPLE_USE)
        self:SetCollisionGroup(COLLISION_GROUP_WORLD)
        self:GetPhysicsObject():Wake()
        self.Container = itemstore.Container(unpack(itemstore.config.ShopSize))
        self.Container:AddCallback("read", function(con, pl) return pl:GetPos():Distance(self:GetPos()) < 250 end)

        self.Container:AddCallback("write", function(to_con, pl, action, from_con, from_slot, from_item, to_slot, to_item)
            if self:Getowning_ent() ~= pl then return false end

            if action == "move" and from_item then
                net.Start("ItemStorePriceShopItem")
                net.WriteEntity(self)
                net.WriteUInt(to_slot, 16)
                net.Send(pl)
            end

            return true
        end)
    end

    function ENT:Use(pl)
        self.Container:Sync(pl)

        if self:Getowning_ent() == pl then
            pl:OpenContainer(self.Container:GetID(), "Ларек")
            pl.lavka = self.Container:GetID()
        else
            net.Start("ItemStoreOpenShop")
            net.WriteEntity(self)
            net.WriteUInt(self.Container:GetID(), 32)
            net.Send(pl)
        end
    end

    function ENT:PriceItem(pl, slot, price)
        if pl ~= self:Getowning_ent() then return end
        local item = self.Container:GetItem(slot)
        if not IsValid(item) then return end
        item:SetData("ShopPrice", price)
    end

    function ENT:OnRemove()
        self.Container:Remove()
    end
else
    function ENT:Draw()
        self:DrawModel()
        if self:GetPos():Distance(LocalPlayer():GetPos()) > 270 then return end
        if not self:IsValid() or not self:Getowning_ent():IsValid() then return end
        local pos = self:GetPos()
        local ang = self:GetAngles()
        local eblan = (math.sin(CurTime()) + 1) / 2
        local color_white = Color(255, 255, 255)
        local color_black = Color(0, 0, 0)
        ang:RotateAroundAxis(ang:Forward(), 90)
        ang:RotateAroundAxis(ang:Right(), -180)
        cam.Start3D2D(pos + ang:Right() * -65 + ang:Up() * -10, ang, 0.05)

        if self:Getowning_ent():HasGambitPlus() then
            draw.SimpleTextOutlined('Торговая лавка', '3d2d', 0, -15, Color(eblan * 255, 0, 255 - (eblan * 255)), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color(0, 0, 0))
            draw.SimpleTextOutlined(self:Getowning_ent():Nick() or "Неизвестно", '3d2d', 0, 90, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color(0, 0, 0))
        else
            draw.SimpleTextOutlined('Торговая лавка', '3d2d', 0, -15, Color(255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color(0, 0, 0))
            draw.SimpleTextOutlined(self:Getowning_ent():Nick() or "Неизвестно", '3d2d', 0, 90, Color(255, 0, 0), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP, 1, Color(0, 0, 0))
        end

        cam.End3D2D()
    end
end
--PATH addons/111mod/lua/entities/npc_travel.lua:
ENT.Base = 'base_ai'
ENT.Type = 'ai'
ENT.PrintName = 'Travel NPC'
ENT.Author = 'MrPupir'
ENT.Contact = ''
ENT.Category = 'Other'
ENT.Spawnable = true
ENT.AdminSpawnable = true

if SERVER then
    AddCSLuaFile()

    function ENT:Initialize()
        self:SetModel("models/Humans/Group02/male_06.mdl")
        self:SetHullType(HULL_HUMAN)
        self:SetHullSizeNormal()
        self:SetNPCState(NPC_STATE_SCRIPT)
        self:SetSolid(SOLID_BBOX)
        self:SetUseType(SIMPLE_USE)
        self:SetBloodColor(BLOOD_COLOR_RED)
        self:CapabilitiesAdd(bit.bor(CAP_ANIMATEDFACE, CAP_TURN_HEAD))
    end

    util.AddNetworkString'GambitRP.Travel'

    function ENT:AcceptInput(name, ply, caller)
        if not ply:IsValid() or not ply:IsPlayer() then return end
        net.Start('GambitRP.Travel')
        net.Send(ply)
    end
elseif CLIENT then
    surface.CreateFont('neffpidr', {
        size = 64,
        weight = 350,
        antialias = true,
        extended = true,
        font = "Roboto"
    })

    local color_white = Color(255,255,255)
    local color_black = Color(0,0,0)
    local complex_off = Vector(0, 0, 9)
    local ang = Angle(0, 90, 90)

    local cam_End3D2D, cam_Start3D2D, LocalPlayer, CurTime, draw_SimpleTextOutlined, math_sin = cam.End3D2D, cam.Start3D2D, LocalPlayer, CurTime, draw.SimpleTextOutlined, math.sin

    function ENT:Draw()
        self:DrawModel()
        local bone = self:LookupBone('ValveBiped.Bip01_Head1')
        pos = self:GetBonePosition(bone) + complex_off
        ang.y = (LocalPlayer():EyeAngles().y - 90)
        local x = math_sin(CurTime() * math.pi) * 30

        if (LocalPlayer():GetPos():Distance(self:GetPos()) < 200 or LocalPlayer():GetEyeTrace().Entity == self) then
            cam_Start3D2D(pos, ang, 0.03)
            draw_SimpleTextOutlined('Таксист Алишер', '3d2d', 0, 0, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM, 1, color_black)
            cam_End3D2D()
        end
    end

    net.Receive('GambitRP.Travel', function(len)
        local GambitIPs = {"212.22.93.215:27015", "212.22.93.171:27015"}

        local GambitNames = {
            ["212.22.93.215:27015"] = "★ GambitRP - #1",
            ["212.22.93.171:27015"] = "★ GambitRP - #2"
        }

        local fr = ui.Create("ui_frame", function(self)
            self:SetTitle("Таксист Алишер")
            self:SetSize(300, 30 + (#GambitIPs - 1) * 60)
            self:Center()
            self:MakePopup()
        end)

        local lbl = ui.Create("DLabel", function(self)
            self:SetText("Выберите куда хотите отправиться: ")
            self:SetSize(300, 20)
            self:SetPos(10, 35)
            self:SetFont("ui.20")
        end, fr)

        if GambitNames[game.GetIPAddress()] then
            table.RemoveByValue(GambitIPs, game.GetIPAddress())
        end

        for k, v in pairs(GambitIPs) do
            ui.Create("DButton", function(self)
                self:SetText(GambitNames[v])
                self:SetSize(300, 30)
                self:SetPos(0, 30 + 30 * k)

                self.DoClick = function(self)
                    LocalPlayer():ConCommand([[connect ]] .. v)
                end
            end, fr)
        end
    end)
end
--PATH addons/truefishing/lua/entities/rod_fish/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
end

--PATH gamemodes/darkrp/entities/entities/spawned_ammo/shared.lua:
ENT.Type = "anim"
ENT.Base = "spawned_weapon"
ENT.PrintName = "Spawned Ammo"
ENT.Author = "FPtje"
ENT.Spawnable = false
ENT.IsSpawnedAmmo = true

function ENT:SetupDataTables()
    self.BaseClass.SetupDataTables(self)
    self:NetworkVar("Entity", 0, "owning_ent")
end

--PATH gamemodes/darkrp/entities/entities/spawned_shipment/cl_init.lua:
include("shared.lua")

local matBallGlow = Material("models/props_combine/tpballglow")
function ENT:Draw()
    self.height = self.height or 0
    self.colr = self.colr or 1
    self.colg = self.colg or 0
    self.StartTime = self.StartTime or CurTime()

    if GAMEMODE.Config.shipmentspawntime > 0 and self.height < self:OBBMaxs().z then
        self:drawSpawning()
    else
        self:DrawModel()
    end

    self:drawFloatingGun()
    self:drawInfo()
end

net.Receive("DarkRP_shipmentSpawn", function()
    local ent = net.ReadEntity()
    if not IsValid(ent) or not ent.IsSpawnedShipment then return end

    ent.height = 0
    ent.StartTime = CurTime()
end)

function ENT:drawSpawning()
    render.MaterialOverride(matBallGlow)

    render.SetColorModulation(self.colr, self.colg, 0)

    self:DrawModel()

    render.MaterialOverride()
    self.colr = 1 - ((CurTime() - self.StartTime) / GAMEMODE.Config.shipmentspawntime)
    self.colg = (CurTime() - self.StartTime) / GAMEMODE.Config.shipmentspawntime

    render.SetColorModulation(1, 1, 1)

    render.MaterialOverride()

    local normal = - self:GetAngles():Up()
    local pos = self:LocalToWorld(Vector(0, 0, self:OBBMins().z + self.height))
    local distance = normal:Dot(pos)
    self.height = self:OBBMaxs().z * ((CurTime() - self.StartTime) / GAMEMODE.Config.shipmentspawntime)
    render.EnableClipping(true)
    render.PushCustomClipPlane(normal, distance)

    self:DrawModel()

    render.PopCustomClipPlane()
end

function ENT:drawFloatingGun()
    local contents = CustomShipments[self:Getcontents() or ""]
    if not contents or not IsValid(self:GetgunModel()) then return end
    self:GetgunModel():SetNoDraw(true)

    local pos = self:GetPos()
    local ang = self:GetAngles()

    -- Position the gun
    local gunPos = self:GetAngles():Up() * 40 + ang:Up() * (math.sin(CurTime() * 3) * 8)
    self:GetgunModel():SetPos(pos + gunPos)


    -- Make it dance
    ang:RotateAroundAxis(ang:Up(), (CurTime() * 180) % 360)
    self:GetgunModel():SetAngles(ang)

    -- Draw the model
    if self:Getgunspawn() < CurTime() - 2 then
        self:GetgunModel():DrawModel()
        return
    elseif self:Getgunspawn() < CurTime() then -- Not when a gun just spawned
        return
    end

    -- Draw the spawning effect
    local delta = self:Getgunspawn() - CurTime()
    local min, max = self:GetgunModel():OBBMins(), self:GetgunModel():OBBMaxs()
    min, max = self:GetgunModel():LocalToWorld(min), self:GetgunModel():LocalToWorld(max)

    -- Draw the ghosted weapon
    render.MaterialOverride(matBallGlow)
    render.SetColorModulation(1 - delta, delta, 0) -- From red to green
    self:GetgunModel():DrawModel()
    render.MaterialOverride()
    render.SetColorModulation(1, 1, 1)

    -- Draw the cut-off weapon
    render.EnableClipping(true)
    -- The clipping plane only draws objects that face the plane
    local normal = -self:GetgunModel():GetAngles():Forward()
    local cutPosition = LerpVector(delta, max, min) -- Where it cuts
    local cutDistance = normal:Dot(cutPosition) -- Project the vector onto the normal to get the shortest distance between the plane and origin

    -- Activate the plane
    render.PushCustomClipPlane(normal, cutDistance);
    -- Draw the partial model
    self:GetgunModel():DrawModel()
    -- Remove the plane
    render.PopCustomClipPlane()

    render.EnableClipping(false)
end

function ENT:drawInfo()
    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    local content = self:Getcontents() or ""
    local contents = CustomShipments[content]
    if not contents then return end
    contents = contents.name

    surface.SetFont("HUDNumber5")
    local text = DarkRP.getPhrase("contents")
    local TextWidth = surface.GetTextSize(text)
    local TextWidth2 = surface.GetTextSize(contents)

    cam.Start3D2D(Pos + Ang:Up() * 25, Ang, 0.2)
        draw.WordBox(2, -TextWidth * 0.5 + 5, -30, text, "HUDNumber5", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
        draw.WordBox(2, -TextWidth2 * 0.5 + 5, 18, contents, "HUDNumber5", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
    cam.End3D2D()

    Ang:RotateAroundAxis(Ang:Forward(), 90)

    text = DarkRP.getPhrase("amount")
    TextWidth = surface.GetTextSize(text)
    TextWidth2 = surface.GetTextSize(self:Getcount())

    cam.Start3D2D(Pos + Ang:Up() * 17, Ang, 0.14)
        draw.WordBox(2, -TextWidth * 0.5 + 5, -150, text, "HUDNumber5", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
        draw.WordBox(2, -TextWidth2 * 0.5 + 0, -102, self:Getcount(), "HUDNumber5", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
    cam.End3D2D()
end

--[[---------------------------------------------------------------------------
Create a shipment from a spawned_weapon
---------------------------------------------------------------------------]]
properties.Add("splitShipment",
{
    MenuLabel   =   DarkRP.getPhrase("splitshipment"),
    Order       =   2003,
    MenuIcon    =   "icon16/arrow_divide.png",

    Filter      =   function(self, ent, ply)
                        if not IsValid(ent) then return false end
                        return ent.IsSpawnedShipment
                    end,

    Action      =   function(self, ent)
                        if not IsValid(ent) then return end
                        RunConsoleCommand("darkrp", "splitshipment", ent:EntIndex())
                    end
})

--PATH gamemodes/darkrp/entities/entities/spawned_weapon/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_gmodentity"
ENT.PrintName = "Spawned Weapon"
ENT.Author = "Rickster"
ENT.Spawnable = false
ENT.IsSpawnedWeapon = true

function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "amount")
    self:NetworkVar("String", 0, "WeaponClass")
    self:NetworkVar("Entity", 0, "owning_ent")
end

--PATH addons/vcmod_main_autoupdate/lua/entities/vc_spikestrip_pointyend_extended/shared.lua:
// Copyright © 2020 VCMod (freemmaann). All Rights Reserved. if you have any complaints or ideas contact me: steam - steamcommunity.com/id/freemmaann/ or email - freemmaann@gmail.com.
ENT.Base 		= "base_anim"
ENT.Type 		= "anim"
ENT.PrintName	= "Spike strip pointy end, extended"
ENT.Author		= "freemmaann"
ENT.Category	= "VCMod"

ENT.Spawnable = false
ENT.AdminSpawnable = false
--PATH addons/zeros_methlab2/lua/entities/zmlab2_item_aluminium/cl_init.lua:
include("shared.lua")

function ENT:Initialize()

end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:Draw()
	self:DrawModel()
end

--PATH addons/zeros_methlab2/lua/entities/zmlab2_item_aluminium/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_aluminium.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = false
ENT.AdminSpawnable = false
ENT.PrintName = "Aluminum"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE


function ENT:CanProperty(ply)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanDrive(ply)
    return zmlab2.Player.IsAdmin(ply)
end

--PATH addons/zeros_methlab2/lua/entities/zmlab2_table/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_table.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Table"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE

function ENT:SetupDataTables()
    self:NetworkVar("Int", 1, "ProcessState")
    self:NetworkVar("Entity", 1, "Crate")
    self:NetworkVar("Entity", 2, "Tray")
    self:NetworkVar("Bool", 1, "IsAutobreaking")

    if (SERVER) then
        self:SetIsAutobreaking(false)
        self:SetProcessState(0)
        self:SetCrate(NULL)
        self:SetTray(NULL)
    end
end

function ENT:OnDrop_Crate(ply)
    local trace = ply:GetEyeTrace()
    local lp = self:WorldToLocal(trace.HitPos)
    if lp.x > 5 and lp.x < 19 and lp.y < 13 and lp.y > 6 and lp.z > 35 and lp.z < 38 then
        return true
    else
        return false
    end
end

function ENT:OnDrop_Tray(ply)
    local trace = ply:GetEyeTrace()
    local lp = self:WorldToLocal(trace.HitPos)
    if lp.x > -19 and lp.x < -6 and lp.y < 13 and lp.y > 6 and lp.z > 35 and lp.z < 38 then
        return true
    else
        return false
    end
end

function ENT:CanProperty(ply)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanDrive(ply)
    return zmlab2.Player.IsAdmin(ply)
end

--PATH addons/zeros_methlab2/lua/entities/zmlab2_tent/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.Model = "models/zerochain/props_methlab/zmlab2_tentkit.mdl"
ENT.AutomaticFrameAdvance = true
ENT.Spawnable = true
ENT.AdminSpawnable = false
ENT.PrintName = "Tent"
ENT.Category = "Zeros Methlab 2"
ENT.RenderGroup = RENDERGROUP_OPAQUE

function ENT:SetupDataTables()

    self:NetworkVar("Int", 1, "BuildState")
    self:NetworkVar("Int", 2, "BuildCompletion")

    self:NetworkVar("Int", 3, "TentID")

    self:NetworkVar("Int", 4, "ColorID")

    self:NetworkVar("Bool", 1, "IsPublic")

    self:NetworkVar("Int", 5, "LastExtinguish")


    if (SERVER) then
        self:SetTentID(-1)
        self:SetColorID(1)

        // Unfolded
        self:SetBuildState(-1)
        self:SetBuildCompletion(-1)

        self:SetIsPublic(false)

        self:SetLastExtinguish(0)
    end
end

function ENT:OnControllPanel(ply)
    if self:GetAttachment(1) == nil then return false end
    local trace = ply:GetEyeTrace()

    if trace.HitPos:Distance(self:GetAttachment(1).Pos) < 5 then
        return true
    else
        return false
    end
end

function ENT:OnLightButton(ply)
    if self:GetAttachment(1) == nil then return false end
    local attach = self:GetAttachment(1)
    local trace = ply:GetEyeTrace()
    if zmlab2.util.InDistance(attach.Pos - attach.Ang:Forward() * 5, trace.HitPos, 2) then
        return true
    else
        return false
    end
end

function ENT:OnExtinquisher(ply)
    if self:GetAttachment(1) == nil then return false end
    local attach = self:GetAttachment(1)
    local trace = ply:GetEyeTrace()
    if zmlab2.util.InDistance(attach.Pos, trace.HitPos, 2) then
        return true
    else
        return false
    end
end

function ENT:OnFoldButton(ply)
    if self:GetAttachment(1) == nil then return false end
    local attach = self:GetAttachment(1)
    local trace = ply:GetEyeTrace()

    //debugoverlay.Sphere(attach.Pos - attach.Ang:Forward() * 5,2,0.1,Color( 255, 255, 255 ),true)

    if zmlab2.util.InDistance(attach.Pos + attach.Ang:Forward() * 5, trace.HitPos, 2) then
        return true
    else
        return false
    end
end

function ENT:CanProperty(ply)
    return zmlab2.Player.IsAdmin(ply)
end

function ENT:CanTool(ply, tab, str)
    return str == "colour" or zmlab2.Player.IsAdmin(ply)
end

function ENT:CanDrive(ply)
    return zmlab2.Player.IsAdmin(ply)
end

--PATH addons/zeros_weedfarm/lua/entities/zwf_autopacker/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	zwf.f.EntList_Add(self)
end

function ENT:Draw()
	self:DrawModel()
end

--PATH addons/zeros_weedfarm/lua/entities/zwf_buyer_npc/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	zwf.f.EntList_Add(self)

	self.HasEffect = false
end

function ENT:Draw()
	self:DrawModel()

	if GetConVar("zwf_cl_vfx_drawui"):GetInt() == 1 and zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 500) then
		self:DrawInfo()
	end
end

function ENT:DrawInfo()
	local Pos = self:GetPos() + self:GetUp() * 80
	Pos = Pos + self:GetUp() * math.abs(math.sin(CurTime()) * 1)
	local Ang = Angle(0, LocalPlayer():EyeAngles().y - 90, 90)

	cam.Start3D2D(Pos, Ang, 0.1)


		if zwf.config.NPC.DynamicBuyRate == true and zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 200) then

			local profit = self:GetPrice() - 100

			if profit > 0 then
				profit = "+" .. profit
			else
				profit = profit
			end

			local sellInfo = zwf.language.NPC["profit"] .. ": " .. profit .. "%"

			local aSize = 23 * string.len(sellInfo)
			draw.RoundedBox(25, -aSize / 2, 25, aSize, 50, zwf.default_colors["black01"])
			draw.SimpleText(sellInfo, "zwf_npc_font02", 0, 40, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
		end

		draw.SimpleTextOutlined(zwf.language.NPC["title"], "zwf_npc_font01", 0, -35, zwf.default_colors["green01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 2, zwf.default_colors["black02"])
	cam.End3D2D()
end

function ENT:Think()
	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 500) then
		if self.HasEffect == false then
			zwf.f.ParticleEffectAttach("zwf_joint_fire", PATTACH_POINT_FOLLOW, self, 10)
			self.HasEffect = true
		end
	else
		if self.HasEffect == true then
			self.HasEffect = false
			self:StopParticles()
		end
	end
end

--PATH addons/zeros_weedfarm/lua/entities/zwf_lamp/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.LastPower = -1
	self.LastRunning = -1
	self.LastPowerLevel = -1
	self.Cached_Rope = false
	self.RopeRefresh = true

	self.Output = nil
	self.PowerSource = nil

	self.PixVis = util.GetPixelVisibleHandle()

	self.LampID = self:GetLampID()
	self.LampData =  zwf.config.Lamps[self.LampID ]

	self:DrawShadow(false)

	zwf.f.EntList_Add(self)
end

function ENT:PixVisLight()
	local LightPos = self:GetPos() - self:GetUp() * 2

	if self.LampID  == 1 then
		LightPos = self:GetPos() - self:GetUp() * 2
	else
		LightPos = self:GetPos() - self:GetUp() * 10
	end

	render.SetMaterial(zwf.default_materials["light_sprite"])

	local ViewNormal = LightPos - EyePos()
	ViewNormal:Normalize()

	local Visibile = util.PixelVisible(LightPos, 4, self.PixVis)
	if (not Visibile or Visibile < 0.1) then return end

	render.DrawSprite(LightPos, 256, 128, self.LampData.light_color)
end

function ENT:DynamicLight()
	local dlight01 = DynamicLight(self:EntIndex())

	if (dlight01) then
		dlight01.pos = self:GetPos() + self:GetUp() * -35
		dlight01.r = self.LampData.light_color.r
		dlight01.g = self.LampData.light_color.g
		dlight01.b = self.LampData.light_color.b
		dlight01.brightness = 0.5
		dlight01.Decay = 1000
		dlight01.Size = 1000
		dlight01.DieTime = CurTime() + 1
	end
end

function ENT:Draw()
	self:DrawModel()

	zwf.f.UpdateEntityVisuals(self)

	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 500) then

		if GetConVar("zwf_cl_vfx_drawui"):GetInt() == 1 then
			self:DrawUI()
		end

		if self.LastRunning == true and self.LastPower > 0 and GetConVar("zwf_cl_vfx_lightsprite"):GetInt() == 1 then
			self:PixVisLight()
		end
	end

	if GetConVar("zwf_cl_vfx_dynlight"):GetInt() == 1 and zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 1000) and self.LastRunning == true and self.LastPower > 0 then
		self:DynamicLight()
	end
end


function ENT:DrawUI()
	local Pos = self:GetPos() + self:GetRight() * -7 + self:GetUp() * 0.1 + self:GetForward() * 15

	local Ang02 = self:GetAngles()
	Ang02:RotateAroundAxis(self:GetRight(),-90)
	Ang02:RotateAroundAxis(self:GetUp(),90)
	Ang02:RotateAroundAxis(self:GetRight(),-90)


	local _power = self:GetPower()
	local _isrunning = self:GetIsRunning()
	cam.Start3D2D(Pos, Ang02, 0.1)

		//BG

		//Power Bar

		draw.RoundedBox(5, -215 , 30, 100, 20,  zwf.default_colors["gray01"])

		if _power > 0 then
			local newPowerLvl = (92 / zwf.config.Lamps[self:GetLampID()].Power_storage) * _power

			newPowerLvl = math.Clamp(newPowerLvl,0,92)

			if self.LastPowerLevel ~= newPowerLvl then
				if newPowerLvl > self.LastPowerLevel then
					self.LastPowerLevel = self.LastPowerLevel + 25 * FrameTime()
					self.LastPowerLevel = math.Clamp(self.LastPowerLevel, 0, newPowerLvl)
				else
					self.LastPowerLevel = self.LastPowerLevel - 25 * FrameTime()
					self.LastPowerLevel = math.Clamp(self.LastPowerLevel, newPowerLvl, 380)
				end
			end

			draw.RoundedBox(5, -211 , 32, self.LastPowerLevel, 16, zwf.default_colors["power"])
		end

		draw.SimpleText( _power,"zwf_lamp01_font01", -165, 41, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)


		if self:EnableButton(LocalPlayer()) then
			if _isrunning then
				draw.RoundedBox(5, -190, -25, 50, 50, zwf.default_colors["green02"])
			else
				draw.RoundedBox(5, -190, -25, 50, 50, zwf.default_colors["red01"])
			end
		else
			if _isrunning then
				draw.RoundedBox(5, -190, -25, 50, 50, zwf.default_colors["green03"])
			else
				draw.RoundedBox(5, -190, -25, 50, 50, zwf.default_colors["red02"])
			end
		end


		surface.SetDrawColor(zwf.default_colors["white01"])
		surface.SetMaterial(zwf.default_materials["switch"])
		surface.DrawTexturedRect(-185, -20, 40, 40)
		draw.NoTexture()
	cam.End3D2D()
end


function ENT:Lamp_Running_VFX()
	if self.LastRunning and self.LastPower > 0 then

		if self.SoundObj == nil then
			if self.LampID == 1 then
				self.SoundObj = CreateSound(self, "zwf_lamp_sodium_loop")
			elseif self.LampID == 2 then
				self.SoundObj = CreateSound(self, "zwf_lamp_led_loop")
			end
		end

		if self.SoundObj:IsPlaying() == false then

			if self.LampID == 1 then
				zwf.f.EmitSoundENT("zwf_lamp_sodium_start", self)
			end

			self.SoundObj:Play()
			self.SoundObj:ChangeVolume(0, 0)
			self.SoundObj:ChangeVolume(zwf_SoundVolume, 1)
		end
	else

		if self.SoundObj and self.SoundObj:IsPlaying() == true then

			if self.LampID == 1 then
				zwf.f.EmitSoundENT("zwf_lamp_sodium_stop", self)
			end

			self.SoundObj:ChangeVolume(0, 1)
			self.SoundObj:Stop()
		end
	end
end

function ENT:OnVolumeChange()
	if self.SoundObj and self.SoundObj:IsPlaying() == true then
		self.SoundObj:ChangeVolume(zwf_SoundVolume, 0)
	end
end

function ENT:Think()
	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 1000) then

		local _energy = self:GetPower()
		local _isrunning = self:GetIsRunning()


		if self.ClientProps == nil then
			self.ClientProps = {}
		end

		if GetConVar("zwf_cl_vfx_lightcone"):GetInt() == 1 then

			if not IsValid(self.ClientProps["LightVolume"]) then
				self:SpawnClientModel_LightVolume()
			else
				if self.LastPower > 0 and self.LastRunning then
					if self.ClientProps["LightVolume"]:GetNoDraw() == true then
						self.ClientProps["LightVolume"]:SetPos(self:GetPos())
						self.ClientProps["LightVolume"]:SetNoDraw(false)
						self.ClientProps["LightVolume"]:SetColor(self.LampData.light_color)
					end
				else
					if self.ClientProps["LightVolume"]:GetNoDraw() == false then
						self.ClientProps["LightVolume"]:SetNoDraw(true)
					end
				end
			end
		else
			if IsValid(self.ClientProps["LightVolume"]) then
				self.ClientProps["LightVolume"]:Remove()
			end
		end

		if self.LastPower ~= _energy or self.LastRunning  ~= _isrunning then


			if self.LastRunning  ~= _isrunning then
				if self.LastRunning then
					zwf.f.EmitSoundENT("zwf_button_off", self)
				else
					zwf.f.EmitSoundENT("zwf_button_on", self)
				end
			end

			self.LastRunning = _isrunning

			self.LastPower = _energy


			if self.LastPower > 0 and self.LastRunning then
				self:SetSkin(1)
			else
				self:SetSkin(0)
			end
		end

		local _PowerSource = self:GetPowerSource()
		if self.PowerSource ~= _PowerSource then
			self.PowerSource = _PowerSource

			if IsValid(self.PowerSource) then
				self:SetBodygroup(0,1)
			else
				self:SetBodygroup(0,0)
			end
		end


		local _Output = self:GetOutput()
		if self.Output ~= _Output then
			self.Output = _Output

			if IsValid(self.Output) then
				self:SetBodygroup(1,1)
			else
				self:SetBodygroup(1,0)
			end
		end


		self:Lamp_Running_VFX()
	else
		self:RemoveClientModels()
		self.LastPower = -1
		self.PowerSource = nil
		self.Output = nil
		self.LastRunning = false
	end
	self:SetNextClientThink(CurTime())
	return true
end

function ENT:SpawnClientModel_LightVolume()

	local ent = ents.CreateClientProp("models/zerochain/props_weedfarm/zwf_light_volume.mdl")
	ent:SetPos(self:GetPos())
	ent:SetAngles(self:GetAngles())
	ent:Spawn()
	ent:Activate()
	ent:SetParent(self)
	ent:SetNoDraw(true)
	ent:SetRenderMode(RENDERMODE_TRANSALPHA)
	self.ClientProps["LightVolume"] = ent
end

function ENT:RemoveClientModels()
	if (self.ClientProps and table.Count(self.ClientProps) > 0) then
		for k, v in pairs(self.ClientProps) do
			if IsValid(v) then
				v:Remove()
			end
		end
	end

	self.ClientProps = {}
end

function ENT:OnRemove()
	self:RemoveClientModels()

	if self.SoundObj and self.SoundObj:IsPlaying() == true then
		self.SoundObj:ChangeVolume(0, 1)
		self.SoundObj:Stop()
	end
end

function ENT:UpdateVisuals()
	if IsValid(self.PowerSource) then
		self:SetBodygroup(0,1)
	else
		self:SetBodygroup(0,0)
	end

	if IsValid(self.Output) then
		self:SetBodygroup(1,1)
	else
		self:SetBodygroup(1,0)
	end
end

--PATH addons/zeros_weedfarm/lua/entities/zwf_palette/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	zwf.f.EntList_Add(self)

	self.Count_Y = 0
	self.Count_X = 0
	self.Count_Z = 0

	self.LastBlockCount = -1
end

function ENT:Draw()
	self:DrawModel()

	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 600) then
		self:DrawInfo()
	end
end

function ENT:DrawTranslucent()
	self:Draw()
end

function ENT:DrawInfo()
	local Pos = self:GetPos() + Vector(0, 0, 60 + (1 * math.Clamp(self.LastBlockCount, 1, 10000)))
	local Ang = Angle(0, LocalPlayer():EyeAngles().y - 90, 90)

	if self.LastBlockCount > 0 then
		local money = math.Round(self:GetMoney())
		cam.Start3D2D(Pos, Ang, 0.1)
			draw.DrawText(zwf.config.Currency .. money, "zwf_palette_font02", 0, 5, zwf.default_colors["black02"], TEXT_ALIGN_CENTER)
			draw.DrawText(zwf.config.Currency .. money, "zwf_palette_font01", 0, 5, zwf.default_colors["green05"], TEXT_ALIGN_CENTER)
		cam.End3D2D()
	end
end


function ENT:BlockChangeUpdater()
	local blockCount = self:GetBlockCount()

	if self.LastBlockCount ~= blockCount then
		self.LastBlockCount = blockCount
		self:UpdateClientProps()
	end
end

function ENT:Think()

	--Here we create or remove the client models
	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 1000) then

		self:BlockChangeUpdater()
	else
		self:RemoveClientModels()
		self.ClientProps = {}

		self.LastBlockCount = -1
	end
end

function ENT:UpdateClientProps()
	self:RemoveClientModels()

	local weedblocks = {}

	for i = 1, self:GetWeedID01() do
		table.insert(weedblocks,1)
	end

	for i = 1, self:GetWeedID02() do
		table.insert(weedblocks,2)
	end

	for i = 1, self:GetWeedID03() do
		table.insert(weedblocks,3)
	end

	for i = 1, self:GetWeedID04() do
		table.insert(weedblocks,4)
	end

	for i = 1, self:GetWeedID05() do
		table.insert(weedblocks,5)
	end

	for i = 1, self:GetWeedID06() do
		table.insert(weedblocks,6)
	end

	for i = 1, self:GetWeedID07() do
		table.insert(weedblocks,7)
	end

	self.ClientProps = {}

	for i = 1, table.Count(weedblocks) do
		self:CreateClientBlock(i,weedblocks[i])
	end
end

function ENT:OnRemove()
	self:RemoveClientModels()
end

function ENT:CreateClientBlock(blockid,weedID)


	local pos = self:GetPos() - self:GetRight() * 25 - self:GetForward() * 33 + self:GetUp() * 9
	local ang = self:GetAngles()


	if self.Count_X >= 3 then
		self.Count_X = 1
		self.Count_Y = self.Count_Y + 1
	else
		self.Count_X = self.Count_X + 1
	end

	if self.Count_Y >= 3 then
		self.Count_Y = 0
		self.Count_Z = self.Count_Z + 1
	end

	pos = pos + self:GetForward() * 17 * self.Count_X
	pos = pos + self:GetRight() * 25 * self.Count_Y
	pos = pos + self:GetUp() * 10 * self.Count_Z


	local crate = ents.CreateClientProp("models/zerochain/props_weedfarm/zwf_weedblock.mdl")
	//crate:SetAngles(self:LocalToWorldAngles(blockPos[blockid].ang))
	//crate:SetPos(self:LocalToWorld(blockPos[blockid].pos))

	crate:SetAngles(ang)
	crate:SetPos(pos)


	crate:Spawn()
	crate:Activate()

	local skin = zwf.config.Plants[weedID].skin
	crate:SetSkin(skin)

	crate:SetParent(self)

	self.ClientProps["Block" .. blockid] = crate
end

function ENT:RemoveClientModels()

	self.Count_Y = 0
	self.Count_X = 0
	self.Count_Z = 0

	if (self.ClientProps and table.Count(self.ClientProps) > 0) then
		for k, v in pairs(self.ClientProps) do
			if IsValid(v) then
				v:Remove()
			end
		end
	end
end

--PATH addons/zeros_weedfarm/lua/entities/zwf_ventilator/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.LastPowerLevel = -1
	self.LastPower = -1
	self.IsRunning = false

	self.Cached_Rope = false
	self.RopeRefresh = true

	self.PowerSource = nil
	zwf.f.EntList_Add(self)

	self.HasAirEffect = false
end

function ENT:Draw()
	self:DrawModel()

	zwf.f.UpdateEntityVisuals(self)

	if GetConVar("zwf_cl_vfx_drawui"):GetInt() == 1 and zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 300) then
		self:DrawUI()
	end
end



function ENT:DrawUI()
	local Pos02 = self:GetPos() + self:GetRight() * 2.4 + self:GetUp() * 30

	local Ang02 = self:GetAngles()
	Ang02:RotateAroundAxis(self:GetRight(),90)
	Ang02:RotateAroundAxis(self:GetUp(),90)
	Ang02:RotateAroundAxis(self:GetRight(),90)


	local _power = self:GetPower()
	local _isrunning = self:GetIsRunning()
	cam.Start3D2D(Pos02, Ang02, 0.1)

		//Power Bar
		if _power > 0 then
			local newPowerLvl = (68 / zwf.config.Ventilator.Power_storage) * _power

			newPowerLvl = math.Clamp(newPowerLvl,0,68)

			if self.LastPowerLevel ~= newPowerLvl then
				if newPowerLvl > self.LastPowerLevel then
					self.LastPowerLevel = self.LastPowerLevel + 25 * FrameTime()
					self.LastPowerLevel = math.Clamp(self.LastPowerLevel, 0, newPowerLvl)
				else
					self.LastPowerLevel = self.LastPowerLevel - 25 * FrameTime()
					self.LastPowerLevel = math.Clamp(self.LastPowerLevel, newPowerLvl, 380)
				end
			end

			draw.RoundedBox(3, -8 , -18, 16, self.LastPowerLevel, zwf.default_colors["power"])
		end
	cam.End3D2D()


	local Pos01 = self:GetPos() + self:GetRight() * 2.4 + self:GetUp() * 30
	local Ang01 = self:GetAngles()
	Ang01:RotateAroundAxis(self:GetRight(),90)
	Ang01:RotateAroundAxis(self:GetUp(),90)
	Ang01:RotateAroundAxis(self:GetRight(),-90)


	cam.Start3D2D(Pos01, Ang01, 0.1)

		draw.SimpleText( _power,"zwf_ventilator_font01", 0, -15, zwf.default_colors["white01"], TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

		if self:EnableButton(LocalPlayer()) then
			if _isrunning then
				draw.RoundedBox(5, -10, -84, 20, 20, zwf.default_colors["green02"])
			else
				draw.RoundedBox(5, -10, -84, 20, 20, zwf.default_colors["red01"])
			end
		else
			if _isrunning then
				draw.RoundedBox(5, -10, -84, 20, 20, zwf.default_colors["green03"])
			else
				draw.RoundedBox(5, -10, -84, 20, 20, zwf.default_colors["red02"])
			end
		end

		surface.SetDrawColor(zwf.default_colors["white01"])
		surface.SetMaterial(zwf.default_materials["switch"])
		surface.DrawTexturedRect(-8, -82, 16, 16)
		draw.NoTexture()
	cam.End3D2D()
end

function ENT:OnVolumeChange()
	if self.SoundObj and self.SoundObj:IsPlaying() == true then
		self.SoundObj:ChangeVolume(zwf_SoundVolume, 0)
	end
end

function ENT:Think()
	if zwf.f.InDistance(LocalPlayer():GetPos(), self:GetPos(), 600) then
		local _isrunning = self:GetIsRunning()
		local _power = self:GetPower()

		if self.IsRunning ~= _isrunning or self.LastPower ~= _power then


			if self.IsRunning  ~= _isrunning then
				if self.IsRunning then
					zwf.f.EmitSoundENT("zwf_button_off", self)
				else
					zwf.f.EmitSoundENT("zwf_button_on", self)
				end
			end

			self.IsRunning = _isrunning
			self.LastPower = _power


			if self.IsRunning and self.LastPower > zwf.config.Ventilator.Power_usage then
				if self:GetSequenceName(self:GetSequence()) ~= "run" then
					zwf.f.ClientAnim(self,"run", 1)
				end
			else
				zwf.f.ClientAnim(self,"idle", 1)
			end
		end

		local _PowerSource = self:GetPowerSource()

		if self.PowerSource ~= _PowerSource then
			self.PowerSource = _PowerSource

			if IsValid(self.PowerSource) then
				self:SetBodygroup(0,1)
			else
				self:SetBodygroup(0,0)
			end
		end

		if self.IsRunning and self.LastPower > 0 then

			if GetConVar("zwf_cl_vfx_ventilatorffects"):GetInt() == 1 then
				if self.HasAirEffect == false then
					zwf.f.ParticleEffectAttach("zwf_airwave", PATTACH_POINT_FOLLOW, self, 1)
					self.HasAirEffect = true
				end
			else
				if self.HasAirEffect == true then
					self:StopParticlesNamed("zwf_airwave")
					self.HasAirEffect = false
				end
			end

			if self.SoundObj == nil then
				self.SoundObj = CreateSound(self, "zwf_ventilator_loop")
			end

			if self.SoundObj:IsPlaying() == false then
				self.SoundObj:Play()
				self.SoundObj:ChangeVolume(0, 0)
				self.SoundObj:ChangeVolume(zwf_SoundVolume, 0)
			end
		else

			if self.HasAirEffect == true then
				self:StopParticlesNamed("zwf_airwave")
				self.HasAirEffect = false
			end

			if self.SoundObj and self.SoundObj:IsPlaying() == true then
				self.SoundObj:ChangeVolume(0, 0)
				self.SoundObj:Stop()
			end
		end
	else

		if self.SoundObj and self.SoundObj:IsPlaying() == true then
			self.SoundObj:ChangeVolume(0, 0)
			self.SoundObj:Stop()
		end

		if self.HasAirEffect == true then
			self:StopParticlesNamed("zwf_airwave")
			self.HasAirEffect = false
		end

		self.PowerSource = nil
	end

	self:SetNextClientThink(CurTime())
	return true
end

function ENT:Remove()
	if self.SoundObj and self.SoundObj:IsPlaying() == true then
		self.SoundObj:ChangeVolume(0, 0)
		self.SoundObj:Stop()
	end
end

function ENT:UpdateVisuals()
	if IsValid(self.PowerSource) then
		self:SetBodygroup(0,1)
	else
		self:SetBodygroup(0,0)
	end
end

--PATH addons/enc_advmarket/lua/market/shared/sh_config.lua:
enc.Colors = {
    bg = Color(42,42,42),
    white = Color(255,255,255),
    whitea = Color(255,255,255,127),
    whiteaa = Color(255,255,255,67),
    blacka = Color(0,0,0,87),
    ibg = Color(31,31,31,254),
    blue = Color(1,116,222),
    red = Color(222,54,1),
    bnhov = Color(217,217,217,50),
}

enc.Admins = {
    ['superadmin'] = true,
    ['uprav'] = true,
    ['manager'] = true,
    ['NS-zammanager'] = true,
    ['overwatch'] = true
}
--PATH addons/itemstore_new/lua/itemstore/items/gunlab.lua:
﻿ITEM.Name = itemstore.Translate("gunlab_name")
ITEM.Description = itemstore.Translate("gunlab_name")
ITEM.Model = "models/props_c17/TrapPropeller_Engine.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Factories
ITEM.Base = "base_darkrp"

function ITEM:SaveData(ent)
    self:SetData("Price", ent:Getprice())
    self:SetData("Owner", ent:Getowning_ent())
end

function ITEM:LoadData(ent)
    ent:Setprice(self:GetData("Price"))
    local owner = self:GetData("Owner")

    if not IsValid(owner) then
        owner = player.GetAll()[1]
    end

    ent:Setowning_ent(owner)
end
--PATH addons/itemstore_new/lua/itemstore/admin.lua:
﻿if SERVER then
    util.AddNetworkString("ItemStoreAdminInventory")

    net.Receive("ItemStoreAdminInventory", function(len, admin)
        if not admin:IsSuperAdmin() then return end
        local pl = net.ReadEntity()
        if not IsValid(pl) then return end
        if not pl.Inventory then return end
        pl.Inventory:SetPermissions(admin, true, true)
        pl.Inventory:Sync(admin)
        admin:OpenContainer(pl.Inventory:GetID(), itemstore.Translate("players_inventory", pl:Name()))
    end)

    util.AddNetworkString("ItemStoreAdminBank")

    net.Receive("ItemStoreAdminBank", function(len, admin)
        if not admin:IsSuperAdmin() then return end
        local pl = net.ReadEntity()
        if not IsValid(pl) then return end
        if not pl.Bank then return end
        pl.Bank:SetPermissions(admin, true, true)
        pl.Bank:Sync(admin)
        admin:OpenContainer(pl.Bank:GetID(), itemstore.Translate("players_bank", pl:Name()))
    end)
else
    concommand.Add("itemstore_admin", function(pl)
        if not pl:IsSuperAdmin() then return end
        local panel = vgui.Create("ItemStoreAdmin")
        panel:SetSize(200, 300)
        panel:Center()
        panel:MakePopup()
    end)
end
--PATH addons/itemstore_new/lua/itemstore/vgui/newslot.lua:
﻿local PANEL = {}
local GradientUp = Material("gui/gradient_up")
local GradientDown = Material("gui/gradient_down")
AccessorFunc(PANEL, "Item", "Item")
AccessorFunc(PANEL, "ContainerID", "ContainerID", FORCE_NUMBER)
AccessorFunc(PANEL, "Slot", "Slot", FORCE_NUMBER)

function PANEL:Init()
    self.BaseClass.Init(self)
    self:Droppable("ItemStore")

    self:Receiver("ItemStore", function(receiver, droptable, dropped)
        if not dropped then return end
        local droppable = droptable[1]
        if droppable == receiver then return end
        local from_con = droppable:GetContainerID()
        local to_con = droppable:GetContainerID()
        if not from_con then return end
        if not to_con then return end
        local from_slot = droppable:GetSlot()
        local to_slot = receiver:GetSlot()
        if not from_slot then return end
        if not to_slot then return end
        local from_item = droppable:GetItem()
        local to_item = receiver:GetItem()

        if from_item and to_item and (from_item:CanMerge(to_item) or from_item:CanUseWith(to_item)) then
            local menu = DermaMenu()

            if from_item:CanUseWith(to_item) then
                menu:AddOption(itemstore.Translate("usewith"), function()
                    LocalPlayer():UseItemWith(droppable:GetContainerID(), droppable:GetSlot(), receiver:GetContainerID(), receiver:GetSlot())
                end):SetIcon("icon16/wrench_orange.png")

                menu:AddSpacer()
            end

            menu:AddOption(itemstore.Translate("move"), function()
                LocalPlayer():MoveItem(droppable:GetContainerID(), droppable:GetSlot(), receiver:GetContainerID(), receiver:GetSlot())
            end):SetIcon("icon16/arrow_switch.png")

            if from_item:CanMerge(to_item) then
                menu:AddOption(itemstore.Translate("merge"), function()
                    LocalPlayer():MergeItem(droppable:GetContainerID(), droppable:GetSlot(), receiver:GetContainerID(), receiver:GetSlot())
                end):SetIcon("icon16/arrow_join.png")
            end

            menu:Open()
        else
            LocalPlayer():MoveItem(droppable:GetContainerID(), droppable:GetSlot(), receiver:GetContainerID(), receiver:GetSlot())
        end
    end)
end

function PANEL:PaintHighlight(w, h)
    if true then return end
    local item = self:GetItem()

    if item and item.HighlightColor then
        local col = Color(item.HighlightColor.r, item.HighlightColor.g, item.HighlightColor.b)
        local bright = Color(col.r * 1.25, col.g * 1.25, col.b * 1.25)
        local dark = Color(bright.r / 2, bright.g / 2, bright.b / 2)

        local shape = {
            {
                x = 0,
                y = 0
            },
            {
                x = w * 0.1,
                y = 0
            },
            {
                x = 0,
                y = h * 0.1
            }
        }

        draw.NoTexture()
        surface.SetDrawColor(col)
        surface.DrawPoly(shape)
    end
end

PANEL.Vingette = Material("itemstore/vingette.png")

function PANEL:PaintBackground(w, h)
    local item = self:GetItem()
    local col = Color(50, 50, 50, 100)

    if item then
        col = Color(55, 55, 55)

        if self:IsDown() then
            col.r = math.min(col.r * 0.75, 255)
            col.g = math.min(col.g * 0.75, 255)
            col.b = math.min(col.b * 0.75, 255)
        elseif self.Hovered then
            col.r = math.min(col.r * 1.25, 255)
            col.g = math.min(col.g * 1.25, 255)
            col.b = math.min(col.b * 1.25, 255)
        end
    end

    --surface.SetDrawColor(col)
    --surface.DrawRect(0, 0, w, h)
    draw.RoundedBox(8, 0, 0, w, h, col)

    --if item then
    --    surface.SetMaterial(self.Vingette)
    --    surface.SetDrawColor(Color(0, 0, 0, 125))
    --    surface.DrawTexturedRect(0, 0, w, h)
    --end
end

PANEL.LabelLerp = 0

surface.CreateFont("ItemStoreSlotLabel", {
    font = "PT Root UI",
    size = 14,
    weight = 500
})

function PANEL:PaintLabel(w, h)
    if w < 100 or self:IsDragging() then return end
    local item = self:GetItem()
    if not item then return end
    self.LabelLerp = Lerp(FrameTime() * 15, self.LabelLerp, self.Hovered and 1 or -0.1)
    local lw, lh = w, 32
    local lx, ly = 0, h - (self.LabelLerp * lh)
    surface.SetDrawColor(Color(0, 0, 0, 150))
    surface.DrawRect(lx, ly, lw, lh)
    draw.SimpleText(item:GetName(), "ItemStoreSlotLabel", lw / 2, ly + (lh / 2), color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
end

surface.CreateFont("ItemStoreAmount", {
    font = "PT Root UI",
    size = 14,
    weight = 500
})

function PANEL:PaintAmount(w, h)
    local item = self:GetItem()

    if item and item:GetAmount() > 1 then
        draw.SimpleText(item:FormatAmount(), "ItemStoreAmount", w - w * 0.05 - 4, h * 0.05 - 2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_TOP)
    end
end

function PANEL:PaintBorder(w, h)
    surface.SetDrawColor(Color(0, 0, 0, 150))
    surface.DrawOutlinedRect(0, 0, w, h)
    surface.SetDrawColor(Color(255, 255, 255, 25))
    surface.DrawOutlinedRect(1, 1, w - 2, h - 2)
end

function PANEL:Paint(w, h)
    self:PaintBackground(w, h)
    self.BaseClass.Paint(self, w, h)
    self:PaintHighlight(w, h)
    self:PaintAmount(w, h)
    self:PaintLabel(w, h)
    --self:PaintBorder(w, h)
end

function PANEL:Refresh()
    local item = self:GetItem()

    if item then
        self:SetModel(item:GetModel())
        self:SetColor(item:GetColor() or color_white)

        if IsValid(self.Entity) then
            self.Entity:SetMaterial(item:GetMaterial())
            local min, max = self.Entity:GetRenderBounds()
            self:SetCamPos(Vector(0.55, 0.55, 0.55) * min:Distance(max))
            self:SetLookAt((min + max) / 2)
        end
    else
        self.Entity = nil
        self:SetTooltip(nil)
    end
end

function PANEL:DoDoubleClick()
    local con_id = self:GetContainerID()
    local slot = self:GetSlot()
    local item = self:GetItem()
    if not con_id then return end
    if not slot then return end
    if not item then return end
    if not item.Use then return end
    LocalPlayer():UseItem(con_id, slot)
end

function PANEL:DoMiddleClick()
    local con_id = self:GetContainerID()
    local slot = self:GetSlot()
    local item = self:GetItem()
    if not con_id then return end
    if not slot then return end
    if not item then return end
    LocalPlayer():DropItem(con_id, slot)
end

function PANEL:DoRightClick()
    local con_id = self:GetContainerID()
    local slot = self:GetSlot()
    local item = self:GetItem()
    if not con_id then return end
    if not slot then return end
    if not item then return end
    local menu = DermaMenu()

    if item.Use then
        menu:AddOption(itemstore.Translate("use"), function()
            LocalPlayer():UseItem(con_id, slot)
        end):SetIcon("icon16/wrench.png")

        menu:AddSpacer()
    end

    menu:AddOption(itemstore.Translate("drop"), function()
        LocalPlayer():DropItem(con_id, slot)
    end):SetIcon("icon16/arrow_out.png")

    menu:AddOption(itemstore.Translate("destroy"), function()
        Derma_Query(itemstore.Translate("destroy_confirmation"), itemstore.Translate("destroy_title"), itemstore.Translate("ok"), function()
            LocalPlayer():DestroyItem(con_id, slot)
        end, itemstore.Translate("cancel")):SetSkin("itemstore")
    end):SetIcon("icon16/delete.png")

    if item:CanSplit(1) then
        menu:AddSpacer()
        local submenu, entry = menu:AddSubMenu(itemstore.Translate("split"))
        entry:SetIcon("icon16/arrow_divide.png")
        local half = math.floor(item:GetAmount() / 2)

        submenu:AddOption(itemstore.Translate("split_half", half), function()
            LocalPlayer():SplitItem(con_id, slot, half)
        end)

        submenu:AddSpacer()

        for _, amount in ipairs({1, 2, 5, 10, 25, 50, 100, 250, 1000}) do
            if item:CanSplit(amount) then
                submenu:AddOption(amount, function()
                    LocalPlayer():SplitItem(con_id, slot, amount)
                end)
            end
        end

        menu:Open()
    end

    item:Run("PopulateMenu", menu)
    menu:Open()
end

local Tooltip

function PANEL:CreateTooltip()
    if IsValid(Tooltip) then
        Tooltip:SetVisible(true)

        return
    end

    Tooltip = vgui.Create("ItemStoreTooltip")
    self:UpdateTooltip()
end

function PANEL:UpdateTooltip()
    if not IsValid(Tooltip) then return end
    Tooltip:SetContainerID(self:GetContainerID())
    Tooltip:SetSlot(self:GetSlot())
    Tooltip:SetItem(self:GetItem())
    Tooltip:Refresh()
end

function PANEL:HideTooltip()
    if IsValid(Tooltip) then
        Tooltip:SetVisible(false)
    end
end

function PANEL:OnCursorEntered()
    if not self:GetItem() then return end
    self:CreateTooltip()
    self:UpdateTooltip()
end

function PANEL:OnCursorMoved()
    if not IsValid(Tooltip) then return end
    local x, y = gui.MousePos()
    Tooltip:SetPos(x, y - Tooltip:GetTall())
end

function PANEL:OnCursorExited()
    self:HideTooltip()
end

vgui.Register("ItemStoreNewSlot", PANEL, "DModelPanel")
local blur = Material("pp/blurscreen")
local gradient_up = Material("gui/gradient_up")
local gradient_down = Material("gui/gradient_down")

concommand.Add("itemstore_test", function()
    local lerp = 0
    -- todo: move this to it's own vgui element
    local frame = vgui.Create("EditablePanel")
    frame:DockPadding(10, ScrH() * 0.1 + 10, 10, ScrH() * 0.1 + 10)
    frame:SetAlpha(lerp)
    frame:SetSize(ScrW(), ScrH())
    frame:Center()

    frame.Paint = function(self, w, h)
        lerp = Lerp(FrameTime() * 5, lerp, 1)
        self:SetAlpha(lerp * 255)
        blur:SetFloat("$blur", 4)
        blur:Recompute()
        render.UpdateScreenEffectTexture()
        surface.SetMaterial(blur)
        surface.SetDrawColor(color_white)
        surface.DrawTexturedRect(0, 0, w, h)
        surface.SetDrawColor(Color(255, 255, 255, 25))
        surface.DrawRect(0, 0, w, h)
        local height = math.floor(ScrH() * 0.35 * lerp)
        surface.SetDrawColor(Color(0, 0, 0, 225))
        surface.SetMaterial(gradient_down)
        surface.DrawTexturedRect(0, 0, w, height)
        surface.SetMaterial(gradient_up)
        surface.DrawTexturedRect(0, h - height, w, height)
    end

    --[[
    local grid = vgui.Create( "DGrid", frame )
    grid:Dock( FILL )
    grid:SetCols( 8 )
    ]]
    --[[
    for i = 1, 80 do
        local slot = vgui.Create( "ItemStoreNewSlot" )
        slot:SetSize( 100, 100 )
        slot:SetItem( item )
        slot:Refresh()

        grid:AddItem( slot )
    end
    ]]
    local model = vgui.Create("DModelPanel", frame)
    model:Dock(LEFT)
    model:DockMargin(0, 0, 10, 0)
    model:SetWidth(ScrW() * 0.25)
    model:SetModel("models/player/alyx.mdl")
    local con = vgui.Create("ItemStoreNewContainer", frame)
    con:Dock(FILL)
    con:Center()
    con:SetContainerID(LocalPlayer().InventoryID)
    local button = vgui.Create("DButton", frame)
    button:SetPos(10, 10)

    button.DoClick = function()
        frame:Remove()
    end

    button:SetText("Close")
    frame:MakePopup()
end)
--PATH addons/itemstore_new/lua/itemstore/vgui/shopitem.lua:
local PANEL = {}

AccessorFunc( PANEL, "Item", "Item" )
AccessorFunc( PANEL, "Entity", "Entity" )
AccessorFunc( PANEL, "SlotID", "SlotID" )

function PANEL:Init()
	self.Slot = vgui.Create( "ItemStoreSlot", self )
	
	self.Name = vgui.Create( "DLabel", self )
	self.Name:SetFont( "DermaDefaultBold" )
	self.Name:SetColor( Color( 255, 255, 255 ) )
	
	self.Description = vgui.Create( "DLabel", self )
	
	self.Purchase = vgui.Create( "DButton", self )

	function self.Purchase.DoClick( b )
		net.Start( "ItemStoreShopPurchase" )
			net.WriteEntity( self:GetEntity() )
			net.WriteUInt( self:GetSlotID(), 16 )
		net.SendToServer()
	end
end

function PANEL:PerformLayout()
	local size = self:GetTall() - 10
	self.Slot:SetSize( size, size )
	self.Slot:SetPos( 5, 5 )
	
	self.Name:SetPos( 5 + size + 10, 5 )

	self.Description:SetPos( 5 + size + 10, 20 )

	self.Purchase:SetPos( self:GetWide() - self.Purchase:GetWide() - 5, self:GetTall() - self.Purchase:GetTall() - 5 )
	self.Purchase:SetSize( 125, 25 )
	
	local item = self:GetItem()
	if not item then return end

	self.Slot:SetItem( item )
	self.Slot:Refresh()
	
	self.Name:SetText( item:GetName() )

	if item:GetAmount() > 1 then
		self.Name:SetText( self.Name:GetText() .. " x" .. item:GetAmount() )
	end

	if item:GetData( "ShopPrice" ) then
		self.Purchase:SetText( "Купить ($" .. item:GetData( "ShopPrice" ) .. ")" )
		self.Purchase:SetDisabled( false )
	else
		self.Purchase:SetText( "Покупка" )
		self.Purchase:SetDisabled( true )
	end

	self.Name:SizeToContents()
	
	self.Description:SetText( "Описание" )
	self.Description:SizeToContents()
end

function PANEL:Paint()
	surface.SetDrawColor( Color( 0, 0, 0, 150 ) )
	surface.DrawRect( 0, 0, self:GetWide(), self:GetTall() )
end

vgui.Register( "ItemStoreShopItem", PANEL )
--PATH addons/deceive/lua/deceive/sh_translations.lua:

local files, folders = file.Find("deceive/translations/*.lua", "LUA")

if SERVER then
	for _, fn in pairs(files) do
		AddCSLuaFile("deceive/translations/" .. fn)
	end
	return
end

deceive.Languages = {}
deceive.Language = CreateConVar("deceive_language", system.GetCountry(), { FCVAR_ARCHIVE }, "The language used to display strings related to the Deceive Disguise System add-on.")

for _, fn in pairs(files) do
	local lang = fn:StripExtension():upper()
	deceive.Languages[lang] = include("deceive/translations/" .. fn) -- CompileFile("deceive/translations/" .. fn)()
end

local fallback = "US" -- if we can't find a translation file, what language will we be faling back to?
function deceive.Translate(str)
	local lang = deceive.Language:GetString():upper()
	local translation = deceive.Languages[lang] or deceive.Languages[fallback]
	return translation[str:lower()]
end


--PATH addons/deceive/lua/deceive/sh_disguise.lua:

local PLAYER = FindMetaTable("Player")

deceive.PLAYER = deceive.PLAYER or {}
if deceive.Config then
	if deceive.Config.FakeName then
		deceive.PLAYER.Name = deceive.PLAYER.Name or PLAYER.Name
	end
	if deceive.Config.FakeJob then
		deceive.PLAYER.Team = deceive.PLAYER.Team or PLAYER.Team
		if DarkRP then
			deceive.PLAYER.getJobTable = deceive.PLAYER.getJobTable or PLAYER.getJobTable
			deceive.PLAYER.getDarkRPVar = deceive.PLAYER.getDarkRPVar or PLAYER.getDarkRPVar
		end
	end
	if deceive.Config.FakeModelColor then
		deceive.PLAYER.GetPlayerColor = deceive.PLAYER.GetPlayerColor or PLAYER.GetPlayerColor
	end
	--[[ does not do anything
	if deceive.Config.FakeSteamID64 then
		deceive.PLAYER.SteamID64 = deceive.PLAYER.SteamID64 or PLAYER.SteamID64
	end
	]]
end

local manualOverride = {
	getDarkRPVar = true
}
local ignoreLPlayer = {
	GetPlayerColor = true
}
for k, v in next, deceive.PLAYER do
	if not manualOverride[k] then
		PLAYER[k] = function(self, ignore)
			if SERVER then ignore = true end
			if IsValid(self.Disguised) and not ignore then
				local disguised = self.Disguised
				local func = deceive.PLAYER[k] -- disguised[k] -- deceive.PLAYER[k]
				return func(disguised, true)
			end
			return deceive.PLAYER[k](self)
		end
	end
end

if deceive.Config and deceive.Config.FakeName then
	PLAYER.GetName = PLAYER.Name
	PLAYER.Nick = PLAYER.Name
end

if DarkRP and deceive.Config and deceive.Config.FakeJob then
	local whitelist = {
		job = true
	}
	function PLAYER:getDarkRPVar(varName, ignore)
		if whitelist[varName] then
			if SERVER then ignore = true end
			if IsValid(self.Disguised) and not ignore then
				return deceive.PLAYER.getDarkRPVar(self.Disguised, varName)
			end
		end
		return deceive.PLAYER.getDarkRPVar(self, varName)
	end
end

--PATH addons/zeros_methlab2/lua/zmlab2_languages/sh_language_cz.lua:
zmlab2 = zmlab2 or {}
zmlab2.language = zmlab2.language or {}

if (zmlab2.config.SelectedLanguage == "cz") then
    zmlab2.language["YouDontOwnThis"] = "Ty tohle nevlastníš!"
    zmlab2.language["Minutes"] = "Minut"
    zmlab2.language["Seconds"] = "Sekund"
    zmlab2.language["CratePickupFail"] = "Bedna je prázdná!"
    zmlab2.language["CratePickupSuccess"] = "Sebráno $MethAmount $MethName, Kvalita: $MethQuality%"
    zmlab2.language["Interaction_Fail_Job"] = "Nejseš správná práce proto aby jsi s tímhle použil!"
    zmlab2.language["Interaction_Fail_Dropoff"] = "Tento výhoz byl k tobě přiřazen!"
    zmlab2.language["Dropoff_assinged"] = "Výhoz přiřazen!"
    zmlab2.language["Dropoff_cooldown"] = "Výhoz cooldown!"
    zmlab2.language["Equipment"] = "Vybavení"
    zmlab2.language["Equipment_Build"] = "Stavět"
    zmlab2.language["Equipment_Move"] = "Pohybovat"
    zmlab2.language["Equipment_Repair"] = "Spravit"
    zmlab2.language["Equipment_Remove"] = "Smazat"
    zmlab2.language["NotEnoughMoney"] = "Nemáš dostatek peněz!"
    zmlab2.language["ExtinguisherFail"] = "Tento objekt nehoří!"
    zmlab2.language["Start"] = "Start"
    zmlab2.language["Drop"] = "Vyhodit"
    zmlab2.language["Move Liquid"] = "Přemístit tekutinu"
    zmlab2.language["Frezzer_NeedTray"] = "Žádnej tác s Meth nebyl nalezen!"
    zmlab2.language["ERROR"] = "ERROR"
    zmlab2.language["SPACE"] = "Zmáčkni SPACE"
    zmlab2.language["NPC_InteractionFail01"] = "Vodpal hajzle.! [Špatná práce]"
    zmlab2.language["NPC_InteractionFail02"] = "Nemáš žádnou Meth!"
    zmlab2.language["NPC_InteractionFail03"] = "Všechny výhozy mám plné, přijd' za chvilku."
    zmlab2.language["PoliceWanted"] = "Prodáno Meth!"
    zmlab2.language["MissingCrate"] = "Chybějící bedna"
    zmlab2.language["Storage"] = "SKLAD"
    zmlab2.language["ItemLimit"] = "Už si nemůžeš koupit více $ItemName!"
    zmlab2.language["TentFoldInfo01"] = "Jseš si jistej že chceš vymazat stan?"
    zmlab2.language["TentFoldInfo02"] = "Všechno vybavení vevnitř bude vymazáno také!"
    zmlab2.language["TentFoldAction"] = "SLOŽIT"
    zmlab2.language["TentType_None"] = "ŽÁDNÝ"
    zmlab2.language["TentAction_Build"] = "STAVĚT"
    zmlab2.language["TentBuild_Info"] = "Prosím vyklid'oblast!"
    zmlab2.language["TentBuild_Abort"] = "Něco je v cestě!"
    zmlab2.language["Enabled"] = "Zapnuto"
    zmlab2.language["Disabled"] = "Vypnuto"
    zmlab2.language["MethTypeRestricted"] = "Nemůžeš vyrábět tento druh Meth!"
    zmlab2.language["SelectMethType"] = "Vyber druh Methu"
    zmlab2.language["SelectTentType"] = "Vyber druh stanu"
    zmlab2.language["LightColor"] = "Světlá barva"
    zmlab2.language["Cancel"] = "Zrušit"
    zmlab2.language["Deconstruct"] = "Dekrostrukce"
    zmlab2.language["Construct"] = "Konstrukce"
    zmlab2.language["Choosepostion"] = "Vyber novou pozici"
    zmlab2.language["ChooseMachine"] = "Vyber stroj"
    zmlab2.language["Extinguish"] = "Uhas"
    zmlab2.language["PumpTo"] = "Vypumpovat do"
    zmlab2.language["ConstructionCompleted"] = "Konstrukce Dokončena!"
    zmlab2.language["Duration"] = "Délka"
    zmlab2.language["Amount"] = "Výtěžek"
    zmlab2.language["Difficulty"] = "Obtížnost"
    zmlab2.language["Money"] = "Peníze"
    zmlab2.language["Difficulty_Easy"] = "Jednoduchý"
    zmlab2.language["Difficulty_Medium"] = "Medium"
    zmlab2.language["Difficulty_Hard"] = "Těžký"
    zmlab2.language["Difficulty_Expert"] = "Expert"
    zmlab2.language["Connected"] = "Připojeno!"
    zmlab2.language["Missed"] = "Minuto!"
    -- Tent Config
    -- Note: "Vamonos Pest" and "Crystale Castle" are the names of those tents so you dont need to translate them if you dont want
    zmlab2.language["tent01_title"] = "Vamonos Pest Tent - Small"
    zmlab2.language["tent01_desc"] = "Tento stan má místo pro 6 strojů."
    zmlab2.language["tent02_title"] = "Vamonos Pest Tent - Medium"
    zmlab2.language["tent02_desc"] = "Tento stan má místo pro 9 strojů."
    zmlab2.language["tent03_title"] = "Vamonos Pest Tent - Large"
    zmlab2.language["tent03_desc"] = "Tento stan má místo pro 16 strojů."
    zmlab2.language["tent04_title"] = "Crystale Castle"
    zmlab2.language["tent04_desc"] = "Tento stan má místo pro 24 strojů."
    -- Equipment Config
    zmlab2.language["ventilation_title"] = "Ventilace"
    zmlab2.language["ventilation_desc"] = "Vyčistí oblast před Poluci."
    zmlab2.language["storage_title"] = "Sklad"
    zmlab2.language["storage_desc"] = "Z tohodle dostáváš vybavení a chemikálie."
    zmlab2.language["furnace_title"] = "Thorium furnace"
    zmlab2.language["furnace_desc"] = "Pro topení kyseliny."
    zmlab2.language["mixer_title"] = "Mixer"
    zmlab2.language["mixer_desc"] = "Kombinuje."
    zmlab2.language["filter_title"] = "Filter"
    zmlab2.language["filter_desc"] = "Použiváno k refinování quality methu."
    zmlab2.language["filler_title"] = "Filler"
    zmlab2.language["filler_desc"] = "Používáno k naplnění tácu."
    zmlab2.language["frezzer_title"] = "Frezzer"
    zmlab2.language["frezzer_desc"] = "Používáno k zastavení k poslednímu složení Methamphetaminu."
    zmlab2.language["packingtable_title"] = "Packing Table"
    zmlab2.language["packingtable_desc"] = "Využito k ničení a zabalování Methu, může být vylepšeno Ice Breakerem."
    -- Storage Config
    zmlab2.language["acid_title"] = "Hydrofluoric Acid"
    zmlab2.language["acid_desc"] = "Zrychluje reakci."
    zmlab2.language["methylamine_title"] = "Methylamine"
    zmlab2.language["methylamine_desc"] = "Methylamine (CH3NH2) je organická sloučenina a jedna z hlavních složek pro výrobu metamfetaminu."
    zmlab2.language["aluminum_title"] = "Hliníková amalgám"
    zmlab2.language["aluminum_desc"] = "Hliníkový amalgám se používá jako chemické činidlo pro redukci sloučenin."
    zmlab2.language["lox_title"] = "Liquid Oxygen"
    zmlab2.language["lox_desc"] = "Hliníkový amalgám používá jako chemický prostředek pro redukci sloučenin."
    zmlab2.language["crate_title"] = "Transportcrate"
    zmlab2.language["crate_desc"] = "Použito pro transportování Methu."
    zmlab2.language["palette_title"] = "Paleta"
    zmlab2.language["palette_desc"] = "Použito pro transportování velké množství methu."
    zmlab2.language["crusher_title"] = "Ice Breaker"
    zmlab2.language["crusher_desc"] = "Automaticky ničí a balí Meth když položen na Balící stůl."
    -- Meth Config
    -- Note: Hard to say what about the meth should be translated and what not. Decide for yourself whats important here.
    zmlab2.language["meth_title"] = "Meth"
    zmlab2.language["meth_desc"] = "Fet'áci tohle mají v oblibě."
    zmlab2.language["bluemeth_title"] = "Crystal Blue"
    zmlab2.language["bluemeth_desc"] = "Modrá jako fialka, že jo Jesse?"
    zmlab2.language["kalaxi_title"] = "Kalaxian Crystal"
    zmlab2.language["kalaxi_desc"] = "Je stejná jako hodně drog, senzace a zhulení na jednom křist'álu."
    zmlab2.language["glitter_title"] = "Glitter"
    zmlab2.language["glitter_desc"] = "Glitter je vysoce psychedelická droga a nedávný příjezd do ulic Night City. Je to opravdu silná věc, dokonce i pro přeplněné obyvatele Night City."
    zmlab2.language["kronole_title"] = "Kronole"
    zmlab2.language["kronole_desc"] = "Kronole je pouliční droga prodávaná na palubě Snowpiercer na černém trhu. Droga má schopnost blokovat receptory bolesti, Kronole je tak silný, že blokuje všechny pocity, nejen bolest."
    zmlab2.language["melange_title"] = "Melange"
    zmlab2.language["melange_desc"] = "Melange (Spice) je lék schopný prodloužit život, poskytnout zvýšenou vitalitu a vědomí a odemknout předvídavost u některých lidí."
    zmlab2.language["mdma_title"] = "MDMA"
    zmlab2.language["mdma_desc"] = "MDMA byl poprvé vyvinut v roce 1912 společností Merck. To bylo používáno k posílení psychoterapie od 70. let a v 80. letech se stalo populární jako pouliční droga."
    -- Update 1.0.5
    zmlab2.language["tent05_title"] = "Round Tent"
    zmlab2.language["tent05_desc"] = "This round tent provides room for 8 machines."
end

--PATH addons/zeros_methlab2/lua/zmlab2/sh_custom_hooks.lua:

hook.Add("CanTool","PPMethToolDsbl",function(pl,tr)
    if IsValid(tr.Entity) and tr.Entity:GetModel() == 'models/zerochain/props_methlab/zmlab2_ventilation_head.mdl' then
        return false
    end
end)

// Called when the player creates the Final Meth by Pressing E on the frezzing Tray
hook.Add("zmlab2_OnMethMade", "zmlab2_OnMethMade_test", function(ply, frezzingTray, methEnt)
    if not IsValid(ply) then return end

    /*
        methEnt can either be a meth bag or a meth crate, depending if the frezzer tray is put on a packing table or not
    */
end)

// Called before the player receives his earning
// Can be used to modify the money earned from selling meth
hook.Add("zmlab2_PreMethSell","zmlab2_PreSell_test",function(ply,earning)

    /*
        if ply:IsSuperAdmin() then
            earning = earning * 2
        end
    */

    return earning
end)

// Gets called when a Player destorys Methbag, Methcrate or Palette with Meth
hook.Add("zmlab2_OnMethObjectDestroyed", "zmlab2_OnMethObjectDestroyed_test", function(methObject,damageinfo)

    if IsValid(methObject) then
        local ply = damageinfo:GetAttacker()

        local Earning = 0
        if methObject:GetClass() == "zmlab2_item_palette" then
            for k,v in pairs(methObject.MethList) do
                Earning = Earning + zmlab2.Meth.GetValue(v.t,v.a,v.q)
            end
        else
            Earning = zmlab2.Meth.GetValue(methObject:GetMethType(),methObject:GetMethAmount(),methObject:GetMethQuality())
        end
        if Earning <= 0 then return end

        if methObject.GetMethType then
            zmlab2.NetEvent.Create("meth_explo", methObject:GetPos(),methObject:GetMethType())
        else
            zmlab2.NetEvent.Create("meth_explo", methObject:GetPos(),1)
        end

        // If the attacker is a player with a police job then we reward that player
        if IsValid(ply) and ply:IsPlayer() and ply:Alive() and zmlab2.config.Police.Jobs[zmlab2.Player.GetJob(ply)] then

            // Add Rank multiplicator
            Earning = Earning * ( zmlab2.config.NPC.SellRanks[zmlab2.Player.GetRank(ply)] or zmlab2.config.NPC.SellRanks["default"])

            // Multiply by police cut
            Earning = Earning * zmlab2.config.Police.PoliceCut
            zmlab2.Money.Give(ply, Earning)
            zmlab2.Notify(ply, "+" .. zmlab2.Money.Display(math.Round(Earning)), 0)
        end
    end
end)

// Called when a player gets wanted for either selling meth or lockpicking a tentdoor
hook.Add("zmlab2_OnWanted", "zmlab2_OnWanted_test", function(ply,reason)
    if (IsValid(ply)) then
        //print(ply:Nick() .. " " .. reason)
    end
end)

// Here you can return which sellmode this player should have for selling meth
// Return 1,2, 3, 4 or return nothing if you want to use the default sellmode defind in the config
hook.Add("zmlab2_GetSellMode", "zmlab2_GetSellMode_test", function(ply)

    // 1 = Methcrates can be absorbed by Players and sold by the MethBuyer on use
    // 2 = Methcrates cant be absorbed and the MethBuyer tells you a dropoff point instead (Palette Entity gets used here for easier transport)
    // 3 = Methcrates can be absorbed and the MethBuyer tells you a dropoff point
    // 4 = Methcrates need to be moved to the MethBuyer and sold directly by him

    if IsValid(ply) and ply:IsSuperAdmin() then
        //return 3
    end
end)

// Gets called when a dropoff point gets assinged to a player
hook.Add("zmlab2_OnDropOffPoint_Assigned", "zmlab2_OnDropOffPoint_Assigned_test", function(dropoffpoint,ply)
    /*
    if IsValid(dropoffpoint) and IsValid(ply) then
        print("Player: " .. ply:Nick() .. " just got assigned DropOffPoint: " .. tostring(dropoffpoint) .. ".")
    end
    */
end)

// Called when a player consums meth
hook.Add("zmlab2_OnMethConsum", "zmlab2_OnMethConsum_test", function(ply, MethType,MethQuality)
    if not IsValid(ply) then return end
end)

// Can be used to overwrite the limit for a specific item which the player trys to buy from the storage entity
hook.Add("zmlab2_Storage_GetItemLimit", "zmlab2_Storage_GetItemLimit_test", function(ply,ItemID)

    /*
    // Superadmins can buy double as much
    if IsValid(ply) and ply:IsSuperAdmin() then
        return zmlab2.config.Storage.Shop[ItemID].limit * 2
    end
    */
end)

// Can be used to overwrite the limit for a specific item which the player trys to buy / build from the Equipmentbox entity
hook.Add("zmlab2_Equipment_GetItemLimit", "zmlab2_Equipment_GetItemLimit_test", function(ply,ItemID)

    /*
    // Superadmins can buy double as much
    if IsValid(ply) and ply:IsSuperAdmin() then
        return zmlab2.config.Equipment.List[ItemID].limit * 2
    end
    */

    if IsValid(ply) and ply:IsSuperAdmin() then
        return zmlab2.config.Equipment.List[ItemID].limit * 5
    end
end)

--PATH addons/zeros_methlab2/lua/zmlab2/util/sh_convar.lua:
zmlab2 = zmlab2 or {}
zmlab2.Convar = zmlab2.Convar or {}
zmlab2.Convars = zmlab2.Convars or {}

function zmlab2.Convar.Get(convar)
    return tonumber(zmlab2.Convars[convar] or 0, 10)
end

function zmlab2.Convar.Set(convar, val)
    zmlab2.Convars[convar] = val
end

function zmlab2.Convar.Create(convar, val, data)
    CreateConVar(convar, val, data)
    zmlab2.Convars[convar] = GetConVar(convar):GetString()

    local identifier = "convar_" .. convar
    cvars.RemoveChangeCallback(convar, identifier)
    cvars.AddChangeCallback(convar, function(convar_name, value_old, value_new)
        zmlab2.Convar.Set(convar, value_new)
    end, identifier)
end

if CLIENT then
    zmlab2.Convar.Create("zmlab2_cl_vfx_dynamiclight", "1", {FCVAR_ARCHIVE})
    zmlab2.Convar.Create("zmlab2_cl_sfx_volume", "1", {FCVAR_ARCHIVE})
    zmlab2.Convar.Create("zmlab2_cl_drawui", "1", {FCVAR_ARCHIVE})
    zmlab2.Convar.Create("zmlab2_cl_particleeffects", "1", {FCVAR_ARCHIVE})
end

--PATH addons/zeros_methlab2/lua/zmlab2/util/sh_money.lua:
zmlab2 = zmlab2 or {}
zmlab2.Money = zmlab2.Money or {}

if SERVER then
	function zmlab2.Money.Give(ply, money)
		if (DarkRP) then
			ply:addMoney(money)
		elseif (nut) then
			ply:getChar():giveMoney(money)
		elseif (BaseWars) then
			ply:GiveMoney(money)
		end
	end

	function zmlab2.Money.Take(ply, money)
		if (DarkRP) then
			ply:addMoney(-money)
		elseif (nut) then
			ply:getChar():takeMoney(money)
		elseif (BaseWars) then
			ply:GiveMoney(-money)
		end
	end
end

function zmlab2.Money.Has(ply, money)
	if (DarkRP) then
		if ((ply:getDarkRPVar("money") or 0) >= money) then
			return true
		else
			return false
		end
	elseif (nut) then
		if (ply:getChar():hasMoney(money)) then
			return true
		else
			return false
		end
	elseif (BaseWars) then
		if ((ply:GetMoney() or 0) >= money) then
			return true
		else
			return false
		end
	elseif (engine.ActiveGamemode() == "sandbox") then
		return true
	end
end

// Returns the formated money as string
function zmlab2.Money.Format(money)
	if not money then return "0" end
	money = tostring(math.abs(money))
	local sep = ","
	local dp = string.find(money, "%.") or #money + 1

	for i = dp - 4, 1, -3 do
		money = money:sub(1, i) .. sep .. money:sub(i + 1)
	end

	return money
end

function zmlab2.Money.Display(money)
	if not zmlab2.config.CurrencyInvert then
		return zmlab2.config.Currency .. zmlab2.Money.Format(money)
	else
		return zmlab2.Money.Format(money) .. zmlab2.config.Currency
	end
end

--PATH addons/zeros_methlab2/lua/zmlab2/util/cl_precache_mdl.lua:
if SERVER then return end

zmlab2 = zmlab2 or {}

timer.Simple(2,function()
    for k,v in pairs(zmlab2.config.Equipment.List) do zmlab2.CacheModel(v.model) end
    for k,v in pairs(zmlab2.config.Tent) do zmlab2.CacheModel(v.model) end
    zmlab2.CacheModel("models/zerochain/props_methlab/zmlab2_pipe_vent.mdl")
    zmlab2.CacheModel("models/zerochain/props_methlab/zmlab2_crate.mdl")
    zmlab2.CacheModel("models/hunter/misc/sphere025x025.mdl")
end)



////////////////////////////////////////////
/////////// PRECACHE - MODELS //////////////
////////////////////////////////////////////
// Precaches the Model before it gets used, isntead of precaching all models at once
zmlab2.CachedModels = {}
function zmlab2.CacheModel(path)
    if zmlab2.CachedModels[path] then
        return path
    else
        util.PrecacheModel(path)
        zmlab2.CachedModels[path] = true

        zmlab2.Print("Model " .. path .. " cached!")

        return path
    end
end
////////////////////////////////////////////
////////////////////////////////////////////




////////////////////////////////////////////
///////////// ClientModels /////////////////
////////////////////////////////////////////
/*

	This system Creates / Removes and keeps track on ClientModels

*/

zmlab2.ClientModel = zmlab2.ClientModel or {}
if zmlab2_ClientModelList == nil then
    zmlab2_ClientModelList = {}
end

function zmlab2.ClientModel.PrintAll()
    for k, v in pairs(zmlab2_ClientModelList) do
        if not IsValid(v) then
            zmlab2_ClientModelList[k] = nil
        end
    end

    PrintTable(zmlab2_ClientModelList)
end

function zmlab2.ClientModel.Add(mdl_path, rendermode)
    zmlab2.CacheModel(mdl_path)
    local ent = ClientsideModel(mdl_path or "error.mdl", rendermode)
    table.insert(zmlab2_ClientModelList, ent)

    return ent
end

function zmlab2.ClientModel.AddProp(mdl_path)
    local ent = nil

    if mdl_path then
        zmlab2.CacheModel(mdl_path)
        ent = ents.CreateClientProp(mdl_path)
    else
        ent = ents.CreateClientProp()
    end

    table.insert(zmlab2_ClientModelList, ent)

    return ent
end

function zmlab2.ClientModel.Remove(ent)
    if not IsValid(ent) then return end
    table.RemoveByValue(zmlab2_ClientModelList, ent)

    // Stop moving if you have physics
    if ent.PhysicsDestroy then ent:PhysicsDestroy() end

    // Hide entity
    if ent.SetNoDraw then ent:SetNoDraw(true) end

    // This got taken from a Physcollide function but maybe its needed to prevent a crash
    local deltime = FrameTime() * 2
    if not game.SinglePlayer() then deltime = FrameTime() * 6 end
    SafeRemoveEntityDelayed(ent, deltime)
end
////////////////////////////////////////////
////////////////////////////////////////////

--PATH addons/zeros_methlab2/lua/zmlab2/mixer/sh_mixer.lua:
zmlab2 = zmlab2 or {}
zmlab2.Mixer = zmlab2.Mixer or {}

// Checks if the player is allowed to create this methtype
function zmlab2.Mixer.MethTypeCheck(ply,methtype)
    local MethData = zmlab2.config.MethTypes[methtype]
    if MethData == nil then return false end
    if MethData.rank and istable(MethData.rank) and table.Count(MethData.rank) > 0 and zmlab2.Player.RankCheck(ply,MethData.rank) == false then return false end
    if MethData.job and istable(MethData.job) and table.Count(MethData.job) > 0 and MethData.job[zmlab2.Player.GetJob(ply)] == nil then return false end
    if MethData.customcheck and MethData.customcheck(ply) == false then return false end

    return true
end

function zmlab2.Mixer.GetLiquidColor(Mixer)
    local col
    local state = Mixer:GetProcessState()
    local MethType = Mixer:GetMethType()
    /*
        < 2 = Yellow
        2 = Acid Yellow
        2 - 3 > Acid Yellow to meth color half way
        8 > 9 half color to final color
    */

    if state < 2 then
        col = zmlab2.colors["mixer_liquid01"]
    elseif state == 2 then

        col = zmlab2.colors["mixer_liquid02"]

    elseif state == 3 then

        local mix_start = Mixer:GetProcessStart()
        local time_fract = (1 / zmlab2.Meth.GetMixTime(MethType)) * (CurTime() - mix_start)

        local midColor = zmlab2.util.LerpColor(0.5, zmlab2.colors["mixer_liquid02"], zmlab2.Meth.GetColor(MethType))

        col = zmlab2.util.LerpColor(time_fract, zmlab2.colors["mixer_liquid02"], midColor)

    elseif state > 3 and state < 8 then

        col = zmlab2.util.LerpColor(0.5, zmlab2.colors["mixer_liquid02"], zmlab2.Meth.GetColor(MethType))

    else
        local midColor = zmlab2.util.LerpColor(0.5, zmlab2.colors["mixer_liquid02"], zmlab2.Meth.GetColor(MethType))

        local vent_start = Mixer:GetProcessStart()
        local time_fract = (1 / zmlab2.Meth.GetVentTime(MethType)) * (CurTime() - vent_start)
        col = zmlab2.util.LerpColor(time_fract, midColor, zmlab2.Meth.GetColor(MethType))

        local qual_fact = (1 / 100) * Mixer:GetMethQuality()
        local h, s, v = ColorToHSV(col)
        col = HSVToColor(h, s * qual_fact, v)

        local fract = (1 / 4) * (state - 3)
        col = zmlab2.util.LerpColor(fract, midColor, col)
    end

    return col
end

--PATH addons/zeros_methlab2/lua/zmlab2/filler/cl_filler.lua:
if not CLIENT then return end
zmlab2 = zmlab2 or {}
zmlab2.Filler = zmlab2.Filler or {}

function zmlab2.Filler.Initialize(Filler)
end

function zmlab2.Filler.Think(Filler)
    if zmlab2.util.InDistance(LocalPlayer():GetPos(), Filler:GetPos(), 500) and Filler:GetProcessState() == 2 and (Filler.NextEffect == nil or Filler.NextEffect < CurTime()) then
        local attach = Filler:GetAttachment(2)
        zmlab2.Effect.ParticleEffect("zmlab2_methsludge_fill", attach.Pos + Filler:GetForward() * math.random(-5, 5), angle_zero, Filler)
        Filler.NextEffect = CurTime() + 0.1
    end
end

function zmlab2.Filler.Draw(Filler)
    zmlab2.util.LoopedSound(Filler, "zmlab2_machine_pumping", Filler:GetProcessState() == 2)

    if zmlab2.util.InDistance(LocalPlayer():GetPos(), Filler:GetPos(), 500) and zmlab2.Convar.Get("zmlab2_cl_drawui") == 1 then
        zmlab2.Filler.DrawUI(Filler)
    end
end

function zmlab2.Filler.OnRemove(Filler)
    Filler:StopSound("zmlab2_machine_pumping")
end

function zmlab2.Filler.DrawUI_Liquid(Filler)
    if Filler.SmoothBar == nil then Filler.SmoothBar = 0 end
    Filler.SmoothBar = Lerp(0.5 * FrameTime(), Filler.SmoothBar, Filler:GetMethAmount())

    local dat = zmlab2.config.MethTypes[Filler:GetMethType()]

    local turbulence = 0
    if Filler:GetProcessState() == 2 then turbulence = 0.5 end

    cam.Start3D2D(Filler:LocalToWorld(Vector(17.8, 13.7, 18)), Filler:LocalToWorldAngles(Angle(0, 0, -90)), 0.1)
        zmlab2.Interface.DrawLiquid(Filler, -50, -20, 40, 260, (1 / dat.batch_size) * Filler.SmoothBar, dat.color, turbulence)
    cam.End3D2D()
end

local ScreenData = {
    pos = Vector(-4.85, 12, 29.55),
    ang = Angle(0, 180, 90),
    x = 0,
    y = 0,
    w = 200,
    h = 220,
    pages = {
        [0] = function(Filler)
            zmlab2.Interface.DrawPipe(200,200,zmlab2.colors["mixer_liquid01"])
        end,
        [1] = function(Filler)
            zmlab2.Interface.DrawIngredient(0, 0, 200, 210, zmlab2.materials["icon_tray"],1,zmlab2.GetFont("zmlab2_font03"))
        end,
        [3] = function(Filler)
            surface.SetDrawColor(color_white )
            surface.SetMaterial(zmlab2.materials["icon_sponge"])
            surface.DrawTexturedRectRotated(0, 0, 140, 140, 0 )
        end
    }
}

function zmlab2.Filler.DrawUI(Filler)

    zmlab2.Filler.DrawUI_Liquid(Filler)

    zmlab2.Interface.Draw(Filler, ScreenData)

    // A little animated pointer
    zmlab2.Interface.DrawScalar(Filler,Vector(6, 1,52),Angle(0, 0, -90),Filler:GetProcessState() == 2)
end

--PATH addons/zeros_methlab2/lua/zmlab2/pollutionsystem/cl_pollutionsystem.lua:
if SERVER then return end
zmlab2 = zmlab2 or {}
zmlab2.PollutionSystem = zmlab2.PollutionSystem or {}
zmlab2.PollutionSystem.PolutedAreas = zmlab2.PollutionSystem.PolutedAreas or {}

net.Receive("zmlab2_PollutionSystem_AddPollution", function(len, ply)
    //zmlab2.Debug_Net("zmlab2_PollutionSystem_AddPollution", len)
    local pos = net.ReadVector()
    local amount = net.ReadUInt(16)
    if pos == nil then return end
    if amount == nil then return end
    zmlab2.PollutionSystem.AddPollution(pos,amount)
end)
function zmlab2.PollutionSystem.AddPollution(pos,amount)

    local id = zmlab2.PollutionSystem.FindNearest(pos,50)
    if id then
        zmlab2.PollutionSystem.PolutedAreas[id].amount = zmlab2.PollutionSystem.PolutedAreas[id].amount + amount
    else
        table.insert(zmlab2.PollutionSystem.PolutedAreas, {
            pos = pos,
            amount = amount
        })
    end
    zmlab2.PollutionSystem.TimeCheck()
end


net.Receive("zmlab2_PollutionSystem_RemovePollution", function(len, ply)
    //zmlab2.Debug_Net("zmlab2_PollutionSystem_RemovePollution", len)
    local pos = net.ReadVector()
    local amount = net.ReadUInt(16)
    if pos == nil then return end
    if amount == nil then return end
    zmlab2.PollutionSystem.RemovePollution(pos,amount)
end)
function zmlab2.PollutionSystem.RemovePollution(pos,amount)
    local id = zmlab2.PollutionSystem.FindNearest(pos,zmlab2.config.Ventilation.Radius)
    if id then
        zmlab2.PollutionSystem.PolutedAreas[id].amount = math.Clamp(zmlab2.PollutionSystem.PolutedAreas[id].amount - amount,0,99999999)

        if zmlab2.PollutionSystem.PolutedAreas[id].amount <= 0 then
            zmlab2.PollutionSystem.PolutedAreas[id] = nil
        end
    else
        //debugoverlay.Sphere(pos,100,1,Color( 255, 255, 0 ,50),true)
        // Could not find any pollution
        return
    end
    zmlab2.PollutionSystem.TimeCheck()
end

function zmlab2.PollutionSystem.TimeCheck()
    local timerid = "zmlab2_PollutionSystem_timer"
    if timer.Exists(timerid) == true then return end
    zmlab2.Timer.Remove(timerid)

    zmlab2.Timer.Create(timerid,1,0,function()

        //NearestPollution = nil
        if zmlab2.PollutionSystem.PolutedAreas == nil or table.Count(zmlab2.PollutionSystem.PolutedAreas) <= 0 then
            zmlab2.Debug("Pollution Timer Removed")
            zmlab2.Timer.Remove(timerid)
        else
            for area_id,pollution_amount in pairs(zmlab2.PollutionSystem.PolutedAreas) do

                local area_data = zmlab2.PollutionSystem.PolutedAreas[area_id]

                area_data.amount = math.Clamp(area_data.amount - zmlab2.config.PollutionSystem.EvaporationAmount,0,9999999)

                if area_data.amount <= 0 then
                    zmlab2.PollutionSystem.PolutedAreas[area_id] = nil
                else

                    if zmlab2.util.InDistance(LocalPlayer():GetPos(), area_data.pos, 1000) then
                        zmlab2.PollutionSystem.Visualize(area_data)
                    end
                end
            end
        end
    end)
    zmlab2.Debug("Pollution Timer Created")
end


// Keeps track on when the player last was inside a pollution area
function zmlab2.PollutionSystem.Visualize(polution_data)
    //local count = math.Clamp(math.Round(polution_data.amount / 10),1,10)
    local count = math.Clamp(math.Round(polution_data.amount / 10),1,10)
    local rad = 30 * count
    local impact_dist = zmlab2.PollutionSystem.GetSize() + rad
    //debugoverlay.Sphere(polution_data.pos,impact_dist,1,Color( 255, 0, 0 ,50),true)

    for i = 0, count-1 do
        local ang = (360 / count) * i
        local circlePos = Vector(math.cos(ang) * rad, math.sin(ang) * rad, 1)

        //local rndPos = Vector(math.random(-rad,rad),math.random(-rad,rad),0)

        if zmlab2.config.PollutionSystem.UseTraces == true then
            local c_trace = zmlab2.util.TraceLine({
                start = polution_data.pos + circlePos + Vector(0,0,50),
                endpos = polution_data.pos + circlePos - Vector(0,0,5000),
                mask = MASK_SOLID_BRUSHONLY,
            }, "PollutionSystem")

            //debugoverlay.Line( polution_data.pos + circlePos + Vector(0,0,50), c_trace.HitPos, 1, Color( 255, 255, 255 ), false )

            if c_trace and c_trace.Hit and c_trace.HitPos then
                zmlab2.Effect.ParticleEffect("zmlab2_poison_gas", c_trace.HitPos, angle_zero, Entity(1))
                //debugoverlay.Sphere(c_trace.HitPos,15,1,Color( 0, 0, 255 ,50),true)
            end
        else
            zmlab2.Effect.ParticleEffect("zmlab2_poison_gas", polution_data.pos + circlePos, angle_zero, Entity(1))
            //debugoverlay.Sphere(polution_data.pos + circlePos,15,1,Color( 0, 0, 255 ,50),true)
        end
    end

    zmlab2.Effect.ParticleEffect("zmlab2_poison_gas", polution_data.pos, angle_zero, Entity(1))

    //debugoverlay.Sphere(polution_data.pos,zmlab2.PollutionSystem.GetSize(),1,Color( 255, 0, 0 ,50),true)

    if zmlab2.util.InDistance(LocalPlayer():GetPos(), polution_data.pos, impact_dist) and zmlab2.config.PollutionSystem.ImmunityCheck(LocalPlayer()) ~= true then

        if zmlab2.config.PollutionSystem.UseTraces == true then
            local c_trace = zmlab2.util.TraceLine({
                start = polution_data.pos + Vector(0,0,50),
                endpos = LocalPlayer():GetPos() + Vector(0,0,10),
                mask = MASK_SOLID_BRUSHONLY,
            }, "PollutionSystem")

            if c_trace and c_trace.Fraction >= 0.9 then
                zmlab2.PollutionSystem.ScreenEffect_Add()
            end
        else
            zmlab2.PollutionSystem.ScreenEffect_Add()
        end
    end

    //zmlab2.Sound.EmitFromPosition(polution_data.pos, "gas_buff")
end

local LastImpact = 0
local ScreenEffectAmount = 0
function zmlab2.PollutionSystem.ScreenEffect()

    if not IsValid(LocalPlayer()) or LocalPlayer():Alive() == false then
        zmlab2.PollutionSystem.ScreenEffect_Remove()
        return
    end

    if CurTime() <= (LastImpact + 1.1) then
        ScreenEffectAmount = math.Clamp(ScreenEffectAmount + (100 * FrameTime()),0,100)
    else
        ScreenEffectAmount = math.Clamp(ScreenEffectAmount - (100 * FrameTime()),0,100)
    end

    if ScreenEffectAmount > 0 then

        local alpha = (1 / 100) * ScreenEffectAmount

        DrawBloom(0.2, 2 * alpha, alpha * 8, alpha * 8, 15, 1, 0, 0.5, 0.3)

        DrawMotionBlur(0.05, alpha, 0)

        DrawMaterialOverlay("effects/tp_eyefx/tpeye3", 1 * alpha)
        DrawMaterialOverlay("effects/water_warp01", 0.01 * alpha)

        local tab = {}
        tab["$pp_colour_colour"] = 1
        tab["$pp_colour_contrast"] = 0.5
        tab["$pp_colour_brightness"] = 0.1

        tab["$pp_colour_addg"] = 0.1 * alpha
        tab["$pp_colour_addr"] = 0
        tab["$pp_colour_addb"] = 0

        tab["$pp_colour_mulg"] = 1 * alpha
        tab["$pp_colour_mulr"] = 0
        tab["$pp_colour_mulb"] = 0
        DrawColorModify(tab)
    else
        zmlab2.PollutionSystem.ScreenEffect_Remove()
    end
end
function zmlab2.PollutionSystem.ScreenEffect_Add()
    LocalPlayer():SetDSP(3)
    LastImpact = CurTime()
    LocalPlayer():EmitSound("zmlab2_gas_indicator")
    // Creates the hook if it doesent exists yet
    zmlab2.Hook.Add("RenderScreenspaceEffects", "PollutionSystem", zmlab2.PollutionSystem.ScreenEffect)
end
function zmlab2.PollutionSystem.ScreenEffect_Remove()
    ScreenEffectAmount = 0
    LastImpact = 0
    LocalPlayer():SetDSP(0)
    zmlab2.Hook.Remove("RenderScreenspaceEffects", "PollutionSystem")
end


/*
gameevent.Listen( "player_spawn" )
hook.Add("player_spawn", "zmlab2_ClearPollutionScreenEffect_OnSpawn", function( data )
	ScreenEffectAmount = 0
end)
*/

--PATH addons/zeros_methlab2/lua/zmlab2/meth/sh_meth.lua:
zmlab2 = zmlab2 or {}
zmlab2.Meth = zmlab2.Meth or {}

zmlab2.Meth.Materials = zmlab2.Meth.Materials or {}

// Creates / returns a meth material which matches the specified parameters
function zmlab2.Meth.GetMaterial(MethType,MethQuality)

    local quality_step = math.Round((5 / 100) * MethQuality)

    local mat_name = "zmlab2_material_meth_" .. MethType .. "_" .. quality_step

    if zmlab2.Meth.Materials[mat_name] then
        return mat_name
    end


    local MethData = zmlab2.config.MethTypes[MethType]
    if MethData == nil then return end
    // This is a big OOF but for some reason phong wont work for materials created with LUA

    local mat_params = {
    	["$basetexture"] = "$basetexture","zerochain/props_methlab/meth/zmlab2_meth_cracked_diff",
    	["$bumpMap"] = "$bumpMap","zerochain/props_methlab/meth/zmlab2_meth_cracked_nrm",
        ["$normalmapalphaenvmapmask"] = 1,

        ["$halflambert"] = 1,
        ["$model"] = 1,
        ["$selfillum"] = 1,
        ["$selfillummaskscale"] = 0.5,

        ["$envmap"] = "env_cubemap",
        ["$envmaptint"] = Vector(1,1,1),
        ["$envmapfresnel"] = 1,

        ["$phong"] = 1,
        ["$phongexponent"] = 1,
        ["$phongboost"] = 1,
        ["$phongfresnelranges"] = Vector(1, 1, 1),
        ["$phongtint"] = Vector(1, 1, 1),

        ["$rimlight"] = 1,
        ["$rimlightexponent"] = 5,
        ["$rimlightboost"] = 1,
    }

    zmlab2.Debug("zmlab2.Meth.MethMaterial Created!")
    local mat = CreateMaterial(mat_name, "VertexLitGeneric", mat_params)

    mat:SetInt("$halflambert", 1)
    mat:SetInt("$model", 1)
    mat:SetInt("$normalmapalphaenvmapmask", 1)
    mat:SetInt("$phong", 1)
    mat:SetVector("$phongfresnelranges", Vector(1, 1, 1))
    mat:SetInt("$rimlight", 1)
    mat:SetFloat("$rimlightexponent", 2)
    mat:SetFloat("$rimlightboost", 1)

    // $model + $envmapmode + $normalmapalphaenvmapmask + $opaquetexture + $softwareskin + $halflambert + $selfillum
    mat:SetInt("$flags", 2048 + 33554432 + 4194304 + 16777216 + 8388608)

    if MethData.material then
        if MethData.material.diff then mat:SetTexture("$basetexture",MethData.material.diff) end
        if MethData.material.nrm then mat:SetTexture("$bumpMap",MethData.material.nrm) end
    else
        mat:SetTexture("$basetexture","zerochain/props_methlab/meth/zmlab2_meth_cracked_diff")
        mat:SetTexture("$bumpMap","zerochain/props_methlab/meth/zmlab2_meth_cracked_nrm")
    end
    //mat:SetInt("$flags",2048 + 4194304 + 134217728 + 512 ) // model + normalmapalphaenvmapmask + halflambert + $multipass

    local qual_fract = (1 / 100) * MethQuality

    local col = MethData.color

    mat:SetFloat("$phongexponent",5 * qual_fract) // DOES NOT WORK
    mat:SetFloat("$phongboost",1 * qual_fract) // DOES NOT WORK
    mat:SetFloat("$envmapfresnel",1 * qual_fract)

    local h,s,v = ColorToHSV(col)
    s = s * qual_fract

    local reflect_strength = 0.25

    local col_vec = zmlab2.util.ColorToVector(HSVToColor(h,s,v))
    mat:SetVector("$phongtint",zmlab2.util.ColorToVector(col)) // DOES NOT WORK
    mat:SetVector("$envmaptint",Vector(col_vec.x * qual_fract * reflect_strength,col_vec.y * qual_fract * reflect_strength,col_vec.z * qual_fract * reflect_strength))
    mat:SetVector("$color2",col_vec)

    mat:Recompute()

    zmlab2.Meth.Materials[mat_name] = mat

    return mat_name
end

function zmlab2.Meth.GetValue(MethType,MethAmount,MethQuality)
    if MethType and MethAmount and MethQuality and zmlab2.config.MethTypes[MethType] and zmlab2.config.MethTypes[MethType].price then
        return (zmlab2.config.MethTypes[MethType].price * MethAmount) * ((1 / 100) * MethQuality)
    else
        return 0
    end
end

function zmlab2.Meth.GetMixTime(MethType)
    return zmlab2.config.MethTypes[MethType] and zmlab2.config.MethTypes[MethType].mix_time or 60
end

function zmlab2.Meth.GetVentTime(MethType)
    return zmlab2.config.MethTypes[MethType] and zmlab2.config.MethTypes[MethType].vent_time or 60
end

function zmlab2.Meth.GetFilterTime(MethType)
    return zmlab2.config.MethTypes[MethType] and zmlab2.config.MethTypes[MethType].filter_time or 60
end

function zmlab2.Meth.GetColor(MethType)
    return zmlab2.config.MethTypes[MethType] and zmlab2.config.MethTypes[MethType].color or Color(255,255,255,255)
end

function zmlab2.Meth.GetDifficulty(MethType)
    return zmlab2.config.MethTypes[MethType] and math.Clamp(zmlab2.config.MethTypes[MethType].difficulty or 1,1,10)
end

function zmlab2.Meth.GetName(MethType)
    return zmlab2.config.MethTypes[MethType] and zmlab2.config.MethTypes[MethType].name
end

--PATH addons/zeros_weedfarm/lua/zwf_languages/sh_zwf_language_dk.lua:
zwf = zwf or {}
zwf.language = zwf.language or {}

zwf.language.General = zwf.language.General or {}
zwf.language.Shop = zwf.language.Shop or {}
zwf.language.NPC = zwf.language.NPC or {}
zwf.language.VGUI = zwf.language.VGUI or {}
zwf.language.Settings = zwf.language.Settings or {}


if (zwf.config.SelectedLanguage == "dk") then

    zwf.language.General["Fuel"] = "Brændstof"

    zwf.language.General["THC"] = "THC"
    zwf.language.General["Remove"] = "Fjern"
    zwf.language.General["Splice"] = "Kombiner" // The splice button on the seed lab for creating new seeds

    zwf.language.General["Bad"] = "Dårlig"
    zwf.language.General["Good"] = "God"

    zwf.language.General["Collect"] = "Indsaml"

    zwf.language.General["Speed"] = "Fart"
    zwf.language.General["Productivity"] = "Produktivitet"
    zwf.language.General["AntiPlague"] = "Anti Pest"

    zwf.language.General["Water"] = "Vand"

    zwf.language.General["invalid_character"] = "Navnet har udgyldige tegn i sig!"
    zwf.language.General["name_too_short"] = "Navnet er for kort!"
    zwf.language.General["name_too_long"] = "Navnet er for langt!"

    zwf.language.General["Cancel"] = "Annuller"
    zwf.language.General["Enter"] = "Godkend"

    zwf.language.General["ItemBought"] = "Du købte $itemname for $currency$price!"


    zwf.language.General["seedlab_titlescreen"] = "Frø Lab" -- (READ!!) "Lab" would be the most commen word for it too in danish. If you want something more detailed you can use "Laboratorium" as well.
    zwf.language.General["seedlab_help"] = "Indtast plantens navn"

    zwf.language.General["watertank_refill"] = "Genopfyld"
    zwf.language.General["watertank_title"] = "Vandtank"

    zwf.language.General["bong_pickup_fail"] = "Du har allerede denne bong!"
    zwf.language.General["bong_no_weed"] = "Mangler Weed!" -- Also called weed in danish.


    zwf.language.General["generator_repair"] = "Reparer!"
    zwf.language.General["generator_start"] = "Start"
    zwf.language.General["generator_stop"] = "Stop"
    zwf.language.General["generator_nofuel"] = "Mangler Brændstof!"

    zwf.language.General["packingstation_info"] = "Tilføj glas med weed."
    zwf.language.General["packingstation_weedmix"] = "Weed Mix" // If the player mixes diffrent sorts of weed together then we change the name of the weed to this -- Mix is called the same in danish

    zwf.language.General["seedbank_full"] = "Frø bank er fuld!"

    zwf.language.General["plant_heal"] = "Helbred" // The heal button
    zwf.language.General["plant_harvest"] = "Høst" // The harvest button
    zwf.language.General["plant_infected"] = "Inficeret!" // Tells us that the plant is infected
    zwf.language.General["plant_postgrow"] = "Gylden Periode" // Tells us that the plant is in the post grow phase where it keeps growing till it reaches its max weedamount
    zwf.language.General["plant_empty"] = "Tom" // Tells the player that the flowerpot is empty

    zwf.language.General["not_enough_money"] = "Du har ikke råd til dette!"
    zwf.language.General["not_correct_rank"] = "Du har ikke det rigtige rang for dette!"
    zwf.language.General["entity_limit"] = "Du kan ikke spawne flere $itemname!"


    zwf.language.General["CableDistanceFail"] = "Genstandene er for lang væk fra hinanden!"

    zwf.language.General["BongSharingFail"] = "$PlayerName har allerede denne slags bong!"

    zwf.language.General["WeedBlock"] = "WeedBlok"

    zwf.language.General["WrongJob"] = "Du er ikke det rette job!"


    zwf.language.VGUI["Purchase"] = "Køb"
    zwf.language.VGUI["SellWeed"] = "Sælg Weed"
    zwf.language.VGUI["Drop"] = "Smid"
    zwf.language.VGUI["Delete"] = "Slet"
    zwf.language.VGUI["weedbuyer_title"] = "Weed Forhandler"
    zwf.language.VGUI["seedbank_title"] = "Frø Bank"
    zwf.language.VGUI["Strain"] = "Art"
    zwf.language.VGUI["Duration"] = "Varighed"
    zwf.language.VGUI["Difficulty"] = "sværhedsgrad"
    zwf.language.VGUI["HarvestAmount"] = "Høstmængde"
    zwf.language.VGUI["THCBoost"] = "THC Boost" -- "Boost" Is called the same in danish
    zwf.language.VGUI["GrowTimeBoost"] = "Vækst boost"
    zwf.language.VGUI["GrowAmountBoost"] = "Vækst beløb Boost"
    zwf.language.VGUI["THCBoost"] = "THC Boost"
    zwf.language.VGUI["SeedCount"] = "Frøantal"
    zwf.language.VGUI["PowerUsage"] = "Strømforbrug"
    zwf.language.VGUI["HeatProduction"] = "Varmeproduktion"
    zwf.language.VGUI["Ranks"] = "Påkrævede ranks" -- Most danish players would also use the english word for "ranks".
    zwf.language.VGUI["SeedName"] = "Frø Navn"




    zwf.language.NPC["title"] = "Weed Forhandler"
    zwf.language.NPC["profit"] = "Profit" -- Called the same in danish
    zwf.language.NPC["interact_fail"] = "Skrid med dig!"
    zwf.language.NPC["interact_noweed"] = "Kom tilbage når du har noget for mig!"



    zwf.language.Shop["title"] = "Weed Shop" -- If you want a direct translation of the word grow. It would be called "Gro Shop". But since it dosnt sound as good in danish as it does in english. I though it would change it to "Weed Shop" instead. "Shop" is called the same in danish.

    zwf.language.Shop["category_Equipment"] = "Udstyr"

    zwf.language.Shop["item_generator_title"] = "Generator"
    zwf.language.Shop["item_generator_desc"] = "Genererer strøm ved hjælp af brændstof."

    zwf.language.Shop["item_fuel_title"] = "Brændstof"
    zwf.language.Shop["item_fuel_desc"] = "Brændstof til generatoren."

    zwf.language.Shop["item_lamp01_desc"] = "Levere lys til planterne, men øger deres temperatur."
    zwf.language.Shop["item_lamp02_desc"] = "Levere lys til planterne uden at øge deres temperatur."

    zwf.language.Shop["item_ventilator_title"] = "Ventilator"
    zwf.language.Shop["item_ventilator_desc"] = "Sænker planternes temperatur."

    zwf.language.Shop["item_outlet_title"] = "Strømstik"
    zwf.language.Shop["item_outlet_desc"] = "Gør det muligt at forsyne flere maskiner med strøm."

    zwf.language.Shop["item_flowerpot01_title"] = "Blomsterkrukke"
    zwf.language.Shop["item_flowerpot01_desc"] = "Normal blomsterpotte til dyrkning af planter."

    zwf.language.Shop["item_flowerpot02_title"] = "Hydro Blomsterkrukke" -- "Hydro" is the correct word in danish as well.
    zwf.language.Shop["item_flowerpot02_desc"] = "Bruges til at dyrke planter. Kan tilsluttes en vandtank til automatisk vandforsyning."

    zwf.language.Shop["item_soil_title"] = "Jord"
    zwf.language.Shop["item_soil_desc"] = "Basismateriale til dyrkning af planter."

    zwf.language.Shop["item_watertank_title"] = "Vandtank"
    zwf.language.Shop["item_watertank_desc"] = "Producerer vand til planter."

    zwf.language.Shop["item_drystation_title"] = "Tørstation"
    zwf.language.Shop["item_drystation_desc"] = "Bruges til tørring af weed."

    zwf.language.Shop["item_packingtable_title"] = "Pakkebord"
    zwf.language.Shop["item_packingtable_desc"] = "Bruges til at pakke weed glas ind i en blok til transport."

    zwf.language.Shop["item_autopacker_title"] = "Automatisk Pakning"
    zwf.language.Shop["item_autopacker_desc"] = "Kan installeres på et pakkebord for at automatisere processen."

    zwf.language.Shop["item_seedlab_title"] = "Frø Lab"
    zwf.language.Shop["item_seedlab_desc"] = "Lader dig fremstille nye frø fra weed."

    zwf.language.Shop["item_seedbank_title"] = "Frø Bank"
    zwf.language.Shop["item_seedbank_desc"] = "Lader dig opbevare frø."

    zwf.language.Shop["item_palette_title"] = "Palle"
    zwf.language.Shop["item_palette_desc"] = "Bruges til at sælge blokke af weed til weed køberen."


    zwf.language.Shop["item_seed01_desc"] = "OG Kush er en legendarisk weed art med et navn, der anerkendes selv uden for cannabis verdenen."
    zwf.language.Shop["item_seed02_desc"] = "Bubba Kush er en tung Indica-hybrid, der ses med en meget bred popularitet."
    zwf.language.Shop["item_seed03_desc"] = "Sour Diesels energirige og posivtive følelse, gør det nemt at se, hvorfor arten nyder en popularitet over alle De Forenede Stater i USA."
    zwf.language.Shop["item_seed04_desc"] = "AK-47 er en Sativa-dominerende hybrid med en lys hvid farve."
    zwf.language.Shop["item_seed05_desc"] = "Genetikken fra Super Lemon Haze kombinerer en sød og syrlig oplevelse."
    zwf.language.Shop["item_seed06_desc"] = "Strawberry Cough er en forfriskende, smagsfokuseret sativa-hybrid."
    zwf.language.Shop["item_seed07_desc"] = "Den lilla karakteristik af denne art arves fra dens forfædre fra regionen Chitral i det pakistanske hindu Kush."
    -- Kept alle the names of the seeds types, sence it would make more sence to use them, rather than translating them all.
    zwf.language.Shop["category_Nutritions"] = "Gødning"

    zwf.language.Shop["item_nutrition01_desc"] = "Et lille vækst boost til din plante."
    zwf.language.Shop["item_nutrition02_desc"] = "Øger plantens væksthastighed temmelig meget."
    zwf.language.Shop["item_nutrition03_desc"] = "Et lille høst boost til din plante."
    zwf.language.Shop["item_nutrition04_desc"] = "Øger plantens høstmængde temmelig meget."
    zwf.language.Shop["item_nutrition05_desc"] = "Øger både høstmængden og væksthastighed en smule."
    zwf.language.Shop["item_nutrition06_desc"] = "Øger både høstmængden og væksthastighed temmelig meget."

    zwf.language.Shop["category_Seeds"] = "Frø"



    // Joint UPDATE
    zwf.language.General["joint_pickup_fail"] = "Du har allerede en joint!" -- Joint is called the same in danish
    zwf.language.General["JointSharingFail"] = "$PlayerName har allerede en joint!"

    zwf.language.NPC["question_01"] = "Hvad vil du have?"
    zwf.language.NPC["question_01_answer01"] = "Vil gerne købe en Bong"
    zwf.language.NPC["question_01_answer02"] = "Har noget Weed til dig"
    zwf.language.NPC["question_01_answer03"] = "Intet"

    zwf.language.NPC["question_02"] = "Hvilken en vil du have?"
    zwf.language.NPC["question_02_answer01"] = "Gå tilbage" // This is the Back button on the NPC BongShop interface

end

--PATH addons/zeros_weedfarm/lua/zweedfarm/sh/zwf_higheffects.lua:
zwf = zwf or {}
zwf.f = zwf.f or {}

if SERVER then

	//Screeneffects
	util.AddNetworkString("zwf_start_screeneffect")
	function zwf.f.CreateHighEffect(effectID,THC,Duration,ply)

		local effectData = {
			id = effectID,
			thc = THC,
			duration = Duration,
		}

		net.Start("zwf_start_screeneffect")
		net.WriteTable(effectData)
		net.Send(ply)
	end

	util.AddNetworkString("zwf_stop_screeneffect")
	function zwf.f.RemoveHighEffect(ply)
		if IsValid(ply) then
			net.Start("zwf_stop_screeneffect")
			net.Send(ply)
		end
	end
end

if CLIENT then

	// Screeneffects
	local effect_id = 0
	local effect_duration = 0
	local effect_strength = 0
	local effect_intensity = 0

	//Starts our screeneffect
	net.Receive("zwf_start_screeneffect", function(len)

		local effectData = net.ReadTable()

		if effectData == nil or effectData.id == nil or effectData.thc == nil or effectData.duration == nil then return end

		effect_id = effectData.id
		effect_intensity = effectData.thc
		effect_duration = effect_duration + ( 100 * effectData.duration)

		effect_duration = math.Clamp(effect_duration,0,100 * zwf.config.HighEffect.MaxDuration)
	end)

	//Stops our screeneffect
	net.Receive("zwf_stop_screeneffect", function(len)
		effect_duration = 0
		effect_strength = 0
		effect_intensity = 0
		effect_id = 0
		LocalPlayer():SetDSP(0,true)
		if LocalPlayer().zwf_WeedSoundObj and LocalPlayer().zwf_WeedSoundObj:IsPlaying() == true then
			LocalPlayer().zwf_WeedSoundObj:Stop()
		end
	end)

	function zwf.f.HasPlayerHighEffects()
		return effect_id > 0 or effect_duration > 0
	end

	if timer.Exists("zwf_screeneffect_counter") then
		timer.Remove("zwf_screeneffect_counter")
	end

	timer.Create("zwf_screeneffect_counter", 0.1, 0, function()
		if (effect_duration or 0) > 0 then
			effect_duration = effect_duration - 10
		else

			if zwf.f.HasPlayerHighEffects() and IsValid(LocalPlayer()) then
				LocalPlayer():SetDSP(0,true)
				effect_id = 0
				effect_duration = 0
			end
		end
	end)


	function zwf.f.WeedMusic()

		if zwf.config.Plants[effect_id] == nil or zwf.config.Plants[effect_id].high_music == nil then return end

		local ply = LocalPlayer()
		local weedsound = CreateSound(ply, "zwf_weedmusic0" .. effect_id)


		if effect_duration > 0 then
			if ply.zwf_WeedSoundObj == nil then
				ply.zwf_WeedSoundObj = weedsound
			end

			if ply.zwf_WeedSoundObj:IsPlaying() == false then
				ply.zwf_WeedSoundObj:Play()
				ply.zwf_WeedSoundObj:ChangeVolume(0, 0)
				ply.zwf_WeedSoundObj:ChangeVolume(1, 2)
			end

		else
			if ply.zwf_WeedSoundObj == nil then
				ply.zwf_WeedSoundObj = weedsound
			end

			if ply.zwf_WeedSoundObj:IsPlaying() == true then
				ply.zwf_WeedSoundObj:ChangeVolume(0, 2)
				if ((lastSoundStop or CurTime()) > CurTime()) then return end
				lastSoundStop = CurTime() + 3

				timer.Simple(2, function()
					if IsValid(ply) and ply.zwf_WeedSoundObj and effect_duration <= 0 then
						ply.zwf_WeedSoundObj:Stop()
					end
				end)
			end
		end
	end

	hook.Add("RenderScreenspaceEffects", "a_zwf_HighEffect_RenderScreenspaceEffects", function()

		zwf.f.WeedMusic()

		if (effect_duration or 0) > 0 then


			effect_strength = math.Clamp(effect_strength + 100 * FrameTime(),0,effect_duration)

			local strength = math.Clamp((1 / 300) * effect_strength,0,1)


			if IsValid(LocalPlayer()) and effect_intensity > 5 then

				if effect_intensity >= zwf.config.Growing.max_thc * 0.75 then
					LocalPlayer():SetDSP(25,true)
				elseif effect_intensity > zwf.config.Growing.max_thc * 0.5 then
					LocalPlayer():SetDSP(20,true)
				elseif effect_intensity > zwf.config.Growing.max_thc * 0.25 then
					LocalPlayer():SetDSP(3,true)
				elseif effect_intensity > 0 then
					LocalPlayer():SetDSP(15,true)
				end

			end

			local effectData = zwf.config.HighEffect.Effects[zwf.config.Plants[effect_id].high_effect]

			local bloom_strength = 1 / 10 * effect_intensity
			DrawBloom(0, math.Clamp(bloom_strength, 0, 1) * strength, math.Clamp(bloom_strength, 0, 1.5) * strength, math.Clamp(bloom_strength, 0, 1.5) * strength, 15, 0.1, effectData.bloom[1], effectData.bloom[2], effectData.bloom[3])

			local tab = {
				["$pp_colour_addr"] = math.Clamp(math.Clamp(effectData.colormodify["pp_colour_addr"], 0, 1) * strength,0.4,1),
				["$pp_colour_addg"] = math.Clamp(math.Clamp(effectData.colormodify["pp_colour_addg"], 0, 1) * strength,0.4,1),
				["$pp_colour_addb"] = math.Clamp(math.Clamp(effectData.colormodify["pp_colour_addb"], 0, 1) * strength,0.4,1),

				["$pp_colour_brightness"] = effectData.colormodify["pp_colour_brightness"],
				["$pp_colour_contrast"] = math.Clamp(effectData.colormodify["pp_colour_contrast"] * strength,1,2),
				["$pp_colour_colour"] = math.Clamp(effectData.colormodify["pp_colour_colour"] * strength,1,2),

				["$pp_colour_mulr"] = math.Clamp(effectData.colormodify["pp_colour_mulr"], 0, 1),
				["$pp_colour_mulg"] = math.Clamp(effectData.colormodify["pp_colour_mulg"], 0, 1),
				["$pp_colour_mulb"] = math.Clamp(effectData.colormodify["pp_colour_mulb"], 0, 1)
			}

			DrawColorModify(tab)

			local blur_strength = 1 / 25 * effect_intensity
			DrawMotionBlur(math.Clamp(blur_strength, 0, 0.1) * strength, math.Clamp(blur_strength, 0, 2) * strength, 0.01)


			// Display material
			if GetConVar("zwf_cl_vfx_epilepsy"):GetInt() == 0 then

				local count = math.Clamp(math.Round((effect_intensity / 40) * strength), 0, 5)

				for i = 1, count do
					DrawMaterialOverlay(effectData.mat, 0)
				end

				// The refract material
				local ref_strength = (0.05 / zwf.config.Growing.max_thc) * effect_intensity
				ref_strength = ref_strength * strength
				DrawMaterialOverlay(effectData.warp_mat, math.Clamp(ref_strength,0,0.03))
			end
		end
	end)
end

--PATH addons/zeros_weedfarm/lua/zweedfarm/sh/zwf_soundlibary.lua:
zwf = zwf or {}
zwf.f = zwf.f or {}
zwf.sounds = zwf.sounds or {}

zwf.GlobalSounds = {
	["zwf_cash01"] = Sound("zwf/zwf_cash01.wav"),
}

zwf_SoundVolume = 1

// This packs the requested sound Data
function zwf.f.CatchSound(id)
	local soundData = {}
	local soundTable = zwf.sounds[id]
	soundData.sound = soundTable.paths[math.random(#soundTable.paths)]
	soundData.lvl = soundTable.lvl
	soundData.pitch = math.Rand(soundTable.pitchMin, soundTable.pitchMax)
	local vol = 1
	if CLIENT then
		vol = zwf_SoundVolume
	end
	soundData.volume = vol * soundTable.pref_volume

	return soundData
end

function zwf.f.EmitSoundENT(id, ent)
	local soundData = zwf.f.CatchSound(id)
	EmitSound(soundData.sound, ent:GetPos(), ent:EntIndex(), CHAN_STATIC, soundData.volume, soundData.lvl, 0, soundData.pitch)
end

// Gets called when the player changes the volume
function zwf.f.VolumeChanged(old_volume,new_volume)

	zwf_SoundVolume =  new_volume

	if timer.Exists( "zwf_loopedsound_updater" ) then
		timer.Remove( "zwf_loopedsound_updater" )
	end

	timer.Create( "zwf_loopedsound_updater", 0.25, 1, function()

		if timer.Exists( "zwf_loopedsound_updater" ) then
			timer.Remove( "zwf_loopedsound_updater" )
		end

		zwf.f.Update_LoopedSound_Volume()
	end )
end

// Updates the looped sounds for all entites near the player
function zwf.f.Update_LoopedSound_Volume()
	local ply_pos = LocalPlayer():GetPos()

	for k, v in pairs(zwf.EntList) do
		if IsValid(v) and zwf.f.InDistance(ply_pos, v:GetPos(), 1000) and zwf.f.FunctionValidater(v.OnVolumeChange) then
			v:OnVolumeChange()
		end
	end
end


// Generic
sound.Add({
	name = "zwf_cough",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 60,
	pitch = {90, 110},
	sound = {"zwf/zwf_cough.wav"}
})

// Generic
sound.Add({
	name = "zwf_ui_click",
	channel = CHAN_STATIC,
	volume = 1,
	level = 60,
	pitch = {100, 100},
	sound = {"UI/buttonclick.wav"}
})

// Sniff Swep
zwf.sounds["zwf_sniff"] = {
	paths = {"zwf/zwf_sniff01.wav","zwf/zwf_sniff02.wav"},
	lvl = 60,
	pitchMin = 95,
	pitchMax = 105,
	pref_volume = 1
}


// NPC
zwf.sounds["zwf_selling"] = {
	paths = {"zwf/zwf_cash01.wav"},
	lvl = 70,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_npc_wrongjob"] = {
	paths = {"vo/npc/male01/pardonme01.wav", "vo/npc/male01/pardonme02.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_npc_sell"] = {
	paths = {"vo/NovaProspekt/eli_foundme02.wav", "vo/npc/male01/question02.wav", "vo/npc/male01/question03.wav", "vo/npc/male01/question04.wav", "vo/npc/male01/question05.wav", "vo/npc/male01/question06.wav", "vo/npc/male01/question09.wav", "vo/npc/male01/question10.wav", "vo/npc/male01/question13.wav", "vo/npc/male01/question16.wav", "vo/npc/male01/question17.wav", "vo/npc/male01/question18.wav", "vo/npc/male01/question19.wav", "vo/npc/male01/question23.wav", "vo/npc/male01/question25.wav", "vo/npc/male01/question27.wav", "vo/npc/male01/question28.wav", "vo/npc/male01/question29.wav", "vo/npc/male01/question30.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}


// WaterTank
zwf.sounds["zwf_water_refill"] = {
	paths = {"ambient/water/water_splash1.wav", "ambient/water/water_splash2.wav", "ambient/water/water_splash3.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}


// PackingStation
zwf.sounds["zwf_weed_pack"] = {
	paths = {"zwf/zwf_weed_pack.wav"},
	lvl = 60,
	pitchMin = 95,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_place_jar"] = {
	paths = {"zwf/zwf_place_jar.wav"},
	lvl = 60,
	pitchMin = 99,
	pitchMax = 100,
	pref_volume = 1
}


// Plants
zwf.sounds["zwf_cut_plant"] = {
	paths = {"zwf/zwf_plant_cut.wav"},
	lvl = 70,
	pitchMin = 90,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_plant_heal"] = {
	paths = {"zwf/zwf_plant_heal.wav"},
	lvl = 60,
	pitchMin = 90,
	pitchMax = 100,
	pref_volume = 1
}
sound.Add({
	name = "zwf_plant_plague",
	channel = CHAN_STATIC,
	volume = 0.5,
	level = 60,
	pitch = {100, 100},
	sound = {"zwf/zwf_plant_plague.wav"}
})


// Buttons
zwf.sounds["zwf_button_on"] = {
	paths = {"buttons/button24.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_button_off"] = {
	paths = {"buttons/button16.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}


// Cable Swep
zwf.sounds["zwf_cable_select"] = {
	paths = {"UI/buttonclick.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_cable_connect"] = {
	paths = {"weapons/ar2/ar2_reload_push.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_cable_deconnect"] = {
	paths = {"weapons/357/357_reload4.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}


// High Music
for k, v in pairs(zwf.config.Plants) do
	if v.high_music ~= nil and v.high_music ~= "" and v.high_music ~= " " then
		sound.Add({
			name = "zwf_weedmusic0" .. k,
			channel = CHAN_STATIC,
			volume = 0.25,
			level = 80,
			pitch = {100, 100},
			sound = v.high_music
		})
	end
end


// SeedLab
sound.Add({
	name = "zwf_seedlab_scan",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 50,
	pitch = {100, 100},
	sound = {"npc/scanner/combat_scan_loop6.wav"}
})


// Ventilator
sound.Add({
	name = "zwf_ventilator_loop",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 50,
	pitch = {100, 100},
	sound = {"zwf/zwf_ventilator_loop.wav"}
})


// Generator
sound.Add({
	name = "zwf_generator_running",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 60,
	pitch = {100, 100},
	sound = {"zwf/zwf_generator_running.wav"}
})
sound.Add({
	name = "zwf_generator_damaged",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 60,
	pitch = {100, 100},
	sound = {"zwf/zwf_generator_damaged.wav"}
})
zwf.sounds["zwf_generator_repair"] = {
	paths = {"zwf/zwf_generator_repair.wav"},
	lvl = 60,
	pitchMin = 90,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_generator_start_fail"] = {
	paths = {"zwf/zwf_generator_start_fail.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_generator_start_sucess"] = {
	paths = {"zwf/zwf_generator_start_sucess.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_generator_stop"] = {
	paths = {"zwf/zwf_generator_stop.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_fuel_fill"] = {
	paths = {"zwf/zwf_gas_can_fill_01.wav"},
	lvl = 50,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}


// Lamp
sound.Add({
	name = "zwf_lamp_sodium_loop",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 45,
	pitch = {100, 100},
	sound = {"zwf/zwf_lamp_sodium_loop.wav"}
})
sound.Add({
	name = "zwf_lamp_led_loop",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 45,
	pitch = {100, 100},
	sound = {"zwf/zwf_lamp_led_loop.wav"}
})
zwf.sounds["zwf_lamp_sodium_start"] = {
	paths = {"zwf/zwf_lamp_sodium_start.wav"},
	lvl = 45,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_lamp_sodium_stop"] = {
	paths = {"zwf/zwf_lamp_sodium_stop.wav"},
	lvl = 45,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}


// Bong
sound.Add({
	name = "zwf_igniter_lit",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 60,
	pitch = {100, 100},
	sound = {"zwf/zwf_igniter_lit.wav"}
})
sound.Add({
	name = "zwf_bong_end",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 60,
	pitch = {100, 100},
	sound = {"zwf/zwf_bong_end.wav"}
})
sound.Add({
	name = "zwf_bong_loop",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 60,
	pitch = {100, 100},
	sound = {"zwf/zwf_bong_loop.wav"}
})
zwf.sounds["zwf_bong_exhale_short"] = {
	paths = {"zwf/zwf_bong_exhale_short.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_bong_exhale_mid"] = {
	paths = {"zwf/zwf_bong_exhale_mid.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_bong_exhale_long"] = {
	paths = {"zwf/zwf_bong_exhale_long.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}


// WateringCan
sound.Add({
	name = "zwf_watering_loop",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 60,
	pitch = {100, 100},
	sound = {"zwf/zwf_watering.wav"}
})


// Joint
sound.Add({
	name = "zwf_joint_loop",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 60,
	pitch = {100, 100},
	sound = {"zwf/zwf_joint_loop.wav"}
})
zwf.sounds["zwf_joint_start"] = {
	paths = {"zwf/zwf_joint_start.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_joint_stop"] = {
	paths = {"zwf/zwf_joint_stop.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}


// DoobyTable
zwf.sounds["zwf_grab_weed"] = {
	paths = {"zwf/zwf_grab_weed.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}

zwf.sounds["zwf_grab_paper"] = {
	paths = {"zwf/zwf_grab_paper.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_paper_close"] = {
	paths = {"zwf/zwf_paper_close.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_paper_open"] = {
	paths = {"zwf/zwf_paper_open.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}

zwf.sounds["zwf_grinder_open"] = {
	paths = {"zwf/zwf_grinder_open.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_grinder_close"] = {
	paths = {"zwf/zwf_grinder_close.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_grinder_grind"] = {
	paths = {"zwf/zwf_grinder_grind.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}

zwf.sounds["zwf_joint_foldstage"] = {
	paths = {"zwf/zwf_joint_fold01.wav","zwf/zwf_joint_fold02.wav","zwf/zwf_joint_fold03.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_joint_fold_finish"] = {
	paths = {"zwf/zwf_joint_fold_finish.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}



// Muffin
zwf.sounds["zwf_muffin_eat"] = {
	paths = {"zwf/zwf_muffin_eat.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}



// Cooking
zwf.sounds["zwf_cooking_dough"] = {
	paths = {"zwf/zwf_cooking_dough.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_cooking_flour"] = {
	paths = {"zwf/zwf_cooking_flour.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_mixer_close"] = {
	paths = {"zwf/zwf_mixer_close.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
sound.Add({
	name = "zwf_mixer_loop",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 60,
	pitch = {100, 100},
	sound = {"zwf/zwf_mixer_loop.wav"}
})
zwf.sounds["zwf_mixer_open"] = {
	paths = {"zwf/zwf_mixer_open.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_mixerbowl_add"] = {
	paths = {"zwf/zwf_mixerbowl_add.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_mixerbowl_remove"] = {
	paths = {"zwf/zwf_mixerbowl_remove.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_oven_close"] = {
	paths = {"zwf/zwf_oven_close.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
zwf.sounds["zwf_oven_open"] = {
	paths = {"zwf/zwf_oven_open.wav"},
	lvl = 60,
	pitchMin = 100,
	pitchMax = 100,
	pref_volume = 1
}
sound.Add({
	name = "zwf_oven_loop",
	channel = CHAN_STATIC,
	volume = 1.0,
	level = 60,
	pitch = {100, 100},
	sound = {"zwf/zwf_oven_loop.wav"}
})

--PATH addons/zeros_weedfarm/lua/zweedfarm/cl/zwf_cable_cl.lua:
if not CLIENT then return end
zwf = zwf or {}
zwf.f = zwf.f or {}
zwf.f.Cable = zwf.f.Cable or {}


local zwf_generators = {
	["zwf_generator"] = true,
	["zwf_lamp"] = true,
	["zwf_ventilator"] = true,
	["zwf_outlet"] = true,

	["zwf_watertank"] = true,
	["zwf_pot_hydro"] = true,
}

local zwf_EnergyUser = {
	["zwf_lamp"] = true,
	["zwf_ventilator"] = true,
	["zwf_outlet"] = true,

	["zwf_pot_hydro"] = true,
}

local zwf_CPoints = {
	["zwf_generator"] = {
		output = Vector(-9, 19, 16)
	},
	["zwf_lamp"] = {
		[1] = {
			input = Vector(39, 0, 0),
			output = Vector(-27, 0, 0)
		},
		[2] = {
			input = Vector(39, 0, 0),
			output = Vector(-44, 0, 0)
		}
	},
	["zwf_ventilator"] = {
		input = Vector(0, -3, 26),
		output = Vector(0, -3, 26)
	},
	["zwf_outlet"] = {
		input = Vector(-9.5, 0, 3),
		output = {
			[1] = Vector(-6, 0, 5),
			[2] = Vector(0, 0, 5),
			[3] = Vector(6, 0, 5),
		}
	},


	["zwf_watertank"] = {
		output = Vector(0, 34, 16)
	},
	["zwf_pot_hydro"] = {
		input = Vector(13, 0, 12.5),
		output = Vector(-13, 0, 12.5)
	},
}

local rope_render_distance = 500



// Tells use if the provided entity has a output entity, which means it has a connection
function zwf.f.Cable.HasConnection(ent)
	local HasConnection = false
	local class = ent:GetClass()

	if class == "zwf_generator" then
		HasConnection = IsValid(ent:GetOutput())
	elseif class == "zwf_lamp" then
		HasConnection = IsValid(ent:GetOutput())
	elseif class == "zwf_ventilator" then
		HasConnection = IsValid(ent:GetOutput())
	elseif class == "zwf_outlet" then
		if IsValid(ent:GetOutput01()) or IsValid(ent:GetOutput02()) or IsValid(ent:GetOutput03()) then
			HasConnection = true
		end


	elseif class == "zwf_watertank" then
		HasConnection = IsValid(ent:GetOutput())
	elseif class == "zwf_pot_hydro" then
		HasConnection = IsValid(ent:GetOutput())
	end

	return HasConnection
end


// Gets all the entites in radius that have a connection and generates the "ConnectedEntities" table
function zwf.f.Cable.Cache_Client()
	local ply = LocalPlayer()

	for k, v in pairs(zwf.EntList) do
		if not IsValid(v) then continue end

		if zwf.f.InDistance(v:GetPos(), ply:GetPos(), rope_render_distance) == false or zwf.f.Cable.HasConnection(v) == false then
			v.Cached_Rope = false
			continue
		end

		if v.Cached_Rope == true then
			continue
		end

		local input = v
		if v:GetClass() == "zwf_outlet" then

			v.ConnectedEntities = {}

			for i = 1, 3 do
				local output

				if i == 1 then
					output = v:GetOutput01()
				elseif i == 2 then
					output = v:GetOutput02()
				elseif i == 3 then
					output = v:GetOutput03()
				end

				if IsValid(output) then
					local genOutPos = zwf_CPoints[v:GetClass()].output[i]
					local entInPos = zwf_CPoints[output:GetClass()].input

					if output:GetClass() == "zwf_lamp" then
						local lampid = output:GetLampID()
						entInPos = zwf_CPoints["zwf_lamp"][lampid].input
					else
						entInPos = zwf_CPoints[output:GetClass()].input
					end

					table.insert(v.ConnectedEntities, {
						ent = output,
						RopeStart = genOutPos,
						RopeEnd = entInPos
					})
				end
			end

			v.Cached_Rope = true
			v.RopeRefresh = true

			zwf.f.Debug(v:GetClass() .. "[" .. v:EntIndex() .. "]: " .. "Cached_Rope")
		else

			local output = v:GetOutput()

			if IsValid(output) then
				local genOutPos
				local entInPos

				if input:GetClass() == "zwf_lamp" then
					local lampid = input:GetLampID()
					genOutPos = zwf_CPoints["zwf_lamp"][lampid].output
				else
					 genOutPos = zwf_CPoints[input:GetClass()].output
			 	end

				if output:GetClass() == "zwf_lamp" then
					local lampid = output:GetLampID()
					entInPos = zwf_CPoints["zwf_lamp"][lampid].input
				else
					entInPos = zwf_CPoints[output:GetClass()].input
				end


				v.ConnectedEntities = {}

				table.insert(v.ConnectedEntities, {
					ent = output,
					RopeStart = genOutPos,
					RopeEnd = entInPos
				})

				v.Cached_Rope = true
				v.RopeRefresh = true
				zwf.f.Debug(v:GetClass() .. "[" .. v:EntIndex() .. "]: " .. "Cached_Rope")
			end
		end


	end
end
hook.Add("Think", "a_zwf_think_cables_cl", zwf.f.Cable.Cache_Client)

if zwf_ropes == nil then
	zwf_ropes = {}
end


local length = 10
local gravity = Vector(0, 0, -10)
local damping = 0.7

// Builds the Rope points for the ConnectedEntities for the entity
function zwf.f.BuildRopeData(Generator)
	if Generator.ConnectedEntities == nil then return end

	local genID = Generator:EntIndex()

	zwf_ropes[genID] = {}

	for k, v in pairs(Generator.ConnectedEntities) do
		local ent = v.ent
		if IsValid(ent) then

			// This rebuilds the rope points
			local machineID = ent:EntIndex()

			zwf_ropes[genID][machineID] = {}

			for point = 1, length do
				zwf_ropes[genID][machineID][point] = {
					position = Generator:LocalToWorld(v.RopeStart),
					velocity = ent:GetVelocity()
				}
			end

			local rp = zwf_ropes[genID][machineID]

			if rp and table.Count(rp) > 0 then
				rp[1].position = Generator:LocalToWorld(v.RopeStart)
				rp[length].position = ent:LocalToWorld(v.RopeEnd)
			end
		end
	end

	zwf.f.Debug("zwf.f.BuildRopeData for " .. Generator:GetClass() .. "[" .. genID .. "]")
end

// Updates the Rope points to move physicly
function zwf.f.UpdateRopePhysics(Generator)

	local genID = Generator:EntIndex()

	if zwf_ropes[genID] == nil then return end

	for k, v in pairs(Generator.ConnectedEntities) do
		local ent = v.ent
		if IsValid(ent) then

			// This makes the rope be more physical
			local machineID = ent:EntIndex()

			local rp = zwf_ropes[genID][machineID]
			if rp and table.Count(rp) > 0 then

				rp[1].position = Generator:LocalToWorld(v.RopeStart)
				rp[length].position = ent:LocalToWorld(v.RopeEnd)

				for point = 1, length do

					local position1 = rp[math.Clamp(point - 1, 1, length)].position - rp[point].position
					local length1 = math.max(position1:Length(), 1)
					local position2 = rp[math.Clamp(point + 1, 1, length)].position - rp[point].position
					local length2 = math.max(position2:Length(), 1)
					local velocity = (position1 / length1) + (position2 / length2) + (gravity * 0.001)

					rp[point].velocity = rp[point].velocity * damping  + (velocity * 0.3)
					rp[point].position = rp[point].position + rp[point].velocity
				end
			end
		end
	end
end

net.Receive( "zwf_cable_update", function( len, pl )
	local ent = net.ReadEntity()
	if IsValid(ent) then
		ent.Cached_Rope = false
	end
end )

function zwf.f.UpdateRopeData()

	// Cleans up the rope table if some entity becomes invalid
	for k, v in pairs(zwf_ropes) do
		local generator = Entity(k)

		if IsValid(generator) and zwf_generators[generator:GetClass()] then

			for i,o in pairs(zwf_ropes[k]) do

				local machine = Entity(i)
				if IsValid(machine) and zwf_EnergyUser[machine:GetClass()] then
					if o == nil or table.Count(o) < 0 then
						zwf_ropes[k][i] = nil
					end
				else
					zwf_ropes[k][i] = nil
				end
			end
		else
			zwf_ropes[k] = nil
		end
	end

	for k, v in pairs(zwf.EntList) do
		if IsValid(v) and zwf_generators[v:GetClass()] then
			local genID = v:EntIndex()

			if zwf.f.InDistance(v:GetPos(), LocalPlayer():GetPos(), rope_render_distance) and zwf.f.Cable.HasConnection(v) then

				if v.RopeRefresh then

					zwf.f.BuildRopeData(v)
					v.RopeRefresh = false
				else

					zwf.f.UpdateRopePhysics(v)
				end
			else
				v.RopeRefresh = true
				zwf_ropes[genID] = nil
			end
		end
	end
end





local material = Material("cable/new_cable_lit")
function zwf.f.RenderRope(ropePoints,color,size)
	cam.Start3D(EyePos(), EyeAngles())
		render.SetMaterial(material)
		render.StartBeam(length)

		for point = 1, length do
			if ropePoints[point] then
				render.AddBeam(ropePoints[point].position, size, 0.25, color)
			end
		end

		render.EndBeam()
	cam.End3D()
end

hook.Add("RenderScreenspaceEffects", "a_zwf_renderscreenspaceeffects_rope", function()

	// This creates/updates the ropes
	zwf.f.UpdateRopeData()


	// This renders the rope per frame
	for k, v in pairs(zwf_ropes) do
		local gen = Entity(k)
		local color = zwf.default_colors["white01"]
		local size = 1

		if gen:GetClass() == "zwf_generator" or gen:GetClass() == "zwf_lamp" or gen:GetClass() == "zwf_ventilator" or gen:GetClass() == "zwf_outlet" then
			color = zwf.default_colors["cable"]
			size = 1
		else
			color = zwf.default_colors["water"]
			size = 2
		end

		for i, o in pairs(zwf_ropes[k]) do
			zwf.f.RenderRope(o,color,size)
		end
	end
end)

--PATH addons/zeros_weedfarm/lua/zweedfarm/cl/zwf_shop_vgui.lua:
if not CLIENT then return end

local wMod = ScrW() / 1920
local hMod = ScrH() / 1080

local zwf_ShopMenu = {}
local zwf_ShopMain = {}


zwf_player_SELECTED_ITEM = 1
zwf_player_SELECTED_CATERGORY = 1
zwf_player_SELECTED_TIME = 1

/////////// General
local function zwf_OpenUI()

	if not IsValid(zwf_ShopMenu_panel) then

		zwf_ShopMenu_panel = vgui.Create("zwf_vgui_ShopMenu")
	end

end

local function zwf_CloseUI()

	if IsValid(zwf_ShopMenu_panel) then
		zwf_ShopMenu_panel:Remove()
	end
end
///////////



// This closes the shop interface
net.Receive("zwf_Shop_Close_net", function(len)
	zwf_CloseUI()
end)

// This opens the shop interface
net.Receive("zwf_Shop_Open_net", function(len)
	zwf_OpenUI()
end)


/////////// Init
function zwf_ShopMenu:Init()
	self:SetSize(1384 * wMod, 830 * hMod)
	self:Center()

	self:MakePopup(false)

	self:SetKeyboardInputEnabled()
	self:SetMouseInputEnabled(true)

	zwf_ShopMain.Title = vgui.Create("DLabel", self)
	zwf_ShopMain.Title:SetPos(195 * wMod, 80 * hMod)
	zwf_ShopMain.Title:SetSize(600 * wMod, 125 * hMod)
	zwf_ShopMain.Title:SetFont("zwf_vgui_font03")
	zwf_ShopMain.Title:SetText(zwf.language.Shop["title"])
	zwf_ShopMain.Title:SetColor(zwf.default_colors["white01"])

	zwf_ShopMain.close = vgui.Create("DButton", self)
	zwf_ShopMain.close:SetText("")
	zwf_ShopMain.close:SetPos(1140 * wMod, 115 * hMod)
	zwf_ShopMain.close:SetSize(50 * wMod, 50 * hMod)
	zwf_ShopMain.close.DoClick = function()
		zwf_CloseUI()
	end
	zwf_ShopMain.close.Paint = function(s,w, h)


		if zwf_ShopMain.close:IsHovered() then
			draw.RoundedBox(10, 0 , 0, w, h,  zwf.default_colors["black03"])
		else
			draw.RoundedBox(10, 0 , 0, w, h,  zwf.default_colors["black06"])
		end



		if zwf_ShopMain.close:IsHovered() then
			draw.DrawText("X", "zwf_vgui_font03", 25 * wMod, 4 * hMod, zwf.default_colors["white01"], TEXT_ALIGN_CENTER)
		else
			draw.DrawText("X", "zwf_vgui_font03", 25 * wMod, 4 * hMod, zwf.default_colors["black06"], TEXT_ALIGN_CENTER)
		end
	end



	zwf_ProductCategoryButtons(self)

	zwf_ProductList(self)

	zwf_ProductPanel(self)
end

function zwf_ShopMenu:Paint(w, h)
	//draw.RoundedBox(15, 0 , 0, w, h,  zwf.default_colors["gray01"])

	surface.SetDrawColor(255,255,255,255)
	surface.SetMaterial(zwf.default_materials["tablet_interface"])
	surface.DrawTexturedRect(0, 0, w, h)
end

function zwf_ProductCategoryButtons(parent)
	zwf_ShopMain.ButtonPanel = vgui.Create("Panel", parent)
	zwf_ShopMain.ButtonPanel:SetPos(187 * wMod, 170 * hMod)
	zwf_ShopMain.ButtonPanel:SetSize(1010 * wMod, 50 * hMod)
	zwf_ShopMain.ButtonPanel.Paint = function(s, w, h)
		surface.SetDrawColor(0,0,0, 125)
		surface.SetMaterial(zwf.default_materials["square"])
		surface.DrawTexturedRect(0, 0, w, h)
	end

	zwf_ShopMain.ButtonList = vgui.Create("DIconLayout", zwf_ShopMain.ButtonPanel)
	zwf_ShopMain.ButtonList:SetSize(1000 * wMod, 50 * hMod)
	zwf_ShopMain.ButtonList:SetPos(15 * wMod, 0 * hMod)
	zwf_ShopMain.ButtonList:SetSpaceX(10)
	zwf_ShopMain.ButtonList:SetAutoDelete(true)
	zwf_ShopMain.ButtonList.Paint = function(self, w, h)
	end


	zwf_ProductCategory = {}
	local shopData = zwf.config.Shop
	for i = 1, table.Count(shopData) do
		zwf_ProductCategory[i] = zwf_ShopMain.ButtonList:Add("DButton")
		zwf_ProductCategory[i]:SetText("")
		zwf_ProductCategory[i]:SetSize(200 * wMod,zwf_ShopMain.ButtonList:GetTall())
		zwf_ProductCategory[i]:SetVisible(true)
		zwf_ProductCategory[i].DoClick = function()
			zwf_player_SELECTED_CATERGORY = i
			zwf_player_SELECTED_ITEM = 1

			zwf_ProductList(parent)
			zwf_ProductPanel(parent)
			surface.PlaySound("UI/buttonclick.wav")
		end

		zwf_ProductCategory[i].Paint = function(s, w, h)
			if i == zwf_player_SELECTED_CATERGORY then
				draw.RoundedBox(5, 0 , 0, w, h,  zwf.default_colors["red06"])
			else
				if zwf_ProductCategory[i]:IsHovered() then
					draw.RoundedBox(5, 0 , 0, w, h,  zwf.default_colors["black06"])
				else
					draw.RoundedBox(5, 0 , 0, w, h,  zwf.default_colors["black03"])

				end
			end

			surface.SetFont("zwf_vgui_font01")

			local text = shopData[i].title
			local tw, th = surface.GetTextSize(text)
			surface.SetTextPos(100 * wMod - (tw / 2), 26 * hMod - (th / 2))
			surface.SetTextColor(255, 255, 255, 255)
			surface.DrawText(text)
		end
	end
end

function zwf_ProductList(parent)

	local ItemsData = zwf.config.Shop[zwf_player_SELECTED_CATERGORY]

	if (zwf_MainShopList and IsValid(zwf_MainShopList.ProductPanel)) then
		zwf_MainShopList.ProductPanel:Remove()
	end

	zwf_MainShopList = {}

	zwf_MainShopList.ProductPanel = vgui.Create("Panel", parent)
	zwf_MainShopList.ProductPanel:SetPos(187 * wMod, 241 * hMod)
	zwf_MainShopList.ProductPanel:SetSize(300 * wMod, 478 * hMod)
	zwf_MainShopList.ProductPanel.Paint = function(s, w, h)
		surface.SetDrawColor(0, 0 ,0, 125)
		surface.SetMaterial(zwf.default_materials["square"])
		surface.DrawTexturedRect(0, 0, w, h)
	end

	zwf_MainShopList.scrollpanel = vgui.Create("DScrollPanel", zwf_MainShopList.ProductPanel)
	zwf_MainShopList.scrollpanel:DockMargin(0 * wMod, 0 * hMod, 15 * wMod, 0 * hMod)
	zwf_MainShopList.scrollpanel:Dock(FILL)
	local sbar01 = zwf_MainShopList.scrollpanel:GetVBar()
	function sbar01:Paint( w, h )
		draw.RoundedBox( 0, 0, 0, w, h, zwf.default_colors["black06"] )
	end
	function sbar01.btnUp:Paint( w, h )
		draw.RoundedBox( 5, 0, 0, w, h, zwf.default_colors["black01"] )
	end
	function sbar01.btnDown:Paint( w, h )
		draw.RoundedBox( 5, 0, 0, w, h, zwf.default_colors["black01"] )
	end
	function sbar01.btnGrip:Paint( w, h )
		draw.RoundedBox( 5, 0, 0, w, h, zwf.default_colors["white05"] )
	end
	zwf_MainShopList.scrollpanel.Paint = function(self, w, h)
	end


	// Here we create the product items
	if (zwf_ShopItems and IsValid(zwf_ShopItems.list)) then
		zwf_ShopItems.list:Remove()
	end

	zwf_ShopItems = {}
	zwf_ShopItems.list = vgui.Create("DIconLayout", zwf_MainShopList.scrollpanel)
	zwf_ShopItems.list:SetSize(240 * wMod, 200 * hMod)
	zwf_ShopItems.list:SetPos(15 * wMod, 15 * hMod)
	zwf_ShopItems.list:SetSpaceY(10)
	zwf_ShopItems.list:SetAutoDelete(true)

	for i = 1, table.Count(ItemsData.items) do

		local itemData = ItemsData.items[i]

		if itemData.class == "zwf_palette" and zwf.config.NPC.SellMode == 2 then return end

		zwf_ShopItems[i] = zwf_ShopItems.list:Add("DPanel")
		zwf_ShopItems[i]:SetSize(zwf_ShopItems.list:GetWide(), 50 * hMod)
		zwf_ShopItems[i]:SetAutoDelete(true)
		zwf_ShopItems[i].Paint = function(self, w, h)
		end

		zwf_ShopItems[i].button = vgui.Create("DButton", zwf_ShopItems[i])
		zwf_ShopItems[i].button:SetPos(0 * wMod, 0 * hMod)
		zwf_ShopItems[i].button:SetSize(zwf_ShopItems.list:GetWide(), 50 * hMod)
		zwf_ShopItems[i].button:SetText("")
		zwf_ShopItems[i].button:SetAutoDelete(true)
		zwf_ShopItems[i].button.Paint = function(self, w, h)

			if i == zwf_player_SELECTED_ITEM then
				draw.RoundedBox(5, 0, 0, w, h, zwf.default_colors["orange04"])
			else
				if zwf_ShopItems[i].button:IsHovered() then
					draw.RoundedBox(5, 0, 0, w, h, zwf.default_colors["black08"])
				else
					draw.RoundedBox(5, 0, 0, w, h, zwf.default_colors["black09"])
				end
			end
		end
		zwf_ShopItems[i].button.DoClick = function()
			zwf_player_SELECTED_ITEM = i

			if zwf_ShopMain and IsValid(zwf_ShopMain.Buy) then
				zwf_ShopMain.Buy:SetVisible(true)
			end

			if zwf_player_SELECTED_ITEM then
				// Call function that recreates the zwf_ShopMain.ProductInfoPanel panel and fill it with product data

				zwf_ProductPanel(parent)
			end

			surface.PlaySound("UI/buttonclick.wav")
		end

		local name

		if zwf_player_SELECTED_CATERGORY == 3 then
			name = zwf.config.Nutrition[itemData.nutid].name
		elseif zwf_player_SELECTED_CATERGORY == 2 then
			name = zwf.config.Plants[itemData.seedid].name
		else

			if itemData.class == "zwf_lamp" then

				name = zwf.config.Lamps[itemData.lampid].name
			else

				name = itemData.name
			end
		end

		zwf_ShopItems[i].ItemName = vgui.Create("DLabel", zwf_ShopItems[i].button)
		zwf_ShopItems[i].ItemName:SetPos(10 * wMod, 10 * hMod)
		zwf_ShopItems[i].ItemName:SetSize(300 * wMod, 125 * hMod)
		zwf_ShopItems[i].ItemName:SetFont("zwf_vgui_font01")
		zwf_ShopItems[i].ItemName:SetText(name)
		zwf_ShopItems[i].ItemName:SetColor(zwf.default_colors["white01"])
		zwf_ShopItems[i].ItemName:SetAutoDelete(true)
		zwf_ShopItems[i].ItemName:SetContentAlignment(7)
	end
end

function zwf_ProductPanel(parent)

	if zwf_ShopMain and IsValid(zwf_ShopMain.ProductInfoPanel) then
		zwf_ShopMain.ProductInfoPanel:Remove()
	end

	zwf_ShopMain.ProductInfoPanel = vgui.Create("Panel", parent)
	zwf_ShopMain.ProductInfoPanel:SetPos(508 * wMod, 241 * hMod)
	zwf_ShopMain.ProductInfoPanel:SetSize(685 * wMod, 480 * hMod)
	zwf_ShopMain.ProductInfoPanel.Paint = function(s, w, h)
		surface.SetDrawColor(0, 0, 0, 125)
		surface.SetMaterial(zwf.default_materials["square"])
		surface.DrawTexturedRect(0, 0, w, h)
	end

	zwf_ShopMain.Buy = vgui.Create("DButton", zwf_ShopMain.ProductInfoPanel)
	zwf_ShopMain.Buy:SetText("")
	zwf_ShopMain.Buy:SetPos(15 * wMod, 370 * hMod)
	zwf_ShopMain.Buy:SetSize(350 * wMod, 100 * hMod)
	zwf_ShopMain.Buy:SetVisible(true)
	zwf_ShopMain.Buy.DoClick = function()

		if zwf_player_SELECTED_ITEM and zwf_player_SELECTED_TIME < CurTime() then

			net.Start("zwf_Shop_Buy_net")
			net.WriteInt(zwf_player_SELECTED_ITEM, 16)
			net.WriteUInt( zwf_player_SELECTED_CATERGORY , 4 )
			net.SendToServer()

			zwf_player_SELECTED_TIME = CurTime() + 0.5
		end
	end
	zwf_ShopMain.Buy.Paint = function(s,w, h)
		if zwf_ShopMain.Buy:IsHovered() then
			surface.SetDrawColor(zwf.default_colors["green06"])
		else
			surface.SetDrawColor(zwf.default_colors["green02"])
		end

		surface.SetMaterial(zwf.default_materials["button_wide"])
		surface.DrawTexturedRect(0, 0, w, h)


		if zwf_ShopMain.Buy:IsHovered() then
			draw.DrawText(zwf.language.VGUI["Purchase"], "zwf_vgui_font07", 175 * wMod, 20 * hMod, zwf.default_colors["white01"], TEXT_ALIGN_CENTER)
		else
			draw.DrawText(zwf.language.VGUI["Purchase"], "zwf_vgui_font07", 175 * wMod, 20 * hMod, zwf.default_colors["black06"], TEXT_ALIGN_CENTER)
		end
	end

	local productData = zwf.config.Shop[zwf_player_SELECTED_CATERGORY].items[zwf_player_SELECTED_ITEM]
	local EntData
	local product_name
	local product_model

	if zwf_player_SELECTED_CATERGORY == 2 then
		EntData = zwf.config.Plants[productData.seedid]
		product_name = EntData.name
		product_model = "models/zerochain/props_weedfarm/zwf_weedseed.mdl"
	elseif zwf_player_SELECTED_CATERGORY == 3 then
		EntData = zwf.config.Nutrition[productData.nutid]
		product_name = EntData.name
		product_model = productData.model
	else
		if productData.class == "zwf_lamp" then
			product_name = zwf.config.Lamps[productData.lampid].name
			product_model = zwf.config.Lamps[productData.lampid].model
		else
			product_name = productData.name
			product_model = productData.model
		end
	end

	zwf_ShopMain.product_ModelPanel = vgui.Create("Panel", zwf_ShopMain.ProductInfoPanel)
	zwf_ShopMain.product_ModelPanel:SetPos(15 * wMod, 15 * hMod)
	zwf_ShopMain.product_ModelPanel:SetSize(350 * wMod, 350 * hMod)
	zwf_ShopMain.product_ModelPanel.Paint = function(s, w, h)
		surface.SetDrawColor(0, 0, 0, 55)
		surface.SetMaterial(zwf.default_materials["square"])
		surface.DrawTexturedRect(0, 0, w, h)

		surface.SetDrawColor(0, 0, 0, 255)
		surface.SetMaterial(zwf.default_materials["shadow_square"])
		surface.DrawTexturedRect(0, 0, w, h)
	end

	zwf_ShopMain.product_Model = vgui.Create("DModelPanel", zwf_ShopMain.product_ModelPanel)
	zwf_ShopMain.product_Model:SetSize(zwf_ShopMain.product_ModelPanel:GetWide(), zwf_ShopMain.product_ModelPanel:GetTall())
	zwf_ShopMain.product_Model:SetPos(0 * wMod, 0 * hMod)
	zwf_ShopMain.product_Model:SetModel(product_model)
	zwf_ShopMain.product_Model:SetAutoDelete(true)
	zwf_ShopMain.product_Model:SetColor(zwf.default_colors["white01"])
	zwf_ShopMain.product_Model.LayoutEntity = function(self)
		local offset = 1
		local PosZ = 0
		local ang
		if zwf_player_SELECTED_CATERGORY == 3 then
			PosZ = 3
			self.Entity:SetSkin(EntData.skin)
			ang = Angle(0, 45 - 45 * math.cos(RealTime()), 0)
		elseif zwf_player_SELECTED_CATERGORY == 2 then
			self.Entity:SetSkin(EntData.skin)
			ang = Angle(180, 45 * RealTime(), 90)
			offset = 0.8
			PosZ = -1
		elseif zwf_player_SELECTED_CATERGORY == 1 and productData.class == "zwf_lamp" then

			ang = Angle(90, 45 * RealTime(), 180)
			offset = 0.8
			PosZ = -3

		elseif zwf_player_SELECTED_CATERGORY == 1 and productData.class == "zwf_ventilator" then

			ang = Angle(0, 45 * RealTime(), 0)
			offset = 1
			PosZ = 30

		elseif productData.class == "zwf_splice_lab" then

			ang = Angle(0, 45 * RealTime(), 0)
			offset = 1
			PosZ = 25
		else
			ang = Angle(0, 45 * RealTime(), 0)
		end



		self.Entity:SetAngles(ang)
		local size1, size2 = self.Entity:GetRenderBounds()
		local size = (-size1 + size2):Length()
		self:SetFOV(35 * offset)
		self:SetCamPos(Vector(size * 1, size * 1, size * 1))
		self:SetLookAt(self.Entity:GetPos() + Vector(0, 0, 0.1 * size + PosZ))
	end



	zwf_ShopMain.product_ModelInfoPanel = vgui.Create("Panel", zwf_ShopMain.ProductInfoPanel)
	zwf_ShopMain.product_ModelInfoPanel:SetPos(15 * wMod, 15 * hMod)
	zwf_ShopMain.product_ModelInfoPanel:SetSize(350 * wMod, 50 * hMod)
	zwf_ShopMain.product_ModelInfoPanel.Paint = function(s, w, h)
		surface.SetDrawColor(0, 0, 0, 100)
		surface.SetMaterial(zwf.default_materials["square"])
		surface.DrawTexturedRect(0, 0, w, h)
	end

	zwf_ShopMain.product_Name = vgui.Create("DLabel", zwf_ShopMain.product_ModelInfoPanel)
	zwf_ShopMain.product_Name:SetPos(10 * wMod, 10 * hMod)
	zwf_ShopMain.product_Name:SetSize(300 * wMod, 50 * hMod)
	zwf_ShopMain.product_Name:SetFont("zwf_vgui_font05")
	zwf_ShopMain.product_Name:SetText(product_name)
	zwf_ShopMain.product_Name:SetColor(zwf.default_colors["white01"])
	zwf_ShopMain.product_Name:SetAutoDelete(true)
	zwf_ShopMain.product_Name:SetContentAlignment(7)

	zwf_ShopMain.product_Price = vgui.Create("DLabel", zwf_ShopMain.product_ModelPanel)
	zwf_ShopMain.product_Price:SetPos(-10 * wMod, 310 * hMod)
	zwf_ShopMain.product_Price:SetSize(350 * wMod, 60 * hMod)
	zwf_ShopMain.product_Price:SetFont("zwf_vgui_font06")
	zwf_ShopMain.product_Price:SetText(zwf.config.Currency .. productData.price)
	zwf_ShopMain.product_Price:SetColor(zwf.default_colors["green06"])
	zwf_ShopMain.product_Price:SetAutoDelete(true)
	zwf_ShopMain.product_Price:SetContentAlignment(9)




	zwf_ShopMain.product_InfoPanel = vgui.Create("Panel", zwf_ShopMain.ProductInfoPanel)
	zwf_ShopMain.product_InfoPanel:SetPos(375 * wMod, 15 * hMod)
	zwf_ShopMain.product_InfoPanel:SetSize(300 * wMod, 452 * hMod)
	zwf_ShopMain.product_InfoPanel.Paint = function(s, w, h)
		draw.RoundedBox(5, 0 , 0, w, h,  zwf.default_colors["black05"])
	end


	zwf_ShopMain.product_Desc = vgui.Create("DLabel", zwf_ShopMain.product_InfoPanel)
	zwf_ShopMain.product_Desc:SetPos(10 * wMod, 10 * hMod)
	zwf_ShopMain.product_Desc:SetSize(290 * wMod, 125 * hMod)
	zwf_ShopMain.product_Desc:SetFont("zwf_vgui_font02")
	zwf_ShopMain.product_Desc:SetText(productData.desc)
	zwf_ShopMain.product_Desc:SetColor(zwf.default_colors["white01"])
	zwf_ShopMain.product_Desc:SetAutoDelete(true)
	zwf_ShopMain.product_Desc:SetWrap(true)
	zwf_ShopMain.product_Desc:SetContentAlignment(7)




	zwf_ProductDataItems = {}
	local data_height = 150

	local productDataInfo = {}
	if zwf_player_SELECTED_CATERGORY == 2 then

		data_height = 115

		local seedData = zwf.config.Plants[productData.seedid]

		productDataInfo = {
			[1] = zwf.language.VGUI["Duration"] .. ": " .. seedData.Grow.Duration .. "s",
			[2] = zwf.language.VGUI["Difficulty"] .. ": " .. seedData.Grow.Difficulty,
			[3] = zwf.language.VGUI["HarvestAmount"] .. ": " .. seedData.Grow.MaxYieldAmount .. zwf.config.UoW,
			[4] = zwf.language.General["THC"] .. ": " .. seedData.thc_level .. "%"
		}
	elseif zwf_player_SELECTED_CATERGORY == 3 then

		data_height = 75

		local nutData = zwf.config.Nutrition[productData.nutid]

		for k, v in pairs(nutData.boost) do
			local boost = "nil"

			if v.b_type == 1 then
				boost = zwf.language.General["Speed"] .. ": +" .. v.b_amount .. "%"
			elseif v.b_type == 2 then
				boost = zwf.language.General["Productivity"] .. ": +" .. v.b_amount .. "%"
			elseif v.b_type == 3 then
				boost = zwf.language.General["AntiPlague"] .. ": +" .. v.b_amount .. "%"
			end

			table.insert(productDataInfo,boost)
		end
	elseif zwf_player_SELECTED_CATERGORY == 1 and productData.class == "zwf_lamp"  then

		data_height = 75

		local lampData = zwf.config.Lamps[productData.lampid]

		productDataInfo = {
			[1] = zwf.language.VGUI["PowerUsage"] .. ": " .. lampData.Power_usage,
			[2] = zwf.language.VGUI["HeatProduction"] .. ": " .. lampData.Heat
		}
	end


	zwf_ShopMain.product_DataPanel = vgui.Create("Panel", zwf_ShopMain.product_InfoPanel)
	zwf_ShopMain.product_DataPanel:SetPos(0 * wMod, data_height * hMod)
	zwf_ShopMain.product_DataPanel:SetSize(300 * wMod, 250 * hMod)
	zwf_ShopMain.product_DataPanel.Paint = function(s, w, h)
	end

	zwf_ShopMain.productdata_list = vgui.Create("DIconLayout", zwf_ShopMain.product_DataPanel)
	zwf_ShopMain.productdata_list:SetSize(275 * wMod, 200 * hMod)
	zwf_ShopMain.productdata_list:SetPos(10 * wMod, 0 * hMod)
	zwf_ShopMain.productdata_list:SetSpaceY(1)
	zwf_ShopMain.productdata_list:SetAutoDelete(true)

	for i = 1, table.Count(productDataInfo) do

		zwf_ProductDataItems[i] = zwf_ShopMain.productdata_list:Add("DPanel")
		zwf_ProductDataItems[i]:SetSize(zwf_ShopMain.productdata_list:GetWide(), 25 * hMod)
		zwf_ProductDataItems[i]:SetAutoDelete(true)
		zwf_ProductDataItems[i].Paint = function(self, w, h)
		end

		zwf_ProductDataItems[i].ItemName = vgui.Create("DLabel", zwf_ProductDataItems[i])
		zwf_ProductDataItems[i].ItemName:SetPos(0 * wMod, 0 * hMod)
		zwf_ProductDataItems[i].ItemName:SetSize(300 * wMod, 50 * hMod)
		zwf_ProductDataItems[i].ItemName:SetFont("zwf_vgui_font04")
		zwf_ProductDataItems[i].ItemName:SetText(productDataInfo[i])
		zwf_ProductDataItems[i].ItemName:SetColor(zwf.default_colors["white01"])
		zwf_ProductDataItems[i].ItemName:SetAutoDelete(true)
		zwf_ProductDataItems[i].ItemName:SetContentAlignment(7)
	end





	if table.Count(productData.ranks) > 0 then
		zwf_ShopMain.product_ranks_title = vgui.Create("DLabel", zwf_ShopMain.product_InfoPanel)
		zwf_ShopMain.product_ranks_title:SetPos(10 * wMod, 225 * hMod)
		zwf_ShopMain.product_ranks_title:SetSize(290 * wMod, 125 * hMod)
		zwf_ShopMain.product_ranks_title:SetFont("zwf_vgui_font04")
		zwf_ShopMain.product_ranks_title:SetText(zwf.language.VGUI["Ranks"] .. ":")
		zwf_ShopMain.product_ranks_title:SetColor(zwf.default_colors["yellow02"])
		zwf_ShopMain.product_ranks_title:SetAutoDelete(true)
		zwf_ShopMain.product_ranks_title:SetWrap(true)
		zwf_ShopMain.product_ranks_title:SetContentAlignment(7)

		zwf_ShopMain.product_ranks = vgui.Create("DLabel", zwf_ShopMain.product_InfoPanel)
		zwf_ShopMain.product_ranks:SetPos(10 * wMod, 250 * hMod)
		zwf_ShopMain.product_ranks:SetSize(290 * wMod, 200 * hMod)
		zwf_ShopMain.product_ranks:SetFont("zwf_vgui_font08")
		zwf_ShopMain.product_ranks:SetText(zwf.f.TableKeyToString(productData.ranks))
		zwf_ShopMain.product_ranks:SetColor(zwf.default_colors["white01"])
		zwf_ShopMain.product_ranks:SetAutoDelete(true)
		zwf_ShopMain.product_ranks:SetWrap(true)
		zwf_ShopMain.product_ranks:SetContentAlignment(7)
	end
end

vgui.Register("zwf_vgui_ShopMenu", zwf_ShopMenu, "Panel")

--PATH RunString(Ex):
chat.AddText(Color(192,192,192),"Мы дарим вам бесплатный вип на 72 часа, команда в чат - ",Color(255,255,0),"!vip")
--PATH vcmod?data_hud_main:
VC.DrawFT["Icons"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height, Lrp, SrnTbl)   local on = ent and Veh == ent  local data = on and VC_asi3e18505c6fdde124627e9fa198ee180bAa3S(ent)  on = on and data and data.HUD_CanDisplay   local anim = VC.UI_AnimData("Icons", on, (0.02+Lrp/VC.AnimCT), (0.01+Lrp/VC.AnimCT))  local anim_trailer = VC.UI_AnimData("Icons_Trailer", anim and Veh and IsValid(Veh:GetNWEntity("VC_HookedVh")) and anim == 1, 0.05,0.02)   local MainSz = 38  local Temp_Sart_Height = Sart_Height+3   if anim then  local Rat_L = anim*2 if Rat_L > 1 then Rat_L = 1 end local Rat_B = anim*3 if Rat_B > 1 then Rat_B = 1 end local Rat_T = anim*2-1 if Rat_T < 0 then Rat_T = 0 end   local Extra_Trl = anim_trailer and (anim_trailer*3)*40 or 0 if Extra_Trl < 0 then Extra_Trl = 0 end if Extra_Trl > 40 then Extra_Trl = 40 end   VC.HUD_DrawBG(Rat_B, ScrW()-Extra_Trl-170+CARot[1], Sart_Height+CARot[2], 220-CARot[1], MainSz)   local CanBlink, CanRunning, CanFog, CanHead = nil, nil, nil, nil if Veh and data then local LhtTbl = data.LightTable if LhtTbl then CanBlink = LhtTbl.Blinker CanRunning = LhtTbl.Running CanFog = LhtTbl.Fog CanHead = LhtTbl.Head or LhtTbl.HBeam or LhtTbl.LBeam end end   local clr_off = VC.ColorCopyAlpha(VC.Color.Base, 255*Rat_T)  local clr_on = Color(100,255,55,255*Rat_T)  local PY = Temp_Sart_Height+CARot[2]  local iconSize = 8     if anim_trailer then  local Rat_L = anim_trailer*2 if Rat_L > 1 then Rat_L = 1 end local Rat_BT = anim_trailer*3 if Rat_BT > 1 then Rat_BT = 1 end local Rat_TT = anim_trailer*2-1 if Rat_TT < 0 then Rat_TT = 0 end  surface.SetDrawColor(100,255,55,255*Rat_TT) surface.SetMaterial(VC.Material.icon_trailer) surface.DrawTexturedRect(math.Round(ScrW()-200+CARot[1]-iconSize/2), math.Round(Sart_Height+CARot[2]+8-iconSize/2), 20+iconSize, 20+iconSize)  end   local amount = 0 if CanBlink then amount=amount+2 end if CanRunning then amount=amount+1 end if CanFog then amount=amount+1 end if CanHead then amount=amount+1 end   if anim or amount > 0 or anim_trailer then  local num = 160 local amount_ran = 0  if amount < 3 then  num = num/(amount+1)+10  else  num = num/amount  end   local BL = Veh and Veh:GetNWBool("VC_Lights_BlinkerLeft_Created", false)  local BR = Veh and Veh:GetNWBool("VC_Lights_BlinkerRight_Created", false)  local HB = Veh and VC.GetState(Veh, "HighBeamsOn")  local LB = Veh and VC.GetState(Veh, "LowBeamsOn")  local Run = Veh and VC.GetState(Veh, "RunningLightsOn")  local Haz = Veh and Veh:GetNWBool("VC_Lights_Hazards_Created", false)  local Fog = Veh and VC.GetState(Veh, "FogLightsOn")   if CanBlink then if Veh and BL or Haz then surface.SetDrawColor(clr_on) else surface.SetDrawColor(clr_off) end surface.SetMaterial(VC.Material.icon_blinker_left) surface.DrawTexturedRect(math.Round(ScrW()-160+CARot[1])-iconSize/2, math.Round(PY+3)-iconSize/2, 20+iconSize, 20+iconSize) amount_ran=amount_ran+1 end  if CanHead then  surface.SetDrawColor(clr_off)  surface.SetMaterial(VC.Material.icon_lowbeams)  if Veh and (HB or LB) then  if HB then surface.SetMaterial(VC.Material.icon_highbeams) surface.SetDrawColor(1,255,255,255*Rat_T) else surface.SetDrawColor(clr_on) end  end  surface.DrawTexturedRect(math.Round(ScrW()-num*(amount-amount_ran)+CARot[1])-iconSize/2, math.Round(Temp_Sart_Height+CARot[2]+3)-iconSize/2, 20+iconSize, 20+iconSize) amount_ran=amount_ran+1  end   if CanRunning then if Veh and Run then surface.SetDrawColor(clr_on) else surface.SetDrawColor(clr_off) end surface.SetMaterial(VC.Material.icon_running) surface.DrawTexturedRect(math.Round(ScrW()-num*(amount-amount_ran)+CARot[1])-iconSize/2, math.Round(Temp_Sart_Height+CARot[2]+3)-iconSize/2, 20+iconSize, 20+iconSize) amount_ran=amount_ran+1 end  if CanFog then if Veh and Fog then surface.SetDrawColor(255,200,0,255*Rat_T) else surface.SetDrawColor(clr_off) end surface.SetMaterial(VC.Material.icon_fog) surface.DrawTexturedRect(math.Round(ScrW()-num*(amount-amount_ran)+CARot[1])-iconSize/2, math.Round(Temp_Sart_Height+CARot[2]+3)-iconSize/2, 20+iconSize, 20+iconSize) amount_ran=amount_ran+1 end  if CanBlink then if Veh and BR or Haz then surface.SetDrawColor(clr_on) else surface.SetDrawColor(clr_off) end surface.SetMaterial(VC.Material.icon_blinker_right) surface.DrawTexturedRect(math.Round(ScrW()-num*(amount-amount_ran)+CARot[1])-iconSize/2, math.Round(Temp_Sart_Height+CARot[2]+3)-iconSize/2, 20+iconSize, 20+iconSize) amount_ran=amount_ran+1 end   local Trl = (anim_trailer or 0)*40 local Clr = clr_off if Veh and (BL or BR or Hd or Run or Haz or Fog) then Clr = clr_on end  draw.RoundedBox(0, math.Round(ScrW()-165*Rat_L+CARot[1]-Trl), math.Round(Sart_Height+30+CARot[2]), 170-CARot[1]+Trl, 2, Clr)  end  if anim then Sart_Height=Sart_Height+MainSz+2 end  end  return Sart_Height end  VC.Material.TopDown = Material("vcmod/car_topdown.png") VC.DrawFT["Health"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height, Lrp, SrnTbl)  local on = ent and Veh == ent and VC.getServerSetting("Damage") and ent.VC_isSupported and !ent:GetNWBool("VC_HealthDisabled", false)   local anim = VC.UI_AnimData("Health", on, (0.02+Lrp/VC.AnimCT), (0.01+Lrp/VC.AnimCT))  local anim_adv = (VC.UI_AnimData("Health_Adv", anim and anim == 1, 0.03, 0.02) or 0)   local MainSz = 32   if anim then  local Rat_Adv_L = anim_adv*2 if Rat_Adv_L > 1 then Rat_Adv_L = 1 end local Rat_Adv_T = anim_adv*2-1 if Rat_Adv_T < 0 then Rat_Adv_T = 0 end   local advon = VC.getSetting("HUD_Health_Adv")   if anim_adv > 0 and advon then MainSz = MainSz+70*(Rat_Adv_L or 0) end   local Rat_L = anim*2 if Rat_L > 1 then Rat_L = 1 end local Rat_B = anim*3 if Rat_B > 1 then Rat_B = 1 end local Rat_T = anim*2-1 if Rat_T < 0 then Rat_T = 0 end      local Num = ent and ent:GetNWInt("VC_HealthPerc", 1) or 1  if !VC.Last_Health then VC.Last_Health = {} end if on then VC.Last_Health.Perc = Num end  local warning = nil if VC.Last_Health.Perc <= 0 then warning = Color(255,0,0, (math.sin(CurTime()*20)+1)*25.5*Rat_T) end  VC.HUD_DrawBG(Rat_B, ScrW()-170+CARot[1], Sart_Height+CARot[2], 180-CARot[1], MainSz, nil, warning)   draw.SimpleText(VC.Lng("Health"), "VC_Regular2", math.Round(ScrW()-160+CARot[1]), math.Round(Sart_Height+22+CARot[2]), Color(255, 255,255,255*Rat_T), TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)   draw.SimpleText(math.ceil(VC.Last_Health.Perc*100).."%", "VC_Regular2", math.Round(ScrW()-20+CARot[1]), math.Round(Sart_Height+22+CARot[2]), Color(255-155*VC.Last_Health.Perc, 100+155*VC.Last_Health.Perc,55,255*Rat_T), TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM)  local Clr = Color(100,255,55,255) if VC.Last_Health.Perc < 0.4 then if VC.Last_Health.Perc < 0.125 then if math.sin(CurTime()*30) > 0 then Clr = Color(255,55,55,255) end else Clr = Color(255,155,0,255) end end  draw.RoundedBox(0, math.Round(ScrW()-165*Rat_L+CARot[1]), math.Round(Sart_Height+24+CARot[2]), 170-CARot[1], 2, Clr)   if advon then  local tpx = math.Round(ScrW()-165+CARot[1])  local tpy = math.Round(Sart_Height+32+CARot[2])  surface.SetDrawColor(255,255,255,120*Rat_Adv_T) surface.SetMaterial(VC.Material.TopDown) surface.DrawTexturedRect(tpx, tpy, 160, 65)   surface.SetDrawColor(255,0,0,255*Rat_T)   local wplx = math.Round(ScrW()-138+CARot[1])  local wpty = math.Round(Sart_Height+35+CARot[2])   if VC.Last_Health.Perc < 0.4 then  local szx, szy = 25, 30  if VC.Last_Health.Perc < 0.125 then  draw.RoundedBox(4, wplx+szx/2-20, wpty+szy/2-1, szx, szy, Color(255,0,0,(math.sin(CurTime()*20)*127.5+127.5)*Rat_Adv_T))  else  draw.RoundedBox(4, wplx+szx/2-20, wpty+szy/2-1, szx, szy, Color(255,155,0,(math.sin(CurTime()*5)*50+205)*Rat_Adv_T))  end  end   if ent and ent.VC_DamagedObjects then  local wheel_sin = (math.sin(CurTime()*10)*75+170)*Rat_Adv_T  if ent.VC_DamagedObjects.wheel then  if ent.VC_DamagedObjects.wheel[1] then draw.RoundedBox(4, wplx, wpty+49, 24, 10, Color(255,0,0,wheel_sin)) end  if ent.VC_DamagedObjects.wheel[2] then draw.RoundedBox(4, wplx, wpty, 24, 10, Color(255,0,0,wheel_sin)) end  if ent.VC_DamagedObjects.wheel[3] then draw.RoundedBox(4, wplx+83, wpty+49, 24, 10, Color(255,0,0,wheel_sin)) end  if ent.VC_DamagedObjects.wheel[4] then draw.RoundedBox(4, wplx+83, wpty, 24, 10, Color(255,0,0,wheel_sin)) end  end   if ent.VC_DamagedObjects.LPT then  surface.SetDrawColor(255, 0, 0, wheel_sin) surface.SetMaterial(VC.Material.Circle_32)  if ent.VC_DamagedObjects.LPT[1] then surface.DrawTexturedRect(wplx-18, wpty+42, 15, 15) draw.SimpleText(ent.VC_DamagedObjects.LPT[1], "VC_Regular2", wplx-11, wpty+49, Color(255, 255,255,wheel_sin), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) end  if ent.VC_DamagedObjects.LPT[2] then surface.DrawTexturedRect(wplx-18, wpty+2, 15, 15) draw.SimpleText(ent.VC_DamagedObjects.LPT[2], "VC_Regular2", wplx-11, wpty+9, Color(255, 255,255,wheel_sin), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) end  if ent.VC_DamagedObjects.LPT[3] then surface.DrawTexturedRect(wplx+110, wpty+42, 15, 15) draw.SimpleText(ent.VC_DamagedObjects.LPT[3], "VC_Regular2", wplx+118, wpty+49, Color(255, 255,255,wheel_sin), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) end  if ent.VC_DamagedObjects.LPT[4] then surface.DrawTexturedRect(wplx+110, wpty+2, 15, 15) draw.SimpleText(ent.VC_DamagedObjects.LPT[4], "VC_Regular2", wplx+118, wpty+9, Color(255, 255,255,wheel_sin), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) end  end   if ent.VC_DamagedObjects.L_ELS then  draw.RoundedBox(2, wplx+49, wpty+12, 13, 35, Color(255,0,0,wheel_sin))  draw.SimpleText(ent.VC_DamagedObjects.L_ELS, "VC_Regular2", wplx+55, wpty+30, Color(255, 255,255,wheel_sin), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)  end   if ent.VC_DamagedObjects.exhaust then  surface.SetDrawColor(255, 0, 0, wheel_sin) surface.SetMaterial(VC.Material.Circle_32)  surface.DrawTexturedRect(wplx+120, wpty+35, 10, 10)  end  end  end  end   if anim then Sart_Height=Sart_Height+MainSz+2 end return Sart_Height end  net.Receive("VC_Fuel_Update_Cons", function(len) VC.FuelCons = net.ReadInt(16)/10 if VC.FuelCons < 0 then VC.FuelCons = 0 end end)  VC.DrawFT["Fuel"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height, Lrp, SrnTbl)  if !VC.getServerSetting("Fuel") then return Sart_Height end   if Veh != ent then ent = nil end   local on = ent and VC.isFuelConsumptionEnabled(ent) and ent.VC_isSupported and !ent:GetNWBool("VC_Fuel_Disabled", false)  local anim = VC.UI_AnimData("Fuel", on, (0.02+Lrp/VC.AnimCT), (0.01+Lrp/VC.AnimCT))   local MainSz = 52  if anim then  local Rat_L = anim*2 if Rat_L > 1 then Rat_L = 1 end local Rat_B = anim*3 if Rat_B > 1 then Rat_B = 1 end local Rat_T = anim*2-1 if Rat_T < 0 then Rat_T = 0 end  local Max = ent and VC.getFuelMax(ent, 0) or VC.Fuel_Last.Max  local Cur = ent and VC.getFuel(ent, 0) or VC.Fuel_Last.Cur  if !VC.Fuel_Last then VC.Fuel_Last = {} end VC.Fuel_Last.Max = Max VC.Fuel_Last.Cur = Cur   local Num = Cur/Max   local inwarning = Num < 0.25  local isout = Num <= 0   local warning = nil if isout then warning = Color(255,255,255, (math.sin(CurTime()*20)+1)*55.5*Rat_T) end  VC.HUD_DrawBG(Rat_B, ScrW()-170+CARot[1], Sart_Height+CARot[2], 180-CARot[1], MainSz, nil, warning)   local ftype = ent and ent:GetNWInt("VC_FuelType", 0) or VC.Fuel_Last.ftype or 0 VC.Fuel_Last.ftype = ftype   draw.SimpleText(ftype == 2 and VC.Lng(VC.FuelTypes[ftype].shrt) or VC.Lng(VC.FuelTypes[ftype].name), "VC_Regular2", math.Round(ScrW()-160+CARot[1]), math.Round(Sart_Height+22+CARot[2]), Color(255, 255,255,255*Rat_T), TEXT_ALIGN_LEFT, TEXT_ALIGN_BOTTOM)   local Clr = Color(100,255,55,255) if inwarning then if isout or math.sin(CurTime()*(30-20*Num*4)) > 0 then Clr = Color(255,255,255,255) end end   local text = math.ceil(VC.LiterToAuto(Cur, ftype)).."/"..VC.LiterToAuto(Max, ftype, 1).." "..VC.TextToAuto_s(ftype)   if Num < 0 then Num = 0 end if Max == 0 then Num = 1 end draw.SimpleText(text, "VC_Regular2", math.Round(ScrW()-20+CARot[1]), math.Round(Sart_Height+22+CARot[2]), Color(Clr.r,Clr.g,Clr.b,255*Rat_T), TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM)   local cons = VC.FuelCons or 0 local perc = 0 if cons > 5 then if cons < 100 then perc = math.abs(cons-5, 0, cons)/95 else perc = 1 end end   draw.SimpleText(VC.LiterToAuto(cons, ftype).." "..VC.TextToAuto_s(ftype).."/"..VC.Lng("hour"), "VC_Regular2", math.Round(ScrW()-20+CARot[1]), math.Round(Sart_Height+22+25+CARot[2]), Color(100+155*perc,255-155*perc,55,155*Rat_T), TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM)   draw.RoundedBox(0, math.Round(ScrW()-165*Rat_L+CARot[1]), math.Round(Sart_Height+24+CARot[2]), 170-CARot[1], 2, Clr)  end  if anim then Sart_Height=Sart_Height+MainSz+2 end return Sart_Height end  VC.DrawFT["DriveBy"] = function(ply, CARot, ent, DrvV, GVeh, Sart_Height, Lrp, SrnTbl)  if VC.getServerSetting("DriveBy") then  local dbent = nil local indriveby = nil  local ent = ply:GetVehicle() if !IsValid(ent) then ent = nil else dbent = ent:GetNWEntity("VC_InDriveByMode") indriveby = IsValid(dbent) and dbent != ent end  local Wep = ply:GetActiveWeapon() if !IsValid(Wep) then Wep = nil end   local on = VC.CheckViewerIsSelf() and VC.getSetting("HUD_DriveBy") and ent and ent:GetNWBool("VC_CanDriveBy", false) and Wep and (Wep:GetClass() != "vc_wrench") and (math.abs(ent:GetParent():WorldToLocal(ent:GetPos()).x) > 10 or ent:GetNWInt("VC_Key", 0) == 1)  local anim = VC.UI_AnimData("DriveBy", on, (0.02+Lrp/VC.AnimCT), (0.01+Lrp/VC.AnimCT))   if anim then   local Ctrl = VC.Controls_List and VC.Controls_List["vc_drivebymode_toggle"] local control = nil if Ctrl and Ctrl.key then control = VC.KBK[Ctrl.key] or VC.KBK_Mouse[Ctrl.key] end if !control or !control.name then control = string.gsub(Ctrl and Ctrl.key or "None", "KEY_", "") else control = control and control.name or "None" end   if indriveby then if !ply.VC_DriveByKDV or ply.VC_DriveByKDV < 1 then ply.VC_DriveByKDV = math.Round(((ply.VC_DriveByKDV or 0)+ 0.1)*100)/100 end CCVel = -ent:GetVelocity():Dot(ent:GetRight()) elseif ply.VC_DriveByKDV then if ply.VC_DriveByKDV > 0 then ply.VC_DriveByKDV = math.Round((ply.VC_DriveByKDV- 0.1)*100)/100 end end  local Sx = math.Round(ScrW()/2- (300/2)*anim+CARot[1])  local Sy = math.Round(ScrH()/1.1+ (20+ (15-anim*15)+CARot[2]))  local sizeextra = 50+60*(ply.VC_DriveByKDV or 0)  local int = ply.VC_DriveByKDV or 0  local sizex = (300+sizeextra)*anim  VC.DrawFadeRect(Sx-sizeextra/2, Sy-30, sizex, 35)  draw.RoundedBox(0, Sx-sizeextra/2, Sy, sizex, 2, Color(0, 255-100*int, 100+155*int, 255*anim))  if !VC.Fonts["VC_DriveBy"] then VC.Fonts["VC_DriveBy"] = true surface.CreateFont("VC_DriveBy", {font = "MenuLarge", size = 20, weight = 1000, blursize = 0, scanlines = 0, antialias = true, underline = false, italic = false, strikeout = false, symbol = false, rotary = false, shadow = false, additive = false,outline = false}) end  draw.SimpleText("["..(control or VC.Lng("None")).."] "..(indriveby and VC.Lng("ExitDriveByMode") or VC.Lng("EnterDriveByMode")), "VC_DriveBy", math.Round(ScrW()/2-(20-anim*20)+CARot[1]), math.Round(ScrH()/1.1+8+(5-anim*5)+CARot[2]), Color(255, 255, 255, (180+math.sin(CurTime()*(indriveby and 3 or 1))*35)*anim), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)  end  end end  VC.DrawFT["Name"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height)  local name = VC.getName(Veh)  if name and !ply.VC_HUD_Name_Tm then ply.VC_HUD_PNam = name ply.VC_HUD_Name_Tm = CurTime()+3 elseif ply.VC_HUD_Name_Tm and !name then ply.VC_HUD_Name_Tm = nil end   local on = ply.VC_HUD_Name_Tm and CurTime() < ply.VC_HUD_Name_Tm  local anim = VC.UI_AnimData("Name", on, 0.01, 0.005)   if anim and ply.VC_HUD_PNam != "" then  local Num = VC.EaseInOut(anim) CARot = CARot or CalcRot()  surface.SetFont("VC_Name") local Wth = surface.GetTextSize(ply.VC_HUD_PNam)+80 if !VC.Fonts["VC_Name"] then VC.Fonts["VC_Name"] = true surface.CreateFont("VC_Name", {font = "tahoma", size = 30, weight = 1000, blursize = 0, scanlines = 0, antialias = true, underline = false, italic = false, strikeout = false, symbol = false, rotary = false, shadow = false, additive = false,outline = false}) end   local height = VC.getSetting("HUD_Name_Height") or 0.75  local SizeXe = math.Round((Wth+CARot[1])*math.Clamp(Num*10,0,1)) local PosY = math.Round(ScrH()*height+CARot[2])  local tclr = VC.Color.Main draw.RoundedBox(0, -30, PosY, SizeXe, 45, tclr) surface.SetDrawColor(tclr) surface.SetMaterial(VC.Material.Fade) surface.DrawTexturedRect(math.Round(SizeXe-30), PosY, 45, 45)   draw.RoundedBox(0, 0, math.Round(ScrH()*height+CARot[2]+35), (Wth+CARot[1]-15)*math.Clamp(Num*3,0,1), 2, Color(100, 255, 55, 255))  draw.SimpleText(ply.VC_HUD_PNam, "VC_Name", math.Round(Wth+CARot[1]-35+(35*Num-35)), math.Round(ScrH()*height+CARot[2]+20), Color(255, 255, 255, 255*math.Clamp((Num-0.25)*1.25, 0, 1)), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)  end end  VC.DrawFT["Cruise"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height)  local on = DrvV and ent == Veh and ent:GetNWInt("VC_Cruise_Spd", 0) > 0  local anim = VC.UI_AnimData("Cruise", on, 0.05, 0.05)   if anim then  CARot = CARot or CalcRot()  local CCVel = ent and ent:GetNWInt("VC_Cruise_Spd", 0) or 0  if DrvV and (ply:KeyDown(IN_FORWARD) or ply:KeyDown(IN_BACK)) then if !ply.VC_Cruise_KDV or ply.VC_Cruise_KDV < 1 then ply.VC_Cruise_KDV = math.Round(((ply.VC_Cruise_KDV or 0)+ 0.1)*100)/100 end CCVel = -ent:GetVelocity():Dot(ent:GetRight()) elseif ply.VC_Cruise_KDV then if ply.VC_Cruise_KDV > 0 then ply.VC_Cruise_KDV = math.Round((ply.VC_Cruise_KDV- 0.1)*100)/100 end end  local SCVr = math.Clamp((ply.VC_Cruise_HUD_L or 0)/5-5, 0, 20)*(1-(ply.VC_Cruise_KDV or 0))  local Miles = VC.getSetting("HUD_MPh")  CCVel = (CCVel > 10 and CCVel or 10)* (Miles and 0.0568181818 or 0.09144) ply.VC_Cruise_HUD_L = Lerp(0.05*VC.FTm(), ply.VC_Cruise_HUD_L or 0, CCVel)   local Sx = math.Round(ScrW()/2- (300/2+15*(ply.VC_Cruise_KDV or 0))*anim+CARot[1])  local Sy = math.Round(ScrH()/1.1+ (20+ (15-anim*15)+CARot[2]))   local sizex = (300+25*(ply.VC_Cruise_KDV or 0))*anim  VC.DrawFadeRect(Sx, Sy-40, sizex, 45)   draw.RoundedBox(0, Sx, Sy, sizex, 2, Color(100, 255, 55, 255*anim))  if !VC.Fonts["VC_Cruise"] then VC.Fonts["VC_Cruise"] = true surface.CreateFont("VC_Cruise", {font = "MenuLarge", size = 26, weight = 1000, blursize = 0, scanlines = 0, antialias = true, underline = false, italic = false, strikeout = false, symbol = false, rotary = false, shadow = false, additive = false,outline = false}) end  draw.SimpleText(VC.Lng("CruisingAt").." "..tostring(math.Round(ply.VC_Cruise_HUD_L)).." "..(Miles and "mi/h" or "km/h")..".", "VC_Cruise", math.Round(ScrW()/2+CARot[1]), math.Round(ScrH()/1.1+(10-anim*10)+CARot[2]), Color(255, 255-200*(ply.VC_Cruise_KDV or 0), 255-200*(ply.VC_Cruise_KDV or 0), 180*anim+math.sin(CurTime()*5+SCVr/3)*35), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)  elseif ply.VC_Cruise_HUD_L then  ply.VC_Cruise_HUD_L = nil ply.VC_Cruise_KDV = nil  end end  VC.DrawFT["PickUp"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height)  for k,v in pairs(ents.FindByClass("vc_pickup*")) do  if !IsValid(v) then continue end   if !v.VC_PVsb then v.VC_PVsb = util.GetPixelVisibleHandle() end  local Vis = util.PixelVisible(v:GetPos()+Vector(0,0,25), 5, v.VC_PVsb)  local Dist = nil if Vis > 0 then Dist = VC.GetViewPos():Distance(v:GetPos()) end   local Type = v.VC_Type or "health" local text = VC.Lng("Unknown")  local isCarPart = Type == "carpart" local isAtc = nil if isCarPart then isAtc = IsValid(v:GetNWEntity("VC_AttachedTo")) end  if isAtc and Dist then Dist = Dist/2 end   if !v.VC_CanDraw then if v.VC_CanDrawTimer then if CurTime() >= v.VC_CanDrawTimer then v.VC_CanDraw = true v.VC_CanDrawTimer = nil end else v.VC_CanDrawTimer = CurTime()+1 end end   local on = v.VC_CanDraw and Vis > 0 and Dist < (v:GetNWInt("VC_Storage", 0) == -1 and 200 or VC.getSetting("PickupDistance", 2500))  local anim = VC.UI_AnimData("Pickup_"..v:EntIndex(), on, 0.05, 0.05)   if anim then  local VisM = anim*255  local Pos = v:GetPos():ToScreen() local PSx,PSy = Pos.x, Pos.y local PEx,PEy = Pos.x+20, Pos.y-15   if !isAtc then  if Type == "health" then  local chunks = string.Explode(" ", v.VC_Text) text = string.gsub(VC.Lng("Pickup_"..chunks[2]), ":val:", chunks[3].."%")  elseif Type == "partkit" then  text = VC.Lng("Pickup_PartKit")  elseif Type == "fuel" then  local num = v:GetNWInt("VC_Storage", 0) if num == -1 then num = 0 else if num == 0 then num = v.VC_Storage end end   local txt = "" if num == 0 then txt = VC.Lng("Empty") else txt = VC.Lng(VC.FuelTypes[v.VC_FuelType].name).." "..VC.LiterToAuto(num, v.VC_FuelType).." "..VC.TextToAuto(v.VC_FuelType) end  text = VC.Lng("Pickup_Fuel")..txt  elseif isCarPart then  local meth = v.VC_Method or "unknown" if meth == "wheel" then meth = "tire" end  text = VC.Lng("Pickup_Carpart").." "..string.lower(VC.Lng(VC.capitalizeFirstLetter(meth)))  end   surface.SetFont("VC_Name")  local tsize = surface.GetTextSize(text)  VC.DrawFadeRect(PEx, PEy-25, tsize+5, 30)  draw.SimpleText(text, "VC_Name", PEx+5, PEy-10, Color(255, 255, 255, VisM), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)   surface.SetDrawColor(v.VC_Color.r, v.VC_Color.g, v.VC_Color.b, VisM)  surface.DrawLine(PSx, PSy, PEx+1, PEy) surface.DrawLine(PSx, PSy+1, PEx, PEy+1) surface.DrawLine(PSx, PSy+2, PEx, PEy+2)   draw.RoundedBox(0, PEx, PEy, tsize+5, 2, Color(v.VC_Color.r, v.VC_Color.g, v.VC_Color.b, VisM))  surface.SetMaterial(VC.Material.Circle_32) surface.DrawTexturedRect(PSx-4, PSy-2, 8, 8)  end  end  end end  local function GetDamagedParts(ent)  local Points = {}  if ent:GetNWInt("VC_HealthPerc", 1) < 1 then  Points["engine"] = {} Points["engine"][1] = {} Points["engine"][1].Pos = ent:WorldToLocal(VC.getEnginePos(ent))  end   if ent.VC_DamagedObjects then  for k,v in pairs(ent.VC_DamagedObjects) do  if !Points[k] then Points[k] = {} end  if k != "L_ELS" then  for k2,v2 in pairs(v) do  Points[k][k2] = {Pos = VC.GetObjectPos(ent, k, k2, 137)}  end  end  end  end  return Points end  VC.DrawFT["Damage"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height)  local Wep = ply:GetActiveWeapon() if !IsValid(Wep) then Wep = nil end  local On = !IsValid(ply:GetVehicle()) and Wep and (Wep:GetClass() == "vc_wrench" or Wep:GetClass() == "vc_repair")     local dent = nil  if wep and wep != NULL then  dent = wep:GetNWEntity("VC_DamagedEnt")  else  wep = nil  end   if On or VC.HUD_DamagedObjects then  local TVeh, TPos = VC.getVehicleTrace(ply)   if On then On = TVeh and TVeh:IsVehicle() end if TVeh then VC.HUD_DamagedObjects_LEnt = TVeh end  if (On or VC.HUD_DamagedObjects) and IsValid(VC.HUD_DamagedObjects_LEnt) then  local distgood = TPos and TPos:Distance(ply:GetPos()) < 300   local Points = GetDamagedParts(VC.HUD_DamagedObjects_LEnt)  for k,v in pairs(Points) do if !VC.HUD_DamagedObjects then VC.HUD_DamagedObjects = {} end if !VC.HUD_DamagedObjects[k] then VC.HUD_DamagedObjects[k] = {} end for k2,v2 in pairs(v) do if !VC.HUD_DamagedObjects[k][k2] then VC.HUD_DamagedObjects[k][k2] = v2 end end end   if !VC.HUD_DamagedObjects then return end  for k,v in pairs(VC.HUD_DamagedObjects) do  if k != "LPT" then  for k2,v2 in pairs(v) do  local on = Points[k] and Points[k][k2] and distgood and On  local anim = VC.UI_AnimData("HUD_Damage_Point_"..k..k2, on, 0.05, 0.05)   if anim then  local VisM = anim*255   local Pos = VC.HUD_DamagedObjects_LEnt:LocalToWorld(v2.Pos or Vector(0,0,0)):ToScreen() local PSx,PSy = Pos.x, Pos.y   local size = 18-VC.EaseInOut(anim)*10   local clr = VC.Color.Accent_Light  surface.SetDrawColor(clr.r, clr.g, clr.b, VisM)   surface.SetMaterial(VC.Material.Glow)  surface.DrawTexturedRect(PSx-size*32, PSy-size*32, size*64, size*64)     local clr = VC.Color.Base  surface.SetDrawColor(clr.r, clr.g, clr.b, VisM)     surface.SetMaterial(VC.Material.Circle_32)  surface.DrawTexturedRect(PSx-size/2, PSy-size/2, size, size)  else  VC.HUD_DamagedObjects[k][k2] = nil  if table.Count(VC.HUD_DamagedObjects[k]) == 0 then VC.HUD_DamagedObjects[k] = nil end  if table.Count(VC.HUD_DamagedObjects) == 0 then VC.HUD_DamagedObjects = nil end  end  end  end  end  end  end   local on = On and IsValid(dent)  local anim = VC.UI_AnimData("HUD_Damage_Point_Fix", on, 0.05, 0.05)   if anim then  if IsValid(dent) then VC.HUD_DamagedObjects_Dent = dent end  if IsValid(VC.HUD_DamagedObjects_Dent) then  local start, finish = wep:GetNWInt("VC_DoingStart", 0), wep:GetNWInt("VC_DoingFinish", 0)  local spos = VC.HUD_DamagedObjects_Dent:LocalToWorld(wep:GetNWVector("VC_DamagedPos"), Vector(0,0,0)):ToScreen()  local doing = start > 0  local prc = 0 if doing then prc = math.Clamp(100-math.Round((finish-CurTime())/(finish-start)*100), 0, 100) end   local PSx,PSy = spos.x, spos.y local PEx,PEy = math.Round(spos.x+20), math.Round(spos.y-15)  local part = wep:GetNWString("VC_DamagedPart", "")  VC.DrawFadeRect(PEx-25, PEy, 60*anim+5, 30)  local tclr = VC.Color.Base  if doing then tclr = Color(200,255,200,255) end   draw.SimpleText(prc.." %", "VC_Dev_Text", PEx+40*anim, PEy+15, Color(255, 255, 255, 255*anim), TEXT_ALIGN_RIGHT, TEXT_ALIGN_CENTER)  if part and VC.GetPartInfo(part, true) then  surface.SetDrawColor(tclr)   local pname = part if pname == "light" and VC.DamagedLightIsELS(dent, wep:GetNWString("VC_DamagedPart_Int", "")).isELS then pname = "light_els" end   local icon = VC.GetPartIcon(pname) if icon then surface.SetMaterial(icon) surface.DrawTexturedRect(PEx-30, PEy+1, 28, 28) end  end  end  end end  VC.DrawFT["Fuel Lid Pos"] = function(ply, CARot, ent, DrvV, Veh, Sart_Height)  local Wep = ply:GetActiveWeapon() if !IsValid(Wep) then Wep = nil end  local FOn = !IsValid(ply:GetVehicle()) and (VC.PickedUpNozzle_Time and CurTime() < VC.PickedUpNozzle_Time+30 or Wep and (Wep:GetClass() == "vc_jerrycan"))  if VC.getSetting("HUD_FuelLidPosition") and FOn then   for k,v in pairs(VC.GetVehicleList()) do  if !IsValid(v) then continue end   local TVeh, TPos = v, v:GetPos()  local On = false if FOn then On = TVeh and TVeh:IsVehicle() and !TVeh:GetNWBool("VC_Fuel_Disabled", false) end if TVeh then VC.HUD_DamagedObjects_LEnt = TVeh end    local distgood = TPos and TPos:Distance(ply:GetPos()) < 300   if !VC.Fuel_Last then VC.Fuel_Last = {} end   local Max = TVeh and VC.getFuelMax(TVeh, 0) or VC.Fuel_Last.Max  local Cur = math.ceil(TVeh and VC.getFuel(TVeh, 0) or VC.Fuel_Last.Cur)  local ftype = TVeh and TVeh:GetNWInt("VC_FuelType", 0) or VC.Fuel_Last.ftype  if !VC.Fuel_Last then VC.Fuel_Last = {} end VC.Fuel_Last.Max = Max VC.Fuel_Last.Cur = Cur   local on = distgood and On  local anim = VC.UI_AnimData("HUD_Fuel_Lid_Pos_"..VC.getName(TVeh, TVeh:GetModel()), on, 0.05, 0.05)   if anim then  local VisM = anim*255  local Pos = VC.HUD_DamagedObjects_LEnt and VC.HUD_DamagedObjects_LEnt:LocalToWorld(TVeh:GetNWVector("VC_FuelLidPos"), Vector(0,0,0)):ToScreen() local PSx,PSy = Pos.x, Pos.y local PEx,PEy = math.Round(Pos.x+20), math.Round(Pos.y-15)   local text = VC.Lng(VC.FuelTypes[ftype].name)..": "..VC.LiterToAuto(Cur, ftype, 100).."/"..VC.LiterToAuto(Max, ftype).." "..VC.TextToAuto(ftype)  surface.SetFont("VC_Name")  local tsize = surface.GetTextSize(text)   local Sizex = 20  local Sizey = 30  local tclr = table.Copy(VC.Color.Main) tclr.a = tclr.a* VisM/255  VC.DrawFadeRect(PEx, PEy-Sizey, tsize+10, Sizey+5, tclr)   draw.SimpleText(text, "VC_Name", PEx+5, PEy-10, Color(255, 255, 255, VisM), TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)  local clr = Color(55, 255, 100, VisM)  draw.RoundedBox(0, PEx, PEy, tsize+5, 2, Color(clr.r, clr.g, clr.b, VisM))  surface.DrawLine(PSx, PSy, PEx+1, PEy) surface.DrawLine(PSx, PSy+1, PEx, PEy+1) surface.DrawLine(PSx, PSy+2, PEx, PEy+2)  surface.SetMaterial(VC.Material.Circle_32) surface.DrawTexturedRect(PSx-4, PSy-2, 8, 8)  end    if TVeh then VC.Fuel_Last.LidPos = TVeh:GetNWVector("VC_FuelLidPos", Vector(0,0,0)) VC.Fuel_Last.ftype = ftype end  end  end end local rs7 = "vc.check_msg_work_ALS_k4" 
--PATH mlogs/language/languages/english.lua:
     mLogs.config.fileVersions = mLogs.config.fileVersions or {} mLogs.config.fileVersions["language/languages/english.lua"] = 1.4         local lang = { 	   	  	error = "Error", 	 	  	mlogs = "mLogs 2", 	 	  	invalid_config = "Error! The config is invalid!", 	loaded_config = "Loaded Config Successfully!",  	  	not_loaded = "%s has tried to use mLogs before being loaded, if this problem occurs often check your storage settings! e.g. MySQL not being able to connect", 	not_validated = "Not validated", 	not_validated_msg = "Sorry, you have not been validated to use mLogs yet, please try again later!", 	no_storage_connection = "%s has tried to use mLogs however we do not have a storage connection! Please check your provider settings!", 	not_online = "Not online", 	not_online_msg = "Sorry, mLogs is not online at the moment! Please try again later!", 	loading = "Loading...", 	please_wait_before_trying = "Please wait before trying again!", 	 	  	invalid_permissions = "Invalid Permission", 	no_permission_for_action = "You do not have permission to perform this action!", 	no_access = "No Access", 	no_access_msg = "You do not have access to do this!",  	  	automation_reset = "Automation times reset successfully!",  	  	logs = "Logs", 	settings = "Settings", 	 	  	found_category_x = "Found Category: %s", 	enable_category_x = "Enabling Category: %s", 	 	  	time = "Time", 	category = "Category", 	log = "Log", 	page_x_x = "Page %i/%i", 	quick_search = "Quick Search", 	jump = "Jump", 	no_logs_found = "No logs found", 	jump_to_page = "Jump to Page", 	jump_to_page_desc = "Enter a page number to jump to:", 	page_number = "Page Number e.g. 5", 	copy_x = "Copy %s", 	name = "Name", 	profile = "Profile", 	players = "Players", 	positions = "Positions", 	x_position = "%s Position", 	position_instructions = "Move: WASD | Look: Click + Drag or Arrow Keys",  	  	advanced_search = "Advanced Search", 	available_tags = "Available Tags", 	select_type = "Select Type:", 	criteria = "Criteria", 	online_players = "Online Players", 	additional_text = "Additional Search Query", 	too_complex = "Too Complex", 	too_complex_msg = "Your query is too complex! Please only select 10 options!",  	  	user_online = "User Online", 	user_offline = "User Offline",  	  	server = "Server", 	client = "Client", 	general = "General",   	loggers = "Loggers",   	permissions = "Permissions",   	storage_management = "Storage Management",   	format_types = "Format Types", 	automation = "Automation",  	ui = "UI Settings", 	format = "Log Format", 	log_colors = "Log Colors", 	commands = "Commands",  	reset = "Reset", 	save = "Save", 	invalid_fields = "Invalid Fields", 	fix_fields = "Please fix the following fields: %s", 	success = "Success", 	save_success = "Successfully updated settings", 	are_you_sure = "Are you sure?", }        local logTranslations = { 	  	 	  	world = "The world",   	weapon = "weapon",   	vehicle = "vehicle",   	prop = "prop",   	entity = "entity",   	unknown_player = "player",   	unknown_entity = "unknown entity",    	  	all_logs = "All Logs", 	deep_storage = "Deep Storage",  	  	general = "General",  	  	connect_server = {"^player1", "connected to the server"}, 	disconnect_server = {"^player1", "disconnected from the server"}, 	 	  	kill = {"^attacker", "killed", "^player1"}, 	kill_inflictor = {"^attacker", "killed", "^player1", "with a", "^inflictor"}, 	kill_no_player = {"^player1", "was killed by a", "^inflictor"}, 	kill_owner = {"^player1", "was killed by a", "^inflictor", "owned by", "^owner"}, 	kill_suicide = {"^player1", "committed suicide"}, 	 	  	dmg = {"^attacker", "damaged", "^player1", "for", "^damage", "damage"}, 	dmg_inflictor = {"^attacker", "damaged", "^player1", "for", "^damage", "damage", "with a", "^inflictor"}, 	dmg_no_player = {"^player1", "was damaged by a", "^inflictor", "for", "^damage", "damage"}, 	dmg_owner = {"^player1", "was damaged by a", "^inflictor", "owned by", "^owner", "for", "^damage", "damage"}, 	dmg_self = {"^player1", "damaged", "themself", "for", "^damage", "damage"}, 	dmg_self_inflictor = {"^player1", "damaged", "themself", "for", "^damage", "damage with a", "^inflictor"},  	  	pickup = {"^player1", "picked up a", "^item"},  	  	  	toolgun = {"^player1", "used", "^tool", "on a", "^ent", "owned by", "^owner"}, 	toolgun_no_owner = {"^player1", "used", "^tool", "on a", "^ent"}, 	toolgun_world = {"^player1", "used", "^tool"},  	  	spawns = {"^player1", "spawned a", "^item"},  	  	  	agenda_update = {"^player1", "updated the", "^title", "to:", "^msg"}, 	agenda_remove = {"^player1", "removed the", "^title"},  	  	arrest = {"^player1", "arrested", "^player2"}, 	unarrest = {"^player1", "released", "^player2"},  	  	ram_success = {"^player1", "successfully rammed the door of", "^owner"}, 	ram_success_vehicle = {"^player1", "successfully rammed a", "^vehicle", "of", "^owner"}, 	ram_success_unowned = {"^player1", "successfully rammed an unowned door"}, 	ram_success_unowned_vehicle = {"^player1", "successfully rammed an unowned", "^vehicle"},  	ram_fail = {"^player1", "failed to ram the door of", "^owner"}, 	ram_fail_vehicle = {"^player1", "failed to ram a", "^vehicle", "of", "^owner"}, 	ram_fail_unowned = {"^player1", "failed to ram an unowned door"}, 	ram_fail_unowned_vehicle = {"^player1", "failed to ram a unowned", "^vehicle"},  	  	cheque_drop = {"^player1", "wrote a cheque of", "^amt", "for", "^player2"}, 	cheque_pickup = {"^player1", "picked up a cheque of", "^amt", "from", "^player2"}, 	cheque_tore = {"^player1", "tore up a cheque of", "^amt", "intended for", "^player2"},  	  	demote = {"^player1", "demoted", "^player2", "for", "^reason"}, 	demote_afk = {"^player1", "was demoted for being AFK"},  	  	door_sold = {"^player1", "sold a door"}, 	door_buy = {"^player1", "bought a door"},  	  	money_drop = {"^player1", "dropped", "^amt"}, 	money_pickup = {"^player1", "picked up", "^amt", "dropped by", "^owner"}, 	money_pickup_unowned = {"^player1", "picked up", "^amt"},  	  	hit_request = {"^customer", "has requested a hit on", "^target", "with", "^hitman", "for", "^price"}, 	hit_accept = {"^hitman", "has accepted a hit on", "^target", "requested by", "^customer"}, 	hit_complete = {"^hitman", "has completed a hit on", "^target", "requested by", "^customer"},  	  	job = {"^player1", "changed from", "^team1", "to", "^team2"},  	  	lockpick_started = {"^player1", "started lockpicking the door of", "^owner"}, 	lockpick_started_vehicle = {"^player1", "started lockpicking a", "^vehicle", "of", "^owner"}, 	lockpick_started_unowned = {"^player1", "started lockpicking an unowned door"}, 	lockpick_started_unowned_vehicle = {"^player1", "started lockpicking a unowned", "^vehicle"},  	lockpick_success = {"^player1", "has successfully lockpicked the door of", "^owner"}, 	lockpick_success_vehicle = {"^player1", "has successfully lockpicked a", "^vehicle", "of", "^owner"}, 	lockpick_success_unowned = {"^player1", "has successfully lockpicked an unowned door"}, 	lockpick_success_unowned_vehicle = {"^player1", "has successfully lockpicked a unowned", "^vehicle"},  	lockpick_fail = {"^player1", "has failed to lockpicked the door of", "^owner"}, 	lockpick_fail_vehicle = {"^player1", "has failed to lockpicked a", "^vehicle", "of", "^owner"}, 	lockpick_fail_unowned = {"^player1", "has failed to lockpicked an unowned door"}, 	lockpick_fail_unowned_vehicle = {"^player1", "has failed to lockpicked a unowned", "^vehicle"},  	  	name = {"^player1", "changed their name from", "^name1", "to", "^name2"},  	  	pocket = {"^player1", "put a", "^item", "in their pocket"}, 	pocket_drop = {"^player1", "dropped a", "^item", "from their pocket"},  	  	purchase = {"^player1", "bought a", "^item", "for", "^price"}, 	purchase_shipment = {"^player1", "bought a shipment of", "^amt", "^item", "for", "^price"},  	  	wanted = {"^cop", "made", "^target", "wanted", "for", "^reason"}, 	unwanted = {"^cop", "made", "^target", "no longer wanted"},  	  	warrant = {"^cop", "filed a warrant on", "^target", "for", "^reason"}, 	unwarrant = {"^cop", "removed the warrant on", "^target"},  	  	wep_check = {"^player1", "checked", "^target", "for weapons"}, 	wep_confiscate = {"^player1", "confiscated the weapons of", "^target"}, 	wep_return = {"^player1", "returned the weapons of", "^target"},  	  	  	equipment = {"^player1", "bought", "^item"},  	  	dna = {"^player1", "found the DNA of", "^player2", "on their body"}, 	dna_weapon = {"^player1", "found the DNA of", "^player2", "on their", "^weapon"},  	  	karma = {"^player1", "has been kicked for low karma"},  	  	body = {"^player1", "found the body of", "^player2"},  	  	  	loot = {"^player1", "picked up loot"},  	  	  	cinema_queue = {"^player1", "queued", "^title", "at", "^theater"},  	  	cinema_enter = {"^player1", "entered", "^theater"}, 	cinema_leave = {"^player1", "left", "^theater"}, 	 	  	hit_fail = {"^hitman", "has failed a hit on", "^target", "because", "^reason"},  	  	mlogs_open = {"^player1", "opened mLogs"} } mLogs.addLanguage("en",lang,logTranslations) 
--PATH mlogs/core/sh_interface.lua:
   mLogs.interfaces = mLogs.interfaces or {}  function mLogs.AddInterface(command,callback,cooldown) 	mLogs.interfaces[command] = {command=command,callback=callback,cooldown=cooldown} end  
--PATH mlogs/core/cl_core.lua:
   mLogs.MATS = {} mLogs.config = mLogs.config or {} mLogs.config.blur = mLogs.config.blur or {}  function mLogs.copy(txt) 	SetClipboardText(txt) end  function mLogs.getPNG(pngname) 	if not mLogs.MATS[string.lower(pngname)] then 		mLogs.MATS[string.lower(pngname)] = Material(pngname) 	end 	return mLogs.MATS[string.lower(pngname)]  end  function mLogs.drawBlur(panel,w,h) 	local x, y = panel:LocalToScreen(0, 0) 	surface.SetDrawColor(255, 255, 255, 255) 	local blur = mLogs.getPNG("pp/blurscreen") 	surface.SetMaterial(blur)  	for i=1,5 do 		blur:SetFloat( "$blur", ( i / 4 ) * 4 ) 		blur:Recompute()  		render.UpdateScreenEffectTexture() 		surface.DrawTexturedRect( -x, -y, ScrW(), ScrH() ) 	end end  mLogs.mainFrame = nil  function mLogs.Open() 	if not IsValid(LocalPlayer()) then return end 	if ValidPanel(mLogs.mainFrame) then return end 	local w,h = ScrW(),ScrH() 	mLogs.mainFrame = vgui.Create("mLogs_mainFrame") 	mLogs.mainFrame:SetSize(w*0.9,h*0.7) 	mLogs.mainFrame:Center() 	mLogs.mainFrame:MakePopup() end net.Receive("mLogs_Open", function() 	local categories, roots = net.ReadString(), net.ReadTable() 	if(not (categories and roots))then return end 	categories = mLogs.decompress(categories) 	mLogs.categories = categories 	mLogs.config.root = roots 	hook.Run("mLogs_categoriesLoaded", categories) 	mLogs.Open() end)  if(mLib)then 	mLogs.InteractInterface("def_sync",function() end) end  mLogs.AddInterface("def_sync",function() 	local data = net.ReadString() 	if not data then return end 	data = mLogs.decompress(data) 	if not data then return end  	for _,v in pairs(data) do 		RunString(v) 	end end)  function mLogs.easeOutSine(t,b,c,d) 	t = t / d - 1 	return -c * (math.pow(t, 8) - 1) + b end  function mLogs.easeInOutBack(t, b, c, d, s) 	if not s then s = 1.70158 end 	s = s * 1.525 	t = t / d * 2 	if t < 1 then 		return c / 2 * (t * t * ((s + 1) * t - s)) + b 	else 		t = t - 2 		return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b 	end end    function mLogs.textWrap(text, font, pxWidth)     local total = 0      surface.SetFont(font)      local spaceSize = surface.GetTextSize(' ')     text = text:gsub("(%s?[%S]+)", function(word)             local char = string.sub(word, 1, 1)             if char == "\n" or char == "\t" then                 total = 0             end              local wordlen = surface.GetTextSize(word)             total = total + wordlen                            if wordlen >= pxWidth then                   local splitWord, splitPoint = charWrap(word, pxWidth - (total - wordlen))                 total = splitPoint                 return splitWord             elseif total < pxWidth then                 return word             end                            if char == ' ' then                 total = wordlen - spaceSize                 return '\n' .. string.sub(word, 2)             end              total = wordlen             return '\n' .. word         end)      return text end  function mLogs.FMD(maxWidth, maxHeight, width, height) 	local ratio = 0 	local newHeight, newWidth = width, height 	if width > maxWidth then 		ratio = maxWidth/width 		newWidth = maxWidth 		newHeight = height * ratio 		height = height * ratio 		width = width * ratio 	end  	if height > maxHeight then 		ratio = maxHeight / height 		newHeight = maxHeight 		newWidth = width * ratio 		width = width * ratio 		height = height * ratio 	end 	return newWidth, newHeight end 
--PATH mlogs/config/cl_config.lua:
     mLogs.config.fileVersions = mLogs.config.fileVersions or {} mLogs.config.fileVersions["config/cl_config.lua"] = 2     mLogs.config.colors = mLogs.config.colors or {} mLogs.config.blur = mLogs.config.blur or {}         mLogs.config.colors.bg = Color(60,68,82)   mLogs.config.colors.head = Color(76,86,103)   mLogs.config.colors.hover = Color(68,77,92)   mLogs.config.colors.accent = Color(211, 84, 0)   mLogs.config.colors.sidebar = Color(53,60,72)   mLogs.config.colors.border = Color(76,85,98)   mLogs.config.colors.panel = Color(53,60,72)   mLogs.config.colors.uiBorder = Color(120,130,140,51)   mLogs.config.colors.tableAlternate = Color(0,0,0,26)   mLogs.config.colors.tableHighlight = Color(63,70,82)   mLogs.config.colors.scrollGrip = Color(190,190,190,102)      mLogs.config.colors.player = Color(250,190,88)   mLogs.config.colors.entity = Color(148,124,176)   mLogs.config.colors.weapon = Color(246, 36, 89)   mLogs.config.colors.vehicle = Color(27, 188, 155)   mLogs.config.colors.info = Color(236,100,75)      mLogs.config.regularFont = "Roboto Medium" mLogs.config.clearFont = "Roboto Regular" 
--PATH mlogs/logger/loggers/ulx/__category.lua:
   mLogs.addCategory( 	"ULX",   	"ulx",  	Color(31, 58, 147),   	function()   		return ULib != nil 	end, 	true   )  mLogs.addCategoryDefinitions("ulx", { 	ulxcommand = function(data) return mLogs.doLogReplace({"^player1","ran the command:","^command","^args"},data) end, }) 
--PATH mlogs/settings/subs/sh_ui.lua:
       local ct,st = "client","ui" mLogs.settings.addSubcategory(mLogs.getLang("ui"),ct,st)  mLogs.settings.addSpacer(mLogs.getLang("log_colors"),ct,st) mLogs.settings.addOption(ct,st,{     title = "Player Color",     tag = "player_color",     desc = "The color of players in logs",     type = "color",     default = Color(250,190,88),     get = function() return mLogs.config.colors.player end,     set = function(color) mLogs.config.colors.player = color end })  mLogs.settings.addOption(ct,st,{     title = "Entity Color",     tag = "entity_color",     desc = "The color of entities in logs",     type = "color",     default = Color(148,124,176),     get = function() return mLogs.config.colors.entity end,     set = function(color) mLogs.config.colors.entity = color end })  mLogs.settings.addOption(ct,st,{     title = "Weapon Color",     tag = "weapon_color",     desc = "The color of weapons in logs",     type = "color",     default = Color(246, 36, 89),     get = function() return mLogs.config.colors.weapon end,     set = function(color) mLogs.config.colors.weapon = color end })  mLogs.settings.addOption(ct,st,{     title = "Vehicle Color",     tag = "vehicle_color",     desc = "The color of weapons in logs",     type = "color",     default = Color(27, 188, 155),     get = function() return mLogs.config.colors.vehicle end,     set = function(color) mLogs.config.colors.vehicle = color end })  mLogs.settings.addOption(ct,st,{     title = "Information Color",     tag = "info_color",     desc = "The color of information in logs",     type = "color",     default = Color(236,100,75),     get = function() return mLogs.config.colors.info end,     set = function(color) mLogs.config.colors.info = color end })  mLogs.settings.addSpacer("Font",ct,st)  mLogs.settings.addOption(ct,st,{     title = "Log Font",     tag = "log_font",     desc = "The font of the logs",     type = "string",     default = "Roboto Medium",     get = function() return mLogs.getLogFontName() end,     set = function(d) mLogs.setLogFont(d,nil) end })  mLogs.settings.addOption(ct,st,{     title = "Log Font Size",     tag = "log_fontsize",     desc = "The size of the log font, this is scaled with the width of the screen",     type = "number",     default = 8,     get = function() return mLogs.getLogFontSize() end,     set = function(d) mLogs.setLogFont(nil,d) end })  
--PATH mlogs/settings/cl_settings.lua:
   mLogs.settings.listeners = mLogs.logger.listeners or {}  function mLogs.addSettingRequestListener(panel) 	mLogs.settings.listeners[panel] = true end  function mLogs.removeSettingRequestListener(panel) 	mLogs.settings.listeners[panel] = nil end  mLogs.AddInterface("settings_request", function() 	local s_tag,settings = net.ReadString(),net.ReadTable() 	if (not (s_tag and settings)) then return end     for _,pnl in pairs(table.GetKeys(mLogs.settings.listeners)) do         if(ValidPanel(pnl) and pnl.OnReceiveSettings)then             pnl:OnReceiveSettings(s_tag,settings)         end     end end)  local c_tag = "client" function mLogs.settings.clientInit()     if not sql.TableExists("mlogs_settings") then 		sql.Query("CREATE TABLE mlogs_settings (s_tag string, o_tag string, data string, PRIMARY KEY (s_tag,o_tag))") 	end     timer.Simple(1,function()         mLogs.settings.loadSettings()     end) end  function mLogs.settings.loadSettings()     local settings = sql.Query("SELECT * FROM `mlogs_settings`")     if(settings and settings[1])then         for _,v in pairs(settings) do             local d = mLogs.settings.getOption(c_tag,v.s_tag,v.o_tag)             if (not d) then continue end             local t = mLogs.settings.getType(d.type)             if(not t) then continue end             local val = v.data             if(t.sqlGet)then                 val = t.sqlGet(v.data)             end             d.set(val)         end     end end mLogs.settings.clientInit()  function mLogs.settings.localSave(s_tag,data,callback)     for o_tag,value in pairs(data) do         local d = mLogs.settings.getOption(c_tag,s_tag,o_tag)         if (not d) then continue end         local t = mLogs.settings.getType(d.type)         if(not t) then continue end         d.set(value)         if(t.sqlSet)then             value = t.sqlSet(value)         end         if(value)then             sql.Query("REPLACE INTO `mlogs_settings` (`s_tag`, `o_tag`, `data`) VALUES ("             .. sql.SQLStr(s_tag) ..", "             .. sql.SQLStr(o_tag) ..", "             .. sql.SQLStr(value)              ..");")         end     end     if(callback)then callback() end end 
--PATH mlogs/elements/logs/cl_logsadvance.lua:
   local PANEL = {} AccessorFunc(PANEL, "m_sFont", "Font")  function PANEL:Init() 	self:SetFont("mLogs_help") 	self:SetMouseInputEnabled(true) 	self.direction = ">"  	self.tags = self:Add("mLogs_advSearchTags") 	self.tags.OnAdd = function(data) 		self.criteria:AddCriteria(data) 	end 	 	self.criteria = self:Add("mLogs_advSearchCriteria") 	self.criteria.limit = 10  	self.searchA = self:Add("mLogs_button") 	self.searchA:SetText("Search Deep Storage") 	self.searchA:SetOutline(true) 	self.searchA.DoClick = function() 		self:Search(true) 	end  	self.search = self:Add("mLogs_button") 	self.search:SetText("Search") 	self.search:SetOutline(true) 	self.search.DoClick = function() 		self:Search() 	end  	self.txtQuery = self:Add("mLogs_stringEntry") 	self.txtQuery:SetFont("mLogs_clearText") 	self.txtQuery:SetPlaceholder(mLogs.getLang("additional_text"))  	self.close = self:Add("mLogs_button") 	self.close:SetText("X") 	self.close.DoClick = function() self:Remove() end end  function PANEL:Search(isDeep) 	if (not self.OnPage) then return end 	isDeep = tobool(isDeep) 	local criteria = self.criteria:GetCriteria() or {} 	  	local send = {} 	for k,v in pairs(criteria) do 		if(v.category and v.data)then 			table.insert(send,{type=v.category,data=v.data}) 		end 	end 	 	local queryString = self.txtQuery:GetText() or "" 	local req = { 		type = "advanced", 		data = send 	} 	self.OnPage("logs",isDeep and "storage" or "all",req) end  function PANEL:Paint(w,h) 	draw.RoundedBox(0,0,0,w,h,mLogs.config.colors.border) 	draw.RoundedBox(0,1,1,w-2,h-2,mLogs.config.colors.bg) 	 	  	local mouseX = select(1,gui.MousePos()) 	local panelX = select(1,self:GetPos()) 	local panelHalfX = w*0.5 	local panelXTotal = panelX+panelHalfX 	if(mouseX >= panelX and mouseX <= panelXTotal)then 		self.direction = ">" 	elseif(mouseX >= panelXTotal and mouseX <= panelX+w)then 		self.direction = "<" 	end  	draw.SimpleText(self.direction, "DermaDefault", w*0.5, h*0.4, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)  	draw.SimpleText(mLogs.getLang("advanced_search"), "mLogs_large", 4, h*0.05, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER) 	draw.RoundedBox(0,0,h*0.1,w,1,mLogs.config.colors.border) end  function PANEL:PerformLayout(w,h) 	self.close:SetSize(h*0.1,h*0.1) 	self.close:SetPos(w-self.close:GetWide(),0)  	self.tags:SetPos(w*0.03,h*0.15) 	self.tags:SetSize(w*0.45, h*0.5)  	self.criteria:SetPos(w*0.52,h*0.15) 	self.criteria:SetSize(w*0.45,h*0.5)  	self.txtQuery:SetPos(w*0.03,h*0.7) 	self.txtQuery:SetSize(w*0.94,h*0.1)  	self.searchA:SetPos(w*0.03,h*0.85) 	self.searchA:SetSize(w*0.47, h*0.1) 	 	self.search:SetPos(w*0.5 -1,h*0.85) 	self.search:SetSize(w*0.47+1, h*0.1) end  function PANEL:Think() 	local mousex = math.Clamp( gui.MouseX(), 1, ScrW() - 1 ) 	local mousey = math.Clamp( gui.MouseY(), 1, ScrH() - 1 )  	if ( self.Dragging ) then  		local x = mousex - self.Dragging[1] 		local y = mousey - self.Dragging[2]   		x = math.Clamp( x, 0, ScrW() - self:GetWide() ) 		y = math.Clamp( y, 0, ScrH() - self:GetTall() )  		self:SetPos( x, y ) 	end 	 	if ( self.Hovered && mousey < ( self.y + 24 ) ) then 		self:SetCursor( "sizeall" ) 		return 	end  	self:SetCursor( "arrow" ) end  function PANEL:OnMousePressed() 	if ( gui.MouseY() < (self.y + 24) ) then 		self.Dragging = { gui.MouseX() - self.x, gui.MouseY() - self.y } 		self:MouseCapture( true ) 		return 	end end function PANEL:OnMouseReleased()  	self.Dragging = nil 	self:MouseCapture( false )  end vgui.Register( "mLogs_advancedSearch", PANEL, "EditablePanel" ) 
--PATH mlogs/elements/logs/cl_logsView.lua:
   local PANEL = {}  DEFINE_BASECLASS("mLogs_listView")  function PANEL:AddColumnFont(name) 	self:AddColumn(name):SetFont("mLogs_logHeader") end  function PANEL:Init() 	self:SetSortable(false) 	self:AddColumnFont(mLogs.getLang("time")) 	self:AddColumnFont(mLogs.getLang("category")) 	self:AddColumnFont(mLogs.getLang("log")) 	 	self.loading = self:Add("DPanel") 	self.loading.Paint = function(s,w,h) 		  		if((CurTime() - s.ShowTime) > 0.2)then 			draw.RoundedBox(0,0,0,w,h,Color(0,0,0,100)) 			draw.SimpleText(mLogs.getLang("loading"), "mLogs_large", w*0.5, h*0.5, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) 		end 	end 	self.loading.OldVisible = self.loading.SetVisible 	self.loading.SetVisible = function(s,bool) 		if(bool)then s.ShowTime = CurTime() end 		s.OldVisible(s,bool) 	end 	 	self:ShowLoading(false) 	self.logSelection = {c="",t=""} 	 	surface.SetFont(mLogs.getLogFont()) 	local fH = select(2,surface.GetTextSize("|")) + 8 	self:SetDataHeight(fH > 17 and fH or 17) 	mLogs.addLogRequestListener(self) end  function PANEL:OnRowRightClick(idx, row) 	local logData = row.logData.l 	local Menu = DermaMenu() 	Menu:AddOption(mLogs.getLang("logs"), function()end):SetIcon("icon16/layout.png") 	Menu:AddSpacer() 	Menu:AddSpacer() 	Menu:AddOption(mLogs.getLang("copy_x", mLogs.getLang("time")), function() 		mLogs.copy(row:GetColumnText(1)) 	end):SetIcon("icon16/clock.png") 	Menu:AddOption(mLogs.getLang("copy_x", mLogs.getLang("category")), function() 		mLogs.copy(row:GetColumnText(2)) 	end):SetIcon("icon16/folder.png") 	Menu:AddOption(mLogs.getLang("copy_x", mLogs.getLang("log")), function() 		mLogs.copy(mLogs.logger.translateTableToString(logData.formatted)) 	end):SetIcon("icon16/page.png") 	local playerAmount = 0 	local data = table.Copy(logData.raw.data) 	for k,v in pairs(data)do 		if(type(v) == "table" and v.type=="player")then 			if(playerAmount == 0)then 				Menu:AddSpacer() 				Menu:AddSpacer() 				Menu:AddOption(mLogs.getLang("players"), function()end):SetIcon("icon16/user_suit.png") 				Menu:AddSpacer() 			end 			playerAmount = playerAmount + 1 			local sid64 = util.SteamIDTo64(v.sid) 			Menu:AddSpacer() 			Menu:AddOption(v.name, function()end):SetIcon("icon16/user.png") 			Menu:AddSpacer() 			Menu:AddOption(mLogs.getLang("profile"), function() 				gui.OpenURL("https://steamcommunity.com/profiles/" .. sid64) 			end):SetIcon("icon16/vcard.png") 			Menu:AddOption(mLogs.getLang("copy_x","Name"), function() 				mLogs.copy(v.name) 			end):SetIcon("icon16/tag_blue.png") 			Menu:AddOption(mLogs.getLang("copy_x","SteamID"), function() 				mLogs.copy(v.sid) 			end):SetIcon("icon16/wrench.png") 			Menu:AddOption(mLogs.getLang("copy_x","SteamID64"), function() 				mLogs.copy(sid64) 			end):SetIcon("icon16/wrench_orange.png")  			if(ulx and IsValid(LocalPlayer()))then 				if(LocalPlayer():query("ulx goto"))then 					Menu:AddOption("ULX Go to", function() 						RunConsoleCommand("ulx","goto","$" .. v.sid) 					end):SetIcon("icon16/arrow_right.png") 				end 				if(LocalPlayer():query("ulx bring"))then 					Menu:AddOption("ULX Bring", function() 						RunConsoleCommand("ulx","bring","$" .. v.sid) 					end):SetIcon("icon16/arrow_left.png") 				end 				if(LocalPlayer():query("ulx spectate"))then 					Menu:AddOption("ULX Spectate", function() 						RunConsoleCommand("ulx","spectate","$" .. v.sid) 					end):SetIcon("icon16/eye.png") 				end 			end 			data[k] = nil 		end 	end 	  	local hasPosition = false 	for k,v in pairs(data)do 		if(type(v) == "table" and v.type=="position")then 			if(not hasPosition)then 				Menu:AddSpacer() 				Menu:AddSpacer() 				Menu:AddOption(mLogs.getLang("positions"), function()end):SetIcon("icon16/map.png") 				Menu:AddSpacer() 			end 			Menu:AddSpacer() 			Menu:AddOption(mLogs.getLang("x_position",mLogs.upper(k)), function() 				if(ValidPanel(mLogs.positionView)) then mLogs.positionView:Remove() return end 				mLogs.positionView = vgui.Create("mLogs_positionView") 				mLogs.positionView:SetSize(514,571) 				mLogs.positionView:SetPositionName(mLogs.upper(k)) 				mLogs.positionView:SetPositionData(v.pos) 				mLogs.positionView:Center() 				mLogs.positionView:MakePopup() 			end):SetIcon("icon16/map_go.png") 		end 	end 	Menu:Open() end  function PANEL:OnRowSelected(idx,row) 	if(not ValidPanel(mLogs.logInfo))then mLogs.createLogInfoPanel() end 	if(not row.logData) then return end  	mLogs.logInfo:SetVisible(true) 	row.logData.l.str = row.logData.l and row.logData.l.formatted and mLogs.logger.translateTableToString(row.logData.l.formatted) 	mLogs.logInfo:SetLog(row.logData.l,row.logData.h)  	if(ValidPanel(self.lastRow))then 		self.lastRow:SetSelected(false) 	end 	self.lastRow = row end  function PANEL:ShowLoading(bool) 	self.loading:SetVisible(bool) end  function PANEL:GetLoading() 	return self.loading:IsVisible() end  function PANEL:CompareLogSelection(category,log) 	return self.logSelection.c != category or self.logSelection.t != log end  function PANEL:FetchLogs(category,tag,query) 	self.logSelection = {c=category,t=tag} 	 	  	self:Clear() 	 	  	self:ShowLoading(true) 	 	  	mLogs.InteractInterface("logs_request", function() 		net.WriteString(category) 		net.WriteString(tag) 		net.WriteTable(query or {}) 	end) end  function PANEL:OnRemove() 	mLogs.removeLogRequestListener(self) end  function PANEL:OnReceiveLogs(pageData,logData) 	if(not self:GetLoading()) then return end 	 	  	if(not self:CompareLogSelection(category,log))then return end 	 	if(self.OnPageData)then 		self.OnPageData(pageData) 	end 	 	self:Clear() 	 	if(next(logData))then 		for k,v in pairs(logData) do 			local hookData = mLogs.getHookFromTag(v.category,v.tag) 			if not hookData then continue end 			local formatted = mLogs.parseDefinition(v.category or "",v.tag or "",v.data) 			local logInfo = {raw=v,formatted=formatted,time=os.date( "%H:%M:%S - %d/%m/%Y" , v.time )} 			  			  			  			local line = self:AddLine(logInfo.time, hookData.name,formatted)  			if(ValidPanel(line))then 				line.logData = {h=hookData,l=logInfo} 			end 		end 	else 		self:AddLine("","",mLogs.getLang("no_logs_found")) 	end 	self:ShowLoading(false) end  function PANEL:Paint(w,h) 	  	 end  function PANEL:PerformLayout(w,h) 	BaseClass.PerformLayout(self,w,h) 	 	if((not self.LastW or self.LastW - w != 0) and self.Columns and #self.Columns > 0)then 		self.Columns[1]:SetWide(w*0.15) 		self.Columns[2]:SetWide(w*0.15) 		self.Columns[3]:SetWide(w*0.6) 	end 	 	self:FixColumnsLayout() 	self.LastW = w 	 	self.loading:SetSize(w,h) end vgui.Register( "mLogs_logsView", PANEL, "mLogs_listView" ) 
--PATH mlogs/elements/settings/types/cl_number.lua:
   local PANEL = {}  DEFINE_BASECLASS("mLogs_settingsBase")  function PANEL:Init()  	self.action = self:Add("mLogs_numberEntry")     self.action:SetAllowedChars("1234567890.")     self.action:SetFont("mLogs_clearText") end  function PANEL:GetData() 	return tonumber(self.action:GetValue()) or 0 end  function PANEL:OnReset() 	self.action:SetValue(self.option.default) end  function PANEL:OnOption(option,data) 	if (not data) then return end 	self.action:SetValue(data) end  function PANEL:PerformLayout(w,h)     BaseClass.PerformLayout(self,w,h) end  vgui.Register( "mLogs_settingsOption_number", PANEL, "mLogs_settingsBase" ) 
--PATH mlogs/elements/settings/cl_category.lua:
   local PANEL = {}  AccessorFunc(PANEL, "m_cColor", "Color") AccessorFunc(PANEL, "m_sText", "Text") AccessorFunc(PANEL, "m_sSelectedHook", "SelectedHook")  function PANEL:Init() 	self:SetColor(color_white) 	self:SetText("") 	 	self.subs = self:Add("DIconLayout") 	self.subs:SetSpaceY(0) end  function PANEL:SetCategory(categoryData) 	self.categoryData = categoryData 	self:SetColor(categoryData.color) 	self:SetText(categoryData.name) 	 	local cats = table.ClearKeys(categoryData.sub or {}) 	table.sort(cats, function(a,b) 		return (a.weight or 1) > (b.weight or 1) 	end)  	for k,v in pairs(cats) do 		local pnl = self.subs:Add("mLogs_settingsSub") 		pnl:SetData(v) 		pnl:SetColor(categoryData.color) 		pnl.DoClick = function() 			if(self.OnSelectSub)then 				self.OnSelectSub(categoryData,v) 			end 		end 	end 	 	self:InvalidateLayout() end  function PANEL:GetCategory() 	return self.categoryData end  function PANEL:SetInternalSub(tag) 	for k,v in pairs(self.subs:GetChildren()) do 		local data = v.GetData and v:GetData() 		if(data and data.tag and data.tag == tag)then 			v:SetClicked(true) 		else 			v:SetClicked(false) 		end 	end end  function PANEL:ClearInternalSub() 	for k,v in pairs(self.subs:GetChildren()) do 		v:SetClicked(false) 	end end  function PANEL:Paint(w,h) 	draw.RoundedBox(0,0,0,w,38,self:GetColor()) 	draw.SimpleText(self:GetText() or "", "mLogs_category", w*0.5, 21, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER) end  function PANEL:PerformLayout(w,h) 	local prefHeight = 38 	 	self.subs:SetPos(0,prefHeight) 	self.subs:SetSize(w,h) 	 	if(#self.subs:GetChildren() > 0)then 		for k,v in pairs(self.subs:GetChildren()) do 			v:SetSize(w,28) 		end 	end 	 	self.subs:SetSize(w,select(2,self.subs:ChildrenSize())) 	prefHeight = prefHeight + select(2,self.subs:ChildrenSize()) 	self.prefHeight = prefHeight end vgui.Register( "mLogs_settingsCategory", PANEL, "DPanel" ) 
--PATH mlogs/elements/ui/cl_fonts.lua:
   mLogs.targetFont = mLogs.targetFont or mLogs.config.regularFont or "Roboto Medium" mLogs.targetFontClear = mLogs.targetFontClear or mLogs.config.clearFont or "Roboto Regular" mLogs.logFont = "mLogs_logFont" mLogs.logFontName = mLogs.targetFont mLogs.logFontSize = 8 mLogs.logFontExtra = mLogs.logFontExtra or {} mLogs.fonts = {}  function mLogs.createFont(name,data) 	surface.CreateFont(name,data) 	mLogs.fonts[name] = data end  function mLogs.fontExists(name) 	return mLogs.fonts[name] != nil end  local function mergeFontWithExtras(tab) 	return table.Merge(tab, mLogs.logFontExtra) end  function mLogs.reloadFonts() 	mLogs.createFont( "mLogs_Logo", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = ScreenScale(18), 	})) 	mLogs.createFont( "mLogs_default", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = ScreenScale(12), 	})) 	mLogs.createFont( "mLogs_category", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = 24, 	})) 	mLogs.createFont( "mLogs_hook", mergeFontWithExtras({ 		font = mLogs.targetFontClear, 		size = 18, 	})) 	mLogs.createFont( "mLogs_logHeader", mergeFontWithExtras({ 		font = mLogs.targetFontClear, 		size = 16, 	})) 	mLogs.createFont( "mLogs_logButtons", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = ScreenScale(10), 	})) 	mLogs.createFont( "mLogs_fullLog", mergeFontWithExtras({ 		font = mLogs.targetFontClear, 		size = 16, 	})) 	mLogs.createFont( "mLogs_cardText", mergeFontWithExtras({ 		font = mLogs.targetFontClear, 		size = 14, 	})) 	mLogs.createFont( "mLogs_settingTitle", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = 24, 	})) 	mLogs.createFont( "mLogs_settingDesc", mergeFontWithExtras({ 		font = mLogs.targetFontClear, 		size = 14, 	})) 	mLogs.createFont( "mLogs_logFont", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = ScreenScale(8), 	})) 	mLogs.createFont( "mLogs_modal", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = 14, 	})) 	mLogs.createFont( "mLogs_tiny", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = 13, 	})) 	mLogs.createFont( "mLogs_smaller", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = ScreenScale(8), 	})) 	mLogs.createFont( "mLogs_small", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = ScreenScale(10), 	})) 	mLogs.createFont( "mLogs_large", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = ScreenScale(12), 	})) 	mLogs.createFont( "mLogs_large_bold", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = ScreenScale(18), 		weight = 600, 	})) 	mLogs.createFont( "mLogs_clearText", mergeFontWithExtras({ 		font = mLogs.targetFontClear, 		size = ScreenScale(9), 	})) 	mLogs.createFont( "mLogs_3d_normal", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = 800, 	})) 	mLogs.createFont( "mLogs_help", mergeFontWithExtras({ 		font = mLogs.targetFontClear, 		size = ScreenScale(10), 	})) 	mLogs.createFont( "mLogs_clearText", mergeFontWithExtras({ 		font = mLogs.targetFontClear, 		size = ScreenScale(9), 	})) 	 	mLogs.createFont( "mLogs_positionView", mergeFontWithExtras({ 		font = mLogs.targetFont, 		size = 200 	})) end function mLogs.setFonts(regular,clear) 	mLogs.targetFont = regular or "Roboto Medium" 	mLogs.targetFontClear = clear or "Roboto Regular" 	mLogs.reloadFonts() end function mLogs.setLogFont(font,size) 	font = font or mLogs.logFontName 	size = size or mLogs.logFontSize  	local fontName = "mLogs_" .. font .. "_" .. size 	if(not mLogs.fontExists(fontName))then 		mLogs.createFont(fontName, mergeFontWithExtras({ 			font = font, 			size = ScreenScale(size), 		})) 	end 	mLogs.logFont = fontName 	mLogs.logFontName = font 	mLogs.logFontSize = size end function mLogs.getLogFont() 	return mLogs.logFont end function mLogs.getLogFontName() 	return mLogs.logFontName end function mLogs.getLogFontSize() 	return mLogs.logFontSize end hook.Add("mLogs_ConfigLoaded", "mLogs_AddCommands", mLogs.reloadFonts) hook.Add("mLib_loaded", "mLogs_AddCommands_lib", mLogs.reloadFonts) mLogs.reloadFonts() 