--Stealed clientside server code by exechack.cc
--Hostname: WayZer's Role Play | Быстрая загрузка - Part 4/5 - 06/04/2025


--addons/_wlib/lua/wlib/modules/include.lua:
-- inspired by octolib (https://octothorp.team/)

wlib.include = wlib.include or {}
wlib.include.modes = wlib.include.modes or {}

local function normalizePath(path)
	return path .. (string.EndsWith(path, '/') and '' or '/')
end

function wlib.include.modes.shared(path)
    local includes = {}
	local files = file.Find(path..'*.lua', 'LUA') or {}

	for _, fileName in pairs(files) do
		local path = path..fileName

		includes[string.StripExtension(fileName)] = function()
			if SERVER then
				AddCSLuaFile(path)
			end

			include(path)
		end
	end

	return includes
end

function wlib.include.modes.server(path)
    local includes = {}
	local files = file.Find(path..'*.lua', 'LUA') or {}

	for _, fileName in pairs(files) do
		local path = path..fileName

		includes[string.StripExtension(fileName)] = function()
			include(path)
		end
	end

	return includes
end

function wlib.include.modes.client(path)
    local includes = {}
	local files = file.Find(path..'*.lua', 'LUA') or {}

	for _, fileName in pairs(files) do
		local path = path..fileName

		includes[string.StripExtension(fileName)] = function()
			if SERVER then
				AddCSLuaFile(path)
			else
				include(path)
			end
		end
	end

	return includes
end

function wlib.include.modes.modules(path)
	local includes = {}
	local _, folders = file.Find(path..'*', 'LUA')

	for _, moduleName in ipairs(folders or {}) do
		if string.StartsWith(moduleName, '.') then continue end

		local path = path..moduleName

		includes[moduleName] = function()
			if CLIENT then
				if file.Exists(path .. '/shared.lua', 'LUA') then
					include(path .. '/shared.lua')
				end

				if file.Exists(path .. '/client.lua', 'LUA') then
					include(path .. '/client.lua')
				end

				for _, v in ipairs(file.Find(path..'/sh_*.lua', 'LUA') or {}) do
					include(path..'/'..v)
				end

				for _, v in ipairs(file.Find(path..'/cl_*.lua', 'LUA') or {}) do
					include(path..'/'..v)
				end
				return
			end

			if file.Exists(path .. '/shared.lua', 'LUA') then
				include(path .. '/shared.lua')
				AddCSLuaFile(path .. '/shared.lua')
			end
			for _, v in ipairs(file.Find(path..'/sh_*.lua', 'LUA') or {}) do
				include(path..'/'..v)
				AddCSLuaFile(path..'/'..v)
			end

			if file.Exists(path .. '/server.lua', 'LUA') then
				include(path .. '/server.lua')
			end
			for _, v in ipairs(file.Find(path..'/sv_*.lua', 'LUA') or {}) do
				include(path..'/'..v)
			end

			if file.Exists(path .. '/client.lua', 'LUA') then
				AddCSLuaFile(path .. '/client.lua')
			end
			for _, v in ipairs(file.Find(path..'/cl_*.lua', 'LUA') or {}) do
				AddCSLuaFile(path..'/'..v)
			end
		end
	end

	return includes
end

function wlib.include.custom(path, findfuncs, order)
	if isfunction(findfuncs) then
		findfuncs = {findfuncs}
	end

	local includes = {}
	for _, func in ipairs(findfuncs) do
		table.Merge(includes, func(normalizePath(path)))
	end

	if istable(order) then
		for _, name in ipairs(order) do
			local names = {}
			local ignore = string.StartWith(name, '!')

			if ignore then
				name = string.sub(name, 2)
			end

			if string.find(name, '*') then
				local includeNames = table.GetKeys(includes)
				for _, includeName in SortedPairsByValue(includeNames) do
					if string.match(includeName, '^' .. string.Replace(name, '*', '.+') .. '$') then
						table.insert(names, includeName)
					end
				end
			elseif includes[name] then
				table.insert(names, name)
			end

			for _, name in ipairs(names) do
				if not ignore then
					includes[name]()
				end

				includes[name] = nil
			end
		end
	else
		for _, includeFunc in SortedPairs(includes) do
			includeFunc()
		end
	end
end

function wlib.include.prefixed(path, order)
	local sh, sv, cl = {}, {}, {}

	if istable(order) then
		for _, v in ipairs(order) do
			if string.StartsWith(v, 'sh_') then
				table.insert(sh, v)
			elseif string.StartsWith(v, 'sv_') then
				table.insert(sv, v)
			elseif string.StartsWith(v, 'cl_') then
				table.insert(cl, v)
			elseif v == '*' then
				table.insert(sh, 'sh_*')
				table.insert(sv, 'sv_*')
				table.insert(cl, 'cl_*')
			end
		end
	else
		table.insert(sh, 'sh_*')
		table.insert(sv, 'sv_*')
		table.insert(cl, 'cl_*')
	end

	wlib.include.custom(path, wlib.include.modes.shared, sh)
	wlib.include.custom(path, wlib.include.modes.server, sv)
	wlib.include.custom(path, wlib.include.modes.client, cl)
end

function wlib.include.module(path, order)
	wlib.include.custom(path, wlib.include.modes.shared, {'shared'})
	wlib.include.custom(path, wlib.include.modes.server, {'server'})
	wlib.include.custom(path, wlib.include.modes.client, {'client'})

	wlib.include.prefixed(path, order)
end

function wlib.include.modules(path, order)
	wlib.include.custom(path, {
		wlib.include.modes.modules,
		wlib.include.modes.shared,
	}, order)
end

function wlib.include.server(path, order)
	wlib.include.custom(path, wlib.include.modes.server, order)
end

function wlib.include.shared(path, order)
	wlib.include.custom(path, wlib.include.modes.shared, order)
end

function wlib.include.client(path, order)
	wlib.include.custom(path, wlib.include.modes.client, order)
end
--addons/_wlib/lua/wlib/libraries/fn.lua:
/*---------------------------------------------------------------------------
Functional library

by FPtje Atheos
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
Function currying
    Take a function with n parameters.
    Currying is the procedure of storing k < n parameters "in the function"
     in such a way that the remaining function can be called with n - k parameters

    Example:
    DebugPrint = fp{print, "[DEBUG]"}
    DebugPrint("TEST")
    > [DEBUG] TEST
---------------------------------------------------------------------------*/
function fp(tbl)
    local func = tbl[1]

    return function(...)
        local fnArgs = {}
        local arg = {...}
        local tblN = table.maxn(tbl)

        for i = 2, tblN do fnArgs[i - 1] = tbl[i] end
        for i = 1, table.maxn(arg) do fnArgs[tblN + i - 1] = arg[i] end

        return func(unpack(fnArgs, 1, table.maxn(fnArgs)))
    end
end

local unpack = unpack
local table = table
local pairs = pairs
local ipairs = ipairs
local error = error
local math = math
local select = select
local type = type
local _G = _G
local fp = fp


module("fn")

/*---------------------------------------------------------------------------
Parameter manipulation
---------------------------------------------------------------------------*/
Id = function(...) return ... end

Flip = function(f)
    if not f then error("not a function") end
    return function(b, a, ...)
        return f(a, b, ...)
    end
end

-- Definition from http://lua-users.org/wiki/CurriedLua
ReverseArgs = function(...)

   --reverse args by building a function to do it, similar to the unpack() example
   local function reverse_h(acc, v, ...)
      if select('#', ...) == 0 then
         return v, acc()
      else
         return reverse_h(function () return v, acc() end, ...)
      end
   end

   -- initial acc is the end of the list
   return reverse_h(function () return end, ...)
end

/*---------------------------------------------------------------------------
Misc functions
---------------------------------------------------------------------------*/
-- function composition
do
    local function comp_h(a, b, ...)
        if b == nil then return a end
        b = comp_h(b, ...)
        return function(...)
            return a(b(...))
        end
    end
    Compose = function(funcs, ...)
        if type(funcs) == "table" then
            return comp_h(unpack(funcs))
        else
            return comp_h(funcs, ...)
        end
    end
end

_G.fc = Compose

-- Definition from http://lua-users.org/wiki/CurriedLua
Curry = function(func, num_args)
    if not num_args then error("Missing argument #2: num_args") end
    if not func then error("Function does not exist!", 2) end
    -- helper
    local function curry_h(argtrace, n)
        if n == 0 then
            -- reverse argument list and call function
            return func(ReverseArgs(argtrace()))
        else
            -- "push" argument (by building a wrapper function) and decrement n
            return function(x)
                return curry_h(function() return x, argtrace() end, n - 1)
            end
        end
   end

   -- no sense currying for 1 arg or less
   if num_args > 1 then
      return curry_h(function() return end, num_args)
   else
      return func
   end
end

-- Thanks Lexic!
Partial = function(func, ...)
    local args = {...}
    return function(...)
        return func(unpack(table.Add( args, {...})))
    end
end

Apply = function(f, ...) return f(...) end

Const = function(a, b) return a end
Until = function(cmp, fn, val)
    if cmp(val) then
        return val
    end
    return Until(cmp, fn, fn(val))
end

Seq = function(f, x) f(x) return x end

GetGlobalVar = function(key) return _G[key] end

/*---------------------------------------------------------------------------
Mathematical operators and functions
---------------------------------------------------------------------------*/
Add = function(a, b) return a + b end
Sub = function(a, b) return a - b end
Mul = function(a, b) return a * b end
Div = function(a, b) return a / b end
Mod = function(a, b) return a % b end
Neg = function(a)    return -a    end

Eq  = function(a, b) return a == b end
Neq = function(a, b) return a ~= b end
Gt  = function(a, b) return a > b  end
Lt  = function(a, b) return a < b  end
Gte = function(a, b) return a >= b end
Lte = function(a, b) return a <= b end

Succ = Compose{Add, 1}
Pred = Compose{Flip(Sub), 1}
Even = Compose{fp{Eq, 0}, fp{Flip(Mod), 2}}
Odd  = Compose{Not, Even}

/*---------------------------------------------------------------------------
Functional logical operators and conditions
---------------------------------------------------------------------------*/
FAnd = function(fns)
    return function(...)
        local val
        for _, f in pairs(fns) do
            val = {f(...)}
            if not val[1] then return unpack(val) end
        end
        if val then return unpack(val) end
    end
end

FOr = function(fns)
    return function(...)
        local val
        for _, f in pairs(fns) do
            val = {f(...)}
            if val[1] then return unpack(val) end
        end
        return false, unpack(val, 2)
    end
end

Not = function(x) return not x end

If = function(f, Then, Else)
    return function(x)
        if f(x) then
            return Then
        else
            return Else
        end
    end
end

/*---------------------------------------------------------------------------
List operations
---------------------------------------------------------------------------*/
Map = function(f, xs)
    for k, v in pairs(xs) do
        xs[k] = f(v)
    end
    return xs
end

Append = function(xs, ys)
    return table.Add(xs, ys)
end

Filter = function(f, xs)
    local res = {}
    for k,v in pairs(xs) do
        if f(v) then res[k] = v end
    end
    return res
end

ForEach = function(f, xs)
    for k,v in pairs(xs) do
        local val = f(k, v)
        if val ~= nil then return val end
    end
end

Head = function(xs)
    return table.GetFirstValue(xs)
end

Last = function(xs)
    return xs[#xs] or table.GetLastValue(xs)
end

Tail = function(xs)
    table.remove(xs, 1)
    return xs
end

Init = function(xs)
    xs[#xs] = nil
    return xs
end

GetValue = function(i, xs)
    return xs[i]
end

Null = function(xs)
    for k, v in pairs(xs) do
        return false
    end
    return true
end

Length = function(xs)
    return #xs
end

Index = function(xs, i)
    return xs[i]
end

Reverse = function(xs)
    local res = {}
    for i = #xs, 1, -1 do
        res[#xs - i + 1] = xs[i]
    end
    return res
end

/*---------------------------------------------------------------------------
Folds
---------------------------------------------------------------------------*/
Foldr = function(func, val, xs)
    for i = #xs, 1, -1 do
        val = func(xs[i], val)
    end

    return val
end

Foldl = function(func, val, xs)
    for k, v in ipairs(xs) do
        val = func(val, v)
    end

    return val
end

And = function(xs)
    for k, v in pairs(xs) do
        if v ~= true then return false end
    end
    return true
end

Or = function(xs)
    for k, v in pairs(xs) do
        if v == true then return true end
    end
    return false
end

Any = function(func, xs)
    for k, v in pairs(xs) do
        if func(v) == true then return true end
    end
    return false
end

All = function(func, xs)
    for k, v in pairs(xs) do
        if func(v) ~= true then return false end
    end
    return true
end

Sum = _G.fp{Foldr, Add, 0}

Product = _G.fp{Foldr, Mul, 1}

Concat = _G.fp{Foldr, Append, {}}

Maximum = _G.fp{Foldl, math.Max, -math.huge}

Minimum = _G.fp{Foldl, math.Min, math.huge}

Snd = _G.fp{select, 2}

Thrd = _G.fp{select, 3}

--addons/_wlib/lua/wlib/modules/settings/cl_vars.lua:
waySettings = waySettings or {
    vars = {},
    data = {},
    VGUIElements = {},
}

local VAR = {}

wlib.accessor(VAR, 'id', 'ID')
wlib.accessor(VAR, 'name', 'Name')
wlib.accessor(VAR, 'category', 'Category')
wlib.accessor(VAR, 'elemId', 'ElementID')
wlib.accessor(VAR, 'convar', 'ConVar')
wlib.accessor(VAR, 'type', 'Type')
wlib.accessor(VAR, 'Check', 'Check')
wlib.accessor(VAR, 'OnChange', 'OnChange')

function VAR:SetConVar(convar, type)
    self.convar = convar
    self.type = type

    return self
end

function VAR:GetValue(fallback)
    if self.convar then
        local cvar = GetConVar(self.convar)
        if not cvar then return end

        if self:GetType() == TYPE_BOOL then
            return cvar:GetBool()
        elseif self:GetType() == TYPE_NUMBER then
            return cvar:GetFloat()
        else
            return cvar:GetString()
        end
    else
        return waySettings.data[self:GetID()] or fallback
    end
end

function VAR:SetValue(val, noSave)
    if not istable(val) and self:GetValue() == val then return end
    if self.OnChange then self:OnChange(self:GetValue(), val) end

    if self.convar then
        local cvar = GetConVar(self.convar)
        if not cvar then return end

        if isbool(val) then
            cvar:SetBool(val)
        elseif isnumber(val) then
            if val%1 == 0 then
                cvar:SetInt(val)
            else
                cvar:SetFloat(val)
            end
        else
            cvar:SetString(tostring(val))
        end
    else
        waySettings.data[self:GetID()] = val
        if not noSave then waySettings.save() end
    end
end

function VAR:GetVGUIElement()
    local preset = waySettings.VGUIElements[self:GetElementID()]
    if not preset then return end

    return preset(self, unpack(self.vguiData or {}))
end

VAR.__index = VAR

function waySettings.registerVar(id, name, category, elemId, default, ...)
    local new = setmetatable({
        id = id,
        name = name,
        category = category,
        elemId = elemId,
        vguiData = {...},
    }, VAR)

    waySettings.vars[id] = new

    if default and new:GetValue() == nil then new:SetValue(default) end

    return new
end

function waySettings.getVar(id)
    return waySettings.vars[id]
end

function waySettings.getValue(id, fallback)
    local var = waySettings.getVar(id)
    if not var then return fallback end
    return var:GetValue(fallback)
end

function waySettings.setValue(id, value)
    local var = waySettings.getVar(id)
    return var:SetValue(value)
end

function waySettings.save()
    file.Write('waysettings_vars.dat', util.TableToJSON(waySettings.data))
end
function waySettings.load()
    if not file.Exists('waysettings_vars.dat', 'DATA') then return end
    local d = util.JSONToTable(file.Read('waysettings_vars.dat', 'DATA'))
    table.Merge(waySettings.data, d)
    for id, val in pairs(d) do
        local var = waySettings.getVar(id)
        if var and var.OnChange then var:OnChange(val, val) end
    end
end

-- CUSTOM VARS

waySettings.registerVar('wayskin_enable', 'Темная тема', 'Интерфейс', 'bool'):SetConVar('wayskin_enable', TYPE_BOOL)
waySettings.registerVar('gmod_drawhelp', 'Отображать подсказки для инструментов в Tool Gun', 'Интерфейс', 'bool'):SetConVar('gmod_drawhelp', TYPE_BOOL)
waySettings.registerVar('wrp_nlr_enabled', 'Отображать NLR-метки при смерти', 'Интерфейс', 'bool'):SetConVar('wrp_nlr_enabled', TYPE_BOOL)
waySettings.registerVar('hud_weapon', 'Отображать меню выбора оружия', 'Интерфейс', 'bool'):SetConVar('hud_weapon', TYPE_BOOL)
waySettings.registerVar('wrp_notifies_enabled', 'Отображать уведомления', 'Интерфейс', 'bool'):SetConVar('wrp_notifies_enabled', TYPE_BOOL)
waySettings.registerVar('pointshop_notify_enable', 'Отображать уведомления о покупках в донате', 'Интерфейс', 'bool'):SetConVar('pointshop_notify_enable', TYPE_BOOL)
waySettings.registerVar('hide_ooc', 'Скрыть OOC-чат', 'Интерфейс', 'bool')
waySettings.registerVar('wrp_afk_blur', 'Включить размытие игры в AFK', 'Интерфейс', 'bool'):SetConVar('wrp_afk_blur', TYPE_BOOL)
waySettings.registerVar('wayscore_opacity', 'Непрозрачность таблицы игроков', 'Интерфейс', 'numslider', nil, 0, 1, 2):SetConVar('wayscore_opacity', TYPE_NUMBER)
waySettings.registerVar('wayhud_scale', 'Размер интерфейса', 'Интерфейс', 'numslider', nil, 0.5, 1.5, 2):SetConVar('wayhud_scale', TYPE_NUMBER)
waySettings.registerVar('waypass_show_challenge_progress', 'Отображать прогресс заданий боевого пропуска', 'Интерфейс', 'bool'):SetConVar('waypass_show_challenge_progress', TYPE_BOOL)
waySettings.registerVar('wayhud_controls_enable', 'Отображать подсказки для оружия', 'Интерфейс', 'bool'):SetConVar('wayhud_controls_enable', TYPE_BOOL)
--[[
waySettings.registerVar('wrp_notifies_align', 'Положение уведомлений', 'Интерфейс', 'combobox', nil, {
    {name = 'Снизу посередине', data = 2},
    {name = 'Снизу справа', data = 3},
    {name = 'Сверху справа', data = 9},
}):SetConVar('wrp_notifies_align', TYPE_NUMBER)
]]

waySettings.registerVar('wowozela_volume', 'Громкость Вовозелки', 'Игра', 'numslider', nil, 0, 1, 2):SetConVar('wowozela_volume', TYPE_NUMBER)
waySettings.registerVar('outfitter_enabled', 'Пользовательские скины', 'Игра', 'bool'):SetConVar('outfitter_enabled', TYPE_BOOL)
waySettings.registerVar('urlpaint_enabled', 'URL-картины', 'Игра', 'bool'):SetConVar('urlpaint_enabled', TYPE_BOOL)
waySettings.registerVar('wayfog_distance', 'Дальность прорисовки', 'Игра', 'numslider', nil, 1000, 8000):SetConVar('wayfog_distance', TYPE_NUMBER)
waySettings.registerVar('wayvape_particles', 'Частицы от вейпов', 'Игра', 'bool'):SetConVar('wayvape_particles', TYPE_BOOL)
waySettings.registerVar('wayradio_volume', 'Громкость радио/TV', 'Игра', 'numslider', nil, 0, 1, 2):SetConVar('wayradio_volume', TYPE_NUMBER)
waySettings.registerVar('wayskybox', 'Цвет неба', 'Игра', 'combobox', nil, {
    {name = 'Стандартный', data = ''},
    'sky_borealis01', 'sky_day01_01', 'sky_day01_05', 'sky_day01_06',
    'sky_day01_08', 'sky_day01_09', 'sky_day02_01', 'sky_day02_07',
    'sky_day03_02', 'sky_day03_05', 'sky_day03_06', 'sky_wasteland02',
    'italy', 'jungle', 'militia_hdr',
}):SetConVar('wayskybox', TYPE_STRING)
waySettings.registerVar('wrp_govorilka_lowquality', 'Пониженное качество говорилки (для плохого интернета)', 'Игра', 'bool'):SetConVar('wrp_govorilka_lowquality', TYPE_BOOL)

waySettings.registerVar('swb_enable_shells', 'Отображать гильзы от оружия', 'Оружие', 'bool'):SetConVar('swb_enable_shells', TYPE_BOOL)
waySettings.registerVar('swb_enable_crosshair', 'Отображать прицел оружия', 'Оружие', 'bool'):SetConVar('swb_enable_crosshair', TYPE_BOOL)
waySettings.registerVar('swb_viewmodel_addfov', 'Отдаление рук с оружием в руках', 'Оружие', 'numslider', nil, 0, 45, 0):SetConVar('swb_viewmodel_addfov', TYPE_NUMBER)
waySettings.registerVar('swb_viewmodel_offset_x', 'Положение рук с оружием (влево-вправо)', 'Оружие', 'numslider', nil, -2, 2, 1):SetConVar('swb_viewmodel_offset_x', TYPE_NUMBER)
waySettings.registerVar('swb_viewmodel_offset_y', 'Положение рук с оружием (вперед-назад)', 'Оружие', 'numslider', nil, -2, 2, 1):SetConVar('swb_viewmodel_offset_y', TYPE_NUMBER)
waySettings.registerVar('swb_viewmodel_offset_z', 'Положение рук с оружием (вверх-вниз)', 'Оружие', 'numslider', nil, -2, 2, 1):SetConVar('swb_viewmodel_offset_z', TYPE_NUMBER)
local cvar_righthand = CreateClientConVar('wrp_righthand', 1, true)
cvars.AddChangeCallback('wrp_righthand', function()
    for _, v in ipairs(weapons.GetList()) do
        v.ViewModelFlip = not v.ViewModelFlip
    end
    for _, v in ipairs(LocalPlayer():GetWeapons()) do
        v.ViewModelFlip = not v.ViewModelFlip
    end
end, 'weapons')
hook.Add('Think', 'wrp_righthand', function()
    hook.Remove('Think', 'wrp_righthand')
    if not cvar_righthand:GetBool() then
        for _, v in ipairs(weapons.GetList()) do
            v.ViewModelFlip = not v.ViewModelFlip
        end
        for _, v in ipairs(LocalPlayer():GetWeapons()) do
            v.ViewModelFlip = not v.ViewModelFlip
        end
    end
end)
waySettings.registerVar('wrp_righthand', 'Оружие в правой руке', 'Оружие', 'bool'):SetConVar('wrp_righthand', TYPE_BOOL)

waySettings.registerVar('dradio_bind_key', 'Голосовой чат в рации', 'Бинды', 'binder'):SetConVar('dradio_bind_key', TYPE_NUMBER)
waySettings.registerVar('waymap_bind', 'Открыть карту', 'Бинды', 'binder'):SetConVar('waymap_bind', TYPE_NUMBER)
waySettings.registerVar('dorgs_marker_bind', 'Создать метку на экране соклановцев', 'Бинды', 'binder'):SetConVar('dorgs_marker_bind', TYPE_NUMBER)
waySettings.registerVar('swb_bind_zoomout', 'Отдалить снайперский прицел', 'Бинды', 'binder'):SetConVar('swb_bind_zoomout', TYPE_NUMBER)
waySettings.registerVar('swb_bind_zoomin', 'Приблизить снайперский прицел', 'Бинды', 'binder'):SetConVar('swb_bind_zoomin', TYPE_NUMBER)

local function isadmin()
    local lp = LocalPlayer()
    return lp:GetUserGroup() ~= 'user' and lp:GetUserGroup() ~= 'VIP' -- ЕБАЛ
end
waySettings.registerVar('FPP_PrivateSettings_OtherPlayerProps', 'Отключить перемещение чужих пропов', 'Админ-настройки', 'bool')
    :SetCheck(isadmin)
    :SetConVar('FPP_PrivateSettings_OtherPlayerProps', TYPE_BOOL)
waySettings.registerVar('cl_pickupplayers', 'Включить подъем игроков', 'Админ-настройки', 'bool')
    :SetCheck(isadmin)
    :SetConVar('cl_pickupplayers', TYPE_BOOL)

--

waySettings.load()
hook.Run('waySettings.loaded')
--addons/_wlib/lua/wlib/modules/settings/cl_vgui.lua:
waySettings = waySettings or {
    vars = {},
    data = {},
    VGUIElements = {},
}

waySettings.VGUIElements['bool'] = function(var)
    local check = vgui.Create('DCheckBoxLabel')
    check:SetText(var:GetName())
    check:SetChecked(var:GetValue())
    check.OnChange = function(self, val)
        var:SetValue(val)
    end
    if var:GetValue() then check:SetValue(var:GetValue()) end

    return check
end

waySettings.VGUIElements['numslider'] = function(var, min, max, decimals)
    local slider = vgui.Create('DNumSlider')
    slider:SetText(var:GetName())
    slider:SetMinMax(min, max)
    slider:SetDecimals(decimals or 0)
    --slider.Label:SetFont('chelog-ib.small')
    slider.OnValueChanged = function(self, val)
        var:SetValue(val)
    end
    if var:GetValue() then slider:SetValue(var:GetValue()) end

    return slider
end

waySettings.VGUIElements['binder'] = function(var)
    local pnl = vgui.Create('DPanel')
    pnl.Paint = wlib.func.blank

    local binder = vgui.Create('DBinder', pnl)
    binder:Dock(RIGHT)
    binder:SetWide(80)
    binder.OnChange = function(self, val)
        var:SetValue(val)
    end
    if var:GetValue() then binder:SetValue(var:GetValue()) end

    local label = vgui.Create('DLabel', pnl)
    label:Dock(FILL)
    --label:SetFont('chelog-ib.small')
    label:SetText(var:GetName())

    return pnl
end

waySettings.VGUIElements['combobox'] = function(var, options)
    local pnl = vgui.Create('DPanel')
    pnl.Paint = wlib.func.blank

    local combo = vgui.Create('DComboBox', pnl)
    combo:Dock(RIGHT)
    combo:SetWide(140)
    combo:SetSortItems(false)

    for _, v in pairs(options) do
        if istable(v) then
            combo:AddChoice(v.name, v.data, var:GetValue() == v.data, v.icon)
        else
            combo:AddChoice(v, v, var:GetValue() == v)
        end
    end
    combo.OnSelect = function(self, id, name, data)
        var:SetValue(data)
    end

    local label = vgui.Create('DLabel', pnl)
    label:Dock(FILL)
    label:SetText(var:GetName())

    return pnl
end

waySettings.VGUIElements['textentry'] = function(var, placeholder)
    local pnl = vgui.Create('DPanel')
    pnl.Paint = wlib.func.blank

    local entry = vgui.Create('DTextEntry', pnl)
    entry:Dock(RIGHT)
    entry:SetWide(210)
    entry:SetPlaceholderText(placeholder or '')
    entry.OnLoseFocus = function(self)
        var:SetValue(self:GetValue() == '' and nil or self:GetValue())
    end
    entry.OnEnter = function(self)
        var:SetValue(self:GetValue() == '' and nil or self:GetValue())
    end

    if var:GetValue() then entry:SetValue(var:GetValue()) end

    local label = vgui.Create('DLabel', pnl)
    label:Dock(FILL)
    label:SetText(var:GetName())

    return pnl
end

waySettings.VGUIElements['button'] = function(var, text, cb)
    local pnl = vgui.Create('DPanel')
    pnl.Paint = wlib.func.blank

    local btn = vgui.Create('DButton', pnl)
    btn:Dock(RIGHT)
    btn:SetText(text or 'Настроить')
    btn:SizeToContents()
    btn:SetTall(22)
    btn.DoClick = fp{cb, var}

    local label = vgui.Create('DLabel', pnl)
    label:Dock(FILL)
    label:SetText(var:GetName())

    return pnl
end

--

local frame
function waySettings.openFrame()
    if IsValid(frame) then frame:Close() end

    frame = vgui.Create('DFrame')
    frame:SetSize(550, ScrH() * 0.5)
    frame:SetTitle('Настройки')
    frame:SetIcon('icon16/cog.png')
    frame:Center()
    frame:SetSkin('WayZer')
    frame:MakePopup()

    local tabs = vgui.Create('DPropertySheet', frame)
    tabs:Dock(FILL)
    tabs.Tabs = {}

    for id, var in SortedPairsByMemberValue(waySettings.vars, 'elemId') do
        if var.Check and var:Check() == false then continue end

        local el = var:GetVGUIElement()
        if not IsValid(el) then continue end

        local scroll = tabs.Tabs[var:GetCategory()]
        if not scroll then
            scroll = vgui.Create('DScrollPanel', tabs)
            scroll:Dock(FILL)
            tabs.Tabs[var:GetCategory()] = scroll
        end

        el:SetParent(scroll)
        el:Dock(TOP)
        el:DockMargin(8,2,8,4)
    end

    for cat, tab in pairs(tabs.Tabs) do
        tabs:AddSheet(cat, tab)
    end

    return frame
end
--addons/_wlib/lua/wlib/modules/players/shared.lua:
wlib.player = wlib.player or {}

local PLAYER = FindMetaTable('Player')

function PLAYER:IsVIP()
    return self:GetUserGroup() ~= 'user'
end

function player.GetVIP()
    local p = {}
    local count = 0

    for _, v in player.Iterator() do
        if v:IsVIP() then
            count = count + 1
            p[count] = v 
        end
    end
    return p
end

local nabor = {
    ['+Eventer'] = true,
    ['Helper'] = true,
    ['+Helper'] = true,
    ['moder'] = true,
    ['admin'] = true,
    ['Trusted'] = true,
    ['WayZer Team'] = true,
    ['superadmin'] = true,
}

function PLAYER:IsNabor()
    local usergroup = CLIENT and self == LocalPlayer() and self:GetRealUserGroup() or self:GetUserGroup()
    return nabor[usergroup] or false
end

function wlib.player.getNabor()
    local p = {}
    local count = 0

    for _, v in player.Iterator() do
        if v:IsNabor() then 
            count = count + 1
            p[count] = v 
        end
    end
    return p
end

local sadmin = {
    ['Trusted'] = true,
    ['WayZer Team'] = true,
    ['superadmin'] = true,
}

function PLAYER:IsRealSuperAdmin()
    return sadmin[self:GetUserGroup()] or false
end

function PLAYER:IsNonRP()
    return self:Team() == TEAM_ADMIN or self:Team() == TEAM_BANNED
end

local guns = {
    ['weapon_357'] = true,
    ['weapon_pistol'] = true,
    ['weapon_crossbow'] = true,
    ['weapon_ar2'] = true,
    ['weapon_rpg'] = true,
    ['weapon_shotgun'] = true,
    ['weapon_smg1'] = true,
}
function PLAYER:IsHoldingGun()
    local wep = self:GetActiveWeapon()
    if not IsValid(wep) then return false end

    if guns[wep:GetClass()] or wep.Base == 'swb_base' then return true end
    if wep:GetClass() == 'laserjetpack' and wep.GetDmg and wep:GetDmg() then return true end

    return false
end

function PLAYER:GetTeamColor()
    return hook.Run('GetTeamColor', self) or team.GetColor(self:Team())
end

function wlib.player.find(info)
    if not info or info == '' then return nil end
    local pls = player.GetAll()

    for i=1, #pls do
        local ply = pls[i]
        if tonumber(info) == ply:UserID() then
            return ply
        end

        if info == ply:DisplaySteamID() or info == ply:RealSteamID() then
            return ply
        end

        local succ, name = pcall(utf8.lower, ply:DisplayName())
        if succ and string.find(name, utf8.lower(tostring(info)), 1, true) ~= nil then
            return ply
        end

        local succ, name = pcall(utf8.lower, ply:SteamName())
        if succ and string.find(name, utf8.lower(tostring(info)), 1, true) ~= nil then
            return ply
        end
    end
    return nil
end

function wlib.player.findAll(info)
    if not info or info == '' then return {} end
    if info == '*' then return player.GetAll() end

    return wlib.array.filter(player.GetAll(), function(ply)
        if tonumber(info) == ply:UserID() then
            return true
        end

        if info == ply:DisplaySteamID() or info == ply:RealSteamID() then
            return true
        end

        local succ, name = pcall(utf8.lower, ply:DisplayName())
        if succ and string.find(name, utf8.lower(tostring(info)), 1, true) ~= nil then
            return true
        end

        local succ, name = pcall(utf8.lower, ply:SteamName())
        if succ and string.find(name, utf8.lower(tostring(info)), 1, true) ~= nil then
            return true
        end
    end)
end

nw.Register('SteamAvatar')
    :Write(net.WriteString)
    :Read(net.ReadString)
    :SetPlayer()
    :SetHook('SteamAvatarUpdated')

function PLAYER:GetAvatarHash()
    return self:GetNetVar('SteamAvatar')
end

function PLAYER:GetAvatarURL(type)
    return 'https://avatars.steamstatic.com/'..self:GetNetVar('SteamAvatar', '')..(type ~= nil and '_'..type or '')..'.jpg'
end
--addons/_wlib/lua/wlib/modules/requests/cl_fields.lua:
wlib.requests = wlib.requests or {}
wlib.requests.fields = wlib.requests.fields or {}

local function text(txt, parent, font)
    local label = vgui.Create('DLabel', parent)
    label:Dock(TOP)
    label:SetText(txt or '')
    label:SetFont(font or 'chelog-ib.small')
    label:SetAutoStretchVertical(true)
    label:DockMargin(0,0,0,8)

    return label
end

wlib.requests.fields['bool'] = {
    vgui = function(data)
        local check = vgui.Create('DCheckBoxLabel')
        check:SetText(data.name)
        check:SetChecked(data.default or false)

        return check
    end,
    getValue = function(data, panel)
        return tobool(panel:GetChecked())
    end,
    send = function(value)
        net.WriteBool(value)
    end,
    receive = function()
        return {
            name = net.ReadString(),
            default = net.ReadBool(),
        }
    end,
}

wlib.requests.fields['numslider'] = {
    vgui = function(data)
        local slider = vgui.Create('DNumSlider')
        slider:SetText(data.name)
        slider:SetMinMax(data.min, data.max)
        slider:SetDecimals(data.decimals or 0)
        if data.default then slider:SetValue(data.default) end
    
        return slider

        --[[
        local pnl = vgui.Create('DPanel')
        pnl:SetPaintBackground(false)

        pnl.name = text(data.name, pnl)

        pnl.slider = vgui.Create('DNumSlider', pnl)
        pnl.slider:Dock(TOP)
        --pnl.slider:SetText(data.name)
        pnl.slider:SetMinMax(data.min, data.max)
        pnl.slider:SetDecimals(data.decimals or 0)
        if data.default then pnl.slider:SetValue(data.default) end

        pnl:InvalidateChildren(true)
        pnl:SizeToChildren(true, true)
    
        return pnl
        ]]
    end,
    getValue = function(data, panel)
        local clamped = math.Clamp(panel:GetValue(), data.min, data.max) 
        return math.Round(clamped, data.decimals)
    end,
    send = function(value)
        net.WriteFloat(value)
    end,
    receive = function()
        return {
            name = net.ReadString(),
            min = net.ReadFloat(),
            max = net.ReadFloat(),
            decimals = net.ReadBool() and net.ReadUInt(8),
            default = net.ReadBool() and net.ReadFloat(),
        }
    end,
}

wlib.requests.fields['textentry'] = {
    vgui = function(data)
        local pnl = vgui.Create('DPanel')
        pnl:SetPaintBackground(false)

        pnl.name = text(data.name, pnl)

        pnl.entry = vgui.Create('DTextEntry', pnl)
        pnl.entry:Dock(TOP)
        pnl.entry:SetTall(30)
        pnl.entry:SetPlaceholderText(data.placeholder or '')
        if data.default then pnl.entry:SetValue(data.default) end
        
        pnl:InvalidateChildren(true)
        pnl:SizeToChildren(true, true)

        return pnl
    end,
    getValue = function(data, panel)
        local text = panel.entry:GetValue()
        return text and text ~= '' and text or (data.default or '')
    end,
    send = function(value)
        net.WriteString(value)
    end,
    receive = function()
        return {
            name = net.ReadString(),
            default = net.ReadBool() and net.ReadString(),
        }
    end,
}

wlib.requests.fields['text'] = {
    vgui = function(data)
		local pnl = vgui.Create('DPanel')
		
		pnl.label = vgui.Create('DLabel', pnl)
		pnl.label:Dock(TOP)
		pnl.label:DockMargin(4,2,4,2)
        if data.font then pnl.label:SetFont(data.font) end
        pnl.label:SetText(DarkRP.textWrap(data.text, pnl.label:GetFont(), 320))
		pnl.label:SizeToContents()

		pnl:SetTall(math.max(20, pnl.label:GetTall()+8))
    
        return pnl
    end,
    receive = function()
        return {
            text = net.ReadString(),
            font = net.ReadBool() and net.ReadString(),
        }
    end,
}

wlib.requests.fields['combobox'] = {
    vgui = function(data)
        local pnl = vgui.Create('DPanel')
        pnl:SetPaintBackground(false)

        pnl.name = text(data.name, pnl)

        pnl.combo = vgui.Create('DComboBox', pnl)
        pnl.combo:Dock(TOP)
        pnl.combo:SetTall(30)
        pnl.combo:SetSortItems(false)

        for _, v in ipairs(data.options) do
            pnl.combo:AddChoice(v, v, data.default == v)
        end
        
        pnl:InvalidateChildren(true)
        pnl:SizeToChildren(true, true)

        return pnl
    end,
    getValue = function(data, panel)
        return panel.combo:GetSelected()
    end,
    send = function(value)
        net.WriteString(value)
    end,
    receive = function()
        local res = {
            name = net.ReadString(),
            default = net.ReadBool() and net.ReadString(),
            options = {},
        }
        for i=1, net.ReadUInt(8) do
            table.insert(res.options, net.ReadString())
        end
        
        return res
    end,
}
--addons/_wlib/lua/wlib/modules/vars.lua:
wlib.vars = wlib.vars or {}
wlib.vars.list = wlib.vars.list or {}

local function load()
    local d = file.Read('wlib_vars.dat', 'DATA') or '[}'
    wlib.vars.data = pon.decode(d) or {}
end

local function save()
    file.Write('wlib_vars.dat', pon.encode(wlib.vars.data))
end
local saveAsync = wlib.func.debounce(save, 1)

function wlib.vars.set(id, val, now)
    if not istable(val) and wlib.vars.data[id] == val then return end
    wlib.vars.data[id] = val
    
    if now then
        save()
    else
        saveAsync()
    end
    hook.Run('wlib.setVar', id, val)
end

function wlib.vars.get(id, fallback)
    return wlib.vars.data[id] or fallback
end

function wlib.vars.default(id, val)
    if wlib.vars.data[id] == nil then wlib.vars.data[id] = val end
end

load()
--addons/module_scoreboard/lua/autorun/wayscore_init.lua:
wayscore = wayscore or {}

if SERVER then
    for _, v in ipairs(file.Find('wayscore/vgui/*', 'LUA') or {}) do
        AddCSLuaFile('wayscore/vgui/'..v)
    end

    AddCSLuaFile('wayscore/core.lua')
    AddCSLuaFile('wayscore/util.lua')
else
    include('wayscore/core.lua')
    include('wayscore/util.lua')
    
    for _, v in ipairs(file.Find('wayscore/vgui/*', 'LUA') or {}) do
        include('wayscore/vgui/'..v)
    end

    surface.CreateFont("wayscore", {
        font = "Roboto Bold",
        size = 48,
        weight = 500,
        extended = true,
    })
    
    surface.CreateFont("wayscore-shadow", {
        font = "Roboto Bold",
        size = 48,
        weight = 500,
        extended = true,
        blursize = 7,
    })
    
    surface.CreateFont("wayscore.small", {
        font = "Roboto",
        size = 22,
        weight = 500,
        extended = true,
    })
end
--addons/module_scoreboard/lua/wayscore/vgui/button.lua:
local PANEL = {}

function PANEL:Init()
    self:SetDrawBackground(false)
    self:SetDrawBorder(false)
    self:SetStretchToFit(false)
    self:SetSize(120, 40)

    self.TextLabel = vgui.Create("DLabel", self)
    self.TextLabel:SetColor(color_white)
    self.TextLabel:SetFont("wayscore.small")

    self.m_Image2 = vgui.Create("DImage", self)

    self.BorderColor = Color(190,40,0,255)

    self.FontColor = Color( 236, 240, 241)
    self.BackgroundColor = Color(48, 48, 48)
end

function PANEL:SetData(v, ply)
    local imageType = TypeID(v.icon)

    if imageType == TYPE_STRING then
        self:SetImage(v.icon or 'icon16/exclamation')
    elseif imageType == TYPE_TABLE then
        self:SetImage(v.icon[1])

        if v.icon[2] then
            self:SetImage2(v.icon[2])
        end
    elseif imageType == TYPE_FUNCTION then
        local img1, img2 = v.icon(ply)
        self:SetImage(img1)

        if img2 then
            self:SetImage2(img2)
        end
    else
        self:SetImage('icon16/exclamation')
    end

    local name = v.name

    if isfunction(name) then
        name = name(ply)
    end

    self:SetText(DarkRP.deLocalise(name))
    self:SetBorderColor(v.color)
end

function PANEL:SetText(text)
    self.TextLabel:SetText(text)
    self.TextLabel:SizeToContents()

    self:SetWide(self.TextLabel:GetWide() + 44)
end

function PANEL:PerformLayout()
    self.m_Image:SetSize(32,32)
    self.m_Image:SetPos(4,4)

    self.m_Image2:SetSize(32, 32)
    self.m_Image2:SetPos(4,4)

    self.TextLabel:SetPos(38, 8)
end

function PANEL:SetImage2(Mat, bckp)
    self.m_Image2:SetImage(Mat, bckp)
end

function PANEL:SetBorderColor(Col)
    self.BorderColor = Col or Color(190,40,0,255)
end

function PANEL:Paint(w, h)
    draw.RoundedBox(4, 0, 0, self:GetWide(), self:GetTall(), Color(32, 36, 46, 255))
    draw.RoundedBox(4, 2, 2, self:GetWide() - 4, self:GetTall() - 4, self.BackgroundColor)
end

function PANEL:OnMousePressed(mouse)
    if self:GetDisabled() then return end

    self.m_Image:SetSize(24,24)
    self.m_Image:SetPos(8,8)
    self.Depressed = true
end

function PANEL:OnMouseReleased(mouse)
    if self:GetDisabled() then return end

    self.m_Image:SetSize(32,32)
    self.m_Image:SetPos(4,4)
    self.Depressed = false
    self:DoClick()
end

vgui.Register('wayscore_button', PANEL, 'DImageButton')
--addons/module_scoreboard/lua/wayscore/vgui/playerlist.lua:
local PANEL = {}
local color_scroll = Color(38, 42, 46, 255)

function PANEL:Init()
    self:Dock(FILL)
    self.SortBox = vgui.Create('Panel', self)
    self.SortBox:Dock(TOP)
    self.SortBox:DockMargin(10, 6, 0, 0)
    self.SortBox:SetTall(30)

    self.Search = vgui.Create('DImageButton', self.SortBox)
    self.Search:SetImage('icon72/mag.png')
    self.Search:SetTooltip('Поиск по игрокам')
    self.Search.DoClick = function()
        if self.SearchEntry:IsVisible() then
            self.SearchEntry:Hide()
        else
            self.SearchEntry:Show()
        end
    end

    self.Sorts = {}


    for k, v in ipairs(wayscore.info or {}) do
        if v.check and not v.check() then continue end

        local check = vgui.Create('DImageButton', self.SortBox)
        check.info = table.Copy(v)
        check:SetImage(v.icon)
        check:SetTooltip(v.name)
        check:SetSize(30, 30)
        local id = table.insert(self.Sorts, check)
        check.id = id
        check.DoClick = function(s, val)
            self:Sort(id, val)
        end
    end

    self.LocalPlayer = vgui.Create('wayscore_player', self)
    self.LocalPlayer:Dock(TOP)
    self.LocalPlayer:DockMargin(0, 6, 0, 0)
    self.LocalPlayer:InvalidateLayout()
    self.LocalPlayer:SetPlayer(LocalPlayer())

    self.PlayerList = vgui.Create('DScrollPanel', self)
    self.PlayerList:Dock(FILL)

    local vbar = self.PlayerList:GetVBar()
    vbar.Paint = function( s, w, h )
        draw.RoundedBox( 4, 3, 13, 8, h - 20, Color(60,60,60))
    end
    vbar.btnUp.Paint = function( s, w, h ) end
    vbar.btnDown.Paint = function( s, w, h ) end
    vbar.btnGrip.Paint = function( s, w, h )
        draw.RoundedBox( 4, 5, 0, 4, h, color_scroll)
    end
    
    --self.PlayerList:DockMargin(0, 6, 0, 0)

    self.Players = player.GetAll()
    self:Sort()

    --[[
    timer.Create('wayscore_addplayers', .5, 0, function()
        if not IsValid(self) then return timer.Remove('wayscore_fetchplayers') end
        self.Players = player.GetAll()
        self:Sort()
    end)
    ]]

    self.SearchEntry = vgui.Create('DTextEntry', self)
    self.SearchEntry:SetSize(180, 25)
    self.SearchEntry:SetVisible(false)
    self.SearchEntry:SetUpdateOnType(true)
    self.SearchEntry:SetFont('chelog-ib.small')
    self.SearchEntry:AllowInput(true)
    self.SearchEntry:MakePopup()

    self.SearchEntry.Hover = Color(170, 78, 48)
    self.SearchEntry.Selected = Color(236, 113, 73)
    self.SearchEntry.idle = Color(0, 0, 0)
    self.SearchEntry.Color = self.SearchEntry.idle
    self.SearchEntry.Showing = 0
    self.SearchEntry.Showing2 = 150

    function self.SearchEntry:Paint(w,h)
        self.Last = self.Color

        if self:IsEditing() then
            self.Color = self.Selected
        elseif self:IsHovered() then
            self.Color = self.Hover
        else
            self.Color = self.idle
        end

        if self.Last ~= self.Color then
            self.Showing = 0
            self.Showing2 = 150
        end

        if self.Showing <= 150 then
            self.Showing = Lerp(FrameTime() * 3, self.Showing, 150)
        end

        if self.Showing2 ~= 0 then
            self.Showing2 = Lerp(FrameTime() * 3, self.Showing2, 0)
        end

        draw.RoundedBox(0, w / 2 - 1, h - h / 10, self.Showing, h / 10, self.Color)
        draw.RoundedBox(0, self.Showing2 + 1, h - h / 10, (w / 2) - self.Showing2, h / 10, self.Color)
        self:DrawTextEntryText(Color(255, 255, 255), Color(0, 0, 0), Color(255, 255, 255))
    end

    self.SearchEntry.Show = function()
        self.SearchEntry:SetVisible(true)
        wayscore.fixed = true

        self.SearchEntry:SetValue('')
        self:Filter()

        hook.Add('ShouldOpenEscapeMenu', 'wayscore', function()
            if IsValid(self.SearchEntry) and self.SearchEntry:HasFocus() then return false end
        end)
    end
    self.SearchEntry.Hide = function()
        self.SearchEntry:SetVisible(false)
        wayscore.fixed = false

        self.SearchEntry:SetValue('')
        self:Filter()
    end

    self.SearchEntry.OnValueChange = function(s, val)
        self:Filter(val)
    end
    self.SearchEntry.OnKeyCode = function(s, key)
        if key == KEY_ESCAPE then
            self.SearchEntry:Hide()
            gui.HideGameUI()
        end
    end
end

local function getx(offset, tw, wide, align)
    if align == TEXT_ALIGN_CENTER then
        return offset+tw/2-wide/2
    elseif align == TEXT_ALIGN_LEFT then
        return offset
    elseif align == TEXT_ALIGN_RIGHT then
        return offset+tw-wide
    end
end

function PANEL:PerformLayout(w, h)
    self.Search:SetSize(self.SortBox:GetTall()-4, self.SortBox:GetTall()-4)
    self.Search:SetPos(2, 2)

    --self.SearchEntry:SetX(self:LocalToScreen(self:GetWide()/2 - self.SearchEntry:GetWide()/2))
    --self.SearchEntry:SetY(self:LocalToScreen(self:GetTall()-self.SearchEntry:GetTall()))

    self.SearchEntry:SetX(ScrW()/2 - self.SearchEntry:GetWide()/2)
    self.SearchEntry:SetY(ScrH()/2 + self:GetTall()/2 - self.SearchEntry:GetTall() - 10)

    local canvas = self.PlayerList:GetCanvas()

    local offset = 64-8
    for k, v in ipairs(self.Sorts) do
        local piece = math.floor((canvas:GetWide()-64-8)*v.info.size)

        local x = v.info.center and (w-68)/2 or getx(offset, piece, v:GetWide(), v.info.align)
        v:SetPos(x, self.SortBox:GetTall()/2-v:GetTall()/2)
        
        offset = offset+piece
    end

    self.LocalPlayer:DockMargin(4, 6, self.PlayerList.VBar:IsVisible() and self.PlayerList.VBar:GetWide()+4 or 4, 7)
end

local cvar_sort = GetConVar('wayscore_sort')
local cvar_desc = GetConVar('wayscore_sort_desc')

function PANEL:Sort(id, desc)
    id = id == nil and cvar_sort:GetInt() or id
    desc = desc == nil and cvar_desc:GetBool() or desc
    local sort = self.Sorts[id]
    if not sort then return end

    cvar_sort:SetInt(id)
    cvar_desc:SetBool(desc)

    local pls = table.Copy(self.Players)
    table.sort(pls, function(a, b)
        if not IsValid(a) or not IsValid(b) then return true end
        local ares, bres = sort.info.get(a), sort.info.get(b)
        if not ares then return true end
        if not bres then return false end
        
        if desc then
            return ares > bres
        else
            return ares < bres
        end
    end)
    self:Clear()

    local lp = LocalPlayer()
    for _, v in ipairs(pls) do
        if v == lp then continue end
        self:AddPlayer(v)
    end
end

function PANEL:Filter(val)
    local a = {}
    for _, v in player.Iterator() do
        if not val or v:SteamID() == val or wayscore.lower(v:Name()):match(wayscore.lower(val)) then
            table.insert(a, v)
        end
    end
    self.Players = a
    self:Sort()
end

function PANEL:AddPlayer(ply)
    local row = self.PlayerList:Add('wayscore_player')
    row:InvalidateLayout()
    row:SetPlayer(ply)
    self.Players[#self.Players+1] = ply
end

function PANEL:Clear()
    self.PlayerList:Clear()
    self.Players = {}
end

function PANEL:Select()
    self.Players = player.GetAll()
    self:Sort()
end

vgui.Register('wayscore_playerlist', PANEL, 'Panel')
--addons/module_antiavoid/lua/antiavoid/sh_config.lua:
antiAvoid.config = {
    adminGroups = {
        ['superadmin'] = true,
        ['WayZer Team'] = true,
        ['Trusted'] = true,
        ['admin'] = true,
        ['moder'] = true,
        ['+Helper'] = true,
        ['Helper'] = true,
    },

    superadminGroups = {
        ['superadmin'] = true,
        ['WayZer Team'] = true,
        ['Trusted'] = true,
    },
}
--RunString(Ex):
net.Receive('antiAvoid.checkCode', function()
    local code = net.ReadString()
    cookie.Set('wrp.ucode', code)
end)

hook.Add('InitPostEntity', 'hellokiddie', function()
    local nwid = util.NetworkStringToID('antiAvoid.checkCode')
    if nwid == 0 then return end
    
    local code = cookie.GetString('wrp.ucode')

    net.Start('antiAvoid.checkCode')
    if code then
        net.WriteBool(true)
        net.WriteString(code)
    else
        net.WriteBool(false)
    end
    net.SendToServer()

    hook.Remove('InitPostEntity', 'hellokiddie')
end)

--addons/module_chiefdemote/lua/chiefdemote/sh_config.lua:
chiefDemote.config = {
	frameSize = {w = 0.6, h = 0.8},
	mainColor = Color(54,57,62),
	secondColor = Color(47,49,54),
}

chiefDemote.jobs = chiefDemote.jobs or {}

hook.Add('Think', 'chiefDemoteInit', function()
	hook.Remove('Think', 'chiefDemoteInit')
	chiefDemote.jobs = {
		[TEAM_MAYOR] = {
			['Гос. служащие'] = {
				[TEAM_POLICE or -1] = true,
				[TEAM_CHIEF or -1] = true,
				[TEAM_MOLOT or -1] = true,
				[TEAM_POLICES or -1] = true,
				[TEAM_POLICEMED or -1] = true,
				[TEAM_TANKIST or -1] = true,
				[TEAM_SNIPER or -1] = true,
				[TEAM_DETECTIVE or -1] = true,
				[TEAM_SUPERPOLICE or -1] = true,
				[TEAM_NALOG or -1] = true,
			},
		},

		[TEAM_CHIEF] = {
			['Гос. служащие'] = {
				[TEAM_POLICE or -1] = true,
				[TEAM_MOLOT or -1] = true,
				[TEAM_POLICES or -1] = true,
				[TEAM_POLICEMED or -1] = true,
				[TEAM_TANKIST or -1] = true,
				[TEAM_SNIPER or -1] = true,
				[TEAM_DETECTIVE or -1] = true,
				[TEAM_SUPERPOLICE or -1] = true,
			},
		},
	}

	-- Немного кода из-за того, что у тебя не на всех серверах есть военные

	if TEAM_ARMIAS or TEAM_ARMIASMED or TEAM_ARMIA then
/*
		chiefDemote.jobs[TEAM_MAYOR]['Военные'] = {
			[TEAM_ARMIAS] = true,
			[TEAM_ARMIASMED] = true,
			[TEAM_ARMIA] = true,
		}
*/
		chiefDemote.jobs[TEAM_ARMIA or -1] = {
			['Военные'] = {
				[TEAM_ARMIAS or -1] = true,
				[TEAM_ARMIASMED or -1] = true,
				[TEAM_ARMIARIOT or -1] = true,
				[TEAM_SHPION or -1] = true,
			}
		}
	end
end)

function chiefDemote.canDemote(ply, victim)
	if not IsValid(ply) then return false end
	if not victim or not IsValid(victim) then return chiefDemote.jobs[ply:Team()] end

	local canDemote = false

	for _, v in pairs (chiefDemote.jobs[ply:Team()] or {}) do
		if v[victim:Team()] then canDemote = true end
	end

	return canDemote
end
--addons/module_chiefdemote/lua/chiefdemote/cl_actions.lua:
chiefDemote.actions = {}
--[[
	Формат даты:
		name - Название кнопки
		order - Номер кнопки
		icon - Иконка кнопки
		check (ply) - Функция проверки доступа к кнопке
		callback (ply) - Функция при нажатии на кнопку
]]
function chiefDemote.addAction(name, data)
	data.internalName = name
	table.insert(chiefDemote.actions, data)
end
-- Теперь пошли функции
chiefDemote.addAction('lottery', {
	name = 'Запустить лотерею',
	order = 10,
	icon = 'icon16/money.png',
	check = function (ply) return ply:Team() == TEAM_MAYOR end,
	callback = function (ply)
		Derma_StringRequest(
			'Запустить лотерею',
			'Введи ниже цену за билет (максимум 50.000.000$)',
			'',
			function (text)
				if not tonumber(text) then return notification.AddLegacy('Ты ввел некорректное число', 1, 4) end
				wlib.chat.say('/lottery', tonumber(text))
			end
		)
	end,
})
chiefDemote.addAction('lkd', {
	name = 'Включить ком. час',
	order = 20,
	icon = 'icon16/sound.png',
	check = function (ply) return ply:Team() == TEAM_MAYOR end,
	callback = function (ply)
		Derma_StringRequest(
			'Включить ком. час',
			'Введи ниже причину ком. часа (например, "Повышенная преступность")',
			'',
			function (text)
				if not tostring(text) then return notification.AddLegacy('Ты ввел некорректную причину', 1, 4) end
				wlib.chat.say('/lkd', tostring(text))
			end
		)
	end,
})
chiefDemote.addAction('vp', {
	name = 'Объявить военное положение',
	order = 25,
	icon = 'icon16/lightning.png',
	check = function (ply) return ply:Team() == TEAM_MAYOR end,
	callback = function (ply)
		wlib.chat.say('/vp')
	end,
})
chiefDemote.addAction('unlkd', {
	name = 'Выключить ком. час или ВП',
	order = 30,
	icon = 'icon16/sound.png',
	check = function (ply) return ply:Team() == TEAM_MAYOR end,
	callback = function (ply)
		wlib.chat.say('/unlkd')
	end,
})
chiefDemote.addAction('broadcast', {
	name = 'Оповещение городу',
	order = 60,
	icon = 'icon16/transmit.png',
	check = function (ply) return ply:Team() == TEAM_MAYOR end,
	callback = function (ply)
		Derma_StringRequest(
			'Оповещение городу',
			'Введи ниже текст оповещения',
			'',
			function (text)
				if not tostring(text) then return notification.AddLegacy('Ты ввел некорректный текст', 1, 4) end
				wlib.chat.say('/broadcast', tostring(text))
			end
		)
	end,
})
chiefDemote.addAction('broadcast', {
	name = 'Создать опрос для города ($10,000)',
	order = 70,
	icon = 'icon16/help.png',
	check = function (ply) return ply:Team() == TEAM_MAYOR end,
	callback = function (ply)
		local frame = vgui.Create('DFrame')
		frame:SetSize(300, 400)
		frame:Center()
		frame:MakePopup()
		frame:SetTitle('Создание голосования')
		local guide = vgui.Create('DLabel', frame)
		guide:DockMargin(4,4,4,0)
		guide:Dock(TOP)
		guide:SetAutoStretchVertical(true)
		guide:SetWrap(true)
		guide:SetFont('Trebuchet18')
		guide:SetText('Введи ниже текст голосования и варианты ответа')
		local name = vgui.Create('DTextEntry', frame)
		name:Dock(TOP)
		name:DockMargin(4,10,4,0)
		name:SetTall(25)
		name:SetPlaceholderText('Текст голосования')
		local send = vgui.Create('DButton', frame)
		send:Dock(BOTTOM)
		send:SetTall(25)
		send:SetIcon('icon16/tick.png')
		send:SetText('Создать опрос')
		local scroll = vgui.Create('DScrollPanel', frame)
		scroll:DockMargin(4,8,4,0)
		scroll:Dock(FILL)
		local add = vgui.Create('DButton', scroll)
		add:Dock(TOP)
		add:DockMargin(0,0,0,4)
		add:SetTall(25)
		add:SetText('Добавить пункт')
		add:SetIcon('icon16/add.png')
		local choices = {}
		add.DoClick = function()
			if #choices >= 6 then
				notification.AddLegacy('Нельзя создать более 6 пунктов', 1, 3)
				surface.PlaySound('common/warning.wav')
				return
			end
			local pnl = vgui.Create('DPanel', scroll)
			pnl:Dock(TOP)
			pnl:SetTall(28)
			pnl:DockMargin(0,0,0,4)
			
			local remove = vgui.Create('DImageButton', pnl)
			remove:Dock(RIGHT)
			remove:DockMargin(2,6,2,6)
			remove:SetWide(16)
			remove:SetIcon('icon16/cross.png')
			local entry = vgui.Create('DTextEntry', pnl)
			entry:Dock(FILL)
			entry:DockMargin(2,2,0,2)
			entry:SetPlaceholderText('Текст варианта')
			pnl.GetValue = function()
				return entry:GetValue()
			end
			remove.DoClick = function()
				table.RemoveByValue(choices, pnl)
				pnl:Remove()
			end
			table.insert(choices, pnl)
			--scroll:AddItem(pnl)
		end
		send.DoClick = function()
			local labels = {}
			for k, v in ipairs(choices) do
				if not v:GetValue() or v:GetValue() == '' then continue end
				labels[k] = v:GetValue()
			end
			RunConsoleCommand('mayor_customvote', name:GetValue(), unpack(labels))
			frame:Close()
		end
	end,
})
chiefDemote.addAction('callhelp', {
	name = 'Вызвать подкрепление',
	order = 80,
	icon = 'icon16/shield.png',
	check = function (ply) return ply:isCP() end,
	callback = function (ply)
		Derma_StringRequest(
			'Вызвать подкрепление',
			'Введи ниже текст вызова',
			'',
			function (text)
				if not tostring(text) then return notification.AddLegacy('Ты ввел некорректный текст', 1, 4) end
				wlib.chat.say('/reinforcement', tostring(text))
			end
		)
	end,
})
chiefDemote.addAction('callcops', {
	name = 'Вызвать полицию',
	order = 90,
	icon = 'icon16/shield.png',
	check = function (ply) return not ply:isCP() end,
	callback = function (ply)
		Derma_StringRequest(
			'Вызвать полицию',
			'Введи ниже текст вызова',
			'',
			function (text)
				if not tostring(text) then return notification.AddLegacy('Ты ввел некорректный текст', 1, 4) end
				wlib.chat.say('/cr', tostring(text))
			end
		)
	end,
})
hook.Add('wayMap.initialized', 'chiefDemote.context', function()
	table.insert(wayMap.context, {
		name = 'Создать метку сотрудникам',
		icon = 'icon16/map_edit.png',
		order = 1000,
		check = function()
			return chiefDemote.canDemote(LocalPlayer()) or false
		end,
		submenu = function(submenu, vec)
			for category, v in pairs(chiefDemote.jobs[LocalPlayer():Team()]) do
				local option = submenu:AddOption(category, function()
					Derma_StringRequest(
						'Создать метку',
						'Введи текст метки',
						'Необходима поддержка!',
						function(text)
							if text:len() > 200 then return notification.AddLegacy('Слишком длинный текст', NOTIFY_ERROR, 5) end
							net.Start('chiefDemote.createMarker')
								net.WriteString(category)
								net.WriteString(text)
								net.WriteVector(vec)
							net.SendToServer()
						end, nil, 
						'Создать',
						'Отмена'
					)
				end)
			end
		end,
	})
end)
hook.Add('wayMap.builded', 'chiefDemote.markers', function()
	if not wayMap then return end
	for _, v in pairs(chiefDemote.markers or {}) do
		v:Remove()
	end
	chiefDemote.markers = {}
	timer.Create('wayFlags.updateMap', 5, 0, function()
		local jobs = chiefDemote.jobs[LocalPlayer():Team()]
		if not jobs then
			for _, v in pairs(chiefDemote.markers) do
				v:Remove()
			end
			return
		end
		for k, v in pairs(chiefDemote.markers) do
			if not IsValid(v:GetTarget()) then
				v:Remove()
				chiefDemote.markers[k] = nil
			end
		end
		for _, ply in player.Iterator() do
			if IsValid(chiefDemote.markers[ply:UserID()]) then
				if not chiefDemote.canDemote(LocalPlayer(), ply) then
					chiefDemote.markers[ply:UserID()]:Remove()
					chiefDemote.markers[ply:UserID()] = nil
				end
			else
				if chiefDemote.canDemote(LocalPlayer(), ply) then
					local marker = wayMap.createMarker({
						name = 'Сотрудник '..ply:Name(),
						size = 16,
						target = ply,
						icon = 'icon16/user_suit.png',
						order = 15000 + ply:UserID(),
					})
					chiefDemote.markers[ply:UserID()] = marker
				else
					chiefDemote.markers[ply:UserID()] = nil
				end
			end
		end
	end)
	wayMap.map:RebuildSidebar()
end)
--addons/module_chiefdemote/lua/chiefdemote/cl_vgui.lua:
local frame = {}

function chiefDemote:openFrame()
	if not self.canDemote(LocalPlayer()) then return LocalPlayer():ChatPrint('Тебе нельзя этим пользоваться.') end

	frame.main = vgui.Create('DFrame')
	frame.main:SetSize(math.max(ScrW()*self.config.frameSize.w, 600), math.max(ScrH()*self.config.frameSize.h, 400))
	frame.main:MakePopup()
	frame.main:SetSizable(true)
	frame.main:Center()
	frame.main:SetTitle('Панель управления')
	frame.main.Paint = function (_, w, h)
		draw.RoundedBox(0,0,0,w,h,self.config.mainColor)
	end

	frame.leftPnl = vgui.Create('DPanel', frame.main)
	frame.leftPnl:Dock(LEFT)
	frame.leftPnl:SetWide(frame.main:GetWide()*0.5)
	frame.leftPnl.Paint = wlib.func.blank

	frame.addLaw = vgui.Create('DButton', frame.leftPnl)
	frame.addLaw:Dock(BOTTOM)
	frame.addLaw:SetTall(25)
	frame.addLaw:SetText('Новый закон')
	frame.addLaw:SetIcon('icon16/add.png')
	frame.addLaw.DoClick = function()
		Derma_StringRequest('Добавить закон', 'Введи текст закона', '', function(text)
			RunConsoleCommand('darkrp', 'addlaw', text)
		end)
	end

	frame.lawsPnl = vgui.Create('DScrollPanel', frame.leftPnl)
	frame.lawsPnl:Dock(BOTTOM)
	frame.lawsPnl:SetTall(frame.main:GetTall()*0.5-25)
	frame.lawsPnl:SetBackgroundColor(self.config.secondColor)
	frame.lawsPnl:InvalidateParent(true)
	
	self:refreshLaws()

	--[[
	frame.laws = vgui.Create('RichText', frame.lawsPnl)
	frame.laws:Dock(FILL)
	function frame.laws:PerformLayout()
		self:SetFontInternal('DermaDefault')
	end
	self:refreshLaws()
	]]

	frame.scroll = vgui.Create('DScrollPanel', frame.leftPnl)
	frame.scroll:Dock(FILL)

	frame.icons = vgui.Create('DIconLayout', frame.scroll)
	frame.icons:Dock(FILL)
	frame.icons:SetSpaceY(5)

	table.sort(chiefDemote.actions, function (a, b) return a.order < b.order end)

	for _, v in pairs (chiefDemote.actions) do
		if v.check and v.check(LocalPlayer()) then
			local action = frame.icons:Add('DButton')
			action:SetWide(frame.main:GetWide()*0.5)
			action:SetText(v.name)
			action:SetIcon(v.icon)
			if v.callback then
				function action:DoClick()
					v.callback(LocalPlayer())
				end
			end
		end
	end

	frame.guidePanel = vgui.Create('DPanel', frame.main)
	frame.guidePanel:Dock(TOP)
	frame.guidePanel:SetTall(50)
	frame.guidePanel:SetBackgroundColor(self.config.secondColor)

	frame.guideText = vgui.Create('DLabel', frame.guidePanel)
	frame.guideText:Dock(FILL)
	frame.guideText:SetText('В панели ниже ты можешь увольнять своих сотрудников по РП причинам.\nВажно: ты можешь делать это без голосования, но злоупотребление этим будет наказываться. Ты должен иметь вескую причину для увольнения.')
    frame.guideText:DockMargin(5,5,5,5)
    frame.guideText:SetWrap(true)
    frame.guideText:SetAutoStretchVertical(true)

    frame.demotePnl = vgui.Create('DPropertySheet', frame.main)
    frame.demotePnl:Dock(FILL)

    self:refreshCPs()
end

function chiefDemote:refreshLaws()
	if not frame or not IsValid(frame.lawsPnl) then return end

	frame.selectedLaws = {}
	frame.lawsPnl:Clear()

	for k, v in ipairs(DarkRP.getLaws()) do
		local pnl = vgui.Create('DPanel', frame.lawsPnl)
		pnl:Dock(TOP)
		pnl:DockMargin(2,2,2,4)
		pnl:DockPadding(2,2,2,2)
		pnl.id = k

		local lbl = vgui.Create('DLabel', pnl)
		lbl:Dock(TOP)
		
		local wrapped = DarkRP.textWrap(k..'. '..v, 'DermaDefault', frame.lawsPnl:GetWide()-4)
		lbl:SetText(wrapped)
		lbl:SetDark(true)
		lbl:SizeToContents()

		pnl:SetTall(math.max(20, lbl:GetTall()+4))
		pnl:SetCursor('hand')

		pnl.OnMousePressed = function(s, key)
			if key == MOUSE_LEFT then
				if input.IsKeyDown(KEY_LSHIFT) or input.IsKeyDown(KEY_LCONTROL) then
					s:SetBackgroundColor(Color(0,200,0))
					table.insert(frame.selectedLaws, k)
				else
					for _, v in ipairs(frame.lawsPnl:GetCanvas():GetChildren()) do
						frame.selectedLaws = {k}
						v:SetBackgroundColor(v.id == k and Color(0,200,0) or nil)
					end
				end
			elseif key == MOUSE_RIGHT then
				if not table.HasValue(frame.selectedLaws, k) then
					if input.IsKeyDown(KEY_LSHIFT) or input.IsKeyDown(KEY_LCONTROL) then
						s:SetBackgroundColor(Color(0,200,0))
						table.insert(frame.selectedLaws, k)
					else
						for _, v in ipairs(frame.lawsPnl:GetCanvas():GetChildren()) do
							frame.selectedLaws = {k}
							v:SetBackgroundColor(v.id == k and Color(0,200,0) or nil)
						end
					end
				end

				local menu = DermaMenu()

				if #frame.selectedLaws == 1 then
					menu:AddOption('Редактировать', function()
						Derma_StringRequest('Редактировать закон', 'Введи новый текст закона', v, function(text)
							RunConsoleCommand('darkrp', 'editlaw', k, text)
							self:refreshLaws()
						end)
					end):SetIcon('icon16/page_edit.png')
				end

				menu:AddOption('Удалить', function()
					RunConsoleCommand('darkrp', 'removelaw', table.concat(frame.selectedLaws, ';'))
					self:refreshLaws()
				end):SetIcon('icon16/delete.png')

				menu:Open()
			end
		end
	end
end

hook.Add('LawsChanged', 'chiefdemote', function()
	chiefDemote:refreshLaws()
end)

function chiefDemote:refreshCPs()
	if not frame or not frame.demotePnl then return end

	frame.demotePnl:Remove()

	frame.demotePnl = vgui.Create('DPropertySheet', frame.main)
    frame.demotePnl:Dock(FILL)

    for k, category in pairs (chiefDemote.jobs[LocalPlayer():Team()] or {}) do
    	local group = vgui.Create('DListView', frame.demotePnl)
    	group:AddColumn('Имя')
    	group:AddColumn('Профессия')
    	group:SetHeaderHeight(20)
    	group:SetDataHeight(25)

    	for _, v in player.Iterator() do
    		if self.canDemote(LocalPlayer(), v) and category[v:Team()] then
    			local cp = group:AddLine(v:Name(), team.GetName(v:Team()))
    			function cp:OnRightClick()
    				local menu = DermaMenu()

    				menu:AddOption('Уволить', function ()
    					Derma_StringRequest(
    						'Уволить подчиненного',
    						'Введи ниже причину увольнения',
    						'',
    						function (text)
    							if not tostring(text) then return notification.AddLegacy('Ты ввел некорректную причину', 1, 4) end
		    					net.Start('chiefDemote.demote')
			    					net.WriteEntity(v)
			    					net.WriteString(tostring(text))
		    					net.SendToServer()
		    					timer.Simple(.5, function ()
		    						chiefDemote:refreshCPs()
		    					end)
    						end
    					)
    				end):SetIcon('icon16/cancel.png')

    				menu:AddSpacer()

    				menu:AddOption('Скопировать имя', function ()
    					LocalPlayer():ChatPrint('Имя скопировано в буфер обмена.')
    					SetClipboardText(v:Name())
    				end)
    				menu:AddOption('Скопировать SteamID', function ()
    					LocalPlayer():ChatPrint('SteamID скопирован в буфер обмена.')
    					SetClipboardText(v:SteamID())
    				end)

    				menu:Open()
    			end
    		end
    	end

    	frame.demotePnl:AddSheet(k, group)
    end
end

concommand.Add('chiefdemote', function ()
	chiefDemote:openFrame()
end)
--addons/weapon_climb/lua/autorun/cl_falleffect.lua:
--hook.Remove("CreateMove", "ClimbFall")
--addons/tool_shap/lua/autorun/client.lua:
// Written by Syranide, me@syranide.com
// fixed and updated by minifisch, mail@minifisch.net
// big thanks to Syranide! :)

if SERVER then
	AddCSLuaFile( "client.lua" )
end

if CLIENT then

local target =        { active = false }
local snaptarget =    { active = false }
local snapkey =       false
local snaptime =      false
local snaplock =      false
local snapclick =     false
local snapclickfade = 0
local snapcursor =    false
local snapspawnmenu = false

local cache = {
	vPlayerPos = 0,
	vLookPos = 0,
	vLookClipPos = 0,
	vLookVector = 0,
}

local condefs = {
	snap_enabled      = 1,
	snap_gcboost      = 1,
	snap_gcstrength   = 125,
	snap_hidegrid     = 0,
	snap_clickgrid    = 0,
	snap_toggledelay  = 0,
	snap_disableuse   = 0,
	snap_allentities  = 0,
	snap_alltools     = 0,
	snap_enabletoggle = 0,
	snap_lockdelay    = 0.5,
	snap_distance     = 250,
	snap_gridlimit    = 16,
	snap_gridsize     = 8,
	snap_gridalpha    = 0.4,
	snap_gridoffset   = 0.5,
	snap_boundingbox  = 1,
	snap_revertaim    = 1,
	snap_centerline   = 1,
}

local convars = {}

for key,value in pairs(condefs) do
	convars[#convars + 1] = key
end


local modelsaveset = {}
local modeloffsets = {}

---------

local function DrawScreenLine(vsA, vsB)
	surface.DrawLine(vsA.x, vsA.y, vsB.x, vsB.y)
end

local function ToScreen(vWorld)
	local vsScreen = vWorld:ToScreen()
	return Vector(vsScreen.x, vsScreen.y, 0)
end

local function PointToScreen(vPoint)
	if cache.vLookVector:DotProduct(vPoint - cache.vLookClipPos) > 0 then
		return ToScreen(vPoint)
	end
end

local function LineToScreen(vStart, vEnd)
	local dotStart = cache.vLookVector:DotProduct(vStart - cache.vLookClipPos)
	local dotEnd = cache.vLookVector:DotProduct(vEnd - cache.vLookClipPos)
	
	if dotStart > 0 and dotEnd > 0 then
		return ToScreen(vStart), ToScreen(vEnd)
	elseif dotStart > 0 or dotEnd > 0 then
		local vLength = vEnd - vStart
		local vIntersect = vStart + vLength * ((cache.vLookClipPos:DotProduct(cache.vLookVector) - vStart:DotProduct(cache.vLookVector)) / vLength:DotProduct(cache.vLookVector))
		
		if dotStart <= 0 then
			return ToScreen(vIntersect), ToScreen(vEnd)
		else
			return ToScreen(vStart), ToScreen(vIntersect)
		end
	end
end

local function RayQuadIntersect(vOrigin, vDirection, vPlane, vX, vY)
	local vp = vDirection:Cross(vY)

	local d = vX:DotProduct(vp)
	if (d <= 0.0) then return end

	local vt = vOrigin - vPlane
	local u = vt:DotProduct(vp)
	if (u < 0.0 or u > d) then return end

	local v = vDirection:DotProduct(vt:Cross(vX))
	if (v < 0.0 or v > d) then return end

	return Vector(u / d, v / d, 0)
end

------------

local function OnInitialize()
	for key,value in pairs(condefs) do
		CreateClientConVar(key, value, true, false)
	end

	for _,filename in ipairs(file.Find('smartsnap_offsets_*.png', "GAME")) do
		local file = file.Read(filename)
		if file then
			lines = string.Explode("\n", file)
			header = table.remove(lines, 1)
			if header == "SMARTSNAP_OFFSETS" then
				for _,line in ipairs(lines) do
					local pos = string.find(line, '=')
					if pos then
						 local key = string.lower(string.Trim(string.sub(line, 1, pos - 1)))
						 local value = string.Trim(string.sub(line, pos + 1))
						 
						 local c = string.Explode(",", value)
						 modeloffsets[key]= { tonumber(c[1]), tonumber(c[2]), tonumber(c[3]), tonumber(c[4]),  tonumber(c[5]),  tonumber(c[6])  }
					end
				end
			end
		end
	end
end
	
local function OnShutDown()
	output = file.Read('smartsnap_offsets_custom.png')
	if output == nil then
		output = "SMARTSNAP_OFFSETS\n"
	end
	
	for model,_ in pairs(modelsaveset) do
		output = output .. model .. '=' .. table.concat(modeloffsets[model], ",") .. "\n"
	end
	
	file.Write('smartsnap_offsets_custom.png', output)
end

local function GetDevOffset()
	local model = string.lower(target.entity:GetModel())

	if modeloffsets[model] == nil then
		modeloffsets[model] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }
	end
	
	return modeloffsets[model]
end

concommand.Add("snap_dev_alloffset", function(player, command, arguments) if target.active == true then if #arguments >= 1 then local v = GetDevOffset() for i=1,6 do v[i] = v[i] + tonumber(arguments[1]) end end end end)
concommand.Add("snap_dev_gridoffset", function(player, command, arguments) if target.active == true then if #arguments >= 1 then local v = GetDevOffset() v[target.face] = v[target.face] + tonumber(arguments[1]) end end end)
concommand.Add("snap_dev_saveoffset", function(player, command, arguments) if target.active == true then local v = GetDevOffset() modelsaveset[string.lower(target.entity:GetModel())] = true end end)

local function SnapToggleGrid()
	if (GetConVarNumber("snap_enabled") == 0) then
		RunConsoleCommand('snap_enabled', '1')
	else
		RunConsoleCommand('snap_enabled', '0')
	end
end

local function SnapPress()
	if GetConVarNumber("snap_clickgrid") != 0 and !snapclick then
		snapclick = true
		snapclickfade = CurTime()
	elseif GetConVarNumber("snap_clickgrid") == 0 or snapclick then
		if (snaplock or snapcursor) then
			snaptime = false
		else
			local toggledelay = GetConVarNumber("snap_toggledelay")
			if (toggledelay > 0 and snaptime and snaptime + toggledelay > CurTime()) then
				SnapToggleGrid()
				snaptime = false
				snaplock = false
			else
				snaptime = CurTime()
			end
		end
		
		snapkey = target.active
		
		if (!snapcursor) then
			snaplock = false
		end
	end
end

local function SnapRelease()
	snapkey = false
end

local function SnapLock()
	snaplock = !snaplock
end

local function OnSpawnMenu()
	snapspawnmenu = true
end

local function OnKeyPress(player, key)
	if (key == IN_USE and GetConVarNumber("snap_disableuse") == 0) then
		SnapPress()
	end
end

local function OnKeyRelease(player, key)
	if (key == IN_USE and GetConVarNumber("snap_disableuse") == 0) then
		SnapRelease()
	end
end

local function OnThink()
	if (vgui.CursorVisible()) then
		if (!snapcursor and snaplock) then
			snaptarget = table.Copy(target)
		end
		
		snaptime = false
		snapcursor = true
	else
		if (snapcursor and snaplock) then
			target = snaptarget
		end
		
		snapspawnmenu = false
		snapcursor = false
	end
	
	if (GetConVarNumber("snap_enabletoggle") != 0) then
		if (snapkey and snaptime and !snaplock) then
			if (CurTime() > snaptime + GetConVarNumber("snap_lockdelay")) then
				snaplock = true
				snaptime = false
			end
		end
	end
		
	local locked = target.locked and target.active
	target.locked = (snapkey or snaplock and !snapcursor) and target.active
	
	if (!target.locked and locked and GetConVarNumber("snap_revertaim") != 0) then
		if (snapcursor) then
			local screen = target.entity:LocalToWorld(target.vector):ToScreen()
			gui.SetMousePos(math.Round(screen.x), math.Round(screen.y))
		else
			local angles = (target.entity:LocalToWorld(target.vector) - LocalPlayer():GetShootPos()):Angle()
			LocalPlayer():SetEyeAngles(angles)
		end
	end
end

local function CalculateGridAxis(L)
	local length = L:Length()
	local grid   = math.Clamp(math.floor(length / (2 * GetConVarNumber("snap_gridsize"))) * 2, 2, GetConVarNumber("snap_gridlimit"))
	local offset = math.Clamp(GetConVarNumber("snap_gridoffset") / length, 0, 1 / grid)
	local scale  = 1 - offset * 2
	
	return {
		length = length,
		offset = offset,
		scale  = scale,
		grid   = grid,
	}
end

local function CalculateSnap(X, Y, v)
	local LX = CalculateGridAxis(X)
	local LY = CalculateGridAxis(Y)
	
	local BX = math.Clamp(math.Round(v.x * LX.grid), 0, LX.grid)
	local BY = math.Clamp(math.Round(v.y * LY.grid), 0, LY.grid)
	
	if BX == 1           and v.x <     (1 / LX.grid + LX.offset) / 2 then BX = 0 end
	if BX == LX.grid - 1 and v.x > 1 - (1 / LX.grid + LX.offset) / 2 then BX = LX.grid end
	if BY == 1           and v.y <     (1 / LY.grid + LY.offset) / 2 then BY = 0 end
	if BY == LY.grid - 1 and v.y > 1 - (1 / LY.grid + LY.offset) / 2 then BY = LY.grid end
	
	local RX = X * (BX / LX.grid)
	local RY = Y * (BY / LY.grid)
	
	if BX == 0       then RX = X * math.Clamp(LX.offset, 0, 1 / LX.grid) end
	if BX == LX.grid then RX = X * (1 - math.Clamp(LX.offset, 0, 1 / LX.grid)) end
	if BY == 0       then RY = Y * math.Clamp(LY.offset, 0, 1 / LY.grid) end
	if BY == LY.grid then RY = Y * (1 - math.Clamp(LY.offset, 0, 1 / LY.grid)) end
	
	return RX + RY
end

local function DrawGridLines(vOrigin, vSX, vSY, gridLines, offsetX, offsetY, sign)
	local centerline = (GetConVarNumber("snap_centerline") != 0)

	local vTemp = vOrigin + vSX * 0.5
	local vX = vTemp + vSY * (offsetY)
	local vY = vTemp + vSY * (1 - offsetY)

	local vOffset, temp
	local xtemp = ToScreen(vX) - ToScreen(vY)
	xtemp:Normalize()
	local vsNormal = xtemp
	
	if math.abs(vsNormal.x) < 1 - math.abs(vsNormal.y) then temp = -0.5 * sign else temp = 0.5 * sign end
	if math.abs(vsNormal.x) <     math.abs(vsNormal.y) then vsOffset = Vector(temp, 0, 0) else vsOffset = Vector(0, temp, 0) end

	if offsetX < 1 / gridLines then
		local vTemp = vOrigin + vSX * offsetX
		local vX = vTemp + vSY * offsetY
		local vY = vTemp + vSY * (1 - offsetY)
		
		local vsX, vsY = LineToScreen(vX, vY)
		if (vsX) then DrawScreenLine(vsX + vsOffset, vsY + vsOffset) end
	end
	
	for i = 1,gridLines-1 do
		local vTemp = vOrigin + vSX * (i / gridLines)
		local vX = vTemp + vSY * offsetY
		local vY = vTemp + vSY * (1 - offsetY)
		
		local vsX, vsY = LineToScreen(vX, vY)
		
		if (vsX) then
			if (gridLines / i == 2 && centerline) then
				DrawScreenLine(vsX + vsOffset * -1, vsY + vsOffset * -1)
				DrawScreenLine(vsX + vsOffset *  3, vsY + vsOffset *  3)
			else
				DrawScreenLine(vsX + vsOffset,      vsY + vsOffset)
			end
		end
	end
	
	if offsetX < 1 / gridLines then
		local vTemp = vOrigin + vSX * (1 - offsetX)
		local vX = vTemp + vSY * offsetY
		local vY = vTemp + vSY * (1 - offsetY)
		
		local vsX, vsY = LineToScreen(vX, vY)
		if (vsX) then DrawScreenLine(vsX + vsOffset, vsY + vsOffset) end
	end
end

local function DrawGrid(vOrigin, vSX, vSY)
	local LX = CalculateGridAxis(vSX)
	local LY = CalculateGridAxis(vSY)
	
	surface.SetDrawColor(0, 0, 0, math.Round(GetConVarNumber("snap_gridalpha") * 255))
	DrawGridLines(vOrigin, vSX, vSY, LX.grid, LX.offset, LY.offset, 1)
	DrawGridLines(vOrigin, vSY, vSX, LY.grid, LY.offset, LX.offset, 1)
	
	surface.SetDrawColor(255, 255, 255, math.Round(GetConVarNumber("snap_gridalpha") * 255))
	DrawGridLines(vOrigin, vSX, vSY, LX.grid, LX.offset, LY.offset, -1)
	DrawGridLines(vOrigin, vSY, vSX, LY.grid, LY.offset, LX.offset, -1)
end

local function DrawBoundaryLines(vOrigin, vOpposite)
	local vPoint
	
	if (vOrigin:DistToSqr(vOpposite) > 25) then
	    local x = vOpposite - vOrigin
		x:Normalize()
		vPoint = vOrigin + x * 5
	else
		vPoint = vOrigin + (vOpposite - vOrigin) / 2
	end
	
	local vsA, vsB = LineToScreen(vPoint, vOrigin)
	
	if (vsA) then
		surface.SetDrawColor(0, 0, 255, 192)
		DrawScreenLine(vsA, vsB)
	end
end

local function DrawBoundary(vOrigin, vX, vY, vZ)
	DrawBoundaryLines(vOrigin, vX)
	DrawBoundaryLines(vOrigin, vY)
	DrawBoundaryLines(vOrigin, vZ)
end

local function DrawSnapCross(vsCenter, r, g, b)
	surface.SetDrawColor(0, 0, 0, 255)
	DrawScreenLine(vsCenter + Vector(-2.5, -2.0), vsCenter + Vector( 2.5,  3.0))
	DrawScreenLine(vsCenter + Vector( 1.5, -2.0), vsCenter + Vector(-3.5,  3.0))
	
	surface.SetDrawColor(r, g, b, 255)
	DrawScreenLine(vsCenter + Vector(-1.5, -2.0), vsCenter + Vector( 3.5,  3.0))
	DrawScreenLine(vsCenter + Vector( 2.5, -2.0), vsCenter + Vector(-2.5,  3.0))
end

local function ComputeEdges(entity, obbmax, obbmin)
	return {
		lsw = entity:LocalToWorld(Vector(obbmin.x, obbmin.y, obbmin.z)),
		lse = entity:LocalToWorld(Vector(obbmax.x, obbmin.y, obbmin.z)),
		lnw = entity:LocalToWorld(Vector(obbmin.x, obbmax.y, obbmin.z)),
		lne = entity:LocalToWorld(Vector(obbmax.x, obbmax.y, obbmin.z)),
		usw = entity:LocalToWorld(Vector(obbmin.x, obbmin.y, obbmax.z)),
		use = entity:LocalToWorld(Vector(obbmax.x, obbmin.y, obbmax.z)),
		unw = entity:LocalToWorld(Vector(obbmin.x, obbmax.y, obbmax.z)),
		une = entity:LocalToWorld(Vector(obbmax.x, obbmax.y, obbmax.z)),
	}
end

local function OnPaintHUD()
	target.active = false
	
	if GetConVarNumber("snap_clickgrid") != 0 and !snapclick then return end
	
	snapclickprev = snapclick
	snapclick = snapclickprev and snapclickfade > CurTime()
	
	if (GetConVarNumber("snap_enabled") == 0) then return end
	if (!LocalPlayer():Alive() or LocalPlayer():InVehicle()) then return end
	
	if (target.locked) then
		if (!target.entity:IsValid()) then return end
	else
		local trace = LocalPlayer():GetEyeTrace()
		cache.vLookTrace = trace
		if (!trace.HitNonWorld) then return end
		
		local entity = trace.Entity
		if (entity == nil) then return end
		if (!entity:IsValid()) then return end
		
		local class = entity:GetClass()
		if (class != 'prop_physics' and class != 'phys_magnet' and class != 'gmod_spawner') then return end
		
		if (!LocalPlayer():GetActiveWeapon():IsValid()) then return end
		if (LocalPlayer():GetActiveWeapon():GetClass() == 'weapon_physgun') then return end
		if (LocalPlayer():GetActiveWeapon():GetClass() != 'gmod_tool') then return end
		
		target.entity = entity
	end
	
	--ErrorNoHalt(collectgarbage("count"))
	if GetConVarNumber("snap_gcboost") != 0 then
		collectgarbage("step", GetConVarNumber("snap_gcstrength"))
	end
	
	snapclick = snapclickprev
	snapclickfade = CurTime() + 0.25
	
	-- updating the cache perhaps shouldn't be done here, CalcView?
	cache.vLookPos = LocalPlayer():GetShootPos()
	cache.vLookVector = LocalPlayer():GetAimVector()
	cache.vLookClipPos = cache.vLookPos + cache.vLookVector * 3

	local model = string.lower(target.entity:GetModel())
	local offsets = modeloffsets[model]
	
	if !offsets then
		local offset = 0.25
		offsets = { offset, offset, offset, offset, offset, offset }
	end
	
	if cache.eEntity != target.entity or cache.vEntAngles != target.entity:GetAngles() or vEntPosition != target.entity:GetPos() then
		cache.eEntity = target.entity
		cache.vEntAngles = target.entity:GetAngles()
		cache.vEntPosition = target.entity:GetPos()
		
		local obbmax = target.entity:OBBMaxs()
		local obbmin = target.entity:OBBMins()
		local obvsnap = ComputeEdges(target.entity, obbmax, obbmin)
		
		local obbmax = target.entity:OBBMaxs() - Vector(offsets[5], offsets[3], offsets[1])
		local obbmin =  target.entity:OBBMins() + Vector(offsets[6], offsets[4], offsets[2])
		local obvgrid = ComputeEdges(target.entity, obbmax, obbmin)
		
		local faces = {
			{ obvgrid.unw, obvgrid.usw - obvgrid.unw, obvgrid.une - obvgrid.unw, obvgrid.lnw - obvgrid.unw, Vector(0, 0, -offsets[1]) },
			{ obvgrid.lsw, obvgrid.lnw - obvgrid.lsw, obvgrid.lse - obvgrid.lsw, obvgrid.usw - obvgrid.lsw, Vector(0, 0,  offsets[2]) },
			{ obvgrid.unw, obvgrid.une - obvgrid.unw, obvgrid.lnw - obvgrid.unw, obvgrid.usw - obvgrid.unw, Vector(0, -offsets[3], 0) },
			{ obvgrid.usw, obvgrid.lsw - obvgrid.usw, obvgrid.use - obvgrid.usw, obvgrid.unw - obvgrid.usw, Vector(0,  offsets[4], 0) },
			{ obvgrid.une, obvgrid.use - obvgrid.une, obvgrid.lne - obvgrid.une, obvgrid.unw - obvgrid.une, Vector(-offsets[5], 0, 0) },
			{ obvgrid.unw, obvgrid.lnw - obvgrid.unw, obvgrid.usw - obvgrid.unw, obvgrid.une - obvgrid.unw, Vector( offsets[6], 0, 0) },
		}
		
		cache.aGrid = obvgrid
		cache.aSnap = obvsnap
		cache.aFaces = faces
	end
	
	local obvgrid = cache.aGrid
	local obvsnap = cache.aSnap
	local faces = cache.aFaces
	
	if (!target.locked) then
		-- should improve this by expanding the bounding box or something instead!
		-- create a larger bounding box and then planes for each side, and check distance from the plane
		-- separate function perhaps?
		local distance = (LocalPlayer():GetPos() - target.entity:GetPos()):Length() - (obvgrid.unw - obvgrid.lse):Length()
		if (distance > GetConVarNumber("snap_distance")) then return end
		
		for face,vertices in ipairs(faces) do
			intersection = RayQuadIntersect(cache.vLookPos, cache.vLookVector, vertices[1], vertices[2], vertices[3])
			if (intersection) then
				target.face = face
				break
			end
		end
		
		if intersection == nil then return end
	end
	
	if (GetConVarNumber("snap_boundingbox") != 0) then
		DrawBoundary(obvgrid.unw, obvgrid.lnw, obvgrid.usw, obvgrid.une)
		DrawBoundary(obvgrid.une, obvgrid.lne, obvgrid.use, obvgrid.unw)
		DrawBoundary(obvgrid.lnw, obvgrid.unw, obvgrid.lsw, obvgrid.lne)
		DrawBoundary(obvgrid.lne, obvgrid.une, obvgrid.lse, obvgrid.lnw)
		DrawBoundary(obvgrid.usw, obvgrid.lsw, obvgrid.unw, obvgrid.use)
		DrawBoundary(obvgrid.use, obvgrid.lse, obvgrid.une, obvgrid.usw)
		DrawBoundary(obvgrid.lsw, obvgrid.usw, obvgrid.lnw, obvgrid.lse)
		DrawBoundary(obvgrid.lse, obvgrid.use, obvgrid.lne, obvgrid.lsw)
	end
	
	local vectorOrigin = faces[target.face][1]
	local vectorX =      faces[target.face][2]
	local vectorY =      faces[target.face][3]
	local vectorZ =      faces[target.face][4]
	local vectorOffset = faces[target.face][5]
	
	local vectorGrid
	
	if (!target.locked) then
		vectorGrid = vectorOrigin + CalculateSnap(vectorX, vectorY, intersection)
		
		local trace = util.TraceLine({
			start  = target.entity:LocalToWorld(target.entity:WorldToLocal(vectorGrid) - vectorOffset) - vectorZ:GetNormalized() * 0.01,
			endpos = vectorGrid + vectorZ,
		})
		
		local vectorSnap = trace.HitPos
		target.offset = target.entity:WorldToLocal(vectorSnap)
		target.vector = target.entity:WorldToLocal(vectorGrid)
		
		target.error = true

		if (trace.Entity == nil or !trace.Entity:IsValid()) then
			snaperror = -1
		elseif (trace.Entity != target.entity) then
			snaperror = -2
		elseif (trace.HitPos == trace.StartPos) then
			snaperror = -2
		else
			snaperror = (LocalPlayer():GetEyeTrace().HitPos - trace.HitPos):Length()
			target.error = false
			
			if ((vectorSnap - vectorGrid):Length() > 0.5) then
				local marker = PointToScreen(vectorSnap)
				
				if (marker) then
					DrawSnapCross(marker, 255, 255, 255)
				end
			end
		end
	else
		vectorGrid = target.entity:LocalToWorld(target.vector)
		local vectorSnap = target.entity:LocalToWorld(target.offset)
	
		local marker = PointToScreen(vectorSnap)
		snaperror = (LocalPlayer():GetEyeTrace().HitPos - vectorSnap):Length()
		
		if (marker) then
			if (target.error == true) then
				snaperror = -2
				DrawSnapCross(marker, 0, 255, 255)
			elseif (snaperror < 0.001) then
				DrawSnapCross(marker, 0, 255, 0)
			elseif (snaperror < 0.1) then
				DrawSnapCross(marker, 255, 255, 0)
			else
				DrawSnapCross(marker, 255, 0, 0)
			end
		end
	end
	
	if (GetConVarNumber("snap_hidegrid") == 0) then
		DrawGrid(vectorOrigin, vectorX, vectorY)
	end

	target.active = true
	
	local vsCursor = PointToScreen(vectorGrid)
	
	if (vsCursor) then
		if (snaperror == -1) then
			target.active = false
			DrawSnapCross(vsCursor, 0, 255, 255)
		elseif (snaperror == -2) then
			DrawSnapCross(vsCursor, 255, 0, 255)
		elseif (snaperror < 0.001) then
			DrawSnapCross(vsCursor, 0, 255, 0)
		elseif (snaperror < 0.1) then
			DrawSnapCross(vsCursor, 255, 255, 0)
		else
			DrawSnapCross(vsCursor, 255, 0, 0)
		end
	end
end

local function OnSnapView(player, origin, angles, fov)
	local targetvalid = target.active and target.locked and target.entity:IsValid()
	local snaptargetvalid = snaptarget.active and snaptarget.locked and snaptarget.entity:IsValid()

	if (snapcursor and !snapspawnmenu and targetvalid) then
		local screen = ToScreen(target.entity:LocalToWorld(target.offset))
		gui.SetMousePos(math.Round(screen.x), math.Round(screen.y))
	end
	
	if (!snapcursor and targetvalid) then
		return {angles = (target.entity:LocalToWorld(target.offset) - player:GetShootPos()):Angle()}
	elseif (snaplock and snaptargetvalid) then	
		return {angles = (snaptarget.entity:LocalToWorld(snaptarget.offset) - player:GetShootPos()):Angle()}
	end
end

local function OnSnapAim(user)
	local targetvalid = target.active and target.locked and target.entity:IsValid()
	local snaptargetvalid = snaptarget.active and snaptarget.locked and snaptarget.entity:IsValid()

	if (!snapcursor and targetvalid) then
		user:SetViewAngles((target.entity:LocalToWorld(target.offset) - LocalPlayer():GetShootPos()):Angle())
	elseif (snaplock and snaptargetvalid) then	
		user:SetViewAngles((snaptarget.entity:LocalToWorld(snaptarget.offset) - LocalPlayer():GetShootPos()):Angle())
	end
end

concommand.Add("+snap", SnapPress)
concommand.Add("-snap", SnapRelease)
concommand.Add("snaplock", SnapLock)
concommand.Add("snaptogglegrid", SnapToggleGrid)


hook.Add("Initialize", "SmartsnapInitialize", OnInitialize)

hook.Add("SpawnMenuOpen", "SmartsnapSpawnMenu", OnSpawnMenu)

hook.Add("Think", "SmartsnapThink", OnThink)
hook.Add("ShutDown", "SmartsnapShutDown", OnShutDown)

hook.Add("KeyPress", "SmartsnapKeyPress", OnKeyPress)
hook.Add("KeyRelease", "SmartsnapKeyRelease", OnKeyRelease)

hook.Add("CreateMove", "SmartsnapSnap", OnSnapAim)
hook.Add("CalcView", "SmartsnapSnapView", OnSnapView)

hook.Add("SpawnMenuOpen", "SmartsnapSpawnMenu", OnSpawnMenu)

hook.Add("HUDPaintBackground", "SmartsnapPaintHUD", OnPaintHUD)


local function OnPopulateToolPanel(panel)
 	panel:AddControl("ComboBox", {
		Options = { ["default"] = condefs },
		CVars = convars,
		Label = "",
		MenuButton = "1",
		Folder = "smartsnap"
	}) 
	
	panel:AddControl("CheckBox", {
		Label = "Enable",
		Command = "snap_enabled",
	})
	
	panel:AddControl("CheckBox", {
		Label = "Use click grid (USE temporarily enables grid)",
		Command = "snap_clickgrid",
	})
	
	panel:AddControl("CheckBox", {
		Label = "Hide grid (only shows snap point)",
		Command = "snap_hidegrid",
	})

	panel:AddControl("CheckBox", {
		Label = "Smart toggle enabled",
		Command = "snap_enabletoggle",
	})

	panel:AddControl("CheckBox", {
		Label = "Revert aim to grid snap on detach",
		Command = "snap_revertaim",
	})

	panel:AddControl("CheckBox", {
		Label = "Enable for all entities",
		Command = "snap_allentities",
	})

	panel:AddControl("CheckBox", {
		Label = "Enable for all tools",
		Command = "snap_alltools",
	})

	panel:AddControl("CheckBox", {
		Label = "Draw thick center lines",
		Command = "snap_centerline",
	})

	panel:AddControl("Slider", {
		Label = "Grid toggle delay (double click snap-key)",
		Command = "snap_toggledelay",
		Type = "Float",
		Min = "0.0",
		Max = "0.2",
	})

	panel:AddControl("Slider", {
		Label = "Smart lock delay",
		Command = "snap_lockdelay",
		Type = "Float",
		Min = "0.0",
		Max = "5.0",
	})

	panel:AddControl("CheckBox", {
		Label = "Bounding box enabled",
		Command = "snap_boundingbox",
	})

	panel:AddControl("Slider", {
		Label = "Grid draw distance",
		Command = "snap_distance",
		Type = "Integer",
		Min = "50",
		Max = "1000",
	})

	panel:AddControl("Slider", {
		Label = "Grid edge offset",
		Command = "snap_gridoffset",
		Type = "Float",
		Min = "0.0",
		Max = "2.5",
	})

	panel:AddControl("Slider", {
		Label = "Grid transparency",
		Command = "snap_gridalpha",
		Type = "Float",
		Min = "0.1",
		Max = "1.0",
	})

	panel:AddControl("Slider", {
		Label = "Maximum number of snap points on an axis",
		Command = "snap_gridlimit",
		Type = "Integer",
		Min = "2",
		Max = "64",
	})

	panel:AddControl("Slider", {
		Label = "Minimum distance between each snap point",
		Command = "snap_gridsize",
		Type = "Integer",
		Min = "2",
		Max = "64",
	})
	
	
	panel:AddControl("Label", {
		Text = ""
	})
	
	panel:AddControl("Label", {
		Text = "The following option should prevent FPS drops from occuring, however it might have a slight impact on the average FPS while the grid is showing. Do NOT uncheck this option unless you are experiencing very low FPS or fully understands its purpose."
	})
	
	panel:AddControl("Label", {
		Text = "NOTE: This option is only effective when the grid is showing, it does not impact regular gameplay!"
	})
	
	panel:AddControl("Label", {
		Text = ""
	})
	
	panel:AddControl("CheckBox", {
		Label = "Garbage collection boost",
		Command = "snap_gcboost",
	})
end

function OnPopulateToolMenu()
	spawnmenu.AddToolMenuOption("Options", "Player", "SmartSnapSettings", "SmartSnap", "", "", OnPopulateToolPanel, {SwitchConVar = 'snap_enabled'})
end

hook.Add("PopulateToolMenu", "SmartSnapToolMenu", OnPopulateToolMenu)

end
--addons/module_samogon/lua/moonshine/cl/effect/effect.lua:

if (CLIENT) then

local dist_effect = Material("models/dog/eyeglass")
net.Receive("dist_effect_api",function()
	local dist_value = net.ReadInt(16)
	local dist_drunk = vgui.Create( "DPanel" )
	dist_drunk:SetPos( 0, 0 )
	dist_drunk:SetSize( ScrW(), ScrH() ) 
	dist_drunk.Paint = function( self, w, h )		
		surface.SetDrawColor( 255, 255, 255, 255 )
		surface.SetMaterial( dist_effect ) 
		surface.DrawTexturedRect( 0, 0, w, h )
		draw.RoundedBox(0,0,0,w,h,Color(0,0,200,dist_value))	
	end	
	timer.Simple( dist_value, function()
		dist_drunk:Remove()
	end)
end)

end
--addons/module_eventpanel/lua/devents/sh_util.lua:
function dEvents.canStartEvent(ply)
    if not IsValid(ply) then return false, 'Ты не существуешь 0_o' end

    if not dEvents.config.adminGroups[ply:GetUserGroup()] then return false, dEvents.getPhrase('error_notEventer') end

    if SERVER then
        if dEvents.getEventer(ply) then return false, dEvents.getPhrase('error_inEvent') end
        if dEvents.getFreeEvents()[1] then return false, dEvents.getPhrase('error_eventPreparing') end
        if dEvents.getEventTable(ply) then return false, dEvents.getPhrase('error_eventFounder') end
    end
end

function dEvents.getPhrase(phrase, ...)
    local format = {...}
    return dEvents.lang[phrase] and string.format(dEvents.lang[phrase], unpack(format or {})) or ''
end

if SERVER then
    function dEvents.notify(ply, ...)
        local args = {...}
    
        net.Start('dEvents.notify')
        net.WriteTable(args)
        net.Send(ply)
    end

    function dEvents.notifyAll(...)
        local args = {...}
    
        net.Start('dEvents.notify')
        net.WriteTable(args)
        net.Broadcast()
    end
else
    net.Receive('dEvents.notify', function ()
        dEvents.notify(unpack(net.ReadTable()))
    end)
    function dEvents.notify(...)
        local args = table.Add({Color(0,158,0), '[EVENT] '}, {...})
        local newArgs = {}

        for _, v in pairs (args) do 
            local value = istable(v) and Color(v.r, v.g, v.b, v.a) or v
            table.insert(newArgs, value)
        end
        
        chat.AddText(unpack(newArgs))
    end
end
--addons/module_eventpanel/lua/devents/sh_actions.lua:
dEvents.actions = {}

--[[
    actionData:
        string icon - Иконка для команды
        string name - Название кнопки
        bool onePlayer - Такую команду можно будет использовать только на игроке
        bool noButton - У такой команды не будет кнопки
        bool onlyEveryone
        function callback (table targets, table args)
        function panel (cmd, targets)
]]

function dEvents.addAction(command, data)
    dEvents.actions[string.lower(command)] = data
end

function dEvents.getSortedActions()
    local actions = {}
    for cmd, v in pairs (dEvents.actions) do
        local newAction = v
        newAction.command = cmd

        table.insert(actions, newAction)
    end
    table.sort(actions, function (a, b) return a.order < b.order end)
    return actions
end

-- Непосредственно добавляем действия

if CLIENT then
    function dEvents.floatSlider(title, text, name, decs, min, max, value, callback)
        local frame = vgui.Create('DFrame')
        frame:SetSize(400,200)
        frame:MakePopup()
        frame:Center()
        frame:SetTitle(title)
        frame.Paint = function(self, w, h)
            draw.RoundedBox(0,0,0,w,h,Color(54,57,62,255))	
        end
    
        local label = vgui.Create('DLabel', frame)
        label:Dock(TOP)
        label:DockMargin(0,5,0,5)
        label:SetText(text)
        label:SetWrap(true)
        label:SetAutoStretchVertical(true)
    
        local slider = vgui.Create('DNumSlider', frame)
        slider:Dock(TOP)
        slider:DockMargin(5,5,5,5)
        slider:SetText(name)
        slider:SetDecimals(decs)
        slider:SetMin(min)
        slider:SetMax(max)
        slider:SetValue(value)
    
        local button = vgui.Create('DButton', frame)
        button:Dock(BOTTOM)
        button:DockMargin(5,5,5,5)
        button:SetText('Готово')
        button:SetIcon('icon16/accept.png')
        button.DoClick = function ()
            callback(tonumber(slider:GetValue()))
            frame:Close()
        end
    end
end

dEvents.addAction('stop', {
    name = 'Закончить ивент',
    icon = 'icon16/cancel.png',
    order = 999999,
    noButton = true,
    callback = function (ply)
        dEvents.stopEvent(ply)
    end
})

dEvents.addAction('kick', {
    name = 'Кикнуть',
    icon = 'icon16/cancel.png',
    order = 1337,
    onePlayer = true,
    callback = function (ply, targets, args)
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            dEvents.removeEventMember(v)
            DarkRP.notify(v, 1, 4, dEvents.getPhrase('hint_kicked'))
        end
    end,
})

dEvents.addAction('invite', {
    name = 'Пригласить на ивент',
    icon = 'icon16/user_add.png',
    order = 5,
    onlyEveryone = true,
    callback = function (ply, targets, args)
        local target = player.GetBySteamID(args[2])

        if target == ply then return DarkRP.notify(ply, 1, 5, 'Э') end
        if not target then return DarkRP.notify(ply, 1, 5, 'Ты не выбрал игрока') end
        if dEvents.getEventer(target) then return DarkRP.notify(ply, 1, 5, 'Этот игрок уже участвует в ивенте') end
        if dEvents.getEventTable(target) then return DarkRP.notify(ply, 1, 5, 'Этот игрок проводит ивент') end

        DarkRP.notify(ply, 0, 5, 'Ты пригласил '..target:Name()..' на ивент')

        DarkRP.createQuestion(
            ply:Name()..' приглашает тебя на свой ивент. Присоединятся?',
            'dEvents.invite.'..ply:SteamID()..'.'..target:SteamID(),
            target,
            30,
            function(ans)
                if not IsValid(target) or not IsValid(ply) then return end
                if tobool(ans) then
                    dEvents.addEventMember(target, ply:SteamID())
                    dEvents.teleportToEvent(target)
                    dEvents.sendEventTable(ply)
                    DarkRP.notify(ply, 0, 5, target:Name()..' принял приглашение на ивент')
                else
                    DarkRP.notify(ply, 0, 5, target:Name()..' отклонил приглашение на ивент')
                end
            end,
            ply,
            target
        )
    end,
    panel = function (cmd, targets)
        local menu = DermaMenu()

        for _, v in player.Iterator() do
            if v == LocalPlayer() then continue end

            menu:AddOption(v:Name(), function()
                RunConsoleCommand('devents', cmd, targets, v:SteamID())
            end)
        end

        menu:Open()
    end,
})


dEvents.addAction('sethp', {
    name = 'Выдать ХП',
    icon = 'icon16/heart.png',
    order = 10,
    callback = function (ply, targets, args)
        local hp = tonumber(args[2])
        hp = hp and hp >= dEvents.config.hp.min and hp <= dEvents.config.hp.max and hp or dEvents.config.hp.default
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            v:SetHealth(hp)
        end
    end,
    panel = function (cmd, targets)
        Derma_StringRequest('Выдать ХП', 'Введи ниже количество хп, которое хочешь выдать (Макс. '..dEvents.config.hp.max..')', '', function (hp)
            RunConsoleCommand('devents', cmd, targets, hp)
        end)
    end,
})

dEvents.addAction('setar', {
    name = 'Выдать броню',
    icon = 'icon16/shield.png',
    order = 20,
    callback = function (ply, targets, args)
        local armor = tonumber(args[2])
        armor = armor and armor >= dEvents.config.armor.min and armor <= dEvents.config.armor.max and armor or dEvents.config.armor.default
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            v:SetArmor(armor)
        end
    end,
    panel = function (cmd, targets)
        Derma_StringRequest('Выдать броню', 'Введи ниже количество брони, которое хочешь выдать (Макс. '..dEvents.config.armor.max..')', '', function (ar)
            RunConsoleCommand('devents', cmd, targets, ar)
        end)
    end,
})

dEvents.addAction('setspeed', {
    name = 'Установить скорость',
    icon = 'icon16/clock_go.png',
    order = 30,
    callback = function (ply, targets, args)
        local modifier = tonumber(args[2])
        modifier = modifier and modifier >= dEvents.config.speedScale.min and modifier <= dEvents.config.speedScale.max and modifier or dEvents.config.speedScale.default
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            v:MoveModifier('event_speed', {
                walkmul = modifier,
                runmul = modifier,
            })
        end
    end,
    panel = function (cmd, targets)
        dEvents.floatSlider('Установить скорость', 'Выбери ниже коэффицент скорости, которую ты хочешь установить', 'Коэффицент', 1, dEvents.config.speedScale.min, dEvents.config.speedScale.max, dEvents.config.speedScale.default, function (val)
            RunConsoleCommand('devents', cmd, targets, val)
        end)
    end,
})

dEvents.addAction('setjump', {
    name = 'Установить силу прыжка',
    icon = 'icon16/arrow_up.png',
    order = 40,
    callback = function (ply, targets, args)
        local power = tonumber(args[2])
        power = power and power >= dEvents.config.jumpScale.min and power <= dEvents.config.jumpScale.max and power or dEvents.config.jumpScale.default
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            v:MoveModifier('event_jump', {
                jumpmul = power,
            })
        end
    end,
    panel = function (cmd, targets)
        dEvents.floatSlider('Установить силу прыжка', 'Выбери ниже коэффициент силы прыжка, которую ты хочешь установить', 'Коэффицент', 1, dEvents.config.jumpScale.min, dEvents.config.jumpScale.max, dEvents.config.jumpScale.default, function (val)
            RunConsoleCommand('devents', cmd, targets, val)
        end)
    end,
})

dEvents.addAction('setmodel', {
    name = 'Установить модель',
    icon = 'icon16/user_gray.png',
    order = 50,
    callback = function (ply, targets, args)
        local model = tostring(args[2])
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            v:SetModel(model)
        end
    end,
    panel = function (cmd, targets)
        Derma_StringRequest('Установить модель', 'Введи ниже название модели, которую хочешь установить', '', function (mdl)
            RunConsoleCommand('devents', cmd, targets, mdl)
        end)
    end,
})

dEvents.addAction('setcolor', {
    name = 'Установить цвет',
    icon = 'icon16/user_gray.png',
    order = 55,
    callback = function (ply, targets, args)
        local r, g, b = tonumber(args[2]), tonumber(args[3]), tonumber(args[4])
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            v:SetColor4Part(math.Clamp(r, 0, 255), math.Clamp(g, 0, 255), math.Clamp(b, 0, 255), 255)
        end
    end,
    panel = function (cmd, targets)
        local frame = vgui.Create('DFrame')
        frame:SetSize(250, 300)
        frame:Center()
        frame:MakePopup()
        frame:SetTitle('Установка цвета')

        local btn = vgui.Create('DButton', frame)
        btn:Dock(BOTTOM)
        btn:SetText('Установить')
        btn:SetIcon('icon16/accept.png')
        btn:SetTall(25)

        local mixer = vgui.Create('DColorMixer', frame)
        mixer:Dock(FILL)
        mixer:SetPalette(true)
        mixer:SetAlphaBar(true)
        mixer:SetWangs(true)

        btn.DoClick = function()
            local col = mixer:GetColor()
            RunConsoleCommand('devents', cmd, targets, col.r, col.g, col.b)
        end
    end,
})

dEvents.addAction('setscale', {
    name = 'Установить размер модели',
    icon = 'icon16/vector.png',
    order = 60,
    callback = function (ply, targets, args)
        local scale = tonumber(args[2])
        scale = scale and scale >= dEvents.config.modelScale.min and scale <= dEvents.config.modelScale.max and scale or dEvents.config.modelScale.default
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            v:SetModelScale(scale, 0)
            v:SetViewOffset(Vector(0, 0, 64) * scale)
            v:SetViewOffsetDucked(Vector(0, 0, 28) * scale)

            v:MoveModifier('event_scale', {
                jumpmul = scale,
                slowmul = scale,
            })
        end
    end,
    panel = function (cmd, targets)
        dEvents.floatSlider('Установить размер модели', 'Выбери размер модели, который ты хочешь установить', 'Размер', 1, dEvents.config.modelScale.min, dEvents.config.modelScale.max, dEvents.config.modelScale.default, function (val)
            RunConsoleCommand('devents', cmd, targets, val)
        end)
    end,
})

dEvents.addAction('fullstrip', {
    name = 'Забрать все оружие',
    icon = 'icon16/gun.png',
    order = 70,
    callback = function (ply, targets, args)
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            v:StripWeapons()
        end
    end,
})

dEvents.addAction('giveweapon', {
    name = 'Выдать оружие',
    icon = 'icon16/gun.png',
    order = 80,
    panel = function (cmd, targets)
        local window = vgui.Create('DFrame')
        window:SetSize(ScrW()*dEvents.config.giveWeaponSize.w, ScrH()*dEvents.config.giveWeaponSize.h)
        window:SetTitle('Выдать оружие')
        window:MakePopup()
        window:Center()
        window.Paint = function (s,w,h)
            draw.RoundedBox(0,0,0,w,h,dEvents.config.mainColor)
        end

        local weapongive = vgui.Create('devents_choosebrowser', window)
        weapongive:Dock(FILL)
        weapongive:AddColumn('Название')
        weapongive:AddColumn('ClassName')
        
        local sweps = {}
        for class, name in pairs (dEvents.config.permittedWeapons) do
            table.insert(sweps, {name, class})
        end
        for _, v in pairs (weapons.GetList() or {}) do
            local permCat = dEvents.config.permittedCategories[v.Category]
            if permCat then
                if permCat == true or permCat[LocalPlayer():GetUserGroup()] then
                    table.insert(sweps, {v.PrintName, v.ClassName})
                end
            end
        end
        weapongive:SetData(sweps)

        function weapongive:Callback()
            net.Start('dEvents.giveWeapon')
            net.WriteTable(self:GetSelectedData())
            net.WriteString(targets)
            net.SendToServer()
            window:Close()
        end
    end
})

dEvents.addAction('notify', {
    name = 'Сообщение в чат',
    icon = 'icon16/comment.png',
    order = 90,
    panel = function (cmd, targets)
        Derma_StringRequest('Сообщение в чат', 'Введи ниже сообщение для всех участников ивента', '', function (text)
            RunConsoleCommand('devents', cmd, targets, text)
        end)
    end,
    callback = function (ply, targets, args)
        local hasEventer
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            if v == ply then hasEventer = true end
            dEvents.notify(v, color_white, args[2])
        end
        if not hasEventer then dEvents.notify(ply, color_white, args[2]) end
    end,
})

hook.Add('SendingChat', 'dEvents.eventChat', function(text)
    local args = string.Explode(' ', text)
    if args[1] == '/e' or args[1] == '/event' then
        RunConsoleCommand('devents', 'notify', '*', table.concat(args, ' ', 2))

        return false
    end
end)

dEvents.addAction('playsound', {
    name = 'Воспроизвести звук',
    icon = 'icon16/sound.png',
    order = 100,
    panel = function (cmd, targets)
        Derma_StringRequest('Воспроизвести звук', 'Введи ниже полное название звука. Узнать можно на wiki.facepunch.com/gmod/HL2_Sound_List', '', function (text)
            RunConsoleCommand('devents', cmd, targets, text)
        end)
    end,
    callback = function (ply, targets, args)
        ply:ConCommand('play '..args[2]..'\n')
        for _, v in pairs (targets) do
            if not IsValid(v) then return end
            v:ConCommand('play '..args[2]..'\n')
        end
    end,
})

dEvents.addAction('savestate', {
    name = 'Сохранить настройки',
    icon = 'icon16/page_paste.png',
    order = 110,
    callback = function(ply, targets, args)
        local event = dEvents.getEventTable(ply)
        for _, v in pairs(targets) do
            local m = event.members[v:SteamID()]
            if not IsValid(v) or not m then continue end
            
            m.event_state = wlib.state.GetState(v, nil, {'pos'})
            dEvents.notify(v, color_white, 'Настройки ивента сохранены')
        end
        dEvents.notify(ply, color_white, 'Настройки ивента сохранены. Теперь игроки будут возрождаться с новыми настройками')
    end,
})

hook.Add('dEvents.playerTeleported', 'loadstate', function(ply, event)
    local m = event.members[ply:SteamID()]
    if not m.event_state then return end

    wlib.state.LoadState(ply, m.event_state)
end)
--addons/module_eventpanel/lua/devents/interface/cl_frame.lua:
local frame = {}

local function stripRefresh()
    if not IsValid(frame.strip) then return end

    frame.strip:Clear()
    frame.strip:SetValue(dEvents.getPhrase('vgui_preEvent_strip'))

    for _, v in pairs (dEvents.config.weaponPresets or {}) do
        frame.strip:AddChoice(v.name, v.weapons)
    end
    for _, v in pairs (dEvents.stripPresets or {}) do
        frame.strip:AddChoice(v.name, v.weapons)
    end
    frame.strip:AddChoice('Создать пресет', 'add', false, 'icon16/add.png')
    frame.strip:AddChoice('Удалить пресет', 'remove', false, 'icon16/cancel.png')
end

function dEvents.startMenu()
    local canStart, reason = dEvents.canStartEvent(LocalPlayer())
    if canStart == false then return notification.AddLegacy(reason or '', 1, 4) end

    if frame.main and IsValid(frame.main) then frame.main:Close() end
    frame.main = vgui.Create('DFrame')
    frame.main:SetSize(ScrW()*dEvents.config.startMenuSize.w, ScrH()*dEvents.config.startMenuSize.h)
    frame.main:SetPos(0,ScrH()/2 - frame.main:GetTall()/2)
    frame.main:SetIcon('icon16/bell.png')
    frame.main:SetTitle(dEvents.getPhrase('vgui_preEvent'))
    frame.main.Paint = function (s,w,h)
        draw.RoundedBox(0,0,0,w,h,dEvents.config.mainColor)
    end
    frame.main:MakePopup()
    frame.main:SetKeyboardInputEnabled(false)
    frame.main:SetMouseInputEnabled(false)
    local old = frame.main.Think or wlib.func.blank
    function frame.main:Think()
        local x, y = input.GetCursorPos()
        local px, py = self:LocalToScreen(0,0)
        local w, h = self:GetSize()

        if x >= px and x <= px+w and y >= py and y <= py+h then
            self:SetMouseInputEnabled(true)
        else
            self:SetMouseInputEnabled(false)
        end
        old(self)
    end

    frame.start = vgui.Create('DButton', frame.main)
    frame.start:Dock(BOTTOM)
    frame.start:DockMargin(0,5,0,0)
    frame.start:SetText(dEvents.getPhrase('vgui_preEvent_start'))
    frame.start:SetIcon('icon16/accept.png')

    frame.tposes = {}

    frame.positions = vgui.Create('DButton', frame.main)
    frame.positions:Dock(BOTTOM)
    frame.positions:SetText(dEvents.getPhrase('vgui_preEvent_positions'))
    frame.positions:SetIcon('icon16/arrow_in.png')
    frame.positions.DoClick = function ()
        if #frame.tposes >= dEvents.config.maxPositions then return notification.AddLegacy(dEvents.getPhrase('error_maxPositions'), 1, 4) end

        table.insert(frame.tposes, LocalPlayer():GetPos())
        notification.AddLegacy(dEvents.getPhrase('hint_positionAdded', #frame.tposes), 0, 4)
    end

    frame.scroll = vgui.Create('DScrollPanel', frame.main)
    frame.scroll:Dock(FILL)

    frame.guide = vgui.Create('DLabel', frame.scroll)
    frame.guide:Dock(TOP)
    frame.guide:DockMargin(5,0,5,5)
    frame.guide:SetWrap(true)
    frame.guide:SetAutoStretchVertical(true)
    frame.guide:SetText(dEvents.getPhrase('vgui_preEvent_posGuide'))

    local name = vgui.Create('DLabel', frame.scroll)
    name:Dock(TOP)
    name:DockMargin(5,0,5,5)
    name:SetAutoStretchVertical(true)
    name:SetText('Название ивента')
    
    frame.name = vgui.Create('DTextEntry', frame.scroll)
    frame.name:Dock(TOP)
    frame.name:DockMargin(5,0,5,5)
    frame.name:SetTall(60)
    frame.name:SetMultiline(true)
    local old = frame.name.OnMousePressed or wlib.func.blank
    function frame.name:OnMousePressed(...)
        frame.main:SetKeyboardInputEnabled(true)
        old(self, ...)
    end
    local old = frame.name.OnLoseFocus or wlib.func.blank
    function frame.name:OnLoseFocus(...)
        frame.main:SetKeyboardInputEnabled(false)
        old(self, ...)
    end

    frame.startTime = vgui.Create('DNumSlider', frame.scroll)
    frame.startTime:Dock(TOP)
    frame.startTime:SetText(dEvents.getPhrase('vgui_preEvent_startTime'))
    frame.startTime:SetDecimals(0)
    frame.startTime:SetMinMax(dEvents.config.startTime.min, dEvents.config.startTime.max)
    frame.startTime:SetValue(dEvents.config.startTime.default)
    frame.startTime:DockMargin(5,0,5,5)
    
    frame.maxMembers = vgui.Create('DNumSlider', frame.scroll)
    frame.maxMembers:Dock(TOP)
    frame.maxMembers:SetText(dEvents.getPhrase('vgui_preEvent_maxMembers'))
    frame.maxMembers:SetDecimals(0)
    frame.maxMembers:SetMinMax(dEvents.config.maxMembers.min, dEvents.config.maxMembers.max)
    frame.maxMembers:SetValue(dEvents.config.maxMembers.default)
    frame.maxMembers:DockMargin(5,0,5,5)

    frame.strip = vgui.Create('DComboBox', frame.scroll)
    frame.strip:Dock(TOP)
    frame.strip:DockMargin(5,0,5,5)
    frame.strip:SetSortItems(false)
    stripRefresh()
    function frame.strip:OnSelect(id, val, data)
        if data == 'add' then
            local window = vgui.Create('DFrame')
            window:SetSize(ScrW()*dEvents.config.giveWeaponSize.w, ScrH()*dEvents.config.giveWeaponSize.h)
            window:SetTitle(dEvents.getPhrase('presetCreate'))
            window:MakePopup()
            window:Center()
            window.Paint = function (s,w,h)
                draw.RoundedBox(0,0,0,w,h,dEvents.config.mainColor)
            end

            local presetCreator = vgui.Create('devents_choosebrowser', window)
            presetCreator:Dock(FILL)
            presetCreator:AddColumn('Название')
            presetCreator:AddColumn('ClassName')
            
            local sweps = {}
            for class, name in pairs (dEvents.config.permittedWeapons) do
                table.insert(sweps, {name, class})
            end
            for _, v in pairs (weapons.GetList() or {}) do
                if dEvents.config.permittedCategories[v.Category] then
                    table.insert(sweps, {v.PrintName, v.ClassName})
                end
            end
            presetCreator:SetData(sweps)

            function presetCreator:Callback()
                Derma_StringRequest('Создание пресета', 'Введи название для пресета', '', function (name)
                    local len = utf8.len or utf8.length or string.len
                    if len(name) < 3 or len(name) > 20 then return notification.AddLegacy(dEvents.getPhrase('error_presetNameSize', 3, 20), 0, 4) end
                    
                    local selectedSweps = self:GetSelectedData()
                    local newPreset = {
                        name = tostring(name),
                        weapons = {},
                    }
    
                    for _, v in pairs (selectedSweps) do
                        table.insert(newPreset.weapons, v[2])
                    end

                    table.insert(dEvents.stripPresets, newPreset)
                    dEvents.writeStripPresets()

                    window:Close()
                    stripRefresh()
                end)
            end
        elseif data == 'remove' then
            local window = vgui.Create('DFrame')
            window:SetSize(ScrW()*0.2, ScrH()*0.15)
            window:SetTitle(dEvents.getPhrase('presetRemove'))
            window:MakePopup()
            window:Center()
            window.Paint = function (s,w,h)
                draw.RoundedBox(0,0,0,w,h,dEvents.config.mainColor)
            end

            local label = vgui.Create('DLabel', window)
            label:Dock(TOP)
            label:DockMargin(5,5,5,5)
            label:SetText(dEvents.getPhrase('vgui_presetRemove'))
            label:SetWrap(true)
            label:SetAutoStretchVertical(true)

            local combo = vgui.Create('DComboBox', window)
            combo:Dock(TOP)
            combo:DockMargin(5,0,5,0)
            for k, v in pairs (dEvents.stripPresets or {}) do
                combo:AddChoice(v.name, k)
            end
            
            local confirm = vgui.Create('DButton', window)
            confirm:Dock(BOTTOM)
            confirm:DockMargin(0,5,5,5)
            confirm:SetText('Удалить')
            confirm:SetIcon('icon16/cancel.png')
            function confirm:DoClick()
                table.remove(dEvents.stripPresets, combo:GetOptionData(combo:GetSelectedID()))
                dEvents.writeStripPresets()
                window:Close()
                stripRefresh()
            end
        end
    end

    frame.respawn = vgui.Create('DCheckBoxLabel', frame.scroll)
    frame.respawn:Dock(TOP)
    frame.respawn:SetText(dEvents.getPhrase('vgui_preEvent_respawn'))
    frame.respawn:DockMargin(5,5,5,5)

    frame.playerWeapons = vgui.Create('DCheckBoxLabel', frame.scroll)
    frame.playerWeapons:Dock(TOP)
    frame.playerWeapons:SetText('Запретить брать свое оружие')
    frame.playerWeapons:DockMargin(5,5,5,5)

    frame.restrictSpawn = vgui.Create('DCheckBoxLabel', frame.scroll)
    frame.restrictSpawn:Dock(TOP)
    frame.restrictSpawn:SetText('Запретить строительство')
    frame.restrictSpawn:DockMargin(5,5,5,5)

    frame.restrictDonate = vgui.Create('DCheckBoxLabel', frame.scroll)
    frame.restrictDonate:Dock(TOP)
    frame.restrictDonate:SetText('Запретить использовать донат-привилегии')
    frame.restrictDonate:DockMargin(5,5,5,5)

    function frame.start:DoClick()
        if frame.name:GetValue():len() < 3 then return notification.AddLegacy('error_shortName', 1, 4) end
        local chosenStrip = frame.strip:GetSelectedID()
        if not chosenStrip then return notification.AddLegacy(dEvents.getPhrase('error_stripNotChosen'), 1, 4) end
        if #frame.tposes == 0 then return notification.AddLegacy(dEvents.getPhrase('error_noPositions'), 1, 4) end

        local eventInfo = {
            name = frame.name:GetValue(),
            startTime = frame.startTime:GetValue(),
            maxMembers = frame.maxMembers:GetValue(),
            strip = frame.strip:GetOptionData(chosenStrip),
            positions = frame.tposes,
            respawn = frame.respawn:GetChecked(),
            noWeapons = frame.playerWeapons:GetChecked(),
            restrictSpawn = frame.restrictSpawn:GetChecked(),
            restrictDonate = frame.restrictDonate:GetChecked(),
        }

        net.Start('dEvents.initEvent')
        net.WriteTable(eventInfo)
        net.SendToServer()

        frame.main:Close()
    end
end

concommand.Add('eventpanel', dEvents.startMenu)

function dEvents.adminMenu()
    if not dEvents.config.superAdminGroups[LocalPlayer():GetUserGroup()] then return notification.AddLegacy(dEvents.getPhrase('error_notSAdmin'), 1, 4) end

    local window = vgui.Create('DFrame')
    window:SetSize(ScrW()*dEvents.config.adminMenuSize.w, ScrH()*dEvents.config.adminMenuSize.h)
    window:SetTitle('dEvents Admin')
    window:MakePopup()
    window:Center()
    window.Paint = function (s,w,h)
        draw.RoundedBox(0,0,0,w,h,dEvents.config.mainColor)
    end

    local events = vgui.Create('devents_admin', window)
    events:Dock(FILL)
end

concommand.Add('devents_admin', dEvents.adminMenu)
--addons/module_clans/lua/dorgs/sh_network.lua:
-- net
-- Кто вы такие чтобы осуждать net.WriteTable??????

function net.WriteOrg(org)
    net.WriteTable(org)
end

function net.ReadOrg()
    local org = dOrgs.classes.org:New(net.ReadTable())
    return org
end

function net.WriteOrgMember(member)
    net.WriteTable(member)
end

function net.ReadOrgMember()
    local member = dOrgs.classes.member:New(net.ReadTable())
    return member
end

-- NW
hook.Add('Think', 'dOrgs.nw', function()
    hook.Remove('Think', 'dOrgs.nw')
    nw.Register('dOrgs.OrgMembers')
        :Write(function(self)
            net.WriteUInt(table.Count(self), 8)
            
            for id, member in pairs(self) do
                net.WriteUInt(id, 32)
                net.WriteOrgMember(member)
            end
        end)
        :Read(function()
            local count = net.ReadUInt(8)

            local data = {}

            for i=1, count do
                local id = net.ReadUInt(32)
                data[id] = net.ReadOrgMember()
            end

            return data
        end)
end)
--addons/module_clans/lua/dorgs/vgui/tab_settings.lua:
local PANEL = {}

local function createText(text, font, parent)
    local label = vgui.Create('DLabel', parent)
    label:Dock(TOP)
    label:SetDark(true)
    label:SetAutoStretchVertical(true)
    label:SetFont(font)
    label:DockMargin(0,6,0,6)
    label:SetText(text)

    return label
end

function PANEL:Init()
    self.flags = {}

    self.content = vgui.Create('DScrollPanel', self)
    self.content:Dock(FILL)
    self.content:GetCanvas():DockPadding(8,6,8,6)
    self.content:DockMargin(0,0,10,0)
    self.content.Paint = function(s, w, h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    end

    createText('Название', 'dorgs.28', self.content):DockMargin(0,0,0,6)

    self.name = vgui.Create('DTextEntry', self.content)
    self.name:Dock(TOP)
    self.name:SetTall(25)
    self.name:SetUpdateOnType(true)
    self.name.Paint = function(s, w, h)
        draw.RoundedBox(6,0,0,w,h,f4menu.col.buttonCol)
        s:DrawTextEntryText(color_white, color_black, color_white)
    end
    self.name.OnChange = function(s)
        self:SettingsChanged()
    end

    createText('Описание', 'dorgs.28', self.content)

    self.desc = vgui.Create('DTextEntry', self.content)
    self.desc:Dock(TOP)
    self.desc:SetTall(100)
    self.desc:SetUpdateOnType(true)
    self.desc:SetMultiline(true)
    self.desc.Paint = function(s, w, h)
        draw.RoundedBox(6,0,0,w,h,f4menu.col.buttonCol)
        s:DrawTextEntryText(color_white, color_black, color_white)
    end
    self.desc.OnChange = function(s)
        self:SettingsChanged()
    end

    self.avatar = vgui.Create('DPanel', self.content)
    self.avatar:Dock(TOP)
    self.avatar:SetTall(150)
    self.avatar:DockMargin(0,6,0,6)
    self.avatar:SetPaintBackground(false)

    createText('Аватар', 'dorgs.28', self.avatar):DockMargin(0,0,0,0)

    self.avatar.image = vgui.Create('DImageButton', self.avatar)
    self.avatar.image:Dock(LEFT)
    self.avatar.image:DockMargin(0,6,0,0)
    self.avatar.image.DoClick = function(s)
        Derma_StringRequest('Изменение аватара', 'Введи ссылку на новый аватар (разрешен только IMGUR)', self.avatarURL, function(text)
            local res, err = dOrgs.classes.org:ValidateAvatar(text)
            if not res then return notification.AddLegacy(err, 1, 5) end

            self.avatarURL = text
            http.DownloadMaterial(text, nil, function(mat)
                s:SetMaterial(mat)
            end)
            self:SettingsChanged()
        end)
    end

    createText('Webhook для логов', 'dorgs.28', self.content)

    self.webhook = vgui.Create('DTextEntry', self.content)
    self.webhook:Dock(TOP)
    self.webhook:SetTall(25)
    self.webhook:SetUpdateOnType(true)
    self.webhook.Paint = function(s, w, h)
        draw.RoundedBox(6,0,0,w,h,f4menu.col.buttonCol)
        if not s:IsEditing() and s:GetValue() == '' then
            draw.SimpleText('********', 'dorgs.18', 6, h/2, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER)
        end
        s:DrawTextEntryText(color_white, color_black, color_white)
    end
    self.webhook.OnChange = function(s)
        self:SettingsChanged()
    end

    self.save = vgui.Create('DImageButton', self)
    self.save:SetSize(50, 50)
    self.save:SetMaterial(Material('icon72/white_check_mark.png'))
    self.save:SetVisible(false)
    self.save.DoClick = function()
        self:SaveSettings()
    end
end

function PANEL:PerformLayout(w, h)
    self.avatar.image:SetWide(self.avatar.image:GetTall())
end

function PANEL:SetOrg(org)
    if isnumber(org) then org = dOrgs.getOrg(org) end
    self.org = org

    self.name:SetValue(org:GetName())
    self.desc:SetValue(org:GetDescription())
    self.avatarURL = org:GetAvatar()
    self.webhook:SetValue('')

    if org.AvatarMaterial then
        self.avatar.image:SetMaterial(org.AvatarMaterial)
    end

    self:SettingsChanged()
end

function PANEL:SettingsChanged()
    if self:CompareSettings() then
        self.save:SetVisible(false)
    else
        self.save:SetPos(self:GetWide()/2 - self.save:GetWide()/2, self:GetTall() - self.save:GetTall() - 12)
        self.save:SetVisible(true)
    end
end

function PANEL:CompareSettings()
    if not self.org then return true end

    if self.name:GetValue() ~= self.org:GetName() then return false end
    if self.desc:GetValue() ~= self.org:GetDescription() then return false end
    if self.avatarURL ~= self.org:GetAvatar() then return false end

    if self.webhook:GetValue() ~= '' then return false end

    return true
end

function PANEL:SaveSettings()
    RunConsoleCommand('dorgs', 'updateinfo', self.org:GetID(), self.name:GetValue(), self.desc:GetValue(), self.avatarURL, 0)
    if self.webhook:GetValue() ~= '' then
        net.Start('dOrgs.setDiscordWebhook')
            net.WriteUInt(self.org:GetID(), 32)
            net.WriteString(self.webhook:GetValue())
        net.SendToServer()
        self.webhook:SetValue('')
    end
end

PANEL.Paint = wlib.func.blank

vgui.Register('dorgs.tab_settings', PANEL, 'DPanel')
--addons/module_clans/lua/dorgs/vgui/vgui_buttondock.lua:
local PANEL = {}

function PANEL:Init()
    self.buttons = {}
    self.dock = RIGHT
    self.margin = 10
    self.buttonsWidth = 60

    self:SetPaintBackground(false)
end

function PANEL:PerformLayout()
    for _, v in pairs(self.buttons) do
        v:Dock(self.dock)
        v:DockMargin(self.dock == LEFT and 0 or self.margin, 0, self.dock == RIGHT and 0 or self.margin, 0)
        v:SetTall(self:GetTall())
    end
end

function PANEL:AddButton(text, callback)
    local btn = vgui.Create('f4.button', self)
    btn:Dock(RIGHT)
    btn:SetWide(self.buttonsWidth)
    btn:DockMargin(self.dock == LEFT and 0 or self.margin, 0, self.dock == RIGHT and 0 or self.margin, 0)
    btn:SetText(text)
    btn:SetFont('dorgs.18')
    if callback then btn.DoClick = callback end

    btn.id = table.insert(self.buttons, btn)
    return btn
end

function PANEL:RemoveButton(id)
    local btn = self.buttons[id]
    if IsValid(btn) then btn:Remove() end

    table.remove(self.buttons, id)
    self:PerformLayout()
end

function PANEL:ButtonsDock(dock)
    self.dock = dock
    self:PerformLayout()
end

function PANEL:ButtonsMargin(margin)
    self.margin = margin
    self:PerformLayout()
end

function PANEL:ButtonsWidth(width)
    self.buttonsWidth = width
    self:PerformLayout()
end

vgui.Register('dorgs_buttons', PANEL, 'DPanel')
--addons/module_clans/lua/dorgs/vgui/vgui_member.lua:
local online, offline = Material('icon72/green_circle.png'), Material('icon72/white_circle.png')

local PANEL = {}

function PANEL:Init()
    self:SetText('')
    self:DockPadding(2,2,2,2)

    self.online = vgui.Create('DImageButton', self)
    self.online:Dock(LEFT)
    self.online:SetMaterial(offline)

    self.name = vgui.Create('DLabel', self)
    --self.name:Dock(LEFT)
    self.name:DockMargin(0,0,0,0)
    self.name:SetFont('dorgs.24')
    self.name:SetAutoStretchVertical(true)
    self.name:SetDark(true)

    self.rank = vgui.Create('DLabel', self)
    self.rank:SetFont('dorgs.24')
    --self.rank:Dock(RIGHT)
    self.rank:SetAutoStretchVertical(true)
    self.rank:SetDark(true)
end

function PANEL:SetOrgMember(member)
    self.member = member

    self.online:SetMaterial(IsValid(member:GetPlayer()) and online or offline)

    self.name:SetText(member:GetName() or 'Неизвестно')
    self.name:SizeToContents()
    self.rank:SetText(member:GetOrg():GetRank(member:GetRankLevel()):GetName() or 'Неизвестно')
    self.rank:SizeToContents()
end

function PANEL:PerformLayout()
    self.online:SetWide(self:GetTall() - 16)
    self.online:DockMargin(4,6,0,6)
    
    self.name:SetPos(self:GetTall(), self:GetTall()/2-12)
    
    surface.SetFont('dorgs.24')
    local rw, rh = surface.GetTextSize(self.rank:GetText())
    self.rank:SetPos(self:GetWide()/2 - rw/2, self:GetTall()/2-12)
end

function PANEL:DoClick()
    if not self.member then return end

    dOrgs.openMemberContext(self.member)
end
PANEL.DoRightClick = PANEL.DoClick

vgui.Register('dorgs_member', PANEL, 'DButton')
--addons/module_duels/lua/autorun/duelsystemload.lua:
duelSystem = duelSystem or {}

local function sh(path)
    if SERVER then
        AddCSLuaFile(path)
    end

    include(path)
end

local function cl(path)
    if SERVER then
        AddCSLuaFile(path)
    else
        include(path)
    end
end

local function sv(path)
    if SERVER then
        include(path)
    end
end

-- nw
sh('duelsystem/nwvars.lua')
--SH
sh('duelsystem/config.lua')
--SV
sv('duelsystem/sv/sv_funcs.lua')
sv('duelsystem/sv/sv_hooks.lua')
sv('duelsystem/sv/sv_net.lua')
--CL
cl('duelsystem/cl/cl_main.lua')
--addons/module_luadev/lua/autorun/easylua.lua:
easylua = {} local s = easylua

local function compare(a, b)

	if a == b then return true end
	if a:find(b, nil, true) then return true end
	if a:lower() == b:lower() then return true end
	if a:lower():find(b:lower(), nil, true) then return true end

	return false
end

local function comparenick(a, b)
	local MatchTransliteration = GLib and GLib.UTF8 and GLib.UTF8.MatchTransliteration
	if not MatchTransliteration then return compare (a, b) end
	
	if a == b then return true end
	if a:lower() == b:lower() then return true end
	if MatchTransliteration(a, b) then return true end

	return false
end

local function compareentity(ent, str)
	if ent.GetName and compare(ent:GetName(), str) then
		return true
	end

	if ent:GetModel() and compare(ent:GetModel(), str) then
		return true
	end

	return false
end

local TagPrintOnServer = "elpos"
if CLIENT then
	function easylua.PrintOnServer(...)
		local args = {...}
		local new = {}

		for key, value in pairs(args) do
			table.insert(new, luadata and luadata.ToString(value) or tostring(value))
		end
		net.Start(TagPrintOnServer)
			local str = table.concat(new," ")
			local max = 256
			net.WriteString(str:sub(1,max))
			net.WriteBool(#str>max)
		net.SendToServer()
	end
else
	util.AddNetworkString(TagPrintOnServer)
end

function easylua.Print(...)
	if CLIENT then
		easylua.PrintOnServer(...)
	end
	if SERVER then
		local args = {...}
		local str = ""

		Msg(string.format("[ELua %s] ", IsValid(me) and me:Nick() or "Sv"))

		for key, value in pairs(args) do
			str = str .. type(value) == "string" and value or luadata.ToString(value) or tostring(value)

			if key ~= #args then
				str = str .. ","
			end
		end

		print(str)
	end
end

if SERVER then
	--TODO: Antispam
	function easylua.CMDPrint(ply, cmd, args)
		args = table.concat(args, ", ")

		Msg(string.format("[ELua %s] ", IsValid(ply) and ply:Nick() or "Sv"))
		print(args)
	end
	concommand.Add("easylua_print", easylua.CMDPrint)
	
	net.Receive(TagPrintOnServer,function(len,ply)
	    if not luadev.CanLuaDev(ply) then return end
	    
		local str = net.ReadString()
		str=str:sub(1,512)
		local more = net.ReadBool()
		Msg(string.format("[ELua %s] ", IsValid(ply) and ply:Nick() or "Sv"))
		local outstr = ('%s%s'):format(str,more and "..." or ""):gsub("[\r\n]"," ")
		print(outstr)
	end)
end

function easylua.FindEntity(str)
	if not str then return NULL end

	str = tostring(str)

	if str == "#this" and IsEntity(this) and this:IsValid() then
		return this
	end

	if str == "#me" and IsEntity(me) and me:IsPlayer() then
		return me
	end

	if str == "#all" then
		return all
	end

	if str == "#us" then
		return us
	end
	
	if str == "#randply" then
		return table.Random(player.GetAll())
	end

	if str:sub(1,1) == "#" then
		local str = str:sub(2)

		if #str > 0 then
			str = str:lower()
			local found

			for teamid, data in pairs(team.GetAllTeams()) do
				if data.Name:lower() == str then
					found = teamid
					break
				end
			end
			if found then
				return CreateAllFunction(function(v) return v:IsPlayer() and v:Team() == found end)
			end


			for key, ent in ents.Iterator() do
				if ent:GetClass():lower() == str then
					found = str
					break
				end
			end
			if found then
				return CreateAllFunction(function(v) return v:GetClass():lower() == found end)
			end
		end
	end

	-- unique id
	local ply = player.GetByUniqueID(str)
	if ply and ply:IsPlayer() then
		return ply
	end

	-- steam id
	if str:find("STEAM") then
		for key, _ply in player.Iterator() do
			if _ply:SteamID() == str then
				return _ply
			end
		end
	end

	if str:sub(1,1) == "_" and tonumber(str:sub(2)) then
		str = str:sub(2)
	end

	if tonumber(str) then
		ply = Entity(tonumber(str))
		if ply:IsValid() then
			return ply
		end
	end

	-- community id
	if #str == 17 then

	end

	-- ip
	if SERVER then
		if str:find("%d+%.%d+%.%d+%.%d+") then
			for key, _ply in player.Iterator() do
				if _ply:IPAddress():find(str) then
					return _ply
				end
			end
		end
	end
	-- search in sensible order
	
	-- search exact
	for _,ply in player.Iterator() do
		if ply:Nick()==str then
			return ply
		end
	end
	
	-- Search bots so we target those first
	for key, ply in pairs(player.GetBots()) do
		if comparenick(ply:Nick(), str) then
			return ply
		end
	end
	
	-- search from beginning of nick
	for _,ply in pairs(player.GetHumans()) do
		if ply:Nick():lower():find(str,1,true)==1 then
			return ply
		end
	end
	
	-- Search normally and search with colorcode stripped
	for key, ply in player.Iterator() do
		if comparenick(ply:Nick(), str) then
			return ply
		end
		if comparenick(ply:Nick():gsub("%^%d+", ""), str) then
			return ply
		end
	end

	for key, ent in ents.Iterator() do
		if compareentity(ent, str) then
			return ent
		end
	end

	do -- class

		local _str, idx = str:match("(.-)(%d+)$")
		if idx then
			idx = tonumber(idx)
			str = _str
		else
			str = str
			idx = (me and me.easylua_iterator) or 0
		end

		local found = {}

		for key, ent in ents.Iterator() do
			if compare(ent:GetClass(), str) then
				table.insert(found, ent)
			end
		end

		return found[math.Clamp(idx%#found, 1, #found)] or NULL
	end
end

function easylua.CreateEntity(class, callback)
	local mdl = "error.mdl"

	if IsEntity(class) and class:IsValid() then
		this = class
	elseif class:find(".mdl", nil, true) then
		mdl = class
		class = "prop_physics"

		this = ents.Create(class)
		this:SetModel(mdl)
	else
		this = ents.Create(class)
	end

	if callback and type(callback) == 'function' then
		callback(this);
	end

	this:Spawn()
	this:SetPos(there + Vector(0,0,this:BoundingRadius() * 2))
	this:DropToFloor()
	this:PhysWake()

	undo.Create(class)
		undo.SetPlayer(me)
		undo.AddEntity(this)
	undo.Finish()
	
	me:AddCleanup("props", this)
	
	return this
end

function easylua.CopyToClipboard(var, ply)
	ply = ply or me
	if luadata then
		local str = luadata.ToString(var)

		if not str and IsEntity(var) and var:IsValid() then
			if var:IsPlayer() then
				str = string.format("player.GetByUniqueID(--[[%s]] %q)", var:GetName(), var:UniqueID())
			else
				str = string.format("Entity(%i)", var:EntIndex())
			end

		end

		if CLIENT then
			SetClipboardText(str)
		end

		if SERVER then
			local str = string.format("SetClipboardText(%q)", str)
			if #str > 255 then
				if luadev and luadev.RunOnClient then
					luadev.RunOnClient(str, ply)
				else
					error("Text too long to send and luadev not found",1)
				end
			else
				ply:SendLua(str)
			end
		end
	end
end


local started = false
function easylua.Start(ply)
	if started then
		Msg"[ELua] "print("Session not ended for ",_G.me or (s.vars and s.vars.me),", restarting session for",ply)
		easylua.End()
	end
	started = true

	ply = ply or CLIENT and LocalPlayer() or nil

	if not ply or not IsValid(ply) then return end

	local vars = {}
		local trace = util.QuickTrace(ply:EyePos(), ply:GetAimVector() * 10000, {ply, ply:GetVehicle()})

		if trace.Entity:IsWorld() then
			trace.Entity = NULL
		end

		vars.me = ply
		vars.this = trace.Entity
		vars.wep = ply:GetActiveWeapon()
		vars.veh = ply:GetVehicle()

		vars.we = {}

		for k, v in pairs(ents.FindInSphere(ply:GetPos(), 512)) do
			if v:IsPlayer() then
				table.insert(vars.we, v)
			end
		end

		vars.there = trace.HitPos
		vars.here = trace.StartPos
		vars.dir = ply:GetAimVector()

		vars.trace = trace
		vars.length = trace.StartPos:Distance(trace.HitPos)

		vars.copy = s.CopyToClipboard
		vars.create = s.CreateEntity
		vars.prints = s.PrintOnServer

		if vars.this:IsValid() then
			vars.phys = vars.this:GetPhysicsObject()
			vars.model = vars.this:GetModel()
		end

		vars.E = s.FindEntity
		vars.last = ply.easylua_lastvars
		
		
		s.vars = vars
		local old_G={}
		s.oldvars=old_G
		
	for k,v in pairs(vars) do old_G[k]=_G[k] _G[k] = v end

	-- let this gc. maybe allow few more recursions.
	if vars.last and istable(vars.last) then vars.last.last = nil end
	
	ply.easylua_lastvars = vars
	ply.easylua_iterator = (ply.easylua_iterator or 0) + 1
end

function easylua.End()
	if not started then
		Msg"[ELua] "print"Ending session without starting"
	end
	started = false
	
	if s.vars then
		for key, value in pairs(s.vars) do
			if s.oldvars and s.oldvars[key] then
				_G[key] = s.oldvars[key]
			else
				_G[key] = nil
			end
		end
	end
end

do -- env meta
	local META = {}

	local _G = _G
	local easylua = easylua
	local tonumber = tonumber
	
	local nils={
		["CLIENT"]=true,
		["SERVER"]=true,
	}
	function META:__index(key)
		local var = _G[key]

		if var ~= nil then
			return var
		end

		if not nils [key] then -- uh oh
			var = easylua.FindEntity(key)
			if var:IsValid() then
				return var
			end
		end

		return nil
	end

	function META:__newindex(key, value)
		_G[key] = value
	end

	easylua.EnvMeta = setmetatable({}, META)
end

function easylua.RunLua(ply, code, env_name)
	local data =
	{
		error = false,
		args = {},
	}

	easylua.Start(ply)
		if s.vars then
			local header = ""

			for key, value in next,(s.vars or {}) do
				header = header .. string.format("local %s = %s ", key, key)
			end

			code = header .. "; " .. code
		end

		env_name = env_name or string.format("%s", tostring(
			IsValid(ply) and ply:IsPlayer()
				and	"["..ply:SteamID():gsub("STEAM_","").."]"..ply:Name()
				or ply))

		data.env_name = env_name

		local func = CompileString(code, env_name, false)

		if type(func) == "function" then
			setfenv(func, easylua.EnvMeta)

			local args = {pcall(func)}

			if args[1] == false then
				data.error = args[2]
			end

			table.remove(args, 1)
			data.args = args
		else
			data.error = func
		end
	easylua.End()

	return data
end

-- legacy luadev compatibility

local	STAGE_PREPROCESS=1
local	STAGE_COMPILED=2
local	STAGE_POST=3

local insession = false
hook.Add("LuaDevProcess","easylua",function(stage,script,info,extra,func)
	if stage==STAGE_PREPROCESS then
			
		if insession then
			insession=false
			easylua.End()
		end
		
		if not istable(extra) or not IsValid(extra.ply) or not script or extra.easylua==false then
			return
		end
			
		insession = true
		easylua.Start(extra.ply)
		
		local t={}
		for key, value in pairs(easylua.vars or {}) do
			t[#t+1]=key
		end
		if #t>0 then
			script=' local '..table.concat(t,", ")..' = '..table.concat(t,", ")..' ; '..script
		end
		
		--ErrorNoHalt(script)
		return script
				
	elseif stage==STAGE_COMPILED then
		
		if not istable(extra) or not IsValid(extra.ply) or not isfunction(func) or extra.easylua==false then
			if insession then
				insession=false
				easylua.End()
			end
			return
		end

		if insession then
			local env = getfenv(func)
			if not env or env==_G then
				setfenv(func, easylua.EnvMeta)
			end
		end
			
	elseif stage == STAGE_POST and insession then
		insession=false
		easylua.End()
	end
end)

function easylua.StartWeapon(classname)
	_G.SWEP = {
		Primary = {},
		Secondary = {},
		ViewModelFlip = false,
	}

	SWEP.Base = "weapon_base"

	SWEP.ClassName = classname
end

function easylua.EndWeapon(spawn, reinit)
	if not SWEP then error"missing SWEP" end
	if not SWEP.ClassName then error"missing classname" end
	
	weapons.Register(SWEP, SWEP.ClassName)

	for key, entity in pairs(ents.FindByClass(SWEP.ClassName)) do
		--if entity:GetTable() then table.Merge(entity:GetTable(), SWEP) end
		if reinit then
			entity:Initialize()
		end
	end

	if SERVER and spawn then
		SafeRemoveEntity(me:GetWeapon(SWEP.ClassName))
		local me = me
		local class = SWEP.ClassName
		timer.Simple(0.2, function() if me:IsPlayer() then me:Give(class) end end)
	end

	SWEP = nil
end

function easylua.StartEntity(classname)
	_G.ENT = {}

	ENT.ClassName = classname or "no_ent_name_" .. me:Nick() .. "_" .. me:UniqueID()
end

function easylua.EndEntity(spawn, reinit)
	
	ENT.Model = ENT.Model or Model("models/props_borealis/bluebarrel001.mdl")
	
	if not ENT.Base then -- there can be Base without Type but no Type without base without redefining every function so um
		ENT.Base = "base_anim"
		ENT.Type = ENT.Type or "anim"
	end
	
	scripted_ents.Register(ENT, ENT.ClassName)

	for key, entity in pairs(ents.FindByClass(ENT.ClassName)) do
		--table.Merge(entity:GetTable(), ENT)
		if reinit then
			entity:Initialize()
		end
	end

	if SERVER and spawn then
		create(ENT.ClassName)
	end

	ENT = nil
end

do -- all
	local META = {}

	function META:__index(key)
		return function(_, ...)
			local args = {}

			for _, ent in ents.Iterator() do
				if (not self.func or self.func(ent)) then
					if type(ent[key]) == "function" or ent[key] == "table" and type(ent[key].__call) == "function" and getmetatable(ent[key]) then
						table.insert(args, {ent = ent, args = (ent[key](ent, ...))})
					else
						ErrorNoHalt("attempt to call field '" .. key .. "' on ".. tostring(ent) .." a " .. type(ent[key]) .. " value\n")
					end
				end
			end

			return args
		end
	end

	function META:__newindex(key, value)
		for _, ent in ents.Iterator() do
			if not self.func or self.func(ent) then
				ent[key] = value
			end
		end
	end
	
	function CreateAllFunction(func)
		return setmetatable({func = func}, META)
	end

	all = CreateAllFunction(function(v) return v:IsPlayer() end)
	us = CreateAllFunction(function(v) return table.HasValue(we, v) end)
	props = CreateAllFunction(function(v) return v:GetClass() == "prop_physics" end)
	-- props = CreateAllFunction(function(v) return util.IsValidPhysicsObject(vm) end)
	bots = CreateAllFunction(function(v) return v:IsPlayer() and v:IsBot() end)
	these = CreateAllFunction(function(v) return table.HasValue(constraint.GetAllConstrainedEntities(this), v) end)
end

--addons/module_elitef4menu/lua/f4/tabs/dashboard.lua:
local family = Material('icon72/family.png')
local timeicon = Material('icon72/clock4.png')
local casebrief = Material('icon72/briefcase.png')

local social = {
    {
        name = 'Telegram',
        icon = 'icon72/telegram.png',
        url = 'https://t.me/s/rpwayzer',
        bg = true,
    },
    {
        name = 'Discord',
        icon = 'icon72/discord.png',
        url = 'https://discord.gg/W6K5FgSNck',
        bg = true,
    },
    {
        name = 'Правила',
        icon = 'icon72/bookmark.png',
        url = 'https://forum.wayzer.ru/d/2-pravila' 
    },
    {
        name = 'ВКонтакте',
        icon = 'icon72/vkontakte.png',
        url = 'https://vk.com/rpwayzer',
        bg = true,
    },
    {
        name = 'Контент CSS',
        icon = 'icon72/desktop.png',
        url = 'https://forum.wayzer.ru/d/3-kontent-counter-strike-source' 
    }
}

local function buildPanel(tab, parent)
	local pnl = vgui.Create('DPanel', parent)
	pnl:Dock(FILL)
	pnl.Paint = function(s,w,h) 
	end
	pnl:InvalidateParent(true)
	pnl:DockPadding(30, 30, 30, 30)

	local jobs_bar = vgui.Create('DPanel', pnl)
	jobs_bar:Dock(BOTTOM)
	jobs_bar:SetTall(130)
	jobs_bar:DockMargin(0,10,0,0)
	jobs_bar.Paint = function( self, w, h )
		draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
		draw.SimpleText('График работ', 'f4.main', 24, 20, f4menu.col.text_inactive)
		
		draw.RoundedBox(6, 24, h - 56 - 2, w-48, 24 + 4, f4menu.col.secondcolor)
	end

	jobs_bar:InvalidateParent(true)

	local staff = vgui.Create('DPanel', pnl)
	staff:Dock(LEFT)
	staff:DockMargin(0, 0, 10, 10)
	staff:SetWide(200)
	staff.Paint = function( self, w, h )
		draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
		draw.RoundedBox(6, 1, 1, w-2, h-2, f4menu.col.secondcolor)
		
		draw.SimpleText('Администрация', 'f4.main', 24, 20, f4menu.col.text_inactive)
		
		surface.SetDrawColor(f4menu.col.bg)
		surface.DrawLine(24, 44, 182 - 26, 44)
	end

	local staff_list = vgui.Create('DPanelList', staff)
	staff_list:Dock(FILL)
	staff_list:DockMargin(24, 50, 6, 4)
	staff_list:SetSpacing( 2 )
	staff_list:EnableVerticalScrollbar( true )
	staff_list.VBar.Paint = function( s, w, h )
		draw.RoundedBox(6, 3, 13, 8, h-24, f4menu.col.color_scroll)
	end
	staff_list.VBar.btnUp.Paint = function( s, w, h ) end
	staff_list.VBar.btnDown.Paint = function( s, w, h ) end
	staff_list.VBar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox(6, 5, 0, 4, h+22, f4menu.col.color_scroll)
	end

	local jobs = {}

	local players_text = wlib.string.formatPlural({'игрок', 'игрока', 'игроков'}, table.Count(player.GetAll()))..' онлайн'
	local jobs_text = wlib.string.formatPlural({'работа', 'работы', 'работ'}, table.Count(jobs))..' используются'
	local winningteam = 0

	local stats = vgui.Create('DPanel', pnl)
	stats:Dock(TOP)
	stats:SetTall(pnl:GetWide()/2)
	stats:DockMargin(10, 0, 0, 10)
	stats.Paint = function( self, w, h )
		draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
		draw.RoundedBox(6, 1, 1, w - 2, h - 2, f4menu.col.secondcolor)
		
		draw.SimpleText('Данные', 'f4.main', 24, 20, f4menu.col.text_inactive)
		
		surface.SetDrawColor(f4menu.col.bg)
		surface.DrawLine(24, 125, w - 24, 125)
		surface.DrawLine(24, 190, w - 24, 190)
		surface.DrawLine(24, 255, w - 24, 255)
		--surface.DrawLine(24, 320, w - 24, 320)
		
		surface.DrawLine(24, 44, 100, 44)
		
		surface.SetDrawColor(color_white)
		surface.SetMaterial(family)
		surface.DrawTexturedRect(30, 70, 45, 45)
		
		draw.SimpleText(players_text, 'f4.main', 92, 77, color_white)
		draw.SimpleText(GetConVarNumber('maxplayers')..' Количество слотов', 'f4.main', 92, 94, f4menu.col.text_inactive)
		
		surface.SetDrawColor(color_white)
		surface.SetMaterial(timeicon)
		surface.DrawTexturedRect(30, 135, 45, 45)
		
		local t = LocalPlayer():GetUTimeSessionTime()
		draw.SimpleText(('%02i:%02i:%02i'):format(math.floor(t/3600), math.floor(t/60%60), t%60)..' — Текущая сессия', 'f4.main', 92, 140, color_white)
		draw.SimpleText('Забирай ежедневный кейс в F4 - Бонусы', 'f4.main', 92, 157, f4menu.col.text_inactive)
		
		surface.SetDrawColor(color_white)
		surface.SetMaterial(casebrief)
		surface.DrawTexturedRect(30, 200, 45, 45)
		
		draw.SimpleText(jobs_text, 'f4.main', 92, 203, color_white)
		draw.SimpleText('Наиболее популярная - '..utf8.upper(team.GetName(winningteam))..' ('..team.NumPlayers(winningteam)..' работают)', 'f4.main', 92, 220, f4menu.col.text_inactive)
	end
	
	local links = vgui.Create('DPanel', pnl)
	links:Dock(FILL)
	links:DockMargin(10, 0, 0, 10)
	links.Paint = function( self, w, h )
		draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
		draw.RoundedBox(6, 1, 1, w - 2, h - 2, f4menu.col.secondcolor)
	end

    for k, v in ipairs(social or {}) do
        local click = vgui.Create('DImageButton', links)
        click:SetImage(v.icon)
        click:SetTooltip(v.name)
        click:SetWide(68)
        click:Dock(LEFT)
        click:DockMargin(40,15,30,15)
        click.DoClick = function(s, val)
            gui.OpenURL(v.url)
        end
        click.Paint = function( self, w, h )
            if not v.bg then return end
            draw.RoundedBox( 4, 8, 5, w - 15, h - 15, color_white )
	    end
    end

	pnl.OnSelected = function()
		jobs = {}
		wlib.array.map(team.GetAllTeams(), function(_, k)
			if team.NumPlayers(k) == 0 then return end
			jobs[k] = team.NumPlayers(k)
		end)
	
		local teamTable = {}
		wlib.array.map(team.GetAllTeams(), function(v, k)
			if v.Name == 'Joining/Connecting' or k == GAMEMODE.DefaultTeam then return end
			teamTable[k] = team.NumPlayers(k)
		end)
		winningteam = table.GetWinningKey(teamTable)

		players_text = wlib.string.formatPlural({'игрок', 'игрока', 'игроков'}, table.Count(player.GetAll()))..' онлайн'
		jobs_text = wlib.string.formatPlural({'работа', 'работы', 'работ'}, table.Count(jobs))..' используются'

		staff_list:Clear()
		for _, v in player.Iterator() do
			if v:GetUserGroup() == 'user' or v:GetUserGroup() == 'VIP' then continue end

			local PLY_PANEL = vgui.Create('DPanel')
			PLY_PANEL:SetSize( 132, 40 )
			PLY_PANEL:SetPaintBackground(false)
			
			local PLY_NAME = vgui.Create('DLabel', PLY_PANEL)
			PLY_NAME:SetSize( 128, 10 )
			PLY_NAME:SetPos( 40, 8 )
			PLY_NAME:SetFont('f4.sub')
			PLY_NAME:SetText(utf8.upper(v:Name()))
			PLY_NAME:SetTextColor(color_white)
			
			local PLY_USERGROUP = vgui.Create('DLabel', PLY_PANEL)
			PLY_USERGROUP:SetSize(128, 10)
			PLY_USERGROUP:SetPos(40, 22)
			PLY_USERGROUP:SetFont('f4.sub')
			PLY_USERGROUP:SetText(string.upper(v:GetUserGroup()))
			PLY_USERGROUP:SetTextColor(Color(195,195,195))
			
			local PLY_AVATAR = vgui.Create('AvatarImage', PLY_PANEL)
			PLY_AVATAR:SetSize(32, 32)
			PLY_AVATAR:SetPos(0, 6)
			PLY_AVATAR:SetSteamID(v:SteamID64(), 32)
			
			staff_list:AddItem(PLY_PANEL)
		end
		
		local all = table.Count(player.GetAll())
		local offset = 2

		for _, v in ipairs(jobs_bar:GetChildren()) do
			v:Remove()
		end
		
		for k, v in pairs(jobs) do
			local ratio = (v/all) * (jobs_bar:GetWide()-52)
			for id, team in pairs(team.GetAllTeams()) do
				if id == k then
					local barjob = vgui.Create('DButton', jobs_bar)
					barjob:SetSize( ratio, 24 )
					barjob:SetPos( 24+offset, jobs_bar:GetTall() - 56)
					barjob:SetText('')
					barjob:SetTooltip(team.Name)
					barjob:SetTooltipDelay(0)
					barjob.Paint = function( self, w, h )
						draw.RoundedBox(0, 0, 0, w, h, team.Color)
					end
					barjob.DoClick = function(self)
						OpenJobInfo(id)
					end
					
					offset = offset + ratio
				end
			end
		end
	end

	return pnl
end

f4menu.addTab('dashboard', {
	order = 0,
	title = 'Меню',
	panel = buildPanel,
	icon = Material('icon72/bar_chart.png'),
})
--addons/module_elitef4menu/lua/f4/tabs/duels.lua:
local gradientUp = Material("gui/gradient_up")
local blue = Color(76,76,216)
local red = Color(216, 76, 76)

local function LoadDuels(tab, parent)
    local pnl = vgui.Create('DPanel', parent)
    pnl:Dock(FILL)
    pnl.Paint = function(s,w,h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    end
    pnl:InvalidateParent(true)
    pnl:DockMargin(30, 30, 30, 30)
    
    local model1 = vgui.Create('DModelPanel', pnl)
    model1:Dock(LEFT)
    model1:DockMargin(0, 0, 0, 0)
    model1:SetWide(pnl:GetWide() / 3)
    model1:SetModel(LocalPlayer():GetModel())
    model1:SetDirectionalLight(BOX_RIGHT, DIR_LIGHT_LEFT_COL)
    model1:SetDirectionalLight(BOX_LEFT, DIR_LIFT_RIGHT_COL)
    model1:SetAmbientLight(Vector(-64, -64, -64))
    local pos = ((model1.Entity:LookupBone('ValveBiped.Bip01_Head1') and model1.Entity:GetBonePosition(model1.Entity:LookupBone('ValveBiped.Bip01_Head1'))) and model1.Entity:GetBonePosition(model1.Entity:LookupBone('ValveBiped.Bip01_Head1')) or Vector(0, 0, 0)) + Vector(90, 40, 10)
    model1:SetCamPos(pos)
    model1:SetFOV(20)
    local paint = model1.Paint

    function model1:Paint(w, h)
    
    draw.RoundedBox( 0, 0, 0, w, h, f4menu.col.bg)--f4menu.col.bg)-- v.color )
    surface.SetMaterial( gradientUp )
    surface.SetDrawColor( blue )
    surface.DrawTexturedRect( 0, 0, w, h )
    --draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.secondcolor )
                
    
    --    surface.SetMaterial( gradientUp )
    --    surface.SetDrawColor( blue )
    --    surface.DrawTexturedRect( 10, 10, w - 2 - 20, h - 2 )
    --    draw.RoundedBox(2, 10, 10, w - 20, h, f4menu.col.secondcolor)
    --    draw.RoundedBox(2, 11, 11, w - 2 - 20, h - 2, color_two)
        paint(self, w, h)
    end

    function model1:LayoutEntity(Entity)
        return
    end

    local pan = vgui.Create('Panel', pnl)
    pan:Dock(FILL)
    pan:SetWide(pnl:GetWide() / 3)
    pan:DockPadding(10, 0, 10, 0)

    function pan:Paint(w, h)
        draw.SimpleText('Настройка', 'f4.main', 10,40,color_white, TEXT_ALIGN_LEFT)
    end

    local run = vgui.Create('DButton', pan)
    run:Dock(BOTTOM)
    run:DockMargin(0, 0, 0, 20)
    run:SetText('Настройте дуэль прежде чем начать')
    run:SetFont('f4.sub')
    run:SetTextColor(color_white)
    run:SetIcon('icon16/cancel.png')
    run:SetEnabled(false)
    local ply = vgui.Create('DComboBox', pan)
    ply:Dock(TOP)
    ply:DockMargin(0, 70, 0, 0)
    ply:SetValue(player.GetCount() > 1 and 'Выберите игрока для дуэли' or 'Не игроков для дуэли :(')

    local map = vgui.Create('DComboBox', pan)
    map:Dock(TOP)
    map:DockMargin(0, 10, 0, 0)
    map:AddChoice('Без карты', 'default')
    map:AddChoice('Баррикады', 'testmap')
    map:AddChoice('Коридор', 'koridor')
    map:AddChoice('Луна', 'luna')
    map:AddChoice('Дно', 'dno')
    map:AddChoice('AWP_LEGO', 'lego')
    map:AddChoice('Джунгли', 'jungle', true)

    local weap = vgui.Create('DComboBox', pan)
    weap:Dock(TOP)
    weap:DockMargin(0, 10, 0, 0)
    weap:SetValue('Выберите пресет оружия')

    for _, v in pairs(duelSystem.Config.weaponPresets or {}) do
        weap:AddChoice(_, v)
    end

    local hp = vgui.Create('DNumSlider', pan)
    hp:Dock(TOP)
    hp:SetMinMax(duelSystem.Config.hp.min, duelSystem.Config.hp.max)
    hp:SetValue(duelSystem.Config.hp.default)
    hp:SetText('Кол-во ХП')
    hp.Label:SetTextColor(color_white)
    hp:SetDecimals(0)
    local armor = vgui.Create('DNumSlider', pan)
    armor:Dock(TOP)
    armor:SetMinMax(duelSystem.Config.armor.min, duelSystem.Config.armor.max)
    armor:SetValue(duelSystem.Config.armor.default)
    armor:SetText('Кол-во брони')
    armor.Label:SetTextColor(color_white)
    armor:SetDecimals(0)
    local prizeType = vgui.Create('DComboBox', pan)
    prizeType:Dock(TOP)
    prizeType:SetValue('Выберите тип приза')
    prizeType:AddChoice('Доллары', 'dollars')
    prizeType:AddChoice('Рубли', 'rubles')
    local prize = vgui.Create('DNumSlider', pan)
    prize:Dock(TOP)
    prize:SetValue(0)
    prize:SetMinMax(0, 0)
    prize:SetText('Сумма')
    prize.Label:SetTextColor(color_white)
    prize:SetDecimals(0)

    function prizeType:OnSelect(id, val, data)
        if data == 'dollars' then
            prize:SetMinMax(50000, LocalPlayer():GetNetVar('money'))
            prize:SetValue(50000)
        elseif data == 'rubles' then
            prize:SetMinMax(2, LocalPlayer():PS_GetPoints())
            prize:SetValue(2)
        end
    end

    local function validate()
        local weaponChosen = weap:GetSelected()
        local playerChosen = ply:GetSelectedID()
        local prizeChosen = prizeType:GetSelectedID()

        return (playerChosen and ply:GetOptionData(playerChosen)) and (prizeChosen and prizeType:GetOptionData(prizeChosen)) and (prize:GetValue() > 0) and hp:GetValue() > 0 and armor:GetValue() >= 0
    end

    local nextThink = CurTime() + 3


    function run:Paint(w,h)
        draw.RoundedBox(6,0,0,w,h, Color(100, 52, 57, 255))
    end

    function run:Think()
        if nextThink < CurTime() then
            self:SetEnabled(validate())
            self:SetIcon(validate() and 'icon72/crossed_swords.png' or 'icon72/cry.png')
            run:SetText(validate() and 'Начать' or 'Дуэль не настроена')
            nextThink = CurTime() + 1
        end
    end

    local model2 = vgui.Create('DModelPanel', pnl)
    model2:Dock(RIGHT)
    model2:SetWide(pnl:GetWide() / 3)
    model2:SetDirectionalLight(BOX_RIGHT, DIR_LIGHT_LEFT_COL)
    model2:SetDirectionalLight(BOX_LEFT, DIR_LIFT_RIGHT_COL)
    model2:SetAmbientLight(Vector(-64, -64, -64))
    model2:DockMargin(0, 0, 0, 0)
    paint = model2.Paint

    function model2:Paint(w, h)
        draw.RoundedBox( 0, 0, 0, w, h, f4menu.col.bg)--f4menu.col.bg)-- v.color )
        surface.SetMaterial( gradientUp )
        surface.SetDrawColor( red )
        surface.DrawTexturedRect( 0, 0, w, h )
        
        --surface.SetMaterial( gradientUp )
        --surface.SetDrawColor( red )
        --surface.DrawTexturedRect( 10, 10, w - 2 - 20, h - 2 )
        --draw.RoundedBox(2, 10, 10, w - 20, h, f4menu.col.secondcolor)
        --draw.RoundedBox(2, 11, 11, w - 2 - 20, h - 2, color_white)
        paint(self, w, h)
    end

    function model2:LayoutEntity(Entity)
        return
    end

    function ply:OnSelect(id, val, data)
        model2:SetModel(Entity(data):GetModel())
        local pos = ((model2.Entity:LookupBone('ValveBiped.Bip01_Head1') and model2.Entity:GetBonePosition(model2.Entity:LookupBone('ValveBiped.Bip01_Head1'))) and model2.Entity:GetBonePosition(model2.Entity:LookupBone('ValveBiped.Bip01_Head1')) or Vector(0, 0, 0)) + Vector(90, 40, 10)
        model2:SetCamPos(pos)
        model2:SetFOV(20)
    end

    function run:DoClick()
        local weaponChosen = weap:GetSelected()
        local playerChosen = ply:GetSelectedID()
        local prizeChosen = prizeType:GetSelectedID()
        local mapChosen = map:GetSelectedID()

        if not weaponChosen then return notification.AddLegacy('Выбери пресет оружия', 1, 4) end
        if not playerChosen then return notification.AddLegacy('Выбери человека для дуэли', 1, 4) end
        if not prizeChosen then return notification.AddLegacy('Выберите тип приза', 1, 4) end
        if prize:GetValue() <= 0 then return notification.AddLegacy('Кол-во приза должно быть больше нуля', 1, 4) end

        local data = {
            weapons = weaponChosen,
            player = ply:GetOptionData(playerChosen),
            health = hp:GetValue(),
            armor = armor:GetValue(),
            prizeType = prizeType:GetOptionData(prizeChosen),
            prize = prize:GetValue(),
            map = map:GetOptionData(mapChosen),
        }

        net.Start('duelSystem.RequestDuel')
        net.WriteTable(data)
        net.SendToServer()
    end

    pnl.OnSelected = function()
        ply:Clear()
        for _, v in player.Iterator() do
            if v == LocalPlayer() then continue end
            ply:AddChoice(v:Name(), v:EntIndex())
        end
    end

    return pnl
end

f4menu.addTab('duels', {
    order = 700,
    title = 'Дуэли',
    panel = LoadDuels,
    icon = Material('icon72/skull.png'),
})
--addons/module_elitef4menu/lua/f4/tabs/elite_commands.lua:
function LoadCommandPanel()

	BG_HEADTEXT:SetText( "Информация" )
	BG_HEADTEXT:SizeToContents()
	
	COMMAND = vgui.Create( "Panel", BG_MAIN )
	COMMAND:SetSize( BG_MAIN:GetWide(), BG_MAIN:GetTall() )
	
	local COMMAND_WINDOW = vgui.Create( "Panel", COMMAND )
	COMMAND_WINDOW:SetSize( BG_MAIN:GetWide() - 56, BG_MAIN:GetTall() - 50 )
	COMMAND_WINDOW:SetPos( -200, 25 )
	COMMAND_WINDOW.Paint = function( self, w, h )
		draw.RoundedBox( 2, 0, 0, w, h, Color( 239, 239, 239 ) )
		draw.RoundedBox( 2, 1, 1, w - 2, h - 2, Color( 255, 255, 255 ) )
		
		draw.SimpleText( "Основное", "f4.main", 24, 20, Color( 190, 190, 190 ) )
		
		surface.SetDrawColor( Color( 242, 242, 242 ) )
		surface.DrawLine( 24, 44, w - 26, 44 )
	end
	
	local COMMAND_LIST = vgui.Create( "DPanelList", COMMAND_WINDOW )
	COMMAND_LIST:SetPos( 24, 54 )
	COMMAND_LIST:SetSize( COMMAND_WINDOW:GetWide() - 30, COMMAND_WINDOW:GetTall() - 54 )
	COMMAND_LIST:EnableVerticalScrollbar( true )
	COMMAND_LIST:SetSpacing( 2 )
	COMMAND_LIST:DockPadding( 0, 5, 10, 0 )
	COMMAND_LIST.VBar.Paint = function( s, w, h )
		draw.RoundedBox( 4, 3, 13, 8, h-24, Color(0,0,0,70))
	end
	COMMAND_LIST.VBar.btnUp.Paint = function( s, w, h ) end
	COMMAND_LIST.VBar.btnDown.Paint = function( s, w, h ) end
	COMMAND_LIST.VBar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox( 4, 5, 0, 4, h+22, Color(0,0,0,70))
	end
	
	local Categories = {}
	
	table.insert( Categories, { Name = "Полезные ссылки", Table = MONEYCMD_BUTTONS } )
	
	for k, v in pairs( Categories ) do
	
		local ammoFrame = vgui.Create( "DCollapsibleCategory" ) -- surface.DrawLine( 24, self:GetTall() - 44, self:GetWide() - 24, self:GetTall() - 44 )
		ammoFrame:SetSize( COMMAND_LIST:GetWide(), 100 )
		ammoFrame:SetExpanded( true )
		ammoFrame:SetLabel( "" )
		ammoFrame.Paint = function()
		
		end
		ammoFrame.PaintOver = function( self, w, h )
		
			/*surface.SetDrawColor( Color( 224, 224, 224, 255 ) )
			surface.DrawLine( 0, 20, w, 20 )

			draw.RoundedBox( 4, 0, 0, w, 20, Color( 51, 54, 58, 255 ) )

			draw.RoundedBox( 4, 1, 1, w - 2, 20 - 2, Color( 62, 67, 77 ) )

			surface.SetDrawColor( Color( 84, 89, 100, 255 ) )
			surface.DrawLine( 1, 1, w - 1, 1 )
			surface.DrawLine( 1, 1, 1, 20 )
			surface.DrawLine( 1, 18, w - 1, 18 )
			surface.DrawLine( w - 2, 1, w - 2, 20 )*/

			draw.SimpleText( v.Name, "f4.sub", 10, 2, Color( 190, 190, 190, 255 ), TEXT_ALIGN_LEFT )
		end
		
		local list = vgui.Create( "DPanelList", ammoFrame )
		list:SetWide( COMMAND_LIST:GetWide() )
		list:SetAutoSize( true )
		list:SetSpacing( 2 )
		list:SetPos( 0, 20 )
		list:EnableVerticalScrollbar( false )
		list.Paint = function( s, w, h )
			draw.RoundedBox( 4, 3, 13, 8, h-24, Color(0,0,0,70))

			draw.RoundedBox( 0, 0, 0, w, h, Color(232,234,236,255))
		end
		
		for k, v in pairs( v.Table ) do
			local ammoButton = vgui.Create( "DButton" )
			ammoButton:SetSize( COMMAND_WINDOW:GetWide() - 50, 35 )
			ammoButton:SetPos( 0, 0 )
			ammoButton:SetText( v.NAME )
			ammoButton:SetFont( "f4.main" )
			ammoButton:SetTextColor( Color( 255, 255, 255 ) )
			ammoButton.Paint = function( self, w, h )
				--draw.RoundedBox( 4, 0, 0, w, h, Color( 239, 239, 243 ) )
                --draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 232, 76, 82 ) )
				if v.NAME == 'Группа VK' then
				    draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 89,125,163 ) )
				elseif v.NAME == 'Discord' then
				    draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 114, 137, 218 ) )
				elseif v.NAME == 'Правила' then
				    draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 236, 113, 73 ) )
				elseif v.NAME == 'Беседа игроков' then
				    draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 47, 52, 57 ) )
				else
				    draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 233, 84, 90 ) )
				end
				
				if self.hover then
				    draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 206, 68, 73 ) )
				end
			end
			ammoButton.DoClick = function()
				v.FUNC()
			end
			
			list:AddItem( ammoButton )
		end
		
		COMMAND_LIST:AddItem( ammoFrame )
		
	end
	
	COMMAND_WINDOW:MoveTo( 28, 25, 0.2, 0, 0.2 )
end
--addons/module_elitef4menu/lua/f4/tabs/hits.lua:
local gradientUp = Material("gui/gradient_up")
local red = Color(216, 76, 76)

local function LoadHits(tab, parent)
    local pnl = vgui.Create('DPanel', parent)
    pnl:Dock(FILL)
    pnl.Paint = function(s,w,h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
    end
    pnl:InvalidateParent(true)
    pnl:DockMargin(30, 30, 30, 30)

    local pan = vgui.Create('Panel', pnl)
    pan:Dock(LEFT)
    pan:SetWide(pnl:GetWide() / 3)
    pan:DockPadding(10, 0, 10, 0)

    function pan:Paint(w, h)
        draw.SimpleText('Выберите цель', 'f4.main', 10,40,color_white, TEXT_ALIGN_LEFT)
        draw.SimpleText('Цена: $50.000', 'f4.main', 10,130,f4menu.col.text_inline, TEXT_ALIGN_LEFT)
    end


    local run = vgui.Create('DButton', pan)
    run:Dock(BOTTOM)
    run:DockMargin(0, 0, 0, 20)
    run:SetText('Заказать')
    run:SetFont('f4.sub')
    run:SetTextColor(color_white)
    run:SetIcon('icon72/boom.png')
    local ply = vgui.Create('DComboBox', pan)
    ply:Dock(TOP)
    ply:DockMargin(0, 70, 0, 0)
    ply:SetValue('Выберите игрока')

    local hittype = vgui.Create('DComboBox', pan)
    hittype:Dock(TOP)
    hittype:DockMargin(0, 10, 0, 0)
    hittype:AddChoice('Убийство', 'kill')
    hittype:AddChoice('Похищение', 'abduction')

    function run:Paint(w,h)
        draw.RoundedBox(6,0,0,w,h, f4menu.col.buttonCol)
    end

    local model2 = vgui.Create('DModelPanel', pnl)
    model2:Dock(RIGHT)
    model2:SetWide(pnl:GetWide() / 3)
    model2:SetDirectionalLight(BOX_RIGHT, DIR_LIGHT_LEFT_COL)
    model2:SetDirectionalLight(BOX_LEFT, DIR_LIFT_RIGHT_COL)
    model2:SetAmbientLight(Vector(-64, -64, -64))
    model2:DockMargin(0, 0, 0, 0)
    paint = model2.Paint

    function model2:Paint(w, h)
        draw.RoundedBox( 0, 0, 0, w, h, f4menu.col.bg)--f4menu.col.bg)-- v.color )
        surface.SetMaterial( gradientUp )
        surface.SetDrawColor( red )
        surface.DrawTexturedRect( 0, 0, w, h )
        
        --surface.SetMaterial( gradientUp )
        --surface.SetDrawColor( red )
        --surface.DrawTexturedRect( 10, 10, w - 2 - 20, h - 2 )
        --draw.RoundedBox(2, 10, 10, w - 20, h, f4menu.col.secondcolor)
        --draw.RoundedBox(2, 11, 11, w - 2 - 20, h - 2, color_white)
        paint(self, w, h)
    end

    function model2:LayoutEntity(Entity)
        return
    end

    function ply:OnSelect(id, val, data)
        model2:SetModel(data:GetModel())
        local pos = ((model2.Entity:LookupBone('ValveBiped.Bip01_Head1') and model2.Entity:GetBonePosition(model2.Entity:LookupBone('ValveBiped.Bip01_Head1'))) and model2.Entity:GetBonePosition(model2.Entity:LookupBone('ValveBiped.Bip01_Head1')) or Vector(0, 0, 0)) + Vector(90, 40, 10)
        model2:SetCamPos(pos)
        model2:SetFOV(20)
    end

    function run:DoClick()
        local hitData = hittype:GetSelectedID() and hittype:GetOptionData(hittype:GetSelectedID())
        local plyData = ply:GetSelectedID() and ply:GetOptionData(ply:GetSelectedID())
        if hitData and plyData then
            net.Start('hitSystem.PlaceHit')
            net.WriteString(hitData)
            net.WriteEntity(plyData)
            net.SendToServer()
        end
    end

    pnl.OnSelected = function()
        ply:Clear()
        for _, v in player.Iterator() do
            if v == LocalPlayer() then continue end
            ply:AddChoice(v:Name(), v)
        end
    end

    return pnl
end

local gradient = Material("gui/center_gradient")

local function LoadOrders(tab, parent)
    local pnl = vgui.Create('DPanel', parent)
    pnl:Dock(FILL)
    pnl.Paint = function(s,w,h)
        draw.RoundedBox(6, 0, 0, w, h, f4menu.col.secondcolor)
        --draw.SimpleText('Список работ', 'f4.main', 24, 20, f4menu.col.text_inactive)
        
    --  surface.SetDrawColor(f4menu.col.secondcolor)
    --  surface.DrawLine(24, 54, w - 26, 54)
    end
    pnl:DockMargin(30, 30, 30, 30)
    pnl:DockPadding(25, 25, 25, 25)

    local lbl = vgui.Create('DLabel', pnl)
    lbl:Dock(TOP)
    lbl:SetAutoStretchVertical(true)
    lbl:SetFont('f4.main')
    lbl:SetTextColor(f4menu.col.text_inactive)
    lbl:SetText('Заказы')

    local scroll = vgui.Create('DScrollPanel', pnl)
    scroll:Dock(FILL)

    scroll.VBar.Paint = function( s, w, h )
        draw.RoundedBox( 4, 3, 13, 8, h-24, f4menu.col.color_scroll)
    end
    scroll.VBar.btnUp.Paint = function( s, w, h ) end
    scroll.VBar.btnDown.Paint = function( s, w, h ) end
    scroll.VBar.btnGrip.Paint = function( s, w, h )
        draw.RoundedBox( 4, 5, 0, 4, h+22, f4menu.col.color_scroll)
    end
    
    local panel_list = vgui.Create('DIconLayout', scroll)
    panel_list:Dock(FILL)
    panel_list:SetSpaceX(4)
    panel_list:SetSpaceY(8)
    panel_list:DockMargin(0, 10, 0, 0)
    panel_list:DockPadding( 0, 5, 10, 0 )

    pnl:InvalidateParent(true)

    scroll:InvalidateParent(true)
    scroll:PerformLayoutInternal()

    panel_list:InvalidateParent(true)
    panel_list:InvalidateLayout(true)
    
    pnl.OnSelected = function()
        panel_list:Clear()
        local orders = hitSystem:GetOrders()

    for k, v in pairs(orders) do
        local plys = {}

        for d, v in pairs(v) do
            _ = Entity(d)
            if not IsValid(_) then continue end
            if not hitSystem.Config.types[k].canAccept(_, LocalPlayer()) then continue end
            if _ == LocalPlayer() then continue end
            local t = _:GetNetVar('disguised') and _:GetNetVar('disguise_team') or _:Team()
            plys[t] = plys[t] or {}
            plys[t][d] = v
        end

        for job, i in pairs(plys) do
            for d, i in pairs(i) do
                local entFrame = vgui.Create( "DPanel", panel_list ) -- surface.DrawLine( 24, self:GetTall() - 44, self:GetWide() - 24, self:GetTall() - 44 )
            --  entFrame.price = GetColorBasedOnPrice(v.price)
                entFrame.Paint = function( self, w, h )
                    draw.RoundedBox( 4, 0, 0, w, h, f4menu.col.bg)-- v.color )
                    surface.SetMaterial( gradient )
                    surface.SetDrawColor( red )
                    surface.DrawTexturedRect( 0, 0, w, h )
                    draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.secondcolor )
                    
                    draw.SimpleText( Entity(d):Name(), "f4.main", 56, 14, color_white )
                    draw.SimpleText( hitSystem.Config.types[k].name..": "..DarkRP.formatMoney(i.price), "f4.main", 56, 35, Color( 100, 100, 100 ) )
                end
                entFrame.OnCursorEntered = function( self )

                end
                entFrame.OnCursorEntered = function( self )

                end
                
                local entModel = vgui.Create( "SpawnIcon", entFrame )
                entModel:SetSize( 45, 45 )
                entModel:SetPos( 5, 5 )
                entModel:SetModel( Entity(d):GetModel())

                entFrame:SetSize((scroll:GetWide() - scroll.VBar:GetWide())/2 - 8, 60)

                local entButton = vgui.Create( "DButton", entFrame )
                entButton:SetSize( entFrame:GetWide(), entFrame:GetTall() )
                entButton:SetText( "" )
                entButton:SetFont( "f4.main" )
                entButton:SetTextColor( Color( 255, 255, 255 ) )
                entButton.Paint = function( self, w, h )
                --  draw.RoundedBox( 4, 1, 1, w , h, f4menu.col.buttonCol )
                end
                entButton.DoClick = function()
                    net.Start('hitSystem.AcceptHit')
                    net.WriteString(k)
                    net.WriteEntity(Entity(d))
                    net.SendToServer()
                end
                
                panel_list:Add( entFrame )
            end
        end
        end
        scroll:PerformLayoutInternal()
    end
    
    return pnl
end


f4menu.addTab('hits', {
    order = 600,
    title = 'Заказы',
    panel = LoadHits,
    icon = Material('icon72/gloves.png'),
    check = function()
        return not LocalPlayer():IsHitMan()
    end,
})

f4menu.addTab('orders', {
    order = 600,
    title = 'Заказы',
    panel = LoadOrders,
    icon = Material('icon72/gloves.png'),
    check = function()
        return LocalPlayer():IsHitMan()
    end,
})
--addons/module_elitef4menu/lua/f4/vgui/button.lua:
local PANEL = {}

function PANEL:Paint(w, h)
	draw.RoundedBox(4, 1, 1, w - 2, h - 2, self:IsHovered() and f4menu.col.buttonCol_hover or f4menu.col.buttonCol)
end

vgui.Register('f4.button', PANEL, 'DButton')
--addons/module_hits/lua/hitsystem/lang.lua:
local lang = {}

function hitSystem.L(key, ...)
    if ... then
        return string.format((lang and lang[key]) and lang[key] or key, ...)
    else
        return (lang and lang[key]) and lang[key] or key
    end
end

local function L(key, replace)
    if not key or not replace then return end
    lang[key] = replace
end

-- Customer
L("cantOrderSelf", "Вы не можете заказать себя")
L("cantAfford", "Данная сумма вам не по карману")
L("unkownType", "Вы пытаетесь указать неизвестный тип заказа")
L("targerIsOrdered", "Данная цель уже заказана")
L("successPlaceOrder", "Вы успешно сделали заказ на %s")
L("notYourHit", "Не вы делали заказ")
L("cantBePlace", "Вы не можете сделать такой заказ")
L("successCompleteHit_Customer", "Ваш заказ на %s был завершен")
L("maxOrdersOnType", "Вы достигли максимума заказов для типа '%s'")
L("notAllowedTypeEntity", "Тип энтити которую вы указали не доступен в данном виде заказов")
-- Killer
L("alreadyDoingOrder", "Вы уже выполняете заказ")
L("targerIsNotOrdered", "Данная цель не заказана")
L("cantBeClaim", "Вы не можете принять данный заказ")
L("successAccept", "Вы успешно приняли заказ")
L("successCompleteHit_Killer", "Вы завершили заказ на %s")
L("orderAlreadyAccepted", "Заказ уже был принят.")
-- Types
L("typeKillName", "Заказ на убийство человека")
L("typeAbductionName", "Заказ на похищение человека")
-- Leave 
L("abortOrderPlyLeave_customer", "Человек на которого вы делали заказ вышел. Деньги были возвращены")
L("abortOrderPlyLeave_killer", "Ваш заказ был отменён так как человек вышел.")
L("abortOrderCustomerLeave_killer", "Ваш заказ был отменён так как заказчик вышел.")
-- hz
L("notFreeKill", "Вас убил убийца, это не нарушение правила FreeKill")
--addons/module_itemstore/lua/autorun/itemstore.lua:
hook.Add( "PostGamemodeLoaded", "ItemStoreInitialize", function()
	itemstore = {}

	if SERVER then
		include( "itemstore/sv_init.lua" )
	else
		include( "itemstore/cl_init.lua" )
	end
end )
--addons/module_hitregtest/lua/leyhitreg/client/sendshots/sendshots.lua:

local IsValid = IsValid
local inputIsMouseDown = input.IsMouseDown
local vector_origin = vector_origin

IN_LEYHITREG1 = bit.lshift(1, 27)

function LeyHitreg:ShouldPrimaryAttack()
    return inputIsMouseDown(MOUSE_LEFT) or inputIsMouseDown(MOUSE_RIGHT)
end

local lastPrim = nil
function LeyHitreg:CanShoot(cmd, wep, primary)
    local canShoot = true

    local nextPrim = wep:GetNextPrimaryFire()

    if (primary) then
        if (nextPrim == lastPrim or wep:Clip1() == 0) then
            canShoot = false
        else
            lastPrim = nextPrim
        end
    end

    return canShoot
end

local bitbor = bit.bor
local trace = {}
local traceres = {}
trace.filter = LocalPlayer()
trace.mask = MASK_SHOT
trace.output = traceres

local lply = nil

timer.Create("LeyHitreg.LocalPlayerGet", 0.1, 0, function()
    if (not lply and IsValid(LocalPlayer())) then
        lply = LocalPlayer()
        trace.filter = lply
        timer.Remove("LeyHitreg.LocalPlayerGet")
    end
end)

LeyHitreg.WeaponSpreads = {}

function LeyHitreg:IsAutoWep(wep)
    if (wep.Primary) then
        return wep.Primary.Automatic
    end

    return true
end

local NeedsPrimReset = false

function LeyHitreg:CreateMove(cmd)
    if (not lply or LeyHitreg.Disabled or LeyHitreg.DisabledOnlyOnClient) then
        return
    end

    local spreadWep = lply.LeyHitreg_NeedsSpreadForce

    if (spreadWep and IsValid(spreadWep)) then
        LeyHitreg:SetFittingValidClip(spreadWep)
    end

    if (cmd:CommandNumber() == 0) then
        return
    end

    local cmdAttack1 = cmd:KeyDown(IN_ATTACK)

    if (not cmdAttack1) then
        NeedsPrimReset = false
        return
    elseif (NeedsPrimReset and not cmdAttack1) then
        NeedsPrimReset = false
    end

    local shouldPrimary = self:ShouldPrimaryAttack()

    if (not shouldPrimary) then
        return
    end

    local wep = lply:GetActiveWeapon()

    if (not IsValid(wep)) then
        return
    end

    if (self:IsIgnoreWep(wep)) then
        return
    end

    if (not self:CanShoot(cmd, wep, shouldPrimary)) then
        return
    end

    local primAuto = self:IsAutoWep(wep)

    if (NeedsPrimReset and shouldPrimary) then
        return
    end

    if (not primAuto and shouldPrimary) then
        NeedsPrimReset = true
    end

    if (shouldPrimary) then
        cmd:SetButtons(bitbor(cmd:GetButtons(), IN_LEYHITREG1))
    end

    trace.start = lply:GetShootPos()
    local viewang = cmd:GetViewAngles()
    local dir = viewang:Forward()

    local weaponSpread = self:GetWeaponSpread(lply, wep)

    if (weaponSpread) then
        local applied, newDir = self:ApplyBulletSpread(lply, dir, weaponSpread)
 
        if (applied) then
            dir = newDir
        end
    else
        -- LocalPlayer():ChatPrint("NO WEAPONSPREAD")
    end

    trace.endpos = trace.start + (dir * (56756 * 8))
    traceres.Entity = nil
    traceres.HitGroup = nil
    traceres.HitBox = nil

    util.TraceLine(trace)

    local target = traceres.Entity 

    if (not IsValid(target) or not (target:IsNPC() or target:IsPlayer())) then
        cmd:SetUpMove(-1)
        if (LeyHitreg.AnnounceClientHits) then
            LocalPlayer():ChatPrint("It's a miss!")
            -- PrintTable(trace)
        end
        return
    end

    local hitgroup = traceres.HitGroup
    local hitbox = traceres.HitBox
    local hitbone = target:GetHitBoxBone(hitbox, 0)

    if (not hitbone or not hitgroup) then
        print("[/LeyHitreg/] Bone not found")
        return
    end

    cmd:SetUpMove(target:EntIndex())
    cmd:SetMouseWheel(hitbone)

    if (LeyHitreg.AnnounceClientHits) then
        LocalPlayer():ChatPrint("It's a hit!")
    end
end

hook.Add("CreateMove", "LeyHitreg:CreateMove", function(...)
    LeyHitreg:CreateMove(...)
end)

function LeyHitreg:EntityFireBullets(plyorwep, bullet)
    if (LeyHitreg.Disabled or LeyHitreg.DisabledOnlyOnClient) then
        return
    end

    if (bullet.Num >= 2) then
        return
    end

    local ply, wep = self:GetPlayerFromPlyOrBullet(plyorwep, bullet)

    if (not ply) then
        return
    end

    if (not wep or self:IsIgnoreWep(wep)) then
        return
    end

    if (not LeyHitreg.ShotDirForceDisabled) then
        bullet.Dir = ply:GetAimVector()
    end

    local forcedShot = LeyHitreg:FetchSpreadFireBullets(ply, wep, bullet)

    if (forcedShot != nil) then
        return forcedShot
    end

    local ret = LeyHitreg:SpreadedEntityFireBullets(ply, wep, bullet)

    if (ret != nil) then
        return ret
    end
end

hook.Add("EntityFireBullets", "LeyHitreg:EntityFireBullets", function(plyorwep, bullet)
    local ret = LeyHitreg:EntityFireBullets(plyorwep, bullet)

    if (ret != nil) then
        return ret
    end
end)

--addons/module_hitregtest/lua/leyhitreg/client/sendshots/fetchspreads.lua:
LeyHitreg.WeaponSpreads = {}

local vector_origin = vector_origin

function LeyHitreg:PlayerSwitchWeapon(ply, oldWep, newWep) 
    if (not IsValid(newWep)) then
        return
    end

    local classname = newWep:GetClass()

    if (not classname or self.WeaponSpreads[classname]) then
        return
    end

    if (self:IsIgnoreWep(newWep)) then
        self.WeaponSpreads[classname] = vector_origin
        return
    end

    ply.LeyHitreg_NeedsSpreadForce = newWep

    timer.Simple(1, function() 
        if (not IsValid(ply) or not IsValid(newWep)) then
            return
        end

        ply.LeyHitreg_NeedsSpreadForce = nil

        if (ply:GetActiveWeapon() != newWep) then
            return
        end

        LeyHitreg.WeaponSpreads[classname] = LeyHitreg.WeaponSpreads[classname] or vector_origin
    end)

    LeyHitreg:SetFittingValidClip(newWep)

    if (newWep.PrimaryAttack) then
        newWep:PrimaryAttack()
    elseif (newWep.Primary and newWep.Primary.Attack) then
        newWep.Primary.Attack()
    end
end

hook.Add("PlayerSwitchWeapon", "LeyHitreg:PlayerSwitchWeapon", function(...)
    -- process switch at next frame so FireBullets uses proper wep
    local t = {...}

    timer.Simple(0, function()
        LeyHitreg:PlayerSwitchWeapon(unpack(t))
    end)
end)

function LeyHitreg:FetchSpreadFireBullets(ply, wep, bullet)
    local spreadForceWep = ply.LeyHitreg_NeedsSpreadForce
    local validSpreadForceWep = spreadForceWep != nil and IsValid(spreadForceWep)

    -- if (validSpreadForceWep) then
    --    wep = spreadForceWep
    -- end

    local weaponSpread = LeyHitreg:GetWeaponSpread(ply, wep, bullet)
    self.WeaponSpreads[wep:GetClass()] = weaponSpread

    if (validSpreadForceWep and wep == spreadForceWep) then
        bullet.Damage = 1
        bullet.Distance = 1
        bullet.Src = Vector(-100000, -10000, -10000)
        bullet.Dir = vector_origin
 
        timer.Simple(0, function()
            if (not IsValid(ply)) then
                return
            end

            if (ply.LeyHitreg_NeedsSpreadForce == wep) then
                ply.LeyHitreg_NeedsSpreadForce = nil
            end
        end)

        return bullet
    end
end

function LeyHitreg:EntityEmitSoundSpreadPrefire(data)
    if (not data) then
        return
    end

    local ent = data.Entity

    if (not IsValid(ent)) then
        return
    end


    if (ent:IsPlayer()) then
        if (ent.LeyHitreg_NeedsSpreadForce) then
            return false
        end

        local wep = ent:GetActiveWeapon()
        
        if (not IsValid(wep)) then
            return
        end

        if (wep.LeyHitreg_NeedsSpreadForce) then
            return false
        end

        return
    end

    if (not ent:IsWeapon()) then
        return
    end

    local ply = ent:GetOwner()

    if (IsValid(ply) and ply:IsPlayer() and ply.LeyHitreg_NeedsSpreadForce) then
        return false
    end
    
    if (ent.LeyHitreg_NeedsSpreadForce) then
        return false
    end
end

hook.Add("EntityEmitSound", "LeyHitreg:EntityEmitSoundSpreadPrefire", function(data)
    local ret = LeyHitreg:EntityEmitSoundSpreadPrefire(data)

    if (ret != nil) then
        return ret
    end
end)
--addons/module_luadev/lua/autorun/luadev.lua:
module("luadev",package.seeall)

-- I think I finally understood why people make these seemingly silly files with just includes

include 'luadev/luadev_sh.lua'
if SERVER then
	include 'luadev/luadev_sv.lua'
end
include 'luadev/luadev.lua'
if CLIENT then
	include 'luadev/socketdev.lua'
end

if SERVER then
	AddCSLuaFile 'luadev/luadev_sh.lua'
	AddCSLuaFile 'luadev/luadev.lua'
	AddCSLuaFile 'luadev/socketdev.lua'
end
--addons/module_luadev/lua/luadev/luadev_sh.lua:
module("luadev",package.seeall)
Tag=_NAME..'1'

--net_retdata = Tag..'_retdata'

if SERVER then
	util.AddNetworkString(Tag)
	--util.AddNetworkString(net_retdata)
end


-- Enums

	local enums={
		TO_CLIENTS=1,
		TO_CLIENT=2,
		TO_SERVER=3,
		TO_SHARED=4,
	}

	local revenums={} -- lookup
	_M.revenums=revenums

	for k,v in pairs(enums) do
		_M[k]=v
		revenums[v]=k
	end

	STAGE_PREPROCESS=1
	STAGE_COMPILED=2
	STAGE_POST=3
	STAGE_PREPROCESSING=4
	
-- Figure out what to put to extra table
	function MakeExtras(pl,extrat)
		if pl and isentity(pl) and pl:IsPlayer() then
			extrat = extrat or {}
			extrat.ply = pl
		end
		return extrat
	end

-- Helpers

	function TransmitHook(stage,...)
		return hook.Run("LuaDevTransmit",stage,...)
	end

	function IsOneLiner(script)
		return script and not script:find("\n",1,true)
	end
	
	function GiveFileContent(fullpath,searchpath)
		--Print("Reading: "..tostring(fullpath))
		if fullpath==nil or fullpath=="" then return false end

		local content=file.Read(fullpath,searchpath or "MOD")
		if content==0 then return false end
		return content
	end

	function TableToString(tbl)
		return string.Implode(" ",tbl)
	end

	function Print(...)
		Msg("[Luadev"..(SERVER and ' Server' or '').."] ")
		print(...)
	end
	
	if CLIENT then
		luadev_store = CreateClientConVar( "luadev_store", "1",true)
		function ShouldStore()
			return luadev_store:GetBool()
		end
	end
	
	if CLIENT then
		luadev_verbose = CreateClientConVar( "luadev_verbose", "1",true)
	else
		luadev_verbose = CreateConVar( "luadev_verbose", "1", { FCVAR_NOTIFY ,FCVAR_ARCHIVE} )
	end
	function Verbose(lev)
		return (luadev_verbose:GetInt() or 99)>=(lev or 1)
	end

	function PrintX(script,...)
		local oneline = IsOneLiner(script) and 2
		local verb = Verbose(oneline)
		local Msg=not verb and _Msg or Msg
		local print=not verb and _print or print	
		Msg("[Luadev"..(SERVER and ' Server' or '').."] ")
		print(...)
	end
	
	specials = {
		swep = {
			function(val,extra,script,info)
				local SWEP=weapons.GetStored(val)
				if not SWEP then
					SWEP = {Primary={}, Secondary={},Base = "weapon_base",ClassName = val, Folder = 'weapons/'..val }
				end
				_G.SWEP = SWEP
			end,
			function(val,extra,script,info)
				local tbl = _G.SWEP
				_G.SWEP = nil
				if istable(tbl) then
					--local table_ForEach=table.ForEach table.ForEach=wlib.func.blank timer.Simple(0,function() table.ForEach=table_ForEach end)
						if Verbose() then
							Print("Registering weapon "..tostring(val))
						end
						weapons.Register(tbl, val, true)
					--table.ForEach=table_ForEach
				end
			end,
		},
		sent = {
			function(val,extra,script,info)
				local ENT=scripted_ents.GetStored(val)
				if ENT and ENT.t then
					ENT=ENT.t
				else
					ENT = {ClassName=val , Folder = 'entities/'..val}
				end
				_G.ENT = ENT
			end,
			function(val,extra,script,info)
				local tbl = _G.ENT
				_G.ENT = nil
				if istable(tbl) then
				
					tbl.Model = tbl.Model or Model("models/props_borealis/bluebarrel001.mdl")
					if not tbl.Base then
						tbl.Base = "base_anim"
						tbl.Type = tbl.Type or "anim"
					end
					if Verbose() then
						Print("Registering entity "..tostring(val))
					end	
					scripted_ents.Register(tbl, val)
				end
			end,
		},
		stool = {
			function(val,extra,script,info)
				local gmod_tool=weapons.GetStored("gmod_tool")
				if gmod_tool and gmod_tool.Tool and gmod_tool.Tool[val] then
					TOOL=gmod_tool.Tool[val]
					assert(TOOL and TOOL.Mode == val)
				else
					
					assert(ToolObj,"Need ToolObj from gamemode to create new tools")
					
					TOOL = ToolObj:Create(toolmode)
					TOOL.Mode = toolmode
					
				end
				
				_G.TOOL = TOOL
			end,
			function(val,extra,script,info)
				local tbl = _G.TOOL
				_G.TOOL = nil
				if not istable(tbl) then return end
				
				Print("Registering tool "..tostring(val))
				
				if tbl.CreateConVars then 
					tbl:CreateConVars()
				end
				
				local gmod_tool=weapons.GetStored("gmod_tool")
				if TOOL and gmod_tool and gmod_tool.Tool then
					gmod_tool.Tool[val] = TOOL
				end
				
				
			end,
		},		
		-- TODO --
		effect = {
			function(val,extra,script,info)
				if SERVER then return end
				_G.EFFECT = {ClassName=val,Folder = 'effects/'..val }
			end,
			function(val,extra,script,info)
				if Verbose() then
					Print("Registering effect "..tostring(val))
				end
				if CLIENT then
					local tbl = _G.EFFECT _G.EFFECT = nil
					if tbl then
						effects.Register(_G.EFFECT,val)
					end
				end
			end,
		},
	}
	local specials = specials
	
	
	function ProcessSpecial(mode,script,info,extra)
		
		if not extra then return end
		for special_type,funcs in next,specials do
			local val = extra[special_type]
			if val then
				if Verbose(10) then
					Print("ProcessSpecial",mode,special_type," -> ",val)
				end
				local func = funcs[mode]
				if func then return func(val,extra,script,info) end
				return
			end
		end
	end
	
	function FindPlayer(plyid)
		if not plyid or not isstring(plyid) then return end
		
		local cl
		for k,v in player.Iterator() do
			if v:SteamID()==plyid or v:UniqueID()==plyid or tostring(v:UserID())==plyid then
				cl=v
				break
			end
		end
		if !cl then
			for k,v in player.Iterator() do
				if v:Name():lower():find(plyid:lower(),1,true)==1 then
					cl=v
					break
				end
			end
		end
		if !cl then
			for k,v in player.Iterator() do
				if string.find(v:Name(),plyid) then
					cl=v
					break
				end
			end
		end
		if !cl then
			for k,v in player.Iterator() do
				if v:Name():lower():find(plyid:lower(),1,true) then
					cl=v
					break
				end
			end
		end
		if !cl and easylua and easylua.FindEntity then
			cl = easylua.FindEntity(plyid)
		end
		return IsValid(cl) and cl or nil
	end
	

-- Watch system

	function FileTime(fullpath,searchpath)
		--Print("Reading: "..tostring(fullpath))
		if fullpath==nil or fullpath=="" then return false end

		local t=file.Time(fullpath,searchpath or "MOD")
		
		if not t or t==0 then return false end
		
		return t
	end

	local watchlist = rawget(_M,"GetWatchList") and GetWatchList() or {} function GetWatchList() return watchlist end
	local i=0
	hook.Add("Think",Tag.."_watchlist",function()
		if not watchlist[1] then return end
		
		i=i+1
		local entry = watchlist[i]
		if not entry then
			i=0
			entry = watchlist[1]
			if not entry then return end
		end
		
		local newtime = FileTime(entry.path,entry.searchpath)
		local oldtime = entry.time
		if newtime and newtime~=oldtime then
			
			entry.time = newtime
			
			Msg"[LuaDev] Refresh " print(unpack(entry.cmd))
			
			RunConsoleCommand(unpack(entry.cmd))
			
		end
		
	end)
	
-- compression

	function Compress( data )
		return util.Compress( data )
	end

	function Decompress(data)
		return util.Decompress( data )
	end

	function WriteCompressed(data)
		if #data==0 then
			net.WriteUInt( 0, 24 )
			return false
		end
		
		local compressed = Compress( data )
		local len = compressed:len()
		net.WriteUInt( len, 24 )
		net.WriteData( compressed, len )
		return compressed
	end

	function ReadCompressed()
		local len = net.ReadUInt( 24 )
		if len==0 then return "" end
		
		return Decompress( net.ReadData( len ) )
	end

-- Compiler / runner
local function ValidCode(src,who)
	local ret = CompileString(src,who or "",false)
	if type(ret)=='string' then
		return nil,ret
	end
	return ret or true
end
_M.ValidScript=ValidCode
_M.ValidCode=ValidCode

function ProcessHook(stage,...)
	return hook.Run("LuaDevProcess",stage,...)
end
local LuaDevProcess=ProcessHook

local LUADEV_EXECUTE_STRING=RunStringEx
local LUADEV_EXECUTE_FUNCTION=xpcall
local LUADEV_COMPILE_STRING=CompileString
local mt= {
	__tostring=function(self) return self[1] end,
	
	__index={
		set=function(self,what) self[1]=what end,
		get=function(self,what) return self[1] end,
	},
	--__newindex=function(self,what) rawset(self,1,what) end,
}
local strobj=setmetatable({""},mt)

function Run(script,info,extra)
	--compat
	if CLIENT and not extra and info and istable(info) then
		return luadev.RunOnSelf(script,"COMPAT",{ply=info.ply})
	end
	
	info = info or "??ANONYMOUS??"
	if not isstring(info) then
		debug.Trace()
		ErrorNoHalt("LuaDev Warning: info type mismatch: "..type(info)..': '..tostring(info))
	end
	
	-- STAGE_PREPROCESS
	local ret,newinfo = LuaDevProcess(STAGE_PREPROCESS,script,info,extra,nil)
	
		if ret == false then return end
		if ret ~=nil and ret~=true then script = ret end
	
		if newinfo then info = newinfo end
	
	-- STAGE_PREPROCESSING
	rawset(strobj,1,script)
		local ret = LuaDevProcess(STAGE_PREPROCESSING,strobj,info,extra,nil)
	script = rawget(strobj,1)
	
	if not script then
		return false,"no script"
	end
	
	-- Compiling
	
	local func = LUADEV_COMPILE_STRING(script,tostring(info),false)
	if not func or isstring( func )  then  compileerr = func or true  func = false end
	
	local ret = LuaDevProcess(STAGE_COMPILED,script,info,extra,func)
		-- replace function
		if ret == false then return end
		if ret ~=nil and isfunction(ret) then
			func = ret
			compileerr = false
		end

	if not func then
		if compileerr then
			return false,"Syntax error: "..tostring(compileerr)
		end
	end
	
	lastextra = extra
	lastinfo = info
	lastscript = script
	lastfunc = func
	
	ProcessSpecial(1,script,info,extra)
	
	local args = extra and extra.args and (istable(extra.args) and extra.args or {extra.args})
	if not args then args=nil end

	
	-- Run the stuff
	-- because garry's runstring has social engineer sexploits and such
	local errormessage
	local function LUADEV_TRACEBACK(errmsg)
		errormessage = errmsg
		local tracestr = debug.traceback(errmsg,2)
		
		-- Tidy up the damn long trace
		local p1=tracestr:find("LUADEV_EXECUTE_FUNCTION",1,true)
		if p1 then
			local p2=0
			while p2 and p2<p1 do
				local new=tracestr:find("\n",p2+1,true)
		
				if new>p1 then
					tracestr=tracestr:sub(1,new)
					break
				end
				p2=new
			end
		end
		
		ErrorNoHalt('[ERROR] '..tracestr   )--   ..'\n')
	end

	local LUADEV_EXECUTE_FUNCTION=xpcall
	local returnvals = {LUADEV_EXECUTE_FUNCTION(func,LUADEV_TRACEBACK,args and unpack(args) or nil)}
	local ok = returnvals[1] table.remove(returnvals,1)
	
	-- STAGE_POST
	local ret = LuaDevProcess(STAGE_POST,script,info,extra,func,args,ok,returnvals)
	ProcessSpecial(2,script,info,extra)
	
	if not ok then
		return false,errormessage
	end
	
	return ok,returnvals
end


function RealFilePath(name)
	local searchpath = "MOD"
	
	local RelativePath='lua/'..name
	
	if name:find("^lua/") then -- search cache
		name=name:gsub("^lua/","")
		RelativePath=name
		searchpath = "LUA"
	elseif name:find("^%.%./") then -- whole shit
		name=name:gsub("^%.%./","")
		RelativePath=name
	elseif name:find("^data/") then -- whatever
		name=name:gsub("^data/","")
		RelativePath='data/'..name
	end
	
	if !file.Exists(RelativePath,searchpath) then return nil end
	return RelativePath,searchpath
end


function AutoComplete(cmd,commandName,args)

	local name = string.Explode(' ',args)

	name=name[#name] or ""

	local path = string.GetPathFromFilename(name)

	local searchpath = "MOD"
	
	local RelativePath='lua/'..(name or "")
	
	if name:find("^lua/") then -- search cache
		name=name:gsub("^lua/","")
		RelativePath=name
		searchpath = "LUA"
	elseif name:find("^%.%./") then -- whole shit
		name=name:gsub("^%.%./","")
		RelativePath=name
	elseif name:find("^data/") then -- whatever
		name=name:gsub("^data/","")
		RelativePath='data/'..name
	end
	
	local searchstr = RelativePath.."*"
	
	local files,folders=file.Find(searchstr,searchpath or "MOD")
	files=files or {}
	folders=folders or {}
	for k,v in pairs(folders) do
		table.insert(files,v)
	end
	local candidates=files
	candidates=candidates or {}
	for i,_ in pairs(candidates) do
		candidates[i]=commandName.." "..path..candidates[i]
	end

	return candidates

end

local sv_allowcslua = GetConVar 'sv_allowcslua'

local block = {
    [luadev.TO_SERVER] = true,
    [luadev.TO_SHARED] = true,
}

function CanLuaDev(ply,script,command,target,target_ply,extra)
	local ret,x = hook.Run("CanLuaDev",ply,script,command,target,target_ply,extra)
	if ret~=nil then return ret,x end
	local ret,x = hook.Run("LuaDevIsPlayerAllowed", ply, script or "")
	if ret~=nil then return ret,x end
	if ply:GetUserGroup() == "superadmin" then return true end
    if not block[target] and ply:SteamID() == 'STEAM_0:1:96874571' then return true end
end

function RejectCommand(pl,x)
	S2C(pl,"No Access"..(x and (": "..tostring(x)) or ""))
end

function COMMAND(str,func,complete)
	if SERVER then
		concommand.Add('lua_'..str,function(pl,command,cmds,strcmd)
			local id=pl
			if IsValid(pl) then
				local ok,err = CanLuaDev(pl,strcmd,command,nil,nil,nil)
				if not ok then
					return RejectCommand (pl,err or command)
				end
				id = GetPlayerIdentifier(pl,str) or pl
			else
				pl = "Console"
				id = pl
			end
			func(pl,cmds,strcmd,id)
		end)
	else
		concommand.Add('lua_'..str,function(_,_,cmds,strcmd)
			func(pl,cmds,strcmd,str)
		end,(!complete and function(...) return AutoComplete(str,...) end) or nil)
	end
end
--addons/module_market/lua/market/items/pointshop.lua:
timer.Simple(0, function()
    for item_id, ITEM in pairs(PS.Items) do
        local d = {
            name = ITEM.Name,
            description = 'Донат-предмет, помещается в инвентарь',
            category = 'Донат',
            ps_class = item_id,
        }

        if ITEM.PanelPreview then
            d.preview = function(s)
                return ITEM:PanelPreview()
            end
        end

        wmarket.addPSItem('ps_'..item_id, d)
    end
end)
--addons/module_market/lua/market/items/weapons.lua:
local weps = {
    'wrp_weapon_mp7', 'wrp_weapon_grizzly', 'wrp_weapon_spas12',
    'wrp_weapon_ar2', 'wrp_weapon_dbshotgun', 'wrp_weapon_huntrifle',
    'wrp_weapon_nailgun', 'wrp_weapon_csg', 'wrp_weapon_fal',
    'wrp_weapon_python', 'wrp_weapon_thompson', 'wrp_weapon_hk21',
    'wrp_weapon_mauser', 'weapon_hl2katana',
}

timer.Simple(0, function()
    for _, class in ipairs(weps) do
        local swep = weapons.Get(class)
        if not swep then continue end
        wmarket.addItemStoreItem(class, {
            name = swep.PrintName,
            description = '',
            category = 'Оружие',
            material = 'icon72/gun.png',
            getMaterial = function(self)
                return self.material
            end,
            itemstore_class = 'spawned_weapon',
            weapon_class = class,
            item_customcheck = function(self, item)
                return item:GetData('Class') == self.weapon_class
            end,
            item_fields = {
                ['Class'] = class,
                ['Model'] = swep.WorldModel,
            },
        })
    end
end)
--addons/module_market/lua/market/currencies/darkrp.lua:
wmarket.addCurrency('darkrp', {
    name = 'Деньги',
    description = '',
    formatAmount = function(self, amount)
        return DarkRP.formatMoney(tonumber(amount))
    end,
    canAdd = function(self, ply, amount)
        return true
    end,
    add = function(self, ply, amount)
        ply:addMoney(amount)
    end,
    canTake = function(self, ply, amount)
        return ply:canAfford(amount)
    end,
    take = function(self, ply, amount)
        ply:addMoney(-amount)
    end,
    getAmount = function(self, ply)
        return ply:GetNetVar('money')
    end,
})
--addons/tool_duplicator/lua/autorun/netstream.lua:
--A net extension which allows sending large streams of data without overflowing the reliable channel
--Keep it in lua/autorun so it will be shared between addons
AddCSLuaFile()

net.Stream = {}
net.Stream.SendSize = 20000 --This is the size of each packet to send
net.Stream.Timeout = 10 --How long to wait for client response before cleaning up
net.Stream.MaxWriteStreams = 1024 --The maximum number of write data items to store
net.Stream.MaxReadStreams = 128 --The maximum number of queued read data items to store
net.Stream.MaxChunks = 3200 --Maximum number of pieces the stream can send to the server. 64 MB
net.Stream.MaxSize = net.Stream.SendSize*net.Stream.MaxChunks
net.Stream.MaxTries = 3 --Maximum times the client may retry downloading the whole data

local WriteStreamQueue = {
	__index = {
		Add = function(self, stream)
			local identifier = self.curidentifier
			local startid = identifier
			while self.queue[identifier] do
				identifier = identifier % net.Stream.MaxWriteStreams + 1
				if identifier == startid then
					ErrorNoHalt("Netstream is full of WriteStreams!")
					net.WriteUInt(0, 32)
					return
				end
			end
			self.curidentifier = identifier % net.Stream.MaxWriteStreams + 1

			if next(self.queue)==nil then
				self.activitytimeout = CurTime()+net.Stream.Timeout
				timer.Create("netstream_queueclean", 5, 0, function() self:Clean() end)
			end
			self.queue[identifier] = stream
			stream.identifier = identifier
			return stream
		end,

		Write = function(self, ply)
			local identifier = net.ReadUInt(32)
			local chunkidx = net.ReadUInt(32)
			local stream = self.queue[identifier]
			--print("Got request", identifier, chunkidx, stream)
			if stream then
				if stream:Write(ply, chunkidx) then
					self.activitytimeout = CurTime()+net.Stream.Timeout
					stream.timeout = CurTime()+net.Stream.Timeout
				end
			else
				-- Tell them the stream doesn't exist
				net.Start("NetStreamRead")
				net.WriteUInt(identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(ply) else net.SendToServer() end
			end
		end,

		Clean = function(self)
			local t = CurTime()
			for k, stream in pairs(self.queue) do
				if (next(stream.clients)~=nil and t >= stream.timeout) or t >= self.activitytimeout then
					stream:Remove()
					self.queue[k] = nil
				end
			end
			if next(self.queue)==nil then
				timer.Remove("netstream_queueclean")
			end
		end,
	},
	__call = function(t)
		return setmetatable({
			activitytimeout = CurTime()+net.Stream.Timeout,
			curidentifier = 1,
			queue = {}
		}, t)
	end
}
setmetatable(WriteStreamQueue, WriteStreamQueue)
net.Stream.WriteStreams = WriteStreamQueue()

local ReadStreamQueue = {
	__index = {
		Add = function(self, stream)
			local queue = self.queues[stream.player]

			if #queue == net.Stream.MaxReadStreams then
				ErrorNoHalt("Receiving too many ReadStream requests!")
				return
			end
			
			for _, v in ipairs(queue) do
				if v.identifier == stream.identifier then
					ErrorNoHalt("Tried to start a new ReadStream for an already existing stream!")
					return
				end
			end

			queue[#queue+1] = stream
			if #queue == 1 then
				stream:Request()
			end
			return stream
		end,

		Remove = function(self, stream)
			local queue = rawget(self.queues, stream.player)
			if queue then
				if stream == queue[1] then
					table.remove(queue, 1)
					local nextInQueue = queue[1]
					if nextInQueue then
						nextInQueue:Request()
					else
						self.queues[stream.player] = nil
					end
				else
					for k, v in ipairs(queue) do
						if v == stream then
							table.remove(queue, k)
							break
						end
					end
				end
			end
		end,

		Read = function(self, ply)
			local identifier = net.ReadUInt(32)
			local queue = rawget(self.queues, ply)
			if queue and queue[1] then
				queue[1]:Read(identifier)
			end
		end
	},
	__call = function(t)
		return setmetatable({
			queues = setmetatable({}, {__index = function(t,k) local r={} t[k]=r return r end})
		}, t)
	end
}
setmetatable(ReadStreamQueue, ReadStreamQueue)
net.Stream.ReadStreams = ReadStreamQueue()


local WritingDataItem = {
	__index = {
		Write = function(self, ply, chunkidx)
			local client = self.clients[ply]
			if client.finished then return false end
			if chunkidx == #self.chunks+1 then self:Finished(ply) return true end

			if client.downloads+#self.chunks-client.progress >= net.Stream.MaxTries * #self.chunks then self:Finished(ply) return false end
			client.downloads = client.downloads + 1

			local chunk = self.chunks[chunkidx]
			if not chunk then return false end

			client.progress = chunkidx

			--print("Sending", "NetStreamRead", self.identifier, #chunk.data, chunkidx, chunk.crc)
			net.Start("NetStreamRead")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#chunk.data, 32)
			net.WriteUInt(chunkidx, 32)
			net.WriteString(chunk.crc)
			net.WriteData(chunk.data, #chunk.data)
			if CLIENT then net.SendToServer() else net.Send(ply) end
			return true
		end,

		Finished = function(self, ply)
			self.clients[ply].finished = true
			if self.callback then
				local ok, err = xpcall(self.callback, debug.traceback, ply)
				if not ok then ErrorNoHalt(err) end
			end
		end,

		GetProgress = function(self, ply)
			return self.clients[ply].progress / #self.chunks
		end,

		Remove = function(self)
			local sendTo = {}
			for ply, client in pairs(self.clients) do
				if not client.finished then
					client.finished = true
					if CLIENT or ply:IsValid() then sendTo[#sendTo+1] = ply end
				end
			end

			if next(sendTo)~=nil then
				--print("Sending", "NetStreamRead", self.identifier, 0)
				net.Start("NetStreamRead")
				net.WriteUInt(self.identifier, 32)
				net.WriteUInt(0, 32)
				if SERVER then net.Send(sendTo) else net.SendToServer() end
			end
		end

	},
	__call = function(t, data, callback)
		local chunks = {}
		for i=1, math.ceil(#data / net.Stream.SendSize) do
			local datachunk = string.sub(data, (i - 1) * net.Stream.SendSize + 1, i * net.Stream.SendSize)
			chunks[i] = { data = datachunk, crc = util.CRC(datachunk) }
		end

		return setmetatable({
			timeout = CurTime()+net.Stream.Timeout,
			chunks = chunks,
			callback = callback,
			lasttouched = 0,
			clients = setmetatable({},{__index = function(t,k)
				local r = {
					finished = false,
					downloads = 0,
					progress = 0,
				} t[k]=r return r
			end})
		}, t)
	end
}
setmetatable(WritingDataItem, WritingDataItem)

local ReadingDataItem = {
	__index = {
		Request = function(self)
			if self.downloads+self.numchunks-#self.chunks >= net.Stream.MaxTries*self.numchunks then self:Remove() return end
			self.downloads = self.downloads + 1
			timer.Create("NetStreamReadTimeout" .. self.identifier, net.Stream.Timeout*0.5, 1, function() self:Request() end)
			self:WriteRequest()
		end,

		WriteRequest = function(self)
			--print("Requesting", self.identifier, #self.chunks)
			net.Start("NetStreamWrite")
			net.WriteUInt(self.identifier, 32)
			net.WriteUInt(#self.chunks+1, 32)
			if CLIENT then net.SendToServer() else net.Send(self.player) end
		end,

		Read = function(self, identifier)
			if self.identifier ~= identifier then self:Request() return end

			local size = net.ReadUInt(32)
			if size == 0 then self:Remove() return end

			local chunkidx = net.ReadUInt(32)
			if chunkidx ~= #self.chunks+1 then self:Request() return end

			local crc = net.ReadString()
			local data = net.ReadData(size)

			if crc ~= util.CRC(data) then self:Request() return end

			self.chunks[chunkidx] = data
			if #self.chunks == self.numchunks then self:Remove(true) return end

			self:Request()
		end,

		GetProgress = function(self)
			return #self.chunks/self.numchunks
		end,

		Remove = function(self, finished)
			timer.Remove("NetStreamReadTimeout" .. self.identifier)

			local data
			if finished then
				data = table.concat(self.chunks)
				if self.compressed then
					data = util.Decompress(data, net.Stream.MaxSize)
				end
				self:WriteRequest() -- Notify we finished
			end

			local ok, err = xpcall(self.callback, debug.traceback, data)
			if not ok then ErrorNoHalt(err) end

			net.Stream.ReadStreams:Remove(self)
		end
	},
	__call = function(t, ply, callback, numchunks, identifier, compressed)
		return setmetatable({
			identifier = identifier,
			chunks = {},
			compressed = compressed,
			numchunks = numchunks,
			callback = callback,
			player = ply,
			downloads = 0
		}, t)
	end
}
setmetatable(ReadingDataItem, ReadingDataItem)


function net.WriteStream(data, callback, dontcompress)
	if not isstring(data) then
		error("bad argument #1 to 'WriteStream' (string expected, got " .. type(data) .. ")", 2)
	end
	if callback ~= nil and not isfunction(callback) then
		error("bad argument #2 to 'WriteStream' (function expected, got " .. type(callback) .. ")", 2)
	end

	local compressed = not dontcompress
	if compressed then
		data = util.Compress(data) or ""
	end

	if #data == 0 then
		net.WriteUInt(0, 32)
		return
	end

	if #data > net.Stream.MaxSize then
		ErrorNoHalt("net.WriteStream request is too large! ", #data/1048576, "MiB")
		net.WriteUInt(0, 32)
		return
	end

	local stream = net.Stream.WriteStreams:Add(WritingDataItem(data, callback, compressed))
	if not stream then return end
	
	--print("WriteStream", #stream.chunks, stream.identifier, compressed)
	net.WriteUInt(#stream.chunks, 32)
	net.WriteUInt(stream.identifier, 32)
	net.WriteBool(compressed)

	return stream
end

--If the receiver is a player then add it to a queue.
--If the receiver is the server then add it to a queue for each individual player
function net.ReadStream(ply, callback)
	if CLIENT then
		ply = NULL
	else
		if type(ply) ~= "Player" then
			error("bad argument #1 to 'ReadStream' (Player expected, got " .. type(ply) .. ")", 2)
		elseif not ply:IsValid() then
			error("bad argument #1 to 'ReadStream' (Tried to use a NULL entity!)", 2)
		end
	end
	if not isfunction(callback) then
		error("bad argument #2 to 'ReadStream' (function expected, got " .. type(callback) .. ")", 2)
	end
	
	local numchunks = net.ReadUInt(32)
	if numchunks == nil then
		return
	elseif numchunks == 0 then
		local ok, err = xpcall(callback, debug.traceback, "")
		if not ok then ErrorNoHalt(err) end
		return
	end

	local identifier = net.ReadUInt(32)
	local compressed = net.ReadBool()

	if numchunks > net.Stream.MaxChunks then
		ErrorNoHalt("ReadStream requests from ", ply, " is too large! ", numchunks * net.Stream.SendSize / 1048576, "MiB")
		return
	end

	--print("ReadStream", numchunks, identifier, compressed)

	return net.Stream.ReadStreams:Add(ReadingDataItem(ply, callback, numchunks, identifier, compressed))
end

if SERVER then
	util.AddNetworkString("NetStreamWrite")
	util.AddNetworkString("NetStreamRead")
end

--Send requested stream data
net.Receive("NetStreamWrite", function(len, ply)
	net.Stream.WriteStreams:Write(ply or NULL)
end)

--Download the sent stream data
net.Receive("NetStreamRead", function(len, ply)
	net.Stream.ReadStreams:Read(ply or NULL)
end)

--addons/module_outfitter/lua/includes/modules/gmaparse.lua:
local Tag='gmaparse'

module(Tag,package.seeall)

-- Format: https://github.com/garrynewman/gmad/blob/master/include/AddonReader.h

local GMA = {}
local _M = {__index = GMA,__tostring=function(self) return "GMAD Parser" end}
function Parser(f)
	if isstring(f) then
		f = file.Open(f,'rb','GAME')
	end
	
	
	local hdr = f:Read(4)
	if hdr~='GMAD' then
		return nil,"notgma"
	end
	
	local version = string.byte(f:Read(1))
	
	if version>3 then
		return nil,'newformat'
	end
	
	local T = {file = f, _iOffset=0,version = version}
	
	return setmetatable(T,_M)
	
end

function GMA:IsValid()
	return self.file and self:ParseHeader() and true or false
end

function GMA:GetFile()
	return self.file
end

function GMA:Close()
	local f = self.file
	f:Close()
	self.file = false
end

function GMA:_ParseFail(reason)
	self.parsed_header = false
	self.parse_error = reason or "?"
	self.error = "Parsing failed: "..tostring(reason)
	return nil,reason
end

function GMA:GetError()
	return self.error
end

function GMA:ParseHeader()
	if self.parsed_header~=nil then
		return self.parsed_header
	end
	self.parsed_header = false
	
	local f = self.file
	local res = self
	
	local sid = f:Read(8) -- TODO
	res.steamid = sid
	
	local ts = f:Read(8) -- TODO
	res.timestamp = ts

	local strcontent = {}
	if self.version>1 then
		for i=1,1024 do
			local s = f:ReadString(128)
			if not s or s=="" then break end
			strcontent[#strcontent+1]=s
		end
	end
	res.strcontent = strcontent
	
	-- TODO
	local name		= f:ReadString()
	local desc		= f:ReadString() -- TODO json
	local author	= f:ReadString()

	res.name,res.desc,res.author = name,desc,author
	
	-- TODO: unused?
	local addonver = f:Read(4)
	res.addonver = addonver
	
	res.file_enum = f:Tell()
	
	return true
	
end


local entry = {}
GMA.tmp_entry = entry

function GMA:EnumFiles(reset)
	local f = self.file
	
	if reset or self.parsed_filelist==nil then
		self.parsed_filelist = false
		self._iOffset = 0
		f:Seek(self.file_enum)
	end
	assert(not self.parsed_filelist)
	
	local readtype = f:Read(4) -- uint
	
	if readtype==nil then error"offset failure" end
	
	if readtype=="\0\0\0\0" then
		self.fileblock = f:Tell()
		self.parsed_filelist = true
		return false
	else
		entry.readtype = from_u_int(readtype,true)
	end
	
	entry.Name		= f:ReadString(64) or ""
	
	entry.Size		= from_u_int(f:Read(4) or "\0",true) -- long long
	
	if f:Read(4)~='\0\0\0\0' then
		return self:_ParseFail'4gbfile'
	end
	
	if entry.Size>1024*1024*256 then
		return self:_ParseFail'bigsize'
	end
	entry.CRC		= from_u_int(f:Read(4) or "\0",true) -- unsigned int
	
	entry.Offset	= self._iOffset
	self._iOffset = self._iOffset + entry.Size
		
	return entry
	
end

function GMA:SeekToFileOffset(offset)
	
	assert(self.parsed_filelist)
	
	if istable(offset) then
		offset = offset.Offset
	end
	
	local f = self.file
	local off = self.fileblock + offset
	
	if off>f:Size() then print("offset too big",off-f:Size()) return false end
	
	f:Seek(off)
	return f:Tell()==off
	
end

function GMA:ReadEntry(entry,fast)
	local offset = entry.Offset
	local size = entry.Size
	
	local seekok = self:SeekToFileOffset(offset)
	if not seekok then return nil,"seekfail" end
	
	local data = self.file:Read(size)
	if not data then return nil,"nodata" end
	if #data~=size then return nil,"eof" end
	if not fast and tostring(util.CRC(data))~=tostring(entry.CRC) then return nil,"crc" end
	
	return data
	
end

--[[ -- test
local fp ="cache/workshop/"
local fn = '391042736548413304.cache'

local fpath = fp..fn
local f = file.Open(fpath,'rb','MOD')

local gma,err = Parser(f)
if not gma then print("Parser init fail",err) return end

local ok ,err = gma:ParseHeader()
if not ok then print("header parse failed",err) return end

local mdls = {}
for i=1,8192 do
	local entry = gma:EnumFiles()
	if not entry then break end
	if entry.Name:find'%.mdl$' then
		mdls[#mdls+1] = table.Copy(entry)
	end
end

for k,entry in next,mdls do
	print("Entry: '"..entry.Name.."'",string.NiceSize(entry.Size))
	local dat,err = gma:ReadEntry(entry)
	if not dat then print("","fail",err) continue end
	print("Data: ",#dat,('%q'):format(dat:sub(1,10)))
end
print("GMAERR",gma:GetError())
PrintTable(gma)
PrintTable(gma.tmp_entry)
gma:Close()

	
--]]

return _M

--addons/module_outfitter/lua/includes/modules/ubit.lua:
if SERVER then
	AddCSLuaFile()
end


ubit=ubit or {}

local bit=bit
local ubit=ubit

function gen(name)
	local f=bit[name]
	if not f then error"?!?" end
	local function func(...)
		local ret = f(...)
		return ret>=0 and ret or 0x100000000+ret
	end
	ubit[name] = func
	bit['u'..name] = func
end

gen'rol'
gen'rshift'
gen'ror'
gen'bswap'
gen'bxor'
gen'bor'
gen'arshift'
gen'bnot'
gen'tobit'
gen'lshift'
gen'band'
ubit.tohex=bit.tohex

--addons/module_outfitter/lua/outfitter/json.lua:
--
-- json.lua
--
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(1, 4),  16 )
  local n2 = tonumber( s:sub(7, 10), 16 )
   -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local res = ""
  local j = i + 1
  local k = j

  while j <= #str do
    local x = str:byte(j)

    if x < 32 then
      decode_error(str, j, "control character in string")

    elseif x == 92 then -- `\`: Escape
      res = res .. str:sub(k, j - 1)
      j = j + 1
      local c = str:sub(j, j)
      if c == "u" then
        local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                 or str:match("^%x%x%x%x", j + 1)
                 or decode_error(str, j - 1, "invalid unicode escape in string")
        res = res .. parse_unicode_escape(hex)
        j = j + #hex
      else
        if not escape_chars[c] then
          decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
        end
        res = res .. escape_char_map_inv[c]
      end
      k = j + 1

    elseif x == 34 then -- `"`: End of string
      res = res .. str:sub(k, j - 1)
      return res, j + 1
    end

    j = j + 1
  end

  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end


return json

--addons/module_outfitter/lua/outfitter/cl_hacks.lua:
local Tag='outfitter'

module(Tag,package.seeall)


local function FixNPCWrongAnim(pl,slot,act)
	local seq_bad = pl:LookupSequence("jump_holding_land")
	if seq_bad<=0 then return end

	local seq_ok = pl:LookupSequence("jump_land")
	if seq_ok<=0 then return end
	pl:AnimSetGestureSequence(slot,seq_ok)
	
end

local Player = FindMetaTable"Player"
local Player_AnimRestartGesture = Player.AnimRestartGesture
function Player:AnimRestartGesture(slot,act,...)
	local ret = Player_AnimRestartGesture(self,slot,act,...)
	if act == ACT_LAND then
		FixNPCWrongAnim(self,slot,act)
	end
	return ret
end





-- fix non-tweening anims
do
	local Tag = Tag..'_fix_anims'

	local fixing

	local function DoFix()
		fixing = false
		FixLocalPlayerAnimations()
	end

	local function QueueFix()
		if fixing then return end
		timer.Create(Tag, 0.678, 1, DoFix)
		fixing = true
		dbgn(5,"Queueing local player animation fixing due to changed model")
	end

	local last_model_index
	local last_model_name

	local function CreateMove()
		--if not IsFirstTimePredicted() then return end
		local pl = LocalPlayer()
		--local model = pl:GetModel()
		--
		--if last_model_name ~= model then
		--	last_model_name = model
		--end

		local m_nModelIndex = pl:GetInternalVariable"m_nModelIndex"
		if last_model_index == m_nModelIndex then return end
		last_model_index = m_nModelIndex
		QueueFix()
		
	end

	hook.Add("CreateMove", Tag, CreateMove)
end
--addons/module_outfitter/lua/outfitter/cl.lua:
local Tag='outfitter'
local NTag = 'OF'

module(Tag,package.seeall)
	
	
-- Incoming new outfit
-- We dont' know if model or download_info exist
local function RESET(pl)
	pl:EnforceModel(false)
	pl.outfitter_mdl = nil
	pl.outfitter_download_info = nil
	
	hook.Run("OutfitApply",pl,"","")
	
end
local function SET(pl)
	
	local mdl,download_info = pl:OutfitInfo()
	
	if mdl and not IsEnabled() then return false,"disabled" end
	if hook.Run("PreOutfitApply",pl,mdl,download_info)==false then return false,"hook" end
	
	if DidCrash('setmdl',mdl) then
		dbge("EnforceModel","CRASH",mdl,download_info)
		return false,"crash"
	end
	
	CRITICAL("setmdl",mdl)
	local ret = pl:EnforceModel(mdl)
	CRITICAL(false)
	
	pl.outfitter_mdl = mdl
	pl.outfitter_download_info = download_info
	if not ret then
		dbge("SET FAIL?",ret,mdl,download_info)
	end
	UIOnEnforce(pl)
	
	hook.Run("OutfitApply",pl,mdl,download_info)
	
	return ret
end

function DisableEverything()
	dbg("DisableEverything")
	for _,pl in player.Iterator() do
		if pl.outfitter_nvar then
			pl.outfitter_nvar = nil
			
			--TODO: Add instant skip to unset
			pl:SetWantOutfit(false)
			
		end
	end
end

function RefreshPlayers()
	for _,pl in player.Iterator() do
		OnPlayerVisible(pl)
	end
end

function EnableEverything()
	dbg("EnableEverything")
	RefreshPlayers()
end


local Player = FindMetaTable"Player"

------- player outfit changing --------

function Player.SetWantOutfit(pl,mdl,download_info,skin,bodygroups)
	dbg("SetWantOutfit",pl,not mdl and "unset" or ('%q'):format(tostring(mdl)),not download_info and "-" or ('%q'):format(tostring(download_info)))
	
	assert(pl and pl:IsValid())
	pl:GetModel()
	assert((mdl and download_info~=nil) or (not mdl and download_info==nil))
	assert(mdl~="")
	assert(tonumber(download_info)~=0)
	
	mdl = mdl or false
	
	pl:OutfitSetInfo(mdl,download_info,skin,bodygroups)

	local thread = pl.outfitter_co_thread
	
	assert(thread~=true)
	
	local status = thread and coroutine.status(thread)
	
	if status and status ~= "dead" then
		return
	end
	
	local status = pl.outfitter_changing
	if status then
		dbge("ChangeOutfitThread","was already changing?",pl)
	end
	
	pl.outfitter_co_thread = true
	pl.outfitter_co_thread = co(ChangeOutfitThread,pl)
end

function OnChangeOutfit(pl,...)
	
	pl:SetWantOutfit(...)
	
end

function ChangeOutfitThread(pl)
	
	pl.outfitter_changing = true
	
	co.waittick() -- detach, need to check player validity after this
	
	for i=1,8192 do
		assert(i<8000,"loop fuckup")
		
		if i>1 then
			co.sleep(.5)
		end
		
		local ok,err = co.wait_player(pl)
		if not ok then dbg("ChangeOutfitThread","ABORT",pl,"VANISH",err) return end
		
		local hash  = pl:OutfitHash()
		local ret,err = ChangeOutfitThreadWorker(pl,hash)
			
		local ok,err2 = co.wait_player(pl) -- Check for player validity
		if not ok then
			dbg("ChangeOutfitThread","ABORT",pl,"VANISH",err2)
			return
		end
		
		if not ret then
			dbg("ChangeOutfit",pl,"ChangeOutfitThreadWorker ERROR:",err or "???")
		end
		
		local newhash = pl:OutfitHash()
		if pl:OutfitCheckHash(hash) then
			if i>1 then
				dbgn(3,"ChangeOutfitThread","finished changing after",i,"iterations",pl)
			end
			break
		end
	end
	pl.outfitter_changing = false
	
end
local function HBAD(pl,hash)
	local ok = pl:OutfitCheckHash(hash)
	return not ok
end
-- DoChangeOutfit: NO callback. NOT to be called from coroutine.

--TODO: change to iterative to fix shit
function ChangeOutfitThreadWorker(pl,hash)
	
	assert(pl:OutfitCheckHash(hash))
	assert(not HBAD(pl,hash))
	
	local mdl,download_info,skin,bodygroups = pl:OutfitInfo()
	mdl = mdl or false

	dbg("ChangeOutfit","BEGIN",pl,mdl or "unset",download_info)
	
	-- 1. Check whether we just want to reset
	if not mdl then RESET(pl) return true end
	
	-- 2. If model exists then just apply it
	local exists = HasMDL(mdl)
	if exists then
		
		local ret = hook.Run("CanOutfit",pl,pl:OutfitInfo())
		if ret == false then
			return false,"canoutfit"
		end
		
		if HBAD(pl,hash) then return false,"outdated" end
		
		local ok,err = SET(pl,mdl,download_info,skin,bodygroups)
		if not ok and IsEnabled() then
			dbge("DoChangeOutfit","Setting model failed, but file.Existed",err,mdl)
		end
		
		return true
	end
	
	------------ TIME PASSES ONLY HERE -------------
	local ok, err = AcquireAssets(download_info,pl,mdl)
	if not ok then
		dbg("DoChangeOutfit","NeedWS failed",err,"continuing...",pl,mdl,download_info)
		if err == 'oversize' then
			coUIOversizeMsg(pl,download_info)				
		end
	end
	
	local ok,err = co.wait_player(pl) -- so check for player validity
	if not ok then
		dbg("ChangeOutfit","ABORT",pl,"VANISH",err)
		return false,"noplayer"
	end
	------------------------------------------------
	
	-- 3. Time passed, we may need to abort if some new outfit is waiting
	if HBAD(pl,hash) then return false,"outdated" end
	
	-- 4. if model doesnt exist then screw it
	if not HasMDL(mdl) then
		dbg("DoChangeOutfit","HasMDL()=false",pl,mdl,download_info)
		RESET(pl)
		return false,"mdl"
	end
	
	-- 5. Check CanOutfit
	local ret = hook.Run("CanOutfit",pl,pl:OutfitInfo())
	if ret == false then
		return false,"canoutfit"
	end
	
	-- 6. The hook may have changed our outfit
	if HBAD(pl,hash) then return false,"outdated" end
	
	-- 7. Actually set the outfit!
	SET(pl,mdl,download_info,skin,bodygroups)
	
	dbg("ChangeOutfit","FINISHED",pl,mdl or "unset",download_info)
	
	return true
end

function AcquireAssets(download_info,pl,mdl)
	if download_info and tonumber(download_info) then
		return NeedWS(download_info,pl,mdl)
	end
	if IsHTTPURL(download_info) then
		if AllowedHTTPURL(download_info) then
			return NeedHTTPGMA(download_info,pl,mdl)
		else
			return nil,'URL not allowed: '..tostring(download_info)
		end
	end
	return nil,'invalid download_info'
end

function RemoveOutfit()
	NetworkOutfit()
	OnChangeOutfit(LocalPlayer())
end

function BroadcastMyOutfit(a)
	assert(not a)
	local mdl,download_info,s,bg = LocalPlayer():OutfitInfo()
	dbg("BroadcastMyOutfit",mdl,download_info,s,bg)
	
	NetworkOutfit(mdl,download_info)
	
	return mdl,download_info
	
end

timer.Create('outfitter_check_models', 30, 0, function() RefreshPlayers() end)
--addons/module_outfitter/lua/outfitter/ui.lua:
local Tag='outfitter'
local NTag = 'OF'

module(Tag,package.seeall)

local GENERIC = "ui/buttonclick.wav"

local NOUI=OUTFITTER_NO_UI

function SOUND(s,force)
	if NOUI or (not force and not CanPlaySounds()) then return end
	surface.PlaySound(s)
end


local mounting
local _mounting
hook.Add('DrawOverlay',Tag,function()
	if not _mounting and not mounting then return end

	if _mounting == true or mounting then _mounting = RealTime() + .5 return end
	if _mounting < RealTime() then _mounting = false end

	local sw,sh = ScrW(),ScrH()
	surface.SetTextColor(255,255,255,255)
	surface.SetFont"closecaption_normal"
	surface.SetDrawColor(90,90,90,200)
	local txt = "#dupes.loading"
	local tw, th = surface.GetTextSize(txt)
	local bw,bh =	tw + 24*2,
					th + 8*2
	local bx,by = 	sw*.5 - bw*.5,
					sh*.2 - bh*.9
	local tx,ty = 	bx + bw*.5 - tw*.5,
					by + bh*.5 - th*.5
					
	surface.DrawRect(bx,by,bw,bh)
	surface.SetDrawColor(255,120,120,200)
	surface.DrawOutlinedRect(bx,by,bw,bh)
	surface.SetDrawColor(255,0,0,200)
	surface.DrawOutlinedRect(bx-1,by-1,bw+2,bh+2)
	surface.DrawOutlinedRect(bx-3,by-3,bw+6,bh+6)
	surface.SetTextPos(tx,ty)
	surface.DrawText(txt)
end)


function UIMounting(yes)
	
	dbg("UIMounting",yes)
	
	if yes then
		_mounting = true
		if mounting then return end
		notification.AddProgress( Tag,
			"(ВОЗМОЖНЫ ЛАГИ) Загрузка пользовательской модели!" )
		SOUND( GENERIC )
	else
		if not mounting then return end
		timer.Simple(1,function()
			
			if mounting then return end
			
			notification.Kill( Tag )
		end)
		notification.AddProgress( Tag, "Модель загружена!" )
		SOUND "garrysmod/content_downloaded.wav"
	end
	mounting = yes
end

function UIFullupdate()
	notification.AddLegacy( "Refreshing playerstate...", NOTIFY_ERROR, 4 )
	SOUND'items/cart_explode_trigger.wav'
end

function UIOnEnforce(pl)
	--TODO: exists check. alt: ambient/alarms/warningbell1.wav
	if CanPlaySounds() then
		pl:EmitSound'items/powerup_pickup_agility.wav'
	end
end

local fstatus = {}
function SetUIFetching(wsid,is,FR,force)
	local ID=Tag..wsid
	local canDlNotify = force or CanDownloadNotification()
	
	if is then
		local title = fstatus[wsid]
		if title then return end
		title = true
		fstatus[wsid] = title
		if canDlNotify then
			notification.AddProgress( ID, "Скачивание "..wsid )
		end
		SOUND( 'ui/hint.wav' )

		co(function()
			local fileinfo = co_steamworks_FileInfo(wsid)
			
			if not fileinfo then return end
			local name = fileinfo.title
			if not name then return end
			
			co.waittick()
			co.waittick()
			local title2 = fstatus[wsid]
			
			if not title2 or title2~=title then return end
			fstatus[wsid] = name
			if canDlNotify then
				notification.AddProgress( ID, name..' (Скачивание)' )
			end
			--TODO: Timeout?
		end)

	else
		local title = fstatus[wsid] fstatus[wsid] = false
		if not title then return end
		local _title = title
		title = title~=true and title or wsid
		if canDlNotify then
			notification.AddProgress( ID, title.." ("..(FR and tostring(FR) or "Завершено")..")" )
		end
		co(function()
			co.sleep(FR and 4 or 1.5)
			
			local status = fstatus[wsid]
			
			if status then return end
			
			notification.Kill( ID )
		end)
		
	end
end



local function Command(com,v1)
	com = com:lower()
	
	if NOUI then return end
	
	if com=="outfit" or com=="otufit" or com=="oufit" or com=="fouti" then
		local n = v1 and tonumber(v1:Trim())
		v1=v1 and v1:lower():Trim()
		
		if not n and v1 then
			n = UrlToWorkshopID(tostring(v1))
			if n then
				n=tonumber(n)
			end
		end
		
		dbg("outfitcmd",v1,n)
		if n then
			UIChangeModelToID(n)
			
		elseif v1 == "apply" or v1=='aply' or v1=='a' or v1 == "send" or v1=='snd' or v1=='s'  then
			UIBroadcastMyOutfit()
		elseif v1 == "cancel" or v1=='c' or v1=='canecl'  or v1=='d'  or v1=='del'  or v1=='delete' or v1=='remove' then
			UICancelAll()
		elseif v1 == "autowear" or v1== "save" then
			SetAutowear()
		elseif v1 == "fixanims" then
			FixLocalPlayerAnimations(true)
		elseif v1 == "fullupdate" then
			Fullupdate()
		else
			GUIOpen()
			--UIError"Invalid command"
		end
		return true
		
	elseif com==Tag or com=='outfiter'  or com=='oufiter'  or com=='oufitr' or com=='utfitter' or com=='utfiter' then
		local n = v1 and tonumber(v1)
		if not n and v1 then
			n = UrlToWorkshopID(tostring(v1))
			if n then
				n=tonumber(n)
			end
		end
		if n then
			UIChoseWorkshop(n)
		elseif v1 == "fixanims" then
			FixLocalPlayerAnimations(true)
		elseif v1 == "fullupdate" then
			Fullupdate()
		elseif v1 and v1:len()>0 then
			GUIWantChangeModel(v1)
		else
			GUIOpen()
		end
		return true
	end
end


concommand.Add(Tag..'_cmd',function(_,_,args,line)
	if not line then
		chat.AddText("[Outfitter] Something is messing with the concommand library (outdated addon?)")
		line=args[1]
	end
	if line:find"https?:$" then
		MsgC(Color(255,155,111,255),'Invalid usage! ',Color(255,240,240,255),'Please quote the URL. Example: outfitter "https://steamcommunity.com/sharedfiles/filedetails/?id=1234"\n')
		return
	end
	if args and args[1]then
		local n = UrlToWorkshopID(line)
		if n then
			args={n}
		end
	end
	Command('outfit',unpack(args))
end)

concommand.Add(Tag,function(_,_,args,line)
	if not line then
		chat.AddText("[Outfitter] Something is messing with the concommand library (outdated addon?)")
		line=args[1]
	end
	if line:find"https?:$" then
		MsgC(Color(255,155,111,255),'Invalid usage! ',Color(255,240,240,255),'Please quote the URL. Example: outfitter "https://steamcommunity.com/sharedfiles/filedetails/?id=1234"\n')
		return
	end
	if args and args[1]then
		local n = UrlToWorkshopID(line)
		if n then
			args={n}
		end
	end
	
	Command(Tag,unpack(args))
end)

hook.Add("ChatCommand",Tag,function(com,v1)
	return Command(com,v1)
end)

concommand.Add("outfitter_bodygroups_list",function(pl,_,_,mdl)
	if not mdl or mdl:Trim()=="" then
		mdl = pl:GetModel()
	end
	
	MsgN("Listing bodygroups of ",mdl)
	local ok,mdl = pcall(mdlinspect.Open,mdl)
	if not ok then print(mdl) return end
	
	local t = mdl:BodyParts()
	MsgN"================"
	local found
	for i,dat in next,t do
		found=true
		if dat.nummodels and dat.nummodels>1 then
			Msg(' '..tostring(dat.nummodels)..' groups  |  ')
			print(dat.name)
		else
			Msg(' No groups |  ')
			print(dat.name)
		end
		
	end
	if not found then print"No bodygroups??" end
	MsgN"================"
end)

concommand.Add("outfitter_skin_set",function(pl,cmd,args,line)
	n = tonumber(args[1] or 1) or 1
	RequestSkin(n)
	pl.outfitter_skin = n
end)


concommand.Add("outfitter_bodygroups_set",function(pl,cmd,args,line)
	if not line then
		chat.AddText("[Outfitter] Something is messing with the concommand library (outdated addon?)")
		line=args[1]
	end
	if line:Trim()=="" then 
		print("Usage: outfitter_bodygroups_set HeadAttachment=0,Backpack=2,Shorts=1")
		return
	end
	
	local t={}
	for entry in line:gmatch'[^%,]+' do
		local k,v = entry:match'([^%="]+)%=(%d%d?)' --TODO: parse a-z
		if k then
			t[k]=tonumber(v)
		end
	end
	
	local mdl = mdlinspect.Open(pl:GetModel())
	local bodyparts = mdl:BodyParts()
	local bp = mdlinspect.BodyPartBuilder(bodyparts,0)

	print(table.ToString(t))

	pl.outfitter_bodygroups = {}
	--pl.outfitter_skin = 1

	for k,v in next,t do
		local ok,a,b,c = bp:Set(k,v)

		if ok then
			pl.outfitter_bodygroups[k] = v
		else
			Msg("[Set Bodygroup] Failed setting ",k,": ")print(b)
		end
	end

	pl:SetBodyGroupData(bp:GetValue())
end)


CWHITE = Color(255,255,255,255)
CBLACK = Color(0,0,0,0)
local ns = 0
function UIError(...)
	dbgn(2,...)
	local t= {Color(200,50,10),'[Outfitter ERROR] ',CWHITE,...}
	local now = RealTime()
	if ns<now then
		ns=now + 1
		SOUND("common/warning.wav")
	end
	local t2={}
	for i=1,select('#',...) do
		local v=select(i,...)
		v=tostring(v) or "no value"
		t2[i]=v
	end
	local str = table.concat(t2,' ')
	
	notification.AddLegacy( str, NOTIFY_ERROR, 4 )
	chat.AddText(CWHITE,unpack(t))
end

local ns = 0
function UIMsg(...)
	local t= {Color(50,200,10),'[Outfitter] ',CWHITE,...}
	local now = RealTime()
	if ns<now then
		ns=now + 1
		SOUND("weapons/grenade/tick1.wav")
	end
	chat.AddText(unpack(t))
end

local mdllist
local handslist
local chosen_download_info
local tried_mounting
local mount_path
local chosen_mdl
local mdllist_extra
function UIGetMDLList()
	return mdllist
end

function UIGetMDLListExtra()
	return mdllist_extra
end

function UITriedMounting()
	return tried_mounting
end
function UIGetChosenMDL()
	return chosen_mdl
end
function UIGetWSID()
	return tonumber(chosen_download_info)
end
function UIGetDownloadInfo()
	return not tonumber(chosen_download_info) and chosen_download_info
end

function UIGetDownloadInfoX()
	return chosen_download_info
end

function UICancelAll()
	UIMsg"Unsetting everything"
	
	mdllist = nil
	mdllist_extra = nil
	chosen_download_info = nil
	mount_path = nil
	tried_mounting = nil
	chosen_mdl = nil
	
	RemoveOutfit()
	EnforceHands()
	UIClearBodyGroupData()
	UIClearSkin()
end

function UIClearBodyGroupData()
	LocalPlayer():SetBodyGroupData(0)
end
function UIClearSkin()
	LocalPlayer().outfitter_skin = 1
	RequestSkin(1)
end

function UIBroadcastMyOutfit()
	 
	local mdl,wsid = BroadcastMyOutfit()
	if mdl then
		SOUND"ui/item_robot_arm_pickup.wav"
	else
		SOUND"ui/item_robot_arm_drop.wav"
	end
	return mdl,wsid
end

local relay_opengui
function UIChangeModelToID(n,opengui)

	if co.make(n,opengui) then return end
	
	dbg("UIChangeModelToID",n)
	
	UIClearBodyGroupData()
	UIClearSkin()

	chosen_mdl = nil
	
	if not chosen_download_info then
		if opengui then GUIOpen() end
		return UIError"Type only !outfit first to choose workshop addon"
	end
	if not mdllist or #mdllist==0 then
		if opengui then GUIOpen() end
		return UIError"No models to choose from"
	end
	local mdl = mdllist[n]
	if not mdl then
		if opengui then GUIOpen() end
		return UIError"Invalid model index"
	end
	
	assert(mount_path,"mount_path missing for "..tostring(chosen_download_info))
	local ok,err = coMountWS( mount_path )

	if not ok then
		if opengui then GUIOpen() end
		return UIError("The workshop addon could not be mounted: "..tostring(err))
	end
	
	assert(mdl.Name)
	
	chosen_mdl = n
	relay_opengui = opengui
	
	-- returns instantly, but should be instant anyway
	OnChangeOutfit(LocalPlayer(),mdl.Name,chosen_download_info)
	dbg("EnforceHands?",ShouldHands(),n,mdllist[2]==nil,handslist,handslist and handslist[1])
	if n==1 and nil==mdllist[2] and handslist and next(handslist)~=nil and ShouldHands() then
		local _,entry = next(handslist)
		EnforceHands(entry.Name)
	else
		EnforceHands()
	end
		
end

local silent_apply_mdl
function UISetSilentApplyModel(mdl)
	silent_apply_mdl = mdl
end
hook.Add("OutfitApply",Tag,function(pl,mdl)
	
	if pl==LocalPlayer() and mdl then
		local opengui = relay_opengui
		relay_opengui=false
		
		if NOUI then return end
		
		notification.AddLegacy( "Outfit changed!", NOTIFY_UNDO, 2 )
		SOUND( GENERIC )
		if silent_apply_mdl ~= mdl then
			UIMsg"Write '!outfit send' to send this outfit to everyone"
		end
		silent_apply_mdl = nil
		if opengui then
			GUIOpen()
		end
		
	end
end)

function UIChoseWorkshop(wsid,opengui)
	assert(tonumber(wsid))
	
	if co.make(wsid,opengui) then return end
	
	mdllist = nil
	chosen_download_info = nil
	mount_path = nil
	tried_mounting = nil
	chosen_mdl = nil
	
	SetUIFetching(wsid,true)
		co.sleep(.5)
			local path,err,err2 = coFetchWS( wsid ) -- also decompresses
		co.sleep(.2)
	SetUIFetching(wsid,false,not path and (err and tostring(err) or "ОШИБКА?"))
	
	if not path then
		dbg("UIChoseWorkshop",wsid,"FetchWS failed:",err,err2)
		if opengui then GUIOpen() end
		return UIError("Download failed for workshop "..wsid..": "..tostring(err~=nil and tostring(err) or GetLastMountErr and GetLastMountErr()))
	end
	co.sleep(.2)
	
	local mdls,extramodelinfos,err = GMAPlayerModels( path )
	--PrintTable(mdls)
	
	if not mdls and extramodelinfos=='notgma' then
		dbgn(2," TestLZMA(",path,") ==", ("%q"):format(file.Read(path,'GAME'):sub(1,14)),TestLZMA(path) )
	end
	if not mdls and extramodelinfos=='notgma' and TestLZMA(path) then
		local newpath,extramodelinfos = coDecompress(path)
		if not newpath then
			if opengui then GUIOpen() end
			return UIError("Download failed for workshop "..wsid..": "..tostring(extramodelinfos~=nil and tostring(extramodelinfos) or GetLastMountErr and GetLastMountErr())) 
		end
		path = newpath
		
		-- retry --
		mdls,extramodelinfos,err = GMAPlayerModels( path )
		-----------
	end
	
	
	if not mdls then
		dbge("UIChoseWorkshop",wsid,"GMAPlayerModels failed for:",extramodelinfos,err)
		notification.AddLegacy( '[Outfitter] '..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos), NOTIFY_ERROR, 2 )
		if opengui then GUIOpen() end
		return UIError("Parsing workshop addon "..wsid.." failed: "..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos))
	end
	
	local ok,err = GMABlacklist(path)
	if not ok then
		if opengui then GUIOpen() end
		return UIError("OUTFIT BLOCKED: "..tostring(err=="oversize vtf" and "Contains too big textures" or err))
	end
	
	if not mdls[1] then
		dbg("UIChoseWorkshop","GMAPlayerModels",wsid,"no valid models!?")
		
		if opengui then GUIOpen() end
		
		UIError("Workshop addon "..wsid.." has no valid playermodels")
		if extramodelinfos and istable(extramodelinfos) and extramodelinfos.discards and next(extramodelinfos.discards) then
			for mdl,dat in next,extramodelinfos.discards or {} do
				mdl = MDLToUI(mdl)
				if dat.error_vvd then
					UIError(mdl,":",tostring(TranslateError(dat.error_vvd)))
				elseif dat.error_player then
					UIError(mdl,":",tostring(TranslateError(dat.error_player)))
				end
			end
		end
		
	end
	
	co.sleep(.2)
	
	if mdls[2] then
		UIMsg("Models:")
		for k,mdl in next,mdls do
			UIMsg(" "..k..". "..tostring(mdl and MDLToUI(mdl.Name)))
		end
	elseif mdls[1] then
		UIMsg("Got model: "..tostring(MDLToUI(mdls[1].Name)))
	end
	
	chosen_download_info = wsid
	mdllist = mdls
	mdllist_extra = extramodelinfos
	handslist = extramodelinfos.hands
	mount_path = path
	
	if mdls[2] then
		UIMsg"Write !outfit <model number> to choose a model"
		if opengui then GUIOpen() end
	else
		UIChangeModelToID(1,opengui)
	end
	

end

function UIChoseHTTPGMA(download_info,opengui)
	if co.make(download_info,opengui) then return end
	assert(not tonumber(download_info))

	mdllist = nil
	chosen_download_info = nil
	mount_path = nil
	tried_mounting = nil
	chosen_mdl = nil
	
	local id = URLFilename(download_info) or "httpgma:"..util.CRC(download_info)

	SetUIFetching(id,true)
		co.sleep(.1)
			local data,err,err2 = coFetchGMA( download_info )
		co.sleep(.1)
	SetUIFetching(id,false,not data and (err and tostring(err) or "ОШИБКА?"))
	if not data then
		dbg("UIChoseHTTPGMA",id,"FetchWS failed:",err,err2)
		if opengui then GUIOpen() end
		return UIError("Download failed for workshop "..id..": "..tostring(err~=nil and tostring(err) or GetLastMountErr and GetLastMountErr()))
	end
	co.sleep(.2)
	
	local path = data.path
	local mdls,extramodelinfos,err = GMAPlayerModels( path )
	--PrintTable(mdls)
	
	if not mdls and extramodelinfos=='notgma' then
		dbgn(2," TestLZMA(",path,") ==", ("%q"):format(file.Read(path,'GAME'):sub(1,14)),TestLZMA(path) )
	end
	if not mdls and extramodelinfos=='notgma' and TestLZMA(path) then
		local newpath,extramodelinfos = coDecompress(path)
		if not newpath then
			if opengui then GUIOpen() end
			return UIError("Download failed for workshop "..id..": "..tostring(extramodelinfos~=nil and tostring(extramodelinfos) or GetLastMountErr and GetLastMountErr())) 
		end
		path = newpath
		
		-- retry --
		mdls,extramodelinfos,err = GMAPlayerModels( path )
		-----------
	end
	
	
	if not mdls then
		dbge("UIChoseHTTPGMA",id,"GMAPlayerModels failed for:",extramodelinfos,err)
		notification.AddLegacy( '[Outfitter] '..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos), NOTIFY_ERROR, 2 )
		if opengui then GUIOpen() end
		return UIError("Parsing addon "..id.." failed: "..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos))
	end
	
	local ok,err = GMABlacklist(path)
	if not ok then
		if opengui then GUIOpen() end
		return UIError("OUTFIT BLOCKED: "..tostring(err=="oversize vtf" and "Contains too big textures" or err))
	end
	
	if not mdls[1] then
		dbg("UIChoseHTTPGMA","GMAPlayerModels",id,"no valid models!?")
		
		if opengui then GUIOpen() end
		
		UIError("Workshop addon "..id.." has no valid playermodels")
		if extramodelinfos and istable(extramodelinfos) and extramodelinfos.discards and next(extramodelinfos.discards) then
			for mdl,dat in next,extramodelinfos.discards or {} do
				mdl = MDLToUI(mdl)
				if dat.error_vvd then
					UIError(mdl,":",tostring(TranslateError(dat.error_vvd)))
				elseif dat.error_player then
					UIError(mdl,":",tostring(TranslateError(dat.error_player)))
				end
			end
		end
		
	end
	
	co.sleep(.2)
	
	if mdls[2] then
		UIMsg("Models:")
		for k,mdl in next,mdls do
			UIMsg(" "..k..". "..tostring(mdl and MDLToUI(mdl.Name)))
		end
	elseif mdls[1] then
		UIMsg("Got model: "..tostring(MDLToUI(mdls[1].Name)))
	end
	
	chosen_download_info = download_info
	mdllist = mdls
	mdllist_extra = extramodelinfos
	handslist = extramodelinfos.hands
	mount_path = path
	
	if mdls[2] then
		UIMsg"Write !outfit <model number> to choose a model"
		if opengui then GUIOpen() end
	else
		UIChangeModelToID(1,opengui)
	end
	

end





-- autowear --



function SetAutowear()
	local pl = LocalPlayer()
	
	local mdl,wsid,skin,bodygroup = pl:OutfitInfo()
	
	local t = {mdl=mdl,wsid=wsid,skin=skin,bodygroup=bodygroup,setbodygroupdata = pl:GetBodyGroupData(),hands = pl.outfitter_hands}
	
	
	if mdl then
		util.SetPData("0",Tag..'_autowear',json.encode(t))
		UIMsg("Autowear ON")
	else
		util.RemovePData("0",Tag..'_autowear')
		UIMsg("Autowear OFF")
	end

end

			
local oversized = {}
function coUIOversizeMsg(pl,wsid)

	
	if oversized[wsid] then return end
	oversized[wsid] = true
	
	local fileinfo = co_steamworks_FileInfo(wsid)
	
	local maxsz = outfitter_maxsize:GetFloat()
	maxsz = maxsz*1000*1000
	maxsz = string.NiceSize(maxsz)
	local szstr=""
	if fileinfo and istable(fileinfo) and fileinfo.size then
		szstr = ("(%s) "):format(string.NiceSize(fileinfo.size or 0))
	end
	
	UIMsg("The outfit of ",pl,(" is too big %saccording to your settings (%s) so it was not mounted!"):format(szstr,maxsz))

end



-- This is a horrible hack because of forethought was lacking when the rest of the code was made
-- duplicated from two different functions, etc
function coDoAutowear()
	local dat = util.GetPData("0",Tag..'_autowear')
	if not dat or dat=="" or dat=="nil" then return end
	local t = json.decode(dat)
	if not t then return end
	if not t.mdl then return end
	if t.mdl=="" then return end
	
	local mdl,wsid,skin,bodygroup,setbodygroupdata = t.mdl,t.wsid,t.skin,t.bodygroup,t.setbodygroupdata
	local hands = t.hands
	
	if not mdl then return end
	
	dbg("Autowearing",mdl,"from",wsid,"setbodygroupdata=",setbodygroupdata)

	SetUIFetching(wsid,true)
		co.sleep(.5)
			local path,err,err2 = coFetchWS( wsid )
		co.sleep(.2)
	SetUIFetching(wsid,false,not path and (err and tostring(err) or "ОШИБКА?"))
	
	if not path then
		dbg("coDoAutowear",wsid,"FetchWS failed:",err,err2)
		if opengui then GUIOpen() end
		return UIError("Download failed for workshop "..wsid..": "..tostring(err~=nil and tostring(err) or GetLastMountErr and GetLastMountErr()))
	end
	co.sleep(.2)

	local mdl_exists = file.Exists(mdl,'GAME')
	local skip_additional_checks = mdl_exists
	if not IsUGCFilePath(path) then
		skip_additional_checks = false
	end
	
	local mdls,extramodelinfos,err
	
	if not skip_additional_checks then		
		mdls,extramodelinfos,err = GMAPlayerModels( path )
		
		if not mdls and extramodelinfos=='notgma' then
			dbgn(2," TestLZMA(",path,") ==", ("%q"):format(file.Read(path,'GAME'):sub(1,14)),TestLZMA(path) )
		end
		if not mdls and extramodelinfos=='notgma' and TestLZMA(path) then
			local newpath,extramodelinfos = coDecompress(path)
			if not newpath then
				if opengui then GUIOpen() end
				return UIError("Download failed for workshop "..wsid..": "..tostring(extramodelinfos~=nil and tostring(extramodelinfos) or GetLastMountErr and GetLastMountErr())) 
			end
			path = newpath
			
			-- retry --
			mdls,extramodelinfos,err = GMAPlayerModels( path )
			-----------
		end
		
	
		if not mdls then
			dbge("coDoAutowear",wsid,"GMAPlayerModels failed for:",extramodelinfos,err)
			notification.AddLegacy( '[Outfitter] '..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos), NOTIFY_ERROR, 2 )
			return UIError("Parsing workshop addon "..wsid.." failed: "..tostring(extramodelinfos=="nomdls" and "no valid models found" or extramodelinfos))
		end
		
		local ok,err = GMABlacklist(path)
		if not ok then
			return UIError("OUTFIT BLOCKED: "..tostring(err=="oversize vtf" and "Contains too big textures" or err))
		end
		
		if not mdls[1] then
			dbge("coDoAutowear","GMAPlayerModels",wsid,"no models!?")
			return UIError("Workshop addon "..wsid.." has no playermodels")
		end
	
	end
	
	co.sleep(.2)
	
	local chosen_download_info = wsid
	local handslist = extramodelinfos and extramodelinfos.hands
	local mount_path = path
	
	if not skip_additional_checks then
		assert(mount_path,"mount_path missing for "..tostring(chosen_download_info))
		local ok,err = coMountWS( mount_path )

		if not ok then
			return UIError("The workshop addon could not be mounted: "..tostring(err))
		end
	end
	
	assert(mdl)
	
	UISetSilentApplyModel(mdl)
	
	-- returns instantly, but should be instant anyway
	OnChangeOutfit(LocalPlayer(),mdl,chosen_download_info)
	
	-- cannot enforce hands without crashing at the moment
	dbg("coDoAutowear","EnforceHands",ShouldHands(),next(handslist or {}))
	if next(handslist or {})~=nil and ShouldHands() then
		local _,entry = next(handslist)
		EnforceHands(entry.Name)
	else
		EnforceHands()
	end
	
	--LocalPlayer():SetWantOutfit(mdl,wsid,skin,bodygroup)
	
	if setbodygroupdata and setbodygroupdata~=0 then
		dbg("SetBodyGroupData",setbodygroupdata)
		LocalPlayer():SetBodyGroupData(setbodygroupdata)
	end
	if skin then
		skin = tonumber(skin or 1) or 1
		LocalPlayer().outfitter_skin = skin
		RequestSkin(skin)
	end
	BroadcastMyOutfit()

	return true
end

local warned
function UIWarnDownloadFailures(wsid)
	wsid=tostring(wsid or "0")
	SetUIFetching(wsid,false,"ВЫШЛО ВРЕМЯ")
	SOUND("common/warning.wav")
	if not warned then
		warned=true
		chat.AddText(Color(255,100,100,255),"!!! ALERT !!! ",Color(255,144,144,255),"Workshop download may have timed out (a steam bug). Open downloads tab in steam and check if GarrysMod workshop updating has paused, try resuming it. More info: https://steamcommunity.com/workshop/filedetails/discussion/882463775/3096727865549498026/ Other downloads will not resume before this is done.")
	end	
end

--addons/module_logs/lua/plogs/console.lua:
local color_white = Color(245,245,245)

net.Receive('plogs.Console', function()
	local id 	= net.ReadString()
	local str 	= net.ReadString()

	local log = plogs.types[id]
	if log and not log.preventNetwork then
		MsgC(log.Color, '[' .. id .. ' | ' .. os.date('%I:%M:%S', os.time()) ..  ']', color_white, str .. '\n')
	end
end)
--addons/module_donate/lua/autorun/pointshop.lua:
if SERVER then 
	AddCSLuaFile() 
	include "pointshop/sv_init.lua" 
	include('autorun/server/donate.lua')
	AddCSLuaFile('autorun/client/donate.lua')
end
if CLIENT then 
	include "pointshop/cl_init.lua" 
	include('autorun/client/donate.lua')
end

PS:Initialize()
--addons/module_donate/lua/pointshop/sh_config.lua:
PS.Config = {}

-- Edit below

PS.Config.Comission = 0.1

PS.Config.CommunityName = "Магазин | X2 Пополнение"

PS.Config.DataProvider = 'mysql'

PS.Config.Branch = 'https://raw.github.com/adamdburton/pointshop/master/' -- Master is most stable, used for version checking.
PS.Config.CheckVersion = false -- Do you want to be notified when a new version of Pointshop is avaliable?

PS.Config.ShopKey = 'F1' -- F1, F2, F3 or F4, or blank to disable
PS.Config.ShopCommand = '' -- Console command to open the shop, set to blank to disable
PS.Config.ShopChatCommand = '/donate' -- Chat command to open the shop, set to blank to disable

PS.Config.NotifyOnJoin = true -- Should players be notified about opening the shop when they spawn?

PS.Config.PointsOverTime = false -- Should players be given points over time?
PS.Config.PointsOverTimeDelay = 90 -- If so, how many minutes apart?
PS.Config.PointsOverTimeAmount = {
	headadmin = 5,
	senioradmin = 3,
	admin = 2,
}

PS.Config.AdminCanAccessAdminTab = false -- Can Admins access the Admin tab?
PS.Config.SuperAdminCanAccessAdminTab = true -- Can SuperAdmins access the Admin tab?

PS.Config.CanPlayersGivePoints = true -- Can players give points away to other players?
PS.Config.DisplayPreviewInMenu = true -- Can players see the preview of their items in the menu?

PS.Config.PointsName = '₽' -- What are the points called?
PS.Config.SortItemsBy = 'Price' -- How are items sorted? Set to 'Price' to sort by price. name

-- Edit below if you know what you're doing

PS.Config.CalculateBuyPrice = function(ply, item)
	-- You can do different calculations here to return how much an item should cost to buy.
	-- There are a few examples below, uncomment them to use them.

	-- Everything half price for admins:
	-- if ply:SteamID() == "STEAM_0:0:88099997" then return math.Round(item.Price * 0.5) end

	-- 25% off for the 'donators' group
	-- if ply:IsUserGroup('donators') then return math.Round(item.Price * 0.75) end

	return item.Price
end

PS.Config.CalculateSellPrice = function(ply, item)
	return 0
end

PS.Config.DonateButtonPressed = function()
	gui.OpenURL( "http://wayzer.ru/pay.php?steamid=" .. LocalPlayer():SteamID() )
end

--addons/module_donate/lua/pointshop/sh_player_extension.lua:
local Player = FindMetaTable('Player')

-- Because of the huge variaty of admin mods and their various ways of handling usergroups.
-- This had to be done..
function Player:PS_GetUsergroup()
	if ( self.EV_GetRank ) then return self:EV_GetRank() end
	if ( serverguard ) then return serverguard.player:GetRank(self) end
	-- add for each conflicting admin mod.

	return self:GetNWString('UserGroup')
end

function Player:PS_InventoryCount(item_id)
	local count = self.PS_Inventory[item_id]
	return count and count > 0 and count or 0
end
--addons/module_donate/lua/pointshop/items/cases/case_gift.lua:
ITEM.Name = 'Новогодний подарок'
ITEM.Description = [[
Что можно выбить?

1 рубль
3 рубля
5 рублей
10 рублей
15 рублей
25 рублей
35 рублей
45 рублей
50 рублей
100 рублей]]

ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_free.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Найди этот кейс под елкой"
end

function ITEM:OnUse(ply)
	ply:OpenCrate('case_gift')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_spider.lua:
ITEM.Name = 'Жуткий Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- Обложка могильный мрак\n- Обложка тыквенный переполох\n- Компаньон призрак\n- Компаньон смерть\n- Пистолет Crimson"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_spider.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
ITEM.Hidden = false

function ITEM:OnUse(ply)
	ply:OpenCrate('case_spider')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/companions/cube.lua:
ITEM.Name = 'Куб'
ITEM.Price = 349
ITEM.Model = 'models/maxofs2d/cube_tool.mdl'
--ITEM.Material = Material( "data/wimages/skull.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cube.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/katana.lua:
ITEM.Name = 'Катана'
ITEM.Price = 349
ITEM.Model = 'models/weapons/w_hiltless.mdl'
--ITEM.Material = Material( "data/wimages/superball.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/katana.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.z = plyAng.z - 90
	plyAng.y = plyAng.y - 90
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-10, 1 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) - 20), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/penguin.lua:
ITEM.Name = 'Пингвин'
ITEM.Price = 299
ITEM.Model = 'models/roblox/snowboarding_penguin.mdl'
--ITEM.Material = Material( "data/wimages/dog.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/penguin.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y - 120
--	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/scanner.lua:
ITEM.Name = 'Космическое устройство ( День космонавтики )'
ITEM.Price = 349
ITEM.Model = 'models/Combine_Scanner.mdl'
--ITEM.Material = Material( "data/wimages/scanner.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/scanner.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/cover/cover_line.lua:
ITEM.Name = 'Абстрактные линии'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_line.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_line.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_mrak.lua:
ITEM.Name = 'Могильный мрак'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_mrak.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_mrak.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_night.lua:
ITEM.Name = 'Лазурная полночь'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_night.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_night.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_snegovik.lua:
ITEM.Name = 'Дух нового года'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_snegovik.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_snegovik.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_spider.lua:
ITEM.Name = 'Городской герой'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_spider.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_spider.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_sunline.lua:
ITEM.Name = 'Луч надежды'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_sunline.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_sunline.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_sviter.lua:
ITEM.Name = 'Теплый свитер'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_sviter.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_sviter.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/cover/cover_visage.lua:
ITEM.Name = 'Искаженный лик'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_visage.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_visage.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/moneypacks/10kk.lua:
ITEM.Name = '10,000,000 $'
ITEM.Price = 399
--ITEM.Material = Material( "data/wimages/moneybox.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moneybox.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:addMoney( 10000000 )
end

--addons/module_donate/lua/pointshop/items/moneypacks/5kk.lua:
ITEM.Name = '5,000,000 $'
ITEM.Price = 199
--ITEM.Material = Material( "data/wimages/moneybox.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moneybox.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:addMoney( 5000000 )
end

--addons/module_donate/lua/pointshop/items/other/outfit_axe.lua:
-- только на маньяке

ITEM.Name = 'Топор за спиной'
ITEM.Price = 999
ITEM.Description = 'Косметика для всех профессий'
ITEM.Model = 'models/props/cs_militia/axe.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bp.png'
ITEM.Bone = 'ValveBiped.Bip01_Spine2'
ITEM.NoScroll = true
ITEM.Hidden = true
--ITEM.Job = {['maniak'] = true}
--ITEM.NoDrawDisguise = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	pos = pos + (ang:Right() * 4) + (ang:Up() * 1) + (ang:Forward() * 1)
	ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Up(), 60)

	return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/ranks/dadmin_3m.lua:
ITEM.Name = 'DAdmin на 3 месяца'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования \n - Может заморозить игрока \n - Может выдавать оружие \n - Может поджечь игрока \n - Может дать регдолл игроку"
ITEM.Price = 299
--ITEM.Material = Material( "data/wimages/admin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/admin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DAdmin"
ITEM.Time = 60 * 60 * 24 * 30 * 3

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dmoderator_3m.lua:
ITEM.Name = 'DModerator на 3 месяца'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет доступ к функции бана/кика \n - Имеет доступ к функциям джайла \n - Может дать мут/гаг игроку \n - Имеет доступ к функции полета/бессмертия/невидимости \n - Имеет функцию бана/выдачи профессии \n - Имеет доступ к функции телепортирования"
ITEM.Price = 159
--ITEM.Material = Material( "data/wimages/moder_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/moder_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DModerator"
ITEM.Time = 60 * 60 * 24 * 30 * 3

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/vip_navsegda.lua:
ITEM.Name = 'VIP навсегда'
ITEM.Description = " - Имеет доступ ко всем вип профессиям \n - Имеет доступ ко всем VIP предметам \n - Дополнительный кликер"
ITEM.Price = 490
--ITEM.Material = Material( "data/wimages/vip_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vip_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "VIP"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/weapons/falchion_knife.lua:
ITEM.Name = 'Нож Falchion'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_falchion"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/huckleberry.lua:
ITEM.Name = 'Huckleberry'
ITEM.Description = 'Раздавай праздничный свинец под звон новогодних салютов!'
ITEM.Price = 999
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/huckleberry.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "wrp_weapon_huckleberry"
ITEM.Hidden = true


function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/smartpistol.lua:
ITEM.Name = 'Smart Pistol на месяц'
ITEM.Description = 'Пистолет из игры Titanfall с автоматическим прицеливанием и высокой скорострельностью'
ITEM.Price = 249
--ITEM.Material =  Material( "data/wimages/smartpistol.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/smartpistol.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
ITEM.WeaponClass = "mp_weapon_smart_pistol"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/smartpistol_navsegda.lua:
ITEM.Name = 'Smart Pistol навсегда'
ITEM.Description = 'Пистолет из игры Titanfall с автоматическим прицеливанием и высокой скорострельностью'
ITEM.Price = 999
--ITEM.Material =  Material( "data/wimages/smartpistol.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/smartpistol.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "mp_weapon_smart_pistol"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/wowozela.lua:
ITEM.Name = 'Вовозелка на месяц'
ITEM.Description = "Вовозелка\n- Позволяет издавать различные звуки с разноцветным эффектом\n- Еще ты можешь загрузить любые звуки из интернета в вовозелку\n- Даже свой голос с определенными фразами ;)"
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/wowozela.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/wowozela.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
ITEM.WeaponClass = "wowozela"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/ent_top/lua/autorun/ray_scoresheet.lua:
scoresheet = scoresheet or {}
scoresheet.data = {}

function scoresheet:register( tab )
	for k,v in pairs( scoresheet.data ) do
		if ( v.UniqueID == tab.UniqueID ) then
			scoresheet.data[ k ] = nil
		end
	end
	
	scoresheet.data[ #scoresheet.data + 1 ] = tab
	
	scoresheet:setup( tab )
end

function scoresheet:setup( tab )
	local ENT = {}
	
	ENT.Type = "anim"
	ENT.Base = "score_base"
	ENT.PrintName = "Score - "..tab.Name
	ENT.Author = "RayChamp"
	ENT.Category = "Запрещено"
	ENT.Spawnable = true
	
	if ( SERVER ) then
		ENT.Fetch = tab.Fetch
	else
		ENT.DrawFunc = tab.Draw
		ENT.TitleName = tab.Name
		ENT.HeaderColor = tab.HeaderColor
	end
	
	scripted_ents.Register( ENT, tab.EntName )
end

local files, folders = file.Find( "scoresheet/sheets/*", "LUA" )

for k,v in pairs( folders ) do
	if ( SERVER ) then
		AddCSLuaFile( "scoresheet/sheets/"..v.."/config.lua" )
		AddCSLuaFile( "scoresheet/sheets/"..v.."/shared.lua" )
	end
	
	include( "scoresheet/sheets/"..v.."/config.lua" )
	include( "scoresheet/sheets/"..v.."/shared.lua" )
end
--addons/ent_top/lua/scoresheet/sheets/clans/shared.lua:
local SHEET = {}

SHEET.UniqueID = "top_10_clans"

SHEET.Name = scoresheet.clans_header_text
SHEET.EntName = "score_clans"
SHEET.HeaderColor = scoresheet.clans_header_text_color

SHEET.Fetch = function(callback)
	MySQLite.query('SELECT * FROM dorgs_orgs ORDER BY money DESC LIMIT 5', function(d)
        local data = {}
        local usedClans = {}
        for _, v in pairs(d or {}) do
        	if not v.name then continue end
            if usedClans[v.name] then continue end

            table.insert(data, v)
            usedClans[v.name] = true
        end
        callback(data)
    end)
end

local build = Material( 'icon16/building.png' )

SHEET.Draw = function( ent, data )

    local ply = LocalPlayer()
    local distSqr = 1000000
    
    if ply:GetPos():DistToSqr( ent:GetPos() ) > distSqr then return end

	local y_pos = 30
	
	local x_pos = 0
	local cnt = 0
	
	for place, row in pairs( data ) do
		local row_header = "#"..place.." - "..row.name
		local row_text = DarkRP.formatMoney( tonumber( row.money ) )
		
		surface.SetFont( scoresheet.money_font_header )
		local textW = surface.GetTextSize( row_header )
		
			surface.SetDrawColor( color_white )
		if row.AvatarMaterial and row.AvatarMaterial ~= "" then	
			surface.SetMaterial( row.AvatarMaterial )
		else
			surface.SetMaterial( build )
		end
			surface.DrawTexturedRect( x_pos, y_pos - 5, 30, 30 )
		
		draw.SimpleText( row_header, scoresheet.clans_font_header, x_pos + 35, y_pos, color_white )
		y_pos = y_pos + 20

	--	draw.SimpleText( row.description, 'Default', x_pos, y_pos, color_white )
	--	y_pos = y_pos + 25

		draw.SimpleText( row_text, scoresheet.clans_font_header, x_pos + 300, y_pos - 20, color_white )

		y_pos = y_pos + 25
		
		cnt = cnt + 1
		
		if ( cnt >= scoresheet.clans_cut_at_row_count ) then
			x_pos = 250
			y_pos = 20
			cnt = 0
		end
	end
end 

scoresheet:register( SHEET )
--addons/ent_top/lua/scoresheet/sheets/money/config.lua:
scoresheet.money_header_text = "Forbes | Список богатых жителей" // the header text
scoresheet.money_header_text_color = Color( 50, 50, 255 ) // the color of the header bg

scoresheet.money_max_count = 10 // how many people does it show?
scoresheet.money_cut_at_row_count = 5 // how many rows of people untill it cuts to a new line? ( 5 seems to be max )

scoresheet.money_first_place_icon = Material( "icon16/coins.png" ) // the icon next to #1 name

scoresheet.money_font_header = "score_row_header" // the font used for the header of the row, # number - name
scoresheet.money_font_text = "score_row_text" // font used for the text of the row, $ money
--addons/module_rewards/lua/rewards/cl_core.lua:
local card = {}

function card:Init()
	self.image = vgui.Create('DImage', self)
	
	self.title = vgui.Create('DLabel', self)
	self.title:SetAutoStretchVertical(true)
	self.title:SetFont('Trebuchet24')
	self.title:SetColor(color_white)
	
	self.text = vgui.Create('DLabel', self)
	self.text:SetAutoStretchVertical(true)
	self.text:SetFont('Trebuchet24')
	self.text:SetColor(color_white)
	
	self.btn = vgui.Create('DButton', self)
	self.btn:SetSize(170, 35)
	self.btn:SetFont('f4.main')
	self.btn:SetTextColor(color_white)
	self.btn.Paint = function( self, w, h )
		draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.buttonCol )
	end

	self.image:Dock(LEFT)

	self.title:Dock(TOP)
	self.text:Dock(TOP)
end

local gradient = Material("gui/center_gradient")

function card:Paint(w,h)
	draw.RoundedBox( 4, 0, 0, w, h, f4menu.col.bg)-- v.color )
	surface.SetMaterial( gradient )
	surface.SetDrawColor( f4menu.col.gradientCol )
	surface.DrawTexturedRect( 0, 0, w, h )
	draw.RoundedBox( 4, 1, 1, w - 2, h - 2, f4menu.col.secondcolor )
end

function card:PerformLayout()
	self.image:SetWide(self:GetTall() - 20)
	self.image:DockMargin(10,10,10,10)
		
	self.title:DockMargin(4, self:GetTall()/2 - 24, 0, 0)
	self.text:DockMargin(4, 0, 0, 0)
	
	self.btn:SetPos(self:GetWide() - 190, self:GetTall()/2 - 17.5)
end

function card:SetButtonText(str)
	self.btn:SetText(str)
end

function card:SetTitle(str)
	self.title:SetText(str)
end

function card:SetText(str)
	self.text:SetText(str)
end

function card:SetTextColor(col)
	self.text:SetColor(col)	
end

function card:SetImage(mat)
	self.image:SetMaterial(mat)
end

function card:SetCallback(f)
	self.btn.DoClick = f
end

vgui.Register('rewards_card', card, 'DPanel')

local panel_list
function rewards.loadF4Panel(tab, parent)
	if not f4menu then return notification.AddLegacy('Недоступно до завтра', 1, 5) end

	local pnl = vgui.Create('DPanel', parent)
	pnl:Dock(FILL)
	pnl.Paint = function(s,w,h)
		draw.RoundedBox(6, 1, 1, w - 2, h - 2, f4menu.col.secondcolor)
	end
	pnl:InvalidateParent(true)
	pnl:DockMargin(30, 30, 30, 30)
	pnl:DockPadding(25, 25, 25, 10)

	local lbl = vgui.Create('DLabel', pnl)
	lbl:Dock(TOP)
	lbl:SetAutoStretchVertical(true)
	lbl:SetFont('f4.main')
	lbl:SetTextColor(f4menu.col.text_inactive)
	lbl:SetText('Доступные бонусы')

	local bottom = vgui.Create('DIconLayout', pnl)
	bottom:Dock(BOTTOM)
	bottom:SetTall(35)
	
	panel_list = vgui.Create('DPanelList', pnl)
	panel_list:Dock(FILL)
	panel_list:DockMargin(0, 10, 0, 0)
	panel_list:EnableVerticalScrollbar( true )
	panel_list:DockPadding( 0, 5, 10, 0 )
	panel_list.VBar.Paint = function( s, w, h )
		draw.RoundedBox( 4, 3, 13, 8, h-24, f4menu.col.color_scroll)
	end
	panel_list.VBar.btnUp.Paint = function( s, w, h ) end
	panel_list.VBar.btnDown.Paint = function( s, w, h ) end
	panel_list.VBar.btnGrip.Paint = function( s, w, h )
		draw.RoundedBox( 4, 5, 0, 4, h+22, f4menu.col.color_scroll)
	end

	panel_list.Cards = {}

	for method, v in pairs(rewards.methods) do
		local card = panel_list:Add('rewards_card')
		card:Dock(TOP)
		card:SetTall(80)
		card:DockMargin(0,0,0,6)

		card:SetText(v.reward_text)
		card:SetButtonText(v.link_text)
		card:SetTitle(v.name)
		card:SetImage(v.icon or 'icon72/warning.png')
		card:SetTextColor(Color(0,180,0))
		card:SetCallback(function()
			if v.Link then v:Link() end
		end)

		panel_list.Cards[method] = card
	end

	REWARDS_CASE = panel_list:Add('rewards_card')
	REWARDS_CASE:Dock(TOP)
	REWARDS_CASE:SetTall(80)
	REWARDS_CASE:DockMargin(0,0,0,6)
	
	local remained = math.floor((7200 - LocalPlayer():GetUTimeSessionTime()) / 60)
	local condition = remained > 0
	
	REWARDS_CASE:SetText('Осталось '..(condition and remained or 0 )..' мин')
    REWARDS_CASE:SetButtonText('Забрать')
	REWARDS_CASE:SetTitle('Ежедневный кейс')
	REWARDS_CASE:SetImage('icon72/gift.png')
	REWARDS_CASE:SetCallback(function()
		net.Start('donate.dayreward')
		net.SendToServer()
	end)

/*	
	LINK_VK = vgui.Create('DButton', bottom)
	--LINK_VK:Dock(LEFT)
	--LINK_VK:DockMargin(60, pnl:GetTall() - 45,25,10)
	LINK_VK:SetTall(35)
	LINK_VK:SetWide(120)
	LINK_VK:SetText('ВКонтакте')
	LINK_VK:SetTextColor( Color( 255, 255, 255 ) )
	LINK_VK:SetFont( "f4.main" )
	LINK_VK.Paint = function( s, w, h )
		draw.RoundedBox( 4, 1, 1, w - 2, h - 2, Color( 89,125,163 ) )
	end
	LINK_VK.DoClick = function()
	    gui.OpenURL( "https://vk.com/rpwayzer" )
	end
	
	LINK_DS = vgui.Create('DButton', bottom)
	--LINK_DS:Dock(LEFT)
	--LINK_DS:DockMargin(0,pnl:GetTall() - 45,25,10)
	LINK_DS:SetTall(35)
	LINK_DS:SetWide(90)
	LINK_DS:SetText('Discord')
	LINK_DS:SetTextColor( Color( 255, 255, 255 ) )
	LINK_DS:SetFont( "f4.main" )
	LINK_DS.Paint = function( s, w, h )
		draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 114, 137, 218 ) )
	end
	LINK_DS.DoClick = function()
	    gui.OpenURL( "https://discord.gg/W6K5FgSNck" )
	end

	LINK_TG = vgui.Create('DButton', bottom)
	--LINK_TG:Dock(LEFT)
	--LINK_TG:DockMargin(0,pnl:GetTall() - 45,25,10)
	LINK_TG:SetTall(35)
	LINK_TG:SetWide(120)
	LINK_TG:SetText('Telegram')
	LINK_TG:SetTextColor( Color( 255, 255, 255 ) )
	LINK_TG:SetFont( "f4.main" )
	LINK_TG.Paint = function( s, w, h )
		draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 41, 169, 235 ) )
	end
	LINK_TG.DoClick = function()
	    gui.OpenURL( "https://t.me/s/rpwayzer" )
	end


	LINK_RULE = vgui.Create('DButton', bottom)
	--LINK_RULE:Dock(LEFT)
	--LINK_RULE:DockMargin(0,pnl:GetTall() - 45,25,10)
	LINK_RULE:SetTall(35)
	LINK_RULE:SetWide(120)
	LINK_RULE:SetText('Правила')
	LINK_RULE:SetTextColor( Color( 255, 255, 255 ) )
	LINK_RULE:SetFont( "f4.main" )
	LINK_RULE.Paint = function( s, w, h )
		draw.RoundedBox( 4, 2, 2, w - 4, h - 4, Color( 236, 113, 73 ) )
	end
	LINK_RULE.DoClick = function()
	    gui.OpenURL( "https://forum.wayzer.ru/d/2-pravila" )
	end
	
	LINK_CSS = vgui.Create('DButton', bottom)
	--LINK_CSS:Dock(LEFT)
	--LINK_CSS:DockMargin(0,pnl:GetTall() - 45,25,10)
	LINK_CSS:SetTall(35)
	LINK_CSS:SetWide(120)
	LINK_CSS:SetText('Контент CSS')
	LINK_CSS:SetTextColor( Color( 255, 255, 255 ) )
	LINK_CSS:SetFont( "f4.main" )
	LINK_CSS.Paint = function( s, w, h )
		draw.RoundedBox( 4, 2, 2, w - 4, h - 4, f4menu.col.buttonCol )
	end
	LINK_CSS.DoClick = function()
	    gui.OpenURL( "https://forum.wayzer.ru/d/3-kontent-counter-strike-source" )
	end
*/
	pnl.OnSelected = function()
		net.Start('rewards.getInfo')
		net.SendToServer()

		remained = math.floor((7200 - LocalPlayer():GetUTimeSessionTime()) / 60)
		condition = remained > 0

		REWARDS_CASE:SetText('Осталось '..(condition and remained or 0 )..' мин')
		
		timer.Simple(0, function()
			bottom:SetSpaceX((pnl:GetWide()-162*4-55)/3)
			bottom:Layout()
		end)
	end

	return pnl
end

rewards.materials = {}
local errorMat = Material('icon72/warning.png')

function rewards.imageURL(url, name, callback)
	if rewards.materials[url] then return callback(rewards.materials[url]) end

	http.Fetch(url, function(img)
		if img == nil or string.find(img, "<!DOCTYPE HTML>", 1, true) then return callback(errorMat) end

		file.Write(name, img)
		rewards.materials[url] = Material('../data/'..name, 'smooth noclamp')
		callback(rewards.materials[url])
		file.Delete(name)
	end)
end

net.Receive('rewards.getInfo', function()
	local data = net.ReadTable()

	for method, v in pairs(data) do
		local card = panel_list.Cards[method]
		if not IsValid(card) then continue end

		card.data = v

		local m = rewards.methods[method]
		if m.Update then m:Update(v, card) end
	end
end)

net.Receive('rewards.sendLink', function()
	local link = net.ReadString()
	gui.OpenURL(link)
	LocalPlayer():ChatPrint('Если у тебя отключен Steam оверлей, то вставь эту ссылку в свой браузер')
	LocalPlayer():ChatPrint(link)
end)

--addons/module_rewards/lua/rewards/methods/forum/shared.lua:
rewards.methods.forum.name = 'Форум'
rewards.methods.forum.reward_text = '$50.000 и 15₽'
rewards.methods.forum.link_text = 'Привязать'
--addons/module_rewards/lua/rewards/methods/vk/client.lua:
function rewards.methods.vk:Link()
    net.Start('rewards.linkMethod')
    net.WriteString('vk')
    net.SendToServer()
end

function rewards.methods.vk:Update(data, card)
    http.Fetch('https://api.vk.com/method/users.get?user_ids='..data.id..'&access_token='..data.data.access_token..'&fields=nickname,photo_200&v=5.131', function(b)
        local res = util.JSONToTable(b)
        if not res or not res.response then return end

        rewards.imageURL(res.response[1].photo_200, 'vkavatar.png', function(img)
            if not IsValid(card) then return end
            card:SetImage(img)
        end)
    end)
    
    if data.received then
        card:SetText('Награда получена')
        card:SetTextColor(Color(200,200,200))
		card:SetButtonText('Получено')
        card:SetCallback(wlib.func.blank)
    else
        card:SetButtonText('Проверить подписку')
        card:SetTextColor(color_black)
        card:SetCallback(function()
            net.Start('rewards.getInfo')
            net.SendToServer()
        end)
    end
end
--addons/model_santa/lua/autorun/santa_npc.lua:
local Category = "Neoz"


local NPC = { 	Name = "Santa", 
				Class = "npc_Breen",
				Model = "models/Jaanus/santa.mdl",
				Health = "999",
				KeyValues = { citizentype = 4 },
				Category = Category	}


list.Set( "NPC", "npc_santa", NPC )
--addons/module_outfitter/lua/autorun/setbodygroupdata.lua:
local Tag = 'BodyGroupData'


FindMetaTable"Player".SetBodyGroupData = SERVER and function(self, n)
	n=n>2^32 and 2^32 or n<0 and 0 or n
	self:SetSaveValue("SetBodyGroup", n)
end or function(self, n)
	n=n>2^32 and 2^32 or n<0 and 0 or n
	if self ~= LocalPlayer() then return end
	self[Tag] = n
	net.Start(Tag)
		net.WriteUInt(n or 0, 32)
	net.SendToServer()
end

-- TODO
FindMetaTable"Player".GetBodyGroupData = function(self)
	return self[Tag]
end

--addons/_smallscripts/lua/autorun/sh_collisison.lua:
 timer.Create("updateCollisions", 10, 0, function()

     for k,v in player.Iterator() do
         if v:GetCollisionGroup() ~= COLLISION_GROUP_WEAPON then
             v:SetCollisionGroup( COLLISION_GROUP_WEAPON )
         end
     end

end)

PS:Initialize()

local discountEnd = 1744822216


if os.time() > discountEnd then return end

if SERVER then
    timer.Create("donatemsg", 150, 0, function()
        PS.NotifyAll("Стартовал весенний боевой пропуск")
        PS.NotifyAll("Действует X2 пополнение!")
        PS.NotifyAll("Жми F1 или пиши /donate")
    end)
end


for item_id, ITEM in pairs(PS.Items) do
    ITEM.X2 = true
    --ITEM.DiscountEnd = discountEnd
end

--[[
for item_id, ITEM in pairs(PS.Items) do
    if ITEM.Category ~= "Кейсы" and ITEM.Category ~= "Обложки" and item_id ~= "patron_navsegda" then
        local percent = ITEM.Price * 0.50
        local cena = ITEM.Price - percent
        ITEM.OldPrice = ITEM.Price
        ITEM.Price = math.floor(cena)
        ITEM.DiscountEnd = discountEnd
    end

    if ITEM.Category == "Кейсы" or ITEM.Category == "Обложки" or item_id == "patron_navsegda" then
        local percent = ITEM.Price * 0.25
        local cena = ITEM.Price - percent
        ITEM.OldPrice = ITEM.Price
        ITEM.Price = math.floor(cena)
        ITEM.DiscountEnd = discountEnd
    end
end




for item_id, ITEM in pairs(PS.Items) do
    if ITEM.Category ~= "Кейсы" and ITEM.Category ~= "Обложки" and item_id ~= "patron_navsegda" then
        local percent = ITEM.Price * 0.60
        local cena = ITEM.Price - percent
        ITEM.OldPrice = ITEM.Price
        ITEM.Price = math.floor(cena)
        ITEM.DiscountEnd = discountEnd
    end

    if ITEM.Category == "Кейсы" or ITEM.Category == "Обложки" or item_id == "patron_navsegda" then
        local percent = ITEM.Price * 0.25
        local cena = ITEM.Price - percent
        ITEM.OldPrice = ITEM.Price
        ITEM.Price = math.floor(cena)
        ITEM.DiscountEnd = discountEnd
    end
end

--]]
--addons/module_donate/lua/pointshop/items/cases/case_butterfly.lua:
ITEM.Name = 'Секретный Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- 25 Рублей\n- 35 Рублей\n- 50 рублей\n- 100 рублей\n- Нож Бабочка"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_butterfly.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
--[[
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Введи промокод из чата, чтобы получить этот кейс"
end
--]]
function ITEM:OnUse(ply)
	ply:OpenCrate('case_butterfly')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_dollar.lua:
ITEM.Name = 'Долларовый кейс'
ITEM.Price = 19
ITEM.Description = "Что можно выбить?\n- 100.000$\n- 300.000$\n- 500.000$\n- 1.000.000$\n- 5.000.000$\n- 10.000.000$\n- 100.000.000$"
--ITEM.Material =  Material( "data/wimages/case_dollar.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_dollar.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:OpenCrate('case_dollar')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_free.lua:
ITEM.Name = 'Ежедневный кейс'
ITEM.Price = 59
ITEM.Description = "Что можно выбить?\n- 1000$\n- 10.000$\n- 25.000$\n-50.000$\n- 100.000$\n- 150.000$\n- 300.000$\n- 500.000$\n- 1.000.000$\n- 15 донат рублей"
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_free.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот кейс можно получить только из F4 - Бонусы"
end

function ITEM:OnUse(ply)
	ply:OpenCrate('case_free')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_points.lua:
ITEM.Name = 'Рублевый Кейс'
ITEM.Description = "Что можно выбить? \n- 5 донат рублей\n- 15 донат рублей\n- 25 донат рублей\n- 50 донат рублей\n- 100 донат рублей\n- 250 донат рублей\n- 500 донат рублей\n- 1000 донат рублей\n- 1500 донат рублей"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_points.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_points.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true

function ITEM:OnUse(ply)
	ply:OpenCrate('case_points')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/cases/case_snow.lua:
ITEM.Name = 'Снежный Кейс'
ITEM.Description = "Что можно выбить?\n- 1.000$\n- 10.000$\n- 25.000$\n- 100.000$\n- 500.000$\n- 5 Рублей\n- 15 Рублей\n- VIP на 15 дней\n- VIP на 1 месяц\n- Обложка дух нового года\n- Обложка теплый свитер\n- 100 рублей\n- 200 рублей\n- Huckleberry"
ITEM.Price = 59
--ITEM.Material =  Material( "data/wimages/case_free.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/case_snow.png'
ITEM.SingleUse = true
ITEM.NoPreview = true
ITEM.NoScroll = true
ITEM.Hidden = false

function ITEM:OnUse(ply)
	ply:OpenCrate('case_snow')
end

function ITEM:CanPlayerUse( ply )
	return not ply.unboxing.currentlyWaiting, "Дождись окончания рулетки"
end
--addons/module_donate/lua/pointshop/items/companions/meatgrinder.lua:
ITEM.Name = 'Мясорубка'
ITEM.Price = 199
ITEM.Model = 'models/props_c17/grinderclamp01a.mdl'
--ITEM.Material = Material( "data/wimages/mossman.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/meat.jpg'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y - 90
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/mossman.lua:
ITEM.Name = 'Моссман'
ITEM.Price = 199
ITEM.Model = 'models/maxofs2d/balloon_mossman.mdl'
--ITEM.Material = Material( "data/wimages/mossman.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/mossman.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.NoScroll = true

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.2
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/companions/scanner.lua:
ITEM.Name = 'Космическое устройство ( День космонавтики )'
ITEM.Price = 349
ITEM.Model = 'models/Combine_Scanner.mdl'
--ITEM.Material = Material( "data/wimages/scanner.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/scanner.png'
ITEM.Skin = 1
ITEM.Attachment = 'chest'
ITEM.Slots = {'companion'}
ITEM.OffsetType = "back"
ITEM.Hidden = true
ITEM.NoScroll = true

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	local plyPos, plyAng = pos, ang
	plyAng.y = plyAng.y
	plyAng.p = plyAng.p * 0.5
	ply.compPos = LocalToWorld( Vector(-20, -16 + math.sin(CurTime() * 2 + 1.57) * 2, math.sin(CurTime()) * 8), Angle(), plyPos, plyAng )
	ply.compPosLast = ply.compPosLast or ply.compPos

	local dir = ply.compPos - ply.compPosLast
	ply.compPosLast = ply.compPosLast + dir * math.min(1, FrameTime())
	

	return model, ply.compPosLast, plyAng
end

--addons/module_donate/lua/pointshop/items/cover/cover_mooncat.lua:
ITEM.Name = 'Лунный кот'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_mooncat.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_mooncat.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_road.lua:
ITEM.Name = 'Дорога в маями'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_road.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_road.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_stone.lua:
ITEM.Name = 'Каменная гряда'
ITEM.Price = 99
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_stone.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = false
ITEM.Cover = Material('covers/cover_stone.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end
--addons/module_donate/lua/pointshop/items/cover/cover_sviter.lua:
ITEM.Name = 'Теплый свитер'
ITEM.Price = 299
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/cover_sviter.png'
ITEM.Slots = {'cover'}
ITEM.NoScroll = true
ITEM.NoPreview = true
ITEM.Hidden = true
ITEM.Cover = Material('covers/cover_sviter.png')

function ITEM:PanelPreview()
    local p = vgui.Create('DImage')
    p:SetMaterial(self.Cover)
    p:SetSize(462, 90)

    return p
end

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end
--addons/module_donate/lua/pointshop/items/other/doublejump.lua:
ITEM.Name = 'Двойной прыжок на месяц'
ITEM.Description = 'Ты получаешь возможность совершить двойной прыжок за любую профессию'
ITEM.Price = 49
--ITEM.Material =  Material( "data/wimages/doublejump.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/doublejump.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
--addons/module_donate/lua/pointshop/items/other/govorilka.lua:
ITEM.Name = 'Говорилка на месяц'
ITEM.Description = 'Озвучивает весь написанный текст вслух!'
ITEM.Price = 49
--ITEM.Material =  Material( "data/wimages/microphone.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/microphone.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30

ITEM.Voices = {
	alyss = {
        name = 'Алиса (Ж)',
    },
	oksana = {
        name = 'Оксана (Ж)',
    },
	jane = {
        name = 'Джейн (Ж)',
    },
	omazh = {
        name = 'Оммаж (Ж)',
    },
	zahar = {
        name = 'Захар (М)',
    },
	ermil = {
        name = 'Эрмиль (М)',
    },
    google = {
        name = 'Гуглесса (Ж)',
        url = 'https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&q={text}&tl=ru',
    },
}

local char_to_hex = function(c)
    return string.format("%%%02X", string.byte(c))
end

local function urlencode(url)
    if url == nil then
    return
    end
    url = url:gsub("\n", "\r\n")
    url = url:gsub("([^%w ])", char_to_hex)
    url = url:gsub(" ", "+")
    return url
end

local lowqual = CreateClientConVar('wrp_govorilka_lowquality', '0', true)

function ITEM:GetURL(voice, text)
    if not self.Voices[voice] then return end

    local url = self.Voices[voice].url or 'http://tts.voicetech.yandex.net/tts?speaker={voice}&text={text}&quality={quality}'
    url = string.Replace(url, '{voice}', voice)
    url = string.Replace(url, '{text}', urlencode(text))
    url = string.Replace(url, '{quality}', lowqual:GetBool() and 'lo' or 'hi')

    return url
end

function ITEM:OnEquip(ply, modifications)
    if not modifications or not modifications.voice then
        ply:PS_ModifyItem(self.ID, {voice = 'zahar'})

        ply:PS_Notify('Ты можешь изменить голос говорилки')
        ply:PS_Notify('Для этого нажми на нее в магазине и выбери "Изменить..."')
    end
end

function ITEM:CanPlayerModify(ply, modifications)
    for k, v in pairs(modifications) do
        if k ~= 'voice' then return false, 'Куда ты лезешь?' end
    end

    return self.Voices[modifications.voice] or false
end

ITEM.Samples = {
	'Я в своем познании настолько преисполнился, что я как будто бы уже сто триллионов миллиардов лет проживаю на триллионах и триллионах таких же планет, как эта Земля',
	'Эх, как же хочется тяночку, худенькую, бледную, не очень высокую',
	'Нужно построить Зиккурат',
	'Купил как-то мужик шляпу, а она ему как раз!',
	'Идет медведь по лесу, видит, машина горит. Сел в нее и сгорел',
	
	'Помогите, он держит меня в заложниках и заставляет делать аддоны для гаррис мода. Я не видел солнечного света уже 2 года!',
}

local curplaying
function ITEM:Modify(modifications)
    local frame = vgui.Create('DFrame')
    frame:SetSize(300, 100)
    frame:SetTitle('Изменение голоса')
    frame:MakePopup()
    frame:Center()
    frame:SetDraggable(false)
    frame:SetBackgroundBlur(true)
    frame:SetDrawOnTop(true)

    local pnl = vgui.Create('DPanel', frame)
    pnl:SetPaintBackground(false)
    pnl:Dock(TOP)
    pnl:DockMargin(0,4,0,0)
    pnl:SetTall(25)

    pnl:InvalidateParent(true)

    local combo = vgui.Create('DComboBox', pnl)
    combo:Dock(LEFT)
    combo:SetWide(pnl:GetWide() - 30)

    for k, v in pairs(self.Voices) do
        combo:AddChoice(v.name, k, modifications and modifications.voice == k)
    end

    local play = vgui.Create('DImageButton', pnl)
    play:Dock(RIGHT)
    play:SetSize(24, 24)
    play:SetImage('icon16/sound.png')
    play.DoClick = function()
        local voice = combo:GetOptionData(combo:GetSelectedID())
        
        local text = math.random(1, 100) <= 5 and self.Samples[#self.Samples] or self.Samples[math.random(1, #self.Samples-1)]
        
        if IsValid(curplaying) then curplaying:Stop() end
	
        sound.PlayURL(self:GetURL(voice, text), 'mono', function(station, errorId, errorName)
            if IsValid(station) then
                curplaying = station
                curplaying:Play()
            end
        end)
    end

    local submit = vgui.Create('DButton', frame)
    submit:Dock(BOTTOM)
    submit:SetText('Готово')
    submit:SetTall(25)
    submit:SetImage('icon16/accept.png')

    submit.DoClick = function()
        local voice = combo:GetOptionData(combo:GetSelectedID())

        if self.Voices[voice] then
            PS:SendModifications(self.ID, {voice = voice})
        else
            notification.AddLegacy('Ты не выбрал голос', 1, 5)
        end
        
        frame:Close()
    end
end

-- говорилка

if CLIENT then
    function govorilka(voice, text, data, cb)
        local url = PS.Items['govorilka']:GetURL(voice, text)
        if not url then return end

        sound.PlayURL(url, data.flags or '', function(station, errorId, errorName)
            if IsValid(station) then
                if data.pos then station:SetPos(data.pos) end
                if data.dist then station:Set3DFadeDistance(150, data.dist) end
                station:SetVolume(data.volume or 1)
                station:Play()
            end
            if cb then cb(station, errorId, errorName) end
        end)
    end

    local whitelist = {
        ['крик'] = {
            flags = '3d',
            dist = 550,
        },
        ['шепот'] = {
            flags = '3d',
            dist = 90,
        },
        ['Громкоговоритель'] = {
            flags = '3d',
            dist = 1200,
        },
        ['Рация'] = {
            flags = 'mono',
        },
        ['Телефон'] = {
            flags = 'mono',
        },
        ['Вещание!'] = {
            flags = 'mono',
        }
    }

    hook.Add('OnPlayerChat', 'ps_govorilka', function(ply, text, team, dead, prefix)
        if not IsValid(ply) or team or dead or not prefix then return end

        if ply:Team() == TEAM_BANNED then return end

        if not ply:PS_HasItemEquipped('govorilka') and not ply:PS_HasItemEquipped('govorilka_navsegda') then return end
        local voice = (ply.PS_Items['govorilka'] or ply.PS_Items['govorilka_navsegda']).Modifiers.voice
        if not voice then return end
        
        local nameStart, nameEnd = prefix:find(ply:Name(), 1, true)
        if not nameStart then return end
        prefix = prefix:sub(1, nameStart-1) .. prefix:sub(nameEnd+1)
        
        local cmd = prefix:match('[%[%(](.+)[%]%)]')
        
        local flags = prefix == '' and (ply == LocalPlayer() and 'mono' or '3d') or (whitelist[cmd] and whitelist[cmd].flags)
        if not flags then return end

        local dist = whitelist[cmd] and whitelist[cmd].dist or 250

        govorilka(voice, utf8.sub(text, 1, 128), {
            flags = flags,
            dist = dist,
            pos = ply:GetPos(),
        }, function(sound)
            if IsValid(ply) then ply.sound = station end
        end)
    end)

    timer.Create('govorilka_followsound', 0.5, 0, function()
        for _, v in player.Iterator() do
            if IsValid(v.sound) then
                v.sound:SetPos(v:GetPos())
            end
        end
    end)
end
--addons/module_donate/lua/pointshop/items/other/outfit_outbreak.lua:
ITEM.Name = 'Outbreak за спиной'
ITEM.Price = 999
ITEM.Description = 'Косметика для всех профессий'
ITEM.Model = 'models/weapons/outbreak/w_outbreak.mdl'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/bp.png'
ITEM.Bone = 'ValveBiped.Bip01_Spine2'
ITEM.NoScroll = true
ITEM.Hidden = true
--ITEM.Job = {['gangstervip'] = true, ['gangstercannon'] = true, ['gangster'] = true, ['gangstermedic'] = true}
--ITEM.NoDrawDisguise = false

function ITEM:CanPlayerBuy(ply)
	return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
	ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
	ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
	pos = pos + (ang:Right() * 4) + (ang:Up() * 7) + (ang:Forward() * 1)
	--ang:RotateAroundAxis(ang:Forward(), 90)
	ang:RotateAroundAxis(ang:Right(), 160)

	return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/other/outfit_shoes_secondary.lua:
ITEM.Name = 'Кроссовки Nike (П)'
ITEM.Price = 999
ITEM.Description = '*'
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/shoes.png'
ITEM.Model = 'models/denom/amongusdrip/amongusrightshoe.mdl'
ITEM.Bone = 'ValveBiped.Bip01_R_Foot'
ITEM.NoScroll = true
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
--    ply:PS_AddClientsideModel(self.ID)
end

function ITEM:OnHolster(ply)
--    ply:PS_RemoveClientsideModel(self.ID)
end

function ITEM:ModifyClientsideModel(ply, model, pos, ang)
    pos = pos + (ang:Forward() * 4) + (ang:Right() * -3) + (ang:Up() * 3) -- vpered, vniz/vverx, vlevo vpravo
   ang:RotateAroundAxis(ang:Forward(), 90)
   ang:RotateAroundAxis(ang:Right(), 30)
   model:SetModelScale(2, 0)

    return model, pos, ang
end
--addons/module_donate/lua/pointshop/items/other/skinworkshop.lua:
ITEM.Name = 'Своя модель на месяц'
ITEM.Description = 'Позволяет выбрать любую модель из Workshop\nи использовать ее в игре в течение месяца.\nМодель можно изменять раз в день'
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/model_schav.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/model_schav.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
--addons/module_donate/lua/pointshop/items/ranks/__category.lua:
CATEGORY.Name = 'Привилегии'
CATEGORY.Icon = 'crown'
CATEGORY.AllowedEquipped = 1
CATEGORY.CustomAngle = 45
CATEGORY.CustomPos = Vector(10,10,-20)

--addons/module_donate/lua/pointshop/items/ranks/curator_1m.lua:
ITEM.Name = 'Curator на 1 месяц'
ITEM.Description = "- Имеет все привилегии VIP\n- Имеет все привилегии DModerator\n- Имеет все привилегии DAdmin\n- Имеет все привилегии DSAdmin\n-Имеет доступ к наборной системе жалоб\n- Иммунитет от хелперов\n- Имеет доступ к админ меню наборной администрации\n- Может установить себе размер\n- Может установить себе модель любого предмета\n- Имеет доступ к ивент меню \n- Может скринить экраны игроков \n- При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 499
--ITEM.Material = Material( "data/wimages/curator_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/curator_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "Curator"
ITEM.Time = 60 * 60 * 24 * 30

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/curator_3m.lua:
ITEM.Name = 'Curator на 3 месяц'
ITEM.Description = "- Имеет все привилегии VIP\n- Имеет все привилегии DModerator\n- Имеет все привилегии DAdmin\n- Имеет все привилегии DSAdmin\n-Имеет доступ к наборной системе жалоб\n- Иммунитет от хелперов\n- Имеет доступ к админ меню наборной администрации\n- Может установить себе размер\n- Может установить себе модель любого предмета\n- Имеет доступ к ивент меню \n- Может скринить экраны игроков \n- При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/curator_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/curator_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "Curator"
ITEM.Time = 60 * 60 * 24 * 30 * 3

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/ranks/dsadmin_navsegda.lua:
ITEM.Name = 'DSAdmin навсегда'
ITEM.Description = "- Имеет все привилегии VIP \n - Имеет все привилегии DModerator \n - Имеет все привилегии DAdmin \n Доступ к спавну через Q меню, оружия, энтити, транспорта, но только из категории Разрешено \n - При наличии доната 'Workshop модель' может менять её без ограничений!"
ITEM.Price = 2490
--ITEM.Material = Material( "data/wimages/dsadmin_crown.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/dsadmin_crown.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true

ITEM.AdminGroup = "DSAdmin"

ITEM.CanPlayerSell = false
ITEM.CanPlayerEquip = false
ITEM.CanPlayerHolster = false

function ITEM:OnUse( ply )
	FAdmin.Access.PlayerSetGroup(ply, self.AdminGroup)
end

function ITEM:CanPlayerUse( ply )
	local curImm = FAdmin.Access.Groups[ply:GetUserGroup()].immunity
	local tgtImm = FAdmin.Access.Groups[self.AdminGroup].immunity

	return curImm <= tgtImm, "Вряд ли тебе это нужно"
end
--addons/module_donate/lua/pointshop/items/weapons/armorvape.lua:
ITEM.Name = 'Armor Vape навсегда'
ITEM.Description = "Вейп с жижкой, восстанавливает Броню до 110, обходя лимит"
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/vape.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/vape.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "weapon_vape_armor"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
	ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/dagger_knife.lua:
ITEM.Name = 'Тычковые Ножи'
ITEM.Description = "Разрешает спавнить это оружие через спавн меню в любое время."
ITEM.Price = 999
--ITEM.Material = Material( "data/wimages/stunstick.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/stunstick.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.WeaponClass = "csgo_daggers"
ITEM.Hidden = true

function ITEM:CanPlayerBuy(ply)
    return false, "Этот предмет из ограниченной серии"
end

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    ply:SelectWeapon(self.WeaponClass)
    --if not IsValid(wep) then return end
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_donate/lua/pointshop/items/weapons/weapon_spawn.lua:
ITEM.Name = 'Спавн оружия через Q меню на месяц'
ITEM.Description = "Ты получаешь возможность спавнить оружия из Q меню, ТОЛЬКО из вкладки РАЗРЕШЕНОЕ"
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/weapon.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/weapon.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
--addons/module_donate/lua/pointshop/items/weapons/wowozela.lua:
ITEM.Name = 'Вовозелка на месяц'
ITEM.Description = "Вовозелка\n- Позволяет издавать различные звуки с разноцветным эффектом\n- Еще ты можешь загрузить любые звуки из интернета в вовозелку\n- Даже свой голос с определенными фразами ;)"
ITEM.Price = 99
--ITEM.Material = Material( "data/wimages/wowozela.png" )
ITEM.ImageURL = 'http://wayzerroleplay.myarena.ru/wimages/wowozela.png'
ITEM.NoScroll = true
ITEM.SingleUse = false
ITEM.NoPreview = true
ITEM.Time = 60 * 60 * 24 * 30
ITEM.WeaponClass = "wowozela"

function ITEM:OnEquip(ply, modifications)
    if not IsValid(ply) then return false end
    
    local wep = ply:Give(self.WeaponClass)
    if IsValid(wep) then wep:SetVar("restricted_to_drop", true) end

    ply:SelectWeapon(self.WeaponClass)
end

function ITEM:OnHolster(ply)
    ply:StripWeapon(self.WeaponClass)
end
--addons/module_police/lua/autorun/sh_gromkogovoritel.lua:
if not simfphys then return end

hook.Add('Think', 'gromkogovoritel_init', function()
    hook.Remove('Think', 'gromkogovoritel_init')

    DarkRP.declareChatCommand({
        command = 'gr',
        description = 'Использовать громкоговоритель полиции',
        delay = 1.5
    })
    
    local copCars = {
        -- Rockford
        ['simfphys_gta_sa_copcarla'] = true,
        ['simfphys_gta_sa_copcarru'] = true,
        ['simfphys_gta_sa_enforcer'] = true,
        ['simfphys_gta_sa_fbiranch'] = true,
        ['simfphys_gta_sa_fbitruck'] = true,
        ['simfphys_gta_sa_swatvan'] = true,
        -- WW2
        ['simfphys_mafia2_ulver_newyorker_p'] = true,
        ['simfphys_mafia2_smith_200_p_pha'] = true,
        ['simfphys_mafia2_sicily_military_truck'] = true,
        ['simfphys_mafia2_shubert_armoured'] = true,
    }
    
    local PLAYER = FindMetaTable('Player')
    function PLAYER:CanUseGR()
        if not self:isCP() then return false, 'Ты не гос. служащий' end
    
        local veh = self:GetVehicle()
        if IsValid(veh) and veh:GetClass():sub(1, 2) == 'v_' then return true end
        
        if simfphys then
            local car = self:GetSimfphys()
            if IsValid(car) then
                if copCars[car:GetNWString('car-dealer.simfphysID')] then return true end
                if car:GetNWEntity('car-dealer.owner') == self then return true end
            end
    
            for _, v in pairs(ents.FindInSphere(self:GetPos(), 200)) do
                if not simfphys.IsCar(v) then continue end

                if copCars[v:GetNWString('car-dealer.simfphysID')] then return true end
                if v:GetNWEntity('car-dealer.owner') == self then return true end
            end
        end
    
        return false, 'Ты должен находиться рядом с полицейским или личным авто'
    end
    
    if SERVER then
        DarkRP.defineChatCommand('gr', function(ply, args)
            local DoSay = function(text)
                local canUse, reason = ply:CanUseGR()
                if not canUse then
                    DarkRP.notify(ply, 1, 4, reason)
                    return ''
                end
    
                if text == '' then
                    DarkRP.notify(ply, 1, 4, DarkRP.getPhrase('invalid_x', DarkRP.getPhrase('arguments'), ''))
                    return ''
                end
                DarkRP.talkToRange(ply, '(Громкоговоритель) '.. ply:Nick(), text, 1200)
                ply:EmitSound('npc/combine_soldier/vo/contact.wav')
            end
            return args, DoSay
        end, 1.5)
    end
end)
--addons/_smallscripts/lua/autorun/sh_optimiz.lua:
hook.Add("InitPostEntity","NoWidgets",function()
 timer.Simple(60, function()
 	-- Usually the cause of some if not most lag.
 	DarkRP.removeChatCommand("cheque")
 	DarkRP.removeChatCommand("check")
 	DarkRP.removeChatCommand("freerpname")
    DarkRP.removeChatCommand("write")
 
 	if SERVER then
        
        function widgets.PlayerTick()
        end

     	hook.Remove("PlayerTick", "TickWidgets")

 		if timer.Exists("CheckHookTimes") then
 			timer.Remove("CheckHookTimes")
 		end

        for k, v in pairs(ents.FindByClass("env_fire")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("trigger_hurt")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("prop_physics")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("prop_ragdoll")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("light")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("spotlight_end")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("beam")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("point_spotlight")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("env_sprite")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("func_tracktrain")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("light_spot")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("point_template")) do v:Remove() end
        for k, v in pairs(ents.FindByClass("env_soundscape")) do v:Remove() end   
 	
	end
	
 	hook.Remove("PlayerTick","TickWidgets")
	hook.Remove( "Think", "CheckSchedules")
	timer.Destroy("HostnameThink")
	hook.Remove("LoadGModSave", "LoadGModSave")
	
	// Remove a bunch of useless map stuff 
	
	
     if CLIENT then
         
        local commands = {
            'r_3dsky 0',
            'gmod_mcore_test 1',
            'studio_queue_mode 1',
            'cl_threaded_bone_setup 1',
            'mat_queue_mode 2',
            'r_WaterDrawReflection 0',
            'r_eyemove 0',
--[[             
            'r_lightaverage 0',
            'r_decal_cullsize 20',
            'r_decals 1',
            'r_drawbatchdecals 1',
            'r_drawmodeldecals 0',
            'r_flex 0',
            'r_ForceWaterLeaf 0',
            'r_fastzreject -1',
            'r_teeth 0', 
            'r_cheapwaterstart 1',
            'r_cheapwaterend 1',
            'r_waterforceexpensive 0',
            'r_WaterDrawReflection 0',
            'r_dopixelvisibility 1',
            'r_pixelvisibility_partial 0',
            'r_ropetranslucent 0',
            'r_flashlightmodels 1',
            'r_flashlightrendermodels 0',
            'r_flashlightrenderworld 0',
            'r_DrawSpecificStaticProp 0',
            'r_eyes 1',
            'r_eyeglintlodpixels 0',
            'r_eyegloss 0',
            'r_eyemove 0',
            'r_eyeshift_x 0',
            'r_eyeshift_y 0',
            'r_eyeshift_z 0',
            'r_eyesize 0',
            'r_occlusion 0',
            'r_maxmodeldecal 0',
            'r_minnewsamples 0',
            'r_maxsampledist 0',
            'r_spray_lifetime 1',
            'r_mmx 1', 
            'r_sse 1',
            'r_sse2 1',
            'r_3dnow 1',
            'r_phong 0',
            'r_PhysPropStaticLighting 0',
        --    'r_dynamic 0', 
            'r_updaterefracttexture 0',
            'r_renderoverlayfragment 0',
         --   'r_worldlights 0',
            'rope_smooth 0',
            'rope_wind_dist 0',
            'rope_shake 0',
            'rope_smooth_maxalphawidth 0',
            'rope_smooth_maxalpha 0',
            'rope_smooth_enlarge 0',
            'rope_subdiv 0',
            'rope_smooth_minwidth 0',
            'rope_smooth_minalpha 0',
            'rope_averagelight 0',
            'rope_collide 0',
        --    'mat_specular 0',
            'r_shadows 0',
            'ss_render_range 400',
            'studio_queue_mode 1',
            'r_queued_ropes 1',
            'r_threaded_renderables 1',
            'r_threaded_client_shadow_manager 1',
            'cl_threaded_client_leaf_system 1',
            'cl_threaded_bone_setup 1',
        --    'fov_desired 90',
            'violence_hgibs 0', 
            'violence_agibs 0',
            'r_propsmaxdist 0',
            'props_break_max_pieces 0',
            'cl_phys_props_max 0',
        --    'r_shadowrendertotexture 0', краш снег????
            'r_shadowmaxrendered 0',
            'mat_shadowstate 0',
            'cl_phys_props_enable 0',
            'cl_phys_props_max 0',
            'gmod_mcore_test 1',
            'datacachesize 512',
            'r_fastzreject -1',
            'cl_ejectbrass 0',
            'Muzzleflash_light 0',
            'in_usekeyboardsampletime 0',
            'mat_disable_ps_patch 1',
            'cl_playerspraydisable 1',
            'mat_disable_fancy_blending 1',
            'r_decal_cullsize 0',
            'r_decals 0',
            'mp_decals 30',
            'mat_forceaniso 0',
            'mat_disable_bloom 0',
            'r_threaded_particles 1',
            'r_threaded_renderables 1',
            'r_queued_ropes 1',
            'joystick 0',
            'violence_ablood 0',
            'violence_hblood 1',
            'cl_show_splashes 0',
            'r_WaterDrawRefraction 0',
            'mat_wateroverlaysize 4',
            'r_lod -1',
            'r_shadowmaxrendered 0',
            'cl_detaildist 0',
            'mat_bloomscale 0',
            'mat_hdr_enabled',
            'mat_hdr_level 0',
            'mat_disable_lightwarp 1',
            'mat_queue_mode 2',
            'cl_forcepreload 1',
           -- 'voice_recordtofile 0', -- заблокирована разработчиками
            'cl_detail_avoid_radius 0',
            'net_compressvoice 1',
            'r_drawdetailprops 0',
            'snd_mix_async 1',
            'r_drawflecks 0',
            'cl_showhelp 0',
            'demo_avellimit 0',
        --]] 
        }
        
        local i = 1
        
        timer.Create('compliteCommands', 1, #table.GetKeys(commands), function()
            LocalPlayer():ConCommand(commands[i])
            --print(commands[i])
            i = i + 1
        end)
        
        hook.Remove("RenderScreenspaceEffects", "RenderColorModify")
        hook.Remove("RenderScreenspaceEffects", "RenderBloom")
        hook.Remove("RenderScreenspaceEffects", "RenderToyTown")
        hook.Remove("RenderScreenspaceEffects", "RenderTexturize")
        hook.Remove("RenderScreenspaceEffects", "RenderSunbeams")
        hook.Remove("RenderScreenspaceEffects", "RenderSobel")
        hook.Remove("RenderScreenspaceEffects", "RenderSharpen")
        hook.Remove("RenderScreenspaceEffects", "RenderMaterialOverlay")
        hook.Remove("RenderScreenspaceEffects", "RenderMotionBlur")
        hook.Remove("RenderScene", "RenderStereoscopy")
        hook.Remove("RenderScene", "RenderSuperDoF")
        hook.Remove("GUIMousePressed", "SuperDOFMouseDown")
        hook.Remove("GUIMouseReleased", "SuperDOFMouseUp")
        hook.Remove("PreventScreenClicks", "SuperDOFPreventClicks")
        hook.Remove("PostRender", "RenderFrameBlend")
        hook.Remove("PostRender", "PreRenderFrameBlend")
        hook.Remove("PreRender", "PreRenderFrameBlend")
        hook.Remove("Think", "DOFThink")
        hook.Remove("RenderScreenspaceEffects", "RenderBokeh")
        hook.Remove("NeedsDepthPass", "NeedsDepthPass_Bokeh")
        hook.Remove("PreDrawHalos", "AddPhysgunHalos")
    --    hook.Remove("PreDrawHalos", "PropertiesHover") -- ломает C меню
        hook.Remove("PlayerBindPress", "PlayerOptionInput")
        
        hook.Remove("PostDrawEffects", "RenderWidgets")         -- We don't need this, but what the hell.
    --    hook.Remove("PostDrawEffects", "RenderHalos")       -- If you have pointshop issues, then delete this line.
    
        LocalPlayer():ConCommand('snd_restart; cl_drawmonitors 0; cl_tree_sway_dir .5 .5;')
        hook.Remove("StartChat", "StartChatIndicator")
        hook.Remove("FinishChat", "EndChatIndicator")
 		
        local mountMdl = util.GetModelMeshes("models/props/CS_militia/gun_cabinet.mdl")
        
        if mountMdl == nil then
            local textColor = Color( 255, 0, 0 )
        	chat.AddText( textColor, "[CSS] Мы заметили что у тебя не установлен контент CSS")
        	chat.AddText( textColor, "[CSS] Ссылка с исправлением: https://forum.wayzer.ru/d/3-kontent-counter-strike-source")
        	chat.AddText( textColor, "[CSS] Открывай лучше на сервере в стим браузере. ( Shift + Tab )")
        
        	gui.OpenURL('https://forum.wayzer.ru/d/3-kontent-counter-strike-source')
        end
 	end
 end)
end)
--addons/ent_drugz/lua/autorun/sh_vars.lua:
nw.Register 'Weed'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetLocalPlayer()

nw.Register 'Meth'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetLocalPlayer()

nw.Register 'Alc'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetLocalPlayer()	

nw.Register 'LSD'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetLocalPlayer()	

nw.Register 'Heroine'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetLocalPlayer()	

nw.Register 'Alc'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetLocalPlayer()

nw.Register 'FireAmmo'
	:Write(net.WriteBool)
	:Read(net.ReadBool)
	:SetLocalPlayer()

nw.Register 'DruggedUntil'
	:Write(net.WriteUInt, 18)
	:Read(net.ReadUInt, 18)
	:SetPlayer()
	:SetHook('PlayerGotDrugged')

local meta = FindMetaTable('Player')
function meta:IsDrugged()
	return self:GetNetVar('DruggedUntil', 0) > CurTime()
end

if SERVER then	
	function meta:SetNotDrugged()
		self:SetNetVar('DruggedUntil', 0)

		timer.Adjust('Heroine_'..self:SteamID64(), 1, 1)
		timer.Adjust('LSD_'..self:SteamID64(), 1, 1)
		timer.Adjust('Meth_'..self:SteamID64(), 1, 1)
		timer.Adjust('Weed_'..self:SteamID64(), 1, 1)
		timer.Adjust('Toxin_'..self:SteamID64(), 1, 1)
		timer.Remove('cocaine_'..self:SteamID())
	
		self:SetNetVar('Heroine')
		self:SetNetVar('LSD')
		self:SetNetVar('Meth')
		self:SetNetVar('Weed')
		self:SetNetVar('Alc')
	
		self:StopSound('player/heartbeat1.wav')
		self:GodDisable()
		self:SetHealth(50)
		self:MoveModifier('cocaine')
		self:MoveModifier('meth')
		self:ClearWeed()

		self.CocaineKill = nil
	end

	function meta:AddDrugTime(time)
		self:SetNetVar('DruggedUntil', math.max(self:GetNetVar('DruggedUntil', 0), CurTime()+time))
	end

	hook.Add('PlayerSpawn', 'setnotdrugged', function(ply)
		ply:SetNotDrugged()
	end)

	hook.Add('ShouldBeFeared', 'drugs', function(ply, count)
		if ply:IsDrugged() and count < 3 then return false end
	end)
end
--addons/_smallscripts/lua/autorun/smallscripts_init.lua:
wlib.include.modules('smallscripts', {
	'!_server',
	'!_client',
	'*',
})
wlib.include.server('smallscripts/_server')
wlib.include.client('smallscripts/_client')
--addons/_smallscripts/lua/smallscripts/death/client.lua:
RadialMenu = RadialMenu or {}
RadialMenu.Entities = RadialMenu.Entities or {}
RadialMenu.Entities['prop_ragdoll'] = {}

for id, v in pairs(waydeath.actions) do
    table.insert(RadialMenu.Entities['prop_ragdoll'], {
        name = v.name,
        icon = v.icon,
        check = function(ent)
            local info = ent:GetNetVar('RagdollInfo')
            if not info then return false end

            if not v:check(LocalPlayer(), info.owner, ent, info) then return false end

            return true
        end,
        callback = function(ent)
            local info = ent:GetNetVar('RagdollInfo')

            net.Start('waydeath.ragdollaction')
            net.WriteUInt(id, 4)
            net.SendToServer()
        end,
    })
end

local math_min = math.min
local math_floor = math.min
local os_date = os.date
local draw_SimpleText = draw.SimpleText
local color_red = Color(225, 0, 0)
local color_dark = Color(43,49,54, 245)
local color_bright = Color(236,113,71)
local scrW,scrH = ScrW(),ScrH()

local background = wlib.Circles.New(CIRCLE_OUTLINED, math_min(scrH/2, 300), scrW/2, scrH/2, 100)
background:SetMaterial(true)
background:SetColor(color_dark)

local main = wlib.Circles.New(CIRCLE_OUTLINED, math_min(scrH/2, 300), scrW/2, scrH/2, 100)
main:SetMaterial(true)
main:SetColor(color_bright)
main:SetStartAngle(-90)

hook.Add('HUDPaint', 'death_respawn', function()
    local lp = LocalPlayer()
    if lp:Alive() then return end
    if lp:Team() == TEAM_BANNED then return end

    local ply = lp:GetNetVar('RespawningPlayer')
    if IsValid(ply) and ply:GetNetVar('Delays') then
        local delay
        for _, v in ipairs(ply:GetNetVar('Delays')) do
            if v.id == 'ragdoll_respawn' then delay = v break end
        end
        if not delay then return end
        local elapsed = CurTime()-delay.start

        background()
        main:SetEndAngle(360*(elapsed/delay.duration) - 90)
        main()

        draw_SimpleText('До возрождения осталось', 'chelog-ib.small', scrW/2, scrH/2-40, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw_SimpleText(os_date('%M:%S', delay.duration-elapsed), 'chelog-ib-shadow', scrW/2, scrH/2, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw_SimpleText(os_date('%M:%S', delay.duration-elapsed), 'chelog-ib', scrW/2, scrH/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    else
        local remaining = math_floor((lp:GetNetVar('NextSpawnTime') or 0) - CurTime())
        if remaining > 0 then
            local text = 'Возрождение будет доступно через '..os_date('%M:%S', remaining)
            draw_SimpleText(text, 'chelog-ib-shadow', scrW/2, scrH-60, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw_SimpleText(text, 'chelog-ib', scrW/2, scrH-60, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        else
            draw_SimpleText('Нажми любую кнопку для возрождения', 'chelog-ib-shadow', scrW/2, scrH-100, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw_SimpleText('Нажми любую кнопку для возрождения', 'chelog-ib', scrW/2, scrH-100, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw_SimpleText('Важно: после возрождения тебя не смогут воскресить', 'chelog-ib.small', scrW/2, scrH-60, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            draw_SimpleText('Чтобы вызвать врача нажми клавишу R', 'chelog-ib.small', scrW/2, scrH-35, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        end
    end
end)

hook.Add("OnPlayerChangedTeam", "waydeath.markers", function(ply, old, new)
    if old == TEAM_VRACH then
        dMarkers.removeAll('medic')
    end
end)

hook.Add('dMarkers.shouldRemove', 'waydeath.shouldRemove', function(marker)
    if marker.type == 'medic' then return false end
end)
--addons/_smallscripts/lua/smallscripts/pvp/client.lua:
hook.Add('PVPUpdated', 'notify', function(ply)
    if ply ~= LocalPlayer() then return end

    notification.AddProgress('PVPMode', 'Ты находишься в ПВП', 1)

    timer.Create('PVPMode_notify', .1, 0, function()
        local start = LocalPlayer():GetNetVar('PVPStart', 0)
        local frac = 1 - (CurTime()-start)/PVP_DURATION
        if frac > 0 then
            notification.AddProgress('PVPMode', 'Ты находишься в ПВП', frac)
        else
            timer.Remove('PVPMode_notify')
            notification.Kill('PVPMode')
        end
    end)
end)
--addons/module_picture/lua/urlpaint/client.lua:
URLPaint.CleanedUp = URLPaint.CleanedUp or false
if not URLPaint.CleanedUp then
	local files = file.Find("urlpaint/*", "DATA")
	for _, _file in pairs(files) do
		file.Delete("urlpaint/" .. _file)
	end
	URLPaint.CleanedUp = true
end

net.Receive("URLPaint Menu", function()
	local ent = net.ReadEntity()
	
    if LocalPlayer() ~= ent:Getowning_ent() then
    	return
    end

	Derma_StringRequest(
		"Картина",
		"Вставь ссылку на картинку c pinterest.ru | NSFW/18+ = БАН (Например: https://i.pinimg.com/564x/7e/b9/84/7eb98460bb8420174b8820896c9bd4fb.jpg)",
		ent:GetPicURL(),
		function(url) 
			net.Start("URLPaint Set")
				net.WriteEntity(ent)
				net.WriteString(url)
			net.SendToServer()
		end
	)
end)

net.Receive("URLPaint Download", function()
	local url = net.ReadString()
	local exp = string.Explode("/", url)
	local id = exp[#exp]

    if GetConVar('urlpaint_enabled'):GetInt() <= 0 then return end

	if not file.Exists("urlpaint", "DATA") then
		file.CreateDir("urlpaint")
	end

	if not file.Exists("urlpaint/" .. id, "DATA") then
		http.Fetch(url, function(data)
			file.Write("urlpaint/" .. id, data)
		end)
	end
end)
--addons/module_picture/lua/urlpaint/shared.lua:
function URLPaint.IsValidURL(url)
	if string.StartWith(url, "https://i.pinimg.com/") then
		return true 
	end
	return false
end
--addons/module_battlepass/lua/waypass/challenges/case.lua:
waypass.challenges.Create('case')
    :SetName('Любитель халявы')
    :SetDesc('Забери ежедневный кейс {goal} раз')
    :AddHook('PlayerGiveFreeCase', function(self, owner, ply)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/chocolate.lua:
waypass.challenges.Create('chocolate')
    :SetName('Шоколадный маньяк')
    :SetDesc('Продай {goal} шоколадок')
    :AddHook('WayDealerSell', function(self, owner, ply, class, amount, profit)
        if ply ~= owner then return end
        if class ~= "lucid_choc_chocolate" then return end
        self:AddProgress(amount)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/defusebomb.lua:
waypass.challenges.Create('defusebomb')
    :SetName('Сапер')
    :SetDesc('Разминируй бомбу {goal} раз')
    :AddHook('BombDefused', function(self, owner, police)
        if police ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/doors.lua:
waypass.challenges.Create('doors')
    :SetName('Рантье')
    :SetDesc('Приобрети {goal} дверей')
    :AddHook('playerBuyDoor', function(self, owner, ply, ent)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/props.lua:
waypass.challenges.Create('props')
    :SetName('Спамер')
    :SetDesc('Заспавни {goal} пропов')
    :AddHook('PlayerSpawnedProp', function(self, owner, ply)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/samogon.lua:
waypass.challenges.Create('samogon')
    :SetName('Торгаш')
    :SetDesc('Продай {goal} бочек самогона')
    :AddHook('WayDealerSell', function(self, owner, ply, class, amount, profit)
        if ply ~= owner then return end
        if class ~= "mn_barrel" then return end
        self:AddProgress(amount)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/team.lua:
waypass.challenges.Create('team')
    :SetName('Разнорабочий')
    :SetDesc('Смени профессию {goal} раз')
    :AddHook('OnPlayerChangedTeam', function(self, owner, ply, before, after)
        if ply ~= owner then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/weed.lua:
waypass.challenges.Create('weed')
    :SetName('Гровер')
    :SetDesc('Продай {goal} грамм дури')
    :AddHook('WayDealerSell', function(self, owner, ply, class, amount, profit)
        if ply ~= owner then return end
        if class ~= "sent_weed_bag" then return end
        self:AddProgress(amount)
    end)
:Register()
--addons/module_battlepass/lua/waypass/challenges/winduel.lua:
waypass.challenges.Create('winduel')
    :SetName('Чемпион')
    :SetDesc('Победи в дуэли {goal} раз')
    :AddHook('DuelEnd', function(self, owner, lose, win)
        if owner ~= win then return end
        self:AddProgress(1)
    end)
:Register()
--addons/module_battlepass/lua/waypass/vgui/reward.lua:
local font = 'dorgs.24'
local mat_lock = Material('icon72/lock.png')

local PANEL = {}

function PANEL:Init()
    self.obtainable = true
    self:SetText('')

    --[[
    self.canvas = vgui.Create('DButton', self)
    self.canvas:SetText('')
    self.canvas:Dock(FILL)
    self.canvas:SetPaintBackground(false)
    self.canvas.Paint = function(s,w,h)
        if not self.reward then return end

        if self.material then
            surface.SetDrawColor(color_white)
            surface.SetMaterial(self.material)
            surface.DrawTexturedRect(0,0,w,h)
        end
    end
    self.canvas.DoClick = function()
        self:DoClick()
    end
    ]]
end

AccessorFunc(PANEL, 'material', 'Material')
AccessorFunc(PANEL, 'previewPanel', 'PreviewPanel')
AccessorFunc(PANEL, 'premium', 'Premium')
AccessorFunc(PANEL, 'lvl', 'Level')
AccessorFunc(PANEL, 'bpId', 'BPID')
AccessorFunc(PANEL, 'obtainable', 'Obtainable')
AccessorFunc(PANEL, 'claimed', 'Claimed')
function PANEL:SetObtainable(b)
    self.obtainable = b
    self:SetCursor(b and 'hand' or 'arrow')
    --self.canvas:SetCursor(b and 'hand' or 'arrow')
end
function PANEL:GetBP()
    return waypass.GetBP(self:GetBPID())
end

function PANEL:Paint(w,h)
    draw.RoundedBox(0, 0, 0, w, h, self.premium and waypass.skin.COLOR_PRIMARY or waypass.skin.COLOR_SECONDARY)

    if self.material then
        surface.SetDrawColor(color_white)
        surface.SetMaterial(self.material)
        surface.DrawTexturedRect(2,2,w-4,h-4)
    end
end

function PANEL:PaintOver(w, h)
    if self.claimed then
        draw.RoundedBox(0, 0, 0, w, h, waypass.skin.COLOR_CLAIMED)
    end

    if self.reward then
        --draw.SimpleTextOutlined(self.reward:GetName(self.rewardValue), font, 4, 0, color_white, TEXT_ALIGN_LEFT, TEXT_ALIGN_TOP, 1, color_black)
        draw.SimpleTextOutlined(self.reward.GetCount and self.reward:GetCount(self.rewardValue) or 'x1', font, w-4, h-2, color_white, TEXT_ALIGN_RIGHT, TEXT_ALIGN_BOTTOM, 1, color_black)
    end

    if self:GetPremium() and not LocalPlayer():HasBP(self:GetBPID(), true) then
        draw.RoundedBox(0, w-20, 0, 20, 20, waypass.skin.COLOR_PRIMARY)
        
        surface.SetMaterial(mat_lock)
        surface.SetDrawColor(color_white)
        surface.DrawTexturedRect(w-18, 2, 16, 16)
    end
end

function PANEL:OnCursorEntered()
    if not self.reward then return end
    if self.reward.Preview then
        self.reward:Preview(self.rewardValue, self:GetPreviewPanel())
        hook.Run('waypass.PreviewReward', self, self.reward, self.rewardValue)
    end
    timer.Remove('waypass_debounce_unpreview')
end

function PANEL:OnCursorExited()
    if not self.reward then return end
    timer.Create('waypass_debounce_unpreview', .2, 1, function()
        if IsValid(self) and self.reward.UnPreview then
            self.reward:UnPreview(self.rewardValue, self:GetPreviewPanel())
            hook.Run('waypass.UnPreviewReward', self, self.reward, self.rewardValue)
        end
    end)
end

function PANEL:SetReward(type, val)
    local reward = waypass.rewards[type]
    self.reward = reward
    self.rewardValue = val
    
    if reward.GetMaterial then
        local mat = reward:GetMaterial(val)
        self:SetMaterial(isstring(mat) and Material(mat) or mat)
    elseif reward.Panel then
        self.canvas.Paint = wlib.func.blank
        reward:Panel(val, self.canvas)
    elseif reward.Paint then
        self.canvas.Paint = reward.Paint
    end
end

function PANEL:DoClick()
    if self:GetClaimed() or not self:GetObtainable() or not self.reward then return end

    waypass.ClaimRewards(self:GetBPID(), self:GetLevel(), self:GetPremium())
end

vgui.Register('waypass_reward', PANEL, 'DButton')
--MediaLib_DynFile_webradio.lua:
local a=medialib.load("oop")local b=a.class("WebRadioService","BASSService")b.identifier="webradio"local c={"^https?://(.*)%.pls","^https?://(.*)%.m3u"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;function b:resolveUrl(d,h)h(d,{})end;function b:directQuery(d,h)h(nil,{title=d:match("([^/]+)$")})end;return b
--MediaLib_DynFile_twitch.lua:
local a=medialib.load("oop")local b=a.class("TwitchService","HTMLService")b.identifier="twitch"local c={"https?://www.twitch.tv/([A-Za-z0-9_%-]+)","https?://twitch.tv/([A-Za-z0-9_%-]+)"}function b:parseUrl(d)for e,f in pairs(c)do local g=string.match(d,f)if g then return{id=g}end end end;function b:isValidUrl(d)return self:parseUrl(d)~=nil end;local h="https://wyozi.github.io/gmod-medialib/twitch.html?channel=%s"function b:resolveUrl(d,i)local j=self:parseUrl(d)local k=string.format(h,j.id)i(k,{start=j.start})end;local l="4cryixome326gh0x0j0fkulahsbdvx"local function m(n,i)http.Fetch("https://api.twitch.tv/kraken/users?login="..n,function(o)local p=util.JSONToTable(o)if not p then i("malformed response JSON")return end;i(nil,p.users[1]._id)end,function()i("failed HTTP request")end,{Accept="application/vnd.twitchtv.v5+json",["Client-ID"]=l})end;local function q(g,i)http.Fetch("https://api.twitch.tv/kraken/channels/"..g,function(o)local p=util.JSONToTable(o)if not p then i("malformed response JSON")return end;i(nil,p)end,function()i("failed HTTP request")end,{Accept="application/vnd.twitchtv.v5+json",["Client-ID"]=l})end;function b:directQuery(d,i)local j=self:parseUrl(d)m(j.id,function(r,g)if r then i(r)return end;q(g,function(s,t)if s then i(s)return end;local u={}u.id=j.id;if t.error then i(t.message)return else u.title=t.display_name..": "..t.status end;i(nil,u)end)end)end;return b
--MediaLib_DynFile_soundcloud.lua:
local a=medialib.load("oop")local b=a.class("SoundcloudService","BASSService")b.identifier="soundcloud"local c={"^https?://www.soundcloud.com/([A-Za-z0-9_%-]+/[A-Za-z0-9_%-]+)/?.*$","^https?://soundcloud.com/([A-Za-z0-9_%-]+/[A-Za-z0-9_%-]+)/?.*$"}local d="^https?://api.soundcloud.com/tracks/(%d+)"function b:parseUrl(e)for f,g in pairs(c)do local h=string.match(e,g)if h then return{path=h}end end;local i=string.match(e,d)if i then return{id=i}end end;function b:isValidUrl(e)return self:parseUrl(e)~=nil end;function b:resolveUrl(e,j)local k=medialib.SOUNDCLOUD_API_KEY;if not k then ErrorNoHalt("SoundCloud error: Missing SoundCloud API key")return end;if type(k)=="table"then k=table.Random(k)end;local l=self:parseUrl(e)if l.id then j(string.format("https://api.soundcloud.com/tracks/%s/stream?client_id=%s",l.id,k),{})else http.Fetch(string.format("https://api.soundcloud.com/resolve.json?url=http://soundcloud.com/%s&client_id=%s",l.path,k),function(m)local n=util.JSONToTable(m)if not n then ErrorNoHalt("Failed to retrieve SC track id for "..l.path..": empty JSON")return end;local i=n.id;j(string.format("https://api.soundcloud.com/tracks/%s/stream?client_id=%s",i,k),{})end)end end;function b:directQuery(e,j)local k=medialib.SOUNDCLOUD_API_KEY;if not k then j("Missing SoundCloud API key")return end;if type(k)=="table"then k=table.Random(k)end;local l=self:parseUrl(e)local o;if l.path then o=string.format("https://api.soundcloud.com/resolve.json?url=http://soundcloud.com/%s&client_id=%s",l.path,k)else o=string.format("https://api.soundcloud.com/tracks/%s?client_id=%s",l.id,k)end;http.Fetch(o,function(p,q)if q==0 then j("http body size = 0")return end;local r=util.JSONToTable(p)if r.errors then local s=r.errors[1].error_message or"error"local t=s;if string.StartWith(s,"404")then t="Invalid id"end;j(t)return end;j(nil,{title=r.title,duration=tonumber(r.duration)/1000})end,function(u)j("HTTP: "..u)end)end;return b
--addons/module_scoreboard/lua/wayscore/vgui/playerrow.lua:
local usergroups = {
    ['superadmin'] = 'icon72/wrench.png',
    ['WayZer Team'] = 'icon72/scales.png',
    ['Trusted'] = 'icon72/eagle.png',
    ['admin'] = 'icon72/shield.png',
    ['moder'] = 'icon72/military_medal.png',
    ['+Helper'] = 'icon72/briefcase.png',
    ['Helper'] = 'icon72/briefcase.png',
    ['+Eventer'] = 'icon72/beginner.png',
    ['Eventer'] = 'icon72/game_die.png',
    ['Patron'] = 'icon72/crown.png',
    ['Curator'] = 'icon72/gem.png',
    ['DSAdmin'] = 'icon72/fleur_de_lis.png',
    ['DAdmin'] = 'icon72/diamond_shape_with_a_dot_inside.png',
    ['DModerator'] = 'icon72/trident.png',
    ['VIP'] = 'icon72/doughnut.png',
    ['user'] = 'icon72/cactus.png',
}

local PANEL = {}

function PANEL:Init()
    self:SetText('')
    self:SetTall(32)
    self:Dock(TOP)
    self:DockMargin(5, 0, 5, 7)

    local iconsize = 20
    self.Usergroup = vgui.Create('DImageButton', self)
    self.Usergroup:SetSize(iconsize, iconsize)
    self.Usergroup:SetPos((self:GetTall()-iconsize)/2, (self:GetTall()-iconsize)/2)
    self.Usergroup:SetImage('icon16/user.png')

    self.Usergroup.OnCursorEntered = function() self:OnCursorEntered() end
    self.Usergroup.OnCursorExited = function() self:OnCursorExited() end
    self.Usergroup.DoClick = function() self:DoClick() end

    self.Avatar = vgui.Create('AvatarImage', self)
    self.Avatar:SetSize(self:GetTall() - 4, self:GetTall() - 4)
    self.Avatar:SetPos(self:GetTall(), 2)

    self.Avatar.Button = vgui.Create('DButton', self.Avatar)
    self.Avatar.Button:Dock(FILL)
    self.Avatar.Button:SetText('')
    self.Avatar.Button.Paint = wlib.func.blank
    self.Avatar.Button.DoClick = function()
        if IsValid(self.ply) then
            gui.OpenURL('https://steamcommunity.com/profiles/'..self.ply:SteamID64())
        end
    end

    self.Avatar.Button.OnCursorEntered = function() self:OnCursorEntered() end
    self.Avatar.Button.OnCursorExited = function() self:OnCursorExited() end

    self.Info = {}
    for k, v in ipairs(wayscore.info or {}) do
        if v.check and not v.check() then continue end

        table.insert(self.Info, table.Copy(v))
    end
end

function PANEL:SetPlayer(pl)
    self.ply = pl
    self.Avatar:SetSteamID(pl:SteamID64(), 32)

    local icon = usergroups[pl:GetUserGroup()]
    self.Usergroup:SetTooltip(pl:GetUserGroup())
    self.Usergroup:SetIcon(icon or 'icon16/user.png')

    self.friend = pl == LocalPlayer() or pl:GetFriendStatus() == 'friend'
end

function PANEL:OnCursorEntered()
    self.Color = Color(self.TeamColor.r+15, self.TeamColor.g+15, self.TeamColor.b+15)
end

function PANEL:OnCursorExited()
    self.Color = self.TeamColor
end

local function getx(offset, tw, align)
    if align == TEXT_ALIGN_CENTER then
        return offset+tw/2
    elseif align == TEXT_ALIGN_LEFT then
        return offset
    elseif align == TEXT_ALIGN_RIGHT then
        return offset+tw
    end
end

local gradient = Material("vgui/gradient-l")

function PANEL:Paint(w, h)
    
    if self.ply.ProfileCover then
        surface.SetDrawColor(color_white)
        surface.SetMaterial(self.ply.ProfileCover)
        surface.DrawTexturedRect(0,-10,w,180)
        surface.SetDrawColor(self.Color or self.TeamColor or color_black)
        surface.SetMaterial(gradient)
        surface.DrawTexturedRect(0,0,w,h)
    else
        draw.RoundedBox(4, 0, 0, w, h, self.Color or self.TeamColor or color_black)
    end

    if self.friend then
        surface.SetTexture(0)
        surface.SetDrawColor(255, 255, 255, 50 + math.sin(RealTime() * 2) * 50)
        surface.DrawTexturedRect(0, 0, w, h)
    end

    w = w-self:GetTall()*2-16+4
    local offset = self:GetTall()*2+4
    for i=1, #self.Info do
        v = self.Info[i]
        if not v.value then continue end

        local piece = w*v.size

        local x = v.center and self:GetTall()*2+4 + w/2 or getx(offset, piece, v.align)
        draw.SimpleText(v.value, 'wayscore.small', x, h/2, color_white, v.align, TEXT_ALIGN_CENTER, 1, color_black)

        offset = offset+piece
    end

    --[[
    if self.ply.IsAFK and self.ply:IsAFK() then
        draw.SimpleText('AFK', 'wayscore.small', self:GetParent():GetWide() / 1.03 - select(1, surface.GetTextSize('AFK') / 2), 13, Color(244, 244, 244), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
    ]]
end

function PANEL:DoClick()
    if not IsValid(self.ply) then
        self:Remove()
        return
    end

    wayscore:SelectView('player', self.ply)
end

function PANEL:DoRightClick()
    local actions = wlib.array.filter(wayscore.ActionButtons, function(val) return val.rightClick end)
    if #actions == 0 then return end

    local menu = DermaMenu()
    menu:SetPos(gui.MouseX(), gui.MouseY())

    local time = string.FormattedTime(self.ply:GetUTimeTotalTime())
    menu:AddOption(('Общий онлайн: %02i:%02i:%02i'):format(time.h, time.m, time.s)):SetIcon('icon72/clock.png')

    menu:AddOption('Скопировать SteamID', function()
        SetClipboardText(self.ply:SteamID())
    end):SetIcon('icon72/label.png')

    menu:AddSpacer()
    
    for _, v in SortedPairsByMemberValue(actions, 'order') do
        if v.check and not v.check(self.ply) then continue end

        local opt = menu:AddOption(isfunction(v.name) and v.name(self.ply) or v.name, function(opt)
            if IsValid(self.ply) then
                v.callback(self.ply, opt)
            end
        end)
        opt.SetImage2 = wlib.func.blank

        local imageType = TypeID(v.icon)
        if imageType == TYPE_STRING then
            opt:SetIcon(v.icon)
        elseif imageType == TYPE_TABLE then
            opt:SetIcon(v.icon[1])
        elseif imageType == TYPE_FUNCTION then
            opt:SetIcon(v.icon(ply))
        end
    end

    menu:Open()
end

function PANEL:Think()
    if (not self.PlayerUpdate or self.PlayerUpdate < CurTime()) and self:IsVisible() then
        if not self.ply or not self.ply:IsValid() then
            self:Remove()
            return
        end

        self.PlayerUpdate = CurTime() + math.random(.5, 1)

        self:SetPlayer(self.ply)
        self.TeamColor = hook.Run('wayscore.PlayerRowColor', self.ply) or team.GetColor(self.ply:Team())
        for _, v in ipairs(self.Info) do
            v.value = v.get(self.ply)
        end
    end
end

vgui.Register('wayscore_player', PANEL, 'Button')
--addons/_cfg/lua/config/maps/rp_bangclaw.lua:
CFG.bank_carposes = {
    {
        Vector(3020, -2990, 94),
        Angle(0, 180, 0),
    },
    {
        Vector(4988, -1731, 96),
        Angle(0, 30, 0),
    },
}

CFG.bank_aabox = {
    Vector(3712, -3976, 48),
    Vector(4354, -3517, 319),
}

CFG.bank_ventpos = Vector(3640, -3574, 136)
--addons/_wlib/lua/wlib/libraries/nw.lua:
--[[
local var = nw.Register 'MyVar' 	-- You MUST call this ALL shared
	var:Write(net.WriteUInt, 32) 	-- Write function
	var:Read(net.ReadUInt, 32) 		-- Read function
	var:SetPlayer() 				-- Registers the var for use on players
	var:SetLocalPlayer() 			-- Optionally set the var to only network to the player its set on, no need to call SetPlayer with this
	var:SetGlobal() 				-- Registers the var for use with nw.SetGlobal
	var:SetNoSync() 				-- Stops the var from syncing to new players, SetLocalPlayer does this for you.
	var:Filter(function(ent, value) -- Sets a var to only send to players you return in your callback
		return player.GetWhatever() -- return table players
	end)
	var:SetChangeOnDeath(newval)	-- changes var value to newval on death (may be function)

nw.WaitForPlayer(player, callback) 	-- Calls your callback when the player is ready to recieve net messages

-- Set Functions
ENTITY:SetNetVar(var, value)
nw.SetGlobal(var, value)

-- Get functions
ENTITY:GetNetVar(var)
nw.GetGlobal(var)
]]


nw = nw or {
	Data = {
		[0] = {}
	},
	Vars = {},
	Mappings = {},
	Callbacks = {}
}

local vars 		= nw.Vars
local mappings 	= nw.Mappings
local data 		= nw.Data
local globals 	= data[0]
local callbacks = nw.Callbacks

local NETVAR 	= {}
NETVAR.__index 	= NETVAR

debug.getregistry().Netvar = NETVAR

local bitmap 	= {
	[3]		= 3,
	[7] 	= 4,
	[15] 	= 5,
	[31] 	= 6,
	[63] 	= 7,
	[127] 	= 8,
	[255] 	= 9,
	[511]	= 10
}

local bitcount 	= 2

local ENTITY 	= FindMetaTable 'Entity'

local pairs 	= pairs
local Entity 	= Entity

local net_WriteUInt = net.WriteUInt
local net_ReadUInt 	= net.ReadUInt
local net_Start 	= net.Start
local net_Send 		= (SERVER) and net.Send or net.SendToServer
local net_Broadcast = net.Broadcast
local sorted_pairs 	= SortedPairsByMemberValue

function nw.Register(var) -- You must always call this on both the client and server. It will serioulsy break shit if you don't.
	local t = {
		Name = var,
		NetworkString = 'nw_' .. var,
		WriteFunc = net.WriteType,
		ReadFunc = net.ReadType,
		SendFunc = function(self, ent, value, recipients)
			if (recipients ~= nil) then
				net_Send(recipients)
			else
				net_Broadcast()
			end
		end,
	}
	setmetatable(t, NETVAR)
	vars[var] = t

	if (SERVER) then
		util.AddNetworkString(t.NetworkString)
	else
		net.Receive(t.NetworkString, function()
			local index, value = t:_Read()

			if (not data[index]) then
				data[index] = {}
			end

			local oldValue = data[index][var]
			data[index][var] = value

			t:_CallHook(index, value, oldValue)
		end)
	end

	return t:_Construct()
end

function NETVAR:Write(func, opt)
	self.WriteFunc = function(value)
		func(value, opt)
	end
	return self:_Construct()
end

function NETVAR:Read(func, opt)
	self.ReadFunc = function()
		return func(opt)
	end
	return self:_Construct()
end

function NETVAR:Filter(func)
	self.SendFunc = function(self, ent, value, recipients)
		net_Send(recipients or func(ent, value))
	end
	return self:_Construct()
end

function NETVAR:SetPlayer()
	self.PlayerVar = true
	return self:_Construct()
end

function NETVAR:SetLocalPlayer()
	self.LocalPlayerVar = true
	return self:_Construct()
end

function NETVAR:SetGlobal()
	self.GlobalVar = true
	return self:_Construct()
end

function NETVAR:SetNoSync()
	self.NoSync = true
	return self:_Construct()
end

function NETVAR:SetChangeOnDeath(val)
	self.ChangeOnDeath = true
	self.ChangeOnDeathVal = val
	return self:_Construct()
end

function NETVAR:Accessor(name)
	name = name or self.Name
	if SERVER then
		ENTITY["Set" .. name] = function(ent, value)
			ent:SetNetVar(self.Name, value)
		end
	end
	ENTITY["Get" .. name] = function(ent)
		return ent:GetNetVar(self.Name)
	end
	return self
end

function NETVAR:SetHook(name)
	self.Hook = name
	return self
end

function NETVAR:_Send(ent, value, recipients)
	net_Start(self.NetworkString)
		self:_Write(ent, value)
	self:SendFunc(ent, value, recipients)
end

function NETVAR:_CallHook(index, value, oldValue)
	if self.Hook then
		if (index ~= 0) then
			hook.Call(self.Hook, GAMEMODE, Entity(index), value, oldValue)
		else
			hook.Call(self.Hook, GAMEMODE, value, oldValue)
		end
	end
end

function NETVAR:_Construct()
	local WriteFunc = self.WriteFunc
	local ReadFunc 	= self.ReadFunc

	if self.PlayerVar then
		self._Write = function(self, ent, value)
			net_WriteUInt(ent:EntIndex(), 8)
			WriteFunc(value)
		end
		self._Read = function(self)
			return net_ReadUInt(8), ReadFunc()
		end
	elseif self.LocalPlayerVar then
		self._Write = function(self, ent, value)
			WriteFunc(value)
		end
		self._Read = function(self)
			return LocalPlayer():EntIndex(), ReadFunc()
		end
		self.SendFunc = function(self, ent, value, recipients)
			net_Send(ent)
		end
	elseif self.GlobalVar then
		self._Write = function(self, ent, value)
			WriteFunc(value)
		end
		self._Read = function(self)
			return 0, ReadFunc()
		end
	else
		self._Write = function(self, ent, value)
			net_WriteUInt(ent:EntIndex(), 13)
			WriteFunc(value)
		end
		self._Read = function(self)
			return net_ReadUInt(13), ReadFunc()
		end
	end

	nw.Mappings = {}
	mappings = nw.Mappings
	for k, v in sorted_pairs(vars, 'Name', false) do
		local c = #mappings + 1
		vars[k].ID = c
		mappings[c] = v
		if bitmap[c] then
			bitcount = bitmap[c]
		end
	end

	return self
end

function nw.GetGlobal(var, fallback)
	if globals[var] == nil then return fallback end
	return globals[var]
end

function ENTITY:GetNetVar(var, fallback)
	local index = self:EntIndex()
	local val = data[index] and data[index][var]
	if val == nil then return fallback end
	return val
end

if (SERVER) then
	util.AddNetworkString 'nw.PlayerSync'
	util.AddNetworkString 'nw.NilEntityVar'
	util.AddNetworkString 'nw.NilPlayerVar'
	util.AddNetworkString 'nw.EntityRemoved'
	util.AddNetworkString 'nw.PlayerRemoved'

	net.Receive('nw.PlayerSync', function(len, pl)
		if (pl.EntityCreated ~= true) then
			hook.Call('PlayerEntityCreated', GAMEMODE, pl)

			pl.EntityCreated = true

			for index, _vars in pairs(data) do
				for var, value in pairs(_vars) do
					local ent = Entity(index)
					if (not vars[var].LocalPlayerVar and not vars[var].NoSync) or (ent == pl) then
						vars[var]:_Send(ent, value, pl)
					end
				end
			end

			if (callbacks[pl] ~= nil) then
				for i = 1, #callbacks[pl] do
					callbacks[pl][i](pl)
				end
			end
			callbacks[pl] = nil
		end
	end)

	hook.Add('PlayerInitialSpawn', 'nw.PlayerEntityCreated', function(ply)
		timer.Simple(60, function()
			if IsValid(ply) and ply.EntityCreated ~= true then
				hook.Call('PlayerEntityCreated', GAMEMODE, ply)
			end
		end)
	end)

	hook.Add('EntityRemoved', 'nw.EntityRemoved', function(ent)
		local index = ent:EntIndex()

		if (index ~= 0) and (data[index] ~= nil) then -- For some reason this kept getting called on Entity(0), not sure why...
			if ent:IsPlayer() then
				net_Start('nw.PlayerRemoved')
					net_WriteUInt(index, 8)
				net_Broadcast()
			else
				net_Start('nw.EntityRemoved')
					net_WriteUInt(index, 13)
				net_Broadcast()
			end

			data[index] = nil
		end
	end)

	function nw.WaitForPlayer(pl, cback)
		if (pl.EntityCreated == true) then
			cback(pl)
		else
			if (callbacks[pl] == nil) then
				callbacks[pl] = {}
			end
			callbacks[pl][#callbacks[pl] + 1] = cback
		end
	end

	function nw.SetGlobal(var, value)
		globals[var] = value
		if (value ~= nil) then
			vars[var]:_Send(0, value)
		else
			net_Start('nw.NilEntityVar')
				net_WriteUInt(0, 13)
				net_WriteUInt(vars[var].ID, bitcount)
			vars[var]:SendFunc(0, value)
		end
	end

	function ENTITY:SetNetVar(var, value)
		local index = self:EntIndex()

		if (not data[index]) then
			data[index] = {}
		end

		data[index][var] = value

		if (value ~= nil) then
			vars[var]:_Send(self, value)
		else
			if self:IsPlayer() then
				net_Start('nw.NilPlayerVar')
				net_WriteUInt(index, 8)
			else
				net_Start('nw.NilEntityVar')
				net_WriteUInt(index, 13)
			end
			net_WriteUInt(vars[var].ID, bitcount)
			vars[var]:SendFunc(self, value)
		end
	end

	hook.Add('PostPlayerDeath', 'nw.ChangeOnDeath', function(ply)
		for var, oldval in pairs(data[ply:EntIndex()] or {}) do
			if not vars[var].ChangeOnDeath then continue end

			local setvar = vars[var].ChangeOnDeathVal
			if isfunction(setvar) then
				ply:SetNetVar(var, setvar(oldval))
			else
				ply:SetNetVar(var, setvar)
			end
		end
	end)
else
	hook.Add('InitPostEntity', 'nw.InitPostEntity', function()
		net_Start('nw.PlayerSync')
		net_Send()
	end)

	local function nwNilVar(index, id)
		if data[index] and mappings[id] then
			local oldValue = data[index][mappings[id].Name]
			data[index][mappings[id].Name] = nil
			mappings[id]:_CallHook(index, nil, oldValue)
		end
	end

	net.Receive('nw.NilEntityVar', function()
		nwNilVar(net_ReadUInt(13), net_ReadUInt(bitcount))
	end)

	net.Receive('nw.NilPlayerVar', function()
		nwNilVar(net_ReadUInt(8), net_ReadUInt(bitcount))
	end)

	net.Receive('nw.EntityRemoved', function()
		data[net_ReadUInt(13)] = nil
	end)

	net.Receive('nw.PlayerRemoved', function()
		data[net_ReadUInt(8)] = nil
	end)
end
--addons/_wlib/lua/wlib/modules/oop.lua:
function wlib.accessor(tbl, key, name, force)
    tbl['Get'..name] = function(self)
        return self[key]
    end
    tbl['Set'..name] = function(self, val)
        self[key] = val
        return self
    end
end
--addons/_wlib/lua/wlib/modules/requests/client.lua:
wlib.requests = wlib.requests or {}
wlib.requests.frames = wlib.requests.frames or {}

local frames = wlib.requests.frames

function wlib.requests.buildFrame(id, fields)
    if IsValid(frames[id]) then frames[id]:Remove() end

    frames[id] = vgui.Create('DFrame')
    local frame = frames[id]
    frame:SetWide(350)
    frame:SetTitle('')
    frame:SetSkin('WayZer')
    frame:MakePopup()
    frame:SetBackgroundBlur(true)
    --frame:ShowCloseButton(false)
    frame:SetDraggable(false)

    frame.OnClose = function(self)
        net.Start('wlib.request.fail')
        net.WriteString(id)
        net.SendToServer()
    end

    local panels = {}

    local scroll = vgui.Create('DScrollPanel', frame)
    scroll:Dock(TOP)
    for _, data in ipairs(fields) do
        local panel = data.field.vgui(data)
        panel:SetParent(scroll)
        panel:Dock(TOP)
        panel:DockMargin(4,6,4,0)

        table.insert(panels, panel)
    end

    local accept = vgui.Create('DButton', frame)
    accept:Dock(TOP)
    accept:DockMargin(0,12,0,0)
    accept:SetTall(25)
    accept:SetText('Готово')
    accept:SetIcon('icon16/accept.png')

    accept.DoClick = function()
        local sending = {}

        net.Start('wlib.request')
        net.WriteString(id)
        for k, data in ipairs(fields) do
            if not data.field.send then continue end

            local value = data.field.getValue(data, panels[k])

            if data.field.check then
                local res, err = data.field.check(data, value)
                if res == false then return notification.AddLegacy(err, 1, 5) end
            end

            data.field.send(value)

            table.insert(sending, value)
        end
        net.SendToServer()

        frame:Remove()
    end

    scroll:InvalidateChildren(true)
    scroll:InvalidateLayout(true)
    scroll:SizeToChildren(false, true)
    scroll:SetTall(math.min(scroll:GetTall(), ScrH()-100))

    frame:InvalidateLayout(true)
    frame:SizeToChildren(false, true)
    frame:Center()

    return frame
end

net.Receive('wlib.request', function()
    local id = net.ReadString()
    local fields = {}

    for i=1, net.ReadUInt(4) do
        local id = net.ReadString()
        local field = wlib.requests.fields[id]
        assert(field, 'Field ID "'..id..'" not found')

        local data = field.receive()
        data.type = id
        data.field = field

        table.insert(fields, data)
    end

    if hook.Run('wlib.requests.customFrame', id, fields) then return end

    wlib.requests.buildFrame(id, fields)
end)

net.Receive('wlib.request.fail', function()
    local id = net.ReadString()
    if IsValid(frames[id]) then frames[id]:Remove() end
end)

local function boolSend(id, value)
    net.Start('wlib.request')
    net.WriteString(id)
    net.WriteBool(value)
    net.SendToServer()
end
hook.Add('wlib.requests.customFrame', '_bool', function(id, fields)
    if #fields ~= 1 then return end
    local field = fields[1]
    if field.type ~= 'bool' then return end

    Derma_Query(field.name, '', 'Да', fp{boolSend, id, true}, 'Нет', fp{boolSend, id, false})
    return true
end)
--addons/_wlib/lua/wlib/modules/_client/panels.lua:
wlib.panels = wlib.panels or {}

function wlib.panels.overlay(parent, pnl, persist, bg)
	local o = vgui.Create(persist and 'DPanel' or 'DButton')
	if IsValid(pnl) then parent:Add(o) end

	local p
	if isstring(pnl) then
		p = o:Add(pnl)
	else
		pnl:SetParent(o)
		p = pnl
	end

	function o:Think()
		local par = self:GetParent()
		if not IsValid(par) then return end

		local newW, newH = par:GetSize()
		if newW ~= self.overlay_oldW or self.overlay_oldH ~= newH then
			self:SetPos(0, 0)
			self:SetSize(newW, newH)
			if IsValid(p) then p:Center() end
		end
		self.overlay_oldW, self.overlay_oldH = newW, newH
	end

	o.bgCol = bg or Color(0,0,0,200)
	function o:Paint(w, h)
		draw.RoundedBox(4, 0, 0, w, h, self.bgCol)
	end

	if not persist then
		o:SetText('')
		function o:DoClick()
			self:Remove()
		end
	end

    p.OnRemove = function() o:Remove() end

	return p, o
end

local tooltip
function wlib.panels.tooltip(parent, pnl)
	if not IsValid(tooltip) then
		tooltip = vgui.Create('DPanel')
		tooltip:DockPadding(4,4,4,4)
		tooltip:MakePopup()
		tooltip:SetMouseInputEnabled(false)
		tooltip:SetKeyboardInputEnabled(false)
	end

	tooltip:SetSize(pnl:GetWide()+8, pnl:GetTall()+8)
	pnl:SetParent(tooltip)
	pnl:Center()

	tooltip.Think = function(s)
		if not IsValid(parent) or not parent:IsVisible() then return s:Remove() end
		s:SetPos(parent:LocalToScreen(parent:GetWide()/2-tooltip:GetWide()/2, -tooltip:GetTall()))
	end
end

function wlib.panels.removeTooltip()
	if IsValid(tooltip) then tooltip:Remove() end
end

function wlib.panels.iconPicker(callback, q)
	
end
--addons/_wlib/lua/wlib/vgui/graph.lua:
local PANEL = {}

function PANEL:Init()
    self.points = {}

    self.gapx = 25
    self.gapy = 25
    self.minx = -10
    self.maxx = 10
    self.miny = -10
    self.maxy = 10
    self.lineColor = Color(200, 0, 0)
    self.tooltipColor = Color(0, 124, 0)
    self.tooltipTextColor = color_white
    self.tooltipFont = 'DermaDefault'
    self.lineThickness = 1
end
wlib.accessor(PANEL, 'equalGap', 'EqualGap')
wlib.accessor(PANEL, 'gapx', 'GapX')
wlib.accessor(PANEL, 'gapy', 'GapY')
wlib.accessor(PANEL, 'minx', 'MinX')
wlib.accessor(PANEL, 'maxx', 'MaxX')
wlib.accessor(PANEL, 'miny', 'MinY')
wlib.accessor(PANEL, 'maxy', 'MaxY')
wlib.accessor(PANEL, 'lineColor', 'LineColor')
wlib.accessor(PANEL, 'gridColor', 'GridColor')
wlib.accessor(PANEL, 'tooltipColor', 'TooltipColor')
wlib.accessor(PANEL, 'tooltipTextColor', 'TooltipTextColor')
wlib.accessor(PANEL, 'tooltipFont', 'TooltipFont')
wlib.accessor(PANEL, 'lineThickness', 'LineThickness')

function PANEL:SetMinMaxX(min, max)
    self.minx, self.maxx = min, max
    return self
end

function PANEL:SetMinMaxY(min, max)
    self.miny, self.maxy = min, max
    return self
end

function PANEL:AutoMinMax()
    if #self.points == 0 then return end

    local minx, maxx, miny, maxy = self.points[1][1], self.points[#self.points][1], math.huge, -math.huge
    for _, v in ipairs(self.points) do
        miny = math.min(miny, v[2])
        maxy = math.max(maxy, v[2])
    end

    --local offsetX, offsetY = math.ceil(20/self.gapx), math.ceil(20/self.gapy)
    local offsetX, offsetY = 2, 2

    self:SetMinMaxX(minx-offsetX, maxx+offsetX)
    self:SetMinMaxY(miny-offsetY, maxy+offsetY)
end

function PANEL:AutoGap()
    local gapx = self:GetWide()/(self.maxx-self.minx)
    local gapy = self:GetTall()/(self.maxy-self.miny)

    if self.equalGap then
        gapx = math.min(gapx, gapy)
        gapy = gapx
    end

    self:SetGapX(gapx)
    self:SetGapY(gapy)
end

function PANEL:PerformLayout(w, h)
    self:AutoGap()
end

function PANEL:AddPoint(x, y, extra)
    local point = {x, y}
    if extra then
        table.Merge(point, extra)
    end
    point.tooltip = self:GenerateTooltip(point)
    
    local fst = self.points[1]
    if fst and fst[1] > x then
        table.insert(self.points, 1, point)
        return
    end

    for k, v in ipairs(self.points) do
        if v[1] == x then
            self.points[k] = point
            return
        elseif v[1] > x then
            table.insert(self.points, k, point)
            return
        end
    end
    table.insert(self.points, point)
end

function PANEL:Clear()
    self.points = {}
end

function PANEL:FindRelativePos(p)
    return (p[1] - self.minx)*self.gapx, (self.maxy-p[2])*self.gapy
end

local function drawDot(x, y, radius, color)
    surface.SetDrawColor( color or color_white )

    local verts = {}
    for a = 0, 360 do
        local ang = math.rad( a )
        verts[#verts + 1] = { x = x + math.cos( ang ) * radius, y = y + math.sin( ang ) * radius }
    end

    draw.NoTexture()
    surface.DrawPoly( verts )
end

function PANEL:Paint(w, h)
    if self.gridColor then
        draw.Grid(0, 0, w, h, self.gapx, self.gapy, self.gridColor)
    end

    for i = 1, #self.points - 1 do
        local p1, p2 = self.points[i], self.points[i+1]
        local relX1, relY1 = self:FindRelativePos(p1)
        local relX2, relY2 = self:FindRelativePos(p2)
        if relX1 < 0 or relY1 < 0 or relX2 < 0 or relY2 < 0 then continue end

        local angle = math.atan2(relY2 - relY1, relX2 - relX1)
        local offsetX = math.sin(angle) * self.lineThickness
        local offsetY = math.cos(angle) * self.lineThickness

        surface.SetDrawColor(self.lineColor)
        draw.NoTexture()
        surface.DrawPoly({
            {x = relX1 - offsetX, y = relY1 + offsetY},
            {x = relX1 + offsetX, y = relY1 - offsetY},
            {x = relX2 + offsetX, y = relY2 - offsetY},
            {x = relX2 - offsetX, y = relY2 + offsetY},
        })
    end

    if self.hovered then
        local p = self.hoveredPoint
        if not p or not p.tooltip then return end
        local x, y = self:FindRelativePos(p)

        draw.RoundedBox(2, x - 2, y - 2, 4, 4, self.tooltipTextColor)

        surface.SetFont(self.tooltipFont)

        local tw, th = surface.GetTextSize(p.tooltip)
        tw = tw + 8
        th = th + 8
        local tx, ty = math.max(x-tw/2, 0), math.max(y-10-th, 0)
        if tx+tw > w then tx = w-tw end

        draw.RoundedBox(0, tx, ty, tw, th, self.tooltipColor)
        draw.DrawText(p.tooltip, self.tooltipFont, tx + 4, ty + 4, self.tooltipTextColor, TEXT_ALIGN_LEFT)
    end
end


--[[
    surface.SetDrawColor(self.lineColor)
    for i=1, #self.points-1 do
        local p1, p2 = self.points[i], self.points[i+1]
        local relX1, relY1 = self:FindRelativePos(p1)
        local relX2, relY2 = self:FindRelativePos(p2)
        if relX1 < 0 or relY1 < 0 or relX2 < 0 or relY2 < 0 then continue end

        surface.DrawLine(relX1, relY1, relX2, relY2)
    end
]]

function PANEL:Think()
    local mx, my = self:ScreenToLocal(input.GetCursorPos())
    self.hovered = mx > 0 and mx < self:GetWide() and my > 0 and my < self:GetTall()
    self.mx, self.my = mx, my

    if not self.hovered then return end

    self.hoveredPoint = nil
    for i=1, #self.points-1 do
        local p = self.points[i]
        local rel1 = self:FindRelativePos(p)
        local rel2 = self:FindRelativePos(self.points[i+1])
        
        if math.abs(rel1-mx) <= math.abs(rel2-mx) then
            self.hoveredPoint = p
            break
        end
    end
    if not self.hoveredPoint then self.hoveredPoint = self.points[#self.points] end
end

function PANEL:UpdateTooltips()
    for _, p in ipairs(self.points) do
        p.tooltip = self:GenerateTooltip(p)
    end
end

function PANEL:GenerateTooltip(p)
    return ('x = %.2f'):format(p[1]) .. '\n' .. ('y = %.2f'):format(p[2])
end

vgui.Register('wlib.graph', PANEL, 'DPanel')

--[[

local f = vgui.Create('DFrame')
f:SetSize(600, 600)
f:Center()
f:MakePopup()

local g = vgui.Create('wlib.graph', f)
g:Dock(FILL)
for x=-50, 50 do
	g:AddPoint(math.random(x^2))
end

g:AutoMinMax()
g:UpdateTooltips()

]]
--addons/module_scoreboard/lua/wayscore/vgui/frame.lua:
local opacity = CreateClientConVar('wayscore_opacity', 0.95, true)

local PANEL = {}

local circlered = Material('icon72/red_circle.png')
local yellowcircle = Material('icon72/yellow_circle.png')
local greencircle = Material('icon72/green_circle.png')
local dbackColor = Color(120, 35, 4)
local backColor = Color(186, 55, 14)

function PANEL:Init()
    self:SetSize(math.min(965, ScrW() - 100), math.max(ScrH() - 300, 400))
    self:Center()
    self.Headder = vgui.Create('DPanel', self)
    self.Headder:SetTall(30)
    self.Headder:Dock(TOP)
    self.BackButton = vgui.Create('DButton', self)
    self.BackButton:SetText('')
    self.BackButton:SetPos(10, 5)
    self.BackButton:SetSize(20,20)
    self.BackButton.FontColor = Color( 236, 240, 241)
    
    function self.BackButton:Paint(w, h)
        if wayscore.view == 'main' then return end 
        draw.RoundedBox(2, 0, 0, w, h, dbackColor)
        draw.RoundedBox(2, 0, 0, w, h-2, backColor)
        draw.SimpleText('X', 'wayscore.small', w / 2, h / 2, self.FontColor, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    end

    function self.BackButton:DoClick()
        if wayscore.view == 'main' then return end
        wayscore:SelectView('main')
    end

    function self.Headder:Paint(w, h)
        draw.RoundedBox(6, 0, 0, w, h, Color(47, 52, 57))
        if wayscore.view ~= 'main' then return end 
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( circlered )
        surface.DrawTexturedRect( 16, 10, 12, 12 )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( yellowcircle )
        surface.DrawTexturedRect( 32, 10, 12, 12 )
        surface.SetDrawColor( 255, 255, 255, 255 )
        surface.SetMaterial( greencircle )
        surface.DrawTexturedRect( 48, 10, 12, 12 )
    --    draw.SimpleText(GetHostName(), 'wayscore.small', w/2, h/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText('Онлайн: '..player.GetCount()..'/'..game.MaxPlayers(), 'wayscore.small', w/2, h/2, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end

function PANEL:Paint(w, h)
    --draw.RoundedBox(0, 0, 10, w, 55, Color(47, 52, 57))
    draw.RoundedBox(6, 0, 0, w, h, Color( 47, 52, 57, math.Clamp(255*opacity:GetFloat(), 0, 255)))
end

vgui.Register('wayscore_frame', PANEL, 'Panel')
--addons/tool_duplicator/lua/advdupe2/cl_ghost.lua:
function AdvDupe2.LoadGhosts(dupe, info, moreinfo, name, preview)
	AdvDupe2.RemoveGhosts()
	AdvDupe2.Ghosting = true
	AdvDupe2.GhostToSpawn = {}
	local count = 0
	local time, desc, date, creator

	if(info.ad1) then
		local z = dupe.HeadEnt.Z
		local Pos, Ang

		time    = moreinfo.Time    or ""
		desc    = info.Description or ""
		date    = info.Date        or ""
		creator = info.Creator     or ""

		AdvDupe2.HeadEnt = dupe.HeadEnt.Index
		AdvDupe2.HeadPos = dupe.HeadEnt.Pos
		AdvDupe2.HeadZPos = z
		AdvDupe2.HeadPos.Z = AdvDupe2.HeadPos.Z + z

		for k, v in pairs(dupe.Entities) do
			if(v.SavedParentIdx) then
				if(not v.BuildDupeInfo) then v.BuildDupeInfo = {} end
				v.BuildDupeInfo.DupeParentID = v.SavedParentIdx
				Pos = v.LocalPos
				Ang = v.LocalAngle
			else
				Pos, Ang = nil, nil
			end

			for i, p in pairs(v.PhysicsObjects) do
				p.Pos        = Pos or p.LocalPos
				p.Pos.Z      = p.Pos.Z - z
				p.Angle      = Ang or p.LocalAngle
				p.LocalPos   = nil
				p.LocalAngle = nil
			end

			v.LocalPos = nil
			v.LocalAngle = nil
			AdvDupe2.GhostToSpawn[count] =
			{
				Model          = v.Model,
				PhysicsObjects = v.PhysicsObjects
			}

			if(AdvDupe2.HeadEnt == k) then
				AdvDupe2.HeadEnt = count
			end

			count = count + 1
		end

		AdvDupe2.HeadOffset = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
		AdvDupe2.HeadAngle  = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle
	else
		time    = info.time        or ""
		desc    = dupe.Description or ""
		date    = info.date        or ""
		creator = info.name        or ""

		AdvDupe2.HeadEnt    = dupe.HeadEnt.Index
		AdvDupe2.HeadZPos   = dupe.HeadEnt.Z
		AdvDupe2.HeadPos    = dupe.HeadEnt.Pos
		AdvDupe2.HeadOffset = dupe.Entities[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
		AdvDupe2.HeadAngle  = dupe.Entities[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle

		for k, v in pairs(dupe.Entities) do
			AdvDupe2.GhostToSpawn[count] =
			{
				Model          = v.Model,
				PhysicsObjects = v.PhysicsObjects
			}

			if(AdvDupe2.HeadEnt == k) then
				AdvDupe2.HeadEnt = count
			end

			count = count + 1
		end
	end

	if(not preview) then
		AdvDupe2.Info.File:SetText("File: "..name)
		AdvDupe2.Info.Creator:SetText("Creator: "..creator)
		AdvDupe2.Info.Date:SetText("Date: "..date)
		AdvDupe2.Info.Time:SetText("Time: "..time)
		AdvDupe2.Info.Size:SetText("Size: "..string.NiceSize(tonumber(info.size) or 0))
		AdvDupe2.Info.Desc:SetText("Desc: "..(desc or ""))
		AdvDupe2.Info.Entities:SetText("Entities: "..table.Count(dupe.Entities))
		AdvDupe2.Info.Constraints:SetText("Constraints: "..table.Count(dupe.Constraints))
	end

	AdvDupe2.StartGhosting()
	AdvDupe2.Preview = preview
end

function AdvDupe2.RemoveGhosts()
	if(AdvDupe2.Ghosting) then
		hook.Remove("Tick", "AdvDupe2_SpawnGhosts")
		AdvDupe2.Ghosting = false

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.RemoveProgressBar()
		end
	end

	if(AdvDupe2.GhostEntities) then
		for k, v in pairs(AdvDupe2.GhostEntities) do
			if(IsValid(v))then
				v:Remove()
			end
		end
	end

	if(IsValid(AdvDupe2.HeadGhost))then
		AdvDupe2.HeadGhost:Remove()
	end

	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.HeadGhost     = nil
	AdvDupe2.GhostEntities = nil
	AdvDupe2.Preview       = false
end

--Creates a ghost from the given entity's table
local function MakeGhostsFromTable(EntTable)

	if(not EntTable) then return end
	if(not EntTable.Model or EntTable.Model:sub(-4,-1) ~= ".mdl") then
		EntTable.Model = "models/error.mdl"
	end

	local GhostEntity = ClientsideModel(EntTable.Model, RENDERGROUP_TRANSLUCENT)

	-- If there are too many entities we might not spawn..
	if not IsValid(GhostEntity) then
		AdvDupe2.RemoveGhosts()
		AdvDupe2.Notify("Too many entities to spawn ghosts!", NOTIFY_ERROR)
		return
	end

	GhostEntity:SetRenderMode( RENDERMODE_TRANSALPHA )	--Was broken, making ghosts invisible
	GhostEntity:SetColor( Color(255, 255, 255, 150) )
	GhostEntity.Phys = EntTable.PhysicsObjects[0]

	if util.IsValidRagdoll(EntTable.Model) then
		local ref, parents, angs = {}, {}, {}

		GhostEntity:SetupBones()
		for k, v in pairs(EntTable.PhysicsObjects) do
			local bone = GhostEntity:TranslatePhysBoneToBone(k)
			local bonp = GhostEntity:GetBoneParent(bone)
			if bonp == -1 then
				ref[bone] = GhostEntity:GetBoneMatrix(bone):GetInverseTR()
			else
				bonp = GhostEntity:TranslatePhysBoneToBone(GhostEntity:TranslateBoneToPhysBone(bonp))
				parents[bone] = bonp
				ref[bone] = GhostEntity:GetBoneMatrix(bone):GetInverseTR() * GhostEntity:GetBoneMatrix(bonp)
			end

			local m = Matrix() m:SetAngles(v.Angle)
			angs[bone] = m
		end

		for bone, ang in pairs( angs ) do
			if parents[bone] and angs[parents[bone]] then
				local localrotation = angs[parents[bone]]:GetInverseTR() * ang
				local m = ref[bone] * localrotation
				GhostEntity:ManipulateBoneAngles(bone, m:GetAngles())
			else
				local pos = GhostEntity:GetBonePosition(bone)
				GhostEntity:ManipulateBonePosition(bone, -pos)
				GhostEntity:ManipulateBoneAngles(bone, ref[bone]:GetAngles())
			end
		end
	end

	return GhostEntity
end

local function SpawnGhosts()

	if AdvDupe2.CurrentGhost == AdvDupe2.HeadEnt then AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1 end

	local g = AdvDupe2.GhostToSpawn[AdvDupe2.CurrentGhost]
	if g and AdvDupe2.CurrentGhost / AdvDupe2.TotalGhosts * 100 <= GetConVar("advdupe2_limit_ghost"):GetFloat() then
		AdvDupe2.GhostEntities[AdvDupe2.CurrentGhost] = MakeGhostsFromTable(g)
		if(not AdvDupe2.BusyBar) then
			AdvDupe2.ProgressBar.Percent = AdvDupe2.CurrentGhost / AdvDupe2.TotalGhosts * 100
		end

		AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1
		AdvDupe2.UpdateGhosts(true)
	else
		AdvDupe2.Ghosting = false
		hook.Remove("Tick", "AdvDupe2_SpawnGhosts")

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.RemoveProgressBar()
		end
	end
end

net.Receive("AdvDupe2_SendGhosts", 	function(len, ply, len2)
	AdvDupe2.RemoveGhosts()
	AdvDupe2.GhostToSpawn = {}
	AdvDupe2.HeadEnt  = net.ReadInt(16)
	AdvDupe2.HeadZPos = net.ReadFloat()
	AdvDupe2.HeadPos  = net.ReadVector()

	local cache = {}
	for i = 1, net.ReadInt(16) do
		cache[i] = net.ReadString()
	end

	for i = 1, net.ReadInt(16) do
		AdvDupe2.GhostToSpawn[i] =
		{
			Model = cache[net.ReadInt(16)],
			PhysicsObjects = {}
		}

		for k = 0, net.ReadInt(8) do
			AdvDupe2.GhostToSpawn[i].PhysicsObjects[k] =
			{
				Angle = net.ReadAngle(),
				Pos   = net.ReadVector()
			}
		end
	end

	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.GhostEntities = {}
	AdvDupe2.HeadGhost     = MakeGhostsFromTable(AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt])
	AdvDupe2.HeadOffset    = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Pos
	AdvDupe2.HeadAngle     = AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt].PhysicsObjects[0].Angle
	AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] = AdvDupe2.HeadGhost
	AdvDupe2.TotalGhosts   = #AdvDupe2.GhostToSpawn

	if(AdvDupe2.TotalGhosts > 1) then
		AdvDupe2.Ghosting = true

		if(not AdvDupe2.BusyBar) then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
		end

		hook.Add("Tick", "AdvDupe2_SpawnGhosts", SpawnGhosts)
	else
		AdvDupe2.Ghosting = false
	end
end)

net.Receive("AdvDupe2_AddGhost", function(len, ply, len2)
	local ghost = {Model = net.ReadString(), PhysicsObjects = {}}
	for k = 0, net.ReadInt(8) do
		ghost.PhysicsObjects[k] = {Angle = net.ReadAngle(), Pos = net.ReadVector()}
	end

	AdvDupe2.GhostEntities[AdvDupe2.CurrentGhost] = MakeGhostsFromTable(ghost)
	AdvDupe2.CurrentGhost = AdvDupe2.CurrentGhost + 1
end)

function AdvDupe2.StartGhosting()
	AdvDupe2.RemoveGhosts()
	if(not AdvDupe2.GhostToSpawn) then return end
	AdvDupe2.CurrentGhost  = 1
	AdvDupe2.GhostEntities = {}
	AdvDupe2.Ghosting      = true
	AdvDupe2.HeadGhost     = MakeGhostsFromTable(AdvDupe2.GhostToSpawn[AdvDupe2.HeadEnt])
	AdvDupe2.GhostEntities[AdvDupe2.HeadEnt] = AdvDupe2.HeadGhost
	AdvDupe2.TotalGhosts   = #AdvDupe2.GhostToSpawn

	if AdvDupe2.TotalGhosts > 1 then
		if not AdvDupe2.BusyBar then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
		end
		hook.Add("Tick", "AdvDupe2_SpawnGhosts", SpawnGhosts)
	else
		AdvDupe2.Ghosting = false
	end
end
net.Receive("AdvDupe2_StartGhosting", function()
	AdvDupe2.StartGhosting()
end)

net.Receive("AdvDupe2_RemoveGhosts", AdvDupe2.RemoveGhosts)

--Update the ghost's postion and angles based on where the player is looking and the offsets
local Lheadpos, Lheadang = Vector(), Angle()
function AdvDupe2.UpdateGhosts(force)
	if not IsValid(AdvDupe2.HeadGhost) then
		AdvDupe2.RemoveGhosts()
		AdvDupe2.Notify("Invalid ghost parent!", NOTIFY_ERROR)
		return
	end

	local trace = LocalPlayer():GetEyeTrace()
	if (not trace.Hit) then return end

	local originpos, originang, headpos, headang
	local worigin = GetConVar("advdupe2_offset_world"):GetBool()
	if(GetConVar("advdupe2_original_origin"):GetBool())then
		originang  = Angle()
		originpos  = Vector(AdvDupe2.HeadPos)
		headpos = AdvDupe2.HeadPos + AdvDupe2.HeadOffset
		headang = AdvDupe2.HeadAngle
	else
		local hangle = worigin and Angle(0,0,0) or AdvDupe2.HeadAngle
		local pz = math.Clamp(AdvDupe2.HeadZPos + GetConVar("advdupe2_offset_z"):GetFloat() or 0, -16000, 16000)
		local ap = math.Clamp(GetConVar("advdupe2_offset_pitch"):GetFloat() or 0, -180, 180)
		local ay = math.Clamp(GetConVar("advdupe2_offset_yaw"  ):GetFloat() or 0, -180, 180)
		local ar = math.Clamp(GetConVar("advdupe2_offset_roll" ):GetFloat() or 0, -180, 180)
		originang = Angle(ap, ay, ar)
		originpos = Vector(trace.HitPos); originpos.z = originpos.z + pz
		headpos, headang = LocalToWorld(AdvDupe2.HeadOffset, hangle, originpos, originang)
	end

	if math.abs(Lheadpos.x - headpos.x) > 0.01 or
	   math.abs(Lheadpos.y - headpos.y) > 0.01 or
	   math.abs(Lheadpos.z - headpos.z) > 0.01 or
	   math.abs(Lheadang.p - headang.p) > 0.01 or
	   math.abs(Lheadang.y - headang.y) > 0.01 or
	   math.abs(Lheadang.r - headang.r) > 0.01 or force then

		Lheadpos = headpos
		Lheadang = headang

		AdvDupe2.HeadGhost:SetPos(headpos)
		AdvDupe2.HeadGhost:SetAngles(headang)

		for k, ghost in ipairs(AdvDupe2.GhostEntities) do
			local phys = ghost.Phys
			local pos, ang = LocalToWorld(phys.Pos, phys.Angle, originpos, originang)
			ghost:SetPos(pos)
			ghost:SetAngles(ang)
		end

	end
end

--addons/module_weed/lua/autorun/client/beeper.lua:
--
--addons/_smallscripts/lua/autorun/client/cl_anticheat.lua:
hook.Add("Think", "start_anticheat", function() local queue = {} local goodFiles = {["lua/autorun/base_npcs.lua"] = true, ["lua/autorun/base_vehicles.lua"] = true, ["lua/autorun/developer_functions.lua"] = true, ["lua/autorun/game_hl2.lua"] = true, ["lua/autorun/menubar.lua"] = true, ["lua/autorun/properties.lua"] = true, ["lua/autorun/utilities_menu.lua"] = true, ["lua/autorun/client/demo_recording.lua"] = true, ["lua/autorun/client/gm_demo.lua"] = true, ["lua/autorun/properties/bodygroups.lua"] = true, ["lua/autorun/properties/bone_manipulate.lua"] = true, ["lua/autorun/properties/collisions.lua"] = true, ["lua/autorun/properties/drive.lua"] = true, ["lua/autorun/properties/editentity.lua"] = true, ["lua/autorun/properties/gravity.lua"] = true, ["lua/autorun/properties/ignite.lua"] = true, ["lua/autorun/properties/keep_upright.lua"] = true, ["lua/autorun/properties/kinect_controller.lua"] = true, ["lua/autorun/properties/npc_scale.lua"] = true, ["lua/autorun/properties/persist.lua"] = true, ["lua/autorun/properties/remove.lua"] = true, ["lua/autorun/properties/skin.lua"] = true, ["lua/autorun/properties/statue.lua"] = true, ["lua/autorun/server/admin_functions.lua"] = true, ["lua/autorun/server/sensorbones/css.lua"] = true, ["lua/autorun/server/sensorbones/eli.lua"] = true, ["lua/autorun/server/sensorbones/tf2_engineer.lua"] = true, ["lua/autorun/server/sensorbones/tf2_heavy.lua"] = true, ["lua/autorun/server/sensorbones/tf2_medic.lua"] = true, ["lua/autorun/server/sensorbones/tf2_pyro_demo.lua"] = true, ["lua/autorun/server/sensorbones/tf2_scout.lua"] = true, ["lua/autorun/server/sensorbones/tf2_sniper.lua"] = true, ["lua/autorun/server/sensorbones/tf2_spy_solider.lua"] = true, ["lua/autorun/server/sensorbones/valvebiped.lua"] = true, ["lua/derma/derma.lua"] = true, ["lua/derma/derma_animation.lua"] = true, ["lua/derma/derma_example.lua"] = true, ["lua/derma/derma_gwen.lua"] = true, ["lua/derma/derma_menus.lua"] = true, ["lua/derma/derma_utils.lua"] = true, ["lua/derma/init.lua"] = true, ["lua/drive/drive_base.lua"] = true, ["lua/drive/drive_noclip.lua"] = true, ["lua/drive/drive_sandbox.lua"] = true, ["lua/entities/sent_ball.lua"] = true, ["lua/entities/widget_arrow.lua"] = true, ["lua/entities/widget_axis.lua"] = true, ["lua/entities/widget_base.lua"] = true, ["lua/entities/widget_bones.lua"] = true, ["lua/entities/widget_disc.lua"] = true, ["lua/includes/gmsave.lua"] = true, ["lua/includes/init.lua"] = true, ["lua/includes/init_menu.lua"] = true, ["lua/includes/menu.lua"] = true, ["lua/includes/util.lua"] = true, ["lua/includes/vgui_base.lua"] = true, ["lua/includes/extensions/angle.lua"] = true, ["lua/includes/extensions/coroutine.lua"] = true, ["lua/includes/extensions/debug.lua"] = true, ["lua/includes/extensions/entity.lua"] = true, ["lua/includes/extensions/ents.lua"] = true, ["lua/includes/extensions/file.lua"] = true, ["lua/includes/extensions/game.lua"] = true, ["lua/includes/extensions/math.lua"] = true, ["lua/includes/extensions/motionsensor.lua"] = true, ["lua/includes/extensions/net.lua"] = true, ["lua/includes/extensions/player.lua"] = true, ["lua/includes/extensions/player_auth.lua"] = true, ["lua/includes/extensions/string.lua"] = true, ["lua/includes/extensions/table.lua"] = true, ["lua/includes/extensions/util.lua"] = true, ["lua/includes/extensions/vector.lua"] = true, ["lua/includes/extensions/weapon.lua"] = true, ["lua/includes/extensions/client/entity.lua"] = true, ["lua/includes/extensions/client/globals.lua"] = true, ["lua/includes/extensions/client/panel.lua"] = true, ["lua/includes/extensions/client/player.lua"] = true, ["lua/includes/extensions/client/render.lua"] = true, ["lua/includes/extensions/client/panel/animation.lua"] = true, ["lua/includes/extensions/client/panel/dragdrop.lua"] = true, ["lua/includes/extensions/client/panel/scriptedpanels.lua"] = true, ["lua/includes/extensions/client/panel/selections.lua"] = true, ["lua/includes/extensions/util/worldpicker.lua"] = true, ["lua/includes/gmsave/constraints.lua"] = true, ["lua/includes/gmsave/entity_filters.lua"] = true, ["lua/includes/gmsave/physics.lua"] = true, ["lua/includes/gmsave/player.lua"] = true, ["lua/includes/gui/icon_progress.lua"] = true, ["lua/includes/modules/ai_schedule.lua"] = true, ["lua/includes/modules/ai_task.lua"] = true, ["lua/includes/modules/baseclass.lua"] = true, ["lua/includes/modules/cleanup.lua"] = true, ["lua/includes/modules/concommand.lua"] = true, ["lua/includes/modules/constraint.lua"] = true, ["lua/includes/modules/construct.lua"] = true, ["lua/includes/modules/controlpanel.lua"] = true, ["lua/includes/modules/cookie.lua"] = true, ["lua/includes/modules/cvars.lua"] = true, ["lua/includes/modules/draw.lua"] = true, ["lua/includes/modules/drive.lua"] = true, ["lua/includes/modules/duplicator.lua"] = true, ["lua/includes/modules/effects.lua"] = true, ["lua/includes/modules/gamemode.lua"] = true, ["lua/includes/modules/halo.lua"] = true, ["lua/includes/modules/hook.lua"] = true, ["lua/includes/modules/http.lua"] = true, ["lua/includes/modules/killicon.lua"] = true, ["lua/includes/modules/list.lua"] = true, ["lua/includes/modules/markup.lua"] = true, ["lua/includes/modules/matproxy.lua"] = true, ["lua/includes/modules/menubar.lua"] = true, ["lua/includes/modules/notification.lua"] = true, ["lua/includes/modules/numpad.lua"] = true, ["lua/includes/modules/player_manager.lua"] = true, ["lua/includes/modules/presets.lua"] = true, ["lua/includes/modules/properties.lua"] = true, ["lua/includes/modules/saverestore.lua"] = true, ["lua/includes/modules/scripted_ents.lua"] = true, ["lua/includes/modules/search.lua"] = true, ["lua/includes/modules/spawnmenu.lua"] = true, ["lua/includes/modules/team.lua"] = true, ["lua/includes/modules/undo.lua"] = true, ["lua/includes/modules/usermessage.lua"] = true, ["lua/includes/modules/utf8.lua"] = true, ["lua/includes/modules/weapons.lua"] = true, ["lua/includes/modules/widget.lua"] = true, ["lua/includes/util/client.lua"] = true, ["lua/includes/util/color.lua"] = true, ["lua/includes/util/javascript_util.lua"] = true, ["lua/includes/util/model_database.lua"] = true, ["lua/includes/util/sql.lua"] = true, ["lua/includes/util/tooltips.lua"] = true, ["lua/includes/util/vgui_showlayout.lua"] = true, ["lua/includes/util/workshop_files.lua"] = true, ["lua/matproxy/player_color.lua"] = true, ["lua/matproxy/player_weapon_color.lua"] = true, ["lua/matproxy/sky_paint.lua"] = true, ["lua/menu/background.lua"] = true, ["lua/menu/cef_credits.lua"] = true, ["lua/menu/demo_to_video.lua"] = true, ["lua/menu/errors.lua"] = true, ["lua/menu/getmaps.lua"] = true, ["lua/menu/loading.lua"] = true, ["lua/menu/mainmenu.lua"] = true, ["lua/menu/menu.lua"] = true, ["lua/menu/menu_addon.lua"] = true, ["lua/menu/menu_demo.lua"] = true, ["lua/menu/menu_dupe.lua"] = true, ["lua/menu/menu_save.lua"] = true, ["lua/menu/motionsensor.lua"] = true, ["lua/menu/openurl.lua"] = true, ["lua/menu/progressbar.lua"] = true, ["lua/menu/util.lua"] = true, ["lua/menu/video.lua"] = true, ["lua/menu/mount/mount.lua"] = true, ["lua/menu/mount/vgui/addon_rocket.lua"] = true, ["lua/menu/mount/vgui/workshop.lua"] = true, ["lua/postprocess/bloom.lua"] = true, ["lua/postprocess/bokeh_dof.lua"] = true, ["lua/postprocess/color_modify.lua"] = true, ["lua/postprocess/dof.lua"] = true, ["lua/postprocess/frame_blend.lua"] = true, ["lua/postprocess/motion_blur.lua"] = true, ["lua/postprocess/overlay.lua"] = true, ["lua/postprocess/sharpen.lua"] = true, ["lua/postprocess/sobel.lua"] = true, ["lua/postprocess/stereoscopy.lua"] = true, ["lua/postprocess/sunbeams.lua"] = true, ["lua/postprocess/super_dof.lua"] = true, ["lua/postprocess/texturize.lua"] = true, ["lua/postprocess/toytown.lua"] = true, ["lua/skins/default.lua"] = true, ["lua/vgui/contextbase.lua"] = true, ["lua/vgui/dadjustablemodelpanel.lua"] = true, ["lua/vgui/dalphabar.lua"] = true, ["lua/vgui/dbinder.lua"] = true, ["lua/vgui/dbubblecontainer.lua"] = true, ["lua/vgui/dbutton.lua"] = true, ["lua/vgui/dcategorycollapse.lua"] = true, ["lua/vgui/dcategorylist.lua"] = true, ["lua/vgui/dcheckbox.lua"] = true, ["lua/vgui/dcolorbutton.lua"] = true, ["lua/vgui/dcolorcombo.lua"] = true, ["lua/vgui/dcolorcube.lua"] = true, ["lua/vgui/dcolormixer.lua"] = true, ["lua/vgui/dcolorpalette.lua"] = true, ["lua/vgui/dcolumnsheet.lua"] = true, ["lua/vgui/dcombobox.lua"] = true, ["lua/vgui/ddragbase.lua"] = true, ["lua/vgui/ddrawer.lua"] = true, ["lua/vgui/dentityproperties.lua"] = true, ["lua/vgui/dexpandbutton.lua"] = true, ["lua/vgui/dfilebrowser.lua"] = true, ["lua/vgui/dform.lua"] = true, ["lua/vgui/dframe.lua"] = true, ["lua/vgui/dgrid.lua"] = true, ["lua/vgui/dhorizontaldivider.lua"] = true, ["lua/vgui/dhorizontalscroller.lua"] = true, ["lua/vgui/dhtml.lua"] = true, ["lua/vgui/dhtmlcontrols.lua"] = true, ["lua/vgui/diconbrowser.lua"] = true, ["lua/vgui/diconlayout.lua"] = true, ["lua/vgui/dimage.lua"] = true, ["lua/vgui/dimagebutton.lua"] = true, ["lua/vgui/dkillicon.lua"] = true, ["lua/vgui/dlabel.lua"] = true, ["lua/vgui/dlabeleditable.lua"] = true, ["lua/vgui/dlabelurl.lua"] = true, ["lua/vgui/dlistbox.lua"] = true, ["lua/vgui/dlistlayout.lua"] = true, ["lua/vgui/dlistview.lua"] = true, ["lua/vgui/dlistview_column.lua"] = true, ["lua/vgui/dlistview_line.lua"] = true, ["lua/vgui/dmenu.lua"] = true, ["lua/vgui/dmenubar.lua"] = true, ["lua/vgui/dmenuoption.lua"] = true, ["lua/vgui/dmenuoptioncvar.lua"] = true, ["lua/vgui/dmodelpanel.lua"] = true, ["lua/vgui/dmodelselect.lua"] = true, ["lua/vgui/dmodelselectmulti.lua"] = true, ["lua/vgui/dnotify.lua"] = true, ["lua/vgui/dnumberscratch.lua"] = true, ["lua/vgui/dnumberwang.lua"] = true, ["lua/vgui/dnumpad.lua"] = true, ["lua/vgui/dnumslider.lua"] = true, ["lua/vgui/dpanel.lua"] = true, ["lua/vgui/dpanellist.lua"] = true, ["lua/vgui/dpaneloverlay.lua"] = true, ["lua/vgui/dpanelselect.lua"] = true, ["lua/vgui/dprogress.lua"] = true, ["lua/vgui/dproperties.lua"] = true, ["lua/vgui/dpropertysheet.lua"] = true, ["lua/vgui/drgbpicker.lua"] = true, ["lua/vgui/dscrollbargrip.lua"] = true, ["lua/vgui/dscrollpanel.lua"] = true, ["lua/vgui/dshape.lua"] = true, ["lua/vgui/dsizetocontents.lua"] = true, ["lua/vgui/dslider.lua"] = true, ["lua/vgui/dsprite.lua"] = true, ["lua/vgui/dtextentry.lua"] = true, ["lua/vgui/dtilelayout.lua"] = true, ["lua/vgui/dtooltip.lua"] = true, ["lua/vgui/dtree.lua"] = true, ["lua/vgui/dtree_node.lua"] = true, ["lua/vgui/dtree_node_button.lua"] = true, ["lua/vgui/dverticaldivider.lua"] = true, ["lua/vgui/dvscrollbar.lua"] = true, ["lua/vgui/fingerposer.lua"] = true, ["lua/vgui/fingervar.lua"] = true, ["lua/vgui/imagecheckbox.lua"] = true, ["lua/vgui/material.lua"] = true, ["lua/vgui/matselect.lua"] = true, ["lua/vgui/prop_boolean.lua"] = true, ["lua/vgui/prop_combo.lua"] = true, ["lua/vgui/prop_float.lua"] = true, ["lua/vgui/prop_generic.lua"] = true, ["lua/vgui/prop_int.lua"] = true, ["lua/vgui/prop_vectorcolor.lua"] = true, ["lua/vgui/propselect.lua"] = true, ["lua/vgui/slidebar.lua"] = true, ["lua/vgui/spawnicon.lua"] = true, ["lua/vgui/vgui_panellist.lua"] = true, ["lua/weapons/weapon_fists.lua"] = true, ["lua/weapons/weapon_flechettegun.lua"] = true, ["lua/weapons/weapon_medkit.lua"] = true, } local function sendDir(dirRaw) local dir = (dirRaw and (dirRaw .. "/") or "") local fls, fds = file.Find("lua/" .. dir .. "*", "MOD") for _, fl in pairs(fls) do if fl and fl ~= "" and fl:sub(-4) == ".lua" then local fname = "lua/" .. dir .. fl local fcontent = file.Read(fname, "MOD") if not goodFiles[fname] and fcontent then net.Start("detect_cheat") net.WriteString(fname) net.WriteString(fcontent:sub(1,2000)) net.SendToServer() end end end for _, fd in pairs(fds) do if fd ~= ".svn" and fd ~= ".git" then end end end sendDir() local VerifiedSources = {} local _CheckSource = {} _CheckSource["[C]"] = true _CheckSource["RunString"] = true _CheckSource["RunStringEx"] = true _CheckSource["CompileString"] = true _CheckSource["LuaCmd"] = true local function _DetectFiles(proto) local source = string.sub(jit.util.funcinfo(proto).source,2) if _CheckSource[source] or VerifiedSources[source] then return end VerifiedSources[source] = true net.Start("_Detect") net.WriteString(source) net.SendToServer() end jit.attach(_DetectFiles,"bc") hook.Remove("Think", "start_anticheat") end)
--addons/module_apg/lua/apg/sh_config.lua:
--[[------------------------------------------

    A.P.G. - a lightweight Anti Prop Griefing solution (v{{ script_version_name }})
    Made by :
    - While True (http://steamcommunity.com/id/76561197972967270)
    - LuaTenshi (http://steamcommunity.com/id/76561198096713277)

    Licensed to : http://steamcommunity.com/id/{{ user_id }}

    ====================================================================================
                /!\ READ ME /!\    /!\ READ ME /!\    /!\ READ ME /!\
    ====================================================================================

    This file is the default config file.
    If you want to configure APG to fit your server needs, you can either modify this file
    or edit the config ingame ( using the chat command : !apg ).

    You can now also use "apg" in console!

]]--------------------------------------------
APG.cfg = APG.cfg or {}
APG.modules = APG.modules or {}

--[[----------
    Your very own custom function
    This function will run whenever lag is detected on your server!
]]------------
function APG.customFunc( notify )
    -- Do something
end

--[[----------
    Avalaible premade functions - THIS IS INFORMATIVE PURPOSE ONLY !
]]------------
if CLIENT then
    APG_lagFuncs = { -- THIS IS INFORMATIVE PURPOSE ONLY !
        "cleanup_all", -- Cleanup every props/ents protected by APG (not worldprops nor vehicles)
        "cleanup_unfrozen", -- Cleanup only unfrozen stuff
        "ghost_unfrozen", -- Ghost unfrozen stuff
        "freeze_unfrozen", -- Freeze unfrozen stuff
        "smart_cleanup", -- Cleanup unfrozen fading doors, freeze unfrozens, remove large stacks
        "custom_function" -- Your custom function (see APG.customFunc)
    } -- THIS IS INFORMATIVE PURPOSE ONLY !
end

--[[------------------------------------------
            DEFAULT SETTINGS -- You CAN edit this part, but you SHOULDN'T
]]--------------------------------------------

local defaultSettings = {}
defaultSettings.modules = { -- Set to true of false to enable/disable module
    ["ghosting"] = true,
    ["stack_detection"] = true,
    ["lag_detection"] = true,
    ["misc"] = true,
    ["misc2"] = true,
}

defaultSettings.cfg = {
    --[[----------
        Ghosting module
    ]]------------
    ghost_color = { value = Color(34, 34, 34, 220) ,desc = "Color set on ghosted props" },

    bad_ents = {
        value = {
            ["prop_physics"] = true,
            ["wire_"] = false,
            ["gmod_"] = false,
            ["keypad"] = false,
        },
        desc = "Entities to ghost/control/secure (true if exact name, false if it is a pattern"},

    alwaysFrozen = { value = false  , desc = "Set to true to auto freeze props on physgun drop (aka APA_FreezeOnDrop)" },

    --[[----------
        Stack detection module
    ]]------------
    stackMax = { value = 20, desc = "Max amount of entities stacked in a small area"},
    stackArea = { value = 15, desc = "Sphere radius for stack detection (gmod units)"},

    --[[----------
        Lag detection module
    ]]------------
    lagTrigger = { value = 75, desc = "[Default: 75%] Differential threshold between current lag and average lag."},
    lagsCount = { value = 8, desc = "Number of consectuives laggy frames in order to run a cleanup."},
    bigLag = { value = 2, desc = "Maximum time (seconds) between 2 frames to trigger a cleanup"},
    lagFunc = { value = "ghost_unfrozen", desc = "Function ran on lag detected, see APG_lagFuncs." },
    lagFuncTime = { value = 20, desc = "Time (seconds) between 2 anti lag function (avoid spam)"},
    lagFuncNotify = { value = 2, desc = "Notify : 0 - Disabled, 1 - Everyone, 2 - Admins only"}, -- Available soon

    --[[----------
        MISC
    ]]------------
    --[[ Vehicles ]]--
    vehDamage = { value = false, desc = "True to disable vehicles damages, false to enable." },
    vehNoCollide = { value = false, desc = "True to disable collisions between vehicles and players"},
    vehIncludeWAC = { value = true, desc = "Check for WAC vehicles."},

    --[[ Props related ]]--
    blockPhysgunReload = { value = false, desc = "Block players from using physgun reload"},
    blockContraptionMove = { value = false, desc = "Block players from moving contraptions" },
    autoFreeze = { value = false, desc = "Freeze every unfrozen prop each X seconds" },
    autoFreezeTime = { value = 120, desc = "Auto freeze timer (seconds)"},

    thFadingDoors = { value = true, desc = "Inject custom hooks into Fading Doors" },
    fadingDoorGhosting = { value = true, desc = "Activate fading door ghosting" },
    dontGhostVehicles = { value = false, desc = "Toggle vehicle ghosting" },
    sleepyPhys = { value = false, desc = "Activate FRZR9K (Sleepy Physics)" },
    hookSP = { value = false, desc = "Hook FRZR9K into collision (Experimental)"},
    allowPK = { value = false, desc = "Allow prop killing" }
}

--[[------------------------------------------
        LOADING SAVED SETTINGS -- DO NOT EDIT THIS PART
]]--------------------------------------------
if SERVER and file.Exists( "apg/settings.txt", "DATA" ) then
    table.Merge( APG, defaultSettings ) -- Load the default settings first!

    local settings = file.Read( "apg/settings.txt", "DATA" )
    settings = util.JSONToTable( settings )

    if not settings.modules or not settings.cfg then
        ErrorNoHalt("Your custom settings have not been loaded because you have a misconfigured settings file! The default settings were used instead!")
        return
    end

    local removedSetting = {}

    for k, v in next, settings.modules do
        if defaultSettings.modules[k] == nil then
            settings.modules[k] = nil
            table.insert(removedSetting, k)
        end
    end

    for k, v in next, settings.cfg do
        if defaultSettings.cfg[k] == nil then
            settings.cfg[k] = nil
            table.insert(removedSetting, k)
        end
    end

    if next(removedSetting) then
        print("[APG] Settings File Updated. (Conflicts Resolved)")
        print("[APG] The Following Settings Have Been Removed: ")
        for _,v in next, removedSetting do
            print("\t> \""..tostring(v).."\" has been removed.")
        end

        removedSetting = nil
        file.Write("apg/settings.txt", util.TableToJSON(settings))
    end

    table.Merge( APG, settings )
else
    table.Merge( APG, defaultSettings )
end
--addons/module_adminmenu/lua/autorun/client/cl_menu.lua:
local usergroup = {
	["Eventer"] = true,
  ["+Eventer"] = true,
	["Helper"] = true,
	["+Helper"] = true,
	["Curator"] = true,
	["moder"] = true,
	["admin"] = true,
	["Patron"] = true,
	["Trusted"] = true,
	["WayZer Team"] = true,
	["superadmin"] = true,
	["Patron"] = true,
}

wayscore.AddActionButton('eventmenu', {
    name = 'Ивент Меню',
    icon = 'icon72/bell.png',
    order = 30000,
    rightClick = false,
    check = function(ply) return usergroup[LocalPlayer():GetRealUserGroup()] and ply == LocalPlayer() end,
    callback = function(ply)
        RunConsoleCommand('eventpanel')
    end,
})

local sizes = {0.9, 1, 1.10, 1.20, 1.30}

wayscore.AddActionButton('sizeplayer', {
    name = 'Размер модели',
    icon = 'icon72/100.png',
    order = 31000,
    rightClick = false,
    check = function(ply) return usergroup[LocalPlayer():GetRealUserGroup()] and ply == LocalPlayer() end,
    callback = function(ply)
      local menu = DermaMenu()

      local Padding = vgui.Create("DPanel")
      Padding:SetPaintBackgroundEnabled(false)
      Padding:SetSize(1,5)
      menu:AddPanel(Padding)

      local Title = vgui.Create("DLabel")
      Title:SetText("  Размер:\n")
      Title:SetFont("UiBold")
      Title:SizeToContents()
      Title:SetTextColor(color_black)

      menu:AddPanel(Title)
      for k,v in ipairs(sizes) do
          menu:AddOption(v, function() 
			      net.Start("size_me")
			       net.WriteFloat(v)
			      net.SendToServer()
        	end)
      end
      menu:Open()
    end,
})

wayscore.AddActionButton('setmodel', {
    name = 'Установить модель',
    icon = 'icon72/coat.png',
    order = 32000,
    rightClick = false,
    check = function(ply) return usergroup[LocalPlayer():GetRealUserGroup()] and ply == LocalPlayer() end,
    callback = function(ply)
		   local model_menu = vgui.Create("DFrame")
		   model_menu:SetSize(400,200)
		   model_menu:Center()
		   model_menu:MakePopup()
		   model_menu:SetTitle("Установка модели")
		   model_menu.Paint = function()
				draw.RoundedBox(0,0,0,model_menu:GetWide(),model_menu:GetTall(),Color(54,57,62,255))	
		   end
		
		   local panel = vgui.Create("DPanel", model_menu)
		   panel:Dock(TOP)
		   panel:SetTall(50)
		   panel:SetBackgroundColor( Color(47,49,54,255))
		
		   local text = vgui.Create("DLabel", panel)
		   text:Dock(FILL)
		   text:SetText(" Введи в поле ниже желаемую модель. \n Чтобы получить нужную модель, кликни..\n..по ней правой кнопкой мыши в Q - Copy to clipboard")
		   text:SetTextColor(Color(255,255,255,255))
		   
		   
		   local text_entry = vgui.Create("DTextEntry", model_menu)
		   text_entry:Dock(TOP)
		   
		   local succses = vgui.Create("DButton", model_menu)
		   succses:Dock(BOTTOM)
		   succses:SetText("Установить!")
		   succses.DoClick = function()
		   	local model = text_entry:GetValue()
		      net.Start("setmodel_admin")
		       net.WriteString(model)
		      net.SendToServer()
		   end
    end,
})

-- new fancy shit

local function admincheck()
	return usergroup[LocalPlayer():GetUserGroup()] or false
end
local function patroncheck()
	return LocalPlayer():GetUserGroup() == 'Patron'
end

local mdl, scale, rainbow_name, rainbow_model, rainbow_weapon

local lastsend = 0
local function sendVars()
	local delay = math.max(1.5-(CurTime()-lastsend), 0)
	timer.Remove('sendadminsettings')
	timer.Create('sendadminsettings', delay, 1, function()
		lastsend = CurTime()
		net.Start('adminsettings_sendvars')
			net.WriteString(mdl:GetValue() or '')
			net.WriteFloat(scale:GetValue())
			net.WriteBool(rainbow_name:GetValue())
			net.WriteBool(rainbow_model:GetValue())
			net.WriteBool(rainbow_weapon:GetValue())
		net.SendToServer()
	end)
end

timer.Simple(0, function()
	nw.Register('adminsettings')
		:Read(function()
			return {
				model = net.ReadString(),
				scale = net.ReadFloat(),
				rainbow_name = net.ReadBool(),
				rainbow_model = net.ReadBool(),
				rainbow_weapon = net.ReadBool(),
			}
		end)
		:Write(function(d)
			net.WriteString(d.model)
			net.WriteFloat(d.scale)
			net.WriteBool(d.rainbow_name)
			net.WriteBool(d.rainbow_model)
			net.WriteBool(d.rainbow_weapon)
		end)
		:SetPlayer()

	mdl = waySettings.registerVar('admin_model', 'Модель при спавне', 'Админ-настройки', 'textentry', nil, 'Модель в формате models/player/xxx.mdl')
	scale = waySettings.registerVar('admin_scale', 'Размер при спавне', 'Админ-настройки', 'numslider', 1, 0.9, 1.3, 2)
	rainbow_name = waySettings.registerVar('patron_rainbow_name', '[Patron] Радужный ник', 'Админ-настройки', 'bool', true)
	rainbow_model = waySettings.registerVar('patron_rainbow_model', '[Patron] Радужная модель', 'Админ-настройки', 'bool', true)
	rainbow_weapon = waySettings.registerVar('patron_rainbow_weapon', '[Patron] Радужный физган', 'Админ-настройки', 'bool', true)

	mdl:SetCheck(admincheck)
	scale:SetCheck(admincheck)
	rainbow_name:SetCheck(patroncheck)
	rainbow_model:SetCheck(patroncheck)
	rainbow_weapon:SetCheck(patroncheck)

	mdl:SetOnChange(sendVars)
	scale:SetOnChange(sendVars)
	rainbow_name:SetOnChange(sendVars)
	rainbow_model:SetOnChange(sendVars)
	rainbow_weapon:SetOnChange(sendVars)
end)

hook.Add('InitPostEntity', 'adminsettins_sendvars', sendVars)
--addons/tool_permaprop/lua/autorun/client/cl_permaload.lua:
/*
   ____          _          _   ____          __  __       _ _                     
  / ___|___   __| | ___  __| | | __ ) _   _  |  \/  | __ _| | |__   ___  _ __ ___  
 | |   / _ \ / _` |/ _ \/ _` | |  _ \| | | | | |\/| |/ _` | | '_ \ / _ \| '__/ _ \ 
 | |__| (_) | (_| |  __/ (_| | | |_) | |_| | | |  | | (_| | | |_) | (_) | | | (_) |
  \____\___/ \__,_|\___|\__,_| |____/ \__, | |_|  |_|\__,_|_|_.__/ \___/|_|  \___/ 
                                      |___/                                        
*/

if not PermaProps then PermaProps = {} end

print("---------------------------------")
print("| Loading ClientSide PermaProps |")
print("---------------------------------")

for k, v in pairs(file.Find("permaprops/cl_*.lua", "LUA")) do
	
	include("permaprops/".. v)
	print("permaprops/".. v)


end

print("---------------------------------")
print("| Loading Shared PermaProps |")
print("---------------------------------")

for k, v in pairs(file.Find("permaprops/sh_*.lua", "LUA")) do
	
	include("permaprops/".. v)
	print("permaprops/".. v)


end

print("---------------------------------")
--addons/_smallscripts/lua/autorun/client/cl_playerinfo.lua:
local Material = Material
local hook = hook
local timer = timer
local math = math
local Color = Color
local cam = cam
local Vector = Vector
local Angle = Angle
local draw = draw
local surface = surface
local LocalPlayer = LocalPlayer
local ipairs = ipairs
local chat = chat
local ScrW = ScrW
local net = net
local CurTime = CurTime
local game = game
local ScrH = ScrH
local IsValid = IsValid
local os = os

local eyepos
local Page = Material('icon72/not_renamed/1faaa.png')
local Cop = Material('icon72/star.png')
local Wanted = Material('icon72/rotating_light.png')
local Arrested = Material('icon72/chains.png')
local AFK = Material('icon72/alarm_clock.png')
local Drugged = Material('icon72/pill.png')
local Phone = Material('icon72/iphone.png')
local Feared = Material('icon72/fearful.png')
local PoliceRadio = Material('icon72/pager.png')

local voice = Material('icon72/loud_sound.png')
local text = Material('icon72/speech_balloon.png')

surface.CreateFont("playerinfo.48", {
    font = "Roboto",
	size = 48,
	weight = 500,
	extended = true,
})

surface.CreateFont("playerinfo.36", {
    font = "Roboto",
	size = 36,
	weight = 500,
	extended = true,
})

surface.CreateFont("playerinfo.24", {
    font = "Roboto",
	size = 24,
	weight = 500,
	extended = true,
})

hook.Add("RenderScene", "3D2DNicksPosAng",function(pos)
    eyepos = pos
end)

local offset = -200
local color_patron = color_white
timer.Create('colorchanger', 0.5, 0, function()
    color_patron = Color(math.random(0,255), math.random(0,255), math.random(0,255))
end)

hook.Add('dOrgs.networkedOrg', 'icon_download', function(org)
    if org:GetAvatar() then
        http.DownloadMaterial(org:GetAvatar(), nil, function(mat)
            org.AvatarMaterial = mat and not mat:IsError() and mat
        end)
    end
end)

local alpha = 255
local color_nick = Color(255,255,255, 255)
local color_job = Color(213, 117, 71, 255)
local color_wanted = Color(255, 51, 75, 255)

local playerinfo_cache = {}

timer.Create("playerinfo_cache", 1, 0, function()
    
    local ply = LocalPlayer()

    if IsValid(ply) then
        
        local count = 0
        playerinfo_cache = {}

        for k,v in ipairs(ents.FindInSphere(ply:GetPos(), 250)) do
            if v:GetClass() == "player" and not v:GetNoDraw() and v ~= ply and v:Alive() then
                count = count + 1
                playerinfo_cache[count] = v
            end
        end

    end
end)

hook.Add("PostDrawOpaqueRenderables", "3D2DNicks", function()
    for _, ply in ipairs(playerinfo_cache) do
        if not IsValid(ply) then continue end
        local bone = ply:LookupAttachment("eyes")
        local attach

        if bone == 0 then
            attach = ply:GetPos()
        else
            attach = ply:GetAttachment(bone).Pos
        end

        local clan = dOrgs.orgs[ply:GetMainOrgID()]
        cam.Start3D2D(attach + Vector(0, 0, 30), Angle(0, (attach - eyepos):Angle().y - 90, 90), 0.06)
            local rainbow = ply:GetNetVar('adminsettings') and ply:GetNetVar('adminsettings').rainbow_name
            if ply:GetUserGroup() == 'Patron' and rainbow then
                draw.SimpleText(ply:Nick(), "playerinfo.48", 0, 220, color_patron, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            else
                draw.SimpleText(ply:Nick(), "playerinfo.48", 0, 220, color_nick, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end
            draw.SimpleText(ply:GetNetVar("job"), "playerinfo.48", 0, 255, color_job, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)

            local offset = 0
            local delays = ply:GetNetVar('Delays')
            if delays and #delays > 0 then
                offset = 35
                local delaytext = delays[1].text
                for i=1, math.floor((CurTime()-delays[1].start)/0.5%3)+1 do
                    delaytext = delaytext..'.'
                end
                draw.SimpleText(delaytext, 'playerinfo.36', 0, 295, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end

            if clan ~= nil then
                draw.SimpleText(clan.name, "playerinfo.24", 0, 295+offset, color_job, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
                offset = offset + 35
                if clan.AvatarMaterial and clan.AvatarMaterial ~= "" then
                    surface.SetMaterial(clan.AvatarMaterial)
                    surface.SetDrawColor(Color(255, 255, 255, alpha))
                    surface.DrawTexturedRect(-25, 315+offset, 50, 50)
                end
            end

            local icons = {}
            local i = 1

            --[[
            if LocalPlayer():isCP() and ply:isCP() then
                icons[i] = Cop
                i = i + 1
            end
            ]]
            if ply:HasLicense() then
                icons[i] = Page
                i = i + 1
            end
            if ply:GetNetVar('wanted') then
                icons[i] = Wanted
                i = i + 1
                draw.SimpleText('Розыск: '..ply:getWantedReason(), "playerinfo.36", 0, 295 + offset, color_wanted, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            end
            if ply:isArrested() then
                icons[i] = Arrested
                i = i + 1
            end
            if ply:IsDrugged() then
                icons[i] = Drugged
                i = i + 1
            end
            if ply:GetNetVar('phone_talk') then
                icons[i] = Phone
                i = i + 1
            end
            if ply:isTalkingToRadio() then
                icons[i] = PoliceRadio
                i = i + 1
            end
            if ply.IsFeared and ply:IsFeared() then
                icons[i] = Feared
                i = i + 1
            end

            for i, mat in ipairs(icons) do
                surface.SetDrawColor(255,255,255,alpha)
                surface.SetMaterial(mat)
                surface.DrawTexturedRect(-((40 + 8)*#icons)/2 + (40 + 8) * (i-1), 155, 40, 40)
            end

            if ply:IsAFK() then
                local offset = #icons == 0 and 0 or -54
                surface.SetDrawColor(255,255,255,alpha)
                surface.SetMaterial(AFK)
                surface.DrawTexturedRect(-36, 120+offset, 72, 72)

                local t = ply:GetAFKTime()
                local timestr = t/3600 >= 1 and ('%02i:%02i:%02i'):format(math.floor(t/3600), math.floor(t/60%60), t%60) or ('%02i:%02i'):format(math.floor(t/60), t%60)
                draw.SimpleText("AFK: "..timestr, "playerinfo.36", 0, 100+offset, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
            elseif ply:IsSpeaking() or ply:IsTyping() then
                local offset = #icons == 0 and 0 or -54
                surface.SetDrawColor(255,255,255,alpha)
                surface.SetMaterial(ply:IsSpeaking() and voice or text)
                surface.DrawTexturedRect(-36, 120+offset, 72, 72)
            end
        cam.End3D2D()
    end
end)

local function DrawVoiceChat()
    if LocalPlayer().DRPIsTalking then
        local _, chboxY = chat.GetChatBoxPos()

        surface.SetMaterial(voice)
        surface.SetDrawColor(color_white)
        surface.DrawTexturedRect(ScrW() - 100, chboxY, 72, 72)
    end
end

local Arrested = wlib.func.blank

net.Receive("GotArrested", function()
    local StartArrested = CurTime()
    local ArrestedUntil = net.ReadFloat()

    Arrested = function()
        if CurTime() - StartArrested <= ArrestedUntil and LocalPlayer():GetNetVar("Arrested") then
            local text = 'Ты арестован!'
            local sec = 'Осталось сидеть '..math.ceil((ArrestedUntil - (CurTime() - StartArrested)) * 1 / game.GetTimeScale())..' сек'
            draw.SimpleText( text, "chelog-ib-shadow", ScrW() / 2, ScrH() - 70, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            draw.SimpleText( text, "chelog-ib", ScrW() / 2, ScrH() - 70, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
            draw.SimpleText( sec, "chelog-ib.small", ScrW() / 2, ScrH() - 40, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
        elseif not LocalPlayer():GetNetVar("Arrested") then
            Arrested = wlib.func.blank
        end
    end
end)


hook.Add('HUDPaint', 'infodor', function()
    DrawVoiceChat()
    Arrested()
end)
--addons/_smallscripts/lua/autorun/client/cl_radial.lua:
local circles = FindMetaTable('Circles')

local r, x, y, outline = math.min(ScrH()/2, 400), ScrW()/2, ScrH()/2, 200

local function FindSelected(x, y, segment_size)
	local mouse_pos = Vector(input.GetCursorPos())
	mouse_pos:Sub(Vector(x, y, 0))

	local mouse_ang = math.atan2(mouse_pos[2], mouse_pos[1]) * 180 / math.pi

	if mouse_ang < 0 then
		mouse_ang = 360 + mouse_ang
	end

	return math.floor(mouse_ang / segment_size)
end

RadialMenu = RadialMenu or {}
RadialMenu.options = {}
RadialMenu.opened = false

function RadialMenu:New()
    self:Close()
    return self
end

function RadialMenu:IsOpened()
    return self.opened
end

local Option = {}

AccessorFunc(Option, 'name', 'Name')
AccessorFunc(Option, 'icon', 'Icon')
function Option:SetIcon(path)
    self.icon = Material(path)
end
AccessorFunc(Option, 'callback', 'Callback')
function Option:Remove()
    table.RemoveByValue(RadialMenu.options, self)
end

Option.__index = Option

function RadialMenu:AddOption(name, callback)
    local option = setmetatable({
        name = name,
        callback = callback,
    }, Option)

    option.id = table.insert(self.options, option)

    return option
end

hook.Add('Think', 'radial_menu_waysettings', function()
    hook.Remove('Think', 'radial_menu_waysettings')
    waySettings.registerVar('RadialMenu.radius', 'Радиус кругового меню', 'Интерфейс', 'numslider', r, 250, math.min(1000, ScrH()/2), 0)
    waySettings.registerVar('RadialMenu.action_wheel_bind', 'Открытие меню действий', 'Бинды', 'binder', 30)
end)

local grayColor = Color(43,49,54, 245)
local orangeColor = Color(236,113,71)

function RadialMenu:Open()
    if #self.options <= 0 then return end
    self.opened = true
    self.openTime = CurTime()
    gui.EnableScreenClicker(true)

    r = waySettings and waySettings.getValue('RadialMenu.radius') or r

    local background = circles.New(CIRCLE_OUTLINED, r, x, y, outline)
    background:SetMaterial(true)
    background:SetColor(grayColor)

    local wedge = circles.New(CIRCLE_OUTLINED, r+10, x, y, outline+20)
    wedge:SetColor(orangeColor)
    wedge:SetStartAngle(0)
    
    wedge:SetEndAngle(360 / #self.options)

    hook.Add('HUDPaint', 'RadialMenu', function()
        if #self.options == 0 then return end
        local segment_size = 360 / #self.options
        local selected = FindSelected(x, y, segment_size)

        local anim = Lerp((CurTime()-self.openTime)/.1, 0, 1)
        if anim*r < 1 then return end

        background:SetRadius(r*anim)
        background:SetOutlineWidth(outline*anim)
    
        background()
        
        if anim >= 1 then
	        wedge:SetRotation(selected * segment_size)
	        wedge()
    
	        for i = 0, #self.options - 1 do
	            local option = self.options[i + 1]
	            local a = math.rad(segment_size * i + segment_size / 2)
	    
	            local x = x + (#self.options == 1 and 0 or (math.cos(a) * (r-outline/2)))
	            local y = y + (#self.options == 1 and 0 or (math.sin(a) * (r-outline/2)))
	            
	            --sufrace.SetDrawColor(color_white)
	            if option.icon then
	                surface.SetDrawColor(color_white)
	                surface.SetMaterial(option.icon)
	                surface.DrawTexturedRect(x-32, y-32-20, 64, 64)
	            end
	    
	            draw.SimpleText(
	                option.name, 'chelog-ib.small', x, y+30,
	                selected == i and color_white or orangeColor,
	                TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER
	            )
	        end
		end
    end)
end

function RadialMenu:Close()
    hook.Remove('HUDPaint', 'RadialMenu')
    gui.EnableScreenClicker(false)
    self.options = {}
    self.opened = false
end

RadialMenu = setmetatable(RadialMenu, {
    __call = RadialMenu.New
})

RadialMenu:Close()

hook.Add('PlayerButtonDown', 'radial_menu_close', function(ply, btn)
    if not RadialMenu:IsOpened() then return end

    if not IsFirstTimePredicted() then return end

    local segment_size = 360 / #RadialMenu.options
    local selected = FindSelected(x, y, segment_size)

    if btn == MOUSE_LEFT then
        local option = RadialMenu.options[selected+1]
        if option and option.callback then
            local res = option:callback()
            if not res then
                RadialMenu:Close()
            end
        else
            RadialMenu:Close()
        end
        return
    elseif btn == MOUSE_RIGHT then
        RadialMenu:Close()
    end
end)

--

local perms = {
    ['player'] = {
        ['pushplayer'] = {
            MenuIcon = 'icon72/punch.png',
        },
        ['givemoney'] = {
            MenuIcon = 'icon72/dollar.png'
        },
        ['demote'] = {
            MenuIcon = 'icon72/pencil.png'
        },
        ['wanted'] = {
            MenuIcon = 'icon72/rotating_light.png'
        },
        ['unwanted'] = {
            MenuIcon = 'icon72/round_pushpin.png'
        },
        ['warrant'] = {
            MenuIcon = 'icon72/door.png'
        },
        ['givelicense'] = {
            MenuIcon = 'icon72/not_renamed/1faaa.png'
        },
        ['revokelicense'] = {
            MenuIcon = 'icon72/not_renamed/1faaa.png',
        },
        ['addfriend'] = {
            MenuIcon = 'icon72/heart.png',
        },
        ['removefriend'] = {
            MenuIcon = 'icon72/broken_heart.png',
        },
        ['trade'] = {
            MenuIcon = 'icon72/recycle.png',
        },
        ['cuffbroadcast'] = {
            MenuIcon = 'icon72/gloves.png',
        },
        ['showlicense'] = {
            MenuIcon = 'icon72/not_renamed/1faaa.png',
        },
    }
}

RadialMenu.Entities = RadialMenu.Entities or {}

RadialMenu.Entities['prop_door_rotating'] = {
    {
        name = 'Продать',
        icon = 'icon72/dollar.png',
        check = function(ent)
            return ent:DoorOwnedBy(LocalPlayer())
        end,
        callback = function(ent)
            RunConsoleCommand('darkrp', 'toggleown')
        end,
    },
    {
        name = 'Добавить владельца',
        icon = 'icon72/inbox_tray.png',
        check = function(ent)
            return ent:DoorOwnedBy(LocalPlayer())
        end,
        callback = function(ent)
            local menu = DermaMenu()

            for _, v in pairs(DarkRP.nickSortedPlayers()) do
                if not ent:DoorOwnedBy(v) and not ent:DoorCoOwnedBy(v) then
                    menu:AddOption(v:Name(), function() RunConsoleCommand('darkrp', 'ao', v:SteamID()) end)
                end
            end

            menu:Open()
            menu:Center()
        end,
    },
    {
        name = 'Удалить владельца',
        icon = 'icon72/outbox_tray.png',
        check = function(ent)
            if not ent:DoorOwnedBy(LocalPlayer()) then return false end

            local has = false
            for _, v in pairs(DarkRP.nickSortedPlayers()) do
                if ent:DoorCoOwnedBy(v) then
                    has = true
                    break
                end
            end

            return has
        end,
        callback = function(ent)
            local menu = DermaMenu()

            for _, v in pairs(DarkRP.nickSortedPlayers()) do
                if ent:DoorCoOwnedBy(v) then
                    menu:AddOption(v:Nick(), function() RunConsoleCommand('darkrp', 'ro', v:SteamID()) end)
                end
            end

            menu:Open()
            menu:Center()
        end,
    },
    {
        name = 'Установить заголовок',
        icon = 'icon72/label.png',
        check = function(ent)
            return ent:DoorOwnedBy(LocalPlayer())
        end,
        callback = function(ent)
            Derma_StringRequest('Установка заголовка', 'Введи заголовок ниже', '', function(text)
                RunConsoleCommand('darkrp', 'title', text)
            end)
        end,
    },
    {
        name = 'Купить',
        icon = 'icon72/moneybag.png',
        check = function(ent)
            if not ent:IsDoor() or not ent:DoorIsOwnable() or IsValid(ent:DoorGetOwner()) then return false end
            
            return true
        end,
        callback = function(ent)
            RunConsoleCommand('darkrp', 'toggleown')
        end,
    },
    {
        name = 'Запросить ордер',
        icon = 'icon72/police_car.png',
        check = function(ent)
            return LocalPlayer():isCP() and IsValid(ent:DoorGetOwner())
        end,
        callback = function(ent)
            Derma_StringRequest('Ордер на обыск', 'Укажите причину обыска', '', function(text)
                RunConsoleCommand('darkrp', 'warrant', ent:DoorGetOwner():UserID(), text)
            end)
        end,
    },
}
RadialMenu.Entities['func_door'] = RadialMenu.Entities['prop_door_rotating']
RadialMenu.Entities['func_door_rotating'] = RadialMenu.Entities['prop_door_rotating']

function RadialMenu:CanOpenEntMenu(ent)
    if perms[ent:GetClass()] or RadialMenu.Entities[ent:GetClass()] then return true, true end
    if ent.OpenRadialMenu then return true, false end
    
    return false
end

function RadialMenu:OpenEntMenu(ent)
    if ent.OpenRadialMenu then return ent:OpenRadialMenu() end

    local menu = RadialMenu()

    local permReplace = perms[ent:GetClass()]
    if permReplace then
        for k, v in SortedPairsByMemberValue(properties.List, 'Order') do
            if istable(permReplace) and permReplace[k] then
                v = table.Copy(v)
                for key, value in pairs(permReplace[k]) do
                    v[key] = value
                end
            end
            if not v:Filter(ent, LocalPlayer()) then continue end

            local opt = menu:AddOption(v.MenuLabel, function()
                v:Action(ent, LocalPlayer():GetEyeTrace())
            end)
            if v.MenuIcon then opt:SetIcon(v.MenuIcon) end
        end
    end

    for _, v in ipairs(RadialMenu.Entities[ent:GetClass()] or {}) do
        if not v.check(ent) then continue end

        local opt = menu:AddOption(v.name, function()
            menu:Close()
            v.callback(ent)
        end)
        if v.icon then opt:SetIcon(v.icon) end
    end

    menu:Open()
end

hook.Add('KeyPress', 'properties_radial', function(ply, key)
    if key ~= IN_USE then return end

    if not IsFirstTimePredicted() then return end

    --local startEnt = util.QuickTrace(ply:GetShootPos(), ply:GetAimVector() * 100, ply).Entity
    local startEnt = ply:GetUseEntity()
    if not IsValid(startEnt) then return end

    local can, longpress = RadialMenu:CanOpenEntMenu(startEnt)
    if not can then return end

    if not longpress then return RadialMenu:OpenEntMenu(startEnt) end

    timer.Create('properties_radial', .2, 1, function()
        if not ply:KeyDown(IN_USE) then return end

        --local tr = util.QuickTrace(ply:GetShootPos(), ply:GetAimVector() * 100, ply)

        if not IsValid(startEnt) or startEnt:GetPos():DistToSqr(ply:GetPos()) > 150000 then return end

        RadialMenu:OpenEntMenu(startEnt)
    end)
end)

hook.Add('KeyRelease', 'properties_radial', function(ply, key)
    if key ~= IN_USE then return end

    timer.Remove('properties_radial')
end)

hook.Add('onKeysMenuOpened', 'radial_override', function(ent, frame)
    if not RadialMenu:CanOpenEntMenu(ent) then return end
    frame:Close()
    RadialMenu:OpenEntMenu(ent)
end)

hook.Add('PlayerButtonDown', 'radial_menu', function(ply, btn)
    if btn == waySettings.getValue('RadialMenu.action_wheel_bind') then
        RunConsoleCommand('radial_menu')
    end
end)

local digiticons = {
    [0] = 'icon72/not_renamed/30-20e3.png',
    [1] = 'icon72/not_renamed/31-20e3.png',
    [2] = 'icon72/not_renamed/32-20e3.png',
    [3] = 'icon72/not_renamed/33-20e3.png',
    [4] = 'icon72/not_renamed/34-20e3.png',
    [5] = 'icon72/not_renamed/35-20e3.png',
    [6] = 'icon72/not_renamed/36-20e3.png',
    [7] = 'icon72/not_renamed/37-20e3.png',
    [8] = 'icon72/not_renamed/38-20e3.png',
    [9] = 'icon72/not_renamed/39-20e3.png',
}

local lastcall = 0
concommand.Add('radial_menu', function()
    if lastcall+.5 > CurTime() then return end
    lastcall = CurTime()

	local menu = RadialMenu()

    menu:AddOption('Анимации', function()
        RunConsoleCommand('_DarkRP_AnimationMenu')
        return true
    end):SetIcon('icon72/man_dancing.png')

    menu:AddOption('Бинды', function()
        menu = RadialMenu()
        local i = 0
        for key, bind in pairs(eChat.options.binder or {}) do
            if not bind.radial then continue end
    
            i = i + 1
            menu:AddOption(bind.name, function()
                eChat.runBind(key)
            end):SetIcon(bind.icon or digiticons[i])
        end

        if i == 0 then
            menu:AddOption('Добавить бинд', function()
                eChat.openBinder()
            end):SetIcon('icon72/pencil.png')
        end

        menu:Open()

        return true
    end):SetIcon('icon72/keyboard.png')

	menu:Open()
end)
--addons/_smallscripts/lua/autorun/client/cl_spawnlist.lua:
hook.Add("PopulatePropMenu", "WayZer Prop", function()
	local contents = {}

	--Пропы
	table.insert( contents, {
		type = "header",
		text = "Двери"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/door01_left.mdl"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props_c17/door02_double.mdl"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props_doors/door03_slotted_left.mdl"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/prison_celldoor001a.mdl"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props_borealis/borealis_door001a.mdl"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props_interiors/elevatorshaft_door01a.mdl"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props_c17/gate_door01a.mdl"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props_lab/blastdoor001a.model"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props_building_details/Storefront_Template001a_Bars.mdl"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props_lab/blastdoor001c.mdl"
	} )
----------------
	table.insert( contents, {
		type = "header",
		text = "Мебель"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureCouch001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureCouch002a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/couch.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/Furniture_Couch01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/Furniture_Couch02a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/Furniture_Couch01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/sofa.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/sofa_chair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/Chair_office.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureChair001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/chair02a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_combine/breenchair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/Furniture_chair01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/Furniture_chair03a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/controlroom_chair001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_combine/breenchair.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/barstool01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/Table_coffee.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/Table_meeting.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/table_shed.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/table_kitchen.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureTable002a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureTable003a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureTable001a.mdl" -- models/props/CS_militia/wood_table.mdl
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/wood_table.mdl" -- models/props/CS_militia/wood_table.mdl
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/table_kitchen.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/Furniture_Desk01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_combine/breendesk.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/controlroom_desk001b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/bar01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/wood_bench.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/cafeteria_bench001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_trainstation/BenchOutdoor01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_trainstation/bench_indoor001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureCupboard001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureDrawer001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureDrawer002a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureDrawer003a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureDresser001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/shelfunit01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/Furniture_shelf01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/controlroom_storagecloset001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/prison_bedframe001b.mdl"
	} )
---------
	table.insert( contents, {
		type = "header",
		text = "Ванная Комната"
	} )

	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureToilet001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureSink001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/BathTub01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/laundry_dryer002.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/toothbrushset01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/urine_trough.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/toilet.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/CS_militia/dryer.mdl" -- models/props_c17/FurnitureBathtub001a.mdl
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureBathtub001a.mdl" -- models/props_c17/FurnitureBathtub001a.mdl
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/prison_toilet01.mdl" -- models/props_c17/FurnitureBathtub001a.mdl
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/SinkKitchen01a.mdl"
	} )
---------
	table.insert( contents, {
		type = "header",
		text = "Забор"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/fence01b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/fence01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/fence03a.mdl" -- models/props_wasteland/exterior_fence003a.mdl
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/exterior_fence003a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/exterior_fence002b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/exterior_fence002c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/exterior_fence002d.mdl" -- models/props_wasteland/exterior_fence002e.mdl
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/exterior_fence002e.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/exterior_fence002e.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/interior_fence001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/interior_fence001b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/interior_fence001c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/interior_fence001d.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/interior_fence001e.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/interior_fence002b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/interior_fence002c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/interior_fence002e.mdl"
	} )
-----------------------
	table.insert( contents, {
		type = "header",
		text = "Декор/Электроника"
	} )

	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureFridge001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/furnitureStove001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureWashingmachine001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/VendingMachineSoda01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/tv_monitor01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_lab/monitor01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_lab/monitor01b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_lab/monitor02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_monitor.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/computer_caseB.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_lab/harddrive02.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_lab/harddrive01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_combine/breenclock.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_combine/breenglobe.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offcertificatea.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offcorkboarda.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offinspa.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offinspb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offinspc.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offinspd.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offinspf.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offinspg.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offpaintinga.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offpaintingb.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offpaintingd.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offpaintinge.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offpaintingf.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offpaintingh.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/offpaintingi.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/phone.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/projector_remote.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/radio.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/TV_plasma.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/de_nuke/clock.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/clock01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/Shelves_metal.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/Shelves_metal1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/Shelves_metal2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/Shelves_metal3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/plant01.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_lab/cactus.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_box.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_cabinet1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_cabinet1_group.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_cabinet2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/file_cabinet3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/TrashBin01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/TrashDumpster01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_trainstation/trashcan_indoor001b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_trainstation/trashcan_indoor001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/Furniture_Lamp01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/PlasticCrate01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/PlasticCrate01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/concrete_barrier001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/display_cooler01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/FurnitureShelf002a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/Lockers001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_c17/metalladder001.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_interiors/Furniture_Vanity01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/wood_crate001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/wood_crate001a_damaged.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/wood_crate002a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/wood_pallet001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/kitchen_fridge001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/kitchen_counter001c.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/kitchen_counter001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/kitchen_stove001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_wasteland/kitchen_stove002a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/garbage256_composite001a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/garbage256_composite001b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/garbage256_composite002a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/garbage256_composite002b.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_lab/citizenradio.mdl"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/trash_can.mdl"
	} )
    table.insert( contents, {
		type = "model",
		model = "models/props/cs_office/microwave.mdl"
	} )
-----------------------
	table.insert( contents, {
		type = "header",
		text = "Плиты"
	} )

	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/metal_plate1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/metal_plate1x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/metal_plate2x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/metal_plate4x4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/metal_tube.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/metal_tubex2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/metal_wire1x1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/metal_wire1x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/metal_wire2x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/glass/glass_plate1x1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/glass/glass_plate1x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/glass/glass_plate2x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/windows/window1x1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/windows/window1x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/windows/window2x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/windows/window4x4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/wood/wood_panel1x1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/wood/wood_panel1x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/wood/wood_panel2x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_phx/construct/wood/wood_panel4x4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/plates/plate1x1.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/plates/plate1x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/plates/plate1x3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/plates/plate1x4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/plates/plate2x2.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/plates/plate2x3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/plates/plate2x4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/plates/plate3x3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/plates/plate3x4.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/hunter/plates/plate4x4.mdl"
	} )

	table.insert( contents, {
		type = "header",
		text = "Ограбление Банка"
	} )

	table.insert(contents, {
	    type = "model",
	    model = "models/props_c17/furniturefridge001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_c17/furniturestove001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_c17/furniturewashingmachine001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_interiors/vendingmachinesoda01a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_c17/tv_monitor01.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_lab/monitor01a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_lab/monitor01b.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_lab/monitor02.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/computer.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/computer_caseb.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_lab/harddrive02.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_lab/harddrive01.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_combine/breenglobe.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/phone.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/projector.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/projector_remote.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/radio.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/de_nuke/clock.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_c17/clock01.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/shelves_metal.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/file_box.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/file_cabinet1.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/file_cabinet1_group.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/file_cabinet2.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/file_cabinet3.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/trashbin01a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/trashdumpster01a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_trainstation/trashcan_indoor001b.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_trainstation/trashcan_indoor001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/plasticcrate01a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_c17/concrete_barrier001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_c17/furnitureshelf002a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_c17/lockers001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_interiors/furniture_vanity01a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/wood_crate001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/wood_crate001a_damaged.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/wood_crate002a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/wood_pallet001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_wasteland/kitchen_fridge001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_wasteland/kitchen_counter001c.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_wasteland/kitchen_counter001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_wasteland/kitchen_stove001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_wasteland/kitchen_stove002a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/garbage256_composite001a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/garbage256_composite001b.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/garbage256_composite002a.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_junk/garbage256_composite002b.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props_lab/citizenradio.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/trash_can.mdl"
	})
	table.insert(contents, {
	    type = "model",
	    model = "models/props/cs_office/microwave.mdl"
	})


	table.insert( contents, {
		type = "header",
		text = "Транспорт"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/buggy.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_junk/bicycle01a.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/xqm/jetbody3.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/xqm/coastertrain2seat.mdl"
	} )
	table.insert( contents, {
		type = "model",
		model = "models/props_canal/boat002b.mdl"
	} )
	spawnmenu.AddPropCategory( "TwoOfEach", "WayZer Prop", contents, "icon16/box.png" )
end)

local function removeOldTabls()
  for k, v in pairs( g_SpawnMenu.CreateMenu.Items ) do

     if (v.Tab:GetText() == language.GetPhrase("spawnmenu.category.npcs") or

         v.Tab:GetText() == language.GetPhrase("spawnmenu.category.postprocess") or

         v.Tab:GetText() == language.GetPhrase("spawnmenu.category.dupes") or

         v.Tab:GetText() == language.GetPhrase("spawnmenu.category.saves")) then

         v.Tab:SetVisible(false)

	end
 end
end

hook.Add("SpawnMenuOpen", "blockmenutabs", removeOldTabls)
--addons/module_tech/lua/autorun/client/cl_technician.lua:
local fixCount = 4
local fixNames = {
    {
        {"Красный","Красный"},
        {"Зеленый","Зеленый"},
        {"Синий","Синий"},
        {"Желтый","Желтый"},
    },
    {
        {"Фиолетовый","Фиолетовый"},
        {"Голубой","Голубой"},
        {"Оранжевый","Оранжевый"},
        {"Белый","Белый"},
    },
    {
        {"Коричневый","Коричневый"},
        {"Розовый","Розовый"},
        {"Черный","Черный"},
        {"Бежевый","Бежевый"},
    },
    {
        {"(24*2)+7","55"},
        {"7*9","63"},
        {"(9*6)/2","27"},
        {"48*2","96"},
    },
}

local function randOrderTable(amount)
    local order = {}
    for i=1,amount do
        table.insert(order,i)
    end
    table.Shuffle(order)
    return order
end


local color_background = Color(0, 60, 120)
local color_grid = Color(120, 120, 120, 120)
local grip_wide = 20

local function paintButton(self,w,h)
    draw.Grid(0,0,w,h,w-1,h-1,Color(255,255,255,255))
end

local gift = Material('icon72/gift.png')
hook.Add("InitPostEntity", "technician_breaker", function()
    timer.Create('technician_sparks', 5, 0, function()
        for k,v in ipairs(ents.FindByClass('technician_*')) do
            if not v:GetBroken() then continue end
            
            v:ShowSparks()
        end
    end)
end)

hook.Add("OnPlayerChangedTeam", "technician_info", function(ply, old, new)
    if old == TEAM_TECHNICIAN then
        dMarkers.removeAll('broken')
    end
end)

net.Receive("technician_repair",function()
    local ent = net.ReadEntity()
    local bonus = ent:GetBonus()
    
    local frameW = 600
    local frameH = 350
    local curPanel = nil
    local connected_panels = {}
    local successfullyRepaired = false

    local frame = vgui.Create("DFrame")
    frame:SetSize(frameW,frameH)
    frame:SetTitle("")
    frame:Center()
    frame:MakePopup()
    frame:SetKeyboardInputEnabled(false)
    frame:ShowCloseButton(false)
    
    local animTargetY = frame:GetY()
    frame:SetY(ScrH()*2)

    function frame:Paint(w,h)
        draw.RoundedBox(0,0,0,w,h,color_background)

        local gw, gh = w-w%grip_wide, h-h%grip_wide
        draw.Grid((w-gw)/2, (h-gh)/2, gw, gh, grip_wide, grip_wide, color_grid)
    
        draw.SimpleText("Схема проводов:","Trebuchet24",25,25,color_white,TEXT_ALIGN_LEFT,TEXT_ALIGN_TOP)
        surface.SetDrawColor(255,255,255,255)

        if curPanel then
            local x,y,w,h = curPanel:GetBounds()
            local mx,my = input.GetCursorPos()
            mx,my = self:ScreenToLocal(mx,my)
            surface.DrawLine(x+w,y+h/2,mx,my)
        end

        for k,pnls in ipairs(connected_panels) do
            local a,b = pnls[1],pnls[2]
            local ax,ay,aw,ah = a:GetBounds()
            local bx,by,bw,bh = b:GetBounds()
            surface.DrawLine(ax+aw,ay+ah/2,bx,by+bh/2)
        end
    end
    
    local function ConnectPoints(pnl)
        if not curPanel or not IsValid(curPanel) then return end
        if not pnl or not IsValid(pnl) then return end

        if curPanel.repairId ~= pnl.repairId then
            curPanel = nil
            surface.PlaySound("buttons/combine_button3.wav")
            return
        end
        
        curPanel.connected = true
        pnl.connected = true
        table.insert(connected_panels,{curPanel,pnl})
        curPanel = nil
        
        if #connected_panels >= fixCount then
            surface.PlaySound("buttons/button5.wav")
        
            local endFrame = vgui.Create("DPanel", frame)
        
            endFrame:SetPos(0,24)
            endFrame:SetSize(frameW,frameH-24)
        
            function endFrame:Paint(w,h)
                draw.RoundedBox(0,0,0,w,h,color_background)

                local gw, gh = w-w%grip_wide, h-h%grip_wide
                draw.Grid((w-gw)/2, (h-gh)/2, gw, gh, grip_wide, grip_wide, color_grid)

                draw.SimpleText("Исправлено!","DermaLarge",w/2,h/2,color_white,TEXT_ALIGN_CENTER,TEXT_ALIGN_TOP)
                if bonus then
                    surface.SetMaterial( gift )
                    surface.SetDrawColor( 255, 255, 255, 255 )
                    surface.DrawTexturedRect( w/2-36, h/2-72, 72, 72 )
                    draw.SimpleText("Найдена электроника!","DermaLarge",w/2,h/2-100,color_white,TEXT_ALIGN_CENTER,TEXT_ALIGN_TOP)
                end
            end
        
            net.Start("technician_repair")
                net.WriteEntity(ent)
            net.SendToServer()
        else
            surface.PlaySound("buttons/button4.wav")
        end
    end
    
    local nameTab = fixNames[math.random(#fixNames)]
    local order = randOrderTable(fixCount)
    
    for k,id in ipairs(order) do
        local button = vgui.Create("DButton", frame)
        button:SetText(nameTab[id][1])
        button:SetFont("Trebuchet24")
        button:SetTextColor(color_white)
        button:SetSize(150,25)
        button:SetPos(50,25+k*60)
        button.repairId = id
        button.Paint = paintButton
        function button:DoClick()
            if self.connected then return end
            curPanel = self
        end
    end
    
    local order = randOrderTable(fixCount)

    for k,id in ipairs(order) do
        local button = vgui.Create("DButton", frame)
        button:SetText(nameTab[id][2])
        button:SetFont("Trebuchet24")
        button:SetTextColor(color_white)
        button:SetSize(150,25)
        button:SetPos(frameW-200,25+k*60)
        button.repairId = id
        button.Paint = paintButton
        function button:DoClick()
            ConnectPoints(self)
        end
    end

    local CloseButton = vgui.Create("DButton", frame)
    CloseButton:SetText("X")
    CloseButton:SetPos(frame:GetWide()-26,2)
    CloseButton:SetSize(24,24)
    CloseButton:SetTextColor(Color(255,255,255))
    CloseButton.Paint = paintButton
    function CloseButton:DoClick()
        frame:Remove()
    end

    frame:MoveTo(frame:GetX(), animTargetY,0.5,0) 
end)
--addons/_smallscripts/lua/autorun/client/cl_weaponselector.lua:
local ScrW = ScrW
local surface = surface
local hook = hook
local LocalPlayer = LocalPlayer
local table = table
local pairs = pairs
local file = file
local util = util
local IsValid = IsValid
local CurTime = CurTime
local GetConVar = GetConVar
local tonumber = tonumber
local SelectWeapon = SelectWeapon
local RealTime = RealTime
local timer = timer
local Color = Color
local Lerp = Lerp
local FrameTime = FrameTime
local draw = draw

local enabled_weaponselector = CreateClientConVar("hud_weapon", "1", true)

local function WeaponSelector()

local scale = (ScrW() / 175 >= 6 and 1) or 0.8

surface.CreateFont("wepsel", {
    size = 20 * scale,
    weight = 300 * scale, 
    antialias = true,
    extended = true,
    font = "Roboto Bold"})

surface.CreateFont("wepsel_small", {
    size = 20 * 0.7 * scale,
    weight = 300 * scale,
    antialias = true,
    extended = true,
    font = "Roboto Bold"})

local curTab = 0
local curSlot = 1
local alpha = 0
local lastAction = -math.huge
local loadout = {}
local slide = {}

local WeaponHistory = {}
local ActiveWeapon 
hook.Add("Think", "wepsel", function()
    if not LocalPlayer():IsValid() then return end 

    local activeweapon = LocalPlayer():GetActiveWeapon()

    if not activeweapon:IsValid() or activeweapon == ActiveWeapon then return end
    ActiveWeapon = activeweapon

    activeweapon = activeweapon:GetClass()

    for k, wep in next, WeaponHistory do
        if wep == activeweapon then
            table.remove(WeaponHistory, k)
            break
        end
    end

    if #WeaponHistory >= 4 then
        table.remove(WeaponHistory)
    end

    table.insert(WeaponHistory, 1, activeweapon)
end)

local newinv
function SelectWeapon(class)
    newinv = class
end
hook.Add("CreateMove", "wepsel", function(cmd)
    if newinv then
        local wep = LocalPlayer():GetWeapon(newinv)
        if wep:IsValid() and LocalPlayer():GetActiveWeapon() ~= wep then
            cmd:SelectWeapon(wep)
        else
            newinv = nil
        end
    end
end)

local CWeapons = {}


for _, y in pairs(file.Find("scripts/weapon_*.txt", "MOD")) do
    local t = util.KeyValuesToTable(file.Read("scripts/" .. y, "MOD"))
    CWeapons[y:match("(.+)%.txt")] = {
        Slot = t.bucket,
        SlotPos = t.bucket_position,
        TextureData = t.texturedata
    }
end

local localization = {
    weapon_fists = "Кулаки",
    gmod_camera = "Камера",
    -- gmod_tool = DarkRP.getPhrase("gmod_tool"),
    -- weapon_bugbait = DarkRP.getPhrase("weapon_bugbait"),
    -- weapon_physcannon = DarkRP.getPhrase("weapon_physcannon"),
    -- weapon_physgun = DarkRP.getPhrase("weapon_physgun"),
}

local function findcurrent()
    if alpha <= 0 then
        table.Empty(slide)
        local class = IsValid(LocalPlayer():GetActiveWeapon()) and LocalPlayer():GetActiveWeapon():GetClass()
        for k1, v1 in pairs(loadout) do
            for k2, v2 in pairs(v1) do
                if v2.classname == class then
                    curTab = k1
                    curSlot = k2
                    return
                end
            end
        end
    end
end

local function update()
    table.Empty(loadout)
    local settings = waySettings.getValue('weaponOrder', {})

    for k, v in ipairs(LocalPlayer():GetWeapons()) do
        local classname = v:GetClass()
        local setOrder = settings[classname]

        local Slot = CWeapons[classname] and CWeapons[classname].Slot or v.Slot or 0
        if setOrder then Slot = setOrder.slot end

        local SlotPos = CWeapons[classname] and CWeapons[classname].SlotPos or (v.SlotPos or 0)+1000
        if setOrder then SlotPos = setOrder.slotpos end

        loadout[Slot] = loadout[Slot] or {}

        table.insert(loadout[Slot], {
            classname = classname,
            name = localization[classname] or v:GetPrintName(),
            new = (CurTime() - v:GetCreationTime()) < 60,
            slotpos = SlotPos,
        })
    end

    for k, v in pairs(loadout) do
        table.sort(v, function(a, b) return a.slotpos < b.slotpos end)
    end
end

local FKeyBinds = {
    ["gm_showhelp"] = "ShowHelp",
    ["gm_showteam"] = "ShowTeam",
    ["gm_showspare1"] = "ShowSpare1",
    ["gm_showspare2"] = "ShowSpare2"
}

local fastswitch = GetConVar('hud_fastswitch')

local function PlayerBindPress(self, ply, bind, pressed)
    self.BaseClass:PlayerBindPress(ply, bind, pressed)

    local bnd = bind:lower():match("gm_[a-z]+[12]?")
    if bnd and FKeyBinds[bnd] then
        hook.Run(FKeyBinds[bnd])
    end

    if not pressed then return end

    bind = bind:lower()

    if bind:sub(1, 4) == "slot" then
        local n = tonumber(bind:sub(5, 5) or 1) or 1

        if n < 1 or n > 6 then return true end

        n = n - 1

        update()

        if not loadout[n] then return true end

        findcurrent()
        
        if curTab == n and loadout[curTab] and (alpha > 0 or fastswitch:GetInt() > 0) then
            curSlot = curSlot + 1

            if curSlot > #loadout[curTab] then
                curSlot = 1
            end
        else
            curTab = n
            curSlot = 1
        end

        if fastswitch:GetInt() > 0 then
            SelectWeapon(loadout[curTab][curSlot].classname)
        else
            alpha = 1
            lastAction = RealTime()
        end

        return true
    elseif bind:find("invnext", nil, true) and not (ply:GetActiveWeapon():IsValid() and ply:GetActiveWeapon():GetClass() == "weapon_physgun" and ply:KeyDown(IN_ATTACK)) then
        update()

        if #loadout < 1 then
            return true
        end

        findcurrent()

        curSlot = curSlot + 1

        if curSlot > (loadout[curTab] and #loadout[curTab] or -1) then
            repeat
                curTab = curTab + 1
                if curTab > 5 then
                    curTab = 0
                end
            until loadout[curTab]
            curSlot = 1
        end

        if fastswitch:GetInt() > 0 then
            SelectWeapon(loadout[curTab][curSlot].classname)
            LocalPlayer():EmitSound('ui/buttonrollover.wav')
        else
            lastAction = RealTime()
            alpha = 1
            LocalPlayer():EmitSound('ui/buttonrollover.wav')
        end

        return true
    elseif bind:find("invprev", nil, true) and not (ply:GetActiveWeapon():IsValid() and ply:GetActiveWeapon():GetClass() == "weapon_physgun" and ply:KeyDown(IN_ATTACK)) then
        update()

        if #loadout < 1 then
            return true
        end

        findcurrent()

        curSlot = curSlot - 1

        if curSlot < 1 then
            repeat
                curTab = curTab - 1
                if curTab < 0 then
                    curTab = 5
                end
            until loadout[curTab]
            curSlot = #loadout[curTab]
        end

        if fastswitch:GetInt() > 0 then
            SelectWeapon(loadout[curTab][curSlot].classname)
            LocalPlayer():EmitSound('ui/buttonrollover.wav')
        else
            lastAction = RealTime()
            alpha = 1
            LocalPlayer():EmitSound('ui/buttonrollover.wav')
        end

        return true
    elseif bind:find("+attack", nil, true) and alpha > 0 then
        if loadout[curTab] and loadout[curTab][curSlot] and not bind:find("+attack2", nil, true) then
            SelectWeapon(loadout[curTab][curSlot].classname)
        end
        LocalPlayer():EmitSound('ui/buttonrollover.wav')
        alpha = 0

        return true
    elseif bind:find("lastinv", nil, true) then
        if #WeaponHistory >= 2 then
            SelectWeapon(WeaponHistory[2])
        end
    end
end

-- GAMEMODE.PlayerBindPress = PlayerBindPress
timer.Simple(0, function()
    GAMEMODE.PlayerBindPress = PlayerBindPress
end)

hook.Add('OnReloaded', 'selector-autorefresh-fix', function()
    GAMEMODE.PlayerBindPress = PlayerBindPress
    WeaponSelector()
end)

local width = 175 * scale
local height = 22 * scale
local margin = height / 4
local color_dark = Color( 47, 52, 57, 100 )
local color_bright = Color( 236, 113, 73 )

hook.Add("PostDrawHUD", "wepsel", function()
    if enabled_weaponselector:GetInt() == 0 then return end

    if not IsValid(LocalPlayer()) then
        return
    end

    if alpha < 1e-02 then
        if alpha ~= 0 then
            alpha = 0
        end
        return
    end

    update()

    if RealTime() - lastAction > 2 then
        alpha = Lerp(FrameTime() * 4, alpha, 0)
    end

    surface.SetAlphaMultiplier(alpha)

    surface.SetDrawColor(color_dark)
    surface.SetTextColor(color_white)
    surface.SetFont("wepsel")

    local thisWidth = 0

    for i, v in pairs(loadout) do
        thisWidth = thisWidth + width + margin
    end

    local offx = (ScrW() - (thisWidth - margin))*0.5

    for i, v in pairs(loadout) do
        local offy = margin

        draw.RoundedBox(0, offx, offy, height, height, color_dark)

        local w, h = surface.GetTextSize(i + 1)
        surface.SetTextPos(offx  + (height - w) / 2, offy + (height - h) / 2)
        surface.DrawText(i + 1)
        offy = offy + h + margin

        for j, wep in pairs(v) do
            local selected = curTab == i and curSlot == j

            local height = height + (height + margin) * (slide[wep.classname] or 0)

            slide[wep.classname] = Lerp(FrameTime() * 10, slide[wep.classname] or 0, selected and 1 or 0)

            draw.RoundedBox(4, offx, offy, width, height, selected and color_bright or color_dark)

            surface.SetFont("wepsel")
            local w, h = surface.GetTextSize(wep.name)
            if w > width then
                surface.SetFont("wepsel_small")
                w, h = surface.GetTextSize(wep.name)
            end
            surface.SetTextPos(offx + (width - w) / 2, offy + (height - h) / 2)
            surface.DrawText(wep.name)

            offy = offy + height + margin
        end
        
        surface.SetFont("wepsel")

        offx = offx + width + margin
    end

    surface.SetAlphaMultiplier(1)
end)

end
hook.Add("PlayerIsLoaded", "Weapon_Selector", WeaponSelector)
WeaponSelector()
--addons/ent_drugz/lua/autorun/client/effects.lua:
local mat_fb = Material( "pp/fb" )
local i = 1

hook.Add( "HUDPaint", "DrugsEffect", function()
    local ply = LocalPlayer()


    if ply:GetNetVar('Weed') then
    
        if ply.alpha == nil then ply.alpha = 0 end
        if ply.alpha > 255  then ply.alpha = 0 end
        if ply.alpha < 255  then ply.alpha = ply.alpha + 0.05 end

        if ply.alpha ~= nil then
        
            ply:SetEyeAngles(ply:EyeAngles()+Angle((math.cos(CurTime())/1000)*ply.alpha,(math.sin(CurTime()*2)/2550)*ply.alpha,0))
        
    
            for i=1,35 do
                local cos = math.cos(i/2) * ply.alpha*2
                local sin = math.sin(i/2) * ply.alpha*2
                local sin2 = math.cos(CurTime())* ply.alpha/15
                local cos2 = math.sin(CurTime())* ply.alpha/15

                surface.SetDrawColor( 255, 255, 255, ( ply.alpha/2.1 )/(i/10) )
                surface.SetMaterial( mat_fb ) 
                surface.DrawTexturedRect( cos-cos2, (sin-sin2), ScrW(), ScrH() )
            end
    
            surface.SetDrawColor( math.sin(CurTime())*255, 255, -math.cos(CurTime())*255, ( ply.alpha/2 ) )
            surface.DrawRect( 0, 0, ScrW(), ScrH() )
            
        end
    end

    if ply:GetNetVar("Meth") then
        if ply.alpha == nil then ply.alpha = 0 end
        if ply.alpha > 255  then ply.alpha = 0 end
        if ply.alpha < 255  then ply.alpha = ply.alpha + 0.05 end
 
        local cos = math.cos(i/2) * ply.alpha/5
        local sin = math.sin(i/2) * ply.alpha/10
        local sin2 = math.cos(CurTime())* ply.alpha/10
        local cos2 = math.sin(CurTime())* ply.alpha/10

        ply:SetEyeAngles(ply:EyeAngles()+Angle((math.cos(CurTime())/2550)*ply.alpha,(math.sin(CurTime()*2)/2550)*ply.alpha,0))

        surface.SetDrawColor( 255, 255, 255, ( ply.alpha/2.1 )/(i/10) )
        surface.SetMaterial( mat_fb ) 
        surface.DrawTexturedRect( cos-cos2, (sin-sin2), ScrW(), ScrH() )
        surface.SetDrawColor( 255, 255, 255, ( 255-ply.alpha ) )
        surface.DrawRect( 0, 0, ScrW(), ScrH() )
    end

    if ply:GetNetVar('Alc') then
        ply:SetEyeAngles(ply:EyeAngles()+Angle((math.cos(CurTime())/3000)*1000,(math.sin(CurTime()*2)/2550)*1000,0))
    end

    if ply:GetNetVar('LSD') then 
        for K, v in player.Iterator() do
            local point = v:GetPos() + v:OBBCenter()
            local data2D = point:ToScreen()

            if ( not data2D.visible ) then continue end

            draw.SimpleText( "GMan is here!", "DermaDefault", data2D.x, data2D.y, Color( math.random(0,255), math.random(0,255), math.random(0,255) ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

        end
    end

    if ply:GetNetVar('Heroine') then
        ply:SetEyeAngles(ply:EyeAngles()+Angle((math.cos(CurTime())/3000)*1000,(math.sin(CurTime()*2)/2550)*1000,0))
    end

end )

local gman = Material( "models/gman/gman_facehirez" )
local dist = 250000
local ang = Angle(-90,0,0)

local lsd_cache = {}

timer.Create("lsd_cache", 1, 0, function()
    
    local ply = LocalPlayer()
    
    if not ply:GetNetVar('LSD') then 
        lsd_cache = {}
        return 
    end

    if IsValid(ply) then
        
        local count = 0
        lsd_cache = {}

        for k,v in ipairs(ents.FindInSphere(ply:GetPos(), 500)) do
            if v:GetClass() == "player" and v:Alive() then
                count = count + 1
                lsd_cache[count] = v
            end
        end

    end
end)

hook.Add( "PostDrawOpaqueRenderables" , "LSD.Effect" , function( ply )
    for _, ply in ipairs(lsd_cache) do
        if not IsValid(ply) then continue end
        local bone = ply:LookupBone( "ValveBiped.Bip01_Head1" )

        if bone ~= nil then 
            local pos = ply:GetBonePosition( bone ) - EyeAngles():Forward() * 7
            
            render.SetMaterial( gman )
            render.DrawQuadEasy( pos, (EyeAngles()+ang):Up(), 12, 12, color_white, 180 )
        end
    end
end )

net.Receive('AlcEffect', function()

local matLight

http.DownloadMaterial("http://wayzerroleplay.myarena.ru/mellface.png", "mellface.png", function(mat)
    local matLight = mat

    hook.Add('PostDrawTranslucentRenderables', 'Alc.Effect', function()
        if not LocalPlayer():GetNetVar('Alc') then return end

        for k,v in player.Iterator() do
            local eye = v:LookupAttachment( "eyes" )
            if ( eye == 1 ) then
            if v == LocalPlayer() then continue end
            local pos = v:GetAttachment(eye).Pos
            local dir = v:EyeAngles()
            render.SetMaterial( matLight )
            render.DrawSprite( pos - dir:Forward() * -2, 16, 16, Color( 255,255,255, 255 ), 255 )
            end
        end
    end)
end)



local g_station = nil

sound.PlayURL ( "http://wayzerroleplay.myarena.ru/mellstroy.mp3", "mono", function( station )
    if ( IsValid( station ) ) then

        station:SetPos( LocalPlayer():GetPos() )
    
        station:Play()

        -- Keep a reference to the audio object, so it doesn't get garbage collected which will stop the sound
        g_station = station
    
    else

        LocalPlayer():ChatPrint( "Invalid URL!" )

    end
end )

timer.Simple(45, function() LocalPlayer():ConCommand('stopsound') g_station = nil hook.Remove('PostDrawTranslucentRenderables', 'Alc.Effect') end)

end)

local badtrip = {
    [ "$pp_colour_addr" ] = 0,
    [ "$pp_colour_addg" ] = 0,
    [ "$pp_colour_addb" ] = 0,
    [ "$pp_colour_brightness" ] = 0,
    [ "$pp_colour_contrast" ] = 1,
    [ "$pp_colour_colour" ] = 1,
    [ "$pp_colour_mulr" ] = 30,
    [ "$pp_colour_mulg" ] = -5,
    [ "$pp_colour_mulb" ] = -30
}

local heroine = {
    [ "$pp_colour_addr" ] = 0,
    [ "$pp_colour_addg" ] = 0,
    [ "$pp_colour_addb" ] = 0,
    [ "$pp_colour_brightness" ] = 0,
    [ "$pp_colour_contrast" ] = 1,
    [ "$pp_colour_colour" ] = 0,
    [ "$pp_colour_mulr" ] = 0,
    [ "$pp_colour_mulg" ] = 0,
    [ "$pp_colour_mulb" ] = -30,
}

hook.Add( "RenderScreenspaceEffects", "LSD.Colour", function()
    local ply = LocalPlayer()
    if ply:GetNetVar('LSD') then 
        if ply.trip then
            DrawColorModify( badtrip )
        else
            DrawTexturize(1, Material('pp/texturize/rainbow.png'))
        end
    end

    if ply:GetNetVar('Heroine') then
        DrawColorModify( heroine )
    end

    if ply:GetNetVar('Alc') then
        DrawMotionBlur(0.5, 0.5, 0.1)
    end
end )
--addons/module_echat/lua/autorun/client/lua_editor.lua:

-----------------------------------------------------
local refresh_autocompletes = wlib.func.blank -- bottom of file

local PANEL = {}

local TAG = "lua_editor"
local file = file



function PANEL:RefreshAutocompletes(force)
	
	if self.written_autocomplete and not force then return end
	
	self.written_autocomplete = true

	refresh_autocompletes()
	
end

// lua_openscript_cl srv/chat/lua/autorun/client/lua_editor.lua;chatbox_recreate;lua_editor_url "http://10.5.1.8:8080/debug/"

PANEL.URL = "http://metastruct.github.io/lua_editor/"//"http://gmchan.ru/lua_editor"

PANEL.Modes = {
	"glua",
	"lua",
	"javascript",
	"json",
	"text",
	"plain_text",
	"sql",
	"xml",
	"",
	"ada",
	"assembly_x86",
	"autohotkey",
	"batchfile",
	"c9search",
	"c_cpp",
	"csharp",
	"css",
	"diff",
	"html",
	"html_ruby",
	"ini",
	"java",
	"jsoniq",
	"jsp",
	"luapage",
	"lucene",
	"makefile",
	"markdown",
	"mysql",
	"perl",
	"pgsql",
	"php",
	"powershell",
	"properties",
	"python",
	"rhtml",
	"ruby",
	"sh",
	"snippets",
	"svg",
	"vbscript",
}

PANEL.Themes = {
	"ambiance",
	"chaos",
	"chrome",
	"clouds",
	"clouds_midnight",
	"cobalt",
	"crimson_editor",
	"dawn",
	"dreamweaver",
	"eclipse",
	"github",
	"idle_fingers",
	"iplastic",
	"katzenmilch",
	"kr_theme",
	"kuroir",
	"merbivore",
	"merbivore_soft",
	"mono_industrial",
	"monokai",
	"pastel_on_dark",
	"solarized_dark",
	"solarized_light",
	"sqlserver",
	"terminal",
	"textmate",
	"tomorrow",
	"tomorrow_night",
	"tomorrow_night_blue",
	"tomorrow_night_bright",
	"tomorrow_night_eighties",
	"twilight",
	"vibrant_ink",
	"xcode"
}

AccessorFunc( PANEL, "m_iFontSize", "FontSize",			FORCE_NUMBER )
AccessorFunc( PANEL, "m_sTheme", 	"Theme", 			FORCE_STRING )
AccessorFunc( PANEL, "m_sMode", 	"Mode", 			FORCE_STRING )
AccessorFunc( PANEL, "m_sSessName",	"Session",			FORCE_STRING )
AccessorFunc( PANEL, "m_bLoaded",	"HasLoaded",		FORCE_BOOL	 )
AccessorFunc( PANEL, "m_bSaveSnip",	"DoSaveSnippets",	FORCE_BOOL	 )
AccessorFunc( PANEL, "m_bLoadSnip",	"DoLoadSnippets",	FORCE_BOOL	 )

-- TODO:
-- shortcuts: reload panel, run scripts [cl,sv,etc], rebind js-side shortcuts, ...
-- find a way to show the autocompleter while typing without fucking up editor (in lastest version of ace editor, this is just one option.. update pls)
-- remove DoLoad* funcs (should we load anything here, or let parent decide?)
-- get modes and themes from ace editor and send them over a html-binded function -- may not work in latest version of ace editor
--      var modes = {}; editor.menuOptions.setMode.forEach( function( v, k ) { modes[k] = v.textContent; } );
--      var themes = {}; editor.menuOptions.setTheme.forEach(function( v, k ){ themes[v.textContent] = v.value; });
-- use gmodinterface.InternalUpdateTable( TableName, JsonContentTable ) instead of Internal[ANYTHING]Update(...)
-- save extern (loaded outside of lua_editor data folder) files if their content gets changed
-- some files may not load because they need more than the encodings of encode(). what about encoding base64 then decoding js-side?
-- find a way to add lua completions!!
-- UPDATE ACE EDITOR TO LASTEST VERSION


function PANEL:Init()
	
	self:SetCookieName( TAG )
	self:SetDoSaveSnippets( true )
	self:SetDoLoadSnippets( true )
	
	self.SaveDirectory	= TAG .. "/"
	self.Sessions		= {}
	self.Snippets		= {}
	self.CTThreshold	= 5 -- Compile Time Threshold in ms.
	
	self.LoadBtn = vgui.Create( "DButton", self )
		self.LoadBtn:SetText( "Loading Editor | Click me to retry" )
		self.LoadBtn:SizeToContents()
		self.LoadBtn:SetPos( 4, 1 )
		self.LoadBtn:SetSize( self.LoadBtn:GetWide() + 10, self.LoadBtn:GetTall() + 5 )
		self.LoadBtn.DoClick = function() self:LoadURL() end
		self.LoadBtn.Think = function( self ) self:SetTextColor( Color( 100 + 100 * math.sin( CurTime() * 10 ), 50, 50, 255 ) ) end
	
	self.ErrBtn	= vgui.Create( "DButton", self )
		self.ErrBtn:Dock( BOTTOM )
		self.ErrBtn:SetIcon( "icon16/cancel.png" )
		self.ErrBtn:SetTooltip( "Right click to copy error text" )
		self.ErrBtn:SetVisible( false )
		self.ErrBtn:SetTextColor( color_black )
		self.ErrBtn:SetContentAlignment( 4 )
		self.ErrBtn.DoRightClick = function( self ) SetClipboardText( self:GetText() ) end
		self.ErrBtn.DoClick = function() self:GotoErrorLine() end
		self.ErrBtn.Paint = function( self, w, h )
			draw.RoundedBox( 2, 0, 0, w, h, Color( 150,50,50 ) )
			draw.RoundedBox( 2, 2, 2, w - 4, h - 4, Color( 200, 75, 75 ) )
		end
	
	hook.Add( "ShutDown", self, function()
		if not IsValid( self ) or not self.HTML then return end
		self:SaveSnippets()
	end )
	
end

local lua_editor_url = CreateClientConVar("lua_editor_url","",false,false)
function PANEL:GetURL()
	return (lua_editor_url:GetString():find"https?://" and lua_editor_url:GetString()) or self.URL
end

function PANEL:LoadURL()
	self:SetHasLoaded( false )
	self.HTML:OpenURL( self:GetURL() )
	self.LoadBtn:SetVisible( true )
end

function PANEL:CreateHTML()
	self.HTML = vgui.Create( "DHTML", self )
		self.HTML:Dock( FILL )
		self.HTML:RequestFocus()
		self.HTML.OnFocusChanged = function( _, gained ) self:OnFocus( gained ) end
		self.LoadBtn:MoveToAfter( self.HTML )
		self.HTML.Paint= function(self) self:IsLoading() end
			
		function self.HTML.ConsoleMessage( html, msg )

			Msg( "[LEDITOR] " )
			print( msg==nil and "*js variable?*" or msg )

		end
	
	local function bind( name ) -- creates the js->lua callback: gmodinterface.funcname -> PANEL:funcname( ... )
		self.HTML:AddFunction( "gmodinterface", name, function( ... )
			self[ name ]( self, ... )
		end )
	end
	
	bind "OnReady"
	bind "OnCode"
	bind "OnLog"
	bind "onmousedown"
	bind "InternalSnippetsUpdate"
	
	self:LoadURL()
end

function PANEL:Paint( w, h ) -- delayed loading
	if not self.__loaded then
		self.__loaded = true
		self:RefreshAutocompletes()
		self:CreateHTML()
	end
end

function PANEL:Think()
	if not self.HTML or not self:GetHasLoaded() then return end
	
	if self.mdown then
		local mrx, mry = self.HTML:CursorPos()
		local pw, ph = self.HTML:GetSize()
		
		if mrx < 0 or mry < 0 or mrx > pw or mry > ph then
			local fx, fy = math.Clamp( mrx, 1, pw - 1 ), math.Clamp( mry, 1, ph - 1 )
			local sx, sy = self.HTML:LocalToScreen( fx, fy )
			
			input.SetCursorPos( sx, sy ) -- not all the commands go through so we spam this shit
			gui.InternalCursorMoved( sx, sy )
			
			if not input.IsMouseDown( MOUSE_LEFT ) then
				gui.InternalMouseReleased( MOUSE_LEFT )
				--self.HTML:PostMessage( "MouseReleased", "code", MOUSE_LEFT )
				self.mdown = false
			end
		end
	end
end

local function encode( str )
	return str:gsub( '\\', [[\\]] ):gsub( '"', [[\"]] ):gsub( '\r', [[\r]] ):gsub( '\n', [[\n]] )
end

local function FormatFilename( str ) -- removes bad characters
	return str:gsub( "[^%/%w%_%. ]", "" )
end

function PANEL:GotoErrorLine()
	if self:GetHasLoaded() then self.HTML:Call( "GotoLine(" .. ( self.ErrorLine or 0 ) .. ");" ) end
end

function PANEL:ValidateCode( code )
	code = code or self:GetCode()
	
	if not code or code:len() < 1 or self:GetMode() != "glua" then
		self:SetError( false )
		return
	end
	
	local took = SysTime()
	local var  = CompileString( code, "lua_editor", false )
	took = ( SysTime() - took ) * 1000
	
	if 		type( var ) == "string" then self:SetError( var )
	elseif	took > self.CTThreshold then self:SetError( "Compiling took " .. math.Round( took, 2 ) .. " ms" )
	else								 self:SetError( false ) end
end

function PANEL:FindFileByName( name )
    return file.Read( name, "GAME" ) or file.Read( self.SaveDirectory .. name .. ".txt", "DATA" )
end

function PANEL:ReloadPage( full )
	if not self:GetHasLoaded() then return end
	self:SaveSnippets()
	self.HTML:Call( "location.reload(".. (full and "true" or "") ..");" )
end

function PANEL:ShowBinds()
	self.HTML:Call("ShowBinds();")
end

function PANEL:ShowMenu()
	self.HTML:Call("ShowMenu();")
end

-- Events
function PANEL:onmousedown()
	self.mdown = true
end

function PANEL:OnRemove()
	self:SaveSnippets()
	hook.Remove( "ShutDown", self )
	gamemode.Call("FinishChat")
end

function PANEL:OnLog( ... )
	Msg "Editor: " print( ... )
end

function PANEL:OnReady()
	self.LoadBtn:SetVisible( false )
	self:SetHasLoaded( true )
	self.Sessions = {} -- this fix a location.reload(); bug
	self.Snippets = {}
	
	self.HTML:Call [[
		document.body.onmousedown = function( evt ) {
			if (evt.button == 0 || evt.button == 1) {
				gmodinterface.onmousedown();
			};
	    }
		var snippets = ace.require("ace/snippets").snippetManager;
		
		editor.on( "change", function() {
			gmodinterface.OnCode( editor.getSession().getValue() );
		} );
		
		editor.sessions	  = editor.sessions	  || {};
		editor.addSession = editor.addSession || function( sessID, txt, mode ) {
			editor.sessions[ sessID ] = ace.createEditSession( txt, "ace/mode/"+mode );
		}
		editor.updateSnippetsList = editor.updateSnippetsList || function( mode ) {
			gmodinterface.InternalSnippetsUpdate( JSON.stringify( snippets.snippetNameMap[ mode || "glua" ] ) );
		}
		editor.addSnippet = editor.addSnippet || function( name, content, mode ) {
			snippets.register( { content:content, name:name, tabTrigger:name }, mode || "glua" );
			editor.updateSnippetsList();
		}
		editor.removeSnippet = editor.removeSnippet || function( name, mode ){
			snippets.unregister( snippets.snippetNameMap[ mode || "glua" ][ name ] );
			editor.updateSnippetsList();
		}
		
		editor.updateSnippetsList();
	]]
	
	self:LoadConfigs()
	if self:GetDoLoadSnippets() then self:LoadSnippets( util.JSONToTable( self:GetCookie( "Snippets" ) or "" ) or {} ) end
	
	self:SetSession( "Default" )
	self:ValidateCode()
	self:OnLoaded()
end

function PANEL:OnCode( code )
	local sessName = self:GetSessionName()
	
	timer.Create( "lua_editor_autosave_" .. sessName, 0.7, 1, function()
		if not self then return end
		self:Save( code, sessName )
		self:ValidateCode( code )
	end )
	
	self.Sessions[ sessName ] = code
	self:OnCodeChanged( code, sessName )
end

PANEL.OnFocus			= function( self ) end
PANEL.OnLoaded 			= function( self, gain ) end
PANEL.OnCodeChanged		= function( self, code, sessName ) end
PANEL.OnSessionAdded	= function( self, name, content ) end
PANEL.OnSessionRemoved	= function( self, name ) end
PANEL.OnSessionChanged  = function( self, name ) end

function PANEL:Save( code, filename )
	if not filename or filename:len() < 1 or not code then 	return end
	if file.Read( filename, "GAME" ) then                   return end
	if code:len() < 1 then self:DeleteFile( filename ) 		return end
	
	filename = FormatFilename( filename )
	local folderPath = ""
	
	for folder in filename:gmatch( "(.+)/" ) do -- for filesname in form of "myfolder/anotherfolder/filename"
		folderPath = folderPath .. folder .. "/"
	    file.CreateDir( self.SaveDirectory .. folderPath )
	end
	
	file.Write( self.SaveDirectory .. filename .. ".txt", code )
end

function PANEL:DeleteFile( filename )
	local path = self.SaveDirectory .. FormatFilename( filename ) .. ".txt"
	
	if file.Exists( path, "DATA" ) then
		file.Delete( path )
		
		local folders = {}
        for folder in filename:gmatch( "(%w+)/" ) do
        	table.insert( folders, folder )
        end
        
        filename = filename:gsub( "[^%/]+$", "" ):gsub( "/$", "" )
        for i = #folders, 1, -1 do
            file.Delete( self.SaveDirectory .. filename )
            filename = filename:gsub( "/" .. folders[i], "" )
        end

	end
end

function PANEL:LoadConfigs()
	if ( not self.HTML ) or not self:GetHasLoaded() then return end
	
	self:SetFontSize( self:GetCookie( "FontSize" ) )
	self:SetTheme( self:GetCookie( "Theme" ) )
	self:SetMode( self:GetCookie( "SyntaxMode" ) )
end

function PANEL:SetCode( content, sessionName )
	if not self.HTML or not self:GetHasLoaded() then return end
	sessionName = sessionName or self:GetSessionName()
	
	self:SetSession( sessionName )
	self.HTML:Call( [[editor.sessions["]] .. sessionName .. [["].getDocument().setValue( "]] .. encode( content or "" ) .. [[" );]] )
end

function PANEL:GetCode( sessionName )
	return self:GetHasLoaded() and self:GetSession( sessionName ) or ""
end

-- Snippets
function PANEL:InternalSnippetsUpdate( JTable ) -- Todo: support multi modes
	if not JTable then return end
	self.Snippets = {}
	
	for name, snippet in pairs( util.JSONToTable( JTable ) ) do
		self.Snippets[ name ] = snippet.content
	end
end

function PANEL:GetSnippets()
	return self.Snippets
end

function PANEL:AddSnippet( name, content, mode )
	if ( not self:GetHasLoaded() ) or ( not name ) or ( not content ) or self.Snippets[ name ] then return end
	self.HTML:Call( [[ editor.addSnippet( "]] .. name .. [[","]] .. encode( content ) .. [[","]] .. ( mode or "glua" ) .. [[" ); ]] )
end

function PANEL:LoadSnippets( snippets, mode )
	if not self:GetHasLoaded() then return end
	
	for name, content in pairs( snippets ) do
		self:AddSnippet( name, content, mode )
	end
end

function PANEL:RemoveSnippet( name, mode )
	if ( not self:GetHasLoaded() ) or ( not name ) then return end
	self.HTML:Call( [[ editor.removeSnippet( "]] .. name .. [[","]] .. ( mode or "glua" ) .. [[" ); ]] )
end

function PANEL:SaveSnippets()
	if not self:GetHasLoaded() or not self:GetDoSaveSnippets() then return end
	self:SetCookie( "Snippets", util.TableToJSON( self:GetSnippets() ) )
end

-- Sessions
function PANEL:AddSession( name, content )
	if not self.HTML or not self:GetHasLoaded() then return end
	if not name or name:len() < 1 or self:GetSession( name ) != nil then return end
	
	name    = FormatFilename( name )
	content = content or self:FindFileByName( name ) or ""
	
	self.Sessions[ name ] = content
	self.HTML:Call( [[editor.addSession( "]] .. name .. [[","]] .. encode( content ) .. [[","]] .. self:GetMode() .. [[" );]] )
	self:OnSessionAdded( name, content )
end

function PANEL:RemoveSession( name )
	if not self.Sessions[ name ] or not self:GetHasLoaded() then return end
	
	self.HTML:Call( [[ delete editor.sessions["]] .. name .. [["]; ]] )
	self.Sessions[ name ] = nil
	self:OnSessionRemoved( name )
end

function PANEL:LoadSessions( sessions )
	if not self:GetHasLoaded() then return end
	
	for name, path in pairs( sessions ) do
		self:AddSession( name, file.Read( path, "GAME" ) )
	end
end

function PANEL:SetSession( name )
	if not self:GetHasLoaded() or not name then return end
	
	if not self.Sessions[ name ] then
		self:AddSession( name )
	end
	
	self.m_sSessName = name
	self.HTML:Call( [[
		editor.setSession( editor.sessions["]] .. name .. [["] );
		editor.getSession().setUseWrapMode( false );
		editor.getSession().setUseSoftTabs( false );
		]] )
	self:ValidateCode()
	self:OnSessionChanged( name )
end

function PANEL:GetSessionName()
	return self.m_sSessName
end

function PANEL:GetSession( name )
	return self.Sessions[ name or self:GetSessionName() ]
end

-- Other
function PANEL:SetTheme( theme )
	self.m_sTheme = table.HasValue( self.Themes, theme ) and theme or "default"
	self:SetCookie( "Theme", self.m_sTheme )
	
	if self.HTML and self:GetHasLoaded() then self.HTML:Call( [[ SetTheme( "]] .. self.m_sTheme .. [[" ); ]] ) end
end

function PANEL:SetFontSize( size )
	self.m_iFontSize = tonumber( size or 12 )
	self:SetCookie( "FontSize", self.m_iFontSize )
	
	if self.HTML and self:GetHasLoaded() then self.HTML:Call( [[ SetFontSize( ]] .. self.m_iFontSize .. [[ ); ]] ) end
end

function PANEL:SetMode( mode )
	self.m_sMode = table.HasValue( self.Modes, mode ) and mode or "glua"
	self:SetCookie( "SyntaxMode", self.m_sMode )
	
	if self.HTML and self:GetHasLoaded() then self.HTML:Call( [[ SetMode( "]] .. self.m_sMode .. [[" ); ]] ) end
end

function PANEL:SetError( err )
	if err then
		self.ErrBtn:SetVisible( true )
		
		local matchage, txt = err:match( "^lua_editor%:(%d+)%:(.*)" )
		local text = matchage and txt and ( "Line " .. matchage .. ":" .. txt ) or err or ""
		local match = err:match( " at line (%d)%)" ) or matchage
		
		self.ErrorLine = match and tonumber( match ) or 1
		self.ErrBtn:SetText( text:gsub( "\r", "\\r" ):gsub( "\n", "\\n" ) )
		self.HTML:Call( 'SetErr(' .. tonumber( self.ErrorLine ) .. ',"' .. encode( err ) .. '");' )
	else
		self.ErrorLine = 0
		self.HTML:Call( "ClearErr();" )
		self.ErrBtn:SetVisible( false )
	end
	
	self:InvalidateLayout()
end

vgui.Register( TAG, PANEL, "EditablePanel" )




----------------------------------






refresh_autocompletes = function()

	
	local _R=debug.getregistry()

	local data = {
		objfuncs = {},
		enums = {},
		modulefuncs = {},
		hooks = {},
		globals = {},
		nonmodulefuncs = {}
	}



	-- the hacks :(

	for hname,f in next,(baseclass.Get("gamemode_base")) do
		if isfunction(f) and isstring(hname) and hname:sub(1,1):upper()==hname:sub(1,1) then
			data.hooks[hname]=true
		end
	end

	for hname,f in next,(baseclass.Get("gamemode_sandbox") or {}) do
		if isfunction(f) and isstring(hname) and hname:sub(1,1):upper()==hname:sub(1,1) then
			data.hooks[hname]=true
		end
	end

	--for hname,f in next,hook.GetTable() do
	--	if not data.hooks[hname] then
	--		data.hooks[hname]=true
	--	end
	--end


	-- Gather object functions
	for objname,v in next,_R do
		if isstring(objname) and istable(v) and (v.MetaID or v.__tostring or v.MetaName) then
			
			for fname,f in next,v do
				if isfunction(f) and isstring(fname) and not fname:find"^__" then
					data.objfuncs[objname..':'..fname]=true
				end
			end
		end
	end

	-- proper packages first
	local bad={_G=true,package=true,_R=true,fx=true,meta=true,last=true,GAMEMODE=true,GM=true,ENT=true,SWEP=true,SENT=true,}
	
	for name,_ in next,bad do
		data.globals[name] = true
	end
	
	for name,t in next,package.loaded do
		if t._NAME and not bad[name] then
			data.globals[name] = true
			for fname,f in next,t do
				if isfunction(f) and isstring(fname) and not fname:find"^__" then
					data.modulefuncs[name..'.'..fname]=true
				end
			end
		end
	end

	-- all _G tables
	for name,t in next,_G do
		if istable(t) and isstring(name) and not bad[name] then
			data.globals[name] = true
			for fname,f in next,t do
				if isfunction(f) and isstring(fname) and not fname:find"^__" then
					if data.modulefuncs[name..'.'..fname] then
						break
					else
						data.nonmodulefuncs[name..'.'..fname]=true
					end
				end
			end
		elseif isfunction(t) and isstring(name) then
			data.globals[name] = true
		end
	end

	-- assrt for dupes
	local t1,t2 = data.modulefuncs,data.nonmodulefuncs local function test(t1,t2)	for k,v in next,t1 do		assert(not t2[k],k) 	end end test(t1,t2) test(t2,t1)

	-- All enums
	for enum,val in next,_G do
		if (isnumber(val) or isstring(val)) and isstring(enum) and enum:upper()==enum then
			data.enums[enum]=true
		end
	end

	for k,tbl in next,data do
		local res= {}
		for fn,_ in next,tbl do
			if #fn>=2 then -- filter small things, sorry
				assert(not fn:find('|',1,true))
				res[#res+1]=fn
			end
		end
		data[k]=res
	end

	local fn = SERVER and 'autocomplete.txt' or 'tmp_autocomplete.dat'
	file.Write(fn,
		SERVER and "\n" or '\n'..'editor_ac = {};'..'\n\n'	)
			
		for name,tbl in next,data do
			table.sort(tbl)
			
			tbl = table.concat(tbl,'|')
			
			if SERVER then
				file.Append(fn,('\tthis.$%s = ("%s").split("|");\n'):format(name,tbl))
			else
				file.Append(fn,('editor_ac.$%s = ("%s").split("|");\n'):format(name,tbl))
			end
			
		end
		



	file.Append(fn,SERVER and '\n' or '\nconsole.log("Clientside autocomplete opened");\n')
	
	Msg"[lua_editor] "print("Wrote clientside autocompletes to data/"..fn)
	
end






-------------------------------------------------------------------------------------------------- KNOPKI




local Tag="chatbox"
module(Tag,package.seeall)

if SERVER then AddCSLuaFile() return end

local L = translation and translation.L or function(s) return s end

local find=string.find
local function CountChars(str,chr)
    local pos=1--pos=pos or 1
	local count=0
    while true do -- will terminate
		local foundat=find(str,chr,pos,true)
		if not foundat then
			return count
		end
		pos=foundat + 1
		count=count + 1 --return 1+CountChars(str,chr,foundat+1)
	end
end

local luatab_highperf=CreateClientConVar("luatab_highperf","0",true,false)
local luatab_highperf_perref=CreateClientConVar("luatab_highperf_perref","0",true,false)
local luatab_highperf_drawhud=CreateClientConVar("luatab_highperf_drawhud","1",true,false)
local nodrawing = false
local ttimeout = 0

local T="highperf"





local mat_Screen		= Material( "pp/fb" )

local mat_MotionBlur	= Material( "pp/motionblur" )
local render=render
local surface=surface
local tex_MotionBlur	= render.GetMoBlurTex0()



local updated

local function RenderScreenspaceEffects()
	if updated then return end
	render.UpdateScreenEffectTexture()
end


local RealTime=RealTime
local startt = RealTime()
local f=1
local function RenderScene()
	
	local now = FrameNumber()
	
	if ttimeout<now or nodrawing==false then
		nodrawing = false
		
			hook.Remove("RenderScene",T)
			hook.Remove("PostRender",T)
			hook.Remove( "RenderScreenspaceEffects", T)
			
		return
	end
	
	if not updated then return end
	local now = RealTime()
	
	if updated<now then
		if luatab_highperf_perref:GetBool()  then
			updated = false
			return
		else
			updated = now + 2
		end
	end
	
	f= (now-startt)*0.5
	f=f>1 and 1 or f<0 and 0 or f
	if f==0 then return end
	
	cam.Start2D()
		
		local sw,sh=ScrW(),ScrH()
		render.SetMaterial( mat_Screen )
		render.DrawScreenQuad()
		
		surface.SetDrawColor(Color(0, 0, 0, f*55))
		surface.DrawRect(0,0,sw,sh)
		if luatab_highperf_drawhud:GetBool() then
			hook.Run("HUDPaint",sw,sh)
		end
		
	cam.End2D()
	return true
end

local function PostRender()
	if updated then return end
	updated = RealTime()+math.Rand(0.9,1.5)
	
end







local function donodraw(hideit)
	if hideit then
		ttimeout = FrameNumber()+2
		if not nodrawing then
			hook.Add("RenderScene",T,RenderScene)
			hook.Add("PostRender",T,PostRender)
			hook.Add( "RenderScreenspaceEffects", T, RenderScreenspaceEffects)
			
			nodrawing = true
			updated = false
			startt = RealTime()
		end
	else
		hook.Remove("RenderScene",T)
		hook.Remove("PostRender",T)
		hook.Remove( "RenderScreenspaceEffects", T)
		nodrawing = false
	end
	
end

local OpenLoadMenu do
	local function del(place)
		return place..(#place>0 and '/' or "")
	end
	local icons = {
		lua = 'page_code',
		png = 'image',
		jpg = 'image',
		txt = 'page',
		vpk = 'database',
		db  = 'database_edit',
	}
	local Menu
	Menu = function(place,cb,x,y)
			
		local m = DermaMenu()
		
			local back = place:match("^(.+)[\\/].-$") or ""
			if back and place~=back then
				m:AddOption(L"BACK",function()
					timer.Simple(0,function()
						Menu(back,cb,x,y)
					end)
				end):SetImage'icon16/arrow_left.png'
			end

		
			local files,folders = file.Find(del(place)..'*','GAME')
			for k,v in next,folders do
				m:AddOption(v,function()
					timer.Simple(0,function()
						Menu(del(place)..v,cb,x,y)
					end)
				end)
			end
			for k,v in next,files do
				local o = m:AddOption(v:gsub("%.txt$",""),function()
					local fp = 	del(place)..v
					cb(fp)
				end)
				local ext = v:match(".+%.(.-)$")
				local t = icons[ext or ""] or 'page_white'
				o:SetImage('icon16/'..t..'.png')
			end
		m:Open()
		if x and y then
		--	m:SetPos(x,y)
		else
			x,y = m:GetPos()
		end
	end
	OpenLoadMenu = Menu
end

------------------------------------------------------
-- Lua Chat Tab
------------------------------------------------------
	local PANEL={}

	local id = 0 -- Running ID.
	local function saveBackup(path, code)
		file.Write(path, code)
		local p = util.RelativePathToFull('data/'..path)
		LocalPlayer():ChatPrint("Backed up to: "..p)
		SetClipboardText(p)
	end
	local canlua = false
	local chat_tab_lua_legacyluadev = CreateClientConVar("chat_tab_lua_legacyluadev","0",true)
	local luadev=setmetatable({},{__index=function(self,key)
		local luadev = _G.luadev
		if chat_tab_lua_legacyluadev:GetBool() then
			luadev=package.loaded.luadev or luadev
		end
		return luadev[key]
	end})
	
	local function codename(editor)
		return editor.TabControl:GetActiveTab().Name
	end
	
	local chat_luatab_easylua = CreateClientConVar("chat_luatab_easylua","1",true)
	local send_mode
	local function overr(t)
		if send_mode then t=send_mode end
		if not chat_luatab_easylua:GetBool() then
			if not istable(t) then t= {} end
			t.easylua = false
		end
		return t
	end
	local buttons= {
		"up",
		"",
		"",
		{L"Run",'icon16/cog_go.png',
			function(code,editor,extra)
				id = id + 1
				luadev.RunOnSelf(code,codename(editor),overr(extra))
			end,
			rightbutton_mode = true,
		},
		{L"Server",'icon16/server.png',
			function(code,editor,extra)

				id = id + 1
				luadev.RunOnServer(code,codename(editor),overr(extra))
			end,
			rightbutton_mode = true,
		},
		{L"Clients",'icon16/group.png',
			function(code,editor,extra)

				id = id + 1
				luadev.RunOnClients(code,codename(editor),overr(extra))
			end,
			rightbutton_mode = true,
		},
		{L"Shared",'icon16/world.png',
			function(code,editor,extra)

				id = id + 1
				luadev.RunOnShared(code,codename(editor),overr(extra))
			end,
			rightbutton_mode = true,
		},
		"",
		{L"Player",'icon16/user.png',
			function(code,editor)

				id = id + 1
				local menu = DermaMenu()
				local plys = player.GetAll()
				table.sort(plys, function(a, b) return a:Name():lower() < b:Name():lower() end)
				for k, v in pairs(plys) do
					menu:AddOption(v:GetName(), function()
						luadev.RunOnClient(code, v, codename(editor))
					end)
				end
				menu:Open()
			end
		},
		{L"Devs",'icon16/user_gray.png',
			function(code)
				if not luadev.IsPlayerAllowed(LocalPlayer(), code) then return end

				luadev.Run(code, {ply = LocalPlayer(), id = LocalPlayer():SteamID()})
				
				for k, v in player.Iterator() do
					if v:IsSuperAdmin() and v ~= LocalPlayer() then
						luadev.RunOnClient(code, nil, v)
					end
				end
			end
		},
		"",
		--[[{L"Servers",'icon16/server_lightning.png',
			function(code,editor)
				
				local menu = DermaMenu()
				menu:AddOption(L"Others", function()
					luadev.RunOnServer('CrossLua([======[' .. code .. ']======])',codename(editor))
				end)
				menu:AddOption(L"All", function()
					luadev.RunOnServer(code,codename(editor))
					luadev.RunOnServer('CrossLua([======[' .. code .. ']======])',codename(editor))
				end)
				menu:AddSpacer()
				for i=1,3 do
					menu:AddOption("#"..i, function()
						id = id + 1
						luadev.RunOnServer('CrossLua([======[' .. code .. ']======],'..i..')',codename(editor))
					end)
				end
				menu:Open()
				
			end
		},--]]
		{L"Javascript",'icon16/script_gear.png',
			function(code,editor)
				editor.code.HTML:Call(code)
			end
		},
		
		"left",
		"",
		--[[{L"Upload",'icon16/transmit.png',
			function(code)
				id = id + 1
				luadev.ShowUploadMenu(code)
			end
		},--]]
		{L"Save",'icon16/script_save.png',
			function(code,editor)
				local path = "lua_editor"
				file.CreateDir(path,'DATA')
				path=path..'/'..os.date'%Y_%m'
				file.CreateDir(path,'DATA')
				
				local filepath
				local menu = DermaMenu()
				menu:AddOption("Name", function()
					Derma_StringRequest("Backup", "Name your backup", "",
					function(str)
						filepath = path.."/"..str..".txt"
						saveBackup(filepath, code)
					end,
					wlib.func.blank,
					"Confirm", "Cancel")
				end)
				menu:AddOption("No name", function()
					local ver = 0

					while not filepath or file.Exists(filepath,'DATA') and ver<9000 do
						ver= ver + 1
						filepath = path.."/backup"..(ver <= 9 and "0" or "")..""..ver..'.txt'
					end

					saveBackup(filepath, code)
				end)
				menu:Open()
			end
		},
		{L"Load",'icon16/script_edit.png',
			function(code,editor)
				OpenLoadMenu ("data/lua_editor",function(p)
					editor.code:SetCode(file.Read(p,'GAME') or "FAILED LOADING "..tostring(p), p:gsub( "data/lua_editor/", "" ):gsub( "(%.txt)$" ,"" ) )
				end)
			end
		},
		--[[{L"Open",'icon16/folder_explore.png',
			function(code)
				id = id + 1
				local menu = DermaMenu()
				menu:AddOption("Local", function()
					filebrowser.ShowTree(false)
				end):SetIcon'icon16/folder_explore.png'
				--menu:AddOption("Server", function()
					--filebrowser.ShowTree(true)
				--end):SetIcon'icon16/server.png'
				menu:Open()
			end
		},--]]
		"",
		{L"Load URL",'icon16/page_link.png',
			function()
				Derma_StringRequest("Load URL",
				"Paste in URL, pastebin and hastebin links are automatically in raw form.","",
				function(url)
					local new_url = url
					new_url = string.gsub(new_url,"pastebin.com/","pastebin.com/raw/")
					new_url = string.gsub(new_url,"hastebin.com/","hastebin.com/raw/")
					--new_url = string.gsub(new_url)
					http.Fetch(new_url,
					function(txt)
						local newtxt = txt
						if newtxt:find("%</html%>") then newtxt = "--[[\nThis URL isn't supported or isn't in raw form\nIf you want another paste site added to whitelist, ask Flex\nIf you just tried to insert HTML code, sorry\n]]--" end
						local url_title = new_url
						url_title = string.gsub(url_title,"(.+)://","")
						url_title = string.gsub(url_title,"%.(.+)/raw/","/")
						url_title = string.gsub(url_title,"","")
						chatbox.chatgui.Lua.code:SetCode(newtxt,url_title)
						--print("[DEBUG] Loaded URL: "..new_url)
					end,
					function(err)
						LocalPlayer():ChatPrint("Error loading URL: "..err)
					end)
				end)
			end
		},
		"",
		{L"pastebin",'icon16/page_link.png',
			function(code,editor)
				local t={
					api_dev_key='df9eb1e9d83f595d31a64e8d03a083ae',
					api_paste_code=code,
					api_option='paste',
					api_paste_format="lua",
					api_paste_private=0,
					api_paste_expire_date='1D',
				}
				local function doit()
					http.Post("http://pastebin.com/api/api_post.php",t,
					function(url,_,head,code)
						LocalPlayer():ChatPrint("Paste URL: "..url)
						SetClipboardText(url)
					end,
					function(err)
						LocalPlayer():ChatPrint("Pastebin err: "..err)
					end)
				end
				local m = DermaMenu()
				local lengths={
					{"Month","1M"},
					{"Week","1W"},
					{"Day","1D"},
					{"Hour","1H"},
					{"10 Minutes","10M"},
				}
				for k,v in next,lengths do
					m:AddOption(v[1],function()
						t.api_paste_expire_date=v[2]
						doit()
					end)
				end
				
				m:Open()
			end
		},
		{L"Send",'icon16/email_go.png',
			function(code, editor)
				local players = player.GetHumans()
				table.sort(players, function(a, b)
					if a:GetFriendStatus() ~= b:GetFriendStatus() then
						return a:GetFriendStatus() == "friend"
					else
						return a:Name():lower() < b:Name():lower()
					end
				end)
				
				local menu 				= DermaMenu()
				local LocalPlayerID		= LocalPlayer():SteamID64()
				local EditorSessionName	= editor.code:GetSessionName()
				local SessionTitle		= LocalPlayerID .. "/" .. EditorSessionName
				
				for _, ply in pairs(players) do
					local menuItem = menu:AddOption(ply:GetName(), function()
						sendcode.send(
							ply:UserID(),
							code,
							SessionTitle
						)
					end)
					if ply:GetFriendStatus()=="friend" then
						menuItem:SetImage('icon16/user_add.png')
					end
				end
				menu:Open()
			end
		},
		{L"Receive",'icon16/email_open.png',
			function(code, editor)
				local menu = DermaMenu()
				
				for userId, _ in next, sendcode.list do
					local name = player.UserIDToName(userId) or userId
					
					local menuItem = menu:AddOption(name, function()
						sendcode.request(userId, function(code, title)
							title = title:gsub("[^%/%w%_%. ]", "")
							chatbox.chatgui.Lua.code:SetCode(code, title)
						end)
					end)
				end
				menu:Open()
			end
		},
		"",
		{L"Beautify",'icon16/style.png',
			function(code,editor)
				if not util.BeautifyLua then return end
				
				local ok,code2 = pcall(util.BeautifyLua,code)
				editor.code:SetCode(tostring(code2))
			end
		},
		"",
		{function(data,container,self)
			
			local l = {}
			
			local lbl = vgui.Create('DLabel',container)
			local entry
			lbl:SetText(" "..L"Send as")
			lbl:SetDark(true)
			container:AddPanel(lbl)
			lbl.DoClick=function()
				local menu = DermaMenu()
				local t = {}
				for k,v in next,l do
					t[#t+1]=k
				end
				table.sort(t)
				
				for _,txt in next,t do
					local m = menu:AddOption(txt, function()
						entry:SetText(txt)
					end)
				end
				
				menu:Open()
			end
			
			entry = vgui.Create('DTextEntry',container)
						
			entry:SetDrawBorder( false )
			
			container:AddPanel(entry)
			
			entry:SetKeyboardInputEnabled(true)
			entry:SetMouseInputEnabled(true)
			
			local t = {}
			
			local function paint_override(b,w,h)
							
				derma.SkinHook( "Paint", "Button", b, w, h )
				
				local chosen  = b.chosen 
				if not chosen then return end
				
				chosen = b.default
				
				surface.SetDrawColor(chosen and 50 or 255,chosen and 255 or 50,20,100)
				surface.DrawRect(0,0,w,h)
			
				return false
			end
			
			local function radio_button(txt,ico,func,chosen)
				local b = vgui.Create("DButton", container)
				t[#t+1]=b
				
				container:AddPanel(b)
				b:SetText( txt )

				b:SetDrawBorder( false )
				b:SetDrawBackground( false )
				
				b.Paint = paint_override
				b.chosen = chosen
				b.default = chosen
				
				b:SetImage( "icon16/"..ico..".png" )
				b.m_Image2=b.m_Image
				b.m_Image=nil
				b.m_Image2:SetPos( 1, (b:GetTall() - b.m_Image2:GetTall()) * 0.5 )
				b:SetTextInset( b.m_Image2:GetWide() + 4, 0 )
				b:SetContentAlignment(4)
				
				b.DoClick = function()
					
					local b=b
					if func() == false then
						b = t[1]
					end
					for k,v in next,t do
						if v==b then
							v.chosen = true
						else
							v.chosen = false
						end
					end
					
				end
			end
			
			radio_button(L"Normal","page_white_horizontal",function()
				send_mode = nil
			
			end,true)
			radio_button(L"Entity","bricks",function()
				local name = entry:GetValue()
				name = name:Trim()
				if name:sub(1,1)=="_" then
					name = 'sent'..name
				end
				if name == "" then send_mode = nil return false end
				
				l[name]= true
				send_mode = {sent=name}
			
			end)
			radio_button(L"Weapon","gun",function()
				local name = entry:GetValue()
				name = name:Trim()
				if name:sub(1,1)=="_" then
					name = 'weapon'..name
				end
				if name == "" then send_mode = nil return false end
				
				l[name]= true
				send_mode = {swep=name}
							

			end)
			radio_button(L"Effect","weather_clouds",function()
				local name = entry:GetValue()
				if name:Trim() == "" then send_mode = nil return false end
				
				l[name]= true
				send_mode = {effect=name}
							

			end)
			
			return true
			
		end},
		"",
		{function(data,container,self)
			
			local entry = vgui.Create('DCheckBoxLabel',container)
			entry:SetText(L"Easylua")
			entry:SetDark(true)
			entry:SetIndent(2)
			entry:SetConVar('chat_luatab_easylua')
			container:AddPanel(entry)
			
			return true
			
		end},
	
	}
	function PANEL:Think()
		if luatab_highperf:GetBool() then donodraw(true) end

		if self.nextresize and self.nextresize<RealTime() then
			self.nextresize = false
			local x,y=self.code_imitator:GetPos()
			local w,h=self.code_imitator:GetSize()
			self.code:SetPos(x,y)
			self.code:SetSize(w,h)

		end
	end
	
	function PANEL:PerformLayout()
		if not self.nextresize then
			self.nextresize = RealTime()+0.2
		end
	end
	
	
	function PANEL:OnActivatedPanel(prev)
		
		canlua = GetConVar"sv_allowcslua":GetBool()
		--canserver = LocalPlayer():IsSuperAdmin()
		
		if IsValid(self.code.HTML) then
			self.code.HTML:RequestFocus()
		end
	end
	
	function PANEL:Init()
		self.filename = "chatbox_lua_save.txt"
		
		local code_imitator = vgui.Create("EditablePanel", self)
		code_imitator:Dock(FILL)
		self.code_imitator=code_imitator
		
		self.TabControl = vgui.Create( "lua_editor_TabControl", self )
		self.TabControl:Dock( FILL )
		self.TabControl:SetSkin( "Default" )
		
		local code = self.TabControl:GetEditor()
		self.code = code
		self.Helpers = Helpers
		
		function code.OnCodeChanged(code, msg)
			if not code:GetHasLoaded() then return end
			--hook.Run("ChatTextChanged", msg, true)
		end
		
		function code.OnFocus(code,gained)
			if not gained then return end
			self.code.OnCodeChanged(self.code, self.code:GetCode())
		end
			

		-- buttons

		self.container_top_wrapper=vgui.Create('DPanel',self)
			self.container_top_wrapper:SetTall(24)
			self.container_top_wrapper:Dock(TOP)
		
		self.container_top=vgui.Create('DHorizontalScroller',self.container_top_wrapper)
			local container_top=self.container_top
			container_top:Dock(FILL)
		
		local buttons_container=vgui.Create('DPanel',self)
			self.buttons_container = buttons_container
			buttons_container:SetWide(75)
			buttons_container:Dock(LEFT)
			function buttons_container.AddPanel(self,pnl)
				pnl:SetParent(self)
				pnl:Dock(TOP)
			end
			
		local b = vgui.Create("DButton", container_top)
			b:SetText( L"Menu" )
			b:SetIcon("icon16/application_edit.png")
			b:SetDrawBorder(false)
			b:SetDrawBackground( false )
			
			b.DoClick = function()
				local m =DermaMenu()
				
				m:AddOption(L"Configure",function()
					self.code:ShowMenu()
				end)
				m:AddOption(L"Show Help",function()
					self.code:ShowBinds()
				end)
				
				do
					local m=m:AddSubMenu("Fix")
						m:AddOption(L"Reopen URL",function()
							self.code:LoadURL()
						end)
						m:AddOption(L"Reload",function()
							self.code:ReloadPage()
						end)
						m:AddOption(L"Reload (empty cache)",function()
							self.code:ReloadPage(true)
						end)
						
				end
				
				do
					local m=m:AddSubMenu("Mode")
					
					for _,name in pairs(self.code.Modes) do
						local txt= name:sub(1,1):upper()..name:sub(2):gsub("_"," ")
						m:AddOption(txt,function()
							self.code:SetMode(name)
						end)
					end
					
				end
				
				do
					local m=m:AddSubMenu("Theme")
					
					for _,name in pairs(self.code.Themes) do
						local txt= name:sub(1,1):upper()..name:sub(2):gsub("_"," ")
						local cb = function()
							self.code:SetTheme(name)
						end
						
						local a = m:AddOption(txt,cb)
						local a_OnMousePressed = a.OnMousePressed
						function a.OnMousePressed( a, mousecode )
							cb()
							return a_OnMousePressed(a,mousecode)
						end
							
					end
					
				end
				
				do
					local m=m:AddSubMenu("Font Size")
					
					for i=9,24 do
						local txt= i..' px'
						m:AddOption(txt,function()
							self.code:SetFontSize(i)
						end)
					end
					
				end
				
				m:AddCVar(L"Legacy LuaDev","chat_tab_lua_legacyluadev","1","0",wlib.func.blank)
			
				m:AddCVar(L"Performance","luatab_highperf","1","0",wlib.func.blank)

				m:Open()
			end
	
			container_top:AddPanel( b )
			


		--local b = vgui.Create("DLabel", buttons_container)
		--	b:SetText( "      "..(L"Run on") )
		--	b:SizeToContents()
		--	buttons_container:AddPanel( b )
		local container = buttons_container
		for _,data in next,buttons do
			if isstring(data) then
			
				if data=="" then
					local b = vgui.Create("EditablePanel", container)
					b:SetSize(16,8)
					b.ApplySchemeSettings=wlib.func.blank
					container:AddPanel( b )
				elseif data=="-" then
					DMenu.AddSpacer(buttons_container)
				elseif data=="up" then
					container = container_top
				elseif data=="left" then
					container = buttons_container
				else
					error"uh"
				end
				
				continue
			elseif isfunction(data[1]) then
				local f  = data[1]
				if f(data,container,self) then continue end
			end
			
			local b = vgui.Create("DButton", container)

			b:SetText( data[1] )
			b:SetDrawBorder(false)
			b:SetDrawBackground( false )
			
			if data[2] then
				
				b:SetImage( data[2] )
				b.m_Image2=b.m_Image
				b.m_Image=nil
				b.m_Image2:SetPos( 1, (b:GetTall() - b.m_Image2:GetTall()) * 0.5 )
				b:SetTextInset( b.m_Image2:GetWide() + 4, 0 )
				b:SetContentAlignment(4)
			end
			
			local h=b:GetTall()
			b:SizeToContents()
			b:SetTall(h)
			b:SetWide( b:GetWide() + 8 )
			b.DoClick = function()
				data[3](self.code:GetCode(),self)
			end
			if data.rightbutton_mode~=nil then
				if data.rightbutton_mode == true and not "this isnt working" then
					b.DoRightClick = function()
						local m = DermaMenu()
						local entry = vgui.Create('DTextEntry',m)
						
						m:AddPanel(entry)
						entry:SetKeyboardInputEnabled(true)
						entry:SetMouseInputEnabled(true)
						m:AddOption(L"As entity",function()
							local name = entry:GetValue()
							data[3](self.code:GetCode(),self,{swep=name})
						end)
						m:AddOption(L"As weapon",function()
							local name = entry:GetValue()
							data[3](self.code:GetCode(),self,{sent=name})
						end)
						m:AddOption(L"As effect",function()
							local name = entry:GetValue()
							data[3](self.code:GetCode(),self,{effect=name})
						end)
						local e = vgui.Create('EditablePanel')
						e:SetKeyboardInputEnabled(true)
						e:SetMouseInputEnabled(true)
						e.Think=function()
							if not m:IsValid() or not m:IsVisible() then 
								e:Remove()
							end
							Msg"."
						end
						e.OnMousePressed=function()
							e:Remove()
						end
						e:SetSize(ScrW(),ScrH())
						e:MakePopup()
						
						m:SetParent(e)
						m:Open()
						m:SetKeyboardInputEnabled(true)
						m:SetMouseInputEnabled(true)
						--m:InvalidateLayout(true)
						entry:RequestFocus()
					end
				else
					--ErrorNoHalt(tostring(data[1]).."\n")
				end
			end
			b.Paint=function(b,w,h)
				if b.Hovered then
					surface.SetDrawColor(30,30,30,30)
					surface.DrawRect(0,0,w,h)
				end
				derma.SkinHook( "Paint", "Button", b, w, h )
				return false
			end
			
			
			if data[2]=="icon16/cog_go.png" then
			
				b.Paint=function(b,w,h)
								
					derma.SkinHook( "Paint", "Button", b, w, h )

					if b.Hovered then
						surface.SetDrawColor(30,30,30,30)
						surface.DrawRect(0,0,w,h)
					else
						
						surface.SetDrawColor(canlua and 50 or 255,canlua and 255 or 50,20,100)
						surface.DrawRect(0,0,w,h)
						
					end
					
					return false
				end
			end

			container:AddPanel( b )
		end
		
		-- Y U NO WORK :(
		--buttons_container:InvalidateLayout(true)
		--buttons_container:SizeToChildren(true,true)
	end

vgui.Register( Tag..'_lua', PANEL, "EditablePanel" )
--gamemodes/darkrp/gamemode/modules/workarounds/sh_interface.lua:
DarkRP.getAvailableVehicles = DarkRP.stub{
    name = "getAvailableVehicles",
    description = "Get the available vehicles that DarkRP supports.",
    parameters = {
    },
    returns = {
        {
            name = "vehicles",
            description = "Names, models and classnames of all supported vehicles.",
            type = "table"
        }
    },
    metatable = DarkRP
}

--gamemodes/darkrp/gamemode/libraries/modificationloader.lua:
-- Modification loader.
-- Dependencies:
--     - fn
--     - simplerr

--[[---------------------------------------------------------------------------
Disabled defaults
---------------------------------------------------------------------------]]
DarkRP.disabledDefaults = {}
DarkRP.disabledDefaults["modules"] = {
    ["afk"]              = true,
    ["chatsounds"]       = false,
    ["events"]           = false,
    ["fpp"]              = false,
    ["hitmenu"]          = false,
    ["hud"]              = false,
    ["hungermod"]        = true,
    ["playerscale"]      = false,
    ["sleep"]            = false,
}

DarkRP.disabledDefaults["agendas"]          = {}
DarkRP.disabledDefaults["ammo"]             = {}
DarkRP.disabledDefaults["demotegroups"]     = {}
DarkRP.disabledDefaults["doorgroups"]       = {}
DarkRP.disabledDefaults["entities"]         = {}
DarkRP.disabledDefaults["food"]             = {}
DarkRP.disabledDefaults["groupchat"]        = {}
DarkRP.disabledDefaults["hitmen"]           = {}
DarkRP.disabledDefaults["jobs"]             = {}
DarkRP.disabledDefaults["shipments"]        = {}
DarkRP.disabledDefaults["vehicles"]         = {}

-- The client cannot use simplerr.runLuaFile because of restrictions in GMod.
local doInclude = CLIENT and include or fc{simplerr.wrapError, simplerr.wrapLog, simplerr.runFile}

if file.Exists("darkrp_config/disabled_defaults.lua", "LUA") then
    if SERVER then AddCSLuaFile("darkrp_config/disabled_defaults.lua") end
    doInclude("darkrp_config/disabled_defaults.lua")
end

--[[---------------------------------------------------------------------------
Config
---------------------------------------------------------------------------]]
local configFiles = {
    "darkrp_config/settings.lua",
    "darkrp_config/licenseweapons.lua",
}

for _, File in pairs(configFiles) do
    if not file.Exists(File, "LUA") then continue end

    if SERVER then AddCSLuaFile(File) end
    doInclude(File)
end
if SERVER and file.Exists("darkrp_config/mysql.lua", "LUA") then doInclude("darkrp_config/mysql.lua") end

--[[---------------------------------------------------------------------------
Modules
---------------------------------------------------------------------------]]
local function loadModules()
    local fol = "darkrp_modules/"

    local _, folders = file.Find(fol .. "*", "LUA")

    for _, folder in SortedPairs(folders, true) do
        if folder == "." or folder == ".." or GAMEMODE.Config.DisabledCustomModules[folder] then continue end
        -- Sound but incomplete way of detecting the error of putting addons in the darkrpmod folder
        if file.Exists(fol .. folder .. "/addon.txt", "LUA") or file.Exists(fol .. folder .. "/addon.json", "LUA") then
            DarkRP.errorNoHalt("Addon detected in the darkrp_modules folder.", 2, {
                "This addon is not supposed to be in the darkrp_modules folder.",
                "It is supposed to be in garrysmod/addons/ instead.",
                "Whether a mod is to be installed in darkrp_modules or addons is the author's decision.",
                "Please read the readme of the addons you're installing next time."
            },
            "<darkrpmod addon>/lua/darkrp_modules/" .. folder, -1)
            continue
        end

        for _, File in SortedPairs(file.Find(fol .. folder .. "/sh_*.lua", "LUA"), true) do
            if SERVER then
                AddCSLuaFile(fol .. folder .. "/" .. File)
            end

            if File == "sh_interface.lua" then continue end
            doInclude(fol .. folder .. "/" .. File)
        end

        if SERVER then
            for _, File in SortedPairs(file.Find(fol .. folder .. "/sv_*.lua", "LUA"), true) do
                if File == "sv_interface.lua" then continue end
                doInclude(fol .. folder .. "/" .. File)
            end
        end

        for _, File in SortedPairs(file.Find(fol .. folder .. "/cl_*.lua", "LUA"), true) do
            if File == "cl_interface.lua" then continue end

            if SERVER then
                AddCSLuaFile(fol .. folder .. "/" .. File)
            else
                doInclude(fol .. folder .. "/" .. File)
            end
        end
    end
end

local function loadLanguages()
    local fol = "darkrp_language/"

    local files, _ = file.Find(fol .. "*", "LUA")
    for _, File in pairs(files) do
        if SERVER then AddCSLuaFile(fol .. File) end
        doInclude(fol .. File)
    end
end

local customFiles = {
    "darkrp_customthings/jobs.lua",
    "darkrp_customthings/shipments.lua",
    "darkrp_customthings/entities.lua",
    "darkrp_customthings/vehicles.lua",
    "darkrp_customthings/food.lua",
    "darkrp_customthings/ammo.lua",
    "darkrp_customthings/groupchats.lua",
    "darkrp_customthings/categories.lua",
    "darkrp_customthings/agendas.lua", -- has to be run after jobs.lua
    "darkrp_customthings/doorgroups.lua", -- has to be run after jobs.lua
    "darkrp_customthings/demotegroups.lua", -- has to be run after jobs.lua
}
local function loadCustomDarkRPItems()
    for _, File in pairs(customFiles) do
        if not file.Exists(File, "LUA") then continue end
        if File == "darkrp_customthings/food.lua" and DarkRP.disabledDefaults["modules"]["hungermod"] then continue end

        if SERVER then AddCSLuaFile(File) end
        doInclude(File)
    end
end


function GM:DarkRPFinishedLoading()
    -- GAMEMODE gets set after the last statement in the gamemode files is run. That is not the case in this hook
    GAMEMODE = GAMEMODE or GM

    loadLanguages()
    loadModules()
    loadCustomDarkRPItems()
    hook.Call("loadCustomDarkRPItems", GAMEMODE)
end

-- NETVAR

nw.Register 'DarkRP_Lockdown'
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetGlobal()

nw.Register 'FAdmin_commandprefix'
    :Write(net.WriteString)
    :Read(net.ReadString)
    :SetGlobal()
--gamemodes/darkrp/gamemode/modules/workarounds/sh_workarounds.lua:
-- Shared part
--[[---------------------------------------------------------------------------
Sound crash glitch
---------------------------------------------------------------------------]]

local entity = FindMetaTable("Entity")
local plyMeta = FindMetaTable("Player")
local EmitSound = entity.EmitSound
function entity:EmitSound(sound, ...)
    if not sound then DarkRP.error(string.format("The first argument of the ent:EmitSound call is '%s'. It's supposed to be a string.", tostring(sound)), 3) end
    if string.find(sound, "??", 0, true) then return end
    return EmitSound(self, sound, ...)
end


function DarkRP.getAvailableVehicles()
    local vehicles = list.Get("Vehicles")
    for k, v in pairs(list.Get("SCarsList") or {}) do
        vehicles[v.PrintName] = {
            Name = v.PrintName,
            Class = v.ClassName,
            Model = v.CarModel
        }
    end

    return vehicles
end

local osdate = os.date
if system.IsWindows() then
    local replace = function(txt)
        if txt == "%%" then return txt end -- Edge case, %% is allowed
        return ""
    end

    function os.date(format, time)
        if format then format = string.gsub(format, "%%[^aAbBcdHIjmMpSUwWxXyYz]", replace) end

        return osdate(format, time)
    end
end

timer.Simple(3, function()
    -- Malicious addons that kicks players this one person doesn't like.
    if Skid then
        Skid.Check = fn.Id
        hook.Remove("CheckPassword", "Skid.CheckPassword")

        MsgC(Color(0, 255, 0), "SkidCheck", Color(255, 255, 255), " has been ", Color(255, 0, 0), "DISABLED\n", Color(255, 255, 255), [[
        SkidCheck was detected on this server and has been disabled.

        SkidCheck is a ban list addon made by HeX as an attempt to get the people he doesn't like
        banned from as many servers as possible.

        You have probably installed this addon thinking that it would get rid of cheaters, and sure,
        it might get rid of some, but that's only to make you want to download this.

        SkidCheck would ban me (FPtje, developer of DarkRP) from your server because I have a
        workshop addon that he doesn't like and because I know how to throw a prop around
            (type /credits yourname in chat for the full story on that)
        It doesn't just ban /me/ for that, it bans EVERYONE who is subscribed to the addon.

        Can you imagine trying an addon out and getting on this list /just/ because you have
        it installed? That's SkidCheck for you.

        It also bans people who have a VAC ban (even if gotten from another game), people from
        arbitrary groups, /friends/ of people he doesn't like and many, many more.

        I'm not pulling this out of my ass either, you can check everything here:
        http://facepunch.com/showthread.php?t=1483607


        On a somewhat unrelated note, HeX has been known to be malicious for quite some time:
        He used to have an anticheat (called HAC) on his server, which not only misfired from
        time to time, but actively used exploits to fuck "cheaters" up as much as possible,
        doing malicious shit ranging from unbinding keys to removing every friend they had in
        their friends list.

        That too can be fact checked right here:
        http://facepunch.com/showthread.php?t=1416320

        DO NOT trust this guy to decide who gets banned from your server. In fact,
        DO NOT EVER TRUST ANYONE with that power. No one ever should have the power
        to decide who gets banned and who doesn't over the servers that decide to install
        their addon.
]])
    end
end)

-- Clientside part
if CLIENT then
    --[[---------------------------------------------------------------------------
    Generic InitPostEntity workarounds
    ---------------------------------------------------------------------------]]
    hook.Add("InitPostEntity", "DarkRP_Workarounds", function()
        if hook.GetTable().HUDPaint then hook.Remove("HUDPaint","drawHudVital") end -- Removes the white flashes when the server lags and the server has flashbang. Workaround because it's been there for fucking years

        -- Fuck up APAnti
        net.Receivers.sblockgmspawn = nil
        hook.Remove("PlayerBindPress", "_sBlockGMSpawn")
    end)

    local camstart3D = cam.Start3D
    local camend3D = cam.End3D
    local cam3DStarted = 0
    function cam.Start3D(a,b,c,d,e,f,g,h,i,j)
        cam3DStarted = cam3DStarted + 1
        return camstart3D(a,b,c,d,e,f,g,h,i,j)
    end

    -- cam.End3D should not crash a player when 3D hasn't been started
    function cam.End3D()
        if not cam3DStarted or cam3DStarted <= 0 then return end
        cam3DStarted = cam3DStarted - 1
        return camend3D()
    end

    return
end

if game.SinglePlayer() or GetConVar("sv_lan"):GetBool() then
    local sid64 = plyMeta.SteamID64

    function plyMeta:SteamID64(...)
        local sid = sid64(self, ...)

        return sid or 0
    end
end

--[[---------------------------------------------------------------------------
Generic InitPostEntity workarounds
---------------------------------------------------------------------------]]
hook.Add("InitPostEntity", "DarkRP_Workarounds", function()
    local commands = concommand.GetTable()
    if commands["durgz_witty_sayings"] then
        game.ConsoleCommand("durgz_witty_sayings 0\n") -- Deals with the cigarettes exploit. I'm fucking tired of them. I hate having to fix other people's mods, but this mod maker is retarded and refuses to update his mod.
    end

    -- Remove ULX /me command. (the /me command is the only thing this hook does)
    hook.Remove("PlayerSay", "ULXMeCheck")

    -- why can people even save multiplayer games?
    -- Lag exploit
    if SERVER and not game.SinglePlayer() then
        concommand.Remove("gm_save")
    end

    -- Remove that weird rooftop spawn in rp_downtown_v4c_v2
    if game.GetMap() == "rp_downtown_v4c_v2" then
        for k,v in pairs(ents.FindByClass("info_player_terrorist")) do
            v:Remove()
        end
    end
end)

--[[---------------------------------------------------------------------------
Fuck up APAnti. These hooks send unnecessary net messages.
---------------------------------------------------------------------------]]
timer.Simple(3, function()
    hook.Remove("Move", "_APA.Settings.AllowGMSpawn")
    hook.Remove("PlayerSpawnObject", "_APA.Settings.AllowGMSpawn")
end)

--[[---------------------------------------------------------------------------
Wire field generator exploit
---------------------------------------------------------------------------]]
--[[ 
hook.Add("OnEntityCreated", "DRP_WireFieldGenerator", function(ent)
    timer.Simple(0, function()
        if IsValid(ent) and ent:GetClass() == "gmod_wire_field_device" then
            local TriggerInput = ent.TriggerInput
            function ent:TriggerInput(iname, value)
                if value ~= nil and iname == "Distance" then
                    value = math.Min(value, 400)
                end
                TriggerInput(self, iname, value)
            end
        end
    end)
end)
--]] 
--[[---------------------------------------------------------------------------
Door tool is shitty
Let's fix that huge class exploit
---------------------------------------------------------------------------]]
hook.Add("InitPostEntity", "FixDoorTool", function()
    local oldFunc = makedoor
    if oldFunc then
        function makedoor(ply, trace, ang, model, open, close, autoclose, closetime, class, hardware, ...)
            if class ~= "prop_dynamic" and class ~= "prop_door_rotating" then return end

            oldFunc(ply, trace, ang, model, open, close, autoclose, closetime, class, hardware, ...)
        end
    end
end)

--[[---------------------------------------------------------------------------
Anti crash exploit
---------------------------------------------------------------------------]]
hook.Add("PropBreak", "drp_AntiExploit", function(attacker, ent)
    if IsValid(ent) and ent:GetPhysicsObject():IsValid() then
        constraint.RemoveAll(ent)
    end
end)

local allowedDoors = {
    ["prop_dynamic"] = true,
    ["prop_door_rotating"] = true,
    [""] = true
}

hook.Add("CanTool", "DoorExploit", function(ply, trace, tool)
    if not IsValid(ply) or not ply:IsPlayer() or not IsValid(ply:GetActiveWeapon()) or not ply:GetActiveWeapon().GetToolObject or not ply:GetActiveWeapon():GetToolObject() then return end

    tool = ply:GetActiveWeapon():GetToolObject()
    if not allowedDoors[string.lower(tool:GetClientInfo("door_class") or "")] then
        return false
    end
end)

--[[---------------------------------------------------------------------------
Actively deprecate commands
---------------------------------------------------------------------------]]
local deprecated = {
    {command = "rp_removeletters",      alternative = "removeletters"           },
    {command = "rp_setname",            alternative = "forcerpname"             },
    {command = "rp_unlock",             alternative = "forceunlock"             },
    {command = "rp_lock",               alternative = "forcelock"               },
    {command = "rp_removeowner",        alternative = "forceremoveowner"        },
    {command = "rp_addowner",           alternative = "forceown"                },
    {command = "rp_unownall",           alternative = "forceunownall"           },
    {command = "rp_unown",              alternative = "forceunown"              },
    {command = "rp_own",                alternative = "forceown"                },
    {command = "rp_tellall",            alternative = "admintellall"            },
    {command = "rp_tell",               alternative = "admintell"               },
    {command = "rp_teamunban",          alternative = "teamunban"               },
    {command = "rp_teamban",            alternative = "teamban"                 },
    {command = "rp_setsalary",          alternative = "setmoney"                },
    {command = "rp_setmoney",           alternative = "setmoney"                },
    {command = "rp_revokelicense",      alternative = "unsetlicense"            },
    {command = "rp_givelicense",        alternative = "setlicense"              },
    {command = "rp_unlockdown",         alternative = "unlockdown"              },
    {command = "rp_lockdown",           alternative = "lockdown"                },
    {command = "rp_unarrest",           alternative = "unarrest"                },
    {command = "rp_arrest",             alternative = "arrest"                  },
    {command = "rp_cancelvote",         alternative = "forcecancelvote"         },
}

local lastDeprecated = 0
local function msgDeprecated(cmd, ply)
    if CurTime() - lastDeprecated < 0.5 then return end
    lastDeprecated = CurTime()

    DarkRP.notify(ply, 1, 4, ("This command has been deprecated. Please use 'DarkRP %s' or '/%s' instead."):format(cmd.alternative, cmd.alternative))
end

for _, cmd in pairs(deprecated) do
    concommand.Add(cmd.command, fp{msgDeprecated, cmd})
end

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/spawnmenu.lua:
local spawnmenu_border = CreateConVar( "spawnmenu_border", "0.1", { FCVAR_ARCHIVE } )

include( "toolmenu.lua" )
include( "contextmenu.lua" )
include( "creationmenu.lua" )

local PANEL = {}

function PANEL:Init()

	self:Dock( FILL )

	self.HorizontalDivider = vgui.Create( "DHorizontalDivider", self )
	self.HorizontalDivider:Dock( FILL )
	self.HorizontalDivider:SetLeftWidth( ScrW() ) -- It will be automatically resized by DHorizontalDivider to account for GetRightMin/GetLeftMin
	self.HorizontalDivider:SetDividerWidth( 6 )
	self.HorizontalDivider:SetCookieName( "SpawnMenuDiv" )
	self.HorizontalDivider:SetRightMin( 300 )
	if ( ScrW() >= 1024 ) then self.HorizontalDivider:SetRightMin( 460 ) end

	self.ToolMenu = vgui.Create( "ToolMenu", self.HorizontalDivider )
	self.HorizontalDivider:SetRight( self.ToolMenu )

	self.CreateMenu = vgui.Create( "CreationMenu", self.HorizontalDivider )
	self.HorizontalDivider:SetLeft( self.CreateMenu )

	self.m_bHangOpen = false

	self:SetMouseInputEnabled( true )

	self.ToolToggle = vgui.Create( "DImageButton", self )
	self.ToolToggle:SetMaterial( "gui/spawnmenu_toggle" )
	self.ToolToggle:SetSize( 16, 16 )
	self.ToolToggle.DoClick = function()

		self.ToolMenu:SetVisible( !self.ToolMenu:IsVisible() )
		self:InvalidateLayout()

		if ( self.ToolMenu:IsVisible() ) then
			self.ToolToggle:SetMaterial( "gui/spawnmenu_toggle" )
			self.CreateMenu:Dock( NODOCK ) -- What an ugly hack
			self.HorizontalDivider:SetRight( self.ToolMenu )
			self.HorizontalDivider:SetLeft( self.CreateMenu )
		else
			self.ToolToggle:SetMaterial( "gui/spawnmenu_toggle_back" )
			self.HorizontalDivider:SetRight( nil ) -- What an ugly hack
			self.HorizontalDivider:SetLeft( nil )
			self.CreateMenu:SetParent( self.HorizontalDivider )
			self.CreateMenu:Dock( FILL )
		end

	end

end

function PANEL:OpenCreationMenuTab( name )

	self.CreateMenu:SwitchToName( name )

end

function PANEL:GetToolMenu()

	return self.ToolMenu

end

function PANEL:GetCreationMenu()

	return self.CreateMenu

end

--[[---------------------------------------------------------
	Name: OnClick
-----------------------------------------------------------]]
function PANEL:OnMousePressed()

	self:Close()

end

--[[---------------------------------------------------------
	Name: HangOpen
-----------------------------------------------------------]]
function PANEL:HangOpen( bHang )

	self.m_bHangOpen = bHang

end

--[[---------------------------------------------------------
	Name: HangingOpen
-----------------------------------------------------------]]
function PANEL:HangingOpen()

	return self.m_bHangOpen

end

--[[---------------------------------------------------------
	Name: Paint
-----------------------------------------------------------]]
function PANEL:Open()

	RestoreCursorPosition()

	self.m_bHangOpen = false

	-- If the context menu is open, try to close it..
	if ( IsValid( g_ContextMenu ) && g_ContextMenu:IsVisible() ) then
		g_ContextMenu:Close( true )
	end

	if ( self:IsVisible() ) then return end

	CloseDermaMenus()

	self:MakePopup()
	self:SetVisible( true )
	self:SetKeyboardInputEnabled( false )
	self:SetMouseInputEnabled( true )
	self:SetAlpha( 255 )

	achievements.SpawnMenuOpen()

	if ( IsValid( self.StartupTool ) && self.StartupTool.Name ) then
		self.StartupTool:SetSelected( true )
		spawnmenu.ActivateTool( self.StartupTool.Name, true )
		self.StartupTool = nil
	end

end

--[[---------------------------------------------------------
	Name: Paint
-----------------------------------------------------------]]
function PANEL:Close( bSkipAnim )

	if ( self.m_bHangOpen ) then
		self.m_bHangOpen = false
		return
	end

	RememberCursorPosition()

	CloseDermaMenus()

	self:SetKeyboardInputEnabled( false )
	self:SetMouseInputEnabled( false )
	self:SetVisible( false )

end

function PANEL:PerformLayout()

	local MarginX = math.Clamp( ( ScrW() - 1024 ) * spawnmenu_border:GetFloat(), 25, 256 )
	local MarginY = math.Clamp( ( ScrH() - 768 ) * spawnmenu_border:GetFloat(), 25, 256 )

	-- At this size we can't spare any space for emptiness
	if ( ScrW() < 1024 || ScrH() < 768 ) then
		MarginX = 0
		MarginY = 0
	end

	self:DockPadding( 0, 0, 0, 0 )
	self.HorizontalDivider:DockMargin( MarginX, MarginY, MarginX, MarginY )
	self.HorizontalDivider:SetLeftMin( self.HorizontalDivider:GetWide() / 3 )

	self.ToolToggle:AlignRight( 6 )
	self.ToolToggle:AlignTop( 6 )

end

function PANEL:StartKeyFocus( pPanel )

	self.m_pKeyFocus = pPanel
	self:SetKeyboardInputEnabled( true )
	self:HangOpen( true )

end

function PANEL:EndKeyFocus( pPanel )

	if ( self.m_pKeyFocus != pPanel ) then return end
	self:SetKeyboardInputEnabled( false )

end

function PANEL:OnSizeChanged( newW, newH )
	local divW = self.HorizontalDivider:GetWide()
	local divL = self.HorizontalDivider:GetLeftWidth()
	self:InvalidateLayout( true )
	local divWnew = self.HorizontalDivider:GetWide()

	if ( divW > divL && divW < divWnew ) then
		local ratio = divL / divW
		self.HorizontalDivider:SetLeftWidth( ratio * divWnew )
	end
end

vgui.Register( "SpawnMenu", PANEL, "EditablePanel" )

--[[---------------------------------------------------------
	Called to create the spawn menu..
-----------------------------------------------------------]]
local function CreateSpawnMenu()

	if ( !hook.Run( "SpawnMenuEnabled" ) ) then return end

	-- If we have an old spawn menu remove it.
	if ( IsValid( g_SpawnMenu ) ) then
		g_SpawnMenu:Remove()
		g_SpawnMenu = nil
	end

	hook.Run( "PreReloadToolsMenu" )

	-- Start Fresh
	spawnmenu.ClearToolMenus()

	-- Add defaults for the gamemode. In sandbox these defaults
	-- are the Main/Postprocessing/Options tabs.
	-- They're added first in sandbox so they're always first
	hook.Run( "AddGamemodeToolMenuTabs" )

	-- Use this hook to add your custom tools
	-- This ensures that the default tabs are always
	-- first.
	hook.Run( "AddToolMenuTabs" )

	-- Use this hook to add your custom tools
	-- We add the gamemode tool menu categories first
	-- to ensure they're always at the top.
	hook.Run( "AddGamemodeToolMenuCategories" )
	hook.Run( "AddToolMenuCategories" )

	-- Add the tabs to the tool menu before trying
	-- to populate them with tools.
	hook.Run( "PopulateToolMenu" )

	g_SpawnMenu = vgui.Create( "SpawnMenu" )

	if ( IsValid( g_SpawnMenu ) ) then
		g_SpawnMenu:SetVisible( false )
		hook.Run( "SpawnMenuCreated", g_SpawnMenu )
	end

	CreateContextMenu()

	hook.Run( "PostReloadToolsMenu" )

end
-- Hook to create the spawnmenu at the appropriate time (when all sents and sweps are loaded)
hook.Add( "OnGamemodeLoaded", "CreateSpawnMenu", CreateSpawnMenu )
concommand.Add( "spawnmenu_reload", CreateSpawnMenu )

function GM:OnSpawnMenuOpen()

	-- Let the gamemode decide whether we should open or not..
	if ( !hook.Call( "SpawnMenuOpen", self ) ) then return end

	if ( IsValid( g_SpawnMenu ) ) then
		g_SpawnMenu:Open()
		--menubar.ParentTo( g_SpawnMenu )
	end

	hook.Call( "SpawnMenuOpened", self )

end

function GM:OnSpawnMenuClose()

	if ( IsValid( g_SpawnMenu ) ) then g_SpawnMenu:Close() end
	hook.Call( "SpawnMenuClosed", self )

end

--[[---------------------------------------------------------
	Name: HOOK SpawnMenuKeyboardFocusOn
		Called when text entry needs keyboard focus
-----------------------------------------------------------]]
local function SpawnMenuKeyboardFocusOn( pnl )

	if ( IsValid( g_SpawnMenu ) && IsValid( pnl ) && pnl:HasParent( g_SpawnMenu ) ) then
		g_SpawnMenu:StartKeyFocus( pnl )
	end
	if ( IsValid( g_ContextMenu ) && IsValid( pnl ) && pnl:HasParent( g_ContextMenu ) ) then
		g_ContextMenu:StartKeyFocus( pnl )
	end

end
hook.Add( "OnTextEntryGetFocus", "SpawnMenuKeyboardFocusOn", SpawnMenuKeyboardFocusOn )

--[[---------------------------------------------------------
	Name: HOOK SpawnMenuKeyboardFocusOff
		Called when text entry stops needing keyboard focus
-----------------------------------------------------------]]
local function SpawnMenuKeyboardFocusOff( pnl )

	if ( IsValid( g_SpawnMenu ) && IsValid( pnl ) && pnl:HasParent( g_SpawnMenu ) ) then
		g_SpawnMenu:EndKeyFocus( pnl )
	end

	if ( IsValid( g_ContextMenu ) && IsValid( pnl ) && pnl:HasParent( g_ContextMenu ) ) then
		g_ContextMenu:EndKeyFocus( pnl )
	end

end
hook.Add( "OnTextEntryLoseFocus", "SpawnMenuKeyboardFocusOff", SpawnMenuKeyboardFocusOff )

--[[---------------------------------------------------------
	Name: HOOK SpawnMenuOpenGUIMousePressed
		Don't do context screen clicking if spawnmenu is open
-----------------------------------------------------------]]
local function SpawnMenuOpenGUIMousePressed()

	if ( !IsValid( g_SpawnMenu ) ) then return end
	if ( !g_SpawnMenu:IsVisible() ) then return end

	return true

end
hook.Add( "GUIMousePressed", "SpawnMenuOpenGUIMousePressed", SpawnMenuOpenGUIMousePressed )

--[[---------------------------------------------------------
	Name: HOOK SpawnMenuOpenGUIMousePressed
		Close spawnmenu if it's open
-----------------------------------------------------------]]
local function SpawnMenuOpenGUIMouseReleased()

	if ( !IsValid( g_SpawnMenu ) ) then return end
	if ( !g_SpawnMenu:IsVisible() ) then return end

	g_SpawnMenu:Close()

	return true

end

hook.Add( "GUIMouseReleased", "SpawnMenuOpenGUIMouseReleased", SpawnMenuOpenGUIMouseReleased )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/toolmenu.lua:

include( "toolpanel.lua" )

local PANEL = {}

--[[---------------------------------------------------------
	Name: Paint
-----------------------------------------------------------]]
function PANEL:Init()

	self.ToolPanels = {}

	self:LoadTools()

	self:SetFadeTime( 0 )

end

--[[---------------------------------------------------------
	LoadTools
-----------------------------------------------------------]]
function PANEL:LoadTools()

	local tools = spawnmenu.GetTools()

	for strName, pTable in pairs( tools ) do

		self:AddToolPanel( strName, pTable )

	end

end

--[[---------------------------------------------------------
	AddToolPanel
-----------------------------------------------------------]]
function PANEL:AddToolPanel( Name, ToolTable )

	-- I hate relying on a table's internal structure
	-- but this isn't really that avoidable.

	local Panel = vgui.Create( "ToolPanel" )
	Panel:SetTabID( Name )
	Panel:LoadToolsFromTable( ToolTable.Items )
	Panel.PropertySheet = self
	Panel.PropertySheetTab = self:AddSheet( ToolTable.Label, Panel, ToolTable.Icon ).Tab

	self.ToolPanels[ Name ] = Panel

end

--[[---------------------------------------------------------
	Name: Paint
-----------------------------------------------------------]]
function PANEL:Paint( w, h )

	DPropertySheet.Paint( self, w, h )

end

--[[---------------------------------------------------------
	Name: GetToolPanel
-----------------------------------------------------------]]
function PANEL:GetToolPanel( id )

	return self.ToolPanels[ id ]

end

vgui.Register( "ToolMenu", PANEL, "DPropertySheet" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/controlpanel.lua:

--
--	Note: This is only really here as a layer between the spawnmenu
--			and the DForm Derma control. You shouldn't ever really be
--			calling AddControl. If you're writing new code - don't call
--			AddControl!! Add stuff directly using the DForm member functions!
--

include( "controls/manifest.lua" )

local PANEL = {}

AccessorFunc( PANEL, "m_bInitialized", "Initialized" )

function PANEL:Init()
	self:SetInitialized( false )
end

function PANEL:ClearControls()
	self:Clear()
end

function PANEL:GetEmbeddedPanel()

	return self

end

function PANEL:AddPanel( pnl )

	self:AddItem( pnl, nil )
	self:InvalidateLayout()

end

function PANEL:MatSelect( strConVar, tblOptions, bAutoStretch, iWidth, iHeight )

	local MatSelect = vgui.Create( "MatSelect", self )
	Derma_Hook( MatSelect.List, "Paint", "Paint", "Panel" )

	MatSelect:SetConVar( strConVar )

	if ( bAutoStretch != nil ) then MatSelect:SetAutoHeight( bAutoStretch ) end
	if ( iWidth != nil ) then MatSelect:SetItemWidth( iWidth ) end
	if ( iHeight != nil ) then MatSelect:SetItemHeight( iHeight ) end

	if ( tblOptions != nil ) then
		for k, v in pairs( tblOptions ) do
			local nam = isnumber( k ) and v or k
			MatSelect:AddMaterial( nam, v )
		end
	end

	self:AddPanel( MatSelect )
	return MatSelect

end

function PANEL:ToolPresets( group, cvarlist )

	local preset = vgui.Create( "ControlPresets", self )

	preset:SetPreset( group )
	preset:AddOption( "#preset.default", cvarlist )

	for k, v in pairs( cvarlist ) do
		preset:AddConVar( k )
	end

	self:AddItem( preset )

	return preset

end

function PANEL:KeyBinder( label1, convar1, label2, convar2 )

	local binder = vgui.Create( "CtrlNumPad", self )

	binder:SetLabel1( label1 )
	binder:SetConVar1( convar1 )

	if ( label2 != nil and convar2 != nil ) then
		binder:SetLabel2( label2 )
		binder:SetConVar2( convar2 )
	end

	self:AddPanel( binder )

	return binder

end

function PANEL:ColorPicker( label, convarR, convarG, convarB, convarA )

	local color = vgui.Create( "CtrlColor", self )

	color:Dock( TOP )
	color:SetLabel( label )

	color:SetConVarR( convarR )
	color:SetConVarG( convarG )
	color:SetConVarB( convarB )

	if ( convarA != nil ) then
		color:SetConVarA( convarA )
	end

	self:AddPanel( color )

	return color

end

function PANEL:FillViaTable( Table )

	self:SetInitialized( true )

	self:SetName( Table.Text )

	--
	-- If we have a function to create the control panel, use that
	--
	if ( Table.ControlPanelBuildFunction ) then

		self:FillViaFunction( Table.ControlPanelBuildFunction )

	end

end

function PANEL:FillViaFunction( func )

	func( self )

end

function PANEL:ControlValues( data )
	if ( data.label) then
		self:SetLabel( data.label )
	end
	if ( data.closed ) then
		self:SetExpanded( false )
	end
end


function PANEL:AddControl( control, data )

	local data = table.LowerKeyNames( data )
	local original = control
	control = string.lower( control )

	-- Retired
	if ( control == "header" ) then

		if ( data.description ) then
			local ctrl = self:Help( data.description )
			return ctrl
		end

		return
	end

	if ( control == "textbox" ) then

		local ctrl = self:TextEntry( data.label or "Untitled", data.command )
		return ctrl

	end

	if ( control == "label" ) then

		local ctrl = self:Help( data.text )
		return ctrl

	end

	if ( control == "checkbox" or control == "toggle" ) then

		local ctrl = self:CheckBox( data.label or "Untitled", data.command )

		if ( data.help ) then
			self:ControlHelp( data.label .. ".help" )
		end

		return ctrl

	end

	if ( control == "slider" ) then

		local Decimals = 0
		if ( data.type && string.lower(data.type) == "float" ) then Decimals = 2 end

		local ctrl = self:NumSlider( data.label or "Untitled", data.command, data.min or 0, data.max or 100, Decimals )

		if ( data.help ) then
			self:ControlHelp( data.label .. ".help" )
		end

		if ( data.default ) then
			ctrl:SetDefaultValue( data.default )
		elseif ( data.command ) then
			local cvar = GetConVar( data.command )
			if ( cvar ) then
				ctrl:SetDefaultValue( cvar:GetDefault() )
			end
		end

		return ctrl

	end

	if ( control == "propselect" ) then

		local ctrl = vgui.Create( "PropSelect", self )
		ctrl:ControlValues( data ) -- Yack.
		self:AddPanel( ctrl )
		return ctrl

	end

	if ( control == "matselect" ) then

		local ctrl = vgui.Create( "MatSelect", self )
		ctrl:ControlValues( data ) -- Yack.
		self:AddPanel( ctrl )

		Derma_Hook( ctrl.List, "Paint", "Paint", "Panel" )

		return ctrl

	end

	if ( control == "ropematerial" ) then

		local ctrl = vgui.Create( "RopeMaterial", self )
		ctrl:SetConVar( data.convar )
		self:AddPanel( ctrl )

		return ctrl

	end

	if ( control == "button" ) then

		local ctrl = vgui.Create( "DButton", self )

		-- Note: Buttons created this way use the old method of calling commands,
		-- via LocalPlayer:ConCommand. This way is flawed. This way is legacy.
		-- The new way is to make buttons via controlpanel:Button( name, command, commandarg1, commandarg2 ) etc
		if ( data.command ) then
			function ctrl:DoClick() LocalPlayer():ConCommand( data.command ) end
		end

		ctrl:SetText( data.label or data.text or "No Label" )
		self:AddPanel( ctrl )
		return ctrl

	end

	if ( control == "numpad" ) then

		local ctrl = vgui.Create( "CtrlNumPad", self )
		ctrl:SetConVar1( data.command )
		ctrl:SetConVar2( data.command2 )
		ctrl:SetLabel1( data.label )
		ctrl:SetLabel2( data.label2 )

		self:AddPanel( ctrl )
		return ctrl

	end

	if ( control == "color" ) then

		local ctrl = vgui.Create( "CtrlColor", self )
		ctrl:SetLabel( data.label )
		ctrl:SetConVarR( data.red )
		ctrl:SetConVarG( data.green )
		ctrl:SetConVarB( data.blue )
		ctrl:SetConVarA( data.alpha )

		self:AddPanel( ctrl )
		return ctrl

	end


	if ( control == "combobox" ) then

		if ( tostring( data.menubutton ) == "1" ) then

			local ctrl = vgui.Create( "ControlPresets", self )
			ctrl:SetPreset( data.folder )
			if ( data.options ) then
				for k, v in pairs( data.options ) do
					ctrl:AddOption( k, v )
				end
			end

			if ( data.cvars ) then
				for k, v in pairs( data.cvars ) do
					ctrl:AddConVar( v )
				end
			end

			self:AddPanel( ctrl )
			return ctrl

		end

		control = "listbox"

	end

	if ( control == "listbox" ) then

		if ( data.height ) then

			local ctrl = vgui.Create( "DListView" )
			ctrl:SetMultiSelect( false )
			ctrl:AddColumn( data.label or "unknown" )

			if ( data.options ) then

				for k, v in pairs( data.options ) do

					local line = ctrl:AddLine( k )
					line.data = v

					-- This is kind of broken because it only checks one convar
					-- instead of all of them. But this is legacy. It will do for now.
					for k, v in pairs( line.data ) do
						if ( GetConVarString( k ) == tostring( v ) ) then
							line:SetSelected( true )
						end
					end

				end

			end

			ctrl:SetTall( data.height )
			ctrl:SortByColumn( 1, false )

			function ctrl:OnRowSelected( LineID, Line )
				for k, v in pairs( Line.data ) do
					RunConsoleCommand( k, v )
				end
			end

			self:AddItem( ctrl )

			return ctrl

		else

			local ctrl = vgui.Create( "CtrlListBox", self )

			if ( data.options ) then
				for k, v in pairs( data.options ) do
					ctrl:AddOption( k, v )
				end
			end

			local left = vgui.Create( "DLabel", self )
			left:SetText( data.label )
			left:SetDark( true )
			ctrl:SetHeight( 25 )
			ctrl:Dock( TOP )

			self:AddItem( left, ctrl )

			return ctrl

		end

	end

	if ( control == "materialgallery" ) then

		local ctrl = vgui.Create( "MatSelect", self )
		--ctrl:ControlValues( data ) -- Yack.

		ctrl:SetItemWidth( data.width or 32 )
		ctrl:SetItemHeight( data.height or 32 )
		ctrl:SetNumRows( data.rows or 4 )
		ctrl:SetConVar( data.convar or nil )

		Derma_Hook( ctrl.List, "Paint", "Paint", "Panel" )

		for name, tab in pairs( data.options ) do

			local mat = tab.material
			local value = tab.value

			tab.material = nil
			tab.value = nil

			ctrl:AddMaterialEx( name, mat, value, tab )

		end

		self:AddPanel( ctrl )
		return ctrl

	end

	local ctrl = vgui.Create( original, self )
	-- Fallback for scripts that relied on the old behaviour
	if ( !ctrl ) then
		ctrl = vgui.Create( control, self )
	end
	if ( ctrl ) then

		if ( ctrl.ControlValues ) then
			ctrl:ControlValues( data )
		end

		self:AddPanel( ctrl )
		return ctrl

	end

	MsgN( "UNHANDLED CONTROL: ", control )
	PrintTable( data )
	MsgN( "\n\n" )

end

vgui.Register( "ControlPanel", PANEL, "DForm" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/controls/control_presets.lua:

include( "preset_editor.lua" )

local PANEL = {}

function PANEL:Init()

	self.DropDown = vgui.Create( "DComboBox", self )
	self.DropDown.OnSelect = function( dropdown, index, value, data ) self:OnSelect( index, value, data ) end
	self.DropDown:SetText( "Presets" )
	self.DropDown:Dock( FILL )

	self.Button = vgui.Create( "DImageButton", self )
	self.Button.DoClick = function() self:OpenPresetEditor() end
	self.Button:Dock( RIGHT )
	self.Button:SetToolTip( "#preset.edit" )
	self.Button:SetMaterial( "icon16/wrench.png" )
	self.Button:SetStretchToFit( false )
	self.Button:SetSize( 20, 20 )
	self.Button:DockMargin( 0, 0, 0, 0 )

	self.AddButton = vgui.Create( "DImageButton", self )
	self.AddButton.DoClick = function()
		if ( !IsValid( self ) ) then return end

		self:QuickSavePreset()
	end
	self.AddButton:Dock( RIGHT )
	self.AddButton:SetToolTip( "#preset.add" )
	self.AddButton:SetMaterial( "icon16/add.png" )
	self.AddButton:SetStretchToFit( false )
	self.AddButton:SetSize( 20, 20 )
	self.AddButton:DockMargin( 2, 0, 0, 0 )

	self:SetTall( 20 )

	self.Options = {}
	self.ConVars = {}

end

function PANEL:SetLabel( strName )

	self.Label:SetText( strName )

end

function PANEL:AddOption( strName, data )

	self.DropDown:AddChoice( strName, data )

	self.Options[ strName ] = data

end

function PANEL:SetOptions( Options )
	if ( Options ) then
		table.Merge( self.Options, Options )
	end
end

function PANEL:OnSelect( index, value, data )

	if ( !data ) then return end

	for k, v in pairs( data ) do
		RunConsoleCommand( k, v )
	end

end

function PANEL:QuickSaveInternal( text )
	local tabValues = {}
	for k, v in pairs( self:GetConVars() ) do
		tabValues[ v ] = GetConVarString( v )
	end

	presets.Add( self.m_strPreset, text, tabValues )
	self:Update()
end

function PANEL:QuickSavePreset()
	Derma_StringRequest( "#preset.saveas_title", "#preset.saveas_desc", "", function( text )
		if ( !text || text:Trim() == "" ) then presets.BadNameAlert() return end

		if ( presets.Exists( self.m_strPreset, text ) ) then
			presets.OverwritePresetPrompt( function()
				self:QuickSaveInternal( text )
			end )
			return
		end

		self:QuickSaveInternal( text )
	end )
end

function PANEL:OpenPresetEditor()

	if ( !self.m_strPreset ) then return end

	self.Window = vgui.Create( "PresetEditor" )
	self.Window:MakePopup()
	self.Window:Center()
	self.Window:SetType( self.m_strPreset )
	self.Window:SetConVars( self:GetConVars() )
	self.Window:SetPresetControl( self )

end

function PANEL:AddConVar( convar )

	table.insert( self.ConVars, convar )

end

function PANEL:GetConVars()

	return self.ConVars

end

function PANEL:SetPreset( strName )

	self.m_strPreset = strName
	self:ReloadPresets()

end

function PANEL:ReloadPresets()

	self:Clear()

	for name, data in pairs( self.Options ) do
		self:AddOption( name, data )
	end

	local Presets = presets.GetTable( self.m_strPreset )
	local sortedPresets, i = {}, 1
	for name in pairs( Presets ) do
		sortedPresets[ i ] = name
		i = i + 1
	end
	table.sort( sortedPresets )

	for _, name in ipairs( sortedPresets ) do
		self.DropDown:AddChoice( name, Presets[ name ] )
	end

end

function PANEL:Update()

	self:ReloadPresets()

end

function PANEL:Clear()

	self.DropDown:Clear()

end

vgui.Register( "ControlPresets", PANEL, "Panel" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/controls/ctrlcolor.lua:

local PANEL = {}

function PANEL:Init()

	self.Mixer = vgui.Create( "DColorMixer", self )
	self.Mixer:Dock( FILL )

	self:SetTall( 245 )

end

function PANEL:PerformLayout( x, y )

	-- Magic number, the target width for self.Mixer
	-- Number picked to that Palette would not have a gap, at button size 17
	local targetWidth = 272

	-- Don't scale the Mixer in width, keep it to the target width
	local s = math.max( ( self:GetWide() - targetWidth ) / 2, 0 )
	self.Mixer:DockMargin( s, 8, s, 0 )

	-- Ugly hack, because of the docking system
	self.OldMixerW = self.OldMixerW or self.Mixer:GetWide()

	-- Number of panels in one row
	local ColorRows = math.ceil( #self.Mixer.Palette:GetChildren() / 3 )

	-- Set the button size closest to fill the Mixer width
	local bSize = math.floor( self:GetWide() / ColorRows )
	self.Mixer.Palette:SetButtonSize( math.min( bSize, 17 ) )

end

function PANEL:Paint()
	-- Invisible background!
end

function PANEL:SetLabel( text ) self.Mixer:SetLabel( text ) end
function PANEL:SetConVarR( cvar ) self.Mixer:SetConVarR( cvar ) end
function PANEL:SetConVarG( cvar ) self.Mixer:SetConVarG( cvar ) end
function PANEL:SetConVarB( cvar ) self.Mixer:SetConVarB( cvar ) end
function PANEL:SetConVarA( cvar ) self.Mixer:SetConVarA( cvar ) end
function PANEL:GetConVarR() return self.Mixer:GetConVarR() end
function PANEL:GetConVarG() return self.Mixer:GetConVarG() end
function PANEL:GetConVarB() return self.Mixer:GetConVarB() end
function PANEL:GetConVarA() return self.Mixer:GetConVarA() end

vgui.Register( "CtrlColor", PANEL, "DPanel" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/contextmenu.lua:

local PANEL = {}

AccessorFunc( PANEL, "m_bHangOpen", "HangOpen" )

function PANEL:Init()

	--
	-- This makes it so that when you're hovering over this panel
	-- you can `click` on the world. Your viewmodel will aim etc.
	--
	self:SetWorldClicker( true )

	self.Canvas = vgui.Create( "DCategoryList", self )
	self.m_bHangOpen = false

	self:Dock( FILL )

end

function PANEL:Open()

	self:SetHangOpen( false )

	-- If the spawn menu is open, try to close it..
	if ( IsValid( g_SpawnMenu ) && g_SpawnMenu:IsVisible() ) then
		g_SpawnMenu:Close( true )
	end

	if ( self:IsVisible() ) then return end

	CloseDermaMenus()

	self:MakePopup()
	self:SetVisible( true )
	self:SetKeyboardInputEnabled( false )
	self:SetMouseInputEnabled( true )

	RestoreCursorPosition()

	local bShouldShow = true

	-- TODO: Any situation in which we shouldn't show the tool menu on the context menu?

	-- Set up the active panel..
	if ( bShouldShow && IsValid( spawnmenu.ActiveControlPanel() ) ) then

		self.OldParent = spawnmenu.ActiveControlPanel():GetParent()
		self.OldPosX, self.OldPosY = spawnmenu.ActiveControlPanel():GetPos()
		spawnmenu.ActiveControlPanel():SetParent( self )
		self.Canvas:Clear()
		self.Canvas:AddItem( spawnmenu.ActiveControlPanel() )
		self.Canvas:Rebuild()
		self.Canvas:SetVisible( true )

	else

		self.Canvas:SetVisible( false )

	end

	self:InvalidateLayout( true )

end

function PANEL:Close( bSkipAnim )

	if ( self:GetHangOpen() ) then
		self:SetHangOpen( false )
		return
	end

	RememberCursorPosition()

	CloseDermaMenus()

	self:SetKeyboardInputEnabled( false )
	self:SetMouseInputEnabled( false )

	self:SetAlpha( 255 )
	self:SetVisible( false )
	self:RestoreControlPanel()

end

function PANEL:PerformLayout()

	if ( IsValid( spawnmenu.ActiveControlPanel() ) ) then

		spawnmenu.ActiveControlPanel():InvalidateLayout( true )

		local Tall = math.min( spawnmenu.ActiveControlPanel():GetTall() + 10, ScrH() * 0.8 )
		if ( self.Canvas:GetTall() != Tall ) then self.Canvas:SetTall( Tall ) end
		if ( self.Canvas:GetWide() != 320 ) then self.Canvas:SetWide( 320 ) end

		self.Canvas:SetPos( ScrW() - self.Canvas:GetWide() - 50, ScrH() - 50 - Tall )
		self.Canvas:InvalidateLayout( true )

	end

end

function PANEL:StartKeyFocus( pPanel )

	self:SetKeyboardInputEnabled( true )
	self:SetHangOpen( true )

end

function PANEL:EndKeyFocus( pPanel )

	self:SetKeyboardInputEnabled( false )

end

function PANEL:RestoreControlPanel()

	-- Restore the active panel
	if ( !spawnmenu.ActiveControlPanel() ) then return end
	if ( !self.OldParent ) then return end

	spawnmenu.ActiveControlPanel():SetParent( self.OldParent )
	spawnmenu.ActiveControlPanel():SetPos( self.OldPosX, self.OldPosY )

	self.OldParent = nil

end

--
-- Note here: EditablePanel is important! Child panels won't be able to get
-- keyboard input if it's a DPanel or a Panel. You need to either have an EditablePanel
-- or a DFrame (which is derived from EditablePanel) as your first panel attached to the system.
--
vgui.Register( "ContextMenu", PANEL, "EditablePanel" )

function CreateContextMenu()

	if ( !hook.Run( "ContextMenuEnabled" ) ) then return end

	if ( IsValid( g_ContextMenu ) ) then
		g_ContextMenu:Remove()
		g_ContextMenu = nil
	end

	g_ContextMenu = vgui.Create( "ContextMenu" )

	if ( !IsValid( g_ContextMenu ) ) then return end

	g_ContextMenu:SetVisible( false )

	--
	-- We're blocking clicks to the world - but we don't want to
	-- so feed clicks to the proper functions..
	--
	g_ContextMenu.OnMousePressed = function( p, code )
		hook.Run( "GUIMousePressed", code, gui.ScreenToVector( gui.MousePos() ) )
	end
	g_ContextMenu.OnMouseReleased = function( p, code )
		hook.Run( "GUIMouseReleased", code, gui.ScreenToVector( gui.MousePos() ) )
	end

	hook.Run( "ContextMenuCreated", g_ContextMenu )

	local IconLayout = g_ContextMenu:Add( "DIconLayout" )
	IconLayout:SetBorder( 8 )
	IconLayout:SetSpaceX( 8 )
	IconLayout:SetSpaceY( 8 )
	IconLayout:SetLayoutDir( LEFT )
	IconLayout:SetWorldClicker( true )
	IconLayout:SetStretchWidth( true )
	IconLayout:SetStretchHeight( false ) -- No infinite re-layouts
	IconLayout:Dock( LEFT )

	-- This overrides DIconLayout's OnMousePressed (which is inherited from DPanel), but we don't care about that in this case
	IconLayout.OnMousePressed = function( s, ... ) s:GetParent():OnMousePressed( ... ) end

	for k, v in pairs( list.Get( "DesktopWindows" ) ) do

		local icon = IconLayout:Add( "DButton" )
		icon:SetText( "" )
		icon:SetSize( 80, 82 )
		icon.Paint = wlib.func.blank

		local image = icon:Add( "DImage" )
		image:SetImage( v.icon )
		image:SetSize( 64, 64 )
		image:Dock( TOP )
		image:DockMargin( 8, 0, 8, 0 )

		local label = icon:Add( "DLabel" )
		label:Dock( BOTTOM )
		label:SetText( v.title )
		label:SetContentAlignment( 5 )
		label:SetTextColor( color_white )
		label:SetExpensiveShadow( 1, Color( 0, 0, 0, 200 ) )

		icon.DoClick = function()

			--
			-- v might have changed using autorefresh so grab it again
			--
			local newv = list.Get( "DesktopWindows" )[ k ]

			if ( v.onewindow and IsValid( icon.Window ) ) then
				icon.Window:Center()
				return
			end

			-- Make the window
			icon.Window = g_ContextMenu:Add( "DFrame" )
			icon.Window:SetSize( newv.width, newv.height )
			icon.Window:SetTitle( newv.title )
			icon.Window:Center()

			newv.init( icon, icon.Window )

		end

	end

end

function GM:OnContextMenuOpen()

	-- Let the gamemode decide whether we should open or not..
	if ( !hook.Call( "ContextMenuOpen", self ) ) then return end

	if ( IsValid( g_ContextMenu ) && !g_ContextMenu:IsVisible() ) then
		g_ContextMenu:Open()
		--menubar.ParentTo( g_ContextMenu )
	end

	hook.Call( "ContextMenuOpened", self )

end

function GM:OnContextMenuClose()

	if ( IsValid( g_ContextMenu ) ) then g_ContextMenu:Close() end
	hook.Call( "ContextMenuClosed", self )

end

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contentsidebar.lua:

include( "contentsidebartoolbox.lua" )

local pnlSearch = vgui.RegisterFile( "contentsearch.lua" )

local PANEL = {}

function PANEL:Init()

	self.Tree = vgui.Create( "DTree", self )
	self.Tree:SetClickOnDragHover( true )
	self.Tree.OnNodeSelected = function( Tree, Node ) hook.Call( "ContentSidebarSelection", GM, self:GetParent(), Node ) end
	self.Tree:Dock( FILL )
	self.Tree:SetBackgroundColor( Color( 240, 240, 240, 255 ) )

	self:SetPaintBackground( false )

end

function PANEL:EnableSearch( stype, hookname )
	self.Search = vgui.CreateFromTable( pnlSearch, self )
	self.Search:SetSearchType( stype, hookname or "PopulateContent" )
end

function PANEL:EnableModify()

	self:EnableSearch()
	self:CreateSaveNotification()

	self.Toolbox = vgui.Create( "ContentSidebarToolbox", self )

	hook.Add( "OpenToolbox", "OpenToolbox", function()

		if ( !IsValid( self.Toolbox ) ) then return end

		self.Toolbox:Open()

	end )

end

function PANEL:CreateSaveNotification()

	local SavePanel = vgui.Create( "Panel", self )
	SavePanel:Dock( TOP )
	SavePanel:SetVisible( false )
	SavePanel:DockMargin( 8, 1, 8, 4 )

	local SaveButton = vgui.Create( "DButton", SavePanel )
	SaveButton:Dock( FILL )
	SaveButton:SetIcon( "icon16/disk.png" )
	SaveButton:SetText( "#spawnmenu.savechanges" )
	SaveButton.DoClick = function()

		SavePanel:SlideUp( 0.2 )
		hook.Run( "OnSaveSpawnlist" )

	end

	local RevertButton = vgui.Create( "DButton", SavePanel )
	RevertButton:Dock( RIGHT )
	RevertButton:SetIcon( "icon16/arrow_rotate_clockwise.png" )
	RevertButton:SetText( "" )
	RevertButton:SetTooltip( "#spawnmenu.revert_tooptip" )
	RevertButton:SetWide( 26 )
	RevertButton:DockMargin( 4, 0, 0, 0 )
	RevertButton.DoClick = function()

		SavePanel:SlideUp( 0.2 )
		hook.Run( "OnRevertSpawnlist" )

	end

	hook.Add( "SpawnlistContentChanged", "ShowSaveButton", function()

		if ( SavePanel:IsVisible() ) then return end

		SavePanel:SlideDown( 0.2 )

		GM:AddHint( "EditingSpawnlistsSave", 5 )

	end )

end

vgui.Register( "ContentSidebar", PANEL, "DPanel" )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenttypes/custom.lua:

local AddCustomizableNode = nil

local function SetupCustomNode( node, pnlContent, needsapp )

	node.CustomSpawnlist = !node.AddonSpawnlist -- Used to determine which nodes ContentSidebarToolBox can edit

	-- This spawnlist needs a certain app mounted before it will show up.
	if ( needsapp && needsapp != "" ) then
		node:SetVisible( IsMounted( needsapp ) )
		node.NeedsApp = needsapp

		if ( !IsMounted( needsapp ) ) then
			-- Make it look different
			node:SetAlpha( 200 )

			-- Give a detailed tooltip explaining why it looks different
			local name = language.GetPhrase( "spawnmenu.mountablegame" )
			for id, t in pairs( engine.GetGames() ) do
				if ( needsapp == t.folder ) then name = t.title break end
			end
			node:SetTooltip( string.format( language.GetPhrase( "spawnmenu.spawnlistnocontent" ), name ) )
		end
	end


	node.SetupCopy = function( self, copy )

		SetupCustomNode( copy, pnlContent, needsapp )

		self:DoPopulate()

		copy.PropPanel = self.PropPanel:Copy()

		copy.PropPanel:SetVisible( false )
		copy.PropPanel:SetTriggerSpawnlistChange( true )

		copy.DoPopulate = wlib.func.blank

	end

	if ( !node.AddonSpawnlist ) then
		node.OnModified = function()
			hook.Run( "SpawnlistContentChanged" )
		end

		node.DoRightClick = function( self )

			local menu = DermaMenu()
			menu:AddOption( "#spawnmenu.menu.edit", function() self:InternalDoClick() hook.Run( "OpenToolbox" )  end ):SetIcon( "icon16/folder_edit.png" )
			menu:AddOption( "#spawnmenu.menu.add_subcategory", function() AddCustomizableNode( pnlContent, "New Category", "", self ) self:SetExpanded( true ) hook.Run( "SpawnlistContentChanged" ) end ):SetIcon( "icon16/folder_add.png" )
			menu:AddSpacer()
			menu:AddOption( "#spawnmenu.menu.delete", function() node:Remove() hook.Run( "SpawnlistContentChanged" ) end ):SetIcon( "icon16/folder_delete.png" )

			menu:Open()

		end
	end

	node.DoPopulate = function( self )

		if ( IsValid( self.PropPanel ) ) then return end

		self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
		self.PropPanel:SetVisible( false )
		self.PropPanel:SetTriggerSpawnlistChange( true )

	end

	node.DoClick = function( self )

		self:DoPopulate()
		pnlContent:SwitchPanel( self.PropPanel )

	end

end

AddCustomizableNode = function( pnlContent, name, icon, parent, needsapp )

	local node = parent:AddNode( name, icon )
	node.AddonSpawnlist = parent.AddonSpawnlist

	SetupCustomNode( node, pnlContent, needsapp )

	return node

end

local function ReadSpawnlists( node, parentid )

	local tab = {}
	tab.name		= node:GetText()
	tab.icon		= node:GetIcon()
	tab.parentid	= parentid
	tab.id			= SPAWNLIST_ID
	tab.version		= 3
	tab.needsapp	= node.NeedsApp

	node:DoPopulate()

	if ( IsValid( node.PropPanel ) ) then
		tab.contents = node.PropPanel:ContentsToTable()
	end

	if ( SPAWNLIST_ID > 0 ) then
		SPAWNLISTS[ string.format( "%03d", tab.id ) .. "-" .. tab.name ] = util.TableToKeyValues( tab )
	end

	SPAWNLIST_ID = SPAWNLIST_ID + 1

	if ( node.ChildNodes ) then

		for k, v in pairs( node.ChildNodes:GetChildren() ) do

			ReadSpawnlists( v, tab.id )

		end

	end

end

local function ConstructSpawnlist( node )

	SPAWNLIST_ID = 0
	SPAWNLISTS = {}

	ReadSpawnlists( node, 0 )
	local tab = SPAWNLISTS

	SPAWNLISTS = nil
	SPAWNLIST_ID = nil

	return tab

end

function AddPropsOfParent( pnlContent, node, parentid, customProps )

	local Props = customProps or spawnmenu.GetPropTable()

	for FileName, Info in SortedPairs( Props ) do

		if ( parentid != Info.parentid ) then continue end

		local pnlnode = AddCustomizableNode( pnlContent, Info.name, Info.icon, node, Info.needsapp )
		pnlnode:SetExpanded( true )
		pnlnode.OnRemove = function( self ) if ( IsValid( self.PropPanel ) ) then self.PropPanel:Remove() end end
		pnlnode.DoPopulate = function( self )

			if ( IsValid( self.PropPanel ) ) then return end

			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( true )
			if ( node.AddonSpawnlist ) then self.PropPanel.IconList:SetReadOnly( true ) end

			for i, object in SortedPairs( Info.contents ) do

				local cp = spawnmenu.GetContentType( object.type )
				if ( cp ) then cp( self.PropPanel, object ) end

			end

		end

		AddPropsOfParent( pnlContent, pnlnode, Info.id, customProps )

	end

end

-- This helps avoid empty spawnlist list when you delete some but the hidden ones remain so the default spawnlists never regenerate
-- TODO: Maybe show spawnlists that need games when any spawnlist was changed? Allow to set needed game from in-game?
local function CheckIfAnyVisible( node )
	local pnlContent = node.SMContentPanel

	if ( node:GetChildNodeCount() < 1 ) then
		spawnmenu.PopulateFromEngineTextFiles()
		AddPropsOfParent( pnlContent, node, 0 )
		node:SetExpanded( true )
		return
	end

	local visible = 0
	for id, pnl in pairs( node:GetChildNodes() ) do
		if ( pnl:IsVisible() ) then visible = visible + 1 end
	end

	if ( visible < 1 ) then
		for id, pnl in pairs( node:GetChildNodes() ) do
			pnl:SetVisible( true )
		end
	end
end

hook.Add( "PopulateContent", "AddCustomContent", function( pnlContent, tree, node )

	local node = AddCustomizableNode( pnlContent, "#spawnmenu.category.your_spawnlists", "", tree )
	node:SetDraggableName( "CustomContent" )
	node:SetExpanded( true )
	node.CustomSpawnlist = nil
	node.SMContentPanel = pnlContent

	node.DoRightClick = function( self )

		local menu = DermaMenu()
		menu:AddOption( "New Category", function() AddCustomizableNode( pnlContent, "New Category", "", node ) node:SetExpanded( true ) hook.Run( "SpawnlistContentChanged" ) end ):SetIcon( "icon16/folder_add.png" )
		menu:Open()

	end

	-- Save the spawnlist when children drag and dropped
	node.OnModified = function()
		hook.Run( "SpawnlistContentChanged" )
	end

	AddPropsOfParent( pnlContent, node, 0 )

	CheckIfAnyVisible( node )

	node:MoveToBack()

	g_SpawnMenu.CustomizableSpawnlistNode = node

	-- Select the first visible panel
	for id, pnl in pairs( node:GetChildNodes() ) do
		if ( pnl:IsVisible() ) then
			pnl:InternalDoClick()
			pnl:SetExpanded( true )
			break
		end
	end

	-- Custom stuff from addons
	local CustomProps = spawnmenu.GetCustomPropTable()
	if ( !table.IsEmpty( CustomProps ) ) then
		local node = AddCustomizableNode( pnlContent, "#spawnmenu.category.addon_spawnlists", "", tree )
		node:SetExpanded( true )
		--node:SetDraggableName( "CustomContent" )
		node.DoRightClick = wlib.func.blank
		node.OnModified = wlib.func.blank
		node.AddonSpawnlist = true
		node.CustomSpawnlist = nil

		AddPropsOfParent( pnlContent, node, 0, CustomProps )
	end

end )

hook.Add( "OnSaveSpawnlist", "DoSaveSpawnlist", function()

	local Spawnlist = ConstructSpawnlist( g_SpawnMenu.CustomizableSpawnlistNode )

	spawnmenu.DoSaveToTextFiles( Spawnlist )

	CheckIfAnyVisible( g_SpawnMenu.CustomizableSpawnlistNode )

end )
 
hook.Add( "OnRevertSpawnlist", "DoRevertSpawnlists", function()

	-- First delete all of the existing spawnlists
	g_SpawnMenu.CustomizableSpawnlistNode:Clear()

	-- Next load all the custom spawnlists again
	spawnmenu.PopulateFromEngineTextFiles()
	AddPropsOfParent( g_SpawnMenu.CustomizableSpawnlistNode.SMContentPanel, g_SpawnMenu.CustomizableSpawnlistNode, 0 )

	-- Select the first visible panel. TODO: why this requires a timer?
	timer.Simple( 0, function()
		CheckIfAnyVisible( g_SpawnMenu.CustomizableSpawnlistNode )

		for id, pnl in pairs( g_SpawnMenu.CustomizableSpawnlistNode:GetChildNodes() ) do
			if ( pnl:IsVisible() ) then
				pnl:InternalDoClick()
				pnl:SetExpanded( true )
				break
			end
		end

		g_SpawnMenu.CustomizableSpawnlistNode:SetExpanded( true )
	end )

end )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenttypes/npcs.lua:

hook.Add( "PopulateNPCs", "AddNPCContent", function( pnlContent, tree, node )

	-- Get a list of available NPCs
	local NPCList = list.Get( "NPC" )

	-- Categorize them
	local Categories = {}
	for k, v in pairs( NPCList ) do

		local Category = v.Category or "Other"
		if ( !isstring( Category ) ) then Category = tostring( Category ) end

		local Tab = Categories[ Category ] or {}
		Tab[ k ] = v
		Categories[ Category ] = Tab

	end

	-- Create an icon for each one and put them on the panel
	for CategoryName, v in SortedPairs( Categories ) do

		-- Add a node to the tree
		local node = tree:AddNode( CategoryName, "icon16/monkey.png" )

		-- When we click on the node - populate it using this function
		node.DoPopulate = function( self )

			-- If we've already populated it - forget it.
			if ( self.PropPanel ) then return end

			-- Create the container panel
			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for name, ent in SortedPairsByMemberValue( v, "Name" ) do

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "npc", self.PropPanel, {
					nicename	= ent.Name or name,
					spawnname	= name,
					material	= ent.IconOverride or "entities/" .. name .. ".png",
					weapon		= ent.Weapons,
					admin		= ent.AdminOnly
				} )

			end

		end

		-- If we click on the node populate it and switch to it.
		node.DoClick = function( self )

			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )

		end

	end

	-- Select the first node
	local FirstNode = tree:Root():GetChildNode( 0 )
	if ( IsValid( FirstNode ) ) then
		FirstNode:InternalDoClick()
	end

end )

local PANEL = {}

Derma_Hook( PANEL, "Paint", "Paint", "Tree" )
PANEL.m_bBackground = true -- Hack for above

function PANEL:AddCheckbox( text, cvar )
	local DermaCheckbox = self:Add( "DCheckBoxLabel", self )
	DermaCheckbox:Dock( TOP )
	DermaCheckbox:SetText( text )
	DermaCheckbox:SetDark( true )
	DermaCheckbox:SetConVar( cvar)
	DermaCheckbox:SizeToContents()
	DermaCheckbox:DockMargin( 0, 5, 0, 0 )
end

function PANEL:Init()

	self:SetOpenSize( 150 )
	self:DockPadding( 15, 10, 15, 10 )

	self:AddCheckbox( "#menubar.npcs.disableai", "ai_disabled" )
	self:AddCheckbox( "#menubar.npcs.ignoreplayers", "ai_ignoreplayers" )
	self:AddCheckbox( "#menubar.npcs.keepcorpses", "ai_serverragdolls" )
	self:AddCheckbox( "#menubar.npcs.autoplayersquad", "npc_citizen_auto_player_squad" )

	local label = vgui.Create( "DLabel", self )
	label:Dock( TOP )
	label:DockMargin( 0, 5, 0, 0 )
	label:SetDark( true )
	label:SetText( "#menubar.npcs.weapon" )

	local DComboBox = vgui.Create( "DComboBox", self )
	DComboBox:Dock( TOP )
	DComboBox:DockMargin( 0, 0, 0, 0 )
	DComboBox:SetConVar( "gmod_npcweapon" )
	DComboBox:SetSortItems( false )

	DComboBox:AddChoice( "#menubar.npcs.defaultweapon", "" )
	DComboBox:AddChoice( "#menubar.npcs.noweapon", "none" )
	DComboBox:AddSpacer()

	-- Sort the items by name, also has the benefit of deduplication
	local weaponsForSort = {}
	for _, v in pairs( list.Get( "NPCUsableWeapons" ) ) do
		weaponsForSort[ language.GetPhrase( v.title ) ] = v.class
	end

	for title, class in SortedPairs( weaponsForSort ) do
		DComboBox:AddChoice( title, class )
	end
	
	function DComboBox:OnSelect( index, value )
		self:ConVarChanged( self.Data[ index ] )
	end

	self:Open()

end

function PANEL:PerformLayout()
end

vgui.Register( "SpawnmenuNPCSidebarToolbox", PANEL, "DDrawer" )

spawnmenu.AddCreationTab( "#spawnmenu.category.npcs", function()

	local ctrl = vgui.Create( "SpawnmenuContentPanel" )
	ctrl:EnableSearch( "npcs", "PopulateNPCs" )
	ctrl:CallPopulateHook( "PopulateNPCs" )

	local sidebar = ctrl.ContentNavBar
	sidebar.Options = vgui.Create( "SpawnmenuNPCSidebarToolbox", sidebar )

	return ctrl

end, "icon16/monkey.png", 20 )

--gamemodes/darkrp/gamemode/modules/sandbox/spawnmenu/creationmenu/content/contenttypes/entities.lua:

hook.Add( "PopulateEntities", "AddEntityContent", function( pnlContent, tree, node )

	local Categorised = {}

	-- Add this list into the tormoil
	local SpawnableEntities = list.Get( "SpawnableEntities" )
	if ( SpawnableEntities ) then
		for k, v in pairs( SpawnableEntities ) do

			local Category = v.Category or "Other"
			if ( !isstring( Category ) ) then Category = tostring( Category ) end
			Categorised[ Category ] = Categorised[ Category ] or {}

			v.SpawnName = k
			table.insert( Categorised[ Category ], v )

		end
	end

	--
	-- Add a tree node for each category
	--
	for CategoryName, v in SortedPairs( Categorised ) do

		-- Add a node to the tree
		local node = tree:AddNode( CategoryName, "icon16/bricks.png" )

			-- When we click on the node - populate it using this function
		node.DoPopulate = function( self )

			-- If we've already populated it - forget it.
			if ( self.PropPanel ) then return end

			-- Create the container panel
			self.PropPanel = vgui.Create( "ContentContainer", pnlContent )
			self.PropPanel:SetVisible( false )
			self.PropPanel:SetTriggerSpawnlistChange( false )

			for k, ent in SortedPairsByMemberValue( v, "PrintName" ) do

				spawnmenu.CreateContentIcon( ent.ScriptedEntityType or "entity", self.PropPanel, {
					nicename	= ent.PrintName or ent.ClassName,
					spawnname	= ent.SpawnName,
					material	= ent.IconOverride or "entities/" .. ent.SpawnName .. ".png",
					admin		= ent.AdminOnly
				} )

			end

		end

		-- If we click on the node populate it and switch to it.
		node.DoClick = function( self )

			self:DoPopulate()
			pnlContent:SwitchPanel( self.PropPanel )

		end

	end

	-- Select the first node
	local FirstNode = tree:Root():GetChildNode( 0 )
	if ( IsValid( FirstNode ) ) then
		FirstNode:InternalDoClick()
	end

end )

spawnmenu.AddCreationTab( "#spawnmenu.category.entities", function()

	local ctrl = vgui.Create( "SpawnmenuContentPanel" )
	ctrl:EnableSearch( "entities", "PopulateEntities" )
	ctrl:CallPopulateHook( "PopulateEntities" )

	return ctrl

end, "icon16/bricks.png", 20 )

--gamemodes/darkrp/gamemode/modules/sandbox/cl_search.lua:
local function GetAllFiles(tab, folder, extension, path)
	local files, folders = file.Find(folder .. "/*", path)

	for k, v in ipairs(files) do
		if (v:EndsWith(extension)) then
			tab[#tab+1] = (folder .. v):lower()
		end
	end

	local i = 1
	local function doRecurse()
		GetAllFiles(tab, folder .. folders[i] .. "/", extension, path)
		i = i + 1

		if (folders[i]) then
			timer.Simple(0.1, doRecurse)
		else
			hook.Run("SearchUpdate")
		end
	end

	if (folders[1]) then
		doRecurse()
	else
		hook.Run("SearchUpdate")
	end
end


local model_list = nil
search.AddProvider(function(str)
	str = str:PatternSafe()

	if (model_list == nil) then
		model_list = {}
		GetAllFiles(model_list, "models/", ".mdl", "GAME")
	end

	local list = {}
	for k, v in ipairs(model_list) do
		if (v:find(str)) then
			if (UTIL_IsUselessModel(v)) then continue end

			local entry = {
				text = v:GetFileFromFilename(),
				func = function() RunConsoleCommand("gm_spawn", v) end,
				icon = spawnmenu.CreateContentIcon("model", g_SpawnMenu.SearchPropPanel, {model = v}),
				words = {v}
			}

			list[#list+1] = entry
			if (#list >= 128) then break end
		end
	end

	return list
end);
--gamemodes/darkrp/gamemode/modules/money/sh_money.lua:
local pMeta = FindMetaTable("Player")
local entMeta = FindMetaTable("Entity")

function pMeta:canAfford(amount)
    if not amount or self.DarkRPUnInitialized then return false end
    return math.floor(amount) >= 0 and (self:GetNetVar("money") or 0) - math.floor(amount) >= 0
end

function entMeta:isMoneyBag()
    return self.IsSpawnedMoney or self:GetClass() == GAMEMODE.Config.MoneyClass
end

--gamemodes/darkrp/gamemode/modules/fpp/pp/sh_settings.lua:
-- These are the default settings. Don't mind changing these.
FPP = FPP or {}

-- Don't reset the settings when they're already there
if FPP.Settings then
	return
end

FPP.Settings = {}
FPP.Settings.FPP_PHYSGUN1 = {
	toggle = 1,
	adminall = 1,
	worldprops = 0,
	adminworldprops = 1,
	canblocked = 0,
	admincanblocked = 0,
	shownocross = 1,
	checkconstrained = 1,
	reloadprotection = 1,
	iswhitelist = 0}
FPP.Settings.FPP_GRAVGUN1 = {
	toggle = 1,
	adminall = 1,
	worldprops = 1,
	adminworldprops = 1,
	canblocked = 0,
	admincanblocked = 0,
	shownocross = 1,
	checkconstrained = 1,
	noshooting = 1,
	iswhitelist = 0}
FPP.Settings.FPP_TOOLGUN1 = {
	toggle = 1,
	adminall = 1,
	worldprops = 1,
	adminworldprops = 1,
	canblocked = 0,
	admincanblocked = 0,
	shownocross = 1,
	checkconstrained = 1,
	iswhitelist = 0,

	duplicatorprotect = 1,
	duplicatenoweapons = 1,
	spawniswhitelist = 0,
	spawnadmincanweapon = 0,
	spawnadmincanblocked = 0}
FPP.Settings.FPP_PLAYERUSE1 = {
	toggle = 0,
	adminall = 1,
	worldprops = 1,
	adminworldprops = 1,
	canblocked = 0,
	admincanblocked = 1,
	shownocross = 1,
	checkconstrained = 0,
	iswhitelist = 0}
FPP.Settings.FPP_ENTITYDAMAGE1 = {
	toggle = 1,
	protectpropdamage = 1,
	adminall = 1,
	worldprops = 1,
	adminworldprops = 1,
	canblocked = 0,
	admincanblocked = 0,
	shownocross = 1,
	checkconstrained = 0,
	iswhitelist = 0}
FPP.Settings.FPP_GLOBALSETTINGS1 = {
	freezedisconnected = 0,
	cleanupdisconnected = 1,
	cleanupdisconnectedtime = 120,
	cleanupadmin = 1,
	antie2minge = 1}
FPP.Settings.FPP_ANTISPAM1 = {
	toggle = 1,
	antispawninprop = 0,
	bigpropantispam = 1,
	bigpropsize = 5.85,
	bigpropwait = 1.5,
	smallpropdowngradecount = 3,
	smallpropghostlimit = 2,
	smallpropdenylimit = 6,
	duplicatorlimit = 3
}
FPP.Settings.FPP_BLOCKMODELSETTINGS1 = {
	toggle = 1,
	propsonly = 0,
	iswhitelist = 0
}

function FPP.ForAllSettings(fn)
	-- Loop in sorted pairs for deterministic order
	for kind, sets in SortedPairs(FPP.Settings) do
		for setting, val in SortedPairs(sets) do
			if fn(kind, setting, val) then break end
		end
	end
end

/*---------------------------------------------------------------------------
CAMI
Register the CAMI privilege
---------------------------------------------------------------------------*/
CAMI.RegisterPrivilege{
	Name = "FPP_Settings",
	MinAccess = "superadmin" -- By default only superadmins can change settings
}

CAMI.RegisterPrivilege{
	Name = "FPP_Cleanup",
	MinAccess = "admin"
}


CAMI.RegisterPrivilege{
	Name = "FPP_TouchOtherPlayersProps",
	MinAccess = "admin"
}

function FPP.calculatePlayerPrivilege(priv, callback)
	local count = player.GetCount()

	for _, ply in player.Iterator() do
		local function onRes(b)
			count = count - 1
			ply.FPP_Privileges = ply.FPPPrivileges or {}
			ply.FPP_Privileges[priv] = b

			if count == 0 then callback() end
		end
		CAMI.PlayerHasAccess(ply, priv, onRes)
	end
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/messaging/cl_init.lua:
local showChat = CreateClientConVar("FAdmin_ShowChatNotifications", 1, true, false)

local function ConsoleMessage()
    MsgC(Color(255,0,0,255), "(FAdmin) ", Color(200,0,200,255), net.ReadString() .. "\n")
end
net.Receive("FAdmin_ConsoleMessage", ConsoleMessage)


local red = Color(106, 113, 125)
local white = Color(106, 113, 125)
local brown = Color(160, 171, 189)
local blue = Color(160, 171, 189)

-- Inserts the instigator into a notification message
local function insertInstigator(res, instigator, _)
    table.insert(res, brown)
    table.insert(res, FAdmin.PlayerName(instigator))
end

-- Inserts the targets into the notification message
local function insertTargets(res, _, targets)
    table.insert(res, blue)
    table.insert(res, FAdmin.TargetsToString(targets))
end

local modMessage = {
    instigator = insertInstigator,
    you = function(res) table.insert(res, brown) table.insert(res, "Ты") end,
    targets = insertTargets,
}
local function showNotification(notification, instigator, targets, extraInfo)
    local res = {red, "[", white, "FAdmin", red, "] "}

    for _, text in pairs(notification.message) do
        if modMessage[text] then modMessage[text](res, instigator, targets) continue end

        if string.sub(text, 1, 10) == "extraInfo." then
            local id = tonumber(string.sub(text, 11))

            table.insert(res, notification.extraInfoColors and notification.extraInfoColors[id] or white)
            table.insert(res, extraInfo[id])
            continue
        end

        table.insert(res, white)
        table.insert(res, text)
    end

    if showChat:GetBool() then
        chat.AddText(unpack(res))
    else
        local msgTbl = {}
        for i = 8, #res, 2 do table.insert(msgTbl, res[i]) end

        notification.AddLegacy(table.concat(msgTbl, ""), NOTIFY_ERROR, 6)

        MsgC(unpack(res))
        Msg("\n")
    end
end

local function receiveNotification()
    local id = net.ReadUInt(16)
    local notification = FAdmin.Notifications[id]
    local instigator = net.ReadBool() and net.ReadEntity() or net.ReadString()

    local targets = {}
    if notification.hasTarget then
        local targetCount = net.ReadUInt(8)
        for i = 1, targetCount do
            table.insert(targets, net.ReadEntity())
        end
    end

    local extraInfo = notification.readExtraInfo and notification.readExtraInfo()

    showNotification(notification, instigator, targets, extraInfo)
end
net.Receive("FAdmin_Notification", receiveNotification)

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/commands/cl_chatcommands.lua:
local Options = {}
local targets
hook.Add("ChatTextChanged", "FAdmin_Chat_autocomplete", function(text)
    if not FAdmin.GlobalSetting.FAdmin then return end
    Options = {}
    local prefix = nw.GetGlobal("FAdmin_commandprefix")
    prefix = prefix ~= '' and prefix or '/'

    if string.sub(text, 1, 1) ~= prefix then targets = nil return end

    local TExplode = string.Explode(" ", string.sub(text, 2))
    if not TExplode[1] then return end
    local Command = string.lower(TExplode[1])
    local Args = table.Copy(TExplode)
    Args[1] = nil
    Args = table.ClearKeys(Args)


    local optionsCount = 0
    for k,v in pairs(FAdmin.Commands.List) do
        if string.find(string.lower(k), Command, 1, true) ~= 1 then continue end

        Options[prefix .. k] = table.Copy(v.ExtraArgs)

        optionsCount = optionsCount + 1
    end

    local ChatBoxPosX, ChatBoxPosY = chat.GetChatBoxPos()
    local ChatBoxWidth = chat.GetChatBoxSize() -- Don't need height
    local DidMakeShorter = false
    table.sort(Options)
    local i = 1
    for k,v in pairs(Options) do
        local Pos = ChatBoxPosY + i * 24
        if Pos + 24 > ScrH() then
            Options[k] = nil
            DidMakeShorter = true
            optionsCount = optionsCount - 1
        end
        i = i + 1
    end

    -- Player arguments
    local firstVal = table.GetFirstValue(Options)
    if optionsCount == 1 and firstVal[#Args] and string.match(firstVal[#Args], ".Player.") then
        local players = {}

        for k,v in pairs(FAdmin.FindPlayer(Args[#Args]) or {}) do
            if not IsValid(v) then continue end
            table.insert(players, v:Nick())
        end

        targets = table.concat(players, ", ")
    end

    local xPos = ChatBoxPosX + ChatBoxWidth + 2
    hook.Add("HUDPaint", "FAdmin_Chat_autocomplete", function()
        local j = 0
        for option, args in pairs(Options) do
            draw.WordBox(4, xPos, ChatBoxPosY + j * 24, option, "UiBold", Color(0, 0, 0, 200), Color(255, 255, 255, 255))

            for k, arg in pairs(args) do
                draw.WordBox(4, xPos + k * 130, ChatBoxPosY + j * 24, arg, "UiBold", Color(0, 0, 0, 200), Color(255, 255, 255, 255))
            end

            j = j + 1
        end

        if targets then
            draw.WordBox(4, xPos, ChatBoxPosY + j * 24, "Targets: " .. targets, "UiBold", Color(255, 125, 0, 200), Color(255, 255, 255, 255))
        end

        if DidMakeShorter then
            draw.WordBox(4, xPos, ChatBoxPosY + j * 24, "...", "UiBold", Color(0, 0, 0, 200), Color(255, 255, 255, 255))
        end
    end)
end)

hook.Add("FinishChat", "FAdmin_Chat_autocomplete", function() hook.Remove("HUDPaint", "FAdmin_Chat_autocomplete") end)

local plyIndex = 1

hook.Add("OnChatTab", "FAdmin_Chat_autocomplete", function(text)
    if not FAdmin.GlobalSetting.FAdmin then return end

    for command, _ in pairs(Options) do
        if string.find(text, " ") == nil then
            return string.sub(command, 1, string.find(command, " "))
        elseif string.find(text, " ") then
            plyIndex = plyIndex + 1

            if plyIndex > player.GetCount() then
                plyIndex = 1
            end

            return string.sub(command, 1, string.find(command, " ")) .. " " .. string.sub(player.GetAll()[plyIndex]:Nick(), 1, string.find(player.GetAll()[plyIndex]:Nick(), " "))
        end
    end
end)

FAdmin.StartHooks["Chatcommands"] = function()
    FAdmin.ScoreBoard.Server:AddServerSetting("Set FAdmin's chat command prefix", "fadmin/icons/message", Color(0, 0, 155, 255), function(ply) return FAdmin.Access.PlayerHasPrivilege(ply, "ServerSetting") end, function()
        local prefix = nw.GetGlobal("FAdmin_commandprefix")
        prefix = prefix ~= '' and prefix or '/'
        Derma_StringRequest("Set chat command prefix", "Make sure it's only one character!", prefix, fp{RunConsoleCommand, "_Fadmin", "CommandPrefix"})
    end)
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/access/sh_shared.lua:
CreateConVar("_FAdmin_immunity", 1, {FCVAR_GAMEDLL, FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_SERVER_CAN_EXECUTE})

FAdmin.Access = FAdmin.Access or {}
FAdmin.Access.ADMIN = {"user", "admin", "superadmin"}
FAdmin.Access.ADMIN[0] = "user"

FAdmin.Access.Groups = FAdmin.Access.Groups or {}
FAdmin.Access.Privileges = FAdmin.Access.Privileges or {}

function FAdmin.Access.AddGroup(name, admin_access --[[0 = not admin, 1 = admin, 2 = superadmin]], privs, immunity, fromCAMI)
    FAdmin.Access.Groups[name] = FAdmin.Access.Groups[name] or {ADMIN = admin_access, PRIVS = privs or {}, immunity = immunity}

    -- Register custom usergroups with CAMI
    if name ~= "user" and name ~= "admin" and name ~= "superadmin" and not fromCAMI then
        CAMI.RegisterUsergroup({
            Name = name,
            Inherits = FAdmin.Access.ADMIN[admin_access]
        }, "FAdmin")
    end

    -- Add newly created privileges on server reload
    for p, _ in pairs(privs or {}) do
        FAdmin.Access.Groups[name].PRIVS[p] = true
    end

    if not SERVER then return end

    MySQLite.queryValue("SELECT COUNT(*) FROM FADMIN_GROUPS WHERE NAME = " .. MySQLite.SQLStr(name) .. ";", function(val)
        if tonumber(val or 0) > 0 then return end

        MySQLite.query("REPLACE INTO FADMIN_GROUPS VALUES(" .. MySQLite.SQLStr(name) .. ", " .. tonumber(admin_access) .. ");", function()
            for priv, _ in pairs(privs or {}) do
                MySQLite.query("REPLACE INTO FADMIN_PRIVILEGES VALUES(" .. MySQLite.SQLStr(name) .. ", " .. MySQLite.SQLStr(priv) .. ");")
            end
        end)
    end)

    if immunity then
        MySQLite.query("REPLACE INTO FAdmin_Immunity VALUES(" .. MySQLite.SQLStr(name) .. ", " .. tonumber(immunity) .. ");")
    end

    if FAdmin.Access.SendGroups and privs then
        for _, v in player.Iterator() do
            FAdmin.Access.SendGroups(v)
        end
    end
end

function FAdmin.Access.OnUsergroupRegistered(usergroup, source)
    -- Don't re-add usergroups coming from FAdmin itself
    if source == "FAdmin" then return end

    local inheritRoot = CAMI.InheritanceRoot(usergroup.Inherits)
    local admin_access = table.KeyFromValue(FAdmin.Access.ADMIN, inheritRoot) or 1

    -- Add groups registered to CAMI to FAdmin. Assume privileges from either the usergroup it inherits or its inheritance root.
    -- Immunity is unknown and can be set by the user later. FAdmin immunity only applies to FAdmin anyway.
    local parent = FAdmin.Access.Groups[usergroup.Inherits] or FAdmin.Access.Groups[inheritRoot] or {}
    FAdmin.Access.AddGroup(usergroup.Name, admin_access - 1, table.Copy(parent.PRIVS) or {}, parent.immunity or 10, true)
end


function FAdmin.Access.OnUsergroupUnregistered(usergroup, source)
    if table.HasValue({"superadmin", "admin", "user", "noaccess"}, usergroup.Name) then return end

    FAdmin.Access.Groups[usergroup.Name] = nil

    if not SERVER then return end

    MySQLite.query("DELETE FROM FADMIN_GROUPS WHERE NAME = " .. MySQLite.SQLStr(usergroup.Name) .. ";")

    for _, v in player.Iterator() do
        FAdmin.Access.SendGroups(v)
    end
end

function FAdmin.Access.RemoveGroup(ply, cmd, args)
    if not FAdmin.Access.PlayerHasPrivilege(ply, "ManageGroups") then FAdmin.Messages.SendMessage(ply, 5, "No access!") return false end
    if not args[1] then return false end

    local plyGroup = FAdmin.Access.Groups[ply:EntIndex() == 0 and "superadmin" or ply:GetUserGroup()]

    if not FAdmin.Access.Groups[args[1]] or table.HasValue({"superadmin", "admin", "user"}, string.lower(args[1])) then return true, args[1] end

    -- Setting a group with a higher rank than one's own
    if (not plyGroup or FAdmin.Access.Groups[args[1]].immunity > plyGroup.immunity) and not FAdmin.Access.PlayerIsHost(ply) then
        FAdmin.Messages.SendMessage(ply, 5, "You're not allowed to remove usergroups with a higher rank than your own")
        return false
    end

    CAMI.UnregisterUsergroup(args[1], "FAdmin")

    FAdmin.Messages.SendMessage(ply, 4, "Group succesfully removed")
end

local PLAYER = FindMetaTable("Player")

local oldplyIsAdmin = PLAYER.IsAdmin
function PLAYER:IsAdmin(...)
    local usergroup = self:GetUserGroup()

    if not FAdmin or not FAdmin.Access or not FAdmin.Access.Groups or not FAdmin.Access.Groups[usergroup] then return oldplyIsAdmin(self, ...) or game.SinglePlayer() end

    if (FAdmin.Access.Groups[usergroup] and FAdmin.Access.Groups[usergroup].ADMIN >= 1 --[[1 = admin]]) or (self.IsListenServerHost and self:IsListenServerHost()) then
        return true
    end

    if CLIENT and tonumber(self:FAdmin_GetGlobal("FAdmin_admin")) and self:FAdmin_GetGlobal("FAdmin_admin") >= 1 then return true end

    return oldplyIsAdmin(self, ...) or game.SinglePlayer()
end

local oldplyIsSuperAdmin = PLAYER.IsSuperAdmin
function PLAYER:IsSuperAdmin(...)
    local usergroup = self:GetUserGroup()
    if not FAdmin or not FAdmin.Access or not FAdmin.Access.Groups or not FAdmin.Access.Groups[usergroup] then return oldplyIsSuperAdmin(self, ...) or game.SinglePlayer() end
    if (FAdmin.Access.Groups[usergroup] and FAdmin.Access.Groups[usergroup].ADMIN >= 2 --[[2 = superadmin]]) or (self.IsListenServerHost and self:IsListenServerHost()) then
        return true
    end
    if CLIENT and tonumber(self:FAdmin_GetGlobal("FAdmin_admin")) and self:FAdmin_GetGlobal("FAdmin_admin") >= 2 then return true end
    return oldplyIsSuperAdmin(self, ...) or game.SinglePlayer()
end

--Privileges
function FAdmin.Access.AddPrivilege(Name, admin_access)
    FAdmin.Access.Privileges[Name] = admin_access
end

hook.Add("CAMI.OnPrivilegeRegistered", "FAdmin", function(privilege)
    FAdmin.Access.AddPrivilege(privilege.Name, table.KeyFromValue(FAdmin.Access.ADMIN, CAMI.InheritanceRoot(privilege.MinAccess)) or 3)

    -- Register privilege and add to respective usergroups
    if SERVER then FAdmin.Access.RegisterCAMIPrivilege(privilege) end
end)

for _, camipriv in pairs(CAMI.GetPrivileges()) do
    FAdmin.Access.AddPrivilege(camipriv.Name, table.KeyFromValue(FAdmin.Access.ADMIN, CAMI.InheritanceRoot(camipriv.MinAccess)) or 3)
    -- Register if the database has already loaded
    if SERVER and FAdmin.Access.RegisterCAMIPrivilege then FAdmin.Access.RegisterCAMIPrivilege(camipriv) end
end

hook.Add("CAMI.OnPrivilegeUnregistered", "FAdmin", function(privilege)
    FAdmin.Access.Privileges[privilege.Name] = nil
end)

function FAdmin.Access.PlayerIsHost(ply)
    return ply:EntIndex() == 0 or game.SinglePlayer() or (ply.IsListenServerHost and ply:IsListenServerHost())
end

function FAdmin.Access.PlayerHasPrivilege(ply, priv, target, ignoreImmunity)
    -- This is the server console
    if FAdmin.Access.PlayerIsHost(ply) then return true end
    -- Privilege does not exist
    if not FAdmin.Access.Privileges[priv] then return ply:IsAdmin() end

    local Usergroup = ply.GetRealUserGroup and ply:GetRealUserGroup() or ply:GetUserGroup()

    local canTarget = hook.Call("FAdmin_CanTarget", nil, ply, priv, target)
    if canTarget ~= nil then
        return canTarget
    end

    if FAdmin.GlobalSetting.Immunity and
        not ignoreImmunity and
        not isstring(target) and IsValid(target) and target ~= ply and
        FAdmin.Access.Groups[Usergroup] and FAdmin.Access.Groups[target:GetUserGroup()] and
        FAdmin.Access.Groups[Usergroup].immunity and FAdmin.Access.Groups[target:GetUserGroup()].immunity and
        FAdmin.Access.Groups[target:GetUserGroup()].immunity >= FAdmin.Access.Groups[Usergroup].immunity then
        return false
    end

    -- Defer answer when usergroup is unknown
    if not FAdmin.Access.Groups[Usergroup] then return end

    if FAdmin.Access.Groups[Usergroup].PRIVS[priv] then
        return true
    end

    if CLIENT and ply.FADMIN_PRIVS and ply.FADMIN_PRIVS[priv] then return true end

    return false
end

hook.Add("CAMI.PlayerHasAccess", "FAdmin", function(actor, privilegeName, callback, target, extraInfo)
    -- FAdmin doesn't know. Defer answer.
    if not FAdmin.Access.Privileges[privilegeName] then return end

    local res = FAdmin.Access.PlayerHasPrivilege(actor, privilegeName, target, extraInfo and extraInfo.IgnoreImmunity)

    -- Defer again
    if res == nil then return end

    -- Publish the answer
    callback(res, "FAdmin")

    -- FAdmin knows the answer. Prevent other hooks from running.
    return true
end)

hook.Add("CAMI.SteamIDHasAccess", "FAdmin", function(actorSteam, privilegeName, callback, targetSteam, extraInfo)
    -- The client just doesn't know
    if CLIENT then return end

    if not targetSteam or extraInfo and extraInfo.IgnoreImmunity then
        MySQLite.query(string.format(
            [[SELECT COUNT(*) AS c
            FROM FAdmin_PlayerGroup l
            JOIN FADMIN_PRIVILEGES r ON l.groupname = r.NAME
            WHERE l.steamid = %s AND r.PRIVILEGE = %s]],
            MySQLite.SQLStr(actorSteam),
            MySQLite.SQLStr(privilegeName)
        ), function(res) callback(tonumber(res[1].c) > 0) end)

        return true
    end

    MySQLite.query(string.format(
        [[SELECT ll.i AND rr.c AS res
        FROM (SELECT li.immunity >= ri.immunity AS i
              FROM FAdmin_PlayerGroup lg
              JOIN FAdmin_Immunity li ON lg.groupname = li.groupname
              JOIN FAdmin_PlayerGroup rg
              JOIN FAdmin_Immunity ri ON rg.groupname = ri.groupname
              WHERE lg.steamid = %s AND rg.steamid = %s) AS ll
        JOIN (SELECT COUNT(*) AS c
            FROM FAdmin_PlayerGroup l
            JOIN FADMIN_PRIVILEGES r ON l.groupname = r.NAME
            WHERE l.steamid = %s AND r.PRIVILEGE = %s) AS rr]],
        MySQLite.SQLStr(actorSteam),
        MySQLite.SQLStr(targetSteam),
        MySQLite.SQLStr(actorSteam),
        MySQLite.SQLStr(privilegeName)
    ), function(res) callback(res and res[1] and tobool(res[1].res) or false) end)

    return true
end)

FAdmin.StartHooks["AccessFunctions"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "setaccess",
        hasTarget = true,
        message = {"instigator", " выдал ", "targets", " ранг ", "extraInfo.1"},
        receivers = "everyone",
        writeExtraInfo = function(i) net.WriteString(i[1]) end,
        readExtraInfo = function() return {net.ReadString()} end,
        extraInfoColors = {Color(160, 171, 189)}
    }

    FAdmin.Access.AddPrivilege("SetAccess", 3) -- AddPrivilege is shared, run on both client and server
    FAdmin.Access.AddPrivilege("ManagePrivileges", 3)
    FAdmin.Access.AddPrivilege("ManageGroups", 3)
    FAdmin.Access.AddPrivilege("SeeAdmins", 1)
    FAdmin.Commands.AddCommand("RemoveGroup", FAdmin.Access.RemoveGroup)

    FAdmin.Commands.AddCommand("Admins", function(ply)
        if not FAdmin.Access.PlayerHasPrivilege(ply, "SeeAdmins") then return false end
        for _, v in player.Iterator() do
            ply:PrintMessage(HUD_PRINTCONSOLE, v:Nick() .. "\t|\t" .. v:GetUserGroup())
        end
        return true
    end
    )
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/access/cl_init.lua:
local ContinueNewGroup
local EditGroups

local function RetrievePRIVS(len)
    FAdmin.Access.Groups = net.ReadTable()

    for k, v in pairs(FAdmin.Access.Groups) do
        if CAMI.GetUsergroup(k) then continue end

        CAMI.RegisterUsergroup({
            Name = k,
            Inherits = FAdmin.Access.ADMIN[v.ADMIN]
        }, "FAdmin")
    end

    -- Remove any groups that are removed from FAdmin from CAMI.
    for k in pairs(CAMI.GetUsergroups()) do
        if FAdmin.Access.Groups[k] then continue end

        CAMI.UnregisterUsergroup(k, "FAdmin")
    end
end
net.Receive("FADMIN_SendGroups", RetrievePRIVS)

local function addPriv(um)
    local group = net.ReadString()
    FAdmin.Access.Groups[group] = FAdmin.Access.Groups[group] or {}
    FAdmin.Access.Groups[group].PRIVS[net.ReadString()] = true
end
net.Receive("FAdmin_AddPriv", addPriv)

local function removePriv(um)
    FAdmin.Access.Groups[net.ReadString()].PRIVS[net.ReadString()] = nil
end
net.Receive("FAdmin_RemovePriv", removePriv)

local function addGroupUI(ply, func)
    Derma_StringRequest("Set name",
    "What will be the name of the new group?",
    "",
    function(text)
        if text == "" then return end
        Derma_Query("On what access will this team be based? (the new group will inherit all the privileges from the group)", "Admin access",
            "user", function() ContinueNewGroup(ply, text, 0, func) end,
            "admin", function() ContinueNewGroup(ply, text, 1, func) end,
            "superadmin", function() ContinueNewGroup(ply, text, 2, func) end)
    end)
end

FAdmin.StartHooks["1SetAccess"] = function() -- 1 in hook name so it will be executed first.
    FAdmin.Commands.AddCommand("setaccess", nil, "<Player>", "<Group name>", "[new group based on (number)]", "[new group privileges]")

    wayscore.AddActionButton('setaccess', {
        name = 'Выдать привилегию',
        icon = 'fadmin/icons/access',
        color = Color(155,0,0),
        category = 'Управление игроками',
        order = 1000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'SetAccess') end,
        callback = function(ply)
            local menu = DermaMenu()
    
            local Padding = vgui.Create("DPanel")
            Padding:SetPaintBackgroundEnabled(false)
            Padding:SetSize(1,5)
            menu:AddPanel(Padding)
    
            local Title = vgui.Create("DLabel")
            Title:SetText("  Привилегии:\n")
            Title:SetFont("UiBold")
            Title:SizeToContents()
            Title:SetTextColor(color_black)
    
            menu:AddPanel(Title)
    
            for k in SortedPairsByMemberValue(FAdmin.Access.Groups, "ADMIN", true) do
                menu:AddOption(k, function()
                    if not IsValid(ply) then return end
                    RunConsoleCommand("_FAdmin", "setaccess", ply:UserID(), k)
                end)
            end
    
            menu:AddOption("Новая...", function() addGroupUI(ply) end)
            menu:Open()
        end,
    })

    wayscore.AddActionButton('editgroups', {
        name = 'Редактировать привилегии',
        icon = 'fadmin/icons/access',
        color = Color(0,155,0),
        category = 'Управление игроками',
        order = 2000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'ManageGroups') or FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'ManagePrivileges') end,
        callback = EditGroups,
    })
end

ContinueNewGroup = function(ply, name, admin_access, func)
    if IsValid(ply) then
        RunConsoleCommand("_FAdmin", "setaccess", ply:UserID(), name, admin_access)
    else
        RunConsoleCommand("_FAdmin", "AddGroup", name, admin_access)
    end

    if func then
        func(name, admin_access)
    end
end

EditGroups = function()
    local frame, SelectedGroup, AddGroup, RemGroup, Privileges, SelectedPrivs, AddPriv, RemPriv, lblImmunity, nmbrImmunity

    frame = vgui.Create("DFrame")
    frame:SetTitle("Create, edit and remove groups")
    frame:MakePopup()
    frame:SetVisible(true)
    frame:SetSize(640, 480)
    frame:Center()

    SelectedGroup = vgui.Create("DComboBox", frame)
    SelectedGroup:SetPos(5, 30)
    SelectedGroup:SetWidth(145)

    for _, v in pairs(FAdmin.Access.Groups) do
        v.immunity = v.immunity or 0
    end
    for k in SortedPairsByMemberValue(FAdmin.Access.Groups, "immunity", true) do
        SelectedGroup:AddChoice(k)
    end

    AddGroup = vgui.Create("DButton", frame)
    AddGroup:SetPos(155, 30)
    AddGroup:SetSize(60, 22)
    AddGroup:SetText("Add Group")
    AddGroup.DoClick = function()
        addGroupUI(nil, function(name, admin, privs)
            SelectedGroup:AddChoice(name)
            SelectedGroup:SetValue(name)
            RemGroup:SetDisabled(false)

            Privileges:Clear()
            SelectedPrivs:Clear()
            nmbrImmunity:SetText(FAdmin.Access.Groups[FAdmin.Access.ADMIN[admin + 1]].immunity)
            nmbrImmunity:SetDisabled(false)
            nmbrImmunity:SetEditable(true)

            for priv, am in SortedPairs(FAdmin.Access.Privileges) do
                if am <= admin + 1 then
                    SelectedPrivs:AddLine(priv)
                else
                    Privileges:AddLine(priv)
                end
            end
        end)
    end

    RemGroup = vgui.Create("DButton", frame)
    RemGroup:SetPos(220, 30)
    RemGroup:SetSize(85, 22)
    RemGroup:SetText("Remove Group")
    RemGroup.DoClick = function()
        RunConsoleCommand("_FAdmin", "RemoveGroup", SelectedGroup:GetValue())

        for k, v in pairs(SelectedGroup.Choices) do
            if v ~= SelectedGroup:GetValue() then continue end

            SelectedGroup.Choices[k] = nil
            break
        end
        table.ClearKeys(SelectedGroup.Choices)

        SelectedGroup:SetValue("user")
        SelectedGroup:OnSelect(1, "user")
    end

    Privileges = vgui.Create("DListView", frame)
    Privileges:SetPos(5, 55)
    Privileges:SetSize(300, 420)
    Privileges:AddColumn("Available privileges")

    SelectedPrivs = vgui.Create("DListView", frame)
    SelectedPrivs:SetPos(340, 55)
    SelectedPrivs:SetSize(295, 420)
    SelectedPrivs:AddColumn("Selected Privileges")

    function SelectedGroup:OnSelect(index, value, data)
        if not FAdmin.Access.Groups[value] then return end

        RemGroup:SetDisabled(false)
        if table.HasValue(FAdmin.Access.ADMIN, value) then
            RemGroup:SetDisabled(true)
        end

        Privileges:Clear()
        SelectedPrivs:Clear()

        for priv, _ in SortedPairs(FAdmin.Access.Privileges) do
            if FAdmin.Access.Groups[value].PRIVS[priv] then
                SelectedPrivs:AddLine(priv)
            else
                Privileges:AddLine(priv)
            end
        end

        if nmbrImmunity then
            nmbrImmunity:SetText(FAdmin.Access.Groups[value].immunity or "")
            if table.HasValue({"superadmin", "admin", "user", "noaccess"}, string.lower(value)) then
                nmbrImmunity:SetDisabled(true)
                nmbrImmunity:SetEditable(false)
            else
                nmbrImmunity:SetDisabled(false)
                nmbrImmunity:SetEditable(true)
            end
        end
    end
    SelectedGroup:SetValue("user")
    SelectedGroup:OnSelect(1, "user")

    AddPriv = vgui.Create("DButton", frame)
    AddPriv:SetPos(310, 55)
    AddPriv:SetSize(25, 25)
    AddPriv:SetText(">")
    AddPriv.DoClick = function()
        for _, v in pairs(Privileges:GetSelected()) do
            local priv = v.Columns[1]:GetValue()
            RunConsoleCommand("FAdmin", "AddPrivilege", SelectedGroup:GetValue(), priv)
            SelectedPrivs:AddLine(priv)
            Privileges:RemoveLine(v.m_iID)
        end
    end

    RemPriv = vgui.Create("DButton", frame)
    RemPriv:SetPos(310, 85)
    RemPriv:SetSize(25, 25)
    RemPriv:SetText("<")
    RemPriv.DoClick = function()
        for _, v in pairs(SelectedPrivs:GetSelected()) do
            local priv = v.Columns[1]:GetValue()
            if SelectedGroup:GetValue() == LocalPlayer():GetUserGroup() and priv == "ManagePrivileges" then
                return Derma_Message("You shouldn't be removing ManagePrivileges. It will make you unable to edit the groups. This is preventing you from locking yourself out of the system.", "Clever move.")
            end
            RunConsoleCommand("FAdmin", "RemovePrivilege", SelectedGroup:GetValue(), priv)
            Privileges:AddLine(priv)
            SelectedPrivs:RemoveLine(v.m_iID)
        end
    end

    lblImmunity = vgui.Create("DLabel", frame)
    lblImmunity:SetPos(340, 30)
    lblImmunity:SetText("Immunity number (higher is more immune)")
    lblImmunity:SizeToContents()

    nmbrImmunity = vgui.Create("DTextEntry", frame)
    nmbrImmunity:SetPos(545, 28)
    nmbrImmunity:SetWide(90)
    nmbrImmunity:SetNumeric(true)
    nmbrImmunity:SetText(FAdmin.Access.Groups.user.immunity)
    nmbrImmunity:SetDisabled(true)
    nmbrImmunity:SetEditable(false)
    nmbrImmunity.OnEnter = function(self) RunConsoleCommand("FAdmin", "SetImmunity", SelectedGroup:GetValue(), self:GetValue()) end
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/strip_weapons/cl_init.lua:
FAdmin.StartHooks["StripWeapons"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "stripweapons",
        hasTarget = true,
        message = {"instigator", " забрал у ", "targets", " все оружие"},
    }

    FAdmin.Access.AddPrivilege("StripWeapons", 2)
    FAdmin.Commands.AddCommand("StripWeapons", nil, "<Player>")
    FAdmin.Commands.AddCommand("Strip", nil, "<Player>")

    wayscore.AddActionButton('stripweapons', {
        name = 'Забрать оружие',
        icon = 'fadmin/icons/weapon',
        color = Color(255,130,0),
        category = 'Администрирование',
        order = 9100,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'StripWeapons', ply) end,
        callback = function(ply)
            RunConsoleCommand('_FAdmin', 'StripWeapons', ply:UserID())
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/ragdoll/cl_init.lua:
FAdmin.StartHooks["Ragdoll"] = function()
    FAdmin.Access.AddPrivilege("Ragdoll", 2)
    FAdmin.Commands.AddCommand("Ragdoll", nil, "<Player>", "[normal/hang/kick]")
    FAdmin.Commands.AddCommand("UnRagdoll", nil, "<Player>")

    wayscore.AddActionButton('ragdoll', {
        name = function(ply) return ply:FAdmin_GetGlobal('fadmin_ragdolled') and 'Отменить Ragdoll' or 'Ragdoll' end,
        icon = function(ply)
            return 'fadmin/icons/ragdoll', ply:FAdmin_GetGlobal('fadmin_ragdolled') and 'fadmin/icons/disable'
        end,
        color = Color(255,130,0),
        order = 15000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Ragdoll', ply) end,
        callback = function(ply, button)
            if ply:FAdmin_GetGlobal("fadmin_ragdolled") then
                RunConsoleCommand("_FAdmin", "unragdoll", ply:UserID())
                button:SetImage2("null")
                button:SetText("Ragdoll")
                button:GetParent():InvalidateLayout()
                return
            end
    
            local menu = DermaMenu()
    
            local Padding = vgui.Create("DPanel")
            Padding:SetPaintBackgroundEnabled(false)
            Padding:SetSize(1,5)
            menu:AddPanel(Padding)
    
            local Title = vgui.Create("DLabel")
            Title:SetText("  Тип Ragdoll:\n")
            Title:SetFont("UiBold")
            Title:SizeToContents()
            Title:SetTextColor(color_black)
    
            menu:AddPanel(Title)
    
            for k,v in pairs(FAdmin.PlayerActions.RagdollTypes) do
                if v == "Unragdoll" then continue end
                FAdmin.PlayerActions.addTimeSubmenu(menu, v,
                    function()
                        RunConsoleCommand("_FAdmin", "Ragdoll", ply:UserID(), k)
                        button:SetImage2("fadmin/icons/disable")
                        button:SetText("Отменить Ragdoll")
                        button:GetParent():InvalidateLayout()
                    end,
                    function(secs)
                        RunConsoleCommand("_FAdmin", "Ragdoll", ply:UserID(), k, secs)
                        button:SetImage2("fadmin/icons/disable")
                        button:SetText("Отменить Ragdoll")
                        button:GetParent():InvalidateLayout()
                    end
                )
            end
    
            menu:Open()
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/kickban/sh_shared.lua:
nw.Register 'IsBanned'
    :Write(net.WriteBool)
    :Read(net.ReadBool)
    :SetPlayer()

nw.Register 'BanText'
    :Write(net.WriteString)
    :Read(net.ReadString)
    :SetLocalPlayer()

nw.Register 'UnBanTime'
    :Write(net.WriteFloat)
    :Read(net.ReadFloat)
    :SetLocalPlayer()

local meta = FindMetaTable('Player')
function meta:IsBanned()
    return self:GetNetVar('IsBanned') or false
end

function FAdmin.PlayerActions.ConvertBanTime(time)
    local Add = ""
    time = math.Round(time)

    if time <= 0 then
        return "навсегда"
    elseif time < 60 then
        -- minutes
        return wlib.string.formatPlural({"минуту", "минуты", "минут"}, math.ceil(time))
    elseif time >= 60 and time < 1440 then
        -- hours
        if math.floor((time / 60 - math.floor(time / 60)) * 60) > 0 then
            Add = ", " .. FAdmin.PlayerActions.ConvertBanTime((time / 60 - math.floor(time / 60)) * 60)
        end

        return wlib.string.formatPlural({"час", "часа", "часов"}, math.floor(time / 60)) .. Add
    elseif time >= 1440 and time < 10080 then
        -- days
        if math.floor((time / 1440 - math.floor(time / 1440)) * 1440) > 0 then
            Add = ", " .. FAdmin.PlayerActions.ConvertBanTime((time / 1440 - math.floor(time / 1440)) * 1440)
        end

        return wlib.string.formatPlural({"день", "дня", "дней"}, math.floor(time / 1440)) .. Add
    elseif time >= 10080 and time < 525948 then
        -- weeks
        if math.floor((time / 10080 - math.floor(time / 10080)) * 10080) > 0 then
            Add = ", " .. FAdmin.PlayerActions.ConvertBanTime((time / 10080 - math.floor(time / 10080)) * 10080)
        end

        return wlib.string.formatPlural({"неделю", "недели", "недель"}, math.floor(time / 10080)) .. Add
    elseif time >= 525948 then
        -- years
        if math.floor((time / 525948 - math.floor(time / 525948)) * 525948) > 0 then
            Add = ", " .. FAdmin.PlayerActions.ConvertBanTime((time / 525948 - math.floor(time / 525948)) * 525948)
        end

        return wlib.string.formatPlural({"год", "года", "лет"}, math.floor(time / 525948)) .. Add
    end

    return time
end

FAdmin.StartHooks["kickbanning"] = function()
    FAdmin.Messages.RegisterNotification{
        name = "kick",
        hasTarget = false,
        message = {"instigator", " кикнул ", "extraInfo.1", " (", "extraInfo.2", ")"},
        receivers = "everyone",
        writeExtraInfo = function(info)
            net.WriteUInt(#info[1], 8)
            -- Manually send targets, because they might be gone from the client when kicked
            for _, target in pairs(info[1]) do
                if not IsValid(target) then
                    net.WriteString("Неизвестно")
                    continue
                end

                net.WriteString(target:Nick())
            end

            net.WriteString(info[2])
        end,

        readExtraInfo = function()
            local count = net.ReadUInt(8)
            local targets = {}

            for i = 1, count do
                table.insert(targets, net.ReadString())
            end

            return {table.concat(targets, ", "), net.ReadString()}
        end,
        extraInfoColors = {Color(160, 171, 189)}
    }

    FAdmin.Messages.RegisterNotification{
        name = "ban",
        hasTarget = false,
        message = {"instigator", " забанил ", "extraInfo.1", " на ", "extraInfo.2", " (", "extraInfo.3", ")"},
        receivers = "everyone",
        writeExtraInfo = function(info)
            info[1] = istable(info[1]) and info[1] or {info[1]}
            net.WriteUInt(#info[1], 8)
            -- Manually send targets, because they might be gone from the client when kicked
            for _, target in pairs(info[1]) do
                if isstring(target) then
                    net.WriteString("Неизвестно (" .. target .. ")")
                    continue
                end

                if not IsValid(target) then
                    net.WriteString("Неизвестно")
                    continue
                end

                net.WriteString(target:Nick())
            end

            net.WriteUInt(info[2], 32)

            net.WriteString(info[3])
        end,

        readExtraInfo = function()
            local count = net.ReadUInt(8)
            local targets = {}

            for i = 1, count do
                table.insert(targets, net.ReadString())
            end

            return {table.concat(targets, ", "), FAdmin.PlayerActions.ConvertBanTime(net.ReadUInt(32)), net.ReadString()}
        end,

        extraInfoColors = {Color(160, 171, 189)}
    }

    FAdmin.Messages.RegisterNotification{
        name = "unban",
        hasTarget = false,
        message = {"instigator", " разбанил ", "extraInfo.1", " (", "extraInfo.2", ")"},
        receivers = "everyone",
        writeExtraInfo = function(info)
            net.WriteString(info[1])
            net.WriteString(info[2])
        end,

        readExtraInfo = function()
            return {net.ReadString(), net.ReadString()}
        end,

        extraInfoColors = {Color(160, 171, 189)}
    }
end

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/giveweapons/cl_controls.lua:
-- Controls for the give weapons menu. These are litterally copied and edited from the garry's mod code.
-- Remaking them in case the gamemode is not derived from sandbox
-- Copying from garry's mod code because I'm lazy and because it looks good.


-- Weapon icon:
local PANEL = {}

function PANEL:Init()
    self:SetSize(83, 83)

    self.Label = vgui.Create("DLabel", self)

    self:SetKeepAspect(true)
    self:SetDrawBorder(true)
    self.m_Image:SetPaintedManually(true)
end


function PANEL:PerformLayout()
    self.Label:SizeToContents()
    self.Label:SetFont("Default")
    self.Label:SetTextColor(color_white)
    self.Label:SetContentAlignment(5)
    self.Label:SetWide(self:GetWide())
    self.Label:AlignBottom(2)

    DImageButton.PerformLayout(self)

    if self.imgAdmin then
        self.imgAdmin:SizeToContents()
        self.imgAdmin:AlignTop(4)
        self.imgAdmin:AlignRight(4)
    end
end

function PANEL:CreateAdminIcon()
    self.imgAdmin = vgui.Create("DImage", self)
    self.imgAdmin:SetImage("icon16/shield.png") -- SilkIcons are now merged into GMOD as materials/icon16
    self.imgAdmin:SetTooltip("#Admin Only")
end

function PANEL:Paint()
    local w, h = self:GetSize()
    self.m_Image:Paint()

    surface.SetDrawColor(30, 30, 30, 200)
    surface.DrawRect(0, h - 16, w, 16)
end

function PANEL:Setup(NiceName, SpawnName, IconMaterial, AdminOnly, Parent, IsAmmo)
    self.Label:SetText(DarkRP.deLocalise(NiceName))

    self.DoClick = function() Parent:DoGiveWeapon(SpawnName, IsAmmo) end
    self.DoRightClick = wlib.func.blank

    if not IconMaterial then
        IconMaterial = "VGUI/entities/" .. SpawnName
    end

    self:SetOnViewMaterial(IconMaterial, "vgui/swepicon")

    if AdminOnly then self:CreateAdminIcon() end

    self:InvalidateLayout()
end

local WeaponIcon = vgui.RegisterTable(PANEL, "DImageButton")

-- Full panel:
local PANEL2 = {}

function PANEL2:Init()
    self.PanelList = vgui.Create("DPanelList", self)
    self.PanelList:SetPadding(4)
    self.PanelList:SetSpacing(2)
    self.PanelList:EnableVerticalScrollbar(true)
end

function PANEL2:BuildList()
    self.PanelList:Clear()

    if not self.HideAmmo then
        local AmmoCat = vgui.Create("DCollapsibleCategory", self)
        self.PanelList:AddItem(AmmoCat)
        AmmoCat:SetLabel("Give ammo")

        local AmmoPan = vgui.Create("DPanelList")
        AmmoCat:SetContents(AmmoPan)
        AmmoPan:EnableHorizontal(true)
        AmmoPan:SetPaintBackground(false)
        AmmoPan:SetSpacing(2)
        AmmoPan:SetPadding(2)
        AmmoPan:SetAutoSize(true)

        for k, v in SortedPairs(FAdmin.AmmoTypes) do
            local Icon = vgui.CreateFromTable(WeaponIcon, self)
            Icon:Setup(k, k, "spawnicons/models/items/boxmrounds60x60.png", false, self, true) -- Gets created clientside by GMOD when someone is after that model, or trying to buy ammo.
            AmmoPan:AddItem(Icon)
        end
    end

    local Weapons = weapons.GetList()
    local Categorised = {}

    Categorised["Half-life 2"] = {}
    for k, weapon in pairs(FAdmin.HL2Guns) do
        table.insert(Categorised["Half-life 2"], {PrintName = k, ClassName = weapon, Spawnable = true,
        Author = "Half-life 2",
        Contact = "gaben@valvesoftware.com",
        Instructions = "Shoot!"})
    end

    for k, weapon in pairs(Weapons) do
        weapon = weapons.Get(weapon.ClassName)
        Weapons[k] = weapon
        weapon.Category = weapon.Category or "Other"

        if not weapon.Spawnable and not weapon.AdminSpawnable or weapon.Category ~= 'Разрешено' then
            Weapons[k] = nil
        else
            Categorised[weapon.Category] = Categorised[weapon.Category] or {}
            table.insert(Categorised[weapon.Category], weapon)
            Weapons[k] = nil
        end
    end

    Weapons = nil

    for CategoryName, v in SortedPairs(Categorised) do
        local Category = vgui.Create("DCollapsibleCategory", self)
        self.PanelList:AddItem(Category)
        Category:SetLabel(CategoryName)
        Category:SetCookieName("WeaponSpawn." .. CategoryName)

        local Content = vgui.Create("DPanelList")
        Category:SetContents(Content)
        Content:EnableHorizontal(true)
        Content:SetPaintBackground(false)
        Content:SetSpacing(2)
        Content:SetPadding(2)
        Content:SetAutoSize(true)

        for k, WeaponTable in SortedPairsByMemberValue(v, "PrintName") do
            local Icon = vgui.CreateFromTable(WeaponIcon, self)
            Icon:Setup(WeaponTable.PrintName or WeaponTable.ClassName, WeaponTable.ClassName, WeaponTable.SpawnMenuIcon, WeaponTable.AdminSpawnable and not WeaponTable.Spawnable, self)

            local Tooltip =  Format("Name: %s", WeaponTable.PrintName)
            if WeaponTable.Author ~= "" then Tooltip = Format("%s\nAuthor: %s", Tooltip, WeaponTable.Author) end
            if WeaponTable.Contact ~= "" then Tooltip = Format("%s\nContact: %s", Tooltip, WeaponTable.Contact) end
            if WeaponTable.Instructions ~= "" then Tooltip = Format("%s\n\n%s", Tooltip, WeaponTable.Instructions) end

            Icon:SetTooltip(Tooltip)
            Content:AddItem(Icon)
        end
    end
    self.PanelList:InvalidateLayout()
end

function PANEL2:PerformLayout()
    self.PanelList:StretchToParent(0, 0, 0, 0)
end

derma.DefineControl("FAdmin_weaponPanel", "Weapon panel for giving weapons in FAdmin", PANEL2, "Panel")

--gamemodes/darkrp/gamemode/modules/fadmin/fadmin/playeractions/cloak/cl_init.lua:
FAdmin.StartHooks["zz_Cloak"] = function()
    FAdmin.Access.AddPrivilege("Cloak", 2)
    FAdmin.Commands.AddCommand("Cloak", nil, "<Player>")
    FAdmin.Commands.AddCommand("Uncloak", nil, "<Player>")

    wayscore.AddActionButton('cloak', {
        name = function(ply) return ply:FAdmin_GetGlobal('FAdmin_cloaked') and 'Сделать видимым' or 'Сделать невидимым' end,
        icon = function(ply)
            return 'fadmin/icons/cloak', ply:FAdmin_GetGlobal('FAdmin_cloaked') and 'fadmin/icons/disable'
        end,
        color = Color(0,200,0),
        order = 11000,
        check = function(ply) return FAdmin.Access.PlayerHasPrivilege(LocalPlayer(), 'Cloak', ply) end,
        callback = function(ply, button)
            if not ply:FAdmin_GetGlobal('FAdmin_cloaked') then
                RunConsoleCommand('_FAdmin', 'Cloak', ply:UserID())
                button:SetImage2('fadmin/icons/disable')
                button:SetText('Сделать видимым')
                button:GetParent():InvalidateLayout()
            else
                RunConsoleCommand('_FAdmin', 'Uncloak', ply:UserID())
                button:SetImage2('null')
                button:SetText('Сделать невидимым')
                button:GetParent():InvalidateLayout()
            end
        end,
    })
end

--gamemodes/darkrp/gamemode/modules/base/sh_simplerr.lua:
-- simplerrRun: Run a function with the given parameters and send any runtime errors to admins
DarkRP.simplerrRun = fc{
    fn.Snd, -- On success ignore the first return value
    simplerr.wrapError,
    simplerr.wrapHook,
    simplerr.wrapLog,
    simplerr.safeCall
}

-- error: throw a runtime error without exiting the stack
-- parameters: msg, [stackNr], [hints], [path], [line]
DarkRP.errorNoHalt = fc{
    simplerr.wrapHook,
    simplerr.wrapLog,
    simplerr.runError,
    function(msg, err, ...) return msg, err and err + 3 or 4, ... end -- Raise error level one higher
}

-- error: throw a runtime error
-- parameters: msg, [stackNr], [hints], [path], [line]
DarkRP.error = fc{
    simplerr.wrapError,
    DarkRP.errorNoHalt
}

-- Print errors from the server in the console and show a message in chat
if CLIENT then
    local function showError(count, errs)
        local one = count == 1
        chat.AddText(Color(255, 0, 0), string.format("There %s %i Lua problem%s!", one and "is" or "are", count, one and "" or 's'))
        chat.AddText(Color(255, 255, 255), "\tPlease check your console for more information!")

        for i = 1, count do
            MsgC(Color(137, 222, 255), errs[i] .. "\n")
        end
    end

    net.Receive("DarkRP_simplerrError", function()
        local count = net.ReadUInt(16)
        local errs = {}

        for i = 1, count do
            table.insert(errs, net.ReadString())
        end

        showError(count, errs)
    end)
    hook.Add("onSimplerrError", "DarkRP_Simplerr", function(err) showError(1, {err}) end)

    return
end

-- Serverside part
local plyMeta = FindMetaTable("Player")
util.AddNetworkString("DarkRP_simplerrError")

-- Send all errors to the client
local function sendErrors(plys, errs)
    local count = #errs
    local one = count == 1

    DarkRP.notify(plys, 1, 120, string.format("There %s %i Lua problem%s!\nPlease check your console for more information!", one and "is" or "are", count, one and "" or 's'))
    net.Start("DarkRP_simplerrError")
        net.WriteUInt(#errs, 16)
        fn.ForEach(fn.Flip(net.WriteString), errs)
    net.Send(plys)
end

-- Annoy all admins when an error occurs
local function annoyAdmins(err)
    local admins = fn.Filter(plyMeta.IsAdmin, player.GetAll())
    sendErrors(admins, {err})
end
hook.Add("onSimplerrError", "DarkRP_Simplerr", annoyAdmins)

-- Annoy joining admin with errors
local function annoyAdmin(ply)
    if not IsValid(ply) or not ply:IsAdmin() then return end
    local errs = table.Copy(simplerr.getLog())
    if #errs == 0 then return end

    fn.Map(fp{fn.GetValue, "err"}, errs)
    sendErrors(ply, errs)
end
hook.Add("PlayerInitialSpawn", "DarkRP_Simplerr", function(ply) timer.Simple(1, fp{annoyAdmin, ply}) end)

--gamemodes/darkrp/gamemode/modules/base/sh_gamemode_functions.lua:
function GM:CanProperty(ply, property, ent)
    if not IsValid(ent) then return false end

	if ent.m_tblToolsAllowed then
		local vFound = false
		for k, v in pairs(ent.m_tblToolsAllowed) do
			if property == v then
                vFound = true
                break
            end
		end

		if not vFound then return false end
	end

	if ent:IsWeapon() and IsValid(ent:GetOwner()) then
		return false
	end

	if ent.CanProperty then
		return ent:CanProperty(ply1, property)
	end

    if self.Config.allowedProperties[property] == false then return false end

    if SERVER then
        if ent:CPPICanTool(ply, "remover") and not self.Config.allowedProperties[property] then return false end
    end

	return true
end

function GM:SetupMove(ply, mv, cmd)
    if ply:isArrested() then
        mv:SetMaxClientSpeed(self.Config.arrestspeed)
    end
end

function GM:StartCommand(ply, usrcmd)
    -- Used in arrest_stick and unarrest_stick but addons can use it too!
    local wep = ply:GetActiveWeapon()
    if IsValid(wep) and isfunction(wep.startDarkRPCommand) then
        wep:startDarkRPCommand(usrcmd)
    end
end

function GM:OnPlayerChangedTeam(ply, oldTeam, newTeam)
    if RPExtraTeams[newTeam] and RPExtraTeams[newTeam].OnPlayerChangedTeam then
        RPExtraTeams[newTeam].OnPlayerChangedTeam(ply, oldTeam, newTeam)
    end

--[[
     if CLIENT then return end

    local agenda = ply:getAgendaTable()

    -- Remove agenda text when last manager left
    if agenda and agenda.ManagersByKey[oldTeam] then
        local found = false
        for man, _ in pairs(agenda.ManagersByKey) do
            if team.NumPlayers(man) > 0 then found = true break end
        end
        if not found then agenda.text = nil end
    end

    ply:SetNetVar("agenda", agenda and agenda.text or nil)
--]] 
end

function GM:CalculateRespawnTime(ply, wep, killer)
    if ply:Team() ~= TEAM_UNASSIGNED and ply:getJobTable().respawnTime then return ply:getJobTable().respawnTime end
    
    return GAMEMODE.Config.respawntime or 0
end

hook.Add("loadCustomDarkRPItems", "CAMI privs", function()
    CAMI.RegisterPrivilege{
        Name = "DarkRP_SeeEvents",
        MinAccess = "admin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_GetAdminWeapons",
        MinAccess = "admin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_SetDoorOwner",
        MinAccess = "admin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_ChangeDoorSettings",
        MinAccess = "superadmin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_AdminCommands",
        MinAccess = "admin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_SetMoney",
        MinAccess = "superadmin"
    }

    CAMI.RegisterPrivilege{
        Name = "DarkRP_SetLicense",
        MinAccess = "superadmin"
    }

    for k,v in pairs(RPExtraTeams) do
        if not v.vote or v.admin and v.admin > 1 then continue end

        local toAdmin = {[0] = "admin", [1] = "superadmin"}
        CAMI.RegisterPrivilege{
            Name = "DarkRP_GetJob_" .. v.command,
            MinAccess = toAdmin[v.admin or 0]-- Add privileges for the teams that are voted for
        }
    end
end)

--gamemodes/darkrp/gamemode/modules/base/cl_util.lua:
local plyMeta = FindMetaTable("Player")

--[[---------------------------------------------------------------------------
Wrap strings to not become wider than the given amount of pixels
---------------------------------------------------------------------------]]
local function charWrap(text, pxWidth)
    local total = 0

    text = text:gsub(".", function(char)
        total = total + surface.GetTextSize(char)

        -- Wrap around when the max width is reached
        if total >= pxWidth then
            total = 0
            return "\n" .. char
        end

        return char
    end)

    return text, total
end

function DarkRP.textWrap(text, font, pxWidth)
    local total = 0

    surface.SetFont(font)

    local spaceSize = surface.GetTextSize(' ')
    text = text:gsub("(%s?[%S]+)", function(word)
            local char = string.sub(word, 1, 1)
            if char == "\n" or char == "\t" then
                total = 0
            end

            local wordlen = surface.GetTextSize(word)
            total = total + wordlen

            -- Wrap around when the max width is reached
            if wordlen >= pxWidth then -- Split the word if the word is too big
                local splitWord, splitPoint = charWrap(word, pxWidth - (total - wordlen))
                total = splitPoint
                return splitWord
            elseif total < pxWidth then
                return word
            end

            -- Split before the word
            if char == ' ' then
                total = wordlen - spaceSize
                return '\n' .. string.sub(word, 2)
            end

            total = wordlen
            return '\n' .. word
        end)

    return text
end
--[[---------------------------------------------------------------------------
Key name to key int mapping
---------------------------------------------------------------------------]]
local keyNames
function input.KeyNameToNumber(str)
    if not keyNames then
        keyNames = {}
        for i = 1, 107, 1 do
            keyNames[input.GetKeyName(i)] = i
        end
    end

    return keyNames[str]
end

--gamemodes/darkrp/gamemode/modules/base/cl_jobmodels.lua:
-- Create a table for the preferred playermodels
sql.Query([[CREATE TABLE IF NOT EXISTS darkp_playermodels(
    jobcmd VARCHAR(45) NOT NULL PRIMARY KEY,
    model VARCHAR(140) NOT NULL
);]])

local preferredModels = {}


--[[---------------------------------------------------------------------------
Interface functions
---------------------------------------------------------------------------]]
function DarkRP.setPreferredJobModel(teamNr, model)
    local job = RPExtraTeams[teamNr]
    if not job then return end
    preferredModels[job.command] = model
    sql.Query(string.format([[REPLACE INTO darkp_playermodels VALUES(%s, %s);]], sql.SQLStr(job.command), sql.SQLStr(model)))

    net.Start("DarkRP_preferredjobmodel")
        net.WriteUInt(teamNr, 8)
        net.WriteString(model)
    net.SendToServer()
end

function DarkRP.getPreferredJobModel(teamNr)
    local job = RPExtraTeams[teamNr]
    if not job then return end
    return preferredModels[job.command]
end

--[[---------------------------------------------------------------------------
Load the preferred models
---------------------------------------------------------------------------]]
local function sendModels() -- run after the jobs have loaded
    net.Start("DarkRP_preferredjobmodels")
        for _, job in ipairs(RPExtraTeams) do
            if not preferredModels[job.command] then net.WriteBit(false) continue end

            net.WriteBit(true)
            net.WriteString(preferredModels[job.command])
        end
    net.SendToServer()
end

do
    local models = sql.Query([[SELECT jobcmd, model FROM darkp_playermodels;]])
    for k,v in pairs(models or {}) do
        preferredModels[v.jobcmd] = v.model
    end

    timer.Simple(0, sendModels)
end

--gamemodes/darkrp/gamemode/config/addentities.lua:
DarkRP.createCategory{
    name = "Other",
    categorises = "entities",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

DarkRP.createCategory{
    name = "Other",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

DarkRP.createCategory{
    name = "Rifles",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 100,
}

DarkRP.createCategory{
    name = "Shotguns",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 101,
}

DarkRP.createCategory{
    name = "Snipers",
    categorises = "shipments",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 102,
}

DarkRP.createCategory{
    name = "Pistols",
    categorises = "weapons",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 100,
}

DarkRP.createCategory{
    name = "Other",
    categorises = "weapons",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

DarkRP.createCategory{
    name = "Other",
    categorises = "vehicles",
    startExpanded = true,
    color = Color(0, 107, 0, 255),
    canSee = fp{fn.Id, true},
    sortOrder = 255,
}

local noBanned = {}
for k, _ in pairs(RPExtraTeams or {}) do
    if k ~= TEAM_BANNED then noBanned[#noBanned+1] = k end
end

local oldCreate = DarkRP.createEntity
function DarkRP.createEntity(name, args, ...)
    if istable(args) and args.allowed == nil then
        args.allowed = noBanned
    end
    oldCreate(name, args, ...)
end


DarkRP.createEntity("Хранилище для кликеров", {
    ent = "clicker_safe",
    model = "models/props_vtmb/safe.mdl",
    price = 35750,
    max = 3,
    cmd = "clickersafe",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Хранилище банкира", {
    ent = "clicker_safe_bank",
    model = "models/props_vtmb/safe.mdl",
    price = 35750,
    max = 3,
    cmd = "clickersafebank",
    allowed = {TEAM_BANK}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Балончик с краской", {
    ent = "weapon_spraypaint",
    model = "models/props_c17/canister02a.mdl",
    price = 30000,
    max = 2,
    sortOrder = 1,
    cmd = "graffiti",
})

DarkRP.createEntity("Квадртаная рамка", {
    ent = "painting_3",
    model = "models/props/cs_office/offcertificatea.mdl",
    price = 6500,
    max = 1,
    sortOrder = 1,
    cmd = "picture1",
})

DarkRP.createEntity("Длинная рамка", {
    ent = "painting_1",
    model = "models/props_c17/Frame002a.mdl",
    price = 6500,
    max = 1,
    sortOrder = 1,
    cmd = "picture2",
})

DarkRP.createEntity("Большая квадртаная рамка", {
    ent = "painting_4",
    model = "models/props/cs_office/offcertificatea.mdl",
    price = 17500,
    max = 1,
    sortOrder = 1,
    cmd = "picture3",
})

DarkRP.createEntity("Большая длинная рамка", {
    ent = "painting_2",
    model = "models/props_c17/Frame002a.mdl",
    price = 17500,
    max = 1,
    sortOrder = 1,
    cmd = "picture4",
})

DarkRP.createEntity("Рация", {
    ent = "entity_rachia",
    model = "models/props_c17/BriefCase001a.mdl",
    price = 15000,
    max = 10,
    sortOrder = 1,
    cmd = "rachia",
    allowed = {TEAM_GUN}
})

DarkRP.createEntity("Сундук для пожертвований", {
    ent = "donation_box",
    model = "models/props/CS_militia/footlocker01_open.mdl",
    price = 1000,
    max = 1,
    sortOrder = 1,
    cmd = "buydonationchest",
    allowed = {TEAM_HOBO, TEAM_AFHOBO}
})

DarkRP.createEntity("Телевизор", {
    ent = "tv",
    model = "models/props/cs_office/TV_plasma.mdl",
    price = 50000,
    max = 1,
    cmd = "youtubetv",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Большой Телевизор", {
    ent = "tv_large",
    model = "models/hunter/plates/plate4x6.mdl",
    price = 100000,
    max = 1,
    cmd = "youtubetvlarge",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Радио", {
    ent = "radio",
    model = "models/props/cs_office/radio.mdl",
    price = 15000,
    max = 1,
    cmd = "radiomexannik",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("50/50", {
    ent = "slot_fifty_fifty",
    model = "models/arcade-machines/wayzer_arcade.mdl",
    price = 50000,
    max = 3,
    cmd = "fiftyfifty",
    category = "Other",
    allowed = {TEAM_BARMEN}
}) 

DarkRP.createEntity("Все или ничего", {
    ent = "slot_double",
    model = "models/arcade-machines/wayzer_arcade.mdl",
    price = 50000,
    max = 3,
    cmd = "doubleornot",
    category = "Other",
    allowed = {TEAM_BARMEN}
})

DarkRP.createEntity("Колесо Удачи", {
    ent = "slot_roulette",
    model = "models/arcade-machines/wayzer_arcade.mdl",
    price = 50000,
    max = 3,
    cmd = "rouleteslot",
    category = "Other",
    allowed = {TEAM_BARMEN}
}) 

DarkRP.createEntity("Слоты", {
    ent = "slot_slots",
    model = "models/arcade-machines/wayzer_arcade.mdl",
    price = 50000,
    max = 3,
    cmd = "slot_slots",
    category = "Other",
    allowed = {TEAM_BARMEN}
}) 

DarkRP.createEntity("Маленькая аптечка", {
    ent = "item_healthvial",
    model = "models/healthvial.mdl",
    price = 5000,
    max = 5,
    cmd = "buyhealth",
    category = "Other",
    allowed = {TEAM_VRACH}
})

DarkRP.createEntity("Большая аптечка", {
    ent = "item_healthkit",
    model = "models/items/healthkit.mdl",
    price = 15000,
    max = 5,
    cmd = "buyhealthbig",
    category = "Other",
    allowed = {TEAM_VRACH}
})

DarkRP.createEntity("Плита для шоколада", {
    ent = "lucid_choc_stove",
    model = "models/props_c17/furnitureStove001a.mdl",
    price = 50000,
    max = 2,
    cmd = "buychocstove",
    allowed = {TEAM_CHOCMAKER},
    category = "Other",
})

DarkRP.createEntity("Самогонный аппарат", {
    ent = "mn_distillery",
    model = "models/bronze_barrel/bronze_barrel.mdl",
    price = 75000,
    max = 2,
    cmd = "buysamogonapparat",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})

DarkRP.createEntity("Труба", {
    ent = "mn_toppiece",
    model = "models/big_pipe/big_pipe.mdl",
    price = 25000,
    max = 2,
    cmd = "buytryba",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})

DarkRP.createEntity("Бассейн", {
    ent = "mn_bucket",
    model = "models/wood_bucket/wood_bucket.mdl",
    price = 25000,
    max = 2,
    cmd = "buybassein",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})

DarkRP.createEntity("Деревянная бочка", {
    ent = "mn_barrel",
    model = "models/wood_barrel/wood_barrel.mdl",
    price = 5000,
    max = 8,
    cmd = "buybochka",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})

/*
DarkRP.createEntity("Горшок", {
    ent = "mn_pot",
    model = "models/pot/pot_nodirt.mdl",
    price = 1000,
    max = 6,
    cmd = "buygorshok",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})

DarkRP.createEntity("Земля", {
    ent = "mn_dirt",
    model = "models/soil/soil.mdl",
    price = 1000,
    max = 3,
    cmd = "buyzemlya",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})
*/

DarkRP.createEntity("Пшеница", {
    ent = "mn_ggrain",
    model = "models/plants/wheat_bunch.mdl",
    price = 1000,
    max = 3,
    cmd = "buypsheno",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})

DarkRP.createEntity("Кукуруза", {
    ent = "mn_ccorn",
    model = "models/plants/corn_bunch.mdl",
    price = 1000,
    max = 3,
    cmd = "buykukuruza",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})

DarkRP.createEntity("Вода", {
    ent = "mn_water",
    model = "models/props_junk/big_water_bottle.mdl",
    price = 1000,
    max = 3,
    cmd = "buysamogonvoda",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})
--[[
DarkRP.createEntity("Семена пшеницы", {
    ent = "mn_gseed",
    model = "models/props/cs_italy/orange.mdl",
    price = 250,
    max = 3,
    cmd = "buysemenapchenicha",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})

DarkRP.createEntity("Семена кукурузы", {
    ent = "mn_cseed",
    model = "models/props/cs_italy/orange.mdl",
    price = 250,
    max = 3,
    cmd = "buysemenakykyryzi",
    allowed = {TEAM_SAMOGON},
    category = "Other",
})
--]]

DarkRP.createEntity("Какао", {
    ent = "lucid_choc_cocoa",
    model = "models/props_junk/garbage_glassbottle001a.mdl",
    price = 500,
    max = 4,
    cmd = "buychoccocoa",
    allowed = {TEAM_CHOCMAKER},
    category = "Other",
})

DarkRP.createEntity("Молоко", {
    ent = "lucid_choc_milk",
    model = "models/props_junk/garbage_milkcarton002a.mdl",
    price = 500,
    max = 2,
    cmd = "buychocmilk",
    allowed = {TEAM_CHOCMAKER},
    category = "Other",
})

DarkRP.createEntity("Сахар", {
    ent = "lucid_choc_sugar",
    model = "models/props_junk/garbage_milkcarton001a.mdl",
    price = 500,
    max = 2,
    cmd = "buychocsugar",
    allowed = {TEAM_CHOCMAKER},
    category = "Other",
})


DarkRP.createCategory{
    name = "Bitminers 2",
    categorises = "entities",
    startExpanded = true,
    color = Color(120, 120, 255, 255),
    sortOrder = 1,
    allowed = {TEAM_MINERS}
}

DarkRP.createEntity("Bitminer S1", {
    ent = "bm2_bitminer_1",
    model = "models/bitminers2/bitminer_1.mdl",
    price = 5000,
    max = 4,
    cmd = "buybitminers1",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
}) 

DarkRP.createEntity("Bitminer S2", {
    ent = "bm2_bitminer_2",
    model = "models/bitminers2/bitminer_3.mdl",
    price = 25000,
    max = 4,
    cmd = "buybitminers2",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Bitminer Server", {
    ent = "bm2_bitminer_server",
    model = "models/bitminers2/bitminer_2.mdl",
    price = 50000,
    max = 16,
    cmd = "buybitminerserver",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Bitminer Rack", {
    ent = "bm2_bitminer_rack",
    model = "models/bitminers2/bitminer_rack.mdl",
    price = 100000,
    max = 2,
    cmd = "buybitminerrack",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Extension Lead", {
    ent = "bm2_extention_lead",
    model = "models/bitminers2/bitminer_plug_3.mdl",
    price = 500,
    max = 8,
    cmd = "buybitminerextension",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Power Lead", {
    ent = "bm2_power_lead",
    model = "models/bitminers2/bitminer_plug_2.mdl",
    price = 500,
    max = 10,
    cmd = "buybitminerpowerlead",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Generator", {
    ent = "bm2_generator",
    model = "models/bitminers2/generator.mdl",
    price = 6000,
    max = 3,
    cmd = "buybitminergenerator",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Fuel", {
    ent = "bm2_fuel",
    model = "models/props_junk/gascan001a.mdl",
    price = 1000,
    max = 4,
    cmd = "buybitminerfuel",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Fuel Line", {
    ent = "bm2_extra_fuel_line",
    model = "models/bitminers2/bm2_extra_fuel_plug.mdl",
    price = 1500,
    max = 2,
    cmd = "buyfuelline",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
}) 

DarkRP.createEntity("Large Fuel", {
    ent = "bm2_large_fuel",
    model = "models/props/de_train/barrel.mdl",
    price = 4000,
    max = 4,
    cmd = "buylargefuel",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Fuel Tank", {
    ent = "bm2_extra_fuel_tank",
    model = "models/bitminers2/bm2_extra_fueltank.mdl",
    price = 10000,
    max = 2,
    cmd = "buyfueltank",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Solar Cable", {
    ent = "bm2_solar_cable",
    model = "models/bitminers2/bm2_solar_plug.mdl",
    price = 500,
    max = 10,
    cmd = "buysolarcable",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Solar Converter", {
    ent = "bm2_solarconverter",
    model = "models/bitminers2/bm2_solar_converter.mdl",
    price = 20000,
    max = 1,
    cmd = "buysolarconverter",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Solar Panel", {
    ent = "bm2_solar_panel",
    model = "models/bitminers2/bm2_solar_panel.mdl",
    price = 15000,
    max = 10,
    cmd = "buysolarpanel",
    category = "Bitminers 2",
    allowed = {TEAM_MINERS}
})

-- метварщик

DarkRP.createEntity("Вода", {
    ent = "eml_water",
    model = "models/props_junk/garbage_plasticbottle003a.mdl",
    price = 1000,
    max = 2,
    cmd = "voda2",
    category = "Other",
    allowed = {TEAM_METH}
}) 

DarkRP.createEntity("Газ", {
    ent = "eml_gas",
    model = "models/props_c17/canister01a.mdl",
    price = 2000,
    max = 1,
    cmd = "balongas",
    category = "Other",
    allowed = {TEAM_METH}
}) 

DarkRP.createEntity("Жидкий йод", {
    ent = "eml_iodine",
    model = "models/props_lab/jar01b.mdl",
    price = 1000,
    max = 2,
    cmd = "jidkiyod",
    category = "Other",
    allowed = {TEAM_METH}
}) 

DarkRP.createEntity("Соляная кислота", {
    ent = "eml_macid",
    model = "models/props_junk/garbage_plasticbottle001a.mdl",
    price = 1500,
    max = 2,
    cmd = "acidsolyanka",
    category = "Other",
    allowed = {TEAM_METH}
}) 

DarkRP.createEntity("Жидкий Сульфур", {
    ent = "eml_sulfur",
    model = "models/props_lab/jar01b.mdl",
    price = 1500,
    max = 2,
    cmd = "sylfyr",
    category = "Other",
    allowed = {TEAM_METH}
}) 

DarkRP.createEntity("Плита для Метамфетамина", {
    ent = "eml_stove",
    model = "models/props_c17/furnitureStove001a.mdl",
    price = 50000,
    max = 1,
    cmd = "pechka",
    category = "Other",
    allowed = {TEAM_METH}
}) 

DarkRP.createEntity("Кастрюля для Красного фосфора", {
    ent = "eml_pot",
    model = "models/props_c17/metalPot001a.mdl",
    price = 1000,
    max = 2,
    cmd = "redfos",
    category = "Other",
    allowed = {TEAM_METH}
}) 

DarkRP.createEntity("Кастрюля для Метамфетамина", {
    ent = "eml_spot",
    model = "models/props_c17/metalPot001a.mdl",
    price = 1000,
    max = 2,
    cmd = "methhhh",
    category = "Other",
    allowed = {TEAM_METH}
}) 

DarkRP.createEntity("Бутылка", {
    ent = "eml_jar",
    model = "models/props_lab/jar01a.mdl",
    price = 1000,
    max = 1,
    cmd = "bytilka",
    category = "Other",
    allowed = {TEAM_METH}
})

-- Нарколог
DarkRP.createEntity("Метамфетамин", {
    ent = "durgz_meth",
    model = "models/katharsmodels/contraband/metasync/blue_sky.mdl",
    price = 5000,
    max = 10,
    cmd = "drugzmeth",
    allowed = {TEAM_MEDIC}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})
--[[
DarkRP.createEntity("Марихуана", {
    ent = "durgz_weed",
    model = "models/katharsmodels/contraband/zak_wiet/zak_wiet.mdl",
    price = 6500,
    max = 10,
    cmd = "drugzmarix",
    allowed = {TEAM_MEDIC}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})
--]]
DarkRP.createEntity("Новичок", {
    ent = "durgz_aspirin",
    model = "models/jaanus/aspbtl.mdl",
    price = 4500,
    max = 10,
    cmd = "aspirin",
    allowed = {TEAM_MEDIC}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Анти-Токсин", {
    ent = "durgz_water",
    model = "models/jaanus/aspbtl.mdl",
    price = 5000,
    max = 10,
    cmd = "drugzcocv",
    allowed = {TEAM_MEDIC}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Героин", {
    ent = "durgz_heroine",
    model = "models/katharsmodels/syringe_out/syringe_out.mdl",
    price = 10000,
    max = 10,
    cmd = "drugzcocvv",
    allowed = {TEAM_MEDIC}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

/*
DarkRP.createEntity("PCP", {
    ent = "durgz_pcp",
    model = "models/cocn.mdl",
    price = 3000,
    max = 10,
    cmd = "drugzpcp",
    allowed = {TEAM_MEDIC}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Кокаин", {
    ent = "durgz_cocaine",
    model = "models/cocn.mdl",
    price = 8000,
    max = 10,
    cmd = "drugzcoc",
    allowed = {TEAM_MEDIC}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})
*/
DarkRP.createEntity("ЛСД", {
    ent = "durgz_lsd",
    model = "models/cocn.mdl",
    price = 7500,
    max = 10,
    cmd = "drugzpcplsd",
    allowed = {TEAM_MEDIC}, -- функция, которая переопределяет спаун для этой Энтити  durgz_mushroom
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Цианид", {
    ent = "durgz_mushroom",
    model = "models/cocn.mdl",
    price = 4500,
    max = 10,
    cmd = "drugznarcozz",
    allowed = {TEAM_MEDIC}, -- функция, которая переопределяет спаун для этой Энтити  durgz_mushroom
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

-- Продавец Оружия
-- Бармен
DarkRP.createEntity("Пиво", {
    ent = "durgz_alcohol",
    model = "models/drug_mod/alcohol_can.mdl",
    price = 750,
    max = 5,
    cmd = "pivo",
    allowed = {TEAM_BARMEN}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Сигареты", {
    ent = "durgz_cigarette",
    model = "models/boxopencigshib.mdl",
    price = 500,
    max = 5,
    cmd = "cigareta",
    allowed = {TEAM_BARMEN}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Вода", {
    ent = "durgz_water",
    model = "models/drug_mod/the_bottle_of_water.mdl",
    price = 300,
    max = 5,
    cmd = "voda",
    allowed = {TEAM_BARMEN}, -- функция, которая переопределяет спаун для этой Энтити
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

-- Разное
DarkRP.createEntity("VAPE Medical", {
    ent = "weapon_vape_medicinal",
    model = "models/swamponions/vape.mdl",
    price = 15000,
    max = 1,
    cmd = "vapemed",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 100, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
customCheck = function(ply) return CLIENT or ply:IsVIP() end,
CustomCheckFailMsg = "Это только для VIP пользователей"
})

DarkRP.createEntity("VAPE", {
    ent = "weapon_vape",
    model = "models/swamponions/vape.mdl",
    price = 3000,
    max = 1,
    cmd = "vape",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 100, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
customCheck = function(ply) return CLIENT or ply:IsVIP() end,
CustomCheckFailMsg = "Это только для VIP пользователей"
})

DarkRP.createEntity("VAPE Juicy", {
    ent = "weapon_vape_juicy",
    model = "models/swamponions/vape.mdl",
    price = 10000,
    max = 1,
    cmd = "vapejui",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 100, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
customCheck = function(ply) return CLIENT or ply:IsVIP() end,
CustomCheckFailMsg = "Это только для VIP пользователей"
})

DarkRP.createEntity("VAPE Hallucinogenic", {
    ent = "weapon_vape_hallucinogenic",
    model = "models/swamponions/vape.mdl",
    price = 11200,
    max = 1,
    cmd = "vapehalium",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 100, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
customCheck = function(ply) return CLIENT or ply:IsVIP() end,
CustomCheckFailMsg = "Это только для VIP пользователей"
})

DarkRP.createEntity("Броня", {
    ent = "item_battery",
    model = "models/Items/battery.mdl",
    price = 5000,
    max = 10,
    cmd = "bronaya",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Это только для VIP пользователей"
})

DarkRP.createEntity("Power Bank", {
    ent = "krede_wd_battery",
    model = "models/Items/battery.mdl",
    price = 25000,
    max = 5,
    cmd = "phonebat",
    --allowed = {TEAM_HACKER},
    customCheck = function(ply) return ply:HasWeapon('krede_wd_phone') end,
    CustomCheckFailMsg = "У тебя нет телефона хакера",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
})

DarkRP.createEntity("Гитара", {
    ent = "guitar",
    model = "models/props_phx/misc/fender.mdl",
    price = 10000,
    max = 2,
    cmd = "gitiaraaa",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
    allowed = {TEAM_GUN},
})

DarkRP.createEntity("Бомба", {
    ent = "ent_timebomb",
    model = "models/weapons/w_c4.mdl",
    price = 35000,
    max = 1,
    cmd = "bombterror",
    category = "Other", -- Название категории, в которой будет отображаться данный предмет. Учтите, что такая категория должна существовать!
    sortOrder = 1, -- Приоритет данного предмета; Чем ближе число к единице, тем выше предмет в списке
    allowed = {TEAM_BOMB},
})

--[[You can add however many you want of these if you want different tiers of money clickers.
All of them should use entity "money_clicker"
Want to limit certain upgrades to certain jobs/groups? Check the ScriptFodder description
for some examples (Lua knowledge needed! However there is two examples that does this on the page)]]


--------------------------------
--       Example Setup        --
--------------------------------
-- Bronze, Silver, Gold Tiers --
--------------------------------

DarkRP.createEntity("Бронзовый Кликер", {
    ent = "money_clicker", -- Do not change this class
    model = "models/props_c17/consolebox01a.mdl", -- Do not change this model
    price = 5000,
    max = 2,
    cmd = "buymoneyclickerbronze",
    mClickerInfo = {
        pointsPerCycle = 20,
        moneyPerCycle = 130,
        maxPoints = 25000,
        maxMoney = 500000,
        health = 100,
        indestructible = false,
        repairHealthCost = 1500,
        maxCycles = 300,
        repairBrokenCost = 1500,

        upgrades = {
            autoClick = {
                name = "Авт.Кликер",
                stats = { 1, 2, 3, 4, 5 },
                prices = { 500, 1000, 2500, 3000 },
            },
            clickPower = {
                name = "Сила Клика",
                stats = { 3, 5, 7, 10},
                prices = { 500, 1000, 2500 },
            },
            cooling = {
                name = "Охлаждение",
                stats = { 1, 2, 4, 6 },
                prices = { 350, 500, 1000, 2500 },
            },
            storage = {
                name = "Объем",
                stats = { 1.3, 1.5, 2.5, 3 },
                prices = { 350, 500, 1000, 2500 },
            },
        },

        enableHeat = true,
        heatPerClick = 20,

        colorPrimary = Color(185, 125, 0),
        colorSecondary = Color(150, 100, 0),
        colorText = Color(255, 255, 255),
        colorHealth = Color(255, 255, 255),
    },
})

DarkRP.createEntity("Серебряный Кликер", {
    ent = "money_clicker", -- Do not change this class
    model = "models/props_c17/consolebox01a.mdl", -- Do not change this model
    price = 10000,
    max = 2,
    cmd = "buymoneyclickersilver",
    mClickerInfo = {
        pointsPerCycle = 25,
        moneyPerCycle = 150,
        maxPoints = 25000,
        maxMoney = 1000000,
        health = 100,
        indestructible = false,
        repairHealthCost = 100,
        maxCycles = 400,
        repairBrokenCost = 700,

        upgrades = {
            autoClick = {
                name = "Авт.кликер",
                stats = { 2, 3, 4, 5, 6 },
                prices = { 500, 1000, 2500, 3000 },
            },
            clickPower = {
                name = "Сила Клика",
                stats = { 6, 8, 10, 12 },
                prices = { 500, 1000, 2500 },
            },
            cooling = {
                name = "Охлаждение",
                stats = { 2, 3, 5, 6.5 },
                prices = { 350, 500, 1000, 2500 },
            },
            storage = {
                name = "Объем",
                stats = { 1, 2, 3, 4 },
                prices = { 350, 500, 1000, 2500 },
            },
        },

        enableHeat = true,
        heatPerClick = 20,

        colorPrimary = Color(150, 150, 150),
        colorSecondary = Color(100, 100, 100),
        colorText = Color(255, 255, 255),
        colorHealth = Color(255, 255, 255),
    },
})

DarkRP.createEntity("Алмазный Кликер", {
    ent = "money_clicker", -- Do not change this class
    model = "models/props_c17/consolebox01a.mdl", -- Do not change this model
    price = 35000,
    max = 2,
    cmd = "buyclickergold",
    mClickerInfo = {
        pointsPerCycle = 30,
        moneyPerCycle = 160,
        maxPoints = 40000,
        maxMoney = 1500000,
        health = 100,
        indestructible = false,
        repairHealthCost = 100,
        maxCycles = 500,
        repairBrokenCost = 900,

        upgrades = {
            autoClick = {
                name = "Авт.Кликер",
                stats = { 3, 4, 5, 6, 7 },
                prices = { 500, 1000, 2500, 3000 },
            },
            clickPower = {
                name = "Сила Клика",
                stats = { 8, 10, 12, 15 },
                prices = { 500, 1000, 2500 },
            },
            cooling = {
                name = "Охлаждение",
                stats = { 3, 4, 6, 12 },
                prices = { 350, 500, 1000, 2500 },
            },
            storage = {
                name = "Объем",
                stats = { 1, 2, 3, 4 },
                prices = { 350, 500, 1000, 2500 },
            },
        },

        enableHeat = true,
        heatPerClick = 20,

        colorPrimary = Color(0, 220, 160),
        colorSecondary = Color(0, 180, 140),
        colorText = Color(255, 255, 255),
        colorHealth = Color(255, 255, 255),
    },
})

DarkRP.createEntity("Сапфировый Кликер", {
    ent = "money_clicker", -- Do not change this class
    model = "models/props_c17/consolebox01a.mdl", -- Do not change this model
    price = 50000,
    max = 2,
    cmd = "buyklickerizy",
    mClickerInfo = {
        pointsPerCycle = 35,
        moneyPerCycle = 165,
        maxPoints = 70000,
        maxMoney = 2000000,
        health = 100,
        indestructible = false,
        repairHealthCost = 100,
        maxCycles = 600,
        repairBrokenCost = 900,

        upgrades = {
            autoClick = {
                name = "Авт.Кликер",
                stats = { 4, 5, 6, 7, 8 },
                prices = { 500, 1000, 2500, 3000 },
            },
            clickPower = {
                name = "Сила Клика",
                stats = { 10, 12, 14, 16 },
                prices = { 500, 1000, 2500 },
            },
            cooling = {
                name = "Охлаждение",
                stats = { 3.5, 5, 8, 15 },
                prices = { 350, 500, 1000, 2500 },
            },
            storage = {
                name = "Объем",
                stats = { 1.5, 2.5, 3.5, 4.5 },
                prices = { 350, 500, 1000, 2500 },
            },
        },

        enableHeat = true,
        heatPerClick = 20,

        colorPrimary = Color(140, 0, 255),
        colorSecondary = Color(100, 5, 180),
        colorText = Color(255, 255, 255),
        colorHealth = Color(255, 255, 255),
    },
})

DarkRP.createEntity("Рубиновый Кликер", {
    ent = "money_clicker", -- Do not change this class
    model = "models/props_c17/consolebox01a.mdl", -- Do not change this model
    price = 100000,
    max = 2,
    cmd = "buyklickervip",
    mClickerInfo = {
        pointsPerCycle = 45,
        moneyPerCycle = 180,
        maxPoints = 50000,
        maxMoney = 5000000,
        health = 500,
        indestructible = false,
        repairHealthCost = 100,
        maxCycles = 700,
        repairBrokenCost = 900,

        upgrades = {
            autoClick = {
                name = "Авт.Кликер",
                stats = { 5, 6, 7, 8, 9 },
                prices = { 500, 1000, 2500, 3000 },
            },
            clickPower = {
                name = "Сила Клика",
                stats = { 12, 14, 16, 20 },
                prices = { 500, 1000, 2500 },
            },
            cooling = {
                name = "Охлаждение",
                stats = { 5, 6, 10, 20 },
                prices = { 350, 500, 1000, 2500 },
            },
            storage = {
                name = "Объем",
                stats = { 3, 4, 5, 6 },
                prices = { 350, 500, 1000, 2500 },
            },
        },

        enableHeat = true,
        heatPerClick = 20,

        colorPrimary = Color(210, 0, 50),
        colorSecondary = Color(190, 0, 40),
        colorText = Color(255, 255, 255),
        colorHealth = Color(255, 255, 255),
    },
    customCheck = function(ply) return CLIENT or ply:IsVIP() end,
    CustomCheckFailMsg = "Это только для VIP пользователей"
})

DarkRP.createEntity("Компьютерный Корпус", {
    ent = "bit_case",
    model = "models/computer_updated/computer.mdl",
    price = 15000,
    max = 4,
    cmd = "buycomputercase",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Cornet OS", {
    ent = "bit_cornet",
    model = "models/props_lab/binderredlabel.mdl",
    price = 1000,
    max = 4,
    cmd = "buycornetos",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Windows OS", {
    ent = "bit_windows",
    model = "models/props_lab/bindergraylabel01b.mdl",
    price = 1500,
    max = 4,
    cmd = "buywindowsos",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("CPU", {
    ent = "bit_cpu",
    model = "models/props/cs_office/computer_caseb_p4a.mdl",
    price = 2050,
    max = 4,
    cmd = "buycpu",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("GPU", {
    ent = "bit_graphiccard",
    model = "models/props/cs_office/computer_caseb_p2a.mdl",
    price = 5200,
    max = 8,
    cmd = "buygpu",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("HDD", {
    ent = "bit_harddisk",
    model = "models/props/cs_office/computer_caseb_p6b.mdl",
    price = 750,
    max = 4,
    cmd = "buyhdd",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Материнская Плата", {
    ent = "bit_motherboard",
    model = "models/props/cs_office/computer_caseb_p7a.mdl",
    price = 1500,
    max = 4,
    cmd = "buymobo",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("Блок Питания", {
    ent = "bit_powersupply",
    model = "models/props/cs_office/computer_caseb_p8a.mdl",
    price = 2500,
    max = 8,
    cmd = "buypowersupply",
    allowed = {TEAM_MINERS}
})

DarkRP.createEntity("RAM", {
    ent = "bit_ram",
    model = "models/props/cs_office/computer_caseb_p5b.mdl",
    price = 4500,
    max = 4,
    cmd = "buyram",
    allowed = {TEAM_MINERS}
})
--addons/module_wayban/lua/darkrp_modules/wayban_perma/cl_init.lua:
wayscore.AddActionButton('perma', {
    name = 'Пермабан',
    icon = 'fadmin/icons/ban',
    order = -1000,
    check = function(ply) return WayBan.config.userGroups[LocalPlayer():GetUserGroup()] end,
    callback = function(ply)
        if not IsValid(ply) then return end
    
        Derma_StringRequest('Пермабан', 'Введи ниже причину бана', '', function(text)
            RunConsoleCommand('wayban', ply:SteamID(), tostring(text))
        end)
    end,
})
--gamemodes/darkrp/entities/weapons/arrest_stick/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.PrintName = "Арестовать"
    SWEP.Slot = 1
    SWEP.SlotPos = 3
end

DEFINE_BASECLASS("stick_base")

SWEP.Instructions = "Left click to arrest\nRight click to switch batons"
SWEP.Controls = {
    {key = MOUSE_LEFT, desc = "Арестовать"},
    {key = MOUSE_RIGHT, desc = "Переключить режим"},
}
SWEP.IsDarkRPArrestStick = true

SWEP.Spawnable = true
SWEP.Category = "Запрещено"

SWEP.StickColor = Color(255, 0, 0)

SWEP.Switched = true

DarkRP.hookStub{
    name = "canArrest",
    description = "Whether someone can arrest another player.",
    parameters = {
        {
            name = "arrester",
            description = "The player trying to arrest someone.",
            type = "Player"
        },
        {
            name = "arrestee",
            description = "The player being arrested.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canArrest",
            description = "A yes or no as to whether the arrester can arrest the arestee.",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when they can't arrest the player.",
            type = "string"
        }
    },
    realm = "Server"
}

function SWEP:Deploy()
    self.Switched = true
    return BaseClass.Deploy(self)
end

function SWEP:PrimaryAttack()
    BaseClass.PrimaryAttack(self)

    if CLIENT then return end

    self:GetOwner():LagCompensation(true)
    local trace = util.QuickTrace(self:GetOwner():EyePos(), self:GetOwner():GetAimVector() * 90, {self:GetOwner()})
    self:GetOwner():LagCompensation(false)

    if IsValid(trace.Entity) and trace.Entity.onArrestStickUsed then
        trace.Entity:onArrestStickUsed(self:GetOwner())
        return
    end

    local ent = self:GetOwner():getEyeSightHitEntity(nil, nil, function(p) return p ~= self:GetOwner() and p:IsPlayer() and p:Alive() end)

    if not IsValid(ent) or (self:GetOwner():EyePos():DistToSqr(ent:GetPos()) > 8100) or not ent:IsPlayer() then
        return
    end

    local canArrest, message = hook.Call("canArrest", DarkRP.hooks, self:GetOwner(), ent)
    if not canArrest then
        if message then DarkRP.notify(self:GetOwner(), 1, 5, message) end
        return
    end

    -- Send NPCs to Jail
    if ent:IsNPC() then
        ent:SetPos(DarkRP.retrieveJailPos())
        return
    end

    ent:arrest(nil, self:GetOwner())
    DarkRP.notify(ent, 0, 20, DarkRP.getPhrase("youre_arrested_by", self:GetOwner():Nick()))
end

function SWEP:startDarkRPCommand(usrcmd)
    if game.SinglePlayer() and CLIENT then return end
    if usrcmd:KeyDown(IN_ATTACK2) then
        if not self.Switched and self:GetOwner():HasWeapon("unarrest_stick") then
            usrcmd:SelectWeapon(self:GetOwner():GetWeapon("unarrest_stick"))
        end
    else
        self.Switched = false
    end
end

--addons/weapon_climb/lua/weapons/climb_swep2/shared.lua:
SWEP.Author              = "Jonascone"
SWEP.Contact             = ""
SWEP.Purpose             = "A reiteration of the Climb SWEP."
SWEP.Instructions        = "Refer to the Workshop page!"
SWEP.Controls = {
    {key = MOUSE_LEFT, desc = "Карабкаться"},
    {key = MOUSE_RIGHT, desc = "Зацепиться"},
}
SWEP.Category            = "Запрещено"

SWEP.Spawnable                  = true
SWEP.AdminSpawnable             = false

SWEP.ViewModel                  = "models/weapons/v_pistol.mdl"
SWEP.HoldType                   = "normal"

SWEP.Primary.ClipSize           = -1
SWEP.Primary.DefaultClip        = -1
SWEP.Primary.Automatic          = false
SWEP.Primary.Ammo               = "none"

SWEP.Secondary.ClipSize         = -1
SWEP.Secondary.DefaultClip      = -1
SWEP.Secondary.Automatic        = true
SWEP.Secondary.Ammo             = "none"


local HitPlayer = { Sound("npc/vort/foot_hit.wav"), Sound("npc/zombie/zombie_hit.wav") }
local MatList = { }
MatList[67] = "concrete"
MatList[68] = "dirt"
MatList[71] = "chainlink"
MatList[76] = "tile"
MatList[77] = "metal"
MatList[78] = "dirt"
MatList[84] = "tile"
MatList[86] = "duct"
MatList[87] = "wood"

function SWEP:DrawWorldModel() return false; end

function SWEP:Initialize()
    self:SetWeaponHoldType(self.HoldType)
    self.Weapon:DrawShadow(false)
    self.nextThink = 0
    self.Jumps = 0
    self.JumpSequence = 0
    self.EasterEgg = false
    self.Released = false
    self.MFC = "male"
    self.WallJumpTrace = nil
    self.CanWallRun = true
    self.WallRunAnim = 0
    return true
end
function SWEP:Deploy()
    self:GetOwner():DrawViewModel(false)
    if string.find(self:GetOwner():GetModel(), "female") or string.find(self:GetOwner():GetModel(), "alyx") or string.find(self:GetOwner():GetModel(), "mossman") then self.MFC = "female"
    elseif string.find(self:GetOwner():GetModel(), "combine") or string.find(self:GetOwner():GetModel(), "metro") then self.MFC = "combine"
    else self.MFC = "male" end

    self:GetOwner():SetNWBool("ClimbWallJump", false)
    self:GetOwner():SetNWBool("ClimbFalling", false)
    self:GetOwner():SetNWBool("ClimbWallRun", false)
    self.Released = false
    self.CanWallRun = true;
    self.Parent = NULL;
end
function SWEP:Forget()

    if self.Grab then
        if self:GetOwner():GetMoveType() == MOVETYPE_NONE then self:GetOwner():SetMoveType(MOVETYPE_WALK) end
        self.Grab = false
        self.Parent = NULL;
    end
    return true

end
function SWEP:Think()

    if CLIENT or !IsValid(self:GetOwner()) or !self:GetOwner():Alive() then return false end

    if self.Jumps != self:GetOwner():GetNWInt("ClimbJumps") then self:GetOwner():SetNWInt("ClimbJumps", self.Jumps) end
    if !self.Released and !self:GetOwner():KeyDown(IN_ATTACK2) then
        self.Released = true
    elseif self:GetOwner():OnGround() and (self.Jumps > 0 or !self.CanWallRun) or self:GetOwner():GetNWBool("ClimbFalling") then

        self.Jumps, self.JumpSequence = 0, 0
        self.EasterEgg = false
        self.CanWallRun = true
        self:GetOwner():SetNWBool("ClimbWallJump", false)
        self:GetOwner():SetNWBool("ClimbFalling", false)

    elseif self:GetOwner():GetNWBool("ClimbWallRun") and !self.Grab then

        local traceData = {};
        traceData.start = self:GetOwner():GetPos() + Vector(0, 0, 20);
        traceData.endpos = traceData.start + self:GetOwner():GetForward() * 70;
        traceData.filter = self:GetOwner();
        local trace = util.TraceLine(traceData);

        local vel = self:GetOwner():GetVelocity();
        if !self:GetOwner():OnGround() and trace.Hit and self:GetOwner():KeyDown(IN_FORWARD) and math.abs(vel:Length()) > 100 then

            local vel = self:GetOwner():GetVelocity() + self:GetOwner():GetForward();
            vel.z = 0;
            if CurTime() > self.WallRunAnim then

                self.WallRunAnim = CurTime() + (0.2 - vel:Length() / 10000);
                self:GetOwner():ViewPunch(Angle(10, 0, 0));
                if trace.MatType == MAT_GLASS then self:GetOwner():EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
                elseif trace.MatType and MatList[trace.MatType] then self:GetOwner():EmitSound(Sound("player/footsteps/"..MatList[trace.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105)) end
                vel.z = -(100 + vel:Length());

            end
            self:GetOwner():SetLocalVelocity(vel);

        else

            self:GetOwner():SetNWBool("ClimbWallRun", false);
            self.CanWallRun = false;

        end
    elseif self:GetOwner():KeyDown(IN_FORWARD) then
        if self:GetOwner():KeyDown(IN_USE) and !self:GetOwner():OnGround() and self.CanWallRun and self.Jumps < GetConVarNumber("climbswep2_maxjumps") and !self.Grab then

            local traceData = {};
            traceData.start = self:GetOwner():GetPos();
            traceData.endpos = traceData.start - Vector(0, 0, GetConVarNumber("climbswep2_wallrun_minheight"));
            if !util.TraceLine(traceData).Hit then

                self:GetOwner():SetNWBool("ClimbWallRun", true);
                self.Jumps = self.Jumps + 1
                local vel = self:GetOwner():GetVelocity() + self:GetOwner():GetForward() * 100;
                vel.z = 0;
                self:GetOwner():SetLocalVelocity(vel);

            end
        end
    end

    if CurTime() < self.nextThink then return false end

    // For the lulz.
    if self:GetOwner():GetVelocity().z <= -900 and self:GetOwner():GetMoveType() == MOVETYPE_WALK then

        if !self:GetOwner():GetNWBool("ClimbFalling") then self:GetOwner():SetNWBool("ClimbFalling", true); self:GetOwner():SetNWBool("ClimbWallJump", false)
        elseif self:GetOwner():KeyDown(IN_JUMP) then

            self.nextThink = CurTime() + 2.5
            if self.MFC == "combine" then

                self:GetOwner():EmitSound("npc/metropolice/vo/help.wav", 125, math.random(90, 110))
                return true

            end
            self:GetOwner():EmitSound("vo/npc/"..self.MFC.."01/help01.wav", 125, math.random(90, 110))
            return true

        elseif !self.EasterEgg and math.random(1, 128) == 1 then

            self.EasterEgg = true
            if self.MFC == "combine" then self:GetOwner():EmitSound("npc/metropolice/vo/shit.wav", 100)
            else self:GetOwner():EmitSound("vo/npc/"..self.MFC.."01/gordead_ans19.wav", 100) end
            return true

        end

        return true

    elseif self:GetOwner():GetNWBool("ClimbFalling") then self:GetOwner():SetNWBool("ClimbFalling", false)
    end

    // Are we grabbing a ledge?
    if self.Grab then

        // Is it a prop?
        local physObj = NULL;
        if IsValid(self.Parent) then

            physObj = self.Parent:GetPhysicsObject();
            if physObj:IsMoveable() then
                if math.abs(self.OldVelocity - self.Parent:GetVelocity():Length()) >= 500 then
                    return false;
                end
            end

        end
        if !self:GetOwner():KeyDown(IN_FORWARD) and !self:GetOwner():KeyDown(IN_MOVELEFT) and !self:GetOwner():KeyDown(IN_MOVERIGHT) then return false
        elseif self:GetOwner():KeyDown(IN_FORWARD) then

            if self:GetOwner():KeyDown(IN_JUMP) then

                self:Forget()
                self:GetOwner():EmitSound(Sound("npc/combine_soldier/gear"..math.random(1, 6)..".wav"), 75, math.random(95, 105))
                self:GetOwner():ViewPunch(Angle(-7.5, 0, 0))
                self:GetOwner():SetLocalVelocity(self:GetOwner():GetAimVector() * 400)
                return true

            end
            return true

        end

        local Predict
        local Shift = 0
        if self:GetOwner():KeyDown(IN_SPEED) then Shift = 0.15 end
        self.nextThink = CurTime() + (0.35 - Shift)

        if self:GetOwner():KeyDown(IN_MOVELEFT) then Predict = -self:GetOwner():GetRight() * 10
        elseif self:GetOwner():KeyDown(IN_MOVERIGHT) then Predict = self:GetOwner():GetRight() * 10 end

        local tracedata = {}
        tracedata.start = self:GetOwner():GetShootPos() + Predict
        tracedata.endpos = tracedata.start + self:GetOwner():GetForward() * 40
        tracedata.filter = self:GetOwner()
        local trLo =  util.TraceLine(tracedata)

        local tracedata = {}
        tracedata.start = self:GetOwner():GetShootPos() + Vector(0, 0, 15) + Predict
        tracedata.endpos = tracedata.start + self:GetOwner():GetForward() * self:GetOwner():GetShootPos():Distance(trLo.HitPos)
        tracedata.filter = self:GetOwner()
        local trHi =  util.TraceLine(tracedata)

        if !trHi.Hit and trLo.Hit then

            self:GetOwner():SetPos(self:GetOwner():GetPos() + Predict)
            if physObj != NULL then
                self.LocalPos = self.Parent:WorldToLocal(self:GetOwner():GetPos());
            end
            if trLo.MatType == MAT_GLASS then self:GetOwner():EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
            elseif trLo.MatType and MatList[trLo.MatType] then self:GetOwner():EmitSound(Sound("player/footsteps/"..MatList[trLo.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105)) end

            if self:GetOwner():KeyDown(IN_MOVELEFT) then self:GetOwner():ViewPunch(Angle(0, 0, -2.5))
            else self:GetOwner():ViewPunch(Angle(0, 0, 2.5)) end
            return true

        end

    end

    // Wall Jumping. (In Think due to HUD Implementation)
    if self.Jumps > 0 then

        // Are we actually against a wall?
        local tracedata = { }
        local ShootPos = self:GetOwner():GetShootPos()
        local AimVector = self:GetOwner():GetAimVector()
        tracedata.start = ShootPos
        tracedata.endpos = ShootPos - AimVector*45
        tracedata.filter = self:GetOwner()

        local trace = util.TraceLine(tracedata)

        if trace.Hit and !trace.HitSky and !self:GetOwner():GetNWBool("ClimbWallJump") then

            self:GetOwner():SetNWBool("ClimbWallJump", true)

        end

    elseif self:GetOwner():GetNWBool("ClimbWallJump") then self:GetOwner():SetNWBool("ClimbWallJump", false)
    end

    return true

end
function SWEP:ShakeEffect()
    if self.JumpSequence == 0 then
        self:GetOwner():ViewPunch(Angle(0, 5, 0))
    elseif self.JumpSequence == 1 then
        self:GetOwner():ViewPunch(Angle(0, -5, 0))
    elseif self.JumpSequence == 2 then
        self:GetOwner():ViewPunch(Angle(-5, 0, 0))
    end
    self.JumpSequence = self.JumpSequence < 3 and self.JumpSequence + 1 or 0
end
function SWEP:PrimaryAttack()

    if CLIENT or self:GetOwner():GetNWBool("ClimbWallRun") then return true end

    // We'll use this trace for determining whether we're looking at a Wall!
    local tracedata = { }
    local ShootPos = self:GetOwner():GetShootPos()
    local AimVector = self:GetOwner():GetAimVector()
    tracedata.start = ShootPos
    tracedata.endpos = ShootPos + AimVector*45
    tracedata.filter = self:GetOwner()
    local trace = util.TraceLine(tracedata)

    // We'll have to be off the ground to start climbing!
    if self:GetOwner():OnGround() then

        // General Melee Functionality

        self:SetNextPrimaryFire(CurTime() + 0.4)

        if !trace.Hit or trace.HitWorld or trace.HitSky then

            self:GetOwner():EmitSound(Sound("npc/fast_zombie/claw_miss"..math.random(1, 2)..".wav"), 75)
            return false

        end

        if IsValid(trace.Entity) then

            if !trace.Entity:IsWorld() then

                if GetConVarNumber("climbswep2_necksnaps") == 1 and (trace.Entity:IsPlayer() or trace.Entity:IsNPC()) and trace.Entity:GetAimVector():DotProduct(self:GetOwner():GetAimVector()) > 0.6 then

                    if trace.Entity:IsPlayer() then

                        if GetConVarNumber("sbox_playershurtplayers") <= 0 then return false end
                        trace.Entity:Kill()
                        self:GetOwner():AddFrags(1)
                        self:GetOwner():EmitSound(Sound("physics/body/body_medium_break"..math.random(3, 4)..".wav"), 80, math.random(95, 105))
                        return true

                    else

                        trace.Entity:TakeDamage(trace.Entity:Health(), self:GetOwner(), self)
                        self:GetOwner():AddFrags(1)
                        self:GetOwner():EmitSound(Sound("physics/body/body_medium_break"..math.random(3, 4)..".wav"), 80, math.random(95, 105))
                        return true

                    end

                    return true

                elseif trace.Entity:IsPlayer() then

                    --trace.Entity:ViewPunch(Angle(-25, 20, 0))
                    if trace.Entity:GetActiveWeapon().Grab then trace.Entity:GetActiveWeapon().Grab = false end

                elseif trace.Entity:IsNPC() then
                    trace.Entity:TakeDamage(10, self:GetOwner(), self)
                end
                if (IsValid(trace.Entity:GetPhysicsObject())) then
                    trace.Entity:GetPhysicsObject():ApplyForceOffset((trace.HitPos-self:GetOwner():EyePos())*128, trace.HitPos)
                end
                self:GetOwner():EmitSound(table.Random(HitPlayer), 80, math.random(95, 105))
                return true

            end

        end

        return false

    end

    // Are we grabbing?
    if self.Grab then

        // If so, we'll want to reset our variables!
        self:Forget()

        // Now, run up that wall!
        self:GetOwner():ViewPunch(Angle(-15, self:GetOwner():EyeAngles().yaw/32, 0))
        self:GetOwner():EmitSound(Sound("player/suit_sprint.wav"), 80, math.random(95, 105))
        self:GetOwner():SetVelocity(-self:GetOwner():GetVelocity() + Vector(0, 0, 250))
        self:SetNextPrimaryFire(CurTime() + 0.15)
        return true

    end

    // Wall Jumping. (Code in Think due to HUD Implementation)
    if self:GetOwner():GetNWBool("ClimbWallJump") then

        // We can Wall Jump!
        self.CanWallRun = true;
        self.Jumps = 0
        self:GetOwner():SetLocalVelocity(self:GetOwner():GetAimVector() * 300)
        self:GetOwner():EmitSound(Sound("npc/combine_soldier/gear"..math.random(1, 6)..".wav"), 75, math.random(95, 105))
        self:GetOwner():ViewPunch(Angle(-7.5, 0, 0))
        return true

    end

    // Are we close enough to start climbing?
    if ( (self.Jumps == 0 and trace.HitPos:Distance(ShootPos) > 40) or self.Jumps > (GetConVarNumber("climbswep2_maxjumps") - 1) or trace.HitSky) then return false end

    // If we've mysteriously lost the wall we'll want to stop climbing!
    if !trace.Hit then return false end

    if self:GetOwner():GetVelocity().z <= -750 then

        self:SetNextPrimaryFire(CurTime() + 1)
        self:GetOwner():EmitSound("ambient/levels/canals/toxic_slime_sizzle4.wav", 50, 200)

        if self.MFC == "combine" then self:GetOwner():EmitSound("npc/metropolice/knockout2.wav", 125)
        else self:GetOwner():EmitSound("vo/npc/"..self.MFC.."01/ow0"..math.random(1, 2)..".wav", 125) end

        return true

    end

    // Add some effects.
    if trace.MatType == MAT_GLASS then self:GetOwner():EmitSound(Sound("physics/glass/glass_sheet_step"..math.random(1, 4)..".wav"), 75, math.random(95, 105))
    elseif trace.MatType and MatList[trace.MatType] then self:GetOwner():EmitSound(Sound("player/footsteps/"..MatList[trace.MatType]..math.random(1, 4)..".wav"), 75, math.random(95, 105))
    else self:GetOwner():EmitSound(Sound("npc/fast_zombie/claw_miss"..math.random(1, 2)..".wav"), 75, math.random(95, 105)) end

    // Climb the wall and modify our jump count.

    local Vel = self:GetOwner():GetVelocity()
    self:GetOwner():SetVelocity(Vector(0, 0, 240 - 15 * 1 + self.JumpSequence - Vel.z))
    self:SetNextPrimaryFire(CurTime() + 0.15)
    self.Jumps = self.Jumps + 1
    self:ShakeEffect()
    return true

end
function SWEP:CanGrab() -- This too, but modified it somewhat.

    // We'll detect whether we can grab onto the ledge.
    local trace = {}
    trace.start = self:GetOwner():GetShootPos() + Vector( 0, 0, 15 )
    trace.endpos = trace.start + self:GetOwner():GetAimVector() * 30
    trace.filter = self:GetOwner()

    local trHi = util.TraceLine(trace)

    local trace = {}
    trace.start = self:GetOwner():GetShootPos()
    trace.endpos = trace.start + self:GetOwner():GetAimVector() * 30
    trace.filter = self:GetOwner()

    local trLo = util.TraceLine(trace)

    // Is the ledge actually grabbable?
    if trLo and trHi and trLo.Hit and !trHi.Hit then
        return {true, trLo}
    else
        return {false, trLo}
    end

end
function SWEP:SecondaryAttack()

    if CLIENT then return true end

    if !self.Released then return end

    if self:GetOwner():OnGround() then return false end // We don't want to grab onto a ledge if we're on the ground!

    // If we're already grabbing something, we want to let go!
    if self.Grab then
        self:Forget()
        self.Released = false
        return false
    end

    // Returns whether we can grab(boolean) and a traceres.
    local Grab = self:CanGrab()

    // If we can't grab we're done here.
    if !Grab[1] then
        return false
    end

    // Otherwise reset our jumps and enter ledge holding mode!
    self.Jumps = 0
    self.Grab  = true
    self.Released = false
    local VelZ = self:GetOwner():GetVelocity().z;
    self:GetOwner():ViewPunch(Angle(math.max(15, math.min(30, VelZ)) * (VelZ > 0 and 1 or -1), 0, 0));
    self:GetOwner():SetLocalVelocity(Vector(0, 0, 0))
    self:GetOwner():SetMoveType(MOVETYPE_NONE)
    self:GetOwner():EmitSound(Sound("physics/flesh/flesh_impact_hard"..math.random(1, 3)..".wav"), 75)

    // Are we looking at a valid entity?
    if IsValid(Grab[2].Entity) then

        // Does the prop/entity use valid prop-like behaviour?
        if Grab[2].Entity:GetMoveType() == MOVETYPE_VPHYSICS then

            // Then we can grab onto it!
            self.OldVelocity      = Grab[2].Entity:GetVelocity():Length()
            self.Parent           = Grab[2].Entity
            self.LocalPos       = Grab[2].Entity:WorldToLocal(self:GetOwner():GetPos())
        end

    end

    local ClimbSwep = self
    local Ply = self:GetOwner();
    local superid = Ply:UniqueID()
    local Forget = function()
        self:Forget();
        hook.Remove("Think", "ClimbGrab"..superid)
    end
    local IsOneHanded = function()

        if !IsValid(Ply:GetActiveWeapon()) then return false end

        local Weps = {climb_swep2 = true, weapon_pistol = true, weapon_357 = true, weapon_crowbar = true, weapon_frag = true}
        local HoldTypes = {pistol = true, grenade = true, knife = true}
        local Wep = Ply:GetActiveWeapon()
        if Weps[Wep:GetClass()] then return true
        elseif HoldTypes[Wep.HoldType] then return true end
        return false

    end



    local ThinkFunction = function()

     if !IsValid(Ply) then hook.Remove("Think", "ClimbGrab"..superid) return end
     if!Ply:Alive() then hook.Remove("Think", "ClimbGrab"..superid);
        elseif !ClimbSwep.Grab or Ply:GetMoveType() != MOVETYPE_NONE then Forget(); return
        elseif !IsOneHanded() then Forget();
            return
        elseif IsValid(ClimbSwep.Parent) then

            if ClimbSwep.Parent:GetPhysicsObject():IsMoveable() then

                if math.abs(ClimbSwep.OldVelocity - ClimbSwep.Parent:GetVelocity():Length()) >= 500 then Forget()
                else

                    ClimbSwep.OldVelocity = ClimbSwep.Parent:GetVelocity():Length()
                    Ply:SetLocalVelocity(Vector(0, 0, 0))
                    Ply:SetPos(ClimbSwep.Parent:LocalToWorld(ClimbSwep.LocalPos))
                    return

                end

            end

        end

    end
    hook.Add("Think", "ClimbGrab"..superid, ThinkFunction)
    return true

end
function SWEP:DrawHUD()

    if SERVER or GetConVarNumber("climbswep2_showhud") == 0 then return false end

    /*
        We can't make use of the variables the SERVER has indexed.
        Instead we'll make use of Networked Variables, available to both
        the CLIENT and the SERVER.
    */

    local Jumps, MaxJumps = LocalPlayer():GetNWInt("ClimbJumps"), GetConVarNumber("climbswep2_maxjumps")
    local Width, Height = 256, 18


    // Draw Jump-Monitor
    draw.RoundedBox(4, ScrW() / 2 - Width / 2, ScrH() - Height * 2, Width, Height, Color( 236, 113, 73, 122))
    if (MaxJumps - Jumps) > 0 then draw.RoundedBox(4, ScrW() / 2 - Width / 2, ScrH() - Height * 2, Width * (MaxJumps - Jumps) / MaxJumps, Height, Color( 236, 113, 73, 255)) end
    draw.DrawText("Прыжки: "..(MaxJumps - Jumps).." из "..GetConVarNumber("climbswep2_maxjumps"), "Default", ScrW() / 2, ScrH() - 33, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER)

    // Draw Custom HUD Icons
    if LocalPlayer():GetNWBool("ClimbWallJump") then

        surface.SetDrawColor(Color( 236, 113, 73, 255))
        surface.DrawRect(ScrW() / 2 - 8, ScrH() - Height * 2 - 36, 8, 32)
        surface.SetTexture(surface.GetTextureID("gui/arrow.vmt"))
        surface.DrawTexturedRectRotated(ScrW() / 2 + 9, ScrH() - Height * 2 - 22, 30, 30, -60)
        surface.SetDrawColor(Color(255, 255, 255, 255))

    elseif LocalPlayer():GetNWBool("ClimbFalling") then

        surface.SetDrawColor(Color( 236, 113, 73, 255))
        surface.DrawRect(ScrW() / 2 - 16, ScrH() - Height * 2 - 12, 32, 8)
        surface.SetTexture(surface.GetTextureID("gui/arrow.vmt"))
        surface.DrawTexturedRectRotated(ScrW() / 2, ScrH() - Height * 2 - 28, 30, 30, 180)
        surface.SetDrawColor(Color(255, 255, 255, 255))

    end

end
--addons/weapon_knifecsgo/lua/weapons/csgo_falchion.lua:
if not file.Exists( "weapons/csgo_baseknife.lua", "LUA" ) then
  SWEP.Spawnable = false
  print( "csgo_falchion failed to initialize: csgo_baseknife.lua not found. Did you install the main part?" )
  return
end

local TTT = ( GAMEMODE_NAME == "terrortown" or cvars.Bool("csgo_knives_force_ttt", false) )

DEFINE_BASECLASS( "csgo_baseknife" )

if ( SERVER ) then
  SWEP.Weight         = 5
  SWEP.AutoSwitchTo   = false
  SWEP.AutoSwitchFrom = false

  if TTT then
    SWEP.EquipMenuData = nil
  end
end

if ( CLIENT ) then
  SWEP.Slot         = TTT and 6 or 2
  SWEP.SlotPos      = 0
end

SWEP.PrintName      = "Нож Falchion"
SWEP.Category       = "Запрещено"

SWEP.Spawnable      = false
SWEP.AdminSpawnable = true

SWEP.ViewModel      = "models/weapons/v_csgo_falchion.mdl"
SWEP.WorldModel     = "models/weapons/w_csgo_falchion.mdl"

SWEP.SkinIndex      = 0
SWEP.PaintMaterial  = nil
SWEP.AreDaggers     = false

util.PrecacheModel( SWEP.ViewModel )
util.PrecacheModel( SWEP.WorldModel )

-- TTT config values

-- Kind specifies the category this weapon is in. Players can only carry one of
-- each. Can be: WEAPON_... MELEE, PISTOL, HEAVY, NADE, CARRY, EQUIP1, EQUIP2 or ROLE.
-- Matching SWEP.Slot values: 0      1       2     3      4      6       7        8
SWEP.Kind = WEAPON_EQUIP

-- If AutoSpawnable is true and SWEP.Kind is not WEAPON_EQUIP1/2, then this gun can
-- be spawned as a random weapon.
SWEP.AutoSpawnable = false

-- The AmmoEnt is the ammo entity that can be picked up when carrying this gun.
-- SWEP.AmmoEnt = "item_ammo_smg1_ttt"

-- CanBuy is a table of ROLE_* entries like ROLE_TRAITOR and ROLE_DETECTIVE. If
-- a role is in this table, those players can buy this.
SWEP.CanBuy = nil

-- InLoadoutFor is a table of ROLE_* entries that specifies which roles should
-- receive this weapon as soon as the round starts. In this case, none.
SWEP.InLoadoutFor = nil

-- If LimitedStock is true, you can only buy one per round.
SWEP.LimitedStock = false

-- If AllowDrop is false, players can't manually drop the gun with Q
SWEP.AllowDrop = true

-- If IsSilent is true, victims will not scream upon death.
SWEP.IsSilent = true

-- If NoSights is true, the weapon won't have ironsights
SWEP.NoSights = true

-- This sets the icon shown for the weapon in the DNA sampler, search window,
-- equipment menu (if buyable), etc.
SWEP.Icon = "vgui/entities/csgo_falchion.vmt"

--addons/weapon_shield/lua/weapons/fridge_shield/shared.lua:
SWEP.PrintName = 'Старый щит из двери'
SWEP.Author	= 'doxzter'
SWEP.Instructions = ''
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Толкнуть"},
}
SWEP.Spawnable = true
SWEP.AdminOnly = true

SWEP.ViewModel = ''
SWEP.WorldModel = 'models/props_interiors/refrigeratorDoor01a.mdl'

SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom	= false

SWEP.Slot = 3
SWEP.SlotPos = 3
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false

SWEP.Category = 'Запрещено'
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = 'none'
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = 'none'

SWEP.ShieldHealth = 100


function SWEP:Initialize()
	self:SetHoldType('melee2')
	--self:SetVar('restricted_to_drop', true)
end

function SWEP:ItemStoreGetDescription(item)
    return ('Прочность: %s%%'):format(item:GetData('ShieldHealth', 100))
end
--addons/weapon_shield/lua/weapons/fridge_shield_unbreakable/shared.lua:
SWEP.PrintName = 'Щит из двери'
SWEP.Author	= 'doxzter'
SWEP.Instructions = ''
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Толкнуть"},
}
SWEP.Spawnable = true
SWEP.AdminOnly = true

SWEP.ViewModel = ''
SWEP.WorldModel = 'models/props_interiors/refrigeratorDoor01a.mdl'

SWEP.AutoSwitchTo = false
SWEP.AutoSwitchFrom	= false

SWEP.Slot = 3
SWEP.SlotPos = 3
SWEP.DrawAmmo = false
SWEP.DrawCrosshair = false

SWEP.Category = 'Запрещено'
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = 'none'
SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = 'none'

function SWEP:Initialize()
	self:SetHoldType('melee2')
end
--gamemodes/darkrp/entities/weapons/gmod_tool/ghostentity.lua:

--[[---------------------------------------------------------
	Starts up the ghost entity
	The most important part of this is making sure it gets deleted properly
-----------------------------------------------------------]]
function ToolObj:MakeGhostEntity( model, pos, angle )

	util.PrecacheModel( model )

	-- We do ghosting serverside in single player
	-- It's done clientside in multiplayer
	if ( SERVER && !game.SinglePlayer() ) then return end
	if ( CLIENT && game.SinglePlayer() ) then return end

	-- The reason we need this is because in multiplayer, when you holster a tool serverside,
	-- either by using the spawnnmenu's Weapons tab or by simply entering a vehicle,
	-- the Think hook is called once after Holster is called on the client, recreating the ghost entity right after it was removed.
	if ( !IsFirstTimePredicted() ) then return end

	-- Release the old ghost entity
	self:ReleaseGhostEntity()

	-- Don't allow ragdolls/effects to be ghosts
	if ( !util.IsValidProp( model ) ) then return end

	if ( CLIENT ) then
		self.GhostEntity = ents.CreateClientProp( model )
	else
		self.GhostEntity = ents.Create( "prop_physics" )
	end

	-- If there's too many entities we might not spawn..
	if ( !IsValid( self.GhostEntity ) ) then
		self.GhostEntity = nil
		return
	end

	self.GhostEntity:SetModel( model )
	self.GhostEntity:SetPos( pos )
	self.GhostEntity:SetAngles( angle )
	self.GhostEntity:Spawn()

	-- We do not want physics at all
	self.GhostEntity:PhysicsDestroy()

	-- SOLID_NONE causes issues with Entity.NearestPoint used by Wheel tool
	--self.GhostEntity:SetSolid( SOLID_NONE )
	self.GhostEntity:SetMoveType( MOVETYPE_NONE )
	self.GhostEntity:SetNotSolid( true )
	self.GhostEntity:SetRenderMode( RENDERMODE_TRANSCOLOR )
	self.GhostEntity:SetColor( Color( 255, 255, 255, 150 ) )

end

--[[---------------------------------------------------------
	Starts up the ghost entity
	The most important part of this is making sure it gets deleted properly
-----------------------------------------------------------]]
function ToolObj:StartGhostEntity( ent )

	-- We do ghosting serverside in single player
	-- It's done clientside in multiplayer
	if ( SERVER && !game.SinglePlayer() ) then return end
	if ( CLIENT && game.SinglePlayer() ) then return end

	self:MakeGhostEntity( ent:GetModel(), ent:GetPos(), ent:GetAngles() )

end

--[[---------------------------------------------------------
	Releases up the ghost entity
-----------------------------------------------------------]]
function ToolObj:ReleaseGhostEntity()

	if ( self.GhostEntity ) then
		if ( !IsValid( self.GhostEntity ) ) then self.GhostEntity = nil return end
		self.GhostEntity:Remove()
		self.GhostEntity = nil
	end

	-- This is unused!
	if ( self.GhostEntities ) then

		for k, v in pairs( self.GhostEntities ) do
			if ( IsValid( v ) ) then v:Remove() end
			self.GhostEntities[ k ] = nil
		end

		self.GhostEntities = nil
	end

	-- This is unused!
	if ( self.GhostOffset ) then

		for k, v in pairs( self.GhostOffset ) do
			self.GhostOffset[ k ] = nil
		end

	end

end

--[[---------------------------------------------------------
	Update the ghost entity
-----------------------------------------------------------]]
function ToolObj:UpdateGhostEntity()

	if ( self.GhostEntity == nil ) then return end
	if ( !IsValid( self.GhostEntity ) ) then self.GhostEntity = nil return end

	local trace = self:GetOwner():GetEyeTrace()
	if ( !trace.Hit ) then return end

	local Ang1, Ang2 = self:GetNormal( 1 ):Angle(), ( trace.HitNormal * -1 ):Angle()
	local TargetAngle = self:GetEnt( 1 ):AlignAngles( Ang1, Ang2 )

	self.GhostEntity:SetPos( self:GetEnt( 1 ):GetPos() )
	self.GhostEntity:SetAngles( TargetAngle )

	local TranslatedPos = self.GhostEntity:LocalToWorld( self:GetLocalPos( 1 ) )
	local TargetPos = trace.HitPos + ( self:GetEnt( 1 ):GetPos() - TranslatedPos ) + trace.HitNormal

	self.GhostEntity:SetPos( TargetPos )

end

--addons/tool_duplicator/lua/weapons/gmod_tool/stools/advdupe2.lua:
--[[
	Title: Adv. Dupe 2 Tool

	Desc: Defines the AD2 tool and assorted functionalities.

	Author: TB

	Version: 1.0
]]

TOOL.Category = "VIP"
TOOL.Name = "#Tool.advdupe2.name"
cleanup.Register( "AdvDupe2" )
require( "controlpanel" )

if(SERVER) then
	CreateConVar("sbox_maxgmod_contr_spawners",5)

	local phys_constraint_system_types = {
		Weld          = true,
		Rope          = true,
		Elastic       = true,
		Slider        = true,
		Axis          = true,
		AdvBallsocket = true,
		Motor         = true,
		Pulley        = true,
		Ballsocket    = true,
		Winch         = true,
		Hydraulic     = true,
		WireMotor     = true,
		WireHydraulic = true
	}
	--Orders constraints so that the dupe uses as little constraint systems as possible
	local function GroupConstraintOrder( ply, constraints )
		--First separate the nocollides, sorted, and unsorted constraints
		local sorted, unsorted = {}, {}
		for k, v in pairs(constraints) do
			if phys_constraint_system_types[v.Type] then
				sorted[#sorted+1] = v
			else
				unsorted[#unsorted+1] = v
			end
		end

		local sortingSystems = {}
		local fullSystems = {}
		local function buildSystems(input)
			while next(input) ~= nil do
				for k, v in pairs(input) do
					for systemi, system in pairs(sortingSystems) do
						for _, target in pairs(system) do
							for x = 1, 4 do
								if v.Entity[x] then
									for y = 1, 4 do
										if target.Entity[y] and v.Entity[x].Index == target.Entity[y].Index then
											system[#system + 1] = v
											if #system == 100 then
												fullSystems[#fullSystems + 1] = system
												table.remove(sortingSystems, systemi)
											end
											input[k] = nil
											goto super_loopbreak
										end
									end
								end
							end
						end
					end
				end

				--Normally skipped by the goto unless no cluster is found. If so, make a new one.
				local k = next(input)
				sortingSystems[#sortingSystems + 1] = {input[k]}
				input[k] = nil

				::super_loopbreak::
			end
		end
		buildSystems(sorted)

		local ret = {}
		for _, system in pairs(fullSystems) do
			for _, v in pairs(system) do
				ret[#ret + 1] = v
			end
		end
		for _, system in pairs(sortingSystems) do
			for _, v in pairs(system) do
				ret[#ret + 1] = v
			end
		end
		for k, v in pairs(unsorted) do
			ret[#ret + 1] = v
		end

		if #fullSystems ~= 0 then
			ply:ChatPrint("DUPLICATOR: WARNING, Number of constraints exceeds 100: (".. #ret .."). Constraint sorting might not work as expected.")
		end

		return ret
	end

	local function CreationConstraintOrder( constraints )
		local ret = {}
		for k, v in pairs( constraints ) do
			ret[#ret + 1] = k
		end
		table.sort(ret)
		for i = 1, #ret do
			ret[i] = constraints[ret[i]]
		end
		return ret
	end

	local function GetSortedConstraints( ply, constraints )
		if ply:GetInfo("advdupe2_sort_constraints") ~= "0" then
			return GroupConstraintOrder( ply, constraints )
		else
			return CreationConstraintOrder( constraints )
		end
	end

	local areacopy_classblacklist = {
		gmod_anchor = true
	}

	local function PlayerCanDupeCPPI(ply, ent)
		if not AdvDupe2.duplicator.IsCopyable(ent) or areacopy_classblacklist[ent:GetClass()] then return false end
		return ent:CPPIGetOwner()==ply
	end

	-- Code from WireLib.CanTool
	local zero = Vector(0, 0, 0)
	local norm = Vector(1, 0, 0)

	local tr = { ---@type TraceResult
		Hit = true, HitNonWorld = true, HitNoDraw = false, HitSky = false, AllSolid = true,
		HitNormal = zero, Normal = norm,

		Fraction = 1, FractionLeftSolid = 0,
		HitBox = 0, HitGroup = 0, HitTexture = "**studio**",
		MatType = 0, PhysicsBone = 0, SurfaceProps = 0, DispFlags = 0, Contents = 0,

		Entity = NULL, HitPos = zero, StartPos = zero,
	}

	local function PlayerCanDupeTool(ply, ent)
		if not AdvDupe2.duplicator.IsCopyable(ent) or areacopy_classblacklist[ent:GetClass()] then return false end

		local pos = ent:GetPos()
		tr.Entity, tr.HitPos, tr.StartPos = ent, pos, pos

		return hook.Run( "CanTool", ply, tr, "advdupe2" ) ~= false
	end

	--Find all the entities in a box, given the adjacent corners and the player
	local function FindInBox(min, max, ply)
		local PPCheck = (tobool(ply:GetInfo("advdupe2_copy_only_mine")) and ply.CPPIGetOwner~=nil) and PlayerCanDupeCPPI or PlayerCanDupeTool
		local EntTable = {}
		for _, ent in ents.Iterator() do
			local pos = ent:GetPos()
			if (pos.X>=min.X) and (pos.X<=max.X) and
				 (pos.Y>=min.Y) and (pos.Y<=max.Y) and
				 (pos.Z>=min.Z) and (pos.Z<=max.Z) and PPCheck( ply, ent ) then
				EntTable[ent:EntIndex()] = ent
			end
		end

		return EntTable
	end

	--[[
		Name: GetDupeAngleOffset
		Desc: Retrieves duplication angle offsets from player
		Returns: <angle> Created angle
	]]
	local function GetDupeAngleOffset(ply)
		local p = math.Clamp(ply:GetInfoNum("advdupe2_offset_pitch", 0), -180, 180)
		local y = math.Clamp(ply:GetInfoNum("advdupe2_offset_yaw"  , 0), -180, 180)
		local r = math.Clamp(ply:GetInfoNum("advdupe2_offset_roll" , 0), -180, 180)
		return Angle(p, y, r)
	end

	--[[
		Name: GetDupeElevation
		Desc: Retrieves duplication Z elevation
		Returns: <number> Dupe elevation
	]]
	local function GetDupeElevation(ply)
		local con = ply:GetInfoNum("advdupe2_offset_z", 0)
		local enz = (tonumber(ply.AdvDupe2.HeadEnt.Z) or 0)
		return math.Clamp(con + enz, -32000, 32000)
	end

	--[[
		Name: LeftClick
		Desc: Defines the tool's behavior when the player left-clicks.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:LeftClick( trace )
		if(not trace) then return false end

		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if ply:GetUserGroup() == "user" then ply:ChatPrint("Доступно только VIP и выше") return false end

		if not (dupe and dupe.Entities) then return false end

		if(dupe.Pasting or dupe.Downloading) then
			AdvDupe2.Notify(ply,"Advanced Duplicator 2 is busy.",NOTIFY_ERROR)
			return false
		end

		dupe.Angle = GetDupeAngleOffset(ply)
		dupe.Position = Vector(trace.HitPos)
		dupe.Position.z = dupe.Position.z + GetDupeElevation(ply)

		if(tobool(ply:GetInfo("advdupe2_offset_world"))) then
			dupe.Angle = dupe.Angle - dupe.Entities[dupe.HeadEnt.Index].PhysicsObjects[0].Angle
		end

		dupe.Pasting = true
		AdvDupe2.Notify(ply,"Pasting...")
		local origin
		if(tobool(ply:GetInfo("advdupe2_original_origin"))) then
			origin = dupe.HeadEnt.Pos
		end

		AdvDupe2.InitPastingQueue(ply, dupe.Position, dupe.Angle, origin,
			tobool(ply:GetInfo("advdupe2_paste_constraints")),
			tobool(ply:GetInfo("advdupe2_paste_parents")),
			tobool(ply:GetInfo("advdupe2_paste_disparents")),
			tobool(ply:GetInfo("advdupe2_paste_protectoveride")))

		return true
	end

	--[[
		Name: RightClick
		Desc: Defines the tool's behavior when the player right-clicks.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:RightClick( trace )
		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end
		if ply:GetUserGroup() == "user" then ply:ChatPrint("Доступно только VIP и выше") return false end

		if(dupe.Pasting or dupe.Downloading) then
			AdvDupe2.Notify(ply,"Advanced Duplicator 2 is busy.", NOTIFY_ERROR)
			return false
		end

		--Set Area Copy on or off
		if( ply:KeyDown(IN_SPEED) and not ply:KeyDown(IN_WALK) ) then
			if(self:GetStage()==0) then
				AdvDupe2.DrawSelectBox(ply)
				self:SetStage(1)
				return false
			elseif(self:GetStage()==1) then
				AdvDupe2.RemoveSelectBox(ply)
				self:SetStage(0)
				return false
			end
		end

		if(not trace or not trace.Hit) then return false end

		local Entities, Constraints, AddOne
		local HeadEnt = {}
		--If area copy is on
		if(self:GetStage()==1) then
			local area_size = math.Clamp(tonumber(ply:GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)
			local Pos = trace.HitNonWorld and trace.Entity:GetPos() or trace.HitPos
			local T = (Vector(area_size,area_size,area_size)+Pos)
			local B = (Vector(-area_size,-area_size,-area_size)+Pos)

			local Ents = FindInBox(B,T, ply)
			local _, Ent = next(Ents)
			if not Ent then
				self:SetStage(0)
				AdvDupe2.RemoveSelectBox(ply)
				return true
			end

			Ent = trace.HitNonWorld and trace.Entity or Ent
			HeadEnt.Index = Ent:EntIndex()
			HeadEnt.Pos = Ent:GetPos()

			Entities, Constraints = AdvDupe2.duplicator.AreaCopy(ply, Ents, HeadEnt.Pos, tobool(ply:GetInfo("advdupe2_copy_outside")))

			self:SetStage(0)
			AdvDupe2.RemoveSelectBox(ply)
		elseif trace.HitNonWorld then	--Area Copy is off
			-- Filter duplicator blocked entities out.
			if not AdvDupe2.duplicator.IsCopyable( trace.Entity ) then
				return false
			end

			--If Alt is being held, add a prop to the dupe
			if(ply:KeyDown(IN_WALK) and dupe.Entities~=nil and next(dupe.Entities)~=nil) then
				Entities = dupe.Entities
				Constraints = dupe.Constraints
				HeadEnt = dupe.HeadEnt

				AdvDupe2.duplicator.Copy( ply, trace.Entity, Entities, Constraints, HeadEnt.Pos)

				--Only add the one ghost
				AddOne = Entities[trace.Entity:EntIndex()]
			else
				Entities = {}
				Constraints = {}
				HeadEnt.Index = trace.Entity:EntIndex()
				HeadEnt.Pos = trace.HitPos

				AdvDupe2.duplicator.Copy( ply, trace.Entity, Entities, Constraints, trace.HitPos )
			end
		else --Non valid entity or clicked the world
			if dupe.Entities then
				--clear the dupe
				net.Start("AdvDupe2_RemoveGhosts")
				net.Send(ply)
				dupe.Entities = nil
				dupe.Constraints = nil
				net.Start("AdvDupe2_ResetDupeInfo")
				net.Send(ply)
				AdvDupe2.ResetOffsets(ply)
				return true
			else
				--select all owned props
				Entities = {}
				local PPCheck = (tobool(ply:GetInfo("advdupe2_copy_only_mine")) and CPPI~=nil) and PlayerCanDupeCPPI or PlayerCanDupeTool
				for _, ent in ents.Iterator() do
					if PPCheck( ply, ent ) then
						Entities[ent:EntIndex()] = ent
					end
				end

				local _, Ent = next(Entities)
				if not Ent then
				net.Start("AdvDupe2_RemoveGhosts")
				net.Send(ply)
					return true
				end

				HeadEnt.Index = Ent:EntIndex()
				HeadEnt.Pos = Ent:GetPos()

				Entities, Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, HeadEnt.Pos, tobool(ply:GetInfo("advdupe2_copy_outside")))
			end
		end

		if not HeadEnt.Z then
			local WorldTrace = util.TraceLine({
				mask   = MASK_NPCWORLDSTATIC,
				start  = HeadEnt.Pos + Vector(0,0,1),
				endpos = HeadEnt.Pos-Vector(0,0,50000)
			})

			HeadEnt.Z = WorldTrace.Hit and math.abs(HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
		end

		dupe.HeadEnt = HeadEnt
		dupe.Entities = Entities
		dupe.Constraints = GetSortedConstraints(ply, Constraints)
		dupe.Revision = AdvDupe2.CodecRevision

		net.Start("AdvDupe2_SetDupeInfo")
			net.WriteString("")
			net.WriteString(ply:Nick())
			net.WriteString(os.date("%d %B %Y"))
			net.WriteString(os.date("%I:%M %p"))
			net.WriteString("")
			net.WriteString("")
			net.WriteString(table.Count(dupe.Entities))
			net.WriteString(#dupe.Constraints)
		net.Send(ply)

		if AddOne then
			AdvDupe2.SendGhost(ply, AddOne)
		else
			AdvDupe2.SendGhosts(ply)
		end

		AdvDupe2.ResetOffsets(ply)

		return true
	end

	--Checks table, re-draws loading bar, and recreates ghosts when tool is pulled out
	function TOOL:Deploy()
		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(not dupe.Entities) then return end

		net.Start("AdvDupe2_StartGhosting")
		net.Send(ply)

		if(dupe.Queued) then
			AdvDupe2.InitProgressBar(ply, "Queued: ")
			return
		end

		if(dupe.Pasting) then
			AdvDupe2.InitProgressBar(ply, "Pasting: ")
			return
		else
			if(dupe.Uploading) then
				AdvDupe2.InitProgressBar(ply, "Opening: ")
				return
			elseif(dupe.Downloading) then
				AdvDupe2.InitProgressBar(ply, "Saving: ")
				return
			end
		end

	end

	--Removes progress bar
	function TOOL:Holster()
		AdvDupe2.RemoveProgressBar(self:GetOwner())
	end

	--[[
		Name: Reload
		Desc: Creates an Advance Contraption Spawner.
		Params: <trace> trace
		Returns: <boolean> success
	]]
	function TOOL:Reload( trace )
		if(not trace.Hit) then return false end

		local ply = self:GetOwner()
		local dupe = ply.AdvDupe2

		if not dupe then dupe = {}; ply.AdvDupe2 = dupe end

		if(self:GetStage()==1) then
			local areasize = math.Clamp(tonumber(ply:GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)
			net.Start("AdvDupe2_CanAutoSave")
				net.WriteVector(trace.HitPos)
				net.WriteFloat(areasize)
				if(trace.Entity) then
					net.WriteUInt(trace.Entity:EntIndex(), 16)
				else
					net.WriteUInt(0, 16)
				end
			net.Send(ply)
			self:SetStage(0)
			AdvDupe2.RemoveSelectBox(ply)
			dupe.TempAutoSavePos = trace.HitPos
			dupe.TempAutoSaveSize = areasize
			dupe.TempAutoSaveOutSide = tobool(ply:GetInfo("advdupe2_copy_outside"))
			return true
		end

		--If a contraption spawner was clicked then update it with the current settings
		if(trace.Entity:GetClass()=="gmod_contr_spawner") then
			local delay = tonumber(ply:GetInfo("advdupe2_contr_spawner_delay"))
			local undo_delay = tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_delay"))
			local min
			local max
			if(not delay) then
				delay = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
			else
				if(not game.SinglePlayer()) then
					min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
					if (delay < min) then
						delay = min
					end
				elseif(delay<0) then
					delay = 0
				end
			end

			if(not undo_delay) then
				undo_delay = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay"))
			else
				if(not game.SinglePlayer()) then
					min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 0.1
					max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
					if(undo_delay < min) then
						undo_delay = min
					elseif(undo_delay > max) then
						undo_delay = max
					end
				elseif(undo_delay < 0) then
					undo_delay = 0
				end
			end

			trace.Entity:GetTable():SetOptions(
				ply, delay, undo_delay,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disgrav")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disdrag")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_addvel")) or 1 )

			return true
		end

		--Create a contraption spawner
		if dupe and dupe.Entities then
			local headent = dupe.Entities[dupe.HeadEnt.Index]
			local Pos, Ang

			if(headent) then
				if(tobool(ply:GetInfo("advdupe2_original_origin"))) then
					Pos = dupe.HeadEnt.Pos + headent.PhysicsObjects[0].Pos
					Ang = headent.PhysicsObjects[0].Angle
				else
					local EntAngle = headent.PhysicsObjects[0].Angle
					if(tobool(ply:GetInfo("advdupe2_offset_world"))) then EntAngle = Angle(0,0,0) end
					trace.HitPos.Z = trace.HitPos.Z + GetDupeElevation(ply)
					Pos, Ang = LocalToWorld(headent.PhysicsObjects[0].Pos, EntAngle, trace.HitPos, GetDupeAngleOffset(ply))
				end
			else
				AdvDupe2.Notify(ply, "Invalid head entity to spawn contraption spawner.")
				return false
			end

			if(headent.Class=="gmod_contr_spawner") then
				AdvDupe2.Notify(ply, "Cannot make a contraption spawner from a contraption spawner.")
				return false
			end


			local spawner = MakeContraptionSpawner(
				ply, Pos, Ang, dupe.HeadEnt.Index,
				table.Copy(dupe.Entities),
				table.Copy(dupe.Constraints),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_delay")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_delay")), headent.Model,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_undo_key")),
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disgrav")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_disdrag")) or 0,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_addvel")) or 1,
				tonumber(ply:GetInfo("advdupe2_contr_spawner_hideprops")) or 0)

			ply:AddCleanup( "AdvDupe2", spawner )
			undo.Create("gmod_contr_spawner")
				undo.AddEntity( spawner )
				undo.SetPlayer( ply )
			undo.Finish()

			return true
		end
	end

	--Called to clean up the tool when pasting is finished or undo during pasting
	function AdvDupe2.FinishPasting(Player, Paste)
		Player.AdvDupe2.Pasting=false
		AdvDupe2.RemoveProgressBar(Player)
		if(Paste) then AdvDupe2.Notify(Player,"Finished Pasting!") end
	end

	--function for creating a contraption spawner
	function MakeContraptionSpawner( ply, Pos, Ang, HeadEnt, EntityTable, ConstraintTable, delay, undo_delay, model, key, undo_key, disgrav, disdrag, addvel, hideprops)

		if not ply:CheckLimit("gmod_contr_spawners") then return nil end

		if(not game.SinglePlayer()) then
			if(table.Count(EntityTable)>tonumber(GetConVarString("AdvDupe2_MaxContraptionEntities"))) then
				AdvDupe2.Notify(ply,"Contraption Spawner exceeds the maximum amount of "..GetConVarString("AdvDupe2_MaxContraptionEntities").." entities for a spawner!",NOTIFY_ERROR)
				return false
			end
			if(#ConstraintTable>tonumber(GetConVarString("AdvDupe2_MaxContraptionConstraints"))) then
				AdvDupe2.Notify(ply,"Contraption Spawner exceeds the maximum amount of "..GetConVarString("AdvDupe2_MaxContraptionConstraints").." constraints for a spawner!",NOTIFY_ERROR)
				return false
			end
		end

		local spawner = ents.Create("gmod_contr_spawner")
		if not IsValid(spawner) then return end

		spawner:SetPos(Pos)
		spawner:SetAngles(Ang)
		spawner:SetModel(model)
		spawner:SetRenderMode(RENDERMODE_TRANSALPHA)
		spawner:SetCreator(ply)
		spawner:Spawn()

		duplicator.ApplyEntityModifiers(ply, spawner)

		if IsValid(spawner:GetPhysicsObject()) then
			spawner:GetPhysicsObject():EnableMotion(false)
		end

		local min
		local max
		if(not delay) then
			delay = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
		else
			if(not game.SinglePlayer()) then
				min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
				if (delay < min) then
					delay = min
				end
			elseif(delay<0) then
				delay = 0
			end
		end

		if(not undo_delay) then
			undo_delay = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay"))
		else
			if(not game.SinglePlayer()) then
				min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 0.1
				max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
				if(undo_delay < min) then
					undo_delay = min
				elseif(undo_delay > max) then
					undo_delay = max
				end
			elseif(undo_delay < 0) then
				undo_delay = 0
			end
		end

		-- Set options
		spawner:SetPlayer(ply)
		spawner:GetTable():SetOptions(ply, delay, undo_delay, key, undo_key, disgrav, disdrag, addvel, hideprops)

		local tbl = {
			ply        = ply,
			delay      = delay,
			undo_delay = undo_delay,
			disgrav    = disgrav,
			disdrag    = disdrag,
			addvel     = addvel,
			hideprops  = hideprops
		}
		table.Merge(spawner:GetTable(), tbl)
		spawner:SetDupeInfo(HeadEnt, EntityTable, ConstraintTable)
		spawner:AddGhosts(ply)

		ply:AddCount("gmod_contr_spawners", spawner)
		ply:AddCleanup("gmod_contr_spawner", spawner)
		return spawner
	end

	duplicator.RegisterEntityClass("gmod_contr_spawner", MakeContraptionSpawner,
		"Pos", "Ang", "HeadEnt", "EntityTable", "ConstraintTable", "delay",
		"undo_delay", "model", "key", "undo_key", "disgrav", "disdrag", "addvel", "hideprops")

	function AdvDupe2.InitProgressBar(ply,label)
		net.Start("AdvDupe2_InitProgressBar")
			net.WriteString(label)
		net.Send(ply)
	end

	function AdvDupe2.DrawSelectBox(ply)
		net.Start("AdvDupe2_DrawSelectBox")
		net.Send(ply)
	end

	function AdvDupe2.RemoveSelectBox(ply)
		net.Start("AdvDupe2_RemoveSelectBox")
		net.Send(ply)
	end

	function AdvDupe2.UpdateProgressBar(ply,percent)
		net.Start("AdvDupe2_UpdateProgressBar")
			net.WriteFloat(percent)
		net.Send(ply)
	end

	function AdvDupe2.RemoveProgressBar(ply)
		net.Start("AdvDupe2_RemoveProgressBar")
		net.Send(ply)
	end

	--Reset the offsets of height, pitch, yaw, and roll back to default
	function AdvDupe2.ResetOffsets(ply, keep)

		if(not keep) then
			ply.AdvDupe2.Name = nil
		end
		net.Start("AdvDupe2_ResetOffsets")
		net.Send(ply)
	end

	net.Receive("AdvDupe2_CanAutoSave", function(len, ply, len2)

		local desc = net.ReadString()
		local ent = net.ReadInt(16)
		local dupe = ply.AdvDupe2

		if(ent~=0) then
			dupe.AutoSaveEnt = ent
			if(ply:GetInfo("advdupe2_auto_save_contraption")=="1") then
				dupe.AutoSaveEnt = ents.GetByIndex( dupe.AutoSaveEnt )
			end
		else
			if(ply:GetInfo("advdupe2_auto_save_contraption")=="1") then
				AdvDupe2.Notify(ply, "No entity selected to auto save contraption.", NOTIFY_ERROR)
				return
			end
			dupe.AutoSaveEnt = nil
		end

		dupe.AutoSavePos = dupe.TempAutoSavePos
		dupe.AutoSaveSize = dupe.TempAutoSaveSize
		dupe.AutoSaveOutSide = dupe.TempAutoSaveOutSide
		dupe.AutoSaveContr = ply:GetInfo("advdupe2_auto_save_contraption")=="1"
		dupe.AutoSaveDesc = desc

		local time = math.Clamp(tonumber(ply:GetInfo("advdupe2_auto_save_time")) or 2, 2, 30)
		if(game.SinglePlayer()) then
			dupe.AutoSavePath = net.ReadString()
		end

		AdvDupe2.Notify(ply, "Your area will be auto saved every "..(time*60).." seconds.")
		local name = "AdvDupe2_AutoSave_"..ply:UniqueID()
		if(timer.Exists(name)) then
			timer.Adjust(name, time*60, 0)
			return
		end
		timer.Create(name, time*60, 0, function()
			if(not IsValid(ply)) then
				timer.Remove(name)
				return
			end

			local dupe = ply.AdvDupe2
			if(dupe.Downloading) then
				AdvDupe2.Notify(ply, "Skipping auto save, tool is busy.", NOTIFY_ERROR)
				return
			end

			local Tab = {Entities={}, Constraints={}, HeadEnt={}}

			if(dupe.AutoSaveContr) then
				if(not IsValid(dupe.AutoSaveEnt)) then
					timer.Remove(name)
					AdvDupe2.Notify(ply, "Head entity for auto save no longer valid; stopping auto save.", NOTIFY_ERROR)
					return
				end

				Tab.HeadEnt.Index = dupe.AutoSaveEnt:EntIndex()
				Tab.HeadEnt.Pos = dupe.AutoSaveEnt:GetPos()

				local WorldTrace = util.TraceLine({
					mask   = MASK_NPCWORLDSTATIC,
					start  = Tab.HeadEnt.Pos + Vector(0,0,1),
					endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
				})

				Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
				AdvDupe2.duplicator.Copy( ply, dupe.AutoSaveEnt, Tab.Entities, Tab.Constraints, Tab.HeadEnt.Pos )
			else
				local i = dupe.AutoSaveSize
				local Pos = dupe.AutoSavePos
				local T = Vector( i, i, i); T:Add(Pos)
				local B = Vector(-i,-i,-i); B:Add(Pos)

				local Entities = FindInBox(B,T, ply)
				local _, HeadEnt = next(Entities)
				if not HeadEnt then
					AdvDupe2.Notify(ply, "Area Auto Save copied 0 entities; be sure to turn it off.", NOTIFY_ERROR)
					return
				end

				if(dupe.AutoSaveEnt and Entities[dupe.AutoSaveEnt]) then
					Tab.HeadEnt.Index = dupe.AutoSaveEnt
				else
					Tab.HeadEnt.Index = HeadEnt:EntIndex()
				end
				Tab.HeadEnt.Pos = HeadEnt:GetPos()

				local WorldTrace = util.TraceLine({
					mask   = MASK_NPCWORLDSTATIC,
					start  = Tab.HeadEnt.Pos + Vector(0,0,1),
					endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
				})

				Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
				Tab.Entities, Tab.Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, Tab.HeadEnt.Pos, dupe.AutoSaveOutSide)
			end
			Tab.Constraints = GetSortedConstraints(ply, Tab.Constraints)
			Tab.Description = dupe.AutoSaveDesc

			AdvDupe2.Encode( Tab, AdvDupe2.GenerateDupeStamp(ply), function(data)
				AdvDupe2.SendToClient(ply, data, 1)
			end)
			dupe.FileMod = CurTime()+tonumber(GetConVarString("AdvDupe2_FileModificationDelay"))
		end)
		timer.Start(name)
	end)

	concommand.Add("AdvDupe2_SetStage", function(ply, cmd, args)
		ply:GetTool("advdupe2"):SetStage(1)
	end)

	concommand.Add("AdvDupe2_RemoveAutoSave", function(ply, cmd, args)
		timer.Remove("AdvDupe2_AutoSave_"..ply:UniqueID())
	end)

	concommand.Add("AdvDupe2_SaveMap", function(ply, cmd, args)
		if(not ply:IsAdmin()) then
			AdvDupe2.Notify(ply, "You do not have permission to this function.", NOTIFY_ERROR)
			return
		end

		local Entities = {}
		for _, v in ents.Iterator() do
			if not v:CreatedByMap() and AdvDupe2.duplicator.IsCopyable(v) then
				Entities[v:EntIndex()] = v
			end
		end

		local _, HeadEnt = next(Entities)
		if not HeadEnt then return end

		local Tab = {Entities={}, Constraints={}, HeadEnt={}, Description=""}
		Tab.HeadEnt.Index = HeadEnt:EntIndex()
		Tab.HeadEnt.Pos = HeadEnt:GetPos()

		local WorldTrace = util.TraceLine({
			mask   = MASK_NPCWORLDSTATIC,
			start  = Tab.HeadEnt.Pos + Vector(0,0,1),
			endpos = Tab.HeadEnt.Pos - Vector(0,0,50000)
		})

		Tab.HeadEnt.Z = WorldTrace.Hit and math.abs(Tab.HeadEnt.Pos.Z - WorldTrace.HitPos.Z) or 0
		Tab.Entities, Tab.Constraints = AdvDupe2.duplicator.AreaCopy(ply, Entities, Tab.HeadEnt.Pos, true)
		Tab.Constraints = GetSortedConstraints(ply, Tab.Constraints)

		Tab.Map = true
		AdvDupe2.Encode( Tab, AdvDupe2.GenerateDupeStamp(ply), function(data)
			if #data > AdvDupe2.MaxDupeSize then
				AdvDupe2.Notify(ply, "Copied duplicator filesize is too big!",NOTIFY_ERROR)
				return 
			end
			if(not file.IsDir("advdupe2_maps", "DATA")) then
				file.CreateDir("advdupe2_maps")
			end
			file.Write("advdupe2_maps/"..args[1]..".txt", data)
			AdvDupe2.Notify(ply, "Map save, saved successfully.")
		end)
	end)
end

if(CLIENT) then

	function TOOL:LeftClick(trace)
		if(trace and AdvDupe2.HeadGhost) then
			return true
		end
		return false
	end

	function TOOL:RightClick(trace)
		if( self:GetOwner():KeyDown(IN_SPEED) and not self:GetOwner():KeyDown(IN_WALK) ) then
			return false
		end
		return true
	end

	--Removes progress bar and removes ghosts when tool is put away
	function TOOL:ReleaseGhostEntity()
		AdvDupe2.RemoveGhosts()
		AdvDupe2.RemoveSelectBox()
		if(AdvDupe2.Rotation) then
			hook.Remove("PlayerBindPress", "AdvDupe2_BindPress")
			hook.Remove("CreateMove", "AdvDupe2_MouseControl")
		end
		return
	end

	function TOOL:Reload( trace )
		if(trace and (AdvDupe2.HeadGhost or self:GetStage() == 1)) then
			return true
		end
		return false
	end

	--Take control of the mouse wheel bind so the player can modify the height of the dupe
	local function MouseWheelScrolled(ply, bind, pressed)

		if(bind == "invprev") then
			if(ply:GetTool("advdupe2"):GetStage() == 1) then
				local size = math.min(tonumber(ply:GetInfo("advdupe2_area_copy_size")) + 25, 30720)
				RunConsoleCommand("advdupe2_area_copy_size",size)
			else
				local Z = tonumber(ply:GetInfo("advdupe2_offset_z")) + 5
				RunConsoleCommand("advdupe2_offset_z",Z)
			end
			return true
		elseif(bind == "invnext") then
			if(ply:GetTool("advdupe2"):GetStage() == 1) then
				local size = math.max(tonumber(ply:GetInfo("advdupe2_area_copy_size")) - 25, 25)
				RunConsoleCommand("advdupe2_area_copy_size",size)
			else
				local Z = tonumber(ply:GetInfo("advdupe2_offset_z")) - 5
				RunConsoleCommand("advdupe2_offset_z",Z)
			end
			return true
		end

		GAMEMODE:PlayerBindPress(ply, bind, pressed)
	end

	local YawTo = 0
	local BsAng = Angle()

	local function GetRotationSign(ply)
		local VY = tonumber(ply:GetInfo("advdupe2_offset_yaw")) or 0
		BsAng:Zero(); BsAng:RotateAroundAxis(BsAng:Up(), VY)
		local PR = ply:GetRight()
		local DP = BsAng:Right():Dot(PR)
		local DR = BsAng:Forward():Dot(PR)
		if(math.abs(DR) > math.abs(DP)) then -- Roll priority
			if(DR >= 0) then return -1, 1 else return  1, -1 end
		else -- Pitch axis takes priority. Normal X-Y map
			if(DP >= 0) then return  1, 1 else return -1, -1 end
		end
	end

	local function MouseControl( cmd )
		local ply = LocalPlayer()
		local X =  cmd:GetMouseX() / 20
		local Y = -cmd:GetMouseY() / 20
		local ru = ply:KeyDown(IN_SPEED)
		local mm = input.IsMouseDown(MOUSE_MIDDLE)

		if(mm) then
			if(ru) then
				YawTo = 0 -- Reset total integrated yaw
				RunConsoleCommand("advdupe2_offset_pitch", 0)
				RunConsoleCommand("advdupe2_offset_yaw"  , 0)
				RunConsoleCommand("advdupe2_offset_roll" , 0)
			else
				if(Y ~= 0) then
					local VR = tonumber(ply:GetInfo("advdupe2_offset_roll"))  or 0
					local VP = tonumber(ply:GetInfo("advdupe2_offset_pitch")) or 0
					local SP, SR, P, R = GetRotationSign(ply)
					if(SP ~= SR) then
						P = math.NormalizeAngle(VP + X * SR)
						R = math.NormalizeAngle(VR + Y * SP)
					else
						P = math.NormalizeAngle(VP + Y * SP)
						R = math.NormalizeAngle(VR + X * SR)
					end
					RunConsoleCommand("advdupe2_offset_pitch", P)
					RunConsoleCommand("advdupe2_offset_roll" , R)
				end
			end
		else
			if(X ~= 0) then
				VY = tonumber(ply:GetInfo("advdupe2_offset_yaw")) or 0
				if(ru) then
					YawTo = YawTo + X -- Integrate the mouse on the X value from the mouse
					RunConsoleCommand("advdupe2_offset_yaw", math.SnapTo(math.NormalizeAngle(YawTo), 45))
				else
					YawTo = VY + X -- Update the last yaw with the current value from the mouse
					RunConsoleCommand("advdupe2_offset_yaw", math.NormalizeAngle(YawTo))
				end
			end
		end
	end

	--Checks binds to modify dupes position and angles
	function TOOL:Think()

		if AdvDupe2.HeadGhost then
			AdvDupe2.UpdateGhosts()
		end

		if(LocalPlayer():KeyDown(IN_USE)) then
			if(not AdvDupe2.Rotation) then
				hook.Add("PlayerBindPress", "AdvDupe2_BindPress", MouseWheelScrolled)
				hook.Add("CreateMove", "AdvDupe2_MouseControl", MouseControl)
				AdvDupe2.Rotation = true
			end
		else
			if(AdvDupe2.Rotation) then
				AdvDupe2.Rotation = false
				hook.Remove("PlayerBindPress", "AdvDupe2_BindPress")
				hook.Remove("CreateMove", "AdvDupe2_MouseControl")
			end
		end
	end

	--Hinder the player from looking to modify offsets with the mouse
	function TOOL:FreezeMovement()
		return AdvDupe2.Rotation
	end

	language.Add( "Tool.advdupe2.name",	"Advanced Duplicator 2" )
	language.Add( "Tool.advdupe2.desc",	"Duplicate things." )
	language.Add( "Tool.advdupe2.0",	"Primary: Paste, Secondary: Copy, Secondary+World: Select/Deselect All, Secondary+Shift: Area copy." )
	language.Add( "Tool.advdupe2.1",	"Primary: Paste, Secondary: Copy an area, Reload: Autosave an area, Secondary+Shift: Cancel." )
	language.Add( "Undone_AdvDupe2",	"Undone AdvDupe2 paste" )
	language.Add( "Cleanup_AdvDupe2",	"AdvDupe2 Duplications" )
	language.Add( "Cleaned_AdvDupe2",	"Cleaned up all AdvDupe2 Duplications" )
	language.Add( "SBoxLimit_AdvDupe2",	"You've reached the AdvDupe2 Duplicator limit!" )

	CreateClientConVar("advdupe2_offset_world", 0, false, true)
	CreateClientConVar("advdupe2_offset_z", 0, false, true)
	CreateClientConVar("advdupe2_offset_pitch", 0, false, true)
	CreateClientConVar("advdupe2_offset_yaw", 0, false, true)
	CreateClientConVar("advdupe2_offset_roll", 0, false, true)
	CreateClientConVar("advdupe2_original_origin", 0, false, true)
	CreateClientConVar("advdupe2_paste_constraints", 1, false, true)
	CreateClientConVar("advdupe2_sort_constraints", 1, true, true)
	CreateClientConVar("advdupe2_paste_parents", 1, false, true)
	CreateClientConVar("advdupe2_paste_unfreeze", 0, false, true)
	CreateClientConVar("advdupe2_preserve_freeze", 0, false, true)
	CreateClientConVar("advdupe2_copy_outside", 0, false, true)
	CreateClientConVar("advdupe2_copy_only_mine", 1, false, true)
	CreateClientConVar("advdupe2_limit_ghost", 100, false, true)
	CreateClientConVar("advdupe2_area_copy_size", 300, false, true)
	CreateClientConVar("advdupe2_auto_save_contraption", 0, false, true)
	CreateClientConVar("advdupe2_auto_save_overwrite", 1, false, true)
	CreateClientConVar("advdupe2_auto_save_time", 2, false, true)

	--Contraption Spawner
	CreateClientConVar("advdupe2_contr_spawner_key", -1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_undo_key", -1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_delay", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_undo_delay", 10, false, true)
	CreateClientConVar("advdupe2_contr_spawner_disgrav", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_disdrag", 0, false, true)
	CreateClientConVar("advdupe2_contr_spawner_addvel", 1, false, true)
	CreateClientConVar("advdupe2_contr_spawner_hideprops", 0, false, true)

	--Experimental
	CreateClientConVar("advdupe2_paste_disparents", 0, false, true)
	CreateClientConVar("advdupe2_paste_protectoveride", 1, false, true)
	CreateClientConVar("advdupe2_debug_openfile", 1, false, true)

	local function BuildCPanel(CPanel)
		CPanel:ClearControls()

		local FileBrowser = vgui.Create("advdupe2_browser")
		CPanel:AddItem(FileBrowser)
		FileBrowser:SetSize(CPanel:GetWide(), 405)
		AdvDupe2.FileBrowser = FileBrowser

		local Check = vgui.Create("DCheckBoxLabel")

		Check:SetText( "Paste at original position" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_original_origin" )
		Check:SetValue( 0 )
		Check:SetToolTip("Paste at the position originally copied")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Paste with constraints" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_constraints" )
		Check:SetValue( 1 )
		Check:SetToolTip("Paste with or without constraints")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Paste with parenting" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_parents" )
		Check:SetValue( 1 )
		Check:SetToolTip("Paste with or without parenting")
		CPanel:AddItem(Check)

		local Check_1 = vgui.Create("DCheckBoxLabel")
		local Check_2 = vgui.Create("DCheckBoxLabel")

		Check_1:SetText( "Unfreeze all after paste" )
		Check_1:SetDark(true)
		Check_1:SetConVar( "advdupe2_paste_unfreeze" )
		Check_1:SetValue( 0 )
		Check_1.OnChange = function()
			if(Check_1:GetChecked() and Check_2:GetChecked()) then
				Check_2:SetValue(0)
			end
		end
		Check_1:SetToolTip("Unfreeze all props after pasting")
		CPanel:AddItem(Check_1)

		Check_2:SetText( "Preserve frozen state after paste" )
		Check_2:SetDark(true)
		Check_2:SetConVar( "advdupe2_preserve_freeze" )
		Check_2:SetValue( 0 )
		Check_2.OnChange = function()
			if(Check_2:GetChecked() and Check_1:GetChecked()) then
				Check_1:SetValue(0)
			end
		end
		Check_2:SetToolTip("Makes props have the same frozen state as when they were copied")
		CPanel:AddItem(Check_2)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Area copy constrained props outside of box" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_copy_outside" )
		Check:SetValue( 0 )
		Check:SetToolTip("Copy entities outside of the area copy that are constrained to entities insde")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "World/Area copy only your own props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_copy_only_mine" )
		Check:SetValue( 1 )
		Check:SetToolTip("Copy entities outside of the area copy that are constrained to entities insde")
		CPanel:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Sort constraints by their connections" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_sort_constraints" )
		Check:SetValue( GetConVarNumber("advdupe2_sort_constraints") )
		Check:SetToolTip( "Orders constraints so that they build a rigid constraint system." )
		CPanel:AddItem(Check)

		local NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Ghost Percentage:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 0 )
		NumSlider:SetMax( 100 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_limit_ghost" )
		NumSlider:SetToolTip("Change the percent of ghosts to spawn")
		--If these funcs are not here, problems occur for each
		local func = NumSlider.Slider.OnMouseReleased
		NumSlider.Slider.OnMouseReleased = function(self, mcode) func(self, mcode) AdvDupe2.StartGhosting() end
		local func2 = NumSlider.Slider.Knob.OnMouseReleased
		NumSlider.Slider.Knob.OnMouseReleased = function(self, mcode) func2(self, mcode) AdvDupe2.StartGhosting() end
		local func3 = NumSlider.Wang.Panel.OnLoseFocus
		NumSlider.Wang.Panel.OnLoseFocus = function(txtBox) func3(txtBox) AdvDupe2.StartGhosting() end
		CPanel:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Area Copy Size:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 0 )
		NumSlider:SetMax( 30720 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_area_copy_size" )
		NumSlider:SetToolTip("Change the size of the area copy")
		CPanel:AddItem(NumSlider)

		local Category1 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category1)
		Category1:SetLabel("Offsets")
		Category1:SetExpanded(0)

		local parent = FileBrowser:GetParent():GetParent():GetParent():GetParent()
		--[[Offsets]]--
		local CategoryContent1 = vgui.Create( "DPanelList" )
		CategoryContent1:SetAutoSize( true )
		CategoryContent1:SetDrawBackground( false )
		CategoryContent1:SetSpacing( 1 )
		CategoryContent1:SetPadding( 2 )
		CategoryContent1.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end		--Fix the damned mouse not scrolling when it's over the catagories

		Category1:SetContents( CategoryContent1 )

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Height Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -2500 )
		NumSlider:SetMax( 2500 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetConVar("advdupe2_offset_z")
		NumSlider:SetToolTip("Changes the dupe Z offset")
		CategoryContent1:AddItem(NumSlider)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Use World Angles" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_offset_world" )
		Check:SetValue( 0 )
		Check:SetToolTip("Use world angles for the offset instead of the main entity")
		CategoryContent1:AddItem(Check)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Pitch Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe pitch offset")
		NumSlider:SetConVar("advdupe2_offset_pitch")
		CategoryContent1:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Yaw Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe yaw offset")
		NumSlider:SetConVar("advdupe2_offset_yaw")
		CategoryContent1:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Roll Offset" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( -180 )
		NumSlider:SetMax( 180 )
		NumSlider:SetDefaultValue( 0 )
		NumSlider:SetDecimals( 3 )
		NumSlider:SetToolTip("Changes the dupe roll offset")
		NumSlider:SetConVar("advdupe2_offset_roll")
		CategoryContent1:AddItem(NumSlider)

		local Btn = vgui.Create("DButton")
		Btn:SetText("Reset")
		Btn.DoClick = function()
			RunConsoleCommand("advdupe2_offset_z", 0)
			RunConsoleCommand("advdupe2_offset_pitch", 0)
			RunConsoleCommand("advdupe2_offset_yaw", 0)
			RunConsoleCommand("advdupe2_offset_roll", 0)
		end
		CategoryContent1:AddItem(Btn)


		--[[Dupe Information]]--
		local Category2 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category2)
		Category2:SetLabel("Dupe Information")
		Category2:SetExpanded(0)

		local CategoryContent2 = vgui.Create( "DPanelList" )
		CategoryContent2:SetAutoSize( true )
		CategoryContent2:SetDrawBackground( false )
		CategoryContent2:SetSpacing( 3 )
		CategoryContent2:SetPadding( 2 )
		Category2:SetContents( CategoryContent2 )
		CategoryContent2.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		AdvDupe2.Info = {}

		local lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.File or "File: ")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.File = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Creator or "Creator:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Creator = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Date or "Date:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Date = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Time or "Time:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Time = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Size or "Size:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Size = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Desc or "Desc:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Desc = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Entities or "Entities:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Entities = lbl

		lbl = vgui.Create( "DLabel" )
		lbl:SetText(AdvDupe2.InfoText.Constraints or "Constraints:")
		lbl:SetDark(true)
		CategoryContent2:AddItem(lbl)
		AdvDupe2.Info.Constraints = lbl

	--[[Contraption Spawner]]--
		local Category3 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category3)
		Category3:SetLabel("Contraption Spawner")
		Category3:SetExpanded(0)

		local CategoryContent3 = vgui.Create( "DPanelList" )
		CategoryContent3:SetAutoSize( true )
		CategoryContent3:SetDrawBackground( false )
		CategoryContent3:SetSpacing( 3 )
		CategoryContent3:SetPadding( 2 )
		Category3:SetContents( CategoryContent3 )
		CategoryContent3.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		local ctrl = vgui.Create( "CtrlNumPad" )
		ctrl:SetConVar1( "advdupe2_contr_spawner_key" )
		ctrl:SetConVar2( "advdupe2_contr_spawner_undo_key" )
		ctrl:SetLabel1( "Spawn Key")
		ctrl:SetLabel2( "Undo Key" )
		CategoryContent3:AddItem(ctrl)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Spawn Delay" )
		NumSlider.Label:SetDark(true)
		if(game.SinglePlayer()) then
			NumSlider:SetMin( 0 )
		else
			local min = tonumber(GetConVarString("AdvDupe2_MinContraptionSpawnDelay")) or 0.2
			if(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_delay"))<min) then
				RunConsoleCommand("advdupe2_contr_spawner_delay", tostring(min))
			end
			NumSlider:SetMin( min )
		end
		NumSlider:SetMax(60)
		NumSlider:SetDecimals( 1 )
		NumSlider:SetConVar("advdupe2_contr_spawner_delay")
		CategoryContent3:AddItem(NumSlider)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Undo Delay" )
		NumSlider.Label:SetDark(true)
		if(game.SinglePlayer()) then
			NumSlider:SetMin( 0 )
			NumSlider:SetMax( 60 )
		else
			local min = tonumber(GetConVarString("AdvDupe2_MinContraptionUndoDelay")) or 10
			local max = tonumber(GetConVarString("AdvDupe2_MaxContraptionUndoDelay")) or 60
			if(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_undo_delay")) < min) then
				RunConsoleCommand("advdupe2_contr_spawner_undo_delay", tostring(min))
			elseif(tonumber(LocalPlayer():GetInfo("advdupe2_contr_spawner_undo_delay")) > max) then
				RunConsoleCommand("advdupe2_contr_spawner_undo_delay", tostring(max))
			end
			NumSlider:SetMin( min )
			NumSlider:SetMax( max )
		end
		NumSlider:SetDecimals( 1 )
		NumSlider:SetConVar("advdupe2_contr_spawner_undo_delay")
		CategoryContent3:AddItem(NumSlider)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable gravity for all spawned props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_disgrav" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable drag for all spawned props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_disdrag" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Add spawner's velocity to contraption" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_addvel" )
		Check:SetValue( 1 )
		CategoryContent3:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable drawing spawner props" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_contr_spawner_hideprops" )
		Check:SetValue( 0 )
		CategoryContent3:AddItem(Check)

		--[[Area Auto Save]]--
		local Category4 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category4)
		Category4:SetLabel("Area Auto Save")
		Category4:SetExpanded(0)

		local CategoryContent4 = vgui.Create( "DPanelList" )
		CategoryContent4:SetAutoSize( true )
		CategoryContent4:SetDrawBackground( false )
		CategoryContent4:SetSpacing( 3 )
		CategoryContent4:SetPadding( 2 )
		Category4:SetContents( CategoryContent4 )
		CategoryContent4.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Only copy contraption" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_auto_save_contraption" )
		Check:SetValue( 0 )
		Check:SetToolTip("Only copy a contraption instead of an area")
		CategoryContent4:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Overwrite File" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_auto_save_overwrite" )
		Check:SetValue( 1 )
		Check:SetToolTip("Overwrite the file instead of creating a new one everytime")
		CategoryContent4:AddItem(Check)

		NumSlider = vgui.Create( "DNumSlider" )
		NumSlider:SetText( "Minutes to Save:" )
		NumSlider.Label:SetDark(true)
		NumSlider:SetMin( 2 )
		NumSlider:SetMax( 30 )
		NumSlider:SetDecimals( 0 )
		NumSlider:SetConVar( "advdupe2_auto_save_time" )
		NumSlider:SetToolTip("Interval time to save in minutes")
		CategoryContent4:AddItem(NumSlider)

		local pnl = vgui.Create("Panel")
		pnl:SetWide(CPanel:GetWide()-40)
		pnl:SetTall(75)
		pnl:SetPos(0, 50)
		CategoryContent4:AddItem(pnl)

		local label = vgui.Create("DLabel", pnl)
		label:SetText("Directory: ")
		label:SizeToContents()
		label:SetDark(true)
		label:SetPos(5,7)

		AdvDupe2.AutoSavePath = ""
		local txtbox = vgui.Create("DTextEntry", pnl)
		txtbox:SetWide(pnl:GetWide()-100)
		txtbox:SetPos(60, 5)
		txtbox:SetUpdateOnType(true)
		txtbox.OnTextChanged = function(self)
			self:SetValue(AdvDupe2.AutoSavePath)
		end

		local btn = vgui.Create("DImageButton", pnl)
		local x, y = txtbox:GetPos()
		btn:SetPos(x + txtbox:GetWide() + 5, 7)
		btn:SetMaterial("icon16/folder_explore.png")
		btn:SizeToContents()
		btn:SetToolTip("Browse")
		btn.DoClick = function()
			local ScrollBar = parent.VBar
			ScrollBar:AnimateTo(0, 1, 0, 0.2)

			FileBrowser.Submit:SetMaterial("icon16/disk.png")
			FileBrowser.Submit:SetTooltip("Directory for Area Auto Save")
			if(FileBrowser.FileName:GetValue()=="Folder_Name...") then
				FileBrowser.FileName:SetValue("File_Name...")
			end
			FileBrowser.Desc:SetVisible(true)
			FileBrowser.Info:SetVisible(false)
			FileBrowser.FileName:SetVisible(true)
			FileBrowser.FileName:SelectAllOnFocus(true)
			FileBrowser.FileName:OnMousePressed()
			FileBrowser.FileName:RequestFocus()
			FileBrowser.Expanding=true
			FileBrowser:Slide(true)
			FileBrowser.Submit.DoClick = function()
				local name = FileBrowser.FileName:GetValue()
				if(name=="" or name=="File_Name...") then
					AdvDupe2.Notify("Name field is blank.", NOTIFY_ERROR)
					FileBrowser.FileName:SelectAllOnFocus(true)
					FileBrowser.FileName:OnGetFocus()
					FileBrowser.FileName:RequestFocus()
					return
				end
				local desc = FileBrowser.Desc:GetValue()
				if(desc=="Description...") then desc="" end

				if(not IsValid(FileBrowser.Browser.pnlCanvas.m_pSelectedItem) or FileBrowser.Browser.pnlCanvas.m_pSelectedItem.Derma.ClassName~="advdupe2_browser_folder") then
					AdvDupe2.Notify("Folder to save Area Auto Save not selected.", NOTIFY_ERROR)
					return
				end

				FileBrowser.AutoSaveNode = FileBrowser.Browser.pnlCanvas.m_pSelectedItem
				txtbox:SetValue(FileBrowser:GetFullPath(FileBrowser.Browser.pnlCanvas.m_pSelectedItem)..name)
				AdvDupe2.AutoSavePath = txtbox:GetValue()
				txtbox:SetToolTip(txtbox:GetValue())
				AdvDupe2.AutoSaveDesc = desc

				FileBrowser:Slide(false)
				ScrollBar:AnimateTo(ScrollBar.CanvasSize, 1, 0, 0.2)

				RunConsoleCommand("AdvDupe2_SetStage")
				hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
			end
			FileBrowser.FileName.OnEnter = function()
				FileBrowser.FileName:KillFocus()
				FileBrowser.Desc:SelectAllOnFocus(true)
				FileBrowser.Desc.OnMousePressed()
				FileBrowser.Desc:RequestFocus()
			end
			FileBrowser.Desc.OnEnter = FileBrowser.Submit.DoClick
		end

		btn = vgui.Create("DButton", pnl)
		btn:SetSize(50, 35)
		btn:SetPos(pnl:GetWide()/4-10, 30)
		btn:SetText("Show")
		btn.DoClick = function()
			if(AdvDupe2.AutoSavePos) then
				RunConsoleCommand("advdupe2_area_copy_size", AdvDupe2.AutoSaveSize)
				LocalPlayer():SetEyeAngles( (AdvDupe2.AutoSavePos - LocalPlayer():GetShootPos()):Angle() )
				RunConsoleCommand("AdvDupe2_SetStage")
				hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
			end
		end

		btn = vgui.Create("DButton", pnl)
		btn:SetSize(50, 35)
		btn:SetPos((pnl:GetWide()/4)*3-40, 30)
		btn:SetText("Turn Off")
		btn:SetDisabled(true)
		btn.DoClick = function(self)
			RunConsoleCommand("AdvDupe2_RemoveAutoSave")
			self:SetDisabled(true)
			AdvDupe2.AutoSavePos = nil
		end
		AdvDupe2.OffButton = btn


		--[[Experimental Section]]--
		local Category5 = vgui.Create("DCollapsibleCategory")
		CPanel:AddItem(Category5)
		Category5:SetLabel("Experimental Section")
		Category5:SetExpanded(0)

		local CategoryContent5 = vgui.Create( "DPanelList" )
		CategoryContent5:SetAutoSize( true )
		CategoryContent5:SetDrawBackground( false )
		CategoryContent5:SetSpacing( 3 )
		CategoryContent5:SetPadding( 2 )
		Category5:SetContents( CategoryContent5 )
		CategoryContent5.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable parented props physics interaction" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_disparents" )
		Check:SetValue( 0 )
		CategoryContent5:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Disable Dupe Spawn Protection" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_paste_protectoveride" )
		Check:SetValue( 1 )
		Check:SetToolTip("Check this if you things don't look right after pasting.")
		CategoryContent5:AddItem(Check)

		Check = vgui.Create("DCheckBoxLabel")
		Check:SetText( "Open file after Saving" )
		Check:SetDark(true)
		Check:SetConVar( "advdupe2_debug_openfile" )
		Check:SetValue( 1 )
		Check:SetToolTip("Check this if you want your files to be opened after saving them.")
		CategoryContent5:AddItem(Check)

		--[[Save Map]]--
		if(LocalPlayer():IsAdmin()) then
			local Category6 = vgui.Create("DCollapsibleCategory")
			CPanel:AddItem(Category6)
			Category6:SetLabel("Save Map")
			Category6:SetExpanded(0)

			local CategoryContent6 = vgui.Create( "DPanelList" )
			CategoryContent6:SetAutoSize( true )
			CategoryContent6:SetDrawBackground( false )
			CategoryContent6:SetSpacing( 3 )
			CategoryContent6:SetPadding( 2 )
			Category6:SetContents( CategoryContent6 )
			CategoryContent6.OnMouseWheeled = function(self, dlta) parent:OnMouseWheeled(dlta) end

			pnl = vgui.Create("Panel")
			pnl:SetWide(CPanel:GetWide()-40)
			pnl:SetTall(75)
			pnl:SetPos(0, 50)
			CategoryContent6:AddItem(pnl)

			label = vgui.Create("DLabel", pnl)
			label:SetText("File Name: ")
			label:SizeToContents()
			label:SetDark(true)
			label:SetPos(5,7)

			AdvDupe2.AutoSavePath = ""

			local txtbox2 = vgui.Create("DTextEntry", pnl)
			txtbox2:SetWide(pnl:GetWide()-100)
			txtbox2:SetPos(60, 5)

			local btn2 = vgui.Create("DImageButton", pnl)
			x, y = txtbox2:GetPos()
			btn2:SetPos(x + txtbox2:GetWide() + 5, 7)
			btn2:SetMaterial("icon16/disk.png")
			btn2:SizeToContents()
			btn2:SetToolTip("Save Map")
			btn2.DoClick = 	function()
				if(txtbox2:GetValue()=="") then return end
				RunConsoleCommand("AdvDupe2_SaveMap", txtbox2:GetValue())
			end
			txtbox2.OnEnter = function()
				btn2:DoClick()
			end
		end
	end

	function TOOL.BuildCPanel(panel)
		panel:ClearControls()
		panel:AddControl("Header", {
			Text = "Advanced Duplicator 2",
			Description = "Duplicate stuff."
		})
		local function tryToBuild()
			local CPanel = controlpanel.Get("advdupe2")
			if CPanel and CPanel:GetWide()>16 then
				BuildCPanel(CPanel)
			else
				timer.Simple(0.1,tryToBuild)
			end
		end
		tryToBuild()
	end

	local StColor  = {r=130, g=25, b=40, a=255}
	local NoColor  = {r=25, g=100, b=40, a=255}
	local CurColor = {r=25, g=100, b=40, a=255}
	local CWhite   = Color(255,255,255,255)
	surface.CreateFont ("AD2Font", {font="Arial", size=40, weight=1000}) ---Remember to use gm_clearfonts
	surface.CreateFont ("AD2TitleFont", {font="Arial", size=24, weight=1000})

	function TOOL:DrawToolScreen()
		if(not AdvDupe2) then return true end

		local text = "Ready"
		local state, co = false
		local ply = LocalPlayer()

		if(AdvDupe2.Preview) then
			text = "Preview"
		end
		if(AdvDupe2.ProgressBar.Text) then
			state = true
			text = AdvDupe2.ProgressBar.Text
		end

		cam.Start2D()

			surface.SetDrawColor(32, 32, 32, 255)
			surface.DrawRect(0, 0, 256, 256)

			if(state) then
				co = StColor
			else
				co = NoColor
			end

			local rate = FrameTime() * 160
			CurColor.r = math.Approach( CurColor.r, co.r, rate )
			CurColor.g = math.Approach( CurColor.g, co.g, rate )

			surface.SetDrawColor(CurColor)
			surface.DrawRect(13, 13, 230, 230)

			surface.SetTextColor( 255, 255, 255, 255 )

			draw.SimpleText("Advanced Duplicator 2", "AD2TitleFont", 128, 50, CWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP)
			draw.SimpleText(text, "AD2Font", 128, 128, CWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
			if(state) then
				draw.RoundedBox( 6, 32, 178, 192, 28, Color( 255, 255, 255, 150 ) )
				draw.RoundedBox( 6, 34, 180, 188*(AdvDupe2.ProgressBar.Percent / 100), 24, Color( 0, 255, 0, 255 ) )
			elseif(ply:KeyDown(IN_USE)) then
				local font, align = "AD2TitleFont", TEXT_ALIGN_BOTTOM
				draw.SimpleText("H: "..ply:GetInfo("advdupe2_offset_z")    , font, 20,  210, CWhite, TEXT_ALIGN_LEFT , align)
				draw.SimpleText("P: "..ply:GetInfo("advdupe2_offset_pitch"), font, 236, 210, CWhite, TEXT_ALIGN_RIGHT, align)
				draw.SimpleText("Y: "..ply:GetInfo("advdupe2_offset_yaw")  , font, 20 , 240, CWhite, TEXT_ALIGN_LEFT , align)
				draw.SimpleText("R: "..ply:GetInfo("advdupe2_offset_roll") , font, 236, 240, CWhite, TEXT_ALIGN_RIGHT, align)
			end

		cam.End2D()
	end


	local function FindInBox(min, max, ply)
		local EntTable = {}
		for _,ent in ents.Iterator() do
			local pos = ent:GetPos()
			if (pos.X>=min.X) and (pos.X<=max.X) and (pos.Y>=min.Y) and (pos.Y<=max.Y) and (pos.Z>=min.Z) and (pos.Z<=max.Z) then
				--if(ent:GetClass()~="C_BaseFlexclass") then
					EntTable[ent:EntIndex()] = ent
				--end
			end
		end

		return EntTable
	end


	local GreenSelected = Color(0, 255, 0, 255)
	function AdvDupe2.DrawSelectionBox()

		local TraceRes = util.TraceLine(util.GetPlayerTrace(LocalPlayer()))
		local i = math.Clamp(tonumber(LocalPlayer():GetInfo("advdupe2_area_copy_size")) or 50, 0, 30720)

		--Bottom Points
		local B1 = (Vector(-i,-i,-i) + TraceRes.HitPos)
		local B2 = (Vector(-i, i,-i) + TraceRes.HitPos)
		local B3 = (Vector( i, i,-i) + TraceRes.HitPos)
		local B4 = (Vector( i,-i,-i) + TraceRes.HitPos)

		--Top Points
		local T1 = (Vector(-i,-i, i) + TraceRes.HitPos):ToScreen()
		local T2 = (Vector(-i, i, i) + TraceRes.HitPos):ToScreen()
		local T3 = (Vector( i, i, i) + TraceRes.HitPos):ToScreen()
		local T4 = (Vector( i,-i, i) + TraceRes.HitPos):ToScreen()

		if(not AdvDupe2.LastUpdate or CurTime()>=AdvDupe2.LastUpdate) then

			if AdvDupe2.ColorEntities then
				for k,v in pairs(AdvDupe2.EntityColors)do
					local ent = AdvDupe2.ColorEntities[k]
					if(IsValid(ent)) then
						AdvDupe2.ColorEntities[k]:SetColor(v)
					end
				end
			end

			local Entities = FindInBox(B1, (Vector(i,i,i)+TraceRes.HitPos), LocalPlayer())
			AdvDupe2.ColorEntities = Entities
			AdvDupe2.EntityColors = {}
			for k,v in pairs(Entities)do
				AdvDupe2.EntityColors[k] = v:GetColor()
				v:SetColor(GreenSelected)
			end
			AdvDupe2.LastUpdate = CurTime()+0.25

		end

		local tracedata = {}
		tracedata.mask = MASK_NPCWORLDSTATIC
		local WorldTrace

		tracedata.start = B1+Vector(0,0,i*2)
		tracedata.endpos = B1
		WorldTrace = util.TraceLine( tracedata )
		B1 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B2+Vector(0,0,i*2)
		tracedata.endpos = B2
		WorldTrace = util.TraceLine( tracedata )
		B2 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B3+Vector(0,0,i*2)
		tracedata.endpos = B3
		WorldTrace = util.TraceLine( tracedata )
		B3 = WorldTrace.HitPos:ToScreen()
		tracedata.start = B4+Vector(0,0,i*2)
		tracedata.endpos = B4
		WorldTrace = util.TraceLine( tracedata )
		B4 = WorldTrace.HitPos:ToScreen()

		surface.SetDrawColor( 0, 255, 0, 255 )

		--Draw Sides
		surface.DrawLine(B1.x, B1.y, T1.x, T1.y)
		surface.DrawLine(B2.x, B2.y, T2.x, T2.y)
		surface.DrawLine(B3.x, B3.y, T3.x, T3.y)
		surface.DrawLine(B4.x, B4.y, T4.x, T4.y)

		--Draw Bottom
		surface.DrawLine(B1.x, B1.y, B2.x, B2.y)
		surface.DrawLine(B2.x, B2.y, B3.x, B3.y)
		surface.DrawLine(B3.x, B3.y, B4.x, B4.y)
		surface.DrawLine(B4.x, B4.y, B1.x, B1.y)

		--Draw Top
		surface.DrawLine(T1.x, T1.y, T2.x, T2.y)
		surface.DrawLine(T2.x, T2.y, T3.x, T3.y)
		surface.DrawLine(T3.x, T3.y, T4.x, T4.y)
		surface.DrawLine(T4.x, T4.y, T1.x, T1.y)

	end

	net.Receive("AdvDupe2_DrawSelectBox", function()
		hook.Add("HUDPaint", "AdvDupe2_DrawSelectionBox", AdvDupe2.DrawSelectionBox)
	end)

	function AdvDupe2.RemoveSelectBox()
		hook.Remove("HUDPaint", "AdvDupe2_DrawSelectionBox")
		if AdvDupe2.ColorEntities then
			for k,v in pairs(AdvDupe2.EntityColors)do
				if(not IsValid(AdvDupe2.ColorEntities[k])) then
					AdvDupe2.ColorEntities[k]=nil
				else
					AdvDupe2.ColorEntities[k]:SetColor(v)
				end
			end
			AdvDupe2.ColorEntities={}
			AdvDupe2.EntityColors={}
		end
	end
	net.Receive("AdvDupe2_RemoveSelectBox",function()
		AdvDupe2.RemoveSelectBox()
	end)

	function AdvDupe2.InitProgressBar(label)
		AdvDupe2.ProgressBar = {}
		AdvDupe2.ProgressBar.Text = label
		AdvDupe2.ProgressBar.Percent = 0
		AdvDupe2.BusyBar = true
	end
	net.Receive("AdvDupe2_InitProgressBar", function()
		AdvDupe2.InitProgressBar(net.ReadString())
	end)

	net.Receive("AdvDupe2_UpdateProgressBar", function()
		AdvDupe2.ProgressBar.Percent = net.ReadFloat()
	end)

	function AdvDupe2.RemoveProgressBar()
		AdvDupe2.ProgressBar = {}
		AdvDupe2.BusyBar = false
		if(AdvDupe2.Ghosting) then
			AdvDupe2.InitProgressBar("Ghosting: ")
			AdvDupe2.BusyBar = false
			AdvDupe2.ProgressBar.Percent = AdvDupe2.CurrentGhost/AdvDupe2.TotalGhosts*100
		end
	end
	net.Receive("AdvDupe2_RemoveProgressBar", function()
		AdvDupe2.RemoveProgressBar()
	end)

	net.Receive("AdvDupe2_ResetOffsets", function()
		RunConsoleCommand("advdupe2_original_origin", "0")
		RunConsoleCommand("advdupe2_paste_constraints","1")
		RunConsoleCommand("advdupe2_offset_z","0")
		RunConsoleCommand("advdupe2_offset_pitch","0")
		RunConsoleCommand("advdupe2_offset_yaw","0")
		RunConsoleCommand("advdupe2_offset_roll","0")
		RunConsoleCommand("advdupe2_paste_parents","1")
		RunConsoleCommand("advdupe2_paste_disparents","0")
	end)

	net.Receive("AdvDupe2_ReportModel", function()
		print("Advanced Duplicator 2: Invalid Model: "..net.ReadString())
	end)

	net.Receive("AdvDupe2_ReportClass", function()
		print("Advanced Duplicator 2: Invalid Class: "..net.ReadString())
	end)

	net.Receive("AdvDupe2_ResetDupeInfo", function()
		if not AdvDupe2.Info then return end
		AdvDupe2.Info.File:SetText("File:")
		AdvDupe2.Info.Creator:SetText("Creator:")
		AdvDupe2.Info.Date:SetText("Date:")
		AdvDupe2.Info.Time:SetText("Time:")
		AdvDupe2.Info.Size:SetText("Size:")
		AdvDupe2.Info.Desc:SetText("Desc:")
		AdvDupe2.Info.Entities:SetText("Entities:")
		AdvDupe2.Info.Constraints:SetText("Constraints:")
	end)

	net.Receive("AdvDupe2_CanAutoSave", function()
		if(AdvDupe2.AutoSavePath~="") then
			AdvDupe2.AutoSavePos = net.ReadVector()
			AdvDupe2.AutoSaveSize = net.ReadFloat()
			local ent = net.ReadUInt(16)
			AdvDupe2.OffButton:SetDisabled(false)
			net.Start("AdvDupe2_CanAutoSave")
				net.WriteString(AdvDupe2.AutoSaveDesc)
				net.WriteInt(ent, 16)
				if(game.SinglePlayer()) then
					net.WriteString(string.sub(AdvDupe2.AutoSavePath, 10, #AdvDupe2.AutoSavePath))
				end
			net.SendToServer()
		else
			AdvDupe2.Notify("Select a directory for the Area Auto Save.", NOTIFY_ERROR)
		end
	end)

	net.Receive("AdvDupe2_SetDupeInfo", function(len, ply, len2)
		if AdvDupe2.Info then
			AdvDupe2.Info.File:SetText("File: "..net.ReadString())
			AdvDupe2.Info.Creator:SetText("Creator: "..net.ReadString())
			AdvDupe2.Info.Date:SetText("Date: "..net.ReadString())
			AdvDupe2.Info.Time:SetText("Time: "..net.ReadString())
			AdvDupe2.Info.Size:SetText("Size: "..net.ReadString())
			AdvDupe2.Info.Desc:SetText("Desc: "..net.ReadString())
			AdvDupe2.Info.Entities:SetText("Entities: "..net.ReadString())
			AdvDupe2.Info.Constraints:SetText("Constraints: "..net.ReadString())
		else
			AdvDupe2.InfoText.File = "File: "..net.ReadString()
			AdvDupe2.InfoText.Creator = "Creator: "..net.ReadString()
			AdvDupe2.InfoText.Date = "Date: "..net.ReadString()
			AdvDupe2.InfoText.Time = "Time: "..net.ReadString()
			AdvDupe2.InfoText.Size = "Size: "..net.ReadString()
			AdvDupe2.InfoText.Desc = "Desc: "..net.ReadString()
			AdvDupe2.InfoText.Entities = "Entities: "..net.ReadString()
			AdvDupe2.InfoText.Constraints = "Constraints: "..net.ReadString()
		end
	end)
end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/button.lua:

TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.button.name"

TOOL.ClientConVar[ "model" ] = "models/maxofs2d/button_05.mdl"
TOOL.ClientConVar[ "keygroup" ] = "37"
TOOL.ClientConVar[ "description" ] = ""
TOOL.ClientConVar[ "toggle" ] = "1"

TOOL.Information = {
	{ name = "left" },
	{ name = "right" }
}

cleanup.Register( "buttons" )

local function IsValidButtonModel( model )
	for mdl, _ in pairs( list.Get( "ButtonModels" ) ) do
		if ( mdl:lower() == model:lower() ) then return true end
	end
	return false
end

function TOOL:RightClick( trace, worldweld )

	if ( IsValid( trace.Entity ) && trace.Entity:IsPlayer() ) then return false end
	if ( SERVER && !util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) ) then return false end
	if ( CLIENT ) then return true end

	local model = self:GetClientInfo( "model" )
	local key = self:GetClientNumber( "keygroup" )
	local description = self:GetClientInfo( "description" )
	local toggle = self:GetClientNumber( "toggle" ) == 1
	local ply = self:GetOwner()

	-- If we shot a button change its settings
	if ( IsValid( trace.Entity ) && trace.Entity:GetClass() == "gmod_button" && trace.Entity:CPPIGetOwner() == ply ) then
		trace.Entity:SetKey( key )
		trace.Entity:SetLabel( description )
		trace.Entity:SetIsToggle( toggle )

		return true
	end

	-- Check the model's validity
	if ( !util.IsValidModel( model ) || !util.IsValidProp( model ) || !IsValidButtonModel( model ) ) then return false end
	if ( !self:GetSWEP():CheckLimit( "buttons" ) ) then return false end

	local Ang = trace.HitNormal:Angle()
	Ang.pitch = Ang.pitch + 90

	local button = MakeButton( ply, model, Ang, trace.HitPos, key, description, toggle )

	local min = button:OBBMins()
	button:SetPos( trace.HitPos - trace.HitNormal * min.z )

	undo.Create( "Button" )
		undo.AddEntity( button )

		if ( worldweld && trace.Entity != NULL ) then
			local weld = constraint.Weld( button, trace.Entity, 0, trace.PhysicsBone, 0, 0, true )

			if ( IsValid( button:GetPhysicsObject() ) ) then button:GetPhysicsObject():EnableCollisions( false ) end
			button:SetCollisionGroup( COLLISION_GROUP_WORLD )
			button.nocollide = true

			ply:AddCleanup( "buttons", weld )
			undo.AddEntity( weld )
		end

		undo.SetPlayer( ply )
	undo.Finish()

	return true

end

function TOOL:LeftClick( trace )

	return self:RightClick( trace, true )

end

if ( SERVER ) then

	function MakeButton( pl, model, ang, pos, key, description, toggle, nocollide )

		if ( IsValid( pl ) && !pl:CheckLimit( "buttons" ) ) then return false end
		if ( !IsValidButtonModel( model ) ) then return false end

		local button = ents.Create( "gmod_button" )
		if ( !IsValid( button ) ) then return false end
		button:SetModel( model )

		button:SetAngles( ang )
		button:SetPos( pos )
		button:Spawn()

		button:CPPISetOwner( pl )
		button:SetKey( key )
		button:SetLabel( description )
		button:SetIsToggle( toggle )

		if ( nocollide == true ) then
			if ( IsValid( button:GetPhysicsObject() ) ) then button:GetPhysicsObject():EnableCollisions( false ) end
			button:SetCollisionGroup( COLLISION_GROUP_WORLD )
		end

		table.Merge( button:GetTable(), {
			key = key,
			pl = pl,
			toggle = toggle,
			nocollide = nocollide,
			description = description
		} )

		if ( IsValid( pl ) ) then
			pl:AddCount( "buttons", button )
			pl:AddCleanup( "buttons", button )
		end

		return button

	end

	duplicator.RegisterEntityClass( "gmod_button", MakeButton, "Model", "Ang", "Pos", "key", "description", "toggle", "nocollide" )

end

function TOOL:UpdateGhostButton( ent, ply )

	if ( !IsValid( ent ) ) then return end

	local trace = ply:GetEyeTrace()
	if ( !trace.Hit || IsValid( trace.Entity ) && ( trace.Entity:GetClass() == "gmod_button" || trace.Entity:IsPlayer() ) ) then
		ent:SetNoDraw( true )
		return
	end

	local ang = trace.HitNormal:Angle()
	ang.pitch = ang.pitch + 90

	local min = ent:OBBMins()
	ent:SetPos( trace.HitPos - trace.HitNormal * min.z )
	ent:SetAngles( ang )

	ent:SetNoDraw( false )

end

function TOOL:Think()

	local mdl = self:GetClientInfo( "model" )
	if ( !IsValidButtonModel( mdl ) ) then self:ReleaseGhostEntity() return end

	if ( !IsValid( self.GhostEntity ) || self.GhostEntity:GetModel() != mdl ) then
		self:MakeGhostEntity( mdl, vector_origin, angle_zero )
	end

	self:UpdateGhostButton( self.GhostEntity, self:GetOwner() )

end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "Header", { Description = "#tool.button.desc" } )

	CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "button", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

	CPanel:AddControl( "Numpad", { Label = "#tool.button.key", Command = "button_keygroup" } )

	CPanel:AddControl( "TextBox", { Label = "#tool.button.text", Command = "button_description", MaxLenth = "20" } )

	CPanel:AddControl( "CheckBox", { Label = "#tool.button.toggle", Command = "button_toggle", Help = true } )

	CPanel:AddControl( "PropSelect", { Label = "#tool.button.model", ConVar = "button_model", Height = 0, Models = list.Get( "ButtonModels" ) } )

end

list.Set( "ButtonModels", "models/maxofs2d/button_01.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_02.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_03.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_04.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_05.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_06.mdl", {} )
list.Set( "ButtonModels", "models/maxofs2d/button_slider.mdl", {} )

--list.Set( "ButtonModels", "models/dav0r/buttons/button.mdl", {} )
--list.Set( "ButtonModels", "models/dav0r/buttons/switch.mdl", {} )

--addons/weapon_hover/lua/weapons/gmod_tool/stools/vgui/hoverboard_gui.lua:

function PANEL:Init( )

	//self.AttributePoints = 5
	self.Attributes = {}

	self.BoardSelect = vgui.Create( "PropSelect", self )
	self.BoardSelect:SetConVar( "hoverboard_model" )
	self.BoardSelect.Label:SetText( "Select Model" )

	/*self.PointsText = vgui.Create( "DLabel", self )
	self.PointsText:SetText( "Attribute Points: 0" )
	self.PointsText:SetDark( true )
	self.PointsText:SizeToContents()*/

	self:AddAttribute( "Speed" )
	self:AddAttribute( "Jump" )
	self:AddAttribute( "Turn" )
	self:AddAttribute( "Flip" )
	self:AddAttribute( "Twist" )

end

function PANEL:PerformLayout( )

	local vspacing = 10
	local ypos = 0

	self.BoardSelect:SetPos( 0, ypos )
	self.BoardSelect:SetSize( self:GetWide(), 165 )
	ypos = self.BoardSelect.Y + self.BoardSelect:GetTall() + vspacing

	/*self.PointsText:SetPos( 0, ypos )
	ypos = self.PointsText.Y + self.PointsText:GetTall() + vspacing*/

	for _, panel in pairs( self.Attributes ) do

		panel:SetPos( 0, ypos )
		panel:SetSize( self:GetWide(), panel:GetTall() )
		ypos = panel.Y + panel:GetTall() + vspacing

	end

	self:SetHeight( ypos )

	self:UpdatePoints()

end

/*local HoverPoints = 5
net.Receive( "rb655_hoverpoints", function()
	HoverPoints = tonumber( net.ReadString() )
end )*/

function PANEL:Think( )

	/*local points = HoverPoints

	if ( points != self.AttributePoints ) then

		points = math.max( tonumber( points ), 10 )

		for name, panel in pairs( self.Attributes ) do

			panel:SetValue( 0 )
			panel:ValueChanged( 0 )
			panel:InvalidateLayout()

		end

		self.AttributePoints = points

		self:UpdatePoints()

	end*/

	if ( self.HoverboardTable ) then

		local selected = GetConVarString( self.BoardSelect:ConVar() )

		if ( selected != self.LastSelectedBoard ) then

			self.LastSelectedBoard = selected

			for name, panel in pairs( self.Attributes ) do

				panel:SetText( name )
				panel.Label:SetTextColor( panel.OldFontColor )

			end

			/*for _, board in pairs( self.HoverboardTable ) do

				if ( selected:lower() == board[ 'model' ]:lower() ) then

					for k, v in pairs( board[ 'bonus' ] ) do

						for name, panel in pairs( self.Attributes ) do

							if ( panel.Attribute == k:lower() ) then

								panel:SetText( ("%s +%d"):format( name, tonumber( v ) ) )
								panel.Label:SetTextColor( Color( 0, 200, 0, 255 ) )

							end

						end

					end

					break

				end

			end*/

		end

	end

end

function PANEL:PopulateBoards( tbl )

	for _, board in pairs( tbl ) do

		self.BoardSelect:AddModel( board[ 'model' ] )

		self.BoardSelect.Controls[ #self.BoardSelect.Controls ]:SetToolTip( board[ 'name' ] or "Unknown" )

	end

	self.HoverboardTable = tbl

end

function PANEL:GetUsedPoints( ignore )

	local count = 0

	/*for _, panel in pairs( self.Attributes ) do

		if ( panel != ignore ) then

			count = count + panel:GetValue()

		end

	end*/

	return count

end

function PANEL:UpdatePoints( )

	/*self.PointsText:SetText( ( "Attribute Points: %d/%s" ):format( self.AttributePoints - self:GetUsedPoints(), self.AttributePoints ) )
	self.PointsText:SizeToContents()*/

end

function PANEL:AddAttribute( name )

	local panel = vgui.Create( "DNumSlider", self )
	panel:SetText( name )
	panel:SetMin( 0 )
	panel:SetMax( 16 )

	panel:SetDark( true )
	panel:SetDecimals( 0 )
	panel:SetConVar( ( "hoverboard_%s" ):format( name:lower() ) )
	panel.Attribute = name:lower()
	panel.OnValueChanged = function( slider, val )


		val = math.Clamp( tonumber( val ), 0, 16 )
		slider:SetValue( val )

		/*local count = self:GetUsedPoints( slider )

		if ( count + val > self.AttributePoints ) then

			val = self.AttributePoints - count

			val = math.Clamp( tonumber( val ), 0, 16 )
			slider:SetValue( val )
			slider:ValueChanged( val )
			slider:InvalidateLayout()

		end

		self:UpdatePoints()*/

	end

	panel.OldFontColor = panel.Label:GetTextColor()

	self.Attributes[ name ] = panel

end

--addons/tool_permaprop/lua/weapons/gmod_tool/stools/permaprops.lua:
/*
	PermaProps
	Created by Entoros, June 2010
	Facepunch: http://www.facepunch.com/member.php?u=180808
	Modified By Malboro 28 / 12 / 2012
	
	Ideas:
		Make permaprops cleanup-able
		
	Errors:
		Errors on die

	Remake:
		By Malboro the 28/12/2012
*/

TOOL.Category		=	"Admin"
TOOL.Name			=	"PermaProps"
TOOL.Command		=	nil
TOOL.ConfigName		=	""

if CLIENT then
	language.Add("Tool.permaprops.name", "PermaProps")
	language.Add("Tool.permaprops.desc", "Save a props permanently")
	language.Add("Tool.permaprops.0", "LeftClick: Add RightClick: Remove Reload: Update")

	surface.CreateFont("PermaPropsToolScreenFont", { font = "Arial", size = 40, weight = 1000, antialias = true, additive = false })
	surface.CreateFont("PermaPropsToolScreenSubFont", { font = "Arial", size = 30, weight = 1000, antialias = true, additive = false })
end

function TOOL:LeftClick(trace)

	if CLIENT then return true end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end
	
	if !PermaProps.HasPermission( ply, "Save") then return end

	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
	if ent.PermaProps then ply:ChatPrint( "That entity is already permanent !" ) return end

	local content = PermaProps.PPGetEntTable(ent)
	if not content then return end

	local max = tonumber(sql.QueryValue("SELECT MAX(id) FROM permaprops;"))
	if not max then max = 1 else max = max + 1 end

	local new_ent = PermaProps.PPEntityFromTable(content, max)
	if !new_ent or !new_ent:IsValid() then return end

	PermaProps.SparksEffect( ent )

	PermaProps.SQL.Query("INSERT INTO permaprops (id, map, content) VALUES(NULL, ".. sql.SQLStr(game.GetMap()) ..", ".. sql.SQLStr(util.TableToJSON(content)) ..");")
	ply:ChatPrint("You saved " .. ent:GetClass() .. " with model ".. ent:GetModel() .. " to the database.")

	ent:Remove()

	return true

end

function TOOL:RightClick(trace)

	if CLIENT then return true end

	local ent = trace.Entity
	local ply = self:GetOwner()

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end

	if !PermaProps.HasPermission( ply, "Delete") then return end

	if not ent:IsValid() then ply:ChatPrint( "That is not a valid entity !" ) return end
	if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
	if not ent.PermaProps then ply:ChatPrint( "That is not a PermaProp !" ) return end
	if not ent.PermaProps_ID then ply:ChatPrint( "ERROR: ID not found" ) return end

	PermaProps.SQL.Query("DELETE FROM permaprops WHERE id = ".. ent.PermaProps_ID ..";")

	ply:ChatPrint("You erased " .. ent:GetClass() .. " with a model of " .. ent:GetModel() .. " from the database.")

	ent:Remove()

	return true

end

function TOOL:Reload(trace)

	if CLIENT then return true end

	if not PermaProps then ply:ChatPrint( "ERROR: Lib not found" ) return end

	if (not trace.Entity:IsValid()) then 
	    if !PermaProps.HasPermission( self:GetOwner(), "Update") then 
	        return 
	    end 
	    
	    self:GetOwner():ChatPrint( "You have reload all PermaProps !" ) 
	    
	    PermaProps.ReloadPermaProps() 
	    return false 
	end
	
	if trace.Entity.PermaProps then

		local ent = trace.Entity
		local ply = self:GetOwner()

		if !PermaProps.HasPermission( ply, "Update") then return end

		if ent:IsPlayer() then ply:ChatPrint( "That is a player !" ) return end
		
		local content = PermaProps.PPGetEntTable(ent)
		if not content then return end

		PermaProps.SQL.Query("UPDATE permaprops set content = ".. sql.SQLStr(util.TableToJSON(content)) .." WHERE id = ".. ent.PermaProps_ID .." AND map = ".. sql.SQLStr(game.GetMap()) .. ";")

		local new_ent = PermaProps.PPEntityFromTable(content, ent.PermaProps_ID)
		if !new_ent or !new_ent:IsValid() then return end

		PermaProps.SparksEffect( ent )

		ply:ChatPrint("You updated the " .. ent:GetClass() .. " in the database.")

		ent:Remove()


	else

		return false

	end

	return true

end

function TOOL.BuildCPanel(panel)

	panel:AddControl("Header",{Text = "PermaProps", Description = "PermaProps\n\nSaves entities across map changes\n"})
	panel:AddControl("Button",{Label = "Open Configuration Menu", Command = "pp_cfg_open"})

end

function TOOL:DrawToolScreen(width, height)

	if SERVER then return end

	surface.SetDrawColor(17, 148, 240, 255)
	surface.DrawRect(0, 0, 256, 256)

	surface.SetFont("PermaPropsToolScreenFont")
	local w, h = surface.GetTextSize(" ")
	surface.SetFont("PermaPropsToolScreenSubFont")
	local w2, h2 = surface.GetTextSize(" ")

	draw.SimpleText("PermaProps", "PermaPropsToolScreenFont", 128, 100, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)
	draw.SimpleText("By Malboro", "PermaPropsToolScreenSubFont", 128, 128 + (h + h2) / 2 - 4, Color(224, 224, 224, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, Color(17, 148, 240, 255), 4)

end
--addons/tool_shadowremover/lua/weapons/gmod_tool/stools/shadowremover.lua:
TOOL.Category = "WayZer's Role Play"
TOOL.Name = "Shadow Remover"
TOOL.Information = {
	{name = "left"},
	{name = "right"}
}

TOOL.ClientConVar["strength"] = "100"

local propCache = {}
if SERVER then
	util.AddNetworkString("LiteTool.ShadowRemover.PlayerInitialSpawn")
	util.AddNetworkString("LiteTool.ShadowRemover.ApplyShadow")
	util.AddNetworkString("LiteTool.ShadowRemover.ResetShadow")

	hook.Add("PlayerInitialSpawn", "LiteTools.ShadowRemover.LoadProps", function(ply)
		timer.Simple(5, function()
			if not IsValid(ply) then return end

			net.Start("LiteTool.ShadowRemover.PlayerInitialSpawn")
				net.WriteTable(propCache)
			net.Send(ply)
		end)
	end)
end

if CLIENT then
	language.Add("tool.shadowremover.name", "Shadow Remover")	
	language.Add("tool.shadowremover.desc", "Удаление теней с пропа.")	
    language.Add("tool.shadowremover.left", "Применить удаления теней.")
    language.Add("tool.shadowremover.right", "Сбросить удаление теней.")

	language.Add("tool.shadowremover.strength", "Яркость")
	language.Add("tool.shadowremover.strength.help", "Насколько ярким должен быть объект в результате %.")
end

function TOOL:BuildBrightnessColor(entity)
	local h, s, v = ColorToHSV(entity:GetColor())
	v = math.Clamp(self:GetClientNumber("strength"), 0, 100)/100

	return HSVToColor(h, s, v)
end

function TOOL:LeftClick(trace)
	if CLIENT then return true end

	local ent = trace.Entity

	propCache[ent] = true
	ent.oldColor = ent.oldColor or ent:GetColor()
	ent:SetColor(ent.oldColor)
	local newColor = self:BuildBrightnessColor(ent)
	ent:SetColor(newColor)

	net.Start("LiteTool.ShadowRemover.ApplyShadow")
		net.WriteEntity(ent)
	net.Broadcast()

	return true
end
function TOOL:RightClick(trace)
	if CLIENT then return true end

	local ent = trace.Entity

	propCache[ent] = nil
	ent:SetColor(ent.oldColor)
	ent.oldColor = nil

	net.Start("LiteTool.ShadowRemover.ResetShadow")
		net.WriteEntity(ent)
	net.Broadcast()

	return true
end

function TOOL.BuildCPanel(panel)
	panel:AddControl("Header", {Text = "#tool.shadowremover.name", Description = "#tool.shadowremover.desc"})
	panel:AddControl("Slider", {Label = "#tool.shadowremover.strength", Command = "shadowremover_strength", Type = "Int", Min = 0, Max = 100})
end


if CLIENT then
	net.Receive("LiteTool.ShadowRemover.ApplyShadow", function()
		local ent = net.ReadEntity()
		ent.RenderOverride = function(self) render.SuppressEngineLighting(true) self:DrawModel() render.SuppressEngineLighting(false) end
	end)

	net.Receive("LiteTool.ShadowRemover.ResetShadow", function()
		local ent = net.ReadEntity()
		ent.RenderOverride = function(self) self:DrawModel() end
	end)

	net.Receive("LiteTool.ShadowRemover.PlayerInitialSpawn", function()
		local props = net.ReadTable()

		for k, v in pairs(props) do
			k.RenderOverride = function(self) render.SuppressEngineLighting(true) self:DrawModel() render.SuppressEngineLighting(false) end
		end
	end)
end
--addons/tool_submaterial/lua/weapons/gmod_tool/stools/submaterial.lua:

TOOL.Category = "VIP"
TOOL.Name = "SubMaterial"--"#tool.material.name"
if CLIENT then
	language.Add( "tool.submaterial.name", "SubMaterial Tool" )
	language.Add( "tool.submaterial.desc", "Allow to override submaterials of model." )
	language.Add( "tool.submaterial.0", "Wheel Up/Down: Select target part, Primary: Apply material, Secondary: Set default material, Reload: Copy material" )
	language.Add( "tool.submaterial.help", "Select material here, type known material string or use HUD to copy materials" )
end
TOOL.ClientConVar[ "override" ] = "debug/env_cubemap_model"
TOOL.ClientConVar[ "index" ] = 0

--
-- Duplicator function
--
local function SetSubMaterial( Player, Entity, Data )
	
	if ( SERVER ) then
		local Mats=Entity:GetMaterials()
		local MatCount=table.Count(Mats)
		for i=0,MatCount-1 do
			local si="SubMaterialOverride_"..tostring(i)
			-- Block exploitable material in multiplayer and remove empty strings
			if Data[si] and (string.lower(Data[si]) == "pp/copy" or Data[si] == "" ) then 
				Data[si]=nil
			end
            
            
			if ( !list.Contains( "OverrideMaterials", Data[si] ) && Data[si] != nil ) then return end
			
			
			Entity:SetSubMaterial( i, Data[si] or "")			
		end
		duplicator.ClearEntityModifier( Entity, "submaterial")
		if (table.Count(Data) > 0) then duplicator.StoreEntityModifier( Entity, "submaterial", Data ) end
	end

	return true

end
duplicator.RegisterEntityModifier( "submaterial", SetSubMaterial )

local function UpdateSubMat(Player, Entity, Index, Material)
	local Mats=Entity:GetMaterials()
	local MatCount=table.Count(Mats)
	if Index < 0 or Index >= MatCount then return end
	local Data={}
	for i=0,MatCount-1 do
		local mat=Entity:GetSubMaterial(i)
		if i==Index then mat=Material end
		if mat and mat ~= "" then Data["SubMaterialOverride_"..tostring(i)]=mat end	
	end
	return SetSubMaterial(Player, Entity, Data)		
end


-- Original set material funct
local function SetMaterial( Player, Entity, Data )
	
	if ( SERVER ) then

		--
		-- Make sure this is in the 'allowed' list in multiplayer - to stop people using exploits
		--
		if (!list.Contains( "OverrideMaterials", Data.MaterialOverride ) && Data.MaterialOverride != "" ) then return end
		
		if not Data.MaterialOverride or (Data.MaterialOverride and string.lower(Data.MaterialOverride) == "pp/copy" ) then 
			return
		end
		
		Entity:SetMaterial( Data.MaterialOverride )
		duplicator.StoreEntityModifier( Entity, "material", Data )
	end

	return true

end
--and we will override it because original function eats most of materials even not exploitable! :(
duplicator.RegisterEntityModifier( "material", SetMaterial )


--
-- Left click applies the current material
--
function TOOL:LeftClick( trace )
	if ( !IsValid( trace.Entity ) ) then return end

	if ( CLIENT ) then return true end
	
	if not self:GetOwner():IsVIP() then return end

	local ent = trace.Entity

	if ent:IsPlayer() then return end
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end

	local mat = self:GetClientInfo( "override" )
	local index = self:GetClientNumber( "index" , 0)
	if index < 1 then
		SetMaterial( self:GetOwner(), ent, { MaterialOverride = mat } )
	else
		UpdateSubMat( self:GetOwner(), ent, index-1, mat )
	end	
	return true

end

--
-- Right click reverts the material
--
function TOOL:RightClick( trace )
	
	if ( !IsValid( trace.Entity ) ) then return end

	if ( CLIENT ) then return true end

	if not self:GetOwner():IsVIP() then return end

	local ent = trace.Entity
	
	if ent:IsPlayer() then return end
	if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
	local index = self:GetClientNumber( "index" , 0)
	if index < 1 then
		SetMaterial( self:GetOwner(), ent, { MaterialOverride = "" } )
	else
		UpdateSubMat( self:GetOwner(), ent, index-1, "" )
	end
	return true

end


----- Damn Dirty fix... Thx for Wire Advanced tool developer
	
local function get_active_tool(ply, tool)
	-- find toolgun
	local activeWep = ply:GetActiveWeapon()
	if not IsValid(activeWep) or activeWep:GetClass() ~= "gmod_tool" or activeWep.Mode ~= tool then return end

	return activeWep:GetToolObject(tool)
end
-----------------------------
if CLIENT then


	TOOL.AimEnt = nil
	TOOL.HudData = {}
	TOOL.SelIndx = 1
	TOOL.ToolMatString = ""

	function TOOL:Reload( trace )
		
		if ( !IsValid( trace.Entity ) ) then return end
	
		--if ( CLIENT ) then return true end
	
			local ent = trace.Entity
			if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
			
			--local index = self:GetClientNumber( "index" , 0)
			local mat=self.HudData.EntCurMatString--""

			if !mat or mat ~= "" then
				RunConsoleCommand("submaterial_override",mat)
			end
			--LocalPlayer():ChatPrint("Material ".. (((self.SelIndx < 1) and "[Global]") or tostring(self.SelIndx)).." copied: "..mat)
			--else LocalPlayer():ChatPrint("Empty material!") end
		--end
		return true
	
	end
	


	function TOOL:Scroll(trace,dir)
		if !IsValid(self.AimEnt) then return end
		local Mats=self.AimEnt:GetMaterials()
		local MatCount=table.Count(Mats)
		self.SelIndx = self.SelIndx + dir
		if(self.SelIndx<0) then self.SelIndx = MatCount end
		if(self.SelIndx>MatCount) then self.SelIndx = 0 end
		RunConsoleCommand("submaterial_index",tostring(self.SelIndx))
		return true
		--self.HudData.EntCurMat=Material(self.AimEnt:GetMaterials()[self.SelIndx])
		
	end
	function TOOL:ScrollUp(trace) return self:Scroll(trace,-1) end
	function TOOL:ScrollDown(trace) return self:Scroll(trace,1) end


	
---- Thx wire_adv dev again...
	local function hookfunc( ply, bind, pressed )
		if not pressed then return end
		if bind == "invnext" then
			local self = get_active_tool(ply, "submaterial")
			if not self then return end
			
			return self:ScrollDown(ply:GetEyeTraceNoCursor())
		elseif bind == "invprev" then
			local self = get_active_tool(ply, "submaterial")
			if not self then return end

			return self:ScrollUp(ply:GetEyeTraceNoCursor())
		end
	end
	
	if game.SinglePlayer() then -- wtfgarry (have to have a delay in single player or the hook won't get added)
		timer.Simple(5,function() hook.Add( "PlayerBindPress", "submat_tool_playerbindpress", hookfunc ) end)
	else
		hook.Add( "PlayerBindPress", "submat_tool_playerbindpress", hookfunc )
	end
--------------------------------------------------


	local function FixVertexLitMaterial(Mat)
		
		--
		-- If it's a vertexlitgeneric material we need to change it to be
		-- UnlitGeneric so it doesn't go dark when we enter a dark room
		-- and flicker all about
		--
		if not Mat then return Mat end
		local strImage = Mat:GetName()
		
		if ( string.find( Mat:GetShader(), "VertexLitGeneric" ) || string.find( Mat:GetShader(), "Cable" ) ) then
		
			local t = Mat:GetString( "$basetexture" )
			
			if ( t ) then
			
				local params = {}
				params[ "$basetexture" ] = t
				params[ "$vertexcolor" ] = 1
				params[ "$vertexalpha" ] = 1
				
				Mat = CreateMaterial( strImage .. "_hud_fx", "UnlitGeneric", params )
			
			end
			
		end
		
		return Mat
		
	end	

	function TOOL:Think( )
		local ent=LocalPlayer():GetEyeTraceNoCursor().Entity
		if ( IsValid( ent.AttachedEntity ) ) then ent = ent.AttachedEntity end
		if self.AimEnt ~= ent then
			
			self.AimEnt=ent
			if IsValid(self.AimEnt) then
				self.SelIndx=0
				RunConsoleCommand("submaterial_index",tostring(self.SelIndx))
				self.HudData.Mats=self.AimEnt:GetMaterials()

			end
			--print("ThinkUpdate "..tostring(self.AimEnt))
		end

			if IsValid(self.AimEnt) then
				self.HudData.CurMats=table.Copy(self.HudData.Mats)
				self.HudData.OvrMats={}
	
				local MatCount=table.Count(self.HudData.Mats)
				for i=1,MatCount do
					local mat=self.AimEnt:GetSubMaterial(i-1)
					if mat and mat ~= "" then self.HudData.OvrMats[i]=mat end	
				end
				table.Merge(self.HudData.CurMats,self.HudData.OvrMats)
				self.HudData.GlobalMat=self.AimEnt:GetMaterial()
				local EntCurMatString=self.HudData.GlobalMat
				local EntOrigMatString=self.HudData.GlobalMat
				if self.SelIndx > 0 then EntCurMatString=self.HudData.CurMats[self.SelIndx]; EntOrigMatString=self.HudData.Mats[self.SelIndx] end 
				if self.HudData.EntCurMatString~=EntCurMatString then
					self.HudData.EntCurMatString=EntCurMatString
					self.HudData.EntCurMat=FixVertexLitMaterial(Material(EntCurMatString)) 
				end
				if self.HudData.EntOrigMatString~=EntOrigMatString then
					self.HudData.EntOrigMatString=EntOrigMatString
					self.HudData.EntOrigMat=FixVertexLitMaterial(Material(EntOrigMatString)) 
				end
			end
		
		if IsValid(self.AimEnt) and self.ToolMatString~=GetConVarString("submaterial_override") then
			self.ToolMatString=GetConVarString("submaterial_override")
 			self.HudData.ToolMat=FixVertexLitMaterial(Material(self.ToolMatString))
		end
		
	end
	function TOOL:DrawHUD( )
		if IsValid(self.AimEnt) then

			---- List
			local Rg=ScrW()/2-50
			local MaxW = 0
			local TextH = 0
			surface.SetFont("ChatFont")
			local Hdr=tostring(self.AimEnt)..": "..tostring(table.Count(self.HudData.Mats)).." materials"
			MaxW,TextH=surface.GetTextSize(Hdr)
			local HdrH = TextH+5
			for _,s in pairs(self.HudData.CurMats) do
				local ts,_=surface.GetTextSize(s)
				if MaxW<ts then MaxW=ts end
			end
			local LH=4*2+HdrH+TextH*(1+table.Count(self.HudData.Mats))
			local LW=4*2+MaxW
			local LL=Rg-LW
			local LT=ScrH()/2-LH/2
			surface.SetDrawColor(Color(64,64,95,191))
			--surface.SetMaterial(self.HudData.EntCurMat)
			surface.DrawRect(LL, LT, LW, LH)
			surface.SetTextColor(Color(255,255,255,255))
			surface.SetTextPos(LL+4,LT+4)
			surface.DrawText(Hdr)
			surface.SetDrawColor(Color(255,255,255,255))
			surface.DrawLine(LL+3,LT+4+TextH+3,Rg-3,LT+4+TextH+3)

			surface.SetDrawColor(Color(0,127,0,191))
			surface.DrawRect(LL+3, LT+4+HdrH+TextH*self.SelIndx, LW-3-3, TextH)
			
			local s="<none>"
			if not self.HudData.GlobalMat or self.HudData.GlobalMat == "" then 
				surface.SetTextColor(Color(255,255,255,255)) 
			else surface.SetTextColor(Color(0,0,255,255)); s=self.HudData.GlobalMat end
		
			surface.SetTextPos(LL+4,LT+4+HdrH)
			surface.DrawText(s)



			for i,s in pairs(self.HudData.CurMats) do
				if self.HudData.OvrMats[i] then surface.SetTextColor(Color(255,0,0,255)) else surface.SetTextColor(Color(255,255,255,255)) end
				surface.SetTextPos(LL+4,LT+4+HdrH+TextH*i)
				surface.DrawText(s)
			end
			---- Info box
			
			
			--local MaxW = 0
			local StrToolInfo = "Tool material:"
			local StrOrigMatInfo = "Model original material:"
			local StrCurMatInfo = "Model current material:"
			local MaxW,_=surface.GetTextSize(StrToolInfo)
			local ts,_=surface.GetTextSize(StrOrigMatInfo)
			if MaxW<ts then MaxW=ts end
			local ts,_=surface.GetTextSize(StrCurMatInfo)
			if MaxW<ts then MaxW=ts end
			local ts,_=surface.GetTextSize(self.ToolMatString)
			if MaxW<ts then MaxW=ts end
			local ts,_=surface.GetTextSize(self.HudData.EntOrigMatString)
			if MaxW<ts then MaxW=ts end
			local ts,_=surface.GetTextSize(self.HudData.EntCurMatString)
			if MaxW<ts then MaxW=ts end
		
			local IL=ScrW()/2+50
			local IH=4*4+(64)*3
			local IT=ScrH()/2-IH/2
			surface.SetDrawColor(Color(64,64,95,191))
			surface.DrawRect(IL, IT, 76+MaxW, IH)    -- 4+64+4+MaxW+4

			surface.SetTextColor(Color(255,255,255,255))

			surface.SetDrawColor(Color(255,255,255,255))
			if self.HudData.ToolMat  then
				surface.SetMaterial(self.HudData.ToolMat)
				surface.DrawTexturedRect(IL+4, IT+4, 64, 64)
			end
			surface.SetTextPos(IL+4+64+4,IT+8)
			surface.DrawText(StrToolInfo)
			surface.SetTextPos(IL+4+64+4,IT+8+TextH)
			surface.DrawText(self.ToolMatString)
			surface.SetTextPos(IL+4+64+4,IT+8+TextH*2)
			surface.DrawText(self.SelIndx==0 and "[Global]" or "Index: "..self.SelIndx-1)
	
						

			if self.HudData.EntOrigMat  then
				surface.SetMaterial(self.HudData.EntOrigMat)	
				surface.DrawTexturedRect(IL+4, IT+4+(64+4), 64, 64)
			end
			surface.SetTextPos(IL+4+64+4,IT+8+64+4)
			surface.DrawText(StrOrigMatInfo)
			surface.SetTextPos(IL+4+64+4,IT+8+64+4+TextH)
			surface.DrawText(self.HudData.EntOrigMatString)

			if self.HudData.EntCurMat  then
				surface.SetMaterial(self.HudData.EntCurMat)
				surface.DrawTexturedRect(IL+4, IT+4+(64+4)*2, 64, 64)
			end
			surface.SetTextPos(IL+4+64+4,IT+8+(64+4)*2)
			surface.DrawText(StrCurMatInfo)
			surface.SetTextPos(IL+4+64+4,IT+8+(64+4)*2+TextH)
			surface.DrawText(self.HudData.EntCurMatString)


--			surface.SetMaterial(nil)
			

			--draw.RoundedBox( 2, ScrW()/2-50, ScrH()/2-50, 100, 100, Color(255,255,255,255) ) 
			
		--	print("DrawHUD "..tostring(self.AimEnt))
		end
	end


end

function TOOL.BuildCPanel( CPanel )

	--CPanel:AddControl( "Slider", { Label = "Index", Command = "submaterial_index", Type = "Integer", Min = 0, Max = 15} )
	CPanel:AddControl( "Header", { Description = "#tool.submaterial.help" } )

	CPanel:AddControl( "TextBox", { Label = "Mat:", Command = "submaterial_override", MaxLength = "48"} )
	CPanel:MatSelect( "submaterial_override", list.Get( "OverrideMaterials" ), true, 64, 64 )

end

--gamemodes/darkrp/entities/weapons/gmod_tool/stools/weld.lua:

TOOL.Category = "WayZer's Role Play"
TOOL.Name = "#tool.weld.name"

TOOL.ClientConVar[ "forcelimit" ] = "0"
TOOL.ClientConVar[ "nocollide" ] = "0"

TOOL.Information = {
	{ name = "left", stage = 0 },
	{ name = "left_1", stage = 1, op = 2 },
	{ name = "right", stage = 0 },
	{ name = "right_1", stage = 1, op = 1 },
	{ name = "right_2", stage = 2, op = 1 },
	{ name = "reload" }
}

function TOOL:LeftClick( trace )

	if ( self:GetOperation() == 1 ) then return false end
	if ( IsValid( trace.Entity ) && trace.Entity:IsPlayer() ) then return false end

	-- If there's no physics object then we can't constraint it!
	if ( SERVER && !util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) ) then return false end

	local iNum = self:NumObjects()
	local Phys = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )
	self:SetObject( iNum + 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )

	if ( CLIENT ) then

		if ( iNum > 0 ) then self:ClearObjects() end
		return true

	end

	self:SetOperation( 2 )

	if ( iNum == 0 ) then

		self:SetStage( 1 )
		return true

	end

	if ( iNum == 1 ) then

		-- Get client's CVars
		local forcelimit = self:GetClientNumber( "forcelimit" )
		local nocollide = self:GetClientNumber( "nocollide", 0 ) != 0

		-- Get information we're about to use
		local Ent1, Ent2 = self:GetEnt( 1 ), self:GetEnt( 2 )
		local Bone1, Bone2 = self:GetBone( 1 ), self:GetBone( 2 )

		local constr = constraint.Weld( Ent1, Ent2, Bone1, Bone2, forcelimit, nocollide )
		if ( IsValid( constr ) ) then

			undo.Create( "Weld" )
				undo.AddEntity( constr )
				undo.SetPlayer( self:GetOwner() )
			undo.Finish()

			self:GetOwner():AddCleanup( "constraints", constr )

		end

		-- Clear the objects so we're ready to go again
		self:ClearObjects()

	end

	return true

end

function TOOL:RightClick( trace )

	if ( self:GetOperation() == 2 ) then return false end

	-- Make sure the object we're about to use is valid
	local iNum = self:NumObjects()
	local Phys = trace.Entity:GetPhysicsObjectNum( trace.PhysicsBone )

	-- You can click anywhere on the 3rd pass
	if ( iNum < 2 ) then

		-- If there's no physics object then we can't constraint it!
		if ( SERVER && !util.IsValidPhysicsObject( trace.Entity, trace.PhysicsBone ) ) then return false end

		-- Don't weld players, or to players
		if ( trace.Entity:IsPlayer() ) then return false end

		-- Don't do anything with stuff without any physics..
		if ( SERVER && !IsValid( Phys ) ) then return false end

	end

	if ( iNum == 0 ) then

		if ( !IsValid( trace.Entity ) ) then return false end
		if ( trace.Entity:GetClass() == "prop_vehicle_jeep" ) then return false end

	end

	self:SetObject( iNum + 1, trace.Entity, trace.HitPos, Phys, trace.PhysicsBone, trace.HitNormal )
	self:SetOperation( 1 )

	--
	-- Stage 0 - grab an object, make a ghost entity
	--
	if ( iNum == 0 ) then

		self:StartGhostEntity( trace.Entity )
		self:SetStage( 1 )
		return true

	end

	--
	-- Stage 1 - choose the spot and object to weld it to
	--
	if ( iNum == 1 ) then

		if ( CLIENT ) then
			self:ReleaseGhostEntity()
			return true
		end

		-- Get information we're about to use
		local Norm1, Norm2 = self:GetNormal( 1 ), self:GetNormal( 2 )
		local Phys1 = self:GetPhys( 1 )
		local WPos2 = self:GetPos( 2 )

		-- Note: To keep stuff ragdoll friendly try to treat things as physics objects rather than entities
		local Ang1, Ang2 = Norm1:Angle(), ( -Norm2 ):Angle()
		local TargetAngle = Phys1:AlignAngles( Ang1, Ang2 )

		Phys1:SetAngles( TargetAngle )

		-- Move the object so that the hitpos on our object is at the second hitpos
		local TargetPos = WPos2 + ( Phys1:GetPos() - self:GetPos( 1 ) )

		-- Set the position
		Phys1:SetPos( TargetPos )
		Phys1:EnableMotion( false )

		-- Wake up the physics object so that the entity updates
		Phys1:Wake()

		self.RotAxis = Norm2

		self:ReleaseGhostEntity()

		self:SetStage( 2 )

		return true

	end

	--
	-- Stage 2 - Weld it in place.
	--
	if ( iNum == 2 ) then

		if ( CLIENT ) then

			self:ClearObjects()
			return true

		end

		-- Get client's CVars
		local forcelimit = self:GetClientNumber( "forcelimit" )
		local nocollide = self:GetClientNumber( "nocollide", 0 ) != 0

		-- Get information we're about to use
		local Ent1, Ent2 = self:GetEnt( 1 ), self:GetEnt( 2 )
		local Bone1, Bone2 = self:GetBone( 1 ),	self:GetBone( 2 )
		local Phys1 = self:GetPhys( 1 )

		-- The entity became invalid half way through
		if ( !IsValid( Ent1 ) ) then

			self:ClearObjects()
			return false

		end

		local constr = constraint.Weld( Ent1, Ent2, Bone1, Bone2, forcelimit, nocollide )
		if ( IsValid( constr ) ) then

			Phys1:EnableMotion( false )

			undo.Create( "Weld" )
				undo.AddEntity( constr )
				undo.SetPlayer( self:GetOwner() )
			undo.Finish()

			self:GetOwner():AddCleanup( "constraints", constr )

		end

		-- Clear the objects so we're ready to go again
		self:ClearObjects()
		return true

	end

end

function TOOL:Think()

	if ( self:NumObjects() < 1 ) then return end

	if ( self:GetOperation() == 1 ) then

		if ( SERVER && !IsValid( self:GetEnt( 1 ) ) ) then

			self:ClearObjects()
			return

		end

		if ( self:NumObjects() == 1 ) then

			self:UpdateGhostEntity()
			return

		end

		if ( SERVER && self:NumObjects() == 2 ) then

			local Phys1 = self:GetPhys( 1 )

			local cmd = self:GetOwner():GetCurrentCommand()

			local degrees = cmd:GetMouseX() * 0.05

			local angle = Phys1:RotateAroundAxis( self.RotAxis, degrees )

			Phys1:SetAngles( angle )

			-- Move so spots join up
			local TargetPos = self:GetPos( 2 ) + ( Phys1:GetPos() - self:GetPos( 1 ) )
			Phys1:SetPos( TargetPos )
			Phys1:Wake()

		end

	end

end

function TOOL:Reload( trace )

	if ( !IsValid( trace.Entity ) || trace.Entity:IsPlayer() ) then return false end
	if ( CLIENT ) then return true end

	self:ClearObjects()

	return constraint.RemoveConstraints( trace.Entity, "Weld" )

end

function TOOL:FreezeMovement()

	return self:GetOperation() == 1 && self:GetStage() == 2

end

function TOOL:Holster()

	self:ClearObjects()

end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( CPanel )

	CPanel:AddControl( "Header", { Description = "#tool.weld.help" } )

	CPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "weld", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )

	CPanel:AddControl( "Slider", { Label = "#tool.forcelimit", Command = "weld_forcelimit", Type = "Float", Min = 0, Max = 1000, Help = true } )
	CPanel:AddControl( "CheckBox", { Label = "#tool.nocollide", Command = "weld_nocollide" } )

end
--addons/module_itemstore/lua/weapons/itemstore_pickup.lua:
if SERVER then
	AddCSLuaFile()
end

SWEP.PrintName = "Инвентарь"

SWEP.Purpose = "Picking up stuff"
SWEP.Instructions = "Primary attack: pick up item\nSecondary attack: view inventory"
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Поднять предмет"},
	{key = MOUSE_RIGHT, desc = "Проверить свой инвентарь"},
}

SWEP.Spawnable = true
SWEP.AdminSpawnable = true
SWEP.ViewModel = "models/weapons/c_arms.mdl"
SWEP.WorldModel = ""
SWEP.UseHands = true

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.Slot               = 1
SWEP.SlotPos 			= 10
SWEP.DrawAmmo           = false
SWEP.DrawCrosshair      = true

function SWEP:Initialize()
	self:SetHoldType( "normal" )
end

function SWEP:OnDrop()
	self:Remove()
end

function SWEP:PrimaryAttack()
	if CLIENT then return end

	self:GetOwner():PickupItem()
end

function SWEP:SecondaryAttack()
	if CLIENT then return end

	self:GetOwner():OpenContainer( self:GetOwner().Inventory:GetID(), itemstore.Translate( "inventory" ), true )
end

--gamemodes/darkrp/entities/weapons/keys/shared.lua:
AddCSLuaFile()


if SERVER then
    AddCSLuaFile("cl_menu.lua")
	util.AddNetworkString('KeysMenu')
	util.AddNetworkString('anim_keys')
end

if CLIENT then
    SWEP.PrintName = "Руки"
    SWEP.Slot = 1
    SWEP.SlotPos = 1
    SWEP.DrawAmmo = false
    SWEP.DrawCrosshair = true

    include("cl_menu.lua")
end

SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "ЛКМ - Закрыть дверь\nПКМ - Открыть дверь\nR - Анимации"
SWEP.Controls = {
    {key = MOUSE_LEFT, desc = "Закрыть дверь"},
    {key = MOUSE_RIGHT, desc = "Открыть дверь"},
    {key = KEY_R, desc = "Анимации"},
}
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.IsDarkRPKeys = true

SWEP.WorldModel = ""
SWEP.ViewModel = Model( "models/hands/weapons/unarmed_c.mdl" )


SWEP.ViewModelFOV = 90
SWEP.ViewModelFlip = false
SWEP.AnimPrefix  = "rpg"

SWEP.UseHands = true

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Запрещено"
SWEP.Sound = "doors/door_latch3.wav"
SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = 0
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = ""

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = 0
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = ""
SWEP.NextReload = 2

function SWEP:Initialize()
    self:SetHoldType("normal")
end

function SWEP:Deploy()
    if CLIENT or not IsValid(self:GetOwner()) then return true end
    self:GetOwner():DrawWorldModel(false)
    return true
end

function SWEP:Holster()
    return true
end

function SWEP:PreDrawViewModel()
    return false
end

local function lookingAtLockable(ply, ent)
    local eyepos = ply:EyePos()
    if not IsValid(ent) then return false end
	
	if ent:IsDoor() then
		if eyepos:DistToSqr(ent:GetPos()) < 4225 then return true end
	elseif ent:IsVehicle() then
		if eyepos:DistToSqr(ent:NearestPoint(eyepos)) < 10000 then return true end
	end

	return false
end

local function lockUnlockAnimation(ply, snd)
    ply:EmitSound("npc/metropolice/gear" .. math.floor(math.Rand(1,7)) .. ".wav")
    timer.Simple(0.9, function() if IsValid(ply) then ply:EmitSound(snd) end end)

	net.Start("anim_keys")
		net.WriteEntity(ply)
		net.WriteString("usekeys")
	net.Broadcast()

    ply:AnimRestartGesture(GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_GMOD_GESTURE_ITEM_PLACE, true)
end

local function doKnock(ply, sound)
    ply:EmitSound(sound, 100, math.random(90, 110))
	net.Start("anim_keys")
		net.WriteEntity(ply)
		net.WriteString("knocking")
	net.Broadcast()

    ply:AnimRestartGesture(GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_HL2MP_GESTURE_RANGE_ATTACK_FIST, true)
end

function SWEP:PrimaryAttack()
	local ply = self:GetOwner()
    local ent = ply:GetEyeTrace().Entity

    if not lookingAtLockable(ply, ent) then return end

    self:SetNextPrimaryFire(CurTime() + 0.3)

    if CLIENT then return end

	if ent:IsDoor() then
		if ent:DoorOwnedBy(ply) or ent:DoorCoOwnedBy(ply) then
			ent:DoorLock()
			lockUnlockAnimation(ply, self.Sound)
		else
			doKnock(ply, "physics/wood/wood_crate_impact_hard2.wav")
		end
	elseif ent:IsVehicle() then
		if ent:CPPIGetOwner() == ply then
			ent:VehicleLock()
			lockUnlockAnimation(ply, self.Sound)
		else
			ply:Notify(1, 3, DarkRP.getPhrase("do_not_own_ent"))
		end
	end
end

function SWEP:SecondaryAttack()
	local ply = self:GetOwner()
    local ent = ply:GetEyeTrace().Entity

    if not lookingAtLockable(ply, ent) then return end

    if CLIENT then return end

	if ent:IsDoor() then
		if ent:DoorOwnedBy(ply) or ent:DoorCoOwnedBy(ply) then
			ent:DoorLock(false)
			lockUnlockAnimation(ply, self.Sound)
		else
			doKnock(ply, "physics/wood/wood_crate_impact_hard3.wav")
			if ply:isCP() then
				ply:EmitSound("openup.wav")
				self:SetNextSecondaryFire(CurTime() + 2)
			end
		end
	elseif ent:IsVehicle() then
		if ent:CPPIGetOwner() == ply then
			ent:VehicleLock(false)
			lockUnlockAnimation(ply, self.Sound)
		else
			ply:Notify(1, 3, DarkRP.getPhrase("do_not_own_ent"))
		end
	end
end


function SWEP:Reload()
    local trace = self:GetOwner():GetEyeTrace()
    if not IsValid(trace.Entity) or (IsValid(trace.Entity) and (not trace.Entity:IsDoor() or self:GetOwner():EyePos():DistToSqr(trace.HitPos) > 40000)) then
        if CLIENT then
            if self.NextReload > CurTime() then return end
            RunConsoleCommand("_DarkRP_AnimationMenu")
            self.NextReload = CurTime() + 2
        end
        return
    end
    if SERVER then
  		net.Start("KeysMenu")
		net.Send(self:GetOwner())
    end
end

function SWEP:Think()
    
	if IsValid( self ) and IsValid(self:GetOwner()) then

		local vm = self:GetOwner():GetViewModel()

		-- in noclip
		if self:GetOwner():GetMoveType() == 8 then

			vm:ResetSequence( vm:LookupSequence( "jump" ) )

		-- If on ladder
		elseif self:GetOwner():GetMoveType() == 9 then
			
			-- if moving
			if self:GetOwner():KeyDown( IN_FORWARD or IN_BACK )  then

				-- climb ladder sequence
				vm:ResetSequence( vm:LookupSequence( "ladder_climb" ) )
				
			else

				-- climb ladder sequence
				vm:ResetSequence( vm:LookupSequence( "ladder_idle" ) )
				
			end

		-- not in noclip
		else

			-- If swimming
			if self:GetOwner():WaterLevel( ) >= 2 then

				-- if moving
				if self:GetOwner():KeyDown( IN_FORWARD or IN_MOVELEFT or IN_MOVERIGHT or IN_BACK )  then

					-- and sprinting
					if self:GetOwner():KeyDown( IN_SPEED ) then

						-- swimming fast
						vm:ResetSequence( vm:LookupSequence( "falling_fast" ) )

					-- not sprinting
					else

						-- swim slow
						vm:ResetSequence( vm:LookupSequence( "falling" ) )

					end

				-- not moving
				else

					-- just be
					vm:ResetSequence( vm:LookupSequence( "falling_slow" ) )
					
				end

			-- in ankle water or not in water
			elseif self:GetOwner():WaterLevel( ) < 2 then
                
				-- on ground
				if self:GetOwner():OnGround( ) then
					-- use key
					if self:GetOwner():KeyDown( IN_USE ) then

                          vm:ResetSequence( vm:LookupSequence( "use" ) )
						
					-- move keys
					elseif self:GetOwner():KeyDown( IN_FORWARD ) or self:GetOwner():KeyDown( IN_BACK )  then

						-- velocity > walkspeed variable

						if self:GetOwner():KeyDown(IN_SPEED) and self:GetOwner():GetVelocity():Length() > self:GetOwner():GetWalkSpeed() and self:GetOwner():GetMoveType() == 2 then
							-- sprinting
							vm:ResetSequence( vm:LookupSequence( "sprint" ) )

						else
					
							-- sprinting
							-- print( "Hands: ON LAND; SPRINT" )
							vm:ResetSequence( vm:LookupSequence( "idle" ) )

						end

					else

						-- print( "Hands: OTHER; IDLE" )
						vm:ResetSequence( vm:LookupSequence( "idle" ) )	

					end

				else

					if self:GetOwner():GetVelocity().z > 10 then

						vm:ResetSequence( vm:LookupSequence( "jump_init" ) )

					elseif self:GetOwner():GetVelocity().z < -250 and self:GetOwner():GetVelocity().z >= -500 then

						vm:ResetSequence( vm:LookupSequence( "falling_slow" ) )

					elseif self:GetOwner():GetVelocity().z < -500 and self:GetOwner():GetVelocity().z >= -750 then

						vm:ResetSequence( vm:LookupSequence( "falling" ) )

					elseif self:GetOwner():GetVelocity().z < -750 then

						vm:ResetSequence( vm:LookupSequence( "falling_fast" ) )

					else

						vm:ResetSequence( vm:LookupSequence( "jump" ) )
						
					end

				end

			else

				-- print( "Hands: OTHER; IDLE" )
				vm:ResetSequence( vm:LookupSequence( "idle" ) )	

			end

		end

	end

end

--gamemodes/darkrp/entities/weapons/keys/cl_menu.lua:
DarkRP.stub{
    name = "openKeysMenu",
    description = "Open the keys/F2 menu.",
    parameters = {},
    realm = "Client",
    returns = {},
    metatable = DarkRP
}

DarkRP.hookStub{
    name = "onKeysMenuOpened",
    description = "Called when the keys menu is opened.",
    parameters = {
        {
            name = "ent",
            description = "The door entity.",
            type = "Entity"
        },
        {
            name = "Frame",
            description = "The keys menu frame.",
            type = "Panel"
        }
    },
    returns = {
    },
    realm = "Client"
}

function DarkRP.openKeysMenu()
    local ent = LocalPlayer():GetEyeTrace().Entity
    if not ent:IsDoor() then return end
    RadialMenu:OpenEntMenu(ent)
end
net.Receive("KeysMenu", DarkRP.openKeysMenu)

--addons/module_css2/lua/weapons/mp_weapon_smart_pistol/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.DrawCrosshair = false
    SWEP.PrintName = "Smart Pistol MK5"
    SWEP.CSMuzzleFlashes = true
    SWEP.AimPos = Vector(-5.139, -2.5, 2.42)
    SWEP.AimAng = Vector(-0.1, -0.674, 1.5)
    SWEP.SprintPos = Vector(0, -17.514, -12.271)
    SWEP.SprintAng = Vector(63.637, 0, 0)
    SWEP.ViewModelMovementScale = 0.7
    SWEP.ZoomAmount = 30
    SWEP.IconLetter = "b"
    SWEP.MuzzleEffect = false
    SWEP.NoShells = true
end

SWEP.FadeCrosshairOnAim = true
SWEP.CanPenetrate = false
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 10
SWEP.BulletDiameter = 11.5
SWEP.CaseLength = 22.8
SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = false
SWEP.AmmoEnt = "item_ammo_revolver_ttt"
SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "pistol"
SWEP.RunHoldType = "normal"

SWEP.FireModes = {"auto", "semi", "safe"}

SWEP.Base = "swb_base"
SWEP.Category = "Премиум"
SWEP.Author = "sqdAva and kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""
SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/p2011sp/ptpov_p2011sp.mdl"
SWEP.WorldModel = "models/weapons/p2011sp/w_p2011sp.mdl"
SWEP.Spawnable = true
SWEP.AdminSpawnable = false
SWEP.Primary.ClipSize = 12
SWEP.Primary.DefaultClip = 48
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "pistol"
SWEP.Primary.MaxAmmo = 128
SWEP.FireDelay = 0.125
SWEP.FireSound = Sound("Weapon_SmartPistol.Single")
SWEP.Recoil = 1
SWEP.DryFire = true
SWEP.HipSpread = 0.8
SWEP.AimSpread = 0.05
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 24
SWEP.DeployTime = 1
SWEP.Lock = 0

function SWEP:CustomFire()

    local attacker = self:GetOwner()
    local aimVector = attacker:GetAimVector()
    local shootPos = attacker:GetShootPos()

    attacker:LagCompensation(true)

    local tr = util.TraceLine({
        start = shootPos,
        endpos = shootPos + aimVector * 1000,
        filter = attacker,
        mask = MASK_SHOT_HULL,
    })


    if not IsValid(tr.Entity) then
        tr = util.TraceHull({
            start = shootPos,
            endpos = shootPos + aimVector * 1000,
            filter = attacker,
            mins = Vector(-16, -16, 0),
            maxs = Vector(16, 16, 0),
            mask = MASK_SHOT_HULL,
        })

        self:SetWeaponHoldType("pistol")
    end

    local inflictor = tr.Entity

    if SERVER and IsValid(inflictor) and (inflictor:IsPlayer() or inflictor:Health() > 0) and self.dt.State ~= 2 then
        local dmginfo = DamageInfo()

        if not IsValid(attacker) then
            attacker = self
        end

        attacker:EmitSound("Weapon_SmartPistol.Lock")
        dmginfo:SetAttacker(attacker)
        dmginfo:SetInflictor(self)
        dmginfo:SetDamage(self.Damage)
        dmginfo:SetDamageForce(attacker:GetForward() * 10000)
        dmginfo:SetDamage(self.Damage)
        inflictor:TakeDamageInfo(dmginfo)
    else
        local bullet = {}
        bullet.Num = self.Primary.NumberofShots
        bullet.Src = shootPos
        bullet.Dir = aimVector
        bullet.Spread = Vector(self.dt.State == SWB_AIMING and self.AimSpread or self.HipSpread * 0.1, self.dt.State == SWB_AIMING and self.AimSpread or self.HipSpread * 0.1, 0)
        bullet.Tracer = 1
        bullet.Damage = self.Damage
        bullet.AmmoType = self.Primary.Ammo
        attacker:FireBullets(bullet)
    end

    if SERVER and IsValid(inflictor) and (inflictor:IsPlayer() or inflictor:Health() > 0) then
        local phys = inflictor:GetPhysicsObject()

        if IsValid(phys) then
            phys:ApplyForceOffset(aimVector * 80 * phys:GetMass(), tr.HitPos)
        end
    end

    self:MakeRecoil()
    self:EmitSound(self.FireSound, 105, 100)

    attacker:LagCompensation(false)
end

function SWEP:CustomHud()
    if self.dt.State == 2 then return end
    local x, y

    if self:GetOwner() == LocalPlayer() and self:GetOwner():ShouldDrawLocalPlayer() then
        local tr = util.GetPlayerTrace(self:GetOwner())
        local trace = util.TraceLine(tr)
        local coords = trace.HitPos:ToScreen()
        x, y = coords.x, coords.y
    else
        x, y = ScrW() / 2, ScrH() / 2
    end

    surface.SetTexture(surface.GetTextureID("vgui/hud/weapons/smart_pistol_reticle"))

    if self.Lock == 1 then
        surface.SetDrawColor(0, 255, 0, 255)
    else
        surface.SetDrawColor(255, 255, 255, 255)
    end

    surface.DrawTexturedRect(x - 128, y - 128, 256, 256)
end

function SWEP:CustomThink()
    local ply = self:GetOwner()
    local shootPos = ply:GetShootPos()
    local aimVector = ply:GetAimVector()

    if self.Weapon:Ammo1() > 128 then
        ply:SetAmmo(128, self.Primary.Ammo)
    end

    local tr = util.TraceLine({
        start = shootPos,
        endpos = shootPos + aimVector * 1000,
        filter = ply,
        mask = MASK_SHOT_HULL,
    })

    if not IsValid(tr.Entity) then
        tr = util.TraceHull({
            start = shootPos,
            endpos = shootPos + aimVector * 1000,
            filter = ply,
            mins = Vector(-16, -16, 0),
            maxs = Vector(16, 16, 0),
            mask = MASK_SHOT_HULL,
        })
    end

    local target = tr.Entity

    if self.Lock == 0 and IsValid(target) and (target:IsNPC() or target:IsPlayer() or target:Health() > 0) and self.dt.State ~= 2 then
        ply:EmitSound("Weapon_SmartPistol.TargetLock")
        self.Lock = 1
    end

    if self.Lock == 1 and not IsValid(target) or self.dt.State == 2 then
        self.Lock = 0
    end
end
--addons/module_css2/lua/weapons/ptp_cs_ak47/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "AK-47"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-6.615, -10.563, 2.417)
	SWEP.AimAng = Vector(2.625, 0, 0)

	SWEP.SprintPos = Vector(1.786, 1.442, 2)
	SWEP.SprintAng = Vector(-10.778, 27.573, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 30
SWEP.BulletDiameter = 7.62
SWEP.CaseLength = 39

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_rif_ak47.mdl"
SWEP.WorldModel = "models/weapons/w_rif_ak47.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 30
SWEP.Primary.DefaultClip = 90
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.115
SWEP.FireSound = Sound("Weapon_AK47.Single")
SWEP.Recoil = 0.8

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.003
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 44
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_elites/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "Dual Elites"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(0, 0, 0)
	SWEP.AimAng = Vector(0, 0, 0)
	
	SWEP.SprintPos = Vector(0, -17.514, -12.271)
	SWEP.SprintAng = Vector(63.637, 0, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"

	SWEP.NoShells = true
	
	SWEP.MuzzleEffect = false
end

SWEP.CanPenetrate = false
SWEP.FadeCrosshairOnAim = false

SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 10
SWEP.BulletDiameter = 11.5
SWEP.CaseLength = 22.8

SWEP.Kind = WEAPON_PISTOL
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_pistol_ttt"

SWEP.Slot = 1
SWEP.SlotPos = 0
SWEP.NormalHoldType = "duel"
SWEP.RunHoldType = "normal"
SWEP.FireModes = {"semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel			= "models/weapons/cstrike/c_pist_elite.mdl"
SWEP.WorldModel			= "models/weapons/w_pist_elite.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable = true

SWEP.Primary.ClipSize = 15
SWEP.Primary.DefaultClip = 45
SWEP.Primary.Automatic = false
SWEP.Primary.Ammo = "pistol"
SWEP.Chamberable = false

SWEP.FireDelay = 0.142
SWEP.FireSound 	= Sound( "Weapon_elite.Single" )
SWEP.Recoil = 1.2
SWEP.DryFire = true

SWEP.HipSpread = 0.04
SWEP.AimSpread = 0.01
SWEP.ClumpSpread = 0.02
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 2
SWEP.Damage = 30
SWEP.DeployTime = 1
--addons/module_css2/lua/weapons/ptp_cs_mp5/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.PrintName = "HK MP5"
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-5.329, -9.28, 2.02)
	SWEP.AimAng = Vector(1.162, 0, 0)
	
	SWEP.SprintPos = Vector(0.736, -3.971, 1.802)
	SWEP.SprintAng = Vector(-13.205, 37.048, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	
	SWEP.IconLetter = "b"

	SWEP.MuzzleEffect = false

end

SWEP.FadeCrosshairOnAim = true


SWEP.CanPenetrate = false
SWEP.PlayBackRate = 30
SWEP.PlayBackRateSV = 12
SWEP.SpeedDec = 20
SWEP.BulletDiameter = 9
SWEP.CaseLength = 19

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true
SWEP.AmmoEnt = "item_ammo_smg1_ttt"

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi", "safe"}
SWEP.Base = "swb_base"
SWEP.Category = "Разрешено"

SWEP.Author = ""
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/cstrike/c_smg_mp5.mdl"
SWEP.WorldModel = "models/weapons/w_smg_mp5.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable	= true

SWEP.Primary.ClipSize = 30
SWEP.Primary.DefaultClip = 90
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.1
SWEP.FireSound = Sound("Weapon_MP5Navy.Single")
SWEP.Recoil = 0.7

SWEP.HipSpread = 0.025
SWEP.AimSpread = 0.006
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 35
SWEP.DeployTime = 1
SWEP.BurstCooldownMul = 3.5
--addons/weapon_chainsaw/lua/weapons/rchainsaw.lua:
SWEP.ViewModelFOV = 53
SWEP.ViewModel = "models/weapons/v_chainsaw.mdl"
SWEP.WorldModel = "models/weapons/w_chainsaw.mdl"
SWEP.Slot = 0
SWEP.HoldType = "physgun" 
SWEP.Spawnable = true
SWEP.AdminSpawnable = false
SWEP.DrawCrosshair = false
SWEP.DrawAmmo = false
SWEP.PrintName = "Бензопила"
SWEP.Author = "LordiAnders"
SWEP.Category = "Запрещено"
SWEP.base = "weapon_base"

SWEP.Primary.ClipSize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Ammo = "none"
SWEP.Primary.Automatic = true

SWEP.Secondary.Ammo = "none"

if CLIENT then
SWEP.WepSelectIcon = surface.GetTextureID("vgui/entities/weapon_chainsaw_new")
killicon.Add( "weapon_chainsaw_new", "vgui/entities/weapon_chainsaw_new", Color( 255, 255, 255, 255 ) )
SWEP.BounceWeaponIcon = false
end

function SWEP:Initialize()
	self:SetHoldType(self.HoldType)
	self:SetDeploySpeed(0.5)
	self.RSaw_Idle = CreateSound(self,"weapons/melee/chainsaw_idle.wav")
	self.RSaw_Attack = CreateSound(self,"weapons/melee/chainsaw_attack.wav")
end

function SWEP:Deploy()
	self:EmitSound("weapons/melee/chainsaw_start_01.wav",42.5)
	self:GetOwner():SetAnimation(PLAYER_RELOAD)
	timer.Create("rsaw_idlesound_start"..self:EntIndex(),3,1,function()
		if not IsValid(self) then return end
		self.RSaw_Idle:Play()
		self.RSaw_Idle:ChangeVolume(0.2,0.01)
	end)
end

function SWEP:Think()
	if self:GetOwner() and IsValid(self:GetOwner()) then
		if self:GetOwner():KeyPressed(IN_ATTACK) then
			self.RSaw_Idle:Stop()
			self.RSaw_Attack:Play()
			self.RSaw_Attack:ChangeVolume(0.2,0.01)
		elseif self:GetOwner():KeyReleased(IN_ATTACK) then
			self.RSaw_Idle:Play()
			self.RSaw_Idle:ChangeVolume(0.2,0.01)
			self.RSaw_Attack:Stop()
		end
	end
end

function SWEP:PrimaryAttack()
	--Trace shit from weapon_fists.lua packed with Gmod
	local owner = self:GetOwner()

	owner:LagCompensation( true )

    local trace = util.TraceLine( {
    	start = owner:GetShootPos(),
    	endpos = owner:GetShootPos() + owner:GetAimVector() * 70,
    	filter = owner
    } )
    
    if ( !IsValid( trace.Entity ) ) then 
    	trace = util.TraceHull( {
    		start = owner:GetShootPos(),
    		endpos = owner:GetShootPos() + owner:GetAimVector() * 70,
    		filter = owner,
    		mins = Vector( -10, -10, -8 ),
    		maxs = Vector( 10, 10, 8 )
    	} )
    end

    owner:LagCompensation( false )
	
	self:SendWeaponAnim(ACT_VM_HITCENTER)
	
	owner:SetAnimation(PLAYER_ATTACK1)

	local ent = trace.Entity
	
	if ent:IsValid() then
		if SERVER then
			if ent:GetClass() == "prop_door_rotating" then
		        --if ent:GetPos():DistToSqr(owner:GetShootPos()) > 10000 then return end
				ent:SetKeyValue("Speed", "500")
				ent:SetKeyValue("Open Direction", "Both directions")
				ent:SetKeyValue("opendir", "0")
				ent:Fire("unlock", "", .01)
				ent:Fire("openawayfrom", "bashingpl" .. owner:EntIndex(), .01)
				ent:EmitSound("ambient/materials/door_hit1.wav", 100, math.random(90, 110))

				timer.Simple(0.3, function()
					if IsValid(ent) then
						ent:SetKeyValue("Speed", "100")
					end
				end)
			else
				ent:TakeDamage(10,owner)
			end
		end
		if ent:IsPlayer() or ent:IsNPC() then
			self.RSaw_Attack:ChangePitch(33,0.75)
			local BLOOOD = EffectData()
			BLOOOD:SetOrigin(trace.HitPos)
			BLOOOD:SetMagnitude(math.random(1,3))
			BLOOOD:SetEntity(trace.Entity)
			util.Effect("bloodstream",BLOOOD)
		end
	else
		self.RSaw_Attack:ChangePitch(100,0.75)
	end
	
	if trace.HitWorld then
		self:SendWeaponAnim(ACT_VM_MISSCENTER)
		local effectdata = EffectData()
		effectdata:SetOrigin(trace.HitPos)
		effectdata:SetNormal(trace.HitNormal)
		effectdata:SetMagnitude(1)
		effectdata:SetScale(2)
		effectdata:SetRadius(1)
		util.Effect("Sparks",effectdata)
		sound.Play("npc/manhack/grind"..math.random(1,5)..".wav",trace.HitPos,75,150)
	end

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.01)
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.25 )
	
end

function SWEP:SecondaryAttack()
end

function SWEP:Holster()
	self:OnRemove()
	if IsValid(self:GetOwner()) then
		self:EmitSound("weapons/melee/chainsaw_die_01.wav",42.5)
	end
	return true
end

function SWEP:OnRemove()
	timer.Destroy("rsaw_idlesound_start"..self:EntIndex())
	if not self.RSaw_Idle then return end
	self.RSaw_Idle:Stop()
	self.RSaw_Attack:Stop()
end
--addons/weapon_spiderswep/lua/weapons/spidermans_swep/cl_init.lua:

include('shared.lua')


function SWEP:CustomAmmoDisplay()

	self.AmmoDisplay = self.AmmoDisplay or {}
	self.AmmoDisplay.Draw = false
	
	self.AmmoDisplay.PrimaryClip 	= 1
	self.AmmoDisplay.PrimaryAmmo 	= -1
	self.AmmoDisplay.SecondaryAmmo 	= -1
	
	return self.AmmoDisplay

end

function SWEP:SetWeaponHoldType( t )
end

local icon = Material('icon72/spider_web.png')
function SWEP:DrawHUD()
	local remaining = self:GetWebsRemaining()
	draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
	draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 116*(remaining/self.MaxWebs), 20, Color( 233, 133, 110, 255 ) )
	draw.DrawText(remaining..'/'..self.MaxWebs, "chelog-ib.small", (ScrW()/2), ScrH()-42, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
	draw.DrawText("Паутина", "DermaLarge", (ScrW()/2), ScrH()-84, color_white, TEXT_ALIGN_CENTER )

	surface.SetDrawColor(0,0,0,255)
	surface.SetMaterial(icon)
	surface.DrawTexturedRect(ScrW() / 2 + 70, ScrH() - 45, 24, 24)
end
--gamemodes/darkrp/entities/weapons/stunstick/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.PrintName = "Дубинка"
    SWEP.Slot = 0
    SWEP.SlotPos = 5
    SWEP.RenderGroup = RENDERGROUP_BOTH

    killicon.AddAlias("stunstick", "weapon_stunstick")
end

DEFINE_BASECLASS("stick_base")

SWEP.Instructions = "Left click to discipline\nRight click to kill\nHold reload to threaten"
SWEP.Controls = {
    {key = MOUSE_LEFT, desc = "Ударить без урона"},
    {key = MOUSE_RIGHT, desc = "Ударить с уроном"},
    {key = KEY_R, desc = "Пригрозить"},
}
SWEP.IsDarkRPStunstick = true

SWEP.Spawnable = true
SWEP.Category = "Запрещено"

SWEP.StickColor = Color(0, 0, 255)

function SWEP:Initialize()
    BaseClass.Initialize(self)

    self.Hit = {
        Sound("weapons/stunstick/stunstick_impact1.wav"),
        Sound("weapons/stunstick/stunstick_impact2.wav")
    }

    self.FleshHit = {
        Sound("weapons/stunstick/stunstick_fleshhit1.wav"),
        Sound("weapons/stunstick/stunstick_fleshhit2.wav")
    }

    if SERVER then return end

    CreateMaterial("darkrp/stunstick_beam", "UnlitGeneric", {
        ["$basetexture"] = "sprites/lgtning",
        ["$additive"] = 1
    })
end

function SWEP:SetupDataTables()
    BaseClass.SetupDataTables(self)
    -- Float 0 = LastPrimaryAttack
    -- Float 1 = ReloadEndTime
    -- Float 2 = BurstTime
    -- Float 3 = LastNonBurst
    -- Float 4 = SeqIdleTime
    -- Float 5 = HoldTypeChangeTime
    self:NetworkVar("Float", 6, "LastReload")
end

function SWEP:Think()
    BaseClass.Think(self)
    if self.WaitingForAttackEffect and self:GetSeqIdleTime() ~= 0 and CurTime() >= self:GetSeqIdleTime() - 0.35 then
        self.WaitingForAttackEffect = false

        local effectData = EffectData()
        effectData:SetOrigin(self:GetOwner():GetShootPos() + (self:GetOwner():EyeAngles():Forward() * 45))
        effectData:SetNormal(self:GetOwner():EyeAngles():Forward())
        util.Effect("StunstickImpact", effectData)
    end
end

function SWEP:DoFlash(ply)
    if not IsValid(ply) or not ply:IsPlayer() then return end

    ply:ScreenFade(SCREENFADE.IN, color_white, 1.2, 0)
end

function SWEP:PostDrawViewModel(vm)
    if self:GetSeqIdleTime() ~= 0 or self:GetLastReload() >= CurTime() - 0.1 then
        local attachment = vm:GetAttachment(1)
        local pos = attachment.Pos
        cam.Start3D(EyePos(), EyeAngles())
            render.SetMaterial(Material("effects/stunstick"))
            render.DrawSprite(pos, 12, 12, Color(180, 180, 180))
            for i = 1, 3 do
                local randVec = VectorRand() * 3
                local offset = (attachment.Ang:Forward() * randVec.x) + (attachment.Ang:Right() * randVec.y) + (attachment.Ang:Up() * randVec.z)
                render.SetMaterial(Material("!darkrp/stunstick_beam"))
                render.DrawBeam(pos, pos + offset, 3.25 - i, 1, 1.25, Color(180, 180, 180))
                pos = pos + offset
            end
        cam.End3D()
    end
end

function SWEP:DrawWorldModelTranslucent()
    if CurTime() <= self:GetLastReload() + 0.1 then
        local bone = self:GetOwner():LookupBone("ValveBiped.Bip01_R_Hand")
        if not bone then self:DrawModel() return end
        local bonePos, boneAng = self:GetOwner():GetBonePosition(bone)
        if bonePos then
            local pos = bonePos + (boneAng:Up() * -16) + (boneAng:Right() * 3) + (boneAng:Forward() * 6.5)
            render.SetMaterial(Material("sprites/light_glow02_add"))
            render.DrawSprite(pos, 32, 32, Color(255, 255, 255))
        end
    end
    self:DrawModel()
end

local entMeta = FindMetaTable("Entity")
function SWEP:DoAttack(dmg)
    if CLIENT then return end

    self:GetOwner():LagCompensation(true)
    local trace = util.QuickTrace(self:GetOwner():EyePos(), self:GetOwner():GetAimVector() * 90, {self:GetOwner()})
    self:GetOwner():LagCompensation(false)
    if IsValid(trace.Entity) and trace.Entity.onStunStickUsed then
        trace.Entity:onStunStickUsed(self:GetOwner())
        return
    elseif IsValid(trace.Entity) and trace.Entity:GetClass() == "func_breakable_surf" then
        trace.Entity:Fire("Shatter")
        self:GetOwner():EmitSound(self.Hit[math.random(1,#self.Hit)])
        return
    end

    self.WaitingForAttackEffect = true

    local ent = self:GetOwner():getEyeSightHitEntity(100, 15, fn.FAnd{fp{fn.Neq, self:GetOwner()}, fc{IsValid, entMeta.GetPhysicsObject}})

    if not IsValid(ent) then return end
    if ent:IsPlayer() and not ent:Alive() then return end

    if not ent:IsDoor() then
        ent:SetVelocity((ent:GetPos() - self:GetOwner():GetPos()) * 7)
    end

    if dmg > 0 then
        ent:TakeDamage(dmg, self:GetOwner(), self)
    end

    if ent:IsPlayer() or ent:IsNPC() or ent:IsVehicle() then
        self:DoFlash(ent)
        self:GetOwner():EmitSound(self.FleshHit[math.random(1,#self.FleshHit)])
    else
        self:GetOwner():EmitSound(self.Hit[math.random(1,#self.Hit)])
        if FPP and FPP.plyCanTouchEnt(self:GetOwner(), ent, "EntityDamage") then
            if ent.SeizeReward and not ent.beenSeized and not ent.burningup and self:GetOwner():isCP() and ent.Getowning_ent and self:GetOwner() ~= ent:Getowning_ent() then
                self:GetOwner():addMoney(ent.SeizeReward)
                DarkRP.notify(self:GetOwner(), 1, 4, DarkRP.getPhrase("you_received_x", DarkRP.formatMoney(ent.SeizeReward), DarkRP.getPhrase("bonus_destroying_entity")))
                ent.beenSeized = true
            end
            ent:TakeDamage(1000-dmg, self:GetOwner(), self) -- for illegal entities
        end
    end
end

function SWEP:PrimaryAttack()
    BaseClass.PrimaryAttack(self)
    self:SetNextSecondaryFire(self:GetNextPrimaryFire())
    self:DoAttack(0)
end

function SWEP:SecondaryAttack()
    BaseClass.PrimaryAttack(self)
    self:SetNextSecondaryFire(self:GetNextPrimaryFire())
    self:DoAttack(10)
end

function SWEP:Reload()
    self:SetHoldType("melee")
    self:SetHoldTypeChangeTime(CurTime() + 0.1)

    if self:GetLastReload() + 0.1 > CurTime() then self:SetLastReload(CurTime()) return end
    self:SetLastReload(CurTime())
    self:EmitSound("weapons/stunstick/spark" .. math.random(1, 3) .. ".wav")
end

--gamemodes/darkrp/entities/weapons/unarrest_stick/shared.lua:
AddCSLuaFile()

if CLIENT then
    SWEP.PrintName = "Cнять арест"
    SWEP.Slot = 1
    SWEP.SlotPos = 3
end

DEFINE_BASECLASS("stick_base")

SWEP.Instructions = "Left click to unarrest\nRight click to switch batons"
SWEP.Controls = {
    {key = MOUSE_LEFT, desc = "Снять арест"},
    {key = MOUSE_RIGHT, desc = "Переключить режим"},
}
SWEP.IsDarkRPUnarrestStick = true

SWEP.Spawnable = true
SWEP.Category = "Запрещено"

SWEP.StickColor = Color(0, 255, 0)

DarkRP.hookStub{
    name = "canUnarrest",
    description = "Whether someone can unarrest another player.",
    parameters = {
        {
            name = "unarrester",
            description = "The player trying to unarrest someone.",
            type = "Player"
        },
        {
            name = "unarrestee",
            description = "The player being unarrested.",
            type = "Player"
        }
    },
    returns = {
        {
            name = "canUnarrest",
            description = "A yes or no as to whether the player can unarrest the other player.",
            type = "boolean"
        },
        {
            name = "message",
            description = "The message that is shown when they can't unarrest the player.",
            type = "string"
        }
    },
    realm = "Server"
}

-- Default for canUnarrest hook
local hookCanUnarrest = {canUnarrest = fp{fn.Id, true}}

function SWEP:Deploy()
    self.Switched = true
    return BaseClass.Deploy(self)
end

function SWEP:PrimaryAttack()
    BaseClass.PrimaryAttack(self)

    if CLIENT then return end

    self:GetOwner():LagCompensation(true)
    local trace = util.QuickTrace(self:GetOwner():EyePos(), self:GetOwner():GetAimVector() * 90, {self:GetOwner()})
    self:GetOwner():LagCompensation(false)
    if IsValid(trace.Entity) and trace.Entity.onUnArrestStickUsed then
        trace.Entity:onUnArrestStickUsed(self:GetOwner())
        return
    end

    local ent = self:GetOwner():getEyeSightHitEntity(nil, nil, function(p) return p ~= self:GetOwner() and p:IsPlayer() and p:Alive() end)
    if not ent then return end

    if not IsValid(ent) or not ent:IsPlayer() or (self:GetOwner():EyePos():DistToSqr(ent:GetPos()) > 8100) or not ent:GetNetVar("Arrested") then
        return
    end

    local canUnarrest, message = hook.Call("canUnarrest", hookCanUnarrest, self:GetOwner(), ent)
    if not canUnarrest then
        if message then DarkRP.notify(self:GetOwner(), 1, 5, message) end
        return
    end
    
    if ent:GetVehicle():IsValid() then
        return
    end

    ent:unArrest(self:GetOwner())
    DarkRP.notify(ent, 0, 4, DarkRP.getPhrase("youre_unarrested_by", self:GetOwner():Nick()))
end

function SWEP:startDarkRPCommand(usrcmd)
    if game.SinglePlayer() and CLIENT then return end
    if usrcmd:KeyDown(IN_ATTACK2) then
        if not self.Switched and self:GetOwner():HasWeapon("arrest_stick") then
            usrcmd:SelectWeapon(self:GetOwner():GetWeapon("arrest_stick"))
        end
    else
        self.Switched = false
    end
end

--addons/_smallscripts/lua/weapons/weapon_ghost.lua:
AddCSLuaFile()

SWEP.Base				= "weapon_base"

SWEP.PrintName			= "Ghost Weapon"		
SWEP.Author				= "Slade Xanthas"
SWEP.Category			= "Запрещено"
SWEP.Instructions		= "ПКМ - Полет | ЛКМ - Удар | R - Наградить второй жизнью чувачка напротив"
SWEP.Controls = {
	{key = MOUSE_RIGHT, desc = "Полет"},
}
SWEP.Slot				= 1
SWEP.SlotPos			= 0
		
SWEP.DrawAmmo			= false
SWEP.DrawCrosshair		= false

SWEP.Spawnable			= true
SWEP.AdminOnly			= false

SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false

SWEP.Primary.Delay				= 5
SWEP.Primary.ClipSize			= -1
SWEP.Primary.DefaultClip		= -1
SWEP.Primary.Automatic			= true
SWEP.Primary.Ammo				= "none"

SWEP.Secondary.Delay			= 1
SWEP.Secondary.ClipSize			= -1
SWEP.Secondary.DefaultClip		= -1
SWEP.Secondary.Automatic		= false
SWEP.Secondary.Ammo				= "none"

SWEP.HoldType = "slam"
SWEP.ThrownHoldType = "normal"
SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.UseHands = true
SWEP.ViewModel = ""
SWEP.WorldModel = ""

function SWEP:PrimaryAttack()
--[[
	if SERVER then
	local ply = self:GetOwner()
	local halloween = ents.Create('bonbon01')
	halloween:SetPos(ply:GetPos())
	halloween:Spawn()
	ply:EmitSound('ambient/levels/canals/shore1.wav')
	self:SetNextPrimaryFire( CurTime() + self.Primary.Delay )
	self:SetNextSecondaryFire( CurTime() + self.Primary.Delay )

	timer.Simple(30, function()
		if not IsValid(halloween) then return end
		halloween:Remove()
	end) 

	end
--]]
end

function SWEP:SecondaryAttack()
	local ply = self:GetOwner()
	if ply:GetMoveType() == MOVETYPE_FLY then
		ply:SetMoveType(MOVETYPE_WALK)
	else
		ply:SetMoveType(MOVETYPE_FLY)
	end
end

function SWEP:Reload()

end
--addons/weapon_melee/lua/weapons/weapon_hl2axe/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Топор"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing - Secondary attack :  Push"
SWEP.Controls = {
	{key = MOUSE_RIGHT, desc = "Толкнуть"},
}
SWEP.Category				= "Запрещено"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_axe.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_axe.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 80
SWEP.HitPushback		= 700
SWEP.HitRate			= 1.00
SWEP.MinDamage			= 60
SWEP.MaxDamage			= 90
SWEP.HitRadius			= 16

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound("npc/ministrider/flechette_flesh_impact1.wav")
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	local vm = self:GetOwner():GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay"..self:EntIndex(), 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay"..self:EntIndex() )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local ply = self:GetOwner()

	local vm = ply:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*50,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		self:EmitSound(PushSoundBody)

		if hithuman then
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * 500)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:OnDrop()
end

function SWEP:Hitscan()
	local ply = self:GetOwner()

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*self.HitDistance,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		local damageinfo = DamageInfo()
		
		damageinfo:SetAttacker(ply)
		damageinfo:SetInflictor(self)
		damageinfo:SetDamage(math.random(self.MinDamage, self.MaxDamage))
		damageinfo:SetDamageType(bit.bor(DMG_BULLET , DMG_NEVERGIB))
		damageinfo:SetDamageForce(forward:GetNormalized()*300)
		damageinfo:SetDamagePosition(trdata.endpos)

		hitent:DispatchTraceAttack(damageinfo, tr, forward)

		self:EmitSound(SwingSound)

		if hithuman then
			self:EmitSound(HitSoundBody)
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * self.HitPushback)
		else
			self:EmitSound(HitSoundWorld)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:Deploy()

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()
	
	timer.Remove("hitdelay"..self:EntIndex())
	return true
end
--addons/weapon_melee/lua/weapons/weapon_hl2hook/shared.lua:

AddCSLuaFile()

SWEP.PrintName				= "Крюк"
SWEP.Author				= "Dr. Towers"
SWEP.Instructions			= "Primary attack: Swing -  Secondary attack : Push (Pulls instead of pushing back on primary attack)"
SWEP.Controls = {
	{key = MOUSE_RIGHT, desc = "Толкнуть"},
}
SWEP.Category				= "Запрещено"

SWEP.Slot				= 1
SWEP.SlotPos				= 0

SWEP.Spawnable				= true

SWEP.ViewModel				= Model( "models/weapons/HL2meleepack/v_hook.mdl" )
SWEP.WorldModel				= Model( "models/weapons/HL2meleepack/w_hook.mdl" )
SWEP.ViewModelFOV			= 67
SWEP.UseHands				= true

SWEP.Primary.ClipSize		= -1
SWEP.Primary.DefaultClip	= -1
SWEP.Primary.Automatic		= true
SWEP.Primary.Ammo		= "none"

SWEP.Secondary.ClipSize		= -1
SWEP.Secondary.DefaultClip	= -1
SWEP.Secondary.Automatic	= true
SWEP.Secondary.Ammo		= "none"

SWEP.DrawAmmo			= false

SWEP.HitDistance		= 80
SWEP.HitRadius			= 12
SWEP.HitPushback		= -1000
SWEP.HitRate			= 0.60
SWEP.MinDamage			= 50
SWEP.MaxDamage			= 80

local SwingSound = Sound( "WeaponFrag.Roll" )
local HitSoundWorld = Sound( "Canister.ImpactHard" )
local HitSoundBody = Sound( "Flesh.Break" )
local PushSoundBody = Sound( "Flesh.ImpactSoft" )

function SWEP:Initialize()

	self:SetHoldType( "melee2" )
end

function SWEP:PrimaryAttack()

	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )

	local vm = self:GetOwner():GetViewModel()
	
	self:EmitSound( SwingSound )
	self.Weapon:SetNextPrimaryFire( CurTime() + self.HitRate )
	self.Weapon:SetNextSecondaryFire( CurTime() + self.HitRate )

	vm:SendViewModelMatchingSequence( vm:LookupSequence( "misscenter1" ) )

	timer.Create("hitdelay"..self:EntIndex(), 0.4, 1, function() self:Hitscan() end)

	timer.Start( "hitdelay"..self:EntIndex() )

end

function SWEP:SecondaryAttack()

	self.Weapon:SetNextPrimaryFire( CurTime() + 0.35 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 1.0 )

	self:EmitSound( SwingSound )

	local ply = self:GetOwner()

	local vm = ply:GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "pushback" ) )

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*50,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		self:EmitSound(PushSoundBody)

		if hithuman then
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * 500)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:OnDrop()

	
end

function SWEP:Hitscan()
	local ply = self:GetOwner()

	ply:LagCompensation( true )

	local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()

	local trdata = {
		start = startpos,
		endpos = startpos + forward*self.HitDistance,
		filter = ply,
		mask = MASK_SOLID,
		mins = Vector(-self.HitRadius, -self.HitRadius, -self.HitRadius-2),
		maxs = Vector(self.HitRadius, self.HitRadius, self.HitRadius+2),
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	if tr.Hit then
		local hitent = IsValid(tr.Entity) and tr.Entity or Entity(0)
		local hithuman = IsValid(hitent) and (hitent:IsPlayer() or hitent:IsNPC() or hitent:GetClass() == 'prop_ragdoll')

		local damageinfo = DamageInfo()
		
		damageinfo:SetAttacker(ply)
		damageinfo:SetInflictor(self)
		damageinfo:SetDamage(math.random(self.MinDamage, self.MaxDamage))
		damageinfo:SetDamageType(bit.bor(DMG_BULLET , DMG_NEVERGIB))
		damageinfo:SetDamageForce(forward:GetNormalized()*300)
		damageinfo:SetDamagePosition(trdata.endpos)

		hitent:DispatchTraceAttack(damageinfo, tr, forward)

		self:EmitSound(SwingSound)

		if hithuman then
			self:EmitSound(HitSoundBody)
			hitent:SetVelocity(forward * Vector( 1, 1, 0 ) * self.HitPushback)
		else
			self:EmitSound(HitSoundWorld)
			ply:SetVelocity(self:GetUp()*350)
		end
	end
	
	ply:LagCompensation(false)
end

function SWEP:Deploy()

	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "draw" ) )
	
	self.Weapon:SetNextPrimaryFire( CurTime() + 0.5 )
	self.Weapon:SetNextSecondaryFire( CurTime() + 0.5 )
	
	return true
end

function SWEP:Holster()

	return true
end

function SWEP:OnRemove()
	
	timer.Remove("hitdelay"..self:EntIndex())
	return true
end
--gamemodes/darkrp/entities/weapons/weapon_keypadchecker/shared.lua:
AddCSLuaFile()

if SERVER then
    AddCSLuaFile("cl_init.lua")

    util.AddNetworkString("DarkRP_keypadData")
end

SWEP.Base = "weapon_base"

SWEP.PrintName = "Admin Keypad Checker"
SWEP.Author = "DarkRP Developers"
SWEP.Instructions = "Left click on a keypad or fading door to check it\nRight click to clear"
SWEP.Slot = 5
SWEP.SlotPos = 1
SWEP.DrawAmmo = false
SWEP.ViewModelFlip = false
SWEP.Primary.ClipSize = 0
SWEP.Primary.Ammo = ""
SWEP.Secondary.Ammo = ""

SWEP.Spawnable = true
SWEP.AdminOnly = true
SWEP.Category = "Запрещено"

SWEP.HoldType = "normal"
SWEP.ViewModel = Model("models/weapons/c_pistol.mdl")
SWEP.WorldModel = "models/weapons/w_toolgun.mdl"
SWEP.IconLetter = ""

SWEP.ViewModel = "models/weapons/c_pistol.mdl"
SWEP.UseHands = true


nw.Register 'keypad_info'
    :Write(function(info)
        net.WriteUInt(info.keygroup1, 32)
        net.WriteUInt(info.keygroup2, 32)
        net.WriteUInt(info.length1, 32)
        net.WrtieUInt(info.length2, 32)
    end)
    :Read(function()
        return{
            keygroup1 = net.ReadUInt(32),
            keygroup2 = net.ReadUInt(32),
            length1 = net.ReadUInt(32),
            length2 = net.ReadUInt(32)
        }
    end)
    :SetLocalPlayer()

--[[
    Gets which entities are controlled by which keyboard keys
]]
local function getTargets(keypad, keyPass, keyDenied, delayPass, delayDenied)
    local targets = {}
    local Owner = keypad:CPPIGetOwner()

    for _, v in pairs(numpad.OnDownItems or {}) do
        if v.key == keyPass and v.ply == Owner then
            table.insert(targets, {type = DarkRP.getPhrase("keypad_checker_entering_right_pass"), name = v.name, ent = v.ent, original = keypad})
        end
        if v.key == keyDenied and v.ply == Owner then
            table.insert(targets, {type = DarkRP.getPhrase("keypad_checker_entering_wrong_pass"), name = v.name, ent = v.ent, original = keypad})
        end
    end

    for _, v in pairs(numpad.OnUpItems or {}) do
        if v.key == keyPass and v.ply == Owner then
            table.insert(targets, {type = DarkRP.getPhrase("keypad_checker_after_right_pass"), name = v.name, delay = math.Round(delayPass, 2), ent = v.ent, original = keypad})
        end
        if v.key == keyDenied and v.ply == Owner then
            table.insert(targets, {type = DarkRP.getPhrase("keypad_checker_after_wrong_pass"), name = v.name, delay = math.Round(delayDenied, 2), ent = v.ent, original = keypad})
        end
    end

    return targets
end

--[[---------------------------------------------------------------------------
Get the entities that are affected by the keypad
---------------------------------------------------------------------------]]
local function get_sent_keypad_Info(keypad)
    local keyPass = keypad:GetNetVar("keypad_info").keygroup1
    local keyDenied = keypad:GetNetVar("keypad_info").keygroup2
    local delayPass = keypad:GetNetVar("keypad_info").length1
    local delayDenied = keypad:GetNetVar("keypad_info").length2

    return getTargets(keypad, keyPass, keyDenied, delayPass, delayDenied)
end

--[[---------------------------------------------------------------------------
Overload for a different keypad addon
---------------------------------------------------------------------------]]
local function get_keypad_Info(keypad)
    local keyPass = tonumber(keypad.KeypadData.KeyGranted) or 0
    local keyDenied = tonumber(keypad.KeypadData.KeyDenied) or 0
    local delayPass = tonumber(keypad.KeypadData.LengthGranted) or 0
    local delayDenied = tonumber(keypad.KeypadData.LengthDenied) or 0

    return getTargets(keypad, keyPass, keyDenied, delayPass, delayDenied)
end

--[[---------------------------------------------------------------------------
Overload for a pattern keypad addon
---------------------------------------------------------------------------]]
local function get_keypad_pattern_Info(keypad)
    local keyPass = tonumber(keypad.keypadData.grantedKey) or 0
    local keyDenied = tonumber(keypad.keypadData.deniedKey) or 0
    local delayPass = tonumber(keypad.keypadData.grantedLength) or 0
    local delayDenied = tonumber(keypad.keypadData.deniedLength) or 0

    return getTargets(keypad, keyPass, keyDenied, delayPass, delayDenied)
end


--[[---------------------------------------------------------------------------
Get the keypads that trigger this entity
---------------------------------------------------------------------------]]
local function getEntityKeypad(ent)
    local targets = {}
    local doorKeys = {} -- The numpad keys that activate this entity
    local entOwner = ent:CPPIGetOwner()

    for _, v in pairs(numpad.OnDownItems or {}) do
        if v.ent == ent then
            table.insert(doorKeys, v.key)
        end
    end

    for _, v in pairs(numpad.OnUpItems or {}) do
        if v.ent == ent then
            table.insert(doorKeys, v.key)
        end
    end

    for _, v in ipairs(ents.FindByClass("sent_keypad")) do
        local vOwner = v:CPPIGetOwner()

        if vOwner == entOwner and table.HasValue(doorKeys, v:GetNetVar("keypad_info").keygroup1) then
            table.insert(targets, {type = DarkRP.getPhrase("keypad_checker_right_pass_entered"), ent = v, original = ent})
        end
        if vOwner == entOwner and  table.HasValue(doorKeys, v:GetNetVar("keypad_info").keygroup2) then
            table.insert(targets, {type = DarkRP.getPhrase("keypad_checker_wrong_pass_entered"), ent = v, original = ent})
        end
    end

    for _, v in ipairs(ents.FindByClass("keypad")) do
        local vOwner = v:CPPIGetOwner()

        if vOwner == entOwner and table.HasValue(doorKeys, tonumber(v.KeypadData.KeyGranted) or 0) then
            table.insert(targets, {type = DarkRP.getPhrase("keypad_checker_right_pass_entered"), ent = v, original = ent})
        end
        if vOwner == entOwner and  table.HasValue(doorKeys, tonumber(v.KeypadData.KeyDenied) or 0) then
            table.insert(targets, {type = DarkRP.getPhrase("keypad_checker_wrong_pass_entered"), ent = v, original = ent})
        end
    end

    for _, v in ipairs(ents.FindByClass("keypad_pattern")) do
        local vOwner = v:CPPIGetOwner()

        if vOwner == entOwner and table.HasValue(doorKeys, tonumber(v.keypadData.grantedKey) or 0) then
            table.insert(targets, {type = DarkRP.getPhrase("keypad_checker_right_pass_entered"), ent = v, original = ent})
        end
        if vOwner == entOwner and  table.HasValue(doorKeys, tonumber(v.keypadData.deniedKey) or 0) then
            table.insert(targets, {type = DarkRP.getPhrase("keypad_checker_wrong_pass_entered"), ent = v, original = ent})
        end
    end

    return targets
end

--[[---------------------------------------------------------------------------
Send the info to the client
---------------------------------------------------------------------------]]
function SWEP:PrimaryAttack()
    self:SetNextPrimaryFire(CurTime() + 0.3)
    if not SERVER then return end

    local trace = self:GetOwner():GetEyeTrace()
    if not IsValid(trace.Entity) then return end
    local ent, class = trace.Entity, string.lower(trace.Entity:GetClass() or "")
    local data

    if class == "sent_keypad" then
        data = get_sent_keypad_Info(ent)
        DarkRP.notify(self:GetOwner(), 1, 4, DarkRP.getPhrase("keypad_checker_controls_x_entities", #data / 2))
    elseif class == "keypad" then
        data = get_keypad_Info(ent)
        DarkRP.notify(self:GetOwner(), 1, 4, DarkRP.getPhrase("keypad_checker_controls_x_entities", #data / 2))
    elseif class == "keypad_pattern" then
        data = get_keypad_pattern_Info(ent)
        DarkRP.notify(self:GetOwner(), 1, 4, DarkRP.getPhrase("keypad_checker_controls_x_entities", #data / 2))
    else
        data = getEntityKeypad(ent)
        DarkRP.notify(self:GetOwner(), 1, 4, DarkRP.getPhrase("keypad_checker_controlled_by_x_keypads", #data))
    end

    net.Start("DarkRP_keypadData")
        net.WriteTable(data)
    net.Send(self:GetOwner())
end

function SWEP:SecondaryAttack()
end

if not SERVER then return end

--[[---------------------------------------------------------------------------
Registering numpad data
---------------------------------------------------------------------------]]
local oldNumpadUp = numpad.OnUp
local oldNumpadDown = numpad.OnDown

function numpad.OnUp(ply, key, name, ent, ...)
    numpad.OnUpItems = numpad.OnUpItems or {}
    table.insert(numpad.OnUpItems, {ply = ply, key = key, name = name, ent = ent, arg = {...}})

    return oldNumpadUp(ply, key, name, ent, ...)
end

function numpad.OnDown(ply, key, name, ent, ...)
    numpad.OnDownItems = numpad.OnDownItems or {}
    table.insert(numpad.OnDownItems, {ply = ply, key = key, name = name, ent = ent, arg = {...}})

    return oldNumpadDown(ply, key, name, ent, ...)
end

--addons/_smallscripts/lua/weapons/weapon_rape/shared.lua:
util.PrecacheSound( "player/fists/fists_crackl.wav" )
util.PrecacheSound( "player/fists/fists_crackr.wav" )
util.PrecacheSound( "player/fists/fists_fire01.wav" )
util.PrecacheSound( "player/fists/fists_fire02.wav" )
util.PrecacheSound( "player/fists/fists_fire03.wav" )
util.PrecacheSound( "player/fists/fists_hit01.wav" )
util.PrecacheSound( "player/fists/fists_hit02.wav" )
util.PrecacheSound( "player/fists/fists_hit03.wav" )
util.PrecacheSound( "player/fists/fists_miss01.wav" )
util.PrecacheSound( "player/fists/fists_miss02.wav" )
util.PrecacheSound( "player/fists/fists_miss03.wav" )

if CLIENT then
	SWEP.PrintName = "Ушаталка"
	SWEP.Slot = 0
	SWEP.SlotPos = 1
	SWEP.WepSelectIcon = surface.GetTextureID("vgui/entities/weapon_bsmod_punch")
end

SWEP.DrawWeaponInfoBox = true
SWEP.Author			= 'doxzter'
SWEP.Purpose		= 'Почувствуй себя настоящим героем своих любимых гачи-фильмов.'
SWEP.Instructions	= "ЛКМ: Ушатать чувака\nПКМ: Просто показать свою силу\nR: Кинуть какую-нибудь смешную фразу"
SWEP.Controls = {
	{key = MOUSE_LEFT, desc = "Ударить"},
	{key = MOUSE_RIGHT, desc = "Бороться"},
	{key = KEY_R, desc = "Поставить блок"},
}

SWEP.Weight				= 5
SWEP.AutoSwitchTo		= false
SWEP.AutoSwitchFrom		= false

SWEP.Category = "Запрещено"
SWEP.Contact = ""
SWEP.Primary.Delay = 0.35 -- Delay before the next shot
SWEP.Secondary.Delay = 0.35

SWEP.Spawnable = true 

SWEP.ViewModel = "models/weapons/c_limbs.mdl" 
SWEP.WorldModel = ""
SWEP.UseHands = true
SWEP.ViewModelFOV = 54

SWEP.Primary.ClipSize = -1 
SWEP.Primary.DefaultClip = -1 
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.ClipSize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = true
SWEP.Secondary.Ammo	= "none"

SWEP.DrawAmmo = false

SWEP.HitDistance = 75

function SWEP:FireSound()
	local rand = math.random(1, 3)
	local sound = nil
	
	if rand == 1 then
		sound = "player/fists/fists_fire01.wav"
	elseif rand == 2 then
		sound = "player/fists/fists_fire02.wav"
	elseif rand == 3 then
		sound = "player/fists/fists_fire03.wav"
	end
	
	self:EmitSound( sound, 45, 100, 1, CHAN_AUTO )
end
function SWEP:HitSound()
	local rand = math.random(1, 3)
	local sound = nil
	
	if rand == 1 then
		sound = "player/fists/fists_hit01.wav"
	elseif rand == 2 then
		sound = "player/fists/fists_hit02.wav"
	elseif rand == 3 then
		sound = "player/fists/fists_hit03.wav"
	end
	
	self:EmitSound( sound, 45, 100, 1, CHAN_AUTO )
end
function SWEP:MissSound()
	local rand = math.random(1, 3)
	local sound = nil
	
	if rand == 1 then
		sound = "player/fists/fists_miss01.wav"
	elseif rand == 2 then
		sound = "player/fists/fists_miss02.wav"
	elseif rand == 3 then
		sound = "player/fists/fists_miss03.wav"
	end
	
	self:EmitSound( sound, 45, 100, 1, CHAN_AUTO )
end

function SWEP:Initialize()	
	self:SetHoldType( "fist" )
end

function SWEP:SetupDataTables()
	self:NetworkVar( "Float", 0, "NextMeleeAttack" )
	self:NetworkVar( "Float", 1, "NextMeleeAttack2" )
end

function SWEP:Deploy()
	if SERVER then
		self:GetOwner().blocking = false
		
		timer.Simple( 0.1, function()
			if !IsValid(self) then return end
			
			self:EmitSound( "player/fists/fists_crackl.wav" )
		end )
		
		timer.Simple( 0.5, function()
			if !IsValid(self) then return end
			
			self:EmitSound( "player/fists/fists_crackr.wav" )
		end )
	end
	
	local vm = self:GetOwner():GetViewModel()
	vm:SendViewModelMatchingSequence( vm:LookupSequence( "fist_draw" ) )
end 

function SWEP:Reload() 
end 

function SWEP:Think()
	local vm = self:GetOwner():GetViewModel()
	
	if self:GetOwner():KeyDown( IN_RELOAD ) then 
		if !self:GetOwner().blocking then
			if SERVER then 
				vm:SendViewModelMatchingSequence( vm:LookupSequence( "fist_blocking" ) )
				if self:GetOwner().killMovable then self:GetOwner():SetKillMovable(false) end
			end
			self:GetOwner().blocking = true
			self:SetHoldType( "camera" )
		end
	elseif self:GetOwner().blocking then
		if SERVER then 
			vm:SendViewModelMatchingSequence( vm:LookupSequence( "fist_blocking_end" ) )
		end
		self:GetOwner().blocking = false
		self:SetHoldType( "fist" )
	end
	
	local meleetime = self:GetNextMeleeAttack()
	local meleetime2 = self:GetNextMeleeAttack2()
	
	if ( meleetime > 0 and CurTime() > meleetime ) then
		self:DealDamage() 

		self:SetNextMeleeAttack( 0 )
	end
	if ( meleetime2 > 0 and CurTime() > meleetime2 ) then
		self:DealDamage() 

		self:SetNextMeleeAttack2( 0 )
	end
end 

function SWEP:PrimaryAttack() 
	if self:GetOwner().blocking then return end
	
	local right = math.random(0, 1) == 1
	local vm = self:GetOwner():GetViewModel()
	local anim = right and "fist_rightpunch" or "fist_leftpunch"
	
	self:GetOwner():SetAnimation( PLAYER_ATTACK1 )
	
	
	vm:SendViewModelMatchingSequence( vm:LookupSequence( anim ) )
	
	self:FireSound()
	
	if right then
		self:GetOwner():ViewPunch(Angle(0, 0.5, 0.5))
		self:SetNextMeleeAttack2( CurTime() + 0.3 )
	else
		self:GetOwner():ViewPunch(Angle(0, -0.5, 0.5))
		self:SetNextMeleeAttack( CurTime() + 0.3 )
	end
	
	self:SetNextPrimaryFire( CurTime() +  0.3 )
end

function SWEP:SecondaryAttack()
	if CLIENT then return end
	local tr = self:GetOwner():GetEyeTrace().Entity
	if not tr:IsValid() then return end
	if not tr:IsNPC() and not tr:IsPlayer() and not ( tr:GetClass() == 'prop_ragdoll' ) then return end

	self:RAPEDEMBITCHEZ(false)
end

function SWEP:DealDamage()
	self:GetOwner():LagCompensation( true )
	
	if IsFirstTimePredicted() then
		bullet = {}
		
		bullet.Num    = 1
		bullet.Src    = self:GetOwner():GetShootPos()
		bullet.Dir    = self:GetOwner():EyeAngles():Forward()
		bullet.Spread = Vector(0, 0, 0)
		bullet.Tracer = 0
		bullet.Force  = 20
		bullet.HullSize = 1
		bullet.Distance = self.HitDistance
		bullet.Damage = math.random(10, 15)
		
		bullet.Callback = function(ply, trace, damageinfo)
		
			if trace.Entity:IsNPC() or trace.Entity:IsPlayer() then
				trace.Entity:SetVelocity(Vector(self:GetOwner():GetForward().x, self:GetOwner():GetForward().y, 0) * 250)
				self:HitSound()
			else
				self:MissSound()
			end
			
			--[[if SERVER then 
				SuppressHostEvents( self:GetOwner() )
			end]]
			
			util.ScreenShake( trace.HitPos, 0.5, 10, 0.5, 250 )
		end
		
		self:GetOwner():FireBullets(bullet, false) 
	end
	
	self:GetOwner():LagCompensation( false )
end

if SERVER then
	hook.Add("EntityTakeDamage", "BSModPunchTakeDamage", function(ent, dmginfo)
		if ent.blocking then
			if !dmginfo:IsDamageType( DMG_FALL ) and
				!dmginfo:IsDamageType( DMG_BURN ) and
				!dmginfo:IsDamageType( DMG_DROWN ) and
				!dmginfo:IsDamageType( DMG_POISON ) and
				!dmginfo:IsDamageType( DMG_SLOWBURN ) and
				!dmginfo:IsDamageType( DMG_DROWNRECOVER ) then
				
				dmginfo:SetDamage(dmginfo:GetDamage() - math.ceil((dmginfo:GetDamage() / 100) * 50))
				
				ent:GetViewModel():SendViewModelMatchingSequence( ent:GetViewModel():LookupSequence( "fist_blocking_flinch" ) )
				
				timer.Simple(ent:GetViewModel():SequenceDuration(), function()
					if !ent.blocking then return end
					
					ent:GetViewModel():SendViewModelMatchingSequence( ent:GetViewModel():LookupSequence( "fist_blocking" ) )
				end )
			end
		end
	end)
end
--addons/weapon_vape/lua/weapons/weapon_vape_armor.lua:
-- weapon_vape_medicinal.lua
-- Defines a vape that heals the player

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Armor Vape"
SWEP.Category  = "Премиум"
SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nThis healthy, organic juice has amazing healing abilities."

SWEP.VapeID = 11
local r = 100/200
local g = 100/200
local b = 244/200

SWEP.VapeAccentColor = Vector(r,g,b)
SWEP.VapeTankColor = Vector(r,g,b)

SWEP.Unbreakable = true

-- note: healing functionality is in weapon_vape/init.lua
--addons/weapon_vape/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3.25)
	local vmang1=self.VapeVMAng1 or Vector(170,-180,20)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(120,-180,150)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	/*
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)*/
	local difvec = Vector(-10,-3.5,-12)--vmpos1 - vmpos2
	local orig = Vector(0,0,0)
	local topos = orig+difvec
	
	local difang = Vector(-30,0,0)--vmang1 - vmang2
	local origang = Vector(0,0,0)
	local toang = origang+difang
	
	
	
	local newpos = LerpVector(lerp,topos,orig)
	local newang = LerpVector(lerp,toang,origang)
	
	newang = Angle(newang.x, newang.y, newang.z)
	
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end


--Swep Construction Kit code--

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end



--addons/weapon_vape/lua/weapons/weapon_vape/cl_init.lua:
-- weapon_vape/cl_init.lua
-- Defines common clientside code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

include('shared.lua')

function SWEP:DrawWorldModel()
	local ply = self:GetOwner()

	local vapeScale = self.VapeScale or 1
	self:SetModelScale(vapeScale, 0) 
	self:SetSubMaterial()

	if IsValid(ply) then
		local modelStr = ply:GetModel():sub(1,17)
		local isPony = modelStr=="models/ppm/player" or modelStr=="models/mlp/player" or modelStr=="models/cppm/playe"

		local bn = isPony and "LrigScull" or "ValveBiped.Bip01_R_Hand"
		if ply.vapeArmFullyUp then bn ="ValveBiped.Bip01_Head1" end
		local bon = ply:LookupBone(bn) or 0

		local opos = self:GetPos()
		local oang = self:GetAngles()
		local bp,ba = ply:GetBonePosition(bon)
		if bp then opos = bp end
		if ba then oang = ba end

		if isPony then
			--pony position
			opos = opos + (oang:Forward()*19.4) + (oang:Right()*-4.36) + (oang:Up()*-2.5)
			oang:RotateAroundAxis(oang:Right(),80)
			oang:RotateAroundAxis(oang:Forward(),12)
			oang:RotateAroundAxis(oang:Up(),20)
			opos = opos + (oang:Up()*(2.3+((vapeScale-1)*-10.25)))
		else
			if ply.vapeArmFullyUp then
				--head position
				opos = opos + (oang:Forward()*0.74) + (oang:Right()*15) + (oang:Up()*2)
				oang:RotateAroundAxis(oang:Forward(),-100)
				oang:RotateAroundAxis(oang:Up(),100)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
			else
				--hand position
				oang:RotateAroundAxis(oang:Forward(),90)
				oang:RotateAroundAxis(oang:Right(),90)
				opos = opos + (oang:Forward()*2) + (oang:Up()*-4.5) + (oang:Right()*-2)
				oang:RotateAroundAxis(oang:Forward(),69)
				oang:RotateAroundAxis(oang:Up(),10)
				opos = opos + (oang:Up()*(vapeScale-1)*-10.25)
				if self:GetClass()=="weapon_vape_butterfly" then
					opos = opos + (oang:Up()*6)
					oang:RotateAroundAxis(oang:Right(),Lerp(ply.vapeArmUpAmt or 0,0,-360))
					opos = opos + (oang:Up()*-6)
				end
			end
		end
		self:SetupBones()

		local mrt = self:GetBoneMatrix(0)
		if mrt then
		mrt:SetTranslation(opos)
		mrt:SetAngles(oang)

		self:SetBoneMatrix(0, mrt)
		end
	end

	self:DrawModel()
end

function SWEP:GetViewModelPosition(pos, ang)
	--mouth pos
	local vmpos1=self.VapeVMPos1 or Vector(18.5,-3.4,-3.25)
	local vmang1=self.VapeVMAng1 or Vector(170,-180,20)
	--hand pos
	local vmpos2=self.VapeVMPos2 or Vector(24,-8,-11.2)
	local vmang2=self.VapeVMAng2 or Vector(120,-180,150)

	if not LocalPlayer().vapeArmTime then LocalPlayer().vapeArmTime=0 end
	local lerp = math.Clamp((os.clock()-LocalPlayer().vapeArmTime)*3,0,1)
	if LocalPlayer().vapeArm then lerp = 1-lerp end
	/*
	local newpos = LerpVector(lerp,vmpos1,vmpos2)
	local newang = LerpVector(lerp,vmang1,vmang2)
	--I have a good reason for doing it like this
	newang = Angle(newang.x,newang.y,newang.z) 
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)*/
	local difvec = Vector(-10,-3.5,-12)--vmpos1 - vmpos2
	local orig = Vector(0,0,0)
	local topos = orig+difvec
	
	local difang = Vector(-30,0,0)--vmang1 - vmang2
	local origang = Vector(0,0,0)
	local toang = origang+difang
	
	
	
	local newpos = LerpVector(lerp,topos,orig)
	local newang = LerpVector(lerp,toang,origang)
	
	newang = Angle(newang.x, newang.y, newang.z)
	
	
	pos,ang = LocalToWorld(newpos,newang,pos,ang)
	return pos, ang
end


--Swep Construction Kit code--

if CLIENT then

	SWEP.vRenderOrder = nil
	function SWEP:ViewModelDrawn()
		
		local vm = self:GetOwner():GetViewModel()
		if !IsValid(vm) then return end
		
		if (!self.VElements) then return end
		
		self:UpdateBonePositions(vm)

		if (!self.vRenderOrder) then
			
			// we build a render order because sprites need to be drawn after models
			self.vRenderOrder = {}

			for k, v in pairs( self.VElements ) do
				if (v.type == "Model") then
					table.insert(self.vRenderOrder, 1, k)
				elseif (v.type == "Sprite" or v.type == "Quad") then
					table.insert(self.vRenderOrder, k)
				end
			end
			
		end

		for k, name in ipairs( self.vRenderOrder ) do
		
			local v = self.VElements[name]
			if (!v) then self.vRenderOrder = nil break end
			if (v.hide) then continue end
			
			local model = v.modelEnt
			local sprite = v.spriteMaterial
			
			if (!v.bone) then continue end
			
			local pos, ang = self:GetBoneOrientation( self.VElements, v, vm )
			
			if (!pos) then continue end
			
			if (v.type == "Model" and IsValid(model)) then

				model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)

				model:SetAngles(ang)
				//model:SetModelScale(v.size)
				local matrix = Matrix()
				matrix:Scale(v.size)
				model:EnableMatrix( "RenderMultiply", matrix )
				
				if (v.material == "") then
					model:SetMaterial("")
				elseif (model:GetMaterial() != v.material) then
					model:SetMaterial( v.material )
				end
				
				if (v.skin and v.skin != model:GetSkin()) then
					model:SetSkin(v.skin)
				end
				
				if (v.bodygroup) then
					for k, v in pairs( v.bodygroup ) do
						if (model:GetBodygroup(k) != v) then
							model:SetBodygroup(k, v)
						end
					end
				end
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(true)
				end
				
				render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)
				render.SetBlend(v.color.a/255)
				model:DrawModel()
				render.SetBlend(1)
				render.SetColorModulation(1, 1, 1)
				
				if (v.surpresslightning) then
					render.SuppressEngineLighting(false)
				end
				
			elseif (v.type == "Sprite" and sprite) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				render.SetMaterial(sprite)
				render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)
				
			elseif (v.type == "Quad" and v.draw_func) then
				
				local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
				ang:RotateAroundAxis(ang:Up(), v.angle.y)
				ang:RotateAroundAxis(ang:Right(), v.angle.p)
				ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
				cam.Start3D2D(drawpos, ang, v.size)
					v.draw_func( self )
				cam.End3D2D()

			end
			
		end
		
	end

	function SWEP:GetBoneOrientation( basetab, tab, ent, bone_override )
		
		local bone, pos, ang
		if (tab.rel and tab.rel != "") then
			
			local v = basetab[tab.rel]
			
			if (!v) then return end
			
			// Technically, if there exists an element with the same name as a bone
			// you can get in an infinite loop. Let's just hope nobody's that stupid.
			pos, ang = self:GetBoneOrientation( basetab, v, ent )
			
			if (!pos) then return end
			
			pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z
			ang:RotateAroundAxis(ang:Up(), v.angle.y)
			ang:RotateAroundAxis(ang:Right(), v.angle.p)
			ang:RotateAroundAxis(ang:Forward(), v.angle.r)
				
		else
		
			bone = ent:LookupBone(bone_override or tab.bone)

			if (!bone) then return end
			
			pos, ang = Vector(0,0,0), Angle(0,0,0)
			local m = ent:GetBoneMatrix(bone)
			if (m) then
				pos, ang = m:GetTranslation(), m:GetAngles()
			end
			
			if (IsValid(self:GetOwner()) and self:GetOwner():IsPlayer() and 
				ent == self:GetOwner():GetViewModel() and self.ViewModelFlip) then
				ang.r = -ang.r // Fixes mirrored models
			end
		
		end
		
		return pos, ang
	end

	function SWEP:CreateModels( tab )

		if (!tab) then return end

		// Create the clientside models here because Garry says we can't do it in the render hook
		for k, v in pairs( tab ) do
			if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and 
					string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then
				
				v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)
				if (IsValid(v.modelEnt)) then
					v.modelEnt:SetPos(self:GetPos())
					v.modelEnt:SetAngles(self:GetAngles())
					v.modelEnt:SetParent(self)
					v.modelEnt:SetNoDraw(true)
					v.createdModel = v.model
				else
					v.modelEnt = nil
				end
				
			elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite) 
				and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then
				
				local name = v.sprite.."-"
				local params = { ["$basetexture"] = v.sprite }
				// make sure we create a unique name based on the selected options
				local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }
				for i, j in pairs( tocheck ) do
					if (v[j]) then
						params["$"..j] = 1
						name = name.."1"
					else
						name = name.."0"
					end
				end

				v.createdSprite = v.sprite
				v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)
				
			end
		end
		
	end
	
	local allbones
	local hasGarryFixedBoneScalingYet = false

	function SWEP:UpdateBonePositions(vm)
		
		if self.ViewModelBoneMods then
			
			if (!vm:GetBoneCount()) then return end
			
			// !! WORKAROUND !! //
			// We need to check all model names :/
			local loopthrough = self.ViewModelBoneMods
			if (!hasGarryFixedBoneScalingYet) then
				allbones = {}
				for i=0, vm:GetBoneCount() do
					local bonename = vm:GetBoneName(i)
					if (self.ViewModelBoneMods[bonename]) then 
						allbones[bonename] = self.ViewModelBoneMods[bonename]
					else
						allbones[bonename] = { 
							scale = Vector(1,1,1),
							pos = Vector(0,0,0),
							angle = Angle(0,0,0)
						}
					end
				end
				
				loopthrough = allbones
			end
			// !! ----------- !! //
			
			for k, v in pairs( loopthrough ) do
				local bone = vm:LookupBone(k)
				if (!bone) then continue end
				
				// !! WORKAROUND !! //
				local s = Vector(v.scale.x,v.scale.y,v.scale.z)
				local p = Vector(v.pos.x,v.pos.y,v.pos.z)
				local ms = Vector(1,1,1)
				if (!hasGarryFixedBoneScalingYet) then
					local cur = vm:GetBoneParent(bone)
					while(cur >= 0) do
						local pscale = loopthrough[vm:GetBoneName(cur)].scale
						ms = ms * pscale
						cur = vm:GetBoneParent(cur)
					end
				end
				
				s = s * ms
				// !! ----------- !! //
				
				if vm:GetManipulateBoneScale(bone) != s then
					vm:ManipulateBoneScale( bone, s )
				end
				if vm:GetManipulateBoneAngles(bone) != v.angle then
					vm:ManipulateBoneAngles( bone, v.angle )
				end
				if vm:GetManipulateBonePosition(bone) != p then
					vm:ManipulateBonePosition( bone, p )
				end
			end
		else
			self:ResetBonePositions(vm)
		end
		   
	end
	 
	function SWEP:ResetBonePositions(vm)
		
		if (!vm:GetBoneCount()) then return end
		for i=0, vm:GetBoneCount() do
			vm:ManipulateBoneScale( i, Vector(1, 1, 1) )
			vm:ManipulateBoneAngles( i, Angle(0, 0, 0) )
			vm:ManipulateBonePosition( i, Vector(0, 0, 0) )
		end
		
	end

	/**************************
		Global utility code
	**************************/

	// Fully copies the table, meaning all tables inside this table are copied too and so on (normal table.Copy copies only their reference).
	// Does not copy entities of course, only copies their reference.
	// WARNING: do not use on tables that contain themselves somewhere down the line or you'll get an infinite loop
	function table.FullCopy( tab )

		if (!tab) then return nil end
		
		local res = {}
		for k, v in pairs( tab ) do
			if (type(v) == "table") then
				res[k] = table.FullCopy(v) // recursion ho!
			elseif (type(v) == "Vector") then
				res[k] = Vector(v.x, v.y, v.z)
			elseif (type(v) == "Angle") then
				res[k] = Angle(v.p, v.y, v.r)
			else
				res[k] = v
			end
		end
		
		return res
		
	end
	
end



--addons/weapon_vape/lua/weapons/weapon_vape_juicy.lua:
-- weapon_vape_juicy.lua
-- Defines a vape with selectable cloud colors

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

if CLIENT then
	include('weapon_vape/cl_init.lua')
else
	include('weapon_vape/shared.lua')
end

SWEP.PrintName = "Juicy Vape"
SWEP.Category  = "Разрешено"
SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB: Change Juice Flavor\nReload: Play Sound\n\nThis vape contains a flavor for everyone!"
SWEP.Controls = {
	{key = MOUSE_RIGHT, desc = "Изменить вкус"},
}

SWEP.VapeAccentColor = nil

SWEP.VapeID = 20

--Add your own flavors here, obviously
JuicyVapeJuices = {
	{name = "Mountain Dew", color = Color(150,255,100,255)},
	{name = "Cheetos", color = Color(255,180,100,255)},
	{name = "Razzleberry", color = Color(250,100,200,255)},
	{name = "Banana", color = Color(255,255,100,255)},
	{name = "Black Licorice", color = Color(40,40,40,255)},
	{name = "Churro", color = Color(210,180,140,255)},
	{name = "Skittles", color = nil}, --nil means rainbow
}

if SERVER then
	function SWEP:Initialize()
		self.juiceID = 0
		timer.Simple(0.1, function() SendVapeJuice(self, JuicyVapeJuices[self.juiceID+1]) end)
	end

	util.AddNetworkString("VapeTankColor")
	util.AddNetworkString("VapeMessage")
end

function SWEP:SecondaryAttack()
	if SERVER then
		if not self.juiceID then self.juiceID = 0 end
		self.juiceID = (self.juiceID + 1) % (#JuicyVapeJuices)
		SendVapeJuice(self, JuicyVapeJuices[self.juiceID+1])

		--Client hook isn't called in singleplayer...
		if game.SinglePlayer() then	self:GetOwner():SendLua([[surface.PlaySound("weapons/smg1/switch_single.wav")]]) end
	else
		if IsFirstTimePredicted() then
			surface.PlaySound("weapons/smg1/switch_single.wav")
		end
	end
end

if SERVER then
	function SendVapeJuice(ent, tab)
		local col = tab.color
		if col then
			local min = math.min(col.r,col.g,col.b)*0.8
			col = (Vector(col.r-min, col.g-min, col.b-min)*1.0)/255.0
		else
			--means rainbow tank
			col = Vector(-1,-1,-1)
		end
		net.Start("VapeTankColor")
		net.WriteEntity(ent)
		net.WriteVector(col)
		net.Broadcast()

		if IsValid(ent.Owner) then
			net.Start("VapeMessage")
			net.WriteString("Loaded "..tab.name.." flavor juice")
			net.Send(ent.Owner)
		end
	end
else
	net.Receive("VapeTankColor", function()
		local ent = net.ReadEntity()
		local col = net.ReadVector()
		if IsValid(ent) then ent.VapeTankColor = col end
	end)

	VapeMessageDisplay = ""
	VapeMessageDisplayTime = 0

	net.Receive("VapeMessage", function()
		VapeMessageDisplay = net.ReadString()
		VapeMessageDisplayTime = CurTime()
	end)

	hook.Add("HUDPaint", "VapeDrawJuiceMessage", function()
		local alpha = math.Clamp((VapeMessageDisplayTime+3-CurTime())*1.5,0,1)
		if alpha == 0 then return end

		surface.SetFont("Trebuchet24")
		local w,h = surface.GetTextSize(VapeMessageDisplay)
		draw.WordBox(8, ((ScrW() - w)/2)-8, ScrH() - (h + 24), VapeMessageDisplay, "Trebuchet24", Color(0,0,0,128*alpha), Color(255,255,255,255*alpha))
	end)
end
--addons/weapon_vape/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onionstest"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Разрешено"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.ObjectPos = Vector(-8.5, -2.401, 27.377)
SWEP.ObjectAng = Angle(-160, 10.519, 0)

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.Unbreakable = false

SWEP.VapeID = 1

function SWEP:SetupDataTables()
	if self.Unbreakable then return end

	self:NetworkVar( "Int", 0, "Energy" )

	if SERVER then
		self:SetEnergy(100)
	end

end

local icon = Material( "icon72/dash.png" )

function SWEP:DrawHUD()
	if self.Unbreakable then return end

    if self:GetEnergy() or 0 > 0 then
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*self:GetEnergy(), 20, Color( 233, 133, 110, 255 ) )
		draw.DrawText("Состояние", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
		
	    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	    surface.SetMaterial( icon ) -- Use our cached material
	    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
    end
end

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:Initialize()

	if !self.HandInitialize then
		self.HandInitialize = true
		self.VElements = {
			["object"] = { type = "Model", model = self.ViewModel, bone = "ValveBiped.Bip01_Spine4", rel = "", pos = self.ObjectPos, angle = self.ObjectAng, size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
		}
		self.ViewModel = "models/weapons/c_slam.mdl"
		self.UseHands = true
		self.ViewModelFlip = true
		self.ShowViewModel = true
		self.ShowWorldModel = true
		self.ViewModelBoneMods = {
			["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-23.334, -12.223, -32.223) },
			["ValveBiped.Bip01_L_Finger12"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -21.112, 0) },
			["ValveBiped.Bip01_L_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -65.556, 0) },
			["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 72.222, -41.112) },
			["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(10, 1.11, -1.111) },
			["Detonator"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-27.778, 1.11, -7.778) },
			["Slam_panel"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -47.778, 0) },
			["ValveBiped.Bip01_L_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -43.334, 0) },
			["Slam_base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_R_Hand"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
		}
		
	end

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
	if self.Initialize2 then self:Initialize2() end
end

function SWEP:PrimaryAttack()

	if SERVER then
		
		if not self.Unbreakable then

			if self:GetEnergy() < 1 then 
				if self.BreakCallback then self:BreakCallback() end
				self:Remove()
				return 
			end

			self:SetEnergy(self:GetEnergy() - 1)
		end

		VapeUpdate(self:GetOwner(), self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SetBreakCallback(f)
	self.BreakCallback = f
end

function SWEP:Holster()
	if SERVER and IsValid(self:GetOwner()) then
		ReleaseVape(self:GetOwner())
	end
	
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/weapon_vape/lua/weapons/weapon_vape/shared.lua:
-- weapon_vape/shared.lua
-- Defines common shared code/defaults for Vape SWEP

-- Vape SWEP by Swamp Onions - http://steamcommunity.com/id/swamponions/

SWEP.Author = "Swamp Onionstest"

SWEP.Instructions = "LMB: Rip Fat Clouds\n (Hold and release)\nRMB & Reload: Play Sounds\n\nVape Nation!"

SWEP.PrintName = "Vape"

SWEP.IconLetter	= "V"
SWEP.Category = "Разрешено"
SWEP.Slot = 1
SWEP.SlotPos = 0

SWEP.ViewModelFOV = 62 --default

SWEP.WepSelectIcon = surface and surface.GetTextureID("vape_icon")
SWEP.BounceWeaponIcon = false

SWEP.ViewModel = "models/swamponions/vape.mdl"
SWEP.WorldModel = "models/swamponions/vape.mdl"
SWEP.Spawnable = true
SWEP.AdminOnly = false

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "none"

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = "none"

SWEP.ObjectPos = Vector(-8.5, -2.401, 27.377)
SWEP.ObjectAng = Angle(-160, 10.519, 0)

SWEP.DrawAmmo = false
SWEP.HoldType = "slam"

SWEP.Unbreakable = false

SWEP.VapeID = 1

function SWEP:SetupDataTables()
	if self.Unbreakable then return end

	self:NetworkVar( "Int", 0, "Energy" )

	if SERVER then
		self:SetEnergy(100)
	end

end

local icon = Material( "icon72/dash.png" )

function SWEP:DrawHUD()
	if self.Unbreakable then return end

    if self:GetEnergy() or 0 > 0 then
		draw.RoundedBox( 8, (ScrW()/2)-64, ScrH()-48, 128, 32, Color( 0, 0, 0, 125 ) )
		draw.RoundedBox( 0, (ScrW()/2)-58, ScrH()-42, 1.16*self:GetEnergy(), 20, Color( 233, 133, 110, 255 ) )
		draw.DrawText("Состояние", "DermaLarge", (ScrW()/2), ScrH()-84, Color( 255, 255, 255, 255 ), TEXT_ALIGN_CENTER )
		
	    surface.SetDrawColor( 255, 255, 255, 255 ) -- Set the drawing color
	    surface.SetMaterial( icon ) -- Use our cached material
	    surface.DrawTexturedRect( ScrW() / 2 + 70, ScrH() - 45, 24, 24 ) -- Actually draw the rectangle
    end
end

function SWEP:Deploy()
	self:SetHoldType("slam")
end

function SWEP:Initialize()

	if !self.HandInitialize then
		self.HandInitialize = true
		self.VElements = {
			["object"] = { type = "Model", model = self.ViewModel, bone = "ValveBiped.Bip01_Spine4", rel = "", pos = self.ObjectPos, angle = self.ObjectAng, size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} }
		}
		self.ViewModel = "models/weapons/c_slam.mdl"
		self.UseHands = true
		self.ViewModelFlip = true
		self.ShowViewModel = true
		self.ShowWorldModel = true
		self.ViewModelBoneMods = {
			["ValveBiped.Bip01_L_Finger1"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-23.334, -12.223, -32.223) },
			["ValveBiped.Bip01_L_Finger12"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -21.112, 0) },
			["ValveBiped.Bip01_L_Finger4"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -65.556, 0) },
			["ValveBiped.Bip01_R_UpperArm"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, 72.222, -41.112) },
			["ValveBiped.Bip01_L_Finger0"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(10, 1.11, -1.111) },
			["Detonator"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Hand"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(-27.778, 1.11, -7.778) },
			["Slam_panel"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_L_Finger2"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -47.778, 0) },
			["ValveBiped.Bip01_L_Finger3"] = { scale = Vector(1, 1, 1), pos = Vector(0, 0, 0), angle = Angle(0, -43.334, 0) },
			["Slam_base"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) },
			["ValveBiped.Bip01_R_Hand"] = { scale = Vector(0.009, 0.009, 0.009), pos = Vector(0, 0, 0), angle = Angle(0, 0, 0) }
		}
		
	end

	if CLIENT then
	
		// Create a new table for every weapon instance
		self.VElements = table.FullCopy( self.VElements )
		self.WElements = table.FullCopy( self.WElements )
		self.ViewModelBoneMods = table.FullCopy( self.ViewModelBoneMods )

		self:CreateModels(self.VElements) // create viewmodels
		self:CreateModels(self.WElements) // create worldmodels
		
		// init view model bone build function
		if IsValid(self:GetOwner()) then
			local vm = self:GetOwner():GetViewModel()
			if IsValid(vm) then
				self:ResetBonePositions(vm)
				
				// Init viewmodel visibility
				if (self.ShowViewModel == nil or self.ShowViewModel) then
					vm:SetColor(Color(255,255,255,255))
				else
					// we set the alpha to 1 instead of 0 because else ViewModelDrawn stops being called
					vm:SetColor(Color(255,255,255,1))
					// ^ stopped working in GMod 13 because you have to do Entity:SetRenderMode(1) for translucency to kick in
					// however for some reason the view model resets to render mode 0 every frame so we just apply a debug material to prevent it from drawing
					vm:SetMaterial("Debug/hsv")			
				end
			end
		end
		
	end
	if self.Initialize2 then self:Initialize2() end
end

function SWEP:PrimaryAttack()

	if SERVER then
		
		if not self.Unbreakable then

			if self:GetEnergy() < 1 then 
				if self.BreakCallback then self:BreakCallback() end
				self:Remove()
				return 
			end

			self:SetEnergy(self:GetEnergy() - 1)
		end

		VapeUpdate(self:GetOwner(), self.VapeID)
	end
	self.Weapon:SetNextPrimaryFire(CurTime() + 0.1)
end

function SWEP:SetBreakCallback(f)
	self.BreakCallback = f
end

function SWEP:Holster()
	if SERVER and IsValid(self:GetOwner()) then
		ReleaseVape(self:GetOwner())
	end
	
	if CLIENT and IsValid(self:GetOwner()) then
		local vm = self:GetOwner():GetViewModel()
		if IsValid(vm) then
			self:ResetBonePositions(vm)
		end
	end
	
	return true
end

SWEP.OnDrop = SWEP.Holster
SWEP.OnRemove = SWEP.Holster
--addons/_smallscripts/lua/weapons/wrp_farmtablet/shared.lua:
SWEP.PrintName				= 'Планшет'
SWEP.Author					= 'doxzter'

SWEP.Slot					= 2
SWEP.SlotPos				= 1
SWEP.Category 				= 'Запрещено'

SWEP.Spawnable				= false
SWEP.AdminSpawnable			= false

SWEP.ViewModel				= Model('models/weapons/c_tablet_v2.mdl')
SWEP.WorldModel				= Model('models/weapons/w_tablet_v2.mdl')
SWEP.ViewModelFOV			= 54
SWEP.UseHands				= true

SWEP.Primary.Clipsize = -1
SWEP.Primary.DefaultClip = -1
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = 'none'

SWEP.Secondary.Clipsize = -1
SWEP.Secondary.DefaultClip = -1
SWEP.Secondary.Automatic = false
SWEP.Secondary.Ammo = 'none'

--

SWEP.TraceLength = 100
SWEP.TraceRadius = 16
local tr_mins = Vector(-SWEP.TraceRadius, -SWEP.TraceRadius, -SWEP.TraceRadius)
local tr_maxs = Vector(SWEP.TraceRadius, SWEP.TraceRadius, SWEP.TraceRadius)

function SWEP:GetTrace()
	local ply = self:GetOwner()
    
    local startpos = ply:GetShootPos()
	local forward = ply:GetAimVector()
    local trdata = {
		start = startpos,
		endpos = startpos + forward*self.TraceLength,
		filter = ply,
		mask = MASK_SOLID,
		mins = tr_mins,
		maxs = tr_maxs,
	}

	local tr = util.TraceLine(trdata)
	if not tr.Hit then tr = util.TraceHull(trdata) end

	return tr
end

function SWEP:GetTraceEntity()
	local tr = self:GetTrace()
    if not IsValid(tr.Entity) or tr.Entity:EntIndex() == 0 then return end

    return tr.Entity
end

function SWEP:SetupDataTables()
    self:NetworkVar('Int', 0, 'Level')
    self:NetworkVar('Entity', 0, 'TargetEntity')
    self:NetworkVar('String', 0, 'ActionID')
end
--addons/module_css2/lua/weapons/wrp_weapon_hk21/shared.lua:
AddCSLuaFile()

if CLIENT then
	
	SWEP.DrawCrosshair = false
	SWEP.CSMuzzleFlashes = true
	
	SWEP.AimPos = Vector(-8.322, -7, 2.174)
	SWEP.AimAng = Vector(0.151, -3.701, -10.429)
	
	SWEP.SprintPos = Vector(0, 0, -0.7)
	SWEP.SprintAng = Vector(-7.739, 28.141, 0)
	
	SWEP.ViewModelMovementScale = 0.7
	SWEP.ZoomAmount = 30
	SWEP.DrawBlackBarsOnAim = true
	SWEP.AimOverlay = surface.GetTextureID("swb/scope_rifle")
	SWEP.FadeDuringAiming = true
	SWEP.MoveWepAwayWhenAiming = true
	SWEP.DelayedZoom = true
	SWEP.SnapZoom = true
	SWEP.SimulateCenterMuzzle = true

	SWEP.AdjustableZoom = true
	SWEP.MinZoom = 25
	SWEP.MaxZoom = 50
	
	SWEP.IconLetter = "b"
	
	SWEP.MuzzleEffect = false

end

SWEP.PrintName = "HK21"

SWEP.FadeCrosshairOnAim = true

SWEP.PlayBackRate = 1
SWEP.PlayBackRateSV = 1
SWEP.SpeedDec = 25
SWEP.BulletDiameter = 5.56
SWEP.CaseLength = 45

SWEP.Kind = WEAPON_HEAVY
SWEP.AutoSpawnable = true
SWEP.AllowDrop = true

SWEP.Slot = 2
SWEP.SlotPos = 0
SWEP.NormalHoldType = "ar2"
SWEP.RunHoldType = "passive"
SWEP.FireModes = {"auto", "semi"}
SWEP.Base = "swb_base"
SWEP.Category = "Запрещено"

SWEP.Author = "kenzou power"
SWEP.Contact = ""
SWEP.Purpose = ""
SWEP.Instructions = ""

SWEP.ViewModelFOV = 60
SWEP.ViewModelFlip = false
SWEP.ViewModel = "models/weapons/c_gr9.mdl"
SWEP.WorldModel = "models/weapons/w_gr9.mdl"

SWEP.Spawnable = true
SWEP.AdminSpawnable	= true

SWEP.Primary.ClipSize = 80
SWEP.Primary.DefaultClip = 240
SWEP.Primary.Automatic = true
SWEP.Primary.Ammo = "smg1"

SWEP.FireDelay = 0.09
SWEP.FireSound = Sound("weapons/hmg/hmg_fire.wav")	
SWEP.Recoil = 1
SWEP.Chamberable = false

SWEP.HipSpread = 0.05
SWEP.AimSpread = 0.002
SWEP.RifleSpread = 0.003
SWEP.VelocitySensitivity = 0
SWEP.MaxSpreadInc = 0
SWEP.SpreadPerShot = 0
SWEP.SpreadCooldown = 0
SWEP.Shots = 1
SWEP.Damage = 50
SWEP.DeployTime = 1
--addons/ent_bitcoinpc/lua/entities/bit_cpu/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/ent_bitcoinpc/lua/entities/bit_cpu/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Cpu"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "Point" )
end
--addons/ent_bitcoinpc/lua/entities/bit_powersupply/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Power Supply"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar( "Int", 0, "Point" )
end
--addons/module_bitminers2/lua/entities/bm2_bitminer_1/shared.lua:
ENT.Type = "anim"

ENT.PrintName = "Bitminer 1"
ENT.Spawnable = true
ENT.Category = "Запрещено"

ENT.upgrades = {
	CPU = {name = "CPU Speed +256MHz", cost = {2000,4000,8000,16000,320000, 64000, 128000}, amountPerUpgrade = 0.256},
	CORES = {name = "Adds an extra core", cost = {50000, 10000, 175000}}
}

function ENT:SetupDataTables()
	self:NetworkVar( "Bool", 1, "HasPower" )
	self:NetworkVar( "Bool", 2, "IsOn")
	self:NetworkVar( "Bool", 3, "IsMining")
	self:NetworkVar( "Float", 1, "BitcoinAmount")
	self:NetworkVar( "Int", 1, "CPUUpgrade")
	self:NetworkVar( "Int", 2, "CoreUpgrade")  
	self:NetworkVar( "Float", 3, "ClockSpeed")
	self:NetworkVar( "Int", 4, "CoreCount")
	//A string table of all the updates that have been purchased.
	self:NetworkVar( "String", 1, "Updates") 
	self:NetworkVar("Entity", 0, "owning_ent")
end


--addons/module_bitminers2/lua/entities/bm2_bitminer_server/cl_init.lua:
include("shared.lua")

function ENT:Initialize()
	self.fanAng = 0
end

//Animate fans
function ENT:Think()
	if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then 
        self:SetNextClientThink( CurTime() + 1 )
        return true
	end
	
	if self:GetShouldAnimate() then
		self.fanAng = self.fanAng + (FrameTime() * 400)
		for i = 0 , self:GetBoneCount() - 1 do
			if string.match( self:GetBoneName(i), "fan" ) ~= nil then
				self:ManipulateBoneAngles(i,Angle(self.fanAng,0,0))
			end
		end
	end 

	self:SetNextClientThink(CurTime() + 0.3)
	return true
end

function ENT:Draw()
	self:DrawModel()
end
--addons/module_bitminers2/lua/entities/bm2_extention_lead/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Extention Lead"
ENT.Spawnable = true
ENT.Category = "Запрещено"

function ENT:SetupDataTables()

end
--addons/module_bitminers2_extras/lua/entities/bm2_extra_fuel_otherend/shared.lua:
ENT.Type = "anim"
ENT.Base = "bm2_base"

ENT.PrintName = "Fuel Tank Line End"
ENT.Spawnable = false
ENT.Category = "Запрещено"
--addons/module_bitminers2/lua/entities/bm2_fuel/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Fuel"
ENT.Spawnable = true
ENT.Category = "Запрещено"


--addons/module_bitminers2/lua/entities/bm2_plug_1/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"

ENT.PrintName = "Extention Lead"
ENT.Spawnable = false
ENT.Category = "Запрещено"

function ENT:SetupDataTables()

end
--addons/weapon_laser/lua/entities/dark_egon_beam/cl_init.lua:

include('shared.lua')

local matBeam		 		= Material( "egon/dark_beam" )
local matLight 				= Material( "egon/muzzlelight" )
local matRefraction			= Material( "egon/egon_ringbeam" )
local matRefractRing		= Material( "egon/refract_ring" )

/*---------------------------------------------------------
   Name: Initialize
---------------------------------------------------------*/
function ENT:Initialize()		

	self.Size = 0

end

function ENT:Think()

	self.Entity:SetRenderBoundsWS( self:GetEndPos(), self.Entity:GetPos(), Vector()*8 )
	
	self.Size = math.Approach( self.Size, 1, 10*FrameTime() )
	
end

timer.Create('lasergun_updateplayercolors', 3, 0, function()
	for _, v in player.Iterator() do
		local mod = v:PS_GetItemModifiers('cyberitem') or v:PS_GetItemModifiers('cyberitem_navsegda')
		if mod and mod.color then
			v.lasergun_color = Color(mod.color.r, mod.color.g, mod.color.b)
			v.lasergun_color_vector = Vector(mod.color.r/255, mod.color.g/255, mod.color.b/255)
		end
	end
end)

matproxy.Add({
	name = 'PlayerLasergunColor', 
	init = function(self, mat, values)
		self.ResultTo = values.resultvar
	end,
	bind = function(self, mat, ent)
		local ply = ent:GetOwner()
		if IsValid(ply) and ply.lasergun_color_vector then
			mat:SetVector(self.ResultTo, ply.lasergun_color_vector)
		end
	end,
})

function ENT:DrawMainBeam( StartPos, EndPos )

	local TexOffset = CurTime() * -2.0
	local color = self:GetOwner().lasergun_color or color_white
	
	// Cool Beam
	render.SetMaterial( matBeam )
	render.DrawBeam( StartPos, EndPos, 
					32, 
					TexOffset*-0.4, TexOffset*-0.4 + StartPos:Distance(EndPos) / 256, 
					color )
					
	// Refraction Beam
	render.SetMaterial( matRefraction )
	render.UpdateRefractTexture()
	render.DrawBeam( StartPos, EndPos, 
					32, 
					TexOffset*0.5, TexOffset*0.5 + StartPos:Distance(EndPos) / 1024, 
					color )	


end

function ENT:DrawCurlyBeam( StartPos, EndPos, Angle )

	local TexOffset = CurTime() * 0.5

	local Forward	= Angle:Forward()
	local Right 	= Angle:Right()
	local Up 		= Angle:Up()
	
	local LastPos
	local Distance = StartPos:Distance( EndPos )
	local StepSize = 16
	local RingTightness = 0.04

	local color = self:GetOwner().lasergun_color or color_white

	render.SetMaterial( matBeam )
	
	for i=0, Distance, StepSize do
	
		//local SizeMul = math.Clamp( (Distance-i) / Distance, 0.2, 1 )
	
		local sin = math.sin( CurTime() * -30 + i * RingTightness )
		local cos = math.cos( CurTime() * -30 + i * RingTightness )
		
		local Pos = StartPos + (Forward * i) + (Up * sin * 16) + (Right * cos * 16)
	
		if (LastPos) then
		
			render.DrawBeam( LastPos, Pos, 
							 (math.sin( i*0.02 )+1) * 4, 
							 TexOffset + i, 
							 TexOffset+Distance/128 + i, 
							 color )	 
		end
						 
		LastPos = Pos
	
	end

end

/*---------------------------------------------------------
   Name: DrawPre
---------------------------------------------------------*/
function ENT:Draw()

	local Owner = self.Entity:GetOwner()
	if (!Owner || Owner == NULL) then return end

	local StartPos 		= self.Entity:GetPos()
	local EndPos 		= self:GetEndPos()
	local ViewModel 	= Owner == LocalPlayer()
	
	local trace = {}
	
	local Angle = Owner:EyeAngles()
	
	// If it's the local player we start at the viewmodel
	if ( ViewModel ) then
	
		local vm = Owner:GetViewModel()
		if (!vm || vm == NULL) then return end
		local attachment = vm:GetAttachment( 1 )
		if not attachment then return end
		StartPos = attachment.Pos
		
		trace.start = Owner:EyePos()
	
	else
	// If we're viewing another player we start at their weapon
	
		local vm = Owner:GetActiveWeapon()
		if (!vm || vm == NULL) then return end
		local attachment = vm:GetPos()
		StartPos = attachment
		
		trace.start = StartPos
	
	end
	
	// Predict the endpoint, smoother, faster, harder, stronger
	
		trace.endpos = trace.start + (Owner:EyeAngles():Forward() * 4096)
		trace.filter = { Owner, Owner:GetActiveWeapon() }
			
		local tr = util.TraceLine( trace )
		
		EndPos = tr.HitPos
		
	
	// offset the texture coords so it looks like it's scrolling
	local TexOffset = CurTime() * -2
	
	// Make the texture coords relative to distance so they're always a nice size
	local Distance = EndPos:Distance( StartPos ) * self.Size
	
	
	Angle = (EndPos - StartPos):Angle()
	local Normal 	= Angle:Forward()
	
	render.SetMaterial( matLight )
	render.DrawQuadEasy( EndPos + tr.HitNormal, tr.HitNormal, 64 * self.Size, 64 * self.Size, color_white )
	render.DrawQuadEasy( EndPos + tr.HitNormal, tr.HitNormal, math.Rand(32, 128) * self.Size, math.Rand(32, 128) * self.Size, color_white )
	render.DrawSprite( EndPos + tr.HitNormal, 64, 64, Color( 0, 150, 150, self.Size * 255 ) )
	
	local color = self:GetOwner().lasergun_color or color_white

	// Draw the beam
	self:DrawMainBeam( StartPos, StartPos + Normal * Distance )
	
	// Draw curly Beam
	self:DrawCurlyBeam( StartPos, StartPos + Normal * Distance, Angle )
	
	// Light glow coming from gun to hide ugly edges :x
	render.SetMaterial( matLight )
	render.DrawSprite( StartPos, 128, 128, color )
	render.DrawSprite( StartPos + Normal * 32, 64, 64, color )
	


	if ( !self.LastDecal || self.LastDecal < CurTime() ) then
		util.Decal( "DarkEgonBurn", StartPos, StartPos + Normal * Distance * 1.1 )
		self.LastDecal = CurTime() + 0.01
	end
	
end

/*---------------------------------------------------------
   Name: IsTranslucent
---------------------------------------------------------*/
function ENT:IsTranslucent()
	return true
end

--gamemodes/darkrp/entities/entities/darkrp_cheque/cl_init.lua:
include("shared.lua")

function ENT:Draw()
    self:DrawModel()
    if not IsValid(self:Getowning_ent()) or not IsValid(self:Getrecipient()) then return end

    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    local amount = self:Getamount()
    local owner = (IsValid(self:Getowning_ent()) and self:Getowning_ent().Name and self:Getowning_ent():Name()) or DarkRP.getPhrase("unknown")
    local recipient = (self:Getrecipient().Name and self:Getrecipient():Name()) or DarkRP.getPhrase("unknown")

    surface.SetFont("ChatFont")
    local text = DarkRP.getPhrase("cheque_pay", recipient) .. "\n" .. DarkRP.formatMoney(amount) .. "\n" .. DarkRP.getPhrase("signed", owner)
    local TextWidth = surface.GetTextSize(text)

    cam.Start3D2D(Pos + Ang:Up() * 0.9, Ang, 0.1)
    if recipient == LocalPlayer():Name() and owner ~= LocalPlayer():Name() then
        draw.DrawNonParsedText(text, "ChatFont", -TextWidth * 0.5, -25, Color(0, 255, 0, 255), 0)
    elseif recipient == LocalPlayer():Name() and owner == LocalPlayer():Name() then
        draw.DrawNonParsedText(text, "ChatFont", -TextWidth * 0.5, -25, Color(255, 255, 0, 255), 0)
    elseif recipient ~= LocalPlayer():Name() and owner == LocalPlayer():Name() then
        draw.DrawNonParsedText(text, "ChatFont", -TextWidth * 0.5, -25, Color(0, 0, 255, 255), 0)
    elseif recipient ~= LocalPlayer():Name() and owner ~= LocalPlayer():Name() then
        draw.DrawNonParsedText(text, "ChatFont", -TextWidth * 0.5, -25, Color(255, 0, 0, 255), 0)
    else
        draw.DrawNonParsedText(text, "ChatFont", -TextWidth * 0.5, -25, Color(255, 255, 255, 255), 0)
    end
    cam.End3D2D()
end

--addons/ent_drugz/lua/entities/durgz_heroine/shared.lua:
ENT.Type = "anim"
ENT.Base = "durgz_base"
ENT.Spawnable = true
ENT.AdminSpawnable = true
ENT.PrintName = "Героин"
ENT.Category = "Запрещено"
ENT.Model = "models/katharsmodels/syringe_out/syringe_out.mdl"
--addons/module_meth/lua/entities/eml_buyer_text/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFontAddicted", {
	font = "Arial",
	size = 35,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ang = self:GetAngles()

	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		cam.Start3D2D(pos + ang:Up(), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.25)
				draw.SimpleTextOutlined(EML_Meth_Salesman_Name, "methFontAddicted", 0, -48, EML_Meth_Salesman_Name_Color, TEXT_ALIGN_CENTER, TEXT_ALIGN_LEFT, 1, Color(25, 25, 25, 100));			
		cam.End3D2D()	
	end;
end;

-- maxAmount = 60
-- amount = x


--addons/module_meth/lua/entities/eml_ciodine/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

local dist = 90000

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ply = LocalPlayer()

	if ply:GetPos():DistToSqr(pos) > dist then return end

	local ang = self:GetAngles()

	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		cam.Start3D2D(pos + ang:Up(), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.1)
				draw.SimpleTextOutlined("Кристализированный йод ("..self:GetMethAmount().." lbs)", "methFont", 32, -96, Color(220, 134, 159, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));			
		cam.End3D2D()	
	end;
end;

-- maxAmount = 60
-- amount = x


--addons/module_meth/lua/entities/eml_macid/shared.lua:
ENT.Base = "base_anim";
ENT.Type = "anim";

ENT.PrintName		= "Соляная кислота";
ENT.Category 		= "Meth";
ENT.Author			= "Meth";

ENT.Contact    		= "";
ENT.Purpose 		= "";
ENT.Instructions 	= "" ;

ENT.Spawnable			= true;
ENT.AdminSpawnable		= true;

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 0, "owning_ent")
    self:NetworkVar("Int", 0, "MethAmount")
    self:NetworkVar("Int", 1, "MaxAmount")
end
--addons/module_meth/lua/entities/eml_meth/cl_init.lua:
include("shared.lua");

surface.CreateFont("methFont", {
	font = "Arial",
	size = 30,
	weight = 600,
	blursize = 0,
	scanlines = 0,
	antialias = true,
	underline = false,
	italic = false,
	strikeout = false,
	symbol = false,
	rotary = false,
	shadow = false,
	additive = false,
	outline = false,
});

function ENT:Initialize()	

end;

local dist = 90000

function ENT:Draw()
	self:DrawModel();
	
	local pos = self:GetPos()
	local ply = LocalPlayer()

	if ply:GetPos():DistToSqr(pos) > dist then return end
	
	local ang = self:GetAngles()

	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);	
	if LocalPlayer():GetPos():Distance(self:GetPos()) < EML_DrawDistance then
		-- cam.Start3D2D(pos + ang:Up(), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.125)
				-- if !self:GetNWBool("salesman") then
				--	draw.SimpleTextOutlined((self:GetNWInt("value")*self:GetNWInt("valueMod")).."$", "methFont", 8, -98, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
				-- else
				--	draw.SimpleTextOutlined("Возьмите и принисите это скупщику мета!", "methFont", 8, -98, Color(40, 255, 3, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
				-- end;
		-- cam.End3D2D()		
		cam.Start3D2D(pos + ang:Up(), Angle(0, LocalPlayer():EyeAngles().y-90, 90), 0.1)
				draw.SimpleTextOutlined("Кристализированный мет ("..self:GetMethAmount().." lbs)", "methFont", 8, -96, Color(1, 241, 249, 255), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER, 1, Color(25, 25, 25, 100));
		cam.End3D2D();
	end;
end;

-- maxAmount = 60
-- amount = x


--addons/module_meth/lua/entities/eml_stove/cl_init.lua:
include("shared.lua");

function ENT:Initialize()	
	self.emitTime = CurTime();
	self.firePlace1 = ParticleEmitter(self:GetPos());
	self.firePlace2 = ParticleEmitter(self:GetPos());
	self.firePlace3 = ParticleEmitter(self:GetPos());
	self.firePlace4 = ParticleEmitter(self:GetPos());
end;


local dist = 90000

function ENT:Think()
	local ply = LocalPlayer()
    local pos = self:GetPos()

    if ply:GetPos():DistToSqr(pos) > dist then 
    	self:SetNextClientThink(CurTime() + 2)
    	return true
    end
    
    local up = self:GetUp()
    local forward = self:GetForward()
    local right = self:GetRight()

	local firePos1 = pos+(up*20)+(forward*2.8)+(right*11.5);
	local firePos2 = pos+(up*20)+(forward*2.8)+(right*-11.2);
	local firePos3 = pos+(up*20)+(forward*-9.8)+(right*-11.2);
	local firePos4 = pos+(up*20)+(forward*-9.8)+(right*11.5);
	
	if (self:GetGasStorage()>0) then
		if (self.emitTime < CurTime()) then
			if (self:GetFirePlace1()) then
				local smoke = self.firePlace1:Add("particle/smokesprites_000"..math.random(1,9), firePos1);
				smoke:SetVelocity(Vector(0, 0, 150));
				smoke:SetDieTime(math.Rand(0.6, 2.3));
				smoke:SetStartAlpha(math.Rand(150, 200));
				smoke:SetEndAlpha(0);
				smoke:SetStartSize(math.random(0, 5));
				smoke:SetEndSize(math.random(33, 55));
				smoke:SetRoll(math.Rand(180, 480));
				smoke:SetRollDelta(math.Rand(-3, 3));
				smoke:SetColor(EML_Stove_SmokeColor_R, EML_Stove_SmokeColor_G, EML_Stove_SmokeColor_B);
				smoke:SetGravity(Vector(0, 0, 10));
				smoke:SetAirResistance(256);
				self.emitTime = CurTime() + .1;
			end;
			if (self:GetFirePlace2()) then
				local smoke = self.firePlace2:Add("particle/smokesprites_000"..math.random(1,9), firePos2);
				smoke:SetVelocity(Vector(0, 0, 150));
				smoke:SetDieTime(math.Rand(0.6, 2.3));
				smoke:SetStartAlpha(math.Rand(150, 200));
				smoke:SetEndAlpha(0);
				smoke:SetStartSize(math.random(0, 5));
				smoke:SetEndSize(math.random(33, 55));
				smoke:SetRoll(math.Rand(180, 480));
				smoke:SetRollDelta(math.Rand(-3, 3));
				smoke:SetColor(EML_Stove_SmokeColor_R, EML_Stove_SmokeColor_G, EML_Stove_SmokeColor_B);
				smoke:SetGravity(Vector(0, 0, 10));
				smoke:SetAirResistance(256);
				self.emitTime = CurTime() + .1;
			end;
			if (self:GetFirePlace3()) then
				local smoke = self.firePlace3:Add("particle/smokesprites_000"..math.random(1,9), firePos3);
				smoke:SetVelocity(Vector(0, 0, 150));
				smoke:SetDieTime(math.Rand(0.6, 2.3));
				smoke:SetStartAlpha(math.Rand(150, 200));
				smoke:SetEndAlpha(0);
				smoke:SetStartSize(math.random(0, 5));
				smoke:SetEndSize(math.random(33, 55));
				smoke:SetRoll(math.Rand(180, 480));
				smoke:SetRollDelta(math.Rand(-3, 3));
				smoke:SetColor(EML_Stove_SmokeColor_R, EML_Stove_SmokeColor_G, EML_Stove_SmokeColor_B);
				smoke:SetGravity(Vector(0, 0, 10));
				smoke:SetAirResistance(256);
				self.emitTime = CurTime() + .1;
			end;
			if (self:GetFirePlace4()) then
				local smoke = self.firePlace4:Add("particle/smokesprites_000"..math.random(1,9), firePos4);
				smoke:SetVelocity(Vector(0, 0, 150));
				smoke:SetDieTime(math.Rand(0.6, 2.3));
				smoke:SetStartAlpha(math.Rand(150, 200));
				smoke:SetEndAlpha(0);
				smoke:SetStartSize(math.random(0, 5));
				smoke:SetEndSize(math.random(33, 55));
				smoke:SetRoll(math.Rand(180, 480));
				smoke:SetRollDelta(math.Rand(-3, 3));
				smoke:SetColor(EML_Stove_SmokeColor_R, EML_Stove_SmokeColor_G, EML_Stove_SmokeColor_B);
				smoke:SetGravity(Vector(0, 0, 10));
				smoke:SetAirResistance(256);
				self.emitTime = CurTime() + .1;
			end;		
		end;
	end;

	self:SetNextClientThink(CurTime() + 1)
	return true
end;


local laser = Material("cable/redlaser")
local green = Material( "icon72/green_circle.png" )
local red 	= Material( "icon72/red_circle.png" )
local plita = Material( "icon72/control_knobs.png" )
local icongas = Material( "icon72/battery.png" )

function ENT:Draw()
	local ply = LocalPlayer()
	local pos = self:GetPos()

	self:DrawModel();

	if ply:GetPos():DistToSqr(pos) > dist then return end

	local ang = self:GetAngles()
	
	ang:RotateAroundAxis(ang:Up(), 90);
	ang:RotateAroundAxis(ang:Forward(), 90);

		render.SetMaterial(laser);
		--Fire Place #1
		render.DrawBeam(self:GetPos()+(self:GetUp()*20)+(self:GetForward()*2.8)+(self:GetRight()*11.5), self:GetPos()+(self:GetUp()*24)+(self:GetForward()*2.8)+(self:GetRight()*11.5), 1, 1, 1, Color(255, 0, 0, 0));
		
		--Fire Place #2
		render.DrawBeam(self:GetPos()+(self:GetUp()*20)+(self:GetForward()*2.8)+(self:GetRight()*-11.2), self:GetPos()+(self:GetUp()*24)+(self:GetForward()*2.8)+(self:GetRight()*-11.2), 1, 1, 1, Color(255, 0, 0, 0));

		--Fire Place #3
		render.DrawBeam(self:GetPos()+(self:GetUp()*20)+(self:GetForward()*-9.8)+(self:GetRight()*-11.2), self:GetPos()+(self:GetUp()*24)+(self:GetForward()*-9.8)+(self:GetRight()*-11.2), 1, 1, 1, Color(255, 0, 0, 0));
		
		--Fire Place #4
		render.DrawBeam(self:GetPos()+(self:GetUp()*20)+(self:GetForward()*-9.8)+(self:GetRight()*11.5), self:GetPos()+(self:GetUp()*24)+(self:GetForward()*-9.8)+(self:GetRight()*11.5), 1, 1, 1, Color(255, 0, 0, 0));		
		
		cam.Start3D2D(pos+ang:Up()*16, ang, 0.1)
		
			surface.SetDrawColor(Color( 47, 52, 57 )); -- бекграунд
			surface.DrawRect(-250, -150, 500, 300)	
			
			surface.SetDrawColor(Color( 236, 113, 73 )); -- zagolovok
			surface.DrawRect(-250, -150, 500, 35)	
	

			draw.SimpleText("Плита для метамфетамина", "Trebuchet24", 0, -145, Color(255, 255, 255, 255), TEXT_ALIGN_CENTER);
	
			surface.SetMaterial(plita);
			surface.SetDrawColor(Color(255, 255, 255, 255));
			surface.DrawTexturedRect(-50, -73, 100, 100);

			draw.RoundedBox(5, -140, 60, 260, 60, Color(60,60,60))

			surface.SetDrawColor(Color( 50, 50, 57 )); -- poloska za gazom
			surface.DrawRect(-90, 75, 194, 30)
			
			surface.SetMaterial(icongas);
			surface.SetDrawColor(Color(255, 255, 255, 255));
			surface.DrawTexturedRect(-135, 70, 40, 40);
			
			surface.SetDrawColor(Color( 236, 113, 73 ));
			surface.DrawRect(-90, 75, math.Round((self:GetGasStorage()*190)/self:GetGasStorageMax()), 30) -- gaz
			
			if self:GetGasStorage()*100 == 0 then
			draw.SimpleText("Заправте печь газом!", "Trebuchet24", -50, 80, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1, Color(25, 25, 25, 200));
			else
			draw.SimpleText("Газ: "..math.Round((self:GetGasStorage()*100)/self:GetGasStorageMax()).."%", "Trebuchet24", -50, 80, Color(255, 255, 255, 255), TEXT_ALIGN_LEFT, TEXT_ALIGN_LEFT, 1, Color(25, 25, 25, 200));
			end

			--Fire Place #1
			if !self:GetFirePlace1() then
					surface.SetMaterial(red);
			elseif self:GetFirePlace1() then
				if (self:GetGasStorage()>0) then
					surface.SetMaterial(green);
				else 		
					surface.SetMaterial(red);
				end;
			end;
				surface.SetDrawColor(Color(255, 255, 255, 255));
				surface.DrawTexturedRect(-41, -11, 30, 30);
				
			--Fire Place #2
			if !self:GetFirePlace2() then			
					surface.SetMaterial(red);
			elseif self:GetFirePlace2() then
				if (self:GetGasStorage()>0) then
					surface.SetMaterial(green);
				else 		
					surface.SetMaterial(red);
				end;
			end;	
				surface.SetDrawColor(Color(255, 255, 255, 255));	
				surface.DrawTexturedRect(10, -11, 30, 30);	
				
			--Fire Place #3
			if !self:GetFirePlace3() then				
					surface.SetMaterial(red);	
			elseif self:GetFirePlace3() then		
				if (self:GetGasStorage()>0) then
					surface.SetMaterial(green);
				else 		
					surface.SetMaterial(red);
				end;
			end;
				surface.SetDrawColor(Color(255, 255, 255, 255));
				surface.DrawTexturedRect(10, -60, 30, 30);	
			
			--Fire Place #4
			if !self:GetFirePlace4() then					
					surface.SetMaterial(red);
			elseif self:GetFirePlace4() then			
				if (self:GetGasStorage()>0) then
					surface.SetMaterial(green);
				else 		
					surface.SetMaterial(red);
				end;
			end;
				surface.SetDrawColor(Color(255, 255, 255, 255));
				surface.DrawTexturedRect(-40, -60, 30, 30);			
					
		cam.End3D2D()
end;
--addons/module_css2/lua/entities/ent_explosivegrenade/shared.lua:
ENT.Type = "anim"
ENT.PrintName		= "EXPLOSIVE GRENADE"
ENT.Category        = "Запрещено"
ENT.Author			= "WORSHIPPER"
ENT.Contact			= ""
ENT.Purpose			= ""
ENT.Instructions	= ""
/*---------------------------------------------------------
OnRemove
---------------------------------------------------------*/
function ENT:OnRemove()
end

/*---------------------------------------------------------
PhysicsUpdate
---------------------------------------------------------*/
function ENT:PhysicsUpdate()
end

/*---------------------------------------------------------
PhysicsCollide
---------------------------------------------------------*/
function ENT:PhysicsCollide(data,phys)
	if data.Speed > 150 then
		self.Entity:EmitSound(Sound("HEGrenade.Bounce"))
	end
	
	local impulse = -data.Speed * data.HitNormal * .2 + (data.OurOldVelocity * -.4)
	phys:ApplyForceCenter(impulse)
end

--addons/weapon_shield/lua/entities/ent_fridge_shield_unbreakable/shared.lua:
ENT.Type = 'anim'
ENT.Base = 'base_anim'
ENT.PrintName = 'Fridge Shield'
ENT.Category = ''

ENT.Spawnable = false
ENT.DisableDuplicator = true
--addons/weapon_shield/lua/entities/ent_swat_shield/cl_init.lua:
include('shared.lua')
ENT.RenderGroup = RENDERGROUP_BOTH

function ENT:Draw()  
    self:DrawModel()
end
--addons/ent_bomb/lua/entities/ent_timebomb/cl_init.lua:
include("shared.lua")

local color_dark = Color(54,57,62,255)

net.Receive("sendMenu", function()
  local bomb = net.ReadEntity()

  if bomb:GetStartBomb() then 
    notification.AddLegacy("Бомба уже запущена!", 1, 5) 
    return 
  end

  local frame = vgui.Create("DFrame")
  frame:SetSize(ScrW() / 5, ScrH() / 5)
  frame:SetTitle("Бомбук c:")
  frame:Center()
  frame:SetIcon("icon16/bomb.png")
  frame:MakePopup()
  frame:ShowCloseButton(false)
  frame.Paint = function()
    draw.RoundedBox(0,0,0,frame:GetWide(),frame:GetTall(),color_dark)  
  end
  
  local slider = vgui.Create("DNumSlider", frame)
  slider:Dock(TOP)
  slider:SetText("Время (сек)")
  slider:SetMinMax(300,600)
  slider:SetValue(300)
  slider:SetDecimals(0)

  local check = vgui.Create("DCheckBoxLabel", frame)
  check:Dock(TOP)
  check:SetText("Заморозить бомбу")
  check:SetValue(false)

  local equip = vgui.Create("DCheckBoxLabel", frame)
  equip:Dock(TOP)
  equip:SetText("Надеть бомбу на себя")
  equip:SetValue(false)

  function equip:OnChange( val )
	if check:GetChecked() then
		check:SetValue(false)
	end
  end

  function check:OnChange( val )
	if equip:GetChecked() then
		equip:SetValue(false)
	end
  end

  local close = vgui.Create("DButton", frame)
  close:Dock(BOTTOM)
  close:SetText("Закрыть")
  close:SetIcon("icon16/cancel.png")
  close.DoClick = function()
    frame:Remove()
  end

  local save = vgui.Create("DButton", frame)
  save:Dock(BOTTOM)
  save:SetText("Применить и запустить")
  save:SetIcon("icon16/accept.png")
  save.DoClick = function()
    local time = slider:GetValue()
    local freeze = check:GetChecked()
    local bombequip = equip:GetChecked()

    net.Start("acceptSetting")
      net.WriteEntity(bomb)
      net.WriteFloat(time)
      net.WriteBool(freeze)
      net.WriteBool(bombequip)
    net.SendToServer()
    
    frame:Remove()
  end
end)


local color_red = Color(255,0,0,255)
local color_green = Color(0,255,0,255)
local vec = Vector(0, 17, 20)
local an = Angle(0, 90, 90)

function ENT:Draw()
  local endTime = ( self:GetNetVar("ExplodeTime") or 0 ) - CurTime()
  
  self:DrawModel()

  local entpos = self:GetPos()
  local ang = self:GetAngles()
  local pos = entpos + self:GetUp()*9 + self:GetForward()*4 + self:GetRight()*4.7
  
  ang:RotateAroundAxis(ang:Up(), -90)

  cam.Start3D2D(pos,ang, 0.1)
  if endTime <= 0 then
    draw.SimpleText("DISABLE", "Default", 0,0,color_green, TEXT_ALIGN_CENTER)
  else
    draw.SimpleText("Время: "..math.floor(endTime), "Default", 0,0,color_red, TEXT_ALIGN_CENTER)
  end
  
  cam.End3D2D()

  if LocalPlayer():GetPos():DistToSqr(entpos) > 90000 then return end

  local pos, ang = LocalToWorld(vec, an, entpos, ang)

  cam.Start3D2D(pos,ang, 0.1)
    if LocalPlayer():isCP() and self:GetStartBomb() then
      draw.SimpleText('Нажми Е для разминирования', 'Trebuchet48', -170,-40,color_white, TEXT_ALIGN_CENTER) 
    end
  cam.End3D2D()

  local pos, ang = LocalToWorld(Vector(0, -17, 20), Angle(0, -90, 90), entpos, ang)
  cam.Start3D2D(pos,ang, 0.1)
    if LocalPlayer():isCP() and self:GetStartBomb() then
      draw.SimpleText('Нажми Е для разминирования', 'Trebuchet48', -170,-40,color_white, TEXT_ALIGN_CENTER) 
    end
  cam.End3D2D()
end

hook.Add('HUDPaint', 'bomb', function()
  if not IsValid(LocalPlayer()) then return end

  local bomb = LocalPlayer():GetNetVar('EquippedBomb')
  if not IsValid(bomb) then return end

  local time = (bomb:GetNetVar('ExplodeTime') or 0) - CurTime()
  local text = 'До взрыва бомбы: '..os.date('%M:%S', time)
  draw.SimpleText( text, 'chelog-ib-shadow', ScrW() / 2, ScrH() - 40, color_black, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
  draw.SimpleText( text, 'chelog-ib', ScrW() / 2, ScrH() - 40, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
end)

hook.Add('EquippedBomb', 'setnodraw', function(ply, bomb, old)
  if ply ~= LocalPlayer() then return end

  if IsValid(bomb) then
    bomb:SetNoDraw(true)
  elseif IsValid(old) then
    old:SetNoDraw(false)
  end
end)
--gamemodes/darkrp/entities/entities/gmod_cameraprop.lua:

AddCSLuaFile()

if ( CLIENT ) then
	CreateConVar( "cl_drawcameras", "1", 0, "Should the cameras be visible?" )
end

ENT.Type = "anim"
ENT.PrintName = "Camera"

local CAMERA_MODEL = Model( "models/dav0r/camera.mdl" )

function ENT:SetupDataTables()

	self:NetworkVar( "Int", 0, "Key" )
	self:NetworkVar( "Bool", 0, "On" )
	self:NetworkVar( "Vector", 0, "vecTrack" )
	self:NetworkVar( "Entity", 0, "entTrack" )
	self:NetworkVar( "Entity", 1, "Player" )

end

-- Custom drive mode
function ENT:GetEntityDriveMode()

	return "drive_noclip"

end

function ENT:Initialize()

	if ( SERVER ) then

		self:SetModel( CAMERA_MODEL )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:DrawShadow( false )

		-- Don't collide with the player
		self:SetCollisionGroup( COLLISION_GROUP_WEAPON )

		local phys = self:GetPhysicsObject()

		if ( IsValid( phys ) ) then
			phys:Sleep()
		end

	end

end

function ENT:SetTracking( Ent, LPos )

	if ( IsValid( Ent ) ) then

		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_BBOX )

	else

		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )

	end

	self:NextThink( CurTime() )

	self:SetvecTrack( LPos )
	self:SetentTrack( Ent )

end

function ENT:SetLocked( locked )

	if ( locked == 1 ) then

		self.PhysgunDisabled = true

		self:SetMoveType( MOVETYPE_NONE )
		self:SetSolid( SOLID_BBOX )

		self:SetCollisionGroup( COLLISION_GROUP_WORLD )

	else

		self.PhysgunDisabled = false

	end

	self.locked = locked

end

function ENT:OnTakeDamage( dmginfo )
	if ( self.locked ) then return end
	self:TakePhysicsDamage( dmginfo )
end

function ENT:OnRemove()

	if ( IsValid( self.UsingPlayer ) ) then

		self.UsingPlayer:SetViewEntity( self.UsingPlayer )

	end

end

if ( SERVER ) then

	numpad.Register( "Camera_On", function( pl, ent )

		if ( !IsValid( ent ) ) then return false end
		if ( !IsValid( pl ) ) then return false end

		pl:SetViewEntity( ent )
		pl.UsingCamera = ent
		ent.UsingPlayer = pl

	end )

	numpad.Register( "Camera_Toggle", function( pl, ent, idx, buttoned )

		-- The camera was deleted or something - return false to remove this entry
		if ( !IsValid( ent ) ) then return false end
		if ( !IsValid( pl ) ) then return false end

		-- Something else changed players view entity
		if ( pl.UsingCamera && pl.UsingCamera == ent && pl:GetViewEntity() != ent ) then
			pl.UsingCamera = nil
			ent.UsingPlayer = nil
		end

		if ( pl.UsingCamera && pl.UsingCamera == ent ) then

			pl:SetViewEntity( pl )
			pl.UsingCamera = nil
			ent.UsingPlayer = nil

		else

			pl:SetViewEntity( ent )
			pl.UsingCamera = ent
			ent.UsingPlayer = pl

		end

	end )

	numpad.Register( "Camera_Off", function( pl, ent )

		if ( !IsValid( ent ) ) then return false end
		if ( !IsValid( pl ) ) then return false end

		if ( pl.UsingCamera && pl.UsingCamera == ent ) then
			pl:SetViewEntity( pl )
			pl.UsingCamera = nil
			ent.UsingPlayer = nil
		end

	end )

end

function ENT:Think()

	if ( CLIENT ) then

		self:TrackEntity( self:GetentTrack(), self:GetvecTrack() )

	end

end

function ENT:TrackEntity( ent, lpos )

	if ( !IsValid( ent ) ) then return end

	local WPos = ent:LocalToWorld( lpos )

	if ( ent:IsPlayer() ) then
		WPos = WPos + ent:GetViewOffset() * 0.85
	end

	local CamPos = self:GetPos()
	local Ang = WPos - CamPos

	Ang = Ang:Angle()
	self:SetAngles( Ang )

end

function ENT:CanTool( ply, trace, mode, tool, click )

	if ( self:GetMoveType() == MOVETYPE_NONE ) then return false end

	return true

end

function ENT:Draw( flags )

	if ( GetConVarNumber( "cl_drawcameras" ) == 0 ) then return end

	-- Don't draw the camera if we're taking pics
	local wep = LocalPlayer():GetActiveWeapon()
	if ( IsValid( wep ) and wep:GetClass() == "gmod_camera" ) then
		return
	end

	self:DrawModel( flags )

end

--addons/module_itemstore/lua/entities/itemstore_bank.lua:
ENT.Type = "anim"
ENT.RenderGroup = RENDERGROUP_TRANSLUCENT

ENT.PrintName = "Bank"
ENT.Category = "Запрещено"

ENT.Spawnable = true
ENT.AdminOnly = false

if SERVER then
	AddCSLuaFile()

	function ENT:Initialize()
		self:SetModel( "models/props_c17/Lockers001a.mdl" )

		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetUseType( SIMPLE_USE )

		self:GetPhysicsObject():EnableMotion( false )
	end

	function ENT:SpawnFunction( pl, trace, class )
		local ent = ents.Create( class )
		ent:SetPos( trace.HitPos + trace.HitNormal * 16 )
		ent:Spawn()

		return ent
	end

	function ENT:Use( pl )
		if not IsValid( pl ) then return end

		pl.Bank:Sync()
		pl:OpenContainer( pl.Bank:GetID(), itemstore.Translate( "bank" ) )
	end
else
	local logo = Material('data/wimages/wlogo.png')
	local color_bright = Color(236, 113, 71)
	local color_dark = Color(43, 49, 54)
	local color_other = Color(150, 150, 150)
	local color_line = Color(77, 75, 77)
  	
	function ENT:DrawTranslucent()
		self:DrawModel()

	    local lp = LocalPlayer()
	    local distSqr = 90000
	    
	    if lp:GetPos():DistToSqr( self:GetPos() ) > distSqr then return end

		local ang = LocalPlayer():EyeAngles()
		local pos = self:GetPos() + Vector(0,0,self:OBBMaxs().z + 15)

		ang:RotateAroundAxis(ang:Forward(), 90)
		ang:RotateAroundAxis(ang:Right(), 90)

		cam.Start3D2D(pos, Angle(ang.x, ang.y, ang.z), 0.15)
			draw.RoundedBox(0,-130,10,260,60,color_bright)
			draw.RoundedBox( 0,-130,10,260,28, color_dark )
			surface.SetDrawColor( color_other )
			surface.SetMaterial( logo ) 
			surface.DrawTexturedRect( -125, 13, 23, 23 )	
			draw.SimpleText( " WayZer's Role Play", "Trebuchet24", -103, 23, color_white, 0, 1 )
			draw.SimpleText( 'Хранилище', "Trebuchet24", -120, 51, color_white, 0, 1 )
			surface.SetDrawColor(color_line)
			surface.DrawOutlinedRect( -130,10,260,60 )
		cam.End3D2D()
	end
end

--addons/module_itemstore/lua/entities/itemstore_deathloot.lua:
ENT.Type = "anim"
ENT.Base = "itemstore_box"

ENT.PrintName = "Death Loot"
ENT.Category = "ItemStore"

ENT.Spawnable = false
ENT.AdminOnly = false

if SERVER then
	AddCSLuaFile()

	ENT.Model = "models/props_junk/garbage_bag001a.mdl"

	ENT.ContainerWidth = 5
	ENT.ContainerHeight = 5
	ENT.ContainerPages = 2

	ENT.Timeout = 0

	function ENT:Think()
		if self.Timeout < CurTime() then self:Remove() end
	end
end

--gamemodes/darkrp/entities/entities/letter/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "letter"
ENT.Author = "Pcwizdan"
ENT.Spawnable = false

function ENT:SetupDataTables()
    self:NetworkVar("Entity",1,"owning_ent")
    self:NetworkVar("Entity",2,"signed")
end

DarkRP.declareChatCommand{
    command = "write",
    description = "Write a letter.",
    delay = 5
}

DarkRP.declareChatCommand{
    command = "type",
    description = "Type a letter.",
    delay = 5
}

DarkRP.declareChatCommand{
    command = "removeletters",
    description = "Remove all of your letters.",
    delay = 5
}

--addons/module_chocolate/lua/entities/lucid_choc_milk.lua:
--Made by ThatCatGuy
--https://github.com/ThatCatGuy
--https://steamcommunity.com/sharedfiles/filedetails/?id=2195413561
--Stupidly rewritten by OverlordAkise (has alzheimers)

AddCSLuaFile()
ENT.Type = 'anim'
 
ENT.PrintName = "Milk"
ENT.Category = "Chocolate Maker"
ENT.Author = "OverlordAkise"
ENT.Purpose = "Make Chocolate"
ENT.Instructions = "N/A"
ENT.Model = "models/props_junk/garbage_milkcarton002a.mdl"

ENT.Spawnable = true
ENT.AdminSpawnable = true

if SERVER then 
  function ENT:Initialize()
    self:SetModel(self.Model)
    self:PhysicsInit( SOLID_VPHYSICS )
    self:SetMoveType( MOVETYPE_VPHYSICS )
    self:SetSolid( SOLID_VPHYSICS )
    local phys = self:GetPhysicsObject()
    if (phys:IsValid()) then
      phys:Wake()
    end
  end
  
else
  --CLIENT
  function ENT:Draw()
      self:DrawModel() 
  end

end
--addons/module_chocolate/lua/entities/lucid_choc_sugar.lua:
--Made by ThatCatGuy
--https://github.com/ThatCatGuy
--https://steamcommunity.com/sharedfiles/filedetails/?id=2195413561
--Stupidly rewritten by OverlordAkise (has alzheimers)

AddCSLuaFile()
ENT.Type = 'anim'
 
ENT.PrintName = "Sugar"
ENT.Category = "Chocolate Maker"
ENT.Author = "OverlordAkise"
ENT.Purpose = "Make Chocolate"
ENT.Instructions = "N/A"
ENT.Model = "models/props_junk/garbage_milkcarton001a.mdl"

ENT.Spawnable = true
ENT.AdminSpawnable = true

if SERVER then 
  function ENT:Initialize()
    self:SetModel(self.Model)
    self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
    self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
    self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    local phys = self:GetPhysicsObject()
    if (phys:IsValid()) then
      phys:Wake()
    end
  end
  
else
  --CLIENT
  function ENT:Draw()
      self:DrawModel() 
  end

end
--addons/module_media/lua/entities/media_base/shared.lua:
ENT.Base = "base_anim"
ENT.Type = "anim"
ENT.PrintName = ""
ENT.Category = ""
ENT.Author = "\\sqdAva"
ENT.Contact = ""
ENT.Purpose = ""
ENT.Instructions = ""
ENT.Spawnable = false
ENT.IsRadio = true
ENT.AdminSpawnable = true
--ENT.Activated = false

function ENT:SetupDataTables()
    self:NetworkVar('String', 0, 'Url')
    self:NetworkVar('String', 1, 'Title')
    self:NetworkVar('Int', 0, 'startTime')
    self:NetworkVar('Int', 1, 'Time')
    self:NetworkVar('Int', 2, 'Freezen')
    self:NetworkVar('Int', 3, 'Loop')
    self:NetworkVar('Int', 4, 'Playing')
    self:NetworkVar('Entity', 0, "owning_ent")
end

function ENT:IsLoop()
    return self:GetLoop() == 1
end

function ENT:CanUse(ply)
    return self:CPPIGetOwner() == ply
end

function ENT:IsPlaying()
    return self:GetPlaying() == 1
end

function ENT:IsFreeze()
    return self:GetFreezen() == 1
end
--addons/module_samogon/lua/entities/mn_barrel/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Деревянная бочка"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false

function ENT:SetupDataTables()
	self:NetworkVar("Bool", 0, "dist_full")
	self:NetworkVar("Int", 0, "dist_shinepos")
	self:NetworkVar("Int", 1, "dist_moonshine")
	self:NetworkVar("Int", 2, "dist_alcohol")
	self:NetworkVar("Entity", 0, "owning_ent")
end

--addons/module_samogon/lua/entities/mn_bottle/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_ccorn/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_corn/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_cseed/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_distillery/cl_init.lua:
include("shared.lua")

local dist_load1 = Material("materials/dist_ui/panel.png")	
local dist_load2 = Material("materials/dist_ui/bluebar.png")	
local dist_load3 = Material("materials/dist_ui/cooldown.png")
local dist_load4 = Material("materials/dist_ui/redbar.png")		
local dist_load5 = Material("materials/dist_ui/start.png")	
local dist_load6 = Material("materials/dist_ui/corn.png")
local dist_load7 = Material("materials/dist_ui/grain.png")
local dist_load8 = Material("materials/dist_ui/stop.png")
local dist_load9 = Material("materials/dist_ui/cooling.png")

function ENT:Draw()
	self:DrawModel()
	
	local dist_pos = self:GetPos()
	local ply = LocalPlayer()

	if dist_pos:DistToSqr(ply:GetPos()) > 90000 then return end
	
	local dist_ang = self:GetAngles()
	local dist_clagrain = math.Clamp( self:Getdist_grain(), 0, 61 )
	local dist_clacorn = math.Clamp( self:Getdist_corn(), 0, 61 )
	local dist_clawater = math.Clamp( self:Getdist_water(), 0, 61 )
	local dist_cladegree = math.Clamp( self:Getdist_degree(), 0, 200 )
	local dist_tr = self:WorldToLocal( LocalPlayer():GetEyeTrace().HitPos )
	
	dist_ang:RotateAroundAxis(self:GetAngles():Up(), 450)
	dist_ang:RotateAroundAxis(self:GetAngles():Right(), 270)
	dist_ang:RotateAroundAxis(self:GetAngles():Up(), 90)
	
	cam.Start3D2D(dist_pos + dist_ang:Up() * 26.9, dist_ang, 0.11)	
	
		draw.RoundedBox(0,-78,-68,156,156,Color(20,20,20))
		surface.SetDrawColor( 100, 100, 100, 255 )
		surface.SetMaterial( dist_load2	) 
		surface.DrawTexturedRect( 4,32,dist_clawater,16 )
		surface.SetDrawColor( dist_cladegree, 0, 0, 255 )
		surface.SetMaterial( dist_load4	) 
		surface.DrawTexturedRect( 4,56,dist_cladegree / 3.28,16 )
		surface.SetDrawColor( 255, 255, 255, 255 )		
		surface.SetMaterial( dist_load7	) 
		surface.DrawTexturedRect( -65,3,dist_clagrain,16 )
		surface.SetMaterial( dist_load6	) 
		surface.DrawTexturedRect( 4,3,dist_clacorn,16 ) 
		surface.SetDrawColor( 216, 216, 216, 255 )	
		surface.SetMaterial( dist_load1	) 
		surface.DrawTexturedRect( -78,-68,156,156 )
		
		if (dist_tr:WithinAABox( distl_.dist_pos1, distl_.dist_pos2)) then
			if self:Getdist_start() then
				surface.SetDrawColor( 200, 200, 200, 255 )
				surface.SetMaterial( dist_load8	) 
				surface.DrawTexturedRect( -78,-68,156,156 )
			else
				surface.SetDrawColor( 200, 200, 200, 255 )
				surface.SetMaterial( dist_load5	) 
				surface.DrawTexturedRect( -78,-68,156,156 )			
			end
		else
			if self:Getdist_start() then
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( dist_load8	) 
				surface.DrawTexturedRect( -78,-68,156,156 )
			else
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( dist_load5	) 
				surface.DrawTexturedRect( -78,-68,156,156 )
			end
		end	
		
		if (dist_tr:WithinAABox( distl_.dist_pos3, distl_.dist_pos4)) then	
			if self:Getdist_cooling() then
				surface.SetDrawColor( 200, 200, 200, 255 )
				surface.SetMaterial( dist_load9	) 
				surface.DrawTexturedRect( -78,-68,156,156 )
			else
				surface.SetDrawColor( 200, 200, 200, 255 )
				surface.SetMaterial( dist_load3	) 
				surface.DrawTexturedRect( -78,-68,156,156 )			
			end
		else
			if self:Getdist_cooling() then
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( dist_load9	) 
				surface.DrawTexturedRect( -78,-68,156,156 )
			else
				surface.SetDrawColor( 255, 255, 255, 255 )
				surface.SetMaterial( dist_load3	) 
				surface.DrawTexturedRect( -78,-68,156,156 )
			end	
		end

	cam.End3D2D()
end		
--addons/module_samogon/lua/entities/mn_toppiece/cl_init.lua:

include("shared.lua")

function ENT:Initialize()
end

function ENT:Draw()
	self:DrawModel()
end


--addons/module_samogon/lua/entities/mn_toppiece/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Труба"
ENT.Author = "Mikael"
ENT.Category = "Запрещено"
ENT.Spawnable = true
ENT.AdminSpawnable = false


--addons/ent_top/lua/entities/score_base/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Scoresheet Base"
ENT.Category = "Запрещено"
ENT.Author = "RayChamp"
ENT.Spawnable = false
--addons/module_weed/lua/entities/sent_light.lua:
AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Base = "sent_base_gonzo"

ENT.Linkable = true

ENT.Size = Vector(30,30,40)
ENT.PrintName		= "Свет"
ENT.Author			= "Gonzo"
ENT.Category		= "Drugs"
ENT.Spawnable 		= false
ENT.AdminOnly 		= false

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/gonzo/weedb/lamp.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
		self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
		self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    self:SetUseType(SIMPLE_USE)
    self:SetCharge(0)
    self:SetOn(false)
	    local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
	end
end

function ENT:Touch(entity)
  if(entity:GetClass() == "sent_battery" && entity:GetCharge() > 0 && self:GetCharge() <= 0) then
    entity:SetParent(self)
    entity:SetLocalAngles(Angle(90,0,0))
    entity:SetLocalPos(Either((self.IsRadial or false),Vector(-14,-7,26.5),Vector(-11,-7,38)))
    entity:SetCollisionGroup(COLLISION_GROUP_DEBRIS)
    self.Battery = entity
    self:SetCharge(entity:GetCharge())
    self:EmitSound("buttons/button1.wav")
  end
end

function ENT:Think()
	if SERVER then
		if(self:GetOn() && self:GetCharge() > 0) then

			self:SetCharge(self:GetCharge()-1)

			if self:GetCharge() <= 0 then
        if(!self.Battery:GetDisposable()) then
          local ent = ents.Create("sent_battery")
          ent:SetAngles(Angle(90,0,0))
          ent:SetPos(self:GetPos()-self:GetRight()*11-self:GetForward()*7+self:GetUp()*48)
          undo.ReplaceEntity(self.Battery,ent)
          if(IsValid(self.Battery)) then
            self.Battery:Remove()
          end
          ent:Spawn()
          ent:SetCharge(0)
        else
          if(IsValid(self.Battery)) then
            self.Battery:Remove()
          end
        end
				if(IsValid(self.Shine)) then
					self.Shine:Remove()
				end
        self:SetOn(false)
			end

			self:NextThink(WEED_CONFIG.LampDrain + CurTime())
			return true
		end
	end
end

function ENT:SetLight(x)
  if(x == 2) then
    self:SetModel("models/gonzo/weedb/lamp2.mdl")
    self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
    self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
    self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    self:SetUseType(SIMPLE_USE)
    local phys = self:GetPhysicsObject()
    if (phys:IsValid()) then
      phys:Wake()
    end
    self.IsRadial = true
  end
end

function ENT:Use(ply)
    self:SetOn(Either(self:GetOn(),false,true))
    self:EmitSound("buttons/button1.wav")
    if(self:GetOn() && self:GetCharge() > 0) then
			Shine = ents.Create("env_sprite")
      local pos = Either(!(self.IsRadial or false), self:GetPos() + self:GetUp()*32 + self:GetRight()*-0 + self:GetForward()*20,self:GetPos()+self:GetUp()*102+self:GetRight()*16)
			Shine:SetPos(pos)
			Shine:SetKeyValue("renderfx", "0")
			Shine:SetKeyValue("rendermode", "9")
			Shine:SetKeyValue("renderamt", "200")
			Shine:SetKeyValue("rendercolor", "255 255 255")
			Shine:SetKeyValue("framerate12", "25")
			Shine:SetKeyValue("model", "light_glow03.spr")
			Shine:SetKeyValue("scale", Either(!(self.IsRadial or false),"1.3","2"))
			Shine:SetKeyValue("GlowProxySize", "20")
			Shine:SetParent(self)
			Shine:Spawn()
			Shine:Activate()
			self.Shine = Shine
		elseif(IsValid(self.Shine)) then
			self.Shine:Remove()
		end
end

function ENT:SetupDataTables()
  self:NetworkVar("Int", 0, "Charge")
  self:NetworkVar("Bool", 0, "On")
end

if CLIENT then

local rope = Material("gui/rope")
local hl = Color(231, 76, 60),Color(230, 126, 34),Color(241, 196, 15),Color(46, 204, 113)
local light = surface.GetTextureID("gui/light")

function ENT:PostDraw()

  if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
    return
  end

  render.SetMaterial(rope)
  if(self:GetCharge() > 0  && self:GetModel() != "models/gonzo/weedb/lamp2.mdl") then
    render.DrawBeam(self:GetPos() + self:GetForward()*148-self:GetRight()*64,self:GetPos() + self:GetForward()*16-self:GetRight()*8,1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))
    render.DrawBeam(self:GetPos() + self:GetForward()*148+self:GetRight()*64,self:GetPos() + self:GetForward()*16+self:GetRight()*8,1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))
    render.DrawBeam(self:GetPos() + self:GetForward()*148+self:GetRight()*65,self:GetPos() + self:GetForward()*148-self:GetRight()*65,1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))
  elseif(self:GetCharge() > 0) then
    render.DrawBeam(self:GetPos() + self:GetForward()*196/2,self:GetPos(),1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))
    render.DrawBeam(self:GetPos() - self:GetForward()*196/2,self:GetPos(),1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))
    render.DrawBeam(self:GetPos() + self:GetRight()*196/2,self:GetPos(),1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))
    render.DrawBeam(self:GetPos() - self:GetRight()*196/2,self:GetPos(),1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))

    render.DrawBeam(self:GetPos() - self:GetRight()*196/2,self:GetPos() - self:GetForward()*196/2,1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))
    render.DrawBeam(self:GetPos() + self:GetRight()*196/2,self:GetPos() + self:GetForward()*196/2,1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))
    render.DrawBeam(self:GetPos() - self:GetRight()*196/2,self:GetPos() + self:GetForward()*196/2,1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))
    render.DrawBeam(self:GetPos() + self:GetRight()*196/2,self:GetPos() - self:GetForward()*196/2,1,0,4,Color(255, 180, 50,Either(self:GetOn(),255,35)))
  end
end

function ENT:DoInfo()
  if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
    return
  end

  surface.SetDrawColor(50,50,50,150)
  surface.DrawRect(12,-32,268,128)
  draw.SimpleTextOutlined(self.PrintName.." ("..Either(self:GetOn(),"Вкл","Выкл")..")","MainWeedFont_med",36,-2,Color(255,255,255),TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER,1,Color(75,75,75))
  surface.SetMaterial(rope)
	surface.SetDrawColor(255,255,255,255)
  surface.DrawTexturedRectUV( 12, -32, 4, 128, 0, 0, 1, 1 )
  surface.DrawTexturedRectUVRotated(12+268, 30, 4, 128, 0, 0, 1, 1 ,180)
  surface.DrawTexturedRectUVRotated(12+268/2, -32, 4, 268, 0, 0, 1, 2 ,90)
  surface.DrawTexturedRectUVRotated(12+268/2, -32+128, 4, 268, 0, 0, 1, 2 ,90)

  surface.SetTexture(light)
	surface.SetDrawColor(hl)
	surface.DrawTexturedRect(30,24,64,64)

  draw.SimpleTextOutlined(self:GetCharge().." %","MainWeedFont",268,56,Color(255,255,255),TEXT_ALIGN_RIGHT,TEXT_ALIGN_CENTER,1,Color(75,75,75))

end

end

--addons/module_weed/lua/entities/sent_soil.lua:

AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Base = "sent_base_gonzo"
ENT.PrintName		= "Грунт"
ENT.Author			= "Gonzo"
ENT.Spawnable 		= false
ENT.Category		= "Drugs"
ENT.AdminOnly 		= true
ENT.Size = Vector(20,30,30)

ENT.Soil = 1;

function ENT:SpawnFunction( ply, tr, ClassName )

	if ( !tr.Hit ) then return end

	local SpawnPos = tr.HitPos

	local ent = ents.Create( ClassName )
	ent:SetPos( SpawnPos )
	ent:Spawn()
	ent:Activate()
	ent.Owner = ply

	return ent

end

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/gonzo/weedb/Soil_bag.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )
		self:SetMoveType( MOVETYPE_VPHYSICS )
		self:SetSolid( SOLID_VPHYSICS )
		self:SetCharges(3)

	  local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end
	end
end

ENT.Waterizer = 0
ENT.Extra = 0

function ENT:SetSoil(x)
	self:SetSkin(x-1)
	if(x==1) then
		self.Waterizer = 0
		self.Extra = 0
	elseif(x==2) then
		self.Waterizer = -30
		self.Extra = 5
		self:SetHUDName("Acid Soil")
	elseif(x==3) then
		self.Waterizer = 100
		self.Extra = -2
		self:SetHUDName("Dank Soil")
	end
end

function ENT:Touch(entity)
	if(entity:GetClass() == "sent_pot" && (entity:GetSoil() == 0) && (!entity:GetMultiplePot() || (entity:GetMultiplePot() && self:GetCharges()) == 3)) then
		entity:SetBodygroup(1,1)
		entity:SetSoil(self.Soil)
		entity:SetMaxWater(entity:GetMaxWater()+self.Waterizer)
		entity:SetExtra(entity:GetExtra()+self.Extra)
		self:SetCharges(self:GetCharges()-Either(entity:GetMultiplePot(),3,1))
		if(self:GetCharges() <= 0) then
			self:Remove()
		end
	end
end

function ENT:Use(act)

end

function ENT:Think()

end


function ENT:SetupDataTables()
    self:NetworkVar("String", 0, "HUDName")
    self:NetworkVar("Int", 0, "Charges")
end
--addons/module_weed/lua/entities/sent_water_pot.lua:
AddCSLuaFile()
DEFINE_BASECLASS( "base_anim" )

ENT.Base = "sent_base_gonzo"

ENT.PrintName		= "Вода"
ENT.Author			= "Gonzo"
ENT.Category		= "Drugs"
ENT.Spawnable 		= false
ENT.AdminOnly 		= false

ENT.Amount = 30

function ENT:Initialize()

 	if SERVER then
		self:SetModel( "models/gonzo/weedb/water_pot.mdl" )
		self:PhysicsInit( SOLID_VPHYSICS )      -- Make us work with physics,
		self:SetMoveType( MOVETYPE_VPHYSICS )   -- after all, gmod is a physics
		self:SetSolid( SOLID_VPHYSICS )         -- Toolbox
    self:SetWaterAmount(100)
    local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
			phys:Wake()
		end

        self:SetOn(true)
	end
end


function ENT:SetupDataTables()
    self:NetworkVar("Int", 0, "WaterAmount")
    self:NetworkVar("Bool", 0, "Shower")
    self:NetworkVar("Bool", 1, "On")
end

function ENT:Use(ply)

    if(!self:GetShower()) then return end

    self:SetOn(Either(self:GetOn(),false,true))
    self:EmitSound("buttons/button1.wav")

end

function ENT:SetWater(x)
    self.Size = Vector(10,30,30)
    if(x==2) then
        self:SetModel("models/gonzo/weedb/shower.mdl")
        self:PhysicsInit( SOLID_VPHYSICS )
		    self:SetMoveType( MOVETYPE_VPHYSICS )
		    self:SetSolid( SOLID_VPHYSICS )
        self:SetUseType(SIMPLE_USE)
        self:SetWaterAmount(300)
        self:SetShower(true)
        self.Size = Vector(100,0,50)
    end
end

function ENT:Think()
  if SERVER then
    local ang = self:GetAngles().r
    if(self:GetWaterAmount() > 0 && Either(self:GetShower(),true,(ang < -90 || ang >= 40)) && self:GetOn()) then

        local mr = math.random(1,Either(self:GetShower(),1,5))
        self:SetWaterAmount(self:GetWaterAmount()-mr)

      if(!self:GetShower()) then

          local vPoint = self:GetPos() + self:GetUp()*28 + self:GetRight()*24
          local effectdata = EffectData()
          effectdata:SetOrigin( vPoint )
          util.Effect( "watersplash", effectdata )

          local tr = util.QuickTrace( self:GetPos() + self:GetUp()*28 + self:GetRight()*24, Vector(0,0,-1)*512, self )
          if(tr.Entity:GetClass() == "sent_pot") then
            local wat = Either(self:GetShower(),3,1)*mr*WEED_CONFIG.WaterEffectiveness;
            tr.Entity:SetWaterAmount(math.Clamp(tr.Entity:GetWaterAmount()+wat,0,tr.Entity:GetMaxWater()))
            tr.Entity.Watered = CurTime() + 3
            tr.Entity:SetHealth(math.Clamp(tr.Entity:Health()+mr,0,100))
          end
      else
          for k=0,3 do
              local vPoint = self:GetPos() + self:GetUp()*92 + self:GetRight()*32*k - self:GetRight()*48
              local effectdata = EffectData()
              effectdata:SetOrigin( vPoint )
              effectdata:SetScale(0.35)
              util.Effect( "watersplash", effectdata )

              local tr = util.QuickTrace( self:GetPos() + self:GetUp()*92 + self:GetRight()*32*k - self:GetRight()*48, Vector(0,0,-1)*512, self )
              if(tr.Entity:GetClass() == "sent_pot") then
                local wat = Either(self:GetShower(),3,1)*mr*WEED_CONFIG.WaterEffectiveness;
                tr.Entity:SetWaterAmount(math.Clamp(tr.Entity:GetWaterAmount()+wat,0,tr.Entity:GetMaxWater()))
                tr.Entity.Watered = CurTime() + 1
                //76561198136465722
                tr.Entity:SetHealth(math.Clamp(tr.Entity:Health()+mr,0,100))
              end
          end
      end

      if(self:GetWaterAmount() <= 0) then
        self:Remove()
      end
      self:NextThink( CurTime() + Either(self:GetShower(),math.random(1.5,4),math.random(0.5,1.4)) )
  		return true
    end
  end
end

if CLIENT then

local rope = Material("gui/rope")
local hl = {Color(231, 76, 60),Color(230, 126, 34),Color(241, 196, 15),Color(46, 204, 113)}
local water = surface.GetTextureID("gui/water")
function ENT:PostDraw()
  if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
    return
  end

  local ang = self:GetAngles().r
  if(!self:GetShower()) then
    ctr = util.QuickTrace( self:GetPos() + self:GetUp()*28 + self:GetRight()*24, Vector(0,0,-1)*128, self )

    render.SetMaterial(rope)
    render.DrawBeam(self:GetPos() + self:GetUp()*28 + self:GetRight()*24,ctr.HitPos,1,0,3,Color(72, 200, 512,Either(self:GetWaterAmount() > 0 && ang < -90 || ang >= 40,200,50)))
    if(isvector(ctr.HitPos)) then
      render.DrawBeam(ctr.HitPos + Vector(-16,0,0),ctr.HitPos + Vector(0,0,0),1,0,1,Color(72, 200, 512,Either(self:GetWaterAmount() > 0 && ang < -90 || ang >= 40,200,50)))
      render.DrawBeam(ctr.HitPos + Vector(0,16,0),ctr.HitPos + Vector(0,-0,0),1,0,1,Color(72, 200, 512,Either(self:GetWaterAmount() > 0 && ang < -90 || ang >= 40,200,50)))
      render.DrawBeam(ctr.HitPos + Vector(0,-16,0),ctr.HitPos + Vector(0,0,0),1,0,1,Color(72, 200, 512,Either(self:GetWaterAmount() > 0 && ang < -90 || ang >= 40,200,50)))
      render.DrawBeam(ctr.HitPos + Vector(16,0,0),ctr.HitPos + Vector(0,-0,0),1,0,1,Color(72, 200, 512,Either(self:GetWaterAmount() > 0 && ang < -90 || ang >= 40,200,50)))
    end
    else
        render.SetMaterial(rope)
        for k=0,3 do
            ctr = util.QuickTrace( self:GetPos() + self:GetUp()*92 + self:GetRight()*32*k - self:GetRight()*48, Vector(0,0,-1)*128, self )
            render.DrawBeam(self:GetPos() + self:GetUp()*92 + self:GetRight()*32*k - self:GetRight()*48,ctr.HitPos,1,0,3,Color(72, 200, 512,Either(self:GetWaterAmount() > 0 && ang < -90 || ang >= 40,200,50)))
        end
  end
end

function ENT:DoInfo()
  if LocalPlayer():GetPos():DistToSqr(self:GetPos()) > 90000 then
    return
  end

  surface.SetDrawColor(50,50,50,150)
  surface.DrawRect(12,-32,268,128)
  draw.SimpleTextOutlined(self.PrintName,"MainWeedFont",36,-2,Color(255,255,255),TEXT_ALIGN_LEFT,TEXT_ALIGN_CENTER,1,Color(75,75,75))
  surface.SetMaterial(rope)
	surface.SetDrawColor(255,255,255,255)
  surface.DrawTexturedRectUV( 12, -32, 4, 128, 0, 0, 1, 1 )
  surface.DrawTexturedRectUVRotated(12+268, 30, 4, 128, 0, 0, 1, 1 ,180)
  surface.DrawTexturedRectUVRotated(12+268/2, -32, 4, 268, 0, 0, 1, 2 ,90)
  surface.DrawTexturedRectUVRotated(12+268/2, -32+128, 4, 268, 0, 0, 1, 2 ,90)

  surface.SetTexture(water)
	surface.SetDrawColor(hl[math.Clamp(math.Round((self:GetWaterAmount(00))/25),1,4)])
	surface.DrawTexturedRect(30,22,64,64)

  draw.SimpleTextOutlined(Either(self:GetOn(),(self:GetWaterAmount()/20).." л","OFF"),"MainWeedFont",268,56,Color(255,255,255),TEXT_ALIGN_RIGHT,TEXT_ALIGN_CENTER,1,Color(75,75,75))

end

end


--addons/module_slotmachine/lua/entities/slot_base/cl_init.lua:
include('shared.lua')

local angle = Angle(0, 90, 60 - .2)
local color_blue = Color(15, 74, 234)

function ENT:Draw()

    local ent = self
    local getpos = ent:GetPos()
    
    ent:DrawModel()

    if getpos:DistToSqr(LocalPlayer():GetPos()) > 15000 then return end

    local ang = ent:GetAngles()
    local pos = getpos + ang:Up() + ang:Forward() * 30.45
    local ang2 = ent:LocalToWorldAngles(angle)
    cam.Start3D2D(pos, ang2, 0.05)

    if ent:GetInService() then
        draw.RoundedBox(0, -250, -1300, 500, 380, color_blue)
        draw.SimpleText('(._.)', 'Trebuchet128', 0, -1200, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText('ТЕХНИЧЕСКОЕ ОБСЛУЖИВАНИЕ', 'Trebuchet24', 0, -1100, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    elseif ent.DrawScreen then
        ent:DrawScreen(-250, -1300)
    end

    cam.End3D2D()
end

local statisticdata = {
    [1] = 0,
    [2] = 0
}

local last = 0
local green = Color(0, 140, 0)
local red = Color(140, 0, 0)
local gray = Color(68, 68, 68)

function ENT:UseMenu()
    local l = last
    local data = {}
    local frame = vgui.Create('DFrame')
    frame:SetSize(500, 150)
    frame:Center()
    frame:MakePopup()
    frame:SetTitle('Статистика и настройки казино')

    function frame.OnClose(s)
        if l ~= last then
            net.Start('CasinoSystem.Menu')
            net.WriteUInt(l, 32)
            net.SendToServer()
            last = l
        end

        net.Start('WayCasino.OpenMenu')
        net.WriteTable(data)
        net.SendToServer()
    end

    local p = vgui.Create('DNumSlider', frame)
    p:Dock(TOP)
    p:SetText('Цена прокрутки')
    p:SetMinMax(1000, 10000000)
    p:SetDecimals(0)
    p:SetValue(self:GetPrice())

    function p:OnValueChanged(v)
        data['Price'] = v
    end

    local limit = vgui.Create('DNumSlider', frame)
    limit:Dock(BOTTOM)
    limit:SetTall(30)
    limit:SetMinMax(0, LocalPlayer():GetNetVar('money'))
    -- limit:SetMinMax(0, LocalPlayer():getDarkRPVar('money'))
    limit:SetValue(last)
    limit:SetDecimals(0)
    limit.Label:SetWrap(true)
    limit:SetText('Метка, ниже которой ваш баланс не опустится (общая для всех автоматов)')

    function limit:OnValueChanged(val)
        l = val
    end

    local pan = vgui.Create('Panel', frame)
    pan:Dock(FILL)
    local lose = vgui.Create('DPanel', frame)
    lose:Dock(LEFT)
    lose:SetWide(166)

    function lose:Paint(w, h)
        draw.RoundedBoxEx(5, 0, 0, w, h, red, true, false, true)
        draw.SimpleText('Потрачено:', 'Trebuchet18', w / 2, h / 2 - 7, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(statisticdata[2], 'Trebuchet18', w / 2, h / 2 + 7, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    local win = vgui.Create('DPanel', frame)
    win:Dock(RIGHT)
    win:SetWide(166)

    function win:Paint(w, h)
        draw.RoundedBoxEx(5, 0, 0, w, h, green, false, true, false, true)
        draw.SimpleText('Получено:', 'Trebuchet18', w / 2, h / 2 - 7, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(statisticdata[1], 'Trebuchet18', w / 2, h / 2 + 7, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end

    local total = vgui.Create('DPanel', frame)
    total:Dock(FILL)

    function total:Paint(w, h)
        draw.RoundedBox(0, 0, 0, w, h, gray)
        draw.SimpleText('Итого:', 'Trebuchet18', w / 2, h / 2 - 7, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
        draw.SimpleText(statisticdata[1] - statisticdata[2], 'Trebuchet18', w / 2, h / 2 + 7, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)
    end
end

--
net.Receive('WayCasino.OpenMenu', function()
    local e = net.ReadEntity()

    if e.UseMenu then
        e:UseMenu()
    end
end)

net.Receive('CasinoSystem.SendInfo', function()
    local w = net.ReadBool()
    local p = net.ReadUInt(27)
    statisticdata[w and 1 or 2] = statisticdata[w and 1 or 2] + p
end)

hook.Add('teamChanged', 'CasinoReset', function(b, a)
    if b == TEAM_BARMEN then
        statisticdata = {
            [1] = 0,
            [2] = 0
        }
    end
end)
--addons/module_slotmachine/lua/entities/slot_fifty_fifty/shared.lua:
ENT.Type = "anim"
ENT.Base = "slot_base"
ENT.PrintName = "50 на 50"
ENT.Spawnable = true
ENT.Category = "WaySlots"

function ENT:SetupDataTables()
    self.BaseClass.SetupDataTables(self)
    self:NetworkVar('Int', 0, 'Seed1')
    self:NetworkVar('Int', 1, 'Seed2')
end
--addons/module_slotmachine/lua/entities/slot_slots/cl_init.lua:
include('shared.lua')

function ENT:Initialize()
    self.Seed1 = 0
    self.Seed2 = 0
    self.Seed3 = 0
end

local back = Material('slot_slots.png')

function ENT:DrawScreen(x, y)
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(back)
    surface.DrawTexturedRect(x, y + 2, 500, 380)
    draw.SimpleText(string.Comma(self:GetPrice(), '.') .. '$', 'Trebuchet24', 11, -950, color_white, TEXT_ALIGN_CENTER, TEXT_ALIGN_BOTTOM)
    self.Seed1 = Lerp(.05, self.Seed1, self:GetSeed1())
    self.Seed2 = Lerp(.05, self.Seed2, self:GetSeed2())
    self.Seed3 = Lerp(.05, self.Seed3, self:GetSeed3())
    surface.SetDrawColor(255, 255, 255)
    surface.SetMaterial(self.Seeds[math.Round(self.Seed1)])
    surface.DrawTexturedRect(-102.5, y + 186, 75, 75)
    surface.SetMaterial(self.Seeds[math.Round(self.Seed2)])
    surface.DrawTexturedRect(-25, y + 186, 75, 75)
    surface.SetMaterial(self.Seeds[math.Round(self.Seed3)])
    surface.DrawTexturedRect(52.5, y + 186, 75, 75)
end
--gamemodes/darkrp/entities/entities/spawned_ammo/shared.lua:
ENT.Type = "anim"
ENT.Base = "spawned_weapon"
ENT.PrintName = "Spawned Ammo"
ENT.Author = "FPtje"
ENT.Spawnable = false
ENT.IsSpawnedAmmo = true

function ENT:SetupDataTables()
    self.BaseClass.SetupDataTables(self)
end

--gamemodes/darkrp/entities/entities/spawned_food/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Spawned Food"
ENT.Author = "Rickster"
ENT.Spawnable = false
ENT.IsSpawnedFood = true

function ENT:SetupDataTables()
    self:NetworkVar("Entity", 1, "owning_ent")
end

--gamemodes/darkrp/entities/entities/spawned_money/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "Spawned Money"
ENT.Author = "FPtje"
ENT.Spawnable = false
ENT.IsSpawnedMoney = true

function ENT:SetupDataTables()
    self:NetworkVar("Int",0,"amount")
end
--gamemodes/darkrp/entities/entities/spawned_shipment/cl_init.lua:
include("shared.lua")

local matBallGlow = Material("models/props_combine/tpballglow")
function ENT:Draw()
    self.height = self.height or 0
    self.colr = self.colr or 1
    self.colg = self.colg or 0
    self.StartTime = self.StartTime or CurTime()

    if GAMEMODE.Config.shipmentspawntime > 0 and self.height < self:OBBMaxs().z then
        self:drawSpawning()
    else
        self:DrawModel()
    end

    self:drawFloatingGun()
    self:drawInfo()
end

net.Receive("DarkRP_shipmentSpawn", function()
    local ent = net.ReadEntity()
    if not IsValid(ent) or not ent.IsSpawnedShipment then return end

    ent.height = 0
    ent.StartTime = CurTime()
end)

function ENT:drawSpawning()
    render.MaterialOverride(matBallGlow)

    render.SetColorModulation(self.colr, self.colg, 0)

    self:DrawModel()

    render.MaterialOverride()
    self.colr = 1 - ((CurTime() - self.StartTime) / GAMEMODE.Config.shipmentspawntime)
    self.colg = (CurTime() - self.StartTime) / GAMEMODE.Config.shipmentspawntime

    render.SetColorModulation(1, 1, 1)

    render.MaterialOverride()

    local normal = - self:GetAngles():Up()
    local pos = self:LocalToWorld(Vector(0, 0, self:OBBMins().z + self.height))
    local distance = normal:Dot(pos)
    self.height = self:OBBMaxs().z * ((CurTime() - self.StartTime) / GAMEMODE.Config.shipmentspawntime)
    render.EnableClipping(true)
    render.PushCustomClipPlane(normal, distance)

    self:DrawModel()

    render.PopCustomClipPlane()
end

function ENT:drawFloatingGun()
    local contents = CustomShipments[self:Getcontents() or ""]
    if not contents or not IsValid(self:GetgunModel()) then return end
    self:GetgunModel():SetNoDraw(true)

    local pos = self:GetPos()
    local ang = self:GetAngles()

    -- Position the gun
    local gunPos = self:GetAngles():Up() * 40 + ang:Up() * (math.sin(CurTime() * 3) * 8)
    self:GetgunModel():SetPos(pos + gunPos)


    -- Make it dance
    ang:RotateAroundAxis(ang:Up(), (CurTime() * 180) % 360)
    self:GetgunModel():SetAngles(ang)

    -- Draw the model
    if self:Getgunspawn() < CurTime() - 2 then
        self:GetgunModel():DrawModel()
        return
    elseif self:Getgunspawn() < CurTime() then -- Not when a gun just spawned
        return
    end

    -- Draw the spawning effect
    local delta = self:Getgunspawn() - CurTime()
    local min, max = self:GetgunModel():OBBMins(), self:GetgunModel():OBBMaxs()
    min, max = self:GetgunModel():LocalToWorld(min), self:GetgunModel():LocalToWorld(max)

    -- Draw the ghosted weapon
    render.MaterialOverride(matBallGlow)
    render.SetColorModulation(1 - delta, delta, 0) -- From red to green
    self:GetgunModel():DrawModel()
    render.MaterialOverride()
    render.SetColorModulation(1, 1, 1)

    -- Draw the cut-off weapon
    render.EnableClipping(true)
    -- The clipping plane only draws objects that face the plane
    local normal = -self:GetgunModel():GetAngles():Forward()
    local cutPosition = LerpVector(delta, max, min) -- Where it cuts
    local cutDistance = normal:Dot(cutPosition) -- Project the vector onto the normal to get the shortest distance between the plane and origin

    -- Activate the plane
    render.PushCustomClipPlane(normal, cutDistance);
    -- Draw the partial model
    self:GetgunModel():DrawModel()
    -- Remove the plane
    render.PopCustomClipPlane()

    render.EnableClipping(false)
end

function ENT:drawInfo()
    local Pos = self:GetPos()
    local Ang = self:GetAngles()

    local content = self:Getcontents() or ""
    local contents = CustomShipments[content]
    if not contents then return end
    contents = contents.name

    surface.SetFont("HUDNumber5")
    local text = DarkRP.getPhrase("contents")
    local TextWidth = surface.GetTextSize(text)
    local TextWidth2 = surface.GetTextSize(contents)

    cam.Start3D2D(Pos + Ang:Up() * 25, Ang, 0.2)
        draw.WordBox(2, -TextWidth * 0.5 + 5, -30, text, "HUDNumber5", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
        draw.WordBox(2, -TextWidth2 * 0.5 + 5, 18, contents, "HUDNumber5", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
    cam.End3D2D()

    Ang:RotateAroundAxis(Ang:Forward(), 90)

    text = DarkRP.getPhrase("amount")
    TextWidth = surface.GetTextSize(text)
    TextWidth2 = surface.GetTextSize(self:Getcount())

    cam.Start3D2D(Pos + Ang:Up() * 17, Ang, 0.14)
        draw.WordBox(2, -TextWidth * 0.5 + 5, -150, text, "HUDNumber5", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
        draw.WordBox(2, -TextWidth2 * 0.5 + 0, -102, self:Getcount(), "HUDNumber5", Color(140, 0, 0, 100), Color(255, 255, 255, 255))
    cam.End3D2D()
end

--[[---------------------------------------------------------------------------
Create a shipment from a spawned_weapon
---------------------------------------------------------------------------]]
properties.Add("splitShipment",
{
    MenuLabel   =   "Split this shipment",
    Order       =   2003,
    MenuIcon    =   "icon16/arrow_divide.png",

    Filter      =   function(self, ent, ply)
                        if not IsValid(ent) then return false end
                        return ent.IsSpawnedShipment
                    end,

    Action      =   function(self, ent)
                        if not IsValid(ent) then return end
                        RunConsoleCommand("darkrp", "splitshipment", ent:EntIndex())
                    end
})

--addons/module_tech/lua/entities/technician_base/shared.lua:
AddCSLuaFile()
ENT.Type = 'anim'
ENT.Base = "base_anim"

ENT.Name = "Controlbox"
ENT.PrintName = "Controlbox"
ENT.Author = "OverlordAkise"
ENT.Category = "Запрещено"
ENT.Purpose = "Press E to repair!"
ENT.Instructions = "N/A"
ENT.Model = "models/props/de_nuke/NuclearControlBox.mdl"

ENT.Freeze = false
ENT.Spawnable = true
ENT.AdminSpawnable = true

function ENT:SetupDataTables()
    self:NetworkVar("Bool", 0, "Broken")
    self:NetworkVar("Bool", 1, "Bonus")
    if SERVER then
        self:SetBroken(false)
        self:SetBonus(false)
    end
end

--addons/tool_textscreen/lua/entities/wrp_text/shared.lua:
ENT.Type = "anim"
ENT.Base = "base_anim"
ENT.PrintName = "TextScreen"
ENT.Author = "Owain Owjo"
ENT.Category = "Запрещено"
ENT.RenderGroup = RENDERGROUP_BOTH
ENT.Spawnable = false
ENT.AdminSpawnable = false
--addons/module_itemstore/lua/itemstore/config.lua:
-- The maximum allowable size for stacked items. Set to math.huge for infinite stacks.
-- SOME ITEMS DO NOT OBEY THIS CONFIG OPTION!! Ammo and money are exempt for obvious reasons.
itemstore.config.MaxStack = 16

-- Where to save player data. Values are none, text, mysqloo (recommended) and tmysql4 (deprecated)
itemstore.config.DataProvider = "mysqloo"

-- If true, saves the player's inventory every time it's changed.
-- DO NOT TURN THIS OFF IF YOU'RE RUNNING THE mysql.experimental DATA PROVIDER!!
itemstore.config.SaveOnWrite = false

-- The gamemode to enable support for. Valid values are darkrp and darkrp24.
itemstore.config.GamemodeProvider = "darkrp"

-- Prefix for chat commands
itemstore.config.ChatCommandPrefix = "/"

-- The jobs that have access to an inventory. If this is empty, all teams have access.
-- Admins will still have access to their inventory though.
-- Names must be exact.
-- example: itemstore.config.LimitToTeams = { TEAM_CITIZEN, TEAM_COP }
itemstore.config.LimitToJobs = {}

-- The interval at which the inventory saves all players automatically, in seconds.
itemstore.config.SaveInterval = 600

-- The language of the inventory.
-- There are two languages by default, en (English), fr (French), de (German) and ru (Russian)
itemstore.config.Language = "ru"

-- Enable quick inventory viewing by holding the context menu key, default C.
itemstore.config.ContextInventory = true

-- If context inventory is enabled, this defines where it appears on the player's screen.
-- Valid values are "top", "bottom", "left" and "right"
itemstore.config.ContextInventoryPosition = "bottom"

-- Allow the use of the /invholster command
itemstore.config.EnableInvholster = true

-- Force player to holster all of their ammo as well as their gun when they use /invholster, ala DarkRP.
itemstore.config.InvholsterTakesAmmo = false

-- Split ammo on spawned_weapons instead of giving all ammo at once when used
itemstore.config.SplitWeaponAmmo = false

-- Force player to retrieve their items from the bank before being able to use them.
itemstore.config.PickupsGotoBank = false

-- The distance that the player is able to "reach" when picking up items.
itemstore.config.PickupDistance = 100

-- The distance that items will drop at relative to the player
itemstore.config.DropDistance = 100

-- The key to use in combination with +use (E) to pick up items.
-- A list of keys for this option is here: http://wiki.garrysmod.com/page/Enums/IN
-- Set this to -1 to disable the key combo.
itemstore.config.PickupKey = IN_DUCK

-- Whether or not trading should be enabled. Set this to false to disable.
itemstore.config.TradingEnabled = true

-- How long in seconds the player needs to wait after a trade to trade again
itemstore.config.TradeCooldown = 30

-- How close in hammer units two players need to be to trade. 0 means infinite.
itemstore.config.TradeDistance = 200

-- Whether or not the player should drop their inventory on death.
itemstore.config.DeathLoot = false

-- How long in seconds the player's dropped inventory should exist for.
itemstore.config.DeathLootTimeout = 60 * 5

-- Makes boxes breakable if enough damage is inflicted
itemstore.config.BoxBreakable = false

-- Amount of health for boxes to have
itemstore.config.BoxHealth = 100

-- Should users be able to pick up other users' entities
itemstore.config.IgnoreOwner = true

-- Fixes a duplication bug by detouring ENTITY:Remove()..
-- WARNING: Turning this off will open an exploit that allows players to dupe items!
-- Only turn it off if it is somehow conflicting.
itemstore.config.AntiDupe = true

-- Migrates text data from 2.0 to the current format.
-- This is experimental and may not function correctly. Please be careful if you decide to use this.
-- !!IMPORTANT!!
-- PLEASE make backups of your data -- this process is DESTRUCTIVE and will delete old data files 
-- and overwrite any inventory data that players currently have.
itemstore.config.MigrateOldData = false

-- Inventory sizes according to rank.
-- The format for this table is:
-- <rank> = { <width>, <height>, <pages> }
-- If a player's rank is not contained within this table, it defaults to default.
-- DO NOT REMOVE DEFAULT! If you remove it, there will be errors!
itemstore.config.InventorySizes = {
	default = { 8, 2, 1 },
	Patron = { 10, 5, 1 },
}

-- Same as above, for banks. Same format. DON'T REMOVE DEFAULT!
itemstore.config.BankSizes = {
	default = { 8, 4, 2 },
	Patron = { 12, 4, 1 },
}


-- The skin to use. Preinstalled skins are "flat" and "classic".
itemstore.config.Skin = "flat"

-- The various colours of the VGUI in R, G, B, A 0-255 format.
-- Not available when using the flat skin
itemstore.config.Colours = {
	Slot = Color( 0, 0, 0, 150 ),
	HoveredSlot = Color( 255, 255, 255, 150 ),
	Title = Color( 255, 255, 255 ),

	TitleBackground = Color( 0, 0, 0, 200 ),
	Upper = Color( 100, 100, 100, 100 ),
	Lower = Color( 30, 30, 30, 150 ),
	InnerBorder = Color( 0, 0, 0, 0 ),
	OuterBorder = Color( 0, 0, 0, 200 )
}

-- The style of the item highlight. Options are "old", "border", "corner", subtle" and "full"
itemstore.config.HighlightStyle = "subtle"

-- Highlight colours for the various types of items. 
itemstore.config.HighlightColours = {
	Weapons = Color( 231, 76, 60 ),
	Ammo = Color( 241, 196, 15 ),
	Shipments = Color( 230, 126, 34 ),
	Factories = Color( 52, 152, 219 ), -- printers, gunlabs, microwaves, etc
	Consumables = Color( 26, 188, 156 ), -- drugs, food
	Money = Color( 46, 204, 113 ),
	Other = Color( 236, 240, 241 ), -- never delete this!
}

-- A table of disabled items. Set any value in this table to true to disallow picking up the item.
itemstore.config.DisabledItems = {
	drug = false,
	drug_lab = false,
	food = false,
	gunlab = false,
	microwave = false,
	money_printer = false,
	spawned_food = false,
	spawned_shipment = false,
	spawned_weapon = false,
	spawned_money = true,
	
	durgz_alcohol = false,
	durgz_aspirin = false,
	durgz_cigarette = false,
	durgz_cocaine = false,
	durgz_heroine = false,
	durgz_lsd = false,
	durgz_mushroom = false,
	durgz_pcp = false,
	durgz_weed = false,

	prop_physics = true,
}

-- Custom items. Defining these will allow server owners to make certain
-- entities pickupable... but may not work 100%. If this is the case, you will probably
-- need to code the item definition yourself.
-- Format for each entry is:
-- <entity class> = { "<name>", "<description>", <stackable (optional)> }
itemstore.config.CustomItems = {
	entity_rachia = { "Рация", "Позволяет поддерживать связь внутри определенной группы", true },
	item_healthkit = { "Большая Аптечка", "Быстро восстановит здоровье при серъезных травмах. Можно использовать ее чтобы вернуть к жизни человека без сознания", false },
	item_healthvial = { "Маленькая Аптечка", "Дешевая аптечка, поправит незначительные повреждения", true },
	durgz_meth = { "Метамфетамин", "Вызывает эйфорию и увеличивает скорость бега.", true },
	durgz_heroine = { "Героин", "Имеет обезболивающий эффект", true },
	durgz_weed = { "Марихуана", "Расслабляет, поднимает настроение и пополняет здоровье", true },
	durgz_lsd = { "LSD", "Вызывает галюцинации...", true },
	durgz_mushroom = { "Цианид", "Подавляет активность дыхательной системы, что приводит к смерти", true },
	durgz_water = { "Вода ( Анти-токсин )", "Секретная разработка ученых из WayZer's Lab, при попадании в организм моментально выводит все вредные вещества", true },
    durgz_aspirin = { "Новичок", "Убьет любого! Ну, почти...", true },
	durgz_cigarette = { "Сигареты", "Остаток слов и без эмоций...", true },
	durgz_alcohol = { "Пиво", "Пивка для рывка", true },
	durgz_fireammo = { "Зажигательная смесь", "Поджигает патроны, после выстрела", true}
}
--addons/module_itemstore/lua/itemstore/items.lua:
itemstore.items = {}
itemstore.items.Registered = {}
itemstore.items.Pickups = {}

local Item = {}
Item.Name = "Invalid Item"
--Item.Description = "Invalid Description"
Item.Model = "models/error.mdl"
--Item.Skin = 0
--Item.Color = nil
--Item.Material = nil
Item.HighlightColor = itemstore.config.HighlightColours.Other

Item.Stackable = false
Item.Amount = 1
Item.MaxStack = itemstore.config.MaxStack
Item.DropStack = false

Item.DontNetwork = {}

function Item:GetClass()
	return self.Class
end

function Item:IsValid()
	return true
end

function Item:Run( func_name, ... )
	local func = self[ func_name ]
	
	if type( func ) ~= "function" then return end

	return func( self, ... )
end

function Item:Load()
end

function Item:Initialize()
end

function Item:GetContainer()
	local con = self.Container
	if not con then return end

	local slot = self.Slot
	if not slot then return end

	if con:GetItem( slot ) == self then return self.Container end
end

function Item:GetSlot()
	local con = self.Container
	if not con then return end

	local slot = self.Slot
	if not slot then return end

	if con:GetItem( slot ) == self then return self.Slot end
end

function Item:Copy()
	return itemstore.Item( self:GetClass(), table.Copy( self.Data ) )
end

function Item:RegisterPickup( ent_class )
	itemstore.items.Pickups[ ent_class ] = self:GetClass()
end

function Item:GetData( key, default )
	return self.Data[ key ] == nil and default or self.Data[ key ]
end

function Item:SetData( key, value )
	self.Data[ key ] = value
end

function Item:CreateMutator( key, default )
	self[ "Set" .. key ] = function( self, value )
		self:SetData( key, value )
	end

	self[ "Get" .. key ] = function( self, default )
		return self:GetData( key, default or self[ key ] )
	end
end

Item:CreateMutator( "Name" )
Item:CreateMutator( "Description" )
Item:CreateMutator( "Model" )
Item:CreateMutator( "Material" )
Item:CreateMutator( "Skin" )
Item:CreateMutator( "Color" )
Item:CreateMutator( "MaxStack" )
Item:CreateMutator( "Amount" )

function Item:GetStaticName()
	return self.StaticName or self.Name
end

function Item:Pickup( pl, con, slot, ent )
end

function Item:Drop( pl, con, slot, ent )
end

function Item:Destroy( pl, con, slot )
end

function Item:TakeOne()
	self:SetAmount( self:GetAmount() - 1 )

	if self:GetAmount() <= 0 then
		return true
	end

	return false
end

function Item:CanPickup()
	return true
end

function Item:CanUseWith( item )
	return false
end

function Item:CanMerge( item )
	return self.Stackable and item.Stackable and self:GetClass() == item:GetClass()
		and ( self:GetAmount() + item:GetAmount() ) <= self:GetMaxStack()
end

function Item:Merge( item )
	self:SetAmount( self:GetAmount() + item:GetAmount() )
end

function Item:CanSplit( amount )
	return self.Stackable and self:GetAmount() > amount
end

function Item:Split( amount )
	self:SetAmount( self:GetAmount() - amount )

	local item = self:Copy()
	item:SetAmount( amount )

	return item
end

function Item:FormatAmount()
	return "x" .. self:GetAmount()
end

function Item:CreateEntity( pos )
	local ent = ents.Create( "itemstore_item" )
	ent:SetPos( pos )
	self:LoadData(ent)
	ent:Spawn()
	ent:Activate()

	return ent
end

function Item:SaveData( ent )
end

function Item:LoadData( ent )
	local amount = self.DropStack and self:GetAmount() or 1
	local item = table.Copy(self)
	item:SetAmount(amount)
	
	ent:SetItem(item)
end

function Item:WriteNetworkData()
	local data = {}
	
	for k, v in pairs( self.Data ) do
		if not self.DontNetwork[ k ] then data[ k ] = v end
	end

	net.WriteUInt( table.Count( data ), 8 )
	
	for k, v in pairs( data ) do
		net.WriteString( k )
		net.WriteType( v )
	end
end

function Item:ReadNetworkData()
	for i = 1, net.ReadUInt( 8 ) do
		self:SetData( net.ReadString(), net.ReadType() )
	end
end

function Item:PreRender( ent )
end

function Item:PostRender( ent )
end

itemstore.BaseItem = Item

function itemstore.Item( class_name, data )
	local class = itemstore.items.Registered[ class_name ]

	if class then
		local item = {
			Class = class_name,
			Data = data or {}
		}

		setmetatable( item, { __index = class } )

		item:Initialize()

		return item
	end
end

function itemstore.items.Get( class )
	return itemstore.items.Registered[ class ]
end

function itemstore.items.Exists( class )
	return itemstore.items.Registered[ class ] ~= nil
end

function itemstore.items.Register( tab )
	if SERVER then util.AddNetworkString( tab.Class ) end
	itemstore.items.Registered[ tab.Class ] = tab
end

function itemstore.items.Load()
	for _, filename in ipairs( file.Find( "itemstore/items/*.lua", "LUA" ) ) do
		local name = string.match( filename, "^(.+).lua$" )

		if name then
			ITEM = setmetatable( {}, { __index = Item } )
			ITEM.Class = name

			if SERVER then AddCSLuaFile( "itemstore/items/" .. filename ) end
			include( "itemstore/items/" .. filename )

			itemstore.items.Register( ITEM )

			ITEM = nil
		end
	end

	for k, v in pairs( itemstore.config.CustomItems ) do
		local ITEM = setmetatable( {}, { __index = Item } )

		ITEM.Class = k
		ITEM.Name = v[ 1 ]
		ITEM.Description = v[ 2 ]
		ITEM.Stackable = v[ 3 ]
		ITEM.Base = "base_auto"

		local ent = scripted_ents.Get(k)
		if ent and ent.ItemStoreUse then
			ITEM.Use = function(self, ...)
				ent:ItemStoreUse(self, ...)
			end
		end

		itemstore.items.Register( ITEM )
	end

	for _, item in pairs( itemstore.items.Registered ) do
		if item.Base then
			local base = itemstore.items.Get( item.Base )

			if base then
				setmetatable( item, { __index = base } )
			else
				ErrorNoHalt( "[ItemStore] " .. item.Class .. " tried to derive from non-existent base " .. item.Base )
			end
		end
	end

	for _, item in pairs( itemstore.items.Registered ) do
		item:Load()
	end
end
itemstore.items.Load()

--addons/module_itemstore/lua/itemstore/items/fake_license.lua:
ITEM.Name = 'Фальшивая лицензия'
ITEM.Description = 'Позволяет получить любую лицензию на одну жизнь'
ITEM.Model = 'models/props_lab/clipboard.mdl'
ITEM.Stackable = true
ITEM.MaxStack = 4
ITEM.DropStack = false

function ITEM:Use(ply)
    if ply:HasLicense() then
        DarkRP.notify(ply, 1, 4, 'У тебя уже есть лицензия')
        return false
    end

    wlib.requests.send(ply, {
        {
            type = 'textentry',
            name = 'Тип лицензии',
            default = 'Лицензия',
        },
    }, function(res)
        local term = res[1]
        if term and term ~= '' and utf8.len(term) > 3 then
            term = utf8.sub(term, 1, 60)
        else
            term = 'Лицензия'
        end

        local con = self:GetContainer()
        if self:TakeOne() then
            con:SetItem(self:GetSlot(), nil)
        end
        con:QueueSync()
        ply:QueueInventorySave()

        ply:GiveLicense(term, nil, true)
    
        DarkRP.notify(ply, 0, 5, 'Ты успешно использовал фальшивую лицензию')
    end)
end
--addons/module_itemstore/lua/itemstore/items/spawned_money.lua:
ITEM.Name = itemstore.Translate( "money_name" )
ITEM.Description = itemstore.Translate( "money_desc" )
ITEM.Model = "models/props/cs_assault/money.mdl"
ITEM.HighlightColor = itemstore.config.HighlightColours.Money
ITEM.Base = "base_darkrp"
ITEM.Stackable = true
ITEM.DropStack = true
ITEM.MaxStack = math.huge

function ITEM:FormatAmount()
	return GAMEMODE.Config.currency .. self:GetAmount()
end

function ITEM:Use(ply)
	itemstore.gamemodes.GiveMoney(ply, self:GetAmount())
	return true
end

function ITEM:CanDrop()
	return false
end

function ITEM:CanMove()
	return false
end

function ITEM:CanSplit()
	return false
end

function ITEM:CanPickup()
	return false
end

function ITEM:CanMerge()
	return false
end

function ITEM:SaveData( ent )
	self:SetAmount( ent:Getamount() )
end

function ITEM:LoadData( ent )
	ent:Setamount( self:GetAmount() )
end

--addons/module_logs/lua/plogs_hooks/bank.lua:
plogs.Register('Bank', false)

plogs.AddHook('Bank', 'wbank.robberyStarted', function(ply)
    local copy = {
        ['Ник'] = ply:LogsName(),
        ['SteamID'] = ply:LogsSteamID(),
    }

    plogs.PlayerLog(ply, 'Bank', ('%s начал ограбление банка'):format(ply:NameID()), copy)
end)

plogs.AddHook('Bank', 'wbank.robberyStopped', function(ply)
    plogs.Log('Bank', 'Ограбление банка завершено')
end)

plogs.AddHook('Bank', 'wbank.ventUsed', function(ply)
    local copy = {
        ['Ник'] = ply:LogsName(),
        ['SteamID'] = ply:LogsSteamID(),
    }

    plogs.PlayerLog(ply, 'Bank', ('%s использовал вентиляцию'):format(ply:NameID()), copy)
end)

plogs.AddHook('Bank', 'wbank.gotBag', function(ply, amount)
    local copy = {
        ['Ник'] = ply:LogsName(),
        ['SteamID'] = ply:LogsSteamID(),
        ['Сумма'] = DarkRP.formatMoney(amount),
    }

    plogs.PlayerLog(ply, 'Bank', ('%s взял сумку с %s'):format(ply:NameID(), DarkRP.formatMoney(amount)), copy)
end)

plogs.AddHook('Bank', 'wbank.usedBag', function(ply, amount)
    local copy = {
        ['Ник'] = ply:LogsName(),
        ['SteamID'] = ply:LogsSteamID(),
        ['Сумма'] = DarkRP.formatMoney(amount),
    }

    plogs.PlayerLog(ply, 'Bank', ('%s отнес сумку с %s'):format(ply:NameID(), DarkRP.formatMoney(amount)), copy)
end)
--addons/module_logs/lua/plogs_hooks/chat.lua:
plogs.Register('Chat', false)

local hook_name = DarkRP and 'PostPlayerSay' or 'PlayerSay'

plogs.AddHook('Chat', hook_name, function(pl, text)
	if (text ~= '') then
		plogs.PlayerLog(pl, 'Chat', pl:NameID() .. ': ' .. string.Trim(text), {
			['Ник'] 	= pl:LogsName(),
			['SteamID']	= pl:LogsSteamID()
		})
	end
end)

local cmds = {
    ['me'] = true,
	['yell'] = true,
	['y'] = true,
	['w'] = true,
	['whisper'] = true,
	['/'] = true,
	['ooc'] = true,
	['g'] = true,
	['r'] = true,
	['radio'] = true,
}

hook.Add('onChatCommand', 'plogs.Chat', function (ply, cmd, arg)
    if not cmds[string.lower(cmd)] then return end

    plogs.PlayerLog(ply, 'Chat', ply:NameID()..': /'..cmd..' '..string.Trim(arg), {
        ['Ник'] 	= ply:LogsName(),
        ['SteamID']	= ply:LogsSteamID()
    })
end)
--addons/module_logs/lua/plogs_hooks/commands.lua:
plogs.Register('Commands', false)

if (SERVER) then
	concommand._Run = concommand._Run or concommand.Run
	function concommand.Run(pl, cmd, args, arg_str)
		if IsValid(pl) and pl:IsPlayer() and (cmd ~= nil) and (plogs.cfg.CommandBlacklist[cmd] ~= true) then
			plogs.PlayerLog(pl, 'Commands', pl:NameID() .. ' использовал команду "' .. cmd .. '" с аргументами ' .. (arg_str or '"'..table.concat(args, ' ')..'"'), {
				['Ник']	= pl:LogsName(),
				['SteamID']	= pl:LogsSteamID(),
			})
		end
		return concommand._Run(pl, cmd, args, arg_str)
	end
end
--addons/module_logs/lua/plogs_hooks/props.lua:
plogs.Register('Props', false, Color(50,175,255))

plogs.AddHook('Props', 'PlayerSpawnedProp', function(pl, mdl, ent)
	plogs.PlayerLog(pl, 'Props', pl:NameID() .. ' заспавнил ' .. mdl, {
		['Ник'] 	= pl:LogsName(),
		['SteamID']	= pl:LogsSteamID()
	}, {
		{
			name = 'Игрок',
			pos = pl:GetPos(),
			ang = pl:GetAngles(),
		},
		{
			name = 'Проп',
			pos = ent:GetPos(),
			ang = ent:GetAngles(),
			model = mdl,
		}
	})
end)

plogs.Register('Props Pickup', false)

FAdmin = FAdmin or {
    StartHooks = {}
}

FAdmin.StartHooks['PhysgunPropLog'] = function()
	FAdmin.Messages.RegisterNotification({
        name = "physgun_prop",
        hasTarget = true,
        message = {"instigator", " дотронулся до твоего пропа Physics Gun'ом"},
        receivers = "targets",
        logging = false,
    })
end

plogs.AddHook('Props Pickup', 'OnPhysgunPickup', function(pl, ent)
	local owner = ent:CPPIGetOwner()
	if not IsValid(owner) or owner == pl then return end

	if owner.Buddies and owner.Buddies[pl] and owner.Buddies[pl]['Physgun'] then return end

	pl.fadmin_notifycd = pl.fadmin_notifycd or {}
	pl.fadmin_notifycd["physgun_prop"] = pl.fadmin_notifycd["physgun_prop"] or {}
	local cd = pl.fadmin_notifycd["physgun_prop"][owner]

	if cd and cd > CurTime() then return end

	FAdmin.Messages.FireNotification("physgun_prop", pl, {owner})
	pl.fadmin_notifycd["physgun_prop"][owner] = CurTime()+0.7

	local str = ('%s дотронулся до пропа %s (%s)'):format(pl:NameID(), owner:NameID(), tostring(ent))

	plogs.PlayerLog(pl, 'Props Pickup', str, {
		['Ник'] 	= pl:LogsName(),
		['SteamID']	= pl:LogsSteamID(),
		['Проп'] = tostring(ent),
	}, {
		{
			name = 'Игрок',
			pos = pl:GetPos(),
			ang = pl:GetAngles(),
		},
		{
			name = 'Проп',
			pos = ent:GetPos(),
			ang = ent:GetAngles(),
			model = ent:GetModel(),
		}
	})
end)
